{
    "start": 1758011745.4702008,
    "end": 1758011814.3872018,
    "start-formatted": "2025-09-16 17:35 KST",
    "end-formatted": "2025-09-16 17:36 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "**Refined Sweep Line for Non-Intersecting Voucher Pairs**\n\nOkay, so the challenge boils down to finding the cheapest pair of vacation vouchers that don't overlap and whose durations add up to `x`. The key is to avoid an O(N^2) brute-force approach.  My thinking here is that we need a clever way to efficiently check for the non-overlapping condition, `r_i < l_j` or `r_j < l_i`, alongside the duration constraint, `d_i + d_j = x`.\n\nI've considered sorting vouchers by their start (`l_i`) or end (`r_i`) times. Sorting by start helps with the `r_j < l_i` (one voucher ends before the other starts) condition, but not the reverse. So I settled on using a **sweep-line algorithm**.\n\nThe idea is this: I'll iterate through time (days), keeping track of vouchers that *have already ended* and their minimum costs by duration. As I sweep, for each voucher that *starts* on the current day, I look for a complementary voucher (one with duration `x - d_i`) in my 'ended vouchers' store. I can efficiently store, update, and query the 'ended vouchers' using an array, indexed by duration, `min_cost_for_duration[duration]`, initialized to infinity.\n\nHere's the refined implementation:\n\n1. **Initialization:**\n   - I create an array, `min_cost_for_duration`, to store the minimum cost for a given duration among those that have ended.  This is initialized to infinity.\n   - I also define a maximum day (`MAX_DAY`) based on the input constraints.\n\n2. **Event Queues:**\n   - I set up two event queues:  `vouchers_starting_on_day` and `vouchers_ending_on_day`, to store vouchers based on their start and end days.  For each input voucher, I'll add the start and end event into the corresponding queues.\n\n3. **Sweep Line:**\n   - I iterate from day 1 to `MAX_DAY`.\n   - **Start Processing:**\n     - For any voucher that *starts* on the current day, I calculate its `target_duration = x - current_voucher_duration`.\n     - If `target_duration` is a valid duration (positive and within the range), I check `min_cost_for_duration[target_duration]`.  If it's not infinity, I've found a potential non-overlapping pair!  I update my overall minimum cost `ans`.\n   - **End Processing:**\n     - For vouchers that *end* on the current day, I update `min_cost_for_duration[duration]`.\n\nBy sorting the events based on the start, and storing the ended ones in the array, I can keep track of what's *already available* to be paired with.\n\nThis approach should be O(N) in terms of processing, assuming durations have limited and fixed range.\n",
    "response": "The problem asks us to find two distinct vouchers `i` and `j` such that their total duration `(r_i - l_i + 1) + (r_j - l_j + 1)` is exactly `x`, they do not intersect (meaning `r_i < l_j` or `r_j < l_i`), and their total cost `cost_i + cost_j` is minimized. If no such pair exists, we should print -1.\n\nLet `d_k = r_k - l_k + 1` be the duration of voucher `k`. We are looking for `d_i + d_j = x`. This implies `d_j = x - d_i`.\n\nWe can solve this problem using a sweep-line algorithm. The key idea is to iterate through time (days) and maintain information about vouchers that have already ended.\n\nLet `MAX_COORD = 2 * 10^5` be the maximum possible day.\nWe will use an array `min_cost_for_duration` of size `MAX_COORD + 1`. `min_cost_for_duration[duration]` will store the minimum cost of a voucher that has that specific `duration` and has *already ended* by the current sweep day. This array is initialized with infinity.\n\nWe need to efficiently access vouchers based on their start and end days. We can pre-process the input vouchers into two lists:\n1. `vouchers_starting_on_day[day]`: A list of `(r, cost, duration)` for all vouchers that start on `day`.\n2. `vouchers_ending_on_day[day]`: A list of `(l, cost, duration)` for all vouchers that end on `day`.\n\nThe sweep-line algorithm proceeds as follows:\n1. Initialize `ans = infinity` and `min_cost_for_duration = [infinity] * (MAX_COORD + 1)`.\n2. Populate `vouchers_starting_on_day` and `vouchers_ending_on_day` arrays from the input.\n3. Iterate `day` from 1 to `MAX_COORD`:\n   a. **Process vouchers that start on `day`**: For each voucher `(r_i, cost_i, d_i)` in `vouchers_starting_on_day[day]`:\n      i. Calculate the `target_duration = x - d_i`.\n      ii. If `target_duration > 0` and `target_duration <= MAX_COORD`:\n          If `min_cost_for_duration[target_duration]` is not infinity, it means there's an already-ended voucher `j` with `d_j = target_duration` and cost `min_cost_for_duration[target_duration]`.\n          Since this voucher `j` has already ended by `day - 1` (when its cost was put into `min_cost_for_duration`), and voucher `i` starts on `day`, we have `r_j < l_i` (specifically, `r_j <= day - 1` and `l_i = day`). This satisfies the non-overlapping condition.\n          Update `ans = min(ans, cost_i + min_cost_for_duration[target_duration])`.\n   b. **Update `min_cost_for_duration` with vouchers that end on `day`**: For each voucher `(l_k, cost_k, d_k)` in `vouchers_ending_on_day[day]`:\n      i. Voucher `k` has just ended. It is now available to be paired with any future voucher `m` that starts after `day`.\n      ii. Update `min_cost_for_duration[d_k] = min(min_cost_for_duration[d_k], cost_k)`.\n\nAfter iterating through all days, if `ans` is still infinity, it means no valid pair was found, so print -1. Otherwise, print `ans`.\n\n**Why this covers all non-overlapping cases:**\nConsider any valid pair of non-overlapping vouchers `(V_a, V_b)`.\nWithout loss of generality, assume `V_a` ends before `V_b` starts, i.e., `r_a < l_b`.\nWhen the sweep-line reaches `day = l_b`:\n1. `V_b` will be processed in step 3a (vouchers starting on `day`).\n2. At this point, `min_cost_for_duration` contains costs of all vouchers that ended on or before `l_b - 1`. Since `r_a < l_b`, `V_a` ended by `r_a`, which is `l_b - 1` or earlier.\n3. Therefore, `cost_a` (or a smaller cost if an earlier voucher with `d_a` existed) would have been placed into `min_cost_for_duration[d_a]` when the sweep-line passed `r_a + 1`.\n4. So, when `V_b` is processed, it will query for `target_duration = x - d_b = d_a`, and `min_cost_for_duration[d_a]` will provide a valid cost (including `cost_a`). This pair will be considered for `ans`.\nSince the choice of `V_a` and `V_b` was arbitrary, this sweep-line correctly finds the minimum cost for any pair satisfying `r_a < l_b` or `r_b < l_a`.\n\n**Time Complexity:**\n* Initializing arrays: `O(MAX_COORD)`\n* Pre-processing vouchers: `O(N)` for iterating through vouchers, `O(1)` per voucher for list appends.\n* Sweep-line loop: `MAX_COORD` iterations.\n    * Inside the loop, processing `vouchers_starting_on_day[day]` and `vouchers_ending_on_day[day]` takes time proportional to the number of vouchers starting/ending on that day.\n    * Each voucher is processed exactly once when it starts and exactly once when it ends.\n* Total time: `O(N + MAX_COORD)`. Given `N, MAX_COORD <= 2 * 10^5`, this is efficient enough (`~4 * 10^5` operations).\n\n**Space Complexity:**\n* `vouchers_starting_on_day`, `vouchers_ending_on_day`: `O(N + MAX_COORD)`\n* `min_cost_for_duration`: `O(MAX_COORD)`\n* Total space: `O(N + MAX_COORD)`.\n\n```python\nimport sys\n\n# Constants\nMAX_COORD = 2 * 10**5\nINF = float('inf')\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n\n    # vouchers_starting_on_day[day] will store a list of (r, cost, duration) for vouchers starting on 'day'\n    vouchers_starting_on_day = [[] for _ in range(MAX_COORD + 2)]\n    # vouchers_ending_on_day[day] will store a list of (l, cost, duration) for vouchers ending on 'day'\n    vouchers_ending_on_day = [[] for _ in range(MAX_COORD + 2)]\n\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        duration = r - l + 1\n        vouchers_starting_on_day[l].append((r, cost, duration))\n        vouchers_ending_on_day[r].append((l, cost, duration))\n\n    # min_cost_for_duration[d] stores the minimum cost of a voucher with duration 'd'\n    # that has already ended by the current sweep day.\n    min_cost_for_duration = [INF] * (MAX_COORD + 1)\n    \n    ans = INF\n\n    # Sweep line from day 1 to MAX_COORD\n    for day in range(1, MAX_COORD + 1):\n        # Phase 1: Process vouchers that start on the current 'day'\n        # For these vouchers, we look for a complementary voucher that ended *before* 'day'.\n        for r_i, cost_i, d_i in vouchers_starting_on_day[day]:\n            target_duration = x - d_i\n            # Check if target_duration is valid (positive and within bounds)\n            if 0 < target_duration <= MAX_COORD:\n                if min_cost_for_duration[target_duration] != INF:\n                    ans = min(ans, cost_i + min_cost_for_duration[target_duration])\n\n        # Phase 2: Update min_cost_for_duration with vouchers that end on the current 'day'.\n        # These vouchers are now \"available\" to be paired with any voucher starting *after* 'day'.\n        for l_k, cost_k, d_k in vouchers_ending_on_day[day]:\n            min_cost_for_duration[d_k] = min(min_cost_for_duration[d_k], cost_k)\n\n    if ans == INF:\n        sys.stdout.write(\"-1\\n\")\n    else:\n        sys.stdout.write(str(ans) + \"\\n\")\n\nif __name__ == '__main__':\n    solve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\n# Constants\nMAX_COORD = 2 * 10**5\nINF = float('inf')\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n\n    # vouchers_starting_on_day[day] will store a list of (r, cost, duration) for vouchers starting on 'day'\n    vouchers_starting_on_day = [[] for _ in range(MAX_COORD + 2)]\n    # vouchers_ending_on_day[day] will store a list of (l, cost, duration) for vouchers ending on 'day'\n    vouchers_ending_on_day = [[] for _ in range(MAX_COORD + 2)]\n\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        duration = r - l + 1\n        vouchers_starting_on_day[l].append((r, cost, duration))\n        vouchers_ending_on_day[r].append((l, cost, duration))\n\n    # min_cost_for_duration[d] stores the minimum cost of a voucher with duration 'd'\n    # that has already ended by the current sweep day.\n    min_cost_for_duration = [INF] * (MAX_COORD + 1)\n    \n    ans = INF\n\n    # Sweep line from day 1 to MAX_COORD\n    for day in range(1, MAX_COORD + 1):\n        # Phase 1: Process vouchers that start on the current 'day'\n        # For these vouchers, we look for a complementary voucher that ended *before* 'day'.\n        for r_i, cost_i, d_i in vouchers_starting_on_day[day]:\n            target_duration = x - d_i\n            # Check if target_duration is valid (positive and within bounds)\n            if 0 < target_duration <= MAX_COORD:\n                if min_cost_for_duration[target_duration] != INF:\n                    ans = min(ans, cost_i + min_cost_for_duration[target_duration])\n\n        # Phase 2: Update min_cost_for_duration with vouchers that end on the current 'day'.\n        # These vouchers are now \"available\" to be paired with any voucher starting *after* 'day'.\n        for l_k, cost_k, d_k in vouchers_ending_on_day[day]:\n            min_cost_for_duration[d_k] = min(min_cost_for_duration[d_k], cost_k)\n\n    if ans == INF:\n        sys.stdout.write(\"-1\\n\")\n    else:\n        sys.stdout.write(str(ans) + \"\\n\")\n\nif __name__ == '__main__':\n    solve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 799,
        "completion_token_count": 2130,
        "thoughts_token_count": 6393
    }
}