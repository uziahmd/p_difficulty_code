{
    "start": 1758011747.019641,
    "end": 1758011818.9888837,
    "start-formatted": "2025-09-16 17:35 KST",
    "end-formatted": "2025-09-16 17:36 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "**The Algorithm: A Dynamic Sweep-Line Approach to Minimize Voucher Costs**\n\nOkay, so Leha needs to choose two non-overlapping vouchers whose combined duration equals a given value `x`. The goal is to minimize the total cost of these vouchers.  A naive, brute-force approach (checking every pair of vouchers) is immediately ruled out due to its `O(N^2)` time complexity, which would be too slow. We need something more efficient, aiming for `O(N log N)` or, ideally, `O(N)`.\n\nThe crucial challenge lies in efficiently handling the \"non-intersection\" condition. This constraint introduces a dependency between the chosen vouchers, making direct enumeration cumbersome.  I initially considered sorting vouchers by start or end times, but a sweep-line algorithm seems more promising.  Let's keep track of the minimum cost for each duration encountered so far, ensuring the non-intersection rule is met.\n\nThe core idea is to process vouchers in chronological order. We'll iterate through each day, which serves as a sweep-line. During this iteration, we’ll update and query an array called `min_cost_for_len`. For a given duration, `min_cost_for_len` stores the *minimum* cost of a voucher with that duration whose end date is *before* the current day. This array is initialized with infinity.\n\nAs we move the sweep-line, we’ll update `min_cost_for_len` with vouchers that *end* on the previous day. This enables us to find the cheapest \"valid\" j-voucher for the *current* i-voucher. Then, when we encounter a voucher that *starts* on the current day, we’ll compute the \"needed\" duration for its paired voucher. If there’s a matching duration in our `min_cost_for_len` array (i.e., a valid voucher from the past), we compare the total cost (current voucher plus the best voucher from the past) with the current minimum. We repeat this for all vouchers and choose the best one.\n\nIn this fashion, the algorithm processes each voucher exactly once. The sweep-line technique ensures that the non-intersection conditions are satisfied: by the time we consider a starting voucher, we've looked at all *earlier* end vouchers, enabling easy handling of the `rj < li` constraint. The symmetric handling, which is built into processing each start date, also captures the other condition, `ri < lj`.\n\nThe time complexity is roughly `O(N + MAX_COORD)` where `MAX_COORD = 2 * 10^5`, making it efficient enough. The auxiliary memory (space complexity) for maintaining the lists and `min_cost_for_len` is also `O(N + MAX_COORD)`.\n",
    "response": "The problem asks us to find two distinct, non-overlapping vouchers `i` and `j` such that the sum of their durations `(ri - li + 1) + (rj - lj + 1)` is exactly `x`, and their total cost `costi + costj` is minimized. If no such pair exists, we should output -1.\n\nLet `MAX_COORD` be the maximum possible value for `li` or `ri`, which is `2 * 10^5`.\n\nWe can solve this problem using a sweep-line algorithm. The idea is to iterate through each day from `1` to `MAX_COORD`. As we sweep through the days, we maintain information about vouchers that have already ended, allowing us to efficiently find a suitable second voucher for any voucher starting on the current day.\n\nHere's the detailed approach:\n\n1.  **Data Structures:**\n    *   `vouchers_by_start_day`: A list of lists, where `vouchers_by_start_day[d]` stores all vouchers that start on day `d`. Each voucher is stored as a tuple `(r, duration, cost)`.\n    *   `vouchers_by_end_day`: A list of lists, where `vouchers_by_end_day[d]` stores all vouchers that end on day `d`. Each voucher is stored as a tuple `(duration, cost)`.\n    *   `min_cost_for_len`: An array of size `MAX_COORD + 1`, initialized with `float('inf')`. `min_cost_for_len[d]` will store the minimum cost of a voucher with duration `d` that has *already ended* by the current sweep-line day.\n    *   `min_total_cost`: A variable initialized to `float('inf')` to store the overall minimum total cost found.\n\n2.  **Preprocessing:**\n    *   Read `n` and `x`.\n    *   For each voucher `(li, ri, costi)`:\n        *   Calculate its duration: `duration = ri - li + 1`.\n        *   Add `(ri, duration, costi)` to `vouchers_by_start_day[li]`.\n        *   Add `(duration, costi)` to `vouchers_by_end_day[ri]`.\n\n3.  **Sweep-Line Algorithm:**\n    *   Iterate `day` from `1` to `MAX_COORD`.\n    *   **Step 1: Update `min_cost_for_len` (Vouchers ending before `day`)**\n        *   For each voucher `(duration_j, cost_j)` in `vouchers_by_end_day[day - 1]`:\n            *   Update `min_cost_for_len[duration_j] = min(min_cost_for_len[duration_j], cost_j)`.\n        *   This step makes vouchers that ended on `day - 1` (or earlier, due to previous iterations) available for consideration. These vouchers satisfy the `rj < li` condition for any voucher `i` starting on or after `day`.\n\n    *   **Step 2: Process vouchers starting on `day` (Find pairs)**\n        *   For each voucher `i = (ri, duration_i, cost_i)` in `vouchers_by_start_day[day]`:\n            *   Calculate the `needed_duration_j = x - duration_i`.\n            *   We are looking for a voucher `j` with `needed_duration_j` such that `rj < li` (where `li` is the current `day`).\n            *   Check if `needed_duration_j` is a valid duration (i.e., `1 <= needed_duration_j <= MAX_COORD`).\n            *   If it is valid and `min_cost_for_len[needed_duration_j]` is not `float('inf')`:\n                *   This means there's at least one voucher `j` with the `needed_duration_j` that ended before the current `day` (i.e., `rj < day = li`).\n                *   Update `min_total_cost = min(min_total_cost, cost_i + min_cost_for_len[needed_duration_j])`.\n\n4.  **Result:**\n    *   After the sweep-line finishes, if `min_total_cost` is still `float('inf')`, it means no valid pair was found, so print `-1`.\n    *   Otherwise, print `min_total_cost`.\n\n**Why this works for both non-overlapping conditions:**\nThe non-overlapping condition is `ri < lj` or `rj < li`.\nLet's say we have two vouchers `A` and `B` that form a valid pair.\n*   **Case 1: `r_A < l_B` (A ends before B starts)**\n    When the sweep-line reaches `day = l_B`, voucher `A` would have already ended (since `r_A < l_B`). Thus, `cost_A` would have been used to update `min_cost_for_len[duration_A]` in a previous `day-1` step. When `B` is processed at `day = l_B`, it will look for `needed_duration = x - duration_B`, and `min_cost_for_len[duration_A]` will contain `cost_A` (or a smaller cost if another voucher with `duration_A` ended even earlier and was cheaper). So, this pair will be found.\n*   **Case 2: `r_B < l_A` (B ends before A starts)**\n    This is symmetric to Case 1. When the sweep-line reaches `day = l_A`, voucher `B` would have already ended. `cost_B` would be in `min_cost_for_len[duration_B]`. When `A` is processed at `day = l_A`, it will find `B`.\n\nTherefore, the sweep-line correctly identifies all valid non-overlapping pairs.\n\n**Complexity Analysis:**\n*   **Time Complexity:**\n    *   Populating `vouchers_by_start_day` and `vouchers_by_end_day`: `O(N)`.\n    *   Sweep-line loop: `MAX_COORD` iterations.\n        *   Inside the loop, iterating through `vouchers_by_end_day[day - 1]` (Step 1): Each voucher is processed once across all `day` values. Total `O(N)`.\n        *   Inside the loop, iterating through `vouchers_by_start_day[day]` (Step 2): Each voucher is processed once across all `day` values. Total `O(N)`.\n    *   Total time complexity: `O(N + MAX_COORD)`. Given `N, MAX_COORD <= 2 * 10^5`, this is efficient enough.\n\n*   **Space Complexity:**\n    *   `vouchers_by_start_day`: `O(N + MAX_COORD)`\n    *   `vouchers_by_end_day`: `O(N + MAX_COORD)`\n    *   `min_cost_for_len`: `O(MAX_COORD)`\n    *   Total space complexity: `O(N + MAX_COORD)`. This is also within typical memory limits.\n\n```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n\n    MAX_COORD = 2 * 10**5\n\n    # vouchers_by_start_day[l] stores a list of (r, duration, cost) for vouchers starting on day l\n    vouchers_by_start_day = [[] for _ in range(MAX_COORD + 1)]\n    # vouchers_by_end_day[r] stores a list of (duration, cost) for vouchers ending on day r\n    vouchers_by_end_day = [[] for _ in range(MAX_COORD + 1)]\n\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        duration = r - l + 1\n        vouchers_by_start_day[l].append((r, duration, cost))\n        vouchers_by_end_day[r].append((duration, cost))\n\n    # min_cost_for_len[d] stores the minimum cost of a voucher with duration d\n    # that has already ended by the current sweep-line day.\n    min_cost_for_len = [float('inf')] * (MAX_COORD + 1)\n    min_total_cost = float('inf')\n\n    # Sweep-line from day 1 to MAX_COORD\n    for day in range(1, MAX_COORD + 1):\n        # Step 1: Update min_cost_for_len with vouchers that ended on (day - 1)\n        # These vouchers are now available to be paired with vouchers starting on 'day' or later.\n        if day - 1 >= 1: # Ensure day-1 is a valid index for vouchers_by_end_day\n            for duration_j, cost_j in vouchers_by_end_day[day - 1]:\n                min_cost_for_len[duration_j] = min(min_cost_for_len[duration_j], cost_j)\n\n        # Step 2: Process vouchers that start on the current 'day'\n        for r_i, duration_i, cost_i in vouchers_by_start_day[day]:\n            needed_duration_j = x - duration_i\n\n            # Check if needed_duration_j is valid and exists\n            if 1 <= needed_duration_j <= MAX_COORD:\n                if min_cost_for_len[needed_duration_j] != float('inf'):\n                    # We found a pair: voucher 'i' starting on 'day', and a voucher 'j'\n                    # that ended before 'day' with the required duration and minimum cost.\n                    min_total_cost = min(min_total_cost, cost_i + min_cost_for_len[needed_duration_j])\n\n    if min_total_cost == float('inf'):\n        print(-1)\n    else:\n        print(min_total_cost)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n\n    MAX_COORD = 2 * 10**5\n\n    # vouchers_by_start_day[l] stores a list of (r, duration, cost) for vouchers starting on day l\n    vouchers_by_start_day = [[] for _ in range(MAX_COORD + 1)]\n    # vouchers_by_end_day[r] stores a list of (duration, cost) for vouchers ending on day r\n    vouchers_by_end_day = [[] for _ in range(MAX_COORD + 1)]\n\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        duration = r - l + 1\n        vouchers_by_start_day[l].append((r, duration, cost))\n        vouchers_by_end_day[r].append((duration, cost))\n\n    # min_cost_for_len[d] stores the minimum cost of a voucher with duration d\n    # that has already ended by the current sweep-line day.\n    min_cost_for_len = [float('inf')] * (MAX_COORD + 1)\n    min_total_cost = float('inf')\n\n    # Sweep-line from day 1 to MAX_COORD\n    for day in range(1, MAX_COORD + 1):\n        # Step 1: Update min_cost_for_len with vouchers that ended on (day - 1)\n        # These vouchers are now available to be paired with vouchers starting on 'day' or later.\n        if day - 1 >= 1: # Ensure day-1 is a valid index for vouchers_by_end_day\n            for duration_j, cost_j in vouchers_by_end_day[day - 1]:\n                min_cost_for_len[duration_j] = min(min_cost_for_len[duration_j], cost_j)\n\n        # Step 2: Process vouchers that start on the current 'day'\n        for r_i, duration_i, cost_i in vouchers_by_start_day[day]:\n            needed_duration_j = x - duration_i\n\n            # Check if needed_duration_j is valid and exists\n            if 1 <= needed_duration_j <= MAX_COORD:\n                if min_cost_for_len[needed_duration_j] != float('inf'):\n                    # We found a pair: voucher 'i' starting on 'day', and a voucher 'j'\n                    # that ended before 'day' with the required duration and minimum cost.\n                    min_total_cost = min(min_total_cost, cost_i + min_cost_for_len[needed_duration_j])\n\n    if min_total_cost == float('inf'):\n        print(-1)\n    else:\n        print(min_total_cost)\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 789,
        "completion_token_count": 2334,
        "thoughts_token_count": 6912
    }
}