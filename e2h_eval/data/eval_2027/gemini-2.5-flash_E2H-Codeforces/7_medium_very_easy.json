{
    "start": 1758011823.472806,
    "end": 1758011945.6770375,
    "start-formatted": "2025-09-16 17:37 KST",
    "end-formatted": "2025-09-16 17:39 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "**Algorithm for Rudolf and Snowflakes (Hard Version)**\n\nAlright, so the task is to figure out if a given number `n` can represent the total vertices of a special type of graph called a \"snowflake.\"  My initial thought is to analyze the structure of the snowflake, understanding how its vertices are built up in layers, and then derive a formula. It's a competitive programming problem, so efficiency is key, and I immediately anticipate the need for optimizations and clever arithmetic.\n\nHere's the breakdown: A snowflake starts with one central vertex. Then, it branches out with `k` new vertices, where `k` must be greater than 1. This is the first layer. After the first layer, it has at least one further layer, and from each of those `k` vertices, we connect `k` new vertices. Let `d` represent the depth, which is the number of layers *after* the initial `k` vertices. The number of vertices at each layer forms a geometric series.\n\nMathematically, the total number of vertices `N` is given by the formula for a geometric series: `N = 1 + k + k^2 + ... + k^d`, which can be simplified to `N = (k^(d+1) - 1) / (k - 1)`. The constraints are that `k > 1`, and `d >= 1`. This leads to the requirement to find suitable `k` and `d` values for a given `n`. The goal is to determine if such `k` and `d` exist that fit `n`.\n\nNow for the approach: I start by considering the simplest case where `d=1`, resulting in the formula `n = 1 + k + k^2`. This is a quadratic equation that can be solved using the quadratic formula, and I determine if `4n - 3` is a perfect square to ensure `k` is a whole number greater than 1.\n\nFor the general case where `d > 1`, I analyze the possible values of `k`. Based on the formula and considering that k must be greater than 1, I observe that k is roughly the d-th root of n. Since `n` can be as large as `10^18`, I need a way to limit the possible values of `k`. After some analysis, I conclude that `d` must be less than 60 and that the maximum value for `k` decreases as `d` increases.\n\nI set up a loop iterating through possible values of `d` from 2 to 59. For each `d`, I use binary search to efficiently find a suitable `k`. This is my main approach. Binary search is crucial here. I start by setting a low bound of 2 and an upper bound of the d-th root of `n` (truncated if the value contains decimals) and iterate within that search space. The core of the binary search is to calculate the sum of the geometric series up to `k^d` and compare it to `n`. If the sum equals `n`, I have found a solution. If it's less than `n`, I raise the lower bound of the search range. If it is more than `n`, I reduce the upper bound of the range.\n\nThe most challenging part involves ensuring the calculations don't overflow, especially when dealing with exponentiation (mid^d) and the cumulative sum.  I introduce overflow checks in the binary search loop, ensuring calculations are performed in a controlled manner that prevents exceeding the maximum integer values. I stop calculations if an overflow is likely. I can use the properties of geometric series to further speed up the calculations.\n\nMy final algorithm consists of:\n1.  Checking for the `d=1` (quadratic) case.\n2.  Iterating through `d` from 2 to 59.\n3.  Employing binary search for `k` within a reduced range.\n4.  Implementing precise overflow checks within the loop.\n\nThis strategy combines formula derivation, algorithmic analysis, and careful attention to potential overflow errors to solve the \"Rudolf and Snowflakes (hard version)\" problem efficiently. It allows me to determine for a given number `n`, whether it is a snowflake number or not.\n",
    "response": "The problem asks us to determine if a given number of vertices `n` can form a \"snowflake\" graph. A snowflake is defined by a central vertex, connected to `k` new vertices (`k > 1`). Then, each vertex connected to only one other vertex is connected to `k` more new vertices. This last step must be done at least once.\n\nLet's analyze the number of vertices:\n1.  **Initial vertex:** 1 vertex.\n2.  **First layer:** The central vertex connects to `k` new vertices. Total vertices: `1 + k`.\n3.  **Second layer (first application of the branching step):** Each of the `k` vertices from the first layer is connected to `k` new vertices. This adds `k * k = k^2` vertices. Total vertices: `1 + k + k^2`. This is the smallest possible snowflake, as the branching step must be done at least once.\n4.  **Third layer (second application of the branching step):** Each of the `k^2` vertices from the second layer is connected to `k` new vertices. This adds `k^2 * k = k^3` vertices. Total vertices: `1 + k + k^2 + k^3`.\n\nIn general, if the branching step is applied `d` times (meaning there are `d+1` layers of vertices including the center, or `d` layers of branches), the total number of vertices `N` is given by the sum of a geometric series:\n`N = 1 + k + k^2 + ... + k^d`\n\nThis sum can be expressed as `N = (k^(d+1) - 1) / (k - 1)`.\n\nThe constraints are:\n*   `k > 1` (given in the problem).\n*   `d >= 1` (because the branching step must be done at least once).\n\nWe are given `n` (up to `10^18`) and need to find if there exist integers `k > 1` and `d >= 1` that satisfy `n = 1 + k + ... + k^d`.\n\nWe can break this down into two main cases based on `d`:\n\n**Case 1: `d = 1`**\nIf `d = 1`, the number of vertices is `n = 1 + k + k^2`.\nThis is a quadratic equation in `k`: `k^2 + k + (1 - n) = 0`.\nUsing the quadratic formula, `k = (-1 ± sqrt(1 - 4(1 - n))) / 2 = (-1 ± sqrt(4n - 3)) / 2`.\nFor `k` to be a valid integer greater than 1:\n1.  `4n - 3` must be a perfect square. Let `S = sqrt(4n - 3)`.\n2.  `S` must be an integer.\n3.  `k = (-1 + S) / 2` must be an integer. This implies `S` must be odd.\n4.  `k` must be greater than 1. This implies `(-1 + S) / 2 > 1`, so `-1 + S > 2`, which means `S > 3`.\n\nWe can check these conditions for `d=1` directly. If they are met, `n` is a snowflake number.\n\n**Case 2: `d >= 2`**\nFor `d >= 2`, we need to find `k > 1` such that `n = 1 + k + ... + k^d`.\nThe maximum possible value for `d`:\nIf `k=2` (the smallest possible `k`), `n = 1 + 2 + ... + 2^d = 2^(d+1) - 1`.\nSince `n <= 10^18`:\n`2^(d+1) - 1 <= 10^18`\n`2^(d+1) <= 10^18 + 1`\n`d+1 <= log2(10^18 + 1)`.\n`log2(10^18) approx 18 * log2(10) approx 18 * 3.3219 approx 59.79`.\nSo `d+1` can be at most `59`. This means `d` can be at most `58`. (Actually, `2^59 - 1` is less than `10^18`, `2^60 - 1` is also less than `10^18`, but `2^61 - 1` exceeds `10^18`. So `d` can go up to `59` when `k=2`).\nTherefore, `d` can range from `2` to `59`.\n\nFor each `d` in this range:\nThe function `f(k) = 1 + k + ... + k^d` is monotonically increasing for `k > 1`. We can use binary search to find `k`.\nThe lower bound for `k` is `2`.\nThe upper bound for `k`: Since `k^d < n`, `k < n^(1/d)`. For `n=10^18, d=2`, `k < 10^9`. For `n=10^18, d=59`, `k` is just `2`. A safe upper bound for binary search is `int(n**(1/d)) + 2`.\n\nInside the binary search for `k`:\nCalculate `current_sum = 1 + mid + mid^2 + ... + mid^d`.\nCare must be taken to prevent integer overflow when `mid` and `d` are large.\n`current_sum` could exceed `n` if `mid` is too large. `power_k` (which is `mid^i`) could also exceed `n`.\nWe can check for overflow before each addition and multiplication:\n*   Before `current_sum += power_k`: If `current_sum > n - power_k`, then `current_sum + power_k` would exceed `n`.\n*   Before `power_k *= mid`: If `power_k > n // mid`, then `power_k * mid` would exceed `n`.\n\nIf `current_sum == n`, we found a valid `k` for this `d`, so `n` is a snowflake number.\n\n**Algorithm Steps:**\n1.  Read `n`.\n2.  **Check `d=1`:**\n    a.  Calculate `discriminant = 4 * n - 3`.\n    b.  If `discriminant < 0`, `d=1` is not possible.\n    c.  Calculate integer square root `s = math.isqrt(discriminant)`.\n    d.  If `s * s == discriminant` (i.e., `discriminant` is a perfect square) AND `(s - 1) % 2 == 0` (i.e., `s` is odd) AND `(s - 1) // 2 > 1` (i.e., `k > 1`), then print \"YES\" and return.\n3.  **Check `d >= 2`:**\n    a.  Loop `d` from `2` to `59`.\n    b.  For each `d`, perform binary search for `k`:\n        i.   Initialize `low = 2`, `high = int(n**(1/d)) + 2`. Ensure `high >= low`.\n        ii.  While `low <= high`:\n            *   `mid = low + (high - low) // 2`.\n            *   Calculate `current_sum = 0`, `power_k = 1`.\n            *   Loop `i` from `0` to `d`:\n                *   Check `current_sum` overflow: If `current_sum > n - power_k`, set `current_sum = n + 1` (to mark it as too large) and break.\n                *   `current_sum += power_k`.\n                *   If `i < d` (more terms to add):\n                    *   Check `power_k` overflow: If `power_k > n // mid`, set `power_k = n + 1` and break.\n                    *   `power_k *= mid`.\n            *   If `current_sum == n`, print \"YES\" and return.\n            *   If `current_sum < n`, set `low = mid + 1`.\n            *   Else (`current_sum > n`), set `high = mid - 1`.\n4.  If no `k, d` pair is found after checking all cases, print \"NO\".\n\n**Example `n=13`:**\n1.  `d=1`: `discriminant = 4*13 - 3 = 49`. `s = math.isqrt(49) = 7`.\n    `7*7 == 49` (True). `(7-1)%2 == 0` (True, `6%2==0`). `(7-1)//2 = 3`. `3 > 1` (True).\n    All conditions met. Print \"YES\".\n\n**Example `n=15`:**\n1.  `d=1`: `discriminant = 4*15 - 3 = 57`. Not a perfect square.\n2.  `d=2`: `low=2, high=int(15**(1/2))+2 = 3+2=5`.\n    *   `mid=3`. `1+3+3^2 = 13 < 15`. `low=4`.\n    *   `mid=4`. `1+4+4^2 = 21 > 15`. `high=3`.\n    *   Loop ends. No `k` for `d=2`.\n3.  `d=3`: `low=2, high=int(15**(1/3))+2 = 2+2=4`.\n    *   `mid=3`. `1+3+3^2+3^3 = 40 > 15`. `high=2`.\n    *   `mid=2`. `1+2+2^2+2^3 = 15 == 15`. Found! Print \"YES\".\n\n```python\nimport math\n\ndef solve():\n    n = int(input())\n\n    # Case d = 1: n = 1 + k + k^2\n    # k^2 + k + (1 - n) = 0\n    # k = (-1 + sqrt(4n - 3)) / 2\n    \n    discriminant = 4 * n - 3\n    if discriminant >= 0:\n        s = math.isqrt(discriminant) # Integer square root\n        if s * s == discriminant:\n            # Check if k is an integer > 1\n            # k = (s - 1) / 2\n            if (s - 1) % 2 == 0: # s-1 must be even, so s must be odd\n                k_val = (s - 1) // 2\n                if k_val > 1:\n                    print(\"YES\")\n                    return\n\n    # Case d >= 2: n = 1 + k + k^2 + ... + k^d\n    # Max d is 59 for k=2 (2^60 - 1 is approx 1.15e18, fits within 10^18)\n    for d in range(2, 60): \n        # Binary search for k\n        # k must be > 1. Minimum k is 2.\n        # Upper bound for k: k^d < n, so k < n^(1/d).\n        # We use int(n**(1/d)) + 2 as a safe upper bound.\n        # For n=10^18, d=2, k_upper_bound approx 10^9.\n        # For n=10^18, d=59, k_upper_bound approx 2.\n        \n        low = 2\n        # Calculate high with a safety margin, ensuring it's at least low\n        # The (1/d) exponent can lead to floating point inaccuracies for very large n or d.\n        # However, for n up to 10^18 and d up to 59, Python's float precision is usually sufficient\n        # to get a close enough integer part. Adding 2 covers small errors.\n        high = int(n**(1/d)) + 2\n        high = max(high, low) # Ensure high is not less than low\n        \n        found_k = False\n        while low <= high:\n            mid = low + (high - low) // 2\n\n            # Calculate sum = 1 + mid + mid^2 + ... + mid^d\n            # Be careful with overflow: current_sum and power_k can exceed n.\n            current_sum = 0\n            power_k = 1 # k^0\n            \n            # Loop d+1 times for powers k^0 to k^d\n            for i in range(d + 1): \n                # Check for overflow when adding power_k to current_sum\n                # If current_sum + power_k would exceed n, then current_sum is already too large\n                if current_sum > n - power_k: \n                    current_sum = n + 1 # Mark as exceeding n\n                    break\n                \n                current_sum += power_k\n                \n                # Check for overflow before multiplying power_k by mid for the next term\n                # This check is only needed if more terms are to be added (i < d)\n                if i < d: \n                    # If power_k * mid would exceed n, then next power_k is too large\n                    # mid cannot be 0 as low starts at 2\n                    if power_k > n // mid: \n                        power_k = n + 1 # Mark as exceeding n\n                        break\n                    power_k *= mid\n            \n            if current_sum == n:\n                found_k = True\n                break\n            elif current_sum < n:\n                low = mid + 1\n            else: # current_sum > n\n                high = mid - 1\n        \n        if found_k:\n            print(\"YES\")\n            return\n\n    print(\"NO\")\n\n# Read the number of test cases\nt = int(input())\nfor _ in range(t):\n    solve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef solve():\n    n = int(input())\n\n    # Case d = 1: n = 1 + k + k^2\n    # k^2 + k + (1 - n) = 0\n    # k = (-1 + sqrt(4n - 3)) / 2\n    \n    discriminant = 4 * n - 3\n    if discriminant >= 0:\n        s = math.isqrt(discriminant) # Integer square root\n        if s * s == discriminant:\n            # Check if k is an integer > 1\n            # k = (s - 1) / 2\n            if (s - 1) % 2 == 0: # s-1 must be even, so s must be odd\n                k_val = (s - 1) // 2\n                if k_val > 1:\n                    print(\"YES\")\n                    return\n\n    # Case d >= 2: n = 1 + k + k^2 + ... + k^d\n    # Max d is 59 for k=2 (2^60 - 1 is approx 1.15e18, fits within 10^18)\n    for d in range(2, 60): \n        # Binary search for k\n        # k must be > 1. Minimum k is 2.\n        # Upper bound for k: k^d < n, so k < n^(1/d).\n        # We use int(n**(1/d)) + 2 as a safe upper bound.\n        # For n=10^18, d=2, k_upper_bound approx 10^9.\n        # For n=10^18, d=59, k_upper_bound approx 2.\n        \n        low = 2\n        # Calculate high with a safety margin, ensuring it's at least low\n        # The (1/d) exponent can lead to floating point inaccuracies for very large n or d.\n        # However, for n up to 10^18 and d up to 59, Python's float precision is usually sufficient\n        # to get a close enough integer part. Adding 2 covers small errors.\n        high = int(n**(1/d)) + 2\n        high = max(high, low) # Ensure high is not less than low\n        \n        found_k = False\n        while low <= high:\n            mid = low + (high - low) // 2\n\n            # Calculate sum = 1 + mid + mid^2 + ... + mid^d\n            # Be careful with overflow: current_sum and power_k can exceed n.\n            current_sum = 0\n            power_k = 1 # k^0\n            \n            # Loop d+1 times for powers k^0 to k^d\n            for i in range(d + 1): \n                # Check for overflow when adding power_k to current_sum\n                # If current_sum + power_k would exceed n, then current_sum is already too large\n                if current_sum > n - power_k: \n                    current_sum = n + 1 # Mark as exceeding n\n                    break\n                \n                current_sum += power_k\n                \n                # Check for overflow before multiplying power_k by mid for the next term\n                # This check is only needed if more terms are to be added (i < d)\n                if i < d: \n                    # If power_k * mid would exceed n, then next power_k is too large\n                    # mid cannot be 0 as low starts at 2\n                    if power_k > n // mid: \n                        power_k = n + 1 # Mark as exceeding n\n                        break\n                    power_k *= mid\n            \n            if current_sum == n:\n                found_k = True\n                break\n            elif current_sum < n:\n                low = mid + 1\n            else: # current_sum > n\n                high = mid - 1\n        \n        if found_k:\n            print(\"YES\")\n            return\n\n    print(\"NO\")\n\n# Read the number of test cases\nt = int(input())\nfor _ in range(t):\n    solve()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 569,
        "completion_token_count": 3315,
        "thoughts_token_count": 8193
    }
}