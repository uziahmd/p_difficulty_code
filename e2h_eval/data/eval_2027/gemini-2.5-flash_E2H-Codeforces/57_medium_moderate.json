{
    "start": 1758294739.7836404,
    "end": 1758294823.7807176,
    "start-formatted": "2025-09-20 00:12 KST",
    "end-formatted": "2025-09-20 00:13 KST",
    "gpu": 2,
    "pid": 57,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Olympiad\n\nA boy named Vasya has taken part in an Olympiad. His teacher knows that in total Vasya got at least x points for both tours of the Olympiad. The teacher has the results of the first and the second tour of the Olympiad but the problem is, the results have only points, no names. The teacher has to know Vasya's chances.Help Vasya's teacher, find two numbers — the best and the worst place Vasya could have won. Note that the total results' table sorts the participants by the sum of points for both tours (the first place has the participant who has got the most points). If two or more participants have got the same number of points, it's up to the jury to assign places to them according to their choice. It is guaranteed that each participant of the Olympiad participated in both tours of the Olympiad.\n\n## Input\nThe first line contains two space-separated integers n, x (1 ≤ n ≤ 105; 0 ≤ x ≤ 2·105) — the number of Olympiad participants and the minimum number of points Vasya earned.The second line contains n space-separated integers: a1, a2, ..., an (0 ≤ ai ≤ 105) — the participants' points in the first tour.The third line contains n space-separated integers: b1, b2, ..., bn (0 ≤ bi ≤ 105) — the participants' points in the second tour.The participants' points are given in the arbitrary order. It is guaranteed that Vasya was present in the Olympiad — there are two integers i, j (1 ≤ i, j ≤ n) such, that ai + bj ≥ x.\n\n## Output\nPrint two space-separated integers — the best and the worst place Vasya could have got on the Olympiad.\n\n## Example\n### Input\n['5 2\\n1 1 1 1 1\\n1 1 1 1 1', '6 7\\n4 3 5 6 4 4\\n8 6 0 4 3 4']\n\n### Output\n['1 5', '1 5']\n\n## Note\nIn the first text sample all 5 participants earn 2 points each in any case. Depending on the jury's decision, Vasya can get the first (the best) as well as the last (the worst) fifth place.In the second test sample in the best case scenario Vasya wins again: he can win 12 points and become the absolute winner if the total results' table looks like that — {4:8, 6:4, 3:6, 4:4, 4:3, 5:0}.In this table all participants are sorted by decreasing points and we can see how much a participant earned in the first and in the second tour.In the worst case scenario Vasya can get the fifth place if the table looks like that — {4:8, 4:6, 6:4, 5:4, 4:3, 3:0}, and he earned 4 and 3 points in the first and second tours, correspondingly.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "**Analyzing Vasya's Olympiad Ranks**\n\nOkay, so I've got this problem: figure out the best and worst possible ranks Vasya could achieve in this Olympiad. The input gives us scores from two rounds (`a` and `b`) for `n` participants, and a minimum score `x` that Vasya *must* have. The tricky part is that we don't know who got which score, just that everyone gets one from `a` and one from `b`, and that their sum is at least `x`.\n\n**Best Rank: Always Rank 1**\n\nAfter thinking through different scenarios, it's clear: Vasya's best possible rank is always 1. Here's why: we're told Vasya *is* in the competition, so there's at least *some* pair of scores that gets him at least `x`. To get the best rank, he grabs the *highest* possible scores from both rounds that still meet the `x` requirement. With no constraints, Vasya can always guarantee he's at the top. Since no one else can score higher with this set of scores, Vasya is guaranteed rank 1 if he maximizes his total score. \n\n**Worst Rank: Maximizing Those Above Him**\n\nFinding the worst rank is trickier. We want to minimize Vasya's score, but still hit that `x` mark, and then *maximize* the number of people who score at least as well as he does. \n\nHere's how I'm thinking about it:\n1.  **Minimize Vasya's Score:** Find the smallest possible score Vasya can get that's still at least `x`. I'm thinking of sorting the scores and using a strategy like a binary search. I will have to iterate on all scores to do that. The problem of how to assign scores remains.\n2.  **Maximize Rivals:** To make Vasya's rank terrible, I need as many other people as possible to have scores that are at least as good as his. The `count_ge(S)` function seems promising here. If I can figure out the smallest possible score Vasya gets, then I can see what is the largest number of possible participants that have that same score, or an even larger one.\n\nI need a way to efficiently calculate this `count_ge(S)` function. I'm imagining a process where I fix the `x` value for Vasya and see what it takes to produce the maximum number of participants with at least that score. I think the two-pointer approach I'm thinking about (one on the sorted `a` scores and one on the sorted `b` scores) is the way to do it. The worst possible rank would be: `1 + (number of strictly better scores) + (number of scores equal to Vasya)`. I am going to have to make a final analysis in order to reach my final answer.\n",
    "response": "The problem asks us to find the best and worst possible ranks Vasya could achieve in an Olympiad, given `n` scores for the first tour (`a`) and `n` scores for the second tour (`b`), and a minimum total score `x` that Vasya achieved. The scores in `a` and `b` are arbitrary and not linked to specific participants. Each participant takes one score from `a` and one from `b`, and each score is used exactly once. If participants have the same total points, the jury can decide their relative order.\n\n**1. Best Possible Rank for Vasya:**\n\nTo achieve the best possible rank, Vasya wants to maximize his score. The highest possible score any participant can achieve is `max(a) + max(b)`. Let `A_max = max(a)` and `B_max = max(b)`. If Vasya takes these two scores, his total score would be `A_max + B_max`.\n\nThe problem guarantees: \"It is guaranteed that Vasya was present in the Olympiad — there are two integers i, j (1 ≤ i, j ≤ n) such, that ai + bj ≥ x.\"\nThis means there exists at least one pair of scores `(a_i, b_j)` such that their sum is `S >= x`.\nSince `A_max + B_max` is the largest possible sum of any `a_k` and `b_l`, it must be that `A_max + B_max >= x` (otherwise, no sum would be `>= x`, contradicting the guarantee).\n\nTherefore, Vasya can claim the scores `A_max` and `B_max`. His total score would be `A_max + B_max`. No other participant can achieve a score higher than `A_max + B_max`. Thus, Vasya can be ranked 1st.\n**The best possible rank for Vasya is always 1.**\n\n**2. Worst Possible Rank for Vasya:**\n\nTo achieve the worst possible rank, we need to:\na. Minimize Vasya's total score `S_vasya`, subject to `S_vasya >= x`.\nb. Pair the remaining `n-1` scores from `a` and `n-1` scores from `b` for other participants such that as many of them as possible score `S_vasya` or more. If participants have the same score as Vasya, the jury can place them above Vasya. So, Vasya's worst rank will be `1 + (number of participants with score > S_vasya) + (number of participants with score = S_vasya, excluding Vasya)`. This is equivalent to counting all participants (including Vasya) who score `S_vasya` or more, assuming Vasya is placed last among ties.\n\nLet's define a function `count_ge(S)`: the maximum number of participants who can score `S` or more, given the lists `a` and `b`.\nTo calculate `count_ge(S)`:\n1. Sort `a` in ascending order.\n2. Sort `b` in ascending order.\n3. Use a two-pointer approach:\n   Initialize `count = 0`.\n   Initialize `ptr_a = 0` (points to the smallest score in `a`).\n   Initialize `ptr_b = n - 1` (points to the largest score in `b`).\n   While `ptr_a < n` and `ptr_b >= 0`:\n     If `a[ptr_a] + b[ptr_b] >= S`: We can form a pair `(a[ptr_a], b[ptr_b])` that sums to at least `S`. Increment `count`, move `ptr_a` forward (`ptr_a += 1`), and move `ptr_b` backward (`ptr_b -= 1`). This greedy strategy works because `a[ptr_a]` is the smallest available score in `a`, and `b[ptr_b]` is the largest available score in `b`. By pairing them, we use the \"most valuable\" `b` score to satisfy the \"least valuable\" `a` score. This leaves smaller `b` scores for potentially larger `a` scores, maximizing the chances for other pairs to also meet the `S` threshold.\n     Else (`a[ptr_a] + b[ptr_b] < S`): Even the largest remaining `b` score (`b[ptr_b]`) is not enough for `a[ptr_a]` to reach `S`. So, `a[ptr_a]` cannot be part of any pair that sums to `S` or more. Move `ptr_a` forward (`ptr_a += 1`).\n4. Return `count`.\n\nThe function `count_ge(S)` is monotonically non-increasing. We want to find `max_{S_vasya >= x} count_ge(S_vasya)`. Since `count_ge(S)` is non-increasing, this maximum will be achieved at the smallest possible `S_vasya` that is `>= x`.\nWhat is the smallest possible total score `S_vasya` Vasya could achieve such that `S_vasya >= x`?\nThis is not simply `min {a_i + b_j | a_i + b_j >= x}`. This is because all scores must be paired.\nWe need to find a permutation `P` of `b` such that one of the `a_k + P[k]` is Vasya's score, say `S_vasya`, and `S_vasya >= x`. To maximize `count_ge(S_vasya)`, we should choose `S_vasya` to be as small as possible but still `>= x`.\n\nLet's re-evaluate the worst rank strategy. We want to find a specific pairing of `a` and `b` scores, say `(a_i, P[i])` for each participant `i`, such that if Vasya is assigned `a_k + P[k]`, his rank is maximized.\nThe worst rank for Vasya is the maximum possible value of `count_ge(S_actual)` where `S_actual` is Vasya's score in some valid pairing, and `S_actual >= x`.\nThis means we need to find a valid pairing (a permutation `P`) and an index `k` (Vasya's index) such that `a_k + P[k] >= x`, and the number of participants `j` for whom `a_j + P[j] >= a_k + P[k]` is maximized.\n\nThis is equivalent to finding the smallest possible score `S_vasya` (that Vasya could actually obtain in *some* valid pairing) such that `S_vasya >= x`. Then, for this `S_vasya`, we calculate `count_ge(S_vasya)`.\nThe smallest score Vasya can possibly get while still satisfying `S_vasya >= x` can be found by iterating through all possible `a_i` Vasya could have. For each `a_i`, Vasya needs a `b_j` such that `b_j >= x - a_i`. To minimize `a_i + b_j`, he would pick the smallest such `b_j`.\nLet `a` be sorted ascending. For each `a_i`, find the smallest `b_j` such that `a_i + b_j >= x`. This can be done by binary searching `b` for `x - a_i`. Let this smallest `b_j` be `b_k`. Then `a_i + b_k` is a candidate for Vasya's score.\nWe are looking for the minimum `S` that can be formed by *some* pair `(a_i, b_j)` such that `a_i + b_j >= x`. This minimum `S` is the `S_vasya` we're looking for.\nThis is because `count_ge(S)` is non-increasing. So `max_{S_vasya >= x} count_ge(S_vasya)` will be `count_ge(S_min_vasya)` where `S_min_vasya = min {a_i + b_j | a_i + b_j >= x}`.\nThis `S_min_vasya` can be found efficiently. Sort `a` ascending. Sort `b` ascending.\nIterate `i` from `0` to `n-1`. For each `a_i`, find the smallest `b_j` such that `b_j >= x - a_i`. This `b_j` can be found using `bisect_left` on `b`. If such `b_j` exists, then `a_i + b_j` is a candidate score. The minimum among all such candidates is `S_min_vasya`.\n\nAlgorithm for worst rank:\n1. Sort `a` in ascending order.\n2. Sort `b` in ascending order.\n3. Initialize `S_min_vasya = infinity`.\n4. For each `val_a` in `a`:\n   a. Find the smallest `val_b` in `b` such that `val_a + val_b >= x`. This means `val_b >= x - val_a`.\n   b. Use `bisect_left(b, x - val_a)` to find the index `idx_b` of the first element in `b` that is `>= x - val_a`.\n   c. If `idx_b < n` (meaning such a `val_b` exists):\n      `S_min_vasya = min(S_min_vasya, val_a + b[idx_b])`.\n5. Calculate `worst_rank = count_ge(S_min_vasya)` using the two-pointer approach described above.\n\nExample Walkthrough: `a=[4, 3, 5, 6, 4, 4]`, `b=[8, 6, 0, 4, 3, 4]`, `n=6, x=7`.\nSorted `a = [3, 4, 4, 4, 5, 6]`\nSorted `b = [0, 3, 4, 4, 6, 8]`\n\nFind `S_min_vasya`:\n- `val_a = 3`: `x - val_a = 7 - 3 = 4`. `bisect_left(b, 4)` is at index 2 (`b[2]=4`). `3 + 4 = 7`. `S_min_vasya = 7`.\n- `val_a = 4`: `x - val_a = 7 - 4 = 3`. `bisect_left(b, 3)` is at index 1 (`b[1]=3`). `4 + 3 = 7`. `S_min_vasya = 7`.\n- `val_a = 4`: `x - val_a = 7 - 4 = 3`. `bisect_left(b, 3)` is at index 1 (`b[1]=3`). `4 + 3 = 7`. `S_min_vasya = 7`.\n- `val_a = 4`: `x - val_a = 7 - 4 = 3`. `bisect_left(b, 3)` is at index 1 (`b[1]=3`). `4 + 3 = 7`. `S_min_vasya = 7`.\n- `val_a = 5`: `x - val_a = 7 - 5 = 2`. `bisect_left(b, 2)` is at index 1 (`b[1]=3`). `5 + 3 = 8`. `S_min_vasya = min(7, 8) = 7`.\n- `val_a = 6`: `x - val_a = 7 - 6 = 1`. `bisect_left(b, 1)` is at index 1 (`b[1]=3`). `6 + 3 = 9`. `S_min_vasya = min(7, 9) = 7`.\nSo, `S_min_vasya = 7`.\n\nCalculate `count_ge(7)`:\n`a = [3, 4, 4, 4, 5, 6]`\n`b = [0, 3, 4, 4, 6, 8]`\n`ptr_a = 0` (`a[0]=3`), `ptr_b = 5` (`b[5]=8`)\n1. `a[0]+b[5] = 3+8 = 11 >= 7`. `count = 1`. `ptr_a = 1`, `ptr_b = 4`. (Pairs (3,8))\n2. `a[1]+b[4] = 4+6 = 10 >= 7`. `count = 2`. `ptr_a = 2`, `ptr_b = 3`. (Pairs (4,6))\n3. `a[2]+b[3] = 4+4 = 8 >= 7`. `count = 3`. `ptr_a = 3`, `ptr_b = 2`. (Pairs (4,4))\n4. `a[3]+b[2] = 4+4 = 8 >= 7`. `count = 4`. `ptr_a = 4`, `ptr_b = 1`. (Pairs (4,4))\n5. `a[4]+b[1] = 5+3 = 8 >= 7`. `count = 5`. `ptr_a = 5`, `ptr_b = 0`. (Pairs (5,3))\n6. `a[5]+b[0] = 6+0 = 6 < 7`. `ptr_a = 6`. (a[5] cannot form a pair >= 7)\nLoop ends. `count_ge(7) = 5`.\nSo, the worst rank is 5.\n\nFinal output: `1 5`. This matches the example.\n\nThe time complexity will be:\n- Sorting `a` and `b`: `O(N log N)`.\n- Finding `S_min_vasya`: `N` iterations, each with `bisect_left` (`O(log N)`). Total `O(N log N)`.\n- Calculating `count_ge`: `O(N)` for the two-pointer scan.\nOverall time complexity: `O(N log N)`.\nSpace complexity: `O(N)` for storing sorted arrays (or `O(1)` if sorting in-place).\n\n```python\nimport sys\nfrom bisect import bisect_left\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    # Best rank is always 1\n    # As Vasya can claim the highest score from tour 1 (max(a)) and highest from tour 2 (max(b)).\n    # The problem guarantees that there exists a pair (a_i, b_j) such that a_i + b_j >= x.\n    # The maximum possible sum max(a) + max(b) must therefore also be >= x.\n    # If Vasya gets max(a) + max(b), no one can score higher, so he can be rank 1.\n    best_rank = 1\n\n    # Worst rank calculation\n    # To find the worst rank, we want to maximize the number of people who score >= Vasya's score.\n    # Vasya's score S_vasya must be >= x.\n    # The function count_ge(S) computes the maximum number of participants who can score >= S.\n    # This function is monotonically non-increasing.\n    # So, max_{S_vasya >= x} count_ge(S_vasya) will be achieved for the smallest possible S_vasya >= x.\n    # This S_vasya is the minimum sum a_i + b_j such that a_i + b_j >= x, considering all possible pairs.\n\n    a.sort() # Sort in ascending order\n    b.sort() # Sort in ascending order\n\n    # Find the smallest possible score S_min_vasya that Vasya could achieve such that S_min_vasya >= x.\n    # This involves finding min(a_i + b_j) among all i, j such that a_i + b_j >= x.\n    s_min_vasya = float('inf')\n    for val_a in a:\n        # We need b_j such that b_j >= x - val_a\n        # Use bisect_left to find the index of the smallest b_j that satisfies this condition\n        target_b = x - val_a\n        idx_b = bisect_left(b, target_b)\n        \n        if idx_b < n: # If such a b_j exists\n            s_min_vasya = min(s_min_vasya, val_a + b[idx_b])\n    \n    # Now, calculate the worst rank using s_min_vasya.\n    # This is the maximum number of people who can score at least s_min_vasya.\n    \n    worst_rank = 0\n    ptr_a = 0\n    ptr_b = n - 1 # Start with the largest b score\n\n    while ptr_a < n and ptr_b >= 0:\n        if a[ptr_a] + b[ptr_b] >= s_min_vasya:\n            # This pair (a[ptr_a], b[ptr_b]) can achieve at least s_min_vasya\n            worst_rank += 1\n            ptr_a += 1 # Use this a score\n            ptr_b -= 1 # Use this b score\n        else:\n            # Even with the largest remaining b[ptr_b], a[ptr_a] cannot reach s_min_vasya.\n            # So, a[ptr_a] cannot be part of any pair that sums to s_min_vasya or more.\n            ptr_a += 1 # Discard this a score and try the next one\n\n    print(best_rank, worst_rank)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom bisect import bisect_left\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    # Best rank is always 1\n    # As Vasya can claim the highest score from tour 1 (max(a)) and highest from tour 2 (max(b)).\n    # The problem guarantees that there exists a pair (a_i, b_j) such that a_i + b_j >= x.\n    # The maximum possible sum max(a) + max(b) must therefore also be >= x.\n    # If Vasya gets max(a) + max(b), no one can score higher, so he can be rank 1.\n    best_rank = 1\n\n    # Worst rank calculation\n    # To find the worst rank, we want to maximize the number of people who score >= Vasya's score.\n    # Vasya's score S_vasya must be >= x.\n    # The function count_ge(S) computes the maximum number of participants who can score >= S.\n    # This function is monotonically non-increasing.\n    # So, max_{S_vasya >= x} count_ge(S_vasya) will be achieved for the smallest possible S_vasya >= x.\n    # This S_vasya is the minimum sum a_i + b_j such that a_i + b_j >= x, considering all possible pairs.\n\n    a.sort() # Sort in ascending order\n    b.sort() # Sort in ascending order\n\n    # Find the smallest possible score S_min_vasya that Vasya could achieve such that S_min_vasya >= x.\n    # This involves finding min(a_i + b_j) among all i, j such that a_i + b_j >= x.\n    s_min_vasya = float('inf')\n    for val_a in a:\n        # We need b_j such that b_j >= x - val_a\n        # Use bisect_left to find the index of the smallest b_j that satisfies this condition\n        target_b = x - val_a\n        idx_b = bisect_left(b, target_b)\n        \n        if idx_b < n: # If such a b_j exists\n            s_min_vasya = min(s_min_vasya, val_a + b[idx_b])\n    \n    # Now, calculate the worst rank using s_min_vasya.\n    # This is the maximum number of people who can score at least s_min_vasya.\n    \n    worst_rank = 0\n    ptr_a = 0\n    ptr_b = n - 1 # Start with the largest b score\n\n    while ptr_a < n and ptr_b >= 0:\n        if a[ptr_a] + b[ptr_b] >= s_min_vasya:\n            # This pair (a[ptr_a], b[ptr_b]) can achieve at least s_min_vasya\n            worst_rank += 1\n            ptr_a += 1 # Use this a score\n            ptr_b -= 1 # Use this b score\n        else:\n            # Even with the largest remaining b[ptr_b], a[ptr_a] cannot reach s_min_vasya.\n            # So, a[ptr_a] cannot be part of any pair that sums to s_min_vasya or more.\n            ptr_a += 1 # Discard this a score and try the next one\n\n    print(best_rank, worst_rank)\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 873,
        "completion_token_count": 4190,
        "thoughts_token_count": 6699
    }
}