{
    "start": 1758294859.9203095,
    "end": 1758294947.4595244,
    "start-formatted": "2025-09-20 00:14 KST",
    "end-formatted": "2025-09-20 00:15 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "**Algorithm Design for Mushroom Strife Problem**\n\nOkay, so I'm tackling this \"Mushroom Strife\" problem. We're given a graph where the nodes represent mushroom patches, and edges represent roads with constraints on the GCD and LCM of mushrooms on connected patches. My goal is to devise a Python script to find a valid mushroom count assignment or determine that no solution exists.\n\nFirst, the core idea: We're dealing with constraints on pairs of mushroom counts connected by edges.  The key is the relationship between the GCD, LCM, and the product of the two numbers. Each edge dictates that `x_u * x_v = g * l`, where `x_u` and `x_v` are mushroom counts on the connected patches. Also,  `x_u` and `x_v` must be multiples of the GCD, `g`. The divisibility constraint from the LCM is also crucial. If `l % g != 0` for any edge, we can immediately declare \"NO\" – it's a dead end.\n\nI'm thinking small constraints `n <= 100`, `m <= 100` hints that an exhaustive or graph-based approach is feasible. If `m` is zero, we can simply assign all patches a mushroom count of 1.\n\nThe central concept is to propagate constraints across the graph.  If we \"fix\" the value of one node's mushroom count, we can constrain its neighbors' values using the edge information (GCD and LCM). If the assigned values violate the constraints, we have a problem.\n\nThe initial thought was to propagate, but then realized that the core constraint is related to prime factors.  Focusing on prime factors, we can view each prime factor as a separate \"layer\" of constraint.  For each prime `p`, and edge `(u, v, g, l)`, the exponents of `p` in `x_u` and `x_v` must be either `{v_p(g), v_p(l)}` or `{v_p(l), v_p(g)}`.\n\nThis observation led me to model it as a 2-coloring problem within each prime layer. Using graph traversal, specifically BFS or DFS, would propagate these exponent constraints for a given prime. During this process, any inconsistencies - a conflicting exponent assignment - means the problem is unsolvable, and we can immediately return \"NO.\"\n\nEssentially, I need to:\n1.  **Preprocessing:** Precompute prime factors and their counts for all potential GCD/LCM values.\n2.  **Iterate through primes:** For each prime number p that is a factor of any GCD/LCM, treat it as a separate graph with constraints.\n3.  **Graph Traversal:** Perform BFS/DFS for each connected component related to p. Assign exponents for each node based on the edges' GCD/LCM constraints.\n4. **Consistency Check:** During traversal, check and ensure assigned exponents for each prime are compatible with *all* connected edges. If they are not consistent, return \"NO\".\n5. **Reconstruct Answers:**  After the traversal for each prime factor, reconstruct the solution mushroom counts, ensuring they are within the acceptable range and that the product is as expected.\n6. **Final Validation:** Verify that the calculated counts satisfy the GCD and LCM requirements for all edges in the input.\n\nIt seems like an elegant and efficient way to handle the problem, given the relatively low constraints on graph size.\n",
    "response": "The problem asks us to restore the number of mushrooms on `n` lawns, given `m` roads. For each road connecting lawns `u` and `v`, we are given the greatest common divisor (GCD) and least common multiple (LCM) of the mushroom counts `x_u` and `x_v`. We need to find any valid assignment of `x_i` (between 1 and 10^6) or report that none exists.\n\nLet `x_i` be the number of mushrooms on lawn `i`. For an edge `(u, v)` with given `g = gcd(x_u, x_v)` and `l = lcm(x_u, x_v)`:\n1. `g * l = x_u * x_v`\n2. `x_u` must be a multiple of `g`.\n3. `x_v` must be a multiple of `g`.\n4. `l` must be a multiple of `g`. If `l % g != 0` for any edge, no solution exists.\n\nA powerful property of GCD and LCM relates to prime factorizations. Let `v_p(k)` be the exponent of prime `p` in the prime factorization of `k`.\nFor any prime `p`:\n`v_p(gcd(A, B)) = min(v_p(A), v_p(B))`\n`v_p(lcm(A, B)) = max(v_p(A), v_p(B))`\n\nCombining these, we get:\n`v_p(g) = min(v_p(x_u), v_p(x_v))`\n`v_p(l) = max(v_p(x_u), v_p(x_v))`\n\nThis implies two things for each prime `p` and edge `(u, v)`:\n1. `v_p(g) <= v_p(l)`. If this is not true for any `p`, then `l % g != 0`, which is an immediate \"NO\".\n2. The set `{v_p(x_u), v_p(x_v)}` must be equal to the set `{v_p(g), v_p(l)}`.\n   This also means `v_p(x_u) + v_p(x_v) = v_p(g) + v_p(l)`.\n\nThis breaks down the problem into `P` independent subproblems, one for each prime `p` that appears in the factorization of any `g` or `l` in the input. For each prime `p`, we need to assign `v_p(x_i)` to each lawn `i`.\n\n**Algorithm Steps:**\n\n1.  **Precomputation (Prime Factorization):**\n    *   Find all primes up to `10^6` using a sieve (e.g., Sieve of Eratosthenes) and store the smallest prime factor (SPF) for each number.\n    *   Create a function `get_prime_factorization(num)` that uses the SPF array to efficiently return a dictionary `{prime: exponent}` for `num`.\n\n2.  **Initial Checks and Data Structures:**\n    *   Store the graph using an adjacency list `adj[u]` where each entry is `(v, g, l)`.\n    *   Initialize `final_exponents[i]` as an empty dictionary for each lawn `i` (to store `prime: exponent` for `x_i`).\n    *   Collect all unique prime factors that appear in any `g` or `l` from the input into a set `all_relevant_primes`.\n    *   For each edge `(u, v, g, l)`, check if `l % g != 0`. If so, print \"NO\" and exit.\n\n3.  **Process Each Prime Independently:**\n    *   Iterate through each `p` in `all_relevant_primes`.\n    *   For the current prime `p`, maintain:\n        *   `node_p_exp = [None] * (n + 1)`: Stores the assigned `v_p(x_i)` for each lawn `i` for this prime `p`. `None` means unassigned.\n        *   `visited_p = [False] * (n + 1)`: To track visited nodes in BFS/DFS for this prime.\n    *   Iterate `start_node` from `1` to `n`:\n        *   If `visited_p[start_node]` is `False`:\n            *   Start a Breadth-First Search (BFS) or Depth-First Search (DFS) from `start_node`.\n            *   **Initial Assignment:** `node_p_exp[start_node]` needs an initial value. If `start_node` has no incident edges for which `p` is a factor of `g` or `l`, set `node_p_exp[start_node] = 0`. Otherwise, pick an arbitrary incident edge `(start_node, k, g_0, l_0)` and set `node_p_exp[start_node] = v_p(g_0)`. (This choice is arbitrary; if it leads to a contradiction, no solution exists for this component with this choice, and if the other choice `v_p(l_0)` were the only valid one, the BFS will detect the contradiction and we would report \"NO\". Since we only need *any* solution, one choice is fine.)\n            *   Add `start_node` to queue/stack, mark `visited_p[start_node] = True`.\n            *   **BFS/DFS Traversal:**\n                *   When processing `u` with `exp_u = node_p_exp[u]`:\n                *   For each neighbor `v` via edge `(u, v, g_val, l_val)`:\n                    *   Get `exp_g = v_p(g_val)` and `exp_l = v_p(l_val)`.\n                    *   **Consistency Check 1:** `exp_u` must be either `exp_g` or `exp_l`. If not, print \"NO\" and exit.\n                    *   Calculate `exp_v_expected = exp_g + exp_l - exp_u`. (This is because `v_p(x_u) + v_p(x_v) = v_p(g) + v_p(l)`).\n                    *   If `v` is not `visited_p`:\n                        *   Assign `node_p_exp[v] = exp_v_expected`.\n                        *   Mark `visited_p[v] = True`.\n                        *   Add `v` to queue/stack.\n                    *   Else (`v` is already visited):\n                        *   **Consistency Check 2:** If `node_p_exp[v] != exp_v_expected`, print \"NO\" and exit.\n    *   After processing all components for prime `p`, transfer `node_p_exp` values to `final_exponents`:\n        *   For each `i` from `1` to `n`: if `node_p_exp[i]` is `None` (meaning `i` was isolated for this prime or `p` was not a factor of any incident `g,l`), set `final_exponents[i][p] = 0`. Otherwise, set `final_exponents[i][p] = node_p_exp[i]`.\n\n4.  **Construct Final Mushroom Counts:**\n    *   For each lawn `i` from `1` to `n`:\n        *   Calculate `x_i = product(p ** exp for p, exp in final_exponents[i].items())`.\n        *   If `x_i` exceeds `10^6`, print \"NO\" and exit.\n    *   Store `x_i` in `ans[i]`.\n\n5.  **Final Verification:**\n    *   Iterate through all original `m` edges `(u, v, g, l)`:\n        *   Verify `gcd(ans[u], ans[v]) == g` and `lcm(ans[u], ans[v]) == l`.\n        *   If any check fails, print \"NO\" and exit.\n\n6.  **Output:**\n    *   If all checks pass, print \"YES\" followed by the `n` values in `ans`.\n\n**Edge Cases:**\n*   `m = 0`: All `x_i` can be `1`. The algorithm will assign `0` to all prime exponents, resulting in `x_i=1`.\n*   Isolated nodes: Handled by `node_p_exp[i] = None` and defaulting to `0` exponent.\n*   Values `10^6`: Max value for `g, l, x_i` is `10^6`. The `x_i` calculation must handle potential overflow *before* storing, and check if `x_i > 10^6`.\n\nThe maximum number of distinct prime factors for a number up to `10^6` is small (e.g., `2 * 3 * 5 * 7 * 11 * 13 * 17 = 510510`). The number of primes up to `10^6` is `78498`. However, `all_relevant_primes` will be much smaller (at most `2 * m * log(MAX_VAL)` distinct primes, practically small). The `N, M` constraints are very small (`100`), so the BFS/DFS for each prime will be efficient. The precomputation for SPF and factorization is the dominant part but is done once.\n\n```python\nimport sys\nfrom collections import deque\nimport math\n\n# Max value for g, l, x_i\nMAX_VAL = 10**6\n\n# Sieve for smallest prime factor (spf)\nspf = [0] * (MAX_VAL + 1)\nprimes = []\n\ndef sieve():\n    for i in range(2, MAX_VAL + 1):\n        if spf[i] == 0:\n            spf[i] = i\n            primes.append(i)\n        for p in primes:\n            if p > spf[i] or i * p > MAX_VAL:\n                break\n            spf[i * p] = p\n\nsieve()\n\n# Function to get prime factorization\n# Returns a dictionary {prime: exponent}\ndef get_prime_factorization(n):\n    factors = {}\n    if n <= 1:\n        return factors\n    temp_n = n\n    while temp_n > 1:\n        p = spf[temp_n]\n        count = 0\n        while temp_n % p == 0:\n            temp_n //= p\n            count += 1\n        factors[p] = count\n    return factors\n\n# Function to calculate GCD\ndef calculate_gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\n# Function to calculate LCM\ndef calculate_lcm(a, b):\n    if a == 0 or b == 0:\n        return 0\n    return (a * b) // calculate_gcd(a, b)\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    edges_data = [] # Store (u, v, g, l) for final verification\n\n    all_relevant_primes = set()\n\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        \n        if l % g != 0:\n            sys.stdout.write(\"NO\\n\")\n            return\n\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l))\n        edges_data.append((u, v, g, l))\n\n        # Collect all prime factors from g and l\n        factors_g = get_prime_factorization(g)\n        factors_l = get_prime_factorization(l)\n        all_relevant_primes.update(factors_g.keys())\n        all_relevant_primes.update(factors_l.keys())\n\n    # If no roads, all mushrooms can be 1\n    if m == 0:\n        sys.stdout.write(\"YES\\n\")\n        sys.stdout.write(\" \".join([\"1\"] * n) + \"\\n\")\n        return\n\n    # final_exponents[i] will be a dict {prime: exponent} for x_i\n    final_exponents = [{} for _ in range(n + 1)]\n\n    # Process each relevant prime independently\n    for p in all_relevant_primes:\n        node_p_exp = [None] * (n + 1) # Exponent of p for each node x_i\n        visited_p = [False] * (n + 1) # Visited array for BFS for current prime p\n\n        for start_node in range(1, n + 1):\n            if not visited_p[start_node]:\n                q = deque()\n                \n                # Determine an initial exponent for start_node for prime p\n                initial_exp_p = 0\n                found_initial = False\n                for neighbor, g_val, l_val in adj[start_node]:\n                    exp_g = get_prime_factorization(g_val).get(p, 0)\n                    exp_l = get_prime_factorization(l_val).get(p, 0)\n                    \n                    if exp_g > exp_l: # Should have been caught earlier by l % g != 0\n                        sys.stdout.write(\"NO\\n\")\n                        return\n\n                    if exp_g != 0 or exp_l != 0:\n                        initial_exp_p = exp_g # Arbitrarily pick exp_g as starting point\n                        found_initial = True\n                        break\n                \n                node_p_exp[start_node] = initial_exp_p\n                visited_p[start_node] = True\n                q.append(start_node)\n\n                while q:\n                    u = q.popleft()\n                    exp_u = node_p_exp[u]\n\n                    for v, g_val, l_val in adj[u]:\n                        exp_g = get_prime_factorization(g_val).get(p, 0)\n                        exp_l = get_prime_factorization(l_val).get(p, 0)\n\n                        if exp_g > exp_l: # Should have been caught earlier\n                            sys.stdout.write(\"NO\\n\")\n                            return\n\n                        # Consistency check: exp_u must be either exp_g or exp_l\n                        if exp_u != exp_g and exp_u != exp_l:\n                            sys.stdout.write(\"NO\\n\")\n                            return\n                        \n                        # Calculate expected exponent for v\n                        exp_v_expected = exp_g + exp_l - exp_u\n\n                        if not visited_p[v]:\n                            node_p_exp[v] = exp_v_expected\n                            visited_p[v] = True\n                            q.append(v)\n                        else:\n                            # Consistency check with already assigned exp_v\n                            if node_p_exp[v] != exp_v_expected:\n                                sys.stdout.write(\"NO\\n\")\n                                return\n        \n        # Store the determined exponents for prime p into final_exponents\n        for i in range(1, n + 1):\n            if node_p_exp[i] is None:\n                final_exponents[i][p] = 0 # Default to 0 exponent if not touched by any edge for this prime\n            else:\n                final_exponents[i][p] = node_p_exp[i]\n\n    # Construct final x_i values\n    ans = [0] * (n + 1)\n    for i in range(1, n + 1):\n        x_i = 1\n        for p_val, exp_val in final_exponents[i].items():\n            if exp_val > 0:\n                # Check for overflow before multiplication\n                # (p_val ** exp_val) can be large, use math.pow to handle it\n                # and check against MAX_VAL\n                power_val = 1\n                for _ in range(exp_val):\n                    if x_i > MAX_VAL // p_val: # Check if next multiplication would overflow\n                        x_i = MAX_VAL + 1 # Mark as overflowed\n                        break\n                    power_val *= p_val\n                \n                if x_i > MAX_VAL: # Already marked as overflowed\n                    break\n                \n                if power_val > MAX_VAL // x_i: # Check if current x_i * power_val would overflow\n                    x_i = MAX_VAL + 1\n                    break\n                x_i *= power_val\n                \n        if x_i > MAX_VAL:\n            sys.stdout.write(\"NO\\n\")\n            return\n        ans[i] = x_i\n        \n        # If any x_i ends up 0 (e.g. if MAX_VAL=0, but problem says 1..10^6), it's invalid.\n        # But here x_i starts at 1 and only multiplies by primes, so it will be >= 1.\n\n    # Final verification of all edges\n    for u, v, g, l in edges_data:\n        if calculate_gcd(ans[u], ans[v]) != g or calculate_lcm(ans[u], ans[v]) != l:\n            sys.stdout.write(\"NO\\n\")\n            return\n\n    sys.stdout.write(\"YES\\n\")\n    sys.stdout.write(\" \".join(map(str, ans[1:])) + \"\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\nimport math\n\n# Max value for g, l, x_i\nMAX_VAL = 10**6\n\n# Sieve for smallest prime factor (spf)\nspf = [0] * (MAX_VAL + 1)\nprimes = []\n\ndef sieve():\n    for i in range(2, MAX_VAL + 1):\n        if spf[i] == 0:\n            spf[i] = i\n            primes.append(i)\n        for p in primes:\n            if p > spf[i] or i * p > MAX_VAL:\n                break\n            spf[i * p] = p\n\nsieve()\n\n# Function to get prime factorization\n# Returns a dictionary {prime: exponent}\ndef get_prime_factorization(n):\n    factors = {}\n    if n <= 1:\n        return factors\n    temp_n = n\n    while temp_n > 1:\n        p = spf[temp_n]\n        count = 0\n        while temp_n % p == 0:\n            temp_n //= p\n            count += 1\n        factors[p] = count\n    return factors\n\n# Function to calculate GCD\ndef calculate_gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\n# Function to calculate LCM\ndef calculate_lcm(a, b):\n    if a == 0 or b == 0:\n        return 0\n    return (a * b) // calculate_gcd(a, b)\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    edges_data = [] # Store (u, v, g, l) for final verification\n\n    all_relevant_primes = set()\n\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        \n        if l % g != 0:\n            sys.stdout.write(\"NO\\n\")\n            return\n\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l))\n        edges_data.append((u, v, g, l))\n\n        # Collect all prime factors from g and l\n        factors_g = get_prime_factorization(g)\n        factors_l = get_prime_factorization(l)\n        all_relevant_primes.update(factors_g.keys())\n        all_relevant_primes.update(factors_l.keys())\n\n    # If no roads, all mushrooms can be 1\n    if m == 0:\n        sys.stdout.write(\"YES\\n\")\n        sys.stdout.write(\" \".join([\"1\"] * n) + \"\\n\")\n        return\n\n    # final_exponents[i] will be a dict {prime: exponent} for x_i\n    final_exponents = [{} for _ in range(n + 1)]\n\n    # Process each relevant prime independently\n    for p in all_relevant_primes:\n        node_p_exp = [None] * (n + 1) # Exponent of p for each node x_i\n        visited_p = [False] * (n + 1) # Visited array for BFS for current prime p\n\n        for start_node in range(1, n + 1):\n            if not visited_p[start_node]:\n                q = deque()\n                \n                # Determine an initial exponent for start_node for prime p\n                initial_exp_p = 0\n                found_initial = False\n                for neighbor, g_val, l_val in adj[start_node]:\n                    exp_g = get_prime_factorization(g_val).get(p, 0)\n                    exp_l = get_prime_factorization(l_val).get(p, 0)\n                    \n                    if exp_g > exp_l: # Should have been caught earlier by l % g != 0\n                        sys.stdout.write(\"NO\\n\")\n                        return\n\n                    if exp_g != 0 or exp_l != 0:\n                        initial_exp_p = exp_g # Arbitrarily pick exp_g as starting point\n                        found_initial = True\n                        break\n                \n                node_p_exp[start_node] = initial_exp_p\n                visited_p[start_node] = True\n                q.append(start_node)\n\n                while q:\n                    u = q.popleft()\n                    exp_u = node_p_exp[u]\n\n                    for v, g_val, l_val in adj[u]:\n                        exp_g = get_prime_factorization(g_val).get(p, 0)\n                        exp_l = get_prime_factorization(l_val).get(p, 0)\n\n                        if exp_g > exp_l: # Should have been caught earlier\n                            sys.stdout.write(\"NO\\n\")\n                            return\n\n                        # Consistency check: exp_u must be either exp_g or exp_l\n                        if exp_u != exp_g and exp_u != exp_l:\n                            sys.stdout.write(\"NO\\n\")\n                            return\n                        \n                        # Calculate expected exponent for v\n                        exp_v_expected = exp_g + exp_l - exp_u\n\n                        if not visited_p[v]:\n                            node_p_exp[v] = exp_v_expected\n                            visited_p[v] = True\n                            q.append(v)\n                        else:\n                            # Consistency check with already assigned exp_v\n                            if node_p_exp[v] != exp_v_expected:\n                                sys.stdout.write(\"NO\\n\")\n                                return\n        \n        # Store the determined exponents for prime p into final_exponents\n        for i in range(1, n + 1):\n            if node_p_exp[i] is None:\n                final_exponents[i][p] = 0 # Default to 0 exponent if not touched by any edge for this prime\n            else:\n                final_exponents[i][p] = node_p_exp[i]\n\n    # Construct final x_i values\n    ans = [0] * (n + 1)\n    for i in range(1, n + 1):\n        x_i = 1\n        for p_val, exp_val in final_exponents[i].items():\n            if exp_val > 0:\n                # Check for overflow before multiplication\n                # (p_val ** exp_val) can be large, use math.pow to handle it\n                # and check against MAX_VAL\n                power_val = 1\n                for _ in range(exp_val):\n                    if x_i > MAX_VAL // p_val: # Check if next multiplication would overflow\n                        x_i = MAX_VAL + 1 # Mark as overflowed\n                        break\n                    power_val *= p_val\n                \n                if x_i > MAX_VAL: # Already marked as overflowed\n                    break\n                \n                if power_val > MAX_VAL // x_i: # Check if current x_i * power_val would overflow\n                    x_i = MAX_VAL + 1\n                    break\n                x_i *= power_val\n                \n        if x_i > MAX_VAL:\n            sys.stdout.write(\"NO\\n\")\n            return\n        ans[i] = x_i\n        \n        # If any x_i ends up 0 (e.g. if MAX_VAL=0, but problem says 1..10^6), it's invalid.\n        # But here x_i starts at 1 and only multiplies by primes, so it will be >= 1.\n\n    # Final verification of all edges\n    for u, v, g, l in edges_data:\n        if calculate_gcd(ans[u], ans[v]) != g or calculate_lcm(ans[u], ans[v]) != l:\n            sys.stdout.write(\"NO\\n\")\n            return\n\n    sys.stdout.write(\"YES\\n\")\n    sys.stdout.write(\" \".join(map(str, ans[1:])) + \"\\n\")\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 542,
        "completion_token_count": 4097,
        "thoughts_token_count": 7536
    }
}