{
    "start": 1758284851.0137093,
    "end": 1758284868.3135774,
    "start-formatted": "2025-09-19 21:27 KST",
    "end-formatted": "2025-09-19 21:27 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "**The Plan to Conquer \"Guard Duty (easy)\"**\n\nOkay, so I've got this \"Guard Duty (easy)\" problem staring me down. Time to break it down. First things first:  it's about matching spaceships and bases, but the lines connecting them can't intersect.  The input's pretty clean – integer coordinates and no overlapping points, thank goodness. And the number of rebels and bases, 'R' and 'B', is capped at 10. That's a huge clue!  It screams \"brute force with permutations\" to me.\n\nMy gut says this is how I'll do it. I'll read in R and B, then grab the rebel and base coordinates.  A quick sanity check: R must equal B, or it's game over, and I can just spit out \"No.\"\n\nThe real work starts with generating all possible pairings of rebels and bases, which are really just permutations.  Since the numbers are small, factorial generation is quite manageable, like under 4 million checks. So, for each possible matching, I’ll:\n\n1.  **Map out the assignments** and generate the line segments representing those assignments.\n2.  **Check for intersections**. This is key.  I'll use the orientation test (cross-product/signed area). This will be my core logic.\n3.  If no intersections, bingo! I print \"Yes\" and can exit.\n\nIf I exhaust all the pairings and no configuration passes the intersection test, then I’ll just print \"No.\"\n\nThe intersection check itself is straightforward, luckily.  Two segments intersect only if their orientations are different.  I'll define an `o(p, q, r)` function using the cross-product to determine if `r` is clockwise or counter-clockwise relative to the line segment `pq`. The sign of the cross product determines the orientation.  I need to check that both line segments' end-points have different orientations, indicating an intersection. This `o` function will do the heavy lifting in checking for intersections.  Seems solid to me!\n",
    "response": "```python\nimport sys\nfrom itertools import permutations\n\n# Helper function to calculate orientation (cross product)\n# Returns 0 if p, q, r are collinear\n#         1 if (p, q, r) is clockwise\n#         2 if (p, q, r) is counter-clockwise\ndef orientation(p, q, r):\n    val = (q[1] - p[1]) * (r[0] - q[0]) - \\\n          (q[0] - p[0]) * (r[1] - q[1])\n    if val == 0:\n        return 0  # Collinear\n    return 1 if val > 0 else 2 # Clockwise if val > 0, Counter-clockwise if val < 0\n                               # Note: Standard competitive programming often uses >0 for CCW, <0 for CW.\n                               # The crucial part is that different signs mean different sides.\n                               # Here, I'll use 1 for positive cross product (CCW) and 2 for negative (CW)\n                               # to be consistent with typical return values, but the logic below just checks if they are different.\n\n# Helper function to check if point q lies on segment pr (assuming p, q, r are collinear)\ndef on_segment(p, q, r):\n    return (q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and\n            q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1]))\n\n# Helper function to check if two line segments p1q1 and p2q2 intersect\n# It returns True if segments intersect, False otherwise.\ndef segments_intersect(p1, q1, p2, q2):\n    # Find the four orientations needed for general case and special cases\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    # General case: segments intersect if orientations are different for both segments\n    if o1 != o2 and o3 != o4:\n        return True\n\n    # Special Cases (collinear points):\n    # p1, q1, p2 are collinear and p2 lies on segment p1q1\n    if o1 == 0 and on_segment(p1, p2, q1):\n        return True\n    # p1, q1, q2 are collinear and q2 lies on segment p1q1\n    if o2 == 0 and on_segment(p1, q2, q1):\n        return True\n    # p2, q2, p1 are collinear and p1 lies on segment p2q2\n    if o3 == 0 and on_segment(p2, p1, q2):\n        return True\n    # p2, q2, q1 are collinear and q1 lies on segment p2q2\n    if o4 == 0 and on_segment(p2, q1, q2):\n        return True\n\n    return False # Doesn't fall in any of the above cases\n\ndef solve():\n    R, B = map(int, sys.stdin.readline().split())\n\n    rebels = []\n    for _ in range(R):\n        rebels.append(list(map(int, sys.stdin.readline().split())))\n\n    bases = []\n    for _ in range(B):\n        bases.append(list(map(int, sys.stdin.readline().split())))\n\n    # If the number of rebels and bases are not equal, a perfect matching is impossible.\n    if R != B:\n        print(\"No\")\n        return\n\n    # Iterate through all permutations of bases.\n    # Each permutation represents a possible assignment of bases to rebels.\n    # rebels[i] is assigned to bases[perm[i]].\n    for p_indices in permutations(range(B)):\n        # Construct the list of segments for this permutation\n        # A segment is a tuple ((x1, y1), (x2, y2))\n        segments = []\n        for i in range(R):\n            segments.append((rebels[i], bases[p_indices[i]]))\n\n        # Check for intersections among all pairs of segments\n        has_intersection = False\n        for i in range(R):\n            for j in range(i + 1, R): # Compare each segment with every other segment\n                if segments_intersect(segments[i][0], segments[i][1],\n                                      segments[j][0], segments[j][1]):\n                    has_intersection = True\n                    break\n            if has_intersection:\n                break\n        \n        # If no intersections were found for this permutation, we found a valid assignment\n        if not has_intersection:\n            print(\"Yes\")\n            return\n\n    # If no permutation resulted in a valid assignment\n    print(\"No\")\n\nif __name__ == '__main__':\n    solve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom itertools import permutations\n\n# Helper function to calculate orientation (cross product)\n# Returns 0 if p, q, r are collinear\n#         1 if (p, q, r) is clockwise\n#         2 if (p, q, r) is counter-clockwise\ndef orientation(p, q, r):\n    val = (q[1] - p[1]) * (r[0] - q[0]) - \\\n          (q[0] - p[0]) * (r[1] - q[1])\n    if val == 0:\n        return 0  # Collinear\n    return 1 if val > 0 else 2 # Clockwise if val > 0, Counter-clockwise if val < 0\n                               # Note: Standard competitive programming often uses >0 for CCW, <0 for CW.\n                               # The crucial part is that different signs mean different sides.\n                               # Here, I'll use 1 for positive cross product (CCW) and 2 for negative (CW)\n                               # to be consistent with typical return values, but the logic below just checks if they are different.\n\n# Helper function to check if point q lies on segment pr (assuming p, q, r are collinear)\ndef on_segment(p, q, r):\n    return (q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and\n            q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1]))\n\n# Helper function to check if two line segments p1q1 and p2q2 intersect\n# It returns True if segments intersect, False otherwise.\ndef segments_intersect(p1, q1, p2, q2):\n    # Find the four orientations needed for general case and special cases\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    # General case: segments intersect if orientations are different for both segments\n    if o1 != o2 and o3 != o4:\n        return True\n\n    # Special Cases (collinear points):\n    # p1, q1, p2 are collinear and p2 lies on segment p1q1\n    if o1 == 0 and on_segment(p1, p2, q1):\n        return True\n    # p1, q1, q2 are collinear and q2 lies on segment p1q1\n    if o2 == 0 and on_segment(p1, q2, q1):\n        return True\n    # p2, q2, p1 are collinear and p1 lies on segment p2q2\n    if o3 == 0 and on_segment(p2, p1, q2):\n        return True\n    # p2, q2, q1 are collinear and q1 lies on segment p2q2\n    if o4 == 0 and on_segment(p2, q1, q2):\n        return True\n\n    return False # Doesn't fall in any of the above cases\n\ndef solve():\n    R, B = map(int, sys.stdin.readline().split())\n\n    rebels = []\n    for _ in range(R):\n        rebels.append(list(map(int, sys.stdin.readline().split())))\n\n    bases = []\n    for _ in range(B):\n        bases.append(list(map(int, sys.stdin.readline().split())))\n\n    # If the number of rebels and bases are not equal, a perfect matching is impossible.\n    if R != B:\n        print(\"No\")\n        return\n\n    # Iterate through all permutations of bases.\n    # Each permutation represents a possible assignment of bases to rebels.\n    # rebels[i] is assigned to bases[perm[i]].\n    for p_indices in permutations(range(B)):\n        # Construct the list of segments for this permutation\n        # A segment is a tuple ((x1, y1), (x2, y2))\n        segments = []\n        for i in range(R):\n            segments.append((rebels[i], bases[p_indices[i]]))\n\n        # Check for intersections among all pairs of segments\n        has_intersection = False\n        for i in range(R):\n            for j in range(i + 1, R): # Compare each segment with every other segment\n                if segments_intersect(segments[i][0], segments[i][1],\n                                      segments[j][0], segments[j][1]):\n                    has_intersection = True\n                    break\n            if has_intersection:\n                break\n        \n        # If no intersections were found for this permutation, we found a valid assignment\n        if not has_intersection:\n            print(\"Yes\")\n            return\n\n    # If no permutation resulted in a valid assignment\n    print(\"No\")\n\nif __name__ == '__main__':\n    solve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 512,
        "completion_token_count": 1160,
        "thoughts_token_count": 815
    }
}