{
    "start": 1758294874.158669,
    "end": 1758294949.5248628,
    "start-formatted": "2025-09-20 00:14 KST",
    "end-formatted": "2025-09-20 00:15 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "**Solving a Competitive Programming Challenge**\n\nAlright, let's break this down. My goal is to tackle a competitive programming problem that boils down to finding two key values for a directed graph: the minimum number of nodes needed to achieve a specific level of \"reachability\" and, within that minimum, the maximum number of unidirectional node pairs.\n\nFirst, let's nail down the definitions. \"Reachability\" is the ability to get from one node to another via a directed path. Two nodes are \"reachable from each other\" if there's a path both ways – they're part of the same strongly connected component (SCC). A graph is \"p-reachable\" if it contains precisely *p* ordered pairs of nodes (u, v) where u is less than v and u and v are reachable from each other. Crucially, the \"u < v\" condition means we only count an SCC pair once.\n\nMy initial thought is that to minimize the number of nodes, I want to pack as many nodes as possible into large SCCs. This is because a larger SCC contributes more to the *p* value than smaller ones. If I have *k* nodes in an SCC, it contributes  *k*(k-1)/2 to the *p* count. This is a crucial observation. Now, to find the *minimum* number of nodes (N_min) needed to achieve *p*, I need the smallest integer *N* such that *N*(N-1)/2 is greater than or equal to *p*. I can do this using a quick iteration or by solving a simple quadratic equation (or calculating the ceiling of (1 + sqrt(1 + 8*p))/2).\n\nI am going to use a dynamic programming approach to find the minimum number of nodes. Let dp[x] represent the minimum number of nodes needed to achieve x pairs. The idea is for each possible SCC size, I can calculate how many nodes are needed for the resulting number of pairs. The recurrence relation to calculate this is: dp[x] = min(dp[x], dp[x - C(k, 2)] + k), where dp[0] is initialized to 0.\n\nNow comes the trickier part - maximizing unidirectional pairs. Since my nodes should be partitioned into SCC's that will contribute exactly *p* bidirectional pairs, I want to minimize $N$, and ensure the maximum number of the other pairs are unidirectional.  Essentially, what does it mean to be unidirectional? It means for any two nodes in different SCC's, there is a path from one to the other, but no path the other way. This suggests arranging the SCCs in a directed acyclic graph (DAG) structure. To get maximum unidirectional pairs, I need to order the SCCs linearly. The number of unidirectional pairs is just the number of directed edges in the DAG. This means if I have *N_min* total nodes and $2*p$ are bi-directional, then the unidirectional pairs should equal *N_min*(N_min - 1) - 2*p*. This is how to get the correct answer.\n\nSo, in essence, I'll figure out the minimum number of nodes with my DP algorithm, and then compute the *unidirectional* pairs given this minimal node count. Let's code this and see what happens!\n",
    "response": "The problem asks us to find two values for a given integer $p$:\n1. The minimum number of nodes required to create a directed graph that has exactly $p$ ordered pairs of nodes $(u, v)$ such that $u < v$ and $u$ and $v$ are reachable from each other.\n2. Among all such graphs with the minimum number of nodes, the maximum number of unidirectional pairs of nodes. An ordered pair $(u, v)$ is unidirectional if $u \\neq v$, there is a path from $u$ to $v$, and there are no paths from $v$ to $u$.\n\nLet's analyze the definitions:\n\n**Reachability and $p$-reachable graphs:**\nTwo nodes $u$ and $v$ are reachable from each other if and only if they belong to the same Strongly Connected Component (SCC).\nIf an SCC has $k$ nodes, then any two distinct nodes $u, v$ within this SCC are reachable from each other.\nThe number of ordered pairs $(u, v)$ with $u < v$ where $u$ and $v$ are in the same SCC of size $k$ is $\\binom{k}{2} = \\frac{k(k-1)}{2}$.\nIf a graph has multiple SCCs with sizes $k_1, k_2, \\dots, k_m$, the total number of such pairs is $\\sum_{i=1}^m \\binom{k_i}{2}$.\nWe are given that this sum must be exactly $p$. So, $\\sum_{i=1}^m \\frac{k_i(k_i-1)}{2} = p$.\nThe total number of nodes in the graph is $N = \\sum_{i=1}^m k_i$. We want to minimize $N$.\n\n**Part 1: Minimum number of nodes ($N_{min}$)**\nThis is a variation of the unbounded knapsack or change-making problem. We want to find a set of integers $k_1, k_2, \\dots, k_m$ (representing SCC sizes) such that $\\sum \\frac{k_i(k_i-1)}{2} = p$ and $\\sum k_i$ is minimized.\nLet $dp[x]$ be the minimum number of nodes required to achieve exactly $x$ \"reachable-from-each-other\" pairs.\nBase case: $dp[0] = 0$.\nInitialize $dp[x] = \\infty$ for $x > 0$.\nThe \"items\" we can use are SCCs of size $k$. An SCC of size $k$ contributes $\\binom{k}{2}$ pairs and $k$ nodes.\nWe can iterate through possible SCC sizes $k$ and update the $dp$ table.\nThe maximum value for $p$ is $2 \\cdot 10^5$.\nThe maximum $k$ such that $\\binom{k}{2} \\le 2 \\cdot 10^5$ is $k=633$ (since $\\binom{633}{2} = 199728$ and $\\binom{634}{2} = 200361$).\nThe DP transition is:\nFor each $k$ from $2$ to $633$:\n  Let $val = \\binom{k}{2}$.\n  For $x$ from $val$ to $p$:\n    $dp[x] = \\min(dp[x], dp[x - val] + k)$\n\nThe time complexity of this DP is $O(p \\cdot k_{max})$, where $k_{max} \\approx \\sqrt{2p}$.\nFor $p = 2 \\cdot 10^5$, $k_{max} = 633$. The complexity is roughly $2 \\cdot 10^5 \\cdot 633 \\approx 1.26 \\cdot 10^8$. However, the inner loop runs only for $x$ from $val$ to $p$. The total number of operations is $\\sum_{k=2}^{k_{max}} (p - \\binom{k}{2} + 1)$, which is closer to $O(p \\cdot k_{max} - k_{max}^3/6)$. For the given constraints, this is about $8.4 \\cdot 10^7$ operations, which might pass in Python given typical competitive programming time limits (usually $10^8$ operations per second for C++, so Python might be $10^7$).\n\nAfter computing the $dp$ table, $N_{min} = dp[p]$.\n\n**Part 2: Maximum number of unidirectional pairs**\nA pair $(u, v)$ is unidirectional if $u \\neq v$, there is a path $u \\to v$, and no path $v \\to u$. This means $u$ and $v$ are in different SCCs, and there's a path from $u$'s SCC to $v$'s SCC in the condensation graph (DAG of SCCs).\nLet $N_{min}$ be the total number of nodes and $k_1, \\dots, k_m$ be the sizes of the SCCs such that $\\sum k_i = N_{min}$ and $\\sum \\binom{k_i}{2} = p$.\nTo maximize unidirectional pairs, we should connect the SCCs in a linear chain (topological sort). For example, $S_1 \\to S_2 \\to \\dots \\to S_m$. This can be done by adding one edge from an arbitrary node in $S_i$ to an arbitrary node in $S_{i+1}$ for all $i=1, \\dots, m-1$.\nIn such a configuration:\n- If $u \\in S_i$ and $v \\in S_j$ with $i=j$: $u$ and $v$ are in the same SCC, so they are reachable from each other. There are $k_i(k_i-1)$ such ordered pairs $(u, v)$ for each $S_i$. The total is $\\sum k_i(k_i-1) = 2 \\sum \\binom{k_i}{2} = 2p$. These are *not* unidirectional pairs.\n- If $u \\in S_i$ and $v \\in S_j$ with $i < j$: There is a path from $u$ to $v$ (via the chain of SCCs), but no path from $v$ to $u$ (because it would imply a cycle in the condensation graph). All $k_i k_j$ such pairs are unidirectional.\n- If $u \\in S_i$ and $v \\in S_j$ with $i > j$: There is no path from $u$ to $v$, but there is a path from $v$ to $u$. So $(v, u)$ is a unidirectional pair. In total, all $k_i k_j$ pairs $(u, v)$ where $u \\in S_i, v \\in S_j$ with $i > j$ are pairs where $v \\to u$ but $u \\not\\to v$.\nThe total number of unidirectional pairs is the sum of $k_i k_j$ for all $i \\neq j$.\nSpecifically, if we define the \"direction\" of the unidirectional pair as $S_i \\to S_j$ for $i<j$, then the count is $\\sum_{i<j} k_i k_j$.\nIf we consider all ordered pairs $(u, v)$ with $u \\neq v$:\nTotal pairs is $N_{min}(N_{min}-1)$.\nPairs within the same SCC (bidirectional) is $2p$.\nPairs between different SCCs: $N_{min}(N_{min}-1) - 2p$.\nBy arranging SCCs in a chain, for any $u \\in S_i, v \\in S_j$ with $i \\neq j$:\n- If $i < j$, $(u, v)$ is unidirectional.\n- If $i > j$, $(v, u)$ is unidirectional.\nSo, all pairs $(u, v)$ where $u$ and $v$ are in different SCCs contribute to unidirectional pairs.\nThe number of unidirectional pairs is $N_{min}(N_{min}-1) - 2p$.\nThis formula applies to any graph where all nodes are either reachable from each other (in the same SCC) or form a unidirectional path between their SCCs (in a topologically sorted DAG of SCCs). Such a graph maximizes unidirectional pairs for a given $N_{min}$ and $p$.\n\n**Example Walkthrough**\n$p=3$:\nDP table:\n$dp[0]=0$\n$k=2, val=1$: $dp[1] = \\min(\\infty, dp[0]+2) = 2$\n$k=3, val=3$:\n  $dp[1]=2$\n  $dp[2]=\\min(\\infty, dp[1]+2) = 4$\n  $dp[3]=\\min(\\infty, dp[0]+3) = 3$\n  $dp[3]=\\min(dp[3], dp[2]+2) = \\min(3, 4+2) = 3$\n$N_{min} = dp[3] = 3$.\nMax unidirectional pairs = $N_{min}(N_{min}-1) - 2p = 3(3-1) - 2(3) = 3 \\cdot 2 - 6 = 6 - 6 = 0$.\nOutput: `3 0`. Matches example.\n\n$p=4$:\nDP table (continuing from $p=3$):\n$dp[0]=0, dp[1]=2, dp[2]=4, dp[3]=3$\n$k=2, val=1$: (already processed up to $dp[3]$)\n  $dp[4] = \\min(\\infty, dp[3]+2) = 3+2 = 5$\n$k=3, val=3$: (already processed up to $dp[3]$)\n  $dp[4] = \\min(dp[4], dp[4-3]+3) = \\min(5, dp[1]+3) = \\min(5, 2+3) = 5$\n$N_{min} = dp[4] = 5$.\nMax unidirectional pairs = $N_{min}(N_{min}-1) - 2p = 5(5-1) - 2(4) = 5 \\cdot 4 - 8 = 20 - 8 = 12$.\nOutput: `5 12`. Matches example (example output `5 6` is incorrect based on my understanding, or my understanding of unidirectional pairs is wrong).\n\nLet's re-read the definition of unidirectional: \"ordered pair of nodes $(u, v)$ in a directed graph unidirectional if $u \\neq v$, there exists a path from $u$ to $v$, and there are no paths from $v$ to $u$.\"\nMy calculation $N_{min}(N_{min}-1) - 2p$ counts all pairs $(u,v)$ where $u \\neq v$ and $u,v$ are not in the same SCC. If we arrange the SCCs in a linear order $S_1 \\to S_2 \\to \\dots \\to S_m$, then for any $u \\in S_i, v \\in S_j$:\n- If $i=j$, $u \\leftrightarrow v$. These are $2p$ pairs.\n- If $i < j$, $u \\to v$ but $v \\not\\to u$. This is a unidirectional pair. There are $k_i k_j$ such pairs.\n- If $i > j$, $v \\to u$ but $u \\not\\to v$. This means $(v, u)$ is a unidirectional pair. There are $k_i k_j$ such pairs $(u, v)$ for this $i>j$.\nSo, for any pair of nodes $u, v$ from different SCCs $S_i, S_j$, exactly one of $(u,v)$ or $(v,u)$ will be a unidirectional pair.\nThe total number of pairs of nodes from different SCCs is $N_{min}(N_{min}-1) - \\sum k_i(k_i-1) = N_{min}(N_{min}-1) - 2p$.\nEach such pair $\\{u, v\\}$ (unordered) contributes one unidirectional ordered pair (either $(u,v)$ or $(v,u)$) if we construct the graph as described.\nSo the number of unidirectional pairs is indeed $N_{min}(N_{min}-1) - 2p$.\n\nThe example output `5 6` for $p=4$ suggests something different.\nIf $N=5$, $p=4$.\nPossible SCC configurations for $N=5, p=4$:\n1. $k=3, k=2$: $\\binom{3}{2} + \\binom{2}{2} = 3+1=4$. Total nodes $3+2=5$. This is how $dp[4]=5$ is achieved.\n   SCCs are $S_1$ (3 nodes), $S_2$ (2 nodes).\n   If we connect $S_1 \\to S_2$:\n   Pairs within SCCs: $2 \\cdot 3 + 2 \\cdot 1 = 8$. (These are $2p$)\n   Pairs $u \\in S_1, v \\in S_2$: $3 \\cdot 2 = 6$. These are unidirectional.\n   Pairs $u \\in S_2, v \\in S_1$: $3 \\cdot 2 = 6$. These are not paths.\n   Total unidirectional: $6$.\n   This matches the example output `5 6`.\n\nMy formula $N_{min}(N_{min}-1) - 2p$ implicitly counts $(u,v)$ for $u \\in S_i, v \\in S_j, i<j$ AND $(v,u)$ for $v \\in S_j, u \\in S_i, j<i$.\nLet's clarify:\nTotal distinct ordered pairs $(u,v)$ with $u \\neq v$ is $N(N-1)$.\nPairs where $u,v$ are in the same SCC (bidirectional): $2p$.\nPairs where $u,v$ are in different SCCs: $N(N-1) - 2p$.\nLet's call the set of such pairs $P_{diff}$.\nFor each pair $(u,v) \\in P_{diff}$, either $u \\to v$ or $v \\to u$ or neither.\nTo maximize unidirectional pairs, we want to ensure that for every pair $\\{u,v\\}$ from different SCCs, exactly one of $(u,v)$ or $(v,u)$ is a path. This is achieved by creating a total order on the SCCs, say $S_1 \\to S_2 \\to \\dots \\to S_m$.\nIn this construction, for any $u \\in S_i, v \\in S_j$:\n- If $i < j$: $u \\to v$ (path exists), $v \\not\\to u$ (no path). So $(u,v)$ is unidirectional.\n- If $i > j$: $u \\not\\to v$ (no path), $v \\to u$ (path exists). So $(v,u)$ is unidirectional.\n- If $i = j$: $u \\leftrightarrow v$. Not unidirectional.\n\nSo, the total number of unidirectional pairs is $\\sum_{1 \\le i < j \\le m} k_i k_j$.\nThis is NOT $N(N-1) - 2p$.\n$N(N-1) - 2p$ is the total count of pairs $(u,v)$ where $u,v$ are in different SCCs.\nIf $u \\in S_i, v \\in S_j$ with $i < j$, then $(u,v)$ is unidirectional.\nIf $u \\in S_i, v \\in S_j$ with $i > j$, then $(v,u)$ is unidirectional. $(u,v)$ is NOT unidirectional.\nSo we only count pairs where $u \\in S_i, v \\in S_j$ and $i < j$.\nThis sum is $\\sum_{i=1}^{m-1} k_i \\left( \\sum_{j=i+1}^m k_j \\right)$.\nThis sum can be written as $\\frac{1}{2} \\left( (\\sum k_i)^2 - \\sum k_i^2 \\right)$.\nWhich is $\\frac{1}{2} (N^2 - \\sum k_i^2)$.\nWe need to find the specific $k_i$ values that sum up to $N_{min}$ nodes and $p$ pairs.\nThe DP approach for $N_{min}$ can be extended to store the actual decomposition.\nLet $prev\\_k[x]$ store the $k$ value used to achieve $dp[x]$.\nThen we can reconstruct the SCC sizes.\n`dp = [(float('inf'), None)] * (p + 1)`\n`dp[0] = (0, 0)` # (min_nodes, last_k)\n\n`k_tri_vals = []`\n`k = 0`\n`while True:`\n    `tri = k * (k - 1) // 2`\n    `if tri > p: break`\n    `if k >= 2: k_tri_vals.append((tri, k))`\n    `k += 1`\n\n`for tri, k_nodes in k_tri_vals:`\n    `for current_p in range(tri, p + 1):`\n        `if dp[current_p - tri][0] + k_nodes < dp[current_p][0]:`\n            `dp[current_p] = (dp[current_p - tri][0] + k_nodes, k_nodes)`\n\n`min_nodes = dp[p][0]`\n\nTo reconstruct $k_i$ values:\n`scc_sizes = []`\n`current_p = p`\n`while current_p > 0:`\n    `last_k = dp[current_p][1]`\n    `scc_sizes.append(last_k)`\n    `current_p -= last_k * (last_k - 1) // 2`\n\nNow we have `scc_sizes`. Let these be $k_1, k_2, \\dots, k_m$.\nWe want to maximize $\\sum_{1 \\le i < j \\le m} k_i k_j$.\nThis sum is maximized when the $k_i$ values are arranged in any order.\nThe sum $\\sum_{i<j} k_i k_j = \\frac{1}{2} \\left( (\\sum k_i)^2 - \\sum k_i^2 \\right)$.\nThis value depends only on $N_{min} = \\sum k_i$ and $\\sum k_i^2$.\nTo maximize this, we need to minimize $\\sum k_i^2$.\nFor a fixed sum $N_{min}$, $\\sum k_i^2$ is minimized when the $k_i$ values are as close to each other as possible.\nHowever, the $k_i$ values are determined by the DP, and we can't change them. So the specific values $k_i$ are fixed once we have the optimal decomposition for $p$.\nCalculate `sum_of_squares = sum(k*k for k in scc_sizes)`.\nMax unidirectional pairs = $\\frac{1}{2} (N_{min}^2 - \\text{sum_of_squares})$.\n\nLet's recheck $p=4$:\n$dp[0]=(0,0)$\n$k=2, val=1$: $dp[1]=(2,2)$\n$k=3, val=3$:\n  $dp[1]=(2,2)$\n  $dp[2]=\\min(\\infty, dp[1][0]+2) = (4,2)$\n  $dp[3]=\\min(\\infty, dp[0][0]+3) = (3,3)$\n  $dp[3]=\\min((3,3), dp[2][0]+2) = \\min((3,3), 4+2) = (3,3)$\n$p=4$:\n  $k=2, val=1$: $dp[4]=\\min(\\infty, dp[3][0]+2) = (3+2, 2) = (5,2)$\n  $k=3, val=3$: $dp[4]=\\min((5,2), dp[1][0]+3) = \\min((5,2), 2+3) = (5,3)$\nSo $N_{min}=5$. The last $k$ used for $p=4$ was $3$.\nReconstruction:\n$current\\_p=4$, $last\\_k=3$. $scc\\_sizes = [3]$. $current\\_p = 4 - \\binom{3}{2} = 4-3=1$.\n$current\\_p=1$, $last\\_k=2$. $scc\\_sizes = [3, 2]$. $current\\_p = 1 - \\binom{2}{2} = 1-1=0$.\nSCC sizes are $k_1=3, k_2=2$.\n$N_{min}=3+2=5$.\n$\\sum k_i^2 = 3^2 + 2^2 = 9+4=13$.\nMax unidirectional pairs = $\\frac{1}{2} (N_{min}^2 - \\sum k_i^2) = \\frac{1}{2} (5^2 - 13) = \\frac{1}{2} (25 - 13) = \\frac{1}{2} (12) = 6$.\nThis matches the example output `5 6`. My understanding of the second part is now correct.\n\nFinal checks:\n$p=0$:\n$dp[0]=(0,0)$. $N_{min}=0$.\n$scc\\_sizes = []$. $\\sum k_i^2 = 0$.\nMax unidirectional pairs = $\\frac{1}{2}(0^2 - 0) = 0$.\nOutput: `0 0`. Matches example.\n\nThe solution seems robust.\n\n```python\nimport sys\n\ndef solve():\n    p = int(sys.stdin.readline())\n\n    # Part 1: Minimum number of nodes\n    # dp[x] stores a tuple (min_nodes, last_k_used) for x pairs\n    dp = [(float('inf'), None)] * (p + 1)\n    dp[0] = (0, 0) # 0 pairs, 0 nodes, last_k_used is irrelevant for 0\n\n    # Precompute possible (triangle_number, k) pairs\n    k_tri_vals = []\n    k = 0\n    while True:\n        tri = k * (k - 1) // 2\n        if tri > p:\n            break\n        # Only SCCs of size 2 or more contribute to p\n        # k=0 or k=1 gives tri=0, which doesn't uniquely identify k.\n        # We handle k=0 or k=1 implicitly by dp[0]=0.\n        # For actual SCCs, we start from k=2.\n        if k >= 2:\n            k_tri_vals.append((tri, k))\n        k += 1\n\n    # Fill DP table\n    for tri_val, k_nodes in k_tri_vals:\n        for current_p in range(tri_val, p + 1):\n            if dp[current_p - tri_val][0] != float('inf'): # Ensure previous state is reachable\n                new_nodes = dp[current_p - tri_val][0] + k_nodes\n                if new_nodes < dp[current_p][0]:\n                    dp[current_p] = (new_nodes, k_nodes)\n\n    min_nodes = dp[p][0]\n\n    # Part 2: Maximum number of unidirectional pairs\n    if p == 0:\n        max_unidirectional_pairs = 0\n    else:\n        # Reconstruct the SCC sizes (k_i values) that achieve dp[p]\n        scc_sizes = []\n        current_p_val = p\n        while current_p_val > 0:\n            last_k = dp[current_p_val][1]\n            scc_sizes.append(last_k)\n            current_p_val -= last_k * (last_k - 1) // 2\n        \n        # Calculate sum of squares of SCC sizes\n        sum_of_squares_k_i = sum(k*k for k in scc_sizes)\n        \n        # Max unidirectional pairs = 1/2 * (N_min^2 - sum(k_i^2))\n        max_unidirectional_pairs = (min_nodes * min_nodes - sum_of_squares_k_i) // 2\n\n    sys.stdout.write(f\"{min_nodes} {max_unidirectional_pairs}\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    p = int(sys.stdin.readline())\n\n    # Part 1: Minimum number of nodes\n    # dp[x] stores a tuple (min_nodes, last_k_used) for x pairs\n    dp = [(float('inf'), None)] * (p + 1)\n    dp[0] = (0, 0) # 0 pairs, 0 nodes, last_k_used is irrelevant for 0\n\n    # Precompute possible (triangle_number, k) pairs\n    k_tri_vals = []\n    k = 0\n    while True:\n        tri = k * (k - 1) // 2\n        if tri > p:\n            break\n        # Only SCCs of size 2 or more contribute to p\n        # k=0 or k=1 gives tri=0, which doesn't uniquely identify k.\n        # We handle k=0 or k=1 implicitly by dp[0]=0.\n        # For actual SCCs, we start from k=2.\n        if k >= 2:\n            k_tri_vals.append((tri, k))\n        k += 1\n\n    # Fill DP table\n    for tri_val, k_nodes in k_tri_vals:\n        for current_p in range(tri_val, p + 1):\n            if dp[current_p - tri_val][0] != float('inf'): # Ensure previous state is reachable\n                new_nodes = dp[current_p - tri_val][0] + k_nodes\n                if new_nodes < dp[current_p][0]:\n                    dp[current_p] = (new_nodes, k_nodes)\n\n    min_nodes = dp[p][0]\n\n    # Part 2: Maximum number of unidirectional pairs\n    if p == 0:\n        max_unidirectional_pairs = 0\n    else:\n        # Reconstruct the SCC sizes (k_i values) that achieve dp[p]\n        scc_sizes = []\n        current_p_val = p\n        while current_p_val > 0:\n            last_k = dp[current_p_val][1]\n            scc_sizes.append(last_k)\n            current_p_val -= last_k * (last_k - 1) // 2\n        \n        # Calculate sum of squares of SCC sizes\n        sum_of_squares_k_i = sum(k*k for k in scc_sizes)\n        \n        # Max unidirectional pairs = 1/2 * (N_min^2 - sum(k_i^2))\n        max_unidirectional_pairs = (min_nodes * min_nodes - sum_of_squares_k_i) // 2\n\n    sys.stdout.write(f\"{min_nodes} {max_unidirectional_pairs}\\n\")\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 483,
        "completion_token_count": 5720,
        "thoughts_token_count": 6136
    }
}