{
    "start": 1758294823.7814136,
    "end": 1758294909.1985533,
    "start-formatted": "2025-09-20 00:13 KST",
    "end-formatted": "2025-09-20 00:15 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "**Algorithm for Finding Minimum Edges and Ways to Form Odd Cycles**\n\nAlright, let's break this down. The problem's about taking an undirected graph and figuring out how few edges we need to toss in to guarantee an odd-length cycle, and then how many ways we can do it.  We're assuming no shenanigans like self-loops or duplicate edges.\n\nThe core idea here is that a graph has an odd cycle *if and only if* it's not bipartite. If we already *have* an odd cycle, the answer's trivial: no extra edges needed (t=0), and there's only one way to do it (w=1). We can spot this easily by 2-coloring each connected component – if we find an edge where both ends get the same color, bam, odd cycle. We can stop immediately if this is true.\n\nIf the graph *is* bipartite, all components are also bipartite. We'll need to figure out how to force that odd cycle. This hinges on adding edges that break the bipartite nature.\n\nWe'll run through some cases:\n\n*   **t = 0:**  See if an odd cycle is already present. Do this by checking if the graph is bipartite.\n\n*   **t = 1:** We *need* just one edge. This one edge must connect vertices within the *same* connected component and, when 2-colored, have the same color. If this is the case, the number of ways, `w`, is calculated by summing up the number of pairs of same-colored vertices (that aren't already connected) across *all* connected components.\n\n    To figure this count, we have to look at each bipartite connected component (call it `C`). Perform a 2-coloring. Let's say one partition has `N_U` nodes, and the other has `N_V` nodes. The number of ways to add that single edge is `N_U * (N_U - 1) / 2` + `N_V * (N_V - 1) / 2`. We add this result for all components.\n\n*   **t = 2:**  If t=1 isn't possible (all components are *still* bipartite), this means that for *every* connected component, we only have single vertices or single edges. We'll need to add *two* edges. To get a cycle, we'll need three nodes. If we add an edge between two isolated nodes or to an existing edge, we'll need to find a way to complete a cycle with just one more edge.\n\n*   Here's the trick: We have components of either isolated vertices, or edges. So, add an edge from a vertex to another in a different component.\n*   We'll use two edges from two separate components.\n\n*   If all components are isolated vertices, choose any three isolated vertices (count ways using combinations).\n*   If we have `K_2` components (edges), add one edge from each existing edge to an isolated vertex.\n*   If we have 2 or more edges, we have multiple ways.\n*   When finding two edges, we add two non-existing edges from the edges.\n\n*   **t = 3:** If we still don't have an odd cycle (and t=0, 1, and 2 fail), the graph is essentially disconnected and all components are isolated.  To force an odd cycle, we need to pick *three* of those isolated vertices and make a triangle (add edges between all of them).\n\n**Implementation**\n\nI'll use an adjacency list (`adj`) to represent the graph. During traversal, I'll flag each component as visited (`visited`) and color it (`color`) during the BFS/DFS step. I'll maintain a list of partitions (`bipartite_components_info`), storing the count of nodes in each partition of bipartite components. `is_bipartite_component_found_odd_cycle` can be set when we find a conflict in the bipartite check. The code calculates edges by checking the number of vertices and existing edges (`N_0`, `N_1`).\n",
    "response": "The problem asks us to find the minimum number of edges `t` to add to a given undirected graph to form a simple odd-length cycle, and `w`, the number of ways to do so. The graph can be disconnected, has no loops or parallel edges, and we cannot add loops or parallel edges.\n\nA key property of graphs is that a graph contains an odd-length cycle if and only if it is not bipartite. If a graph is bipartite, its vertices can be divided into two disjoint sets (partitions), say `U` and `V`, such that every edge connects a vertex in `U` to one in `V`. An odd cycle requires at least one edge to connect two vertices within the same partition.\n\nWe can solve this by checking for `t=0, 1, 2, 3` in increasing order.\n\n**1. Check for `t = 0` (Odd cycle already exists):**\nWe can determine if the graph contains an odd cycle by attempting to 2-color its connected components. For each unvisited vertex, start a Breadth-First Search (BFS) or Depth-First Search (DFS) and assign it a color (e.g., 0). All its neighbors get the opposite color (1). When visiting a neighbor `v` of `u`:\n- If `v` is unvisited, color `v` with `1 - color[u]` and add it to the queue/stack.\n- If `v` is visited and `color[v] == color[u]`, then we have found an edge connecting two vertices of the same color, which implies an odd cycle exists.\nIf an odd cycle is found in any component, `t = 0` and `w = 1`.\n\nDuring this 2-coloring process, for each connected component that *is* bipartite, we also count the number of vertices in each partition set, say `N_U` and `N_V`. We'll need these counts for `t=1`.\n\n**2. Check for `t = 1` (Add one edge to form an odd cycle):**\nIf no odd cycle exists (all components are bipartite), we need to add at least one edge.\nTo form an odd cycle by adding a single edge `(u, v)`, `u` and `v` must be in the same connected component, and they must have the same color in that component's 2-coloring. Adding `(u, v)` creates an odd cycle if `(u, v)` is not an existing edge. Since all existing edges connect vertices of different colors in a bipartite graph, any added edge between same-colored vertices will be new.\nFor each bipartite component with partition sizes `N_U` and `N_V`:\n- The number of pairs of vertices in `U` that can be connected is `N_U * (N_U - 1) / 2`.\n- The number of pairs of vertices in `V` that can be connected is `N_V * (N_V - 1) / 2`.\nSumming these counts over all bipartite components gives the total number of ways `w` to add one edge to form an odd cycle.\nIf `w > 0`, then `t = 1`.\n\n**3. Check for `t = 2` (Add two edges to form an odd cycle):**\nIf `t=0` and `t=1` both fail, it means all connected components are bipartite, and for every component, `N_U * (N_U - 1) / 2 + N_V * (N_V - 1) / 2 = 0`. This implies that for every component, `N_U <= 1` and `N_V <= 1`.\nTherefore, every connected component must be either:\n- An isolated vertex (`K_1`): `N_U=1, N_V=0` or `N_U=0, N_V=1`.\n- A single edge (`K_2`): `N_U=1, N_V=1`.\n\nLet `N_0` be the total count of isolated vertices and `N_1` be the total count of existing edges (which form `K_2` components).\nWe can form an odd cycle (specifically, a `K_3` or triangle) by adding two edges in two scenarios:\n- **Scenario A: Connect an existing edge to an isolated vertex.**\n  Pick an existing edge `(u, v)` (from a `K_2` component) and an isolated vertex `w` (from a `K_1` component). Add edges `(u, w)` and `(v, w)`. This forms a `u-v-w-u` cycle of length 3.\n  The number of ways for this is `N_1 * N_0`. This is possible if `N_1 > 0` and `N_0 > 0`.\n- **Scenario B: Connect two existing edges.**\n  Pick two distinct existing edges `(u_1, v_1)` and `(u_2, v_2)` (from two distinct `K_2` components).\n  Choose one vertex from the first edge (e.g., `u_1`) and connect it to both vertices of the second edge (`u_2`, `v_2`). Add edges `(u_1, u_2)` and `(u_1, v_2)`. This forms a `u_1-u_2-v_2-u_1` cycle of length 3.\n  There are `N_1` choices for the first edge, `N_1-1` for the second. For each pair of edges, there are 4 ways to choose which vertex from which edge to connect to the other two vertices (e.g., `u_1` to `u_2, v_2`; `v_1` to `u_2, v_2`; `u_2` to `u_1, v_1`; `v_2` to `u_1, v_1`).\n  The number of ways for this is `N_1 * (N_1 - 1) * 2`. (This is equivalent to `(N_1 choose 2) * 4`). This is possible if `N_1 >= 2`.\n\nThe total `w` for `t=2` is the sum of ways from Scenario A and Scenario B.\nIf `w > 0`, then `t = 2`.\n\n**4. Check for `t = 3` (Add three edges to form an odd cycle):**\nIf `t=0, 1, 2` all fail, it implies:\n- `N_0 = 0` or `N_1 = 0` (for Scenario A to fail).\n- `N_1 < 2` (for Scenario B to fail).\nCombining these, it means either:\n- `N_1 = 0`: All vertices are isolated. In this case, `N_0 = n`.\n  To form an odd cycle (a `K_3`), we need to pick three distinct isolated vertices, say `v_1, v_2, v_3`, and add edges `(v_1, v_2), (v_2, v_3), (v_3, v_1)`. This requires `t=3` edges.\n  The number of ways is `N_0 choose 3 = N_0 * (N_0 - 1) * (N_0 - 2) / 6`. This is possible if `N_0 >= 3`.\n- `N_1 = 1` and `N_0 = 0`: The graph consists of a single edge `(u, v)` and no other vertices. `n=2`. It's impossible to form an odd cycle (which requires at least 3 vertices). The problem constraints imply `n >= 1`, but an odd cycle requires `n >= 3`. If `n < 3`, no odd cycle can be formed. The problem statement implies an answer will always be found.\n  If `n < 3`, no cycle is possible, so `t` cannot be found. However, given the examples, it implies `n >= 3` for a solution to exist. For `n=3, m=0` (Example 3), `N_0=3, N_1=0`, so `t=3, w=1`.\n\nSo, if `t=0, 1, 2` fail, we must have `N_1 = 0` and `N_0 >= 3`. Then `t=3` and `w = N_0 * (N_0 - 1) * (N_0 - 2) / 6`.\n\n**Final Algorithm Steps:**\n1. Initialize adjacency list `adj`, `visited` array (all `False`), `color` array (all `-1`).\n2. Set `found_odd_cycle_t0 = False`.\n3. Initialize `bipartite_components_info = []` (to store `(N_U, N_V)` for each bipartite component).\n4. Iterate `i` from `1` to `n`:\n   If `i` is not `visited`:\n     Perform a BFS/DFS starting from `i` to find its connected component:\n       - Keep track of `current_comp_U_count` and `current_comp_V_count`.\n       - Set `is_current_comp_bipartite = True`.\n       - During traversal, if `visited[v]` and `color[v] == color[u]`, set `is_current_comp_bipartite = False` and `found_odd_cycle_t0 = True`.\n     If `is_current_comp_bipartite`:\n       `bipartite_components_info.append((current_comp_U_count, current_comp_V_count))`\n5. If `found_odd_cycle_t0` is `True`: Print `0 1`.\n6. Else (all components are bipartite):\n   Calculate `ways_t1 = 0`.\n   For `(N_U, N_V)` in `bipartite_components_info`:\n     `ways_t1 += N_U * (N_U - 1) // 2`\n     `ways_t1 += N_V * (N_V - 1) // 2`\n   If `ways_t1 > 0`: Print `1 ways_t1`.\n   Else (no `t=1` ways):\n     Calculate `N_0 = 0`, `N_1 = 0`.\n     For `(N_U, N_V)` in `bipartite_components_info`:\n       If `N_U == 1` and `N_V == 0`: `N_0 += 1`\n       Else if `N_U == 0` and `N_V == 1`: `N_0 += 1`\n       Else if `N_U == 1` and `N_V == 1`: `N_1 += 1`\n     Calculate `ways_t2 = 0`.\n     If `N_0 > 0` and `N_1 > 0`: `ways_t2 += N_0 * N_1`\n     If `N_1 >= 2`: `ways_t2 += 2 * N_1 * (N_1 - 1)`\n     If `ways_t2 > 0`: Print `2 ways_t2`.\n     Else (no `t=2` ways):\n       // Must be `N_1 = 0` and `N_0 >= 3` for a cycle to be possible.\n       Print `3 (N_0 * (N_0 - 1) * (N_0 - 2) // 6)`.\n\n```python\nimport sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n\n    visited = [False] * (n + 1)\n    color = [-1] * (n + 1) # 0 or 1\n    \n    found_odd_cycle_t0 = False\n    bipartite_components_info = [] # Stores (N_U, N_V) for each bipartite component\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            q = deque()\n            q.append(i)\n            visited[i] = True\n            color[i] = 0\n            \n            current_comp_U_count = 0\n            current_comp_V_count = 0\n            is_current_comp_bipartite = True\n            \n            component_nodes_in_bfs = 0 # To count nodes in current component\n\n            # BFS for 2-coloring and component info\n            head = 0\n            bfs_q_list = [(i, 0)] # (node, color)\n            \n            while head < len(bfs_q_list):\n                u, c_u = bfs_q_list[head]\n                head += 1\n                \n                component_nodes_in_bfs += 1\n\n                if c_u == 0:\n                    current_comp_U_count += 1\n                else:\n                    current_comp_V_count += 1\n\n                for v in adj[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        color[v] = 1 - c_u\n                        bfs_q_list.append((v, color[v]))\n                    elif color[v] == c_u:\n                        is_current_comp_bipartite = False\n                        found_odd_cycle_t0 = True\n            \n            if is_current_comp_bipartite:\n                bipartite_components_info.append((current_comp_U_count, current_comp_V_count))\n\n    # Case t = 0\n    if found_odd_cycle_t0:\n        print(\"0 1\")\n        return\n\n    # Case t = 1\n    ways_t1 = 0\n    for nu, nv in bipartite_components_info:\n        ways_t1 += nu * (nu - 1) // 2\n        ways_t1 += nv * (nv - 1) // 2\n    \n    if ways_t1 > 0:\n        print(f\"1 {ways_t1}\")\n        return\n\n    # Case t = 2 (if t=0 and t=1 failed)\n    # At this point, all components are K_1 or K_2\n    N_0 = 0 # count of isolated vertices (K_1 components)\n    N_1 = 0 # count of existing edges (K_2 components)\n\n    for nu, nv in bipartite_components_info:\n        if nu == 1 and nv == 0: # Isolated vertex\n            N_0 += 1\n        elif nu == 0 and nv == 1: # Isolated vertex\n            N_0 += 1\n        elif nu == 1 and nv == 1: # Single edge\n            N_1 += 1\n        # No other cases possible if t=1 failed, as it implies nu<=1 and nv<=1\n\n    ways_t2 = 0\n    # Scenario A: Pick an existing edge (K_2) and an isolated vertex (K_1)\n    # Connect the isolated vertex to both ends of the edge to form a K_3.\n    if N_0 > 0 and N_1 > 0:\n        ways_t2 += N_0 * N_1\n    \n    # Scenario B: Pick two existing edges (K_2, K_2)\n    # Pick one vertex from the first edge and connect it to both vertices of the second edge to form a K_3.\n    if N_1 >= 2:\n        # N_1 choices for the first edge, N_1-1 for the second.\n        # For each pair of edges, 2 ways to pick a vertex from the first edge, and 2 ways to pick a vertex from the second edge.\n        # This is (N_1 * (N_1 - 1) / 2) * 4 = 2 * N_1 * (N_1 - 1)\n        ways_t2 += 2 * N_1 * (N_1 - 1)\n\n    if ways_t2 > 0:\n        print(f\"2 {ways_t2}\")\n        return\n\n    # Case t = 3 (if t=0, t=1, t=2 all failed)\n    # This implies N_1 = 0 (no existing edges) and N_0 >= 3 (at least 3 isolated vertices)\n    # We need to pick 3 isolated vertices and connect them into a K_3.\n    # The number of ways is N_0 choose 3.\n    ways_t3 = N_0 * (N_0 - 1) * (N_0 - 2) // 6\n    print(f\"3 {ways_t3}\")\n    \nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n\n    visited = [False] * (n + 1)\n    color = [-1] * (n + 1) # 0 or 1\n    \n    found_odd_cycle_t0 = False\n    bipartite_components_info = [] # Stores (N_U, N_V) for each bipartite component\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            q = deque()\n            q.append(i)\n            visited[i] = True\n            color[i] = 0\n            \n            current_comp_U_count = 0\n            current_comp_V_count = 0\n            is_current_comp_bipartite = True\n            \n            component_nodes_in_bfs = 0 # To count nodes in current component\n\n            # BFS for 2-coloring and component info\n            head = 0\n            bfs_q_list = [(i, 0)] # (node, color)\n            \n            while head < len(bfs_q_list):\n                u, c_u = bfs_q_list[head]\n                head += 1\n                \n                component_nodes_in_bfs += 1\n\n                if c_u == 0:\n                    current_comp_U_count += 1\n                else:\n                    current_comp_V_count += 1\n\n                for v in adj[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        color[v] = 1 - c_u\n                        bfs_q_list.append((v, color[v]))\n                    elif color[v] == c_u:\n                        is_current_comp_bipartite = False\n                        found_odd_cycle_t0 = True\n            \n            if is_current_comp_bipartite:\n                bipartite_components_info.append((current_comp_U_count, current_comp_V_count))\n\n    # Case t = 0\n    if found_odd_cycle_t0:\n        print(\"0 1\")\n        return\n\n    # Case t = 1\n    ways_t1 = 0\n    for nu, nv in bipartite_components_info:\n        ways_t1 += nu * (nu - 1) // 2\n        ways_t1 += nv * (nv - 1) // 2\n    \n    if ways_t1 > 0:\n        print(f\"1 {ways_t1}\")\n        return\n\n    # Case t = 2 (if t=0 and t=1 failed)\n    # At this point, all components are K_1 or K_2\n    N_0 = 0 # count of isolated vertices (K_1 components)\n    N_1 = 0 # count of existing edges (K_2 components)\n\n    for nu, nv in bipartite_components_info:\n        if nu == 1 and nv == 0: # Isolated vertex\n            N_0 += 1\n        elif nu == 0 and nv == 1: # Isolated vertex\n            N_0 += 1\n        elif nu == 1 and nv == 1: # Single edge\n            N_1 += 1\n        # No other cases possible if t=1 failed, as it implies nu<=1 and nv<=1\n\n    ways_t2 = 0\n    # Scenario A: Pick an existing edge (K_2) and an isolated vertex (K_1)\n    # Connect the isolated vertex to both ends of the edge to form a K_3.\n    if N_0 > 0 and N_1 > 0:\n        ways_t2 += N_0 * N_1\n    \n    # Scenario B: Pick two existing edges (K_2, K_2)\n    # Pick one vertex from the first edge and connect it to both vertices of the second edge to form a K_3.\n    if N_1 >= 2:\n        # N_1 choices for the first edge, N_1-1 for the second.\n        # For each pair of edges, 2 ways to pick a vertex from the first edge, and 2 ways to pick a vertex from the second edge.\n        # This is (N_1 * (N_1 - 1) / 2) * 4 = 2 * N_1 * (N_1 - 1)\n        ways_t2 += 2 * N_1 * (N_1 - 1)\n\n    if ways_t2 > 0:\n        print(f\"2 {ways_t2}\")\n        return\n\n    # Case t = 3 (if t=0, t=1, t=2 all failed)\n    # This implies N_1 = 0 (no existing edges) and N_0 >= 3 (at least 3 isolated vertices)\n    # We need to pick 3 isolated vertices and connect them into a K_3.\n    # The number of ways is N_0 choose 3.\n    ways_t3 = N_0 * (N_0 - 1) * (N_0 - 2) // 6\n    print(f\"3 {ways_t3}\")\n    \nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 604,
        "completion_token_count": 3920,
        "thoughts_token_count": 8193
    }
}