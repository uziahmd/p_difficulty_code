{
    "start": 1758009280.8851736,
    "end": 1758009329.759764,
    "start-formatted": "2025-09-16 16:54 KST",
    "end-formatted": "2025-09-16 16:55 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "**Thinking Through This Competitive Programming Problem**\n\nOkay, so I've got this problem. The goal is to find two separate vouchers where their durations add up to a specific value, `x`, while minimizing the total cost of those two vouchers. If I can't find a pair that meets the criteria, I need to output -1.\n\nFirst, I need to understand the inputs: I'm given `n` vouchers, the target duration `x`, and the details for each voucher – the start and end dates (`l_i`, `r_i`) and the cost (`cost_i`). The constraints on the inputs are pretty tight, so I need to think carefully about efficiency. A naive approach of checking every possible pair is going to be far too slow, it'll be O(n^2), and that just won't cut it. I'm aiming for something around O(n log n) or maybe even O(n).\n\nLooking at the conditions, I need to make sure the vouchers are *disjoint*, meaning their date ranges don't overlap. That's key. Also, their combined duration must equal `x`, and the sum of their costs should be as low as possible.\n\nI'm thinking I can approach this by fixing one voucher and then efficiently searching for a suitable second voucher. Let's say I fix voucher `i`.  Its duration is simply `r_i - l_i + 1`. Now, I'm looking for a voucher `j` such that the duration of `j` is `x` minus the duration of `i`, that they are disjoint and the cost `cost_j` is minimized.\n\nThe disjoint condition is a bit awkward: either `r_i < l_j` or `r_j < l_i`. It seems logical to try processing the vouchers in some sorted order. Maybe sorting by start or end dates would help in identifying disjoint pairs. If I process them by `r_i`, when I'm at voucher `i`, then I'm interested in finding a voucher `j` that *starts after* `r_i`. And that hints towards potentially using a data structure or an indexed approach. The values of `l_i` and `r_i` go up to 2 * 10^5, so maybe an array or a segment tree indexed by day is worth exploring. I'll need to figure out how to efficiently find the optimal `j` for each fixed `i`. It looks like finding the minimal cost disjoint voucher might become the core challenge.\n",
    "response": "```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    vouchers = []\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        vouchers.append((l, r, cost))\n\n    # Sort vouchers by their start day (l_i)\n    vouchers.sort()\n\n    # max_day_coord is the maximum possible value for l_i or r_i\n    # It's given as 2 * 10^5 in problem constraints.\n    max_day_coord = 2 * 10**5\n\n    # min_cost_for_duration[duration][end_day] stores the minimum cost\n    # of a voucher with given duration ending on or before end_day.\n    # We use a 1-indexed array for days, so size max_day_coord + 1.\n    # Initialize with infinity.\n    # min_cost_for_duration[d][k] = min cost of voucher with duration d, ending at k\n    # Initialize with a large value (infinity)\n    min_cost_at_end_day = [{} for _ in range(max_day_coord + 1)] # Stores {duration: min_cost} for vouchers ending at this day\n    \n    # This array will store the minimum cost for a voucher of a specific duration\n    # that ends at or before a given day.\n    # min_cost_prefix_sum_by_duration[duration][day] = min cost of a voucher with duration 'duration'\n    # that ends on or before 'day'.\n    # This is effectively a 2D array (duration x day).\n    # Since duration can be up to max_day_coord, and day also up to max_day_coord,\n    # a direct 2D array would be too large (2e5 * 2e5).\n    # Instead, we will compute this on the fly or use a more dynamic approach.\n\n    # Let's use a different approach for storing minimum costs for durations.\n    # For each possible duration `d`, we need to find the minimum cost of a voucher\n    # with that duration that ends by a certain day `k`.\n    # We can use an array `min_cost_duration_ending_at_k[duration]` for each `k`.\n    # This is still too much memory.\n\n    # The actual approach will be to iterate through days.\n    # For each day `k`, we maintain `min_cost_for_duration[d]` which stores the\n    # minimum cost of a voucher of duration `d` that ends *exactly* at day `k`.\n    # Then, when we consider a voucher `(l, r, cost)`, we need to query\n    # for vouchers `(l', r', cost')` such that `r' < l` and `r' - l' + 1 = x - (r - l + 1)`.\n\n    # Let's re-think the DP state.\n    # `min_cost_ending_at[d][k]` = minimum cost of a voucher with duration `d` that ends at day `k`.\n    # Initialize with infinity.\n    # `min_cost_ending_at` will be a list of dictionaries.\n    # `min_cost_ending_at[k]` will be a dictionary mapping `duration` to `min_cost`.\n    min_cost_ending_at = [{} for _ in range(max_day_coord + 1)]\n\n    # `min_cost_prefix_duration[d][k]` = minimum cost of a voucher with duration `d` that ends on or before day `k`.\n    # This is what we need to query.\n    # We can compute this iteratively.\n    # `min_cost_prefix_duration[d][k] = min(min_cost_prefix_duration[d][k-1], min_cost_ending_at[k][d])`\n    # This still requires storing a lot of state.\n\n    # A better approach for the \"query\" part:\n    # Iterate through vouchers. For each voucher `(l, r, cost)`:\n    # 1. Calculate its duration `d = r - l + 1`.\n    # 2. Required duration for the second voucher `d_req = x - d`.\n    # 3. If `d_req <= 0`, this voucher cannot be part of a pair summing to `x`. Skip.\n    # 4. We need a voucher that ends before `l` (i.e., `r' < l`) and has duration `d_req`.\n    #    We need the minimum cost `cost'` for such a voucher.\n    # 5. Update `min_cost_ending_at[r][d]` with `cost`.\n    #    This means, for day `r`, we have a voucher of duration `d` with cost `cost`.\n    #    We only keep the minimum cost for a given `(r, d)` pair.\n\n    # To optimize step 4, we need a data structure that, given `d_req` and `l`, can query\n    # `min_{cost'} (cost' | voucher (l', r', cost') has duration d_req and r' < l)`.\n    # This is a range minimum query on costs, filtered by duration and end day.\n\n    # Let's use an array `min_cost_for_duration_ending_before_day[duration]`\n    # This array will store the minimum cost for each duration.\n    # When we process vouchers sorted by `l_i`, we can maintain this array.\n\n    # `duration_min_costs[d]` will store the minimum cost found so far for a voucher of duration `d`.\n    # Initialize with infinity.\n    duration_min_costs = {} # Maps duration -> min_cost\n\n    # `min_cost_for_prev_vouchers[day][duration]`\n    # This will be a dictionary mapping `day` to another dictionary `duration -> min_cost`.\n    # This stores the minimum cost of a voucher with a specific duration that ends *on* that `day`.\n    # We use a list of dictionaries for `min_cost_by_end_day`, where index is the end day.\n    # `min_cost_by_end_day[r]` is a dictionary `duration -> min_cost`.\n    min_cost_by_end_day = [{} for _ in range(max_day_coord + 1)]\n\n    min_total_cost = float('inf')\n\n    # Iterate through days from 1 to max_day_coord.\n    # This is the \"sweep-line\" approach.\n    # We need to group vouchers by their start day `l`.\n    # Let's create `vouchers_by_start_day[l]` which is a list of `(r, cost)` for that `l`.\n    vouchers_by_start_day = [[] for _ in range(max_day_coord + 1)]\n    for l, r, cost in vouchers:\n        vouchers_by_start_day[l].append((r, cost))\n\n    # `current_min_cost_for_duration[d]` stores the minimum cost of a voucher with duration `d`\n    # that has been processed so far (i.e., its `r` is less than the current `l` being considered).\n    # Initialize with infinity.\n    # This map needs to be updated.\n    # The actual state we need is `min_cost_for_duration_ending_before_current_l[duration]`.\n    # This is what `duration_min_costs` was intended to be.\n\n    # `min_cost_for_duration_ending_before_day[d]` stores the minimum cost of a voucher with duration `d`\n    # that has an `r` value strictly less than the current day `k` in the sweep.\n    # This needs to be a list of size `x`.\n    # We can use an array `min_cost_duration_so_far` where `min_cost_duration_so_far[d]`\n    # is the minimum cost of a voucher of duration `d` that has *already ended*.\n    # The maximum possible duration is `max_day_coord`.\n    min_cost_duration_so_far = [float('inf')] * (max_day_coord + 1)\n\n    # The sweep line will go from day 1 to max_day_coord.\n    # `k` represents the current day being processed.\n    # When `k` is `l_i`, we consider vouchers starting at `l_i`.\n    # When `k` is `r_i`, we consider vouchers ending at `r_i`.\n\n    # Let's sort all vouchers by their `l_i` first.\n    # The `vouchers` list is already sorted by `l_i`.\n\n    for l, r, cost in vouchers:\n        duration = r - l + 1\n\n        # Part 1: Try to find a previous voucher `j` for current voucher `i` (l,r,cost)\n        # We need `j` such that `r_j < l_i` and `duration_j == x - duration_i`.\n        # `min_cost_duration_so_far[d]` stores the min cost of a voucher of duration `d`\n        # that has already finished (its `r` is less than or equal to the current `l`).\n        # But we need `r_j < l_i`.\n        # The `min_cost_duration_so_far` needs to be updated for each day.\n\n        # Let's iterate through days `k` from 1 to `max_day_coord`.\n        # At each day `k`, we first process all vouchers `(l, r, cost)` such that `r = k-1`.\n        # These vouchers are now \"finished\" and can be paired with any voucher starting at `k` or later.\n        # Then, we process all vouchers `(l, r, cost)` such that `l = k`.\n        # For each such voucher, we try to find a pair.\n\n    # This requires a more explicit sweep-line approach.\n    # `events` list: `(day, type, voucher_index)`\n    # type 0: end of a voucher\n    # type 1: start of a voucher\n    # This is getting complicated.\n\n    # Let's stick to iterating through the sorted vouchers.\n    # We need `min_cost_for_duration[d]` to store the minimum cost of a voucher of duration `d`\n    # that *ends before* the current voucher's `l`.\n    # This `min_cost_for_duration` array needs to be updated based on the `r` values of vouchers.\n\n    # `min_cost_duration_ending_at_or_before_day[day][duration]`\n    # This is the core issue.\n    # We need to maintain `min_cost_for_duration[d]` for all `d`\n    # such that `r_prev < l_current`.\n\n    # Let's define `dp[d]` as the minimum cost of a voucher with duration `d`\n    # that has ended *before the current day we are considering*.\n    # Initialize `dp = [infinity] * (max_day_coord + 1)`.\n\n    # We need to process vouchers sorted by `l_i`.\n    # As we iterate through `l` from 1 to `max_day_coord`:\n    # 1. Update `dp` with vouchers that ended at `l-1`.\n    # 2. For each voucher `(l, r, cost)` starting at `l`:\n    #    a. Calculate `duration = r - l + 1`.\n    #    b. Calculate `required_duration = x - duration`.\n    #    c. If `required_duration > 0` and `required_duration <= max_day_coord`:\n    #       Check `dp[required_duration]`. If it's not infinity, we found a potential pair.\n    #       `min_total_cost = min(min_total_cost, cost + dp[required_duration])`.\n    #    d. Add `(r, duration, cost)` to a temporary list `vouchers_ending_at_l`.\n    #\n    # After iterating through all vouchers starting at `l`, update `dp` based on `vouchers_ending_at_l`.\n    # This is still not quite right. `dp[d]` should be `min cost of a voucher of duration d that has ended at or before current_day - 1`.\n\n    # Let's use an array `min_cost_for_duration_ending_before[duration]`.\n    # This array will be updated as we iterate through days.\n    # `min_cost_for_duration_ending_before[d]` = min cost of a voucher with duration `d`\n    # that ends strictly before the current `l` we are processing.\n    \n    # max_possible_duration = max_day_coord (2 * 10^5)\n    # The array `min_cost_for_duration_ending_before` needs to be indexed by duration.\n    # Let's use `min_cost_d_before_l[duration]`\n    min_cost_d_before_l = [float('inf')] * (max_day_coord + 1)\n\n    # `vouchers_ending_on_day[day]` stores a list of `(duration, cost)` for vouchers ending on `day`.\n    vouchers_ending_on_day = [[] for _ in range(max_day_coord + 1)]\n\n    # Iterate through the vouchers sorted by `l_i`.\n    # This means we process vouchers in increasing order of their start days.\n    current_voucher_idx = 0\n    \n    # We need to iterate through days from 1 to max_day_coord.\n    # For each day `current_day`:\n    # 1. Update `min_cost_d_before_l` with vouchers that ended on `current_day - 1`.\n    # 2. Process all vouchers that start on `current_day`.\n    \n    # It's more efficient to iterate through the sorted `vouchers` array directly.\n    # We need to manage `min_cost_d_before_l` as we go.\n    # The key is that `min_cost_d_before_l` should reflect all vouchers\n    # that have `r_j < l_i` for the current voucher `i`.\n\n    # Let's use a sweep-line on `l_i`.\n    # `min_cost_ending_at_day[day]` stores `min_cost` for vouchers ending at `day`.\n    # For a fixed `duration_val`, `min_cost_ending_at_day[day][duration_val]` is the min cost.\n    # This is still too much memory.\n    \n    # The correct way is to use a sparse data structure or iterate carefully.\n    # Let's try iterating through `l` from 1 to `max_day_coord`.\n    # `min_cost_for_duration[d]` stores the minimum cost of a voucher with duration `d`\n    # that has ended *before* the current day `k`.\n    \n    # Initialize `min_cost_for_duration` for all possible durations.\n    # The maximum duration is `max_day_coord`.\n    min_cost_for_duration = [float('inf')] * (max_day_coord + 1)\n    \n    # Group vouchers by their start day `l`.\n    vouchers_by_l = [[] for _ in range(max_day_coord + 1)]\n    for l, r, cost in vouchers:\n        vouchers_by_l[l].append((r, cost))\n    \n    # Group vouchers by their end day `r`.\n    vouchers_by_r = [[] for _ in range(max_day_coord + 1)]\n    for l, r, cost in vouchers:\n        vouchers_by_r[r].append((l, cost))\n\n    min_total_cost = float('inf')\n\n    # Sweep line from day 1 to max_day_coord.\n    # `current_day` represents the start day `l` of vouchers we are considering.\n    for current_day in range(1, max_day_coord + 1):\n        # Step 1: Update `min_cost_for_duration` with vouchers that ended on `current_day - 1`.\n        # These vouchers are now available to be paired with any voucher starting at `current_day` or later.\n        if current_day > 1:\n            for l_prev, cost_prev in vouchers_by_r[current_day - 1]:\n                duration_prev = (current_day - 1) - l_prev + 1\n                min_cost_for_duration[duration_prev] = min(min_cost_for_duration[duration_prev], cost_prev)\n\n        # Step 2: For all vouchers starting on `current_day`, try to find a pair.\n        for r_curr, cost_curr in vouchers_by_l[current_day]:\n            duration_curr = r_curr - current_day + 1\n            \n            required_duration = x - duration_curr\n            \n            if 1 <= required_duration <= max_day_coord:\n                if min_cost_for_duration[required_duration] != float('inf'):\n                    min_total_cost = min(min_total_cost, cost_curr + min_cost_for_duration[required_duration])\n\n    if min_total_cost == float('inf'):\n        sys.stdout.write(\"-1\\n\")\n    else:\n        sys.stdout.write(str(min_total_cost) + \"\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    vouchers = []\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        vouchers.append((l, r, cost))\n\n    # Sort vouchers by their start day (l_i)\n    vouchers.sort()\n\n    # max_day_coord is the maximum possible value for l_i or r_i\n    # It's given as 2 * 10^5 in problem constraints.\n    max_day_coord = 2 * 10**5\n\n    # min_cost_for_duration[duration][end_day] stores the minimum cost\n    # of a voucher with given duration ending on or before end_day.\n    # We use a 1-indexed array for days, so size max_day_coord + 1.\n    # Initialize with infinity.\n    # min_cost_for_duration[d][k] = min cost of voucher with duration d, ending at k\n    # Initialize with a large value (infinity)\n    min_cost_at_end_day = [{} for _ in range(max_day_coord + 1)] # Stores {duration: min_cost} for vouchers ending at this day\n    \n    # This array will store the minimum cost for a voucher of a specific duration\n    # that ends at or before a given day.\n    # min_cost_prefix_sum_by_duration[duration][day] = min cost of a voucher with duration 'duration'\n    # that ends on or before 'day'.\n    # This is effectively a 2D array (duration x day).\n    # Since duration can be up to max_day_coord, and day also up to max_day_coord,\n    # a direct 2D array would be too large (2e5 * 2e5).\n    # Instead, we will compute this on the fly or use a more dynamic approach.\n\n    # Let's use a different approach for storing minimum costs for durations.\n    # For each possible duration `d`, we need to find the minimum cost of a voucher\n    # with that duration that ends by a certain day `k`.\n    # We can use an array `min_cost_duration_ending_at_k[duration]` for each `k`.\n    # This is still too much memory.\n\n    # The actual approach will be to iterate through days.\n    # For each day `k`, we maintain `min_cost_for_duration[d]` which stores the\n    # minimum cost of a voucher of duration `d` that ends *exactly* at day `k`.\n    # Then, when we consider a voucher `(l, r, cost)`, we need to query\n    # for vouchers `(l', r', cost')` such that `r' < l` and `r' - l' + 1 = x - (r - l + 1)`.\n\n    # Let's re-think the DP state.\n    # `min_cost_ending_at[d][k]` = minimum cost of a voucher with duration `d` that ends at day `k`.\n    # Initialize with infinity.\n    # `min_cost_ending_at` will be a list of dictionaries.\n    # `min_cost_ending_at[k]` will be a dictionary mapping `duration` to `min_cost`.\n    min_cost_ending_at = [{} for _ in range(max_day_coord + 1)]\n\n    # `min_cost_prefix_duration[d][k]` = minimum cost of a voucher with duration `d` that ends on or before day `k`.\n    # This is what we need to query.\n    # We can compute this iteratively.\n    # `min_cost_prefix_duration[d][k] = min(min_cost_prefix_duration[d][k-1], min_cost_ending_at[k][d])`\n    # This still requires storing a lot of state.\n\n    # A better approach for the \"query\" part:\n    # Iterate through vouchers. For each voucher `(l, r, cost)`:\n    # 1. Calculate its duration `d = r - l + 1`.\n    # 2. Required duration for the second voucher `d_req = x - d`.\n    # 3. If `d_req <= 0`, this voucher cannot be part of a pair summing to `x`. Skip.\n    # 4. We need a voucher that ends before `l` (i.e., `r' < l`) and has duration `d_req`.\n    #    We need the minimum cost `cost'` for such a voucher.\n    # 5. Update `min_cost_ending_at[r][d]` with `cost`.\n    #    This means, for day `r`, we have a voucher of duration `d` with cost `cost`.\n    #    We only keep the minimum cost for a given `(r, d)` pair.\n\n    # To optimize step 4, we need a data structure that, given `d_req` and `l`, can query\n    # `min_{cost'} (cost' | voucher (l', r', cost') has duration d_req and r' < l)`.\n    # This is a range minimum query on costs, filtered by duration and end day.\n\n    # Let's use an array `min_cost_for_duration_ending_before_day[duration]`\n    # This array will store the minimum cost for each duration.\n    # When we process vouchers sorted by `l_i`, we can maintain this array.\n\n    # `duration_min_costs[d]` will store the minimum cost found so far for a voucher of duration `d`.\n    # Initialize with infinity.\n    duration_min_costs = {} # Maps duration -> min_cost\n\n    # `min_cost_for_prev_vouchers[day][duration]`\n    # This will be a dictionary mapping `day` to another dictionary `duration -> min_cost`.\n    # This stores the minimum cost of a voucher with a specific duration that ends *on* that `day`.\n    # We use a list of dictionaries for `min_cost_by_end_day`, where index is the end day.\n    # `min_cost_by_end_day[r]` is a dictionary `duration -> min_cost`.\n    min_cost_by_end_day = [{} for _ in range(max_day_coord + 1)]\n\n    min_total_cost = float('inf')\n\n    # Iterate through days from 1 to max_day_coord.\n    # This is the \"sweep-line\" approach.\n    # We need to group vouchers by their start day `l`.\n    # Let's create `vouchers_by_start_day[l]` which is a list of `(r, cost)` for that `l`.\n    vouchers_by_start_day = [[] for _ in range(max_day_coord + 1)]\n    for l, r, cost in vouchers:\n        vouchers_by_start_day[l].append((r, cost))\n\n    # `current_min_cost_for_duration[d]` stores the minimum cost of a voucher with duration `d`\n    # that has been processed so far (i.e., its `r` is less than the current `l` being considered).\n    # Initialize with infinity.\n    # This map needs to be updated.\n    # The actual state we need is `min_cost_for_duration_ending_before_current_l[duration]`.\n    # This is what `duration_min_costs` was intended to be.\n\n    # `min_cost_for_duration_ending_before_day[d]` stores the minimum cost of a voucher with duration `d`\n    # that has an `r` value strictly less than the current day `k` in the sweep.\n    # This needs to be a list of size `x`.\n    # We can use an array `min_cost_duration_so_far` where `min_cost_duration_so_far[d]`\n    # is the minimum cost of a voucher of duration `d` that has *already ended*.\n    # The maximum possible duration is `max_day_coord`.\n    min_cost_duration_so_far = [float('inf')] * (max_day_coord + 1)\n\n    # The sweep line will go from day 1 to max_day_coord.\n    # `k` represents the current day being processed.\n    # When `k` is `l_i`, we consider vouchers starting at `l_i`.\n    # When `k` is `r_i`, we consider vouchers ending at `r_i`.\n\n    # Let's sort all vouchers by their `l_i` first.\n    # The `vouchers` list is already sorted by `l_i`.\n\n    for l, r, cost in vouchers:\n        duration = r - l + 1\n\n        # Part 1: Try to find a previous voucher `j` for current voucher `i` (l,r,cost)\n        # We need `j` such that `r_j < l_i` and `duration_j == x - duration_i`.\n        # `min_cost_duration_so_far[d]` stores the min cost of a voucher of duration `d`\n        # that has already finished (its `r` is less than or equal to the current `l`).\n        # But we need `r_j < l_i`.\n        # The `min_cost_duration_so_far` needs to be updated for each day.\n\n        # Let's iterate through days `k` from 1 to `max_day_coord`.\n        # At each day `k`, we first process all vouchers `(l, r, cost)` such that `r = k-1`.\n        # These vouchers are now \"finished\" and can be paired with any voucher starting at `k` or later.\n        # Then, we process all vouchers `(l, r, cost)` such that `l = k`.\n        # For each such voucher, we try to find a pair.\n\n    # This requires a more explicit sweep-line approach.\n    # `events` list: `(day, type, voucher_index)`\n    # type 0: end of a voucher\n    # type 1: start of a voucher\n    # This is getting complicated.\n\n    # Let's stick to iterating through the sorted vouchers.\n    # We need `min_cost_for_duration[d]` to store the minimum cost of a voucher of duration `d`\n    # that *ends before* the current voucher's `l`.\n    # This `min_cost_for_duration` array needs to be updated based on the `r` values of vouchers.\n\n    # `min_cost_duration_ending_at_or_before_day[day][duration]`\n    # This is the core issue.\n    # We need to maintain `min_cost_for_duration[d]` for all `d`\n    # such that `r_prev < l_current`.\n\n    # Let's define `dp[d]` as the minimum cost of a voucher with duration `d`\n    # that has ended *before the current day we are considering*.\n    # Initialize `dp = [infinity] * (max_day_coord + 1)`.\n\n    # We need to process vouchers sorted by `l_i`.\n    # As we iterate through `l` from 1 to `max_day_coord`:\n    # 1. Update `dp` with vouchers that ended at `l-1`.\n    # 2. For each voucher `(l, r, cost)` starting at `l`:\n    #    a. Calculate `duration = r - l + 1`.\n    #    b. Calculate `required_duration = x - duration`.\n    #    c. If `required_duration > 0` and `required_duration <= max_day_coord`:\n    #       Check `dp[required_duration]`. If it's not infinity, we found a potential pair.\n    #       `min_total_cost = min(min_total_cost, cost + dp[required_duration])`.\n    #    d. Add `(r, duration, cost)` to a temporary list `vouchers_ending_at_l`.\n    #\n    # After iterating through all vouchers starting at `l`, update `dp` based on `vouchers_ending_at_l`.\n    # This is still not quite right. `dp[d]` should be `min cost of a voucher of duration d that has ended at or before current_day - 1`.\n\n    # Let's use an array `min_cost_for_duration_ending_before[duration]`.\n    # This array will be updated as we iterate through days.\n    # `min_cost_for_duration_ending_before[d]` = min cost of a voucher with duration `d`\n    # that ends strictly before the current `l` we are processing.\n    \n    # max_possible_duration = max_day_coord (2 * 10^5)\n    # The array `min_cost_for_duration_ending_before` needs to be indexed by duration.\n    # Let's use `min_cost_d_before_l[duration]`\n    min_cost_d_before_l = [float('inf')] * (max_day_coord + 1)\n\n    # `vouchers_ending_on_day[day]` stores a list of `(duration, cost)` for vouchers ending on `day`.\n    vouchers_ending_on_day = [[] for _ in range(max_day_coord + 1)]\n\n    # Iterate through the vouchers sorted by `l_i`.\n    # This means we process vouchers in increasing order of their start days.\n    current_voucher_idx = 0\n    \n    # We need to iterate through days from 1 to max_day_coord.\n    # For each day `current_day`:\n    # 1. Update `min_cost_d_before_l` with vouchers that ended on `current_day - 1`.\n    # 2. Process all vouchers that start on `current_day`.\n    \n    # It's more efficient to iterate through the sorted `vouchers` array directly.\n    # We need to manage `min_cost_d_before_l` as we go.\n    # The key is that `min_cost_d_before_l` should reflect all vouchers\n    # that have `r_j < l_i` for the current voucher `i`.\n\n    # Let's use a sweep-line on `l_i`.\n    # `min_cost_ending_at_day[day]` stores `min_cost` for vouchers ending at `day`.\n    # For a fixed `duration_val`, `min_cost_ending_at_day[day][duration_val]` is the min cost.\n    # This is still too much memory.\n    \n    # The correct way is to use a sparse data structure or iterate carefully.\n    # Let's try iterating through `l` from 1 to `max_day_coord`.\n    # `min_cost_for_duration[d]` stores the minimum cost of a voucher with duration `d`\n    # that has ended *before* the current day `k`.\n    \n    # Initialize `min_cost_for_duration` for all possible durations.\n    # The maximum duration is `max_day_coord`.\n    min_cost_for_duration = [float('inf')] * (max_day_coord + 1)\n    \n    # Group vouchers by their start day `l`.\n    vouchers_by_l = [[] for _ in range(max_day_coord + 1)]\n    for l, r, cost in vouchers:\n        vouchers_by_l[l].append((r, cost))\n    \n    # Group vouchers by their end day `r`.\n    vouchers_by_r = [[] for _ in range(max_day_coord + 1)]\n    for l, r, cost in vouchers:\n        vouchers_by_r[r].append((l, cost))\n\n    min_total_cost = float('inf')\n\n    # Sweep line from day 1 to max_day_coord.\n    # `current_day` represents the start day `l` of vouchers we are considering.\n    for current_day in range(1, max_day_coord + 1):\n        # Step 1: Update `min_cost_for_duration` with vouchers that ended on `current_day - 1`.\n        # These vouchers are now available to be paired with any voucher starting at `current_day` or later.\n        if current_day > 1:\n            for l_prev, cost_prev in vouchers_by_r[current_day - 1]:\n                duration_prev = (current_day - 1) - l_prev + 1\n                min_cost_for_duration[duration_prev] = min(min_cost_for_duration[duration_prev], cost_prev)\n\n        # Step 2: For all vouchers starting on `current_day`, try to find a pair.\n        for r_curr, cost_curr in vouchers_by_l[current_day]:\n            duration_curr = r_curr - current_day + 1\n            \n            required_duration = x - duration_curr\n            \n            if 1 <= required_duration <= max_day_coord:\n                if min_cost_for_duration[required_duration] != float('inf'):\n                    min_total_cost = min(min_total_cost, cost_curr + min_cost_for_duration[required_duration])\n\n    if min_total_cost == float('inf'):\n        sys.stdout.write(\"-1\\n\")\n    else:\n        sys.stdout.write(str(min_total_cost) + \"\\n\")\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 798,
        "completion_token_count": 4110,
        "thoughts_token_count": 801
    }
}