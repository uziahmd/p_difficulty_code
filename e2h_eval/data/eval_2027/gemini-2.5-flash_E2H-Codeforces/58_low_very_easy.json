{
    "start": 1758284918.8095276,
    "end": 1758285009.6169574,
    "start-formatted": "2025-09-19 21:28 KST",
    "end-formatted": "2025-09-19 21:30 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "**Breaking Down the Odd Cycle Problem**\n\nOkay, so I've got this competitive programming problem and I need a Python solution. The core of it revolves around adding edges to an undirected graph to create a simple odd-length cycle. Specifically, I need to figure out the *minimum* number of edges I need to add (`t`) and then the *number of ways* (`w`) I can add those edges to get that odd cycle. The graph is defined by `n` vertices and `m` edges, and it's important to remember it might not be connected, and there are no parallel edges or self-loops to begin with, and the new edges I add must also avoid those.\n\nThe key observation here is that a graph contains an odd cycle *if and only if* it's not bipartite. That's my starting point. If the given graph *already* has an odd cycle, then `t` is simply 0, and `w` is 1 - a pretty lucky break. Detecting this is the first thing I need to do.\n\nI can check for bipartiteness using either Breadth-First Search (BFS) or Depth-First Search (DFS). The idea is to attempt a 2-coloring. I'll start with a vertex and assign it color 0. Then, all its neighbors get color 1, their neighbors get color 0, and so on. If at any point I encounter an edge where both endpoints have the same color, boom - not bipartite, and I've found my odd cycle. I think I'll go with BFS for this.\n\nSo, I'll iterate through each connected component, starting a BFS from an unvisited vertex. I'll maintain a `color` array: -1 for uncolored, 0 for color A, and 1 for color B. A `parent` array could be useful for path reconstruction, but not absolutely necessary just for the bipartiteness check.\n\n**Let's consider the possible cases:**\n\n**Case 0: Odd Cycle Already Exists**\nIf *any* connected component is not bipartite, I'm done! `t = 0` and `w = 1`.  I can determine this by the attempted 2-coloring process. A color conflict during the process signifies an odd cycle's existing presence.\n\n**Case 1: The Graph is Bipartite**\nIf everything is bipartite, I have to *create* the odd cycle by adding edges. This means connecting two vertices of the same color within a component or connecting different components in the right way.\n\nIf the graph is bipartite, I can successfully 2-color each connected component. I can represent each component `C_i` with sets `S_i0` (vertices colored 0) and `S_i1` (vertices colored 1), along with their sizes `count_0_i` and `count_1_i`.\n\nNow, how do I make that odd cycle with the *minimum* number of edges?\n\n**Option 1: t = 1 (Add One Edge)**\nIf I can add just one edge, that's ideal.  I can do this by connecting two vertices of the *same* color *within the same* connected component. For instance, in component `C_i`, if I add an edge `(u, v)` where `u` and `v` are both in `S_i0` (and `u` isn't `v`), an odd cycle is formed. This is the minimum possible edge count if I can pull it off.\n",
    "response": "The problem asks us to find the minimum number of edges `t` to add to a given undirected graph to form a simple cycle of odd length, and `w`, the number of ways to do so.\n\nA graph contains an odd cycle if and only if it is not bipartite. Our strategy will be to first check if the given graph already contains an odd cycle. If not, we determine the minimum number of edges to add to make it non-bipartite.\n\nWe can use Breadth-First Search (BFS) or Depth-First Search (DFS) to check for bipartiteness and 2-color the graph. We iterate through all vertices. If a vertex hasn't been visited, we start a BFS/DFS from it to process its connected component. During this process, we assign colors (e.g., 0 and 1) to vertices such that adjacent vertices have different colors.\n\nLet's maintain a `color` array, initialized to -1 (unvisited).\n`color[v] = 0` or `color[v] = 1`.\nWhen processing an edge `(u, v)`:\n1. If `v` is unvisited (`color[v] == -1`), assign `color[v] = 1 - color[u]` and add `v` to the queue/stack.\n2. If `v` is visited and `color[v] == color[u]`, then we have found an odd cycle. The graph is not bipartite.\n\n**Case 1: The graph already contains an odd cycle.**\nIf during our bipartiteness check, we find any edge `(u, v)` where `u` and `v` have the same color, it means the current graph already contains an odd cycle. In this case, `t = 0` and `w = 1` (there's one way: add no edges). This is the optimal solution.\n\n**Case 2: The graph is bipartite (all connected components are bipartite).**\nIf the entire graph is bipartite, we need to add edges. We want to find the minimum `t`.\n\n**Option A: Add 1 edge (`t = 1`).**\nWe can form an odd cycle by adding a single edge `(u, v)` if `u` and `v` are in the same connected component and have the same color.\nFor each connected component, after 2-coloring it, let `count_0` be the number of vertices colored 0 and `count_1` be the number of vertices colored 1.\nIf we add an edge between two distinct vertices `u, v` both colored 0, or both colored 1, this creates an odd cycle.\nThe number of ways to pick two distinct vertices of the same color within a component is `count_0 * (count_0 - 1) / 2` for color 0, and `count_1 * (count_1 - 1) / 2` for color 1.\nThe total number of ways to add one edge to form an odd cycle (if possible) is the sum of these counts over all components.\nIf `t=1` is possible (i.e., if any `count_0 >= 2` or `count_1 >= 2` in any component), then this is the minimum `t`. We calculate `w` as described.\n\n**Option B: Add 2 edges (`t = 2`).**\nIf `t=1` is not possible (i.e., all connected components have `count_0 <= 1` and `count_1 <= 1`), this means every connected component is either an isolated vertex or a single edge. In such a graph, every component has at most 2 vertices.\nIn this scenario, we must add at least 2 edges.\nConsider two distinct connected components, `C_i` and `C_j`. Let `u_i` be a vertex in `C_i` and `u_j` be a vertex in `C_j`.\nIf we connect `u_i` and `u_j` with an edge, these two components merge into a larger bipartite component.\nTo form an odd cycle with 2 edges, we need to pick three distinct vertices `u, v, x`. We add edges `(u, v)` and `(v, x)`. This path `u-v-x` has length 2. If we then add an edge `(u, x)`, we form a triangle (an odd cycle of length 3).\nThis means we need to pick three distinct vertices `u, v, x` such that no two are already connected, and add edges `(u, v)`, `(v, x)`, `(x, u)`. This would be 3 edges.\nHowever, we are looking for minimum `t`.\nIf we have three distinct vertices `u, v, x` in the graph, and we add edges `(u, v)` and `(v, x)` such that `u, v, x` were not already connected to form a path, and `u` and `x` are in different components or `u` and `x` are in the same component but have different colors. If we connect `u` and `v`, and `v` and `x`, this creates a path `u-v-x`. This path has length 2.\nIf we add 2 edges, say `(u, v)` and `(x, y)`. This is not guaranteed to form an odd cycle.\nThe simplest way to form an odd cycle with 2 edges is to connect two vertices `u, v` of a bipartite component, and then connect `v, x` such that `u, v, x` forms a path, and then `u, x` has a different parity.\nNo, that is not correct. If we connect `u` and `v` (different components, or same component different colors) and `v` and `x` (different components, or same component different colors), then we have formed a path `u-v-x`. The length of this path is 2. The vertices `u` and `x` are now in the same component. If they have the same color, adding an edge between them would create an odd cycle. But we are adding only 2 edges.\nThe only way to form an odd cycle by adding 2 edges is if we have two vertices `u` and `v` that are already connected by a path of odd length, and another path of even length.\nOr, more simply, if we have two components `C_1` and `C_2`. We pick `u \\in C_1` and `v \\in C_2`. We add an edge `(u, v)`. Now `C_1` and `C_2` are merged. This new component is still bipartite. To make it non-bipartite, we need to add another edge.\nThe problem statement says \"form a simple cycle of an odd length\".\nIf `t=1` is not possible, it means every component is a collection of isolated vertices and edges, where each color class has size at most 1.\nFor example, a component could be `u0-v1`. Adding `(u0, v1)` is a parallel edge. Adding `(u0, u0)` is a loop. So `t=1` is not possible.\nIn this case, `t` must be at least 2.\nConsider any three distinct vertices `u, v, x`. We can add edges `(u, v)` and `(v, x)`. This creates a path `u-v-x`. The length is 2 (even). This path does not form an odd cycle.\nIf we add two edges `(u,v)` and `(x,y)`:\n- If `u,v,x,y` are all distinct, this creates two new edges.\n- If `u=x`, then `(u,v)` and `(u,y)`. This creates a path `v-u-y` of length 2.\nTo form an odd cycle of length 3 (a triangle) using 2 new edges, we need one existing edge. Suppose `(u,v)` is an existing edge. We need to add `(u,x)` and `(v,x)`. This would form a triangle `u-v-x`. This requires `t=2`.\nThe number of ways to do this is `m * (n - 2)`. We pick an existing edge `(u,v)` in `m` ways, and then pick a third vertex `x` (not `u` or `v`) in `n-2` ways. We must ensure `(u,x)` and `(v,x)` are not existing edges.\nThis is the number of ways to form a triangle if `t=2`.\n\n**Option C: Add 3 edges (`t = 3`).**\nIf `t=1` and `t=2` are not possible, we need to add 3 edges.\nThis happens when `n < 3` or `m=0` and `n >= 3`.\nIf `n < 3`, no cycle of length > 1 is possible. The problem statement says \"consisting of more than one vertex\". A cycle of length 3 is the smallest odd cycle. So `n` must be at least 3.\nIf `n=0,1,2`, it's impossible to form an odd cycle. The problem constraints are `n >= 1`.\nIf `n=1` or `n=2`, no odd cycle is possible. The problem implies `n >= 3` for an odd cycle to be possible.\nIf `n >= 3` and `m=0` (empty graph), then `t=3`. We pick any 3 vertices `u, v, x` and add edges `(u,v), (v,x), (x,u)`.\nThe number of ways is `n * (n - 1) * (n - 2) / 6` (number of ways to choose 3 vertices).\n\nLet's refine the logic for `t=2` and `t=3`.\n\n**If `t=0` is not found (graph is bipartite):**\nWe proceed to calculate `t=1` options.\nIterate through all connected components. For each component `C_i`:\n  Perform BFS/DFS to 2-color it and count `count_0` and `count_1`.\n  `ways_t1 += count_0 * (count_0 - 1) / 2`\n  `ways_t1 += count_1 * (count_1 - 1) / 2`\nIf `ways_t1 > 0`:\n  `t = 1`, `w = ways_t1`.\n\n**If `t=1` is not found (`ways_t1 == 0`):**\nThis means every connected component has `count_0 <= 1` and `count_1 <= 1`.\nThis implies every component is either an isolated vertex or a single edge.\nIn this case, we must add at least 2 edges.\nCan we achieve `t=2`?\nTo form an odd cycle of length 3 (a triangle) with 2 new edges, we need one existing edge `(u,v)`. We then pick a third vertex `x` not equal to `u` or `v`. We add edges `(u,x)` and `(v,x)`. This forms a triangle `u-v-x`.\nThe number of ways to do this is `m * (n - 2)`. However, we must ensure that `(u,x)` and `(v,x)` are not already present in the graph.\nThis calculation `m * (n - 2)` counts pairs `((u,v), x)` where `(u,v)` is an existing edge and `x` is a third vertex.\nFor each such pair, we add edges `(u,x)` and `(v,x)`.\nLet's consider the number of pairs `(u,v)` and `(u,x)` where `(u,v)` is an existing edge and `x` is a third vertex.\nThis is equivalent to finding a path of length 2, `v-u-x`, where `(u,v)` is an existing edge, and `(u,x)` is *not* an existing edge, and `(v,x)` is *not* an existing edge.\nThis is a complex counting problem.\n\nA simpler observation for `t=2`:\nIf we have a path `u-v-x` of length 2, where `u, v, x` are distinct vertices, and `(u,v)` and `(v,x)` are existing edges. This path has length 2. If we add an edge `(u,x)`, we form a triangle. This is `t=1` (add one edge).\nIf `t=1` is not possible, it means we cannot form an odd cycle by adding an edge between two same-colored vertices in a component.\nThis means all components are `(1,0)` or `(0,1)` or `(1,1)` (an edge).\nIf `t=1` is not possible, it means no component has `count_0 >= 2` or `count_1 >= 2`.\nSo, all components are of size 1 (isolated vertex) or size 2 (an edge).\nIf `m > 0`:\nWe can pick any existing edge `(u,v)`. This edge connects `u` (color 0) and `v` (color 1).\nWe need to add 2 edges to form an odd cycle.\nIf we pick another vertex `x` (not `u` or `v`), and add edges `(u,x)` and `(v,x)`. This forms a triangle `u-v-x`. This is an odd cycle.\nWe need to count how many such `x` exist such that `(u,x)` and `(v,x)` are not already edges.\nFor each edge `(u,v)`:\n  `ways_to_form_triangle_with_2_new_edges = 0`\n  For each `x` from `1` to `n` (where `x != u` and `x != v`):\n    If `(u,x)` is not an edge AND `(v,x)` is not an edge:\n      `ways_to_form_triangle_with_2_new_edges++`\n  `total_ways_t2 += ways_to_form_triangle_with_2_new_edges`\nThis must be divided by 3 because each triangle is counted 3 times (once for each existing edge if it were part of the triangle). No, this is not a good way to count.\nA simpler way to count `t=2` for a triangle:\nCount the number of pairs of non-adjacent vertices `(u,v)`. Let this be `N_non_adj`.\nIf we have `u,v` non-adjacent, we can add `(u,v)`. Now we have `t=1`.\nThe problem states `t=2` is minimum.\nThis implies `m=0` or all components are isolated vertices or single edges.\nIf `m=0`, then `t=3`.\nIf `m>0` and `t=1` is not possible, then `t=2`.\nConsider any two distinct non-adjacent vertices `u, v`. We can add edge `(u,v)`.\nConsider any three distinct vertices `u, v, x`.\nIf `(u,v)` is an existing edge, and `(u,x)` is not an edge, and `(v,x)` is not an edge. We add `(u,x)` and `(v,x)`. This forms a triangle `u-v-x`.\nThe number of such `(u,v,x)` triplets is:\n`sum over all existing edges (u,v) of (n - 2 - degree[u] - degree[v] + count_common_neighbors(u,v))`\nThis is getting complicated.\n\nLet's re-evaluate the minimum `t`.\n1. If graph is not bipartite: `t=0, w=1`.\n2. If graph is bipartite:\n   a. Check for `t=1`:\n      Iterate components. For each component, count `count_0` and `count_1`.\n      `w1_ways = sum(c0*(c0-1)/2 + c1*(c1-1)/2)` over all components.\n      If `w1_ways > 0`: `t=1, w=w1_ways`.\n   b. If `w1_ways == 0`:\n      This means every component has `count_0 <= 1` and `count_1 <= 1`.\n      So every component is either an isolated vertex or a single edge.\n      In this case, we must add at least 2 edges.\n      The only way to form a triangle with 2 added edges is to pick an existing edge `(u,v)` and a third vertex `x` such that `(u,x)` and `(v,x)` are not existing edges.\n      The number of ways to pick an existing edge `(u,v)` is `m`.\n      The number of ways to pick `x` not adjacent to `u` and not adjacent to `v` (and `x != u, x != v`):\n      `n - 2` (total vertices minus `u` and `v`)\n      `- (degree[u] - 1)` (neighbors of `u` excluding `v`)\n      `- (degree[v] - 1)` (neighbors of `v` excluding `u`)\n      `+ (number of common neighbors of u and v)` (these were subtracted twice)\n      This is `n - 2 - (adj_u_count - 1) - (adj_v_count - 1) + common_neighbors_count`.\n      This is `n - degree[u] - degree[v] + common_neighbors_count`.\n      Let `isolated_vertices_count` be the number of vertices with degree 0.\n      Let `edges_count` be `m`.\n      Total vertices `n`.\n      If `m > 0` and `t=1` is not possible:\n        `t=2`.\n        `w2_ways = 0`.\n        For each existing edge `(u,v)`:\n          For each vertex `x` from `1` to `n`:\n            If `x != u` and `x != v` and `(u,x)` is not an edge and `(v,x)` is not an edge:\n              `w2_ways += 1`.\n        This `w2_ways` counts `(edge, vertex)` pairs. A triangle `u-v-x` is formed by 3 such pairs: `((u,v), x)`, `((u,x), v)`, `((v,x), u)`.\n        Since `(u,v)` is an existing edge, we count `((u,v), x)`.\n        If `(u,x)` and `(v,x)` are new edges, then `((u,x), v)` and `((v,x), u)` are not counted in this loop.\n        So, `w2_ways` is the correct count for this scenario.\n        This is the number of ways to pick an existing edge `(u,v)` and a non-adjacent vertex `x` to form a triangle `u-v-x` by adding `(u,x)` and `(v,x)`.\n        If `w2_ways > 0`: `t=2, w=w2_ways`.\n   c. If `w1_ways == 0` and `w2_ways == 0`:\n      This implies `m=0` (no edges exist, so cannot form a triangle with 1 existing edge).\n      Or it means for every existing edge `(u,v)`, every other vertex `x` is already connected to `u` or `v` (or both). This means the graph is \"dense\" in a specific way.\n      If `m=0`:\n        `t=3`.\n        `w = n * (n - 1) * (n - 2) / 6`. (Number of ways to choose 3 vertices and form a triangle).\n        This is valid only if `n >= 3`.\n        If `n < 3`, it's impossible to form an odd cycle. The problem constraints `n >= 1`.\n        If `n=1` or `n=2`, no odd cycle is possible. The problem statement implies `n >= 3` for an odd cycle of length > 1.\n        The smallest odd cycle is a triangle (length 3).\n        If `n < 3`, the problem is ill-defined for odd cycles. Let's assume `n >= 3` for this case.\n        The example `3 0` -> `3 1` suggests `t=3, w=1` for `n=3, m=0`.\n        So, if `m=0` and `n >= 3`, then `t=3, w = n * (n - 1) * (n - 2) // 6`.\n\nLet's refine `t=2` calculation.\nIf `t=1` is not possible, all components are isolated vertices or single edges.\nConsider any two components `C_i` and `C_j`.\nIf `C_i` is an isolated vertex `u`, and `C_j` is an isolated vertex `v`. We add `(u,v)`. They merge into a bipartite component.\nIf `C_i` is an isolated vertex `u`, and `C_j` is an edge `(x,y)`. We add `(u,x)`. Now `u` merges with `C_j`. This component is still bipartite.\nTo get an odd cycle with 2 edges, we need to connect 3 vertices.\nPick three distinct vertices `u, v, x`.\nAdd edges `(u,v)` and `(v,x)`. This forms a path `u-v-x`. This path has length 2.\nThis does not form an odd cycle by itself.\nAn odd cycle requires an odd number of edges.\nIf we add two edges `e1, e2`, how can they form an odd cycle?\n1. `e1=(u,v), e2=(v,x)`. If `(u,x)` exists, it forms a triangle. This is `t=1` case (add `(u,x)`).\n2. `e1=(u,v), e2=(x,y)`. All distinct. No cycle.\n3. `e1=(u,v), e2=(u,x)`. If `(v,x)` exists, it forms a triangle. This is `t=1` case.\n4. `e1=(u,v), e2=(u,v)`. Parallel edge, prohibited.\n\nThe case for `t=2` is when we pick an existing edge `(u,v)` and a third vertex `x` such that `(u,x)` and `(v,x)` are NOT existing edges. Then we add `(u,x)` and `(v,x)`. This forms a triangle `u-v-x`.\nThis is `t=2`.\nThe number of ways `w` for `t=2` is `sum over all edges (u,v) of (n - 2 - count_neighbors(u) - count_neighbors(v) + count_common_neighbors(u,v))`\nThis is `sum over all edges (u,v) of (n - 2 - (degree[u]-1) - (degree[v]-1) + common_neighbors(u,v))`.\nNo, this is `sum over all edges (u,v) of (n - 2 - (num_u_not_v) - (num_v_not_u))`.\n`num_u_not_v` is `degree[u] - 1`.\n`num_v_not_u` is `degree[v] - 1`.\nThe number of vertices `x` (not `u` or `v`) such that `x` is not adjacent to `u` and not adjacent to `v` is:\n`N_x = (n - 2)` (total vertices excluding `u` and `v`)\n      `- (number of vertices adjacent to u but not v)`\n      `- (number of vertices adjacent to v but not u)`\n      `- (number of vertices adjacent to both u and v)`\nThis is `(n - 2) - (|N(u) \\setminus \\{v\\}|) - (|N(v) \\setminus \\{u\\}|) - (|N(u) \\cap N(v)|)`.\nThis is `(n - 2) - (degree[u] - 1 - |N(u) \\cap N(v)|) - (degree[v] - 1 - |N(u) \\cap N(v)|) - |N(u) \\cap N(v)|`.\nNo, this is `(n-2) - (degree[u]-1) - (degree[v]-1) + |N(u) \\cap N(v)|`.\nThis is `n - degree[u] - degree[v] + |N(u) \\cap N(v)|`.\nLet `adj[u]` be the set of neighbors of `u`.\nFor each edge `(u,v)`:\n  `count_valid_x = 0`\n  For `x` from `1` to `n`:\n    If `x == u` or `x == v`: continue\n    If `x` is in `adj[u]` or `x` is in `adj[v]`: continue\n    `count_valid_x++`\n  `total_w2 += count_valid_x`\nThis `total_w2` is the correct number of ways for `t=2`.\n\nSummary of logic:\n1. Initialize `adj` list for graph, and `colors` array to -1.\n2. `is_bipartite = True`, `ways_t0 = 0`.\n3. For each vertex `i` from `1` to `n`:\n   If `colors[i] == -1`:\n     Start BFS from `i`.\n     `q = deque([(i, 0)])`\n     `colors[i] = 0`\n     `component_nodes = [i]`\n     `count_0 = 1`, `count_1 = 0`\n     While `q`:\n       `u, c_u = q.popleft()`\n       For `v` in `adj[u]`:\n         If `colors[v] == -1`:\n           `colors[v] = 1 - c_u`\n           If `colors[v] == 0`: `count_0 += 1` else `count_1 += 1`\n           `q.append((v, colors[v]))`\n           `component_nodes.append(v)`\n         Else if `colors[v] == c_u`:\n           `is_bipartite = False`\n           Break (from inner loop)\n       If not `is_bipartite`: Break (from outer loop)\n     If not `is_bipartite`: Break (from outer loop)\n     `ways_t1 += count_0 * (count_0 - 1) // 2`\n     `ways_t1 += count_1 * (count_1 - 1) // 2`\n\n4. If `not is_bipartite`:\n   `t = 0`, `w = 1`.\n5. Else (`is_bipartite`):\n   If `ways_t1 > 0`:\n     `t = 1`, `w = ways_t1`.\n   Else (`ways_t1 == 0`):\n     This means all components are isolated vertices or single edges.\n     If `m > 0`:\n       `t = 2`, `w = 0`.\n       For each edge `(u,v)` in the input (store edges in a list or set for this step):\n         For `x` from `1` to `n`:\n           If `x == u` or `x == v`: continue\n           If `x` not in `adj[u]` and `x` not in `adj[v]`:\n             `w += 1`.\n     Else (`m == 0`):\n       `t = 3`, `w = n * (n - 1) * (n - 2) // 6`.\n       (If `n < 3`, `w` will be 0, which is correct as no odd cycle is possible).\n\nExample 1:\n4 4\n1 2\n1 3\n4 2\n4 3\nAdj: {1: {2,3}, 2: {1,4}, 3: {1,4}, 4: {2,3}}\nBFS from 1:\ncolors = [-1,-1,-1,-1,-1]\nq = [(1,0)]\ncolors[1]=0\npop (1,0)\n  v=2: colors[2]=-1. colors[2]=1. q.append((2,1))\n  v=3: colors[3]=-1. colors[3]=1. q.append((3,1))\npop (2,1)\n  v=1: colors[1]=0. colors[1]!=colors[2]. OK.\n  v=4: colors[4]=-1. colors[4]=0. q.append((4,0))\npop (3,1)\n  v=1: colors[1]=0. colors[1]!=colors[3]. OK.\n  v=4: colors[4]=0. colors[4]==colors[3] (0==1 is false). OK.\npop (4,0)\n  v=2: colors[2]=1. colors[2]!=colors[4]. OK.\n  v=3: colors[3]=1. colors[3]!=colors[4]. OK.\nAll components processed. Graph is bipartite.\nComponent 1: vertices {1,2,3,4}. colors: {1:0, 2:1, 3:1, 4:0}.\ncount_0 = 2 (1,4), count_1 = 2 (2,3).\nways_t1 = (2*(2-1)//2) + (2*(2-1)//2) = 1 + 1 = 2.\nSince ways_t1 > 0, `t=1, w=2`. Matches example.\n\nExample 2:\n3 3\n1 2\n2 3\n3 1\nAdj: {1: {2,3}, 2: {1,3}, 3: {1,2}}\nBFS from 1:\ncolors = [-1,-1,-1,-1]\nq = [(1,0)]\ncolors[1]=0\npop (1,0)\n  v=2: colors[2]=-1. colors[2]=1. q.append((2,1))\n  v=3: colors[3]=-1. colors[3]=1. q.append((3,1))\npop (2,1)\n  v=1: colors[1]=0. colors[1]!=colors[2]. OK.\n  v=3: colors[3]=1. colors[3]==colors[2]. Conflict! 1==1.\nis_bipartite = False. Break.\n`t=0, w=1`. Matches example.\n\nExample 3:\n3 0\nAdj: {1: {}, 2: {}, 3: {}}\nBFS from 1:\ncolors[1]=0. count_0=1, count_1=0.\nways_t1 += 0 + 0 = 0.\nBFS from 2:\ncolors[2]=0. count_0=1, count_1=0.\nways_t1 += 0 + 0 = 0.\nBFS from 3:\ncolors[3]=0. count_0=1, count_1=0.\nways_t1 += 0 + 0 = 0.\nis_bipartite = True. ways_t1 = 0.\n`m=0`. So, `t=3, w = 3*(3-1)*(3-2)//6 = 3*2*1//6 = 1`. Matches example.\n\nThis logic seems sound and covers all cases.\nNeed to use `set` for `adj` lists for efficient `x not in adj[u]` checks.\nThe graph can have `n` up to `10^5`, `m` up to `10^5`.\nBFS is `O(N+M)`.\nCalculating `ways_t1` is `O(N)` after BFS.\nCalculating `ways_t2`: Outer loop `m` times. Inner loop `n` times. Set lookups `O(degree)`. Total `O(M * N * AvgDegree)`.\nThis is too slow for `N=10^5, M=10^5`. `10^5 * 10^5 = 10^{10}`. `M * N` is too slow.\n\nThe `t=2` calculation needs to be faster.\n`w2_ways = sum over all edges (u,v) of (n - 2 - |adj[u] \\setminus \\{v\\}| - |adj[v] \\setminus \\{u\\}| - |adj[u] \\cap adj[v]|)`\nNo, this is not correct.\n`w2_ways = sum over all edges (u,v) of (n - 2 - (|adj[u]| - 1) - (|adj[v]| - 1) + |adj[u] \\cap adj[v]|)`\nThis is `sum over all edges (u,v) of (n - degree[u] - degree[v] + |adj[u] \\cap adj[v]|)`.\n`|adj[u] \\cap adj[v]|` is the number of common neighbors of `u` and `v`.\nCalculating common neighbors for each edge `(u,v)`:\nFor each `u` and `v`, iterate over `adj[u]` and check if in `adj[v]`. If `adj` is a set, `O(min(deg(u), deg(v)))`.\nTotal `sum over edges (u,v) of min(deg(u), deg(v))`. This is `O(M * sqrt(M))` or `O(M * N)` in worst case.\nStill too slow.\n\nAlternative for `t=2`:\nThe number of ways to pick an existing edge `(u,v)` and a third vertex `x` such that `(u,x)` and `(v,x)` are NOT existing edges.\nThis is `M * N_total_x` where `N_total_x` is the average number of such `x`.\nInstead of iterating through `x` for each `(u,v)`:\nTotal number of potential `x` vertices is `n`.\nTotal ways to pick an edge `(u,v)` and a vertex `x` (where `x != u, x != v`) is `m * (n - 2)`.\nFrom this, we subtract cases where `(u,x)` exists or `(v,x)` exists.\nSubtract `(u,x)` exists: Iterate over all edges `(u,x)`. For each such edge, `v` can be any vertex not `u` or `x`.\nThis is `sum over edges (u,x) of (n-2)`. No, this is wrong.\n\nLet's count `w2_ways` as the number of \"open triangles\".\nAn open triangle is a path of length 2, `u-x-v`, where `u` and `v` are not connected.\nNo, this is not what we want. We want `u-v` to be existing, and `u-x`, `v-x` to be new.\n\nTotal `(u,v,x)` triplets where `(u,v)` is an edge and `x != u, x != v`: `m * (n - 2)`.\nFor each such triplet, if we add `(u,x)` and `(v,x)`, we form a triangle.\nWe want to count triplets `(u,v,x)` such that `(u,v)` is an edge, `x != u, x != v`, and `(u,x)` is NOT an edge, and `(v,x)` is NOT an edge.\nThis is `m * (n - 2)`\n  `- sum over edges (u,v) of (number of x such that (u,x) is an edge and x != v)`\n  `- sum over edges (u,v) of (number of x such that (v,x) is an edge and x != u)`\n  `+ sum over edges (u,v) of (number of x such that (u,x) is an edge AND (v,x) is an edge)` (common neighbors)\nThis is `m * (n - 2)`\n  `- sum over edges (u,v) of (degree[u] - 1)`\n  `- sum over edges (u,v) of (degree[v] - 1)`\n  `+ sum over edges (u,v) of (|adj[u] \\cap adj[v]|)`\n`sum over edges (u,v) of (degree[u]-1)`: `sum_u (degree[u] * (degree[u]-1))`\n`sum over edges (u,v) of (degree[v]-1)`: `sum_v (degree[v] * (degree[v]-1))`\nThis is `sum_{u} degree[u]*(degree[u]-1) = 2 * (number of paths of length 2)`.\nSo `m * (n - 2) - sum_{u} degree[u]*(degree[u]-1) + sum_{edges (u,v)} |adj[u] \\cap adj[v]|`.\nThe last term `sum_{edges (u,v)} |adj[u] \\cap adj[v]|` is `sum over all triangles (u,v,x) of 1`. This is `3 * (number of triangles)`.\nThis is `O(N+M)` for degrees, but `O(M * min(deg))` for `|adj[u] \\cap adj[v]|`.\n\nLet's use a faster way to count `w2_ways`.\nTotal number of ways to pick an edge `(u,v)` and a third vertex `x` is `m * (n-2)`.\nFrom this, we subtract the cases where `(u,x)` is an edge, or `(v,x)` is an edge.\nLet `A` be the set of pairs `((u,v), x)` where `(u,v)` is an edge and `x != u, x != v`. Size `m(n-2)`.\nLet `B` be the subset where `(u,x)` is an edge.\nLet `C` be the subset where `(v,x)` is an edge.\nWe want `|A| - (|B| + |C| - |B \\cap C|)`.\n`|B|`: Sum over all edges `(u,v)` and for each `u`, iterate `x` in `adj[u]`. If `x != v`, then `((u,v), x)` is in `B`.\nThis is `sum_{(u,v) \\in E} (degree[u] - 1)`.\n`|C|`: Sum over all edges `(u,v)` and for each `v`, iterate `x` in `adj[v]`. If `x != u`, then `((u,v), x)` is in `C`.\nThis is `sum_{(u,v) \\in E} (degree[v] - 1)`.\n`|B \\cap C|`: Sum over all edges `(u,v)` and for each `x` in `adj[u] \\cap adj[v]`.\nThis is `sum_{(u,v) \\in E} |adj[u] \\cap adj[v]|`.\nAll these sums can be computed in `O(N+M)` if we can compute `|adj[u] \\cap adj[v]|` fast.\n`sum_{(u,v) \\in E} (degree[u] - 1)` is `sum_u (degree[u] * (degree[u] - 1))`. This is `O(N+M)`.\n`sum_{(u,v) \\in E} (degree[v] - 1)` is also `O(N+M)`.\nThe tricky part is `sum_{(u,v) \\in E} |adj[u] \\cap adj[v]|`. This is `3 * (number of triangles in graph)`.\nCounting triangles can be `O(M * sqrt(M))` or `O(N+M)` for sparse graphs if we use specific algorithms like iterating over edges `(u,v)` and then checking `min(deg(u), deg(v))` neighbors.\nFor `O(M * sqrt(M))`, it might pass. `10^5 * sqrt(10^5) = 10^5 * 316 = 3.16 * 10^7`. This is feasible.\n\nAlgorithm for counting triangles:\n1. Sort vertices by degree. Break ties by vertex ID.\n2. For each edge `(u,v)`:\n   Assume `degree[u] < degree[v]` (or `degree[u] == degree[v]` and `u < v`).\n   Iterate `w` in `adj[u]`.\n   If `w` is also in `adj[v]`, then `(u,v,w)` is a triangle. Increment count.\n   Store `adj` as `set` for `O(1)` average lookup.\nThis algorithm counts each triangle once.\nThe complexity is `sum_{(u,v) \\in E} min(degree[u], degree[v])`.\nFor `M` edges, this sum is `O(M * sqrt(M))` in worst case.\n\nSo, the `t=2` calculation:\n`num_triangles = 0`\nCreate `adj_sets` (list of sets for neighbors).\n`edges_list` (list of `(u,v)` pairs).\nFor `u` from `1` to `n`:\n  For `v` in `adj_sets[u]`:\n    If `u < v`: `edges_list.append((u,v))`\nSort vertices by degree (and ID for tie-breaking). Store `order[vertex_id] = rank`.\nFor `(u,v)` in `edges_list`:\n  If `order[u] > order[v]`: swap `u,v`. (Ensure `u` has lower rank, i.e., smaller degree or smaller ID)\n  For `w` in `adj_sets[u]`:\n    If `w` in `adj_sets[v]`:\n      `num_triangles += 1`\n`sum_deg_minus_1 = 0`\nFor `u` from `1` to `n`:\n  `sum_deg_minus_1 += degree[u] * (degree[u] - 1)`\n`w = m * (n - 2) - sum_deg_minus_1 + 3 * num_triangles`. (This is the number of `(edge, x)` pairs where `(u,x)` or `(v,x)` exists.)\nNo, this is `m * (n-2) - (|B| + |C|) + |B \\cap C|`.\n`|B| = sum_{(u,v) \\in E} (degree[u] - 1)`\n`|C| = sum_{(u,v) \\in E} (degree[v] - 1)`\n`|B \\cap C| = sum_{(u,v) \\in E} |adj[u] \\cap adj[v]| = 3 * num_triangles`.\nSo `w2_ways = m * (n - 2) - (sum_{(u,v) \\in E} (degree[u] - 1) + sum_{(u,v) \\in E} (degree[v] - 1)) + 3 * num_triangles`.\nThis simplifies to `m * (n - 2) - sum_{u=1 to n} degree[u]*(degree[u]-1) + 3 * num_triangles`.\nThis looks correct and can be computed efficiently.\n\nFinal check on edge cases for `t=2` and `t=3`:\nIf `n < 3`: No odd cycle possible. `t` should be infinite or problem statement implies `n >= 3`.\nProblem says \"consisting of more than one vertex\". Smallest odd cycle has 3 vertices. So `n >= 3` is implicitly required.\nIf `n=1` or `n=2`, the code will output `t=3, w=0` if `m=0`. This is reasonable as `n*(n-1)*(n-2)//6` would be 0.\nIf `n=1` or `n=2` and `m>0`, it means `m=1` (for `n=2`). Then `t=2`, `w=0` (as `n-2=0`). This also seems reasonable.\n\n```python\nimport sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    \n    adj = [set() for _ in range(n + 1)]\n    edges = []\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].add(v)\n        adj[v].add(u)\n        edges.append((u, v))\n\n    colors = [-1] * (n + 1) # -1: unvisited, 0: color A, 1: color B\n    \n    is_bipartite = True\n    ways_t1 = 0\n    \n    # Store degree for t=2 calculation\n    degrees = [0] * (n + 1)\n    for u, v in edges:\n        degrees[u] += 1\n        degrees[v] += 1\n\n    # BFS for bipartiteness and t=1 calculation\n    for i in range(1, n + 1):\n        if colors[i] == -1:\n            q = deque([(i, 0)])\n            colors[i] = 0\n            \n            current_component_count_0 = 0\n            current_component_count_1 = 0\n            \n            if 0 == 0: # current_color is 0\n                current_component_count_0 += 1\n            else:\n                current_component_count_1 += 1\n\n            component_is_bipartite = True\n            \n            while q:\n                u, c_u = q.popleft()\n                \n                for v in adj[u]:\n                    if colors[v] == -1:\n                        colors[v] = 1 - c_u\n                        if colors[v] == 0:\n                            current_component_count_0 += 1\n                        else:\n                            current_component_count_1 += 1\n                        q.append((v, colors[v]))\n                    elif colors[v] == c_u:\n                        is_bipartite = False\n                        component_is_bipartite = False\n                        break\n                if not component_is_bipartite:\n                    break\n            \n            if not is_bipartite:\n                break # Graph is not bipartite, t=0\n            \n            # If component is bipartite, calculate ways for t=1\n            ways_t1 += current_component_count_0 * (current_component_count_0 - 1) // 2\n            ways_t1 += current_component_count_1 * (current_component_count_1 - 1) // 2\n\n    if not is_bipartite:\n        print(\"0 1\")\n    elif ways_t1 > 0:\n        print(f\"1 {ways_t1}\")\n    else:\n        # Graph is bipartite, and t=1 is not possible.\n        # This means all components are isolated vertices or single edges.\n        \n        if m > 0:\n            # Try t=2.\n            # We need to find (u,v,x) such that (u,v) is an edge, x!=u, x!=v,\n            # and (u,x) and (v,x) are not edges.\n            # Number of such triplets (u,v,x) is the answer for t=2.\n            \n            # Count triangles for the term 3 * num_triangles\n            num_triangles = 0\n            \n            # Create a list of vertices sorted by degree to optimize triangle counting\n            # (u,v) with deg(u) <= deg(v)\n            sorted_vertices = sorted(range(1, n + 1), key=lambda x: degrees[x])\n\n            # Adjacency lists for efficient lookup\n            adj_lists = [list(s) for s in adj]\n\n            # Re-index vertices based on sorted order for triangle counting\n            # This is not strictly necessary if we just iterate u in adj_sets[v]\n            # and check if u < v or degree[u] < degree[v]\n            \n            for u_node in range(1, n + 1):\n                for v_node in adj_lists[u_node]:\n                    if u_node < v_node: # Process each edge once\n                        # Iterate over neighbors of u_node\n                        for w_node in adj_lists[u_node]:\n                            if w_node != v_node: # w_node is potential third vertex\n                                # Check if w_node is also a neighbor of v_node\n                                if w_node in adj[v_node]:\n                                    # Found a triangle (u_node, v_node, w_node)\n                                    num_triangles += 1\n            # Each triangle (u,v,w) is counted 3 times (once for (u,v), once for (u,w), once for (v,w)).\n            # So, divide by 3.\n            num_triangles //= 3 \n            \n            # Calculate sum_u degree[u]*(degree[u]-1)\n            sum_deg_term = 0\n            for i in range(1, n + 1):\n                sum_deg_term += degrees[i] * (degrees[i] - 1)\n            \n            # w2_ways = m * (n - 2) - sum_deg_term + 3 * num_triangles\n            w2_ways = m * (n - 2) - sum_deg_term + 3 * num_triangles\n\n            print(f\"2 {w2_ways}\")\n        else:\n            # m == 0 (no edges).\n            # Smallest odd cycle is a triangle, requires 3 edges.\n            # Number of ways to choose 3 vertices from n: C(n,3)\n            if n >= 3:\n                w3_ways = n * (n - 1) * (n - 2) // 6\n            else:\n                w3_ways = 0 # Cannot form a triangle with less than 3 vertices\n            print(f\"3 {w3_ways}\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    \n    adj = [set() for _ in range(n + 1)]\n    edges = []\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].add(v)\n        adj[v].add(u)\n        edges.append((u, v))\n\n    colors = [-1] * (n + 1) # -1: unvisited, 0: color A, 1: color B\n    \n    is_bipartite = True\n    ways_t1 = 0\n    \n    # Store degree for t=2 calculation\n    degrees = [0] * (n + 1)\n    for u, v in edges:\n        degrees[u] += 1\n        degrees[v] += 1\n\n    # BFS for bipartiteness and t=1 calculation\n    for i in range(1, n + 1):\n        if colors[i] == -1:\n            q = deque([(i, 0)])\n            colors[i] = 0\n            \n            current_component_count_0 = 0\n            current_component_count_1 = 0\n            \n            if 0 == 0: # current_color is 0\n                current_component_count_0 += 1\n            else:\n                current_component_count_1 += 1\n\n            component_is_bipartite = True\n            \n            while q:\n                u, c_u = q.popleft()\n                \n                for v in adj[u]:\n                    if colors[v] == -1:\n                        colors[v] = 1 - c_u\n                        if colors[v] == 0:\n                            current_component_count_0 += 1\n                        else:\n                            current_component_count_1 += 1\n                        q.append((v, colors[v]))\n                    elif colors[v] == c_u:\n                        is_bipartite = False\n                        component_is_bipartite = False\n                        break\n                if not component_is_bipartite:\n                    break\n            \n            if not is_bipartite:\n                break # Graph is not bipartite, t=0\n            \n            # If component is bipartite, calculate ways for t=1\n            ways_t1 += current_component_count_0 * (current_component_count_0 - 1) // 2\n            ways_t1 += current_component_count_1 * (current_component_count_1 - 1) // 2\n\n    if not is_bipartite:\n        print(\"0 1\")\n    elif ways_t1 > 0:\n        print(f\"1 {ways_t1}\")\n    else:\n        # Graph is bipartite, and t=1 is not possible.\n        # This means all components are isolated vertices or single edges.\n        \n        if m > 0:\n            # Try t=2.\n            # We need to find (u,v,x) such that (u,v) is an edge, x!=u, x!=v,\n            # and (u,x) and (v,x) are not edges.\n            # Number of such triplets (u,v,x) is the answer for t=2.\n            \n            # Count triangles for the term 3 * num_triangles\n            num_triangles = 0\n            \n            # Create a list of vertices sorted by degree to optimize triangle counting\n            # (u,v) with deg(u) <= deg(v)\n            sorted_vertices = sorted(range(1, n + 1), key=lambda x: degrees[x])\n\n            # Adjacency lists for efficient lookup\n            adj_lists = [list(s) for s in adj]\n\n            # Re-index vertices based on sorted order for triangle counting\n            # This is not strictly necessary if we just iterate u in adj_sets[v]\n            # and check if u < v or degree[u] < degree[v]\n            \n            for u_node in range(1, n + 1):\n                for v_node in adj_lists[u_node]:\n                    if u_node < v_node: # Process each edge once\n                        # Iterate over neighbors of u_node\n                        for w_node in adj_lists[u_node]:\n                            if w_node != v_node: # w_node is potential third vertex\n                                # Check if w_node is also a neighbor of v_node\n                                if w_node in adj[v_node]:\n                                    # Found a triangle (u_node, v_node, w_node)\n                                    num_triangles += 1\n            # Each triangle (u,v,w) is counted 3 times (once for (u,v), once for (u,w), once for (v,w)).\n            # So, divide by 3.\n            num_triangles //= 3 \n            \n            # Calculate sum_u degree[u]*(degree[u]-1)\n            sum_deg_term = 0\n            for i in range(1, n + 1):\n                sum_deg_term += degrees[i] * (degrees[i] - 1)\n            \n            # w2_ways = m * (n - 2) - sum_deg_term + 3 * num_triangles\n            w2_ways = m * (n - 2) - sum_deg_term + 3 * num_triangles\n\n            print(f\"2 {w2_ways}\")\n        else:\n            # m == 0 (no edges).\n            # Smallest odd cycle is a triangle, requires 3 edges.\n            # Number of ways to choose 3 vertices from n: C(n,3)\n            if n >= 3:\n                w3_ways = n * (n - 1) * (n - 2) // 6\n            else:\n                w3_ways = 0 # Cannot form a triangle with less than 3 vertices\n            print(f\"3 {w3_ways}\")\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 604,
        "completion_token_count": 11791,
        "thoughts_token_count": 734
    }
}