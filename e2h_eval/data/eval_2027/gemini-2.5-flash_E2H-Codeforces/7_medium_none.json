{
    "start": 1758011818.989848,
    "end": 1758011939.607266,
    "start-formatted": "2025-09-16 17:36 KST",
    "end-formatted": "2025-09-16 17:38 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "**My Problem-Solving Journey for the \"Rudolf and Snowflakes (Hard Version)\"**\n\nOkay, so I'm tasked with writing a Python script to tackle this competitive programming problem. It's all about analyzing these \"snowflakes\" which are essentially graphs.  Let's break down the structure: a central vertex, and then branches coming off of it, and then branches from *those* branches, and so on.\n\nThe core of the problem is figuring out if a given number of vertices (`n`) can actually form one of these snowflakes.  The tricky part is that the number of branches per level (`k`) and the *depth* of the branches (`d`) are the unknowns, with some constraints (k>1, d>=1).\n\nI started by looking at a few small examples, and then by trying to come up with a formula.  I realized that the total number of vertices could be expressed as a geometric series.  If `d=1`, we had `1 + k + k^2`, which would be the simplest snowflake with at least 2 layers of branches. If `d` is larger, like 2, we have `1 + k + k^2 + k^3`, and so on.\nI realized that `n = (k^(d+2) - 1) / (k - 1)`. Which is a geometric series sum formula.\nMy aim is to find if there are integer values `k` and `d`  that make this true, given `n`.\n\nNow, because n is up to 10^18, and `k>1, d>=1`, I started optimizing to narrow down the range. Because of the size of the values, there had to be some optimization to avoid brute force checking of everything.\nI noticed a special case when d=1, and `n = 1 + k + k^2`.  I realized this is a quadratic equation, and I could use the quadratic formula to solve for k. I just need to make sure that the discriminant is a perfect square,  and that k (the solution of this quadratic equation) is an integer greater than 1. This is my base case.\n\nFor `d > 1`, that equation is not as easy, as there's no simple formula to compute k.\nSo for this geometric series I need to make sure this n value is correct, and I considered iterating through d (or rather through the `m` which equals `d+1`).\nThe max `m` is about 60, based on log2(10^18). For each `m`, I used binary search to quickly look for an integer value `k`. But since k and m are in such a range, I needed to keep bounds on my search space.\nThe main insight I used was the bounds for `k`. The maximum `k` value decreases as the m grows.\n\nA main piece of the binary search is to perform the summation `1 + k + k^2 + ... + k^m` for each `k` in the range.  Since k might be really large, I carefully implemented the summation to avoid integer overflows.\n\nAt the very end, I handle a few edge cases (n values that cannot be a snowflake). And also add an overflow check and other safety measures so this does not take too much time, as it's for a coding competition. It's a balance of math insight and coding skills.\n\nThe final code checks for some special cases, performs the binary search and returns YES or NO.\n\n",
    "response": "The problem asks us to determine if a given number of vertices `n` can form a snowflake. A snowflake is defined by a central vertex, `k` branches connected to it, and then each of these `k` branches sprouts `k` more branches, and so on. This \"sprouting\" step must occur at least once. The parameter `k` must be greater than 1.\n\nLet `d` be the number of times the \"sprouting\" step is performed. According to the problem, `d >= 1`.\nThe number of vertices `n` can be calculated as follows:\n1.  Start with 1 central vertex.\n2.  Connect `k` new vertices to the center. Total vertices: `1 + k`.\n3.  Perform the sprouting step `d` times:\n    *   After 1st sprout (`d=1`): Each of the `k` first-layer vertices gets `k` new vertices. Total `k * k = k^2` new vertices. Total `n = 1 + k + k^2`.\n    *   After 2nd sprout (`d=2`): Each of the `k^2` second-layer vertices gets `k` new vertices. Total `k^2 * k = k^3` new vertices. Total `n = 1 + k + k^2 + k^3`.\n    *   In general, after `d` sprouts, the total number of vertices `n` is `1 + k + k^2 + ... + k^(d+1)`.\n\nThis is a geometric series sum. Let `m = d + 1`. Since `d >= 1`, we have `m >= 2`.\nThe formula for `n` is `n = (k^(m+1) - 1) / (k - 1)`.\n\nWe need to check if there exist integers `k > 1` and `m >= 2` such that `n = 1 + k + k^2 + ... + k^m`.\n\n**1. Base Cases for `n`:**\nThe smallest possible snowflake occurs when `k=2` and `m=2` (i.e., `d=1`).\n`n = 1 + 2 + 2^2 = 1 + 2 + 4 = 7`.\nAny `n < 7` cannot be a snowflake. So for `n=1, 2, 3, 4, 5, 6`, the answer is \"NO\".\n\n**2. Case `m = 2` (i.e., `d = 1`):**\nThe equation is `n = 1 + k + k^2`.\nThis is a quadratic equation in `k`: `k^2 + k + (1 - n) = 0`.\nUsing the quadratic formula, `k = (-1 +/- sqrt(1 - 4(1 - n))) / 2 = (-1 +/- sqrt(4n - 3)) / 2`.\nFor `k` to be a valid integer `> 1`:\n*   `4n - 3` must be a perfect square. Let `S = sqrt(4n - 3)`.\n*   Since `k > 1`, we must take the positive root: `k = (-1 + S) / 2`.\n*   For `k` to be an integer, `S` must be odd (so `-1 + S` is even).\n*   For `k > 1`, `(-1 + S) / 2 > 1` implies `-1 + S > 2`, so `S > 3`.\nSo, if `4n - 3` is a perfect square `S^2` where `S` is an odd integer greater than 3, then `n` is a snowflake number.\n\n**3. Case `m >= 3` (i.e., `d >= 2`):**\nWe need to find if `n = 1 + k + k^2 + ... + k^m` for some `k > 1` and `m >= 3`.\n\n*   **Bounds for `m`:**\n    If `k=2` (smallest possible `k`), `n = 1 + 2 + ... + 2^m = 2^(m+1) - 1`.\n    Since `n <= 10^18`, we have `2^(m+1) - 1 <= 10^18`, which means `2^(m+1) <= 10^18 + 1`.\n    Taking `log2` on both sides: `m+1 <= log2(10^18 + 1)`.\n    `log2(10^18)` is approximately `18 * log2(10) approx 18 * 3.3219 = 59.79`.\n    So, `m+1` can be at most `59`. This implies `m` can be at most `58`.\n    Thus, we only need to iterate `m` from `3` to `58`.\n\n*   **Bounds for `k`:**\n    For a fixed `m`, `n = 1 + k + ... + k^m`. Since `k > 1`, we know `k^m < n`.\n    This implies `k < n^(1/m)`.\n    The smallest `k` is `2`.\n    The largest `k` occurs for the smallest `m`, which is `m=3`. For `n=10^18`, `k < (10^18)^(1/3) = 10^6`.\n    As `m` increases, the upper bound for `k` decreases significantly. For `m=58`, `k < (10^18)^(1/58) approx 2.04`, so `k` can only be `2`.\n\n*   **Binary Search for `k`:**\n    For each `m` in the range `[3, 58]`, we can use binary search to find `k`.\n    The search range for `k` is `[2, min(int(n**(1/m)) + 2, 2 * 10**6)]`. The `+2` and `2 * 10**6` are safety margins for floating point inaccuracies and general upper bound.\n    Inside the binary search, for a `mid` value of `k`:\n    Calculate `current_sum = 1 + mid + mid^2 + ... + mid^m`.\n    This sum must be computed carefully to avoid overflow if intermediate terms `mid^j` become very large, even though Python handles arbitrary-precision integers. It's more efficient to stop early if `current_sum` exceeds `n`.\n    A crucial optimization for calculating the sum:\n    ```python\n    current_sum = 0\n    current_term = 1 # Represents k^0, k^1, k^2, ...\n    overflow = False\n    for _ in range(m + 1): # Loop for powers 0 to m\n        current_sum += current_term\n        if current_sum > n:\n            overflow = True\n            break\n        if _ < m: # Prepare for next term, if not the last term\n            # Check if current_term * mid would exceed n\n            # If current_term > n // mid, then current_term * mid > n\n            if current_term > n // mid: \n                overflow = True\n                break\n            current_term *= mid\n    ```\n    Based on `current_sum` and `n`:\n    *   If `overflow` or `current_sum > n`: `high = mid - 1` (mid is too large).\n    *   If `current_sum == n`: `n` is a snowflake number. Return \"YES\".\n    *   If `current_sum < n`: `low = mid + 1` (mid is too small).\n\nIf after checking all `m` values (and corresponding `k` values), no match is found, then `n` is not a snowflake number. Return \"NO\".\n\n**Example Walkthrough: `n = 255`**\n1.  `n=255` is not `< 7`.\n2.  **`m=2` check:**\n    `discriminant = 4 * 255 - 3 = 1020 - 3 = 1017`.\n    `sqrt(1017)` is approximately `31.89`. `round(31.89) = 32`. `32*32 = 1024 != 1017`. Not a perfect square. So `m=2` fails.\n3.  **`m >= 3` loop:**\n    *   `m=3`: `k < 255^(1/3) approx 6.34`. Binary search `k` in `[2, 6]`.\n        *   Try `k=2`: `1+2+4+8 = 15 != 255`.\n        *   Try `k=3`: `1+3+9+27 = 40 != 255`.\n        *   Try `k=4`: `1+4+16+64 = 85 != 255`.\n        *   Try `k=5`: `1+5+25+125 = 156 != 255`.\n        *   Try `k=6`: `1+6+36+216 = 259 > 255`. No `k` for `m=3`.\n    *   `m=4`: `k < 255^(1/4) approx 3.98`. Binary search `k` in `[2, 3]`.\n        *   Try `k=2`: `1+2+4+8+16 = 31 != 255`.\n        *   Try `k=3`: `1+3+9+27+81 = 121 != 255`. No `k` for `m=4`.\n    *   `m=5`: `k < 255^(1/5) approx 3.05`. Binary search `k` in `[2, 3]`.\n        *   Try `k=2`: `1+2+4+8+16+32 = 63 != 255`.\n        *   Try `k=3`: `1+3+9+27+81+243 = 364 > 255`. No `k` for `m=5`.\n    *   `m=6`: `k < 255^(1/6) approx 2.5`. Binary search `k` in `[2, 2]`.\n        *   Try `k=2`: `1+2+4+8+16+32+64 = 127 != 255`. No `k` for `m=6`.\n    *   `m=7`: `k < 255^(1/7) approx 2.1`. Binary search `k` in `[2, 2]`.\n        *   Try `k=2`: `1+2+4+8+16+32+64+128 = 255`. YES! `n=255` is a snowflake with `k=2, m=7` (or `d=6`). Output \"YES\".\n\nThis approach covers all cases efficiently.\n\n```python\nimport sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n\n    # Base cases: n < 7 cannot be a snowflake (min is 1 + 2 + 2^2 = 7 for k=2, d=1)\n    if n < 7:\n        sys.stdout.write(\"NO\\n\")\n        return\n\n    # Case 1: m = 2 (d = 1), n = 1 + k + k^2\n    # This is k^2 + k + (1 - n) = 0\n    # k = (-1 + sqrt(4n - 3)) / 2\n    discriminant = 4 * n - 3\n    \n    # Check if discriminant is a perfect square\n    s = round(discriminant**0.5)\n    if s * s == discriminant:\n        # For k to be an integer, (-1 + s) must be even, so s must be odd.\n        # For k > 1, (-1 + s) / 2 > 1 => -1 + s > 2 => s > 3.\n        if s % 2 == 1 and s > 3:\n            # k_val = (s - 1) // 2. Since s > 3, k_val will be > 1.\n            sys.stdout.write(\"YES\\n\")\n            return\n\n    # Case 2: m >= 3 (d >= 2), n = 1 + k + k^2 + ... + k^m\n    # Max m: 2^(m+1) - 1 <= 10^18 => m+1 <= log2(10^18 + 1) approx 59.79.\n    # So m+1 can be at most 59, meaning m can be at most 58.\n    for m in range(3, 60): # Iterate m from 3 up to 58\n        # Binary search for k\n        # k must be > 1. Smallest k is 2.\n        # Largest k: k^m < n => k < n^(1/m).\n        # For m=3, n=10^18, k < 10^6.\n        # For m=58, n=10^18, k < 2.04, so k can only be 2.\n        \n        low = 2\n        # Upper bound for k: n^(1/m) + a small buffer for float precision.\n        # Cap it at a reasonable maximum to prevent excessively large search spaces.\n        # Max possible k is around 10^6, so 2*10^6 is a safe upper bound.\n        high = min(int(n**(1/m)) + 2, 2 * 10**6) \n\n        while low <= high:\n            mid = (low + high) // 2\n            if mid < 2: # k must be > 1, adjust low if it somehow becomes less than 2\n                low = 2\n                continue\n\n            current_sum = 0\n            current_term = 1 # Represents k^0\n            \n            # Calculate 1 + mid + mid^2 + ... + mid^m\n            # The loop runs m+1 times (for powers 0 to m)\n            overflow = False\n            for _ in range(m + 1):\n                current_sum += current_term\n                if current_sum > n: # Check if sum exceeds n\n                    overflow = True\n                    break\n                \n                # Prepare for next term: current_term * mid\n                # Only multiply if there's a next term (i.e., not the last iteration)\n                if _ < m: \n                    # Check for overflow before multiplication: if current_term * mid > n,\n                    # then current_term > n / mid.\n                    if current_term > n // mid: \n                        overflow = True\n                        break\n                    current_term *= mid\n            \n            if overflow:\n                high = mid - 1 # mid is too large\n            elif current_sum == n:\n                sys.stdout.write(\"YES\\n\")\n                return\n            else: # current_sum < n\n                low = mid + 1 # mid is too small\n\n    sys.stdout.write(\"NO\\n\")\n\n\nnum_test_cases = int(sys.stdin.readline())\nfor _ in range(num_test_cases):\n    solve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n\n    # Base cases: n < 7 cannot be a snowflake (min is 1 + 2 + 2^2 = 7 for k=2, d=1)\n    if n < 7:\n        sys.stdout.write(\"NO\\n\")\n        return\n\n    # Case 1: m = 2 (d = 1), n = 1 + k + k^2\n    # This is k^2 + k + (1 - n) = 0\n    # k = (-1 + sqrt(4n - 3)) / 2\n    discriminant = 4 * n - 3\n    \n    # Check if discriminant is a perfect square\n    s = round(discriminant**0.5)\n    if s * s == discriminant:\n        # For k to be an integer, (-1 + s) must be even, so s must be odd.\n        # For k > 1, (-1 + s) / 2 > 1 => -1 + s > 2 => s > 3.\n        if s % 2 == 1 and s > 3:\n            # k_val = (s - 1) // 2. Since s > 3, k_val will be > 1.\n            sys.stdout.write(\"YES\\n\")\n            return\n\n    # Case 2: m >= 3 (d >= 2), n = 1 + k + k^2 + ... + k^m\n    # Max m: 2^(m+1) - 1 <= 10^18 => m+1 <= log2(10^18 + 1) approx 59.79.\n    # So m+1 can be at most 59, meaning m can be at most 58.\n    for m in range(3, 60): # Iterate m from 3 up to 58\n        # Binary search for k\n        # k must be > 1. Smallest k is 2.\n        # Largest k: k^m < n => k < n^(1/m).\n        # For m=3, n=10^18, k < 10^6.\n        # For m=58, n=10^18, k < 2.04, so k can only be 2.\n        \n        low = 2\n        # Upper bound for k: n^(1/m) + a small buffer for float precision.\n        # Cap it at a reasonable maximum to prevent excessively large search spaces.\n        # Max possible k is around 10^6, so 2*10^6 is a safe upper bound.\n        high = min(int(n**(1/m)) + 2, 2 * 10**6) \n\n        while low <= high:\n            mid = (low + high) // 2\n            if mid < 2: # k must be > 1, adjust low if it somehow becomes less than 2\n                low = 2\n                continue\n\n            current_sum = 0\n            current_term = 1 # Represents k^0\n            \n            # Calculate 1 + mid + mid^2 + ... + mid^m\n            # The loop runs m+1 times (for powers 0 to m)\n            overflow = False\n            for _ in range(m + 1):\n                current_sum += current_term\n                if current_sum > n: # Check if sum exceeds n\n                    overflow = True\n                    break\n                \n                # Prepare for next term: current_term * mid\n                # Only multiply if there's a next term (i.e., not the last iteration)\n                if _ < m: \n                    # Check for overflow before multiplication: if current_term * mid > n,\n                    # then current_term > n / mid.\n                    if current_term > n // mid: \n                        overflow = True\n                        break\n                    current_term *= mid\n            \n            if overflow:\n                high = mid - 1 # mid is too large\n            elif current_sum == n:\n                sys.stdout.write(\"YES\\n\")\n                return\n            else: # current_sum < n\n                low = mid + 1 # mid is too small\n\n    sys.stdout.write(\"NO\\n\")\n\n\nnum_test_cases = int(sys.stdin.readline())\nfor _ in range(num_test_cases):\n    solve()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 559,
        "completion_token_count": 3640,
        "thoughts_token_count": 8191
    }
}