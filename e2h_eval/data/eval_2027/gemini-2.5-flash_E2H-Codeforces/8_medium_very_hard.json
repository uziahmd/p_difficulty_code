{
    "start": 1758011918.850303,
    "end": 1758012014.6232893,
    "start-formatted": "2025-09-16 17:38 KST",
    "end-formatted": "2025-09-16 17:40 KST",
    "gpu": 2,
    "pid": 8,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "**Initial Thoughts on \"Flawed Flow\" Problem**\n\nOkay, so I'm looking at this \"Flawed Flow\" problem, and my first instinct is to think about it as a directed graph problem with flow constraints, but the \"no cycles\" condition is the real key here. We need to direct edges in an undirected graph to make a Directed Acyclic Graph (DAG) with specific flow properties.\n\nBreaking it down:\n\n*   **Flow Conservation (1 < v < n):** For all intermediate nodes, the total incoming flow must equal the outgoing flow. Standard flow constraint.\n*   **Source Constraint (v = 1):** No incoming edges. This tells me the source is like a \"generator\" of flow.\n*   **No Cycles:** This is the big one. A DAG allows for topological ordering.  It also means the flow is unidirectional in a global sense. Vertex 1 must be the first node in the topological order.\n*   **Sink (v = n):**  Not explicitly constrained, but all flow must leave the system (or be \"consumed\" by the sink).\n\nSo, the \"no cycles\" condition is the most restrictive.  If a solution exists, there must be some way to order the vertices.  If we can assign a \"potential\" or \"level\" to each node, so that edges always go from a lower potential to a higher potential, then there are no cycles.  Vertex 1 is the lowest potential.\n\nNow, let's consider the flow. For each intermediate node, we need to balance the in-flow and out-flow.  This seems a bit like finding a topological sort with flow constraints.  What if we look at this as assigning edge directions based on the current \"imbalance\" at each vertex?\n\nFor a vertex 'v', let's say \"balance[v]\" = (outgoing flow) - (incoming flow).  We need `balance[v]` to be zero for the intermediates. The source must generate the total flow, and the sink absorbs it. This means `balance[v]` has to be positive for the source, negative for the sink, and zero for all the others.\n\nThis sounds like a topological sort with balancing constraints. We want to guide edges such that no cycles are formed and the net flow at each node has a target value: 0 for all except the source, which has to produce a positive value, and the sink that must have a negative one.\n\nI'm thinking we can use a queue and keep track of something like \"deficit\". Start with all deficits equal to zero and as we change the edge directions we update these \"deficits\". The total \"deficit\" is equal to flow volume (sum of capacity).\n\nFor each vertex `v`, we can keep track of incoming and outgoing flows and target them. Vertex 1 and Vertex n are special: they need to have special handling. Vertex 1 must have no incoming flow and vertex `n` absorbs it completely.\n\nLet's rethink this \"deficit\" idea. Each vertex has an inherent \"need\" or \"deficit\" based on flow direction.\n\nThe problem guarantees there is a solution. No matter the edge arrangement, we have to make the edge directions such that there are no cycles and flow is conserved in any intermediate node.\nSo, the question is how to make the best decision when we direct edge flows in order to prevent creating cycles and satisfy the flow constraints.\n\nI'm thinking of building the flow network step by step. We have an adjacency matrix. If an edge has flow volume 'c':\n1. We start by ensuring that all edges connecting to the source are outgoing from it.\n2. For the remaining edges, we have to direct them carefully, such that there is a topological order that exists.\n3. If there is a \"topological order\", this implies that the graph is a Directed Acyclic Graph (DAG).\n4. After determining the directions, we check if all nodes have balanced flow, and the sink absorbs all the total flow and we are done.\n\nSo, for each vertex `v`, with the help of `total_incident_flow[v]`, which can be derived from the input, can make a decision for each edge direction for the DAG structure. The algorithm would likely be iterative, picking and applying edges and then reevaluating.\nThis seems like a promising direction to solve the problem.\n",
    "response": "The problem asks us to direct a given set of undirected edges, each with a specified flow volume, such that three conditions are met:\n1.  **Flow Conservation:** For any intermediate vertex `v` (1 < `v` < `n`), the total incoming flow equals the total outgoing flow.\n2.  **Source Constraint:** Vertex 1 (the source) has no incoming edges.\n3.  **Acyclicity:** The resulting directed graph contains no cycles.\n\nWe are guaranteed that a solution always exists.\n\nLet's analyze the conditions:\n\n**Condition 2: Source Constraint**\nVertex 1 having no incoming edges means that any edge `(1, v)` must be directed `1 -> v`, and any edge `(v, 1)` must be directed `v -> 1`. This effectively means all edges incident to vertex 1 must be directed *away* from vertex 1. This is a strong initial hint.\n\n**Condition 3: Acyclicity**\nIf the graph must be a Directed Acyclic Graph (DAG), then there exists a topological ordering of its vertices. This means we can assign a \"potential\" or \"level\" to each vertex such that all directed edges go from a lower potential vertex to a higher potential vertex. This implies that we can process vertices in a specific order.\n\n**Combining Insights: A Topological Approach**\nThe source (vertex 1) must be one of the \"first\" vertices in any topological order, as it has no incoming edges. This suggests a Kahn's algorithm-like approach.\n\nLet's maintain a `current_excess[v]` for each vertex `v`. `current_excess[v]` will be `(sum of flow into v) - (sum of flow out of v)`.\nInitially, all `current_excess[v]` are 0.\n\n1.  **Initialize and Handle Source Edges:**\n    *   Store all edges with their original indices to output the directions correctly.\n    *   For each vertex `v`, calculate `total_incident_flow[v]`, which is the sum of flow volumes of all edges connected to `v`. This will be useful later.\n    *   Initialize `current_excess[v] = 0` for all `v`.\n    *   Initialize an empty queue `q`.\n    *   For each edge `(a_i, b_i, c_i)` with original index `idx_i`:\n        *   If `a_i == 1`: Direct `1 -> b_i`. Set `ans[idx_i] = 0`. Add `c_i` to `current_excess[b_i]`.\n        *   If `b_i == 1`: Direct `a_i -> 1`. Set `ans[idx_i] = 1`. Add `c_i` to `current_excess[a_i]`.\n        *   If neither `a_i` nor `b_i` is 1, the edge remains undirected for now. Store these edges.\n\n    After this step, `current_excess[1]` will be 0 (as all flow from 1 is outgoing, contributing negatively to its own excess, but we only add to other nodes' excess). For other nodes `v`, `current_excess[v]` will store the flow received from vertex 1.\n\n2.  **Identify Initial \"Pushers\":**\n    For any intermediate vertex `v` (1 < `v` < `n`), we eventually need `current_excess[v] = 0`.\n    If `current_excess[v]` is currently positive, it means `v` has received flow (possibly from 1 or other directed edges) and now needs to *send out* that much flow to balance itself. These are the nodes that can \"push\" flow forward.\n    Add all intermediate vertices `v` (1 < `v` < `n`) for which `current_excess[v] > 0` to the queue `q`. These are our initial \"pushers\".\n\n3.  **Topological Processing:**\n    While the queue `q` is not empty:\n    *   Dequeue a vertex `u`.\n    *   `u` currently has `current_excess[u] > 0`. It needs to send out `current_excess[u]` flow.\n    *   Iterate through all *undirected* edges `(u, v, c)` incident to `u` (where `v != 1` and `v != n`, or `v == n`). We must direct these edges such that `u` sends out its excess flow.\n    *   For each such undirected edge `(u, v, c)`:\n        *   Direct the edge `u -> v`. Set `ans[idx_uv] = 0` (if `u` was `a` in `(a,b)` and `v` was `b`) or `ans[idx_uv] = 1` (if `u` was `b` and `v` was `a`).\n        *   Subtract `c` from `current_excess[u]` (because `u` sent `c` flow).\n        *   Add `c` to `current_excess[v]` (because `v` received `c` flow).\n        *   Mark the edge as directed so it's not processed again.\n        *   If `v` is an intermediate node (1 < `v` < `n`) and `current_excess[v]` becomes positive after receiving flow, and `v` hasn't been added to the queue yet for its current 'pushing' state, add `v` to `q`. This ensures `v` will eventually send out its excess.\n        *   Continue directing edges from `u` until `current_excess[u]` becomes 0.\n\n    **Why this works for acyclicity:**\n    By always directing edges from a node `u` that has `current_excess[u] > 0` (meaning it has received flow and needs to send it out) to its neighbors, we are essentially simulating a flow propagation. Nodes that receive flow eventually become \"pushers\" themselves. Since vertex 1 is the ultimate source and only sends flow, and vertex `n` is the ultimate sink (it just accumulates flow and doesn't need to balance to 0), this process naturally creates a topological order. Flow always moves from nodes with \"excess\" to nodes that \"need\" flow or can accumulate it. This prevents cycles because a cycle would imply a node receiving flow from itself or a node it has already sent flow to, which would require `current_excess` to be positive in a cycle, which cannot be resolved without a sink. The guarantee that a solution exists implies such a topological order can be found.\n\n    **Handling the Sink (vertex n):**\n    Vertex `n` does not need to balance its flow (`current_excess[n]` does not need to be 0). It will simply accumulate all the flow. So, if `v` is `n`, we just update `current_excess[n]` and don't add `n` to the queue.\n\n    The problem guarantees a solution exists, so this process will successfully direct all edges and `current_excess[v]` will become 0 for all `1 < v < n`, and `current_excess[n]` will hold the total max flow value.\n\n**Detailed Algorithm Steps:**\n\n1.  Read `n`, `m`.\n2.  Create an adjacency list `adj` where `adj[u]` stores tuples `(v, c, original_idx)` for all edges `(u, v, c)`. Store edges in a list `edges_data` for easy access to `(a, b, c)` and `original_idx`.\n3.  Initialize `ans = [-1] * m`. This will store the final directions.\n4.  Initialize `current_excess = [0] * (n + 1)`.\n5.  Initialize `edge_ptr = [0] * (n + 1)`. This will help iterate through undirected edges efficiently.\n6.  Initialize an empty queue `q`.\n\n7.  **First Pass (Handle Source and Initial Excess):**\n    For `idx` from `0` to `m-1`:\n        Let `(u, v, c)` be `edges_data[idx]`.\n        If `u == 1`:\n            `ans[idx] = 0` (direct `1 -> v`)\n            `current_excess[v] += c`\n        Else if `v == 1`:\n            `ans[idx] = 1` (direct `u -> 1`)\n            `current_excess[u] += c`\n        Else:\n            // This edge is still undirected.\n            // No action needed for current_excess yet, it will be processed later.\n\n8.  **Populate Initial Queue:**\n    For `v` from `2` to `n-1`: (intermediate vertices)\n        If `current_excess[v] > 0`:\n            `q.append(v)`\n\n9.  **Process Queue (Topological Sort):**\n    While `q` is not empty:\n        `u = q.pop(0)` // Dequeue\n        If `u == n`: continue // Sink doesn't need to balance\n\n        // `u` needs to send out `current_excess[u]` flow.\n        // Iterate through its neighbors using `edge_ptr[u]` to find undirected edges.\n        while `current_excess[u] > 0` and `edge_ptr[u] < len(adj[u])`:\n            `v, c, idx = adj[u][edge_ptr[u]]`\n            `edge_ptr[u] += 1`\n\n            If `ans[idx] != -1`: continue // Edge already directed\n\n            // Direct `u -> v`\n            If `edges_data[idx][0] == u`: // Original edge was (u, v)\n                `ans[idx] = 0`\n            Else: // Original edge was (v, u)\n                `ans[idx] = 1`\n\n            `current_excess[u] -= c`\n            `current_excess[v] += c`\n\n            If `v != 1` and `v != n` and `current_excess[v] > 0`:\n                // If `v` is an intermediate node and now has excess, add it to queue\n                // (only if it wasn't already processing or in queue for this excess state)\n                // A simple check is to re-add, but for efficiency, ensure it's not already in queue\n                // For competitive programming, re-adding is often fine if queue size isn't an issue.\n                // A more robust way is to use a `visited_in_queue` set.\n                // Given constraints and problem type, simple append is likely okay.\n                `q.append(v)` // Add to queue to process its new excess\n\n10. **Output Results:**\n    Print each `ans[i]`.\n\n**Example Walkthrough (First Example):**\n\n`n=3, m=3`\nEdges:\n`0: (3, 2, 10)`\n`1: (1, 2, 10)`\n`2: (3, 1, 5)`\n\n`adj`:\n`1: [(2, 10, 1), (3, 5, 2)]`\n`2: [(3, 10, 0), (1, 10, 1)]`\n`3: [(2, 10, 0), (1, 5, 2)]`\n\n`edges_data`:\n`0: (3, 2, 10)`\n`1: (1, 2, 10)`\n`2: (3, 1, 5)`\n\n`ans = [-1, -1, -1]`\n`current_excess = [0, 0, 0, 0]`\n`q = []`\n\n**Step 7 (First Pass):**\n*   `idx = 0`, `(3, 2, 10)`: Neither 1. Undirected.\n*   `idx = 1`, `(1, 2, 10)`: `u=1`. `ans[1] = 0` (1->2). `current_excess[2] += 10`. `current_excess = [0, 0, 10, 0]`.\n*   `idx = 2`, `(3, 1, 5)`: `v=1`. `ans[2] = 1` (3->1). `current_excess[3] += 5`. `current_excess = [0, 0, 10, 5]`.\n\n**Step 8 (Populate Initial Queue):**\nIntermediate nodes: only `v=2`.\n`current_excess[2] = 10 > 0`. So, `q.append(2)`. `q = [2]`.\n\n**Step 9 (Process Queue):**\n*   `q = [2]`. `u = q.pop(0)` -> `u = 2`. `current_excess[2] = 10`.\n*   `u=2` needs to send out 10 flow.\n*   `adj[2]` is `[(3, 10, 0), (1, 10, 1)]`.\n*   `edge_ptr[2]` starts at 0.\n*   Process `(3, 10, 0)` from `adj[2]`:\n    *   `v=3, c=10, idx=0`. `ans[0]` is -1 (undirected).\n    *   Original edge `edges_data[0]` is `(3, 2, 10)`. Since `u=2` is `b` in `(a,b)`, we want `2 -> 3`. So `ans[0] = 1`.\n    *   `current_excess[2] -= 10`. `current_excess = [0, 0, 0, 5]`.\n    *   `current_excess[3] += 10`. `current_excess = [0, 0, 0, 15]`.\n    *   `v=3` is `n`. Don't add to queue.\n    *   `current_excess[2]` is now 0. Loop terminates for `u=2`.\n\n**Step 9 (Process Queue) - continued:**\n*   `q` is empty. Loop terminates.\n\n**Step 10 (Output):**\n`ans = [1, 0, 1]`\nThis matches the example output.\n\nThis approach seems robust and correctly handles the constraints. The key is that \"no cycles\" allows us to process nodes in a topological fashion, and the source constraint provides the initial nodes for this process.\n\n```python\nimport sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    # Store edges with their original index\n    # edges_data[i] = (u, v, c) for the i-th edge\n    edges_data = []\n    # adj[u] stores list of (neighbor_v, capacity_c, original_edge_idx)\n    adj = [[] for _ in range(n + 1)]\n\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        edges_data.append((u, v, c))\n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n\n    # ans[i] will store 0 if flow is edges_data[i].u -> edges_data[i].v\n    # and 1 if flow is edges_data[i].v -> edges_data[i].u\n    ans = [-1] * m\n\n    # current_excess[v] = (sum of flow into v) - (sum of flow out of v)\n    current_excess = [0] * (n + 1)\n\n    # Queue for nodes that have an excess of incoming flow and need to send it out\n    q = deque()\n\n    # edge_ptr[u] helps iterate through adj[u] to find undirected edges\n    # without re-processing already directed ones\n    edge_ptr = [0] * (n + 1)\n\n    # First pass: Handle edges connected to source (vertex 1)\n    # All edges incident to vertex 1 must be directed AWAY from 1.\n    for i in range(m):\n        u, v, c = edges_data[i]\n        if u == 1:\n            ans[i] = 0 # 1 -> v\n            current_excess[v] += c\n        elif v == 1:\n            ans[i] = 1 # u -> 1\n            current_excess[u] += c\n        # Edges not connected to 1 are left undirected for now\n\n    # Populate the queue with intermediate nodes (2 to n-1) that have an excess\n    # (i.e., they received flow and need to send it out to balance)\n    for v_node in range(2, n): # Iterate from 2 to n-1 (inclusive)\n        if current_excess[v_node] > 0:\n            q.append(v_node)\n\n    # Process nodes in a topological-like order\n    while q:\n        u = q.popleft()\n\n        # If u is the sink (n), it just accumulates flow, no need to balance\n        # (though the problem states 1 < v < n for balancing, this check is for safety)\n        if u == n: \n            continue\n\n        # While u still has excess flow to send out and there are undirected edges from u\n        while current_excess[u] > 0 and edge_ptr[u] < len(adj[u]):\n            v, c, idx = adj[u][edge_ptr[u]]\n            edge_ptr[u] += 1\n\n            if ans[idx] != -1: # This edge has already been directed\n                continue\n\n            # Direct u -> v\n            original_u, original_v, _ = edges_data[idx]\n            if original_u == u:\n                ans[idx] = 0 # Flow is u -> v\n            else: # original_v == u\n                ans[idx] = 1 # Flow is u -> v (which means original_v -> original_u)\n\n            current_excess[u] -= c\n            current_excess[v] += c\n\n            # If v is an intermediate node (not 1 and not n) and now has an excess,\n            # add it to the queue to process its outgoing flow later.\n            # No need to check if it's already in the queue; re-adding is fine for correctness\n            # and usually doesn't hurt performance too much in competitive programming unless queue size explodes.\n            if 1 < v < n and current_excess[v] > 0:\n                q.append(v)\n    \n    # Output the directions\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + '\\n')\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    # Store edges with their original index\n    # edges_data[i] = (u, v, c) for the i-th edge\n    edges_data = []\n    # adj[u] stores list of (neighbor_v, capacity_c, original_edge_idx)\n    adj = [[] for _ in range(n + 1)]\n\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        edges_data.append((u, v, c))\n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n\n    # ans[i] will store 0 if flow is edges_data[i].u -> edges_data[i].v\n    # and 1 if flow is edges_data[i].v -> edges_data[i].u\n    ans = [-1] * m\n\n    # current_excess[v] = (sum of flow into v) - (sum of flow out of v)\n    current_excess = [0] * (n + 1)\n\n    # Queue for nodes that have an excess of incoming flow and need to send it out\n    q = deque()\n\n    # edge_ptr[u] helps iterate through adj[u] to find undirected edges\n    # without re-processing already directed ones\n    edge_ptr = [0] * (n + 1)\n\n    # First pass: Handle edges connected to source (vertex 1)\n    # All edges incident to vertex 1 must be directed AWAY from 1.\n    for i in range(m):\n        u, v, c = edges_data[i]\n        if u == 1:\n            ans[i] = 0 # 1 -> v\n            current_excess[v] += c\n        elif v == 1:\n            ans[i] = 1 # u -> 1\n            current_excess[u] += c\n        # Edges not connected to 1 are left undirected for now\n\n    # Populate the queue with intermediate nodes (2 to n-1) that have an excess\n    # (i.e., they received flow and need to send it out to balance)\n    for v_node in range(2, n): # Iterate from 2 to n-1 (inclusive)\n        if current_excess[v_node] > 0:\n            q.append(v_node)\n\n    # Process nodes in a topological-like order\n    while q:\n        u = q.popleft()\n\n        # If u is the sink (n), it just accumulates flow, no need to balance\n        # (though the problem states 1 < v < n for balancing, this check is for safety)\n        if u == n: \n            continue\n\n        # While u still has excess flow to send out and there are undirected edges from u\n        while current_excess[u] > 0 and edge_ptr[u] < len(adj[u]):\n            v, c, idx = adj[u][edge_ptr[u]]\n            edge_ptr[u] += 1\n\n            if ans[idx] != -1: # This edge has already been directed\n                continue\n\n            # Direct u -> v\n            original_u, original_v, _ = edges_data[idx]\n            if original_u == u:\n                ans[idx] = 0 # Flow is u -> v\n            else: # original_v == u\n                ans[idx] = 1 # Flow is u -> v (which means original_v -> original_u)\n\n            current_excess[u] -= c\n            current_excess[v] += c\n\n            # If v is an intermediate node (not 1 and not n) and now has an excess,\n            # add it to the queue to process its outgoing flow later.\n            # No need to check if it's already in the queue; re-adding is fine for correctness\n            # and usually doesn't hurt performance too much in competitive programming unless queue size explodes.\n            if 1 < v < n and current_excess[v] > 0:\n                q.append(v)\n    \n    # Output the directions\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + '\\n')\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 746,
        "completion_token_count": 4334,
        "thoughts_token_count": 7509
    }
}