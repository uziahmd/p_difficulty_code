{
    "start": 1758285016.7329206,
    "end": 1758285047.9250257,
    "start-formatted": "2025-09-19 21:30 KST",
    "end-formatted": "2025-09-19 21:30 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "**Tackling a Challenging Graph Problem**\n\nOkay, so I'm diving into this competitive programming problem, and the core of it is understanding the interplay between reachability and graph structure. My goal is to figure out the *minimum* number of nodes, `n`, needed to create a directed graph with a specific characteristic: it must be a `p`-reachable graph. And second, among all the optimal graphs with that minimum `n`, I need to identify the *maximum* number of unidirectional node pairs.\n\nLet's unpack these definitions.  Reachability is standard: a path from `u` to `v` means `v` is reachable from `u`.  Crucially, \"reachable from each other\" means there's a path both ways, implying `u` and `v` are within the same strongly connected component (SCC).\n\nThe `p`-reachable part is key.  It stipulates exactly `p` ordered pairs of nodes, `(u, v)`, where `u < v`, and `u` and `v` are mutually reachable.  The `u < v` constraint is important. For a pair `u,v` in the same SCC, only the pair with the smaller first value counts towards `p`.\n\nThis means SCCs are the fundamental building blocks.  Within an SCC of size `k`, there are `k * (k - 1) / 2` *unordered* pairs of distinct nodes. But due to the `u < v` condition, this translates to exactly one pair per unordered pair contributing to `p`. So, an SCC of size `k` (where `k >= 2`) contributes `k * (k - 1) / 2` to `p`. SCCs of size 1 don't contribute.\n\nSo if I have SCCs with sizes `k_1, k_2, ..., k_m`, the total count, `p`, will be the sum of these contributions: `sum(k_i * (k_i - 1) / 2)`.\n\nMy first goal is to minimize the total number of nodes, `n`. This means I need to maximize the size of these SCCs because it produces more pairs for each node. To achieve a given `p`, the larger the SCC size, the better. Let `f(k) = k * (k - 1) / 2`. So, I'm aiming for `sum(f(k_i)) = p` while minimizing `n = sum(k_i)`. The ideal is to have a single SCC that gets as close as possible to covering `p`, by finding a `k` to minimize the number of nodes.\n",
    "response": "The problem asks us to find two values for a given integer `p`:\n1. The minimum number of nodes `n` required to create a `p`-reachable directed graph.\n2. Among all such `p`-reachable directed graphs with the minimum `n`, the maximum number of unidirectional pairs of nodes.\n\nLet's define the terms:\n- An ordered pair of nodes `(u, v)` is **unidirectional** if `u != v`, there is a path from `u` to `v`, and there are no paths from `v` to `u`.\n- A directed graph is **`p`-reachable** if it contains exactly `p` ordered pairs of nodes `(u, v)` such that `u < v` and `u` and `v` are reachable from each other.\n\n**Part 1: Minimum number of nodes `n`**\n\nNodes `u` and `v` are reachable from each other if and only if they belong to the same strongly connected component (SCC). The condition `u < v` means we only count one pair for each set of two distinct nodes in an SCC.\nIf an SCC has size `k`, it contributes `k * (k - 1) / 2` such pairs `(u, v)` with `u < v`. An SCC of size 1 contributes 0 pairs.\n\nLet `f(k) = k * (k - 1) / 2`. We want to find `n = sum(k_i)` such that `sum(f(k_i)) = p` and `n` is minimized.\nTo minimize `n` for a fixed `p`, we should use larger SCCs. This is because `f(k)` grows quadratically with `k`, while `n` grows linearly. Specifically, `f(k)/k = (k-1)/2`, which increases with `k`. So, larger `k` means more `p` pairs per node.\n\nWe can use a greedy approach. We want to represent `p` as a sum of `f(k_i)` values. To minimize `sum(k_i)`, we should prioritize using the largest possible `k` values.\nLet `k_max` be the largest integer such that `f(k_max) <= p`.\nWe can take an SCC of size `k_max`. This uses `k_max` nodes and contributes `f(k_max)` to `p`. The remaining `p' = p - f(k_max)` pairs need to be formed. We then recursively find the minimum nodes for `p'`.\nThis strategy is optimal because `f(k)` is a convex function, and for convex functions, it's always optimal to take the largest possible value that fits.\n\nThe maximum value of `p` is `2 * 10^5`.\nWe can precompute `f(k)` values:\n`f(1) = 0`\n`f(2) = 1`\n`f(3) = 3`\n...\n`f(632) = 632 * 631 / 2 = 199396`\n`f(633) = 633 * 632 / 2 = 200016` (This exceeds `2 * 10^5`)\nSo, the maximum `k` we'll need is around 632.\n\nAlgorithm for minimum `n`:\n1. Initialize `min_n = 0`.\n2. While `p > 0`:\n   a. Find the largest integer `k` such that `k * (k - 1) / 2 <= p`.\n   b. Add `k` to `min_n`.\n   c. Subtract `k * (k - 1) / 2` from `p`.\n3. The final `min_n` is the minimum number of nodes.\n\nExample: `p = 3`\n- `k=2: f(2)=1`. `k=3: f(3)=3`. Largest `k` s.t. `f(k) <= 3` is `k=3`.\n- `min_n = 3`. `p = 3 - f(3) = 3 - 3 = 0`.\n- Loop ends. `min_n = 3`.\n\nExample: `p = 4`\n- Largest `k` s.t. `f(k) <= 4` is `k=3` (`f(3)=3`).\n- `min_n = 3`. `p = 4 - f(3) = 4 - 3 = 1`.\n- `p = 1`. Largest `k` s.t. `f(k) <= 1` is `k=2` (`f(2)=1`).\n- `min_n = 3 + 2 = 5`. `p = 1 - f(2) = 1 - 1 = 0`.\n- Loop ends. `min_n = 5`.\n\n**Part 2: Maximum number of unidirectional pairs**\n\nA unidirectional pair `(u, v)` exists if there's a path `u -> v` but no path `v -> u`. This means `u` and `v` are in different SCCs, and there's a path from `u`'s SCC to `v`'s SCC in the condensation graph (DAG of SCCs).\n\nTo maximize unidirectional pairs, we want to connect as many nodes as possible in a chain-like structure in the condensation graph.\nConsider `min_n` nodes. Suppose these nodes are partitioned into `m` SCCs with sizes `k_1, k_2, ..., k_m`.\nThe total number of nodes is `N = sum(k_i)`.\nThe number of unidirectional pairs is maximized when these `m` SCCs are arranged in a single directed path in the condensation graph.\nFor example, `SCC_1 -> SCC_2 -> ... -> SCC_m`.\nIn this arrangement, every node in `SCC_i` can reach every node in `SCC_j` if `i < j`.\nThe number of unidirectional pairs from `SCC_i` to `SCC_j` (where `i < j`) is `k_i * k_j`.\nThe total number of unidirectional pairs would be `sum_{1 <= i < j <= m} (k_i * k_j)`.\n\nThis sum `sum_{i < j} (k_i * k_j)` is related to the square of the sum of `k_i`s:\n`(sum k_i)^2 = sum(k_i^2) + 2 * sum_{i < j} (k_i * k_j)`.\nSo, `sum_{i < j} (k_i * k_j) = ((sum k_i)^2 - sum(k_i^2)) / 2`.\nSince `sum k_i = N` (the total number of nodes), we want to maximize `(N^2 - sum(k_i^2)) / 2`.\nThis is equivalent to minimizing `sum(k_i^2)`.\n\nTo minimize `sum(k_i^2)` for a fixed sum `N = sum(k_i)`, the values `k_i` should be as close to each other as possible.\nHowever, the `k_i` values are not arbitrary. They are determined by the greedy strategy for minimizing `n`.\nThe greedy strategy for `min_n` generates `k_i` values such that `k_1 >= k_2 >= ... >= k_m`.\nThese `k_i` values are chosen from the sequence `k_s` where `f(k_s)` is the largest `f(k)` less than or equal to the remaining `p`.\nIt turns out that these `k_i` values are already \"spread out\" as much as possible, which means `sum(k_i^2)` will be minimized for a given `N` and given that `p = sum(f(k_i))`.\n\nSo, the strategy is:\n1. Use the same greedy algorithm as for `min_n` to find the sequence of SCC sizes `k_1, k_2, ..., k_m`. Store these `k_i` values.\n2. Calculate `N = sum(k_i)`.\n3. Calculate `sum_sq_k = sum(k_i^2)`.\n4. The maximum number of unidirectional pairs is `(N^2 - sum_sq_k) / 2`.\n\nLet's re-verify the examples:\n\nExample: `p = 3`\n1. `k_1 = 3`. `p = 0`.\n2. `min_n = 3`. `k_values = [3]`.\n3. `N = 3`. `sum_sq_k = 3^2 = 9`.\n4. Unidirectional pairs = `(3^2 - 9) / 2 = (9 - 9) / 2 = 0`.\nOutput: `3 0`. Matches example.\n\nExample: `p = 4`\n1. `k_1 = 3`. `p = 4 - 3 = 1`.\n2. `k_2 = 2`. `p = 1 - 1 = 0`.\n3. `min_n = 3 + 2 = 5`. `k_values = [3, 2]`.\n4. `N = 3 + 2 = 5`. `sum_sq_k = 3^2 + 2^2 = 9 + 4 = 13`.\n5. Unidirectional pairs = `(5^2 - 13) / 2 = (25 - 13) / 2 = 12 / 2 = 6`.\nOutput: `5 6`. Matches example.\n\nExample: `p = 0`\n1. `p = 0`. No SCCs of size >= 2.\n2. `min_n = 0`. `k_values = []`.\n3. `N = 0`. `sum_sq_k = 0`.\n4. Unidirectional pairs = `(0^2 - 0) / 2 = 0`.\nOutput: `0 0`. Matches example.\n\nThis approach seems correct and covers all cases.\n\n**Implementation details:**\n- Precompute `f(k)` values up to `k=632` (or slightly more, e.g., 650 to be safe).\n- Store these `f(k)` values and their corresponding `k` in a way that allows efficient lookup for the largest `k` such that `f(k) <= p_remaining`. A list of `(f(k), k)` pairs sorted by `f(k)` in ascending order, or iterating `k` downwards from `632` will work.\n- `p` can be `0`. Handle this case.\n\n```python\nimport math\n\ndef solve():\n    p = int(input())\n\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    # Precompute f(k) = k * (k - 1) / 2 values\n    # Max p is 2 * 10^5.\n    # k * (k - 1) / 2 <= 2 * 10^5\n    # k^2 approx 4 * 10^5\n    # k approx sqrt(4 * 10^5) = sqrt(40 * 10^4) = 200 * sqrt(10) approx 200 * 3.16 = 632\n    \n    # We'll store (f_val, k) pairs for k >= 2\n    f_values_map = []\n    for k_val in range(2, 650): # 650 is a safe upper bound for k\n        f_val = k_val * (k_val - 1) // 2\n        if f_val > 2 * 10**5: # Optimization: stop if f_val exceeds max_p\n            break\n        f_values_map.append((f_val, k_val))\n    \n    # min_n: total number of nodes\n    # k_components: list to store the sizes of SCCs chosen\n    min_n = 0\n    k_components = []\n\n    current_p = p\n    # Iterate from largest k to smallest k to find the largest f(k) <= current_p\n    # This is equivalent to finding the largest k_val in f_values_map such that f_val <= current_p\n    # Since f_values_map is sorted by f_val, we can iterate backwards or use binary search.\n    # Iterating backwards is simple enough given the small size of f_values_map.\n    while current_p > 0:\n        found_k = 0\n        found_f_val = 0\n        \n        # Find the largest k_val such that f_val <= current_p\n        for f_val, k_val in reversed(f_values_map):\n            if f_val <= current_p:\n                found_k = k_val\n                found_f_val = f_val\n                break\n        \n        # This case should not happen if p is valid and f_values_map is sufficiently large.\n        # If current_p > 0 but no f_val <= current_p is found, it means current_p is 1.\n        # The smallest f_val > 0 is f(2)=1. So if current_p=1, found_k=2.\n        if found_k == 0: # This means current_p must be 1, and we need k=2 (f(2)=1)\n             # This check is technically redundant if f_values_map correctly includes f(2)=1.\n             # It means our loop for f_values_map should at least include k=2.\n             # The loop `range(2, 650)` ensures this.\n             pass # Should always find a k if current_p > 0\n\n        min_n += found_k\n        k_components.append(found_k)\n        current_p -= found_f_val\n\n    # Calculate max unidirectional pairs\n    # Total nodes N = sum(k_i) = min_n\n    # Sum of squares of k_i: sum_sq_k = sum(k_i^2)\n    # Unidirectional pairs = (N^2 - sum_sq_k) / 2\n    \n    total_nodes_N = min_n\n    sum_sq_k = 0\n    for k_val in k_components:\n        sum_sq_k += k_val * k_val\n    \n    max_unidirectional_pairs = (total_nodes_N * total_nodes_N - sum_sq_k) // 2\n    \n    print(min_n, max_unidirectional_pairs)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef solve():\n    p = int(input())\n\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    # Precompute f(k) = k * (k - 1) / 2 values\n    # Max p is 2 * 10^5.\n    # k * (k - 1) / 2 <= 2 * 10^5\n    # k^2 approx 4 * 10^5\n    # k approx sqrt(4 * 10^5) = sqrt(40 * 10^4) = 200 * sqrt(10) approx 200 * 3.16 = 632\n    \n    # We'll store (f_val, k) pairs for k >= 2\n    f_values_map = []\n    for k_val in range(2, 650): # 650 is a safe upper bound for k\n        f_val = k_val * (k_val - 1) // 2\n        if f_val > 2 * 10**5: # Optimization: stop if f_val exceeds max_p\n            break\n        f_values_map.append((f_val, k_val))\n    \n    # min_n: total number of nodes\n    # k_components: list to store the sizes of SCCs chosen\n    min_n = 0\n    k_components = []\n\n    current_p = p\n    # Iterate from largest k to smallest k to find the largest f(k) <= current_p\n    # This is equivalent to finding the largest k_val in f_values_map such that f_val <= current_p\n    # Since f_values_map is sorted by f_val, we can iterate backwards or use binary search.\n    # Iterating backwards is simple enough given the small size of f_values_map.\n    while current_p > 0:\n        found_k = 0\n        found_f_val = 0\n        \n        # Find the largest k_val such that f_val <= current_p\n        for f_val, k_val in reversed(f_values_map):\n            if f_val <= current_p:\n                found_k = k_val\n                found_f_val = f_val\n                break\n        \n        # This case should not happen if p is valid and f_values_map is sufficiently large.\n        # If current_p > 0 but no f_val <= current_p is found, it means current_p is 1.\n        # The smallest f_val > 0 is f(2)=1. So if current_p=1, found_k=2.\n        if found_k == 0: # This means current_p must be 1, and we need k=2 (f(2)=1)\n             # This check is technically redundant if f_values_map correctly includes f(2)=1.\n             # It means our loop for f_values_map should at least include k=2.\n             # The loop `range(2, 650)` ensures this.\n             pass # Should always find a k if current_p > 0\n\n        min_n += found_k\n        k_components.append(found_k)\n        current_p -= found_f_val\n\n    # Calculate max unidirectional pairs\n    # Total nodes N = sum(k_i) = min_n\n    # Sum of squares of k_i: sum_sq_k = sum(k_i^2)\n    # Unidirectional pairs = (N^2 - sum_sq_k) / 2\n    \n    total_nodes_N = min_n\n    sum_sq_k = 0\n    for k_val in k_components:\n        sum_sq_k += k_val * k_val\n    \n    max_unidirectional_pairs = (total_nodes_N * total_nodes_N - sum_sq_k) // 2\n    \n    print(min_n, max_unidirectional_pairs)\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 482,
        "completion_token_count": 3393,
        "thoughts_token_count": 853
    }
}