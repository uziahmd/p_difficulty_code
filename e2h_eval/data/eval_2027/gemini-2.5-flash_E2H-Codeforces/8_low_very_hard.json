{
    "start": 1758009378.6648257,
    "end": 1758009517.9820254,
    "start-formatted": "2025-09-16 16:56 KST",
    "end-formatted": "2025-09-16 16:58 KST",
    "gpu": 2,
    "pid": 8,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "**Tackling the \"Flawed Flow\" Problem**\n\nOkay, so I need to craft a Python script to solve this \"Flawed Flow\" problem. Let's break this down systematically. The core of the issue is figuring out the direction of flow on each edge in a given undirected graph, aiming to satisfy some specific constraints.\n\nFirst, the input: We're given an undirected graph with 'n' vertices and 'm' edges. Each edge `(a_i, b_i)` comes with a capacity `c_i`. Vertex 1 is the source, and vertex 'n' is the sink. The output I need is a direction for each edge: `0` for `a_i -> b_i` and `1` for `b_i -> a_i`.\n\nNow, the crucial constraints that define a valid flow direction. The first, and most important one, is **flow conservation** – for every internal vertex (excluding the source and sink), the incoming flow must equal the outgoing flow. The source has no incoming edges, and, since it’s a standard max-flow setup, I'll assume the sink consumes all incoming flow and has no outgoing flow. The problem statement isn't entirely explicit on this, but the context and the aim of maximizing flow from source to sink strongly suggests that. It's a key detail to keep in mind.\n\nThe second, and really interesting condition, is that the final directed graph must be **acyclic**. This is a big clue. If the graph is acyclic, it implies a topological ordering of the vertices. In the flow network, flow generally goes from vertices that are \"earlier\" in the topological order to vertices that are \"later\" in the order. This really gives me a direction to work with - try to assign directions so flow *generally* moves from the source to the sink.\n\nThere's something interesting about the flow conservation condition. If I consider any internal vertex, the total flow incident to that vertex (sum of capacities on the edges connected to it) must be even. It's an obvious consequence of having incoming and outgoing edges with the flows balancing out.\n\nSo, the key here is to leverage the acyclicity and flow conservation constraints to direct edges appropriately, keeping in mind the source and sink roles. The acyclicity requirement probably hints towards a topological sort approach, potentially combined with some iterative flow assignment. This is the path to explore.\n",
    "response": "The problem asks us to assign directions to given undirected edges, each with a specified flow volume, such that the resulting directed graph represents a valid maximum flow from source (vertex 1) to sink (vertex n). The conditions for a valid flow are:\n1.  For any internal vertex `v` (1 < `v` < `n`), the sum of incoming flow volumes equals the sum of outgoing flow volumes.\n2.  Vertex 1 (source) has no incoming edges.\n3.  The resulting directed graph must not contain any cycles.\n\nThe acyclicity condition is crucial. If a directed graph has no cycles, it implies that there exists a topological ordering of its vertices. In a flow network, flow typically moves from \"earlier\" vertices to \"later\" vertices in such an ordering. This suggests that we should try to direct edges such that flow generally moves away from the source (vertex 1) and towards the sink (vertex n).\n\nLet's consider the flow conservation at an internal vertex `v`. If `S_in` is the sum of incoming flows and `S_out` is the sum of outgoing flows, we need `S_in = S_out`. The total flow incident to `v` (sum of `c_i` for all edges connected to `v`) is `S_in + S_out = 2 * S_in`. This means that for any internal vertex `v`, the sum of flow volumes on all its incident edges must be an even number. This property is guaranteed if a solution exists.\n\nThe problem guarantees that a solution always exists. This is a strong hint. A common strategy for problems involving acyclic graphs and flow-like properties is to use a Depth First Search (DFS) or Breadth First Search (BFS) to establish an ordering or process vertices.\n\nConsider a DFS traversal starting from an arbitrary vertex. When we traverse an edge `(u, v)` from `u` to `v` during DFS, `v` becomes a child of `u` in the DFS tree. If we direct edges based on the DFS tree structure (e.g., parent to child), this naturally avoids cycles within the tree edges. Back-edges (edges connecting a vertex to an already visited ancestor) would form cycles if directed `child -> ancestor`. However, the problem implies a global topological sort, so we can't just direct all tree edges one way.\n\nA more robust approach for flow problems with specific source/sink and acyclicity is to use the concept of \"potential\" or \"distance\" from the source. If we could assign a \"level\" `L(v)` to each vertex `v` such that all directed edges `u -> v` satisfy `L(u) < L(v)`, then the graph would be acyclic. A BFS from the source (vertex 1) naturally assigns such levels (shortest path distance from source). However, this doesn't directly tell us how to direct edges that are not part of the BFS tree.\n\nLet's try a simpler approach related to the flow conservation. For each vertex `v` (1 < `v` < `n`), we need to balance its incoming and outgoing flow. Let `current_flow_out[v]` be the net flow that *must* leave `v` to satisfy conservation. Initially, `current_flow_out[v]` is 0 for all `v`.\nWhen we direct an edge `u -> v` with flow `c`, `current_flow_out[u]` decreases by `c` and `current_flow_out[v]` increases by `c`. We want `current_flow_out[v]` to be 0 for all `v` (1 < `v` < `n`) after all edges are directed.\n\nConsider processing vertices in a specific order. Which order? Perhaps one that allows us to make local decisions that lead to a global solution. A common technique in competitive programming for tree-like structures or graphs where local decisions propagate is to use a DFS from the source (or from leaves towards root in a tree).\n\nLet's try a DFS from vertex 1. We want to direct edges such that flow generally moves away from 1.\nWhen we are at vertex `u` and explore an edge `(u, v)`:\n1.  If `v` is `n` (the sink): We *must* direct flow `u -> n`. This is because `n` is the sink, and flow is supposed to go towards it. Also, directing `n -> u` would mean flow leaving the sink, which is not standard.\n2.  If `v` is `1` (the source): We *must* direct flow `v -> u` (i.e., `1 -> u`). This is because the source has no incoming edges.\n3.  If `v` is an internal vertex (1 < `v` < `n`):\n    *   If `v` has not been visited yet: Recurse on `v`. After the recursive call returns, `v` would have balanced all flow within its subtree (except possibly for the edge `(u,v)` itself). Now, `v` might have a net flow that needs to be balanced through the edge `(u,v)`.\n    *   If `v` has been visited: This is a back-edge or cross-edge. We need to avoid cycles.\n\nThis approach is tricky because the total flow at an internal vertex `v` must be exactly balanced. A simpler way to think about it is to keep track of the *sum of flow values on edges that we have decided to direct *into* `v`* and *sum of flow values on edges that we have decided to direct *out of* `v`*.\n\nLet `balance[v]` be the net incoming flow for vertex `v` from all edges directed so far. Initially, `balance[v] = 0` for all `v`.\nWhen we process an edge `(a_i, b_i)` with flow `c_i`:\nIf we direct `a_i -> b_i`, then `balance[b_i]` increases by `c_i`, and `balance[a_i]` effectively decreases by `c_i` (representing flow leaving `a_i`).\nIf we direct `b_i -> a_i`, then `balance[a_i]` increases by `c_i`, and `balance[b_i]` effectively decreases by `c_i`.\n\nFor `v` (1 < `v` < `n`), we need its total incoming flow to equal its total outgoing flow. This means that after all edges incident to `v` are directed, `balance[v]` must be 0.\nFor `v=1`, `balance[1]` must be non-positive (flow only leaves).\nFor `v=n`, `balance[n]` must be non-negative (flow only enters).\n\nThe key insight for this type of problem often involves a DFS from the source, accumulating flow.\nLet `dfs(u, p)` be a function that explores from `u`, with `p` as its parent in the DFS tree.\nInside `dfs(u, p)`:\nInitialize `current_out_flow_from_u = 0`. This variable will track the net flow that needs to leave `u` towards its parent `p` (if `u != 1`).\nFor each edge `(u, v)` with flow `c`:\n  If `v == p`: continue (don't go back to parent immediately).\n  If `v == n`: Direct `u -> n`. Add `c` to `current_out_flow_from_u` (flow leaves `u`). Store `ans[edge_idx] = 0` if `u=a_i, v=b_i` or `1` if `u=b_i, v=a_i`.\n  If `v == 1`: Direct `1 -> u`. Subtract `c` from `current_out_flow_from_u` (flow enters `u`). Store `ans[edge_idx] = 0` if `1=a_i, u=b_i` or `1` if `1=b_i, u=a_i`.\n  If `v` is unvisited:\n    `flow_from_v_to_u = dfs(v, u)`. This `flow_from_v_to_u` is the net flow that `v` sends *back to* `u` to satisfy `v`'s conservation.\n    If `flow_from_v_to_u > 0`: Direct `v -> u`. Add `flow_from_v_to_u` to `current_out_flow_from_u`. Store `ans[edge_idx] = 1` if `v=a_i, u=b_i` or `0` if `v=b_i, u=a_i`.\n    Else (`flow_from_v_to_u <= 0`): Direct `u -> v`. Subtract `flow_from_v_to_u` from `current_out_flow_from_u` (which means `current_out_flow_from_u` increases by `abs(flow_from_v_to_u)`). Store `ans[edge_idx] = 0` if `u=a_i, v=b_i` or `1` if `u=b_i, v=a_i`.\n  If `v` is visited and `v != p`: This is a cross-edge or back-edge. Since we want an acyclic graph and flow from 1 to n, we should generally direct flow from \"earlier\" visited nodes to \"later\" visited nodes. Or, if `v` is an ancestor, direct `u -> v` to avoid cycles (this is a tricky part).\n    A simpler approach for visited nodes: just direct `u -> v`. This is because `v` must have already balanced its internal flow, and we generally want flow to move away from the source. Add `c` to `current_out_flow_from_u`. Store `ans[edge_idx] = 0` if `u=a_i, v=b_i` or `1` if `u=b_i, v=a_i`. This might be too simplistic and create cycles.\n\nThe problem states \"the obtained directed graph does not have cycles.\" This is the hardest constraint.\nA standard way to ensure acyclicity in a flow network is to establish a topological ordering or a layered graph.\n\nLet's refine the DFS approach. We need to assign directions such that for any internal node `v`, its net flow is zero.\nWe can use a DFS starting from vertex 1. When we traverse an edge `(u, v)`:\n1.  If `v` is the parent `p`, skip.\n2.  Mark `v` as visited.\n3.  Recursively call `dfs(v, u)`.\n4.  After `dfs(v, u)` returns, `v` has processed all its children in the DFS tree. Now, `v` has a certain `net_flow_at_v` (sum of flows coming in minus sum of flows going out, considering only edges within the subtree rooted at `v` and edges `v -> w` where `w` is an already visited non-parent).\n5.  The edge `(u, v)` is the *only* remaining edge incident to `v` that can be used to balance `net_flow_at_v`.\n    *   If `net_flow_at_v > 0`: It means `v` has an excess of incoming flow. This excess *must* leave `v` through `(u, v)`. So, direct `v -> u`. `net_flow_at_v` amount of flow travels `v -> u`.\n    *   If `net_flow_at_v < 0`: It means `v` has an excess of outgoing flow. This deficit *must* be supplied by flow coming into `v` through `(u, v)`. So, direct `u -> v`. `abs(net_flow_at_v)` amount of flow travels `u -> v`.\n    *   If `net_flow_at_v = 0`: This case shouldn't happen for the edge `(u,v)` to have a flow `c_i > 0`. The value `c_i` on edge `(u,v)` must be equal to `abs(net_flow_at_v)`.\n\nThis DFS approach works for trees or tree-like structures. The value `net_flow_at_v` would be the sum of all `c_i` values on edges in the subtree of `v` that are directed towards `v` minus those directed away from `v`. The edge `(u,v)` would then be directed to balance this `net_flow_at_v` with its own `c_i`.\n\nWhat about non-tree edges (back-edges or cross-edges)? When `dfs(u, p)` encounters an edge `(u, v)` where `v` is already visited and `v != p`:\nThis edge `(u, v)` is a non-tree edge. If we direct `u -> v`, it might create a cycle `u -> v -> ... -> u`. If we direct `v -> u`, it might also create a cycle.\nTo ensure acyclicity, we must direct edges from a \"lower level\" vertex to a \"higher level\" vertex in a topological sense. A simple DFS assigns discovery times. Directing from a higher discovery time to a lower discovery time on a back-edge creates a cycle. So, for a back-edge `(u, v)` where `v` is an ancestor of `u`, we must direct `u -> v`. For a cross-edge `(u, v)` where `v` is in another subtree and already visited, we must direct `u -> v` if `v` was discovered earlier than `u`.\n\nThis suggests that we can use a DFS to build a DFS tree.\nFor tree edges `(u, v)` (where `v` is unvisited):\n  Recursively call `dfs(v, u)`.\n  After `dfs(v, u)` returns, `v` has a `current_flow_balance[v]` (net flow from its children and cross-edges within its subtree).\n  The edge `(u, v)` with flow `c` needs to be directed to balance `current_flow_balance[v]`.\n  If `current_flow_balance[v] > 0` (excess incoming flow at `v` from its subtree): direct `v -> u`. Update `current_flow_balance[u] += c`.\n  If `current_flow_balance[v] < 0` (excess outgoing flow at `v` from its subtree): direct `u -> v`. Update `current_flow_balance[u] -= c`.\n  The value `c` on edge `(u,v)` must match `abs(current_flow_balance[v])`. This means `current_flow_balance[v]` is reset to 0 after its edge to `u` is directed.\n\nFor non-tree edges `(u, v)` (where `v` is visited and `v != p`):\n  We need to direct this edge. To ensure acyclicity, we can use the `discovery_time` (or `tin`) of vertices. If `tin[u] < tin[v]`, then `u` was discovered before `v`. Direct `u -> v`.\n  If `tin[v] < tin[u]`, then `v` was discovered before `u`. Direct `v -> u`.\n  This rule for non-tree edges ensures acyclicity: flow always goes from earlier discovered to later discovered, or in the case of back-edges, from child to ancestor (which is `u -> v` if `v` is an ancestor of `u`, then `tin[v] < tin[u]`). Wait, if `v` is an ancestor, `tin[v] < tin[u]`. Directing `v -> u` would be `ancestor -> child`. Directing `u -> v` would be `child -> ancestor`. The latter creates a cycle. So we must direct `v -> u` for back-edges? This is confusing.\n\nLet's re-evaluate the acyclicity constraint with DFS. A directed graph is acyclic if and only if there are no back-edges to an already visited ancestor in a DFS traversal *when all edges are directed according to discovery order*. If we direct tree edges `parent -> child`, and back-edges `child -> ancestor`, this creates cycles.\nTo avoid cycles, we need to ensure that if `u -> v` is an edge, then `v` is not an ancestor of `u` *and* `u` is not an ancestor of `v` if `v` was visited before `u` in a way that implies `v` is \"earlier\" in the topological sort.\n\nA simpler rule to guarantee acyclicity:\nPerform a DFS from vertex 1. Assign `discovery_time[v]` for each `v`.\nWhen considering an edge `(u, v)`:\n1. If `v` is unvisited: This is a tree edge. Recurse `dfs(v, u)`.\n2. If `v` is visited:\n   *   If `discovery_time[u] < discovery_time[v]`: Direct `u -> v`. This is a forward edge or a cross edge.\n   *   If `discovery_time[v] < discovery_time[u]`: Direct `v -> u`. This is a back edge or a cross edge.\n\nThis rule for non-tree edges guarantees acyclicity. Any edge `(x, y)` will be directed such that flow goes from `x` to `y` if `discovery_time[x] < discovery_time[y]`, or `y` to `x` if `discovery_time[y] < discovery_time[x]`. This means flow always goes from a vertex with smaller discovery time to a vertex with larger discovery time. This establishes a topological ordering based on discovery times, thus ensuring acyclicity.\n\nNow, integrate this with flow conservation.\nWe need `balance[v] = 0` for `1 < v < n`.\nLet `current_net_flow_out[u]` be the amount of flow that *must* leave `u` via its parent edge `(u,p)` to satisfy conservation for `u` and its descendants.\nInitialize `current_net_flow_out[u] = 0` for all `u`.\n`visited` array, `discovery_time` array.\n`adj` list stores `(neighbor, flow_capacity, original_edge_index)`.\n\n`dfs(u, p)`:\n  `visited[u] = True`\n  `discovery_time[u] = timer` (increment `timer`)\n  `sum_flow_out_of_u_to_children_and_cross_edges = 0`\n\n  For each `(v, c, edge_idx)` in `adj[u]`:\n    If `v == p`: continue\n    If `visited[v]`: // Non-tree edge\n      If `discovery_time[u] < discovery_time[v]`: // u was discovered before v\n        // Direct u -> v. Flow leaves u.\n        `ans[edge_idx] = 0` if `u == original_a_i` else `1`\n        `sum_flow_out_of_u_to_children_and_cross_edges += c`\n      Else: // v was discovered before u (back-edge or cross-edge)\n        // Direct v -> u. Flow enters u.\n        `ans[edge_idx] = 1` if `u == original_a_i` else `0`\n        `sum_flow_out_of_u_to_children_and_cross_edges -= c`\n    Else: // Tree edge, v is unvisited\n      `flow_from_v_to_u = dfs(v, u)`\n      If `flow_from_v_to_u > 0`: // Excess flow at v, must go v -> u\n        // Direct v -> u. Flow enters u.\n        `ans[edge_idx] = 1` if `u == original_a_i` else `0`\n        `sum_flow_out_of_u_to_children_and_cross_edges -= c`\n      Else: // Deficit flow at v, must go u -> v\n        // Direct u -> v. Flow leaves u.\n        `ans[edge_idx] = 0` if `u == original_a_i` else `1`\n        `sum_flow_out_of_u_to_children_and_cross_edges += c`\n\n  For `u == 1` (source): `sum_flow_out_of_u_to_children_and_cross_edges` must be the total flow from source to sink. We don't return anything.\n  For `u == n` (sink): `sum_flow_out_of_u_to_children_and_cross_edges` must be the total flow from source to sink, but negative (all flow enters `n`). We don't return anything.\n  For `1 < u < n`: We must return `sum_flow_out_of_u_to_children_and_cross_edges`. This is the net flow that needs to be balanced by the edge `(u, p)`. This value *must* be `0` after considering all edges *except* `(u,p)`.\n  Wait, this is not quite right. The `current_net_flow_out[u]` is supposed to be the *total* flow that passes through `u` and its subtree, and eventually leaves `u` via `(u,p)`.\n\nLet `flow_balance[u]` be the sum of `c_i` for edges directed `u -> v` minus `c_i` for edges directed `v -> u`, for all edges `(u, v)` where `v` is in the subtree of `u` (or `v` is a cross-edge with `discovery_time[u] < discovery_time[v]`).\n`dfs(u, p)`:\n  `visited[u] = True`\n  `discovery_time[u] = timer` (increment `timer`)\n  `current_node_balance = 0` // Net flow *into* u from its children and non-tree edges\n\n  For each `(v, c, edge_idx)` in `adj[u]`:\n    If `v == p`: continue\n    If `visited[v]`: // Non-tree edge\n      If `discovery_time[u] < discovery_time[v]`: // u was discovered before v\n        // Direct u -> v. Flow leaves u.\n        `ans[edge_idx] = 0` if `u == original_a_i` else `1`\n        `current_node_balance -= c`\n      Else: // v was discovered before u (back-edge or cross-edge)\n        // Direct v -> u. Flow enters u.\n        `ans[edge_idx] = 1` if `u == original_a_i` else `0`\n        `current_node_balance += c`\n    Else: // Tree edge, v is unvisited\n      `flow_from_subtree_v = dfs(v, u)` // This is the net flow *out of* v's subtree\n      // If flow_from_subtree_v > 0, it means flow leaves v's subtree via (v,u). So v -> u.\n      // If flow_from_subtree_v < 0, it means flow enters v's subtree via (v,u). So u -> v.\n      // The value `c` on edge (u,v) must be `abs(flow_from_subtree_v)`.\n      // We are given `c`, so `flow_from_subtree_v` must be `c` or `-c`.\n      // The problem states \"the resulting flow should be correct maximum flow\". This implies flow conservation.\n      // So, if `flow_from_subtree_v` is positive, it means `v` has an excess of `flow_from_subtree_v` units of flow that must leave `v` via `(v,u)`.\n      // The edge `(u,v)` has capacity `c`. So `flow_from_subtree_v` should be exactly `c`.\n      // If `flow_from_subtree_v` is negative, it means `v` has a deficit of `abs(flow_from_subtree_v)` units of flow that must enter `v` via `(u,v)`.\n      // The edge `(u,v)` has capacity `c`. So `abs(flow_from_subtree_v)` should be exactly `c`.\n      // This implies `flow_from_subtree_v` must be `c` or `-c`.\n\n      // Let's assume `flow_from_subtree_v` is the *net flow exiting* `v` via `(v,u)`.\n      // So `flow_from_subtree_v` is the sum of flows that exit `v` from its children, minus flows that enter `v` from its children.\n      // `flow_from_subtree_v` is the net flow from `v`'s subtree that needs to be balanced by the edge `(u,v)`.\n      // If `flow_from_subtree_v > 0`: means `v` has an excess of `flow_from_subtree_v` to send to `u`. So `v -> u`.\n      //   `ans[edge_idx] = 1` if `u == original_a_i` else `0`\n      //   `current_node_balance += c` (flow enters `u`)\n      // Else (`flow_from_subtree_v <= 0`): means `v` needs `abs(flow_from_subtree_v)` from `u`. So `u -> v`.\n      //   `ans[edge_idx] = 0` if `u == original_a_i` else `1`\n      //   `current_node_balance -= c` (flow leaves `u`)\n\n  // After processing all neighbors, `current_node_balance` is the net flow into `u` from its children's subtrees and non-tree edges.\n  // This `current_node_balance` must be passed up to `p` via `(u,p)`.\n  // If `u` is the source (1), it must have no incoming flow. So `current_node_balance` should be 0.\n  // If `u` is the sink (n), it must have no outgoing flow. So `current_node_balance` should be the total flow.\n  // For internal nodes (1 < u < n), `current_node_balance` must be 0.\n  // The problem guarantees a solution exists, so `current_node_balance` will be 0 for internal nodes.\n  // So, for internal nodes, we return 0.\n  // For source (1), return 0. (It has no parent to send flow to).\n  // For sink (n), return 0. (It has no parent to send flow to).\n\nThis logic has a flaw: `flow_from_subtree_v` must be `c` or `-c`. The value `c` is fixed.\nThe `current_node_balance` tracks how much flow *enters* `u` from its children and cross-edges.\nFor `u` (1 < `u` < `n`), this `current_node_balance` *must* be 0 after considering all edges *except* `(u,p)`.\nThis means the `c` on `(u,p)` must be equal to `abs(current_node_balance)`.\n\nLet's use `flow_diff[u]` to store the net flow into `u` from its children and cross-edges.\n`dfs(u, p)`:\n  `visited[u] = True`\n  `discovery_time[u] = timer`\n  `timer += 1`\n  `flow_diff[u] = 0`\n\n  For each `(v, c, edge_idx)` in `adj[u]`:\n    If `v == p`: continue\n    If `visited[v]`: // Non-tree edge\n      If `discovery_time[u] < discovery_time[v]`: // u was discovered before v\n        // Direct u -> v. Flow leaves u.\n        `ans[edge_idx] = 0` if `u == original_a_i` else `1`\n        `flow_diff[u] -= c`\n      Else: // v was discovered before u (back-edge or cross-edge)\n        // Direct v -> u. Flow enters u.\n        `ans[edge_idx] = 1` if `u == original_a_i` else `0`\n        `flow_diff[u] += c`\n    Else: // Tree edge, v is unvisited\n      `dfs(v, u)` // Recurse\n      // After dfs(v, u) returns, `flow_diff[v]` contains the net flow into `v` from its children and non-tree edges.\n      // This `flow_diff[v]` must be balanced by the edge `(u,v)`.\n      // If `flow_diff[v] > 0`: `v` has an excess of incoming flow. This must leave `v` via `(v,u)`.\n      //   So, direct `v -> u`. Flow `c` enters `u`.\n      //   `ans[edge_idx] = 1` if `u == original_a_i` else `0`\n      //   `flow_diff[u] += c`\n      // Else (`flow_diff[v] <= 0`): `v` has a deficit of incoming flow (or excess outgoing flow). This must be supplied by `u` via `(u,v)`.\n      //   So, direct `u -> v`. Flow `c` leaves `u`.\n      //   `ans[edge_idx] = 0` if `u == original_a_i` else `1`\n      //   `flow_diff[u] -= c`\n\n  // After the loop, `flow_diff[u]` holds the net flow into `u` from all its neighbors *except* parent `p`.\n  // For `u` being an internal node (1 < u < n), `flow_diff[u]` must be 0 for flow conservation.\n  // This implies that the sum of `c` values on edges directed into `u` equals sum of `c` values on edges directed out of `u`.\n  // If `u` is 1 (source), `flow_diff[1]` should be the negative of total max flow (total flow leaving 1).\n  // If `u` is n (sink), `flow_diff[n]` should be the total max flow (total flow entering n).\n\nThe crucial part is that `flow_diff[u]` for `1 < u < n` must be `0`. The problem guarantees a solution exists.\nThe `flow_diff[u]` value that we calculate within the DFS for `u` is actually the `net_flow_out_of_subtree_rooted_at_u`.\nLet `dfs(u, p)` return `net_flow_out_of_subtree_rooted_at_u`.\n`dfs(u, p)`:\n  `visited[u] = True`\n  `discovery_time[u] = timer`\n  `timer += 1`\n  `current_flow_sum = 0` // This will be the sum of flows that are *forced* to leave 'u' or enter 'u' from its children's subtrees and cross-edges.\n\n  For each `(v, c, edge_idx)` in `adj[u]`:\n    If `v == p`: continue\n    If `visited[v]`: // Non-tree edge\n      If `discovery_time[u] < discovery_time[v]`: // u was discovered before v\n        // Direct u -> v. Flow leaves u.\n        `ans[edge_idx] = 0` if `u == original_a_i` else `1`\n        `current_flow_sum += c`\n      Else: // v was discovered before u (back-edge or cross-edge)\n        // Direct v -> u. Flow enters u.\n        `ans[edge_idx] = 1` if `u == original_a_i` else `0`\n        `current_flow_sum -= c`\n    Else: // Tree edge, v is unvisited\n      `flow_from_subtree_v = dfs(v, u)`\n      // `flow_from_subtree_v` is the net flow that *leaves* `v`'s subtree towards `u`.\n      // This flow must be `c` or `-c` (the capacity of edge `(u,v)`).\n      // If `flow_from_subtree_v > 0`: `v` wants to send `flow_from_subtree_v` to `u`. So `v -> u`.\n      //   `ans[edge_idx] = 1` if `u == original_a_i` else `0`\n      //   `current_flow_sum -= c` (flow enters `u` from `v`, so it's a \"negative\" contribution to flow *leaving* `u`)\n      // Else (`flow_from_subtree_v <= 0`): `v` wants to receive `abs(flow_from_subtree_v)` from `u`. So `u -> v`.\n      //   `ans[edge_idx] = 0` if `u == original_a_i` else `1`\n      //   `current_flow_sum += c` (flow leaves `u` to `v`)\n\n  // After the loop, `current_flow_sum` is the net flow that *leaves* `u` to its children's subtrees and non-tree edges.\n  // For `u` being an internal node (1 < u < n), this `current_flow_sum` must be 0 after considering all edges *except* `(u,p)`.\n  // The problem implies that for an internal node `u`, the sum of `c` values on edges directed into `u` equals sum of `c` values on edges directed out of `u`.\n  // So, `current_flow_sum` must be the capacity of the edge `(u,p)` if `u` is to send flow to `p`, or negative capacity if `u` is to receive flow from `p`.\n  // This `current_flow_sum` is what `u` needs to balance with `p`.\n  // So, `dfs` returns `current_flow_sum`.\n\n  // Special handling for source and sink:\n  // If `u == 1` (source): `current_flow_sum` is the total flow leaving the source. This is the max flow. We don't need to return anything.\n  // If `u == n` (sink): `current_flow_sum` must be 0, as no flow leaves the sink. But this is not necessarily true. Flow can leave `n` to other nodes if `n` is not strictly a sink. The problem says \"sum of ci of incoming edges is equal to the sum of ci of outcoming edges\" for `1 < v < n`. This means `n` is NOT strictly a sink, it's just a special vertex. But then where does the flow go? The most natural interpretation of \"source and sink\" in max flow is that source only produces flow, sink only consumes flow. The problem states \"vertex with number 1 has no incoming edges\". It *doesn't* state \"vertex with number n has no outgoing edges\". However, if `n` is an internal node in terms of flow conservation, then `flow_diff[n]` must be 0.\n  // The Note in the example: \"10 flow units pass through path 1->2->3, and 5 flow units pass directly from source to sink: 1->3.\" In this example, vertex 3 is the sink.\n  // For example 1:\n  // (3,2,10), (1,2,10), (3,1,5)\n  // Output: 1, 0, 1\n  // (3,2,10) -> 2->3 (1) means 2->3 flow 10\n  // (1,2,10) -> 1->2 (0) means 1->2 flow 10\n  // (3,1,5) -> 1->3 (1) means 1->3 flow 5\n  // Directed: 1->2 (10), 2->3 (10), 1->3 (5)\n  // Vertex 1: Outgoing 1->2 (10), 1->3 (5). Total 15. Incoming 0. (OK)\n  // Vertex 2: Incoming 1->2 (10). Outgoing 2->3 (10). Total 10. (OK)\n  // Vertex 3: Incoming 2->3 (10), 1->3 (5). Total 15. (OK, but it's the sink, so no outgoing flow is expected).\n  // This example implies that the sink `n` does not need to satisfy `S_in = S_out`. It only needs to have all flow conserved for `1 < v < n`.\n  // So for `u == n`, we just return `current_flow_sum`. This will be the total flow into the sink.\n\n  Return `current_flow_sum`.\n\nThe `flow_from_subtree_v` for `dfs(v,u)` is `current_flow_sum` of `v`.\nSo, if `current_flow_sum > 0` (net flow leaves `v`'s subtree towards `u`), then `v -> u`.\nIf `current_flow_sum < 0` (net flow enters `v`'s subtree from `u`), then `u -> v`.\nThe `c` on edge `(u,v)` must match `abs(current_flow_sum)`.\n\nLet's trace Example 1:\n`n=3, m=3`\nEdges:\n0: (3,2,10)\n1: (1,2,10)\n2: (3,1,5)\n\n`adj`:\n1: [(2,10,1), (3,5,2)]\n2: [(3,10,0), (1,10,1)]\n3: [(2,10,0), (1,5,2)]\n\n`ans = [0,0,0]` (size m)\n`visited = [F,F,F,F]`\n`discovery_time = [0,0,0,0]`\n`timer = 0`\n\nCall `dfs(1, 0)` (0 is dummy parent)\n  `u=1, p=0`\n  `visited[1] = T`, `discovery_time[1] = 0`, `timer = 1`\n  `current_flow_sum = 0`\n\n  Neighbors of 1:\n  1. `(v=2, c=10, edge_idx=1)`\n     `v != p`. `visited[2]` is `F`. Tree edge.\n     Call `dfs(2, 1)`\n       `u=2, p=1`\n       `visited[2] = T`, `discovery_time[2] = 1`, `timer = 2`\n       `current_flow_sum = 0`\n       Neighbors of 2:\n       1. `(v=3, c=10, edge_idx=0)`\n          `v != p`. `visited[3]` is `F`. Tree edge.\n          Call `dfs(3, 2)`\n            `u=3, p=2`\n            `visited[3] = T`, `discovery_time[3] = 2`, `timer = 3`\n            `current_flow_sum = 0`\n            Neighbors of 3:\n            1. `(v=2, c=10, edge_idx=0)`: `v == p`. Continue.\n            2. `(v=1, c=5, edge_idx=2)`: `v != p`. `visited[1]` is `T`. Non-tree edge.\n               `discovery_time[3] (2) > discovery_time[1] (0)`. So `v=1` was discovered before `u=3`.\n               Direct `v -> u` (1 -> 3).\n               Edge 2 is (3,1,5). `u=3, v=1`. Original `a_i=3, b_i=1`. We want `1 -> 3`. So `b_i -> a_i`. `ans[2] = 1`.\n               `current_flow_sum -= c` (flow enters `u=3` from `v=1`). `current_flow_sum = 0 - 5 = -5`.\n            Return `current_flow_sum` (-5) from `dfs(3, 2)`.\n          Back in `dfs(2, 1)`: `flow_from_subtree_v = -5`.\n          `flow_from_subtree_v <= 0`: `v=3` needs flow from `u=2`. Direct `u -> v` (2 -> 3).\n          Edge 0 is (3,2,10). `u=2, v=3`. Original `a_i=3, b_i=2`. We want `2 -> 3`. So `b_i -> a_i`. `ans[0] = 1`.\n          `current_flow_sum += c` (flow leaves `u=2` to `v=3`). `current_flow_sum = 0 + 10 = 10`.\n       2. `(v=1, c=10, edge_idx=1)`: `v != p`. `visited[1]` is `T`. Non-tree edge.\n          `discovery_time[2] (1) > discovery_time[1] (0)`. So `v=1` was discovered before `u=2`.\n          Direct `v -> u` (1 -> 2).\n          Edge 1 is (1,2,10). `u=2, v=1`. Original `a_i=1, b_i=2`. We want `1 -> 2`. So `a_i -> b_i`. `ans[1] = 0`.\n          `current_flow_sum -= c` (flow enters `u=2` from `v=1`). `current_flow_sum = 10 - 10 = 0`.\n       Return `current_flow_sum` (0) from `dfs(2, 1)`.\n     Back in `dfs(1, 0)`: `flow_from_subtree_v = 0`.\n     `flow_from_subtree_v <= 0`: `v=2` needs flow from `u=1`. Direct `u -> v` (1 -> 2).\n     Edge 1 is (1,2,10). `u=1, v=2`. Original `a_i=1, b_i=2`. We want `1 -> 2`. So `a_i -> b_i`. `ans[1] = 0`.\n     `current_flow_sum += c` (flow leaves `u=1` to `v=2`). `current_flow_sum = 0 + 10 = 10`.\n  2. `(v=3, c=5, edge_idx=2)`\n     `v != p`. `visited[3]` is `T`. Non-tree edge.\n     `discovery_time[1] (0) < discovery_time[3] (2)`. So `u=1` was discovered before `v=3`.\n     Direct `u -> v` (1 -> 3).\n     Edge 2 is (3,1,5). `u=1, v=3`. Original `a_i=3, b_i=1`. We want `1 -> 3`. So `b_i -> a_i`. `ans[2] = 1`.\n     `current_flow_sum += c` (flow leaves `u=1` to `v=3`). `current_flow_sum = 10 + 5 = 15`.\n\n  Return `current_flow_sum` (15) from `dfs(1, 0)`.\n\nFinal `ans`: `[1, 0, 1]`. This matches the example output!\n\nThe logic seems correct:\n1.  Use DFS to build a spanning forest (or tree, as the graph is connected).\n2.  Assign `discovery_time` to each node.\n3.  When traversing an edge `(u, v)`:\n    *   If `v` is unvisited: This is a tree edge. Recurse `dfs(v, u)`. After the recursive call returns, `dfs(v, u)` returns the net flow leaving `v`'s subtree. Let this be `flow_from_subtree_v`.\n        *   If `flow_from_subtree_v > 0`, it means `v` has an excess of flow from its subtree that must go to `u`. So direct `v -> u`. This flow `c` (capacity of `(u,v)`) enters `u`, so `u`'s `current_flow_sum` decreases by `c`.\n        *   If `flow_from_subtree_v < 0`, it means `v` needs `abs(flow_from_subtree_v)` flow from `u`. So direct `u -> v`. This flow `c` leaves `u`, so `u`'s `current_flow_sum` increases by `c`.\n        *   Crucially, `flow_from_subtree_v` must be `c` or `-c`. The problem guarantees a solution, so this will hold.\n    *   If `v` is visited and `v != p`: This is a non-tree edge.\n        *   To ensure acyclicity, direct flow from `lower_discovery_time` to `higher_discovery_time`.\n        *   If `discovery_time[u] < discovery_time[v]`: Direct `u -> v`. Flow leaves `u`, so `u`'s `current_flow_sum` increases by `c`.\n        *   If `discovery_time[v] < discovery_time[u]`: Direct `v -> u`. Flow enters `u`, so `u`'s `current_flow_sum` decreases by `c`.\n4.  The `current_flow_sum` returned by `dfs(u, p)` represents the net flow that *leaves* `u` towards `p` (or other parts of the graph not in `u`'s subtree).\n5.  The source (1) has no incoming edges. The sink (n) has no outgoing flow *that needs to be balanced*. Internal nodes `1 < v < n` must have `current_flow_sum = 0` after all their edges are directed (except possibly the parent edge, which is handled by the `dfs` return value).\n\nThe critical part is the definition of `current_flow_sum` and how it relates to `c`.\n`current_flow_sum` is the net flow *leaving* `u` through its children and non-tree edges.\nIf `flow_from_subtree_v` is the net flow *leaving* `v` via `(v,u)`:\n  If `flow_from_subtree_v > 0`: `v` sends flow `c` to `u`. This flow *enters* `u`. So `u`'s `current_flow_sum` (net flow leaving `u`) decreases by `c`.\n  If `flow_from_subtree_v < 0`: `v` receives flow `c` from `u`. This flow *leaves* `u`. So `u`'s `current_flow_sum` (net flow leaving `u`) increases by `c`.\n\nThis logic matches the example trace.\n\nImplementation details:\n*   Adjacency list: `adj[u]` stores `(v, c, original_edge_index, is_original_a_i_u)`. `is_original_a_i_u` is a boolean flag to easily determine `0` or `1` for `ans`.\n*   `ans` array of size `m`.\n*   `visited` array.\n*   `discovery_time` array.\n*   `timer` for `discovery_time`.\n\nMax N, M = 2e5. DFS is O(N+M). This is efficient enough. Recursion depth can be N, so Python's default recursion limit might be an issue. Increase it.\n\n```python\nimport sys\n\n# Increase recursion limit for deep DFS\nsys.setrecursionlimit(2 * 10**5 + 500)\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    edges_info = [] # Store (u, v, c) for original edge indexing\n\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        # Store (neighbor, flow_capacity, original_edge_index, is_u_original_a_i)\n        adj[u].append((v, c, i, True))\n        adj[v].append((u, c, i, False)) # For v, u is neighbor, u is original b_i\n\n    ans = [0] * m\n    visited = [False] * (n + 1)\n    discovery_time = [-1] * (n + 1)\n    timer = 0\n\n    # dfs(u, p) returns the net flow that leaves the subtree rooted at u\n    # towards its parent p. A positive value means flow goes u -> p.\n    # A negative value means flow goes p -> u.\n    def dfs(u, p):\n        nonlocal timer\n        visited[u] = True\n        discovery_time[u] = timer\n        timer += 1\n        \n        # current_flow_sum will track the net flow LEAVING u\n        # through its children's subtrees and non-tree edges.\n        current_flow_sum = 0 \n\n        for v, c, edge_idx, is_u_original_a_i in adj[u]:\n            if v == p:\n                continue\n\n            if visited[v]: # Non-tree edge\n                if discovery_time[u] < discovery_time[v]:\n                    # u was discovered before v. To ensure acyclicity, direct u -> v.\n                    # Flow leaves u.\n                    if is_u_original_a_i:\n                        ans[edge_idx] = 0 # a_i -> b_i\n                    else:\n                        ans[edge_idx] = 1 # b_i -> a_i (which is u -> v)\n                    current_flow_sum += c\n                else:\n                    # v was discovered before u (back-edge or cross-edge). To ensure acyclicity, direct v -> u.\n                    # Flow enters u.\n                    if is_u_original_a_i:\n                        ans[edge_idx] = 1 # a_i <- b_i (which is v -> u)\n                    else:\n                        ans[edge_idx] = 0 # b_i <- a_i\n                    current_flow_sum -= c\n            else: # Tree edge, v is unvisited\n                flow_from_subtree_v = dfs(v, u)\n                \n                # flow_from_subtree_v is the net flow that leaves v's subtree towards u.\n                # It must be equal to c or -c, the capacity of edge (u,v).\n                if flow_from_subtree_v > 0:\n                    # v wants to send flow_from_subtree_v (which is c) to u. So direct v -> u.\n                    # Flow enters u.\n                    if is_u_original_a_i:\n                        ans[edge_idx] = 1 # a_i <- b_i (which is v -> u)\n                    else:\n                        ans[edge_idx] = 0 # b_i <- a_i\n                    current_flow_sum -= c\n                else: # flow_from_subtree_v <= 0\n                    # v wants to receive abs(flow_from_subtree_v) (which is c) from u. So direct u -> v.\n                    # Flow leaves u.\n                    if is_u_original_a_i:\n                        ans[edge_idx] = 0 # a_i -> b_i\n                    else:\n                        ans[edge_idx] = 1 # b_i -> a_i (which is u -> v)\n                    current_flow_sum += c\n        \n        # For internal nodes (1 < u < n), the net flow must be zero.\n        # This means `current_flow_sum` must balance out with the flow on edge (u,p).\n        # The problem guarantees a solution, so `current_flow_sum` will be exactly +/- c for (u,p) or 0 for source/sink.\n        return current_flow_sum\n\n    # Start DFS from source (vertex 1)\n    dfs(1, 0) # 0 is a dummy parent for the source\n\n    for res in ans:\n        sys.stdout.write(str(res) + '\\n')\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\n# Increase recursion limit for deep DFS\nsys.setrecursionlimit(2 * 10**5 + 500)\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    edges_info = [] # Store (u, v, c) for original edge indexing\n\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        # Store (neighbor, flow_capacity, original_edge_index, is_u_original_a_i)\n        adj[u].append((v, c, i, True))\n        adj[v].append((u, c, i, False)) # For v, u is neighbor, u is original b_i\n\n    ans = [0] * m\n    visited = [False] * (n + 1)\n    discovery_time = [-1] * (n + 1)\n    timer = 0\n\n    # dfs(u, p) returns the net flow that leaves the subtree rooted at u\n    # towards its parent p. A positive value means flow goes u -> p.\n    # A negative value means flow goes p -> u.\n    def dfs(u, p):\n        nonlocal timer\n        visited[u] = True\n        discovery_time[u] = timer\n        timer += 1\n        \n        # current_flow_sum will track the net flow LEAVING u\n        # through its children's subtrees and non-tree edges.\n        current_flow_sum = 0 \n\n        for v, c, edge_idx, is_u_original_a_i in adj[u]:\n            if v == p:\n                continue\n\n            if visited[v]: # Non-tree edge\n                if discovery_time[u] < discovery_time[v]:\n                    # u was discovered before v. To ensure acyclicity, direct u -> v.\n                    # Flow leaves u.\n                    if is_u_original_a_i:\n                        ans[edge_idx] = 0 # a_i -> b_i\n                    else:\n                        ans[edge_idx] = 1 # b_i -> a_i (which is u -> v)\n                    current_flow_sum += c\n                else:\n                    # v was discovered before u (back-edge or cross-edge). To ensure acyclicity, direct v -> u.\n                    # Flow enters u.\n                    if is_u_original_a_i:\n                        ans[edge_idx] = 1 # a_i <- b_i (which is v -> u)\n                    else:\n                        ans[edge_idx] = 0 # b_i <- a_i\n                    current_flow_sum -= c\n            else: # Tree edge, v is unvisited\n                flow_from_subtree_v = dfs(v, u)\n                \n                # flow_from_subtree_v is the net flow that leaves v's subtree towards u.\n                # It must be equal to c or -c, the capacity of edge (u,v).\n                if flow_from_subtree_v > 0:\n                    # v wants to send flow_from_subtree_v (which is c) to u. So direct v -> u.\n                    # Flow enters u.\n                    if is_u_original_a_i:\n                        ans[edge_idx] = 1 # a_i <- b_i (which is v -> u)\n                    else:\n                        ans[edge_idx] = 0 # b_i <- a_i\n                    current_flow_sum -= c\n                else: # flow_from_subtree_v <= 0\n                    # v wants to receive abs(flow_from_subtree_v) (which is c) from u. So direct u -> v.\n                    # Flow leaves u.\n                    if is_u_original_a_i:\n                        ans[edge_idx] = 0 # a_i -> b_i\n                    else:\n                        ans[edge_idx] = 1 # b_i -> a_i (which is u -> v)\n                    current_flow_sum += c\n        \n        # For internal nodes (1 < u < n), the net flow must be zero.\n        # This means `current_flow_sum` must balance out with the flow on edge (u,p).\n        # The problem guarantees a solution, so `current_flow_sum` will be exactly +/- c for (u,p) or 0 for source/sink.\n        return current_flow_sum\n\n    # Start DFS from source (vertex 1)\n    dfs(1, 0) # 0 is a dummy parent for the source\n\n    for res in ans:\n        sys.stdout.write(str(res) + '\\n')\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 746,
        "completion_token_count": 12201,
        "thoughts_token_count": 755
    }
}