{
    "start": 1758284871.0146043,
    "end": 1758284906.959047,
    "start-formatted": "2025-09-19 21:27 KST",
    "end-formatted": "2025-09-19 21:28 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "**Breaking Down the Neko Maths Problem**\n\nOkay, so I'm tackling this \"Neko does Maths\" problem, and the core of it is finding a non-negative integer `k` that minimizes the least common multiple (LCM) of `a+k` and `b+k`. If there are ties for the smallest LCM, I need to pick the smallest `k`.\n\nMy initial thought is to set  `x = a+k` and `y = b+k`, and then minimize the `lcm(x, y)`. I know that  `lcm(x, y)` is `(x * y) / gcd(x, y)`.  The difference, `y - x`, is just `b - a`, which I'll call `d`.\n\nFirst, I need to handle a base case. If `a` and `b` are equal, then `d` is 0, and the LCM is just `a+k`. To minimize it, I'd choose `k=0`, and the LCM is `a`. Simple.\n\nNow, if `a` is less than `b` (I can swap them if they're not), `d` is positive. I also know that `gcd(x, y)` is the same as `gcd(x, y-x)`, which is `gcd(a+k, b-a)`, or `gcd(a+k, d)`.  I'll call this `g`. So, I'm trying to minimize `(a+k) * (b+k) / g`.\n\nSince `g` is the greatest common divisor of `a+k` and `d`, it must be a divisor of `d`. The challenge is how do I connect `k` to these divisors?  If I let `a+k = m*g`, then  `b+k` becomes `m*g + d`.  And since `d` is a multiple of `g` (let's say `d = n*g`), I know that `b+k = (m+n)*g`. This simplifies the LCM to `m*(m+n)*g`. But my goal is to express `k` clearly.\n\nThe real key here is that `g` divides both `a+k` and `d`, which also means it divides `b+k` (because `b+k` is just `a+k + d`). The problem has boiled down to: I need to find a `k` such that `gcd(a+k, d)` gives the largest possible `g` that will minimize the LCM calculation.\nI need to examine all the divisors of `d` because the `gcd(a+k, d)` will be the only factor that influences the LCM's minimization. I can iterate through the divisors of d, and for each possible `g` (divisor), derive the required `k` to check.\n",
    "response": "The problem asks us to find a non-negative integer `k` such that `lcm(a+k, b+k)` is minimized. If there are multiple optimal `k`, we choose the smallest one.\n\nFirst, let's handle the case `a > b`. Since `lcm(x, y) = lcm(y, x)`, we can swap `a` and `b` so that `a <= b`. This simplifies the logic as `b-a` will always be non-negative.\n\nIf `a = b`:\nThen `lcm(a+k, b+k) = lcm(a+k, a+k) = a+k`. To minimize this, we choose the smallest possible `k`, which is `k=0`. The minimum LCM is `a`.\n\nIf `a < b`:\nLet `x = a+k` and `y = b+k`. We want to minimize `lcm(x, y)`.\nWe know that `lcm(x, y) = (x * y) / gcd(x, y)`.\nAlso, `gcd(x, y) = gcd(x, y-x) = gcd(a+k, (b+k)-(a+k)) = gcd(a+k, b-a)`.\nLet `diff = b - a`. So we want to minimize `((a+k) * (b+k)) / gcd(a+k, diff)`.\nLet `g = gcd(a+k, diff)`. This implies that `g` must be a divisor of `diff`.\nAlso, `a+k` must be a multiple of `g`. That is, `a+k = m * g` for some integer `m`.\nThis means `a+k` must be congruent to `0` modulo `g`.\nSo `a+k \\equiv 0 \\pmod g`, which means `k \\equiv -a \\pmod g`.\nSince `k \\ge 0`, the smallest non-negative `k` satisfying this is `k = (-a \\pmod g + g) \\pmod g`.\nHowever, we are looking for `a+k` to be a multiple of `g`. The smallest non-negative `a+k` that is a multiple of `g` and `a+k \\ge a` is what we need.\nLet `a+k = qg`. Then `k = qg - a`.\nThe `lcm` value is `(a+k)(b+k)/g`. Since `b+k = a+k+diff`, this is `(a+k)(a+k+diff)/g`.\n\nWe can iterate through all possible values of `g`. Since `g` must be a divisor of `diff`, we can find all divisors of `diff`.\nFor each divisor `g` of `diff`:\nWe need to find the smallest `k \\ge 0` such that `gcd(a+k, diff) = g`.\nThis is equivalent to finding the smallest `k \\ge 0` such that `a+k` is a multiple of `g`.\nLet `rem = a % g`.\nIf `rem == 0`, then `a` is already a multiple of `g`. We can choose `k=0`.\nIf `rem != 0`, then `a` is not a multiple of `g`. We need to add `(g - rem)` to `a` to make it a multiple of `g`. So `k = g - rem`.\nLet `current_k = (g - (a % g)) % g`. This `k` ensures `a+k` is a multiple of `g`.\nWith this `k`, `a+k` will be `a + current_k`.\nThe `lcm` value for this `k` will be `(a+current_k) * (b+current_k) / g`.\nWe calculate this LCM for each divisor `g` of `diff` and keep track of the minimum LCM found and the corresponding smallest `k`.\n\nThe maximum value of `a, b` is `10^9`. So `diff` can be up to `10^9`.\nFinding divisors of `diff` up to `10^9`: We can iterate from `1` to `sqrt(diff)`. If `i` divides `diff`, then both `i` and `diff/i` are divisors. The number of divisors for a number up to `10^9` is relatively small (maximum for `735134400` is 1344 divisors).\nSo this approach is efficient enough.\n\nLet's refine the calculation of `k` for a given `g`:\nThe smallest `k \\ge 0` such that `a+k` is a multiple of `g` is:\n`k = (g - (a % g)) % g`.\nLet `val_a = a + k`.\nLet `val_b = b + k`.\nThe `lcm` for this `k` is `(val_a * val_b) // g`.\nWe need to track the minimum `lcm_val` and the corresponding `k`. Initialize `min_lcm = infinity` and `best_k = 0`.\n\nExample: `a=6, b=10`\n1. `a=6, b=10`. `diff = b-a = 4`.\n2. Divisors of `diff=4`: `1, 2, 4`.\n3. Initialize `min_lcm = infinity`, `best_k = 0`.\n\n   - For `g = 1`:\n     `k = (1 - (6 % 1)) % 1 = (1 - 0) % 1 = 0`.\n     `val_a = 6+0 = 6`. `val_b = 10+0 = 10`.\n     `current_lcm = (6 * 10) // 1 = 60`.\n     `min_lcm = 60`, `best_k = 0`.\n\n   - For `g = 2`:\n     `k = (2 - (6 % 2)) % 2 = (2 - 0) % 2 = 0`.\n     `val_a = 6+0 = 6`. `val_b = 10+0 = 10`.\n     `current_lcm = (6 * 10) // 2 = 30`.\n     `min_lcm = 30`, `best_k = 0`. (Note: `gcd(6, 4)=2`, so this `g` is valid)\n\n   - For `g = 4`:\n     `k = (4 - (6 % 4)) % 4 = (4 - 2) % 4 = 2`.\n     `val_a = 6+2 = 8`. `val_b = 10+2 = 12`.\n     `current_lcm = (8 * 12) // 4 = 24`.\n     `min_lcm = 24`, `best_k = 2`. (Note: `gcd(8, 4)=4`, so this `g` is valid)\n\nFinal answer: `best_k = 2`.\n\nEdge case: `a=5, b=10`\n1. `a=5, b=10`. `diff = b-a = 5`.\n2. Divisors of `diff=5`: `1, 5`.\n3. Initialize `min_lcm = infinity`, `best_k = 0`.\n\n   - For `g = 1`:\n     `k = (1 - (5 % 1)) % 1 = 0`.\n     `val_a = 5+0 = 5`. `val_b = 10+0 = 10`.\n     `current_lcm = (5 * 10) // 1 = 50`.\n     `min_lcm = 50`, `best_k = 0`.\n\n   - For `g = 5`:\n     `k = (5 - (5 % 5)) % 5 = 0`.\n     `val_a = 5+0 = 5`. `val_b = 10+0 = 10`.\n     `current_lcm = (5 * 10) // 5 = 10`.\n     `min_lcm = 10`, `best_k = 0`.\n\nFinal answer: `best_k = 0`.\n\nThe maximum value of `a+k` and `b+k` can be around `10^9 + 10^9 = 2 * 10^9`.\nTheir product `(a+k)*(b+k)` can be up to `(2*10^9)^2 = 4 * 10^{18}`. This fits within a standard 64-bit integer type (Python integers handle arbitrary size, so no overflow issues there).\n\nFinal check on logic for `gcd(a+k, diff) = g`:\nOur approach finds `k` such that `a+k` is a multiple of `g`. This means `g` is *a* common divisor of `a+k` and `diff`.\nHowever, we need `g` to be the *greatest* common divisor.\nIf `g` is a divisor of `diff`, and `a+k` is a multiple of `g`, then `g` divides `a+k` and `g` divides `diff`. So `g` is a common divisor.\nBut `gcd(a+k, diff)` might be `g'` where `g'` is a multiple of `g`.\nFor example, if `diff = 12`, `g=2`. We find `k` such that `a+k` is a multiple of `2`.\nSuppose `a=1`. `k=(2-(1%2))%2 = 1`. `a+k = 2`.\n`gcd(a+k, diff) = gcd(2, 12) = 2`. This works.\nSuppose `a=2`. `k=(2-(2%2))%2 = 0`. `a+k = 2`.\n`gcd(a+k, diff) = gcd(2, 12) = 2`. This works.\nSuppose `a=4`. `k=(2-(4%2))%2 = 0`. `a+k = 4`.\n`gcd(a+k, diff) = gcd(4, 12) = 4`.\nIn this case, for `g=2`, we found `k=0`, and `lcm = (4*16)/2 = 32`.\nBut for `g=4`, we would find `k=0`, and `lcm = (4*16)/4 = 16`.\nThe minimum LCM would be found when `g` is correctly `gcd(a+k, diff)`.\nThe key insight is that `gcd(a+k, diff)` will *always* be one of the divisors of `diff`. By iterating through *all* divisors `g` of `diff` and finding the smallest `k` such that `a+k` is a multiple of `g`, we are effectively considering all possible values for `gcd(a+k, diff)`.\nFor any `k`, let `g_actual = gcd(a+k, diff)`. This `g_actual` must be a divisor of `diff`.\nWhen our loop encounters `g = g_actual`, it will calculate `k_prime = (g_actual - (a % g_actual)) % g_actual`.\nIf `k_prime` is the same `k`, then we calculate the correct LCM.\nIf `k_prime` is different from `k` (because `a+k` might be a multiple of a larger divisor than `g_actual`), our current strategy will still cover it because the larger divisor `g_prime` would also be considered in the loop.\nThe logic is sound because for any `k`, `gcd(a+k, diff)` will be some divisor `g_0` of `diff`. Our loop will consider `g_0`. For that `g_0`, it computes `k_0 = (g_0 - (a % g_0)) % g_0`.\nThe value `a+k_0` is the smallest value `X \\ge a` such that `X` is a multiple of `g_0`.\nThe `lcm` calculated for `(g_0, k_0)` pair is `(a+k_0)(b+k_0)/g_0`.\nThis ensures we check the optimal `k` for each possible `gcd` value.\nSince we want the smallest `k` in case of ties, `best_k` should be updated only if `current_lcm < min_lcm`, or if `current_lcm == min_lcm` and `current_k < best_k`.\n\n```python\nimport math\n\ndef solve():\n    a, b = map(int, input().split())\n\n    # Ensure a <= b\n    if a > b:\n        a, b = b, a\n\n    # Case 1: a == b\n    if a == b:\n        print(0)\n        return\n\n    # Case 2: a < b\n    diff = b - a\n    \n    min_lcm = float('inf')\n    best_k = 0\n\n    # Find all divisors of diff\n    divisors = set()\n    for i in range(1, int(math.sqrt(diff)) + 1):\n        if diff % i == 0:\n            divisors.add(i)\n            divisors.add(diff // i)\n            \n    # Iterate through each divisor g of diff\n    for g in sorted(list(divisors)): # Sorting for consistent behavior, not strictly necessary for correctness\n        # Find smallest non-negative k such that (a+k) is a multiple of g\n        # (a+k) % g == 0  => k % g == (-a % g + g) % g\n        # k = (g - (a % g)) % g\n        current_k = (g - (a % g)) % g\n        \n        val_a = a + current_k\n        val_b = b + current_k\n        \n        # Calculate lcm(val_a, val_b) = (val_a * val_b) / gcd(val_a, val_b)\n        # We know that gcd(val_a, val_b) = gcd(val_a, diff).\n        # Since val_a is a multiple of g, and diff is a multiple of g,\n        # g is a common divisor.\n        # The actual gcd might be a multiple of g.\n        # However, by iterating through all divisors 'g' of 'diff', we ensure that\n        # for any k, the actual gcd(a+k, diff) will be one of the 'g' values considered.\n        # And for that 'g', we find the smallest 'k' that makes 'a+k' a multiple of it.\n        \n        # Calculate the actual gcd(val_a, diff) for this specific k\n        actual_gcd = math.gcd(val_a, diff)\n        current_lcm = (val_a * val_b) // actual_gcd\n        \n        if current_lcm < min_lcm:\n            min_lcm = current_lcm\n            best_k = current_k\n        elif current_lcm == min_lcm:\n            # If LCMs are equal, choose the smallest k\n            if current_k < best_k:\n                best_k = current_k\n\n    print(best_k)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef solve():\n    a, b = map(int, input().split())\n\n    # Ensure a <= b\n    if a > b:\n        a, b = b, a\n\n    # Case 1: a == b\n    if a == b:\n        print(0)\n        return\n\n    # Case 2: a < b\n    diff = b - a\n    \n    min_lcm = float('inf')\n    best_k = 0\n\n    # Find all divisors of diff\n    divisors = set()\n    for i in range(1, int(math.sqrt(diff)) + 1):\n        if diff % i == 0:\n            divisors.add(i)\n            divisors.add(diff // i)\n            \n    # Iterate through each divisor g of diff\n    for g in sorted(list(divisors)): # Sorting for consistent behavior, not strictly necessary for correctness\n        # Find smallest non-negative k such that (a+k) is a multiple of g\n        # (a+k) % g == 0  => k % g == (-a % g + g) % g\n        # k = (g - (a % g)) % g\n        current_k = (g - (a % g)) % g\n        \n        val_a = a + current_k\n        val_b = b + current_k\n        \n        # Calculate lcm(val_a, val_b) = (val_a * val_b) / gcd(val_a, val_b)\n        # We know that gcd(val_a, val_b) = gcd(val_a, diff).\n        # Since val_a is a multiple of g, and diff is a multiple of g,\n        # g is a common divisor.\n        # The actual gcd might be a multiple of g.\n        # However, by iterating through all divisors 'g' of 'diff', we ensure that\n        # for any k, the actual gcd(a+k, diff) will be one of the 'g' values considered.\n        # And for that 'g', we find the smallest 'k' that makes 'a+k' a multiple of it.\n        \n        # Calculate the actual gcd(val_a, diff) for this specific k\n        actual_gcd = math.gcd(val_a, diff)\n        current_lcm = (val_a * val_b) // actual_gcd\n        \n        if current_lcm < min_lcm:\n            min_lcm = current_lcm\n            best_k = current_k\n        elif current_lcm == min_lcm:\n            # If LCMs are equal, choose the smallest k\n            if current_k < best_k:\n                best_k = current_k\n\n    print(best_k)\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 412,
        "completion_token_count": 3576,
        "thoughts_token_count": 825
    }
}