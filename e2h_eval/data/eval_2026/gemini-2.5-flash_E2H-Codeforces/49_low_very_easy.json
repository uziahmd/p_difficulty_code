{
    "start": 1758284910.9676025,
    "end": 1758284955.577389,
    "start-formatted": "2025-09-19 21:28 KST",
    "end-formatted": "2025-09-19 21:29 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "**Initial Deep Dive into \"Mushroom Strife\"**\n\nOkay, so I've got this \"Mushroom Strife\" problem to tackle, and my first instinct is to break it down. We're given a graph – lawns and roads – and the relationships between the mushroom counts on connected lawns are defined by GCD and LCM.  My mind immediately jumps to graph theory and how this can be modeled. The small constraints on `n` and `m` are a huge clue.  Polynomial time is likely, and given the multiplicative nature of the relationships, maybe even an exponential brute force approach might be feasible because the base is bounded.\n\nThe key equation is `g * l = a * b` for connected lawns with `a` and `b` mushrooms, `g` as GCD and `l` as LCM. I'm already simplifying it by realizing that if `a` and `b` are connected by an edge, where GCD is `g` and LCM is `l`, and we let `x_u` and `x_v` be the mushroom counts at the nodes, it means:\n\n*   `GCD(x_u, x_v) = g`\n*   `LCM(x_u, x_v) = l`\n*   `x_u * x_v = g * l`\n*   `x_u` and `x_v` must be multiples of `g`.\n*   Crucially, `x_u / g` and `x_v / g` must be coprime.\n*   `(x_u / g) * (x_v / g) = l / g`.\n\nThis last point is crucial – it means we need to find two coprime factors of `l / g`. Now, the objective becomes clearer: restore *a* valid mushroom count assignment or report \"NO\".\n\nThe graph aspect intrigues me. What if I fix a value at one vertex and see how that propagates through the graph? If I fix `x_u`, then the value of an adjacent vertex `x_v` with an edge-specific `g` and `l` is fully determined by `x_v = (g * l) / x_u`.  I need to make sure that whatever value I choose for `x_u`, it is a multiple of `g`, otherwise the solution is already invalid. This opens the door to exploring different starting points and seeing if a consistent assignment is possible.\n\nI'm starting to think about strategies for the code.  I need a way to efficiently determine if a given assignment is valid, and how to intelligently explore the search space. It feels like backtracking or dynamic programming could be useful, or potentially a form of constraint satisfaction. Time to get coding!\n",
    "response": "```python\nimport sys\nimport math\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    if n == 0: # Should not happen based on constraints 1 <= n, m <= 100\n        print(\"YES\")\n        print()\n        return\n\n    adj = [[] for _ in range(n + 1)]\n    \n    # Store edges to re-check at the end\n    edges = []\n\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        \n        # Basic check: l must be a multiple of g\n        if l % g != 0:\n            print(\"NO\")\n            return\n        \n        # Store for graph traversal\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l))\n        \n        # Store for final verification\n        edges.append((u, v, g, l))\n\n    # Array to store assigned mushroom counts. 0 means unassigned.\n    ans = [0] * (n + 1)\n    \n    # Primes up to sqrt(10^6) = 1000\n    # Sieve of Eratosthenes to precompute primes for factorization\n    MAX_VAL = 1000000\n    sqrt_MAX_VAL = int(math.sqrt(MAX_VAL))\n    \n    is_prime = [True] * (sqrt_MAX_VAL + 1)\n    primes = []\n    for p in range(2, sqrt_MAX_VAL + 1):\n        if is_prime[p]:\n            primes.append(p)\n            for multiple in range(p*p, sqrt_MAX_VAL + 1, p):\n                is_prime[multiple] = False\n\n    # Function to get prime factorization as a dictionary {prime: exponent}\n    def get_prime_factorization(num):\n        factors = {}\n        temp_num = num\n        for p in primes:\n            if p * p > temp_num: # Optimization: if p*p > remaining number, remaining number must be prime\n                break\n            if temp_num % p == 0:\n                count = 0\n                while temp_num % p == 0:\n                    count += 1\n                    temp_num //= p\n                factors[p] = count\n        if temp_num > 1: # Remaining number is a prime factor itself\n            factors[temp_num] = factors.get(temp_num, 0) + 1\n        return factors\n\n    # Function to check if a number can be formed by multiplying factors from a dict\n    def can_form(num, factors_dict):\n        temp_num = num\n        for p, count in factors_dict.items():\n            if temp_num % (p**count) != 0:\n                return False\n            temp_num //= (p**count)\n        return temp_num == 1 # All factors must be used up\n\n    # Function to calculate GCD\n    def calculate_gcd(a, b):\n        return math.gcd(a, b)\n\n    # Function to calculate LCM\n    def calculate_lcm(a, b):\n        if a == 0 or b == 0: return 0 # Or raise error, depending on definition\n        return (a * b) // calculate_gcd(a, b)\n\n\n    # Main loop to process connected components\n    for i in range(1, n + 1):\n        if ans[i] != 0:\n            continue # Already processed this component\n\n        # Start a BFS/DFS from node i\n        q = [(i, 0, 0)] # (node, relative_factor, relative_power_sum)\n                        # relative_factor: x_u / x_root (for some root)\n                        # relative_power_sum: sum of (v_p(x_u) - v_p(x_root)) for all p\n\n        # We will try to find a root value for each connected component.\n        # The choice of root value needs to be consistent.\n        # Let x_u = x_root * K_u.\n        # For an edge (u, v) with GCD=g, LCM=l:\n        # x_u * x_v = g * l\n        # (x_root * K_u) * (x_root * K_v) = g * l\n        # x_root^2 * K_u * K_v = g * l\n        # This is problematic because x_root^2 makes it hard to propagate.\n\n        # A better approach for connected components:\n        # For each connected component, pick an arbitrary node as the \"root\".\n        # Try to assign a value to this root, and then propagate.\n        # What if we assign a \"canonical\" value to the root?\n        # e.g., for node `i`, we assign `ans[i] = g_i_j` for some neighbor `j`.\n        # No, that's not general.\n\n        # Let's try to assign `ans[i] = 1` for the root of a component,\n        # and then determine the relative factors for all other nodes.\n        # After determining relative factors, we can find the actual values.\n        # This requires knowing the prime factorization of numbers.\n\n        # Simplified approach:\n        # For each connected component, we can express all x_j as x_i * (some factor).\n        # Let x_j = x_i * F_j, where F_i = 1.\n        # For an edge (u, v) with GCD=g, LCM=l:\n        # x_u * x_v = g * l.\n        # So, x_i * F_u * x_i * F_v = g * l => x_i^2 * F_u * F_v = g * l.\n        # This is not good for propagation.\n\n        # Let's use the property that x_u = g * A and x_v = g * B where GCD(A,B)=1 and A*B = l/g.\n        # This means x_u and x_v are composed of prime factors from l/g and g.\n        # Specifically, all prime factors of x_u and x_v must come from g*l.\n        # If we know x_u, then x_v = (g*l) / x_u.\n        # We need to ensure GCD(x_u, x_v) == g and LCM(x_u, x_v) == l.\n\n        # For a connected component, let's find the factors for each node.\n        # We can represent each x_j as a product of prime powers.\n        # For an edge (u, v) with GCD=g, LCM=l:\n        # For each prime p:\n        # min(v_p(x_u), v_p(x_v)) = v_p(g)\n        # max(v_p(x_u), v_p(x_v)) = v_p(l)\n        # This implies that for each prime p, {v_p(x_u), v_p(x_v)} MUST be {v_p(g), v_p(l)}.\n        # Or, if v_p(g) == v_p(l), then v_p(x_u) == v_p(x_v) == v_p(g).\n        # And if v_p(g) < v_p(l), then one of v_p(x_u), v_p(x_v) is v_p(g) and the other is v_p(l).\n\n        # This is the key insight: For each prime p and edge (u, v):\n        # Let `gp = v_p(g)` and `lp = v_p(l)`.\n        # Let `xup = v_p(x_u)` and `xvp = v_p(x_v)`.\n        # We must have `min(xup, xvp) = gp` and `max(xup, xvp) = lp`.\n        # This means `xup + xvp = gp + lp`.\n        # And `xup` and `xvp` must be either `gp` or `lp`.\n        # If `gp == lp`, then `xup == xvp == gp`.\n        # If `gp < lp`, then `{xup, xvp}` must be `{gp, lp}`.\n\n        # This suggests a 2-coloring problem on a graph for each prime.\n        # For each prime `p`, we need to assign `v_p(x_j)` to each node `j`.\n        # Let `v_p(x_j)` be denoted `exp[j][p]`.\n        # For an edge `(u, v)` with `g, l`:\n        # `exp[u][p] + exp[v][p] = v_p(g) + v_p(l)`\n        # And `exp[u][p]` must be either `v_p(g)` or `v_p(l)`.\n        # If `v_p(g) == v_p(l)`, then `exp[u][p] = exp[v][p] = v_p(g)`.\n        # If `v_p(g) < v_p(l)`, then `exp[u][p]` and `exp[v][p]` must be different,\n        # one is `v_p(g)` and the other is `v_p(l)`.\n        # This is a 2-coloring problem: assign a \"parity\" to each node `j` for prime `p`.\n        # If `exp[j][p] = v_p(g)`, parity is 0. If `exp[j][p] = v_p(l)`, parity is 1.\n        # For `v_p(g) < v_p(l)`, adjacent nodes must have different parities.\n        # For `v_p(g) == v_p(l)`, adjacent nodes must have the same parity (which is 0 or 1, but doesn't matter since both are equal).\n\n        # Let `v_p(x_j)` be `V_j_p`.\n        # `V_j_p` can be `v_p(g_first_edge)` or `v_p(l_first_edge)` for some arbitrary first edge.\n        # The sum `V_u_p + V_v_p = v_p(g) + v_p(l)` is a constant for each edge.\n        # This is a system of linear equations modulo 2 if we consider `V_j_p` as `v_p(g)` + `(0 or 1) * (v_p(l) - v_p(g))`.\n        # Let `val[j][p]` be the exponent `v_p(x_j)`.\n        # Let `parity[j][p]` be 0 if `val[j][p] = v_p(g)` and 1 if `val[j][p] = v_p(l)`.\n        # This only applies when `v_p(g) < v_p(l)`.\n        # If `v_p(g) == v_p(l)`, then `val[j][p]` must be `v_p(g)`.\n\n        # Let's try to assign parities for each prime p.\n        # `v_p_g_l_pairs` stores for each prime p, a list of (u, v, v_p(g), v_p(l)) for relevant edges.\n        # It's better to iterate through nodes, and for each node, determine its factors.\n        \n        # `node_prime_factors[node_idx][prime]` stores the exponent of `prime` in `x_node_idx`.\n        # Initialize with -1 to indicate unassigned.\n        node_prime_factors = [{} for _ in range(n + 1)]\n        \n        # `visited` array for BFS/DFS.\n        visited = [False] * (n + 1)\n\n        # Iterate through all nodes to handle disconnected components\n        for start_node in range(1, n + 1):\n            if visited[start_node]:\n                continue\n            \n            # For each connected component, we need to determine the actual values.\n            # We can use BFS.\n            # `q` will store nodes to visit.\n            # `x_val_for_bfs` will store `x_u` values determined during BFS for this component.\n            # `x_val_for_bfs[u]` will be the determined `x_u`.\n            # We need to choose a starting value for the root of the component.\n            # For the root `start_node`, we need to pick a value `x_start_node`.\n            # What are the candidates for `x_start_node`?\n            # It must be a divisor of `l` and multiple of `g` for all its neighbors.\n            # It must be `1 <= x <= 10^6`.\n            \n            # The most robust way is to determine prime factor exponents.\n            # For each prime `p`, and for each node `j`, we need to find `v_p(x_j)`.\n            # Let `v_p(x_j) = exp[j][p]`.\n            # For an edge `(u, v)` with `g, l`:\n            # `min(exp[u][p], exp[v][p]) = v_p(g)`\n            # `max(exp[u][p], exp[v][p]) = v_p(l)`\n            # This implies `exp[u][p] + exp[v][p] = v_p(g) + v_p(l)`.\n            # And `exp[u][p]` must be either `v_p(g)` or `v_p(l)`.\n            # This allows us to assign `exp[u][p]` relative to `exp[v][p]`.\n            \n            # Let's define `diff[j][p] = exp[j][p] - v_p(g_first_edge)`.\n            # Or, more simply, let `exp[j][p]` be one of two values.\n            # This is a 2-coloring problem.\n            # For each prime `p`, we can run a BFS/DFS to determine `exp[j][p]` for all `j` in the component.\n            \n            # `component_nodes` will store all nodes in the current connected component.\n            component_nodes = []\n            q_comp = [start_node]\n            visited[start_node] = True\n            head = 0\n            while head < len(q_comp):\n                u = q_comp[head]\n                head += 1\n                component_nodes.append(u)\n                for v_node, _, _ in adj[u]:\n                    if not visited[v_node]:\n                        visited[v_node] = True\n                        q_comp.append(v_node)\n\n            # Collect all relevant primes for this component\n            relevant_primes = set()\n            for u in component_nodes:\n                for v, g, l in adj[u]:\n                    # Factorize g and l to find all primes\n                    factors_g = get_prime_factorization(g)\n                    factors_l = get_prime_factorization(l)\n                    relevant_primes.update(factors_g.keys())\n                    relevant_primes.update(factors_l.keys())\n\n            # For each relevant prime, determine exponents for all nodes in this component.\n            for p in relevant_primes:\n                # `prime_exp_assigned[node_idx]` stores the exponent `v_p(x_node_idx)`.\n                # Initialize with -1 (unassigned).\n                prime_exp_assigned = [-1] * (n + 1)\n                \n                # `q_prime_exp` for BFS for this specific prime `p`.\n                q_prime_exp = [start_node]\n                \n                # Assign an initial value to the `start_node` for prime `p`.\n                # We can try `v_p(g)` from one of its edges, or `v_p(l)`.\n                # Let's just pick an arbitrary one, say `v_p(g)` for the first edge (if any).\n                # If `start_node` has no edges, its value for `p` can be anything, say 0.\n                \n                initial_exp_val = 0 # Default if no edges\n                if adj[start_node]:\n                    _, g_edge, l_edge = adj[start_node][0]\n                    initial_exp_val = get_prime_factorization(g_edge).get(p, 0)\n                \n                prime_exp_assigned[start_node] = initial_exp_val\n                \n                head_prime_exp = 0\n                while head_prime_exp < len(q_prime_exp):\n                    u = q_prime_exp[head_prime_exp]\n                    head_prime_exp += 1\n                    \n                    current_u_exp = prime_exp_assigned[u]\n                    \n                    for v_node, g_edge, l_edge in adj[u]:\n                        v_p_g = get_prime_factorization(g_edge).get(p, 0)\n                        v_p_l = get_prime_factorization(l_edge).get(p, 0)\n\n                        # Check consistency for u\n                        if not (v_p_g <= current_u_exp <= v_p_l):\n                            # This should not happen if previous assignments were correct,\n                            # or indicates an impossible assignment.\n                            # Specifically, current_u_exp must be one of v_p_g or v_p_l.\n                            # If it's not, it's an issue.\n                            # However, if v_p_g == v_p_l, then current_u_exp must be v_p_g.\n                            # If v_p_g < v_p_l, then current_u_exp must be v_p_g or v_p_l.\n                            if not ((v_p_g == v_p_l and current_u_exp == v_p_g) or \\\n                                    (v_p_g < v_p_l and (current_u_exp == v_p_g or current_u_exp == v_p_l))):\n                                print(\"NO\")\n                                return\n\n                        # Determine v's exponent\n                        target_v_exp = v_p_g + v_p_l - current_u_exp\n                        \n                        # Check if target_v_exp is valid\n                        if not (v_p_g <= target_v_exp <= v_p_l):\n                            print(\"NO\")\n                            return\n                        if not ((v_p_g == v_p_l and target_v_exp == v_p_g) or \\\n                                (v_p_g < v_p_l and (target_v_exp == v_p_g or target_v_exp == v_p_l))):\n                            print(\"NO\")\n                            return\n\n                        if prime_exp_assigned[v_node] == -1:\n                            prime_exp_assigned[v_node] = target_v_exp\n                            q_prime_exp.append(v_node)\n                        elif prime_exp_assigned[v_node] != target_v_exp:\n                            # Conflict detected for this prime's exponent\n                            print(\"NO\")\n                            return\n                \n                # After BFS for this prime, store exponents in node_prime_factors\n                for node_in_comp in component_nodes:\n                    node_prime_factors[node_in_comp][p] = prime_exp_assigned[node_in_comp]\n        \n        # Now reconstruct the numbers ans[j] from prime factor exponents\n        for j in range(1, n + 1):\n            current_val = 1\n            for p, exp in node_prime_factors[j].items():\n                current_val *= (p ** exp)\n            ans[j] = current_val\n            if ans[j] > MAX_VAL: # Check if value exceeds 10^6\n                print(\"NO\")\n                return\n        \n        # For isolated nodes (m=0 or disconnected component with only one node),\n        # ans[j] would be 1 because node_prime_factors[j] is empty. This is valid.\n        \n    # Final verification of all edges\n    for u, v, g_orig, l_orig in edges:\n        if ans[u] == 0 or ans[v] == 0: # Should not happen if all components processed\n            print(\"NO\")\n            return\n\n        if calculate_gcd(ans[u], ans[v]) != g_orig:\n            print(\"NO\")\n            return\n        if calculate_lcm(ans[u], ans[v]) != l_orig:\n            print(\"NO\")\n            return\n    \n    print(\"YES\")\n    print(*(ans[1:]))\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    if n == 0: # Should not happen based on constraints 1 <= n, m <= 100\n        print(\"YES\")\n        print()\n        return\n\n    adj = [[] for _ in range(n + 1)]\n    \n    # Store edges to re-check at the end\n    edges = []\n\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        \n        # Basic check: l must be a multiple of g\n        if l % g != 0:\n            print(\"NO\")\n            return\n        \n        # Store for graph traversal\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l))\n        \n        # Store for final verification\n        edges.append((u, v, g, l))\n\n    # Array to store assigned mushroom counts. 0 means unassigned.\n    ans = [0] * (n + 1)\n    \n    # Primes up to sqrt(10^6) = 1000\n    # Sieve of Eratosthenes to precompute primes for factorization\n    MAX_VAL = 1000000\n    sqrt_MAX_VAL = int(math.sqrt(MAX_VAL))\n    \n    is_prime = [True] * (sqrt_MAX_VAL + 1)\n    primes = []\n    for p in range(2, sqrt_MAX_VAL + 1):\n        if is_prime[p]:\n            primes.append(p)\n            for multiple in range(p*p, sqrt_MAX_VAL + 1, p):\n                is_prime[multiple] = False\n\n    # Function to get prime factorization as a dictionary {prime: exponent}\n    def get_prime_factorization(num):\n        factors = {}\n        temp_num = num\n        for p in primes:\n            if p * p > temp_num: # Optimization: if p*p > remaining number, remaining number must be prime\n                break\n            if temp_num % p == 0:\n                count = 0\n                while temp_num % p == 0:\n                    count += 1\n                    temp_num //= p\n                factors[p] = count\n        if temp_num > 1: # Remaining number is a prime factor itself\n            factors[temp_num] = factors.get(temp_num, 0) + 1\n        return factors\n\n    # Function to check if a number can be formed by multiplying factors from a dict\n    def can_form(num, factors_dict):\n        temp_num = num\n        for p, count in factors_dict.items():\n            if temp_num % (p**count) != 0:\n                return False\n            temp_num //= (p**count)\n        return temp_num == 1 # All factors must be used up\n\n    # Function to calculate GCD\n    def calculate_gcd(a, b):\n        return math.gcd(a, b)\n\n    # Function to calculate LCM\n    def calculate_lcm(a, b):\n        if a == 0 or b == 0: return 0 # Or raise error, depending on definition\n        return (a * b) // calculate_gcd(a, b)\n\n\n    # Main loop to process connected components\n    for i in range(1, n + 1):\n        if ans[i] != 0:\n            continue # Already processed this component\n\n        # Start a BFS/DFS from node i\n        q = [(i, 0, 0)] # (node, relative_factor, relative_power_sum)\n                        # relative_factor: x_u / x_root (for some root)\n                        # relative_power_sum: sum of (v_p(x_u) - v_p(x_root)) for all p\n\n        # We will try to find a root value for each connected component.\n        # The choice of root value needs to be consistent.\n        # Let x_u = x_root * K_u.\n        # For an edge (u, v) with GCD=g, LCM=l:\n        # x_u * x_v = g * l\n        # (x_root * K_u) * (x_root * K_v) = g * l\n        # x_root^2 * K_u * K_v = g * l\n        # This is problematic because x_root^2 makes it hard to propagate.\n\n        # A better approach for connected components:\n        # For each connected component, pick an arbitrary node as the \"root\".\n        # Try to assign a value to this root, and then propagate.\n        # What if we assign a \"canonical\" value to the root?\n        # e.g., for node `i`, we assign `ans[i] = g_i_j` for some neighbor `j`.\n        # No, that's not general.\n\n        # Let's try to assign `ans[i] = 1` for the root of a component,\n        # and then determine the relative factors for all other nodes.\n        # After determining relative factors, we can find the actual values.\n        # This requires knowing the prime factorization of numbers.\n\n        # Simplified approach:\n        # For each connected component, we can express all x_j as x_i * (some factor).\n        # Let x_j = x_i * F_j, where F_i = 1.\n        # For an edge (u, v) with GCD=g, LCM=l:\n        # x_u * x_v = g * l.\n        # So, x_i * F_u * x_i * F_v = g * l => x_i^2 * F_u * F_v = g * l.\n        # This is not good for propagation.\n\n        # Let's use the property that x_u = g * A and x_v = g * B where GCD(A,B)=1 and A*B = l/g.\n        # This means x_u and x_v are composed of prime factors from l/g and g.\n        # Specifically, all prime factors of x_u and x_v must come from g*l.\n        # If we know x_u, then x_v = (g*l) / x_u.\n        # We need to ensure GCD(x_u, x_v) == g and LCM(x_u, x_v) == l.\n\n        # For a connected component, let's find the factors for each node.\n        # We can represent each x_j as a product of prime powers.\n        # For an edge (u, v) with GCD=g, LCM=l:\n        # For each prime p:\n        # min(v_p(x_u), v_p(x_v)) = v_p(g)\n        # max(v_p(x_u), v_p(x_v)) = v_p(l)\n        # This implies that for each prime p, {v_p(x_u), v_p(x_v)} MUST be {v_p(g), v_p(l)}.\n        # Or, if v_p(g) == v_p(l), then v_p(x_u) == v_p(x_v) == v_p(g).\n        # And if v_p(g) < v_p(l), then one of v_p(x_u), v_p(x_v) is v_p(g) and the other is v_p(l).\n\n        # This is the key insight: For each prime p and edge (u, v):\n        # Let `gp = v_p(g)` and `lp = v_p(l)`.\n        # Let `xup = v_p(x_u)` and `xvp = v_p(x_v)`.\n        # We must have `min(xup, xvp) = gp` and `max(xup, xvp) = lp`.\n        # This means `xup + xvp = gp + lp`.\n        # And `xup` and `xvp` must be either `gp` or `lp`.\n        # If `gp == lp`, then `xup == xvp == gp`.\n        # If `gp < lp`, then `{xup, xvp}` must be `{gp, lp}`.\n\n        # This suggests a 2-coloring problem on a graph for each prime.\n        # For each prime `p`, we need to assign `v_p(x_j)` to each node `j`.\n        # Let `v_p(x_j)` be denoted `exp[j][p]`.\n        # For an edge `(u, v)` with `g, l`:\n        # `exp[u][p] + exp[v][p] = v_p(g) + v_p(l)`\n        # And `exp[u][p]` must be either `v_p(g)` or `v_p(l)`.\n        # If `v_p(g) == v_p(l)`, then `exp[u][p] = exp[v][p] = v_p(g)`.\n        # If `v_p(g) < v_p(l)`, then `exp[u][p]` and `exp[v][p]` must be different,\n        # one is `v_p(g)` and the other is `v_p(l)`.\n        # This is a 2-coloring problem: assign a \"parity\" to each node `j` for prime `p`.\n        # If `exp[j][p] = v_p(g)`, parity is 0. If `exp[j][p] = v_p(l)`, parity is 1.\n        # For `v_p(g) < v_p(l)`, adjacent nodes must have different parities.\n        # For `v_p(g) == v_p(l)`, adjacent nodes must have the same parity (which is 0 or 1, but doesn't matter since both are equal).\n\n        # Let `v_p(x_j)` be `V_j_p`.\n        # `V_j_p` can be `v_p(g_first_edge)` or `v_p(l_first_edge)` for some arbitrary first edge.\n        # The sum `V_u_p + V_v_p = v_p(g) + v_p(l)` is a constant for each edge.\n        # This is a system of linear equations modulo 2 if we consider `V_j_p` as `v_p(g)` + `(0 or 1) * (v_p(l) - v_p(g))`.\n        # Let `val[j][p]` be the exponent `v_p(x_j)`.\n        # Let `parity[j][p]` be 0 if `val[j][p] = v_p(g)` and 1 if `val[j][p] = v_p(l)`.\n        # This only applies when `v_p(g) < v_p(l)`.\n        # If `v_p(g) == v_p(l)`, then `val[j][p]` must be `v_p(g)`.\n\n        # Let's try to assign parities for each prime p.\n        # `v_p_g_l_pairs` stores for each prime p, a list of (u, v, v_p(g), v_p(l)) for relevant edges.\n        # It's better to iterate through nodes, and for each node, determine its factors.\n        \n        # `node_prime_factors[node_idx][prime]` stores the exponent of `prime` in `x_node_idx`.\n        # Initialize with -1 to indicate unassigned.\n        node_prime_factors = [{} for _ in range(n + 1)]\n        \n        # `visited` array for BFS/DFS.\n        visited = [False] * (n + 1)\n\n        # Iterate through all nodes to handle disconnected components\n        for start_node in range(1, n + 1):\n            if visited[start_node]:\n                continue\n            \n            # For each connected component, we need to determine the actual values.\n            # We can use BFS.\n            # `q` will store nodes to visit.\n            # `x_val_for_bfs` will store `x_u` values determined during BFS for this component.\n            # `x_val_for_bfs[u]` will be the determined `x_u`.\n            # We need to choose a starting value for the root of the component.\n            # For the root `start_node`, we need to pick a value `x_start_node`.\n            # What are the candidates for `x_start_node`?\n            # It must be a divisor of `l` and multiple of `g` for all its neighbors.\n            # It must be `1 <= x <= 10^6`.\n            \n            # The most robust way is to determine prime factor exponents.\n            # For each prime `p`, and for each node `j`, we need to find `v_p(x_j)`.\n            # Let `v_p(x_j) = exp[j][p]`.\n            # For an edge `(u, v)` with `g, l`:\n            # `min(exp[u][p], exp[v][p]) = v_p(g)`\n            # `max(exp[u][p], exp[v][p]) = v_p(l)`\n            # This implies `exp[u][p] + exp[v][p] = v_p(g) + v_p(l)`.\n            # And `exp[u][p]` must be either `v_p(g)` or `v_p(l)`.\n            # This allows us to assign `exp[u][p]` relative to `exp[v][p]`.\n            \n            # Let's define `diff[j][p] = exp[j][p] - v_p(g_first_edge)`.\n            # Or, more simply, let `exp[j][p]` be one of two values.\n            # This is a 2-coloring problem.\n            # For each prime `p`, we can run a BFS/DFS to determine `exp[j][p]` for all `j` in the component.\n            \n            # `component_nodes` will store all nodes in the current connected component.\n            component_nodes = []\n            q_comp = [start_node]\n            visited[start_node] = True\n            head = 0\n            while head < len(q_comp):\n                u = q_comp[head]\n                head += 1\n                component_nodes.append(u)\n                for v_node, _, _ in adj[u]:\n                    if not visited[v_node]:\n                        visited[v_node] = True\n                        q_comp.append(v_node)\n\n            # Collect all relevant primes for this component\n            relevant_primes = set()\n            for u in component_nodes:\n                for v, g, l in adj[u]:\n                    # Factorize g and l to find all primes\n                    factors_g = get_prime_factorization(g)\n                    factors_l = get_prime_factorization(l)\n                    relevant_primes.update(factors_g.keys())\n                    relevant_primes.update(factors_l.keys())\n\n            # For each relevant prime, determine exponents for all nodes in this component.\n            for p in relevant_primes:\n                # `prime_exp_assigned[node_idx]` stores the exponent `v_p(x_node_idx)`.\n                # Initialize with -1 (unassigned).\n                prime_exp_assigned = [-1] * (n + 1)\n                \n                # `q_prime_exp` for BFS for this specific prime `p`.\n                q_prime_exp = [start_node]\n                \n                # Assign an initial value to the `start_node` for prime `p`.\n                # We can try `v_p(g)` from one of its edges, or `v_p(l)`.\n                # Let's just pick an arbitrary one, say `v_p(g)` for the first edge (if any).\n                # If `start_node` has no edges, its value for `p` can be anything, say 0.\n                \n                initial_exp_val = 0 # Default if no edges\n                if adj[start_node]:\n                    _, g_edge, l_edge = adj[start_node][0]\n                    initial_exp_val = get_prime_factorization(g_edge).get(p, 0)\n                \n                prime_exp_assigned[start_node] = initial_exp_val\n                \n                head_prime_exp = 0\n                while head_prime_exp < len(q_prime_exp):\n                    u = q_prime_exp[head_prime_exp]\n                    head_prime_exp += 1\n                    \n                    current_u_exp = prime_exp_assigned[u]\n                    \n                    for v_node, g_edge, l_edge in adj[u]:\n                        v_p_g = get_prime_factorization(g_edge).get(p, 0)\n                        v_p_l = get_prime_factorization(l_edge).get(p, 0)\n\n                        # Check consistency for u\n                        if not (v_p_g <= current_u_exp <= v_p_l):\n                            # This should not happen if previous assignments were correct,\n                            # or indicates an impossible assignment.\n                            # Specifically, current_u_exp must be one of v_p_g or v_p_l.\n                            # If it's not, it's an issue.\n                            # However, if v_p_g == v_p_l, then current_u_exp must be v_p_g.\n                            # If v_p_g < v_p_l, then current_u_exp must be v_p_g or v_p_l.\n                            if not ((v_p_g == v_p_l and current_u_exp == v_p_g) or \\\n                                    (v_p_g < v_p_l and (current_u_exp == v_p_g or current_u_exp == v_p_l))):\n                                print(\"NO\")\n                                return\n\n                        # Determine v's exponent\n                        target_v_exp = v_p_g + v_p_l - current_u_exp\n                        \n                        # Check if target_v_exp is valid\n                        if not (v_p_g <= target_v_exp <= v_p_l):\n                            print(\"NO\")\n                            return\n                        if not ((v_p_g == v_p_l and target_v_exp == v_p_g) or \\\n                                (v_p_g < v_p_l and (target_v_exp == v_p_g or target_v_exp == v_p_l))):\n                            print(\"NO\")\n                            return\n\n                        if prime_exp_assigned[v_node] == -1:\n                            prime_exp_assigned[v_node] = target_v_exp\n                            q_prime_exp.append(v_node)\n                        elif prime_exp_assigned[v_node] != target_v_exp:\n                            # Conflict detected for this prime's exponent\n                            print(\"NO\")\n                            return\n                \n                # After BFS for this prime, store exponents in node_prime_factors\n                for node_in_comp in component_nodes:\n                    node_prime_factors[node_in_comp][p] = prime_exp_assigned[node_in_comp]\n        \n        # Now reconstruct the numbers ans[j] from prime factor exponents\n        for j in range(1, n + 1):\n            current_val = 1\n            for p, exp in node_prime_factors[j].items():\n                current_val *= (p ** exp)\n            ans[j] = current_val\n            if ans[j] > MAX_VAL: # Check if value exceeds 10^6\n                print(\"NO\")\n                return\n        \n        # For isolated nodes (m=0 or disconnected component with only one node),\n        # ans[j] would be 1 because node_prime_factors[j] is empty. This is valid.\n        \n    # Final verification of all edges\n    for u, v, g_orig, l_orig in edges:\n        if ans[u] == 0 or ans[v] == 0: # Should not happen if all components processed\n            print(\"NO\")\n            return\n\n        if calculate_gcd(ans[u], ans[v]) != g_orig:\n            print(\"NO\")\n            return\n        if calculate_lcm(ans[u], ans[v]) != l_orig:\n            print(\"NO\")\n            return\n    \n    print(\"YES\")\n    print(*(ans[1:]))\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 552,
        "completion_token_count": 4924,
        "thoughts_token_count": 771
    }
}