{
    "start": 1758293706.6720612,
    "end": 1758293745.9641614,
    "start-formatted": "2025-09-19 23:55 KST",
    "end-formatted": "2025-09-19 23:55 KST",
    "gpu": 2,
    "pid": 57,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Olympiad\n\nA boy named Vasya has taken part in an Olympiad. His teacher knows that in total Vasya got at least x points for both tours of the Olympiad. The teacher has the results of the first and the second tour of the Olympiad but the problem is, the results have only points, no names. The teacher has to know Vasya's chances.Help Vasya's teacher, find two numbers — the best and the worst place Vasya could have won. Note that the total results' table sorts the participants by the sum of points for both tours (the first place has the participant who has got the most points). If two or more participants have got the same number of points, it's up to the jury to assign places to them according to their choice. It is guaranteed that each participant of the Olympiad participated in both tours of the Olympiad.\n\n## Input\nThe first line contains two space-separated integers n, x (1 ≤ n ≤ 105; 0 ≤ x ≤ 2·105) — the number of Olympiad participants and the minimum number of points Vasya earned.The second line contains n space-separated integers: a1, a2, ..., an (0 ≤ ai ≤ 105) — the participants' points in the first tour.The third line contains n space-separated integers: b1, b2, ..., bn (0 ≤ bi ≤ 105) — the participants' points in the second tour.The participants' points are given in the arbitrary order. It is guaranteed that Vasya was present in the Olympiad — there are two integers i, j (1 ≤ i, j ≤ n) such, that ai + bj ≥ x.\n\n## Output\nPrint two space-separated integers — the best and the worst place Vasya could have got on the Olympiad.\n\n## Example\n### Input\n['5 2\\n1 1 1 1 1\\n1 1 1 1 1', '6 7\\n4 3 5 6 4 4\\n8 6 0 4 3 4']\n\n### Output\n['1 5', '1 5']\n\n## Note\nIn the first text sample all 5 participants earn 2 points each in any case. Depending on the jury's decision, Vasya can get the first (the best) as well as the last (the worst) fifth place.In the second test sample in the best case scenario Vasya wins again: he can win 12 points and become the absolute winner if the total results' table looks like that — {4:8, 6:4, 3:6, 4:4, 4:3, 5:0}.In this table all participants are sorted by decreasing points and we can see how much a participant earned in the first and in the second tour.In the worst case scenario Vasya can get the fifth place if the table looks like that — {4:8, 4:6, 6:4, 5:4, 4:3, 3:0}, and he earned 4 and 3 points in the first and second tours, correspondingly.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "",
    "response": "```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    a.sort()\n    b.sort()\n\n    # Calculate best possible rank\n    # Vasya wants to maximize his score. He picks the highest possible a_i and b_j such that a_i + b_j >= x.\n    # To get the best rank, he also wants to minimize the scores of other participants.\n    # This means other participants should be paired such that their sums are as low as possible.\n    # However, the problem states \"the total results' table sorts the participants by the sum of points\".\n    # And \"If two or more participants have got the same number of points, it's up to the jury to assign places to them\".\n    # This implies that Vasya's specific scores (a_i, b_j) and other participants' scores are not fixed.\n    # We are looking for the best and worst possible *rank* Vasya could achieve.\n\n    # Best rank: Vasya wants to maximize his score. He can pick the largest a[i] and largest b[j].\n    # Since he is guaranteed to exist, he can always pick a pair (a_i, b_j) such that a_i + b_j >= x.\n    # To maximize his score, he would take a[n-1] and b[n-1]. Their sum is a[n-1] + b[n-1].\n    # If a[n-1] + b[n-1] < x, then Vasya cannot achieve this score.\n    # The guarantee states there exist i, j such that a_i + b_j >= x.\n    # So Vasya's maximum possible score is a[n-1] + b[n-1].\n    # Let Vasya's maximum score be V_max = a[n-1] + b[n-1].\n    # The best rank for Vasya is 1. This happens if he gets the highest possible score, and the jury\n    # places him first among those with the same score.\n    # Since Vasya can always achieve a score (a_i + b_j >= x), and he can pick the largest a_i and b_j,\n    # he can achieve a[n-1] + b[n-1].\n    # It is always possible for Vasya to be 1st. He can achieve the maximum possible sum (a[n-1] + b[n-1]).\n    # If multiple people achieve this, he can be assigned 1st place.\n    best_rank = 1\n\n    # Worst rank: Vasya wants to minimize his score, but still satisfy a_i + b_j >= x.\n    # And other participants want to maximize their scores.\n    # Vasya's minimum possible score:\n    # Vasya needs to pick some a_i and some b_j such that a_i + b_j >= x.\n    # To get the worst rank, he should pick the smallest possible sum (a_i + b_j) that satisfies the condition.\n    # This is tricky because other people also need to be assigned points.\n    # We need to find a pairing of all a_k and b_k such that Vasya gets a score S_V, and other people get scores S_k.\n    # Then we count how many people have score >= S_V.\n\n    # Consider the worst case for Vasya. He gets a pair (a_i, b_j) such that a_i + b_j >= x.\n    # To maximize his rank (make it as high as possible, i.e., closer to n),\n    # he wants to minimize his score, while other participants maximize their scores.\n    # However, the problem phrasing \"find two numbers — the best and the worst place Vasya could have won\"\n    # implies we consider all possible pairings.\n\n    # Let's consider a fixed score S for Vasya. How many people could possibly score >= S?\n    # To maximize the number of people scoring >= S, we try to pair a_k and b_k such that their sum is >= S.\n    # This is a maximum bipartite matching problem, or can be solved with a greedy approach.\n\n    # To find the worst rank:\n    # Vasya takes some a_i and some b_j such that a_i + b_j >= x.\n    # To maximize his rank, he should choose a pair (a_i, b_j) such that a_i + b_j is minimized,\n    # subject to a_i + b_j >= x.\n    # Let's call this minimal possible score Vasya can get S_vasya_min_valid.\n    # For a fixed a_i, Vasya needs to find b_j such that b_j >= x - a_i. He would pick the smallest such b_j.\n    # So, for each a_i, find the smallest b_j such that a_i + b_j >= x. This can be done using binary search on b.\n    # Iterate through all a_i. For each a_i, find the smallest b_j such that b_j >= x - a_i.\n    # If such b_j exists, then a_i + b_j is a candidate for Vasya's score.\n    # The minimum of these candidates is S_vasya_min_valid.\n    # But this is not quite right. Vasya doesn't just pick one a_i and one b_j.\n    # He is one of the N participants. All N participants must be paired up.\n\n    # The key insight for worst rank:\n    # Vasya wants to minimize his score S_V, subject to S_V >= x.\n    # All other N-1 participants want to maximize their scores.\n    # The pairing is fixed for all N participants.\n    # The problem implies that we can choose *any* permutation of b to pair with a.\n    # So we want to find a permutation of b such that Vasya gets a score S_V (where S_V >= x),\n    # and the number of people with score >= S_V is maximized.\n\n    # Consider a fixed pairing of (a_i, b_i) (after sorting b).\n    # What if Vasya is assigned (a[i], b[j])?\n    # This is a typical \"how many pairs (a_i, b_j) sum to at least K\" problem.\n    # For worst rank, we want to maximize the number of people who score *strictly greater* than Vasya,\n    # and then maximize the number of people who score *equal* to Vasya and are placed above him.\n\n    # Let's re-read the problem carefully: \"find two numbers — the best and the worst place Vasya could have won.\"\n    # This means we are free to choose *which* a_i and *which* b_j Vasya gets, as long as a_i + b_j >= x.\n    # And we are free to choose how the remaining N-1 participants are paired up.\n    # And we are free to choose the jury's decision for ties.\n\n    # Best case: Vasya gets a[n-1] + b[n-1]. He is placed 1st. (Already handled, best_rank = 1)\n\n    # Worst case:\n    # Vasya wants to get the lowest possible score S_V such that S_V >= x.\n    # To maximize his rank (worst place), he should choose a score S_V that is as low as possible (but >= x).\n    # And then, among all possible pairings of (a, b) for all N participants, we want to find one\n    # where the number of people with score >= S_V is maximized.\n\n    # Let's try to find the maximum number of pairs (a_i, b_j) such that a_i + b_j >= x.\n    # This is a standard two-pointer approach.\n    # Sort a and b.\n    # Iterate with a pointer `i` from 0 to n-1 for array `a`.\n    # For each `a[i]`, we need to find `b[j]` such that `a[i] + b[j] >= x`.\n    # To maximize the count of such pairs, we use a greedy approach.\n    # Sort `a` in ascending order. Sort `b` in ascending order.\n    # Use two pointers: `l` for `a` (starting at 0) and `r` for `b` (starting at n-1).\n    # `count = 0`\n    # While `l < n` and `r >= 0`:\n    #   If `a[l] + b[r] >= x`:\n    #     We can form a valid pair. Increment `count`. Move both pointers: `l++`, `r--`.\n    #     (This pairing maximizes the number of pairs >= x because we use the largest available b for the smallest available a that can make the sum, freeing up smaller b's for other a's, or larger b's for larger a's.)\n    #   Else (`a[l] + b[r] < x`):\n    #     `a[l]` is too small to pair with `b[r]` to reach `x`. We need a larger `a`. Move `l++`.\n    # This count is the maximum number of participants who *could* score at least `x`.\n    # Let this be `max_valid_pairs`.\n    # If Vasya is one of these `max_valid_pairs`, and he gets the lowest score among them,\n    # and everyone else who also scored >= x is placed above him, then his rank would be `max_valid_pairs`.\n\n    # Let's re-evaluate. The problem says Vasya got *at least* x points.\n    # It does not say Vasya *must* be part of a pair that sums to >= x.\n    # It says \"there are two integers i, j (1 <= i, j <= n) such, that ai + bj >= x\".\n    # This means *some* participant can achieve >= x. Vasya is one of the N participants.\n    # He is guaranteed to be one of the people who can achieve >= x.\n\n    # Worst rank:\n    # Vasya wants to get a score S_V such that S_V >= x.\n    # To get the worst rank, he should choose the lowest possible S_V >= x.\n    # And the other N-1 participants should be paired such that as many as possible get score >= S_V.\n    # And among those with score S_V, Vasya is placed last.\n\n    # This is the standard interpretation for \"worst rank\":\n    # 1. Vasya achieves some score `S_V`.\n    # 2. Count `C_greater`: number of participants who can achieve a score `S_k > S_V`.\n    # 3. Count `C_equal`: number of participants who can achieve a score `S_k = S_V`.\n    # Vasya's rank is `C_greater + C_equal + 1`. (If he's last among equals)\n\n    # To maximize `C_greater + C_equal`:\n    # We need to find a pairing of all `a_i` and `b_j`.\n    # We want to find a pairing (p_1, ..., p_n) where p_k is the score of participant k.\n    # Vasya is one of these participants.\n    # Let Vasya's score be S_V. We want to maximize the count of p_k >= S_V.\n\n    # Let's consider all possible scores that Vasya could get.\n    # Vasya can get any score `a[i] + b[j]` such that `a[i] + b[j] >= x`.\n    # To get the worst rank, he should choose `a[i]` and `b[j]` such that `a[i] + b[j]` is minimized,\n    # subject to `a[i] + b[j] >= x`.\n    # Let this minimum possible valid score for Vasya be `S_min_vasya`.\n    # We can find `S_min_vasya` by iterating through `a` and using binary search on `b`.\n    # `S_min_vasya = infinity`\n    # For each `val_a` in `a`:\n    #   `target_b = x - val_a`\n    #   Find smallest `b_k` in `b` such that `b_k >= target_b`.\n    #   If such `b_k` exists:\n    #     `S_min_vasya = min(S_min_vasya, val_a + b_k)`\n    # This is not right, because Vasya cannot just pick any `a_i` and any `b_j` if they are already used by others.\n    # The problem implies we assign *all* `a_i` to *all* `b_j` to form `N` pairs.\n\n    # Let's try a different approach for worst rank.\n    # We want to find a pairing (a_p[k], b_q[k]) for k=0..n-1 that maximizes Vasya's rank.\n    # This means Vasya gets some score S_V, and as many other participants as possible get scores >= S_V.\n    # And if others get S_V, they are placed above Vasya.\n\n    # Consider a fixed score `S`. How many participants can achieve a score of at least `S`?\n    # This is the problem of finding the maximum number of pairs (a_i, b_j) such that a_i + b_j >= S.\n    # Let `count_ge(S)` be this maximum number.\n    # We want to find `S_V` such that `S_V >= x`, and `count_ge(S_V)` is maximized.\n    # If `S_V` is low, `count_ge(S_V)` tends to be high.\n    # So Vasya should pick the lowest possible `S_V` (which is `x` itself, or something slightly higher if `x` is not achievable by any pair).\n    # The actual score Vasya gets must be `a_i + b_j`. So `S_V` must be one of the possible sums.\n\n    # Let's find `count_ge(S)`:\n    # Sort `a` and `b`.\n    # `a_ptr = 0`, `b_ptr = n-1`\n    # `count = 0`\n    # While `a_ptr < n` and `b_ptr >= 0`:\n    #   If `a[a_ptr] + b[b_ptr] >= S`:\n    #     `count += 1`\n    #     `a_ptr += 1`\n    #     `b_ptr -= 1`\n    #   Else (`a[a_ptr] + b[b_ptr] < S`):\n    #     `a_ptr += 1`\n    # Return `count`.\n\n    # The maximum possible rank Vasya can get is `count_ge(S_V)`.\n    # What is `S_V`? It must be some `a_i + b_j` and `a_i + b_j >= x`.\n    # To maximize `count_ge(S_V)`, we want `S_V` to be as small as possible.\n    # The smallest possible `S_V` is `x`.\n    # So we want to find `count_ge(x)`. This is the number of participants who can score at least `x`.\n    # If Vasya is one of these, and he gets exactly `x` (or the lowest score among them),\n    # then his rank would be `count_ge(x)`.\n\n    # Example 1: n=5, x=2. a=[1,1,1,1,1], b=[1,1,1,1,1]\n    # Sorted a: [1,1,1,1,1], Sorted b: [1,1,1,1,1]\n    # count_ge(2):\n    # a_ptr=0, b_ptr=4. a[0]+b[4] = 1+1=2 >= 2. count=1. a_ptr=1, b_ptr=3.\n    # a_ptr=1, b_ptr=3. a[1]+b[3] = 1+1=2 >= 2. count=2. a_ptr=2, b_ptr=2.\n    # a_ptr=2, b_ptr=2. a[2]+b[2] = 1+1=2 >= 2. count=3. a_ptr=3, b_ptr=1.\n    # a_ptr=3, b_ptr=1. a[3]+b[1] = 1+1=2 >= 2. count=4. a_ptr=4, b_ptr=0.\n    # a_ptr=4, b_ptr=0. a[4]+b[0] = 1+1=2 >= 2. count=5. a_ptr=5, b_ptr=-1.\n    # Loop ends. count_ge(2) = 5.\n    # So worst rank is 5. This matches example output.\n\n    # Example 2: n=6, x=7. a=[4,3,5,6,4,4], b=[8,6,0,4,3,4]\n    # Sorted a: [3,4,4,4,5,6]\n    # Sorted b: [0,3,4,4,6,8]\n    # count_ge(7):\n    # S = 7\n    # a_ptr=0 (a[0]=3), b_ptr=5 (b[5]=8). a[0]+b[5] = 3+8=11 >= 7. count=1. a_ptr=1, b_ptr=4.\n    # a_ptr=1 (a[1]=4), b_ptr=4 (b[4]=6). a[1]+b[4] = 4+6=10 >= 7. count=2. a_ptr=2, b_ptr=3.\n    # a_ptr=2 (a[2]=4), b_ptr=3 (b[3]=4). a[2]+b[3] = 4+4=8 >= 7. count=3. a_ptr=3, b_ptr=2.\n    # a_ptr=3 (a[3]=4), b_ptr=2 (b[2]=4). a[3]+b[2] = 4+4=8 >= 7. count=4. a_ptr=4, b_ptr=1.\n    # a_ptr=4 (a[4]=5), b_ptr=1 (b[1]=3). a[4]+b[1] = 5+3=8 >= 7. count=5. a_ptr=5, b_ptr=0.\n    # a_ptr=5 (a[5]=6), b_ptr=0 (b[0]=0). a[5]+b[0] = 6+0=6 < 7. a_ptr=6.\n    # Loop ends. count_ge(7) = 5.\n    # So worst rank is 5. This matches example output.\n\n    # This seems to be the correct logic for worst rank.\n    # The logic is: Vasya wants to be as low as possible.\n    # He can choose any (a_i, b_j) such that a_i + b_j >= x.\n    # To maximize his rank, he would choose the (a_i, b_j) that results in the lowest score S_V (where S_V >= x).\n    # Then, we consider a pairing of *all* N participants such that as many people as possible score >= S_V.\n    # The maximum number of people who can score >= S_V is `count_ge(S_V)`.\n    # If Vasya gets S_V, and is placed last among those with S_V, his rank is `count_ge(S_V)`.\n    # To maximize `count_ge(S_V)`, `S_V` should be minimized.\n    # The smallest possible `S_V` that Vasya could be associated with is `x`.\n    # So we calculate `count_ge(x)`.\n\n    def count_ge(target_score, arr_a, arr_b):\n        count = 0\n        l = 0\n        r = n - 1\n        while l < n and r >= 0:\n            if arr_a[l] + arr_b[r] >= target_score:\n                count += 1\n                l += 1\n                r -= 1\n            else:\n                l += 1 # a[l] is too small, even with largest b[r]. Try next a[l].\n        return count\n\n    worst_rank = count_ge(x, a, b)\n\n    sys.stdout.write(f\"{best_rank} {worst_rank}\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    a.sort()\n    b.sort()\n\n    # Calculate best possible rank\n    # Vasya wants to maximize his score. He picks the highest possible a_i and b_j such that a_i + b_j >= x.\n    # To get the best rank, he also wants to minimize the scores of other participants.\n    # This means other participants should be paired such that their sums are as low as possible.\n    # However, the problem states \"the total results' table sorts the participants by the sum of points\".\n    # And \"If two or more participants have got the same number of points, it's up to the jury to assign places to them\".\n    # This implies that Vasya's specific scores (a_i, b_j) and other participants' scores are not fixed.\n    # We are looking for the best and worst possible *rank* Vasya could achieve.\n\n    # Best rank: Vasya wants to maximize his score. He can pick the largest a[i] and largest b[j].\n    # Since he is guaranteed to exist, he can always pick a pair (a_i, b_j) such that a_i + b_j >= x.\n    # To maximize his score, he would take a[n-1] and b[n-1]. Their sum is a[n-1] + b[n-1].\n    # If a[n-1] + b[n-1] < x, then Vasya cannot achieve this score.\n    # The guarantee states there exist i, j such that a_i + b_j >= x.\n    # So Vasya's maximum possible score is a[n-1] + b[n-1].\n    # Let Vasya's maximum score be V_max = a[n-1] + b[n-1].\n    # The best rank for Vasya is 1. This happens if he gets the highest possible score, and the jury\n    # places him first among those with the same score.\n    # Since Vasya can always achieve a score (a_i + b_j >= x), and he can pick the largest a_i and b_j,\n    # he can achieve a[n-1] + b[n-1].\n    # It is always possible for Vasya to be 1st. He can achieve the maximum possible sum (a[n-1] + b[n-1]).\n    # If multiple people achieve this, he can be assigned 1st place.\n    best_rank = 1\n\n    # Worst rank: Vasya wants to minimize his score, but still satisfy a_i + b_j >= x.\n    # And other participants want to maximize their scores.\n    # Vasya's minimum possible score:\n    # Vasya needs to pick some a_i and some b_j such that a_i + b_j >= x.\n    # To get the worst rank, he should pick the smallest possible sum (a_i + b_j) that satisfies the condition.\n    # This is tricky because other people also need to be assigned points.\n    # We need to find a pairing of all a_k and b_k such that Vasya gets a score S_V, and other people get scores S_k.\n    # Then we count how many people have score >= S_V.\n\n    # Consider the worst case for Vasya. He gets a pair (a_i, b_j) such that a_i + b_j >= x.\n    # To maximize his rank (make it as high as possible, i.e., closer to n),\n    # he wants to minimize his score, while other participants maximize their scores.\n    # However, the problem phrasing \"find two numbers — the best and the worst place Vasya could have won\"\n    # implies we consider all possible pairings.\n\n    # Let's consider a fixed score S for Vasya. How many people could possibly score >= S?\n    # To maximize the number of people scoring >= S, we try to pair a_k and b_k such that their sum is >= S.\n    # This is a maximum bipartite matching problem, or can be solved with a greedy approach.\n\n    # To find the worst rank:\n    # Vasya takes some a_i and some b_j such that a_i + b_j >= x.\n    # To maximize his rank, he should choose a pair (a_i, b_j) such that a_i + b_j is minimized,\n    # subject to a_i + b_j >= x.\n    # Let's call this minimal possible score Vasya can get S_vasya_min_valid.\n    # For a fixed a_i, Vasya needs to find b_j such that b_j >= x - a_i. He would pick the smallest such b_j.\n    # So, for each a_i, find the smallest b_j such that a_i + b_j >= x. This can be done using binary search on b.\n    # Iterate through all a_i. For each a_i, find the smallest b_j such that b_j >= x - a_i.\n    # If such b_j exists, then a_i + b_j is a candidate for Vasya's score.\n    # The minimum of these candidates is S_vasya_min_valid.\n    # But this is not quite right. Vasya doesn't just pick one a_i and one b_j.\n    # He is one of the N participants. All N participants must be paired up.\n\n    # The key insight for worst rank:\n    # Vasya wants to minimize his score S_V, subject to S_V >= x.\n    # All other N-1 participants want to maximize their scores.\n    # The pairing is fixed for all N participants.\n    # The problem implies that we can choose *any* permutation of b to pair with a.\n    # So we want to find a permutation of b such that Vasya gets a score S_V (where S_V >= x),\n    # and the number of people with score >= S_V is maximized.\n\n    # Consider a fixed pairing of (a_i, b_i) (after sorting b).\n    # What if Vasya is assigned (a[i], b[j])?\n    # This is a typical \"how many pairs (a_i, b_j) sum to at least K\" problem.\n    # For worst rank, we want to maximize the number of people who score *strictly greater* than Vasya,\n    # and then maximize the number of people who score *equal* to Vasya and are placed above him.\n\n    # Let's re-read the problem carefully: \"find two numbers — the best and the worst place Vasya could have won.\"\n    # This means we are free to choose *which* a_i and *which* b_j Vasya gets, as long as a_i + b_j >= x.\n    # And we are free to choose how the remaining N-1 participants are paired up.\n    # And we are free to choose the jury's decision for ties.\n\n    # Best case: Vasya gets a[n-1] + b[n-1]. He is placed 1st. (Already handled, best_rank = 1)\n\n    # Worst case:\n    # Vasya wants to get the lowest possible score S_V such that S_V >= x.\n    # To maximize his rank (worst place), he should choose a score S_V that is as low as possible (but >= x).\n    # And then, among all possible pairings of (a, b) for all N participants, we want to find one\n    # where the number of people with score >= S_V is maximized.\n\n    # Let's try to find the maximum number of pairs (a_i, b_j) such that a_i + b_j >= x.\n    # This is a standard two-pointer approach.\n    # Sort a and b.\n    # Iterate with a pointer `i` from 0 to n-1 for array `a`.\n    # For each `a[i]`, we need to find `b[j]` such that `a[i] + b[j] >= x`.\n    # To maximize the count of such pairs, we use a greedy approach.\n    # Sort `a` in ascending order. Sort `b` in ascending order.\n    # Use two pointers: `l` for `a` (starting at 0) and `r` for `b` (starting at n-1).\n    # `count = 0`\n    # While `l < n` and `r >= 0`:\n    #   If `a[l] + b[r] >= x`:\n    #     We can form a valid pair. Increment `count`. Move both pointers: `l++`, `r--`.\n    #     (This pairing maximizes the number of pairs >= x because we use the largest available b for the smallest available a that can make the sum, freeing up smaller b's for other a's, or larger b's for larger a's.)\n    #   Else (`a[l] + b[r] < x`):\n    #     `a[l]` is too small to pair with `b[r]` to reach `x`. We need a larger `a`. Move `l++`.\n    # This count is the maximum number of participants who *could* score at least `x`.\n    # Let this be `max_valid_pairs`.\n    # If Vasya is one of these `max_valid_pairs`, and he gets the lowest score among them,\n    # and everyone else who also scored >= x is placed above him, then his rank would be `max_valid_pairs`.\n\n    # Let's re-evaluate. The problem says Vasya got *at least* x points.\n    # It does not say Vasya *must* be part of a pair that sums to >= x.\n    # It says \"there are two integers i, j (1 <= i, j <= n) such, that ai + bj >= x\".\n    # This means *some* participant can achieve >= x. Vasya is one of the N participants.\n    # He is guaranteed to be one of the people who can achieve >= x.\n\n    # Worst rank:\n    # Vasya wants to get a score S_V such that S_V >= x.\n    # To get the worst rank, he should choose the lowest possible S_V >= x.\n    # And the other N-1 participants should be paired such that as many as possible get score >= S_V.\n    # And among those with score S_V, Vasya is placed last.\n\n    # This is the standard interpretation for \"worst rank\":\n    # 1. Vasya achieves some score `S_V`.\n    # 2. Count `C_greater`: number of participants who can achieve a score `S_k > S_V`.\n    # 3. Count `C_equal`: number of participants who can achieve a score `S_k = S_V`.\n    # Vasya's rank is `C_greater + C_equal + 1`. (If he's last among equals)\n\n    # To maximize `C_greater + C_equal`:\n    # We need to find a pairing of all `a_i` and `b_j`.\n    # We want to find a pairing (p_1, ..., p_n) where p_k is the score of participant k.\n    # Vasya is one of these participants.\n    # Let Vasya's score be S_V. We want to maximize the count of p_k >= S_V.\n\n    # Let's consider all possible scores that Vasya could get.\n    # Vasya can get any score `a[i] + b[j]` such that `a[i] + b[j] >= x`.\n    # To get the worst rank, he should choose `a[i]` and `b[j]` such that `a[i] + b[j]` is minimized,\n    # subject to `a[i] + b[j] >= x`.\n    # Let this minimum possible valid score for Vasya be `S_min_vasya`.\n    # We can find `S_min_vasya` by iterating through `a` and using binary search on `b`.\n    # `S_min_vasya = infinity`\n    # For each `val_a` in `a`:\n    #   `target_b = x - val_a`\n    #   Find smallest `b_k` in `b` such that `b_k >= target_b`.\n    #   If such `b_k` exists:\n    #     `S_min_vasya = min(S_min_vasya, val_a + b_k)`\n    # This is not right, because Vasya cannot just pick any `a_i` and any `b_j` if they are already used by others.\n    # The problem implies we assign *all* `a_i` to *all* `b_j` to form `N` pairs.\n\n    # Let's try a different approach for worst rank.\n    # We want to find a pairing (a_p[k], b_q[k]) for k=0..n-1 that maximizes Vasya's rank.\n    # This means Vasya gets some score S_V, and as many other participants as possible get scores >= S_V.\n    # And if others get S_V, they are placed above Vasya.\n\n    # Consider a fixed score `S`. How many participants can achieve a score of at least `S`?\n    # This is the problem of finding the maximum number of pairs (a_i, b_j) such that a_i + b_j >= S.\n    # Let `count_ge(S)` be this maximum number.\n    # We want to find `S_V` such that `S_V >= x`, and `count_ge(S_V)` is maximized.\n    # If `S_V` is low, `count_ge(S_V)` tends to be high.\n    # So Vasya should pick the lowest possible `S_V` (which is `x` itself, or something slightly higher if `x` is not achievable by any pair).\n    # The actual score Vasya gets must be `a_i + b_j`. So `S_V` must be one of the possible sums.\n\n    # Let's find `count_ge(S)`:\n    # Sort `a` and `b`.\n    # `a_ptr = 0`, `b_ptr = n-1`\n    # `count = 0`\n    # While `a_ptr < n` and `b_ptr >= 0`:\n    #   If `a[a_ptr] + b[b_ptr] >= S`:\n    #     `count += 1`\n    #     `a_ptr += 1`\n    #     `b_ptr -= 1`\n    #   Else (`a[a_ptr] + b[b_ptr] < S`):\n    #     `a_ptr += 1`\n    # Return `count`.\n\n    # The maximum possible rank Vasya can get is `count_ge(S_V)`.\n    # What is `S_V`? It must be some `a_i + b_j` and `a_i + b_j >= x`.\n    # To maximize `count_ge(S_V)`, we want `S_V` to be as small as possible.\n    # The smallest possible `S_V` is `x`.\n    # So we want to find `count_ge(x)`. This is the number of participants who can score at least `x`.\n    # If Vasya is one of these, and he gets exactly `x` (or the lowest score among them),\n    # then his rank would be `count_ge(x)`.\n\n    # Example 1: n=5, x=2. a=[1,1,1,1,1], b=[1,1,1,1,1]\n    # Sorted a: [1,1,1,1,1], Sorted b: [1,1,1,1,1]\n    # count_ge(2):\n    # a_ptr=0, b_ptr=4. a[0]+b[4] = 1+1=2 >= 2. count=1. a_ptr=1, b_ptr=3.\n    # a_ptr=1, b_ptr=3. a[1]+b[3] = 1+1=2 >= 2. count=2. a_ptr=2, b_ptr=2.\n    # a_ptr=2, b_ptr=2. a[2]+b[2] = 1+1=2 >= 2. count=3. a_ptr=3, b_ptr=1.\n    # a_ptr=3, b_ptr=1. a[3]+b[1] = 1+1=2 >= 2. count=4. a_ptr=4, b_ptr=0.\n    # a_ptr=4, b_ptr=0. a[4]+b[0] = 1+1=2 >= 2. count=5. a_ptr=5, b_ptr=-1.\n    # Loop ends. count_ge(2) = 5.\n    # So worst rank is 5. This matches example output.\n\n    # Example 2: n=6, x=7. a=[4,3,5,6,4,4], b=[8,6,0,4,3,4]\n    # Sorted a: [3,4,4,4,5,6]\n    # Sorted b: [0,3,4,4,6,8]\n    # count_ge(7):\n    # S = 7\n    # a_ptr=0 (a[0]=3), b_ptr=5 (b[5]=8). a[0]+b[5] = 3+8=11 >= 7. count=1. a_ptr=1, b_ptr=4.\n    # a_ptr=1 (a[1]=4), b_ptr=4 (b[4]=6). a[1]+b[4] = 4+6=10 >= 7. count=2. a_ptr=2, b_ptr=3.\n    # a_ptr=2 (a[2]=4), b_ptr=3 (b[3]=4). a[2]+b[3] = 4+4=8 >= 7. count=3. a_ptr=3, b_ptr=2.\n    # a_ptr=3 (a[3]=4), b_ptr=2 (b[2]=4). a[3]+b[2] = 4+4=8 >= 7. count=4. a_ptr=4, b_ptr=1.\n    # a_ptr=4 (a[4]=5), b_ptr=1 (b[1]=3). a[4]+b[1] = 5+3=8 >= 7. count=5. a_ptr=5, b_ptr=0.\n    # a_ptr=5 (a[5]=6), b_ptr=0 (b[0]=0). a[5]+b[0] = 6+0=6 < 7. a_ptr=6.\n    # Loop ends. count_ge(7) = 5.\n    # So worst rank is 5. This matches example output.\n\n    # This seems to be the correct logic for worst rank.\n    # The logic is: Vasya wants to be as low as possible.\n    # He can choose any (a_i, b_j) such that a_i + b_j >= x.\n    # To maximize his rank, he would choose the (a_i, b_j) that results in the lowest score S_V (where S_V >= x).\n    # Then, we consider a pairing of *all* N participants such that as many people as possible score >= S_V.\n    # The maximum number of people who can score >= S_V is `count_ge(S_V)`.\n    # If Vasya gets S_V, and is placed last among those with S_V, his rank is `count_ge(S_V)`.\n    # To maximize `count_ge(S_V)`, `S_V` should be minimized.\n    # The smallest possible `S_V` that Vasya could be associated with is `x`.\n    # So we calculate `count_ge(x)`.\n\n    def count_ge(target_score, arr_a, arr_b):\n        count = 0\n        l = 0\n        r = n - 1\n        while l < n and r >= 0:\n            if arr_a[l] + arr_b[r] >= target_score:\n                count += 1\n                l += 1\n                r -= 1\n            else:\n                l += 1 # a[l] is too small, even with largest b[r]. Try next a[l].\n        return count\n\n    worst_rank = count_ge(x, a, b)\n\n    sys.stdout.write(f\"{best_rank} {worst_rank}\\n\")\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 873,
        "completion_token_count": 4936,
        "thoughts_token_count": 0
    }
}