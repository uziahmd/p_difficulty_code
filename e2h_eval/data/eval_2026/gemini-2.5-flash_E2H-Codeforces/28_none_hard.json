{
    "start": 1758293736.1670125,
    "end": 1758293827.1879203,
    "start-formatted": "2025-09-19 23:55 KST",
    "end-formatted": "2025-09-19 23:57 KST",
    "gpu": 2,
    "pid": 28,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vasily the Bear and Beautiful Strings\n\nVasily the Bear loves beautiful strings. String s is beautiful if it meets the following criteria:   String s only consists of characters 0 and 1, at that character 0 must occur in string s exactly n times, and character 1 must occur exactly m times.  We can obtain character g from string s with some (possibly, zero) number of modifications. The character g equals either zero or one. A modification of string with length at least two is the following operation: we replace two last characters from the string by exactly one other character. This character equals one if it replaces two zeros, otherwise it equals zero. For example, one modification transforms string \"01010\" into string \"0100\", two modifications transform it to \"011\". It is forbidden to modify a string with length less than two.Help the Bear, count the number of beautiful strings. As the number of beautiful strings can be rather large, print the remainder after dividing the number by 1000000007 (109 + 7). \n\n## Input\nThe first line of the input contains three space-separated integers n, m, g (0 ≤ n, m ≤ 105, n + m ≥ 1, 0 ≤ g ≤ 1).\n\n## Output\nPrint a single integer — the answer to the problem modulo 1000000007 (109 + 7).\n\n## Example\n### Input\n['1 1 0', '2 2 0', '1 1 1']\n\n### Output\n['2', '4', '0']\n\n## Note\nIn the first sample the beautiful strings are: \"01\", \"10\".In the second sample the beautiful strings are: \"0011\", \"1001\", \"1010\", \"1100\".In the third sample there are no beautiful strings.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "",
    "response": "```python\nimport sys\n\nMOD = 1000000007\n\ndef solve():\n    n, m, g = map(int, sys.stdin.readline().split())\n\n    if n == 0 and m == 0:\n        print(0)\n        return\n\n    fact = [1] * (n + m + 1)\n    inv_fact = [1] * (n + m + 1)\n\n    for i in range(1, n + m + 1):\n        fact[i] = (fact[i - 1] * i) % MOD\n\n    inv_fact[n + m] = pow(fact[n + m], MOD - 2, MOD)\n    for i in range(n + m - 1, -1, -1):\n        inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD\n\n    def nCr_mod_p(n_val, r_val):\n        if r_val < 0 or r_val > n_val:\n            return 0\n        num = fact[n_val]\n        den = (inv_fact[r_val] * inv_fact[n_val - r_val]) % MOD\n        return (num * den) % MOD\n\n    if n == 0:\n        if m == 1:\n            if g == 1:\n                print(1)\n            else:\n                print(0)\n        else: # m > 1\n            if g == 0:\n                print(1)\n            else:\n                print(0)\n        return\n\n    if m == 0:\n        if g == 0:\n            print(1)\n        else:\n            print(0)\n        return\n\n    ans = 0\n    if g == 0:\n        # Case 1: The final character is 0\n        # This happens if the number of 1s in the sequence of results is even.\n        # Or, if the final character is 0 from a sequence of only 0s.\n        \n        # If the number of 1s in the original string (m) is even,\n        # then the final character from 1s is 0.\n        # If m is odd, the final character from 1s is 1.\n\n        # If m is even, the final character from 1s is 0.\n        # We need to combine this 0 with n 0s. The result is always 0.\n        # So, if m is even, the result is always 0.\n        if m % 2 == 0:\n            ans = nCr_mod_p(n + m, n)\n        else: # m is odd\n            # The final character from 1s is 1.\n            # We need to combine this 1 with n 0s.\n            # The result of combining 1 with a 0 is always 0.\n            # So, the final character will be 0 if n >= 1.\n            # If n=0, this case is handled above.\n            ans = nCr_mod_p(n + m, n)\n\n    else: # g == 1\n        # Case 2: The final character is 1\n        # This happens if the number of 1s in the sequence of results is odd.\n        \n        # If m is even, the final character from 1s is 0.\n        # We combine this 0 with n 0s. The result is always 0.\n        # So, if m is even, the result cannot be 1.\n        if m % 2 == 0:\n            ans = 0\n        else: # m is odd\n            # The final character from 1s is 1.\n            # We need to combine this 1 with n 0s.\n            # The result of combining 1 with a 0 is always 0.\n            # However, if n=0, then the result is just 1.\n            # If n >= 1, the result is 0.\n            if n == 0: # This case is handled above\n                # m is odd, n=0. The string is all 1s.\n                # If m=1, result is 1.\n                # If m>1, result is 0.\n                # This is already handled by the m=0 case.\n                pass\n            else: # n >= 1\n                ans = 0\n\n    # The logic above for g=0, m even and g=0, m odd seems to be incorrect.\n    # Let's re-evaluate the parity of the final character.\n    # The final character is 1 if and only if the number of 1s in the string\n    # (after processing all 0s) is odd.\n    # The operation: replace two last characters by one.\n    # 0,0 -> 1\n    # 0,1 -> 0\n    # 1,0 -> 0\n    # 1,1 -> 0\n\n    # Let's consider the parity of the number of 1s in the string.\n    # (x, y) -> z\n    # If x, y are 0, 0 -> z is 1. (parity changes)\n    # If x, y are 0, 1 -> z is 0. (parity changes)\n    # If x, y are 1, 0 -> z is 0. (parity changes)\n    # If x, y are 1, 1 -> z is 0. (parity changes)\n\n    # This is not about parity of 1s. This is about the final character.\n    # The value of the last character of the reduced string depends on the parity of the number of 0s that are processed with 1s.\n    # If we have a sequence of only 0s, say '00...0' (k times).\n    # '00' -> '1'\n    # '000' -> '01' -> '0'\n    # '0000' -> '001' -> '01' -> '0'\n    # '00000' -> '0001' -> '000' -> '01' -> '0'\n    # The result of k 0s is 1 if k=2. Otherwise it's 0 if k>=1.\n    # This is wrong.\n    # '0' -> '0'\n    # '00' -> '1'\n    # '000' -> '01' -> '0'\n    # '0000' -> '001' -> '01' -> '0'\n    # The result of k 0s is 1 if k is even and k >= 2.\n    # The result of k 0s is 0 if k is odd and k >= 1.\n\n    # What about 1s?\n    # '1' -> '1'\n    # '11' -> '0'\n    # '111' -> '10' -> '0'\n    # '1111' -> '110' -> '10' -> '0'\n    # The result of k 1s is 1 if k=1.\n    # The result of k 1s is 0 if k >= 2.\n\n    # Let's analyze the final character.\n    # The operation is (a, b) -> (a XOR b) XOR 1.\n    # Example: 0,0 -> (0 XOR 0) XOR 1 = 1\n    #          0,1 -> (0 XOR 1) XOR 1 = 0\n    #          1,0 -> (1 XOR 0) XOR 1 = 0\n    #          1,1 -> (1 XOR 1) XOR 1 = 1\n    # This is not what the problem states.\n    # The problem states: \"This character equals one if it replaces two zeros, otherwise it equals zero.\"\n    # (0,0) -> 1\n    # (0,1) -> 0\n    # (1,0) -> 0\n    # (1,1) -> 0\n\n    # Let's consider the final character value.\n    # The final character is 1 if and only if the last operation was (0,0) -> 1.\n    # This means the string before the last operation must have been '...00'.\n    # All other operations result in 0.\n\n    # Let's denote the value of the string S as val(S).\n    # val(S_prefix + '00') = val(S_prefix + '1')\n    # val(S_prefix + '01') = val(S_prefix + '0')\n    # val(S_prefix + '10') = val(S_prefix + '0')\n    # val(S_prefix + '11') = val(S_prefix + '0')\n\n    # This means, if there is any '1' in the original string,\n    # or if there is a '0' next to a '1' in the reduction,\n    # the final character will be 0, unless n=0 and m=1 (string \"1\").\n    # If the string contains at least one '1', and its length is > 1:\n    # If '...01' -> '...0'\n    # If '...10' -> '...0'\n    # If '...11' -> '...0'\n    # The only way to get a '1' is if the string is '00' or '1'.\n\n    # Let's trace the effect of 1s.\n    # Any '1' in the string will eventually interact with another character.\n    # If a '1' interacts with a '0' (01 or 10), the result is '0'.\n    # If a '1' interacts with a '1' (11), the result is '0'.\n    # So, if there is at least one '1' in the string, and it's not the only character,\n    # it seems to lead to a '0' result.\n    # The only exception is if the string is just \"1\" (n=0, m=1). In this case, the result is 1.\n\n    # What if n >= 2?\n    # If n >= 2, we can always form \"00\" somewhere.\n    # If we have \"00\", it can become \"1\".\n    # This \"1\" then interacts with other characters.\n    # This is getting complicated. Let's use the property of the final character.\n\n    # The final character is 1 if and only if the string can be reduced to \"1\".\n    # The string can be reduced to \"1\" in two ways:\n    # 1. The original string is \"1\" (n=0, m=1).\n    # 2. The string can be reduced to \"00\", which then becomes \"1\".\n\n    # When does a string reduce to \"00\"?\n    # A string of length L reduces to a single character.\n    # The value of this character depends on the *parity* of the number of '1's involved in '00' operations.\n    # This is a known problem: The final character is 1 if and only if the number of 1s in the string is 1, AND n=0.\n    # Or if n is even, and m=0.\n    # No, this is for (a,b) -> a XOR b.\n\n    # Let's consider the number of 1s.\n    # Let S be a string. Let N_0(S) be count of 0s, N_1(S) be count of 1s.\n    # If we replace two characters X, Y by Z:\n    # (0,0) -> 1: N_0 decreases by 2, N_1 increases by 1.\n    # (0,1) -> 0: N_0 decreases by 1, N_1 decreases by 1, N_0 increases by 1. (Net: N_1 decreases by 1)\n    # (1,0) -> 0: N_0 decreases by 1, N_1 decreases by 1, N_0 increases by 1. (Net: N_1 decreases by 1)\n    # (1,1) -> 0: N_1 decreases by 2, N_0 increases by 1.\n\n    # This is a parity argument.\n    # Let's look at the \"sum\" of characters modulo 2.\n    # For (0,0) -> 1: 0+0=0, result is 1. (sum changes parity)\n    # For (0,1) -> 0: 0+1=1, result is 0. (sum changes parity)\n    # For (1,0) -> 0: 1+0=1, result is 0. (sum changes parity)\n    # For (1,1) -> 0: 1+1=0, result is 0. (sum stays same parity)\n\n    # This is not a simple parity argument.\n    # The problem is equivalent to finding the value of a binary expression tree.\n    # Each leaf is 0 or 1. Each internal node is the \"modification\" operation.\n    # The final character is '1' if and only if the number of '1's in the string is 1 and n=0, OR if n is even and m=0.\n    # This is the standard problem.\n    # The operation is NOT (a XOR b) XOR 1.\n    # The operation is: f(x,y) = 1 if x=0, y=0. Else f(x,y) = 0.\n\n    # Let's denote the value of a string S as V(S).\n    # V(S_1 S_2 ... S_k) = V(S_1 S_2 ... V(S_{k-1} S_k))\n    # V(00) = 1\n    # V(01) = 0\n    # V(10) = 0\n    # V(11) = 0\n\n    # Consider the rightmost '1'. If it exists.\n    # If the string is S_prefix + '1' + S_suffix (where S_suffix contains only 0s).\n    # Example: '00100'.\n    # '00100' -> '0010' -> '000' -> '01' -> '0'\n    # Example: '0010'\n    # '0010' -> '000' -> '01' -> '0'\n    # Example: '001'\n    # '001' -> '00' -> '1'\n    # Example: '010'\n    # '010' -> '00' -> '1'\n    # Example: '100'\n    # '100' -> '10' -> '0'\n    # Example: '10' -> '0'\n    # Example: '11' -> '0'\n    # Example: '00' -> '1'\n    # Example: '0' -> '0'\n    # Example: '1' -> '1'\n\n    # Observations:\n    # 1. If m = 1 and n = 0, string is \"1\". Result is 1.\n    # 2. If n = 0 and m > 1, string is \"1...1\". Result is 0.\n    # 3. If m = 0 and n = 1, string is \"0\". Result is 0.\n    # 4. If m = 0 and n > 1:\n    #    \"00\" -> 1\n    #    \"000\" -> \"01\" -> 0\n    #    \"0000\" -> \"001\" -> \"01\" -> 0\n    #    \"00000\" -> \"0001\" -> \"000\" -> \"01\" -> 0\n    #    The result of N 0s is 1 if N=2. Otherwise it's 0 if N >= 1.\n    #    This is incorrect based on the example. \"0000\" -> \"001\" (replace last two 0s with 1).\n    #    Then \"001\" -> \"00\" (replace 01 with 0). Then \"00\" -> \"1\".\n    #    So, \"0000\" -> \"1\".\n    #    Let's re-evaluate:\n    #    V(0) = 0\n    #    V(00) = 1\n    #    V(000) = V(0(00)) = V(01) = 0\n    #    V(0000) = V(00(00)) = V(001) = V(00) = 1 (since 01->0)\n    #    V(00000) = V(000(00)) = V(0001) = V(000) = 0 (since 01->0)\n    #    So, for N 0s: V(N 0s) = 1 if N is even and N >= 2.\n    #    V(N 0s) = 0 if N is odd and N >= 1.\n\n    # Summary of base cases:\n    # - n=0, m=1 (\"1\"): result is 1.\n    # - n=0, m>1 (\"1...1\"): result is 0.\n    # - m=0, n=1 (\"0\"): result is 0.\n    # - m=0, n even, n>=2 (\"0...0\"): result is 1.\n    # - m=0, n odd, n>=3 (\"0...0\"): result is 0.\n\n    # Now consider n >= 1 and m >= 1.\n    # This means there's at least one '0' and at least one '1'.\n    # The key is that any '1' interacting with a '0' or another '1' results in a '0'.\n    # V(01) = 0\n    # V(10) = 0\n    # V(11) = 0\n    # This implies that if we ever form a '0' from a '1' (by any of the above operations),\n    # then this '0' will propagate.\n    # The only way to get a '1' is from '00'.\n\n    # Let's consider the final character g.\n    # If g = 1:\n    #   The string must reduce to \"1\".\n    #   This happens if the string is \"1\" (n=0, m=1) or if it reduces to \"00\".\n    #   Can a string with n>=1, m>=1 reduce to \"00\"?\n    #   Example: \"010\" -> \"00\" -> \"1\". (n=2, m=1, g=1)\n    #   Example: \"100\" -> \"10\" -> \"0\". (n=2, m=1, g=0)\n    #   Example: \"001\" -> \"00\" -> \"1\". (n=2, m=1, g=1)\n    #   Example: \"011\" -> \"00\" -> \"1\". (n=1, m=2, g=1)\n    #   Example: \"101\" -> \"10\" -> \"0\". (n=1, m=2, g=0)\n    #   Example: \"110\" -> \"10\" -> \"0\". (n=1, m=2, g=0)\n\n    # It seems that if the string contains a '1', and it's not the only character,\n    # the value of the string is 1 if and only if the number of 0s to the left of the rightmost 1\n    # is even, AND the number of 1s (including the rightmost 1) is odd.\n    # This is not a good approach.\n\n    # Let's consider the parity of the number of 0s.\n    # If we have a string S.\n    # If the last character is '1'.\n    # S = S' + '1'.\n    # V(S) = V(S' + '1').\n    # If S' ends with '0': V(S' + '01') = V(S' + '0')\n    # If S' ends with '1': V(S' + '11') = V(S' + '0')\n\n    # If the last character is '0'.\n    # S = S' + '0'.\n    # V(S) = V(S' + '0').\n    # If S' ends with '0': V(S' + '00') = V(S' + '1')\n    # If S' ends with '1': V(S' + '10') = V(S' + '0')\n\n    # This means the last character of the reduced string is 1 if and only if\n    # the last operation was (0,0) -> 1.\n    # This means the string before the last operation was (something) + \"00\".\n    # This means the final character is 1 iff the final string is \"00\".\n    # This means the total number of characters (n+m) must be at least 2.\n\n    # The final character is 1 if and only if:\n    # (n=0, m=1) OR\n    # (n=2, m=0) OR\n    # (n=1, m=1, string is \"01\" or \"10\" -> V(\"01\")=0, V(\"10\")=0)\n    # Wait, example 1: n=1, m=1, g=0. Output 2. Strings \"01\", \"10\".\n    # V(\"01\") = 0. V(\"10\") = 0. So for n=1, m=1, g=0, answer is 2.\n    # For n=1, m=1, g=1, answer is 0. This implies my analysis of \"01\" and \"10\" is correct.\n\n    # Example 2: n=2, m=2, g=0. Output 4.\n    # Strings: \"0011\", \"1001\", \"1010\", \"1100\"\n    # V(\"0011\") = V(\"000\") = V(\"01\") = 0\n    # V(\"1001\") = V(\"100\") = V(\"10\") = 0\n    # V(\"1010\") = V(\"100\") = V(\"10\") = 0\n    # V(\"1100\") = V(\"110\") = V(\"10\") = 0\n    # All these are 0. So for n=2, m=2, g=0, answer is nCr(4,2) = 6. But example says 4.\n    # What strings are missing? \"0101\", \"0110\".\n    # V(\"0101\") = V(\"010\") = V(\"00\") = 1.\n    # V(\"0110\") = V(\"00\") = 1.\n    # So, for n=2, m=2:\n    # V(\"0011\")=0\n    # V(\"0101\")=1\n    # V(\"0110\")=1\n    # V(\"1001\")=0\n    # V(\"1010\")=0\n    # V(\"1100\")=0\n    # Total strings: nCr(4,2) = 6.\n    # Strings that result in 0: 4.\n    # Strings that result in 1: 2.\n    # So if g=0, answer is 4. If g=1, answer is 2.\n    # The example output for n=2, m=2, g=0 is 4. This matches.\n\n    # My understanding of the operation is correct now.\n    # V(S_1 S_2 ... S_k) = V(S_1 S_2 ... V(S_{k-1} S_k))\n    # V(X Y) = 1 if X=0, Y=0. Else 0.\n\n    # The final character is 1 if and only if:\n    # The string is \"1\" (n=0, m=1).\n    # OR, the string can be reduced to \"00\".\n    # A string can be reduced to \"00\" if:\n    # - It is \"00\".\n    # - It is \"0X0\" where V(X)=0. Example: \"010\" -> \"00\". V(\"1\")=1. So \"010\" -> V(\"0\"V(\"10\")) = V(\"00\") = 1.\n    # - It is \"X00\" where V(X)=0. Example: \"100\" -> V(\"10\") -> \"0\".\n    # - It is \"00X\" where V(X)=0. Example: \"001\" -> V(\"00\") -> \"1\".\n    # This is hard. Let's use the parity of the number of 1s in the string.\n    # The problem is that the operation changes 0s to 1s and vice versa.\n\n    # Let's consider the number of 0s and 1s.\n    # The final character is 1 iff the number of 0s is even and m=0, or n=0 and m=1.\n    # Otherwise, it is 0.\n    # This rule comes from a similar problem where (a,b) -> a XOR b.\n    # This is NOT a XOR b.\n    # (0,0) -> 1 (0 XOR 0 = 0)\n    # (0,1) -> 0 (0 XOR 1 = 1)\n    # (1,0) -> 0 (1 XOR 0 = 1)\n    # (1,1) -> 0 (1 XOR 1 = 0)\n\n    # Let's try to determine when the final character is 1.\n    # It is 1 iff:\n    # 1. The string is \"1\" (n=0, m=1).\n    # 2. The string is \"00\" (n=2, m=0).\n    # 3. The string is of the form S_1 S_2 ... S_k, and V(S_k-1 S_k) = 0.\n    #    And V(S_k-2 V(S_k-1 S_k)) = 0.\n    #    And so on, until the string reduces to \"00\".\n\n    # Let's define f(S) as the value of the string S.\n    # f(S_1 S_2 ... S_k) = f(S_1 ... S_{k-2} f(S_{k-1} S_k)).\n    # The final character is 1 if and only if the last operation performed was (0,0) -> 1.\n    # This means the string reduced to '00' at the last step.\n    # Let's denote the reduced value of a character 'c' as 'v(c)'.\n    # v(0) = 0, v(1) = 1.\n    # The string is S_1 S_2 ... S_{N+M}.\n    # The final character is f(S_1, f(S_2, ..., f(S_{N+M-1}, S_{N+M})...)).\n    # Let R_k = f(S_k, f(S_{k+1}, ..., f(S_{N+M-1}, S_{N+M})...)).\n    # R_{N+M} = S_{N+M}\n    # R_k = f(S_k, R_{k+1}).\n    # The final result is R_1.\n\n    # R_k is 1 iff S_k=0 and R_{k+1}=0. Otherwise R_k is 0.\n    # So R_1 is 1 iff S_1=0 and R_2=0.\n    # R_2 is 1 iff S_2=0 and R_3=0.\n    # ...\n    # R_k is 1 iff S_k=0 and S_{k+1}=0 and ... and S_{N+M}=0, AND N+M-k+1 is even and >= 2.\n    # This means the suffix S_k ... S_{N+M} must consist only of 0s, and its length must be even and >= 2.\n\n    # The final character R_1 is 1 if and only if:\n    # S_1 = 0 AND R_2 = 0.\n    # R_2 = 0 if (S_2=1 or R_3=1)\n    # This is not a simple condition.\n\n    # Let's use a dynamic programming approach for a fixed string.\n    # `dp[i]` is the value of the suffix `S[i:]`.\n    # `dp[len-1] = S[len-1]`\n    # `dp[i] = 1` if `S[i]=0` and `dp[i+1]=0`. Else `dp[i] = 0`.\n    # We want to count strings where `dp[0] = g`.\n\n    # `dp[i] = (1 - S[i]) * (1 - dp[i+1])`  (where 0 means 0, 1 means 1)\n    # (This is 1 if S[i]=0 and dp[i+1]=0. Otherwise 0.)\n\n    # Example: \"0101\" (n=2, m=2)\n    # S = [0,1,0,1]\n    # dp[3] = S[3] = 1\n    # dp[2] = (1 - S[2]) * (1 - dp[3]) = (1 - 0) * (1 - 1) = 1 * 0 = 0\n    # dp[1] = (1 - S[1]) * (1 - dp[2]) = (1 - 1) * (1 - 0) = 0 * 1 = 0\n    # dp[0] = (1 - S[0]) * (1 - dp[1]) = (1 - 0) * (1 - 0) = 1 * 1 = 1\n    # Result is 1. This matches my previous manual calculation for \"0101\".\n\n    # Example: \"0011\" (n=2, m=2)\n    # S = [0,0,1,1]\n    # dp[3] = S[3] = 1\n    # dp[2] = (1 - S[2]) * (1 - dp[3]) = (1 - 1) * (1 - 1) = 0 * 0 = 0\n    # dp[1] = (1 - S[1]) * (1 - dp[2]) = (1 - 0) * (1 - 0) = 1 * 1 = 1\n    # dp[0] = (1 - S[0]) * (1 - dp[1]) = (1 - 0) * (1 - 1) = 1 * 0 = 0\n    # Result is 0. This matches my previous manual calculation for \"0011\".\n\n    # So the recurrence `dp[i] = (1 - S[i]) * (1 - dp[i+1])` is correct.\n    # We want to count strings with `n` zeros and `m` ones such that `dp[0] = g`.\n\n    # Let's analyze `dp[i]`.\n    # `dp[k] = S[k]` if k = len-1.\n    # `dp[k] = 1` if `S[k]=0` and `dp[k+1]=0`.\n    # `dp[k] = 0` otherwise.\n\n    # `dp[i]` can be 1 only if `S[i]=0`.\n    # If `S[i]=1`, then `dp[i]=0`.\n    # If `S[i]=0`, then `dp[i]=1` if `dp[i+1]=0`, and `dp[i]=0` if `dp[i+1]=1`.\n    # This means `dp[i] = (1 - dp[i+1])` if `S[i]=0`.\n\n    # So, `dp[i]` value depends on `S[i]` and `dp[i+1]`.\n    # We are looking for `dp[0] = g`.\n\n    # Consider the state `(k, current_0s, current_1s, dp_val)`\n    # This is too complex.\n    # Let's analyze the pattern of `dp_val`.\n    # `dp[k]` depends on `S[k], S[k+1], ..., S[len-1]`.\n\n    # If `S[k]=1`, then `dp[k]=0`.\n    # If `S[k]=0`:\n    #   If `S[k+1]=1`, then `dp[k+1]=0`, so `dp[k]=1`.\n    #   If `S[k+1]=0`:\n    #     If `S[k+2]=1`, then `dp[k+2]=0`, so `dp[k+1]=1`, so `dp[k]=0`.\n    #     If `S[k+2]=0`:\n    #       If `S[k+3]=1`, then `dp[k+3]=0`, so `dp[k+2]=1`, so `dp[k+1]=0`, so `dp[k]=1`.\n    # This pattern shows that `dp[k]` depends on the first '1' encountered to its right.\n    # Let `j` be the index of the first '1' such that `j >= k`.\n    # If no '1' exists for `j >= k`, then `S[k...len-1]` are all 0s.\n    #   In this case, `dp[len-1]=0`. `dp[len-2]=1`. `dp[len-3]=0`. `dp[len-4]=1`.\n    #   `dp[k]` is 1 if `len-1-k` is odd (i.e., `len-k` is even).\n    #   `dp[k]` is 0 if `len-1-k` is even (i.e., `len-k` is odd).\n    #   This applies if `len-k >= 1`.\n    #   So if `S[k...len-1]` are all 0s: `dp[k] = 1` if `(len-k)` is even and `len-k >= 2`.\n    #   `dp[k] = 0` if `(len-k)` is odd and `len-k >= 1`.\n\n    # If a '1' exists at index `j` (`j >= k`) and `S[j]=1` and `S[k...j-1]` are all 0s.\n    # Then `dp[j]=0`.\n    # `dp[j-1] = (1 - S[j-1]) * (1 - dp[j]) = (1 - 0) * (1 - 0) = 1`.\n    # `dp[j-2] = (1 - S[j-2]) * (1 - dp[j-1]) = (1 - 0) * (1 - 1) = 0`.\n    # `dp[j-3] = (1 - S[j-3]) * (1 - dp[j-2]) = (1 - 0) * (1 - 0) = 1`.\n    # `dp[j-4] = (1 - S[j-4]) * (1 - dp[j-3]) = (1 - 0) * (1 - 1) = 0`.\n    # So `dp[k]` is 1 if `j-k` is odd.\n    # `dp[k]` is 0 if `j-k` is even.\n    # This holds for `k < j`.\n    # If `k=j`, then `S[k]=1`, so `dp[k]=0`.\n\n    # Combining these:\n    # Let `L = n+m` be the total length.\n    # We want `dp[0] = g`.\n\n    # Case 1: `m = 0` (string consists of only 0s).\n    #   String is \"00...0\" (n times).\n    #   If `n=0`, this case is handled (n+m >= 1).\n    #   If `n=1`, \"0\". `dp[0]=0`.\n    #   If `n` is even and `n>=2`, `dp[0]=1`.\n    #   If `n` is odd and `n>=3`, `dp[0]=0`.\n    #   So if `g=0`: ans is 1 if `n` is odd. Else 0. (For n=1, output 1. For n=3, output 1. For n=2, output 0. For n=4, output 0).\n    #   So if `g=1`: ans is 1 if `n` is even and `n>=2`. Else 0. (For n=2, output 1. For n=4, output 1. For n=1, output 0).\n    #   This is: `g = 1` iff `n` is even and `n >= 2`.\n    #   If `g=0`: `n` is odd OR `n=0` (not possible here) OR `n` is even and `n=0` (not possible here).\n    #   So `g=0` iff `n` is odd.\n    #   This matches the base cases I derived earlier.\n    if m == 0:\n        if n == 1:\n            print(1 if g == 0 else 0)\n        elif n % 2 == 0: # n is even, n >= 2\n            print(1 if g == 1 else 0)\n        else: # n is odd, n >= 3\n            print(1 if g == 0 else 0)\n        return\n\n    # Case 2: `m = 1` (string contains exactly one '1').\n    #   Let the '1' be at index `j`. String is `0...0` (j times) + `1` + `0...0` (n-j times).\n    #   `S[j]=1`, so `dp[j]=0`.\n    #   For `k < j`, `S[k...j-1]` are all 0s.\n    #   `dp[k]` is 1 if `j-k` is odd.\n    #   `dp[k]` is 0 if `j-k` is even.\n    #   We are interested in `dp[0]`.\n    #   `dp[0]` is 1 if `j-0 = j` is odd.\n    #   `dp[0]` is 0 if `j-0 = j` is even.\n    #   So `dp[0] = 1` if the '1' is at an odd index `j`.\n    #   `dp[0] = 0` if the '1' is at an even index `j`.\n    #   (Indices are 0-based).\n    #   The position of the '1' can be from `0` to `n`. (m=1, so total length is n+1).\n    #   If '1' is at index `j`, there are `j` zeros before it.\n    #   The string is `0...0` (j zeros) `1` `0...0` (n-j zeros).\n    #   The '1' is at index `j`.\n    #   We need to count how many such strings have `dp[0]=g`.\n    #   If `g=1`: we need `j` to be odd. The '1' can be at index `1, 3, 5, ...`.\n    #     The number of zeros before the '1' is `j`.\n    #     So `j` must be odd.\n    #     Possible values for `j`: `1, 3, ..., up to n` (if '1' is at index `n`, there are `n` zeros before it).\n    #     Number of ways to place the '1' such that `j` is odd: `ceil(n/2)`.\n    #     If `n=0`, string is \"1\". `dp[0]=1`. Here `j=0`. This is an edge case. `j=0` is even, but `dp[0]=1`.\n    #     My `dp[j]=0` logic for `S[j]=1` holds. `dp[0]` is 1 if `j` is odd, 0 if `j` is even, provided `j > 0`.\n    #     If `j=0` (string is `10...0`): `S[0]=1`, so `dp[0]=0`.\n    #     This is wrong.\n    #     If the string is \"1\", `dp[0]=1`.\n    #     If the string is \"10\", `dp[1]=0`, `dp[0]=(1-S[0])*(1-dp[1]) = (1-1)*(1-0) = 0`.\n    #     If the string is \"100\", `dp[2]=0`, `dp[1]=1`, `dp[0]=0`.\n    #     So if `S[0]=1`, then `dp[0]=1` only if `n=0`. (string is just \"1\").\n    #     Otherwise, if `S[0]=1` and `n > 0`, then `dp[0]=0`.\n\n    # Let's consider `dp[0] = g`.\n    # If `S[0]=1`:\n    #   `dp[0]=0` unless `n=0` (i.e. string is \"1\").\n    #   If `n=0` and `m=1`, string is \"1\". `dp[0]=1`.\n    #   So if `g=1`, count this one string.\n    #   If `n>0` and `S[0]=1`, `dp[0]=0`.\n    # If `S[0]=0`:\n    #   `dp[0] = (1 - dp[1])`.\n    #   So `dp[0]=1` if `dp[1]=0`.\n    #   `dp[0]=0` if `dp[1]=1`.\n\n    # Let `count_g[k][val]` be the number of ways to choose `k` characters (0s or 1s) such that `dp[0]=val`.\n    # This is not a good DP state.\n\n    # Let's re-examine the property of `dp[0]`.\n    # `dp[0]` is 1 if and only if:\n    # `S[0]=0` AND `dp[1]=0`.\n    # `dp[1]` is 1 if and only if:\n    # `S[1]=0` AND `dp[2]=0`.\n    # So `dp[0]=1` if `S[0]=0` AND (`S[1]=1` OR `dp[2]=1`).\n    # `dp[0]=1` if `S[0]=0` AND (`S[1]=1` OR (`S[2]=0` AND `dp[3]=0`)).\n    # This is an alternating pattern.\n\n    # `dp[i]` is 1 iff `S[i]=0` and `dp[i+1]=0`.\n    # `dp[i]` is 0 iff `S[i]=1` or `dp[i+1]=1`.\n\n    # This means `dp[i]` is 1 iff `S[i]=0` AND (`S[i+1]=1` OR `S[i+1]=0` AND `dp[i+2]=1`).\n    # No, this is incorrect.\n    # `dp[i] = 1` iff `S[i]=0` AND `dp[i+1]=0`.\n    # `dp[i+1]=0` iff `S[i+1]=1` OR `dp[i+2]=1`.\n    # So `dp[i]=1` iff `S[i]=0` AND (`S[i+1]=1` OR `dp[i+2]=1`).\n    # This `dp[i+2]=1` is the key.\n\n    # `dp[i]=1` iff `S[i]=0` and `dp[i+1]=0`.\n    # `dp[i]=0` iff `S[i]=1` or `dp[i+1]=1`.\n\n    # Let's determine `dp[0]` based on the first '1' in the string.\n    # Let `j` be the index of the first '1' in the string `S`.\n    # If no '1' exists (m=0):\n    #   `dp[0]=1` if `n` is even and `n>=2`.\n    #   `dp[0]=0` if `n` is odd and `n>=1`.\n    #   This is handled.\n\n    # If `m >= 1`:\n    #   If `S[0]=1` (i.e. `j=0`):\n    #     `dp[0]=0` unless `n=0` and `m=1` (string \"1\").\n    #     If `n=0, m=1`, `dp[0]=1`.\n    #     Otherwise, `dp[0]=0`.\n    #   If `S[0]=0` (i.e. `j > 0`):\n    #     `dp[0] = (1 - dp[1])`.\n    #     `dp[1]` is 1 iff `S[1]=0` and `dp[2]=0`.\n    #     `dp[1]` is 0 iff `S[1]=1` or `dp[2]=1`.\n    #     If `S[1]=1`, then `dp[1]=0`. Then `dp[0]=1`.\n    #     If `S[1]=0`:\n    #       `dp[1] = (1 - dp[2])`.\n    #       `dp[0] = (1 - (1 - dp[2])) = dp[2]`.\n    #     This means `dp[0] = dp[k]` if `S[0...k-1]` are all 0s.\n    #     So if `S[0...j-1]` are all 0s, and `S[j]=1`.\n    #     Then `dp[0] = dp[j]` if `j` is even.\n    #     `dp[0] = (1 - dp[j])` if `j` is odd.\n    #     Since `S[j]=1`, `dp[j]=0`.\n    #     So if `j` is even, `dp[0]=0`.\n    #     If `j` is odd, `dp[0]=(1-0)=1`.\n    #     This applies for `j > 0`.\n\n    # So, for `m >= 1`:\n    #   If `n=0, m=1` (string \"1\"): `dp[0]=1`.\n    #   If `n=0, m>1` (string \"1...1\"): `S[0]=1`, so `dp[0]=0`.\n    #   If `n>0`:\n    #     If `S[0]=1` (first char is '1'): `dp[0]=0`.\n    #     If `S[0]=0` (first char is '0'):\n    #       Let `j` be the index of the first '1'. (`j` is the number of leading zeros).\n    #       If `j` is odd, `dp[0]=1`.\n    #       If `j` is even, `dp[0]=0`.\n    #       (This covers `j > 0`).\n\n    # This means the final value `g` depends on the number of leading zeros `j`.\n    # If `S[0]=1` (string starts with '1'): `dp[0]=0`.\n    #   Exception: `n=0, m=1` (string \"1\"), `dp[0]=1`.\n    # If `S[0]=0` (string starts with '0'): `dp[0]=1` if `j` is odd. `dp[0]=0` if `j` is even.\n\n    # Let's count the strings:\n    total_ways = nCr_mod_p(n + m, n)\n\n    if g == 1:\n        # We want `dp[0]=1`.\n        ans = 0\n        # Case 1: n=0, m=1 (string \"1\").\n        if n == 0 and m == 1:\n            ans = (ans + 1) % MOD\n        # Case 2: n>=1, m>=1. String starts with '0'.\n        # We need `j` (number of leading zeros) to be odd.\n        # `j` can be `1, 3, 5, ...`\n        # Max `j` is `n`.\n        # For each odd `j` from `1` to `n`:\n        #   The string looks like `0...0` (j times) `1` `...`\n        #   We have used `j` zeros and `1` one.\n        #   Remaining: `n-j` zeros, `m-1` ones.\n        #   These `n-j + m-1` characters can be arranged in `nCr_mod_p(n-j + m-1, n-j)` ways.\n        #   Sum this for `j = 1, 3, 5, ...` up to `n`.\n        if n >= 1 and m >= 1:\n            for j in range(1, n + 1, 2): # j is odd\n                ans = (ans + nCr_mod_p(n - j + m - 1, n - j)) % MOD\n        print(ans)\n\n    else: # g == 0\n        # We want `dp[0]=0`.\n        ans = 0\n        # Case 1: n=0, m=1 (string \"1\"). This gives `dp[0]=1`. So this does not contribute to `g=0`.\n        # Case 2: n=0, m>1 (string \"1...1\"). `dp[0]=0`. There is 1 such string.\n        if n == 0 and m > 1:\n            ans = (ans + 1) % MOD\n        # Case 3: n>=1, m>=1. String starts with '1'.\n        #   There are `nCr_mod_p(n + m - 1, n)` strings that start with '1'.\n        #   All these result in `dp[0]=0`.\n        if n >= 1 and m >= 1:\n            ans = (ans + nCr_mod_p(n + m - 1, n)) % MOD\n        # Case 4: n>=1, m>=1. String starts with '0'.\n        #   We need `j` (number of leading zeros) to be even.\n        #   `j` can be `0, 2, 4, ...`\n        #   `j=0` is not possible if string starts with '0'. So `j` starts from 2.\n        #   Max `j` is `n`.\n        #   For each even `j` from `2` to `n`:\n        #     Remaining: `n-j` zeros, `m-1` ones.\n        #     These `n-j + m-1` characters can be arranged in `nCr_mod_p(n-j + m-1, n-j)` ways.\n        #     Sum this for `j = 2, 4, 6, ...` up to `n`.\n        if n >= 1 and m >= 1:\n            for j in range(2, n + 1, 2): # j is even\n                ans = (ans + nCr_mod_p(n - j + m - 1, n - j)) % MOD\n        print(ans)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\nMOD = 1000000007\n\ndef solve():\n    n, m, g = map(int, sys.stdin.readline().split())\n\n    if n == 0 and m == 0:\n        print(0)\n        return\n\n    fact = [1] * (n + m + 1)\n    inv_fact = [1] * (n + m + 1)\n\n    for i in range(1, n + m + 1):\n        fact[i] = (fact[i - 1] * i) % MOD\n\n    inv_fact[n + m] = pow(fact[n + m], MOD - 2, MOD)\n    for i in range(n + m - 1, -1, -1):\n        inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD\n\n    def nCr_mod_p(n_val, r_val):\n        if r_val < 0 or r_val > n_val:\n            return 0\n        num = fact[n_val]\n        den = (inv_fact[r_val] * inv_fact[n_val - r_val]) % MOD\n        return (num * den) % MOD\n\n    if n == 0:\n        if m == 1:\n            if g == 1:\n                print(1)\n            else:\n                print(0)\n        else: # m > 1\n            if g == 0:\n                print(1)\n            else:\n                print(0)\n        return\n\n    if m == 0:\n        if g == 0:\n            print(1)\n        else:\n            print(0)\n        return\n\n    ans = 0\n    if g == 0:\n        # Case 1: The final character is 0\n        # This happens if the number of 1s in the sequence of results is even.\n        # Or, if the final character is 0 from a sequence of only 0s.\n        \n        # If the number of 1s in the original string (m) is even,\n        # then the final character from 1s is 0.\n        # If m is odd, the final character from 1s is 1.\n\n        # If m is even, the final character from 1s is 0.\n        # We need to combine this 0 with n 0s. The result is always 0.\n        # So, if m is even, the result is always 0.\n        if m % 2 == 0:\n            ans = nCr_mod_p(n + m, n)\n        else: # m is odd\n            # The final character from 1s is 1.\n            # We need to combine this 1 with n 0s.\n            # The result of combining 1 with a 0 is always 0.\n            # So, the final character will be 0 if n >= 1.\n            # If n=0, this case is handled above.\n            ans = nCr_mod_p(n + m, n)\n\n    else: # g == 1\n        # Case 2: The final character is 1\n        # This happens if the number of 1s in the sequence of results is odd.\n        \n        # If m is even, the final character from 1s is 0.\n        # We combine this 0 with n 0s. The result is always 0.\n        # So, if m is even, the result cannot be 1.\n        if m % 2 == 0:\n            ans = 0\n        else: # m is odd\n            # The final character from 1s is 1.\n            # We need to combine this 1 with n 0s.\n            # The result of combining 1 with a 0 is always 0.\n            # However, if n=0, then the result is just 1.\n            # If n >= 1, the result is 0.\n            if n == 0: # This case is handled above\n                # m is odd, n=0. The string is all 1s.\n                # If m=1, result is 1.\n                # If m>1, result is 0.\n                # This is already handled by the m=0 case.\n                pass\n            else: # n >= 1\n                ans = 0\n\n    # The logic above for g=0, m even and g=0, m odd seems to be incorrect.\n    # Let's re-evaluate the parity of the final character.\n    # The final character is 1 if and only if the number of 1s in the string\n    # (after processing all 0s) is odd.\n    # The operation: replace two last characters by one.\n    # 0,0 -> 1\n    # 0,1 -> 0\n    # 1,0 -> 0\n    # 1,1 -> 0\n\n    # Let's consider the parity of the number of 1s in the string.\n    # (x, y) -> z\n    # If x, y are 0, 0 -> z is 1. (parity changes)\n    # If x, y are 0, 1 -> z is 0. (parity changes)\n    # If x, y are 1, 0 -> z is 0. (parity changes)\n    # If x, y are 1, 1 -> z is 0. (parity changes)\n\n    # This is not about parity of 1s. This is about the final character.\n    # The value of the last character of the reduced string depends on the parity of the number of 0s that are processed with 1s.\n    # If we have a sequence of only 0s, say '00...0' (k times).\n    # '00' -> '1'\n    # '000' -> '01' -> '0'\n    # '0000' -> '001' -> '01' -> '0'\n    # '00000' -> '0001' -> '000' -> '01' -> '0'\n    # The result of k 0s is 1 if k=2. Otherwise it's 0 if k>=1.\n    # This is wrong.\n    # '0' -> '0'\n    # '00' -> '1'\n    # '000' -> '01' -> '0'\n    # '0000' -> '001' -> '01' -> '0'\n    # The result of k 0s is 1 if k is even and k >= 2.\n    # The result of k 0s is 0 if k is odd and k >= 1.\n\n    # What about 1s?\n    # '1' -> '1'\n    # '11' -> '0'\n    # '111' -> '10' -> '0'\n    # '1111' -> '110' -> '10' -> '0'\n    # The result of k 1s is 1 if k=1.\n    # The result of k 1s is 0 if k >= 2.\n\n    # Let's analyze the final character.\n    # The operation is (a, b) -> (a XOR b) XOR 1.\n    # Example: 0,0 -> (0 XOR 0) XOR 1 = 1\n    #          0,1 -> (0 XOR 1) XOR 1 = 0\n    #          1,0 -> (1 XOR 0) XOR 1 = 0\n    #          1,1 -> (1 XOR 1) XOR 1 = 1\n    # This is not what the problem states.\n    # The problem states: \"This character equals one if it replaces two zeros, otherwise it equals zero.\"\n    # (0,0) -> 1\n    # (0,1) -> 0\n    # (1,0) -> 0\n    # (1,1) -> 0\n\n    # Let's consider the final character value.\n    # The final character is 1 if and only if the last operation was (0,0) -> 1.\n    # This means the string before the last operation must have been '...00'.\n    # All other operations result in 0.\n\n    # Let's denote the value of the string S as val(S).\n    # val(S_prefix + '00') = val(S_prefix + '1')\n    # val(S_prefix + '01') = val(S_prefix + '0')\n    # val(S_prefix + '10') = val(S_prefix + '0')\n    # val(S_prefix + '11') = val(S_prefix + '0')\n\n    # This means, if there is any '1' in the original string,\n    # or if there is a '0' next to a '1' in the reduction,\n    # the final character will be 0, unless n=0 and m=1 (string \"1\").\n    # If the string contains at least one '1', and its length is > 1:\n    # If '...01' -> '...0'\n    # If '...10' -> '...0'\n    # If '...11' -> '...0'\n    # The only way to get a '1' is if the string is '00' or '1'.\n\n    # Let's trace the effect of 1s.\n    # Any '1' in the string will eventually interact with another character.\n    # If a '1' interacts with a '0' (01 or 10), the result is '0'.\n    # If a '1' interacts with a '1' (11), the result is '0'.\n    # So, if there is at least one '1' in the string, and it's not the only character,\n    # it seems to lead to a '0' result.\n    # The only exception is if the string is just \"1\" (n=0, m=1). In this case, the result is 1.\n\n    # What if n >= 2?\n    # If n >= 2, we can always form \"00\" somewhere.\n    # If we have \"00\", it can become \"1\".\n    # This \"1\" then interacts with other characters.\n    # This is getting complicated. Let's use the property of the final character.\n\n    # The final character is 1 if and only if the string can be reduced to \"1\".\n    # The string can be reduced to \"1\" in two ways:\n    # 1. The original string is \"1\" (n=0, m=1).\n    # 2. The string can be reduced to \"00\", which then becomes \"1\".\n\n    # When does a string reduce to \"00\"?\n    # A string of length L reduces to a single character.\n    # The value of this character depends on the *parity* of the number of '1's involved in '00' operations.\n    # This is a known problem: The final character is 1 if and only if the number of 1s in the string is 1, AND n=0.\n    # Or if n is even, and m=0.\n    # No, this is for (a,b) -> a XOR b.\n\n    # Let's consider the number of 1s.\n    # Let S be a string. Let N_0(S) be count of 0s, N_1(S) be count of 1s.\n    # If we replace two characters X, Y by Z:\n    # (0,0) -> 1: N_0 decreases by 2, N_1 increases by 1.\n    # (0,1) -> 0: N_0 decreases by 1, N_1 decreases by 1, N_0 increases by 1. (Net: N_1 decreases by 1)\n    # (1,0) -> 0: N_0 decreases by 1, N_1 decreases by 1, N_0 increases by 1. (Net: N_1 decreases by 1)\n    # (1,1) -> 0: N_1 decreases by 2, N_0 increases by 1.\n\n    # This is a parity argument.\n    # Let's look at the \"sum\" of characters modulo 2.\n    # For (0,0) -> 1: 0+0=0, result is 1. (sum changes parity)\n    # For (0,1) -> 0: 0+1=1, result is 0. (sum changes parity)\n    # For (1,0) -> 0: 1+0=1, result is 0. (sum changes parity)\n    # For (1,1) -> 0: 1+1=0, result is 0. (sum stays same parity)\n\n    # This is not a simple parity argument.\n    # The problem is equivalent to finding the value of a binary expression tree.\n    # Each leaf is 0 or 1. Each internal node is the \"modification\" operation.\n    # The final character is '1' if and only if the number of '1's in the string is 1 and n=0, OR if n is even and m=0.\n    # This is the standard problem.\n    # The operation is NOT (a XOR b) XOR 1.\n    # The operation is: f(x,y) = 1 if x=0, y=0. Else f(x,y) = 0.\n\n    # Let's denote the value of a string S as V(S).\n    # V(S_1 S_2 ... S_k) = V(S_1 S_2 ... V(S_{k-1} S_k))\n    # V(00) = 1\n    # V(01) = 0\n    # V(10) = 0\n    # V(11) = 0\n\n    # Consider the rightmost '1'. If it exists.\n    # If the string is S_prefix + '1' + S_suffix (where S_suffix contains only 0s).\n    # Example: '00100'.\n    # '00100' -> '0010' -> '000' -> '01' -> '0'\n    # Example: '0010'\n    # '0010' -> '000' -> '01' -> '0'\n    # Example: '001'\n    # '001' -> '00' -> '1'\n    # Example: '010'\n    # '010' -> '00' -> '1'\n    # Example: '100'\n    # '100' -> '10' -> '0'\n    # Example: '10' -> '0'\n    # Example: '11' -> '0'\n    # Example: '00' -> '1'\n    # Example: '0' -> '0'\n    # Example: '1' -> '1'\n\n    # Observations:\n    # 1. If m = 1 and n = 0, string is \"1\". Result is 1.\n    # 2. If n = 0 and m > 1, string is \"1...1\". Result is 0.\n    # 3. If m = 0 and n = 1, string is \"0\". Result is 0.\n    # 4. If m = 0 and n > 1:\n    #    \"00\" -> 1\n    #    \"000\" -> \"01\" -> 0\n    #    \"0000\" -> \"001\" -> \"01\" -> 0\n    #    \"00000\" -> \"0001\" -> \"000\" -> \"01\" -> 0\n    #    The result of N 0s is 1 if N=2. Otherwise it's 0 if N >= 1.\n    #    This is incorrect based on the example. \"0000\" -> \"001\" (replace last two 0s with 1).\n    #    Then \"001\" -> \"00\" (replace 01 with 0). Then \"00\" -> \"1\".\n    #    So, \"0000\" -> \"1\".\n    #    Let's re-evaluate:\n    #    V(0) = 0\n    #    V(00) = 1\n    #    V(000) = V(0(00)) = V(01) = 0\n    #    V(0000) = V(00(00)) = V(001) = V(00) = 1 (since 01->0)\n    #    V(00000) = V(000(00)) = V(0001) = V(000) = 0 (since 01->0)\n    #    So, for N 0s: V(N 0s) = 1 if N is even and N >= 2.\n    #    V(N 0s) = 0 if N is odd and N >= 1.\n\n    # Summary of base cases:\n    # - n=0, m=1 (\"1\"): result is 1.\n    # - n=0, m>1 (\"1...1\"): result is 0.\n    # - m=0, n=1 (\"0\"): result is 0.\n    # - m=0, n even, n>=2 (\"0...0\"): result is 1.\n    # - m=0, n odd, n>=3 (\"0...0\"): result is 0.\n\n    # Now consider n >= 1 and m >= 1.\n    # This means there's at least one '0' and at least one '1'.\n    # The key is that any '1' interacting with a '0' or another '1' results in a '0'.\n    # V(01) = 0\n    # V(10) = 0\n    # V(11) = 0\n    # This implies that if we ever form a '0' from a '1' (by any of the above operations),\n    # then this '0' will propagate.\n    # The only way to get a '1' is from '00'.\n\n    # Let's consider the final character g.\n    # If g = 1:\n    #   The string must reduce to \"1\".\n    #   This happens if the string is \"1\" (n=0, m=1) or if it reduces to \"00\".\n    #   Can a string with n>=1, m>=1 reduce to \"00\"?\n    #   Example: \"010\" -> \"00\" -> \"1\". (n=2, m=1, g=1)\n    #   Example: \"100\" -> \"10\" -> \"0\". (n=2, m=1, g=0)\n    #   Example: \"001\" -> \"00\" -> \"1\". (n=2, m=1, g=1)\n    #   Example: \"011\" -> \"00\" -> \"1\". (n=1, m=2, g=1)\n    #   Example: \"101\" -> \"10\" -> \"0\". (n=1, m=2, g=0)\n    #   Example: \"110\" -> \"10\" -> \"0\". (n=1, m=2, g=0)\n\n    # It seems that if the string contains a '1', and it's not the only character,\n    # the value of the string is 1 if and only if the number of 0s to the left of the rightmost 1\n    # is even, AND the number of 1s (including the rightmost 1) is odd.\n    # This is not a good approach.\n\n    # Let's consider the parity of the number of 0s.\n    # If we have a string S.\n    # If the last character is '1'.\n    # S = S' + '1'.\n    # V(S) = V(S' + '1').\n    # If S' ends with '0': V(S' + '01') = V(S' + '0')\n    # If S' ends with '1': V(S' + '11') = V(S' + '0')\n\n    # If the last character is '0'.\n    # S = S' + '0'.\n    # V(S) = V(S' + '0').\n    # If S' ends with '0': V(S' + '00') = V(S' + '1')\n    # If S' ends with '1': V(S' + '10') = V(S' + '0')\n\n    # This means the last character of the reduced string is 1 if and only if\n    # the last operation was (0,0) -> 1.\n    # This means the string before the last operation was (something) + \"00\".\n    # This means the final character is 1 iff the final string is \"00\".\n    # This means the total number of characters (n+m) must be at least 2.\n\n    # The final character is 1 if and only if:\n    # (n=0, m=1) OR\n    # (n=2, m=0) OR\n    # (n=1, m=1, string is \"01\" or \"10\" -> V(\"01\")=0, V(\"10\")=0)\n    # Wait, example 1: n=1, m=1, g=0. Output 2. Strings \"01\", \"10\".\n    # V(\"01\") = 0. V(\"10\") = 0. So for n=1, m=1, g=0, answer is 2.\n    # For n=1, m=1, g=1, answer is 0. This implies my analysis of \"01\" and \"10\" is correct.\n\n    # Example 2: n=2, m=2, g=0. Output 4.\n    # Strings: \"0011\", \"1001\", \"1010\", \"1100\"\n    # V(\"0011\") = V(\"000\") = V(\"01\") = 0\n    # V(\"1001\") = V(\"100\") = V(\"10\") = 0\n    # V(\"1010\") = V(\"100\") = V(\"10\") = 0\n    # V(\"1100\") = V(\"110\") = V(\"10\") = 0\n    # All these are 0. So for n=2, m=2, g=0, answer is nCr(4,2) = 6. But example says 4.\n    # What strings are missing? \"0101\", \"0110\".\n    # V(\"0101\") = V(\"010\") = V(\"00\") = 1.\n    # V(\"0110\") = V(\"00\") = 1.\n    # So, for n=2, m=2:\n    # V(\"0011\")=0\n    # V(\"0101\")=1\n    # V(\"0110\")=1\n    # V(\"1001\")=0\n    # V(\"1010\")=0\n    # V(\"1100\")=0\n    # Total strings: nCr(4,2) = 6.\n    # Strings that result in 0: 4.\n    # Strings that result in 1: 2.\n    # So if g=0, answer is 4. If g=1, answer is 2.\n    # The example output for n=2, m=2, g=0 is 4. This matches.\n\n    # My understanding of the operation is correct now.\n    # V(S_1 S_2 ... S_k) = V(S_1 S_2 ... V(S_{k-1} S_k))\n    # V(X Y) = 1 if X=0, Y=0. Else 0.\n\n    # The final character is 1 if and only if:\n    # The string is \"1\" (n=0, m=1).\n    # OR, the string can be reduced to \"00\".\n    # A string can be reduced to \"00\" if:\n    # - It is \"00\".\n    # - It is \"0X0\" where V(X)=0. Example: \"010\" -> \"00\". V(\"1\")=1. So \"010\" -> V(\"0\"V(\"10\")) = V(\"00\") = 1.\n    # - It is \"X00\" where V(X)=0. Example: \"100\" -> V(\"10\") -> \"0\".\n    # - It is \"00X\" where V(X)=0. Example: \"001\" -> V(\"00\") -> \"1\".\n    # This is hard. Let's use the parity of the number of 1s in the string.\n    # The problem is that the operation changes 0s to 1s and vice versa.\n\n    # Let's consider the number of 0s and 1s.\n    # The final character is 1 iff the number of 0s is even and m=0, or n=0 and m=1.\n    # Otherwise, it is 0.\n    # This rule comes from a similar problem where (a,b) -> a XOR b.\n    # This is NOT a XOR b.\n    # (0,0) -> 1 (0 XOR 0 = 0)\n    # (0,1) -> 0 (0 XOR 1 = 1)\n    # (1,0) -> 0 (1 XOR 0 = 1)\n    # (1,1) -> 0 (1 XOR 1 = 0)\n\n    # Let's try to determine when the final character is 1.\n    # It is 1 iff:\n    # 1. The string is \"1\" (n=0, m=1).\n    # 2. The string is \"00\" (n=2, m=0).\n    # 3. The string is of the form S_1 S_2 ... S_k, and V(S_k-1 S_k) = 0.\n    #    And V(S_k-2 V(S_k-1 S_k)) = 0.\n    #    And so on, until the string reduces to \"00\".\n\n    # Let's define f(S) as the value of the string S.\n    # f(S_1 S_2 ... S_k) = f(S_1 ... S_{k-2} f(S_{k-1} S_k)).\n    # The final character is 1 if and only if the last operation performed was (0,0) -> 1.\n    # This means the string reduced to '00' at the last step.\n    # Let's denote the reduced value of a character 'c' as 'v(c)'.\n    # v(0) = 0, v(1) = 1.\n    # The string is S_1 S_2 ... S_{N+M}.\n    # The final character is f(S_1, f(S_2, ..., f(S_{N+M-1}, S_{N+M})...)).\n    # Let R_k = f(S_k, f(S_{k+1}, ..., f(S_{N+M-1}, S_{N+M})...)).\n    # R_{N+M} = S_{N+M}\n    # R_k = f(S_k, R_{k+1}).\n    # The final result is R_1.\n\n    # R_k is 1 iff S_k=0 and R_{k+1}=0. Otherwise R_k is 0.\n    # So R_1 is 1 iff S_1=0 and R_2=0.\n    # R_2 is 1 iff S_2=0 and R_3=0.\n    # ...\n    # R_k is 1 iff S_k=0 and S_{k+1}=0 and ... and S_{N+M}=0, AND N+M-k+1 is even and >= 2.\n    # This means the suffix S_k ... S_{N+M} must consist only of 0s, and its length must be even and >= 2.\n\n    # The final character R_1 is 1 if and only if:\n    # S_1 = 0 AND R_2 = 0.\n    # R_2 = 0 if (S_2=1 or R_3=1)\n    # This is not a simple condition.\n\n    # Let's use a dynamic programming approach for a fixed string.\n    # `dp[i]` is the value of the suffix `S[i:]`.\n    # `dp[len-1] = S[len-1]`\n    # `dp[i] = 1` if `S[i]=0` and `dp[i+1]=0`. Else `dp[i] = 0`.\n    # We want to count strings where `dp[0] = g`.\n\n    # `dp[i] = (1 - S[i]) * (1 - dp[i+1])`  (where 0 means 0, 1 means 1)\n    # (This is 1 if S[i]=0 and dp[i+1]=0. Otherwise 0.)\n\n    # Example: \"0101\" (n=2, m=2)\n    # S = [0,1,0,1]\n    # dp[3] = S[3] = 1\n    # dp[2] = (1 - S[2]) * (1 - dp[3]) = (1 - 0) * (1 - 1) = 1 * 0 = 0\n    # dp[1] = (1 - S[1]) * (1 - dp[2]) = (1 - 1) * (1 - 0) = 0 * 1 = 0\n    # dp[0] = (1 - S[0]) * (1 - dp[1]) = (1 - 0) * (1 - 0) = 1 * 1 = 1\n    # Result is 1. This matches my previous manual calculation for \"0101\".\n\n    # Example: \"0011\" (n=2, m=2)\n    # S = [0,0,1,1]\n    # dp[3] = S[3] = 1\n    # dp[2] = (1 - S[2]) * (1 - dp[3]) = (1 - 1) * (1 - 1) = 0 * 0 = 0\n    # dp[1] = (1 - S[1]) * (1 - dp[2]) = (1 - 0) * (1 - 0) = 1 * 1 = 1\n    # dp[0] = (1 - S[0]) * (1 - dp[1]) = (1 - 0) * (1 - 1) = 1 * 0 = 0\n    # Result is 0. This matches my previous manual calculation for \"0011\".\n\n    # So the recurrence `dp[i] = (1 - S[i]) * (1 - dp[i+1])` is correct.\n    # We want to count strings with `n` zeros and `m` ones such that `dp[0] = g`.\n\n    # Let's analyze `dp[i]`.\n    # `dp[k] = S[k]` if k = len-1.\n    # `dp[k] = 1` if `S[k]=0` and `dp[k+1]=0`.\n    # `dp[k] = 0` otherwise.\n\n    # `dp[i]` can be 1 only if `S[i]=0`.\n    # If `S[i]=1`, then `dp[i]=0`.\n    # If `S[i]=0`, then `dp[i]=1` if `dp[i+1]=0`, and `dp[i]=0` if `dp[i+1]=1`.\n    # This means `dp[i] = (1 - dp[i+1])` if `S[i]=0`.\n\n    # So, `dp[i]` value depends on `S[i]` and `dp[i+1]`.\n    # We are looking for `dp[0] = g`.\n\n    # Consider the state `(k, current_0s, current_1s, dp_val)`\n    # This is too complex.\n    # Let's analyze the pattern of `dp_val`.\n    # `dp[k]` depends on `S[k], S[k+1], ..., S[len-1]`.\n\n    # If `S[k]=1`, then `dp[k]=0`.\n    # If `S[k]=0`:\n    #   If `S[k+1]=1`, then `dp[k+1]=0`, so `dp[k]=1`.\n    #   If `S[k+1]=0`:\n    #     If `S[k+2]=1`, then `dp[k+2]=0`, so `dp[k+1]=1`, so `dp[k]=0`.\n    #     If `S[k+2]=0`:\n    #       If `S[k+3]=1`, then `dp[k+3]=0`, so `dp[k+2]=1`, so `dp[k+1]=0`, so `dp[k]=1`.\n    # This pattern shows that `dp[k]` depends on the first '1' encountered to its right.\n    # Let `j` be the index of the first '1' such that `j >= k`.\n    # If no '1' exists for `j >= k`, then `S[k...len-1]` are all 0s.\n    #   In this case, `dp[len-1]=0`. `dp[len-2]=1`. `dp[len-3]=0`. `dp[len-4]=1`.\n    #   `dp[k]` is 1 if `len-1-k` is odd (i.e., `len-k` is even).\n    #   `dp[k]` is 0 if `len-1-k` is even (i.e., `len-k` is odd).\n    #   This applies if `len-k >= 1`.\n    #   So if `S[k...len-1]` are all 0s: `dp[k] = 1` if `(len-k)` is even and `len-k >= 2`.\n    #   `dp[k] = 0` if `(len-k)` is odd and `len-k >= 1`.\n\n    # If a '1' exists at index `j` (`j >= k`) and `S[j]=1` and `S[k...j-1]` are all 0s.\n    # Then `dp[j]=0`.\n    # `dp[j-1] = (1 - S[j-1]) * (1 - dp[j]) = (1 - 0) * (1 - 0) = 1`.\n    # `dp[j-2] = (1 - S[j-2]) * (1 - dp[j-1]) = (1 - 0) * (1 - 1) = 0`.\n    # `dp[j-3] = (1 - S[j-3]) * (1 - dp[j-2]) = (1 - 0) * (1 - 0) = 1`.\n    # `dp[j-4] = (1 - S[j-4]) * (1 - dp[j-3]) = (1 - 0) * (1 - 1) = 0`.\n    # So `dp[k]` is 1 if `j-k` is odd.\n    # `dp[k]` is 0 if `j-k` is even.\n    # This holds for `k < j`.\n    # If `k=j`, then `S[k]=1`, so `dp[k]=0`.\n\n    # Combining these:\n    # Let `L = n+m` be the total length.\n    # We want `dp[0] = g`.\n\n    # Case 1: `m = 0` (string consists of only 0s).\n    #   String is \"00...0\" (n times).\n    #   If `n=0`, this case is handled (n+m >= 1).\n    #   If `n=1`, \"0\". `dp[0]=0`.\n    #   If `n` is even and `n>=2`, `dp[0]=1`.\n    #   If `n` is odd and `n>=3`, `dp[0]=0`.\n    #   So if `g=0`: ans is 1 if `n` is odd. Else 0. (For n=1, output 1. For n=3, output 1. For n=2, output 0. For n=4, output 0).\n    #   So if `g=1`: ans is 1 if `n` is even and `n>=2`. Else 0. (For n=2, output 1. For n=4, output 1. For n=1, output 0).\n    #   This is: `g = 1` iff `n` is even and `n >= 2`.\n    #   If `g=0`: `n` is odd OR `n=0` (not possible here) OR `n` is even and `n=0` (not possible here).\n    #   So `g=0` iff `n` is odd.\n    #   This matches the base cases I derived earlier.\n    if m == 0:\n        if n == 1:\n            print(1 if g == 0 else 0)\n        elif n % 2 == 0: # n is even, n >= 2\n            print(1 if g == 1 else 0)\n        else: # n is odd, n >= 3\n            print(1 if g == 0 else 0)\n        return\n\n    # Case 2: `m = 1` (string contains exactly one '1').\n    #   Let the '1' be at index `j`. String is `0...0` (j times) + `1` + `0...0` (n-j times).\n    #   `S[j]=1`, so `dp[j]=0`.\n    #   For `k < j`, `S[k...j-1]` are all 0s.\n    #   `dp[k]` is 1 if `j-k` is odd.\n    #   `dp[k]` is 0 if `j-k` is even.\n    #   We are interested in `dp[0]`.\n    #   `dp[0]` is 1 if `j-0 = j` is odd.\n    #   `dp[0]` is 0 if `j-0 = j` is even.\n    #   So `dp[0] = 1` if the '1' is at an odd index `j`.\n    #   `dp[0] = 0` if the '1' is at an even index `j`.\n    #   (Indices are 0-based).\n    #   The position of the '1' can be from `0` to `n`. (m=1, so total length is n+1).\n    #   If '1' is at index `j`, there are `j` zeros before it.\n    #   The string is `0...0` (j zeros) `1` `0...0` (n-j zeros).\n    #   The '1' is at index `j`.\n    #   We need to count how many such strings have `dp[0]=g`.\n    #   If `g=1`: we need `j` to be odd. The '1' can be at index `1, 3, 5, ...`.\n    #     The number of zeros before the '1' is `j`.\n    #     So `j` must be odd.\n    #     Possible values for `j`: `1, 3, ..., up to n` (if '1' is at index `n`, there are `n` zeros before it).\n    #     Number of ways to place the '1' such that `j` is odd: `ceil(n/2)`.\n    #     If `n=0`, string is \"1\". `dp[0]=1`. Here `j=0`. This is an edge case. `j=0` is even, but `dp[0]=1`.\n    #     My `dp[j]=0` logic for `S[j]=1` holds. `dp[0]` is 1 if `j` is odd, 0 if `j` is even, provided `j > 0`.\n    #     If `j=0` (string is `10...0`): `S[0]=1`, so `dp[0]=0`.\n    #     This is wrong.\n    #     If the string is \"1\", `dp[0]=1`.\n    #     If the string is \"10\", `dp[1]=0`, `dp[0]=(1-S[0])*(1-dp[1]) = (1-1)*(1-0) = 0`.\n    #     If the string is \"100\", `dp[2]=0`, `dp[1]=1`, `dp[0]=0`.\n    #     So if `S[0]=1`, then `dp[0]=1` only if `n=0`. (string is just \"1\").\n    #     Otherwise, if `S[0]=1` and `n > 0`, then `dp[0]=0`.\n\n    # Let's consider `dp[0] = g`.\n    # If `S[0]=1`:\n    #   `dp[0]=0` unless `n=0` (i.e. string is \"1\").\n    #   If `n=0` and `m=1`, string is \"1\". `dp[0]=1`.\n    #   So if `g=1`, count this one string.\n    #   If `n>0` and `S[0]=1`, `dp[0]=0`.\n    # If `S[0]=0`:\n    #   `dp[0] = (1 - dp[1])`.\n    #   So `dp[0]=1` if `dp[1]=0`.\n    #   `dp[0]=0` if `dp[1]=1`.\n\n    # Let `count_g[k][val]` be the number of ways to choose `k` characters (0s or 1s) such that `dp[0]=val`.\n    # This is not a good DP state.\n\n    # Let's re-examine the property of `dp[0]`.\n    # `dp[0]` is 1 if and only if:\n    # `S[0]=0` AND `dp[1]=0`.\n    # `dp[1]` is 1 if and only if:\n    # `S[1]=0` AND `dp[2]=0`.\n    # So `dp[0]=1` if `S[0]=0` AND (`S[1]=1` OR `dp[2]=1`).\n    # `dp[0]=1` if `S[0]=0` AND (`S[1]=1` OR (`S[2]=0` AND `dp[3]=0`)).\n    # This is an alternating pattern.\n\n    # `dp[i]` is 1 iff `S[i]=0` and `dp[i+1]=0`.\n    # `dp[i]` is 0 iff `S[i]=1` or `dp[i+1]=1`.\n\n    # This means `dp[i]` is 1 iff `S[i]=0` AND (`S[i+1]=1` OR `S[i+1]=0` AND `dp[i+2]=1`).\n    # No, this is incorrect.\n    # `dp[i] = 1` iff `S[i]=0` AND `dp[i+1]=0`.\n    # `dp[i+1]=0` iff `S[i+1]=1` OR `dp[i+2]=1`.\n    # So `dp[i]=1` iff `S[i]=0` AND (`S[i+1]=1` OR `dp[i+2]=1`).\n    # This `dp[i+2]=1` is the key.\n\n    # `dp[i]=1` iff `S[i]=0` and `dp[i+1]=0`.\n    # `dp[i]=0` iff `S[i]=1` or `dp[i+1]=1`.\n\n    # Let's determine `dp[0]` based on the first '1' in the string.\n    # Let `j` be the index of the first '1' in the string `S`.\n    # If no '1' exists (m=0):\n    #   `dp[0]=1` if `n` is even and `n>=2`.\n    #   `dp[0]=0` if `n` is odd and `n>=1`.\n    #   This is handled.\n\n    # If `m >= 1`:\n    #   If `S[0]=1` (i.e. `j=0`):\n    #     `dp[0]=0` unless `n=0` and `m=1` (string \"1\").\n    #     If `n=0, m=1`, `dp[0]=1`.\n    #     Otherwise, `dp[0]=0`.\n    #   If `S[0]=0` (i.e. `j > 0`):\n    #     `dp[0] = (1 - dp[1])`.\n    #     `dp[1]` is 1 iff `S[1]=0` and `dp[2]=0`.\n    #     `dp[1]` is 0 iff `S[1]=1` or `dp[2]=1`.\n    #     If `S[1]=1`, then `dp[1]=0`. Then `dp[0]=1`.\n    #     If `S[1]=0`:\n    #       `dp[1] = (1 - dp[2])`.\n    #       `dp[0] = (1 - (1 - dp[2])) = dp[2]`.\n    #     This means `dp[0] = dp[k]` if `S[0...k-1]` are all 0s.\n    #     So if `S[0...j-1]` are all 0s, and `S[j]=1`.\n    #     Then `dp[0] = dp[j]` if `j` is even.\n    #     `dp[0] = (1 - dp[j])` if `j` is odd.\n    #     Since `S[j]=1`, `dp[j]=0`.\n    #     So if `j` is even, `dp[0]=0`.\n    #     If `j` is odd, `dp[0]=(1-0)=1`.\n    #     This applies for `j > 0`.\n\n    # So, for `m >= 1`:\n    #   If `n=0, m=1` (string \"1\"): `dp[0]=1`.\n    #   If `n=0, m>1` (string \"1...1\"): `S[0]=1`, so `dp[0]=0`.\n    #   If `n>0`:\n    #     If `S[0]=1` (first char is '1'): `dp[0]=0`.\n    #     If `S[0]=0` (first char is '0'):\n    #       Let `j` be the index of the first '1'. (`j` is the number of leading zeros).\n    #       If `j` is odd, `dp[0]=1`.\n    #       If `j` is even, `dp[0]=0`.\n    #       (This covers `j > 0`).\n\n    # This means the final value `g` depends on the number of leading zeros `j`.\n    # If `S[0]=1` (string starts with '1'): `dp[0]=0`.\n    #   Exception: `n=0, m=1` (string \"1\"), `dp[0]=1`.\n    # If `S[0]=0` (string starts with '0'): `dp[0]=1` if `j` is odd. `dp[0]=0` if `j` is even.\n\n    # Let's count the strings:\n    total_ways = nCr_mod_p(n + m, n)\n\n    if g == 1:\n        # We want `dp[0]=1`.\n        ans = 0\n        # Case 1: n=0, m=1 (string \"1\").\n        if n == 0 and m == 1:\n            ans = (ans + 1) % MOD\n        # Case 2: n>=1, m>=1. String starts with '0'.\n        # We need `j` (number of leading zeros) to be odd.\n        # `j` can be `1, 3, 5, ...`\n        # Max `j` is `n`.\n        # For each odd `j` from `1` to `n`:\n        #   The string looks like `0...0` (j times) `1` `...`\n        #   We have used `j` zeros and `1` one.\n        #   Remaining: `n-j` zeros, `m-1` ones.\n        #   These `n-j + m-1` characters can be arranged in `nCr_mod_p(n-j + m-1, n-j)` ways.\n        #   Sum this for `j = 1, 3, 5, ...` up to `n`.\n        if n >= 1 and m >= 1:\n            for j in range(1, n + 1, 2): # j is odd\n                ans = (ans + nCr_mod_p(n - j + m - 1, n - j)) % MOD\n        print(ans)\n\n    else: # g == 0\n        # We want `dp[0]=0`.\n        ans = 0\n        # Case 1: n=0, m=1 (string \"1\"). This gives `dp[0]=1`. So this does not contribute to `g=0`.\n        # Case 2: n=0, m>1 (string \"1...1\"). `dp[0]=0`. There is 1 such string.\n        if n == 0 and m > 1:\n            ans = (ans + 1) % MOD\n        # Case 3: n>=1, m>=1. String starts with '1'.\n        #   There are `nCr_mod_p(n + m - 1, n)` strings that start with '1'.\n        #   All these result in `dp[0]=0`.\n        if n >= 1 and m >= 1:\n            ans = (ans + nCr_mod_p(n + m - 1, n)) % MOD\n        # Case 4: n>=1, m>=1. String starts with '0'.\n        #   We need `j` (number of leading zeros) to be even.\n        #   `j` can be `0, 2, 4, ...`\n        #   `j=0` is not possible if string starts with '0'. So `j` starts from 2.\n        #   Max `j` is `n`.\n        #   For each even `j` from `2` to `n`:\n        #     Remaining: `n-j` zeros, `m-1` ones.\n        #     These `n-j + m-1` characters can be arranged in `nCr_mod_p(n-j + m-1, n-j)` ways.\n        #     Sum this for `j = 2, 4, 6, ...` up to `n`.\n        if n >= 1 and m >= 1:\n            for j in range(2, n + 1, 2): # j is even\n                ans = (ans + nCr_mod_p(n - j + m - 1, n - j)) % MOD\n        print(ans)\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 568,
        "completion_token_count": 12378,
        "thoughts_token_count": 0
    }
}