{
    "start": 1758284904.2098382,
    "end": 1758284926.7418952,
    "start-formatted": "2025-09-19 21:28 KST",
    "end-formatted": "2025-09-19 21:28 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "**Analyzing the Competitive Programming Problem**\n\nOkay, so I'm tackling this competitive programming problem. The goal is to figure out the fewest edges, *t*, needed to turn a given undirected graph into one containing a simple odd-length cycle, and then count the number of ways, *w*, to do it.  Essentially, I need to understand how to manipulate the graph to force this specific cycle.\n\nFirst, I need to break down the definition of a simple odd cycle: it's a closed path with an odd number of edges where each node is visited only once.  No loops, no repeated vertices, and the cycle has to have more than one vertex.\n\nNow, I've got a graph with *n* vertices and *m* edges. It's undirected, but could be disconnected, and I know there are no self-loops or multiple edges between the same two nodes.\n\nThe key insight, as usual, is to consider the properties of odd cycles in graphs. A fundamental theorem here states that a graph *contains* an odd cycle if and only if it's not bipartite. If the original graph already has an odd cycle, the answer is trivial. In that case, *t* would be 0 (no edges to add) and *w* would be 1 (because any existing odd cycle technically satisfies the problem).  Checking for an odd cycle becomes a simple matter of trying to 2-color the graph using BFS or DFS. If I hit a conflict – an edge connecting two vertices of the same color – I've got an odd cycle and I'm done.\n\nSo, this gives me the first case.\n\n**Case 0: Graph Already Has an Odd Cycle**\nIf I do a 2-coloring and hit a conflict, the graph isn't bipartite. The problem only needs *a* cycle, so the answer is *t* = 0 and *w* = 1 because adding zero edges has one way, add nothing.\n\n**Case 1: The Graph is Bipartite**\nIf the 2-coloring succeeds, the graph is bipartite. This is where things get interesting.  If the graph *is* bipartite, I definitely need to add at least one edge to create an odd cycle. Every edge already connects vertices of opposite colors. My mind races. If the graph is not bipartite, my code will fail quickly.\n\nTo form an odd cycle in a bipartite graph, the only option is to connect two vertices of the *same* color.  I'll perform the 2-coloring using BFS/DFS.  The graph might not be connected, so I need to iterate through any unvisited vertices and start a new BFS/DFS from each. Each connected component will be bipartite, so a 2-coloring will work.\n\nNow, if the graph is bipartite, I know *t* > 0 and I need to figure out the minimal value. How does one generate a valid solution? The smallest *t* seems to be just one.  To make an odd cycle, I need to add one edge connecting two vertices of the same color within the same connected component. \n\nSo it sounds like I'm close to a solution. I just need to figure out *how many* ways I can do that, once I've determined that *t* is one.\n",
    "response": "```python\nimport sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    adj = [[] for _ in range(n + 1)]\n    edges_list = []\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n        edges_list.append((u, v))\n\n    colors = [-1] * (n + 1)\n    visited = [False] * (n + 1)\n    \n    # Stores (count of color 0, count of color 1) for each bipartite component\n    component_color_counts = []\n    \n    # Stores (size of component, number of edges within component) for each component\n    # for t=2 consideration\n    component_stats = [] \n\n    has_odd_cycle = False\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            q = deque()\n            q.append(i)\n            visited[i] = True\n            colors[i] = 0\n            \n            current_component_nodes = 0\n            color_counts = [0, 0] # [count of color 0, count of color 1]\n            color_counts[0] = 1\n\n            component_edges = 0 # for t=2 calculation\n\n            q_idx = 0\n            component_q = [i] # Use a list for BFS-like traversal to count edges\n            \n            while q_idx < len(component_q):\n                u = component_q[q_idx]\n                q_idx += 1\n                current_component_nodes += 1\n\n                for v in adj[u]:\n                    component_edges += 1 # Count each edge twice initially\n                    if not visited[v]:\n                        visited[v] = True\n                        colors[v] = 1 - colors[u]\n                        color_counts[colors[v]] += 1\n                        component_q.append(v)\n                    elif colors[v] == colors[u]:\n                        has_odd_cycle = True\n                        # No need to continue BFS for this component if odd cycle found\n                        # The problem asks for *any* odd cycle, so we can stop coloring\n                        # and immediately report t=0, w=1.\n                        # However, for t=2, we need to know all component sizes, so let's\n                        # complete the BFS for this component even if an odd cycle is found.\n                        # But for t=0, we can just exit early.\n                        # Let's break early if we find an odd cycle.\n                        # If has_odd_cycle is True, we don't need to populate component_color_counts\n                        # or component_stats further.\n                        break\n                if has_odd_cycle:\n                    break\n            \n            if has_odd_cycle:\n                # If an odd cycle is found, we don't need to process other components for t=0.\n                # Just set t=0, w=1 and return.\n                # However, the problem implies finding _a_ cycle, so if any component has an odd cycle,\n                # t=0, w=1. We don't need to find all odd cycles.\n                print(0, 1)\n                return\n\n            component_color_counts.append(color_counts)\n            component_stats.append((current_component_nodes, component_edges // 2))\n\n    # If we reached here, the graph is bipartite.\n    # Case 1: t=1\n    # We need to add an edge (u, v) where u and v are in the same component and colors[u] == colors[v].\n    # The number of such pairs (u, v) is sum over all components of (count_color_0 * (count_color_0 - 1) / 2) + (count_color_1 * (count_color_1 - 1) / 2)\n    \n    t1_ways = 0\n    for c0, c1 in component_color_counts:\n        t1_ways += c0 * (c0 - 1) // 2\n        t1_ways += c1 * (c1 - 1) // 2\n    \n    if t1_ways > 0:\n        print(1, t1_ways)\n        return\n\n    # Case 2: t=2\n    # If t1_ways is 0, it means all components are paths or isolated vertices (trees).\n    # Specifically, each component has at most one vertex of each color, meaning it's just a single vertex.\n    # No, this is wrong. A component can be a tree with multiple vertices of same color, but no edge connects them.\n    # e.g., a path 0-1-0-1-0. It has 3 vertices of color 0 and 2 of color 1. t1_ways > 0 for this.\n    # t1_ways = 0 only if for every component, c0 <= 1 and c1 <= 1.\n    # This means each component is either a single vertex or an empty graph.\n    # This is not correct. t1_ways=0 means that for every component, c0*(c0-1)/2 = 0 AND c1*(c1-1)/2 = 0.\n    # This implies c0 < 2 AND c1 < 2 for all components.\n    # So each component has at most one vertex of color 0 and at most one vertex of color 1.\n    # This means each component has at most 2 vertices.\n    # If a component has 2 vertices, it must be an edge (u,v) where colors[u] != colors[v].\n    # If a component has 1 vertex, it's an isolated vertex.\n    # So if t1_ways = 0, all components are isolated vertices or single edges.\n\n    # We need to add two edges.\n    # Option A: Add two edges (u, v) and (v, w) such that u, v, w are distinct\n    # and form an odd cycle.\n    # This means we pick 3 distinct vertices.\n    # If we pick 3 vertices u, v, w, and add (u,v) and (v,w), we make a path u-v-w.\n    # If u, w are already connected, we have a cycle of length 3.\n    # The problem asks for minimum added edges.\n    # If t=2, we need to add two edges.\n    # If we add (u, v) and (x, y), where u,v,x,y are distinct and form a path u-G-x, y-G-v,\n    # and then add (u,y) and (v,x), this forms a cycle.\n    # This is too complex.\n    \n    # Consider paths of length 2: u - k - v.\n    # If we add edge (u, v), we get a cycle of length 3 (an odd cycle).\n    # This requires u, v not to be connected.\n    # How many such pairs (u, v) exist?\n    # For each vertex k, consider its neighbors. Let degree of k be deg(k).\n    # Any pair of neighbors (u, v) of k forms a path u-k-v.\n    # If we add edge (u, v), we form an odd cycle of length 3.\n    # Number of ways to choose 2 neighbors for a vertex k is deg(k) * (deg(k) - 1) / 2.\n    # Sum this over all k. This counts pairs {u, v} that are at distance 2.\n    # This is (number of paths of length 2) - (number of triangles).\n    \n    t2_ways = 0\n    for i in range(1, n + 1):\n        deg_i = len(adj[i])\n        t2_ways += deg_i * (deg_i - 1) // 2\n    \n    if t2_ways > 0:\n        print(2, t2_ways)\n        return\n\n    # Case 3: t=3\n    # If t1_ways = 0 and t2_ways = 0.\n    # t1_ways = 0 means all components have at most 2 vertices (isolated or single edge).\n    # t2_ways = 0 means all vertices have degree 0 or 1.\n    # So the graph consists only of isolated vertices and isolated edges.\n    # In this case, we need to add 3 edges to form a triangle (cycle of length 3).\n    # Pick 3 distinct vertices u, v, w. Add edges (u,v), (v,w), (w,u).\n    # Number of ways to choose 3 vertices from n is n * (n - 1) * (n - 2) / 6.\n    \n    # This is the only remaining case.\n    # The graph has no odd cycles (t=0 failed).\n    # The graph is bipartite.\n    # No way to add 1 edge (t=1 failed): all components have c0 < 2 and c1 < 2.\n    # No way to add 2 edges to form a triangle (t=2 failed): no vertex has degree >= 2.\n    # This means the graph is a collection of isolated vertices and isolated edges.\n    # To form an odd cycle (e.g., a triangle), we need to pick 3 vertices and add 3 edges.\n    \n    t3_ways = n * (n - 1) * (n - 2) // 6\n    print(3, t3_ways)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    adj = [[] for _ in range(n + 1)]\n    edges_list = []\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n        edges_list.append((u, v))\n\n    colors = [-1] * (n + 1)\n    visited = [False] * (n + 1)\n    \n    # Stores (count of color 0, count of color 1) for each bipartite component\n    component_color_counts = []\n    \n    # Stores (size of component, number of edges within component) for each component\n    # for t=2 consideration\n    component_stats = [] \n\n    has_odd_cycle = False\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            q = deque()\n            q.append(i)\n            visited[i] = True\n            colors[i] = 0\n            \n            current_component_nodes = 0\n            color_counts = [0, 0] # [count of color 0, count of color 1]\n            color_counts[0] = 1\n\n            component_edges = 0 # for t=2 calculation\n\n            q_idx = 0\n            component_q = [i] # Use a list for BFS-like traversal to count edges\n            \n            while q_idx < len(component_q):\n                u = component_q[q_idx]\n                q_idx += 1\n                current_component_nodes += 1\n\n                for v in adj[u]:\n                    component_edges += 1 # Count each edge twice initially\n                    if not visited[v]:\n                        visited[v] = True\n                        colors[v] = 1 - colors[u]\n                        color_counts[colors[v]] += 1\n                        component_q.append(v)\n                    elif colors[v] == colors[u]:\n                        has_odd_cycle = True\n                        # No need to continue BFS for this component if odd cycle found\n                        # The problem asks for *any* odd cycle, so we can stop coloring\n                        # and immediately report t=0, w=1.\n                        # However, for t=2, we need to know all component sizes, so let's\n                        # complete the BFS for this component even if an odd cycle is found.\n                        # But for t=0, we can just exit early.\n                        # Let's break early if we find an odd cycle.\n                        # If has_odd_cycle is True, we don't need to populate component_color_counts\n                        # or component_stats further.\n                        break\n                if has_odd_cycle:\n                    break\n            \n            if has_odd_cycle:\n                # If an odd cycle is found, we don't need to process other components for t=0.\n                # Just set t=0, w=1 and return.\n                # However, the problem implies finding _a_ cycle, so if any component has an odd cycle,\n                # t=0, w=1. We don't need to find all odd cycles.\n                print(0, 1)\n                return\n\n            component_color_counts.append(color_counts)\n            component_stats.append((current_component_nodes, component_edges // 2))\n\n    # If we reached here, the graph is bipartite.\n    # Case 1: t=1\n    # We need to add an edge (u, v) where u and v are in the same component and colors[u] == colors[v].\n    # The number of such pairs (u, v) is sum over all components of (count_color_0 * (count_color_0 - 1) / 2) + (count_color_1 * (count_color_1 - 1) / 2)\n    \n    t1_ways = 0\n    for c0, c1 in component_color_counts:\n        t1_ways += c0 * (c0 - 1) // 2\n        t1_ways += c1 * (c1 - 1) // 2\n    \n    if t1_ways > 0:\n        print(1, t1_ways)\n        return\n\n    # Case 2: t=2\n    # If t1_ways is 0, it means all components are paths or isolated vertices (trees).\n    # Specifically, each component has at most one vertex of each color, meaning it's just a single vertex.\n    # No, this is wrong. A component can be a tree with multiple vertices of same color, but no edge connects them.\n    # e.g., a path 0-1-0-1-0. It has 3 vertices of color 0 and 2 of color 1. t1_ways > 0 for this.\n    # t1_ways = 0 only if for every component, c0 <= 1 and c1 <= 1.\n    # This means each component is either a single vertex or an empty graph.\n    # This is not correct. t1_ways=0 means that for every component, c0*(c0-1)/2 = 0 AND c1*(c1-1)/2 = 0.\n    # This implies c0 < 2 AND c1 < 2 for all components.\n    # So each component has at most one vertex of color 0 and at most one vertex of color 1.\n    # This means each component has at most 2 vertices.\n    # If a component has 2 vertices, it must be an edge (u,v) where colors[u] != colors[v].\n    # If a component has 1 vertex, it's an isolated vertex.\n    # So if t1_ways = 0, all components are isolated vertices or single edges.\n\n    # We need to add two edges.\n    # Option A: Add two edges (u, v) and (v, w) such that u, v, w are distinct\n    # and form an odd cycle.\n    # This means we pick 3 distinct vertices.\n    # If we pick 3 vertices u, v, w, and add (u,v) and (v,w), we make a path u-v-w.\n    # If u, w are already connected, we have a cycle of length 3.\n    # The problem asks for minimum added edges.\n    # If t=2, we need to add two edges.\n    # If we add (u, v) and (x, y), where u,v,x,y are distinct and form a path u-G-x, y-G-v,\n    # and then add (u,y) and (v,x), this forms a cycle.\n    # This is too complex.\n    \n    # Consider paths of length 2: u - k - v.\n    # If we add edge (u, v), we get a cycle of length 3 (an odd cycle).\n    # This requires u, v not to be connected.\n    # How many such pairs (u, v) exist?\n    # For each vertex k, consider its neighbors. Let degree of k be deg(k).\n    # Any pair of neighbors (u, v) of k forms a path u-k-v.\n    # If we add edge (u, v), we form an odd cycle of length 3.\n    # Number of ways to choose 2 neighbors for a vertex k is deg(k) * (deg(k) - 1) / 2.\n    # Sum this over all k. This counts pairs {u, v} that are at distance 2.\n    # This is (number of paths of length 2) - (number of triangles).\n    \n    t2_ways = 0\n    for i in range(1, n + 1):\n        deg_i = len(adj[i])\n        t2_ways += deg_i * (deg_i - 1) // 2\n    \n    if t2_ways > 0:\n        print(2, t2_ways)\n        return\n\n    # Case 3: t=3\n    # If t1_ways = 0 and t2_ways = 0.\n    # t1_ways = 0 means all components have at most 2 vertices (isolated or single edge).\n    # t2_ways = 0 means all vertices have degree 0 or 1.\n    # So the graph consists only of isolated vertices and isolated edges.\n    # In this case, we need to add 3 edges to form a triangle (cycle of length 3).\n    # Pick 3 distinct vertices u, v, w. Add edges (u,v), (v,w), (w,u).\n    # Number of ways to choose 3 vertices from n is n * (n - 1) * (n - 2) / 6.\n    \n    # This is the only remaining case.\n    # The graph has no odd cycles (t=0 failed).\n    # The graph is bipartite.\n    # No way to add 1 edge (t=1 failed): all components have c0 < 2 and c1 < 2.\n    # No way to add 2 edges to form a triangle (t=2 failed): no vertex has degree >= 2.\n    # This means the graph is a collection of isolated vertices and isolated edges.\n    # To form an odd cycle (e.g., a triangle), we need to pick 3 vertices and add 3 edges.\n    \n    t3_ways = n * (n - 1) * (n - 2) // 6\n    print(3, t3_ways)\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 604,
        "completion_token_count": 2258,
        "thoughts_token_count": 750
    }
}