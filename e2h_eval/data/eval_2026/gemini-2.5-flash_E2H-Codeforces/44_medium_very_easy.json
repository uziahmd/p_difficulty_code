{
    "start": 1758294827.3108304,
    "end": 1758294904.4085164,
    "start-formatted": "2025-09-20 00:13 KST",
    "end-formatted": "2025-09-20 00:15 KST",
    "gpu": 2,
    "pid": 44,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Polycarp's Practice\n\nPolycarp is practicing his problem solving skill. He has a list of $$$n$$$ problems with difficulties $$$a_1, a_2, \\dots, a_n$$$, respectively. His plan is to practice for exactly $$$k$$$ days. Each day he has to solve at least one problem from his list. Polycarp solves the problems in the order they are given in his list, he cannot skip any problem from his list. He has to solve all $$$n$$$ problems in exactly $$$k$$$ days.Thus, each day Polycarp solves a contiguous sequence of (consecutive) problems from the start of the list. He can't skip problems or solve them multiple times. As a result, in $$$k$$$ days he will solve all the $$$n$$$ problems.The profit of the $$$j$$$-th day of Polycarp's practice is the maximum among all the difficulties of problems Polycarp solves during the $$$j$$$-th day (i.e. if he solves problems with indices from $$$l$$$ to $$$r$$$ during a day, then the profit of the day is $$$\\max\\limits_{l \\le i \\le r}a_i$$$). The total profit of his practice is the sum of the profits over all $$$k$$$ days of his practice.You want to help Polycarp to get the maximum possible total profit over all valid ways to solve problems. Your task is to distribute all $$$n$$$ problems between $$$k$$$ days satisfying the conditions above in such a way, that the total profit is maximum.For example, if $$$n = 8, k = 3$$$ and $$$a = [5, 4, 2, 6, 5, 1, 9, 2]$$$, one of the possible distributions with maximum total profit is: $$$[5, 4, 2], [6, 5], [1, 9, 2]$$$. Here the total profit equals $$$5 + 6 + 9 = 20$$$.\n\n## Input\nThe first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\le k \\le n \\le 2000$$$) — the number of problems and the number of days, respectively.The second line of the input contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le 2000$$$) — difficulties of problems in Polycarp's list, in the order they are placed in the list (i.e. in the order Polycarp will solve them).\n\n## Output\nIn the first line of the output print the maximum possible total profit.In the second line print exactly $$$k$$$ positive integers $$$t_1, t_2, \\dots, t_k$$$ ($$$t_1 + t_2 + \\dots + t_k$$$ must equal $$$n$$$), where $$$t_j$$$ means the number of problems Polycarp will solve during the $$$j$$$-th day in order to achieve the maximum possible total profit of his practice.If there are many possible answers, you may print any of them.\n\n## Example\n### Input\n['8 3\\n5 4 2 6 5 1 9 2', '5 1\\n1 1 1 1 1', '4 2\\n1 2000 2000 2']\n\n### Output\n['20\\n3 2 3', '1\\n5', '4000\\n2 2']\n\n## Note\nThe first example is described in the problem statement.In the second example there is only one possible distribution.In the third example the best answer is to distribute problems in the following way: $$$[1, 2000], [2000, 2]$$$. The total profit of this distribution is $$$2000 + 2000 = 4000$$$.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "**The Optimal Strategy for Competitive Programming**\n\nOkay, so I've got this competitive programming problem staring me down. The goal is clear: maximize the total profit by strategically solving problems over a given number of days. I need to output the maximum profit possible and the lengths of the problem segments solved each day. This feels like a classic partitioning problem with a twist.\n\nLet's break it down. I'm given 'n' problems, 'k' days, and a list 'a' of problem difficulties. Each day, I have to solve at least one problem, and they must be solved in order without skipping. The profit for a day is simply the maximum difficulty of the problems solved on that day. My overarching aim is to maximize the sum of these daily profits.\n\nThe key insight here is that to maximize the total profit, I need to make each day's \"profit\" as high as possible. And the only way to do that is to ensure each day has the highest difficulty problem within its segment. So, the biggest 'k' values within the entire list 'a' need to be strategically assigned as the daily maximums.\n\nTo implement this, I'll sort the problems in descending order of difficulty. The sum of the 'k' largest difficulties is the upper bound on the maximum profit I can achieve. I have to select these 'k' elements.\n\nNow comes the tricky part: determining the segment lengths. I've figured out I need to slice the list 'a' at specific locations. These locations need to be right after each of the 'k' largest difficulty elements. To accomplish this, I must sort the indices of these values, and the segment sizes are calculated by the differences between these indices. The sorted indices of the selected 'k' elements must be the cut-off point.\n\nThe first segment goes from the beginning up to the first selected element. This first selected element must be the maximum value in this segment. The intermediate segments are determined by calculating the lengths between the successive selected elements, adding one element to each, ensuring that each of the \"k\" largest values are indeed the maximum in their segment. The final segment extends up to the end of the entire problem list.\n\nMy approach will thus be: Find the k largest values, calculate the lengths by the position of these values, and then output the sum of these maximum difficulties and the daily segment lengths. Now, let's turn this strategy into working code. This is definitely going to be an efficient solution.\n",
    "response": "The problem asks us to partition `n` problems, given by their difficulties `a_1, a_2, \\dots, a_n`, into exactly `k` contiguous segments (days). Each day's profit is the maximum difficulty among problems solved that day. The goal is to maximize the total profit, which is the sum of daily profits, and to output this maximum profit along with the number of problems solved each day.\n\n**Strategy to Maximize Total Profit:**\n\n1.  **Identify the `k` largest difficulties:** To maximize the sum of `k` daily profits, we should choose the `k` largest difficulties from the entire list `a`. Let these `k` difficulties be `M_1 \\ge M_2 \\ge \\dots \\ge M_k`. The maximum possible total profit will be `M_1 + M_2 + \\dots + M_k`. This is because each of these `M_j` values must be solved on some day. If `M_j` is solved on day `d_j`, then the profit for day `d_j` will be at least `M_j`. To achieve the sum `M_1 + \\dots + M_k`, we need to ensure that each `M_j` is the *actual maximum* for its respective day, and that these `k` maximums correspond to `k` distinct days.\n\n    We can achieve this by:\n    *   Creating pairs `(difficulty, original_index)` for all problems.\n    *   Sorting these pairs in descending order based on difficulty.\n    *   Taking the top `k` pairs. The sum of their difficulties will be the maximum total profit.\n    *   The original indices of these `k` problems will be crucial for determining the segment lengths.\n\n**Strategy to Determine Segment Lengths:**\n\n1.  Let the original 0-based indices of the `k` largest problems be `idx_1, idx_2, \\dots, idx_k`.\n2.  Sort these `k` indices in ascending order: `s_idx_0 < s_idx_1 < \\dots < s_idx_{k-1}`.\n3.  These `k` problems (at indices `s_idx_0, s_idx_1, \\dots, s_idx_{k-1}`) will be the maximums for their respective days. To ensure this, we can make `k-1` cuts in the problem list. A simple and effective way is to make a cut *after* each of the problems at indices `s_idx_0, s_idx_1, \\dots, s_idx_{k-2}`. The last segment will then cover all remaining problems up to `a_{n-1}`.\n\n    *   Day 1 will solve problems from index `0` up to `s_idx_0`. Its length will be `s_idx_0 + 1`.\n    *   Day 2 will solve problems from index `s_idx_0 + 1` up to `s_idx_1`. Its length will be `s_idx_1 - s_idx_0`.\n    *   ...\n    *   Day `j` (for `j` from `1` to `k-1`) will solve problems from index `s_idx_{j-2} + 1` up to `s_idx_{j-1}`. Its length will be `s_idx_{j-1} - s_idx_{j-2}`.\n    *   The `k`-th (last) day will solve problems from index `s_idx_{k-2} + 1` up to `n-1`. Its length will be `n - (s_idx_{k-2} + 1)`.\n\n    This strategy guarantees that `a[s_idx_j]` is included in the `(j+1)`-th segment, and because `s_idx_j` is the `j`-th smallest index among the `k` largest values, `a[s_idx_j]` will be the maximum within its segment.\n\n**Example Walkthrough:**\n\n`n = 8, k = 3, a = [5, 4, 2, 6, 5, 1, 9, 2]`\n\n1.  **Pairs (difficulty, index):** `[(5,0), (4,1), (2,2), (6,3), (5,4), (1,5), (9,6), (2,7)]`\n2.  **Sort by difficulty (descending):** `[(9,6), (6,3), (5,0), (5,4), (4,1), (2,2), (2,7), (1,5)]`\n3.  **Top `k=3` pairs:** `[(9,6), (6,3), (5,0)]`\n4.  **Maximum Total Profit:** `9 + 6 + 5 = 20`.\n5.  **Original Indices of these `k` problems:** `[6, 3, 0]`\n6.  **Sort these indices:** `s_idx = [0, 3, 6]`\n\n7.  **Calculate segment lengths (`t_j`):**\n    *   Initialize `t = []`, `current_pos = -1` (representing the index of the last problem solved in the *previous* day).\n    *   For `j` from `0` to `k-2` (i.e., `0` to `1`):\n        *   `j = 0`: `s_idx[0] = 0`. Length for Day 1: `s_idx[0] - current_pos = 0 - (-1) = 1`. `t = [1]`. `current_pos = 0`.\n        *   `j = 1`: `s_idx[1] = 3`. Length for Day 2: `s_idx[1] - current_pos = 3 - 0 = 3`. `t = [1, 3]`. `current_pos = 3`.\n    *   After the loop, for the last day (`k`-th day): Length for Day 3: `n - (current_pos + 1) = 8 - (3 + 1) = 8 - 4 = 4`. `t = [1, 3, 4]`.\n\n    So, the segment lengths are `[1, 3, 4]`. This means:\n    *   Day 1: `[5]` (max `5`)\n    *   Day 2: `[4, 2, 6]` (max `6`)\n    *   Day 3: `[5, 1, 9, 2]` (max `9`)\n    Total profit `5 + 6 + 9 = 20`. This matches the example's total profit and is a valid distribution.\n\n**Code Structure:**\n\n1.  Read `n` and `k`.\n2.  Read the list `a`.\n3.  Create a list `problems` of `(difficulty, index)` tuples.\n4.  Sort `problems` in descending order by difficulty.\n5.  Extract the top `k` problems. Calculate `max_total_profit` and collect their original indices into a list `cut_indices`.\n6.  Sort `cut_indices` in ascending order.\n7.  Calculate the `k` segment lengths `t_j` using the `cut_indices` and `n`.\n8.  Print `max_total_profit`.\n9.  Print the elements of `t_j` separated by spaces.\n\n```python\nimport sys\n\ndef solve():\n    n, k = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    # Create a list of (difficulty, original_index) tuples\n    problems_with_indices = []\n    for i in range(n):\n        problems_with_indices.append((a[i], i))\n\n    # Sort problems by difficulty in descending order\n    # If difficulties are equal, the original index order doesn't matter for sum,\n    # but for consistency, Python's Timsort is stable.\n    problems_with_indices.sort(key=lambda x: x[0], reverse=True)\n\n    # Select the k largest difficulties\n    top_k_problems = problems_with_indices[:k]\n\n    # Calculate the maximum total profit\n    max_total_profit = sum(p[0] for p in top_k_problems)\n\n    # Get the original indices of these k problems\n    # These indices will be used to determine the cut points\n    cut_indices = sorted([p[1] for p in top_k_problems])\n\n    # Calculate the lengths of problems for each day\n    daily_problem_counts = []\n    current_start_index = 0\n    \n    # For k-1 days, make cuts after the selected problems\n    for i in range(k - 1):\n        # The cut is made after problem at index cut_indices[i]\n        # So, problems from current_start_index to cut_indices[i] form this day's segment\n        length = cut_indices[i] - current_start_index + 1\n        daily_problem_counts.append(length)\n        current_start_index = cut_indices[i] + 1\n    \n    # The last day takes all remaining problems\n    daily_problem_counts.append(n - current_start_index)\n\n    # Print the results\n    sys.stdout.write(str(max_total_profit) + '\\n')\n    sys.stdout.write(' '.join(map(str, daily_problem_counts)) + '\\n')\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, k = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    # Create a list of (difficulty, original_index) tuples\n    problems_with_indices = []\n    for i in range(n):\n        problems_with_indices.append((a[i], i))\n\n    # Sort problems by difficulty in descending order\n    # If difficulties are equal, the original index order doesn't matter for sum,\n    # but for consistency, Python's Timsort is stable.\n    problems_with_indices.sort(key=lambda x: x[0], reverse=True)\n\n    # Select the k largest difficulties\n    top_k_problems = problems_with_indices[:k]\n\n    # Calculate the maximum total profit\n    max_total_profit = sum(p[0] for p in top_k_problems)\n\n    # Get the original indices of these k problems\n    # These indices will be used to determine the cut points\n    cut_indices = sorted([p[1] for p in top_k_problems])\n\n    # Calculate the lengths of problems for each day\n    daily_problem_counts = []\n    current_start_index = 0\n    \n    # For k-1 days, make cuts after the selected problems\n    for i in range(k - 1):\n        # The cut is made after problem at index cut_indices[i]\n        # So, problems from current_start_index to cut_indices[i] form this day's segment\n        length = cut_indices[i] - current_start_index + 1\n        daily_problem_counts.append(length)\n        current_start_index = cut_indices[i] + 1\n    \n    # The last day takes all remaining problems\n    daily_problem_counts.append(n - current_start_index)\n\n    # Print the results\n    sys.stdout.write(str(max_total_profit) + '\\n')\n    sys.stdout.write(' '.join(map(str, daily_problem_counts)) + '\\n')\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 973,
        "completion_token_count": 2198,
        "thoughts_token_count": 7609
    }
}