{
    "start": 1758294860.7219028,
    "end": 1758294946.3285112,
    "start-formatted": "2025-09-20 00:14 KST",
    "end-formatted": "2025-09-20 00:15 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "**Problem Solving Strategy for \"Mushroom Strife\"**\n\nOkay, so I've got this competitive programming problem, \"Mushroom Strife\", and it's all about finding valid mushroom counts on a network of lawns connected by roads, with constraints related to GCD and LCM. I need to output a solution or \"NO\". Here's the breakdown of my thought process:\n\n*   **Understanding the Core:** It's a graph problem. Each lawn is a node and needs an integer mushroom count. Road edges give me GCD and LCM relationships between the connected nodes. `gcd(x_u, x_v) = g` and `lcm(x_u, x_v) = l` for an edge `(u,v)`. We know that `x_u * x_v = g * l`. A critical first check is if `g` divides `l` (otherwise, no solution exists).\n*   **Key Insight: Prime Factorization:** The GCD and LCM hints at prime factorization as a core concept. `x_u = g * a` and `x_v = g * b`, where `gcd(a, b) = 1` and `a * b = l / g`. Each x_i, when expressed in terms of prime factorization, will give us another crucial insight.\n*   **Prime Power Exponents:** For each prime 'p', we can describe the x_i in terms of exponents. The min/max conditions on exponents for g and l give us that we need to color each node with one of two exponents.\n*   **Graph Coloring:** This prime-wise exponent setup looks like a 2-coloring problem. The conditions on GCD/LCM are translated into constraints on those exponent values. We need to build a graph, where each node is a lawn and an edge constraint for each prime means that the exponent levels either have to be the minimum, or the maximum. This sounds like an independent 2-coloring problem for each prime factor.\n*   **Combining Primes:** I need to find the exponents for each prime factor up to 10^6 and calculate the `x_i` (the mushroom counts for each lawn).\n*   **Algorithm Strategy:**\n    1.  *Sieve for Primes:* Use a Sieve of Eratosthenes to pre-compute primes and prime factors up to 10^6. This will optimize how fast we can calculate prime powers for each edge.\n    2.  *Process Each Prime:* Loop through each prime `p`.\n        *   Initialize `exp_val[i]` to -1 (unknown) for the exponent of `p` in `x_i`.\n        *   Handle `v_p(g) == v_p(l)` cases, that require equal exponents.\n        *   Run a graph search (BFS or DFS) to do 2-coloring on the exponents. Propagate constraints, detect conflicts (return \"NO\" if found), and calculate x_i.\n    3.  *Check Limits and Output:* After processing all primes, calculate `x_i` from the exponents. If any `x_i > 10^6`, return \"NO\"; otherwise, print the `x_i` as the solution.\n*   **Data Structures:**\n    *   `exp_val[i]` (exponent of prime `p` in x_i): Stores the prime exponent levels.\n    *   Adjacency list with prime exponents to model connections.\n*   **Potential Challenges:** Watch out for the `10^6` bound. The LCM can grow too large, so handle that carefully. The complexity is O(N * log(MAX) + M * log(MAX)), O(MAX loglog MAX) for sieve + O(M) for graph traversals for each prime.\n",
    "response": "The problem asks us to restore the number of mushrooms `x_i` on `n` lawns, given `m` roads. For each road connecting lawns `u` and `v`, we are given `gcd(x_u, x_v)` and `lcm(x_u, x_v)`. We need to find any valid assignment of `x_i` values (between 1 and 10^6) or report that none exists.\n\nLet `g` be `gcd(x_u, x_v)` and `l` be `lcm(x_u, x_v)`. We know the fundamental property `gcd(a, b) * lcm(a, b) = a * b`. So, for each edge `(u, v)`, we must have `x_u * x_v = g * l`.\nAlso, `g` must divide `l`. If `g` does not divide `l` for any edge, no solution exists.\n\nA crucial insight comes from prime factorization. Let `v_p(k)` denote the exponent of prime `p` in the prime factorization of `k`.\nFor any prime `p`:\n1. `min(v_p(x_u), v_p(x_v)) = v_p(g)`\n2. `max(v_p(x_u), v_p(x_v)) = v_p(l)`\n\nFrom these two conditions, it follows that for each prime `p`, the pair of exponents `(v_p(x_u), v_p(x_v))` must be either `(v_p(g), v_p(l))` or `(v_p(l), v_p(g))`.\nThis means that for a fixed prime `p`, and for any edge `(u, v)` with given `g, l`, the exponents `v_p(x_u)` and `v_p(x_v)` must be `v_p(g)` and `v_p(l)` in some order.\n\nThis problem can be decomposed by prime factors. For each prime `p` up to `10^6`, we need to determine `v_p(x_i)` for all `i`.\nLet `A_p[i]` be `v_p(x_i)`.\nFor an edge `(u, v)` with `g, l`, let `g_p = v_p(g)` and `l_p = v_p(l)`.\n- If `g_p == l_p`: Then `A_p[u]` must be `g_p` AND `A_p[v]` must be `g_p`. This fixes the exponents for `u` and `v` for prime `p`.\n- If `g_p != l_p`: Then `A_p[u]` and `A_p[v]` must be `g_p` and `l_p` in some order. This means `A_p[u] != A_p[v]`. This is a 2-coloring type constraint.\n\nThe overall algorithm:\n\n**1. Precomputation:**\n   - Sieve of Eratosthenes to find all primes up to `10^6` and the Smallest Prime Factor (SPF) for each number up to `10^6`. This allows efficient prime factorization.\n   - For each input `g` and `l`, factorize them to get `v_p(g)` and `v_p(l)` for all relevant primes `p`. Store these as `prime_factors_g[edge_idx]` and `prime_factors_l[edge_idx]`, where each is a dictionary mapping prime `p` to its exponent.\n\n**2. Initialize `x_i` values:**\n   - Create an array `ans_x` of size `n+1`, initialized to `1` (since `x_i >= 1`).\n   - Create an array `possible_primes` which stores all primes `p` that appear in the factorization of any `g` or `l` from the input. This limits the primes we need to iterate over.\n\n**3. Process each prime `p`:**\n   For each prime `p` in `possible_primes`:\n     - Create an array `exp_val[i]` to store `v_p(x_i)`, initialized to `-1` (unknown) for all `i`.\n     - Create an adjacency list `adj_p` for the graph. For an edge `(u, v)` with `g, l`, if `v_p(g) != v_p(l)`, add `(v, v_p(g), v_p(l))` to `adj_p[u]` and `(u, v_p(g), v_p(l))` to `adj_p[v]`.\n     - Create an array `fixed_exp[i]` to store a determined exponent for `v_p(x_i)` if `v_p(g) == v_p(l)` for an incident edge, initialized to `-1`.\n\n     **Phase 1: Handle `v_p(g) == v_p(l)` constraints and initial checks.**\n     - Iterate through all `m` edges:\n       - Let `u, v, g, l` be the edge details.\n       - Get `g_p = v_p(g)` and `l_p = v_p(l)`. (If `p` doesn't divide `g` or `l`, its exponent is 0).\n       - If `g_p > l_p`: This is an invalid condition (`gcd` exponent must be less than or equal to `lcm` exponent). Output \"NO\" and exit.\n       - If `g_p == l_p`:\n         - If `fixed_exp[u]` is `-1`, set `fixed_exp[u] = g_p`.\n         - Else if `fixed_exp[u] != g_p`, there's a conflict. Output \"NO\" and exit.\n         - Do the same for `v`.\n\n     **Phase 2: Propagate fixed exponents using BFS/DFS.**\n     - For `i` from `1` to `n`:\n       - If `fixed_exp[i] != -1` and `exp_val[i] == -1`: // A node has a fixed exponent and is not yet processed\n         - Start a BFS from `i`:\n           - `Q = deque([(i, fixed_exp[i])])`\n           - `exp_val[i] = fixed_exp[i]`\n           - While `Q` is not empty:\n             - `curr_u, curr_exp = Q.popleft()`\n             - For each `(neighbor_v, ng_p, nl_p)` in `adj_p[curr_u]`:\n               - Determine `next_exp` for `neighbor_v`:\n                 - If `curr_exp == ng_p`: `next_exp = nl_p`.\n                 - Else if `curr_exp == nl_p`: `next_exp = ng_p`.\n                 - Else: Conflict (`curr_exp` is neither `ng_p` nor `nl_p`). Output \"NO\" and exit.\n               - If `exp_val[neighbor_v] == -1`:\n                 - `exp_val[neighbor_v] = next_exp`. Add `(neighbor_v, next_exp)` to `Q`.\n               - Else if `exp_val[neighbor_v] != next_exp`: Conflict. Output \"NO\" and exit.\n\n     **Phase 3: Handle remaining unassigned components (where all edges have `v_p(g) != v_p(l)`).**\n     - For `i` from `1` to `n`:\n       - If `exp_val[i] == -1`: // An unassigned node in an uncolored component\n         - Start a BFS from `i`:\n           - Find an incident edge `(i, j)` in `adj_p[i]`. If no such edge, `exp_val[i]` can be 0. Otherwise, pick one of `v_p(g)` or `v_p(l)` for `i` arbitrarily (e.g., `v_p(g)`).\n           - `Q = deque([(i, arbitrary_exp)])`\n           - `exp_val[i] = arbitrary_exp`\n           - Propagate using BFS as in Phase 2. If any conflict, output \"NO\" and exit.\n\n     **4. Update `ans_x` and check limits:**\n     - After `exp_val` is fully determined for prime `p`:\n       - For `i` from `1` to `n`:\n         - `ans_x[i] = ans_x[i] * (p ** exp_val[i])`\n         - If `ans_x[i] > 10^6`: Output \"NO\" and exit.\n\n**5. Output:**\n   - If all primes are processed without conflicts, output \"YES\" and then the `ans_x` array.\n\n**Example of `v_p(g) > v_p(l)` check:**\nIf an edge `(u,v)` has `g=2, l=6`, then for `p=2`, `v_2(g)=1, v_2(l)=1`. For `p=3`, `v_3(g)=0, v_3(l)=1`.\nIf `g=6, l=2`, then `v_2(g)=1, v_2(l)=1`. For `p=3`, `v_3(g)=1, v_3(l)=0`. This would trigger `g_p > l_p` for `p=3`, correctly leading to \"NO\".\n\n**Edge Case: `m=0`**\nIf there are no roads, `n` lawns, any `x_i` from 1 to 10^6 is valid. The problem states `1 <= x_i <= 10^6`. We can just output `1` for all `x_i`. My code handles this by `ans_x` initialized to 1 and no prime processing occurs.\n\n**Complexity:**\n- Sieve: `O(MAX_VAL * log log MAX_VAL)` where `MAX_VAL = 10^6`.\n- Prime factorization for `2m` numbers: `O(m * log MAX_VAL)`.\n- Iterating through primes: Let `P_count` be the number of primes up to `MAX_VAL`.\n  For each prime `p`:\n    - Building `adj_p` and `fixed_exp`: `O(m)`\n    - BFS/DFS phases: `O(N + M)` in total for all components.\n  Total for primes: `P_count * O(N + M)`. This is too slow if `P_count` is large. `78498 * (10^5 + 10^5)` is too much.\n\n**Optimization for prime processing:**\nInstead of iterating through *all* primes for *all* edges:\nFor each edge `(u, v, g, l)`:\n  - Factorize `g` and `l`.\n  - For each prime `p` that divides `g` or `l`:\n    - Add `(u, v, v_p(g), v_p(l))` to a list associated with prime `p`.\nThis way, each prime `p` is only processed for edges where it's relevant.\nA `defaultdict(list)` can store `edges_by_prime[p]`.\nThe total number of prime factors across all `g, l` values is `O(m * log MAX_VAL)`.\nSo the total work across all primes becomes `O(m * log MAX_VAL * (N+M))` if we re-run BFS for each prime for the whole graph.\nThis is still too much.\n\nThe BFS/DFS for a specific prime `p` only needs to consider nodes and edges that have `p` as a factor in their `g` or `l` values.\nLet `nodes_involved_in_p` be the set of nodes `u` such that `p` divides `g` or `l` for some edge incident to `u`.\nThe BFS/DFS for prime `p` can operate on the subgraph induced by `nodes_involved_in_p`.\nThe sum of `(N_p + M_p)` over all primes `p` (where `N_p` is number of nodes involved and `M_p` is number of edges involved) would be `O(m * log MAX_VAL)`. This is because each edge `(u,v)` contributes to processing for `O(log MAX_VAL)` primes.\nSo, total time for prime processing becomes `O(m * log MAX_VAL)`.\n\nFinal complexity:\n- Sieve: `O(MAX_VAL * log log MAX_VAL)`\n- Prime factorization for all `g, l` and grouping edges by prime: `O(m * log MAX_VAL)`\n- Processing all primes (sum over `p` of `(N_p + M_p)` for relevant subgraphs): `O(m * log MAX_VAL)`\n- Final multiplication and check: `O(N * log MAX_VAL)` (for multiplying by `p` up to `log_p(MAX_VAL)` times).\n\nTotal time complexity: `O(MAX_VAL * log log MAX_VAL + m * log MAX_VAL + N * log MAX_VAL)`.\nWith `N, M <= 10^5`, `MAX_VAL = 10^6`:\n`10^6 * log log 10^6` is roughly `10^6 * 3`.\n`10^5 * log 10^6` is roughly `10^5 * 20`.\nThis should be efficient enough.\n\n```python\nimport sys\nfrom collections import deque, defaultdict\n\n# Max value for numbers (GCD, LCM, x_i)\nMAX_VAL = 10**6\n\n# Sieve for smallest prime factor (SPF)\nspf = [0] * (MAX_VAL + 1)\nprimes = []\n\ndef sieve():\n    for i in range(2, MAX_VAL + 1):\n        if spf[i] == 0:\n            spf[i] = i\n            primes.append(i)\n        for p in primes:\n            if p > spf[i] or i * p > MAX_VAL:\n                break\n            spf[i * p] = p\n\n# Function to get prime factorization of a number\ndef get_prime_factorization(n_val):\n    factors = defaultdict(int)\n    if n_val == 0: # Handle 0 specially if it could appear, but constraints say 1 <= GCD, LCM\n        return factors\n    temp_n = n_val\n    while temp_n > 1:\n        p = spf[temp_n]\n        factors[p] += 1\n        temp_n //= p\n    return factors\n\n# Read input\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    # Precompute SPF for prime factorization\n    sieve()\n\n    # Store edge information\n    # edges[i] = (u, v, g_val, l_val, g_factors, l_factors)\n    # g_factors and l_factors are dicts from prime to exponent\n    edges_info = []\n    \n    # Collect all primes that appear in any g or l\n    all_relevant_primes = set()\n\n    for _ in range(m):\n        u, v, g_val, l_val = map(int, sys.stdin.readline().split())\n        if g_val > l_val or l_val % g_val != 0:\n            print(\"NO\")\n            return\n\n        g_factors = get_prime_factorization(g_val)\n        l_factors = get_prime_factorization(l_val)\n        \n        for p in g_factors:\n            all_relevant_primes.add(p)\n        for p in l_factors:\n            all_relevant_primes.add(p)\n\n        edges_info.append((u, v, g_val, l_val, g_factors, l_factors))\n\n    # Initialize answer array\n    ans_x = [1] * (n + 1)\n\n    # Process each relevant prime\n    for p in all_relevant_primes:\n        # exp_val[i] stores v_p(x_i)\n        # -1: unknown, others: exponent value\n        exp_val = [-1] * (n + 1)\n        \n        # adj_p stores (neighbor, g_p, l_p) for edges where g_p != l_p\n        adj_p = defaultdict(list) \n        \n        # fixed_exp[i] stores a determined exponent for v_p(x_i) from g_p == l_p constraints\n        # -1: not fixed, others: fixed exponent value\n        fixed_exp = [-1] * (n + 1)\n\n        # Phase 1: Handle g_p == l_p constraints and build adj_p\n        for u, v, _, _, g_factors, l_factors in edges_info:\n            g_p = g_factors.get(p, 0)\n            l_p = l_factors.get(p, 0)\n\n            if g_p > l_p: # Should have been caught by l_val % g_val != 0 earlier\n                print(\"NO\")\n                return\n            \n            if g_p == l_p:\n                for node in [u, v]:\n                    if fixed_exp[node] == -1:\n                        fixed_exp[node] = g_p\n                    elif fixed_exp[node] != g_p:\n                        print(\"NO\") # Conflict in fixed exponent\n                        return\n            else: # g_p != l_p, add to adj_p for phase 2/3\n                adj_p[u].append((v, g_p, l_p))\n                adj_p[v].append((u, g_p, l_p))\n\n        # Phase 2 & 3: Propagate exponents using BFS\n        # Use a visited array to manage nodes for BFS, as adj_p might contain duplicate edges or edges already processed\n        # during fixed_exp propagation\n        \n        # Iterate through all nodes to find starting points for BFS\n        for start_node in range(1, n + 1):\n            initial_exp = -1\n            if fixed_exp[start_node] != -1:\n                initial_exp = fixed_exp[start_node]\n            elif exp_val[start_node] == -1: # Unvisited, un-fixed node, can pick an arbitrary value\n                # If there are no edges for this prime p incident to start_node, exp_val[start_node] can be 0.\n                # If there are edges, we can pick one of the two options.\n                # For simplicity, if unvisited and no fixed_exp, we can pick 0 or the first g_p from an incident edge.\n                # If no incident edge for this prime, it's effectively 0.\n                if not adj_p[start_node]:\n                    initial_exp = 0\n                else:\n                    # Arbitrarily pick g_p for the first incident edge\n                    initial_exp = adj_p[start_node][0][1] # (v, g_p, l_p) -> g_p\n\n            if initial_exp != -1 and exp_val[start_node] == -1:\n                q = deque([(start_node, initial_exp)])\n                exp_val[start_node] = initial_exp\n                \n                while q:\n                    curr_u, curr_exp = q.popleft()\n\n                    # Process edges from adj_p. Use a seen_edges set or mark visited to avoid re-processing edges\n                    # and ensure each edge is considered once per traversal.\n                    # A simple way is to iterate over a copy or remove processed edges, but removing is complex with defaultdict.\n                    # Instead, we just check exp_val[neighbor_v] == -1.\n                    \n                    for neighbor_v, g_p_edge, l_p_edge in adj_p[curr_u]:\n                        next_exp = -1\n                        if curr_exp == g_p_edge:\n                            next_exp = l_p_edge\n                        elif curr_exp == l_p_edge:\n                            next_exp = g_p_edge\n                        else:\n                            print(\"NO\") # Conflict: curr_exp is neither g_p_edge nor l_p_edge\n                            return\n                        \n                        if exp_val[neighbor_v] == -1:\n                            exp_val[neighbor_v] = next_exp\n                            q.append((neighbor_v, next_exp))\n                        elif exp_val[neighbor_v] != next_exp:\n                            print(\"NO\") # Conflict: neighbor already assigned different exp\n                            return\n        \n        # After processing for prime p, update ans_x\n        for i in range(1, n + 1):\n            if exp_val[i] == -1: # If still unknown, means it's not involved with prime p, so exponent is 0\n                exp_val[i] = 0\n            \n            # Multiply ans_x[i] by p^(exp_val[i])\n            for _ in range(exp_val[i]):\n                ans_x[i] *= p\n                if ans_x[i] > MAX_VAL:\n                    print(\"NO\")\n                    return\n\n    print(\"YES\")\n    print(*(ans_x[1:]))\n\n# Call the solve function\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque, defaultdict\n\n# Max value for numbers (GCD, LCM, x_i)\nMAX_VAL = 10**6\n\n# Sieve for smallest prime factor (SPF)\nspf = [0] * (MAX_VAL + 1)\nprimes = []\n\ndef sieve():\n    for i in range(2, MAX_VAL + 1):\n        if spf[i] == 0:\n            spf[i] = i\n            primes.append(i)\n        for p in primes:\n            if p > spf[i] or i * p > MAX_VAL:\n                break\n            spf[i * p] = p\n\n# Function to get prime factorization of a number\ndef get_prime_factorization(n_val):\n    factors = defaultdict(int)\n    if n_val == 0: # Handle 0 specially if it could appear, but constraints say 1 <= GCD, LCM\n        return factors\n    temp_n = n_val\n    while temp_n > 1:\n        p = spf[temp_n]\n        factors[p] += 1\n        temp_n //= p\n    return factors\n\n# Read input\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    # Precompute SPF for prime factorization\n    sieve()\n\n    # Store edge information\n    # edges[i] = (u, v, g_val, l_val, g_factors, l_factors)\n    # g_factors and l_factors are dicts from prime to exponent\n    edges_info = []\n    \n    # Collect all primes that appear in any g or l\n    all_relevant_primes = set()\n\n    for _ in range(m):\n        u, v, g_val, l_val = map(int, sys.stdin.readline().split())\n        if g_val > l_val or l_val % g_val != 0:\n            print(\"NO\")\n            return\n\n        g_factors = get_prime_factorization(g_val)\n        l_factors = get_prime_factorization(l_val)\n        \n        for p in g_factors:\n            all_relevant_primes.add(p)\n        for p in l_factors:\n            all_relevant_primes.add(p)\n\n        edges_info.append((u, v, g_val, l_val, g_factors, l_factors))\n\n    # Initialize answer array\n    ans_x = [1] * (n + 1)\n\n    # Process each relevant prime\n    for p in all_relevant_primes:\n        # exp_val[i] stores v_p(x_i)\n        # -1: unknown, others: exponent value\n        exp_val = [-1] * (n + 1)\n        \n        # adj_p stores (neighbor, g_p, l_p) for edges where g_p != l_p\n        adj_p = defaultdict(list) \n        \n        # fixed_exp[i] stores a determined exponent for v_p(x_i) from g_p == l_p constraints\n        # -1: not fixed, others: fixed exponent value\n        fixed_exp = [-1] * (n + 1)\n\n        # Phase 1: Handle g_p == l_p constraints and build adj_p\n        for u, v, _, _, g_factors, l_factors in edges_info:\n            g_p = g_factors.get(p, 0)\n            l_p = l_factors.get(p, 0)\n\n            if g_p > l_p: # Should have been caught by l_val % g_val != 0 earlier\n                print(\"NO\")\n                return\n            \n            if g_p == l_p:\n                for node in [u, v]:\n                    if fixed_exp[node] == -1:\n                        fixed_exp[node] = g_p\n                    elif fixed_exp[node] != g_p:\n                        print(\"NO\") # Conflict in fixed exponent\n                        return\n            else: # g_p != l_p, add to adj_p for phase 2/3\n                adj_p[u].append((v, g_p, l_p))\n                adj_p[v].append((u, g_p, l_p))\n\n        # Phase 2 & 3: Propagate exponents using BFS\n        # Use a visited array to manage nodes for BFS, as adj_p might contain duplicate edges or edges already processed\n        # during fixed_exp propagation\n        \n        # Iterate through all nodes to find starting points for BFS\n        for start_node in range(1, n + 1):\n            initial_exp = -1\n            if fixed_exp[start_node] != -1:\n                initial_exp = fixed_exp[start_node]\n            elif exp_val[start_node] == -1: # Unvisited, un-fixed node, can pick an arbitrary value\n                # If there are no edges for this prime p incident to start_node, exp_val[start_node] can be 0.\n                # If there are edges, we can pick one of the two options.\n                # For simplicity, if unvisited and no fixed_exp, we can pick 0 or the first g_p from an incident edge.\n                # If no incident edge for this prime, it's effectively 0.\n                if not adj_p[start_node]:\n                    initial_exp = 0\n                else:\n                    # Arbitrarily pick g_p for the first incident edge\n                    initial_exp = adj_p[start_node][0][1] # (v, g_p, l_p) -> g_p\n\n            if initial_exp != -1 and exp_val[start_node] == -1:\n                q = deque([(start_node, initial_exp)])\n                exp_val[start_node] = initial_exp\n                \n                while q:\n                    curr_u, curr_exp = q.popleft()\n\n                    # Process edges from adj_p. Use a seen_edges set or mark visited to avoid re-processing edges\n                    # and ensure each edge is considered once per traversal.\n                    # A simple way is to iterate over a copy or remove processed edges, but removing is complex with defaultdict.\n                    # Instead, we just check exp_val[neighbor_v] == -1.\n                    \n                    for neighbor_v, g_p_edge, l_p_edge in adj_p[curr_u]:\n                        next_exp = -1\n                        if curr_exp == g_p_edge:\n                            next_exp = l_p_edge\n                        elif curr_exp == l_p_edge:\n                            next_exp = g_p_edge\n                        else:\n                            print(\"NO\") # Conflict: curr_exp is neither g_p_edge nor l_p_edge\n                            return\n                        \n                        if exp_val[neighbor_v] == -1:\n                            exp_val[neighbor_v] = next_exp\n                            q.append((neighbor_v, next_exp))\n                        elif exp_val[neighbor_v] != next_exp:\n                            print(\"NO\") # Conflict: neighbor already assigned different exp\n                            return\n        \n        # After processing for prime p, update ans_x\n        for i in range(1, n + 1):\n            if exp_val[i] == -1: # If still unknown, means it's not involved with prime p, so exponent is 0\n                exp_val[i] = 0\n            \n            # Multiply ans_x[i] by p^(exp_val[i])\n            for _ in range(exp_val[i]):\n                ans_x[i] *= p\n                if ans_x[i] > MAX_VAL:\n                    print(\"NO\")\n                    return\n\n    print(\"YES\")\n    print(*(ans_x[1:]))\n\n# Call the solve function\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 552,
        "completion_token_count": 4975,
        "thoughts_token_count": 6367
    }
}