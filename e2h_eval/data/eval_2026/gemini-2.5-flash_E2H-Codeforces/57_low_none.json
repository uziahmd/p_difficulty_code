{
    "start": 1758284842.621373,
    "end": 1758284901.1970453,
    "start-formatted": "2025-09-19 21:27 KST",
    "end-formatted": "2025-09-19 21:28 KST",
    "gpu": 2,
    "pid": 57,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Olympiad\n\nA boy named Vasya has taken part in an Olympiad. His teacher knows that in total Vasya got at least x points for both tours of the Olympiad. The teacher has the results of the first and the second tour of the Olympiad but the problem is, the results have only points, no names. The teacher has to know Vasya's chances.Help Vasya's teacher, find two numbers — the best and the worst place Vasya could have won. Note that the total results' table sorts the participants by the sum of points for both tours (the first place has the participant who has got the most points). If two or more participants have got the same number of points, it's up to the jury to assign places to them according to their choice. It is guaranteed that each participant of the Olympiad participated in both tours of the Olympiad.\n\n## Input\nThe first line contains two space-separated integers n, x (1 ≤ n ≤ 105; 0 ≤ x ≤ 2·105) — the number of Olympiad participants and the minimum number of points Vasya earned.The second line contains n space-separated integers: a1, a2, ..., an (0 ≤ ai ≤ 105) — the participants' points in the first tour.The third line contains n space-separated integers: b1, b2, ..., bn (0 ≤ bi ≤ 105) — the participants' points in the second tour.The participants' points are given in the arbitrary order. It is guaranteed that Vasya was present in the Olympiad — there are two integers i, j (1 ≤ i, j ≤ n) such, that ai + bj ≥ x.\n\n## Output\nPrint two space-separated integers — the best and the worst place Vasya could have got on the Olympiad.\n\n## Example\n### Input\n['5 2\\n1 1 1 1 1\\n1 1 1 1 1', '6 7\\n4 3 5 6 4 4\\n8 6 0 4 3 4']\n\n### Output\n['1 5', '1 5']\n\n## Note\nIn the first text sample all 5 participants earn 2 points each in any case. Depending on the jury's decision, Vasya can get the first (the best) as well as the last (the worst) fifth place.In the second test sample in the best case scenario Vasya wins again: he can win 12 points and become the absolute winner if the total results' table looks like that — {4:8, 6:4, 3:6, 4:4, 4:3, 5:0}.In this table all participants are sorted by decreasing points and we can see how much a participant earned in the first and in the second tour.In the worst case scenario Vasya can get the fifth place if the table looks like that — {4:8, 4:6, 6:4, 5:4, 4:3, 3:0}, and he earned 4 and 3 points in the first and second tours, correspondingly.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "**Understanding Vasya's Olympiad Ranking**\n\nOkay, so I'm tackling this Olympiad ranking problem. The core is figuring out the best and worst possible places Vasya could achieve, given only the total scores, not individual participant names. I'm given the number of participants (`n`), Vasya's minimum total score (`x`), and lists of scores from the first (`a`) and second (`b`) tours.  The real challenge is the lack of participant identification; I just know there are *n* scores in each list and that Vasya's total is at least *x*.\n\nThe ranking rules are crucial. Scores are summed, and ties are handled by the jury, allowing arbitrary ranking within a tied group. This means that if Vasya shares a score with several others, his rank can be anywhere within that tie.  My goal is to determine the two extreme ranks: the best (highest) and the worst (lowest) possible outcomes for Vasya.\n\nTo find Vasya's best possible rank, I've got to maximize his total score while minimizing the number of people who score higher.  Since ties are settled arbitrarily, if *P* people score strictly higher than Vasya, his best rank is *P+1*. This means pairing *a* scores with *b* scores such that Vasya's score is as high as possible, and other scores are kept lower than his.\n\nThe lack of names is making this a permutation problem. I need to think in terms of how I can pair the scores in *a* and *b* to optimize Vasya's result. This feels like the key is in finding a permutation of scores in *b* to pair with *a* that creates a set of total scores, where Vasya's total is high, and the totals for the other participants are comparatively lower.  I know Vasya's total score will be at least *x*, so I can use that to restrict the possible combinations I need to consider.\n",
    "response": "The problem asks us to find the best and worst possible ranks for Vasya in an Olympiad, given `n` participants, a minimum total score `x` for Vasya, and two lists of `n` scores each for the first and second tours. The crucial aspect is that we don't know which first-tour score belongs to which second-tour score; we can pair them up arbitrarily. Vasya is one of these participants, and his total score is guaranteed to be at least `x`. Ties are broken by the jury arbitrarily.\n\nLet `a` be the list of scores from the first tour and `b` be the list of scores from the second tour.\n\n### Finding the Best Possible Rank for Vasya\n\nTo achieve the best rank (smallest number), Vasya wants to:\n1. Maximize his own total score.\n2. Minimize the number of participants who score strictly more than him.\n3. If there are ties, the jury can rank Vasya first among participants with the same score.\n\nConsider a scenario where Vasya gets a score `S_V`. His rank will be `1 + (number of participants with score > S_V)`. To minimize this, we want to minimize the count of participants scoring strictly more than `S_V`.\n\nLet's sort `a` in ascending order and `b` in descending order.\n`a_sorted_asc = sorted(a)`\n`b_sorted_desc = sorted(b, reverse=True)`\n\nIf we pair `a_sorted_asc[i]` with `b_sorted_desc[i]` for all `i`, we get `n` participant total scores `s_i = a_sorted_asc[i] + b_sorted_desc[i]`. This pairing strategy is known to maximize the sum of minimums (or minimize the sum of maximums, etc., depending on the exact problem, but it creates a specific distribution of sums).\nIn this specific pairing, the `i`-th largest `a` score is paired with the `i`-th smallest `b` score if both were sorted ascending. Here, we pair `a_i` (small) with `b_i` (large).\n\nConsider the participant who gets the highest possible score. This would be `max(a) + max(b)`. But we can't assign both `max(a)` and `max(b)` to one person if they come from different original participants. The overall maximum possible score for any single participant, given the available scores, is achieved by pairing `max(a)` with `max(b)`. However, other pairings might be better for Vasya.\n\nLet's try a different approach for the best rank. We want Vasya to have a high score, and others to have low scores.\nSort `a` in ascending order: `a_1 <= a_2 <= ... <= a_n`.\nSort `b` in ascending order: `b_1 <= b_2 <= ... <= b_n`.\n\nIf Vasya takes `a_i` and `b_j`, his score is `a_i + b_j`. We know `a_i + b_j >= x`.\nTo maximize Vasya's score, he should take the largest `a` and largest `b` available for him.\nSuppose Vasya takes `a_n` and `b_n`. His score is `a_n + b_n`. If `a_n + b_n < x`, then this pairing is not valid for Vasya.\nThe problem guarantees that there exist `i, j` such that `a_i + b_j >= x`. This implies that Vasya can always achieve at least `x` points.\n\nTo achieve the best rank, Vasya wants to maximize his score. The highest possible score any participant can get is `max(a) + max(b)`. No, this is incorrect. The highest possible score for *any* participant is achieved by pairing the largest `a_i` with the largest `b_j`. However, this is not about *Vasya* taking the absolute largest `a` and `b`. It's about a specific pairing.\n\nLet's reconsider the example: `a = [4, 3, 5, 6, 4, 4]`, `b = [8, 6, 0, 4, 3, 4]`, `x = 7`.\nSorted `a`: `[3, 4, 4, 4, 5, 6]`\nSorted `b`: `[0, 3, 4, 4, 6, 8]`\n\nFor the best case, Vasya wants to maximize his score. The highest possible score for *any* participant is `6 + 8 = 14`. If Vasya gets this, and it's `>= x`, he's potentially 1st.\nThe example output for this case is `1 5`. This means Vasya can get 1st place.\nIn the best case scenario Vasya wins again: he can win 12 points and become the absolute winner if the total results' table looks like that — `{4:8, 6:4, 3:6, 4:4, 4:3, 5:0}`.\nHere, Vasya gets `4+8=12` points. Other scores are `6+4=10`, `3+6=9`, `4+4=8`, `4+3=7`, `5+0=5`. Vasya with 12 points is indeed 1st.\n\nThis suggests that for the best rank, Vasya should take `a_i` and `b_j` such that `a_i + b_j` is maximized, *provided* that `a_i + b_j >= x`.\nThe maximum possible sum for any pair `(a_i, b_j)` is `max(a) + max(b)`. Let `S_max = max(a) + max(b)`. If `S_max >= x`, Vasya can achieve `S_max` points.\nThe question is, can other participants get even higher scores? No, `S_max` is the absolute maximum.\nSo, if Vasya gets `S_max` points, and `S_max >= x`, he is guaranteed to be 1st.\nThe best rank is always 1. This is because Vasya can always be assigned the `a_i` and `b_j` that give the highest possible sum, `max(a) + max(b)`. Since the problem guarantees that Vasya was present and there exist `i, j` such that `a_i + b_j >= x`, Vasya can simply be assigned `max(a)` and `max(b)`. The maximum possible sum for any participant is `max(a) + max(b)`, and if this sum is at least `x`, Vasya can achieve it and thus be first. If `max(a) + max(b) < x`, it would contradict the guarantee, so `max(a) + max(b)` must be at least `x`.\nThus, the best rank is always 1.\n\n### Finding the Worst Possible Rank for Vasya\n\nTo achieve the worst rank (largest number), Vasya wants to:\n1. Minimize his own total score, but it must be at least `x`.\n2. Maximize the number of participants who score strictly more than him.\n3. If there are ties, the jury can rank Vasya last among participants with the same score.\n\nLet's sort `a` in ascending order: `a_1 <= a_2 <= ... <= a_n`.\nLet's sort `b` in ascending order: `b_1 <= b_2 <= ... <= b_n`.\n\nTo make Vasya's score low and other scores high, we should pair the largest `a` scores with the largest `b` scores for other participants, and pair Vasya's scores such that his sum is low but still `a_i + b_j >= x`.\n\nConsider a specific pairing strategy: Pair `a_i` with `b_{n-1-i}` (or `b_{n-i}` depending on 0-based vs 1-based indexing).\nThis is often called an \"anti-pairing\" or \"cross-pairing\" strategy.\n`a_sorted_asc = sorted(a)`\n`b_sorted_asc = sorted(b)`\nWe pair `a_sorted_asc[i]` with `b_sorted_asc[n-1-i]`.\nThe sums would be `s_i = a_sorted_asc[i] + b_sorted_asc[n-1-i]`.\n\nWhy this pairing? Suppose we want to minimize the sum of `k` pairs. We would pick the `k` smallest `a` values and `k` smallest `b` values and pair them `a_i` with `b_i`. This makes `k` small sums.\nTo make `n-1` sums as large as possible and one sum as small as possible (but >= x) for Vasya:\nWe want to find a permutation `p` of `(0, ..., n-1)` such that if Vasya is participant `k`, `a_k + b_{p[k]}` is minimized (but >= x), and `a_i + b_{p[i]}` for `i != k` are maximized.\n\nThis is a classic problem that can be solved with a two-pointer approach or by sorting and using a greedy strategy.\nLet `a` be sorted ascending and `b` be sorted descending.\n`a_asc = sorted(a)`\n`b_desc = sorted(b, reverse=True)`\n\nNow, we want to find a pairing `(a_i, b_j)` for Vasya such that `a_i + b_j >= x`, and for all other `n-1` participants, their scores `a_k + b_l` are maximized.\nThe pairing `(a_asc[i], b_desc[i])` for all `i` creates `n` sums.\nLet's denote `S_i = a_asc[i] + b_desc[i]`.\nIf we pair `a_asc[i]` with `b_desc[i]`, these sums `S_i` represent a possible set of total scores for the participants.\nThe crucial insight here is that for any two pairs `(a_i, b_j)` and `(a_k, b_l)`, if `a_i < a_k` and `b_j < b_l`, then `a_i + b_l` and `a_k + b_j` are \"more balanced\" than `a_i + b_j` and `a_k + b_l`. Specifically, `a_i + b_l + a_k + b_j = a_i + b_j + a_k + b_l`. But the sums `a_i + b_l` and `a_k + b_j` are \"closer\" to each other than `a_i + b_j` and `a_k + b_l`.\nTo maximize the number of people who score `S_V` or more, we want to create a distribution of scores where many people score high, and Vasya's score is just barely `x`.\n\nThe standard approach for finding the worst rank is to sort `a` in ascending order and `b` in ascending order.\n`a_sorted = sorted(a)`\n`b_sorted = sorted(b)`\n\nNow, we want to pair `a_sorted[i]` with some `b_sorted[j]` for Vasya, such that `a_sorted[i] + b_sorted[j] >= x`. And for the other `n-1` participants, we pair the remaining `a` and `b` scores to make as many as possible greater than or equal to Vasya's score.\nTo maximize the number of people who score *at least* Vasya's score, we should try to make other people's scores high.\nThis suggests pairing the largest `a` with the largest `b`, the second largest `a` with the second largest `b`, etc., to create `n` sums.\nLet's try to find how many people can achieve a score `S` or more, given `S`.\nIf we pair `a_sorted[i]` with `b_sorted[j]`, we want `a_sorted[i] + b_sorted[j] >= S`.\nTo count how many pairs `(a_i, b_j)` can sum to at least `S`, we can use a two-pointer approach.\nSort `a` in ascending order. Sort `b` in descending order.\n`a_asc = sorted(a)`\n`b_desc = sorted(b, reverse=True)`\n\nInitialize `count = 0`, `j = 0` (pointer for `b_desc`).\nFor each `a_val` in `a_asc`:\n  While `j < n` and `a_val + b_desc[j] < x`:\n    `j += 1`\n  If `j < n`:\n    This means `a_val + b_desc[j] >= x`. We can form a pair `(a_val, b_desc[j])` that sums to at least `x`.\n    Increment `count`.\n    `j += 1` (This `b_desc[j]` is now used)\n\nThis `count` represents the maximum number of participants whose total score can be at least `x` using the `a_asc` and `b_desc` pairing strategy.\nLet's trace this with an example:\n`a = [4, 3, 5, 6, 4, 4]`, `b = [8, 6, 0, 4, 3, 4]`, `x = 7`.\n`a_asc = [3, 4, 4, 4, 5, 6]`\n`b_desc = [8, 6, 4, 4, 3, 0]`\n\n`count = 0`, `j = 0`\n1. `a_val = 3`:\n   `j = 0`: `3 + b_desc[0] = 3 + 8 = 11 >= 7`. Valid. `count = 1`. `j = 1`.\n2. `a_val = 4`:\n   `j = 1`: `4 + b_desc[1] = 4 + 6 = 10 >= 7`. Valid. `count = 2`. `j = 2`.\n3. `a_val = 4`:\n   `j = 2`: `4 + b_desc[2] = 4 + 4 = 8 >= 7`. Valid. `count = 3`. `j = 3`.\n4. `a_val = 4`:\n   `j = 3`: `4 + b_desc[3] = 4 + 4 = 8 >= 7`. Valid. `count = 4`. `j = 4`.\n5. `a_val = 5`:\n   `j = 4`: `5 + b_desc[4] = 5 + 3 = 8 >= 7`. Valid. `count = 5`. `j = 5`.\n6. `a_val = 6`:\n   `j = 5`: `6 + b_desc[5] = 6 + 0 = 6 < 7`. Invalid. `j` becomes 6.\n   `j = 6`: `j < n` is false. Loop terminates for this `a_val`.\n\nThe final `count` is 5.\nThis means that using this pairing strategy, 5 participants can achieve a score of at least `x`.\nSince Vasya is one of them, and the jury can place him last among those with `x` or more points, his worst rank would be `count`.\nIn this example, the worst rank is 5. This matches the example output `1 5`.\n\nLet's re-verify the logic for the worst rank.\nWe want to maximize the number of participants whose sum of points is `S_k >= x`.\nLet `a` be sorted ascending and `b` be sorted descending.\n`a_asc = [a_0, a_1, ..., a_{n-1}]`\n`b_desc = [b_0, b_1, ..., b_{n-1}]`\n\nWe iterate through `a_asc` with pointer `i` from `0` to `n-1`.\nWe iterate through `b_desc` with pointer `j` from `0` to `n-1`.\nIf `a_asc[i] + b_desc[j] >= x`:\n  We can form a pair `(a_asc[i], b_desc[j])` that meets the minimum score `x`. We count this as one participant.\n  Then we use `a_asc[i]` and `b_desc[j]` and move to `a_asc[i+1]` and `b_desc[j+1]`.\nIf `a_asc[i] + b_desc[j] < x`:\n  This `a_asc[i]` is too small to combine with `b_desc[j]` (which is the largest remaining `b` score available for `a_asc[i]` if we were to try to satisfy `x`).\n  So, `a_asc[i]` cannot form a pair `(a_asc[i], b_desc[k])` that sums to `x` or more for any `k >= j`. This `a_asc[i]` must be paired with some `b_desc[k]` where `k < j`, but those `b_desc[k]` are already used or would be used by smaller `a` values.\n  This specific greedy strategy (pairing smallest `a` with largest `b` that satisfies `x`) counts the maximum number of pairs that can sum to at least `x`.\n\nThe logic is as follows:\nTo maximize the number of pairs `(a_i, b_j)` such that `a_i + b_j >= x`:\n1. Sort `a` in ascending order.\n2. Sort `b` in ascending order.\n3. Use two pointers, `ptr_a` for `a` starting at `0`, and `ptr_b` for `b` starting at `n-1`.\n4. Initialize `count = 0`.\n5. While `ptr_a < n` and `ptr_b >= 0`:\n   If `a[ptr_a] + b[ptr_b] >= x`:\n     We found a pair that sums to at least `x`. We should use `a[ptr_a]` (smallest remaining `a`) and `b[ptr_b]` (largest remaining `b`) to maximize our chances of meeting `x`.\n     Increment `count`.\n     Move `ptr_a` forward (`ptr_a += 1`).\n     Move `ptr_b` backward (`ptr_b -= 1`).\n   Else (`a[ptr_a] + b[ptr_b] < x`):\n     The current `a[ptr_a]` is too small to make a sum `x` even with the largest available `b[ptr_b]`. This `a[ptr_a]` cannot be part of a sum `S >= x` with any remaining `b`.\n     So, we must discard `a[ptr_a]` for the purpose of forming `x`-satisfying pairs.\n     Move `ptr_a` forward (`ptr_a += 1`).\n     (We don't increment `ptr_b` here because `b[ptr_b]` might still be useful for a larger `a[ptr_a+1]`).\n\nThis greedy strategy correctly counts the maximum number of pairs that can sum to at least `x`.\nLet's trace this with the example:\n`a = [4, 3, 5, 6, 4, 4]`, `b = [8, 6, 0, 4, 3, 4]`, `x = 7`.\n`a_sorted = [3, 4, 4, 4, 5, 6]`\n`b_sorted = [0, 3, 4, 4, 6, 8]`\n\n`ptr_a = 0`, `ptr_b = 5`, `count = 0`\n1. `a[0] = 3`, `b[5] = 8`. `3 + 8 = 11 >= 7`.\n   `count = 1`. `ptr_a = 1`. `ptr_b = 4`.\n2. `a[1] = 4`, `b[4] = 6`. `4 + 6 = 10 >= 7`.\n   `count = 2`. `ptr_a = 2`. `ptr_b = 3`.\n3. `a[2] = 4`, `b[3] = 4`. `4 + 4 = 8 >= 7`.\n   `count = 3`. `ptr_a = 3`. `ptr_b = 2`.\n4. `a[3] = 4`, `b[2] = 4`. `4 + 4 = 8 >= 7`.\n   `count = 4`. `ptr_a = 4`. `ptr_b = 1`.\n5. `a[4] = 5`, `b[1] = 3`. `5 + 3 = 8 >= 7`.\n   `count = 5`. `ptr_a = 5`. `ptr_b = 0`.\n6. `a[5] = 6`, `b[0] = 0`. `6 + 0 = 6 < 7`.\n   `ptr_a = 6`.\nLoop terminates because `ptr_a = 6` (which is `n`).\n\nThe final `count` is 5. This is the maximum number of participants (including Vasya) who can achieve a score of at least `x`.\nSince Vasya is one of these `count` participants, and the jury can assign him the worst possible rank among them, his worst rank is `count`.\n\nThis two-pointer strategy is correct and efficient.\n\nFinal Answer Structure:\nBest rank: 1\nWorst rank: Calculate using the two-pointer strategy described above.\n\n```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    # Best possible rank for Vasya is always 1.\n    # Vasya can be assigned the largest possible score (max(a_i) + max(b_j))\n    # which is guaranteed to be >= x (from problem statement).\n    # No other participant can score higher, and in case of ties, Vasya can be placed first.\n    best_rank = 1\n\n    # Worst possible rank for Vasya.\n    # We want to maximize the number of participants (including Vasya) whose total score is >= x.\n    # If 'k' participants achieve a score >= x, Vasya's worst rank among them is 'k'.\n    # To maximize 'k':\n    # Sort 'a' in ascending order.\n    # Sort 'b' in ascending order.\n    # Use a two-pointer approach.\n    \n    a.sort()\n    b.sort()\n\n    count_at_least_x = 0\n    ptr_a = 0\n    ptr_b = n - 1\n\n    while ptr_a < n and ptr_b >= 0:\n        if a[ptr_a] + b[ptr_b] >= x:\n            # This pair (a[ptr_a], b[ptr_b]) can form a sum >= x.\n            # We count this as one participant meeting the criteria.\n            # Move both pointers as these scores are now 'used'.\n            count_at_least_x += 1\n            ptr_a += 1\n            ptr_b -= 1\n        else:\n            # a[ptr_a] is too small to make a sum >= x even with the largest available b[ptr_b].\n            # This means a[ptr_a] cannot be part of any sum >= x with any remaining b values.\n            # So, we effectively 'discard' a[ptr_a] for this purpose and try with the next smallest a.\n            ptr_a += 1\n            # ptr_b remains the same, as b[ptr_b] might be useful for a larger a[ptr_a+1].\n\n    worst_rank = count_at_least_x\n\n    print(best_rank, worst_rank)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    # Best possible rank for Vasya is always 1.\n    # Vasya can be assigned the largest possible score (max(a_i) + max(b_j))\n    # which is guaranteed to be >= x (from problem statement).\n    # No other participant can score higher, and in case of ties, Vasya can be placed first.\n    best_rank = 1\n\n    # Worst possible rank for Vasya.\n    # We want to maximize the number of participants (including Vasya) whose total score is >= x.\n    # If 'k' participants achieve a score >= x, Vasya's worst rank among them is 'k'.\n    # To maximize 'k':\n    # Sort 'a' in ascending order.\n    # Sort 'b' in ascending order.\n    # Use a two-pointer approach.\n    \n    a.sort()\n    b.sort()\n\n    count_at_least_x = 0\n    ptr_a = 0\n    ptr_b = n - 1\n\n    while ptr_a < n and ptr_b >= 0:\n        if a[ptr_a] + b[ptr_b] >= x:\n            # This pair (a[ptr_a], b[ptr_b]) can form a sum >= x.\n            # We count this as one participant meeting the criteria.\n            # Move both pointers as these scores are now 'used'.\n            count_at_least_x += 1\n            ptr_a += 1\n            ptr_b -= 1\n        else:\n            # a[ptr_a] is too small to make a sum >= x even with the largest available b[ptr_b].\n            # This means a[ptr_a] cannot be part of any sum >= x with any remaining b values.\n            # So, we effectively 'discard' a[ptr_a] for this purpose and try with the next smallest a.\n            ptr_a += 1\n            # ptr_b remains the same, as b[ptr_b] might be useful for a larger a[ptr_a+1].\n\n    worst_rank = count_at_least_x\n\n    print(best_rank, worst_rank)\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 863,
        "completion_token_count": 5607,
        "thoughts_token_count": 779
    }
}