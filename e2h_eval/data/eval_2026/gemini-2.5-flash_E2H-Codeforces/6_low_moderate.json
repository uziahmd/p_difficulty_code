{
    "start": 1758009285.7393272,
    "end": 1758009349.611635,
    "start-formatted": "2025-09-16 16:54 KST",
    "end-formatted": "2025-09-16 16:55 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "**Thinking Through a Competitive Programming Problem**\n\nOkay, so I've got this competitive programming problem staring me in the face. The core of it is finding the cheapest pair of non-overlapping vouchers that add up to a specific duration, `x`.  My first instinct is to understand the input and the constraints. We have `n` vouchers, each with a departure day, arrival day, and cost.  I quickly see that the duration of a voucher is simply the arrival day minus the departure day plus one.  The goal is to find two of these things, `i` and `j`, that don't overlap in time and whose durations sum to `x`.  The crucial part is minimizing their combined cost, `cost_i + cost_j`.  If no pair works, the answer is -1.\n\nThe problem seems straightforward enough at first glance, but the constraints are where it gets interesting.  We're talking about up to 200,000 vouchers.  A brute-force approach, checking every possible pair, would be far too slow, a killer `O(n^2)` solution.  I need a much more efficient strategy.  Thinking through the constraints again, both the number of vouchers and the coordinate values are on the scale of 2 x 10^5, and the cost can reach 10^9.\n\nLet's break this down. For each voucher `i`, I need to find the best voucher `j`. The key is that `j`'s duration must be `x` minus `i`'s duration. Additionally, vouchers `i` and `j` must be non-overlapping. This means either `j` must start after `i` ends, or `j` must end before `i` starts. I need a way to efficiently find this best `j` for each `i`, and that is going to be the central challenge.\n\nI started thinking about possible optimizations.  I can't just iterate through all potential pairs since that would be `O(n^2)`. Given the non-overlapping condition, sorting the vouchers by either start or end time seemed like a good starting point. I also noticed that calculating the duration for each voucher would be a good step. Maybe then I could filter the valid matches easily and optimize the selection of `j`.\n\nProcessing the vouchers by duration seems like a good avenue to explore. I'm going to need to figure out a data structure or an algorithm that allows me to quickly look up a voucher of the required duration, while also enforcing that non-overlapping time constraint. This means I'll likely need to maintain some kind of lookup based on duration.\n",
    "response": "The problem asks us to find two non-overlapping vouchers `i` and `j` such that their total duration `(ri - li + 1) + (rj - lj + 1)` is exactly `x`, and their total cost `costi + costj` is minimized. If no such pair exists, we should output -1.\n\nThe constraints are `n, x <= 2 * 10^5` and `li, ri <= 2 * 10^5`. A naive `O(N^2)` approach is too slow. We need something closer to `O(N log N)` or `O(N)`.\n\nLet's analyze the conditions:\n1.  **Duration sum**: `duration_i + duration_j = x`.\n2.  **Non-overlapping**: `ri < lj` or `rj < li`. This means one voucher must entirely finish before the other begins.\n3.  **Minimize cost**: `cost_i + cost_j`.\n\nLet `MAX_COORD = 2 * 10^5`. The maximum `ri` value is `MAX_COORD`.\n\nWe can iterate through all vouchers. For each voucher `i`, we calculate its duration `d_i = ri - li + 1`. Then we need to find a voucher `j` such that `d_j = x - d_i` and `j` does not overlap with `i`, while minimizing `cost_j`.\n\nTo efficiently find such a `j`, we can pre-process or maintain information about available vouchers. A common technique for range queries or interval-based problems is to sort events by their start or end times.\n\nLet's sort all vouchers by their `li` (departure day).\nWhen we process vouchers in increasing order of `li`:\nFor a current voucher `v_i = (l_i, r_i, cost_i)`, we are looking for another voucher `v_j = (l_j, r_j, cost_j)` such that:\n1.  `d_j = x - d_i`.\n2.  `r_j < l_i` (voucher `j` ends before `v_i` starts).\n3.  `cost_j` is minimized.\n\nThe condition `r_j < l_i` means we are looking for vouchers that have *already ended* by the time `v_i` starts. This suggests that as we iterate through vouchers sorted by `l_i`, we can maintain information about all vouchers `v_j` encountered so far that satisfy `r_j < l_i`.\n\nWe can use an array (or a dictionary/hash map) to store the minimum cost for each duration. Let `min_cost_for_duration[d]` be the minimum cost of a voucher with duration `d` that has *already ended* by the current `l_i`.\n\n**Algorithm:**\n\n1.  Initialize `min_total_cost = infinity`.\n2.  Create a list of vouchers, storing them as `(li, ri, costi)`.\n3.  Sort the vouchers by their `li` values. If `li` values are equal, sort by `ri` (or `costi`, doesn't strictly matter for correctness, but can be helpful for consistency).\n4.  Create an array `min_cost_at_end_day[day]` which will store the minimum cost of a voucher that *ends on or before `day`* and has a specific duration. This array will be updated dynamically. Initialize all entries to `infinity`.\n    *   A more precise way: We need `min_cost_for_duration[d]` for vouchers ending by a certain day. This can be achieved by an array `min_cost_ending_by_day[day]` where `min_cost_ending_by_day[day]` stores an array/map of `(duration -> min_cost)`. This is too complex.\n\nA simpler approach for `min_cost_at_end_day`:\nLet `min_cost_for_duration_d_ending_by_day[day]` be an array (or map) that stores the minimum cost of a voucher with duration `d` that ends on `day`.\nThis is still not quite right. We need to query for `min_cost_for_duration[d]` where the voucher ends *before* `l_i`.\n\nLet `min_cost_ending_on_day[day]` be an array where `min_cost_ending_on_day[day][duration]` stores the minimum cost of a voucher that ends *exactly* on `day` and has the given `duration`.\nThis would be `MAX_COORD` arrays, each of size `MAX_COORD`. Too much memory (`(2*10^5)^2`).\n\nLet's refine the idea of `min_cost_at_end_day`:\nWe need to efficiently find `min(cost_j)` for `v_j` such that `r_j < l_i` and `d_j = x - d_i`.\n\nConsider processing vouchers in order of `l_i`.\nWe can maintain an array `min_cost_for_duration[duration]` which stores the minimum cost of a voucher with that `duration` *among all vouchers considered so far that have already ended*.\n\nLet's use `dp[day]` to store the minimum cost of a voucher that ends *on or before* `day` and has a specific duration.\n`dp[day][duration]` would be `min_cost` for a voucher of `duration` ending on or before `day`.\nThis is still too much memory.\n\nThe maximum `r_i` is `2 * 10^5`. Let's call this `MAX_R_DAY`.\nWe can use an array `min_cost_for_duration[duration]` initialized to `infinity`.\nThis array will store the minimum cost for a voucher of a given `duration` that has *already ended* by the current processing day.\n\n**Corrected Algorithm:**\n\n1.  Initialize `min_total_cost = infinity`.\n2.  Create a list of all vouchers. For each voucher `(li, ri, costi)`, calculate its duration `d = ri - li + 1`. Store them as `(li, ri, costi, d)`.\n3.  Group vouchers by their departure day `li`. `vouchers_by_start_day[day]` will be a list of `(ri, costi, d)` for vouchers starting on `day`.\n    *   `vouchers_by_start_day` will be an array of lists, indexed from `1` to `MAX_R_DAY`.\n4.  Initialize an array `min_cost_for_duration[duration]` of size `x + 1` (or `MAX_R_DAY + 1`), filled with `infinity`. This array will store the minimum cost of a voucher with a given `duration` that has *already finished* by the current `current_day`.\n5.  Iterate `current_day` from `1` to `MAX_R_DAY`.\n    a.  **Update `min_cost_for_duration`**: For all vouchers `(r_prev, cost_prev, d_prev)` that *ended on `current_day - 1`*:\n        Update `min_cost_for_duration[d_prev] = min(min_cost_for_duration[d_prev], cost_prev)`.\n        This is still not right. `min_cost_for_duration` should be cumulative.\n\nLet's maintain `min_cost_ending_on_day[day][duration]` as a list of `(cost, duration)` for vouchers ending on `day`.\nThis is still too much.\n\nThe key is that for a voucher `(l_i, r_i, cost_i, d_i)`, we need to find `v_j` such that `r_j < l_i` and `d_j = x - d_i`.\nThis means `v_j` must end at `r_j` where `r_j` is at most `l_i - 1`.\n\nLet's group vouchers by their `l_i`.\n`vouchers_starting_on_day[day]` = list of `(r, cost, duration)` for vouchers starting on `day`.\n`MAX_DAY = 2 * 10^5`.\n\n```python\n# Create a list of lists for vouchers starting on each day\n# vouchers_starting_on_day[d] will contain (r, cost, duration) for vouchers starting on day d\nMAX_DAY = 2 * 10**5\nvouchers_starting_on_day = [[] for _ in range(MAX_DAY + 1)]\n\nfor _ in range(n):\n    l, r, cost = map(int, sys.stdin.readline().split())\n    duration = r - l + 1\n    vouchers_starting_on_day[l].append((r, cost, duration))\n\n# min_cost_for_duration[d] stores the minimum cost of a voucher\n# that has duration 'd' AND has already ended by the current 'day'\n# This array will be updated as we sweep through days.\nmin_cost_for_duration = [float('inf')] * (MAX_DAY + 1) # duration can be up to MAX_DAY\n\nmin_total_cost = float('inf')\n\n# Iterate through each possible start day\nfor current_day in range(1, MAX_DAY + 1):\n    # Phase 1: For all vouchers that *end on (current_day - 1)*,\n    # update min_cost_for_duration.\n    # We need to efficiently find vouchers that ended on current_day - 1.\n    # This requires another grouping or processing.\n\n    # Let's consider vouchers that end on (current_day - 1).\n    # We need a data structure that stores vouchers based on their end day.\n    # E.g., vouchers_ending_on_day[day] = list of (cost, duration)\n    # This implies we need to iterate over all vouchers again or pre-process.\n\n    # A better approach:\n    # Iterate `current_day` from 1 to MAX_DAY.\n    # At each `current_day`:\n    # 1. Update `min_cost_for_duration` for vouchers that *ended on `current_day - 1`*.\n    #    This means we need to know what vouchers ended on `current_day - 1`.\n    #    We can use a temporary list `vouchers_ending_today` for this.\n    # 2. For each voucher `(r_i, cost_i, d_i)` starting on `current_day`:\n    #    a. Calculate `d_j_needed = x - d_i`.\n    #    b. If `d_j_needed > 0` and `d_j_needed <= MAX_DAY`:\n    #       `current_min_cost_j = min_cost_for_duration[d_j_needed]`\n    #       If `current_min_cost_j` is not infinity, update `min_total_cost = min(min_total_cost, cost_i + current_min_cost_j)`.\n    #    c. Add `(r_i, cost_i, d_i)` to a list of vouchers that will end on `r_i`.\n    #       This list can be `vouchers_ending_on_day[r_i]`.\n\n# Let's refine the data structures:\n# vouchers_by_start_day[l] = list of (r, cost, duration)\n# vouchers_by_end_day[r] = list of (cost, duration)\n```\n\n**Final Algorithm (Sweep-line approach):**\n\n1.  Initialize `min_total_cost = float('inf')`.\n2.  Create `vouchers_by_start_day = [[] for _ in range(MAX_DAY + 1)]`.\n    For each input voucher `(l, r, cost)`:\n    Calculate `duration = r - l + 1`.\n    Add `(r, cost, duration)` to `vouchers_by_start_day[l]`.\n3.  Initialize `min_cost_for_duration_ending_before_current_day[d]` to `float('inf')` for `d` from `1` to `x`. This array will store the minimum cost of a voucher with duration `d` that *has already finished* before `current_day`.\n    *   Note: `min_cost_for_duration` needs to be able to store costs for durations up to `x`. Since `x` can be `2 * MAX_DAY`, and individual voucher duration is `MAX_DAY`, `x - d_i` can also be `MAX_DAY`. So size `MAX_DAY + 1` is sufficient.\n\n4.  Iterate `current_day` from `1` to `MAX_DAY`.\n    a.  **Process vouchers starting on `current_day`**:\n        For each voucher `(r_i, cost_i, d_i)` in `vouchers_by_start_day[current_day]`:\n            i.  Calculate `d_j_needed = x - d_i`.\n            ii. If `d_j_needed > 0` and `d_j_needed <= MAX_DAY`:\n                `current_min_cost_j = min_cost_for_duration_ending_before_current_day[d_j_needed]`\n                If `current_min_cost_j` is not `float('inf')`:\n                    `min_total_cost = min(min_total_cost, cost_i + current_min_cost_j)`.\n    b.  **Update `min_cost_for_duration_ending_before_current_day`**:\n        For each voucher `(r_i, cost_i, d_i)` in `vouchers_by_start_day[current_day]`:\n            The voucher `(current_day, r_i, cost_i)` ends on `r_i`.\n            When `current_day` reaches `r_i + 1`, this voucher will be \"available\" to pair with others.\n            So, we need to update `min_cost_for_duration_ending_before_current_day[d_i]` with `cost_i` *at day `r_i + 1`*.\n            This means we need to \"schedule\" updates.\n\nLet `min_cost_for_duration_at_day[day][duration]` be the minimum cost of a voucher of `duration` that ends *exactly* on `day`. This is too much memory.\n\nInstead, `min_cost_for_duration_ending_by_day[duration]` should store the minimum cost of a voucher with `duration` that ends *on or before* `current_day`.\nThis is exactly what we need.\n\n**Revised Sweep-line Algorithm:**\n\n1.  Initialize `min_total_cost = float('inf')`.\n2.  Create `vouchers_by_start_day = [[] for _ in range(MAX_DAY + 1)]`.\n    For each input voucher `(l, r, cost)`:\n    Calculate `duration = r - l + 1`.\n    Add `(r, cost, duration)` to `vouchers_by_start_day[l]`.\n3.  Initialize `min_cost_for_duration_ending_on_or_before_current_day[d]` to `float('inf')` for `d` from `1` to `MAX_DAY`. This array will store the minimum cost of a voucher with duration `d` that *ends on or before `current_day - 1`*.\n    *   This array will be updated at the end of each `current_day` loop iteration, considering vouchers that end on `current_day - 1`.\n\n4.  Initialize `min_cost_for_duration_ending_on_current_day[d]` to `float('inf')` for `d` from `1` to `MAX_DAY`. This array will temporarily store the minimum cost of a voucher with duration `d` that *ends exactly on `current_day`*.\n\n5.  Iterate `current_day` from `1` to `MAX_DAY`.\n    a.  **Update `min_cost_for_duration_ending_on_or_before_current_day`**:\n        For each `d` from `1` to `MAX_DAY`:\n            `min_cost_for_duration_ending_on_or_before_current_day[d] = min(min_cost_for_duration_ending_on_or_before_current_day[d], min_cost_for_duration_ending_on_current_day[d])`\n        After this step, `min_cost_for_duration_ending_on_or_before_current_day[d]` contains the minimum cost of a voucher with duration `d` that ends on or before `current_day - 1`.\n        Reset `min_cost_for_duration_ending_on_current_day` for the next iteration.\n\n    b.  **Process vouchers starting on `current_day`**:\n        For each voucher `(r_i, cost_i, d_i)` in `vouchers_by_start_day[current_day]`:\n            i.  Calculate `d_j_needed = x - d_i`.\n            ii. If `d_j_needed > 0` and `d_j_needed <= MAX_DAY`:\n                `current_min_cost_j = min_cost_for_duration_ending_on_or_before_current_day[d_j_needed]`\n                If `current_min_cost_j` is not `float('inf')`:\n                    `min_total_cost = min(min_total_cost, cost_i + current_min_cost_j)`.\n            iii. This voucher `(current_day, r_i, cost_i)` ends on `r_i`. We need to make its cost available for durations that end on `r_i`.\n                Update `min_cost_for_duration_ending_on_current_day[d_i] = min(min_cost_for_duration_ending_on_current_day[d_i], cost_i)`.\n                *This is wrong.* `min_cost_for_duration_ending_on_current_day` should be for vouchers ending on `current_day`.\n                The voucher `(current_day, r_i, cost_i)` ends on `r_i`. We need to update its cost for `duration d_i` at `r_i`.\n\n**Corrected Sweep-line Algorithm (using two arrays for updates):**\n\n1.  Initialize `min_total_cost = float('inf')`.\n2.  Create `vouchers_by_start_day = [[] for _ in range(MAX_DAY + 1)]`.\n    For each input voucher `(l, r, cost)`:\n    Calculate `duration = r - l + 1`.\n    Add `(r, cost, duration)` to `vouchers_by_start_day[l]`.\n3.  Initialize `min_cost_for_duration_ending_before_current_day = [float('inf')] * (MAX_DAY + 1)`.\n    This array stores `min_cost(d)` for vouchers with duration `d` that end strictly before `current_day`.\n\n4.  Iterate `current_day` from `1` to `MAX_DAY`.\n    a.  **For vouchers starting on `current_day`**:\n        For each voucher `(r_i, cost_i, d_i)` in `vouchers_by_start_day[current_day]`:\n            i.  Calculate `d_j_needed = x - d_i`.\n            ii. If `1 <= d_j_needed <= MAX_DAY`:\n                `current_min_cost_j = min_cost_for_duration_ending_before_current_day[d_j_needed]`\n                If `current_min_cost_j` is not `float('inf')`:\n                    `min_total_cost = min(min_total_cost, cost_i + current_min_cost_j)`.\n    b.  **Update `min_cost_for_duration_ending_before_current_day`**:\n        For each voucher `(r_i, cost_i, d_i)` in `vouchers_by_start_day[current_day]`:\n            If `r_i < MAX_DAY`: # If this voucher ends before the last possible day\n                # This voucher ends on `r_i`. Its cost becomes available for\n                # future `current_day` iterations. Specifically, it can be\n                # paired with a voucher starting on `r_i + 1` or later.\n                # So, when `current_day` reaches `r_i + 1`, this voucher\n                # should be included in `min_cost_for_duration_ending_before_current_day`.\n                # This means we need to update `min_cost_for_duration_ending_before_current_day[d_i]`\n                # at `r_i + 1`.\n                # This is a delayed update.\n                `min_cost_for_duration_ending_before_current_day[d_i]` should be updated using\n                `cost_i` at `r_i + 1`.\n\nThis structure needs `min_cost_for_duration_ending_before_current_day` to be updated with values from `current_day - 1`.\n\nLet `min_cost_ending_on_or_before_day[duration]` represent the minimum cost of a voucher of that `duration` that ends on or before `day`.\n\n**Final (and correct) Algorithm:**\n\n1.  Initialize `min_total_cost = float('inf')`.\n2.  Create `vouchers_by_start_day = [[] for _ in range(MAX_DAY + 1)]`.\n    For each input voucher `(l, r, cost)`:\n    Calculate `duration = r - l + 1`.\n    Add `(r, cost, duration)` to `vouchers_by_start_day[l]`.\n3.  Initialize `min_cost_for_duration_ending_before_current_day = [float('inf')] * (MAX_DAY + 1)`.\n    This array stores `min_cost(d)` for vouchers with duration `d` that have *finished* by `current_day - 1`.\n\n4.  Iterate `current_day` from `1` to `MAX_DAY`.\n    a.  **Update `min_cost_for_duration_ending_before_current_day`**:\n        For each voucher `(r_prev, cost_prev, d_prev)` that *started on `current_day - 1`*:\n            If `r_prev == current_day - 1`:  # This voucher ended on `current_day - 1`\n                `min_cost_for_duration_ending_before_current_day[d_prev] = min(min_cost_for_duration_ending_before_current_day[d_prev], cost_prev)`\n        *This is still not right. We need to iterate through `vouchers_by_start_day[current_day - 1]` and check `r_prev`.*\n\nA simpler way to manage the `min_cost_for_duration_ending_before_current_day` array is to update it with values from `current_day-1`'s end.\n\nLet `current_min_costs[d]` be the minimum cost of a voucher with duration `d` that has *finished* by `current_day - 1`.\nLet `next_min_costs[d]` be the minimum cost of a voucher with duration `d` that has *finished* by `current_day`.\n\n```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n\n    MAX_DAY = 2 * 10**5\n\n    # vouchers_by_start_day[l] stores a list of (r, cost, duration) for vouchers starting on day l\n    vouchers_by_start_day = [[] for _ in range(MAX_DAY + 1)]\n    \n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        duration = r - l + 1\n        vouchers_by_start_day[l].append((r, cost, duration))\n\n    # min_cost_for_duration[d] stores the minimum cost of a voucher\n    # with duration 'd' that has finished *before* the current_day.\n    # This array is updated as we sweep through the days.\n    min_cost_for_duration_ending_before_current_day = [float('inf')] * (MAX_DAY + 1)\n    \n    min_total_cost = float('inf')\n\n    # Iterate through each possible start day\n    for current_day in range(1, MAX_DAY + 1):\n        # Step 1: Process vouchers that started on `current_day`.\n        # For each such voucher, try to find a suitable preceding voucher.\n        for r_i, cost_i, d_i in vouchers_by_start_day[current_day]:\n            d_j_needed = x - d_i\n            \n            # Check if d_j_needed is a valid duration\n            if 1 <= d_j_needed <= MAX_DAY:\n                current_min_cost_j = min_cost_for_duration_ending_before_current_day[d_j_needed]\n                if current_min_cost_j != float('inf'):\n                    min_total_cost = min(min_total_cost, cost_i + current_min_cost_j)\n        \n        # Step 2: Update `min_cost_for_duration_ending_before_current_day`\n        # for the *next* iteration.\n        # Vouchers that end on `current_day` will be available for pairing\n        # with vouchers starting on `current_day + 1` or later.\n        # So, for each voucher `(r, cost, d)` that started on `current_day`,\n        # if it ends on `current_day`, its cost should be considered for `d`.\n        # This is where the logic needs to be careful.\n        # We need to update `min_cost_for_duration_ending_before_current_day[d]`\n        # with costs of vouchers that end on `current_day`.\n        \n        # This means, for each voucher (l,r,cost,d) where r == current_day,\n        # we should update min_cost_for_duration_ending_before_current_day[d].\n        # But we only have vouchers_by_start_day.\n        # So, we need to iterate through all vouchers that started on `current_day`\n        # and update `min_cost_for_duration_ending_before_current_day[d]` for those\n        # that end on `current_day`.\n        \n        # The correct way to update min_cost_for_duration_ending_before_current_day\n        # is to take into account all vouchers that *ended* on `current_day - 1`.\n        # This requires another list `vouchers_by_end_day`.\n\n    # Let's try again with vouchers_by_end_day\n    vouchers_by_end_day = [[] for _ in range(MAX_DAY + 1)]\n    for l_val in range(1, MAX_DAY + 1):\n        for r_val, cost_val, duration_val in vouchers_by_start_day[l_val]:\n            vouchers_by_end_day[r_val].append((cost_val, duration_val))\n\n    # Reset vouchers_by_start_day as it's no longer needed in this structure\n    # (or rather, it's used in step 1, but we need to ensure the state is correct)\n    # The sweep line approach is usually:\n    # 1. Process events at current_day (e.g., vouchers starting).\n    # 2. Update data structures based on events at current_day (e.g., vouchers ending).\n    \n    min_cost_for_duration = [float('inf')] * (MAX_DAY + 1)\n    min_total_cost = float('inf')\n\n    for current_day in range(1, MAX_DAY + 1):\n        # Phase 1: Update `min_cost_for_duration` based on vouchers that *ended* on `current_day - 1`.\n        # These vouchers are now available for pairing with vouchers starting on `current_day` or later.\n        # The `min_cost_for_duration` array holds the minimum cost for a given duration\n        # among all vouchers that have ended *on or before* `current_day - 1`.\n        if current_day > 1:\n            for cost_prev, d_prev in vouchers_by_end_day[current_day - 1]:\n                min_cost_for_duration[d_prev] = min(min_cost_for_duration[d_prev], cost_prev)\n\n        # Phase 2: For each voucher `v_i` starting on `current_day`, try to find a pair `v_j`.\n        for r_i, cost_i, d_i in vouchers_by_start_day[current_day]:\n            d_j_needed = x - d_i\n            if 1 <= d_j_needed <= MAX_DAY:\n                current_min_cost_j = min_cost_for_duration[d_j_needed]\n                if current_min_cost_j != float('inf'):\n                    min_total_cost = min(min_total_cost, cost_i + current_min_cost_j)\n\n    if min_total_cost == float('inf'):\n        print(\"-1\")\n    else:\n        print(min_total_cost)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n\n    MAX_DAY = 2 * 10**5\n\n    # vouchers_by_start_day[l] stores a list of (r, cost, duration) for vouchers starting on day l\n    vouchers_by_start_day = [[] for _ in range(MAX_DAY + 1)]\n    \n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        duration = r - l + 1\n        vouchers_by_start_day[l].append((r, cost, duration))\n\n    # min_cost_for_duration[d] stores the minimum cost of a voucher\n    # with duration 'd' that has finished *before* the current_day.\n    # This array is updated as we sweep through the days.\n    min_cost_for_duration_ending_before_current_day = [float('inf')] * (MAX_DAY + 1)\n    \n    min_total_cost = float('inf')\n\n    # Iterate through each possible start day\n    for current_day in range(1, MAX_DAY + 1):\n        # Step 1: Process vouchers that started on `current_day`.\n        # For each such voucher, try to find a suitable preceding voucher.\n        for r_i, cost_i, d_i in vouchers_by_start_day[current_day]:\n            d_j_needed = x - d_i\n            \n            # Check if d_j_needed is a valid duration\n            if 1 <= d_j_needed <= MAX_DAY:\n                current_min_cost_j = min_cost_for_duration_ending_before_current_day[d_j_needed]\n                if current_min_cost_j != float('inf'):\n                    min_total_cost = min(min_total_cost, cost_i + current_min_cost_j)\n        \n        # Step 2: Update `min_cost_for_duration_ending_before_current_day`\n        # for the *next* iteration.\n        # Vouchers that end on `current_day` will be available for pairing\n        # with vouchers starting on `current_day + 1` or later.\n        # So, for each voucher `(r, cost, d)` that started on `current_day`,\n        # if it ends on `current_day`, its cost should be considered for `d`.\n        # This is where the logic needs to be careful.\n        # We need to update `min_cost_for_duration_ending_before_current_day[d]`\n        # with costs of vouchers that end on `current_day`.\n        \n        # This means, for each voucher (l,r,cost,d) where r == current_day,\n        # we should update min_cost_for_duration_ending_before_current_day[d].\n        # But we only have vouchers_by_start_day.\n        # So, we need to iterate through all vouchers that started on `current_day`\n        # and update `min_cost_for_duration_ending_before_current_day[d]` for those\n        # that end on `current_day`.\n        \n        # The correct way to update min_cost_for_duration_ending_before_current_day\n        # is to take into account all vouchers that *ended* on `current_day - 1`.\n        # This requires another list `vouchers_by_end_day`.\n\n    # Let's try again with vouchers_by_end_day\n    vouchers_by_end_day = [[] for _ in range(MAX_DAY + 1)]\n    for l_val in range(1, MAX_DAY + 1):\n        for r_val, cost_val, duration_val in vouchers_by_start_day[l_val]:\n            vouchers_by_end_day[r_val].append((cost_val, duration_val))\n\n    # Reset vouchers_by_start_day as it's no longer needed in this structure\n    # (or rather, it's used in step 1, but we need to ensure the state is correct)\n    # The sweep line approach is usually:\n    # 1. Process events at current_day (e.g., vouchers starting).\n    # 2. Update data structures based on events at current_day (e.g., vouchers ending).\n    \n    min_cost_for_duration = [float('inf')] * (MAX_DAY + 1)\n    min_total_cost = float('inf')\n\n    for current_day in range(1, MAX_DAY + 1):\n        # Phase 1: Update `min_cost_for_duration` based on vouchers that *ended* on `current_day - 1`.\n        # These vouchers are now available for pairing with vouchers starting on `current_day` or later.\n        # The `min_cost_for_duration` array holds the minimum cost for a given duration\n        # among all vouchers that have ended *on or before* `current_day - 1`.\n        if current_day > 1:\n            for cost_prev, d_prev in vouchers_by_end_day[current_day - 1]:\n                min_cost_for_duration[d_prev] = min(min_cost_for_duration[d_prev], cost_prev)\n\n        # Phase 2: For each voucher `v_i` starting on `current_day`, try to find a pair `v_j`.\n        for r_i, cost_i, d_i in vouchers_by_start_day[current_day]:\n            d_j_needed = x - d_i\n            if 1 <= d_j_needed <= MAX_DAY:\n                current_min_cost_j = min_cost_for_duration[d_j_needed]\n                if current_min_cost_j != float('inf'):\n                    min_total_cost = min(min_total_cost, cost_i + current_min_cost_j)\n\n    if min_total_cost == float('inf'):\n        print(\"-1\")\n    else:\n        print(min_total_cost)\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 799,
        "completion_token_count": 6891,
        "thoughts_token_count": 736
    }
}