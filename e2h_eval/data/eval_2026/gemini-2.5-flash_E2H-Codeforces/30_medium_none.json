{
    "start": 1758295103.5903513,
    "end": 1758295150.7938337,
    "start-formatted": "2025-09-20 00:18 KST",
    "end-formatted": "2025-09-20 00:19 KST",
    "gpu": 2,
    "pid": 30,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# TV Game\n\nThere is a new TV game on BerTV. In this game two players get a number A consisting of 2n digits. Before each turn players determine who will make the next move. Each player should make exactly n moves. On it's turn i-th player takes the leftmost digit of A and appends it to his or her number Si. After that this leftmost digit is erased from A. Initially the numbers of both players (S1 and S2) are «empty». Leading zeroes in numbers A, S1, S2 are allowed. In the end of the game the first player gets S1 dollars, and the second gets S2 dollars.One day Homer and Marge came to play the game. They managed to know the number A beforehand. They want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize. Help them.\n\n## Input\nThe first line contains integer n (1 ≤ n ≤ 18). The second line contains integer A consisting of exactly 2n digits. This number can have leading zeroes.\n\n## Output\nOutput the line of 2n characters «H» and «M» — the sequence of moves of Homer and Marge, which gives them maximum possible total prize. Each player must make exactly n moves. If there are several solutions, output any of them.\n\n## Example\n### Input\n['2\\n1234', '2\\n9911']\n\n### Output\n['HHMM', 'HMHM']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "**Problem Breakdown and DP Formulation**\n\nOkay, so I'm tackling this \"TV Game\" problem. The core is figuring out the best sequence of moves (Homer 'H' and Marge 'M') to maximize their combined scores. I've got a string of digits, and each player grabs one at a time from the left.  The tricky part is that the position of a digit within a player's number significantly impacts its value due to the place values (units, tens, hundreds, etc.).  Essentially, I need to figure out the right sequence to achieve the maximum sum.\n\nThe example gave me an insight. `HHMM` for \"1234\" is optimal, and that's the key.  I started by exploring different move sequences, calculating sums for each.  This highlighted the importance of a dynamic programming (DP) approach.\n\nI started to think about DP states, let `dp[i][h_count][m_count]` as the current state, and initially went down a rabbit hole trying to capture the current numbers themselves.  It didn't work because `S1` and `S2` can become gigantic.  I then thought of ways to calculate the contribution of a digit based on its original index, but it was just hard.\n\nAfter that, I thought `dp[h][m]` stores the max sum of the prizes, with `h` being the number of digits Homer takes, and `m` is the number of digits Marge takes.  It means the total processed digits is `h+m`. I considered `dp[h][m] = max(dp[h-1][m] + contribution from Homer take, dp[h][m-1] + contribution from Marge take)`.  And I realized that, with this, I also need to track if Homer or Marge took the digit.\n\nOkay, let's nail down this DP formulation.  I'll define `dp[h][m]` as the maximum total prize after Homer has taken `h` digits and Marge has taken `m` digits. The digits are taken one-by-one from the front. `dp[0][0]` will be the base case with a value of 0. Now the transition is pretty clean. When calculating `dp[h][m]`, I look at the (h+m)-th digit, then add the contribution to `dp[h][m]` based on who takes the digit - Homer (h+m-1)-th or Marge(h+m-1)-th digit.\n\nFinally, the contribution is digit-val * 10^(number of digits after it in player's number) , so `digit_val * 10^(n - h) `or `digit_val * 10^(n-m)`. I'll initialize a path table as well to re-construct the solution at the end. The final solution is then stored in `dp[n][n]`. With this, I can start to write code!\n",
    "response": "```python\nimport sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n    a_str = sys.stdin.readline().strip()\n\n    # dp[h][m] stores the maximum total prize (S1 + S2)\n    # after Homer has taken 'h' digits and Marge has taken 'm' digits.\n    # The total number of digits processed from A is h + m.\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n\n    # path[h][m] stores 'H' if Homer took the (h+m-1)-th digit to reach this state,\n    # or 'M' if Marge took it. Used for reconstructing the sequence.\n    path = [[''] * (n + 1) for _ in range(n + 1)]\n\n    # Base case: No digits taken, total prize is 0.\n    dp[0][0] = 0\n\n    # Precompute powers of 10 for efficiency\n    # powers_of_10[k] = 10^k\n    # A digit taken as the k-th digit (0-indexed) by a player\n    # contributes digit_val * 10^(n - 1 - k) to their number.\n    # In our DP, h and m are 1-indexed counts.\n    # If Homer takes his h-th digit, it contributes digit_val * 10^(n - h).\n    # If Marge takes her m-th digit, it contributes digit_val * 10^(n - m).\n    \n    # Max n is 18, so max power is 10^17. Python handles large integers automatically.\n    \n    for h in range(n + 1):\n        for m in range(n + 1):\n            # Skip the base case (already handled)\n            if h == 0 and m == 0:\n                continue\n\n            # current_digit_idx is the index in the original string A\n            # of the digit being considered for assignment to reach state (h, m).\n            # If h digits for Homer and m digits for Marge have been assigned,\n            # then (h+m) total digits have been assigned.\n            # The digit being considered is A[h+m-1].\n            current_digit_idx = h + m - 1\n\n            # If current_digit_idx is out of bounds for A, or if we've already taken 2n digits,\n            # or if the current state (h,m) is not yet reachable from (0,0)\n            if current_digit_idx >= 2 * n or current_digit_idx < 0:\n                continue\n            \n            digit_val = int(a_str[current_digit_idx])\n\n            val_from_homer_prev = -1 # Max prize if Homer took current digit\n            val_from_marge_prev = -1 # Max prize if Marge took current digit\n\n            # Option 1: Homer takes the current digit\n            # This means we came from state (h-1, m)\n            if h > 0 and dp[h - 1][m] != -1:\n                # This is Homer's h-th digit. It contributes 10^(n-h).\n                contribution = digit_val * (10**(n - h))\n                val_from_homer_prev = dp[h - 1][m] + contribution\n\n            # Option 2: Marge takes the current digit\n            # This means we came from state (h, m-1)\n            if m > 0 and dp[h][m - 1] != -1:\n                # This is Marge's m-th digit. It contributes 10^(n-m).\n                contribution = digit_val * (10**(n - m))\n                val_from_marge_prev = dp[h][m - 1] + contribution\n\n            # Update dp[h][m] and path[h][m] based on which option gives a higher total prize\n            if val_from_homer_prev == -1 and val_from_marge_prev == -1:\n                # This state is unreachable\n                dp[h][m] = -1\n            elif val_from_homer_prev >= val_from_marge_prev:\n                # Homer's option is better or equal (tie-break for Homer)\n                dp[h][m] = val_from_homer_prev\n                path[h][m] = 'H'\n            else:\n                # Marge's option is better\n                dp[h][m] = val_from_marge_prev\n                path[h][m] = 'M'\n\n    # Reconstruct the optimal sequence of moves\n    result_sequence = []\n    current_h, current_m = n, n\n    while current_h > 0 or current_m > 0:\n        move = path[current_h][current_m]\n        result_sequence.append(move)\n        if move == 'H':\n            current_h -= 1\n        elif move == 'M':\n            current_m -= 1\n        else:\n            # Should not happen if DP is correct and path is always set\n            break\n\n    # The sequence is built in reverse order, so reverse it for final output\n    print(\"\".join(reversed(result_sequence)))\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n    a_str = sys.stdin.readline().strip()\n\n    # dp[h][m] stores the maximum total prize (S1 + S2)\n    # after Homer has taken 'h' digits and Marge has taken 'm' digits.\n    # The total number of digits processed from A is h + m.\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n\n    # path[h][m] stores 'H' if Homer took the (h+m-1)-th digit to reach this state,\n    # or 'M' if Marge took it. Used for reconstructing the sequence.\n    path = [[''] * (n + 1) for _ in range(n + 1)]\n\n    # Base case: No digits taken, total prize is 0.\n    dp[0][0] = 0\n\n    # Precompute powers of 10 for efficiency\n    # powers_of_10[k] = 10^k\n    # A digit taken as the k-th digit (0-indexed) by a player\n    # contributes digit_val * 10^(n - 1 - k) to their number.\n    # In our DP, h and m are 1-indexed counts.\n    # If Homer takes his h-th digit, it contributes digit_val * 10^(n - h).\n    # If Marge takes her m-th digit, it contributes digit_val * 10^(n - m).\n    \n    # Max n is 18, so max power is 10^17. Python handles large integers automatically.\n    \n    for h in range(n + 1):\n        for m in range(n + 1):\n            # Skip the base case (already handled)\n            if h == 0 and m == 0:\n                continue\n\n            # current_digit_idx is the index in the original string A\n            # of the digit being considered for assignment to reach state (h, m).\n            # If h digits for Homer and m digits for Marge have been assigned,\n            # then (h+m) total digits have been assigned.\n            # The digit being considered is A[h+m-1].\n            current_digit_idx = h + m - 1\n\n            # If current_digit_idx is out of bounds for A, or if we've already taken 2n digits,\n            # or if the current state (h,m) is not yet reachable from (0,0)\n            if current_digit_idx >= 2 * n or current_digit_idx < 0:\n                continue\n            \n            digit_val = int(a_str[current_digit_idx])\n\n            val_from_homer_prev = -1 # Max prize if Homer took current digit\n            val_from_marge_prev = -1 # Max prize if Marge took current digit\n\n            # Option 1: Homer takes the current digit\n            # This means we came from state (h-1, m)\n            if h > 0 and dp[h - 1][m] != -1:\n                # This is Homer's h-th digit. It contributes 10^(n-h).\n                contribution = digit_val * (10**(n - h))\n                val_from_homer_prev = dp[h - 1][m] + contribution\n\n            # Option 2: Marge takes the current digit\n            # This means we came from state (h, m-1)\n            if m > 0 and dp[h][m - 1] != -1:\n                # This is Marge's m-th digit. It contributes 10^(n-m).\n                contribution = digit_val * (10**(n - m))\n                val_from_marge_prev = dp[h][m - 1] + contribution\n\n            # Update dp[h][m] and path[h][m] based on which option gives a higher total prize\n            if val_from_homer_prev == -1 and val_from_marge_prev == -1:\n                # This state is unreachable\n                dp[h][m] = -1\n            elif val_from_homer_prev >= val_from_marge_prev:\n                # Homer's option is better or equal (tie-break for Homer)\n                dp[h][m] = val_from_homer_prev\n                path[h][m] = 'H'\n            else:\n                # Marge's option is better\n                dp[h][m] = val_from_marge_prev\n                path[h][m] = 'M'\n\n    # Reconstruct the optimal sequence of moves\n    result_sequence = []\n    current_h, current_m = n, n\n    while current_h > 0 or current_m > 0:\n        move = path[current_h][current_m]\n        result_sequence.append(move)\n        if move == 'H':\n            current_h -= 1\n        elif move == 'M':\n            current_m -= 1\n        else:\n            # Should not happen if DP is correct and path is always set\n            break\n\n    # The sequence is built in reverse order, so reverse it for final output\n    print(\"\".join(reversed(result_sequence)))\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 422,
        "completion_token_count": 1244,
        "thoughts_token_count": 6437
    }
}