{
    "start": 1758293726.8025537,
    "end": 1758293794.6423206,
    "start-formatted": "2025-09-19 23:55 KST",
    "end-formatted": "2025-09-19 23:56 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "",
    "response": "```python\nimport sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    adj = [[] for _ in range(n + 1)]\n    edges_set = set()\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n        edges_set.add(tuple(sorted((u, v))))\n\n    # Check for existing odd cycle (t=0)\n    # Use BFS for 2-coloring to detect odd cycles\n    colors = [-1] * (n + 1) # -1: unvisited, 0: color 0, 1: color 1\n    has_odd_cycle = False\n\n    for i in range(1, n + 1):\n        if colors[i] == -1:\n            q = [(i, 0)] # (vertex, color)\n            colors[i] = 0\n            head = 0\n            while head < len(q):\n                u, u_color = q[head]\n                head += 1\n\n                for v in adj[u]:\n                    if colors[v] == -1:\n                        colors[v] = 1 - u_color\n                        q.append((v, 1 - u_color))\n                    elif colors[v] == u_color:\n                        has_odd_cycle = True\n                        break\n                if has_odd_cycle:\n                    break\n        if has_odd_cycle:\n            break\n\n    if has_odd_cycle:\n        print(\"0 1\")\n        return\n\n    # No existing odd cycle, graph is bipartite\n    # t=1: Add one edge to form an odd cycle\n    # An odd cycle can be formed by adding an edge between two vertices of the same color in a connected component.\n    # Since the graph is bipartite, all existing edges connect vertices of different colors.\n    # Adding an edge (u, v) where u and v have the same color will create an odd cycle.\n    # We need to find two vertices u, v (u != v) such that (u, v) is not an existing edge, and colors[u] == colors[v].\n    # The minimum t is 1 if such an edge exists.\n    # The number of ways w is the count of such non-existent edges.\n\n    # Re-run BFS to get colors for all components and count nodes in each color set.\n    colors = [-1] * (n + 1)\n    visited = [False] * (n + 1)\n    \n    ways_t1 = 0\n    \n    for i in range(1, n + 1):\n        if not visited[i]:\n            component_nodes = []\n            q = [i]\n            visited[i] = True\n            colors[i] = 0\n            head = 0\n            \n            while head < len(q):\n                u = q[head]\n                head += 1\n                component_nodes.append(u)\n\n                for v in adj[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        colors[v] = 1 - colors[u]\n                        q.append(v)\n                    elif colors[v] == colors[u]: # Should not happen if graph is bipartite\n                        # This branch should not be reached if has_odd_cycle was false\n                        pass\n\n            # Count same-color pairs within this component\n            color_counts = [0, 0]\n            for node in component_nodes:\n                color_counts[colors[node]] += 1\n            \n            # Number of ways to add an edge within this component to create an odd cycle\n            # is (count_color0 * (count_color0 - 1) / 2) + (count_color1 * (count_color1 - 1) / 2)\n            # This counts pairs of distinct vertices of the same color.\n            # We must subtract existing edges between these pairs.\n            # However, since the graph is bipartite, there are no existing edges between same-colored vertices.\n            # So, we just need to sum up the combinations.\n            ways_t1 += (color_counts[0] * (color_counts[0] - 1)) // 2\n            ways_t1 += (color_counts[1] * (color_counts[1] - 1)) // 2\n    \n    if ways_t1 > 0:\n        print(f\"1 {ways_t1}\")\n        return\n\n    # No t=0 or t=1 solution. Minimum t must be 2 or 3.\n    # t=2: Add two edges.\n    # To form an odd cycle with 2 added edges, we must connect two distinct connected components.\n    # Let's say we have components C1 and C2.\n    # We pick u in C1, v in C2. Add edge (u,v).\n    # Then we pick x in C1, y in C2. Add edge (x,y).\n    # This forms a cycle u-v-...-y-x-...-u.\n    # If colors[u] == colors[x] and colors[v] == colors[y], then u-x path is even, v-y path is even.\n    # If (u,v) and (x,y) are added, and u,x are same color in C1, v,y are same color in C2.\n    # Path u-v is length 1. Path x-y is length 1.\n    # Path u-...-x is even length. Path v-...-y is even length.\n    # Total cycle length: (u-v) + (v-...-y) + (y-x) + (x-...-u)\n    # = 1 + even + 1 + even = even. This doesn't work.\n    \n    # We need to connect two vertices of different colors.\n    # All components are bipartite.\n    # Let's pick two components C_i and C_j.\n    # Pick a vertex u from C_i, and a vertex v from C_j. Add edge (u, v).\n    # Pick a vertex x from C_i, and a vertex y from C_j. Add edge (x, y).\n    # This forms a cycle u - (path in C_j) - y - (path in C_i) - x - u.\n    # The path u-...-x in C_i has length |colors[u] - colors[x]| (mod 2).\n    # The path v-...-y in C_j has length |colors[v] - colors[y]| (mod 2).\n    # The total cycle length is (1 for (u,v)) + (path v-y) + (1 for (y,x)) + (path x-u).\n    # To make it odd: 1 + (|colors[v]-colors[y]|) + 1 + (|colors[x]-colors[u]|) = odd\n    # (|colors[v]-colors[y]|) + (|colors[x]-colors[u]|) = odd (mod 2)\n    # This means one of the paths must be odd and the other even.\n    # So, either (colors[v] != colors[y] and colors[x] == colors[u]) OR (colors[v] == colors[y] and colors[x] != colors[u]).\n\n    # This is equivalent to finding two components, C_i and C_j, and picking two vertices u,x from C_i and two vertices v,y from C_j.\n    # We add edges (u,v) and (x,y).\n    # The cycle is u - v - (path in C_j) - y - x - (path in C_i) - u.\n    # The length is 1 + path_len(v,y) + 1 + path_len(x,u).\n    # For an odd cycle, path_len(v,y) + path_len(x,u) must be odd.\n    # This means (colors[v] != colors[y] and colors[x] == colors[u]) OR (colors[v] == colors[y] and colors[x] != colors[u]).\n\n    # Let N_comp be the number of connected components.\n    # If N_comp >= 2, we can add 2 edges.\n    # Let C_k be the k-th component. Let (c_k0, c_k1) be the counts of vertices of color 0 and color 1 in C_k.\n    # We need to pick two components, say C_i and C_j.\n    # Pick u from C_i, v from C_j, x from C_i, y from C_j.\n    # Add (u,v) and (x,y).\n    # Case 1: u,x have same color in C_i (path u-x is even). v,y have different colors in C_j (path v-y is odd).\n    #   Number of ways to pick u,x of same color in C_i: (c_i0 * (c_i0-1)/2) + (c_i1 * (c_i1-1)/2)\n    #   Number of ways to pick v,y of different colors in C_j: c_j0 * c_j1\n    #   Total ways for this case: ( (c_i0 * (c_i0-1)/2) + (c_i1 * (c_i1-1)/2) ) * (c_j0 * c_j1)\n    # Case 2: u,x have different colors in C_i (path u-x is odd). v,y have same colors in C_j (path v-y is even).\n    #   Number of ways to pick u,x of different colors in C_i: c_i0 * c_i1\n    #   Number of ways to pick v,y of same colors in C_j: (c_j0 * (c_j0-1)/2) + (c_j1 * (c_j1-1)/2)\n    #   Total ways for this case: (c_i0 * c_i1) * ( (c_j0 * (c_j0-1)/2) + (c_j1 * (c_j1-1)/2) )\n    # Summing these for all pairs of components (C_i, C_j) where i < j.\n\n    # Re-run BFS to get component info\n    colors = [-1] * (n + 1)\n    visited = [False] * (n + 1)\n    components_info = [] # List of (color0_count, color1_count) for each component\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            current_component_nodes = []\n            q = [i]\n            visited[i] = True\n            colors[i] = 0\n            head = 0\n            \n            while head < len(q):\n                u = q[head]\n                head += 1\n                current_component_nodes.append(u)\n\n                for v in adj[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        colors[v] = 1 - colors[u]\n                        q.append(v)\n            \n            color_counts = [0, 0]\n            for node in current_component_nodes:\n                color_counts[colors[node]] += 1\n            components_info.append(tuple(color_counts))\n    \n    num_components = len(components_info)\n\n    if num_components >= 2:\n        # Calculate sums for convenience\n        sum_c0_c1 = 0 # sum of c_k0 * c_k1 for all components\n        sum_same_color_pairs = 0 # sum of (c_k0*(c_k0-1)/2 + c_k1*(c_k1-1)/2) for all components\n\n        for c0, c1 in components_info:\n            sum_c0_c1 += c0 * c1\n            sum_same_color_pairs += (c0 * (c0 - 1)) // 2 + (c1 * (c1 - 1)) // 2\n        \n        # Calculate ways for t=2\n        # We need to pick two components C_i and C_j.\n        # Then pick (u,x) from C_i and (v,y) from C_j.\n        # Case 1: (u,x) same color, (v,y) different color.\n        #   Ways = sum over i<j of [ ((c_i0*(c_i0-1)/2 + c_i1*(c_i1-1)/2) * (c_j0*c_j1)) + ((c_j0*(c_j0-1)/2 + c_j1*(c_j1-1)/2) * (c_i0*c_i1)) ]\n        # This can be simplified.\n        # Total ways = sum over i (same_color_pairs_i * diff_color_pairs_j) + sum over j (same_color_pairs_j * diff_color_pairs_i)\n        # = sum over i (same_color_pairs_i * (sum_c0_c1 - diff_color_pairs_i))\n        #   + sum over i (diff_color_pairs_i * (sum_same_color_pairs - same_color_pairs_i))\n        # This double counts.\n        # A better way:\n        # Total ways for t=2:\n        # Pick 2 distinct vertices u, x from different components, say C_i and C_j.\n        # Pick 2 distinct vertices v, y from different components, say C_i and C_j.\n        # This formulation is for adding 2 edges (u,v) and (x,y).\n        # We need u,x from C_i, v,y from C_j.\n        # Total ways = (sum_same_color_pairs) * (sum_c0_c1) + (sum_c0_c1) * (sum_same_color_pairs)\n        # But this counts (C_i, C_j) and (C_j, C_i) separately.\n        # The formula should be:\n        # sum_{i=0}^{N_comp-1} sum_{j=i+1}^{N_comp-1} [\n        #   ( (c_i0*(c_i0-1)//2 + c_i1*(c_i1-1)//2) * (c_j0*c_j1) ) +\n        #   ( (c_j0*(c_j0-1)//2 + c_j1*(c_j1-1)//2) * (c_i0*c_i1) )\n        # ]\n        \n        ways_t2 = 0\n        for i in range(num_components):\n            c_i0, c_i1 = components_info[i]\n            same_i = (c_i0 * (c_i0 - 1)) // 2 + (c_i1 * (c_i1 - 1)) // 2\n            diff_i = c_i0 * c_i1\n            for j in range(i + 1, num_components):\n                c_j0, c_j1 = components_info[j]\n                same_j = (c_j0 * (c_j0 - 1)) // 2 + (c_j1 * (c_j1 - 1)) // 2\n                diff_j = c_j0 * c_j1\n                \n                ways_t2 += same_i * diff_j\n                ways_t2 += same_j * diff_i\n        \n        if ways_t2 > 0:\n            print(f\"2 {ways_t2}\")\n            return\n        \n        # t=2: Add two edges (u,v) and (u,x) where u is in one component, v and x are in another component.\n        # This forms a cycle u-v-...-x-u.\n        # The path v-...-x must be odd. This means colors[v] != colors[x].\n        # We need to pick a vertex u from some component C_i.\n        # Pick two distinct vertices v, x from another component C_j such that colors[v] != colors[x].\n        # Number of ways to pick u: n (total vertices)\n        # Number of ways to pick v,x from C_j with different colors: c_j0 * c_j1\n        # Sum over all components C_j (c_j0 * c_j1)\n        # For each u, we can pick any pair (v,x) from any other component C_j such that colors[v] != colors[x].\n        # Total ways = n * (sum of (c_j0 * c_j1) for all components C_j)\n        # Wait, this is not quite right.\n        # We pick u from C_i. Then we pick v, x from C_j (j != i).\n        # ways = sum over i ( (c_i0+c_i1) * (sum_{j!=i} (c_j0*c_j1)) )\n        # This is (sum over i (c_i0+c_i1)) * (sum over j (c_j0*c_j1)) - sum over i ( (c_i0+c_i1) * (c_i0*c_i1) )\n        # = n * sum_c0_c1 - sum over i ( (c_i0+c_i1) * c_i0*c_i1 )\n        \n        ways_t2_alt = 0\n        for i in range(num_components):\n            c_i0, c_i1 = components_info[i]\n            total_nodes_in_comp_i = c_i0 + c_i1\n            \n            # Sum of c_j0 * c_j1 for all components j != i\n            sum_diff_colors_other_comps = sum_c0_c1 - (c_i0 * c_i1)\n            \n            ways_t2_alt += total_nodes_in_comp_i * sum_diff_colors_other_comps\n\n        # t=2 ways is the sum of ways_t2 and ways_t2_alt\n        # These are distinct cases:\n        # ways_t2: 2 edges connect 2 components (u,v) and (x,y), u,x from C_i, v,y from C_j.\n        # ways_t2_alt: 2 edges connect 3 vertices: (u,v) and (u,x), u from C_i, v,x from C_j.\n        # The problem asks for minimum t. If ways_t2 > 0, then t=2.\n        # If ways_t2 is 0, but ways_t2_alt is > 0, then t=2.\n        # We need to combine them.\n        # The total number of ways for t=2 is ways_t2 + ways_t2_alt.\n        # Note: ways_t2_alt counts ordered pairs (u, {v,x}). If we consider {u,v}, {u,x} as a set of added edges,\n        # then we need to divide by 2 if v,x are distinct.\n        # No, the problem states \"Two ways to add edges to the graph are considered equal if they have the same sets of added edges.\"\n        # So we add {u,v} and {u,x}. This is one set of added edges.\n        # We choose u (N ways). We choose a component C_j (N_comp-1 ways).\n        # We choose two distinct nodes v,x from C_j with different colors (c_j0 * c_j1 ways).\n        # So, ways_t2_alt = sum over u ( sum over j!=comp(u) ( c_j0 * c_j1 ) )\n        # = sum over comp_i ( (c_i0+c_i1) * sum_{j!=i} (c_j0*c_j1) )\n        # This is exactly what ways_t2_alt calculates.\n\n        if ways_t2 + ways_t2_alt > 0:\n            print(f\"2 {ways_t2 + ways_t2_alt}\")\n            return\n    \n    # If num_components < 2, then num_components = 1.\n    # In this case, t=2 solutions are not possible, as they require at least 2 components.\n    # If num_components = 1, then the graph is connected and bipartite.\n    # We already handled t=0 (no odd cycle) and t=1 (no same-color pairs in any component).\n    # So if num_components = 1, and no t=0, t=1 solutions, then we need t=3.\n    # t=3: Add three edges.\n    # The graph is connected and bipartite.\n    # To form an odd cycle with 3 edges, we can pick 3 distinct vertices u, v, x.\n    # Add edges (u,v), (v,x), (x,u). This forms a triangle, which is an odd cycle.\n    # We need to ensure (u,v), (v,x), (x,u) are not existing edges.\n    # Since the graph is bipartite, there are no existing edges between vertices of the same color.\n    # For a triangle, all three edges must be non-existent.\n    # This means all three pairs (u,v), (v,x), (x,u) must have vertices of the same color.\n    # But this is not true for a triangle. A triangle has length 3.\n    # If u,v,x form a triangle:\n    # colors[u] != colors[v]\n    # colors[v] != colors[x]\n    # colors[x] != colors[u]\n    # This implies colors[u] = 0, colors[v] = 1, colors[x] = 0 (or vice versa).\n    # But then colors[x] == colors[u], so the edge (x,u) would be between same-colored vertices.\n    # This contradicts the bipartite property (no existing edges between same-colored vertices).\n    # So, if we add (u,v), (v,x), (x,u) and they are all non-existent, then colors[u] != colors[v], colors[v] != colors[x], colors[x] != colors[u].\n    # This means u,v,x cannot be colored in a bipartite way. This is an odd cycle.\n    # The number of ways to pick 3 distinct vertices (u,v,x) is nC3.\n    # For each such triplet, we add edges (u,v), (v,x), (x,u).\n    # We need to ensure these edges are not already present.\n    # Since the graph is bipartite, any edge between same-colored vertices is non-existent.\n    # Any edge between different-colored vertices might exist.\n    # In a triangle (u,v,x), the edges are (u,v), (v,x), (x,u).\n    # colors[u], colors[v], colors[x] must be such that two are of one color and one of another.\n    # e.g., colors[u]=0, colors[v]=0, colors[x]=1.\n    # Then (u,v) is same-color (non-existent). (v,x) is diff-color (might exist). (x,u) is diff-color (might exist).\n    # This is not a simple way to count.\n\n    # Simpler way for t=3:\n    # We need to pick 3 distinct vertices u, v, x.\n    # We add edges (u,v), (v,x), (x,u).\n    # This forms a C3 (triangle), which is an odd cycle.\n    # The edges (u,v), (v,x), (x,u) must not exist in the graph.\n    # Since the graph is bipartite, any edge between two vertices of the same color does not exist.\n    # Any edge between two vertices of different colors may or may not exist.\n    # For a C3 to be formed by 3 added edges, all 3 edges must be non-existent.\n    # This means (u,v), (v,x), (x,u) must all be non-existent.\n    # This implies that for any pair (a,b) from {u,v,x}, if colors[a] != colors[b], then (a,b) is not an existing edge.\n    # And if colors[a] == colors[b], then (a,b) is not an existing edge (guaranteed by bipartiteness).\n    # So we need to count triplets (u,v,x) such that (u,v), (v,x), (x,u) are all non-existent.\n    # This is equivalent to counting triplets (u,v,x) such that for any pair (a,b) in the triplet, if colors[a] != colors[b], then (a,b) is not an existing edge.\n    # This is complex.\n\n    # A simpler t=3 construction: pick 3 distinct vertices u, v, x.\n    # Add edges (u,v), (v,x), (x,y) where y is any node that completes an odd cycle.\n    # This seems more general.\n    # The easiest way to form an odd cycle with 3 edges is to pick 3 arbitrary vertices u, v, w.\n    # Add edges (u,v), (v,w), (w,u). This forms a C3.\n    # All 3 edges must be non-existent.\n    # Since the graph is bipartite, if u, v, w are chosen such that two have one color and one has another (e.g., u,v color 0, w color 1),\n    # then (u,v) is same-color (non-existent).\n    # (v,w) is diff-color. (w,u) is diff-color.\n    # So we need to count triplets (u,v,w) where (u,v) is non-existent (same color), and (v,w), (w,u) are non-existent (diff color).\n    # Number of ways to pick u,v of same color: ways_t1 (calculated earlier)\n    # This is the number of pairs {u,v} such that u,v are same color.\n    # For each such pair {u,v}, we need to pick a third vertex w.\n    # The edges {u,w} and {v,w} must not exist.\n    # Also, w must be different from u and v.\n    # Let's say u,v are color 0. Then w must be color 1 to form a C3.\n    # Number of ways to pick {u,v} of same color: same_color_pairs_i for component i.\n    # Sum over all components: sum_same_color_pairs.\n    # For each such pair {u,v} (both color 0), we pick w of color 1.\n    # Number of choices for w: total nodes of color 1 (sum of c_k1) minus any w that forms an existing edge with u or v.\n    # This is getting too complicated.\n\n    # What if N is small? n <= 1000.\n    # The total number of pairs of vertices is n*(n-1)/2.\n    # The total number of triplets of vertices is n*(n-1)*(n-2)/6.\n\n    # If t=3, and the graph is connected and bipartite (num_components = 1):\n    # We must add 3 edges.\n    # Consider any three distinct vertices u, v, w.\n    # If we add (u,v), (v,w), (w,u), it forms an odd cycle (C3).\n    # These three edges must be non-existent.\n    # Since the graph is bipartite, any edge between same-colored vertices is non-existent.\n    # Any edge between different-colored vertices may or may not exist.\n    # Let the component have c0 nodes of color 0 and c1 nodes of color 1.\n    # Total nodes n = c0 + c1.\n    # We need to choose u,v,w such that (u,v), (v,w), (w,u) are all non-existent.\n    # Case 1: All three vertices are of the same color. Impossible in a bipartite graph.\n    # Case 2: Two vertices of one color, one of another. E.g., u,v color 0; w color 1.\n    #   (u,v) is same-color, so it's non-existent.\n    #   (v,w) is diff-color. (w,u) is diff-color.\n    #   For this to be a valid way for t=3, (v,w) and (w,u) must also be non-existent.\n    #   Number of ways to pick {u,v} of color 0: c0 * (c0-1) / 2.\n    #   Number of ways to pick w of color 1: c1.\n    #   For each such choice, we must check if (v,w) and (w,u) exist.\n    #   This check is too slow (O(N^3 * M)).\n    \n    # Let's reconsider the problem statement.\n    # \"minimum number of edges that must be added ... to form a simple cycle of an odd length\"\n    # \"simple cycle ... each vertex occurs at most once\"\n    \n    # If n < 3, it's impossible to form a C3.\n    # If n >= 3, and num_components = 1 (graph is connected and bipartite).\n    # And we've ruled out t=0 and t=1.\n    # Then t=3 is the only option left.\n    # Why? If we add 2 edges (u,v) and (x,y), they must be within the same component.\n    # If u,v,x,y are distinct: (u,v) and (x,y). Path u-x and v-y.\n    # Cycle length = 1 + path(v,y) + 1 + path(x,u).\n    # For odd cycle, path(v,y) + path(x,u) must be odd.\n    # This means one path is odd, one is even.\n    # E.g., colors[v] != colors[y] and colors[x] == colors[u].\n    # But all nodes are in one component.\n    # Path(v,y) length is |colors[v]-colors[y]| (mod 2).\n    # Path(x,u) length is |colors[x]-colors[u]| (mod 2).\n    # So we need |colors[v]-colors[y]| + |colors[x]-colors[u]| = 1 (mod 2).\n    # This means we need to pick u,x of same color and v,y of different colors.\n    # Number of ways to pick u,x of same color: (c0*(c0-1)/2) + (c1*(c1-1)/2). This is sum_same_color_pairs (for the single component).\n    # Number of ways to pick v,y of different colors: c0*c1. This is sum_c0_c1 (for the single component).\n    # So, ways = (sum_same_color_pairs) * (sum_c0_c1).\n    # These are pairs of pairs. {u,x} and {v,y}. u,x distinct, v,y distinct, {u,x} and {v,y} disjoint.\n    # This implies 4 distinct vertices.\n    # If n < 4, this is not possible.\n    # What if {u,x} and {v,y} are not disjoint?\n    # e.g., u=v. Then we add (u,u) (loop) and (x,y). Not allowed.\n    # e.g., u=y. Then we add (u,v) and (x,u). This is the ways_t2_alt case.\n    # If ways_t2_alt was 0 (which it is if num_components=1 and no t=1 solution), then this is 0.\n    #\n    # So if num_components = 1, and no t=0, t=1 solutions, then we need t=3.\n    # This happens if n < 3 (impossible to form C3) or if n >= 3.\n    # If n >= 3:\n    # We choose 3 distinct vertices u, v, w. Add (u,v), (v,w), (w,u).\n    # All 3 edges must be non-existent.\n    # Since the graph is bipartite, any edge between same-colored vertices is non-existent.\n    # An edge between different-colored vertices may or may not exist.\n    # So we need to count triplets {u,v,w} such that:\n    # 1. Two vertices are of one color, one of another (e.g., u,v color 0, w color 1).\n    #    (u,v) is same-color, so non-existent.\n    #    (v,w) and (w,u) are diff-color. They must be non-existent.\n    #    Number of ways:\n    #    Pick 2 vertices of color 0: c0 * (c0-1) / 2. Call them u,v.\n    #    Pick 1 vertex of color 1: c1. Call it w.\n    #    Total (c0 * (c0-1) / 2) * c1.\n    #    Then we check if (u,w) and (v,w) are non-existent.\n    #    This is for color 0. Also for color 1: (c1 * (c1-1) / 2) * c0.\n    #    Total = (c0 * (c0-1) / 2) * c1 + (c1 * (c1-1) / 2) * c0.\n    #    This counts triplets {u,v,w} where two are same color, one is different.\n    #    For each such triplet, we add the 3 edges (u,v), (v,w), (w,u).\n    #    The edges are {u,v} (same color), {v,w} (diff color), {w,u} (diff color).\n    #    {u,v} is guaranteed non-existent.\n    #    We need to check if {v,w} and {w,u} are non-existent.\n    #    This is not simply N choose 3.\n\n    # A different approach for t=3.\n    # If num_components = 1, and no t=0, t=1 solution.\n    # This means n >= 1.\n    # We can always add 3 edges if n >= 3.\n    # Pick any 3 vertices u,v,w. Add edges (u,v), (v,w), (w,u).\n    # These 3 edges must be non-existent.\n    # Since the graph is bipartite, if colors[x] == colors[y], then (x,y) is non-existent.\n    # If colors[x] != colors[y], then (x,y) may or may not exist.\n    # If we want all 3 edges to be non-existent, then all pairs (u,v), (v,w), (w,u) must be same-colored.\n    # This is impossible for 3 vertices.\n    # So, at least one edge must be between different-colored vertices.\n    # If we choose u,v,w such that u,v are color 0, w is color 1.\n    # Then (u,v) is non-existent.\n    # (v,w) and (w,u) are between different colors.\n    # For t=3, we need to count triplets {u,v,w} such that (u,v) is non-existent, (v,w) is non-existent, (w,u) is non-existent.\n    # The edges {v,w} and {w,u} must be chosen such that they don't exist in the original graph.\n    # The problem asks for the minimum t. If n >= 3, we can always form a C3 with 3 edges.\n    # The number of ways is N choose 3.\n    # But we must subtract cases where any of the 3 edges already exist.\n    # This is the standard \"count triangles\" problem, but for non-existent edges.\n    \n    # If n < 3, then t=3 is impossible.\n    # The problem implies n >= 1.\n    # If n=1 or n=2, no odd cycle is possible. (min length 3)\n    # The example '3 0' -> '3 1' suggests t=3 is possible even with no edges.\n    # For n=3, m=0: vertices 1,2,3. No edges.\n    # Graph is bipartite. colors[1]=0, colors[2]=0, colors[3]=0 (or any valid coloring).\n    # No t=0. No t=1 (no same-color pairs, unless n=1, but need n>=3).\n    # num_components = 3. components_info = [(1,0), (1,0), (1,0)].\n    # ways_t1 = 0.\n    # ways_t2:\n    # sum_c0_c1 = 0. sum_same_color_pairs = 0.\n    # So ways_t2 = 0.\n    # ways_t2_alt = 0.\n    # So t=3.\n    # For n=3, m=0, we have 3 vertices. We can add (1,2), (2,3), (3,1).\n    # This is 1 way.\n    # So if n >= 3 and no t=0, t=1, t=2 solutions, then t=3.\n    # The number of ways is nC3 if all possible C3s require 3 added edges.\n    # This is true if the graph is bipartite and has no edges at all between different-colored vertices, or very few.\n    # This is not necessarily nC3.\n    # It's (number of triplets {u,v,w}) - (number of triplets that already form a C3) - (number of triplets that form a C3 with 1 added edge) - (number of triplets that form a C3 with 2 added edges).\n    # This is too complicated.\n\n    # Let's re-evaluate the maximum t.\n    # t=0: has_odd_cycle\n    # t=1: ways_t1 (add edge between same-color nodes in a component)\n    # t=2: ways_t2 (add 2 edges connecting 2 components: u,x in C_i, v,y in C_j, (u,v), (x,y) added, one path even one odd)\n    #      ways_t2_alt (add 2 edges connecting 3 nodes: u in C_i, v,x in C_j, (u,v), (u,x) added, path v-x odd)\n    # If all these are 0, then t must be 3.\n    # This happens if n < 3, or n >= 3 and the graph is connected and bipartite (num_components=1), and n <= 2 (so ways_t1 = 0).\n    # If n=1 or n=2, then no odd cycle is possible. Problem states \"more than one vertex\". \"simple cycle of an odd length\". min length 3.\n    # So if n < 3, it's impossible.\n    # The problem guarantees a solution exists. This implies n >= 3.\n    # So if we reach here, n >= 3.\n    # And we've confirmed num_components = 1, and ways_t1 = 0.\n    # In this case, the only way to form an odd cycle is to add 3 edges to form a C3.\n    # How many ways?\n    # We choose 3 distinct vertices u,v,w.\n    # Add (u,v), (v,w), (w,u).\n    # All these 3 edges must be non-existent.\n    # Since the graph is connected and bipartite, all edges between same-colored vertices are non-existent.\n    # Any edge between different-colored vertices might exist.\n    # To have all 3 edges non-existent, we need to choose u,v,w such that two are of one color and one of another (e.g., u,v color 0, w color 1).\n    # Then (u,v) is same-color (non-existent).\n    # (v,w) and (w,u) are diff-color. These must be non-existent.\n    # We need to count triplets {u,v,w} such that:\n    #   1. Two vertices are of color 0, one of color 1. (u,v of color 0, w of color 1).\n    #      And (u,w) is not an edge, and (v,w) is not an edge.\n    #   2. Two vertices are of color 1, one of color 0. (u,v of color 1, w of color 0).\n    #      And (u,w) is not an edge, and (v,w) is not an edge.\n    \n    # This is the most complex part.\n    # For a fixed vertex w (say, color 1), we need to find pairs {u,v} (both color 0) such that (u,w) and (v,w) are not edges.\n    # Let N(w) be the set of neighbors of w.\n    # We need to pick u,v from (nodes of color 0) \\ (N(w)).\n    # Let C0 be the set of nodes of color 0. Let C1 be the set of nodes of color 1.\n    # Ways = sum over w in C1 ( ( |C0 \\ N(w)| * (|C0 \\ N(w)| - 1) / 2 ) )\n    #      + sum over w in C0 ( ( |C1 \\ N(w)| * (|C1 \\ N(w)| - 1) / 2 ) )\n    # This counts pairs of (w, {u,v}) where u,v are same color, and (w,u), (w,v) are non-existent.\n    \n    # Let's calculate this.\n    # We know num_components = 1.\n    # So components_info has one entry: (c0, c1).\n    c0, c1 = components_info[0]\n    \n    ways_t3 = 0\n    \n    # Case: w is color 1, u,v are color 0.\n    for w_node in range(1, n + 1):\n        if colors[w_node] == 1: # w is color 1\n            non_neighbors_color0_count = 0\n            for u_node in range(1, n + 1):\n                if colors[u_node] == 0: # u is color 0\n                    if u_node != w_node and tuple(sorted((u_node, w_node))) not in edges_set:\n                        non_neighbors_color0_count += 1\n            \n            ways_t3 += (non_neighbors_color0_count * (non_neighbors_color0_count - 1)) // 2\n            \n    # Case: w is color 0, u,v are color 1.\n    for w_node in range(1, n + 1):\n        if colors[w_node] == 0: # w is color 0\n            non_neighbors_color1_count = 0\n            for u_node in range(1, n + 1):\n                if colors[u_node] == 1: # u is color 1\n                    if u_node != w_node and tuple(sorted((u_node, w_node))) not in edges_set:\n                        non_neighbors_color1_count += 1\n            \n            ways_t3 += (non_neighbors_color1_count * (non_neighbors_color1_count - 1)) // 2\n\n    print(f\"3 {ways_t3}\")\n\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    adj = [[] for _ in range(n + 1)]\n    edges_set = set()\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n        edges_set.add(tuple(sorted((u, v))))\n\n    # Check for existing odd cycle (t=0)\n    # Use BFS for 2-coloring to detect odd cycles\n    colors = [-1] * (n + 1) # -1: unvisited, 0: color 0, 1: color 1\n    has_odd_cycle = False\n\n    for i in range(1, n + 1):\n        if colors[i] == -1:\n            q = [(i, 0)] # (vertex, color)\n            colors[i] = 0\n            head = 0\n            while head < len(q):\n                u, u_color = q[head]\n                head += 1\n\n                for v in adj[u]:\n                    if colors[v] == -1:\n                        colors[v] = 1 - u_color\n                        q.append((v, 1 - u_color))\n                    elif colors[v] == u_color:\n                        has_odd_cycle = True\n                        break\n                if has_odd_cycle:\n                    break\n        if has_odd_cycle:\n            break\n\n    if has_odd_cycle:\n        print(\"0 1\")\n        return\n\n    # No existing odd cycle, graph is bipartite\n    # t=1: Add one edge to form an odd cycle\n    # An odd cycle can be formed by adding an edge between two vertices of the same color in a connected component.\n    # Since the graph is bipartite, all existing edges connect vertices of different colors.\n    # Adding an edge (u, v) where u and v have the same color will create an odd cycle.\n    # We need to find two vertices u, v (u != v) such that (u, v) is not an existing edge, and colors[u] == colors[v].\n    # The minimum t is 1 if such an edge exists.\n    # The number of ways w is the count of such non-existent edges.\n\n    # Re-run BFS to get colors for all components and count nodes in each color set.\n    colors = [-1] * (n + 1)\n    visited = [False] * (n + 1)\n    \n    ways_t1 = 0\n    \n    for i in range(1, n + 1):\n        if not visited[i]:\n            component_nodes = []\n            q = [i]\n            visited[i] = True\n            colors[i] = 0\n            head = 0\n            \n            while head < len(q):\n                u = q[head]\n                head += 1\n                component_nodes.append(u)\n\n                for v in adj[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        colors[v] = 1 - colors[u]\n                        q.append(v)\n                    elif colors[v] == colors[u]: # Should not happen if graph is bipartite\n                        # This branch should not be reached if has_odd_cycle was false\n                        pass\n\n            # Count same-color pairs within this component\n            color_counts = [0, 0]\n            for node in component_nodes:\n                color_counts[colors[node]] += 1\n            \n            # Number of ways to add an edge within this component to create an odd cycle\n            # is (count_color0 * (count_color0 - 1) / 2) + (count_color1 * (count_color1 - 1) / 2)\n            # This counts pairs of distinct vertices of the same color.\n            # We must subtract existing edges between these pairs.\n            # However, since the graph is bipartite, there are no existing edges between same-colored vertices.\n            # So, we just need to sum up the combinations.\n            ways_t1 += (color_counts[0] * (color_counts[0] - 1)) // 2\n            ways_t1 += (color_counts[1] * (color_counts[1] - 1)) // 2\n    \n    if ways_t1 > 0:\n        print(f\"1 {ways_t1}\")\n        return\n\n    # No t=0 or t=1 solution. Minimum t must be 2 or 3.\n    # t=2: Add two edges.\n    # To form an odd cycle with 2 added edges, we must connect two distinct connected components.\n    # Let's say we have components C1 and C2.\n    # We pick u in C1, v in C2. Add edge (u,v).\n    # Then we pick x in C1, y in C2. Add edge (x,y).\n    # This forms a cycle u-v-...-y-x-...-u.\n    # If colors[u] == colors[x] and colors[v] == colors[y], then u-x path is even, v-y path is even.\n    # If (u,v) and (x,y) are added, and u,x are same color in C1, v,y are same color in C2.\n    # Path u-v is length 1. Path x-y is length 1.\n    # Path u-...-x is even length. Path v-...-y is even length.\n    # Total cycle length: (u-v) + (v-...-y) + (y-x) + (x-...-u)\n    # = 1 + even + 1 + even = even. This doesn't work.\n    \n    # We need to connect two vertices of different colors.\n    # All components are bipartite.\n    # Let's pick two components C_i and C_j.\n    # Pick a vertex u from C_i, and a vertex v from C_j. Add edge (u, v).\n    # Pick a vertex x from C_i, and a vertex y from C_j. Add edge (x, y).\n    # This forms a cycle u - (path in C_j) - y - (path in C_i) - x - u.\n    # The path u-...-x in C_i has length |colors[u] - colors[x]| (mod 2).\n    # The path v-...-y in C_j has length |colors[v] - colors[y]| (mod 2).\n    # The total cycle length is (1 for (u,v)) + (path v-y) + (1 for (y,x)) + (path x-u).\n    # To make it odd: 1 + (|colors[v]-colors[y]|) + 1 + (|colors[x]-colors[u]|) = odd\n    # (|colors[v]-colors[y]|) + (|colors[x]-colors[u]|) = odd (mod 2)\n    # This means one of the paths must be odd and the other even.\n    # So, either (colors[v] != colors[y] and colors[x] == colors[u]) OR (colors[v] == colors[y] and colors[x] != colors[u]).\n\n    # This is equivalent to finding two components, C_i and C_j, and picking two vertices u,x from C_i and two vertices v,y from C_j.\n    # We add edges (u,v) and (x,y).\n    # The cycle is u - v - (path in C_j) - y - x - (path in C_i) - u.\n    # The length is 1 + path_len(v,y) + 1 + path_len(x,u).\n    # For an odd cycle, path_len(v,y) + path_len(x,u) must be odd.\n    # This means (colors[v] != colors[y] and colors[x] == colors[u]) OR (colors[v] == colors[y] and colors[x] != colors[u]).\n\n    # Let N_comp be the number of connected components.\n    # If N_comp >= 2, we can add 2 edges.\n    # Let C_k be the k-th component. Let (c_k0, c_k1) be the counts of vertices of color 0 and color 1 in C_k.\n    # We need to pick two components, say C_i and C_j.\n    # Pick u from C_i, v from C_j, x from C_i, y from C_j.\n    # Add (u,v) and (x,y).\n    # Case 1: u,x have same color in C_i (path u-x is even). v,y have different colors in C_j (path v-y is odd).\n    #   Number of ways to pick u,x of same color in C_i: (c_i0 * (c_i0-1)/2) + (c_i1 * (c_i1-1)/2)\n    #   Number of ways to pick v,y of different colors in C_j: c_j0 * c_j1\n    #   Total ways for this case: ( (c_i0 * (c_i0-1)/2) + (c_i1 * (c_i1-1)/2) ) * (c_j0 * c_j1)\n    # Case 2: u,x have different colors in C_i (path u-x is odd). v,y have same colors in C_j (path v-y is even).\n    #   Number of ways to pick u,x of different colors in C_i: c_i0 * c_i1\n    #   Number of ways to pick v,y of same colors in C_j: (c_j0 * (c_j0-1)/2) + (c_j1 * (c_j1-1)/2)\n    #   Total ways for this case: (c_i0 * c_i1) * ( (c_j0 * (c_j0-1)/2) + (c_j1 * (c_j1-1)/2) )\n    # Summing these for all pairs of components (C_i, C_j) where i < j.\n\n    # Re-run BFS to get component info\n    colors = [-1] * (n + 1)\n    visited = [False] * (n + 1)\n    components_info = [] # List of (color0_count, color1_count) for each component\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            current_component_nodes = []\n            q = [i]\n            visited[i] = True\n            colors[i] = 0\n            head = 0\n            \n            while head < len(q):\n                u = q[head]\n                head += 1\n                current_component_nodes.append(u)\n\n                for v in adj[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        colors[v] = 1 - colors[u]\n                        q.append(v)\n            \n            color_counts = [0, 0]\n            for node in current_component_nodes:\n                color_counts[colors[node]] += 1\n            components_info.append(tuple(color_counts))\n    \n    num_components = len(components_info)\n\n    if num_components >= 2:\n        # Calculate sums for convenience\n        sum_c0_c1 = 0 # sum of c_k0 * c_k1 for all components\n        sum_same_color_pairs = 0 # sum of (c_k0*(c_k0-1)/2 + c_k1*(c_k1-1)/2) for all components\n\n        for c0, c1 in components_info:\n            sum_c0_c1 += c0 * c1\n            sum_same_color_pairs += (c0 * (c0 - 1)) // 2 + (c1 * (c1 - 1)) // 2\n        \n        # Calculate ways for t=2\n        # We need to pick two components C_i and C_j.\n        # Then pick (u,x) from C_i and (v,y) from C_j.\n        # Case 1: (u,x) same color, (v,y) different color.\n        #   Ways = sum over i<j of [ ((c_i0*(c_i0-1)/2 + c_i1*(c_i1-1)/2) * (c_j0*c_j1)) + ((c_j0*(c_j0-1)/2 + c_j1*(c_j1-1)/2) * (c_i0*c_i1)) ]\n        # This can be simplified.\n        # Total ways = sum over i (same_color_pairs_i * diff_color_pairs_j) + sum over j (same_color_pairs_j * diff_color_pairs_i)\n        # = sum over i (same_color_pairs_i * (sum_c0_c1 - diff_color_pairs_i))\n        #   + sum over i (diff_color_pairs_i * (sum_same_color_pairs - same_color_pairs_i))\n        # This double counts.\n        # A better way:\n        # Total ways for t=2:\n        # Pick 2 distinct vertices u, x from different components, say C_i and C_j.\n        # Pick 2 distinct vertices v, y from different components, say C_i and C_j.\n        # This formulation is for adding 2 edges (u,v) and (x,y).\n        # We need u,x from C_i, v,y from C_j.\n        # Total ways = (sum_same_color_pairs) * (sum_c0_c1) + (sum_c0_c1) * (sum_same_color_pairs)\n        # But this counts (C_i, C_j) and (C_j, C_i) separately.\n        # The formula should be:\n        # sum_{i=0}^{N_comp-1} sum_{j=i+1}^{N_comp-1} [\n        #   ( (c_i0*(c_i0-1)//2 + c_i1*(c_i1-1)//2) * (c_j0*c_j1) ) +\n        #   ( (c_j0*(c_j0-1)//2 + c_j1*(c_j1-1)//2) * (c_i0*c_i1) )\n        # ]\n        \n        ways_t2 = 0\n        for i in range(num_components):\n            c_i0, c_i1 = components_info[i]\n            same_i = (c_i0 * (c_i0 - 1)) // 2 + (c_i1 * (c_i1 - 1)) // 2\n            diff_i = c_i0 * c_i1\n            for j in range(i + 1, num_components):\n                c_j0, c_j1 = components_info[j]\n                same_j = (c_j0 * (c_j0 - 1)) // 2 + (c_j1 * (c_j1 - 1)) // 2\n                diff_j = c_j0 * c_j1\n                \n                ways_t2 += same_i * diff_j\n                ways_t2 += same_j * diff_i\n        \n        if ways_t2 > 0:\n            print(f\"2 {ways_t2}\")\n            return\n        \n        # t=2: Add two edges (u,v) and (u,x) where u is in one component, v and x are in another component.\n        # This forms a cycle u-v-...-x-u.\n        # The path v-...-x must be odd. This means colors[v] != colors[x].\n        # We need to pick a vertex u from some component C_i.\n        # Pick two distinct vertices v, x from another component C_j such that colors[v] != colors[x].\n        # Number of ways to pick u: n (total vertices)\n        # Number of ways to pick v,x from C_j with different colors: c_j0 * c_j1\n        # Sum over all components C_j (c_j0 * c_j1)\n        # For each u, we can pick any pair (v,x) from any other component C_j such that colors[v] != colors[x].\n        # Total ways = n * (sum of (c_j0 * c_j1) for all components C_j)\n        # Wait, this is not quite right.\n        # We pick u from C_i. Then we pick v, x from C_j (j != i).\n        # ways = sum over i ( (c_i0+c_i1) * (sum_{j!=i} (c_j0*c_j1)) )\n        # This is (sum over i (c_i0+c_i1)) * (sum over j (c_j0*c_j1)) - sum over i ( (c_i0+c_i1) * (c_i0*c_i1) )\n        # = n * sum_c0_c1 - sum over i ( (c_i0+c_i1) * c_i0*c_i1 )\n        \n        ways_t2_alt = 0\n        for i in range(num_components):\n            c_i0, c_i1 = components_info[i]\n            total_nodes_in_comp_i = c_i0 + c_i1\n            \n            # Sum of c_j0 * c_j1 for all components j != i\n            sum_diff_colors_other_comps = sum_c0_c1 - (c_i0 * c_i1)\n            \n            ways_t2_alt += total_nodes_in_comp_i * sum_diff_colors_other_comps\n\n        # t=2 ways is the sum of ways_t2 and ways_t2_alt\n        # These are distinct cases:\n        # ways_t2: 2 edges connect 2 components (u,v) and (x,y), u,x from C_i, v,y from C_j.\n        # ways_t2_alt: 2 edges connect 3 vertices: (u,v) and (u,x), u from C_i, v,x from C_j.\n        # The problem asks for minimum t. If ways_t2 > 0, then t=2.\n        # If ways_t2 is 0, but ways_t2_alt is > 0, then t=2.\n        # We need to combine them.\n        # The total number of ways for t=2 is ways_t2 + ways_t2_alt.\n        # Note: ways_t2_alt counts ordered pairs (u, {v,x}). If we consider {u,v}, {u,x} as a set of added edges,\n        # then we need to divide by 2 if v,x are distinct.\n        # No, the problem states \"Two ways to add edges to the graph are considered equal if they have the same sets of added edges.\"\n        # So we add {u,v} and {u,x}. This is one set of added edges.\n        # We choose u (N ways). We choose a component C_j (N_comp-1 ways).\n        # We choose two distinct nodes v,x from C_j with different colors (c_j0 * c_j1 ways).\n        # So, ways_t2_alt = sum over u ( sum over j!=comp(u) ( c_j0 * c_j1 ) )\n        # = sum over comp_i ( (c_i0+c_i1) * sum_{j!=i} (c_j0*c_j1) )\n        # This is exactly what ways_t2_alt calculates.\n\n        if ways_t2 + ways_t2_alt > 0:\n            print(f\"2 {ways_t2 + ways_t2_alt}\")\n            return\n    \n    # If num_components < 2, then num_components = 1.\n    # In this case, t=2 solutions are not possible, as they require at least 2 components.\n    # If num_components = 1, then the graph is connected and bipartite.\n    # We already handled t=0 (no odd cycle) and t=1 (no same-color pairs in any component).\n    # So if num_components = 1, and no t=0, t=1 solutions, then we need t=3.\n    # t=3: Add three edges.\n    # The graph is connected and bipartite.\n    # To form an odd cycle with 3 edges, we can pick 3 distinct vertices u, v, x.\n    # Add edges (u,v), (v,x), (x,u). This forms a triangle, which is an odd cycle.\n    # We need to ensure (u,v), (v,x), (x,u) are not existing edges.\n    # Since the graph is bipartite, there are no existing edges between vertices of the same color.\n    # For a triangle, all three edges must be non-existent.\n    # This means all three pairs (u,v), (v,x), (x,u) must have vertices of the same color.\n    # But this is not true for a triangle. A triangle has length 3.\n    # If u,v,x form a triangle:\n    # colors[u] != colors[v]\n    # colors[v] != colors[x]\n    # colors[x] != colors[u]\n    # This implies colors[u] = 0, colors[v] = 1, colors[x] = 0 (or vice versa).\n    # But then colors[x] == colors[u], so the edge (x,u) would be between same-colored vertices.\n    # This contradicts the bipartite property (no existing edges between same-colored vertices).\n    # So, if we add (u,v), (v,x), (x,u) and they are all non-existent, then colors[u] != colors[v], colors[v] != colors[x], colors[x] != colors[u].\n    # This means u,v,x cannot be colored in a bipartite way. This is an odd cycle.\n    # The number of ways to pick 3 distinct vertices (u,v,x) is nC3.\n    # For each such triplet, we add edges (u,v), (v,x), (x,u).\n    # We need to ensure these edges are not already present.\n    # Since the graph is bipartite, any edge between same-colored vertices is non-existent.\n    # Any edge between different-colored vertices might exist.\n    # In a triangle (u,v,x), the edges are (u,v), (v,x), (x,u).\n    # colors[u], colors[v], colors[x] must be such that two are of one color and one of another.\n    # e.g., colors[u]=0, colors[v]=0, colors[x]=1.\n    # Then (u,v) is same-color (non-existent). (v,x) is diff-color (might exist). (x,u) is diff-color (might exist).\n    # This is not a simple way to count.\n\n    # Simpler way for t=3:\n    # We need to pick 3 distinct vertices u, v, x.\n    # We add edges (u,v), (v,x), (x,u).\n    # This forms a C3 (triangle), which is an odd cycle.\n    # The edges (u,v), (v,x), (x,u) must not exist in the graph.\n    # Since the graph is bipartite, any edge between two vertices of the same color does not exist.\n    # Any edge between two vertices of different colors may or may not exist.\n    # For a C3 to be formed by 3 added edges, all 3 edges must be non-existent.\n    # This means (u,v), (v,x), (x,u) must all be non-existent.\n    # This implies that for any pair (a,b) from {u,v,x}, if colors[a] != colors[b], then (a,b) is not an existing edge.\n    # And if colors[a] == colors[b], then (a,b) is not an existing edge (guaranteed by bipartiteness).\n    # So we need to count triplets (u,v,x) such that (u,v), (v,x), (x,u) are all non-existent.\n    # This is equivalent to counting triplets (u,v,x) such that for any pair (a,b) in the triplet, if colors[a] != colors[b], then (a,b) is not an existing edge.\n    # This is complex.\n\n    # A simpler t=3 construction: pick 3 distinct vertices u, v, x.\n    # Add edges (u,v), (v,x), (x,y) where y is any node that completes an odd cycle.\n    # This seems more general.\n    # The easiest way to form an odd cycle with 3 edges is to pick 3 arbitrary vertices u, v, w.\n    # Add edges (u,v), (v,w), (w,u). This forms a C3.\n    # All 3 edges must be non-existent.\n    # Since the graph is bipartite, if u, v, w are chosen such that two have one color and one has another (e.g., u,v color 0, w color 1),\n    # then (u,v) is same-color (non-existent).\n    # (v,w) is diff-color. (w,u) is diff-color.\n    # So we need to count triplets (u,v,w) where (u,v) is non-existent (same color), and (v,w), (w,u) are non-existent (diff color).\n    # Number of ways to pick u,v of same color: ways_t1 (calculated earlier)\n    # This is the number of pairs {u,v} such that u,v are same color.\n    # For each such pair {u,v}, we need to pick a third vertex w.\n    # The edges {u,w} and {v,w} must not exist.\n    # Also, w must be different from u and v.\n    # Let's say u,v are color 0. Then w must be color 1 to form a C3.\n    # Number of ways to pick {u,v} of same color: same_color_pairs_i for component i.\n    # Sum over all components: sum_same_color_pairs.\n    # For each such pair {u,v} (both color 0), we pick w of color 1.\n    # Number of choices for w: total nodes of color 1 (sum of c_k1) minus any w that forms an existing edge with u or v.\n    # This is getting too complicated.\n\n    # What if N is small? n <= 1000.\n    # The total number of pairs of vertices is n*(n-1)/2.\n    # The total number of triplets of vertices is n*(n-1)*(n-2)/6.\n\n    # If t=3, and the graph is connected and bipartite (num_components = 1):\n    # We must add 3 edges.\n    # Consider any three distinct vertices u, v, w.\n    # If we add (u,v), (v,w), (w,u), it forms an odd cycle (C3).\n    # These three edges must be non-existent.\n    # Since the graph is bipartite, any edge between same-colored vertices is non-existent.\n    # Any edge between different-colored vertices may or may not exist.\n    # Let the component have c0 nodes of color 0 and c1 nodes of color 1.\n    # Total nodes n = c0 + c1.\n    # We need to choose u,v,w such that (u,v), (v,w), (w,u) are all non-existent.\n    # Case 1: All three vertices are of the same color. Impossible in a bipartite graph.\n    # Case 2: Two vertices of one color, one of another. E.g., u,v color 0; w color 1.\n    #   (u,v) is same-color, so it's non-existent.\n    #   (v,w) is diff-color. (w,u) is diff-color.\n    #   For this to be a valid way for t=3, (v,w) and (w,u) must also be non-existent.\n    #   Number of ways to pick {u,v} of color 0: c0 * (c0-1) / 2.\n    #   Number of ways to pick w of color 1: c1.\n    #   For each such choice, we must check if (v,w) and (w,u) exist.\n    #   This check is too slow (O(N^3 * M)).\n    \n    # Let's reconsider the problem statement.\n    # \"minimum number of edges that must be added ... to form a simple cycle of an odd length\"\n    # \"simple cycle ... each vertex occurs at most once\"\n    \n    # If n < 3, it's impossible to form a C3.\n    # If n >= 3, and num_components = 1 (graph is connected and bipartite).\n    # And we've ruled out t=0 and t=1.\n    # Then t=3 is the only option left.\n    # Why? If we add 2 edges (u,v) and (x,y), they must be within the same component.\n    # If u,v,x,y are distinct: (u,v) and (x,y). Path u-x and v-y.\n    # Cycle length = 1 + path(v,y) + 1 + path(x,u).\n    # For odd cycle, path(v,y) + path(x,u) must be odd.\n    # This means one path is odd, one is even.\n    # E.g., colors[v] != colors[y] and colors[x] == colors[u].\n    # But all nodes are in one component.\n    # Path(v,y) length is |colors[v]-colors[y]| (mod 2).\n    # Path(x,u) length is |colors[x]-colors[u]| (mod 2).\n    # So we need |colors[v]-colors[y]| + |colors[x]-colors[u]| = 1 (mod 2).\n    # This means we need to pick u,x of same color and v,y of different colors.\n    # Number of ways to pick u,x of same color: (c0*(c0-1)/2) + (c1*(c1-1)/2). This is sum_same_color_pairs (for the single component).\n    # Number of ways to pick v,y of different colors: c0*c1. This is sum_c0_c1 (for the single component).\n    # So, ways = (sum_same_color_pairs) * (sum_c0_c1).\n    # These are pairs of pairs. {u,x} and {v,y}. u,x distinct, v,y distinct, {u,x} and {v,y} disjoint.\n    # This implies 4 distinct vertices.\n    # If n < 4, this is not possible.\n    # What if {u,x} and {v,y} are not disjoint?\n    # e.g., u=v. Then we add (u,u) (loop) and (x,y). Not allowed.\n    # e.g., u=y. Then we add (u,v) and (x,u). This is the ways_t2_alt case.\n    # If ways_t2_alt was 0 (which it is if num_components=1 and no t=1 solution), then this is 0.\n    #\n    # So if num_components = 1, and no t=0, t=1 solutions, then we need t=3.\n    # This happens if n < 3 (impossible to form C3) or if n >= 3.\n    # If n >= 3:\n    # We choose 3 distinct vertices u, v, w. Add (u,v), (v,w), (w,u).\n    # All 3 edges must be non-existent.\n    # Since the graph is bipartite, any edge between same-colored vertices is non-existent.\n    # An edge between different-colored vertices may or may not exist.\n    # So we need to count triplets {u,v,w} such that:\n    # 1. Two vertices are of one color, one of another (e.g., u,v color 0, w color 1).\n    #    (u,v) is same-color, so non-existent.\n    #    (v,w) and (w,u) are diff-color. They must be non-existent.\n    #    Number of ways:\n    #    Pick 2 vertices of color 0: c0 * (c0-1) / 2. Call them u,v.\n    #    Pick 1 vertex of color 1: c1. Call it w.\n    #    Total (c0 * (c0-1) / 2) * c1.\n    #    Then we check if (u,w) and (v,w) are non-existent.\n    #    This is for color 0. Also for color 1: (c1 * (c1-1) / 2) * c0.\n    #    Total = (c0 * (c0-1) / 2) * c1 + (c1 * (c1-1) / 2) * c0.\n    #    This counts triplets {u,v,w} where two are same color, one is different.\n    #    For each such triplet, we add the 3 edges (u,v), (v,w), (w,u).\n    #    The edges are {u,v} (same color), {v,w} (diff color), {w,u} (diff color).\n    #    {u,v} is guaranteed non-existent.\n    #    We need to check if {v,w} and {w,u} are non-existent.\n    #    This is not simply N choose 3.\n\n    # A different approach for t=3.\n    # If num_components = 1, and no t=0, t=1 solution.\n    # This means n >= 1.\n    # We can always add 3 edges if n >= 3.\n    # Pick any 3 vertices u,v,w. Add edges (u,v), (v,w), (w,u).\n    # These 3 edges must be non-existent.\n    # Since the graph is bipartite, if colors[x] == colors[y], then (x,y) is non-existent.\n    # If colors[x] != colors[y], then (x,y) may or may not exist.\n    # If we want all 3 edges to be non-existent, then all pairs (u,v), (v,w), (w,u) must be same-colored.\n    # This is impossible for 3 vertices.\n    # So, at least one edge must be between different-colored vertices.\n    # If we choose u,v,w such that u,v are color 0, w is color 1.\n    # Then (u,v) is non-existent.\n    # (v,w) and (w,u) are between different colors.\n    # For t=3, we need to count triplets {u,v,w} such that (u,v) is non-existent, (v,w) is non-existent, (w,u) is non-existent.\n    # The edges {v,w} and {w,u} must be chosen such that they don't exist in the original graph.\n    # The problem asks for the minimum t. If n >= 3, we can always form a C3 with 3 edges.\n    # The number of ways is N choose 3.\n    # But we must subtract cases where any of the 3 edges already exist.\n    # This is the standard \"count triangles\" problem, but for non-existent edges.\n    \n    # If n < 3, then t=3 is impossible.\n    # The problem implies n >= 1.\n    # If n=1 or n=2, no odd cycle is possible. (min length 3)\n    # The example '3 0' -> '3 1' suggests t=3 is possible even with no edges.\n    # For n=3, m=0: vertices 1,2,3. No edges.\n    # Graph is bipartite. colors[1]=0, colors[2]=0, colors[3]=0 (or any valid coloring).\n    # No t=0. No t=1 (no same-color pairs, unless n=1, but need n>=3).\n    # num_components = 3. components_info = [(1,0), (1,0), (1,0)].\n    # ways_t1 = 0.\n    # ways_t2:\n    # sum_c0_c1 = 0. sum_same_color_pairs = 0.\n    # So ways_t2 = 0.\n    # ways_t2_alt = 0.\n    # So t=3.\n    # For n=3, m=0, we have 3 vertices. We can add (1,2), (2,3), (3,1).\n    # This is 1 way.\n    # So if n >= 3 and no t=0, t=1, t=2 solutions, then t=3.\n    # The number of ways is nC3 if all possible C3s require 3 added edges.\n    # This is true if the graph is bipartite and has no edges at all between different-colored vertices, or very few.\n    # This is not necessarily nC3.\n    # It's (number of triplets {u,v,w}) - (number of triplets that already form a C3) - (number of triplets that form a C3 with 1 added edge) - (number of triplets that form a C3 with 2 added edges).\n    # This is too complicated.\n\n    # Let's re-evaluate the maximum t.\n    # t=0: has_odd_cycle\n    # t=1: ways_t1 (add edge between same-color nodes in a component)\n    # t=2: ways_t2 (add 2 edges connecting 2 components: u,x in C_i, v,y in C_j, (u,v), (x,y) added, one path even one odd)\n    #      ways_t2_alt (add 2 edges connecting 3 nodes: u in C_i, v,x in C_j, (u,v), (u,x) added, path v-x odd)\n    # If all these are 0, then t must be 3.\n    # This happens if n < 3, or n >= 3 and the graph is connected and bipartite (num_components=1), and n <= 2 (so ways_t1 = 0).\n    # If n=1 or n=2, then no odd cycle is possible. Problem states \"more than one vertex\". \"simple cycle of an odd length\". min length 3.\n    # So if n < 3, it's impossible.\n    # The problem guarantees a solution exists. This implies n >= 3.\n    # So if we reach here, n >= 3.\n    # And we've confirmed num_components = 1, and ways_t1 = 0.\n    # In this case, the only way to form an odd cycle is to add 3 edges to form a C3.\n    # How many ways?\n    # We choose 3 distinct vertices u,v,w.\n    # Add (u,v), (v,w), (w,u).\n    # All these 3 edges must be non-existent.\n    # Since the graph is connected and bipartite, all edges between same-colored vertices are non-existent.\n    # Any edge between different-colored vertices might exist.\n    # To have all 3 edges non-existent, we need to choose u,v,w such that two are of one color and one of another (e.g., u,v color 0, w color 1).\n    # Then (u,v) is same-color (non-existent).\n    # (v,w) and (w,u) are diff-color. These must be non-existent.\n    # We need to count triplets {u,v,w} such that:\n    #   1. Two vertices are of color 0, one of color 1. (u,v of color 0, w of color 1).\n    #      And (u,w) is not an edge, and (v,w) is not an edge.\n    #   2. Two vertices are of color 1, one of color 0. (u,v of color 1, w of color 0).\n    #      And (u,w) is not an edge, and (v,w) is not an edge.\n    \n    # This is the most complex part.\n    # For a fixed vertex w (say, color 1), we need to find pairs {u,v} (both color 0) such that (u,w) and (v,w) are not edges.\n    # Let N(w) be the set of neighbors of w.\n    # We need to pick u,v from (nodes of color 0) \\ (N(w)).\n    # Let C0 be the set of nodes of color 0. Let C1 be the set of nodes of color 1.\n    # Ways = sum over w in C1 ( ( |C0 \\ N(w)| * (|C0 \\ N(w)| - 1) / 2 ) )\n    #      + sum over w in C0 ( ( |C1 \\ N(w)| * (|C1 \\ N(w)| - 1) / 2 ) )\n    # This counts pairs of (w, {u,v}) where u,v are same color, and (w,u), (w,v) are non-existent.\n    \n    # Let's calculate this.\n    # We know num_components = 1.\n    # So components_info has one entry: (c0, c1).\n    c0, c1 = components_info[0]\n    \n    ways_t3 = 0\n    \n    # Case: w is color 1, u,v are color 0.\n    for w_node in range(1, n + 1):\n        if colors[w_node] == 1: # w is color 1\n            non_neighbors_color0_count = 0\n            for u_node in range(1, n + 1):\n                if colors[u_node] == 0: # u is color 0\n                    if u_node != w_node and tuple(sorted((u_node, w_node))) not in edges_set:\n                        non_neighbors_color0_count += 1\n            \n            ways_t3 += (non_neighbors_color0_count * (non_neighbors_color0_count - 1)) // 2\n            \n    # Case: w is color 0, u,v are color 1.\n    for w_node in range(1, n + 1):\n        if colors[w_node] == 0: # w is color 0\n            non_neighbors_color1_count = 0\n            for u_node in range(1, n + 1):\n                if colors[u_node] == 1: # u is color 1\n                    if u_node != w_node and tuple(sorted((u_node, w_node))) not in edges_set:\n                        non_neighbors_color1_count += 1\n            \n            ways_t3 += (non_neighbors_color1_count * (non_neighbors_color1_count - 1)) // 2\n\n    print(f\"3 {ways_t3}\")\n\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 603,
        "completion_token_count": 10498,
        "thoughts_token_count": 0
    }
}