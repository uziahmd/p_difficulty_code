{
    "start": 1758009349.6126742,
    "end": 1758009393.2486968,
    "start-formatted": "2025-09-16 16:55 KST",
    "end-formatted": "2025-09-16 16:56 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "**Solving the \"Rudolf and Snowflakes (hard version)\" Problem**\n\nOkay, so I'm looking at this \"Rudolf and Snowflakes (hard version)\" problem, and I need a Python script to figure out if a given number of vertices (`n`) could form a snowflake. Let's break this down.  The core of the problem lies in understanding the snowflake's construction.\n\nThe snowflake starts with a center vertex.  Then, we attach `k` new vertices to that center, where `k` has to be greater than 1.  That's our base.  Now, the key is the iterative expansion. Each of those \"leaf\" vertices (connected only to the center) can then be connected to *another* `k` vertices, and we can do this expansion any number of times (at least once).\n\nThinking through the vertex count: initially, we have 1 (the center). Then we add `k` nodes, giving us a total of `k + 1`.  If we expand once, each of those initial `k` nodes gets another `k` attached, adding `k*k = k^2` nodes, for a total of `1 + k + k^2`. If we expand again, we add `k^3`, and so on. This clearly leads to a geometric series.\n\nWe end up with the equation: `n = 1 + k + k^2 + ... + k^m`, where `m` is related to how many times we expanded.  This is a geometric series, and we can write the closed-form solution as `n = (k^(m+1) - 1) / (k - 1)`.\n\nThe goal is, given an `n` (up to 10^18), can we find integer values for `k > 1` and `d >= 1` that satisfy this equation?  Remembering that `d >= 1` dictates `m >= 2`, which tells me `n` must be the sum of at least three terms.  I now need to figure out an efficient way to search for suitable values of `k` and `d` (or `m`) to determine if a solution exists. This should be interesting...\n",
    "response": "The problem asks us to determine if a given number of vertices `n` can form a snowflake. A snowflake is defined by a construction process involving an integer `k > 1` and at least one \"expansion\" step.\n\nLet's analyze the number of vertices:\n1.  **Initial:** 1 vertex (the center).\n2.  **First layer:** The center is connected to `k` new vertices. Total vertices: `1 + k`.\n3.  **Subsequent expansions:** Each vertex connected to only one other vertex (the \"leaves\") is connected to `k` more new vertices. This step must be done at least once.\n    *   If this step is done once: The `k` leaves from the first layer each connect to `k` new vertices. Total new vertices: `k * k = k^2`. Total vertices: `1 + k + k^2`.\n    *   If this step is done twice: The `k^2` leaves from the previous step each connect to `k` new vertices. Total new vertices: `k^2 * k = k^3`. Total vertices: `1 + k + k^2 + k^3`.\n    *   And so on.\n\nIf the \"subsequent expansions\" step is performed `d` times (where `d >= 1`), the total number of vertices `n` will be:\n`n = 1 + k + k^2 + ... + k^(d+1)`\n\nThis is a geometric series sum. Let `m = d+1`. Since `d >= 1`, we have `m >= 2`.\nSo, `n = 1 + k + k^2 + ... + k^m`, where `k > 1` and `m >= 2`.\n\nWe need to check if for a given `n` (up to `10^18`), there exist integers `k > 1` and `m >= 2` satisfying this equation.\n\nThere are two main cases for `m`:\n\n**Case 1: `m` is small (e.g., `m=2` or `m=3`)**\n*   **If `m = 2`:** `n = 1 + k + k^2`.\n    This is a quadratic equation in `k`: `k^2 + k + (1 - n) = 0`.\n    Using the quadratic formula, `k = (-1 ± sqrt(1 - 4 * (1 - n))) / 2 = (-1 ± sqrt(4n - 3)) / 2`.\n    For `k` to be a valid integer greater than 1, `4n - 3` must be a perfect square, say `S^2`, and `S` must be odd and `S > 1`. Then `k = (S - 1) / 2`.\n    We can check this by calculating `S = round(sqrt(4n - 3))`. If `S*S == 4n - 3` and `(S - 1)` is even and `(S - 1) / 2 > 1`, then `n` is a snowflake number.\n\n*   **If `m = 3`:** `n = 1 + k + k^2 + k^3`.\n    This is a cubic equation in `k`. For `n` up to `10^18`, `k^3` is roughly `n`, so `k` is roughly `n^(1/3)`. `k` can be up to `(10^18)^(1/3) = 10^6`. We can iterate `k` from `2` up to `10^6` and check if `1 + k + k^2 + k^3` equals `n`.\n\n**Case 2: `m` is large**\nWhen `m` is large, `k` must be small.\nThe smallest possible `k` is `2`.\nIf `k = 2`, `n = 1 + 2 + 2^2 + ... + 2^m = 2^(m+1) - 1`.\nSince `n <= 10^18`, `2^(m+1) - 1 <= 10^18`.\n`2^(m+1) <= 10^18 + 1`.\n`m+1 <= log2(10^18 + 1) approx 18 * log2(10) approx 18 * 3.32 approx 59.79`.\nSo `m+1` can be at most `59`. This means `m` can be at most `58`.\n\nFor `k >= 2`, we have `n = (k^(m+1) - 1) / (k - 1)`.\nSince `m >= 2`, we know `n > k^m`.\nSo `k < n^(1/m)`.\nIf `m=2`, `k < n^(1/2) = 10^9`.\nIf `m=3`, `k < n^(1/3) = 10^6`.\nIf `m=4`, `k < n^(1/4) = 10^(4.5) approx 31622`.\nIf `m=5`, `k < n^(1/5) = 10^(3.6) approx 3981`.\n...\nIf `m=58`, `k < n^(1/58)`. For `k=2`, `2^58 approx 2.88 * 10^17`. This is within the range of `n`.\nIf `m=59`, `k < n^(1/59)`. For `k=2`, `2^59 approx 5.76 * 10^17`. This is within the range of `n`.\n\nThe maximum possible value for `m` is around 59 (when `k=2`).\nThe maximum possible value for `k` is around `10^9` (when `m=2`).\n\n**Strategy:**\n1.  **Check for `m=2`:** Calculate `S = round(sqrt(4n - 3))`. If `S*S == 4n - 3` and `(S - 1)` is even and `(S - 1) / 2 > 1`, then `n` is a snowflake number. This covers cases like `n=13` (`k=3`), `n=255` (`k=15`).\n    *   Edge case: `n=1, 2, 3, 6`. For `n=13`, `4n-3 = 49`, `S=7`, `k=(7-1)/2=3`. Valid.\n    *   For `n=15`, `4n-3 = 57`, not a perfect square. So `m=2` doesn't work.\n    *   For `n=10101`, `4n-3 = 40401`, `S=201`, `k=(201-1)/2=100`. Valid.\n\n2.  **Iterate `m` from `3` to `59` (or a slightly higher safe bound like `60`):**\n    For each `m`, we need to find if there exists an integer `k > 1` such that `n = 1 + k + ... + k^m`.\n    This means `n * (k - 1) = k^(m+1) - 1`.\n    Since `n > k^m`, `k < n^(1/m)`.\n    We can use binary search to find `k` for a fixed `m`.\n    The range for `k` is `[2, floor(n^(1/m)) + 2]`. The upper bound `floor(n^(1/m)) + 2` is a safe estimate, as `k` cannot be much larger than `n^(1/m)`. For example, `(k^m + ... + 1)` is slightly larger than `k^m`.\n    In binary search, for a candidate `mid_k`:\n    Calculate `current_sum = 1 + mid_k + ... + mid_k^m`.\n    Be careful with overflow when calculating `mid_k^p`. `mid_k^m` can be up to `10^18`.\n    If `current_sum == n`, we found a solution.\n    If `current_sum < n`, `mid_k` is too small, try `low = mid_k + 1`.\n    If `current_sum > n`, `mid_k` is too large, try `high = mid_k - 1`.\n\nLet's refine the binary search for `k` for a fixed `m`:\nThe function `check_sum(k_val, m_val, target_n)` calculates `1 + k_val + ... + k_val^m_val`.\nIt should return `0` if `current_sum == target_n`, `-1` if `current_sum < target_n`, `1` if `current_sum > target_n`.\nIt must also handle potential overflow: if `k_val^p` exceeds `target_n`, the sum will definitely exceed `target_n`, so we can stop early and return `1`.\n\n```python\ndef solve():\n    n = int(input())\n\n    # Case 1: m = 2 (n = 1 + k + k^2)\n    # k^2 + k + (1-n) = 0\n    # Discriminant D = 1 - 4(1-n) = 4n - 3\n    # k = (-1 + sqrt(D)) / 2\n    \n    # n must be at least 1 + 2 + 2^2 = 7 for k=2\n    # The smallest n for m=2 is 7 (k=2). For smaller n, this case won't apply.\n    if n >= 7:\n        discriminant = 4 * n - 3\n        s = int(discriminant**0.5)\n        if s * s == discriminant:\n            # Check if k is an integer and k > 1\n            if (s - 1) % 2 == 0:\n                k = (s - 1) // 2\n                if k > 1:\n                    print(\"YES\")\n                    return\n\n    # Case 2: m >= 3\n    # Iterate m from 3 up to a max value (e.g., 60, since 2^60 > 10^18)\n    # For a fixed m, perform binary search for k.\n    \n    # Function to calculate sum 1 + k + ... + k^m\n    # Returns 0 if sum == n, -1 if sum < n, 1 if sum > n\n    # Handles potential overflow by returning 1 if sum exceeds n\n    def check_sum(k_val, m_val, target_n):\n        current_sum = 1\n        term = 1\n        for _ in range(m_val): # Iterate m_val times for k^1 to k^m_val\n            # Check for overflow before multiplying term by k_val\n            # If term > target_n / k_val, then term * k_val would overflow target_n\n            # This is a safe check for k_val >= 2.\n            # If target_n / k_val is less than term, it means term * k_val > target_n\n            if k_val > target_n // term: # term * k_val would exceed target_n\n                return 1 # Sum will be > target_n\n            term *= k_val\n            current_sum += term\n            if current_sum > target_n: # Sum already exceeded target_n\n                return 1\n        if current_sum == target_n:\n            return 0\n        elif current_sum < target_n:\n            return -1\n        else: # current_sum > target_n\n            return 1\n\n    # Max m for k=2 is around 59 (2^59 ~ 5.76 * 10^17, 2^60 ~ 1.15 * 10^18)\n    # So m can go up to 59. Let's use 60 as a safe upper bound.\n    for m in range(3, 61): # m from 3 to 60\n        # Determine search range for k\n        # k^m < n => k < n^(1/m)\n        # Low bound for k is 2.\n        # High bound for k can be estimated as n^(1/m) + a small constant.\n        # For n=10^18, m=3, k < 10^6.\n        # For n=10^18, m=60, k < 2.\n        low_k = 2\n        # A safe upper bound for k. If k=2, m=59, sum is ~10^18.\n        # If m=3, k can be up to 10^6.\n        # max_k_for_m = int(n**(1/m)) + 2 # This can be slow due to float precision issues for large m\n        # A safer upper bound for k can be derived from k^m < n.\n        # Since 2^60 > 10^18, k cannot exceed 2 if m is close to 60.\n        # Maximum k is 10^6 for m=3.\n        high_k = int(n**(1/m)) + 2 # A reasonable upper bound.\n        # Let's cap high_k to a reasonable value like 10^6 + 2 to avoid excessively large ranges for small m.\n        # max k for m=3 is 10^6. max k for m=2 is 10^9.\n        # Since m >= 3, k max is 10^6.\n        high_k = min(high_k, 10**6 + 2) # Cap high_k to prevent excessively large ranges\n        \n        # Binary search for k\n        while low_k <= high_k:\n            mid_k = (low_k + high_k) // 2\n            if mid_k < 2: # k must be > 1\n                low_k = 2\n                continue\n            \n            comparison_result = check_sum(mid_k, m, n)\n            \n            if comparison_result == 0: # Found a solution\n                print(\"YES\")\n                return\n            elif comparison_result == -1: # Sum is too small, increase k\n                low_k = mid_k + 1\n            else: # Sum is too large, decrease k\n                high_k = mid_k - 1\n\n    print(\"NO\")\n\n\nnum_test_cases = int(input())\nfor _ in range(num_test_cases):\n    solve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "def solve():\n    n = int(input())\n\n    # Case 1: m = 2 (n = 1 + k + k^2)\n    # k^2 + k + (1-n) = 0\n    # Discriminant D = 1 - 4(1-n) = 4n - 3\n    # k = (-1 + sqrt(D)) / 2\n    \n    # n must be at least 1 + 2 + 2^2 = 7 for k=2\n    # The smallest n for m=2 is 7 (k=2). For smaller n, this case won't apply.\n    if n >= 7:\n        discriminant = 4 * n - 3\n        s = int(discriminant**0.5)\n        if s * s == discriminant:\n            # Check if k is an integer and k > 1\n            if (s - 1) % 2 == 0:\n                k = (s - 1) // 2\n                if k > 1:\n                    print(\"YES\")\n                    return\n\n    # Case 2: m >= 3\n    # Iterate m from 3 up to a max value (e.g., 60, since 2^60 > 10^18)\n    # For a fixed m, perform binary search for k.\n    \n    # Function to calculate sum 1 + k + ... + k^m\n    # Returns 0 if sum == n, -1 if sum < n, 1 if sum > n\n    # Handles potential overflow by returning 1 if sum exceeds n\n    def check_sum(k_val, m_val, target_n):\n        current_sum = 1\n        term = 1\n        for _ in range(m_val): # Iterate m_val times for k^1 to k^m_val\n            # Check for overflow before multiplying term by k_val\n            # If term > target_n / k_val, then term * k_val would overflow target_n\n            # This is a safe check for k_val >= 2.\n            # If target_n / k_val is less than term, it means term * k_val > target_n\n            if k_val > target_n // term: # term * k_val would exceed target_n\n                return 1 # Sum will be > target_n\n            term *= k_val\n            current_sum += term\n            if current_sum > target_n: # Sum already exceeded target_n\n                return 1\n        if current_sum == target_n:\n            return 0\n        elif current_sum < target_n:\n            return -1\n        else: # current_sum > target_n\n            return 1\n\n    # Max m for k=2 is around 59 (2^59 ~ 5.76 * 10^17, 2^60 ~ 1.15 * 10^18)\n    # So m can go up to 59. Let's use 60 as a safe upper bound.\n    for m in range(3, 61): # m from 3 to 60\n        # Determine search range for k\n        # k^m < n => k < n^(1/m)\n        # Low bound for k is 2.\n        # High bound for k can be estimated as n^(1/m) + a small constant.\n        # For n=10^18, m=3, k < 10^6.\n        # For n=10^18, m=60, k < 2.\n        low_k = 2\n        # A safe upper bound for k. If k=2, m=59, sum is ~10^18.\n        # If m=3, k can be up to 10^6.\n        # max_k_for_m = int(n**(1/m)) + 2 # This can be slow due to float precision issues for large m\n        # A safer upper bound for k can be derived from k^m < n.\n        # Since 2^60 > 10^18, k cannot exceed 2 if m is close to 60.\n        # Maximum k is 10^6 for m=3.\n        high_k = int(n**(1/m)) + 2 # A reasonable upper bound.\n        # Let's cap high_k to a reasonable value like 10^6 + 2 to avoid excessively large ranges for small m.\n        # max k for m=3 is 10^6. max k for m=2 is 10^9.\n        # Since m >= 3, k max is 10^6.\n        high_k = min(high_k, 10**6 + 2) # Cap high_k to prevent excessively large ranges\n        \n        # Binary search for k\n        while low_k <= high_k:\n            mid_k = (low_k + high_k) // 2\n            if mid_k < 2: # k must be > 1\n                low_k = 2\n                continue\n            \n            comparison_result = check_sum(mid_k, m, n)\n            \n            if comparison_result == 0: # Found a solution\n                print(\"YES\")\n                return\n            elif comparison_result == -1: # Sum is too small, increase k\n                low_k = mid_k + 1\n            else: # Sum is too large, decrease k\n                high_k = mid_k - 1\n\n    print(\"NO\")\n\n\nnum_test_cases = int(input())\nfor _ in range(num_test_cases):\n    solve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 569,
        "completion_token_count": 3442,
        "thoughts_token_count": 845
    }
}