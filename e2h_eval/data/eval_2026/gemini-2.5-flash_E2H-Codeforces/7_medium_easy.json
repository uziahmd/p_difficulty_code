{
    "start": 1758016320.4327857,
    "end": 1758016414.8366945,
    "start-formatted": "2025-09-16 18:52 KST",
    "end-formatted": "2025-09-16 18:53 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "**Algorithm for Snowflake Vertex Count**\n\nOkay, here's my breakdown of this snowflake graph problem. The core idea is this: we're trying to figure out if a given number, *n*, can be expressed as the total number of vertices in a \"snowflake\" graph.  A snowflake graph starts with a center vertex, connects it to *k* other vertices, and then \"grows\" by repeatedly connecting each leaf node (a vertex only connected to one other) to *k* new vertices. We're told that the \"growing\" process must happen at least once.\n\nLet's denote the number of times this \"growth\" step is repeated as *d*. This means *d* is greater or equal to 1.  If we add 1 to *d*, we get *m*.  This means *m* has to be greater than or equal to 2.\n\nThe formula for the total number of vertices, *n*, turns out to be:\n\n`n = (k^(m+1) - 1) / (k - 1)`\n\nwhere *k* is the branching factor (greater than 1) and *m* is one plus the number of times the graph is expanded.\nWe need to find the right values of *k* and *m* such that this formula gives us the target *n*.\n\nNow, the trick is that we can separate this into two cases.\n\n**Case 1: m = 2**\n\nIf *m* is equal to 2, the number of vertices, *n*, is : `n = 1 + k + k^2`.  This can be rewritten as a quadratic equation.\n\nSo, for this *m = 2* case, I'll solve for *k*.\n\n*   Solve for *k* using quadratic formula.\n*   The solution has to be an integer (greater than 1).\n*   *k* is equal to `(-1 + sqrt(4*n - 3)) / 2`.\n*   We need to check whether `4n-3` gives a perfect square greater than 9.\n*   If we can find such *k* greater than 1, we return \"YES\".\n\n**Case 2: m >= 3**\n\nThis is a bit more involved. The thing is *m* can't be too large.  Because *n* can be at most 10^18, *m* is bounded, so I only have to iterate up to some reasonable limit.  I'll calculate the bounds for *m*.  We can show that `m` can not be much greater than about 60.\n\nTo tackle this case, I'll use a binary search to find an appropriate *k* for each *m*.\n\nHere's the approach:\n\n1.  I iterate through possible values of *m* from 3 up to around 60.\n2.  For each *m*, I'll use binary search on *k* (from 2 up to about the cube root of *n*).\n3.  Inside the binary search, I have to compute `1 + k + k^2 + ... + k^m`. I have to be careful with integer overflow here because *k* and *m* can be large.\n4.  If the calculated total matches my target *n*, I found the right *k*, so the answer is \"YES\".  I break the search and return \"YES\".\n5.  If, after checking all the *m* values, I didn't find the correct total, I return \"NO\".\n\nThere's one more initial check.\n`If n < 7`, I have to immediately return NO. Because, when *m = 2* then the total number of vertices is at least 7.\n",
    "response": "The problem asks us to determine if a given number of vertices `n` can form a \"snowflake\" graph. A snowflake is constructed with a central vertex, connected to `k` new vertices (`k > 1`). Then, this step is repeated at least once: each leaf vertex is connected to `k` more new vertices.\n\nLet `d` be the number of times the third step (connecting leaves to `k` new vertices) is performed. The problem states `d >= 1`.\nThe total number of vertices `N` can be calculated as follows:\n1. Initial vertex: 1\n2. Connect center to `k` new vertices: `k` vertices added. Total: `1 + k`.\n3. First time `d=1`: Each of the `k` new vertices becomes a parent to `k` new vertices. `k * k = k^2` vertices added. Total: `1 + k + k^2`.\n4. Second time `d=2`: Each of the `k^2` new vertices becomes a parent to `k` new vertices. `k^2 * k = k^3` vertices added. Total: `1 + k + k^2 + k^3`.\n\nIn general, if step 3 is performed `d` times, the total number of vertices will be:\n`N = 1 + k + k^2 + ... + k^(d+1)`\n\nThis is a geometric series sum. Let `m = d+1`. Since `d >= 1`, we have `m >= 2`.\nSo, we are looking for `n` such that `n = 1 + k + k^2 + ... + k^m` for some integers `k > 1` and `m >= 2`.\nThe sum can also be written as `n = (k^(m+1) - 1) / (k - 1)`.\n\nWe need to check if `n` can be represented in this form. `n` can be up to `10^18`.\n\n**Case 1: `m = 2`**\nThis corresponds to `d = 1` (step 3 applied exactly once).\nThe formula becomes `n = 1 + k + k^2`.\nThis is a quadratic equation in `k`: `k^2 + k + (1 - n) = 0`.\nUsing the quadratic formula, `k = (-1 +/- sqrt(1 - 4(1 - n))) / 2 = (-1 +/- sqrt(4n - 3)) / 2`.\nFor `k` to be a valid integer `> 1`:\n1. `4n - 3` must be a perfect square. Let `4n - 3 = S^2` for some integer `S`.\n2. `S` must be positive.\n3. `k = (S - 1) / 2` must be an integer `> 1`. This implies `S` must be odd (which is true if `S^2 = 4n-3` is odd, and `4n-3` is always odd). Also, `(S - 1) / 2 > 1` means `S - 1 > 2`, so `S > 3`.\n\nSo, for `m=2`, we check if `4n - 3` is a perfect square `S^2` such that `S > 3`. If it is, then `n` is a snowflake.\n\n**Case 2: `m >= 3`**\n`n = 1 + k + k^2 + ... + k^m`.\nSince `k >= 2`, we can bound `m`:\n`n >= 1 + 2 + 2^2 + ... + 2^m = 2^(m+1) - 1`.\nSo, `n+1 >= 2^(m+1)`, which means `m+1 <= log2(n+1)`.\nFor `n = 10^18`, `log2(10^18 + 1)` is approximately `18 * log2(10) ~ 18 * 3.32 ~ 59.79`.\nThus, `m+1` can be at most `59`, so `m` can be at most `58`.\nTherefore, we only need to check `m` values from `3` to `58` (or `60` for a safe upper bound).\n\nFor a fixed `m` in this range, we need to find an integer `k > 1` such that `n = 1 + k + ... + k^m`.\nThe function `f(k) = 1 + k + ... + k^m` is strictly increasing for `k > 1`. This allows us to use binary search for `k`.\n\nThe lower bound for `k` is `2`.\nThe upper bound for `k`: `k^m < n`. So `k < n^(1/m)`.\nFor `m=3`, `k < (10^18)^(1/3) = 10^6`.\nFor `m=58`, `k < (10^18)^(1/58)`. Since `2^58` is already `2.88 * 10^17`, `k` can only be `2` or `3` for large `m`.\nA safe upper bound for `k` for `m >= 3` is `10^6 + 2`.\n\n**Binary Search for `k`:**\nFor each `m` from `3` to `~60`:\n  Perform a binary search for `k` in the range `[2, 10^6 + 2]`.\n  In the binary search, we need a function `calc_sum(k_val, m_val, target_n)` that computes `1 + k_val + ... + k_val^m_val`. This function must handle potential overflows, as `k_val^m_val` can exceed `10^18` during intermediate calculations.\n\n`calc_sum(k_val, m_val, target_n)`:\n  `current_sum = 1`\n  `current_term = 1`\n  For `_` in range(`m_val`): // iterates `m_val` times for `k_val^1` to `k_val^m_val`\n    // Check for overflow before multiplying `current_term` by `k_val`\n    // If k_val * current_term > target_n, then k_val > target_n / current_term\n    // We can't use target_n / current_term directly if current_term is 0, but current_term starts at 1 and k_val >= 2.\n    if current_term > target_n / k_val:\n      return target_n + 1 // Indicate overflow\n    current_term *= k_val\n    current_sum += current_term\n    if current_sum > target_n:\n      return target_n + 1 // Indicate overflow\n  return current_sum\n\n**Overall Algorithm:**\n1. **Initial check for small `n`:** The smallest possible snowflake has `k=2, m=2`, which gives `1 + 2 + 2^2 = 7` vertices. Any `n < 7` cannot be a snowflake.\n   (The problem example `n=1,2,3,6` are all \"NO\", confirming this logic.)\n2. **Check `m=2` case:**\n   Calculate `val = 4n - 3`.\n   Check if `val` is a perfect square `S^2`.\n   If `S*S == val`, then `S = int(sqrt(val))`.\n   If `S > 3` (ensures `k > 1`), return \"YES\".\n3. **Check `m >= 3` cases:**\n   Iterate `m` from `3` to `60` (inclusive).\n   For each `m`:\n     Set `low = 2`, `high = 10^6 + 2`.\n     Perform binary search:\n       While `low <= high`:\n         `mid_k = low + (high - low) // 2`\n         `calculated_n = calc_sum(mid_k, m, n)`\n         If `calculated_n == n`:\n           Return \"YES\".\n         If `calculated_n < n`:\n           `low = mid_k + 1`\n         Else (`calculated_n > n`):\n           `high = mid_k - 1`\n4. If no `k, m` pair is found after all checks, return \"NO\".\n\n**Example `n=15`:**\n1. `n=15` is not `< 7`.\n2. `m=2` check: `4*15 - 3 = 57`. Not a perfect square.\n3. `m >= 3` checks:\n   `m=3`: Binary search for `k`.\n     `calc_sum(2, 3, 15)` = `1 + 2 + 2^2 + 2^3 = 1 + 2 + 4 + 8 = 15`.\n     Found `k=2` for `m=3`. Return \"YES\".\n\nThis approach covers all valid `k` and `m` values efficiently.\n\n```python\nimport math\n\ndef solve():\n    n = int(input())\n\n    # Smallest snowflake: k=2, m=2 (d=1) -> 1 + 2 + 2^2 = 7 vertices.\n    # Any n < 7 cannot be a snowflake.\n    if n < 7:\n        print(\"NO\")\n        return\n\n    # Case 1: m = 2 (d = 1)\n    # n = 1 + k + k^2\n    # k^2 + k + (1 - n) = 0\n    # k = (-1 + sqrt(1 - 4(1 - n))) / 2\n    # k = (-1 + sqrt(4n - 3)) / 2\n    discriminant = 4 * n - 3\n    \n    # Check if discriminant is a perfect square\n    s_sqrt = int(math.isqrt(discriminant)) # math.isqrt is for integer square root\n    if s_sqrt * s_sqrt == discriminant:\n        # For k to be an integer > 1:\n        # s_sqrt must be odd (4n-3 is always odd, so s_sqrt is always odd if it's a perfect square)\n        # (-1 + s_sqrt) must be even, which is true if s_sqrt is odd\n        # (-1 + s_sqrt) / 2 > 1  =>  s_sqrt - 1 > 2  =>  s_sqrt > 3\n        if s_sqrt > 3:\n            print(\"YES\")\n            return\n\n    # Case 2: m >= 3 (d >= 2)\n    # n = 1 + k + k^2 + ... + k^m\n    # k must be > 1.\n    # m can be at most around log2(n) for k=2. For n=10^18, log2(10^18) approx 59.79.\n    # So m goes up to approx 59. We can iterate m from 3 to 60 for safety.\n\n    # Function to calculate 1 + k + k^2 + ... + k^m, handling overflow\n    def calculate_sum(k_val, m_val, target_n):\n        current_sum = 1\n        current_term = 1\n        for _ in range(m_val):\n            # Check for overflow before multiplying current_term by k_val\n            # If current_term * k_val > target_n, then current_term > target_n / k_val\n            if k_val == 0: # Should not happen as k_val >= 2\n                return target_n + 1 \n            if current_term > target_n // k_val:\n                return target_n + 1 # Indicates sum will exceed target_n\n            \n            current_term *= k_val\n            current_sum += current_term\n            if current_sum > target_n:\n                return target_n + 1 # Indicates sum has exceeded target_n\n        return current_sum\n\n    # Max k for m >= 3 is when m=3, k < (10^18)^(1/3) = 10^6.\n    # So binary search range for k can be [2, 10^6 + 2]\n    max_k_search = int(n**(1/3)) + 2 if n > 0 else 2 # For m=3, k approx n^(1/3)\n    max_k_search = min(max_k_search, 2 * 10**6) # Cap it to prevent excessively large upper bound for small n\n\n    for m in range(3, 61): # Iterate m from 3 up to 60\n        low = 2\n        high = max_k_search\n\n        # For very large m, k can only be 2 or 3.\n        # k^m < n => k < n^(1/m)\n        # For m=60, k < (10^18)^(1/60) = (10^(0.3)) = 1.995. So k must be 1, but k>1.\n        # This implies k cannot be found for m=60.\n        # For m=59, k < (10^18)^(1/59) = (10^(18/59)) = 2.007. So k must be 2.\n        # For m=58, k < (10^18)^(1/58) = (10^(18/58)) = 2.07. So k must be 2.\n        # For m=36, k < (10^18)^(1/36) = 10^(0.5) = 3.16. So k can be 2 or 3.\n        # Adjust high for binary search based on m to avoid unnecessary large search space\n        if m > 2: # m=2 handled above\n            # Maximum possible k for current m.\n            # k^m < n => k < n^(1/m)\n            # Use a slightly generous upper bound for the binary search.\n            # For m=60, n^(1/60) is approx 1.99, so k cannot be >= 2.\n            # So the loop for m should terminate before m=60 effectively.\n            # But let's check explicitly for a tighter upper bound for k.\n            # If 2**m > n, then k cannot be 2, so no k for this m.\n            # This check is done implicitly by calculate_sum and binary search.\n            # The high bound for k for binary search can be reduced to int(n**(1/m)) + 2.\n            # But we can just use a fixed high bound like max_k_search (2*10^6) as it's small enough.\n            # Or a more precise high:\n            if m > 60: # No need to check m beyond this if 2^m > n\n                break\n            \n            # A more precise high bound for k for current m\n            # k_upper = int(n**(1/m)) + 2. If n=10^18, m=3, k_upper approx 10^6.\n            # If m=59, k_upper approx 2+2=4.\n            # high = min(max_k_search, int(n**(1/m)) + 2) # This is more optimized\n            # However, the fixed max_k_search is fine, as calculate_sum will quickly return an overflow.\n\n        while low <= high:\n            mid_k = low + (high - low) // 2\n            if mid_k < 2: # Ensure k is always > 1\n                low = 2\n                continue\n\n            calculated_n = calculate_sum(mid_k, m, n)\n\n            if calculated_n == n:\n                print(\"YES\")\n                return\n            elif calculated_n < n:\n                low = mid_k + 1\n            else: # calculated_n > n\n                high = mid_k - 1\n    \n    print(\"NO\")\n\n\nnum_test_cases = int(input())\nfor _ in range(num_test_cases):\n    solve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef solve():\n    n = int(input())\n\n    # Smallest snowflake: k=2, m=2 (d=1) -> 1 + 2 + 2^2 = 7 vertices.\n    # Any n < 7 cannot be a snowflake.\n    if n < 7:\n        print(\"NO\")\n        return\n\n    # Case 1: m = 2 (d = 1)\n    # n = 1 + k + k^2\n    # k^2 + k + (1 - n) = 0\n    # k = (-1 + sqrt(1 - 4(1 - n))) / 2\n    # k = (-1 + sqrt(4n - 3)) / 2\n    discriminant = 4 * n - 3\n    \n    # Check if discriminant is a perfect square\n    s_sqrt = int(math.isqrt(discriminant)) # math.isqrt is for integer square root\n    if s_sqrt * s_sqrt == discriminant:\n        # For k to be an integer > 1:\n        # s_sqrt must be odd (4n-3 is always odd, so s_sqrt is always odd if it's a perfect square)\n        # (-1 + s_sqrt) must be even, which is true if s_sqrt is odd\n        # (-1 + s_sqrt) / 2 > 1  =>  s_sqrt - 1 > 2  =>  s_sqrt > 3\n        if s_sqrt > 3:\n            print(\"YES\")\n            return\n\n    # Case 2: m >= 3 (d >= 2)\n    # n = 1 + k + k^2 + ... + k^m\n    # k must be > 1.\n    # m can be at most around log2(n) for k=2. For n=10^18, log2(10^18) approx 59.79.\n    # So m goes up to approx 59. We can iterate m from 3 to 60 for safety.\n\n    # Function to calculate 1 + k + k^2 + ... + k^m, handling overflow\n    def calculate_sum(k_val, m_val, target_n):\n        current_sum = 1\n        current_term = 1\n        for _ in range(m_val):\n            # Check for overflow before multiplying current_term by k_val\n            # If current_term * k_val > target_n, then current_term > target_n / k_val\n            if k_val == 0: # Should not happen as k_val >= 2\n                return target_n + 1 \n            if current_term > target_n // k_val:\n                return target_n + 1 # Indicates sum will exceed target_n\n            \n            current_term *= k_val\n            current_sum += current_term\n            if current_sum > target_n:\n                return target_n + 1 # Indicates sum has exceeded target_n\n        return current_sum\n\n    # Max k for m >= 3 is when m=3, k < (10^18)^(1/3) = 10^6.\n    # So binary search range for k can be [2, 10^6 + 2]\n    max_k_search = int(n**(1/3)) + 2 if n > 0 else 2 # For m=3, k approx n^(1/3)\n    max_k_search = min(max_k_search, 2 * 10**6) # Cap it to prevent excessively large upper bound for small n\n\n    for m in range(3, 61): # Iterate m from 3 up to 60\n        low = 2\n        high = max_k_search\n\n        # For very large m, k can only be 2 or 3.\n        # k^m < n => k < n^(1/m)\n        # For m=60, k < (10^18)^(1/60) = (10^(0.3)) = 1.995. So k must be 1, but k>1.\n        # This implies k cannot be found for m=60.\n        # For m=59, k < (10^18)^(1/59) = (10^(18/59)) = 2.007. So k must be 2.\n        # For m=58, k < (10^18)^(1/58) = (10^(18/58)) = 2.07. So k must be 2.\n        # For m=36, k < (10^18)^(1/36) = 10^(0.5) = 3.16. So k can be 2 or 3.\n        # Adjust high for binary search based on m to avoid unnecessary large search space\n        if m > 2: # m=2 handled above\n            # Maximum possible k for current m.\n            # k^m < n => k < n^(1/m)\n            # Use a slightly generous upper bound for the binary search.\n            # For m=60, n^(1/60) is approx 1.99, so k cannot be >= 2.\n            # So the loop for m should terminate before m=60 effectively.\n            # But let's check explicitly for a tighter upper bound for k.\n            # If 2**m > n, then k cannot be 2, so no k for this m.\n            # This check is done implicitly by calculate_sum and binary search.\n            # The high bound for k for binary search can be reduced to int(n**(1/m)) + 2.\n            # But we can just use a fixed high bound like max_k_search (2*10^6) as it's small enough.\n            # Or a more precise high:\n            if m > 60: # No need to check m beyond this if 2^m > n\n                break\n            \n            # A more precise high bound for k for current m\n            # k_upper = int(n**(1/m)) + 2. If n=10^18, m=3, k_upper approx 10^6.\n            # If m=59, k_upper approx 2+2=4.\n            # high = min(max_k_search, int(n**(1/m)) + 2) # This is more optimized\n            # However, the fixed max_k_search is fine, as calculate_sum will quickly return an overflow.\n\n        while low <= high:\n            mid_k = low + (high - low) // 2\n            if mid_k < 2: # Ensure k is always > 1\n                low = 2\n                continue\n\n            calculated_n = calculate_sum(mid_k, m, n)\n\n            if calculated_n == n:\n                print(\"YES\")\n                return\n            elif calculated_n < n:\n                low = mid_k + 1\n            else: # calculated_n > n\n                high = mid_k - 1\n    \n    print(\"NO\")\n\n\nnum_test_cases = int(input())\nfor _ in range(num_test_cases):\n    solve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 568,
        "completion_token_count": 3813,
        "thoughts_token_count": 5467
    }
}