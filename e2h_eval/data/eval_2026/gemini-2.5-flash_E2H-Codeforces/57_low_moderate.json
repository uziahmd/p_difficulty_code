{
    "start": 1758284870.2773376,
    "end": 1758284928.7458277,
    "start-formatted": "2025-09-19 21:27 KST",
    "end-formatted": "2025-09-19 21:28 KST",
    "gpu": 2,
    "pid": 57,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Olympiad\n\nA boy named Vasya has taken part in an Olympiad. His teacher knows that in total Vasya got at least x points for both tours of the Olympiad. The teacher has the results of the first and the second tour of the Olympiad but the problem is, the results have only points, no names. The teacher has to know Vasya's chances.Help Vasya's teacher, find two numbers — the best and the worst place Vasya could have won. Note that the total results' table sorts the participants by the sum of points for both tours (the first place has the participant who has got the most points). If two or more participants have got the same number of points, it's up to the jury to assign places to them according to their choice. It is guaranteed that each participant of the Olympiad participated in both tours of the Olympiad.\n\n## Input\nThe first line contains two space-separated integers n, x (1 ≤ n ≤ 105; 0 ≤ x ≤ 2·105) — the number of Olympiad participants and the minimum number of points Vasya earned.The second line contains n space-separated integers: a1, a2, ..., an (0 ≤ ai ≤ 105) — the participants' points in the first tour.The third line contains n space-separated integers: b1, b2, ..., bn (0 ≤ bi ≤ 105) — the participants' points in the second tour.The participants' points are given in the arbitrary order. It is guaranteed that Vasya was present in the Olympiad — there are two integers i, j (1 ≤ i, j ≤ n) such, that ai + bj ≥ x.\n\n## Output\nPrint two space-separated integers — the best and the worst place Vasya could have got on the Olympiad.\n\n## Example\n### Input\n['5 2\\n1 1 1 1 1\\n1 1 1 1 1', '6 7\\n4 3 5 6 4 4\\n8 6 0 4 3 4']\n\n### Output\n['1 5', '1 5']\n\n## Note\nIn the first text sample all 5 participants earn 2 points each in any case. Depending on the jury's decision, Vasya can get the first (the best) as well as the last (the worst) fifth place.In the second test sample in the best case scenario Vasya wins again: he can win 12 points and become the absolute winner if the total results' table looks like that — {4:8, 6:4, 3:6, 4:4, 4:3, 5:0}.In this table all participants are sorted by decreasing points and we can see how much a participant earned in the first and in the second tour.In the worst case scenario Vasya can get the fifth place if the table looks like that — {4:8, 4:6, 6:4, 5:4, 4:3, 3:0}, and he earned 4 and 3 points in the first and second tours, correspondingly.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "**Thinking Through the Vasya Ranking Problem**\n\nOkay, so I'm tackling this Olympiad ranking problem. I need to figure out Vasya's best and worst possible rank given the scores from two rounds. I've got `n`, the total number of participants, `x`, the minimum total points Vasya got, and the lists `a` and `b` representing the scores from each round.  The tricky part is that I don't know *which* score from `a` corresponds to which score from `b`.\n\nMy main goals are to find Vasya's best and worst-case scenarios. The ranking works like this: rank is 1 plus the number of participants with strictly more total points. If there's a tie, the jury can arbitrarily break it.\n\nTo get the *best* rank, I need to make Vasya's total score as high as possible and have as few people as possible with a higher score. So, I need to strategize the pairings of scores between rounds `a` and `b`. For the worst rank, I want to minimize Vasya's score while still exceeding `x`, and maximize the number of people with at least as high of a score as his.\n\nIt seems like I need to think of these scores as `n` distinct participants, each with a score from `a` and `b` that is unknown. Let's call them `P_1` to `P_n`, and their round 1 scores are `A = {a_1, ..., a_n}` and round 2 scores are `B = {b_1, ..., b_n}`. A pairing is like a function that maps each score in A to a unique score in B. This will impact the total score for each participant.\n\nLet's start by working through how to get the best rank for Vasya. My goal is to maximize Vasya's total score. Let's suppose Vasya's score from the first tour is `a_v` and the score from the second is `b_v`. I'll want to choose this combination of scores to give me the highest possible score!\n",
    "response": "The problem asks us to find the best and worst possible ranks for Vasya in an Olympiad, given `n` scores for the first tour, `n` scores for the second tour, and a minimum total score `x` that Vasya achieved. The crucial information is that we don't know which participant got which scores, only the sets of scores for each tour. Each `a_i` from the first tour must be paired with exactly one `b_j` from the second tour to form `n` participant total scores. Ranks are determined by total scores in descending order; ties are broken by the jury arbitrarily.\n\nLet's analyze how to find the best and worst ranks.\n\n**1. Best Possible Rank for Vasya:**\n\nTo achieve the best possible rank, Vasya wants to:\na. Maximize his own total score.\nb. Minimize the number of participants who score strictly more than him.\nc. If he ties with others, the jury gives him the best possible rank among them (i.e., he gets rank `1 + (number of people with strictly more points)`).\n\nTo maximize Vasya's score, he should take the highest possible `a_i` and `b_j` such that `a_i + b_j >= x`. Since we want to minimize competitors with higher scores, we should try to give high scores to Vasya and low scores to others.\nThe optimal strategy for Vasya's best rank is to pair the highest `a_i` with the highest `b_j` (or generally, `a_i` with `b_j` to maximize `a_i+b_j`) such that `a_i + b_j >= x`.\nHowever, this is not quite right. We need to construct *all* `n` pairs.\nTo maximize Vasya's score relative to others, and minimize the number of people above him, Vasya should take an `a_i` and `b_j` such that `a_i + b_j` is as high as possible, while ensuring all other `n-1` participants get scores that are as low as possible.\n\nConsider the sorted lists: `a_sorted` (ascending) and `b_sorted` (ascending).\nTo maximize some participant's score, we would pair a large `a_i` with a large `b_j`.\nTo minimize some participant's score, we would pair a small `a_i` with a small `b_j`.\n\nFor the best rank, we want to make Vasya's score as high as possible, and the other `n-1` participants' scores as low as possible.\nThe highest possible total score any participant can get is `max(a) + max(b)`. Vasya could potentially achieve this if `max(a) + max(b) >= x`. If so, he gets 1st place.\nWhat if `max(a) + max(b) < x`? The problem guarantees that Vasya was present and `a_i + b_j >= x` for some `i, j`. This means Vasya *can* achieve `x` points.\n\nThe optimal strategy for Vasya's best rank is to pair `a_i` with `b_j` such that Vasya's score `a_i + b_j` is maximized.\nThe remaining `n-1` scores from `A` and `B` are then paired up. To minimize the number of people with higher scores than Vasya, we should pair the remaining scores such that as few people as possible exceed Vasya's score.\nThis is equivalent to saying: find a pairing for Vasya `(a_v, b_v)` such that `a_v + b_v >= x`. Then, for the remaining `n-1` participants, pair them up in a way that minimizes their scores. The best way to minimize the scores of others is to pair the smallest remaining `a` with the smallest remaining `b`, the second smallest `a` with the second smallest `b`, and so on. This is not quite correct because we want to minimize the *max* scores of others, or rather, the number of scores above Vasya.\n\nLet's re-think. To achieve the best rank, Vasya should aim for the highest possible score. What's the highest possible score Vasya can get? It's `max(a) + max(b)`. If this sum is `S_max`, and `S_max >= x`, then Vasya can achieve `S_max`. Can other people also achieve `S_max`? Only if there are multiple `max(a)` and `max(b)` values.\nIf Vasya takes `max(a)` and `max(b)`, then no one else can get a higher score. So, if `max(a) + max(b) >= x`, Vasya's best rank is 1. He can achieve this score, and no one else can get more.\n\n**Best Rank: Always 1**\nThe problem guarantees that there exist `a_i, b_j` such that `a_i + b_j >= x`.\nTo get the best rank, Vasya should simply take the `a_k` and `b_l` that yield the maximum possible sum `a_k + b_l` among all elements in `A` and `B`. Let this maximum sum be `S_max = max(A) + max(B)`. Since `S_max` is the absolute maximum possible score any participant can get, and `S_max >= x` (because `max(A) + max(B) >= a_i + b_j >= x` for any `a_i, b_j` that satisfy the condition), Vasya can achieve this score. No other participant can achieve a score strictly greater than `S_max`. Therefore, Vasya can always be ranked 1st.\n\n**2. Worst Possible Rank for Vasya:**\n\nTo achieve the worst possible rank, Vasya wants to:\na. Minimize his own total score (while still satisfying `a_i + b_j >= x`).\nb. Maximize the number of participants who score strictly more than him.\nc. If he ties with others, the jury gives him the worst possible rank among them (i.e., he gets rank `1 + (number of people with strictly more points) + (number of people with the same points, excluding himself)`).\n\nThis is a more complex scenario. We need to find a pairing for Vasya `(a_v, b_v)` such that `a_v + b_v >= x`, and then pair the remaining `n-1` scores such that as many of them as possible have total scores greater than or equal to `a_v + b_v`.\n\nLet's sort `a` in ascending order: `a_1 <= a_2 <= ... <= a_n`.\nLet's sort `b` in descending order: `b_1 >= b_2 >= ... >= b_n`.\n\nConsider a specific `a_i` from the sorted `a` list. If Vasya takes this `a_i`, which `b_j` should he take to minimize his score `a_i + b_j` while still satisfying `a_i + b_j >= x`? He should take the smallest `b_j` such that `a_i + b_j >= x`.\nThis implies that for a fixed `a_i`, Vasya should find the smallest `b_j` such that `b_j >= x - a_i`. This can be found efficiently using binary search (or `bisect_left`) on the sorted `b` list (if `b` is sorted ascending).\n\nLet's try to find a pairing for all `n` participants that maximizes the number of people with high scores.\nThis is a maximum bipartite matching problem or a greedy approach.\nA common strategy to maximize the number of pairs `(a_i, b_j)` such that `a_i + b_j >= S` for some threshold `S` is as follows:\n1. Sort `a` in ascending order.\n2. Sort `b` in descending order.\n3. Use a two-pointer approach: one pointer `i` for `a` (starting from `a_1`) and one pointer `j` for `b` (starting from `b_1`).\n   If `a_i + b_j >= S`, then we can form a pair `(a_i, b_j)` that meets the threshold. We increment `i` and `j`, and count this pair.\n   If `a_i + b_j < S`, then `a_i` is too small to meet the threshold with `b_j`. Since `b_j` is the largest remaining `b`, `a_i` cannot meet the threshold with any other `b_k` where `k > j` (because `b_k <= b_j`). So, `a_i` cannot form a pair that meets the threshold `S`. We must use `a_i` with some other `b_k` (where `k > j`) for a pair that doesn't meet the threshold. To maximize pairs that meet the threshold, we should try to use `b_j` with a larger `a_k`. So we increment `i` (move to `a_{i+1}`).\n\nThis greedy approach counts the maximum number of pairs `(a_i, b_j)` such that `a_i + b_j >= S`.\nLet `count_ge(S)` be this maximum number of pairs.\n\nNow, for Vasya's worst rank:\nVasya needs to pick `a_v, b_v` such that `a_v + b_v >= x`.\nThe other `n-1` participants are paired up from the remaining scores.\nWe want to maximize the number of people (including Vasya) who get a score `S_k >= S_Vasya`.\nThis means we want to find a pairing `(a_v, b_v)` for Vasya, and then pair the remaining `n-1` scores such that the total number of people whose score is `S_k >= S_Vasya` is maximized.\n\nThis is a \"minimum maximum\" problem. We want to find the minimum `S_Vasya` such that `S_Vasya >= x`, and then maximize the count of people `P_k` with `S_k >= S_Vasya`.\nThe key insight here is that the problem is asking for Vasya's rank, not the maximum number of people above a certain score.\nThe structure of the problem is that we have `n` scores for tour A and `n` scores for tour B. We need to form `n` pairs `(a_i, b_j)` using each score exactly once. Vasya is one of these `n` participants.\n\nTo find the worst rank for Vasya:\n1. Vasya must get `a_v + b_v >= x`. To make his rank worse, his score `S_V = a_v + b_v` should be as low as possible (but still `>= x`).\n2. The other `n-1` participants should be paired such that as many of them as possible get scores `S_k >= S_V`.\n\nThis is a binary search problem on Vasya's final rank. Suppose Vasya's rank is `k`. This means there are `k-1` people who definitely score strictly more than Vasya, and potentially some people who tie with Vasya.\nA simpler approach:\nLet's fix Vasya's score to be `S_V`. He achieves this by taking some `a_i` and `b_j` such that `a_i + b_j = S_V` and `S_V >= x`.\nThen we need to pair the remaining `n-1` scores from `A \\ {a_i}` and `B \\ {b_j}`.\nWe want to maximize the number of pairs `(a_k, b_l)` such that `a_k + b_l >= S_V`.\n\nThis is a classic problem that can be solved with a greedy approach.\nSort `a` in ascending order and `b` in ascending order.\nTo find the worst rank for Vasya, we want to maximize the number of participants who score *at least* as much as Vasya.\nLet's try to match `a_i` with `b_j`.\nWe iterate through each `a_i` (from `a_1` to `a_n`). For each `a_i`, we want to find a `b_j` such that `a_i + b_j >= x`.\nTo maximize the number of other participants who also score highly, we should pair `a_i` with the smallest possible `b_j` such that `a_i + b_j >= x`. This leaves larger `b` values available for other `a` values.\n\nAlgorithm for worst rank:\n1. Sort `a` in ascending order.\n2. Sort `b` in ascending order.\n3. Initialize `worst_rank = n`.\n4. Use a two-pointer approach:\n   - `ptr_a` for `a` (starts at 0).\n   - `ptr_b` for `b` (starts at `n-1`, the largest `b` value).\n5. Iterate while `ptr_a < n` and `ptr_b >= 0`:\n   - If `a[ptr_a] + b[ptr_b] >= x`:\n     This means `a[ptr_a]` can be paired with `b[ptr_b]` to satisfy Vasya's minimum score condition.\n     If we make this pair, it's a \"successful\" pair.\n     To maximize the number of such pairs (which means maximizing the number of people who could potentially get a score >= x), we should count this pair and move both pointers: `ptr_a++`, `ptr_b--`.\n     Each such pair represents a participant who could potentially be Vasya, or another participant who scores at least `x`.\n     The number of such pairs `k` means there are `k` participants who can score at least `x`. Vasya is one of them.\n     In the worst case, all these `k` participants score `S_V` (Vasya's score) or higher.\n     If Vasya is assigned one of these `k` pairs, say `(a_i, b_j)` where `a_i + b_j >= x`, and all other `k-1` participants also get pairs `(a_p, b_q)` such that `a_p + b_q >= x`, then all `k` participants could potentially have scores greater than or equal to Vasya's.\n     The worst rank among `k` people with scores `S_k >= S_V` is `k`.\n     So, `worst_rank` should be updated to `k` if we find `k` such pairs.\n   - If `a[ptr_a] + b[ptr_b] < x`:\n     `a[ptr_a]` is too small to pair with `b[ptr_b]` (the largest available `b`) to reach `x`.\n     This means `a[ptr_a]` cannot be part of any pair that sums to `x` or more with the remaining `b`s.\n     Therefore, `a[ptr_a]` must be paired with some `b_k` such that `a[ptr_a] + b_k < x`.\n     This `a[ptr_a]` cannot be Vasya if Vasya must get at least `x` points.\n     We should try to use `a[ptr_a]` for a participant who will score less than `x`.\n     So, we increment `ptr_a` to try a larger `a` value. This `a[ptr_a]` cannot be used to make a pair `(a_i, b_j)` with `a_i+b_j >= x` if `b_j` is `b[ptr_b]` or smaller. So, `a[ptr_a]` must be paired with some `b_k` where `k > ptr_b` (which is not possible since `ptr_b` is the largest available `b`).\n     The logic for the two-pointer approach needs to be more precise for \"worst rank\".\n\nLet's use the standard greedy strategy for maximum matching for a condition.\nSort `a` in ascending order. Sort `b` in ascending order.\nWe want to find the maximum number of pairs `(a_i, b_j)` such that `a_i + b_j >= x`.\nThis can be done by sorting `a` ascending and `b` descending.\nLet `a_asc` be `a` sorted ascending.\nLet `b_desc` be `b` sorted descending.\nInitialize `count = 0`.\nInitialize `j = 0` (for `b_desc`).\nFor `i` from `0` to `n-1` (for `a_asc`):\n  While `j < n` and `a_asc[i] + b_desc[j] < x`:\n    `j++` (try a smaller `b_desc` for `a_asc[i]` if `a_asc[i]` is too small for `b_desc[j]`)\n  If `j < n`:\n    `count++` (we found a pair `(a_asc[i], b_desc[j])` that satisfies the condition)\n    `j++` (use this `b_desc[j]` and move to the next `b_desc`)\nThis greedy algorithm counts the maximum number of pairs `(a_i, b_j)` such that `a_i + b_j >= x`.\nLet this count be `k`.\nThese `k` participants can all achieve a score of at least `x`.\nIn the worst case, Vasya is one of these `k` participants, and all `k` participants achieve scores `S_P >= S_V` (Vasya's score).\nIf there are `k` such participants, and Vasya is one of them, and all of them score `S_V` or higher, then Vasya's worst rank could be `k`.\nThe other `n-k` participants must score less than `x`.\nSo, the number of people who score at least `x` is `k`.\nVasya's worst rank will be `k`.\n\nLet's test this with the example:\n`n=5, x=2`\n`a = [1, 1, 1, 1, 1]`\n`b = [1, 1, 1, 1, 1]`\nSorted `a_asc = [1, 1, 1, 1, 1]`\nSorted `b_desc = [1, 1, 1, 1, 1]`\n`count = 0`, `j = 0`\n`i=0, a_asc[0]=1`. `j=0, b_desc[0]=1`. `1+1=2 >= x`. `count=1`, `j=1`.\n`i=1, a_asc[1]=1`. `j=1, b_desc[1]=1`. `1+1=2 >= x`. `count=2`, `j=2`.\n`i=2, a_asc[2]=1`. `j=2, b_desc[2]=1`. `1+1=2 >= x`. `count=3`, `j=3`.\n`i=3, a_asc[3]=1`. `j=3, b_desc[3]=1`. `1+1=2 >= x`. `count=4`, `j=4`.\n`i=4, a_asc[4]=1`. `j=4, b_desc[4]=1`. `1+1=2 >= x`. `count=5`, `j=5`.\nLoop ends. `count = 5`. Worst rank = 5. This matches the example output.\n\nSecond example:\n`n=6, x=7`\n`a = [4, 3, 5, 6, 4, 4]`\n`b = [8, 6, 0, 4, 3, 4]`\nSorted `a_asc = [3, 4, 4, 4, 5, 6]`\nSorted `b_desc = [8, 6, 4, 4, 3, 0]`\n`count = 0`, `j = 0`\n`i=0, a_asc[0]=3`.\n  `j=0, b_desc[0]=8`. `3+8=11 >= 7`. `count=1`, `j=1`. (Pair (3,8))\n`i=1, a_asc[1]=4`.\n  `j=1, b_desc[1]=6`. `4+6=10 >= 7`. `count=2`, `j=2`. (Pair (4,6))\n`i=2, a_asc[2]=4`.\n  `j=2, b_desc[2]=4`. `4+4=8 >= 7`. `count=3`, `j=3`. (Pair (4,4))\n`i=3, a_asc[3]=4`.\n  `j=3, b_desc[3]=4`. `4+4=8 >= 7`. `count=4`, `j=4`. (Pair (4,4))\n`i=4, a_asc[4]=5`.\n  `j=4, b_desc[4]=3`. `5+3=8 >= 7`. `count=5`, `j=5`. (Pair (5,3))\n`i=5, a_asc[5]=6`.\n  `j=5, b_desc[5]=0`. `6+0=6 < 7`. `j` becomes `6`. Loop ends.\nLoop ends. `count = 5`. Worst rank = 5. This matches the example output.\n\nThis greedy algorithm works because it maximizes the number of pairs that meet the `sum >= x` condition. To do this, it tries to use the smallest `a` values with the largest `b` values, but only if they satisfy the condition. If an `a_i` is too small even for the largest available `b_j`, then `a_i` cannot form a pair that sums to `x` or more. If `a_i` can form a pair with `b_j`, then we use them up and move on. This ensures that we make the most \"successful\" pairs. The number of such successful pairs represents the maximum number of participants who can achieve a score of at least `x`. In the worst case, Vasya is one of them, and all of them are ranked above or equal to Vasya. So his rank is this count.\n\nFinal check on logic:\nBest rank: Vasya can always achieve the maximum possible total score `max(a) + max(b)`. Since `max(a) + max(b) >= x` (guaranteed by problem statement, as `max(a)+max(b)` is at least any `a_i+b_j`), and no one can score higher, Vasya can be 1st.\nWorst rank: We need to maximize the number of people who score at least as much as Vasya. The greedy algorithm (sort `a` ascending, `b` descending, then pair `a_i` with `b_j` if `a_i + b_j >= x`) correctly finds the maximum number of participants (`k`) who can achieve a score of at least `x`. If `k` participants achieve `S_P >= x`, and Vasya is one of them, then in the worst case, all `k` participants score `S_V` or higher, placing Vasya at rank `k`.\n\nImplementation details:\n- Read `n, x`.\n- Read `a` and `b` lists.\n- For best rank, print `1`.\n- For worst rank:\n  - Sort `a` in ascending order.\n  - Sort `b` in descending order.\n  - Initialize `count = 0`, `j = 0`.\n  - Iterate `i` from `0` to `n-1`:\n    - While `j < n` and `a[i] + b[j] < x`:\n      `j += 1`\n    - If `j < n`:\n      `count += 1`\n      `j += 1`\n  - Print `count`.\n\n```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    # Best possible rank for Vasya\n    # Vasya can always achieve the maximum possible total score (max(a) + max(b)).\n    # The problem guarantees that there exist a_i, b_j such that a_i + b_j >= x.\n    # Therefore, max(a) + max(b) must also be >= x.\n    # Since no one can score higher than max(a) + max(b), Vasya can achieve this score\n    # and thus secure the 1st place.\n    best_rank = 1\n\n    # Worst possible rank for Vasya\n    # To find the worst rank, we want to maximize the number of participants\n    # who score at least Vasya's score (which must be >= x).\n    # This is equivalent to finding the maximum number of pairs (a_i, b_j)\n    # such that a_i + b_j >= x.\n    # We use a greedy approach:\n    # Sort 'a' in ascending order.\n    # Sort 'b' in descending order.\n    # Then try to form pairs (a_i, b_j) that satisfy the condition.\n    # By using the smallest available 'a' with the largest available 'b'\n    # (if it satisfies the condition), we maximize our chances to satisfy\n    # the condition for more participants.\n\n    a.sort()  # Sort a in ascending order\n    b.sort(reverse=True) # Sort b in descending order\n\n    worst_rank_count = 0\n    b_ptr = 0 # Pointer for sorted b (descending)\n\n    for a_val in a:\n        # Try to find a b_val such that a_val + b_val >= x\n        # We iterate b_ptr to find the smallest b_val (from b_descending)\n        # that satisfies the condition for the current a_val.\n        # If a_val + b[b_ptr] is already >= x, it means we found a valid pair.\n        # If not, we need to move b_ptr to a smaller b value (larger index)\n        # because a_val is too small for b[b_ptr] and any b[k] with k < b_ptr.\n        # Wait, the logic is: if a_val + b[b_ptr] < x, it means a_val is too small\n        # to form a pair >= x with b[b_ptr]. Since b is sorted descending, a_val\n        # won't work with any b[k] where k > b_ptr either. So, a_val cannot form\n        # a pair >= x with any *remaining* b values. This means a_val must be\n        # used for someone who scores < x. So we discard a_val and move to the next a.\n        # This is incorrect. The greedy approach is: if a[i] + b[j] >= x, we form a pair.\n        # To maximize pairs, we should use the current a[i] with b[j] and move both pointers.\n        # If a[i] + b[j] < x, it means a[i] is too small for b[j]. Since a is ascending,\n        # and b is descending, a[i] will be too small for b[j+1], b[j+2], etc.\n        # So b[j] cannot be paired with a[i] to reach x. We need to use b[j] with a larger a.\n        # So we discard b[j] and move to b[j+1]. This is also incorrect.\n\n        # Correct greedy for max pairs (a_i, b_j) s.t. a_i + b_j >= x:\n        # Sort a ascending, b ascending.\n        # Use two pointers: left for a (0 to n-1), right for b (n-1 down to 0).\n        # If a[left] + b[right] >= x:\n        #   We found a pair. Increment count, left++, right--.\n        # Else (a[left] + b[right] < x):\n        #   a[left] is too small to make x even with the largest available b[right].\n        #   So a[left] cannot be part of any pair >= x. We must use a[left]\n        #   for a participant who scores < x. So we increment left++.\n        #   b[right] remains available to be paired with a larger a.\n\n    a_ptr = 0\n    b_ptr = n - 1\n    count = 0\n    \n    # a is sorted ascending, b is sorted ascending.\n    # To maximize the number of pairs (a_i, b_j) such that a_i + b_j >= x:\n    # Use two pointers: one for 'a' starting from smallest, one for 'b' starting from largest.\n    # If a[a_ptr] + b[b_ptr] >= x, we found a pair. Increment count, move both pointers inward.\n    # Else (a[a_ptr] + b[b_ptr] < x), a[a_ptr] cannot form a sum >= x with b[b_ptr] (the largest available b).\n    # Since b values are non-increasing as b_ptr decreases, a[a_ptr] cannot form a sum >= x with any smaller b values either.\n    # So a[a_ptr] must be paired with some b_k such that a[a_ptr] + b_k < x.\n    # This means a[a_ptr] cannot be Vasya's score if Vasya must get >= x.\n    # So we effectively discard a[a_ptr] from consideration for forming a pair >= x and move to the next a_val.\n    # This means we increment a_ptr. b[b_ptr] is still available to be paired with a larger a_val.\n    \n    # This is the correct greedy approach for counting maximum pairs with sum >= x.\n    # a is sorted ascending. b is sorted ascending.\n    # b_ptr should start at n-1.\n    # The loop should be while a_ptr < n and b_ptr >= 0.\n    \n    # The sorted 'a' list is already `a`.\n    # The sorted 'b' list is `b_sorted_asc = sorted(b)`.\n    # Let's rename `b` to `b_sorted_asc` for clarity.\n    b_sorted_asc = sorted(b)\n\n    a_ptr = 0\n    b_ptr = n - 1 # Pointer to the largest available b value\n\n    while a_ptr < n and b_ptr >= 0:\n        if a[a_ptr] + b_sorted_asc[b_ptr] >= x:\n            # We found a pair (a[a_ptr], b_sorted_asc[b_ptr]) that sums to >= x.\n            # We use these two scores for one participant.\n            count += 1\n            a_ptr += 1\n            b_ptr -= 1\n        else:\n            # a[a_ptr] is too small to form a sum >= x even with the largest available b_sorted_asc[b_ptr].\n            # This means a[a_ptr] cannot be part of any pair that sums to >= x.\n            # So, we must use a[a_ptr] for a participant who will score less than x.\n            # We move to the next a_val. b_sorted_asc[b_ptr] remains available for a larger a_val.\n            a_ptr += 1\n\n    worst_rank = n - count + 1 # This is for counting people BELOW Vasya.\n                               # No, it's just `count`. If `count` people can score >= x,\n                               # Vasya is one of them. In the worst case, he's ranked `count`.\n    worst_rank = count\n\n\n    sys.stdout.write(f\"{best_rank} {worst_rank}\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    # Best possible rank for Vasya\n    # Vasya can always achieve the maximum possible total score (max(a) + max(b)).\n    # The problem guarantees that there exist a_i, b_j such that a_i + b_j >= x.\n    # Therefore, max(a) + max(b) must also be >= x.\n    # Since no one can score higher than max(a) + max(b), Vasya can achieve this score\n    # and thus secure the 1st place.\n    best_rank = 1\n\n    # Worst possible rank for Vasya\n    # To find the worst rank, we want to maximize the number of participants\n    # who score at least Vasya's score (which must be >= x).\n    # This is equivalent to finding the maximum number of pairs (a_i, b_j)\n    # such that a_i + b_j >= x.\n    # We use a greedy approach:\n    # Sort 'a' in ascending order.\n    # Sort 'b' in descending order.\n    # Then try to form pairs (a_i, b_j) that satisfy the condition.\n    # By using the smallest available 'a' with the largest available 'b'\n    # (if it satisfies the condition), we maximize our chances to satisfy\n    # the condition for more participants.\n\n    a.sort()  # Sort a in ascending order\n    b.sort(reverse=True) # Sort b in descending order\n\n    worst_rank_count = 0\n    b_ptr = 0 # Pointer for sorted b (descending)\n\n    for a_val in a:\n        # Try to find a b_val such that a_val + b_val >= x\n        # We iterate b_ptr to find the smallest b_val (from b_descending)\n        # that satisfies the condition for the current a_val.\n        # If a_val + b[b_ptr] is already >= x, it means we found a valid pair.\n        # If not, we need to move b_ptr to a smaller b value (larger index)\n        # because a_val is too small for b[b_ptr] and any b[k] with k < b_ptr.\n        # Wait, the logic is: if a_val + b[b_ptr] < x, it means a_val is too small\n        # to form a pair >= x with b[b_ptr]. Since b is sorted descending, a_val\n        # won't work with any b[k] where k > b_ptr either. So, a_val cannot form\n        # a pair >= x with any *remaining* b values. This means a_val must be\n        # used for someone who scores < x. So we discard a_val and move to the next a.\n        # This is incorrect. The greedy approach is: if a[i] + b[j] >= x, we form a pair.\n        # To maximize pairs, we should use the current a[i] with b[j] and move both pointers.\n        # If a[i] + b[j] < x, it means a[i] is too small for b[j]. Since a is ascending,\n        # and b is descending, a[i] will be too small for b[j+1], b[j+2], etc.\n        # So b[j] cannot be paired with a[i] to reach x. We need to use b[j] with a larger a.\n        # So we discard b[j] and move to b[j+1]. This is also incorrect.\n\n        # Correct greedy for max pairs (a_i, b_j) s.t. a_i + b_j >= x:\n        # Sort a ascending, b ascending.\n        # Use two pointers: left for a (0 to n-1), right for b (n-1 down to 0).\n        # If a[left] + b[right] >= x:\n        #   We found a pair. Increment count, left++, right--.\n        # Else (a[left] + b[right] < x):\n        #   a[left] is too small to make x even with the largest available b[right].\n        #   So a[left] cannot be part of any pair >= x. We must use a[left]\n        #   for a participant who scores < x. So we increment left++.\n        #   b[right] remains available to be paired with a larger a.\n\n    a_ptr = 0\n    b_ptr = n - 1\n    count = 0\n    \n    # a is sorted ascending, b is sorted ascending.\n    # To maximize the number of pairs (a_i, b_j) such that a_i + b_j >= x:\n    # Use two pointers: one for 'a' starting from smallest, one for 'b' starting from largest.\n    # If a[a_ptr] + b[b_ptr] >= x, we found a pair. Increment count, move both pointers inward.\n    # Else (a[a_ptr] + b[b_ptr] < x), a[a_ptr] cannot form a sum >= x with b[b_ptr] (the largest available b).\n    # Since b values are non-increasing as b_ptr decreases, a[a_ptr] cannot form a sum >= x with any smaller b values either.\n    # So a[a_ptr] must be paired with some b_k such that a[a_ptr] + b_k < x.\n    # This means a[a_ptr] cannot be Vasya's score if Vasya must get >= x.\n    # So we effectively discard a[a_ptr] from consideration for forming a pair >= x and move to the next a_val.\n    # This means we increment a_ptr. b[b_ptr] is still available to be paired with a larger a_val.\n    \n    # This is the correct greedy approach for counting maximum pairs with sum >= x.\n    # a is sorted ascending. b is sorted ascending.\n    # b_ptr should start at n-1.\n    # The loop should be while a_ptr < n and b_ptr >= 0.\n    \n    # The sorted 'a' list is already `a`.\n    # The sorted 'b' list is `b_sorted_asc = sorted(b)`.\n    # Let's rename `b` to `b_sorted_asc` for clarity.\n    b_sorted_asc = sorted(b)\n\n    a_ptr = 0\n    b_ptr = n - 1 # Pointer to the largest available b value\n\n    while a_ptr < n and b_ptr >= 0:\n        if a[a_ptr] + b_sorted_asc[b_ptr] >= x:\n            # We found a pair (a[a_ptr], b_sorted_asc[b_ptr]) that sums to >= x.\n            # We use these two scores for one participant.\n            count += 1\n            a_ptr += 1\n            b_ptr -= 1\n        else:\n            # a[a_ptr] is too small to form a sum >= x even with the largest available b_sorted_asc[b_ptr].\n            # This means a[a_ptr] cannot be part of any pair that sums to >= x.\n            # So, we must use a[a_ptr] for a participant who will score less than x.\n            # We move to the next a_val. b_sorted_asc[b_ptr] remains available for a larger a_val.\n            a_ptr += 1\n\n    worst_rank = n - count + 1 # This is for counting people BELOW Vasya.\n                               # No, it's just `count`. If `count` people can score >= x,\n                               # Vasya is one of them. In the worst case, he's ranked `count`.\n    worst_rank = count\n\n\n    sys.stdout.write(f\"{best_rank} {worst_rank}\\n\")\n\nsolve()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 873,
        "completion_token_count": 7419,
        "thoughts_token_count": 780
    }
}