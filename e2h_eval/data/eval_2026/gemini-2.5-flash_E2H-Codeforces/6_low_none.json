{
    "start": 1758009285.8925946,
    "end": 1758009331.3348935,
    "start-formatted": "2025-09-16 16:54 KST",
    "end-formatted": "2025-09-16 16:55 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "**Tackling a Competitive Programming Problem: Voucher Optimization**\n\nOkay, so I've got this competitive programming problem in front of me. The goal is to find two non-overlapping vouchers whose combined duration equals a target value *x*, while minimizing their total cost. The input seems straightforward: *n* vouchers, each defined by start time (*l_i*), end time (*r_i*), and cost (*cost_i*). The voucher duration *d_i* is simply *r_i - l_i + 1*. If I can't find a valid pair, I need to output -1.\n\nMy initial thought is to break down the problem into smaller, manageable pieces. The constraints are pretty tight: *n* and *x* are up to 2 * 10^5, and the costs can be as high as 10^9. This immediately tells me a brute-force approach, iterating through all pairs, is going to be far too slow, with a time complexity of O(n^2). I need something more efficient, ideally O(n log n) or even O(n).\n\nThe non-overlapping condition is the key here. It means that either one voucher ends before the other starts. So, if I fix one voucher *i*, I need to find another voucher *j* whose duration, *d_j*, is equal to *x - d_i*.  I also need to ensure that the two vouchers don't overlap. That's the real challenge.\n\nSorting feels like the right direction. But what should I sort by? Sorting by start time (*l_i*) seems like a good starting point. If I sort the vouchers based on their start times, I can easily iterate through them. Let's see... If I'm looking at voucher *k*, I need to find voucher *j* that either ends before *k* begins or starts after *k* ends.\n\nThinking this through...  I can rephrase the whole problem. I want two vouchers, say *A* and *B*, that add up to the right duration. Either voucher *A* ends before voucher *B* starts ( *r_A* < *l_B*), or *B* ends before *A* starts.  I'll start with start times.\nAs I process the vouchers sorted by their start times, for a voucher (*l_i*, *r_i*, *cost_i*), I will check... I will need to think how to make efficient checks based on that.\n",
    "response": "The problem asks us to find two distinct vouchers `i` and `j` such that their total duration `(r_i - l_i + 1) + (r_j - l_j + 1)` is exactly `x`, they do not overlap (i.e., `r_i < l_j` or `r_j < l_i`), and their combined cost `cost_i + cost_j` is minimized.\n\nLet's denote the duration of voucher `k` as `d_k = r_k - l_k + 1`.\nThe conditions are:\n1.  `d_i + d_j = x`\n2.  `r_i < l_j` or `r_j < l_i`\n3.  Minimize `cost_i + cost_j`\n\nThe maximum value for `r_i` is `2 * 10^5`. Let's call this `MAX_COORD`. The maximum duration `x` is also `2 * 10^5`.\n\nWe can iterate through all vouchers and for each voucher `i`, try to find a suitable second voucher `j`. To do this efficiently, we need a way to quickly query for the minimum cost of a voucher `j` that satisfies the duration and non-overlapping conditions.\n\nA common technique for interval problems is to sort by start or end times. Let's sort all vouchers by their start times `l_i`. If `l_i` are equal, sort by `r_i`.\n\nWe can process the vouchers in two passes or by using a sweep-line approach. Let's consider a sweep-line approach based on `l_i`.\nWhen we process a voucher `(l, r, cost)`:\n1.  It could be the first voucher (`i`) of a pair where `r < l_j`.\n2.  It could be the second voucher (`j`) of a pair where `r_i < l`.\n\nTo handle the second case efficiently, we need to know the minimum cost of vouchers that *ended* at or before `l-1` and have a specific duration.\nTo handle the first case, we would need to store information about the current voucher to be used by future vouchers.\n\nLet's refine this. We can iterate through all possible end days `R` from `1` to `MAX_COORD`. When we are at day `R`:\n1.  Consider all vouchers that *end* on day `R`. For each such voucher `(l, R, cost)` with duration `d = R - l + 1`:\n    *   This voucher could be the first voucher (`i`) of a pair. We need to find a `j` such that `l_j > R` and `d_j = x - d`.\n    *   This voucher could be the second voucher (`j`) of a pair. We need to find an `i` such that `r_i < l` and `d_i = x - d`.\n\nThis seems complicated because `l_j > R` depends on future vouchers, and `r_i < l` depends on past vouchers.\n\nA more structured approach:\nWe want to find `min(cost_i + cost_j)` such that `d_i + d_j = x` and `r_i < l_j`. (The case `r_j < l_i` is symmetric, we can just swap `i` and `j` or process all pairs and take the minimum).\n\nLet's store vouchers grouped by their duration.\n`vouchers_by_duration[duration]` will be a list of `(l, r, cost)` for all vouchers with that `duration`.\n\nWe iterate through all possible durations `d1` from `1` to `x-1`.\nFor each `d1`, we need `d2 = x - d1`.\nWe are looking for `(l1, r1, cost1)` with duration `d1` and `(l2, r2, cost2)` with duration `d2` such that `r1 < l2`.\n\nThis still looks like `O(N^2)` if we iterate through all pairs of vouchers.\nWe need a way to find the minimum `cost2` for a given `d2` and `l2 > r1`.\n\nLet's try a sweep-line approach over the days `1` to `MAX_COORD`.\nWe'll maintain an array `min_cost_ending_on_day[duration]`. This array stores the minimum cost of a voucher with `duration` that *has already ended* by the current day.\nInitialize `min_cost_ending_on_day` with infinity for all durations.\n\nIterate `day` from `1` to `MAX_COORD`:\n1.  **Update minimum costs for vouchers ending on `day - 1`**:\n    For each voucher `(l, r, cost)` such that `r = day - 1`:\n    *   Calculate its duration `d = r - l + 1`.\n    *   Update `min_cost_ending_on_day[d] = min(min_cost_ending_on_day[d], cost)`.\n    This means `min_cost_ending_on_day[d]` now holds the minimum cost of a voucher of duration `d` that ends *on or before* `day - 1`.\n\n2.  **Process vouchers starting on `day`**:\n    For each voucher `(l, r, cost)` such that `l = day`:\n    *   Calculate its duration `d1 = r - l + 1`.\n    *   We are looking for a second voucher `j` with duration `d2 = x - d1` such that `r_j < l = day`.\n    *   The minimum cost for such a `j` is `min_cost_ending_on_day[d2]`.\n    *   If `d1 < x` (so `d2 > 0`), and `min_cost_ending_on_day[d2]` is not infinity:\n        *   Update the overall minimum total cost: `min_total_cost = min(min_total_cost, cost + min_cost_ending_on_day[d2])`.\n\nLet's refine the update step. `min_cost_ending_on_day[d]` should store the minimum cost of a voucher of duration `d` that *ends strictly before* the current `day`.\nThis means `min_cost_ending_on_day[d]` represents `min(cost_k)` for all `k` such that `r_k < day` and `d_k = d`.\n\nInitialize `min_cost_for_duration[d]` to infinity for all `d`. This array will store the minimum cost of any voucher with duration `d` encountered so far, regardless of its end time.\nInitialize `min_cost_ending_before_day[d]` to infinity for all `d`. This array will store the minimum cost of a voucher with duration `d` that has ended *before* the current `day`.\n\nLet `MAX_R = 2 * 10^5`.\n`min_cost_ending_before_day = [float('inf')] * (x + 1)`\n`ans = float('inf')`\n\nGroup vouchers by their start day `l` and end day `r`.\n`vouchers_by_start_day[l]` is a list of `(r, cost)` for vouchers starting on day `l`.\n`vouchers_by_end_day[r]` is a list of `(l, cost)` for vouchers ending on day `r`.\n\nThe maximum coordinate value is `2 * 10^5`. Let's iterate `current_day` from `1` to `MAX_R`.\n\nFor each `current_day`:\n1.  **Process vouchers that *start* on `current_day`**:\n    For each `(r, cost)` in `vouchers_by_start_day[current_day]`:\n        Let `d1 = r - current_day + 1`.\n        If `d1 < x`: // We need a second voucher, so d1 must be less than x\n            Let `d2 = x - d1`.\n            If `d2 > 0` and `d2 <= x`: // Ensure d2 is a valid duration\n                If `min_cost_ending_before_day[d2]` is not `inf`:\n                    `ans = min(ans, cost + min_cost_ending_before_day[d2])`\n\n2.  **Process vouchers that *end* on `current_day`**:\n    For each `(l, cost)` in `vouchers_by_end_day[current_day]`:\n        Let `d = current_day - l + 1`.\n        If `d <= x`: // Only update for durations relevant to x\n            `min_cost_ending_before_day[d] = min(min_cost_ending_before_day[d], cost)`\n\nAfter iterating through all `current_day` from `1` to `MAX_R`:\nIf `ans` is still `inf`, it's impossible, print `-1`. Otherwise, print `ans`.\n\nLet's trace with an example:\n`n=4, x=5`\nVouchers: `(1,3,4), (1,2,5), (5,6,1), (1,2,4)`\n\n`MAX_R = 6`\n`min_cost_ending_before_day = [inf] * (5+1)` (indices 0 to 5)\n`ans = inf`\n\n`vouchers_by_start_day`:\n`1: [(3,4), (2,5), (2,4)]`\n`5: [(6,1)]`\n\n`vouchers_by_end_day`:\n`2: [(1,5), (1,4)]`\n`3: [(1,4)]`\n`6: [(5,1)]`\n\n`current_day = 1`:\n1.  **Start on day 1**:\n    *   `(r=3, cost=4)`: `d1 = 3-1+1 = 3`. `d2 = 5-3 = 2`. `min_cost_ending_before_day[2]` is `inf`. No update to `ans`.\n    *   `(r=2, cost=5)`: `d1 = 2-1+1 = 2`. `d2 = 5-2 = 3`. `min_cost_ending_before_day[3]` is `inf`. No update to `ans`.\n    *   `(r=2, cost=4)`: `d1 = 2-1+1 = 2`. `d2 = 5-2 = 3`. `min_cost_ending_before_day[3]` is `inf`. No update to `ans`.\n2.  **End on day 1**: No vouchers end on day 1.\n\n`current_day = 2`:\n1.  **Start on day 2**: No vouchers.\n2.  **End on day 2**:\n    *   `(l=1, cost=5)`: `d = 2-1+1 = 2`. `min_cost_ending_before_day[2] = min(inf, 5) = 5`.\n    *   `(l=1, cost=4)`: `d = 2-1+1 = 2`. `min_cost_ending_before_day[2] = min(5, 4) = 4`.\n    `min_cost_ending_before_day` is now `[inf, inf, 4, inf, inf, inf]`\n\n`current_day = 3`:\n1.  **Start on day 3**: No vouchers.\n2.  **End on day 3**:\n    *   `(l=1, cost=4)`: `d = 3-1+1 = 3`. `min_cost_ending_before_day[3] = min(inf, 4) = 4`.\n    `min_cost_ending_before_day` is now `[inf, inf, 4, 4, inf, inf]`\n\n`current_day = 4`:\n1.  **Start on day 4**: No vouchers.\n2.  **End on day 4**: No vouchers.\n\n`current_day = 5`:\n1.  **Start on day 5**:\n    *   `(r=6, cost=1)`: `d1 = 6-5+1 = 2`. `d2 = 5-2 = 3`.\n        `min_cost_ending_before_day[3]` is `4`.\n        `ans = min(inf, 1 + 4) = 5`.\n2.  **End on day 5**: No vouchers.\n\n`current_day = 6`:\n1.  **Start on day 6**: No vouchers.\n2.  **End on day 6**:\n    *   `(l=5, cost=1)`: `d = 6-5+1 = 2`. `min_cost_ending_before_day[2] = min(4, 1) = 1`.\n    `min_cost_ending_before_day` is now `[inf, inf, 1, 4, inf, inf]`\n\nLoop ends. `ans = 5`. This matches the example output.\n\nThis approach seems correct.\n**Complexity Analysis**:\n*   **Initialization**: `MAX_R` arrays, `O(MAX_R + N)`.\n*   **Grouping vouchers**: Iterate `N` vouchers. Each voucher goes into two lists. `O(N)`.\n*   **Sweep-line loop**: `MAX_R` iterations.\n    *   Inside loop, processing `vouchers_by_start_day[current_day]`: Sum of lengths of all `vouchers_by_start_day` lists is `N`. Total `O(N)`.\n    *   Inside loop, processing `vouchers_by_end_day[current_day]`: Sum of lengths of all `vouchers_by_end_day` lists is `N`. Total `O(N)`.\nTotal time complexity: `O(N + MAX_R)`.\nSince `N, MAX_R <= 2 * 10^5`, this is `O(2 * 10^5)`, which is efficient enough.\n\n**Space Complexity**:\n*   `vouchers_by_start_day`: `O(N + MAX_R)` (lists of lists, up to `N` elements total, `MAX_R` possible keys).\n*   `vouchers_by_end_day`: `O(N + MAX_R)`.\n*   `min_cost_ending_before_day`: `O(x)`.\nTotal space complexity: `O(N + MAX_R + x)`. This is `O(2 * 10^5)`, which is fine.\n\n**Edge Cases**:\n*   `x=2`: Minimum possible `x`. `d1=1, d2=1`. Works.\n*   No solution: `ans` remains `inf`, print `-1`.\n*   `n=2`: Only two vouchers. Check if they satisfy conditions. The algorithm will correctly process them. For example, if `(1,2,10)` and `(4,5,20)` and `x=4`.\n    *   `d1 = 2-1+1=2`, `d2 = 5-4+1=2`. `d1+d2=4`.\n    *   `r1=2 < l2=4`.\n    *   `cost=10+20=30`.\n    The algorithm should find this.\n    When `current_day=1`, `(1,2,10)` starts. `d1=2, d2=2`. `min_cost_ending_before_day[2]` is `inf`. No `ans` update.\n    When `current_day=2`, `(1,2,10)` ends. `d=2`. `min_cost_ending_before_day[2]=10`.\n    When `current_day=4`, `(4,5,20)` starts. `d1=2, d2=2`. `min_cost_ending_before_day[2]` is `10`. `ans = min(inf, 20+10) = 30`. Correct.\n\nThe maximum `r_i` is `2 * 10^5`.\n`x` is up to `2 * 10^5`.\nThe duration `d` can be up to `2 * 10^5`. So `min_cost_ending_before_day` array size should be `x + 1` or `MAX_R + 1` (whichever is larger, `x` is the relevant max index for duration).\n`MAX_R` can be used as the upper bound for days.\n\nThe value `float('inf')` for costs should be `10^9 * 2 + 1` (max possible cost + 1) to avoid issues with `float('inf')` in competitive programming if there are any subtle comparisons, but `float('inf')` is generally fine.\n\n```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n\n    # Max coordinate value for l_i, r_i is 2 * 10^5\n    MAX_COORD = 200000\n\n    # vouchers_by_start_day[l] stores a list of (r, cost) for vouchers starting on day l\n    vouchers_by_start_day = [[] for _ in range(MAX_COORD + 1)]\n    # vouchers_by_end_day[r] stores a list of (l, cost) for vouchers ending on day r\n    vouchers_by_end_day = [[] for _ in range(MAX_COORD + 1)]\n\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        vouchers_by_start_day[l].append((r, cost))\n        vouchers_by_end_day[r].append((l, cost))\n\n    # min_cost_ending_before_day[d] stores the minimum cost of a voucher\n    # with duration d that has ended strictly before the current_day.\n    # Initialize with a value larger than any possible sum of costs (2 * 10^9 + 1)\n    # or float('inf')\n    min_cost_ending_before_day = [float('inf')] * (x + 1)\n\n    ans = float('inf')\n\n    # Iterate through each day from 1 to MAX_COORD\n    for current_day in range(1, MAX_COORD + 1):\n        # Step 1: Process vouchers that start on current_day\n        # These vouchers could be the second voucher in a pair (j)\n        # We look for a first voucher (i) that ended before current_day\n        for r1, cost1 in vouchers_by_start_day[current_day]:\n            d1 = r1 - current_day + 1\n            if d1 < x:  # We need a second voucher, so d1 must be less than x\n                d2 = x - d1\n                if 1 <= d2 <= x: # d2 must be a valid duration\n                    if min_cost_ending_before_day[d2] != float('inf'):\n                        ans = min(ans, cost1 + min_cost_ending_before_day[d2])\n\n        # Step 2: Process vouchers that end on current_day\n        # These vouchers become candidates for min_cost_ending_before_day for future days\n        # They are now available to be the first voucher in a pair (i) for future starting vouchers (j)\n        for l0, cost0 in vouchers_by_end_day[current_day]:\n            d0 = current_day - l0 + 1\n            if 1 <= d0 <= x: # Only update for durations relevant to x\n                min_cost_ending_before_day[d0] = min(min_cost_ending_before_day[d0], cost0)\n\n    if ans == float('inf'):\n        sys.stdout.write(\"-1\\n\")\n    else:\n        sys.stdout.write(str(ans) + \"\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n\n    # Max coordinate value for l_i, r_i is 2 * 10^5\n    MAX_COORD = 200000\n\n    # vouchers_by_start_day[l] stores a list of (r, cost) for vouchers starting on day l\n    vouchers_by_start_day = [[] for _ in range(MAX_COORD + 1)]\n    # vouchers_by_end_day[r] stores a list of (l, cost) for vouchers ending on day r\n    vouchers_by_end_day = [[] for _ in range(MAX_COORD + 1)]\n\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        vouchers_by_start_day[l].append((r, cost))\n        vouchers_by_end_day[r].append((l, cost))\n\n    # min_cost_ending_before_day[d] stores the minimum cost of a voucher\n    # with duration d that has ended strictly before the current_day.\n    # Initialize with a value larger than any possible sum of costs (2 * 10^9 + 1)\n    # or float('inf')\n    min_cost_ending_before_day = [float('inf')] * (x + 1)\n\n    ans = float('inf')\n\n    # Iterate through each day from 1 to MAX_COORD\n    for current_day in range(1, MAX_COORD + 1):\n        # Step 1: Process vouchers that start on current_day\n        # These vouchers could be the second voucher in a pair (j)\n        # We look for a first voucher (i) that ended before current_day\n        for r1, cost1 in vouchers_by_start_day[current_day]:\n            d1 = r1 - current_day + 1\n            if d1 < x:  # We need a second voucher, so d1 must be less than x\n                d2 = x - d1\n                if 1 <= d2 <= x: # d2 must be a valid duration\n                    if min_cost_ending_before_day[d2] != float('inf'):\n                        ans = min(ans, cost1 + min_cost_ending_before_day[d2])\n\n        # Step 2: Process vouchers that end on current_day\n        # These vouchers become candidates for min_cost_ending_before_day for future days\n        # They are now available to be the first voucher in a pair (i) for future starting vouchers (j)\n        for l0, cost0 in vouchers_by_end_day[current_day]:\n            d0 = current_day - l0 + 1\n            if 1 <= d0 <= x: # Only update for durations relevant to x\n                min_cost_ending_before_day[d0] = min(min_cost_ending_before_day[d0], cost0)\n\n    if ans == float('inf'):\n        sys.stdout.write(\"-1\\n\")\n    else:\n        sys.stdout.write(str(ans) + \"\\n\")\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 789,
        "completion_token_count": 4662,
        "thoughts_token_count": 825
    }
}