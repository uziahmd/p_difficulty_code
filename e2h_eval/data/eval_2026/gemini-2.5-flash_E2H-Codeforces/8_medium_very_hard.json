{
    "start": 1758011930.942517,
    "end": 1758012008.9827795,
    "start-formatted": "2025-09-16 17:38 KST",
    "end-formatted": "2025-09-16 17:40 KST",
    "gpu": 2,
    "pid": 8,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "**Solving \"Flawed Flow\"**\n\nOkay, so I'm tackling this \"Flawed Flow\" problem, which boils down to figuring out how to direct the flow on the edges of an undirected graph.  The key is that the resulting directed graph *must* be acyclic, and we need to satisfy flow conservation. We are given the amount of flow for each edge, so the direction is the only variable.\n\nI know the source (vertex 1) can't have any incoming flow, and for intermediate vertices (not 1 or *n*), the amount of incoming flow has to equal the outgoing flow. The sink vertex (*n*) might have outgoing edges, but they don't contribute to total s-t flow. The fact that a solution is guaranteed is a relief!\n\nThe most challenging part is ensuring no cycles. This makes me think topological ordering is key. If I can find a topological sort, all the edges should point forward in the ordering. This gives me a framework for figuring out the edge directions!\n\nThe intermediate nodes need *equal* in and out flow, which translates into the incoming flow being D_v / 2, where D_v is the sum of capacities of edges touching the vertex. Also, `D_v` must be even.\n\nLet's use a \"balance\" approach. Each node will have a `current_balance`, which will be the total outflow minus the inflow. We initialize the balance to zero for all nodes except source and sink.  For `1 < v < n`, we want `balance[v] = 0`. For the source, we want balance to be the total flow. And for the sink, we want balance to be -total flow, but we can process sink like any other.\n\nI can make this work by starting at the source and sink because these vertices have constraints. All edges incident to 1 must be out, and all edges incident to *n* must be in. I will create a queue and add 1 and *n* to the queue. For these vertices, I can direct all its incident edges. As I direct an edge I update the balance of the adjacent vertex. If a vertex has only one undirected edge left, then that edge's direction is determined so I'll add that vertex to the queue. I keep processing the vertices in the queue until I've gone over every vertex. This queue approach with balance will allow me to propagate the direction decisions. It feels like the right approach. Let's start coding!\n",
    "response": "The problem asks us to direct edges in a given undirected graph, each with a specified flow volume, such that certain conditions are met. We are given `n` vertices and `m` edges. Vertices 1 and `n` are the source and sink, respectively.\n\nThe conditions are:\n1. For any intermediate vertex `v` (1 < `v` < `n`), the sum of incoming flow must equal the sum of outgoing flow.\n2. Vertex 1 (source) must have no incoming edges.\n3. The resulting directed graph must not contain cycles.\n\nLet's define `balance[v]` for each vertex `v` as `(total_outgoing_flow_from_v - total_incoming_flow_to_v)`.\nBased on the conditions:\n- For `1 < v < n`: `balance[v]` must eventually be 0. This implies that for any such `v`, the total capacity of edges incident to `v` (`D_v = sum(c_i)` for all edges `(u,v,c_i)`) must be an even number. If `D_v` is the total flow passing through `v`, then `D_v/2` must be incoming and `D_v/2` must be outgoing.\n- For `v = 1`: `balance[1]` must be `F_total` (the total max flow). Since it has no incoming edges, all flow on edges incident to 1 must be outgoing.\n- For `v = n`: `balance[n]` must be `-F_total`. This implies `n` has no outgoing edges, and all flow on edges incident to `n` must be incoming. (This is a standard interpretation of a sink in max-flow problems and is consistent with the problem examples).\n\nThe \"no cycles\" condition is important. It suggests that we can process vertices in a topological order. Since we don't know the topological order beforehand, we need a method that implicitly builds one or is guaranteed to work in a DAG. A common strategy for problems like this is to process nodes whose \"state\" becomes determined.\n\nLet's maintain `current_balance[v]` for each vertex `v`, initialized to 0. When an edge `(u, v)` with flow `c` is directed `u -> v`, we update `current_balance[u] += c` and `current_balance[v] -= c`.\n\nThe core idea is to use a queue-based approach (similar to Kahn's algorithm for topological sort) to determine edge directions. We identify vertices whose `current_balance` is \"fixed\" or \"constrained\" to determine the direction of their remaining undirected edges.\n\nAlgorithm:\n1.  **Data Structures:**\n    *   `adj`: An adjacency list where `adj[u]` stores `(v, capacity, edge_index)` for each edge `(u, v)` (or `(v, u)`).\n    *   `ans`: An array of size `m` to store the direction for each edge. `ans[i] = 0` for `a_i -> b_i`, `ans[i] = 1` for `b_i -> a_i`. Initialize with `-1` (undetermined).\n    *   `current_balance`: An array of size `n+1`, initialized to 0. This tracks `(out_flow - in_flow)` for each vertex based on directed edges.\n    *   `num_undirected_edges`: An array of size `n+1`, storing the count of undirected edges incident to each vertex. Initialize with the degree of each vertex.\n    *   `q`: A deque (double-ended queue) for processing vertices.\n\n2.  **Initialization:**\n    *   For `v = 1` (source): Add `v` to `q`.\n    *   For `v = n` (sink): Add `v` to `q`.\n\n3.  **Main Loop (BFS-like):**\n    While `q` is not empty:\n    *   Dequeue a vertex `u`.\n    *   Iterate through all neighbors `v` of `u` via edge `(u, v)` with capacity `c` and `edge_idx`:\n        *   If `ans[edge_idx]` is already determined (not -1), skip this edge.\n        *   **Determine Direction:**\n            *   **Case 1: `u = 1` (Source)**\n                All edges from the source must be outgoing. So, direct `1 -> v`.\n                `ans[edge_idx] = 0` if the original edge was `(1, v)`, `1` if it was `(v, 1)`.\n            *   **Case 2: `u = n` (Sink)**\n                All edges to the sink must be incoming. So, direct `v -> n`.\n                `ans[edge_idx] = 0` if the original edge was `(v, n)`, `1` if it was `(n, v)`.\n            *   **Case 3: `1 < u < n` (Intermediate Vertex)**\n                For an intermediate vertex `u`, we need `current_balance[u]` to eventually be 0.\n                The total flow through `u` is `D_u = sum(c_i)` for all edges incident to `u`. Thus, `u` must have `D_u/2` incoming flow and `D_u/2` outgoing flow.\n                If `u` has only one remaining undirected edge `(u, v)` (i.e., `num_undirected_edges[u] == 1`), its direction is fully determined by `u`'s `current_balance`.\n                If `current_balance[u]` is positive, `u` has too much outgoing flow, so the last edge `(u, v)` must be `v -> u` to bring `current_balance[u]` down towards 0.\n                If `current_balance[u]` is negative, `u` has too much incoming flow, so the last edge `(u, v)` must be `u -> v` to bring `current_balance[u]` up towards 0.\n                Specifically, if `current_balance[u] < 0`, direct `u -> v`. If `current_balance[u] > 0`, direct `v -> u`.\n                (Note: Since `D_u` is even, `current_balance[u]` will always have the same parity as `D_u/2` when `num_undirected_edges[u]` is odd, and `current_balance[u]` will have the same parity as `D_u` when `num_undirected_edges[u]` is even. The problem guarantees a solution, so `current_balance[u]` will be `D_u/2` or `-D_u/2` in magnitude when only one edge remains, and we direct it to make it zero.)\n\n        *   **Update Balances and Counts:**\n            *   Based on the determined direction (e.g., `u -> v`):\n                `current_balance[u] += c`\n                `current_balance[v] -= c`\n            *   Decrement `num_undirected_edges[u]` and `num_undirected_edges[v]`.\n            *   If `num_undirected_edges[v] == 1` and `v` is not 1 or `n`, add `v` to `q`. This ensures that `v` gets processed when its last edge needs to be directed.\n\n4.  **Output:** Print the `ans` array.\n\n**Detailed handling of directions and `ans` array:**\nThe input gives edges as `(a_i, b_i, c_i)`.\nIf we decide `a_i -> b_i`, `ans[i] = 0`.\nIf we decide `b_i -> a_i`, `ans[i] = 1`.\n\nWhen processing an edge `(u, v, c, edge_idx)`:\n*   If `u` is `a_i` and `v` is `b_i`:\n    *   If `u -> v`: `ans[edge_idx] = 0`.\n    *   If `v -> u`: `ans[edge_idx] = 1`.\n*   If `u` is `b_i` and `v` is `a_i`:\n    *   If `u -> v`: `ans[edge_idx] = 1`.\n    *   If `v -> u`: `ans[edge_idx] = 0`.\n\nThis logic ensures that for a general edge `(U, V)` with capacity `C` and index `E_idx` in the adjacency list for `u`:\nIf `u` is `a_{E_idx}`:\n  If we direct `u -> V`: `ans[E_idx] = 0`.\n  If we direct `V -> u`: `ans[E_idx] = 1`.\nIf `u` is `b_{E_idx}`:\n  If we direct `u -> V`: `ans[E_idx] = 1`.\n  If we direct `V -> u`: `ans[E_idx] = 0`.\n\nThe \"no cycles\" condition is implicitly satisfied because we are always directing edges from a \"more determined\" node to a \"less determined\" node, or from source/to sink, ensuring a consistent flow path without circular dependencies.\n\n**Example Walkthrough (Example 1):**\n`n=3, m=3`\nEdges:\n0: `(3, 2, 10)`\n1: `(1, 2, 10)`\n2: `(3, 1, 5)`\n\nInitial:\n`adj`:\n1: `[(2, 10, 1), (3, 5, 2)]`\n2: `[(3, 10, 0), (1, 10, 1)]`\n3: `[(2, 10, 0), (1, 5, 2)]`\n`ans = [-1, -1, -1]`\n`current_balance = [0, 0, 0, 0]`\n`num_undirected_edges = [0, 2, 2, 2]` (degree of each vertex)\n`q = deque([1, 3])` (source 1, sink 3)\n\n1.  **Dequeue `u = 1` (source):**\n    *   Edge `(1, 2, 10, 1)`: `1 -> 2`. `ans[1] = 0`.\n        `current_balance[1] += 10`, `current_balance[2] -= 10`. (`bal = [0, 10, -10, 0]`)\n        `num_undirected_edges[1] -= 1`, `num_undirected_edges[2] -= 1`. (`num_undirected = [0, 1, 1, 2]`)\n        `num_undirected_edges[2]` is now 1, `2` is not 1 or `n`, so `q.append(2)`.\n    *   Edge `(1, 3, 5, 2)`: `1 -> 3`. `ans[2] = 0` (original edge was `(3,1,5)`, so `b_i` is 1, `a_i` is 3. `1->3` means `b_i -> a_i` so `ans[2]=1`).\n        `current_balance[1] += 5`, `current_balance[3] -= 5`. (`bal = [0, 15, -10, -5]`)\n        `num_undirected_edges[1] -= 1`, `num_undirected_edges[3] -= 1`. (`num_undirected = [0, 0, 1, 1]`)\n        `num_undirected_edges[3]` is now 1, but `3` is `n`, so don't add to `q`.\n\n2.  **Dequeue `u = 3` (sink):**\n    *   Edge `(3, 2, 10, 0)`: `ans[0]` is -1. `3` is sink, so flow must be `v -> 3`. This edge is `(3,2)`, so `2 -> 3`. `ans[0] = 1`.\n        `current_balance[2] += 10`, `current_balance[3] -= 10`. (`bal = [0, 15, 0, -15]`)\n        `num_undirected_edges[2] -= 1`, `num_undirected_edges[3] -= 1`. (`num_undirected = [0, 0, 0, 0]`)\n        `num_undirected_edges[2]` is 0, no need to add to `q`.\n    *   Edge `(3, 1, 5, 2)`: `ans[2]` is 1, skip.\n\n3.  **Dequeue `u = 2` (intermediate):**\n    *   `num_undirected_edges[2]` is 0, skip.\n\n`q` is empty. Final `ans`: `[1, 0, 1]`. This matches the example output.\n\n```python\nimport sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    # Store edges: adj[u] will contain (v, capacity, original_edge_index, is_original_a)\n    # is_original_a is True if u was a_i in input, False if u was b_i\n    adj = [[] for _ in range(n + 1)]\n    edges_input = [] # To store (a_i, b_i, c_i) for final direction check\n\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        adj[u].append((v, c, i, True))  # u is a_i\n        adj[v].append((u, c, i, False)) # v is b_i (so u is b_i for edge (v,u))\n        edges_input.append((u, v, c))\n\n    ans = [-1] * m # 0 for a_i -> b_i, 1 for b_i -> a_i\n    current_balance = [0] * (n + 1) # out_flow - in_flow\n    num_undirected_edges = [0] * (n + 1) # count of undirected edges incident to each node\n\n    for u in range(1, n + 1):\n        num_undirected_edges[u] = len(adj[u])\n\n    q = deque()\n\n    # Initialize queue with source and sink\n    q.append(1)\n    q.append(n)\n\n    # Use a set to keep track of nodes already added to queue to avoid duplicates\n    # and re-processing nodes whose last edge has already been directed.\n    # We only add nodes to the queue if their num_undirected_edges becomes 1.\n    # Nodes 1 and n are special and are always added initially.\n    in_queue = {1, n}\n\n    while q:\n        u = q.popleft()\n\n        # Iterate through neighbors of u\n        # Create a list of edges to process to avoid modifying adj while iterating\n        edges_to_process = list(adj[u]) \n        \n        for v, c, edge_idx, u_is_a in edges_to_process:\n            if ans[edge_idx] != -1:\n                continue # Edge already directed\n\n            # Determine direction\n            direction_chosen = -1 # 0 for u -> v, 1 for v -> u\n            \n            if u == 1: # Source: all edges outgoing\n                direction_chosen = 0 # u -> v\n            elif u == n: # Sink: all edges incoming\n                direction_chosen = 1 # v -> u\n            elif num_undirected_edges[u] == 1: # Intermediate node with one remaining edge\n                # If current_balance[u] is negative, u has too much incoming flow.\n                # The last edge must be outgoing from u to balance it.\n                if current_balance[u] < 0:\n                    direction_chosen = 0 # u -> v\n                # If current_balance[u] is positive, u has too much outgoing flow.\n                # The last edge must be incoming to u to balance it.\n                else: # current_balance[u] > 0\n                    direction_chosen = 1 # v -> u\n            else:\n                # This case should not be reached if the problem guarantees a solution\n                # and our logic is sound for reducing to num_undirected_edges[u] == 1\n                continue # Skip if direction not determined yet\n\n            # Apply the chosen direction\n            if direction_chosen == 0: # u -> v\n                current_balance[u] += c\n                current_balance[v] -= c\n                \n                # Set ans based on original (a_i, b_i)\n                if u_is_a: # u was a_i, v was b_i\n                    ans[edge_idx] = 0 # a_i -> b_i\n                else: # u was b_i, v was a_i\n                    ans[edge_idx] = 1 # b_i -> a_i\n            else: # v -> u\n                current_balance[v] += c\n                current_balance[u] -= c\n\n                # Set ans based on original (a_i, b_i)\n                if u_is_a: # u was a_i, v was b_i\n                    ans[edge_idx] = 1 # b_i -> a_i (which is v -> u)\n                else: # u was b_i, v was a_i\n                    ans[edge_idx] = 0 # a_i -> b_i (which is v -> u)\n\n            # Update undirected edge counts\n            num_undirected_edges[u] -= 1\n            num_undirected_edges[v] -= 1\n\n            # Add v to queue if it now has only one undirected edge left and it's not source/sink\n            if num_undirected_edges[v] == 1 and v != 1 and v != n and v not in in_queue:\n                q.append(v)\n                in_queue.add(v)\n            \n            # Remove v from in_queue if all its edges are processed\n            if num_undirected_edges[v] == 0 and v in in_queue:\n                in_queue.remove(v)\n\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + '\\n')\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    # Store edges: adj[u] will contain (v, capacity, original_edge_index, is_original_a)\n    # is_original_a is True if u was a_i in input, False if u was b_i\n    adj = [[] for _ in range(n + 1)]\n    edges_input = [] # To store (a_i, b_i, c_i) for final direction check\n\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        adj[u].append((v, c, i, True))  # u is a_i\n        adj[v].append((u, c, i, False)) # v is b_i (so u is b_i for edge (v,u))\n        edges_input.append((u, v, c))\n\n    ans = [-1] * m # 0 for a_i -> b_i, 1 for b_i -> a_i\n    current_balance = [0] * (n + 1) # out_flow - in_flow\n    num_undirected_edges = [0] * (n + 1) # count of undirected edges incident to each node\n\n    for u in range(1, n + 1):\n        num_undirected_edges[u] = len(adj[u])\n\n    q = deque()\n\n    # Initialize queue with source and sink\n    q.append(1)\n    q.append(n)\n\n    # Use a set to keep track of nodes already added to queue to avoid duplicates\n    # and re-processing nodes whose last edge has already been directed.\n    # We only add nodes to the queue if their num_undirected_edges becomes 1.\n    # Nodes 1 and n are special and are always added initially.\n    in_queue = {1, n}\n\n    while q:\n        u = q.popleft()\n\n        # Iterate through neighbors of u\n        # Create a list of edges to process to avoid modifying adj while iterating\n        edges_to_process = list(adj[u]) \n        \n        for v, c, edge_idx, u_is_a in edges_to_process:\n            if ans[edge_idx] != -1:\n                continue # Edge already directed\n\n            # Determine direction\n            direction_chosen = -1 # 0 for u -> v, 1 for v -> u\n            \n            if u == 1: # Source: all edges outgoing\n                direction_chosen = 0 # u -> v\n            elif u == n: # Sink: all edges incoming\n                direction_chosen = 1 # v -> u\n            elif num_undirected_edges[u] == 1: # Intermediate node with one remaining edge\n                # If current_balance[u] is negative, u has too much incoming flow.\n                # The last edge must be outgoing from u to balance it.\n                if current_balance[u] < 0:\n                    direction_chosen = 0 # u -> v\n                # If current_balance[u] is positive, u has too much outgoing flow.\n                # The last edge must be incoming to u to balance it.\n                else: # current_balance[u] > 0\n                    direction_chosen = 1 # v -> u\n            else:\n                # This case should not be reached if the problem guarantees a solution\n                # and our logic is sound for reducing to num_undirected_edges[u] == 1\n                continue # Skip if direction not determined yet\n\n            # Apply the chosen direction\n            if direction_chosen == 0: # u -> v\n                current_balance[u] += c\n                current_balance[v] -= c\n                \n                # Set ans based on original (a_i, b_i)\n                if u_is_a: # u was a_i, v was b_i\n                    ans[edge_idx] = 0 # a_i -> b_i\n                else: # u was b_i, v was a_i\n                    ans[edge_idx] = 1 # b_i -> a_i\n            else: # v -> u\n                current_balance[v] += c\n                current_balance[u] -= c\n\n                # Set ans based on original (a_i, b_i)\n                if u_is_a: # u was a_i, v was b_i\n                    ans[edge_idx] = 1 # b_i -> a_i (which is v -> u)\n                else: # u was b_i, v was a_i\n                    ans[edge_idx] = 0 # a_i -> b_i (which is v -> u)\n\n            # Update undirected edge counts\n            num_undirected_edges[u] -= 1\n            num_undirected_edges[v] -= 1\n\n            # Add v to queue if it now has only one undirected edge left and it's not source/sink\n            if num_undirected_edges[v] == 1 and v != 1 and v != n and v not in in_queue:\n                q.append(v)\n                in_queue.add(v)\n            \n            # Remove v from in_queue if all its edges are processed\n            if num_undirected_edges[v] == 0 and v in in_queue:\n                in_queue.remove(v)\n\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + '\\n')\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 746,
        "completion_token_count": 4313,
        "thoughts_token_count": 6395
    }
}