{
    "start": 1758284906.5650427,
    "end": 1758284955.8692284,
    "start-formatted": "2025-09-19 21:28 KST",
    "end-formatted": "2025-09-19 21:29 KST",
    "gpu": 2,
    "pid": 44,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Polycarp's Practice\n\nPolycarp is practicing his problem solving skill. He has a list of $$$n$$$ problems with difficulties $$$a_1, a_2, \\dots, a_n$$$, respectively. His plan is to practice for exactly $$$k$$$ days. Each day he has to solve at least one problem from his list. Polycarp solves the problems in the order they are given in his list, he cannot skip any problem from his list. He has to solve all $$$n$$$ problems in exactly $$$k$$$ days.Thus, each day Polycarp solves a contiguous sequence of (consecutive) problems from the start of the list. He can't skip problems or solve them multiple times. As a result, in $$$k$$$ days he will solve all the $$$n$$$ problems.The profit of the $$$j$$$-th day of Polycarp's practice is the maximum among all the difficulties of problems Polycarp solves during the $$$j$$$-th day (i.e. if he solves problems with indices from $$$l$$$ to $$$r$$$ during a day, then the profit of the day is $$$\\max\\limits_{l \\le i \\le r}a_i$$$). The total profit of his practice is the sum of the profits over all $$$k$$$ days of his practice.You want to help Polycarp to get the maximum possible total profit over all valid ways to solve problems. Your task is to distribute all $$$n$$$ problems between $$$k$$$ days satisfying the conditions above in such a way, that the total profit is maximum.For example, if $$$n = 8, k = 3$$$ and $$$a = [5, 4, 2, 6, 5, 1, 9, 2]$$$, one of the possible distributions with maximum total profit is: $$$[5, 4, 2], [6, 5], [1, 9, 2]$$$. Here the total profit equals $$$5 + 6 + 9 = 20$$$.\n\n## Input\nThe first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\le k \\le n \\le 2000$$$) — the number of problems and the number of days, respectively.The second line of the input contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le 2000$$$) — difficulties of problems in Polycarp's list, in the order they are placed in the list (i.e. in the order Polycarp will solve them).\n\n## Output\nIn the first line of the output print the maximum possible total profit.In the second line print exactly $$$k$$$ positive integers $$$t_1, t_2, \\dots, t_k$$$ ($$$t_1 + t_2 + \\dots + t_k$$$ must equal $$$n$$$), where $$$t_j$$$ means the number of problems Polycarp will solve during the $$$j$$$-th day in order to achieve the maximum possible total profit of his practice.If there are many possible answers, you may print any of them.\n\n## Example\n### Input\n['8 3\\n5 4 2 6 5 1 9 2', '5 1\\n1 1 1 1 1', '4 2\\n1 2000 2000 2']\n\n### Output\n['20\\n3 2 3', '1\\n5', '4000\\n2 2']\n\n## Note\nThe first example is described in the problem statement.In the second example there is only one possible distribution.In the third example the best answer is to distribute problems in the following way: $$$[1, 2000], [2000, 2]$$$. The total profit of this distribution is $$$2000 + 2000 = 4000$$$.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "**Thinking Through a Competitive Programming Problem**\n\nOkay, so I've got this competitive programming problem in front of me. The goal is to maximize the profit earned over a set number of days by solving problems with varying difficulties. I need to figure out the best strategy to maximize the total profit and, crucially, determine how many problems to solve each day.\n\nHere's the breakdown: I have `n` problems, `k` days, and a list of difficulties `a`. The constraints tell me I have `k` days, I must solve all `n` problems, and each day must involve a contiguous set of problems. The profit for a day is the maximum difficulty among the problems solved that day. Total profit is the sum of daily profits.\n\nMy initial thought is that to maximize profit, I need to make the *daily maximums* as large as possible. If I can somehow assign the `k` largest difficulties in `a` to be the maximums for each of the `k` days, I'd have the best possible total profit, which would be the sum of those `k` values.\n\nSo, let's explore this greedy approach. First, I would identify the `k` largest difficulties and their original indices. If I can, in fact, arrange these `k` largest difficulties to be the daily maximums, then I've got a winning strategy.\n\nThe sum of these `k` largest difficulties *is* the maximum possible total profit. If I select k problems to be the maximum in each day, then this is the best total profit that can be achieved.\n\nNow, how do I distribute the problems across the days? I'm thinking of sorting the indices of these `k` \"pivot\" problems and then using them as boundaries. For example, the first day would handle problems up to the first pivot point, the second day would handle problems between the first and second pivot points, and so on.\n\nHowever, I'm noticing a potential flaw in this approach. This strategy might create segments where problems within a segment are not handled optimally. For instance, if I simply assign everything up to the first pivot to day 1, it might not result in the largest value being `a[p_1]`. If there's a larger value *before* `p_1`, this setup might create an opportunity for a higher profit. I need to revisit this distribution strategy and account for this scenario.\n",
    "response": "The problem asks us to distribute `n` problems into `k` contiguous sequences (days) such that the sum of the maximum difficulties for each day is maximized. We also need to output the number of problems solved each day.\n\nLet's analyze the profit. The total profit is the sum of `k` values, where each value is the maximum difficulty of problems solved on a particular day. To maximize this sum, we should aim to make each of these `k` maximums as large as possible.\n\nConsider the `k` largest problem difficulties in the entire list `a`. Let these values be `M_1, M_2, ..., M_k`. The sum `M_1 + M_2 + ... + M_k` is the maximum possible total profit we can achieve. This is because each day must have *some* problem as its maximum, and there are `k` days. If we can assign one of these `k` largest problems to each day such that it is the maximum for that day, then we achieve this sum.\n\nSo, the strategy is:\n1.  Identify the `k` largest difficulties in the array `a`.\n2.  Calculate their sum, which will be the maximum total profit.\n3.  Find the original indices of these `k` largest difficulties.\n4.  Sort these indices in ascending order. These sorted indices will serve as the \"split points\" for our days. Specifically, if the sorted indices are `idx_1, idx_2, ..., idx_k`, then:\n    *   Day 1 will solve problems from the start of the list up to problem `idx_1` (inclusive).\n    *   Day 2 will solve problems from `idx_1 + 1` up to problem `idx_2` (inclusive).\n    *   ...\n    *   Day `k-1` will solve problems from `idx_{k-2} + 1` up to problem `idx_{k-1}` (inclusive).\n    *   Day `k` will solve problems from `idx_{k-1} + 1` up to the end of the list (problem `n-1`, inclusive).\n\nThis distribution ensures that each of the `k` largest problems `a[idx_j]` is included in one of the `k` days. Since `a[idx_j]` is one of the `k` overall largest values, it will be the maximum for its respective day (or at least equal to the maximum), thus contributing its value to the total profit. By picking the `k` largest values this way, we guarantee the maximum possible sum.\n\nLet's trace with an example: `n = 8, k = 3, a = [5, 4, 2, 6, 5, 1, 9, 2]`\n\n1.  **Identify `k` largest difficulties**:\n    The difficulties are `[5, 4, 2, 6, 5, 1, 9, 2]`.\n    The `k=3` largest values are `9, 6, 5` (there are two `5`s, we can pick any one).\n    Let's pick `9` (at index 6), `6` (at index 3), and `5` (at index 0).\n    Values: `[9, 6, 5]`\n    Original (0-indexed) positions: `[6, 3, 0]`\n\n2.  **Calculate total profit**:\n    `9 + 6 + 5 = 20`.\n\n3.  **Sort indices**:\n    Sorted indices: `[0, 3, 6]`\n\n4.  **Determine daily problem counts**:\n    The `k` sorted indices define `k-1` split points. The `k`-th split point is effectively `n-1`.\n    *   The first day ends at index `idx_1 = 0`. Problems solved: `a[0]`. Count: `0 - (-1) = 1`.\n    *   The second day ends at index `idx_2 = 3`. Problems solved: `a[1...3]`. Count: `3 - 0 = 3`.\n    *   The third day ends at index `idx_3 = 6`. Problems solved: `a[4...6]`. Count: `6 - 3 = 3`.\n    The remaining problems are from `idx_k + 1` to `n-1`. This is not quite right.\n\nA more robust way to define the split points:\nThe `k-1` split points are `idx_1, idx_2, ..., idx_{k-1}`.\n*   Day 1: Problems from `0` to `idx_1`. Number of problems: `idx_1 + 1`.\n*   Day 2: Problems from `idx_1 + 1` to `idx_2`. Number of problems: `idx_2 - idx_1`.\n*   ...\n*   Day `k-1`: Problems from `idx_{k-2} + 1` to `idx_{k-1}`. Number of problems: `idx_{k-1} - idx_{k-2}`.\n*   Day `k`: Problems from `idx_{k-1} + 1` to `n-1`. Number of problems: `n - 1 - idx_{k-1}`.\n\nLet's re-apply with the sorted indices `[0, 3, 6]` for `k=3`:\nThe actual split points are `idx_1 = 0` and `idx_2 = 3`. `idx_k` is the last one, which is `6`.\n*   Day 1: ends at `idx_1 = 0`. Problems: `a[0]`. Count: `0 - (-1) = 1`.\n*   Day 2: ends at `idx_2 = 3`. Problems: `a[1...3]`. Count: `3 - 0 = 3`.\n*   Day 3: ends at `n-1 = 7`. Problems: `a[4...7]`. Count: `7 - 3 = 4`.\n    This gives `[1, 3, 4]`. Sum `1+3+4=8=n`.\n    Profit: `max(a[0]) + max(a[1..3]) + max(a[4..7]) = max(5) + max(4,2,6) + max(5,1,9,2) = 5 + 6 + 9 = 20`. This matches the example profit.\n    However, the example output for `t_j` is `3 2 3`. This means there can be multiple valid distributions.\n\nLet's refine the split point logic. We need exactly `k-1` actual cuts.\nThe `k` largest problems are at indices `p_1 < p_2 < ... < p_k`.\nThese `k` problems must be the maximums of their respective days.\nWe can make the cuts *after* `p_1`, *after* `p_2`, ..., *after* `p_{k-1}`.\nThis means:\n*   Day 1: problems from `0` to `p_1`. Length: `p_1 + 1`.\n*   Day 2: problems from `p_1 + 1` to `p_2`. Length: `p_2 - p_1`.\n*   ...\n*   Day `k-1`: problems from `p_{k-2} + 1` to `p_{k-1}`. Length: `p_{k-1} - p_{k-2}`.\n*   Day `k`: problems from `p_{k-1} + 1` to `n-1`. Length: `n - p_{k-1} - 1`.\n\nLet's re-evaluate with `a = [5, 4, 2, 6, 5, 1, 9, 2]`, `n=8, k=3`.\nThe `k=3` largest values are `9` (index 6), `6` (index 3), `5` (index 0).\nSorted indices of these values: `p = [0, 3, 6]`.\nWe need `k-1 = 2` split points. These will be `p_1=0` and `p_2=3`.\n*   Day 1: Problems `a[0]` (up to `p_1`). Length `p_1 + 1 = 0 + 1 = 1`.\n*   Day 2: Problems `a[p_1+1 ... p_2]` (`a[1...3]`). Length `p_2 - p_1 = 3 - 0 = 3`.\n*   Day 3: Problems `a[p_2+1 ... n-1]` (`a[4...7]`). Length `n - (p_2 + 1) = 8 - (3 + 1) = 4`.\nThis gives `[1, 3, 4]`. Total profit `5 + 6 + 9 = 20`. This is a valid solution.\n\nThe example output `3 2 3` for `[5, 4, 2], [6, 5], [1, 9, 2]` comes from selecting `5` (index 0), `6` (index 3), `9` (index 6) as the daily maximums.\nThe sorted indices are `[0, 3, 6]`.\nIf we make cuts *after* `a[2]`, *after* `a[4]`, and *after* `a[7]`.\nThis means problem `a[0]` (value 5) is in day 1, problem `a[3]` (value 6) is in day 2, problem `a[6]` (value 9) is in day 3.\nThe split points are indices `2` and `4`.\n*   Day 1: problems `a[0...2]`. Length `3`.\n*   Day 2: problems `a[3...4]`. Length `2`.\n*   Day 3: problems `a[5...7]`. Length `3`.\nThis gives `[3, 2, 3]`. Total profit `max(5,4,2) + max(6,5) + max(1,9,2) = 5 + 6 + 9 = 20`. This is also a valid solution.\n\nThe key insight is that we need to select `k` values that will be the maximums for each day. To maximize the sum, these must be the `k` largest values overall. Once we have identified these `k` values and their original indices, say `pos_1, pos_2, ..., pos_k`, we sort these indices: `p_1 < p_2 < ... < p_k`.\nWe need to make `k-1` cuts. The most straightforward way to ensure each `p_j` is covered and is the maximum for its day is to make cuts *just after* `p_1`, *just after* `p_2`, ..., *just after* `p_{k-1}`.\nThis means:\n*   Day 1: `[0, p_1]`\n*   Day 2: `[p_1+1, p_2]`\n*   ...\n*   Day `k-1`: `[p_{k-2}+1, p_{k-1}]`\n*   Day `k`: `[p_{k-1}+1, n-1]`\n\nThe lengths would be:\n`p_1 + 1`\n`p_2 - p_1`\n...\n`p_{k-1} - p_{k-2}`\n`n - (p_{k-1} + 1)`\n\nThis strategy ensures that each `p_j` is the last problem solved on its respective day (except for `p_k` which is somewhere in the last day). This is not optimal for making it the *maximum* of its day.\n\nThe correct way to use the sorted indices `p_1 < p_2 < ... < p_k` is to realize that these are the `k` problems that will contribute to the sum. We need to make `k-1` cuts in the array `a` such that each `p_j` falls into a different segment.\nThe cuts should be made at positions `p_1, p_2, ..., p_{k-1}`.\nThis means:\n*   Day 1 ends at index `p_1`.\n*   Day 2 ends at index `p_2`.\n*   ...\n*   Day `k-1` ends at index `p_{k-1}`.\n*   Day `k` ends at index `n-1`.\n\nThe problems solved on day `j` will be from `(previous_cut_index + 1)` to `(current_cut_index)`.\nLet `current_cut_index` be `p_j` for `j=1...k-1` and `n-1` for `j=k`.\nLet `prev_cut_index` be `-1` for `j=1` and `p_{j-1}` for `j=2...k-1`.\nFor `j=k`, `prev_cut_index` is `p_{k-1}`.\n\nSo, the lengths `t_j` are:\n`t_1 = p_1 - (-1) = p_1 + 1`\n`t_2 = p_2 - p_1`\n`t_3 = p_3 - p_2`\n...\n`t_{k-1} = p_{k-1} - p_{k-2}`\n`t_k = (n-1) - p_{k-1}`\n\nLet's re-apply with `a = [5, 4, 2, 6, 5, 1, 9, 2]`, `n=8, k=3`.\nThe `k=3` largest values are `9` (index 6), `6` (index 3), `5` (index 0).\nSorted indices of these values: `p = [0, 3, 6]`.\nWe need `k-1 = 2` cut points. These are `p_1=0` and `p_2=3`.\n*   `t_1 = p_1 + 1 = 0 + 1 = 1`. (Problems `a[0]`)\n*   `t_2 = p_2 - p_1 = 3 - 0 = 3`. (Problems `a[1...3]`)\n*   `t_3 = (n-1) - p_2 = (8-1) - 3 = 7 - 3 = 4`. (Problems `a[4...7]`)\nThis gives `[1, 3, 4]`. This is a valid solution producing profit 20, but not the example's `[3, 2, 3]`.\n\nThe problem states \"If there are many possible answers, you may print any of them.\" So `[1, 3, 4]` is a perfectly valid output for the distribution.\n\nLet's verify the logic.\n1. Create pairs `(a_i, i)` for all problems.\n2. Sort these pairs in descending order based on `a_i`.\n3. Take the first `k` pairs. These correspond to the `k` largest problems.\n4. Sum their `a_i` values to get the total profit.\n5. Extract their original `i` indices.\n6. Sort these `k` indices in ascending order. Let them be `p_0, p_1, ..., p_{k-1}`.\n7. The daily problem counts `t_j` will be calculated as follows:\n   `t_1 = p_0 + 1`\n   `t_2 = p_1 - p_0`\n   ...\n   `t_j = p_{j-1} - p_{j-2}` for `j` from `2` to `k-1`\n   `t_k = n - 1 - p_{k-2}` (This is wrong. `t_k = n - (p_{k-1} + 1)` or `n - 1 - p_{k-1} + 1` for 0-indexed `p_{k-1}`. More simply, `n - (sum of previous t_j)`)\n\nLet's use `current_pos` to track the start of the current day's problems.\n`current_pos = -1` (meaning problems start from index 0)\n`t_values = []`\nFor `j` from `0` to `k-2`:\n  `t_j_val = p_j - current_pos`\n  `t_values.append(t_j_val)`\n  `current_pos = p_j`\nFor the last day (day `k`):\n  `t_k_val = n - 1 - current_pos`\n  `t_values.append(t_k_val)`\n\nExample: `p = [0, 3, 6]`, `n=8, k=3`.\n`current_pos = -1`\n`t_values = []`\n\n`j=0`: `p_0 = 0`\n  `t_0_val = p_0 - current_pos = 0 - (-1) = 1`\n  `t_values = [1]`\n  `current_pos = p_0 = 0`\n\n`j=1`: `p_1 = 3`\n  `t_1_val = p_1 - current_pos = 3 - 0 = 3`\n  `t_values = [1, 3]`\n  `current_pos = p_1 = 3`\n\nNow `j` reaches `k-2 = 1`. Loop ends.\n\nLast day (`k=3`):\n  `t_2_val = n - 1 - current_pos = 8 - 1 - 3 = 7 - 3 = 4`\n  `t_values = [1, 3, 4]`\n\nThis correctly produces `[1, 3, 4]`.\n\nThis algorithm is correct and satisfies all conditions:\n*   It uses `k` days.\n*   Each day solves at least one problem (since `k <= n` and `p_j` are distinct, `p_j - p_{j-1}` will be at least 1).\n*   All `n` problems are solved (`sum(t_j) = (p_0+1) + (p_1-p_0) + ... + (p_{k-1}-p_{k-2}) + (n-1-p_{k-1}) = n`).\n*   Problems are solved in order and contiguously.\n*   The total profit is maximized by selecting the `k` largest values.\n\nComplexity:\n*   Creating pairs and sorting: `O(N log N)`\n*   Extracting `k` largest: `O(k)`\n*   Sorting indices: `O(k log k)`\n*   Calculating `t_j`: `O(k)`\nOverall complexity: `O(N log N)` due to the initial sort. Given `N <= 2000`, `N log N` is efficient enough.\n\nLet's consider edge cases:\n*   `k = 1`: `p` will have one element `p_0`. `t_1 = n - 1 - (-1) = n`. Correct.\n*   `k = n`: Each day solves 1 problem. `p = [0, 1, ..., n-1]`.\n    `t_1 = p_0 - (-1) = 0 - (-1) = 1`\n    `t_j = p_{j-1} - p_{j-2} = (j-1) - (j-2) = 1` for `j=2...n-1`.\n    `t_n = n - 1 - p_{n-2} = n - 1 - (n-2) = 1`.\n    All `t_j` are `1`. Correct.\n\nThe problem constraints are `N, K <= 2000`, `a_i <= 2000`. `O(N log N)` is fine.\n\nImplementation details:\nUse `zip` or list comprehensions to create `(value, index)` pairs.\nUse `sort(key=lambda x: x[0], reverse=True)` to sort by value descending.\nSlice the first `k` elements.\nSum values for profit.\nExtract indices, sort them.\nIterate to build `t_values`.\n\n```python\nimport sys\n\ndef solve():\n    n, k = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    # 1. Create pairs of (difficulty, original_index)\n    # We need original_index to determine split points later.\n    problems_with_indices = []\n    for i in range(n):\n        problems_with_indices.append((a[i], i))\n\n    # 2. Sort problems by difficulty in descending order.\n    # If difficulties are equal, the order doesn't matter for finding the k largest.\n    problems_with_indices.sort(key=lambda x: x[0], reverse=True)\n\n    # 3. Select the top k problems.\n    # These will contribute to the maximum total profit.\n    top_k_problems = problems_with_indices[:k]\n\n    # 4. Calculate the maximum total profit.\n    max_total_profit = sum(p[0] for p in top_k_problems)\n    print(max_total_profit)\n\n    # 5. Get the original indices of these top k problems.\n    # These indices will define our split points for the days.\n    split_indices = [p[1] for p in top_k_problems]\n\n    # 6. Sort these indices in ascending order.\n    # This is crucial for correctly defining contiguous segments.\n    split_indices.sort()\n\n    # 7. Calculate the number of problems for each day (t_j).\n    # The split_indices define the *end* of each day's problems,\n    # except for the last day which goes until n-1.\n    \n    t_values = []\n    current_start_index = -1 # Represents the index *before* the first problem of the current day.\n                             # So, if problems start from index 0, current_start_index is -1.\n\n    # For the first k-1 days, the end index is given by split_indices[j].\n    for j in range(k - 1):\n        # The problems for this day are from (current_start_index + 1) to split_indices[j].\n        # The count is (split_indices[j]) - (current_start_index + 1) + 1\n        # which simplifies to split_indices[j] - current_start_index.\n        num_problems_this_day = split_indices[j] - current_start_index\n        t_values.append(num_problems_this_day)\n        current_start_index = split_indices[j] # The next day starts after this index.\n\n    # The last day (k-th day) covers problems from (current_start_index + 1) to n-1.\n    # The count is (n-1) - (current_start_index + 1) + 1\n    # which simplifies to n - 1 - current_start_index.\n    num_problems_last_day = n - 1 - current_start_index\n    t_values.append(num_problems_last_day)\n\n    # 8. Print the t_j values.\n    print(*(t_values))\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, k = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    # 1. Create pairs of (difficulty, original_index)\n    # We need original_index to determine split points later.\n    problems_with_indices = []\n    for i in range(n):\n        problems_with_indices.append((a[i], i))\n\n    # 2. Sort problems by difficulty in descending order.\n    # If difficulties are equal, the order doesn't matter for finding the k largest.\n    problems_with_indices.sort(key=lambda x: x[0], reverse=True)\n\n    # 3. Select the top k problems.\n    # These will contribute to the maximum total profit.\n    top_k_problems = problems_with_indices[:k]\n\n    # 4. Calculate the maximum total profit.\n    max_total_profit = sum(p[0] for p in top_k_problems)\n    print(max_total_profit)\n\n    # 5. Get the original indices of these top k problems.\n    # These indices will define our split points for the days.\n    split_indices = [p[1] for p in top_k_problems]\n\n    # 6. Sort these indices in ascending order.\n    # This is crucial for correctly defining contiguous segments.\n    split_indices.sort()\n\n    # 7. Calculate the number of problems for each day (t_j).\n    # The split_indices define the *end* of each day's problems,\n    # except for the last day which goes until n-1.\n    \n    t_values = []\n    current_start_index = -1 # Represents the index *before* the first problem of the current day.\n                             # So, if problems start from index 0, current_start_index is -1.\n\n    # For the first k-1 days, the end index is given by split_indices[j].\n    for j in range(k - 1):\n        # The problems for this day are from (current_start_index + 1) to split_indices[j].\n        # The count is (split_indices[j]) - (current_start_index + 1) + 1\n        # which simplifies to split_indices[j] - current_start_index.\n        num_problems_this_day = split_indices[j] - current_start_index\n        t_values.append(num_problems_this_day)\n        current_start_index = split_indices[j] # The next day starts after this index.\n\n    # The last day (k-th day) covers problems from (current_start_index + 1) to n-1.\n    # The count is (n-1) - (current_start_index + 1) + 1\n    # which simplifies to n - 1 - current_start_index.\n    num_problems_last_day = n - 1 - current_start_index\n    t_values.append(num_problems_last_day)\n\n    # 8. Print the t_j values.\n    print(*(t_values))\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 963,
        "completion_token_count": 5467,
        "thoughts_token_count": 770
    }
}