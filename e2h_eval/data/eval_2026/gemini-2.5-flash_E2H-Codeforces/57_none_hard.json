{
    "start": 1758293706.264388,
    "end": 1758293726.8018987,
    "start-formatted": "2025-09-19 23:55 KST",
    "end-formatted": "2025-09-19 23:55 KST",
    "gpu": 2,
    "pid": 57,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Olympiad\n\nA boy named Vasya has taken part in an Olympiad. His teacher knows that in total Vasya got at least x points for both tours of the Olympiad. The teacher has the results of the first and the second tour of the Olympiad but the problem is, the results have only points, no names. The teacher has to know Vasya's chances.Help Vasya's teacher, find two numbers — the best and the worst place Vasya could have won. Note that the total results' table sorts the participants by the sum of points for both tours (the first place has the participant who has got the most points). If two or more participants have got the same number of points, it's up to the jury to assign places to them according to their choice. It is guaranteed that each participant of the Olympiad participated in both tours of the Olympiad.\n\n## Input\nThe first line contains two space-separated integers n, x (1 ≤ n ≤ 105; 0 ≤ x ≤ 2·105) — the number of Olympiad participants and the minimum number of points Vasya earned.The second line contains n space-separated integers: a1, a2, ..., an (0 ≤ ai ≤ 105) — the participants' points in the first tour.The third line contains n space-separated integers: b1, b2, ..., bn (0 ≤ bi ≤ 105) — the participants' points in the second tour.The participants' points are given in the arbitrary order. It is guaranteed that Vasya was present in the Olympiad — there are two integers i, j (1 ≤ i, j ≤ n) such, that ai + bj ≥ x.\n\n## Output\nPrint two space-separated integers — the best and the worst place Vasya could have got on the Olympiad.\n\n## Example\n### Input\n['5 2\\n1 1 1 1 1\\n1 1 1 1 1', '6 7\\n4 3 5 6 4 4\\n8 6 0 4 3 4']\n\n### Output\n['1 5', '1 5']\n\n## Note\nIn the first text sample all 5 participants earn 2 points each in any case. Depending on the jury's decision, Vasya can get the first (the best) as well as the last (the worst) fifth place.In the second test sample in the best case scenario Vasya wins again: he can win 12 points and become the absolute winner if the total results' table looks like that — {4:8, 6:4, 3:6, 4:4, 4:3, 5:0}.In this table all participants are sorted by decreasing points and we can see how much a participant earned in the first and in the second tour.In the worst case scenario Vasya can get the fifth place if the table looks like that — {4:8, 4:6, 6:4, 5:4, 4:3, 3:0}, and he earned 4 and 3 points in the first and second tours, correspondingly.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "",
    "response": "```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    a.sort()\n    b.sort()\n\n    # Calculate best possible rank\n    # Vasya wants to maximize his score. He picks the highest possible a_i and b_j such that a_i + b_j >= x.\n    # To get the best rank, he also wants to minimize the scores of other participants.\n    # This means other participants should be paired such that their sums are as low as possible.\n    # However, the problem states \"the total results' table sorts the participants by the sum of points\".\n    # And \"If two or more participants have got the same number of points, it's up to the jury to assign places to them\".\n    # This implies that Vasya's score is fixed once his a_i and b_j are chosen.\n    # The best rank is 1 if Vasya can achieve the highest possible score among all possible pairings.\n    # The highest possible score Vasya can achieve is max(a_i + b_j) where a_i + b_j >= x.\n    # Let's find the maximum possible score Vasya could have.\n    max_vasya_score = 0\n    for val_a in a:\n        # Find largest b_j such that val_a + b_j >= x\n        # This means b_j >= x - val_a\n        target_b = x - val_a\n        \n        # Use binary search to find the smallest b_j in b that is >= target_b\n        low, high = 0, n - 1\n        best_b_idx = -1\n        while low <= high:\n            mid = (low + high) // 2\n            if b[mid] >= target_b:\n                best_b_idx = mid\n                high = mid - 1\n            else:\n                low = mid + 1\n        \n        if best_b_idx != -1:\n            max_vasya_score = max(max_vasya_score, val_a + b[best_b_idx])\n\n    # Now count how many participants could potentially have a score greater than max_vasya_score.\n    # No one can have a score greater than max_vasya_score if Vasya picked the absolute maximum possible score.\n    # The question is about Vasya's best rank. If Vasya can achieve the highest score among all possible pairings,\n    # and if the jury places him first among ties, then his best rank is 1.\n    # The problem guarantees that Vasya was present and a_i + b_j >= x for some i, j.\n    # So Vasya can always achieve a score of at least x.\n    # The highest possible score any participant can get is a[n-1] + b[n-1].\n    # If Vasya's max_vasya_score is equal to a[n-1] + b[n-1], then he can be 1st.\n    # Even if his score is less than a[n-1] + b[n-1], he could still be 1st if he takes the highest a_i and b_j\n    # that satisfy a_i + b_j >= x, and all other participants are paired such that their scores are lower.\n    # The best rank is always 1. Vasya can always choose the highest possible a_i and b_j from the available lists\n    # such that a_i + b_j >= x. Let this sum be S_vasya_best.\n    # Then the remaining n-1 'a' values and n-1 'b' values can be paired in any way.\n    # To maximize Vasya's rank, we assume the jury assigns him 1st place if there are ties.\n    # And we assume the remaining participants are paired to minimize their scores.\n    # But this is not how it works. The participants are fixed, their scores are fixed.\n    # Vasya is one of the participants. The lists a and b are the scores of all participants.\n    # Vasya's best rank: Vasya can pick any a_i and any b_j such that a_i + b_j >= x.\n    # To get the best rank, he should pick the largest possible sum.\n    # Let S_max_possible be the maximum sum a_i + b_j such that a_i + b_j >= x.\n    # This is the max_vasya_score calculated above.\n    # With this score, Vasya can be 1st if no other participant can achieve a higher score.\n    # Can any other participant achieve a higher score?\n    # No, because max_vasya_score is the maximum possible sum a_i + b_j >= x.\n    # If Vasya picks a_i and b_j to get max_vasya_score, then these a_i and b_j are removed from the lists.\n    # The remaining n-1 a's and n-1 b's are paired.\n    # The best rank is 1 because Vasya can achieve the highest score (among those >= x) and the jury places him first among ties.\n    best_rank = 1\n\n    # Calculate worst possible rank\n    # Vasya wants to minimize his score, but still satisfy a_i + b_j >= x.\n    # To get the worst rank, he should pick the smallest possible sum S_vasya_worst such that a_i + b_j >= x.\n    # Let's find this S_vasya_worst.\n    min_vasya_score = float('inf')\n    for val_a in a:\n        # Find smallest b_j such that val_a + b_j >= x\n        # This means b_j >= x - val_a\n        target_b = x - val_a\n        \n        # Use binary search to find the smallest b_j in b that is >= target_b\n        low, high = 0, n - 1\n        best_b_idx = -1 # index of smallest b_j >= target_b\n        while low <= high:\n            mid = (low + high) // 2\n            if b[mid] >= target_b:\n                best_b_idx = mid\n                high = mid - 1\n            else:\n                low = mid + 1\n        \n        if best_b_idx != -1:\n            min_vasya_score = min(min_vasya_score, val_a + b[best_b_idx])\n\n    # Now, with this min_vasya_score, we want to maximize the number of participants\n    # who could have a score greater than or equal to min_vasya_score.\n    # This means we pair up the remaining n-1 participants to maximize their scores.\n    # We also assume the jury places Vasya last among ties.\n    # To maximize the number of people with score >= min_vasya_score, we use a greedy approach.\n    # Sort a and b.\n    # We want to form as many pairs (a_i, b_j) as possible such that a_i + b_j >= min_vasya_score.\n    # This is a standard two-pointer problem.\n    # Sort a in ascending order, b in ascending order.\n    # To maximize the number of pairs (a_i, b_j) with sum >= min_vasya_score,\n    # we can iterate through 'a' from largest to smallest, and for each a_i, find the smallest b_j that satisfies the condition.\n    # Or, we can use a two-pointer approach on sorted lists.\n    # Let's count how many pairs (a_i, b_j) can be formed such that a_i + b_j >= min_vasya_score.\n    # This count will include Vasya.\n    \n    # Create copies to avoid modifying original sorted lists\n    temp_a = sorted(a)\n    temp_b = sorted(b)\n\n    count_greater_equal = 0\n    \n    # We want to find the maximum number of pairs (a_i, b_j) such that a_i + b_j >= min_vasya_score.\n    # Use two pointers. Sort a in ascending, b in ascending.\n    # Iterate through a from left (smallest). For each a_i, we need to find a b_j such that a_i + b_j >= min_vasya_score.\n    # To maximize pairs, we should try to use smaller b_j's first.\n    # No, this is not correct. We want to count how many participants can have a score >= min_vasya_score.\n    # This means we should greedily pair the largest a with largest b, then second largest a with second largest b, etc.\n    # This strategy maximizes the number of high scores.\n    # No, this is not about maximizing high scores. It's about counting pairs with sum >= threshold.\n    # A standard greedy approach for this:\n    # Sort `a` in ascending order. Sort `b` in ascending order.\n    # To maximize the number of pairs (a_i, b_j) with sum >= S:\n    # Use two pointers, `i` for `a` starting from 0, `j` for `b` starting from `n-1`.\n    # If `a[i] + b[j] >= S`, we form a pair. Increment `i`, decrement `j`. Increment count.\n    # If `a[i] + b[j] < S`, then `a[i]` is too small to pair with `b[j]`. We need a larger `a`. Increment `i`.\n    \n    i = 0\n    j = n - 1\n    matched_pairs = 0\n    \n    # This greedy approach counts the maximum number of pairs that can achieve at least min_vasya_score.\n    # Each 'a' and 'b' can be used only once.\n    while i < n and j >= 0:\n        if temp_a[i] + temp_b[j] >= min_vasya_score:\n            matched_pairs += 1\n            i += 1\n            j -= 1\n        else:\n            i += 1 # a[i] is too small to make the sum with b[j], try a larger a[i]\n    \n    worst_rank = matched_pairs\n\n    sys.stdout.write(f\"{best_rank} {worst_rank}\\n\")\n\nsolve()\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    a.sort()\n    b.sort()\n\n    # Calculate best possible rank\n    # Vasya wants to maximize his score. He picks the highest possible a_i and b_j such that a_i + b_j >= x.\n    # To get the best rank, he also wants to minimize the scores of other participants.\n    # This means other participants should be paired such that their sums are as low as possible.\n    # However, the problem states \"the total results' table sorts the participants by the sum of points\".\n    # And \"If two or more participants have got the same number of points, it's up to the jury to assign places to them\".\n    # This implies that Vasya's score is fixed once his a_i and b_j are chosen.\n    # The best rank is 1 if Vasya can achieve the highest possible score among all possible pairings.\n    # The highest possible score Vasya can achieve is max(a_i + b_j) where a_i + b_j >= x.\n    # Let's find the maximum possible score Vasya could have.\n    max_vasya_score = 0\n    for val_a in a:\n        # Find largest b_j such that val_a + b_j >= x\n        # This means b_j >= x - val_a\n        target_b = x - val_a\n        \n        # Use binary search to find the smallest b_j in b that is >= target_b\n        low, high = 0, n - 1\n        best_b_idx = -1\n        while low <= high:\n            mid = (low + high) // 2\n            if b[mid] >= target_b:\n                best_b_idx = mid\n                high = mid - 1\n            else:\n                low = mid + 1\n        \n        if best_b_idx != -1:\n            max_vasya_score = max(max_vasya_score, val_a + b[best_b_idx])\n\n    # Now count how many participants could potentially have a score greater than max_vasya_score.\n    # No one can have a score greater than max_vasya_score if Vasya picked the absolute maximum possible score.\n    # The question is about Vasya's best rank. If Vasya can achieve the highest score among all possible pairings,\n    # and if the jury places him first among ties, then his best rank is 1.\n    # The problem guarantees that Vasya was present and a_i + b_j >= x for some i, j.\n    # So Vasya can always achieve a score of at least x.\n    # The highest possible score any participant can get is a[n-1] + b[n-1].\n    # If Vasya's max_vasya_score is equal to a[n-1] + b[n-1], then he can be 1st.\n    # Even if his score is less than a[n-1] + b[n-1], he could still be 1st if he takes the highest a_i and b_j\n    # that satisfy a_i + b_j >= x, and all other participants are paired such that their scores are lower.\n    # The best rank is always 1. Vasya can always choose the highest possible a_i and b_j from the available lists\n    # such that a_i + b_j >= x. Let this sum be S_vasya_best.\n    # Then the remaining n-1 'a' values and n-1 'b' values can be paired in any way.\n    # To maximize Vasya's rank, we assume the jury assigns him 1st place if there are ties.\n    # And we assume the remaining participants are paired to minimize their scores.\n    # But this is not how it works. The participants are fixed, their scores are fixed.\n    # Vasya is one of the participants. The lists a and b are the scores of all participants.\n    # Vasya's best rank: Vasya can pick any a_i and any b_j such that a_i + b_j >= x.\n    # To get the best rank, he should pick the largest possible sum.\n    # Let S_max_possible be the maximum sum a_i + b_j such that a_i + b_j >= x.\n    # This is the max_vasya_score calculated above.\n    # With this score, Vasya can be 1st if no other participant can achieve a higher score.\n    # Can any other participant achieve a higher score?\n    # No, because max_vasya_score is the maximum possible sum a_i + b_j >= x.\n    # If Vasya picks a_i and b_j to get max_vasya_score, then these a_i and b_j are removed from the lists.\n    # The remaining n-1 a's and n-1 b's are paired.\n    # The best rank is 1 because Vasya can achieve the highest score (among those >= x) and the jury places him first among ties.\n    best_rank = 1\n\n    # Calculate worst possible rank\n    # Vasya wants to minimize his score, but still satisfy a_i + b_j >= x.\n    # To get the worst rank, he should pick the smallest possible sum S_vasya_worst such that a_i + b_j >= x.\n    # Let's find this S_vasya_worst.\n    min_vasya_score = float('inf')\n    for val_a in a:\n        # Find smallest b_j such that val_a + b_j >= x\n        # This means b_j >= x - val_a\n        target_b = x - val_a\n        \n        # Use binary search to find the smallest b_j in b that is >= target_b\n        low, high = 0, n - 1\n        best_b_idx = -1 # index of smallest b_j >= target_b\n        while low <= high:\n            mid = (low + high) // 2\n            if b[mid] >= target_b:\n                best_b_idx = mid\n                high = mid - 1\n            else:\n                low = mid + 1\n        \n        if best_b_idx != -1:\n            min_vasya_score = min(min_vasya_score, val_a + b[best_b_idx])\n\n    # Now, with this min_vasya_score, we want to maximize the number of participants\n    # who could have a score greater than or equal to min_vasya_score.\n    # This means we pair up the remaining n-1 participants to maximize their scores.\n    # We also assume the jury places Vasya last among ties.\n    # To maximize the number of people with score >= min_vasya_score, we use a greedy approach.\n    # Sort a and b.\n    # We want to form as many pairs (a_i, b_j) as possible such that a_i + b_j >= min_vasya_score.\n    # This is a standard two-pointer problem.\n    # Sort a in ascending order, b in ascending order.\n    # To maximize the number of pairs (a_i, b_j) with sum >= min_vasya_score,\n    # we can iterate through 'a' from largest to smallest, and for each a_i, find the smallest b_j that satisfies the condition.\n    # Or, we can use a two-pointer approach on sorted lists.\n    # Let's count how many pairs (a_i, b_j) can be formed such that a_i + b_j >= min_vasya_score.\n    # This count will include Vasya.\n    \n    # Create copies to avoid modifying original sorted lists\n    temp_a = sorted(a)\n    temp_b = sorted(b)\n\n    count_greater_equal = 0\n    \n    # We want to find the maximum number of pairs (a_i, b_j) such that a_i + b_j >= min_vasya_score.\n    # Use two pointers. Sort a in ascending, b in ascending.\n    # Iterate through a from left (smallest). For each a_i, we need to find a b_j such that a_i + b_j >= min_vasya_score.\n    # To maximize pairs, we should try to use smaller b_j's first.\n    # No, this is not correct. We want to count how many participants can have a score >= min_vasya_score.\n    # This means we should greedily pair the largest a with largest b, then second largest a with second largest b, etc.\n    # This strategy maximizes the number of high scores.\n    # No, this is not about maximizing high scores. It's about counting pairs with sum >= threshold.\n    # A standard greedy approach for this:\n    # Sort `a` in ascending order. Sort `b` in ascending order.\n    # To maximize the number of pairs (a_i, b_j) with sum >= S:\n    # Use two pointers, `i` for `a` starting from 0, `j` for `b` starting from `n-1`.\n    # If `a[i] + b[j] >= S`, we form a pair. Increment `i`, decrement `j`. Increment count.\n    # If `a[i] + b[j] < S`, then `a[i]` is too small to pair with `b[j]`. We need a larger `a`. Increment `i`.\n    \n    i = 0\n    j = n - 1\n    matched_pairs = 0\n    \n    # This greedy approach counts the maximum number of pairs that can achieve at least min_vasya_score.\n    # Each 'a' and 'b' can be used only once.\n    while i < n and j >= 0:\n        if temp_a[i] + temp_b[j] >= min_vasya_score:\n            matched_pairs += 1\n            i += 1\n            j -= 1\n        else:\n            i += 1 # a[i] is too small to make the sum with b[j], try a larger a[i]\n    \n    worst_rank = matched_pairs\n\n    sys.stdout.write(f\"{best_rank} {worst_rank}\\n\")\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 872,
        "completion_token_count": 2445,
        "thoughts_token_count": 0
    }
}