{
    "start": 1758284948.9427545,
    "end": 1758284996.3408208,
    "start-formatted": "2025-09-19 21:29 KST",
    "end-formatted": "2025-09-19 21:29 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "**Deconstructing a Tricky Graph Problem**\n\nOkay, so I'm looking at this competitive programming problem, and it's asking me to find some optimal properties of directed graphs. Specifically, I need to figure out the *smallest* number of nodes, `n`, required to build a graph with exactly `p` \"reachable from each other\" pairs. Then, for that minimal `n`, I need to maximize the total number of \"unidirectional pairs\" the graph can have. Let's break this down.\n\nFirst, the core definitions. A pair of nodes `(u, v)` is \"reachable from each other\" if you can go from `u` to `v` *and* from `v` to `u`. That means they're in the same strongly connected component (SCC). The problem specifically limits us to `u < v` when counting these pairs. A graph is \"p-reachable\" if it has exactly `p` such pairs.\n\nOn the flip side, a \"unidirectional pair\" `(u, v)` means you can get from `u` to `v`, but NOT from `v` to `u`. This implies they're in *different* SCCs, with a path in the condensation graph from `SCC(u)` to `SCC(v)`.  So, essentially, it's a one-way street.\n\nMy main goals are twofold: minimize `n` (number of nodes), and maximize the total number of unidirectional pairs *for that minimal `n`*.\n\nNow, let's consider how we'd approach this. Imagine a graph with `n` nodes, partitioned into `k` SCCs of sizes `s_1, s_2, ..., s_k`. This means `s_1 + s_2 + ... + s_k = n`. The key here is the count of \"reachable from each other\" pairs, which directly relates to the size of these SCCs.\n\nWithin an SCC of size `s_i`, any two distinct nodes are reachable from each other. The number of such pairs (with `u < v`) within that SCC is simply `s_i * (s_i - 1) / 2`  (or the number of 2-combinations). The total `p`-reachable count in the entire graph is then the sum of these pairwise counts over all SCCs: `P = sum(s_i * (s_i - 1) / 2 for i in 1 to k)`.  And we need this `P` to equal our given `p`.\n\nTo minimize `n`, I want to make those `s_i` values as large as possible. This is because the function `s_i * (s_i - 1) / 2` grows quadratically, meaning larger `s_i`s are more efficient at generating the required `p`-reachable pairs.  A singleton SCC (size 1) contributes nothing to `P`.  An SCC with 2 nodes gives 1 pair, 3 gives 3, 4 gives 6, and so on.\n\nThe challenge now is finding the optimal balance of SCC sizes to achieve the target `p` while keeping the total number of nodes `n` as small as possible. This feels like an interesting combinatorial optimization problem! I need to think about how to systematically decompose `p` into sums of these quadratic terms and find the corresponding minimal `n`.  Maximizing the unidirectional pairs will likely involve carefully constructing the connections between the SCCs.\n",
    "response": "The problem asks us to find two values for a given integer `p`:\n1. The minimum number of nodes `n` required to create a `p`-reachable directed graph.\n2. The maximum number of unidirectional pairs among all `p`-reachable graphs with this minimum `n`.\n\nLet's define the terms:\n- An ordered pair of nodes `(u, v)` is **reachable from each other** if there's a path from `u` to `v` AND a path from `v` to `u`. This means `u` and `v` are in the same Strongly Connected Component (SCC).\n- A graph is `p`-reachable if it contains exactly `p` ordered pairs `(u, v)` such that `u < v` and `u` and `v` are reachable from each other.\n- An ordered pair of nodes `(u, v)` is **unidirectional** if `u != v`, there's a path from `u` to `v`, and there are NO paths from `v` to `u`. This means `u` and `v` are in different SCCs, and there is a path from `SCC(u)` to `SCC(v)` in the condensation graph.\n\n**Part 1: Minimum number of nodes `n`**\n\nLet a graph have `k` SCCs with sizes `s_1, s_2, ..., s_k`. The total number of nodes is `n = s_1 + s_2 + ... + s_k`.\nWithin an SCC of size `s_i`, any two distinct nodes `u, v` are reachable from each other. The number of such pairs `(u, v)` with `u < v` is `s_i * (s_i - 1) / 2`.\nThe total count of `p`-reachable pairs in the graph is `P = sum(s_i * (s_i - 1) / 2 for i=1 to k)`. We need `P = p`.\n\nTo minimize `n`, we should maximize the contribution of each node to `P`. This means we want to form SCCs that are as large as possible.\nLet `f(s) = s * (s - 1) / 2`. This function is convex and grows with `s`. To get a target `P` with minimum `n`, we should try to use as few SCCs as possible, and make them as large as possible.\nSpecifically, we should try to achieve `p` using one large SCC, if possible.\nIf `p = f(s)` for some `s`, then `n = s` is the minimum.\nIf `p` is not exactly `f(s)` for any `s`, we find the largest `s_1` such that `f(s_1) <= p`. Then we need to obtain `p - f(s_1)` pairs from other SCCs. We continue this greedily. However, since `f(s)` grows quadratically, it's always optimal to use one large SCC for as many pairs as possible.\n\nLet's find the largest `s` such that `s * (s - 1) / 2 <= p`.\n`s^2 - s - 2p <= 0`. The roots of `x^2 - x - 2p = 0` are `(1 +/- sqrt(1 + 8p)) / 2`.\nSince `s > 0`, we are interested in `s <= (1 + sqrt(1 + 8p)) / 2`.\nSo, `s_max = floor((1 + sqrt(1 + 8p)) / 2)`.\nLet `s_0 = s_max`.\nThe number of pairs contributed by this SCC is `p_0 = s_0 * (s_0 - 1) / 2`.\nThe remaining pairs needed are `p_rem = p - p_0`.\nThe number of nodes used so far is `s_0`.\nTo get `p_rem` pairs, we need additional nodes. Each additional node must contribute to `p_rem`.\nA node in an SCC of size 1 contributes 0 pairs.\nA node in an SCC of size 2 contributes 1 pair (with the other node in that SCC).\nA node in an SCC of size 3 contributes 3 pairs.\nTo minimize `n`, we want to get `p_rem` using the fewest additional nodes.\nThe most efficient way to get `p_rem` pairs is to form `p_rem` SCCs of size 2. Each such SCC uses 2 nodes and contributes 1 pair.\nSo, we need `2 * p_rem` additional nodes to get `p_rem` pairs.\nThe total minimum number of nodes `n_min` would be `s_0 + 2 * p_rem`.\n\nLet's verify this strategy:\nConsider `p = 3`.\n`s_max = floor((1 + sqrt(1 + 8*3)) / 2) = floor((1 + sqrt(25)) / 2) = floor((1+5)/2) = floor(3) = 3`.\n`s_0 = 3`.\n`p_0 = 3 * (3 - 1) / 2 = 3`.\n`p_rem = 3 - 3 = 0`.\n`n_min = s_0 + 2 * p_rem = 3 + 2 * 0 = 3`.\nThis is correct. An SCC of size 3 gives 3 pairs.\n\nConsider `p = 4`.\n`s_max = floor((1 + sqrt(1 + 8*4)) / 2) = floor((1 + sqrt(33)) / 2)`. `sqrt(33)` is between 5 and 6, approx 5.74.\n`s_max = floor((1 + 5.74) / 2) = floor(3.37) = 3`.\n`s_0 = 3`.\n`p_0 = 3 * (3 - 1) / 2 = 3`.\n`p_rem = 4 - 3 = 1`.\n`n_min = s_0 + 2 * p_rem = 3 + 2 * 1 = 5`.\nThis means we have one SCC of size 3 (contributes 3 pairs) and one SCC of size 2 (contributes 1 pair). Total nodes: 3 + 2 = 5. This is correct.\n\n**Part 2: Maximum number of unidirectional pairs**\n\nWe have `n_min` nodes. These nodes are partitioned into SCCs as determined above:\n- One SCC of size `s_0`.\n- `p_rem` SCCs of size 2.\n- The remaining `n_min - s_0 - 2*p_rem` nodes (if any) are in SCCs of size 1. These are `p_rem` nodes if `s_0` is odd and `p_rem` is even. Wait, `n_min - s_0 - 2*p_rem` is always 0. The construction `s_0 + 2*p_rem` accounts for all nodes.\nSo, we have one SCC of size `s_0` and `p_rem` SCCs of size 2. Let's call these `s_0` nodes `C_0` and the `2*p_rem` nodes `C_1, ..., C_{p_rem}` where each `C_i` is an SCC of size 2.\n\nTo maximize unidirectional pairs, we want to create a path between as many distinct nodes as possible, such that the path goes in one direction only. This means creating a linear ordering of SCCs in the condensation graph.\nIf we have `K` SCCs, say `SCC_1, SCC_2, ..., SCC_K`, and we arrange them in a chain `SCC_1 -> SCC_2 -> ... -> SCC_K`, then every node in `SCC_i` can reach every node in `SCC_j` for `i < j`, but not vice versa.\nThe number of unidirectional pairs created this way is `sum_{i < j} (size(SCC_i) * size(SCC_j))`.\n\nOur SCCs are:\n- One SCC of size `s_0`.\n- `p_rem` SCCs of size 2.\n- The remaining `n_min - s_0 - 2*p_rem` nodes are singletons. Let `k_1` be the number of singleton SCCs.\nTotal nodes `n_min = s_0 + 2*p_rem + k_1`.\nThe number of SCCs is `1 + p_rem + k_1`.\n\nLet's arrange these SCCs in a chain. The order of SCCs affects the total unidirectional pairs. To maximize `sum_{i < j} (size(SCC_i) * size(SCC_j))`, we should place the largest SCCs at the ends of the chain.\nA common strategy to maximize this sum is to arrange the SCCs in decreasing order of size, or increasing order of size. For `sum_{i < j} a_i a_j`, the sum is maximized when the values `a_i` are sorted (either ascending or descending).\nTotal number of pairs between distinct SCCs is `(N^2 - sum(s_i^2))/2` where `N` is total nodes.\nThis is incorrect. The number of unidirectional pairs is `sum_{i < j} (size(SCC_i) * size(SCC_j))`.\nThis sum is `( (sum s_i)^2 - sum(s_i^2) ) / 2`.\nSince `sum s_i = n_min` is fixed, and `sum s_i^2` is minimized when sizes are as balanced as possible (which is not our case here as `s_0` is large and others are small), the sum `sum_{i < j} (size(SCC_i) * size(SCC_j))` depends only on the sizes of the SCCs, not their order in the chain.\n`Total unidirectional pairs = (n_min * n_min - sum(s_i^2))/2`.\nLet `N = n_min`.\nThe sizes of our SCCs are `s_0` (one time) and `2` (`p_rem` times).\nThe sum of squares of SCC sizes is `s_0^2 + p_rem * 2^2 = s_0^2 + 4 * p_rem`.\nSo, the maximum number of unidirectional pairs is `(N^2 - (s_0^2 + 4 * p_rem)) / 2`.\n\nLet's recheck the example `p=3`:\n`s_0 = 3`, `p_rem = 0`.\n`n_min = 3`.\nSCCs: one of size 3. `k_1 = 0`.\n`N = 3`.\n`sum(s_i^2) = 3^2 = 9`.\nMax unidirectional pairs = `(3^2 - 9) / 2 = 0 / 2 = 0`. This matches the example output.\n\nLet's recheck the example `p=4`:\n`s_0 = 3`, `p_rem = 1`.\n`n_min = 5`.\nSCCs: one of size 3, one of size 2. `k_1 = 0`.\n`N = 5`.\n`sum(s_i^2) = 3^2 + 2^2 = 9 + 4 = 13`.\nMax unidirectional pairs = `(5^2 - 13) / 2 = (25 - 13) / 2 = 12 / 2 = 6`. This matches the example output.\n\nThe logic seems sound.\n\n**Edge case `p = 0`:**\n`s_max = floor((1 + sqrt(1 + 0)) / 2) = floor(1/2) = 0`.\n`s_0 = 0`. This means we can't even form an SCC of size 1. This is not quite right. `s` must be at least 1.\nIf `s_0 = 0`, `p_0 = 0`. `p_rem = 0`.\n`n_min = 0 + 2*0 = 0`. This implies 0 nodes.\nHowever, a graph must have at least 1 node. If `p=0`, we can have `n=1` node (0 pairs). Or `n=2` nodes, no edges (0 pairs).\nThe minimum number of nodes for `p=0` is 1. If `n=1`, `s_0=1`, `p_0=0`, `p_rem=0`. `n_min = 1`.\nSo, if `s_0` calculated as `floor((1+sqrt(1+8p))/2)` is 0, we should use `s_0 = 1`. This makes sense because `f(1)=0` and uses 1 node.\nLet `s_0 = max(1, floor((1 + sqrt(1 + 8*p)) / 2))` for the calculation.\nFor `p=0`: `s_0 = max(1, 0) = 1`.\n`p_0 = 1 * (1 - 1) / 2 = 0`.\n`p_rem = 0 - 0 = 0`.\n`n_min = s_0 + 2 * p_rem = 1 + 2 * 0 = 1`.\nMax unidirectional pairs = `(1^2 - (1^2 + 4*0)) / 2 = (1 - 1) / 2 = 0`.\nSo for `p=0`, output is `1 0`. The example output is `0 0`.\nThe problem states `u < v` and `u != v`. If `n=0` or `n=1`, there are no pairs `(u, v)` with `u < v`. So `p=0` is achieved.\nIf `n=0`, there are 0 unidirectional pairs.\nIf `n=1`, there are 0 unidirectional pairs.\nThe minimum number of nodes for `p=0` is indeed 0.\nMy formula for `s_max` correctly gives 0 for `p=0`.\nThen `n_min = s_0 + 2 * p_rem` would be `0 + 0 = 0`.\nAnd max unidirectional pairs `(0^2 - (0^2 + 4*0)) / 2 = 0`.\nSo the formulas work even for `p=0` if we allow `s_0=0` and `n_min=0`.\nThis implies that `s_0` can be 0, and `n_min` can be 0.\nThe problem statement implies nodes are numbered `1, 2, ..., n`. If `n=0`, there are no nodes.\nThis is a standard competitive programming interpretation: `n=0` means an empty graph. An empty graph has `p=0` and 0 unidirectional pairs.\nSo for `p=0`, `n_min=0` and max unidirectional pairs = `0`.\n\nFinal check of the calculations:\n1. Calculate `s_0 = floor((1 + sqrt(1 + 8*p)) / 2)`.\n2. Calculate `p_0 = s_0 * (s_0 - 1) / 2`.\n3. Calculate `p_rem = p - p_0`.\n4. Minimum nodes `n_min = s_0 + 2 * p_rem`.\n5. Maximum unidirectional pairs `unidir_max = (n_min * n_min - (s_0 * s_0 + 4 * p_rem)) / 2`.\n\nExample `p=2*10^5`:\n`1 + 8*p = 1 + 16*10^5 = 1600001`.\n`sqrt(1600001)` approx `1264.91`.\n`s_0 = floor((1 + 1264.91) / 2) = floor(632.95) = 632`.\n`p_0 = 632 * 631 / 2 = 199396`.\n`p_rem = 200000 - 199396 = 604`.\n`n_min = 632 + 2 * 604 = 632 + 1208 = 1840`.\n`unidir_max = (1840^2 - (632^2 + 4 * 604)) / 2`\n`= (3385600 - (399424 + 2416)) / 2`\n`= (3385600 - 401840) / 2`\n`= 2983760 / 2 = 1491880`.\n\nThe maximum value of `p` is `2 * 10^5`.\n`n_min` will be around `sqrt(2*2*10^5) = sqrt(4*10^5) = 2 * 10^(2.5) approx 632`.\nPlus `2*p_rem` which is at most `2 * (s_0-1)`. So `n_min` is roughly `s_0 + 2*s_0 = 3*s_0`.\nSo `n_min` is at most `3 * 632 = 1896`.\n`n_min^2` is at most `(1896)^2` which is approximately `3.6 * 10^6`. This fits in standard integer types.\n\n```python\nimport math\n\ndef solve():\n    p = int(input())\n\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    # Calculate s_0: the size of the largest possible SCC\n    # s_0 * (s_0 - 1) / 2 <= p\n    # s_0^2 - s_0 - 2p <= 0\n    # Roots of x^2 - x - 2p = 0 are (1 +/- sqrt(1 + 8p)) / 2\n    # We want s_0 <= (1 + sqrt(1 + 8p)) / 2\n    s_0 = int((1 + math.sqrt(1 + 8 * p)) / 2)\n\n    # Calculate p_0: pairs contributed by the SCC of size s_0\n    p_0 = s_0 * (s_0 - 1) // 2\n\n    # Calculate p_rem: remaining pairs needed\n    p_rem = p - p_0\n\n    # Minimum number of nodes:\n    # s_0 nodes for the main SCC\n    # 2 * p_rem nodes for p_rem SCCs of size 2 (each contributing 1 pair)\n    n_min = s_0 + 2 * p_rem\n\n    # Maximum unidirectional pairs:\n    # This is achieved by arranging all SCCs in a chain.\n    # The total number of pairs (u, v) with u != v and u reachable to v is n_min * (n_min - 1).\n    # This sum includes:\n    #   1. Pairs (u, v) where u, v are in the same SCC (reachable both ways).\n    #      This is sum(s_i * (s_i - 1)).\n    #   2. Pairs (u, v) where u, v are in different SCCs, u -> v but not v -> u (unidirectional).\n    #      This is the value we want.\n    # The sum of (s_i * (s_i - 1)) over all SCCs is sum(2 * f(s_i)) = 2 * P_total_reachable_both_ways.\n    # The total number of pairs (u,v) where u != v and u and v are reachable from each other is 2 * p.\n    #\n    # Alternatively, for a chain of SCCs, the number of unidirectional pairs is\n    # (Total pairs of distinct nodes) - (Pairs reachable both ways)\n    # Total pairs of distinct nodes = n_min * (n_min - 1)\n    # Pairs reachable both ways = sum(s_i * (s_i - 1)) for all SCCs.\n    # The SCCs are: one of size s_0, and p_rem of size 2.\n    # Sum of s_i * (s_i - 1) = s_0 * (s_0 - 1) + p_rem * (2 * (2 - 1))\n    #                       = s_0 * (s_0 - 1) + p_rem * 2\n    #                       = 2 * p_0 + 2 * p_rem\n    #                       = 2 * (p_0 + p_rem) = 2 * p\n    # So, unidir_max = n_min * (n_min - 1) - 2 * p\n    # This is a general formula for a graph where the condensation graph is a DAG.\n    # And specifically for a chain, this maximizes the number of unidirectional pairs.\n    unidir_max = n_min * (n_min - 1) - 2 * p\n\n    print(f\"{n_min} {unidir_max}\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef solve():\n    p = int(input())\n\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    # Calculate s_0: the size of the largest possible SCC\n    # s_0 * (s_0 - 1) / 2 <= p\n    # s_0^2 - s_0 - 2p <= 0\n    # Roots of x^2 - x - 2p = 0 are (1 +/- sqrt(1 + 8p)) / 2\n    # We want s_0 <= (1 + sqrt(1 + 8p)) / 2\n    s_0 = int((1 + math.sqrt(1 + 8 * p)) / 2)\n\n    # Calculate p_0: pairs contributed by the SCC of size s_0\n    p_0 = s_0 * (s_0 - 1) // 2\n\n    # Calculate p_rem: remaining pairs needed\n    p_rem = p - p_0\n\n    # Minimum number of nodes:\n    # s_0 nodes for the main SCC\n    # 2 * p_rem nodes for p_rem SCCs of size 2 (each contributing 1 pair)\n    n_min = s_0 + 2 * p_rem\n\n    # Maximum unidirectional pairs:\n    # This is achieved by arranging all SCCs in a chain.\n    # The total number of pairs (u, v) with u != v and u reachable to v is n_min * (n_min - 1).\n    # This sum includes:\n    #   1. Pairs (u, v) where u, v are in the same SCC (reachable both ways).\n    #      This is sum(s_i * (s_i - 1)).\n    #   2. Pairs (u, v) where u, v are in different SCCs, u -> v but not v -> u (unidirectional).\n    #      This is the value we want.\n    # The sum of (s_i * (s_i - 1)) over all SCCs is sum(2 * f(s_i)) = 2 * P_total_reachable_both_ways.\n    # The total number of pairs (u,v) where u != v and u and v are reachable from each other is 2 * p.\n    #\n    # Alternatively, for a chain of SCCs, the number of unidirectional pairs is\n    # (Total pairs of distinct nodes) - (Pairs reachable both ways)\n    # Total pairs of distinct nodes = n_min * (n_min - 1)\n    # Pairs reachable both ways = sum(s_i * (s_i - 1)) for all SCCs.\n    # The SCCs are: one of size s_0, and p_rem of size 2.\n    # Sum of s_i * (s_i - 1) = s_0 * (s_0 - 1) + p_rem * (2 * (2 - 1))\n    #                       = s_0 * (s_0 - 1) + p_rem * 2\n    #                       = 2 * p_0 + 2 * p_rem\n    #                       = 2 * (p_0 + p_rem) = 2 * p\n    # So, unidir_max = n_min * (n_min - 1) - 2 * p\n    # This is a general formula for a graph where the condensation graph is a DAG.\n    # And specifically for a chain, this maximizes the number of unidirectional pairs.\n    unidir_max = n_min * (n_min - 1) - 2 * p\n\n    print(f\"{n_min} {unidir_max}\")\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 482,
        "completion_token_count": 4923,
        "thoughts_token_count": 780
    }
}