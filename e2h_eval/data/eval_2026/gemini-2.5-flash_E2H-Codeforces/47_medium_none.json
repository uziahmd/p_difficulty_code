{
    "start": 1758294746.4948385,
    "end": 1758294790.3663764,
    "start-formatted": "2025-09-20 00:12 KST",
    "end-formatted": "2025-09-20 00:13 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "**Problem-Solving Journey for the Neko Maths Challenge**\n\nAlright, let's break this down. We need a Python script to minimize the LCM of `a+k` and `b+k`, where `k` is a non-negative integer. The key here is to understand the relationship between the GCD and LCM: `lcm(x, y) = (x * y) / gcd(x, y)`.  Our strategy is to maximize the `gcd(a+k, b+k)`.\n\nLet's assume `a <= b` (we can swap them if not). The critical insight is that `gcd(a+k, b+k)` *must* divide `b - a` (the difference). So, we iterate through all divisors (`d`) of `b-a`. For each divisor, we aim to find the smallest `k` such that `gcd(a+k, b+k) = d`. This means both `a+k` and `b+k` have to be multiples of `d`.\n\nTo ensure `a+k` is a multiple of `d`, the smallest `k` is calculated as `(d - (a % d)) % d`.  We then check if `b+k` is also a multiple of `d`. Given that `d` divides `diff`, and we made `a+k` a multiple of `d`, `b+k` *will* also be a multiple of `d`!  We compute the LCM and compare it to the current minimum, updating it and the corresponding `k` if needed, but always keeping track of the smallest `k` for a given LCM.\n\nWe loop through divisors of the difference, from `1` to `sqrt(diff)`, which is pretty efficient. There is a special edge case to handle - `a=b`. If `a` and `b` are equal, our loop to find divisors is short-circuited. Then, setting `k=0` will give the smallest possible `lcm` which is equal to `a`. I am using the standard `math.gcd` function in Python for an efficient GCD calculation.  The resulting `k` (the solution) is outputted after the loop. This covers all cases and is efficient.\n",
    "response": "```python\nimport math\nimport sys\n\ndef solve():\n    a, b = map(int, sys.stdin.readline().split())\n\n    if a == b:\n        print(0)\n        return\n\n    if a > b:\n        a, b = b, a\n\n    diff = b - a\n\n    min_lcm_val = float('inf')\n    ans_k = 0\n\n    for i in range(1, int(math.sqrt(diff)) + 1):\n        if diff % i == 0:\n            divisors_to_check = [i]\n            if i * i != diff:\n                divisors_to_check.append(diff // i)\n            \n            for d in divisors_to_check:\n                current_k = (d - (a % d)) % d\n                \n                current_A = a + current_k\n                current_B = b + current_k\n                \n                current_gcd = math.gcd(current_A, current_B)\n                current_lcm = (current_A // current_gcd) * current_B\n                \n                if current_lcm < min_lcm_val:\n                    min_lcm_val = current_lcm\n                    ans_k = current_k\n                elif current_lcm == min_lcm_val:\n                    ans_k = min(ans_k, current_k)\n\n    print(ans_k)\n\nif __name__ == '__main__':\n    solve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\nimport sys\n\ndef solve():\n    a, b = map(int, sys.stdin.readline().split())\n\n    if a == b:\n        print(0)\n        return\n\n    if a > b:\n        a, b = b, a\n\n    diff = b - a\n\n    min_lcm_val = float('inf')\n    ans_k = 0\n\n    for i in range(1, int(math.sqrt(diff)) + 1):\n        if diff % i == 0:\n            divisors_to_check = [i]\n            if i * i != diff:\n                divisors_to_check.append(diff // i)\n            \n            for d in divisors_to_check:\n                current_k = (d - (a % d)) % d\n                \n                current_A = a + current_k\n                current_B = b + current_k\n                \n                current_gcd = math.gcd(current_A, current_B)\n                current_lcm = (current_A // current_gcd) * current_B\n                \n                if current_lcm < min_lcm_val:\n                    min_lcm_val = current_lcm\n                    ans_k = current_k\n                elif current_lcm == min_lcm_val:\n                    ans_k = min(ans_k, current_k)\n\n    print(ans_k)\n\nif __name__ == '__main__':\n    solve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 412,
        "completion_token_count": 343,
        "thoughts_token_count": 6611
    }
}