{
    "start": 1758011942.7059405,
    "end": 1758012037.4347284,
    "start-formatted": "2025-09-16 17:39 KST",
    "end-formatted": "2025-09-16 17:40 KST",
    "gpu": 2,
    "pid": 8,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "**Reconstructing Flow Directions in a Directed Acyclic Graph**\n\nOkay, here's the deal: I'm staring down a competitive programming problem called \"Flawed Flow.\" It's essentially a graph problem, and the goal is to direct the edges of an undirected graph in a way that satisfies specific flow conservation and acyclicity constraints. I need to make the graph directed, while keeping the flow conservation principle for all intermediate vertices.\n\nHere's my thinking so far. First, the problem provides edge capacities. I understand that the \"no cycles\" condition is the most critical. It essentially means that the directed graph must be a Directed Acyclic Graph (DAG). This implies that there exists at least one source (vertex with no incoming edges) and at least one sink (vertex with no outgoing edges). Luckily, this problem guarantees a solution exists. Vertex 1 is specifically mentioned as having no incoming edges which means it's a source, which is also a strong constraint.\n\nMy strategy involves working with a balance concept. Let's call it the \"balance\" of a vertex; it's the difference between the incoming and outgoing flow. Initially, all edges are undirected, so every vertex is perfectly balanced. I have to direct edges such that the balance of every vertex (except vertex 1 and vertex n) becomes zero, guaranteeing flow conservation.\n\nFirst, I'm taking care of edges connected to vertex 1 (the source). Those are always directed outwards, which sets an initial balance for the connected nodes. Then, I need to look at other vertices to adjust their balances. For intermediate vertices (not the source or the sink), the sum of incoming flow must equal the sum of outgoing flow, so their balance needs to reach zero. My plan is to iteratively process the vertices and adjust the direction of undirected edges. If a vertex has a positive balance (more incoming than outgoing), some of its edges need to be directed *out*. If a vertex has a negative balance (more outgoing than incoming), some edges need to be directed *in*.\n\nSince the graph must be a DAG, I need to avoid creating cycles while directing edges. I think I can use the concept of a topological sort or a similar iterative approach. I can use a queue and keep track of edge states to maintain the acyclic condition. I'll focus on making sure that once an edge is directed, I don't introduce any cycles in the process.\n\nI'll maintain a state called `current_balance` for each vertex and use the capacities of the edges to track flow. I need to guarantee that once all edges connected to a node are directed, its balance is zero.\n\nI'm thinking of an iterative process. First, I would take care of vertices 1 and those edges, and, then, iteratively visit vertices that become \"ready\" to be processed. A vertex will be ready when the directed edges guarantee its balance has reached zero. Once the balance is reached, all the remaining undirected edges of that vertex must be directed. I must make sure that it's possible for this algorithm to reach a solution. I also realize that the sum of the capacities of all edges incident to a vertex (except source or sink) must be an even number. Otherwise, the flow conservation rule cannot be satisfied. The problem is also simplified as the problem statement guarantees a valid solution exists, and this should help make my design easier.\n",
    "response": "The problem asks us to direct the edges of an undirected graph, given the flow volume for each edge, such that several conditions are met:\n1.  **Flow conservation:** For any intermediate vertex `v` (1 < `v` < `n`), the sum of incoming flow must equal the sum of outgoing flow.\n2.  **Source constraint:** Vertex 1 (the source) must have no incoming edges.\n3.  **Acyclicity:** The resulting directed graph must not contain any cycles.\n4.  The problem guarantees that a solution always exists.\n\nLet's denote the flow volume on an edge `(u, v)` as `c_uv`.\n\n**Analysis of Conditions:**\n\n*   **Source Constraint (Vertex 1):** Since vertex 1 must have no incoming edges, any edge `(1, u)` with flow `c_1u` must be directed `1 -> u`. This is a fixed decision for all edges incident to vertex 1.\n\n*   **Flow Conservation (Intermediate Vertices):** For any vertex `v` where `1 < v < n`, let `F_in(v)` be the total flow entering `v` and `F_out(v)` be the total flow leaving `v`. The condition is `F_in(v) = F_out(v)`.\n    Let `S_v` be the sum of flow volumes of all edges incident to `v`. Then `S_v = F_in(v) + F_out(v)`.\n    Substituting `F_out(v) = F_in(v)`, we get `S_v = 2 * F_in(v)`.\n    This implies that `S_v` must be an even number for all `1 < v < n`. If `S_v` were odd, `F_in(v)` would have to be non-integer, which is not possible as `c_i` are integers. The problem guarantees a solution exists, so this condition must hold.\n    Also, `F_in(v)` must be exactly `S_v / 2`.\n\n*   **Acyclicity:** The requirement of no cycles, combined with vertex 1 being a source (no incoming edges), strongly suggests a topological ordering. We can process vertices in an order that ensures edges are always directed from an \"earlier\" vertex to a \"later\" vertex in the topological sort.\n\n**Algorithm:**\n\nThe core idea is to process vertices whose required incoming flow (`S_v / 2`) is met, thus fixing directions for their remaining undirected edges.\n\n1.  **Data Structures:**\n    *   `adj`: An adjacency list `adj[u]` stores `(v, capacity, edge_id)` for all edges incident to `u`. This helps retrieve neighbors and edge details.\n    *   `ans`: An array of size `m` to store the output directions. `ans[i] = 0` for `a_i -> b_i`, `ans[i] = 1` for `b_i -> a_i`. Initialize with -1 (undetermined).\n    *   `current_in_flow`: An array of size `n+1` where `current_in_flow[v]` stores the sum of capacities of edges *already directed* into `v`. Initialize to 0.\n    *   `total_capacity_sum`: An array of size `n+1` where `total_capacity_sum[v]` stores the sum of capacities of *all* edges incident to `v`.\n    *   `undirected_edge_count`: An array of size `n+1` where `undirected_edge_count[v]` stores the number of *undirected* edges currently incident to `v`. Initialize to 0.\n    *   `edge_details`: An array of size `m` storing `(u, v, c)` for the original input edges.\n\n2.  **Initialization and Preprocessing:**\n    *   Read `n` and `m`.\n    *   For each edge `i` from 0 to `m-1`:\n        *   Read `u, v, c`. Store `edge_details[i] = (u, v, c)`.\n        *   Add `(v, c, i)` to `adj[u]` and `(u, c, i)` to `adj[v]`.\n        *   Update `total_capacity_sum[u] += c` and `total_capacity_sum[v] += c`.\n        *   Increment `undirected_edge_count[u]` and `undirected_edge_count[v]`.\n\n3.  **Process Source Edges (Vertex 1):**\n    *   Create a `collections.deque` named `q`.\n    *   For each `(neighbor, capacity, edge_id)` in `adj[1]`:\n        *   If `ans[edge_id]` is still -1 (meaning this edge hasn't been processed yet):\n            *   Set `ans[edge_id] = 0` (direct `1 -> neighbor`).\n            *   Update `current_in_flow[neighbor] += capacity`.\n            *   Decrement `undirected_edge_count[1]` and `undirected_edge_count[neighbor]`.\n            *   If `neighbor != 1` (to avoid self-loops if source is its own neighbor):\n                *   If `neighbor != n` and `current_in_flow[neighbor] == total_capacity_sum[neighbor] // 2`:\n                    *   Add `neighbor` to `q`. This vertex has received its required incoming flow, so all its *remaining* undirected edges must be outgoing.\n\n4.  **Breadth-First Search (BFS) for Remaining Edges:**\n    *   While `q` is not empty:\n        *   Dequeue a vertex `u` from `q`.\n        *   For each `(neighbor, capacity, edge_id)` in `adj[u]`:\n            *   If `ans[edge_id]` is still -1 (meaning the edge `(u, neighbor)` is still undirected):\n                *   Check the original edge `(a, b, c)` from `edge_details[edge_id]`.\n                *   If `a == u`: Direct `u -> neighbor`. Set `ans[edge_id] = 0`.\n                *   Else (`b == u`): Direct `u -> neighbor`. Set `ans[edge_id] = 1`.\n                *   Update `current_in_flow[neighbor] += capacity`.\n                *   Decrement `undirected_edge_count[u]` and `undirected_edge_count[neighbor]`.\n                *   If `neighbor != n` and `current_in_flow[neighbor] == total_capacity_sum[neighbor] // 2`:\n                    *   Add `neighbor` to `q`.\n\n5.  **Output:**\n    *   Print each value in the `ans` array.\n\n**Correctness Justification:**\n\n*   **Source Constraint:** Handled in step 3. All edges from vertex 1 are directed outwards.\n*   **Flow Conservation for Intermediate Vertices:**\n    *   For any `v` (1 < `v` < `n`), we know `F_in(v)` must be `total_capacity_sum[v] / 2`.\n    *   When a vertex `u` is added to the queue (`q.append(u)`), it means `current_in_flow[u]` has reached `total_capacity_sum[u] / 2`. At this point, all remaining undirected edges incident to `u` *must* be directed *out* of `u` to satisfy flow conservation. Any incoming flow on these edges would make `F_in(u)` exceed `total_capacity_sum[u] / 2`, which is impossible.\n    *   By directing these edges out of `u`, we update `current_in_flow` for their neighbors and potentially add new vertices to the queue. This process continues until all intermediate vertices have their flow balanced.\n*   **Acyclicity:** The algorithm processes vertices in a topological-like order. When `u` is dequeued, all its remaining incident edges are directed `u -> neighbor`. This means flow always moves from an already \"balanced\" or \"processed\" vertex `u` to an \"unprocessed\" or \"partially processed\" neighbor `v`. This ensures that we never direct an edge `v -> u` if `u` was processed before `v` in this manner, thus preventing cycles.\n*   **Vertex `n` (Sink):** Vertex `n` is never added to the queue. Its `current_in_flow[n]` will naturally accumulate all incoming flow. The problem statement does not impose `F_out(n) = 0`, but the acyclicity and source constraint imply that all flow from 1 must eventually reach `n` if it's the only sink. The algorithm ensures `current_in_flow[n]` will be the total max flow.\n\n**Example Walkthrough (First Sample):**\n\n`n=3, m=3`\nEdges:\n0: (3, 2, 10)\n1: (1, 2, 10)\n2: (3, 1, 5)\n\n1.  **Preprocessing:**\n    `adj`:\n    1: `[(2, 10, 1), (3, 5, 2)]`\n    2: `[(3, 10, 0), (1, 10, 1)]`\n    3: `[(2, 10, 0), (1, 5, 2)]`\n    `total_capacity_sum`: `[0, 15, 20, 15]` (index 0 unused)\n    `undirected_edge_count`: `[0, 2, 2, 2]`\n    `current_in_flow`: `[0, 0, 0, 0]`\n    `ans`: `[-1, -1, -1]`\n    `edge_details`: `[(3,2,10), (1,2,10), (3,1,5)]`\n\n2.  **Process Source Edges (Vertex 1):**\n    Edges incident to 1: `(1, 2, 10, 1)` and `(1, 3, 5, 2)` (original: `(3,1,5)`).\n    *   Edge (1, 2, 10, 1): `ans[1] = 0` (1 -> 2). `current_in_flow[2] += 10`. `undirected_edge_count[1]--`, `undirected_edge_count[2]--`.\n        `current_in_flow[2] = 10`. `undirected_edge_count`: `[0, 1, 1, 2]`.\n        `2 != n` (2 != 3). `current_in_flow[2] == total_capacity_sum[2] // 2` (10 == 20 // 2) is True. Add `2` to `q`. `q = [2]`.\n    *   Edge (3, 1, 5, 2): Original edge is (3,1), flow 5. It's connected to 1. So it must be `1 -> 3`.\n        `ans[2] = 1` (means `1 -> 3`, i.e., `b_i -> a_i` for `(a_i, b_i) = (3,1)`). `current_in_flow[3] += 5`. `undirected_edge_count[1]--`, `undirected_edge_count[3]--`.\n        `current_in_flow[3] = 5`. `undirected_edge_count`: `[0, 0, 1, 1]`.\n        `3 == n`, so 3 is not added to `q`.\n\n    At this point:\n    `ans`: `[-1, 0, 1]`\n    `current_in_flow`: `[0, 0, 10, 5]`\n    `undirected_edge_count`: `[0, 0, 1, 1]`\n    `q = [2]`\n\n3.  **BFS:**\n    *   Dequeue `u = 2`.\n    *   Edges incident to 2 in `adj[2]`: `(3, 10, 0)` and `(1, 10, 1)`.\n        *   Edge `(1, 10, 1)`: `ans[1]` is 0, already processed. Skip.\n        *   Edge `(3, 10, 0)`: `ans[0]` is -1 (undetermined). Original edge is `(3, 2, 10)`. `a=3, b=2`. Current node `u=2`. So `b=u`.\n            Direct `u -> neighbor`, i.e., `2 -> 3`.\n            Set `ans[0] = 0` (means `a_i -> b_i` for `(a_i, b_i) = (3,2)`, so `3 -> 2`). Wait, this is `a_i -> b_i` if `a_i` is the source, or `b_i -> a_i` if `b_i` is the source.\n            The problem states: `d_i = 0` if `a_i -> b_i`, `d_i = 1` otherwise (`b_i -> a_i`).\n            The edge is `(3, 2, 10)`. We want `2 -> 3`. This means `b_i -> a_i`. So `ans[0] = 1`.\n            `current_in_flow[3] += 10`. `undirected_edge_count[2]--`, `undirected_edge_count[3]--`.\n            `current_in_flow[3] = 5 + 10 = 15`. `undirected_edge_count`: `[0, 0, 0, 0]`.\n            `3 == n`, so 3 is not added to `q`.\n\n    `q` is now empty. All edges processed.\n\n4.  **Output:**\n    `ans`: `[1, 0, 1]`\n    This matches the example output: `1\\n0\\n1`.\n\n```python\nimport sys\nimport collections\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    edge_details = [] # Stores (u, v, c) for original edges\n    \n    # Store all edges and calculate total_capacity_sum for each node\n    total_capacity_sum = [0] * (n + 1)\n    undirected_edge_count = [0] * (n + 1) # This will be decremented as edges are directed\n\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        edge_details.append((u, v, c))\n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n        total_capacity_sum[u] += c\n        total_capacity_sum[v] += c\n        undirected_edge_count[u] += 1\n        undirected_edge_count[v] += 1\n\n    ans = [-1] * m # 0 for u -> v, 1 for v -> u (if original was (u,v))\n    current_in_flow = [0] * (n + 1)\n    \n    q = collections.deque()\n\n    # Process edges connected to source (vertex 1)\n    # All edges connected to vertex 1 must be directed OUT of 1.\n    # This means if an edge is (1, v, c) it becomes 1 -> v.\n    # If an edge is (u, 1, c) it becomes u -> 1.\n    # No, the problem says \"vertex with number 1 has no incoming edges\".\n    # This means for any edge involving 1, say (x, 1) or (1, x), it must be 1 -> x.\n    # The output format is based on the original (ai, bi).\n    # If original edge is (ai, bi), ans[i]=0 means ai -> bi. ans[i]=1 means bi -> ai.\n\n    for neighbor, capacity, edge_id in adj[1]:\n        if ans[edge_id] == -1: # Only process if not already directed (e.g. by another edge from 1)\n            u_orig, v_orig, _ = edge_details[edge_id]\n            \n            if u_orig == 1: # Original edge was (1, v_orig), so 1 -> v_orig\n                ans[edge_id] = 0 \n                current_in_flow[v_orig] += capacity\n                undirected_edge_count[1] -= 1\n                undirected_edge_count[v_orig] -= 1\n                if v_orig != n and current_in_flow[v_orig] == total_capacity_sum[v_orig] // 2:\n                    q.append(v_orig)\n            else: # Original edge was (u_orig, 1), so 1 -> u_orig\n                ans[edge_id] = 1 \n                current_in_flow[u_orig] += capacity\n                undirected_edge_count[1] -= 1\n                undirected_edge_count[u_orig] -= 1\n                if u_orig != n and current_in_flow[u_orig] == total_capacity_sum[u_orig] // 2:\n                    q.append(u_orig)\n    \n    # BFS to determine directions for remaining edges\n    while q:\n        u = q.popleft()\n        \n        # For vertex u, current_in_flow[u] is now total_capacity_sum[u] // 2.\n        # This means all remaining undirected edges incident to u must be directed OUT of u.\n        \n        for neighbor, capacity, edge_id in adj[u]:\n            if ans[edge_id] == -1: # If edge is still undirected\n                u_orig, v_orig, _ = edge_details[edge_id]\n\n                # We want to direct u -> neighbor\n                if u_orig == u: # Original edge was (u, neighbor), so u -> neighbor\n                    ans[edge_id] = 0\n                else: # Original edge was (neighbor, u), so u -> neighbor\n                    ans[edge_id] = 1\n                \n                current_in_flow[neighbor] += capacity\n                undirected_edge_count[u] -= 1\n                undirected_edge_count[neighbor] -= 1\n                \n                # If neighbor is an intermediate node and its required incoming flow is met, add to queue\n                if neighbor != n and current_in_flow[neighbor] == total_capacity_sum[neighbor] // 2:\n                    q.append(neighbor)\n\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + '\\n')\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport collections\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    edge_details = [] # Stores (u, v, c) for original edges\n    \n    # Store all edges and calculate total_capacity_sum for each node\n    total_capacity_sum = [0] * (n + 1)\n    undirected_edge_count = [0] * (n + 1) # This will be decremented as edges are directed\n\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        edge_details.append((u, v, c))\n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n        total_capacity_sum[u] += c\n        total_capacity_sum[v] += c\n        undirected_edge_count[u] += 1\n        undirected_edge_count[v] += 1\n\n    ans = [-1] * m # 0 for u -> v, 1 for v -> u (if original was (u,v))\n    current_in_flow = [0] * (n + 1)\n    \n    q = collections.deque()\n\n    # Process edges connected to source (vertex 1)\n    # All edges connected to vertex 1 must be directed OUT of 1.\n    # This means if an edge is (1, v, c) it becomes 1 -> v.\n    # If an edge is (u, 1, c) it becomes u -> 1.\n    # No, the problem says \"vertex with number 1 has no incoming edges\".\n    # This means for any edge involving 1, say (x, 1) or (1, x), it must be 1 -> x.\n    # The output format is based on the original (ai, bi).\n    # If original edge is (ai, bi), ans[i]=0 means ai -> bi. ans[i]=1 means bi -> ai.\n\n    for neighbor, capacity, edge_id in adj[1]:\n        if ans[edge_id] == -1: # Only process if not already directed (e.g. by another edge from 1)\n            u_orig, v_orig, _ = edge_details[edge_id]\n            \n            if u_orig == 1: # Original edge was (1, v_orig), so 1 -> v_orig\n                ans[edge_id] = 0 \n                current_in_flow[v_orig] += capacity\n                undirected_edge_count[1] -= 1\n                undirected_edge_count[v_orig] -= 1\n                if v_orig != n and current_in_flow[v_orig] == total_capacity_sum[v_orig] // 2:\n                    q.append(v_orig)\n            else: # Original edge was (u_orig, 1), so 1 -> u_orig\n                ans[edge_id] = 1 \n                current_in_flow[u_orig] += capacity\n                undirected_edge_count[1] -= 1\n                undirected_edge_count[u_orig] -= 1\n                if u_orig != n and current_in_flow[u_orig] == total_capacity_sum[u_orig] // 2:\n                    q.append(u_orig)\n    \n    # BFS to determine directions for remaining edges\n    while q:\n        u = q.popleft()\n        \n        # For vertex u, current_in_flow[u] is now total_capacity_sum[u] // 2.\n        # This means all remaining undirected edges incident to u must be directed OUT of u.\n        \n        for neighbor, capacity, edge_id in adj[u]:\n            if ans[edge_id] == -1: # If edge is still undirected\n                u_orig, v_orig, _ = edge_details[edge_id]\n\n                # We want to direct u -> neighbor\n                if u_orig == u: # Original edge was (u, neighbor), so u -> neighbor\n                    ans[edge_id] = 0\n                else: # Original edge was (neighbor, u), so u -> neighbor\n                    ans[edge_id] = 1\n                \n                current_in_flow[neighbor] += capacity\n                undirected_edge_count[u] -= 1\n                undirected_edge_count[neighbor] -= 1\n                \n                # If neighbor is an intermediate node and its required incoming flow is met, add to queue\n                if neighbor != n and current_in_flow[neighbor] == total_capacity_sum[neighbor] // 2:\n                    q.append(neighbor)\n\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + '\\n')\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 736,
        "completion_token_count": 4413,
        "thoughts_token_count": 7741
    }
}