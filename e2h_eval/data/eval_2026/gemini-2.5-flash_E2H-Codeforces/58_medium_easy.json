{
    "start": 1758294834.0134168,
    "end": 1758294931.4487004,
    "start-formatted": "2025-09-20 00:13 KST",
    "end-formatted": "2025-09-20 00:15 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "**Initial Assessment & Problem Decomposition**\n\nAlright, the task is to tackle a competitive programming problem focused on graph manipulation: specifically, adding the minimum number of edges (`t`) to a given graph to create an odd-length cycle, and counting the ways (`w`) to achieve this. My strategy is to break this down by leveraging graph coloring properties, particularly the concept of bipartiteness. A graph contains an odd cycle if and only if it's not bipartite, so that's the key. If the input graph already has an odd cycle, the problem's trivial; `t` is 0, and `w` is 1. Otherwise, we analyze the connected components.\n\n**Detailed Cases & Analysis**\n\nThe core of the problem lies in handling bipartite graphs.\n\n*   **Case 0 (Odd Cycle Exists):** Use BFS or DFS and 2-coloring. If an edge connects vertices of the same color within any connected component, an odd cycle is present, and `t` is 0.\n\n*   **Case 1 (Need One Edge):** If the initial graph is bipartite, we attempt to form an odd cycle by adding a single edge. This requires finding two vertices within the *same* connected component that have the *same* color in the 2-coloring. The count of such valid edges is `w`. The number of ways to pick this edge is calculated within each connected component, accounting for possible overlapping edges that form the odd cycle.\n\n*   **Case 2 (Need Two Edges):** If adding a single edge won't work, all connected components are essentially either isolated vertices or single edges. We need to add at least two edges. So the logic here becomes critical to finding the minimum value of `t`. If all connected components are isolated vertices or edges, it becomes obvious that at least two edges are required. The key is in how we merge the existing components to reach a non-bipartite state.\n\n*   **Case 3 (n=3, m=0):** This is the base case. If the graph has three isolated vertices with no edges between them (`3 0 -> 3 1`), we require three edges to form a cycle (`3 1`).\n\n**Edge Counting and Algorithm Optimization**\n\nTo calculate `w` accurately for `t = 1`, for each component, we will iterate and calculate how many edges can be created using the coloring, taking out any overlapping edges. If `t=1` isn't possible, then we must increase `t` by 1. The challenge lies in determining the precise conditions for when `t` must be greater than 1.\n\nThe crucial observation is that if no components are comprised of any vertices with identical color, then it will take more than one edge to make an odd cycle. If the individual components are just a single node or a single edge, then the only way to generate an odd cycle is by adding at least two more edges.\n\nTherefore, for cases in which `t=2` (two edges) is necessary, we connect isolated vertices or single-edge components to generate an odd-length cycle. Given an isolated vertex and a separate single edge, we add two new edges to create a triangle, which is an odd-length cycle. The answer will, therefore, be `t = 2`, and `w` would represent number of ways you can pick the vertices in each component.\n\nIf we need to add 3 or more edges we should use a different approach altogether. If we have isolated components, we would connect them together using three more edges. This becomes an edge case and is not discussed because based on the problem statement, we should be able to produce an odd-cycle graph.\n\nIf all the components are single vertices then the number of ways to generate the triangle will be determined by a combination equation.\n",
    "response": "The problem asks us to find the minimum number of edges `t` to add to a given undirected graph to form a simple cycle of odd length, and `w` the number of ways to do so. A simple cycle means each vertex occurs at most once.\n\nA graph contains an odd cycle if and only if it is not bipartite. Our strategy will be to determine the graph's bipartiteness, and if it's bipartite, find the minimum edges to make it non-bipartite.\n\nWe can use a 2-coloring algorithm (BFS or DFS) to check if the graph is bipartite. We iterate through all vertices. If a vertex hasn't been visited, start a BFS/DFS from it to explore its connected component. During the traversal, assign colors (say, 0 and 1) to vertices such that adjacent vertices have different colors. If we encounter an edge connecting two vertices of the same color, we've found an odd cycle.\n\nLet `N` be the number of vertices and `M` be the number of edges.\n\n**Step 1: Check for existing odd cycles (t=0)**\nPerform a 2-coloring on the entire graph.\nInitialize `color[v] = -1` for all `v`.\nFor each unvisited vertex `s`:\n  Start a BFS from `s`.\n  `q = deque([s])`, `color[s] = 0`.\n  While `q` is not empty:\n    `u = q.popleft()`.\n    For each neighbor `v` of `u`:\n      If `color[v] == -1`:\n        `color[v] = 1 - color[u]`.\n        `q.append(v)`.\n      Else if `color[v] == color[u]`:\n        // Found an odd cycle.\n        `t = 0`, `w = 1`. Print `0 1` and exit.\n\n**Step 2: Graph is bipartite, calculate counts for t=1, t=2, t=3**\nIf we reach this step, the graph is bipartite. All connected components are bipartite.\nDuring the 2-coloring process, for each connected component `C`, we can count the number of vertices assigned color 0 (`cnt0`) and color 1 (`cnt1`).\nLet `N_comp` be the total number of connected components.\nLet `isolated_vertices_count` be the number of components that are single isolated vertices (i.e., `cnt0=1, cnt1=0` or `cnt0=0, cnt1=1`).\nLet `edge_components_count` be the number of components that are single edges (i.e., `cnt0=1, cnt1=1`).\nLet `large_components_count` be the number of components with `cnt0 > 1` or `cnt1 > 1` (these are components where `t=1` is possible within themselves).\n\nWe need to accumulate `cnt0` and `cnt1` for each component to determine `t` and `w`.\n`sum_sq_cnt0 = sum(cnt0_i * (cnt0_i - 1) / 2)` over all components.\n`sum_sq_cnt1 = sum(cnt1_i * (cnt1_i - 1) / 2)` over all components.\n`sum_comp_prod = sum(cnt0_i * cnt1_i)` over all components.\n\n**Case t=1:**\nAn odd cycle can be formed by adding one edge `(u, v)` if `u` and `v` are in the same connected component and have the same color.\nThe number of such pairs `(u, v)` (which are not already edges) is `sum_sq_cnt0 + sum_sq_cnt1`. (Since the graph is bipartite, no existing edge connects same-colored vertices).\nIf `sum_sq_cnt0 + sum_sq_cnt1 > 0`, then `t=1`.\n`w = sum_sq_cnt0 + sum_sq_cnt1`.\nPrint `1 w` and exit.\n\n**Case t=2:**\nIf `t=1` is not possible, it means for every connected component `i`, `cnt0_i <= 1` and `cnt1_i <= 1`.\nThis implies each component is either an isolated vertex (`cnt0=1, cnt1=0` or `cnt0=0, cnt1=1`) or a single edge (`cnt0=1, cnt1=1`).\nTo form an odd cycle with two edges, say `(u,v)` and `(v,w)`, where `u,v,w` are distinct:\nWe can pick an isolated vertex `u` and a component that is a single edge `v-w`. Add edges `(u,v)` and `(u,w)`. This forms a triangle `u-v-w-u`, which is an odd cycle.\nThe number of ways `w` for this scenario is `isolated_vertices_count * edge_components_count`.\nIf `w > 0`, then `t=2`.\nPrint `2 w` and exit.\n\n**Case t=3:**\nIf `t=1` and `t=2` are not possible, it implies:\n1. `t=1` not possible: All components are isolated vertices or single edges.\n2. `t=2` not possible: There are no isolated vertices AND no single-edge components (i.e., `isolated_vertices_count = 0` or `edge_components_count = 0`).\n   - If `isolated_vertices_count > 0` and `edge_components_count = 0`: All components are isolated vertices. We need to pick 3 vertices `u, v, w` and add edges `(u,v), (v,w), (w,u)`. This forms an odd cycle. This requires `n >= 3`.\n     The number of ways `w` is `n * (n-1) * (n-2) / 6`, which is `C(n, 3)`.\n   - If `isolated_vertices_count = 0` and `edge_components_count > 0`: All components are single edges. We need to pick 3 vertices `u, v, w` from 3 different edge components, say `u-u'`, `v-v'`, `w-w'`. Then add `(u,v), (v,w), (w,u)`. This requires `n >= 6` (3 edge components).\n     This is more complex. However, if we only have edge components, we can achieve `t=2` by combining two edge components. For example, if we have `1-2` and `3-4`. Connect `1` to `3`. Then the merged component has partitions `{1,4}` and `{2,3}`. We can add `(1,4)` or `(2,3)`. This gives `t=2`.\n     So, if `edge_components_count >= 2`, `t=2` is possible. The number of ways is `C(edge_components_count, 2) * 4`. (Choose 2 edge components, say `u-u'` and `v-v'`. There are 4 ways to connect them with the first edge (e.g., `(u,v)`, `(u,v')`, `(u',v)`, `(u',v')`). For each way, there are 2 choices for the second edge.)\n     This implies that if `isolated_vertices_count = 0` and `edge_components_count >= 2`, then `t=2` is possible.\n     Example: `n=4, m=2`, edges `1-2, 3-4`. `isolated_vertices_count=0, edge_components_count=2`.\n     `t=2`. `w = C(2,2) * 4 = 1 * 4 = 4`.\n     The 4 ways:\n     1. Add `(1,3)` and `(1,4)`. Cycle `1-3-4-1`.\n     2. Add `(1,3)` and `(2,3)`. Cycle `1-3-2-1`.\n     3. Add `(2,4)` and `(1,4)`. Cycle `2-4-1-2`.\n     4. Add `(2,4)` and `(2,3)`. Cycle `2-4-3-2`.\n     (Note: The example output for `n=4, m=4` (1-2, 1-3, 4-2, 4-3) is `1 2`. This graph is bipartite. `1` color 0, `2` color 1, `3` color 1, `4` color 0. Component `{1,2,3,4}`. `cnt0=2` (`1,4`), `cnt1=2` (`2,3`). `sum_sq_cnt0 = C(2,2)=1`. `sum_sq_cnt1 = C(2,2)=1`. Total `w=2`. So `t=1, w=2`. This matches.)\n\nThe only remaining case for `t=3` is when `n < 3` (which is not possible for a cycle of length > 1) or `isolated_vertices_count > 0` and `edge_components_count = 0` (which is handled by `C(n,3)`) or `isolated_vertices_count = 0` and `edge_components_count = 0` (which means `n=0`, not possible).\nActually, if `edge_components_count < 2` (i.e., `edge_components_count` is 0 or 1), AND `isolated_vertices_count = 0`, then `n` is 0 or 2. If `n=2` and `m=1` (`1-2`), then `t=0` (no odd cycle possible). If `n=2, m=0`, then `t=0`.\nSo, `t=3` is only possible if all components are isolated vertices and `n >= 3`.\n\nRevised logic for `t=2` and `t=3`:\nIf `t=1` is not possible:\n  If `isolated_vertices_count > 0` and `edge_components_count > 0`:\n    `t = 2`. `w = isolated_vertices_count * edge_components_count`.\n    Print `2 w` and exit.\n  Else if `isolated_vertices_count >= 3` and `edge_components_count == 0`:\n    `t = 3`. `w = n * (n-1) * (n-2) // 6`. (This is `C(n,3)`)\n    Print `3 w` and exit.\n  Else if `edge_components_count >= 2` and `isolated_vertices_count == 0`:\n    `t = 2`. `w = edge_components_count * (edge_components_count - 1) // 2 * 4`. (This is `C(edge_components_count, 2) * 4`)\n    Print `2 w` and exit.\n  Else: (This covers cases like `n=0,1,2` or `n=3, m=1` (1-2, 3), where `isolated_vertices_count=1`, `edge_components_count=1`. This is covered by `isolated_vertices_count > 0` and `edge_components_count > 0` above.)\n    This else branch should not be reached if `n >= 3`. If `n < 3`, no cycle possible.\n    The problem statement implies `n` is large enough to form an odd cycle.\n\nLet's trace `n=3, m=0` (example `3 0 -> 3 1`):\nInitial graph: `1, 2, 3`.\n2-coloring: `color[1]=0, color[2]=0, color[3]=0`. All visited. No odd cycle.\n`comp_data = [(1,0), (1,0), (1,0)]`. (Each component has 1 vertex of color 0, 0 of color 1)\n`sum_sq_cnt0 = (1*(0)/2) * 3 = 0`. `sum_sq_cnt1 = 0`.\n`t=1` not possible.\n`isolated_vertices_count = 3`. `edge_components_count = 0`.\n`isolated_vertices_count > 0` and `edge_components_count = 0`.\n`isolated_vertices_count >= 3` is true.\n`t=3`. `w = 3 * 2 * 1 // 6 = 1`.\nPrint `3 1`. Matches example.\n\nFinal algorithm:\n1. Initialize `adj` list, `color` array (-1), `visited` array (False).\n2. `odd_cycle_found = False`.\n3. `components_data = []` (list of `(cnt0, cnt1)` for each component).\n4. For `i` from 1 to `n`:\n   If `not visited[i]`:\n     `cnt0 = 0`, `cnt1 = 0`.\n     `q = deque([i])`, `color[i] = 0`, `visited[i] = True`.\n     `cnt0 += 1`.\n     While `q` is not empty:\n       `u = q.popleft()`.\n       For `v` in `adj[u]`:\n         If `not visited[v]`:\n           `visited[v] = True`.\n           `color[v] = 1 - color[u]`.\n           If `color[v] == 0`: `cnt0 += 1`. Else: `cnt1 += 1`.\n           `q.append(v)`.\n         Else if `color[v] == color[u]`:\n           `odd_cycle_found = True`.\n           Break (from inner loop).\n     If `odd_cycle_found`: Break (from outer loop).\n     `components_data.append((cnt0, cnt1))`.\n\n5. If `odd_cycle_found`:\n   Print `0 1`.\n   Exit.\n\n6. Calculate `t` and `w` based on `components_data`:\n   `sum_sq_cnt0 = 0`, `sum_sq_cnt1 = 0`.\n   `isolated_vertices_count = 0`.\n   `edge_components_count = 0`.\n\n   For `(c0, c1)` in `components_data`:\n     `sum_sq_cnt0 += c0 * (c0 - 1) // 2`.\n     `sum_sq_cnt1 += c1 * (c1 - 1) // 2`.\n     If `c0 == 1` and `c1 == 0`: `isolated_vertices_count += 1`.\n     If `c0 == 0` and `c1 == 1`: `isolated_vertices_count += 1`.\n     If `c0 == 1` and `c1 == 1`: `edge_components_count += 1`.\n\n   If `sum_sq_cnt0 + sum_sq_cnt1 > 0`:\n     Print `1` `(sum_sq_cnt0 + sum_sq_cnt1)`.\n   Else if `isolated_vertices_count > 0` and `edge_components_count > 0`:\n     Print `2` `(isolated_vertices_count * edge_components_count)`.\n   Else if `edge_components_count >= 2`:\n     Print `2` `(edge_components_count * (edge_components_count - 1) // 2 * 4)`.\n   Else: // Only isolated vertices remain, or no vertices, or 1 isolated vertex, or 1 edge component\n     // The only case where we need 3 edges is if all components are isolated vertices and n >= 3.\n     // Other cases like n=0,1,2 cannot form an odd cycle.\n     // For example, n=1: components_data = [(1,0)], isolated_vertices_count=1, edge_components_count=0.\n     // `isolated_vertices_count >= 3` is false.\n     // This means we only reach here if `n < 3` or `n=3, m=1` (1-2,3) type case.\n     // But `n=3, m=1` is `isolated_vertices_count=1, edge_components_count=1`, which is covered by `t=2` case.\n     // So this else branch is only for `n < 3` or `n=3` where `m=0`.\n     // The problem statement guarantees `n` is large enough to form a cycle.\n     // The only remaining case is `isolated_vertices_count >= 3` and `edge_components_count == 0`\n     // (which is equivalent to `n >= 3` and `m=0`).\n     Print `3` `(n * (n - 1) * (n - 2) // 6)`.\n\nThis logic covers all cases and aligns with the examples.\n\n```python\nimport sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n\n    color = [-1] * (n + 1) # -1: uncolored, 0: color 0, 1: color 1\n    visited = [False] * (n + 1)\n    \n    odd_cycle_found = False\n    components_data = [] # List of (cnt0, cnt1) for each component\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            current_cnt0 = 0\n            current_cnt1 = 0\n            \n            q = deque()\n            q.append(i)\n            color[i] = 0\n            visited[i] = True\n            current_cnt0 += 1\n            \n            component_bipartite = True\n\n            head = 0\n            while head < len(q): # Manual queue for slightly better performance than deque.popleft() on large N\n                u = q[head]\n                head += 1\n\n                for v in adj[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        color[v] = 1 - color[u]\n                        if color[v] == 0:\n                            current_cnt0 += 1\n                        else:\n                            current_cnt1 += 1\n                        q.append(v)\n                    elif color[v] == color[u]:\n                        odd_cycle_found = True\n                        component_bipartite = False\n                        break\n                if not component_bipartite:\n                    break\n            \n            if odd_cycle_found:\n                break\n            \n            components_data.append((current_cnt0, current_cnt1))\n\n    if odd_cycle_found:\n        print(\"0 1\")\n        return\n\n    # If we are here, the graph is bipartite.\n    # Calculate counts for t=1, t=2, t=3\n\n    sum_sq_cnt0 = 0\n    sum_sq_cnt1 = 0\n    \n    isolated_vertices_count = 0\n    edge_components_count = 0 # Components that are single edges (2 vertices)\n\n    for c0, c1 in components_data:\n        sum_sq_cnt0 += c0 * (c0 - 1) // 2\n        sum_sq_cnt1 += c1 * (c1 - 1) // 2\n        \n        if (c0 == 1 and c1 == 0) or (c0 == 0 and c1 == 1):\n            isolated_vertices_count += 1\n        elif c0 == 1 and c1 == 1:\n            edge_components_count += 1\n\n    # Case t=1: Add one edge within a component between same-colored vertices.\n    if sum_sq_cnt0 + sum_sq_cnt1 > 0:\n        print(1, sum_sq_cnt0 + sum_sq_cnt1)\n        return\n\n    # Case t=2: If t=1 is not possible, all components are isolated vertices or single edges.\n    # Option 1: Connect an isolated vertex to a single-edge component to form a triangle.\n    if isolated_vertices_count > 0 and edge_components_count > 0:\n        # Choose 1 isolated vertex (isolated_vertices_count ways)\n        # Choose 1 edge component (edge_components_count ways)\n        # Connect the isolated vertex to both ends of the edge component.\n        # This forms a triangle (odd cycle of length 3).\n        # Example: isolated vertex u, edge v-w. Add (u,v) and (u,w).\n        print(2, isolated_vertices_count * edge_components_count)\n        return\n    \n    # Option 2: Connect two single-edge components.\n    # This happens if there are no isolated vertices or isolated_vertices_count < 3.\n    # If isolated_vertices_count is 0, then we only have edge components.\n    # If isolated_vertices_count is 1 or 2, and edge_components_count is 0,\n    # then n is 1 or 2, which cannot form an odd cycle.\n    # So if isolated_vertices_count is 0, and edge_components_count >= 2, we can do this.\n    if edge_components_count >= 2:\n        # Choose 2 edge components (C(edge_components_count, 2) ways)\n        # For each pair of components (u-u') and (v-v'), there are 4 ways to pick the first edge\n        # (u,v), (u,v'), (u',v), (u',v').\n        # After adding one edge (e.g., (u,v)), the merged component has 4 vertices.\n        # The partitions would be ({u,v'}, {u',v}) if u and v were color 0.\n        # We can add an edge between u and v' or u' and v. So 2 ways for the second edge.\n        # Total ways = C(edge_components_count, 2) * 4\n        print(2, edge_components_count * (edge_components_count - 1) // 2 * 4)\n        return\n\n    # Case t=3: If t=1 and t=2 are not possible.\n    # This means all components are isolated vertices, and there are at least 3 of them.\n    # If isolated_vertices_count < 3, then n < 3, and no odd cycle is possible.\n    # The problem implies that a cycle can be formed.\n    # So, we must have isolated_vertices_count >= 3.\n    # Choose 3 isolated vertices (C(n, 3) ways) and form a triangle.\n    # This is equivalent to n * (n-1) * (n-2) / 6.\n    print(3, n * (n - 1) * (n - 2) // 6)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n\n    color = [-1] * (n + 1) # -1: uncolored, 0: color 0, 1: color 1\n    visited = [False] * (n + 1)\n    \n    odd_cycle_found = False\n    components_data = [] # List of (cnt0, cnt1) for each component\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            current_cnt0 = 0\n            current_cnt1 = 0\n            \n            q = deque()\n            q.append(i)\n            color[i] = 0\n            visited[i] = True\n            current_cnt0 += 1\n            \n            component_bipartite = True\n\n            head = 0\n            while head < len(q): # Manual queue for slightly better performance than deque.popleft() on large N\n                u = q[head]\n                head += 1\n\n                for v in adj[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        color[v] = 1 - color[u]\n                        if color[v] == 0:\n                            current_cnt0 += 1\n                        else:\n                            current_cnt1 += 1\n                        q.append(v)\n                    elif color[v] == color[u]:\n                        odd_cycle_found = True\n                        component_bipartite = False\n                        break\n                if not component_bipartite:\n                    break\n            \n            if odd_cycle_found:\n                break\n            \n            components_data.append((current_cnt0, current_cnt1))\n\n    if odd_cycle_found:\n        print(\"0 1\")\n        return\n\n    # If we are here, the graph is bipartite.\n    # Calculate counts for t=1, t=2, t=3\n\n    sum_sq_cnt0 = 0\n    sum_sq_cnt1 = 0\n    \n    isolated_vertices_count = 0\n    edge_components_count = 0 # Components that are single edges (2 vertices)\n\n    for c0, c1 in components_data:\n        sum_sq_cnt0 += c0 * (c0 - 1) // 2\n        sum_sq_cnt1 += c1 * (c1 - 1) // 2\n        \n        if (c0 == 1 and c1 == 0) or (c0 == 0 and c1 == 1):\n            isolated_vertices_count += 1\n        elif c0 == 1 and c1 == 1:\n            edge_components_count += 1\n\n    # Case t=1: Add one edge within a component between same-colored vertices.\n    if sum_sq_cnt0 + sum_sq_cnt1 > 0:\n        print(1, sum_sq_cnt0 + sum_sq_cnt1)\n        return\n\n    # Case t=2: If t=1 is not possible, all components are isolated vertices or single edges.\n    # Option 1: Connect an isolated vertex to a single-edge component to form a triangle.\n    if isolated_vertices_count > 0 and edge_components_count > 0:\n        # Choose 1 isolated vertex (isolated_vertices_count ways)\n        # Choose 1 edge component (edge_components_count ways)\n        # Connect the isolated vertex to both ends of the edge component.\n        # This forms a triangle (odd cycle of length 3).\n        # Example: isolated vertex u, edge v-w. Add (u,v) and (u,w).\n        print(2, isolated_vertices_count * edge_components_count)\n        return\n    \n    # Option 2: Connect two single-edge components.\n    # This happens if there are no isolated vertices or isolated_vertices_count < 3.\n    # If isolated_vertices_count is 0, then we only have edge components.\n    # If isolated_vertices_count is 1 or 2, and edge_components_count is 0,\n    # then n is 1 or 2, which cannot form an odd cycle.\n    # So if isolated_vertices_count is 0, and edge_components_count >= 2, we can do this.\n    if edge_components_count >= 2:\n        # Choose 2 edge components (C(edge_components_count, 2) ways)\n        # For each pair of components (u-u') and (v-v'), there are 4 ways to pick the first edge\n        # (u,v), (u,v'), (u',v), (u',v').\n        # After adding one edge (e.g., (u,v)), the merged component has 4 vertices.\n        # The partitions would be ({u,v'}, {u',v}) if u and v were color 0.\n        # We can add an edge between u and v' or u' and v. So 2 ways for the second edge.\n        # Total ways = C(edge_components_count, 2) * 4\n        print(2, edge_components_count * (edge_components_count - 1) // 2 * 4)\n        return\n\n    # Case t=3: If t=1 and t=2 are not possible.\n    # This means all components are isolated vertices, and there are at least 3 of them.\n    # If isolated_vertices_count < 3, then n < 3, and no odd cycle is possible.\n    # The problem implies that a cycle can be formed.\n    # So, we must have isolated_vertices_count >= 3.\n    # Choose 3 isolated vertices (C(n, 3) ways) and form a triangle.\n    # This is equivalent to n * (n-1) * (n-2) / 6.\n    print(3, n * (n - 1) * (n - 2) // 6)\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 603,
        "completion_token_count": 5388,
        "thoughts_token_count": 8172
    }
}