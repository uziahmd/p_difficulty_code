{
    "start": 1758294863.4443953,
    "end": 1758294967.338958,
    "start-formatted": "2025-09-20 00:14 KST",
    "end-formatted": "2025-09-20 00:16 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "**Alright, let's break down this \"Mushroom Strife\" problem. My goal is to craft a Python script to find valid mushroom counts for each lawn, or tell the user it's impossible.**\n\nThe core is analyzing the relationship between the number of mushrooms on connected lawns, given their GCD and LCM. I realize the key insight: `x_u * x_v = gcd(x_u, x_v) * lcm(x_u, x_v)`.  This helps derive the relationship `a' * b' = l / g` where `l` is the LCM, `g` is the GCD, and `a'` and `b'` are coprime.  The most important check is that `l` *must* be divisible by `g`; if not, we can stop right there, no solution exists.\n\nThe problem screams \"graph,\" with the lawns as vertices and roads as edges enforcing constraints.  Prime factorization comes in handy because the numbers are within a range. By considering prime factors separately, I can simplify things.  For each prime `p`, the exponents in the prime factorizations must satisfy constraints related to the GCD and LCM exponents.  `min(e_u, e_v) = g_p` and `max(e_u, e_v) = l_p` for exponents `e_u` and `e_v`.  This means for each prime, exponents are fixed or there are two choices `g_p, l_p`.\n\nTo make the prime factorization efficient, I'll precompute a sieve of Eratosthenes to get the smallest prime factor for each number. This allows fast factorization. I'll precalculate this Sieve at the beginning.\n\nNow, processing a single prime factor is the focus. This becomes a graph coloring type of thing! Each prime factor implies a graph where edges are constraints (either `e_u = e_v` if g=l, otherwise  `e_u != e_v`) We'll use DSU or BFS/DFS for the 2-coloring process to determine exponents of primes for each lawn. If a contradiction arises (e.g., both exponents set to the same value on a differential edge), it's \"NO\".\n\nThe strategy:\n\n1.  Sieve all prime factors up to 10^6\n2.  Read the edges. If `LCM % GCD != 0`, exit \"NO\"\n3.  Iterate through unique prime factors in any GCD or LCM.\n4.  For each prime:\n    *   Build graph and apply constaints such as `e_u = g`\n    *   Find a connected component and use either DSU or BFS to propagate\n    *   If no consistent assignment is found, stop and report \"NO\"\n5. Construct x values by taking the exponents for each prime and raising it to its power and multiply it to x[i]\n6.  Finally, perform a final check using the original constraints.\n7. Output the answer\n\nI'm thinking to optimize processing only the *relevant* primes (primes that actually appear as factors in the input GCDs/LCMs). This will limit the graph iterations.  I'll store prime factors for each number and use the data-structure for efficient lookups.\n\nThe complexity is a bit tricky, but with optimized prime factor processing, BFS traversal and precomputing prime factors the solution should be fast enough.\nThe approach seems solid, and I'm confident in my ability to translate these ideas into working Python code.\n",
    "response": "The problem asks us to restore the number of mushrooms `x_i` on `n` lawns, given `m` roads. Each road `(u, v)` specifies `gcd(x_u, x_v)` and `lcm(x_u, x_v)`.\n\n**Key Property of GCD and LCM:**\nFor any two positive integers `a` and `b`, `gcd(a, b) * lcm(a, b) = a * b`.\nAlso, `a` and `b` must be multiples of `gcd(a, b)`.\nLet `g = gcd(x_u, x_v)` and `l = lcm(x_u, x_v)`.\nA fundamental requirement is that `l` must be divisible by `g`. If `l % g != 0` for any edge, no solution exists.\n\n**Prime Factorization Approach:**\nThe problem can be decomposed by considering each prime factor independently.\nLet `exp(k, p)` denote the exponent of prime `p` in the prime factorization of `k`.\nFor an edge `(u, v)` with `GCD=G` and `LCM=L`, and for any prime `p`:\n1.  `min(exp(x_u, p), exp(x_v, p)) = exp(G, p)`\n2.  `max(exp(x_u, p), exp(x_v, p)) = exp(L, p)`\n\nThese two conditions together imply that the set of exponents `{exp(x_u, p), exp(x_v, p)}` must be equal to `{exp(G, p), exp(L, p)}`. This means `exp(G, p)` must be less than or equal to `exp(L, p)`. If `exp(G, p) > exp(L, p)` for any `p`, it's a contradiction (this is covered by the `L % G != 0` check for the whole numbers).\n\n**Algorithm Outline:**\n\n1.  **Precomputation (Sieve):** Since numbers can go up to `10^6`, we precompute the smallest prime factor (SPF) for all numbers up to `10^6` using a sieve. This allows efficient prime factorization.\n\n2.  **Store Edges and Prime Factors:**\n    *   Read `n` and `m`.\n    *   Store all `m` edges `(u, v, G, L)`. Adjust `u, v` to be 0-indexed.\n    *   For each edge, check if `L % G != 0`. If not, print \"NO\" and exit.\n    *   Create a dictionary `all_factors` to store prime factorizations for all unique `G` and `L` values encountered. Example: `all_factors[K] = {p1: e1, p2: e2, ...}`.\n    *   Collect all unique prime factors from these `G` and `L` values into a set `all_primes_in_input`.\n\n3.  **Initialize `ans_x`:** Create an array `ans_x` of size `n`, initialized with `1`s. This array will store the final mushroom counts.\n\n4.  **Process by Prime:** Iterate through each `p` in `all_primes_in_input`:\n    *   **`current_e` array:** Initialize `current_e[0...n-1]` to `-1` (representing an undetermined exponent for prime `p`).\n    *   **Adjacency Lists for Constraints:**\n        *   `forced_val_adj[u]` will store pairs `(v, val)` for edges `(u, v)` where `exp(G, p) == exp(L, p) == val`. This means `exp(x_u, p)` and `exp(x_v, p)` must both be `val`.\n        *   `diff_val_adj[u]` will store tuples `(v, g_p_edge, l_p_edge)` for edges `(u, v)` where `exp(G, p) < exp(L, p)`. This means `{exp(x_u, p), exp(x_v, p)} = {g_p_edge, l_p_edge}`.\n\n    *   **Phase 1: Process `g_p == l_p` constraints:**\n        *   Use a BFS queue. For each `u` from `0` to `n-1`: if `current_e[u]` is still `-1`, process its `forced_val_adj` neighbors. If an edge `(u, v)` forces `exp(x_u, p)` to `val`, set `current_e[u] = val` and add `u` to the queue.\n        *   While the queue is not empty, dequeue `u`. For each `(v, val)` in `forced_val_adj[u]`:\n            *   If `current_e[v]` is `-1`, set `current_e[v] = val` and enqueue `v`.\n            *   If `current_e[v]` is already set but `current_e[v] != val`, then there's a contradiction. Print \"NO\" and exit.\n\n    *   **Phase 2: Process `g_p < l_p` constraints (2-coloring):**\n        *   For each `u` from `0` to `n-1`:\n            *   If `current_e[u]` is still `-1` (meaning `u` hasn't been assigned an exponent for `p` yet):\n                *   Start a new BFS component. Enqueue `u` and arbitrarily assign `current_e[u] = g_p_default` (e.g., the `g_p` from the first `diff_val_adj` edge involving `u`).\n                *   While the queue is not empty, dequeue `curr_u`.\n                *   For each `(v, g_p_edge, l_p_edge)` in `diff_val_adj[curr_u]`:\n                    *   Determine the required exponent for `v`: if `current_e[curr_u] == g_p_edge`, then `exp(x_v, p)` must be `l_p_edge`. Otherwise (`current_e[curr_u] == l_p_edge`), `exp(x_v, p)` must be `g_p_edge`. If `current_e[curr_u]` is neither `g_p_edge` nor `l_p_edge`, it's a contradiction. Print \"NO\" and exit.\n                    *   If `current_e[v]` is `-1`, set `current_e[v]` to the required exponent and enqueue `v`.\n                    *   If `current_e[v]` is already set but `current_e[v]` is not the required exponent, contradiction. Print \"NO\" and exit.\n            *   If `current_e[u]` is already set, iterate through its `diff_val_adj` neighbors `(v, g_p_edge, l_p_edge)` to ensure consistency. If `current_e[u]` is inconsistent with any `(g_p_edge, l_p_edge)` pair for an edge, or if `current_e[v]` is inconsistent with `current_e[u]` via the edge constraint, print \"NO\" and exit.\n\n    *   **Apply Exponents:** For each `i` from `0` to `n-1`:\n        *   If `current_e[i]` is not `-1`, multiply `ans_x[i]` by `p ** current_e[i]`.\n        *   If `current_e[i]` is still `-1`, it means `i` was not involved in any constraints for prime `p`. We can safely assume `exp(x_i, p) = 0`, so `ans_x[i]` remains unchanged (as it was initialized to `1`).\n\n5.  **Final Output:**\n    *   If all prime processing completes without contradiction, print \"YES\".\n    *   Then print the `n` numbers in `ans_x`.\n\n**Helper Functions:**\n\n*   `sieve()`: Computes `spf` array.\n*   `get_prime_factorization(num)`: Uses `spf` to factorize `num` and return a dictionary of prime factors and their exponents.\n*   `gcd(a, b)`: Standard GCD function.\n*   `lcm(a, b)`: Computes `(a * b) // gcd(a, b)`.\n\n**Complexity Analysis:**\n*   Sieve: `O(MAX_VAL log log MAX_VAL)`.\n*   Prime Factorization of G, L values: `O(M * log MAX_VAL)` in total.\n*   Iterating through `all_primes_in_input`: Let `P_count` be the number of unique prime factors.\n    *   For each prime `p`: The BFS-like traversals for `forced_val_adj` and `diff_val_adj` take `O(N + M)` time.\n    *   Total for primes: `O(P_count * (N + M))`.\n    *   `P_count` is at most `pi(MAX_VAL)` (number of primes up to `MAX_VAL`), but practically much smaller. For `MAX_VAL = 10^6` and `M = 10^5`, `P_count` is usually around a few thousands.\n    *   `1000 * (10^5 + 10^5) = 2 * 10^8`, which is on the edge for a 1-2 second time limit, but often passes due to sparse graphs and smaller actual `P_count`.\n\n**Example:**\nConsider `n=2, m=1`, edge `(1, 2, 1, 3)`.\n`x_1, x_2`. `gcd(x_1, x_2) = 1`, `lcm(x_1, x_2) = 3`.\n`L % G == 3 % 1 == 0`. Ok.\nPrime factors of `G=1` is `{}`. Prime factors of `L=3` is `{3: 1}`.\n`all_primes_in_input = {3}`.\nProcessing prime `p=3`:\n  `exp(G, 3) = 0`, `exp(L, 3) = 1`.\n  `g_p = 0`, `l_p = 1`. This is a `g_p < l_p` case.\n  `diff_val_adj[0].append((1, 0, 1))`, `diff_val_adj[1].append((0, 0, 1))`.\n  `current_e = [-1, -1]`.\n  Start BFS from `u=0`. Set `current_e[0] = 0` (arbitrarily pick `g_p`). Queue `[0]`.\n  Dequeue `0`. For edge `(0, 1)`: `g_p_edge=0, l_p_edge=1`.\n    `current_e[0] = 0`, which is `g_p_edge`. So `current_e[1]` must be `l_p_edge = 1`.\n    Set `current_e[1] = 1`. Enqueue `1`.\n  Dequeue `1`. No unvisited neighbors.\n  Final `current_e = [0, 1]`.\nApply exponents:\n  `ans_x[0] *= (3 ** current_e[0]) = 3^0 = 1`.\n  `ans_x[1] *= (3 ** current_e[1]) = 3^1 = 3`.\nResult: `ans_x = [1, 3]`. Output \"YES\\n1 3\". This matches the example.\n\n```python\nimport sys\nfrom collections import deque\n\n# Set recursion limit for potentially deep DFS (though BFS is used here)\nsys.setrecursionlimit(10**6)\n\nMAX_VAL = 10**6\nspf = [0] * (MAX_VAL + 1) # smallest prime factor\nprimes = []\n\ndef sieve():\n    for i in range(2, MAX_VAL + 1):\n        if spf[i] == 0: # i is prime\n            spf[i] = i\n            primes.append(i)\n        for p in primes:\n            if p > spf[i] or i * p > MAX_VAL:\n                break\n            spf[i * p] = p\n\ndef get_prime_factorization(num):\n    factors = {}\n    temp_num = num\n    while temp_num > 1:\n        p = spf[temp_num]\n        count = 0\n        while temp_num % p == 0:\n            count += 1\n            temp_num //= p\n        factors[p] = count\n    return factors\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    if a == 0 or b == 0:\n        return 0\n    return (a * b) // gcd(a, b)\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    edges = []\n    all_factors = {} # Stores precomputed prime factorizations for G and L values\n    all_primes_in_input = set()\n\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        u -= 1 # 0-indexed\n        v -= 1 # 0-indexed\n\n        if l % g != 0:\n            sys.stdout.write(\"NO\\n\")\n            return\n\n        edges.append((u, v, g, l))\n\n        # Precompute prime factorizations for G and L\n        if g not in all_factors:\n            all_factors[g] = get_prime_factorization(g)\n            all_primes_in_input.update(all_factors[g].keys())\n        if l not in all_factors:\n            all_factors[l] = get_prime_factorization(l)\n            all_primes_in_input.update(all_factors[l].keys())\n\n    ans_x = [1] * n\n\n    # Process each relevant prime factor\n    for p in all_primes_in_input:\n        current_e = [-1] * n # Exponent of prime p for each lawn, -1 means undetermined\n\n        # Adjacency lists for this prime p\n        # forced_val_adj[u] = [(v, val), ...] means exp(x_u, p) == exp(x_v, p) == val\n        forced_val_adj = [[] for _ in range(n)]\n        # diff_val_adj[u] = [(v, g_p_edge, l_p_edge), ...] means {exp(x_u, p), exp(x_v, p)} = {g_p_edge, l_p_edge}\n        diff_val_adj = [[] for _ in range(n)]\n\n        for u, v, g, l in edges:\n            g_p = all_factors[g].get(p, 0)\n            l_p = all_factors[l].get(p, 0)\n\n            if g_p == l_p:\n                forced_val_adj[u].append((v, g_p))\n                forced_val_adj[v].append((u, g_p))\n            else: # g_p < l_p\n                diff_val_adj[u].append((v, g_p, l_p))\n                diff_val_adj[v].append((u, g_p, l_p))\n        \n        q = deque()\n\n        # Phase 1: Process fixed exponent constraints (g_p == l_p)\n        for i in range(n):\n            if current_e[i] == -1:\n                # If a node has a fixed constraint, but its own value isn't set yet\n                # We can pick one of its fixed neighbors to set its value\n                for neighbor_v, fixed_val in forced_val_adj[i]:\n                    if current_e[i] == -1: # Only set if it's still undetermined\n                        current_e[i] = fixed_val\n                        q.append(i)\n                        break # Only need to pick one to start propagation\n                    elif current_e[i] != fixed_val:\n                        sys.stdout.write(\"NO\\n\")\n                        return\n\n        while q:\n            u = q.popleft()\n            for v, val in forced_val_adj[u]:\n                if current_e[v] == -1:\n                    current_e[v] = val\n                    q.append(v)\n                elif current_e[v] != val:\n                    sys.stdout.write(\"NO\\n\")\n                    return\n        \n        # Phase 2: Process differential exponent constraints (g_p < l_p)\n        # This is a 2-coloring problem on connected components\n        for i in range(n):\n            if current_e[i] == -1: # Start BFS for a new component\n                # Find the first diff_val_adj edge for this component to get g_p and l_p\n                # If there are no diff_val_adj edges, then this node is isolated for this prime,\n                # its exponent can be 0.\n                if not diff_val_adj[i]:\n                    current_e[i] = 0 # Default to 0 if no constraints for this prime\n                    continue\n                \n                # Pick an arbitrary starting assignment for the component\n                # For example, assign g_p to the first node encountered\n                # The actual g_p and l_p for the edge are stored in diff_val_adj\n                \n                # We need to find *an* edge to get the g_p and l_p for the component\n                # It's better to pick the g_p/l_p from the first edge encountered during BFS\n                \n                # BFS for 2-coloring\n                q.append(i)\n                # For the first node in a component, we can arbitrarily assign one of the two values\n                # However, it must be consistent with *its* edge constraints.\n                # Let's use a dummy value for now and fix it when processing edges.\n                # A safer approach is to assign 0 if no constraints, or pick based on the first edge.\n                \n                # If there are diff_val_adj edges, the values must be g_p_edge or l_p_edge.\n                # We'll use the values from the first edge for 'i' to determine its initial assignment.\n                # If 'i' has multiple diff_val_adj edges, we need to pick one consistent pair.\n                \n                # A better way for 2-coloring: assign first node to 'color 0', second to 'color 1'\n                # then map color 0 to g_p and color 1 to l_p.\n                \n                # We can use a map from component_id to (g_p, l_p) for the component\n                # But g_p and l_p can be different for different edges!\n                # This is the tricky part. The solution for each prime is not a simple 2-coloring.\n                # It's more like, for each edge (u,v), {exp(u), exp(v)} = {g_p_edge, l_p_edge}.\n                # This implies exp(u) != exp(v) if g_p_edge != l_p_edge.\n                # So we can assign exp(u) = g_p_edge and exp(v) = l_p_edge or vice versa.\n\n                # Let's re-evaluate Phase 2:\n                # If current_e[i] is -1, start a BFS.\n                # For each node 'u' in the component, we want to assign current_e[u].\n                # When processing an edge (u,v) with (g_p_edge, l_p_edge):\n                # If current_e[u] is known:\n                #   If current_e[u] == g_p_edge, then current_e[v] must be l_p_edge.\n                #   If current_e[u] == l_p_edge, then current_e[v] must be g_p_edge.\n                #   If current_e[u] is neither, then contradiction.\n                #   Propagate this to v.\n                # If current_e[u] is unknown, and we start BFS from 'u':\n                #   We can assign current_e[u] = g_p_edge (arbitrarily) for the first edge (u,v) we see.\n                #   Then current_e[v] must be l_p_edge.\n                #   This needs to be consistent across all edges incident to 'u'.\n\n                # This is still a 2-coloring problem, but with specific values.\n                # Let's use a standard BFS for 2-coloring.\n                # `colors` array: 0 or 1 for two groups.\n                # `component_g_p`, `component_l_p` to store the actual values for the two groups.\n                \n                # For this specific component, we need to pick one edge (u,v) from diff_val_adj\n                # to determine the two possible values for exponents.\n                # All edges in the same component must share the same (g_p, l_p) pair.\n                # This is a critical assumption. Let's check:\n                # If edge (u,v) has (0,1) and edge (v,w) has (0,2), then\n                # {e_u, e_v} = {0,1} and {e_v, e_w} = {0,2}.\n                # If e_v=0, then e_u=1 and e_w=2. This is fine.\n                # If e_v=1, then e_u=0. But e_v=1 is not in {0,2}, so this is impossible.\n                # This implies that for a connected component in `diff_val_adj`,\n                # all edges must have the SAME `(g_p_edge, l_p_edge)` pair.\n                # If not, then it's a \"NO\".\n\n                # Let's verify this assumption.\n                # Suppose for a connected component, there are two edges:\n                # (A, B) with (g1, l1)\n                # (B, C) with (g2, l2)\n                # If g1 != g2 or l1 != l2, then it's possible no solution exists.\n                # E.g., {eA, eB} = {g1, l1} and {eB, eC} = {g2, l2}.\n                # If eB = g1, then eA = l1. And eB = g1 must be either g2 or l2.\n                # If eB = l1, then eA = g1. And eB = l1 must be either g2 or l2.\n                # This means each node `v` must have `current_e[v]` equal to either `g_p_edge` or `l_p_edge`\n                # for *every* incident `diff_val_adj` edge `(u,v)`.\n                # This is a stronger condition.\n\n                # Let's simplify Phase 2:\n                # We use BFS. For each node `i` not yet fixed:\n                #   Initialize `current_e[i]` to `0` (default for `g_p`, or 0 if no constraints).\n                #   Add `i` to queue.\n                #   While queue not empty:\n                #     `u = q.popleft()`\n                #     For `(v, g_p_edge, l_p_edge)` in `diff_val_adj[u]`:\n                #       # current_e[u] must be one of g_p_edge or l_p_edge\n                #       if current_e[u] != g_p_edge and current_e[u] != l_p_edge:\n                #           sys.stdout.write(\"NO\\n\"); return\n                #       \n                #       target_e_v = l_p_edge if current_e[u] == g_p_edge else g_p_edge\n                #       \n                #       if current_e[v] == -1:\n                #           current_e[v] = target_e_v\n                #           q.append(v)\n                #       elif current_e[v] != target_e_v:\n                #           sys.stdout.write(\"NO\\n\"); return\n                # This approach needs to be careful about initial assignment for components.\n                # If `current_e[i]` is -1, it means it was not fixed by Phase 1.\n                # Its value for `p` could be 0, or `g_p_edge` or `l_p_edge` from an incident edge.\n                # If it has no `diff_val_adj` edges, it has no constraints for `p`, so `exp(x_i, p)` can be 0.\n                # If it has `diff_val_adj` edges, we must pick one of the two values.\n                # Let's try assigning `g_p_edge` from the first incident `diff_val_adj` edge.\n\n                # Simplified Phase 2:\n                # Iterate `i` from 0 to n-1.\n                # If `current_e[i]` is -1:\n                #   If `diff_val_adj[i]` is empty:\n                #     `current_e[i] = 0` (no constraints on this prime, so exponent 0 is safe)\n                #     continue\n                #   \n                #   # Start a BFS component. Arbitrarily assign `i` to one of the two values\n                #   # for its first diff_val_adj neighbor.\n                #   first_neighbor_v, first_g_p, first_l_p = diff_val_adj[i][0]\n                #   current_e[i] = first_g_p # Arbitrary choice\n                #   q.append(i)\n                #   \n                #   while q:\n                #     u = q.popleft()\n                #     for v, g_p_edge, l_p_edge in diff_val_adj[u]:\n                #       # Check consistency of current_e[u] with this edge's constraints\n                #       if current_e[u] != g_p_edge and current_e[u] != l_p_edge:\n                #         sys.stdout.write(\"NO\\n\"); return\n                #       \n                #       target_e_v = l_p_edge if current_e[u] == g_p_edge else g_p_edge\n                #       \n                #       if current_e[v] == -1:\n                #         current_e[v] = target_e_v\n                #         q.append(v)\n                #       elif current_e[v] != target_e_v:\n                #         sys.stdout.write(\"NO\\n\"); return\n                # Else (`current_e[i]` is already fixed by Phase 1):\n                #   # Check consistency with diff_val_adj neighbors\n                #   u = i\n                #   for v, g_p_edge, l_p_edge in diff_val_adj[u]:\n                #     if current_e[u] != g_p_edge and current_e[u] != l_p_edge:\n                #       sys.stdout.write(\"NO\\n\"); return\n                #     \n                #     target_e_v = l_p_edge if current_e[u] == g_p_edge else g_p_edge\n                #     \n                #     if current_e[v] == -1:\n                #       # This means v should have been fixed by a previous BFS starting from u\n                #       # or fixed in Phase 1. If it's still -1, it's an error in logic or traversal.\n                #       # Or it could be that v is not yet processed by BFS.\n                #       # Let's just set it and add to queue for propagation.\n                #       current_e[v] = target_e_v\n                #       q.append(v) # Add to queue for further propagation\n                #     elif current_e[v] != target_e_v:\n                #       sys.stdout.write(\"NO\\n\"); return\n\n        # Refined Phase 2: Iterate through all nodes. If not assigned, start a BFS.\n        # This BFS will handle both cases (fixed and unfixed nodes) and ensure consistency.\n        for i in range(n):\n            if current_e[i] == -1:\n                # If node i is isolated for this prime (no constraints), set its exponent to 0\n                if not diff_val_adj[i] and not forced_val_adj[i]:\n                    current_e[i] = 0\n                    continue\n\n                # Start BFS for this component. Assign an arbitrary valid exponent to i.\n                # To be valid, it must be part of *some* (g_p, l_p) for an incident edge.\n                # If it has diff_val_adj edges, pick one of the two values.\n                # If it only has forced_val_adj edges, it should have been fixed in Phase 1.\n                # So here, it implies diff_val_adj[i] is not empty.\n                \n                # Pick the first diff_val_adj edge to determine the initial assignment\n                if diff_val_adj[i]:\n                    _, g_p_val, _ = diff_val_adj[i][0]\n                    current_e[i] = g_p_val # Arbitrarily assign g_p value to start\n                else: # Only has forced_val_adj edges, but wasn't fixed in Phase 1. This is an error in logic.\n                      # Or it means its forced_val_adj neighbors are all undetermined.\n                      # It should have been handled by the initial loop in Phase 1.\n                      # If it reaches here, it must be isolated or part of a component with only fixed values.\n                      # If it's isolated, current_e[i]=0.\n                      # If it's part of a component with only fixed values, it should have been fixed.\n                      # This case should ideally not happen if Phase 1 is thorough.\n                      # For safety, assign 0.\n                    current_e[i] = 0\n\n                q.append(i)\n\n            # BFS for consistency check and propagation\n            bfs_q = deque([i])\n            while bfs_q:\n                u = bfs_q.popleft()\n\n                # Check diff_val_adj neighbors\n                for v, g_p_edge, l_p_edge in diff_val_adj[u]:\n                    if current_e[u] != g_p_edge and current_e[u] != l_p_edge:\n                        sys.stdout.write(\"NO\\n\"); return\n                    \n                    target_e_v = l_p_edge if current_e[u] == g_p_edge else g_p_edge\n                    \n                    if current_e[v] == -1:\n                        current_e[v] = target_e_v\n                        bfs_q.append(v)\n                    elif current_e[v] != target_e_v:\n                        sys.stdout.write(\"NO\\n\"); return\n                \n                # Check forced_val_adj neighbors (for consistency with Phase 1)\n                for v, val in forced_val_adj[u]:\n                    if current_e[v] == -1:\n                        current_e[v] = val\n                        bfs_q.append(v)\n                    elif current_e[v] != val:\n                        sys.stdout.write(\"NO\\n\"); return\n\n        # Apply exponents for prime p\n        for i in range(n):\n            if current_e[i] != -1: # If exponent was determined for this prime\n                ans_x[i] *= (p ** current_e[i])\n            # If current_e[i] is still -1, it means it was completely isolated for this prime\n            # and was not part of all_primes_in_input logic, so it defaults to 1 (p^0).\n            # This case is handled by `current_e[i] = 0` for isolated nodes.\n\n    # Final verification (optional, but good for robustness)\n    for u, v, g_orig, l_orig in edges:\n        if gcd(ans_x[u], ans_x[v]) != g_orig or lcm(ans_x[u], ans_x[v]) != l_orig:\n            sys.stdout.write(\"NO\\n\")\n            return\n\n    sys.stdout.write(\"YES\\n\")\n    sys.stdout.write(\" \".join(map(str, ans_x)) + \"\\n\")\n\n# Run sieve once\nsieve()\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\n# Set recursion limit for potentially deep DFS (though BFS is used here)\nsys.setrecursionlimit(10**6)\n\nMAX_VAL = 10**6\nspf = [0] * (MAX_VAL + 1) # smallest prime factor\nprimes = []\n\ndef sieve():\n    for i in range(2, MAX_VAL + 1):\n        if spf[i] == 0: # i is prime\n            spf[i] = i\n            primes.append(i)\n        for p in primes:\n            if p > spf[i] or i * p > MAX_VAL:\n                break\n            spf[i * p] = p\n\ndef get_prime_factorization(num):\n    factors = {}\n    temp_num = num\n    while temp_num > 1:\n        p = spf[temp_num]\n        count = 0\n        while temp_num % p == 0:\n            count += 1\n            temp_num //= p\n        factors[p] = count\n    return factors\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    if a == 0 or b == 0:\n        return 0\n    return (a * b) // gcd(a, b)\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    edges = []\n    all_factors = {} # Stores precomputed prime factorizations for G and L values\n    all_primes_in_input = set()\n\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        u -= 1 # 0-indexed\n        v -= 1 # 0-indexed\n\n        if l % g != 0:\n            sys.stdout.write(\"NO\\n\")\n            return\n\n        edges.append((u, v, g, l))\n\n        # Precompute prime factorizations for G and L\n        if g not in all_factors:\n            all_factors[g] = get_prime_factorization(g)\n            all_primes_in_input.update(all_factors[g].keys())\n        if l not in all_factors:\n            all_factors[l] = get_prime_factorization(l)\n            all_primes_in_input.update(all_factors[l].keys())\n\n    ans_x = [1] * n\n\n    # Process each relevant prime factor\n    for p in all_primes_in_input:\n        current_e = [-1] * n # Exponent of prime p for each lawn, -1 means undetermined\n\n        # Adjacency lists for this prime p\n        # forced_val_adj[u] = [(v, val), ...] means exp(x_u, p) == exp(x_v, p) == val\n        forced_val_adj = [[] for _ in range(n)]\n        # diff_val_adj[u] = [(v, g_p_edge, l_p_edge), ...] means {exp(x_u, p), exp(x_v, p)} = {g_p_edge, l_p_edge}\n        diff_val_adj = [[] for _ in range(n)]\n\n        for u, v, g, l in edges:\n            g_p = all_factors[g].get(p, 0)\n            l_p = all_factors[l].get(p, 0)\n\n            if g_p == l_p:\n                forced_val_adj[u].append((v, g_p))\n                forced_val_adj[v].append((u, g_p))\n            else: # g_p < l_p\n                diff_val_adj[u].append((v, g_p, l_p))\n                diff_val_adj[v].append((u, g_p, l_p))\n        \n        q = deque()\n\n        # Phase 1: Process fixed exponent constraints (g_p == l_p)\n        for i in range(n):\n            if current_e[i] == -1:\n                # If a node has a fixed constraint, but its own value isn't set yet\n                # We can pick one of its fixed neighbors to set its value\n                for neighbor_v, fixed_val in forced_val_adj[i]:\n                    if current_e[i] == -1: # Only set if it's still undetermined\n                        current_e[i] = fixed_val\n                        q.append(i)\n                        break # Only need to pick one to start propagation\n                    elif current_e[i] != fixed_val:\n                        sys.stdout.write(\"NO\\n\")\n                        return\n\n        while q:\n            u = q.popleft()\n            for v, val in forced_val_adj[u]:\n                if current_e[v] == -1:\n                    current_e[v] = val\n                    q.append(v)\n                elif current_e[v] != val:\n                    sys.stdout.write(\"NO\\n\")\n                    return\n        \n        # Phase 2: Process differential exponent constraints (g_p < l_p)\n        # This is a 2-coloring problem on connected components\n        for i in range(n):\n            if current_e[i] == -1: # Start BFS for a new component\n                # Find the first diff_val_adj edge for this component to get g_p and l_p\n                # If there are no diff_val_adj edges, then this node is isolated for this prime,\n                # its exponent can be 0.\n                if not diff_val_adj[i]:\n                    current_e[i] = 0 # Default to 0 if no constraints for this prime\n                    continue\n                \n                # Pick an arbitrary starting assignment for the component\n                # For example, assign g_p to the first node encountered\n                # The actual g_p and l_p for the edge are stored in diff_val_adj\n                \n                # We need to find *an* edge to get the g_p and l_p for the component\n                # It's better to pick the g_p/l_p from the first edge encountered during BFS\n                \n                # BFS for 2-coloring\n                q.append(i)\n                # For the first node in a component, we can arbitrarily assign one of the two values\n                # However, it must be consistent with *its* edge constraints.\n                # Let's use a dummy value for now and fix it when processing edges.\n                # A safer approach is to assign 0 if no constraints, or pick based on the first edge.\n                \n                # If there are diff_val_adj edges, the values must be g_p_edge or l_p_edge.\n                # We'll use the values from the first edge for 'i' to determine its initial assignment.\n                # If 'i' has multiple diff_val_adj edges, we need to pick one consistent pair.\n                \n                # A better way for 2-coloring: assign first node to 'color 0', second to 'color 1'\n                # then map color 0 to g_p and color 1 to l_p.\n                \n                # We can use a map from component_id to (g_p, l_p) for the component\n                # But g_p and l_p can be different for different edges!\n                # This is the tricky part. The solution for each prime is not a simple 2-coloring.\n                # It's more like, for each edge (u,v), {exp(u), exp(v)} = {g_p_edge, l_p_edge}.\n                # This implies exp(u) != exp(v) if g_p_edge != l_p_edge.\n                # So we can assign exp(u) = g_p_edge and exp(v) = l_p_edge or vice versa.\n\n                # Let's re-evaluate Phase 2:\n                # If current_e[i] is -1, start a BFS.\n                # For each node 'u' in the component, we want to assign current_e[u].\n                # When processing an edge (u,v) with (g_p_edge, l_p_edge):\n                # If current_e[u] is known:\n                #   If current_e[u] == g_p_edge, then current_e[v] must be l_p_edge.\n                #   If current_e[u] == l_p_edge, then current_e[v] must be g_p_edge.\n                #   If current_e[u] is neither, then contradiction.\n                #   Propagate this to v.\n                # If current_e[u] is unknown, and we start BFS from 'u':\n                #   We can assign current_e[u] = g_p_edge (arbitrarily) for the first edge (u,v) we see.\n                #   Then current_e[v] must be l_p_edge.\n                #   This needs to be consistent across all edges incident to 'u'.\n\n                # This is still a 2-coloring problem, but with specific values.\n                # Let's use a standard BFS for 2-coloring.\n                # `colors` array: 0 or 1 for two groups.\n                # `component_g_p`, `component_l_p` to store the actual values for the two groups.\n                \n                # For this specific component, we need to pick one edge (u,v) from diff_val_adj\n                # to determine the two possible values for exponents.\n                # All edges in the same component must share the same (g_p, l_p) pair.\n                # This is a critical assumption. Let's check:\n                # If edge (u,v) has (0,1) and edge (v,w) has (0,2), then\n                # {e_u, e_v} = {0,1} and {e_v, e_w} = {0,2}.\n                # If e_v=0, then e_u=1 and e_w=2. This is fine.\n                # If e_v=1, then e_u=0. But e_v=1 is not in {0,2}, so this is impossible.\n                # This implies that for a connected component in `diff_val_adj`,\n                # all edges must have the SAME `(g_p_edge, l_p_edge)` pair.\n                # If not, then it's a \"NO\".\n\n                # Let's verify this assumption.\n                # Suppose for a connected component, there are two edges:\n                # (A, B) with (g1, l1)\n                # (B, C) with (g2, l2)\n                # If g1 != g2 or l1 != l2, then it's possible no solution exists.\n                # E.g., {eA, eB} = {g1, l1} and {eB, eC} = {g2, l2}.\n                # If eB = g1, then eA = l1. And eB = g1 must be either g2 or l2.\n                # If eB = l1, then eA = g1. And eB = l1 must be either g2 or l2.\n                # This means each node `v` must have `current_e[v]` equal to either `g_p_edge` or `l_p_edge`\n                # for *every* incident `diff_val_adj` edge `(u,v)`.\n                # This is a stronger condition.\n\n                # Let's simplify Phase 2:\n                # We use BFS. For each node `i` not yet fixed:\n                #   Initialize `current_e[i]` to `0` (default for `g_p`, or 0 if no constraints).\n                #   Add `i` to queue.\n                #   While queue not empty:\n                #     `u = q.popleft()`\n                #     For `(v, g_p_edge, l_p_edge)` in `diff_val_adj[u]`:\n                #       # current_e[u] must be one of g_p_edge or l_p_edge\n                #       if current_e[u] != g_p_edge and current_e[u] != l_p_edge:\n                #           sys.stdout.write(\"NO\\n\"); return\n                #       \n                #       target_e_v = l_p_edge if current_e[u] == g_p_edge else g_p_edge\n                #       \n                #       if current_e[v] == -1:\n                #           current_e[v] = target_e_v\n                #           q.append(v)\n                #       elif current_e[v] != target_e_v:\n                #           sys.stdout.write(\"NO\\n\"); return\n                # This approach needs to be careful about initial assignment for components.\n                # If `current_e[i]` is -1, it means it was not fixed by Phase 1.\n                # Its value for `p` could be 0, or `g_p_edge` or `l_p_edge` from an incident edge.\n                # If it has no `diff_val_adj` edges, it has no constraints for `p`, so `exp(x_i, p)` can be 0.\n                # If it has `diff_val_adj` edges, we must pick one of the two values.\n                # Let's try assigning `g_p_edge` from the first incident `diff_val_adj` edge.\n\n                # Simplified Phase 2:\n                # Iterate `i` from 0 to n-1.\n                # If `current_e[i]` is -1:\n                #   If `diff_val_adj[i]` is empty:\n                #     `current_e[i] = 0` (no constraints on this prime, so exponent 0 is safe)\n                #     continue\n                #   \n                #   # Start a BFS component. Arbitrarily assign `i` to one of the two values\n                #   # for its first diff_val_adj neighbor.\n                #   first_neighbor_v, first_g_p, first_l_p = diff_val_adj[i][0]\n                #   current_e[i] = first_g_p # Arbitrary choice\n                #   q.append(i)\n                #   \n                #   while q:\n                #     u = q.popleft()\n                #     for v, g_p_edge, l_p_edge in diff_val_adj[u]:\n                #       # Check consistency of current_e[u] with this edge's constraints\n                #       if current_e[u] != g_p_edge and current_e[u] != l_p_edge:\n                #         sys.stdout.write(\"NO\\n\"); return\n                #       \n                #       target_e_v = l_p_edge if current_e[u] == g_p_edge else g_p_edge\n                #       \n                #       if current_e[v] == -1:\n                #         current_e[v] = target_e_v\n                #         q.append(v)\n                #       elif current_e[v] != target_e_v:\n                #         sys.stdout.write(\"NO\\n\"); return\n                # Else (`current_e[i]` is already fixed by Phase 1):\n                #   # Check consistency with diff_val_adj neighbors\n                #   u = i\n                #   for v, g_p_edge, l_p_edge in diff_val_adj[u]:\n                #     if current_e[u] != g_p_edge and current_e[u] != l_p_edge:\n                #       sys.stdout.write(\"NO\\n\"); return\n                #     \n                #     target_e_v = l_p_edge if current_e[u] == g_p_edge else g_p_edge\n                #     \n                #     if current_e[v] == -1:\n                #       # This means v should have been fixed by a previous BFS starting from u\n                #       # or fixed in Phase 1. If it's still -1, it's an error in logic or traversal.\n                #       # Or it could be that v is not yet processed by BFS.\n                #       # Let's just set it and add to queue for propagation.\n                #       current_e[v] = target_e_v\n                #       q.append(v) # Add to queue for further propagation\n                #     elif current_e[v] != target_e_v:\n                #       sys.stdout.write(\"NO\\n\"); return\n\n        # Refined Phase 2: Iterate through all nodes. If not assigned, start a BFS.\n        # This BFS will handle both cases (fixed and unfixed nodes) and ensure consistency.\n        for i in range(n):\n            if current_e[i] == -1:\n                # If node i is isolated for this prime (no constraints), set its exponent to 0\n                if not diff_val_adj[i] and not forced_val_adj[i]:\n                    current_e[i] = 0\n                    continue\n\n                # Start BFS for this component. Assign an arbitrary valid exponent to i.\n                # To be valid, it must be part of *some* (g_p, l_p) for an incident edge.\n                # If it has diff_val_adj edges, pick one of the two values.\n                # If it only has forced_val_adj edges, it should have been fixed in Phase 1.\n                # So here, it implies diff_val_adj[i] is not empty.\n                \n                # Pick the first diff_val_adj edge to determine the initial assignment\n                if diff_val_adj[i]:\n                    _, g_p_val, _ = diff_val_adj[i][0]\n                    current_e[i] = g_p_val # Arbitrarily assign g_p value to start\n                else: # Only has forced_val_adj edges, but wasn't fixed in Phase 1. This is an error in logic.\n                      # Or it means its forced_val_adj neighbors are all undetermined.\n                      # It should have been handled by the initial loop in Phase 1.\n                      # If it reaches here, it must be isolated or part of a component with only fixed values.\n                      # If it's isolated, current_e[i]=0.\n                      # If it's part of a component with only fixed values, it should have been fixed.\n                      # This case should ideally not happen if Phase 1 is thorough.\n                      # For safety, assign 0.\n                    current_e[i] = 0\n\n                q.append(i)\n\n            # BFS for consistency check and propagation\n            bfs_q = deque([i])\n            while bfs_q:\n                u = bfs_q.popleft()\n\n                # Check diff_val_adj neighbors\n                for v, g_p_edge, l_p_edge in diff_val_adj[u]:\n                    if current_e[u] != g_p_edge and current_e[u] != l_p_edge:\n                        sys.stdout.write(\"NO\\n\"); return\n                    \n                    target_e_v = l_p_edge if current_e[u] == g_p_edge else g_p_edge\n                    \n                    if current_e[v] == -1:\n                        current_e[v] = target_e_v\n                        bfs_q.append(v)\n                    elif current_e[v] != target_e_v:\n                        sys.stdout.write(\"NO\\n\"); return\n                \n                # Check forced_val_adj neighbors (for consistency with Phase 1)\n                for v, val in forced_val_adj[u]:\n                    if current_e[v] == -1:\n                        current_e[v] = val\n                        bfs_q.append(v)\n                    elif current_e[v] != val:\n                        sys.stdout.write(\"NO\\n\"); return\n\n        # Apply exponents for prime p\n        for i in range(n):\n            if current_e[i] != -1: # If exponent was determined for this prime\n                ans_x[i] *= (p ** current_e[i])\n            # If current_e[i] is still -1, it means it was completely isolated for this prime\n            # and was not part of all_primes_in_input logic, so it defaults to 1 (p^0).\n            # This case is handled by `current_e[i] = 0` for isolated nodes.\n\n    # Final verification (optional, but good for robustness)\n    for u, v, g_orig, l_orig in edges:\n        if gcd(ans_x[u], ans_x[v]) != g_orig or lcm(ans_x[u], ans_x[v]) != l_orig:\n            sys.stdout.write(\"NO\\n\")\n            return\n\n    sys.stdout.write(\"YES\\n\")\n    sys.stdout.write(\" \".join(map(str, ans_x)) + \"\\n\")\n\n# Run sieve once\nsieve()\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 551,
        "completion_token_count": 7704,
        "thoughts_token_count": 7369
    }
}