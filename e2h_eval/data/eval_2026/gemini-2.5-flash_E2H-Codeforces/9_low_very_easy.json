{
    "start": 1758009486.3235664,
    "end": 1758009522.7958298,
    "start-formatted": "2025-09-16 16:58 KST",
    "end-formatted": "2025-09-16 16:58 KST",
    "gpu": 2,
    "pid": 9,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Selling Souvenirs\n\nAfter several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.This morning, as usual, Petya will come to the market. Petya has n different souvenirs to sell; ith souvenir is characterised by its weight wi and cost ci. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than m, and total cost is maximum possible.Help Petya to determine maximum possible total cost.\n\n## Input\nThe first line contains two integers n and m (1 ≤ n ≤ 100000, 1 ≤ m ≤ 300000) — the number of Petya's souvenirs and total weight that he can carry to the market.Then n lines follow. ith line contains two integers wi and ci (1 ≤ wi ≤ 3, 1 ≤ ci ≤ 109) — the weight and the cost of ith souvenir.\n\n## Output\nPrint one number — maximum possible total cost of souvenirs that Petya can carry to the market.\n\n## Example\n### Input\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\n### Output\n['0', '3', '10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "**The \"Selling Souvenirs\" Knapsack Conundrum**\n\nAlright, let's break this down. I need a Python script to solve this \"Selling Souvenirs\" problem, which looks like a variation of the classic knapsack problem. We have `n` souvenirs, a maximum weight `m`, and each souvenir has a weight `wi` and a cost `ci`. The goal is to maximize the total cost of the souvenirs while staying within the weight limit.\n\nThe standard knapsack approach, using dynamic programming, would be too slow with these constraints, given `n` and `m`. However, there's a key detail: the weights are tiny! They're limited to 1, 2, or 3. This changes everything.\n\nThis small weight constraint means I can categorize the souvenirs by weight and pre-sort them by cost in descending order. So I'll have `costs_w1`, `costs_w2`, and `costs_w3`, each sorted to prioritize the most valuable items.\n\nNow the core of the problem is about finding the optimal number of each weight type to pick: `k1` (weight 1), `k2` (weight 2), and `k3` (weight 3), all subject to the weight limit `m`. That translates to  `k1 * 1 + k2 * 2 + k3 * 3 <= m`.\n\nTo maximize the cost, I'll need to figure out the best combination of `k1`, `k2`, and `k3`. I think the best approach is to iterate over one of the variables, maybe `k3`. The maximum possible `k3` is `m // 3`, so I can loop through all the possible values for `k3`.\n\nFor each `k3`, calculate the cost of those souvenirs and the remaining weight to be filled by weight 1 and 2 souvenirs. The problem of filling the remaining weight with items of weight 1 and 2 is a sub-knapsack problem, which is very similar to what was originally intended. I can optimize this further later, perhaps by dynamic programming or by intelligently iterating over the possibilities.\n",
    "response": "```python\nimport sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    # Categorize souvenirs by weight and store their costs\n    costs_w1 = []\n    costs_w2 = []\n    costs_w3 = []\n\n    for _ in range(n):\n        w, c = map(int, sys.stdin.readline().split())\n        if w == 1:\n            costs_w1.append(c)\n        elif w == 2:\n            costs_w2.append(c)\n        else: # w == 3\n            costs_w3.append(c)\n\n    # Sort costs in descending order to pick the most expensive ones first\n    costs_w1.sort(reverse=True)\n    costs_w2.sort(reverse=True)\n    costs_w3.sort(reverse=True)\n\n    # Precompute prefix sums for costs to quickly get sum of top k items\n    # This avoids repeated summing in loops and makes sum operations O(1)\n    prefix_sum_w1 = [0] * (len(costs_w1) + 1)\n    for i in range(len(costs_w1)):\n        prefix_sum_w1[i+1] = prefix_sum_w1[i] + costs_w1[i]\n\n    prefix_sum_w2 = [0] * (len(costs_w2) + 1)\n    for i in range(len(costs_w2)):\n        prefix_sum_w2[i+1] = prefix_sum_w2[i] + costs_w2[i]\n    \n    prefix_sum_w3 = [0] * (len(costs_w3) + 1)\n    for i in range(len(costs_w3)):\n        prefix_sum_w3[i+1] = prefix_sum_w3[i] + costs_w3[i]\n\n    max_total_cost = 0\n\n    # Iterate over the number of items of weight 3 (k3)\n    # k3 can range from 0 up to min(len(costs_w3), m // 3)\n    for k3 in range(len(costs_w3) + 1):\n        weight_k3 = k3 * 3\n        if weight_k3 > m:\n            break # Cannot take more items of weight 3 than capacity allows\n\n        current_cost_k3 = prefix_sum_w3[k3]\n        remaining_m_after_k3 = m - weight_k3\n\n        # Now, we need to fill remaining_m_after_k3 with items of weight 1 and 2.\n        # This is a 0/1 knapsack-like problem with two item types.\n        # We can iterate over the number of items of weight 2 (k2).\n        # k2 can range from 0 up to min(len(costs_w2), remaining_m_after_k3 // 2)\n\n        # To optimize the inner loop for (k2, k1), we can use a two-pointer approach\n        # or iterate k2 and then determine k1.\n        # Let's iterate k2 and then calculate the best k1 for remaining capacity.\n        # This is essentially what the optimized solution does by precalculating\n        # the best cost for weight W using only weight 1 items, and then for weight W using\n        # weight 1 and 2 items.\n\n        # The key insight for the `dp_w1_w2` array (or similar approach) is:\n        # For a given remaining_m_after_k3, we want to find the maximum cost\n        # using weight-1 and weight-2 items.\n        # `max_cost_w1_w2[w]` stores the max cost for capacity `w` using only items of weight 1 and 2.\n        # This array can be built efficiently.\n\n        # Let's build a temporary array `current_max_cost_w1_w2` for the current `remaining_m_after_k3`\n        # This array will store the maximum cost achievable for a given weight `w_prime` using\n        # only items of weight 1 and 2.\n        # Its size will be `remaining_m_after_k3 + 1`.\n\n        # We can optimize this by maintaining the best cost for weight-1 and weight-2 items\n        # as we iterate through k2.\n        # The maximum cost for weight `w_prime` using only weight-1 items is `prefix_sum_w1[min(w_prime, len(costs_w1))]`.\n        # We can iterate `k2` from 0 up to `len(costs_w2)`.\n        \n        current_max_cost_w1_w2 = 0\n        \n        # `k1_ptr` will keep track of how many weight-1 items we can take.\n        # It's initialized to the maximum possible for `remaining_m_after_k3`\n        # and then decremented as we take more weight-2 items.\n        k1_ptr = min(remaining_m_after_k3, len(costs_w1))\n        \n        # The `max_cost_for_w1_only` array (or similar logic) would store the best sum of W1 items up to capacity `w`.\n        # `max_cost_for_w1_only[w]` = `prefix_sum_w1[min(w, len(costs_w1))]`\n\n        # Iterate over the number of items of weight 2 (k2)\n        # k2 can range from 0 up to min(len(costs_w2), remaining_m_after_k3 // 2)\n        for k2 in range(len(costs_w2) + 1):\n            weight_k2 = k2 * 2\n            if weight_k2 > remaining_m_after_k3:\n                break # Cannot take more items of weight 2 than remaining capacity allows\n\n            current_cost_k2 = prefix_sum_w2[k2]\n            remaining_m_after_k2_k3 = remaining_m_after_k3 - weight_k2\n\n            # Adjust k1_ptr: we can't take more weight-1 items than `remaining_m_after_k2_k3`\n            # The `k1_ptr` is for the *current* `remaining_m_after_k2_k3`.\n            # We want to find the maximum cost from weight-1 items for this remaining capacity.\n            # This is simply `prefix_sum_w1[min(remaining_m_after_k2_k3, len(costs_w1))]`\n            \n            # This part is the critical optimization:\n            # Instead of iterating k1, we can directly use prefix_sum_w1.\n            cost_from_w1 = prefix_sum_w1[min(remaining_m_after_k2_k3, len(costs_w1))]\n            \n            current_max_cost_w1_w2 = current_cost_k2 + cost_from_w1\n            \n            max_total_cost = max(max_total_cost, current_cost_k3 + current_max_cost_w1_w2)\n\n    sys.stdout.write(str(max_total_cost) + '\\n')\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    # Categorize souvenirs by weight and store their costs\n    costs_w1 = []\n    costs_w2 = []\n    costs_w3 = []\n\n    for _ in range(n):\n        w, c = map(int, sys.stdin.readline().split())\n        if w == 1:\n            costs_w1.append(c)\n        elif w == 2:\n            costs_w2.append(c)\n        else: # w == 3\n            costs_w3.append(c)\n\n    # Sort costs in descending order to pick the most expensive ones first\n    costs_w1.sort(reverse=True)\n    costs_w2.sort(reverse=True)\n    costs_w3.sort(reverse=True)\n\n    # Precompute prefix sums for costs to quickly get sum of top k items\n    # This avoids repeated summing in loops and makes sum operations O(1)\n    prefix_sum_w1 = [0] * (len(costs_w1) + 1)\n    for i in range(len(costs_w1)):\n        prefix_sum_w1[i+1] = prefix_sum_w1[i] + costs_w1[i]\n\n    prefix_sum_w2 = [0] * (len(costs_w2) + 1)\n    for i in range(len(costs_w2)):\n        prefix_sum_w2[i+1] = prefix_sum_w2[i] + costs_w2[i]\n    \n    prefix_sum_w3 = [0] * (len(costs_w3) + 1)\n    for i in range(len(costs_w3)):\n        prefix_sum_w3[i+1] = prefix_sum_w3[i] + costs_w3[i]\n\n    max_total_cost = 0\n\n    # Iterate over the number of items of weight 3 (k3)\n    # k3 can range from 0 up to min(len(costs_w3), m // 3)\n    for k3 in range(len(costs_w3) + 1):\n        weight_k3 = k3 * 3\n        if weight_k3 > m:\n            break # Cannot take more items of weight 3 than capacity allows\n\n        current_cost_k3 = prefix_sum_w3[k3]\n        remaining_m_after_k3 = m - weight_k3\n\n        # Now, we need to fill remaining_m_after_k3 with items of weight 1 and 2.\n        # This is a 0/1 knapsack-like problem with two item types.\n        # We can iterate over the number of items of weight 2 (k2).\n        # k2 can range from 0 up to min(len(costs_w2), remaining_m_after_k3 // 2)\n\n        # To optimize the inner loop for (k2, k1), we can use a two-pointer approach\n        # or iterate k2 and then determine k1.\n        # Let's iterate k2 and then calculate the best k1 for remaining capacity.\n        # This is essentially what the optimized solution does by precalculating\n        # the best cost for weight W using only weight 1 items, and then for weight W using\n        # weight 1 and 2 items.\n\n        # The key insight for the `dp_w1_w2` array (or similar approach) is:\n        # For a given remaining_m_after_k3, we want to find the maximum cost\n        # using weight-1 and weight-2 items.\n        # `max_cost_w1_w2[w]` stores the max cost for capacity `w` using only items of weight 1 and 2.\n        # This array can be built efficiently.\n\n        # Let's build a temporary array `current_max_cost_w1_w2` for the current `remaining_m_after_k3`\n        # This array will store the maximum cost achievable for a given weight `w_prime` using\n        # only items of weight 1 and 2.\n        # Its size will be `remaining_m_after_k3 + 1`.\n\n        # We can optimize this by maintaining the best cost for weight-1 and weight-2 items\n        # as we iterate through k2.\n        # The maximum cost for weight `w_prime` using only weight-1 items is `prefix_sum_w1[min(w_prime, len(costs_w1))]`.\n        # We can iterate `k2` from 0 up to `len(costs_w2)`.\n        \n        current_max_cost_w1_w2 = 0\n        \n        # `k1_ptr` will keep track of how many weight-1 items we can take.\n        # It's initialized to the maximum possible for `remaining_m_after_k3`\n        # and then decremented as we take more weight-2 items.\n        k1_ptr = min(remaining_m_after_k3, len(costs_w1))\n        \n        # The `max_cost_for_w1_only` array (or similar logic) would store the best sum of W1 items up to capacity `w`.\n        # `max_cost_for_w1_only[w]` = `prefix_sum_w1[min(w, len(costs_w1))]`\n\n        # Iterate over the number of items of weight 2 (k2)\n        # k2 can range from 0 up to min(len(costs_w2), remaining_m_after_k3 // 2)\n        for k2 in range(len(costs_w2) + 1):\n            weight_k2 = k2 * 2\n            if weight_k2 > remaining_m_after_k3:\n                break # Cannot take more items of weight 2 than remaining capacity allows\n\n            current_cost_k2 = prefix_sum_w2[k2]\n            remaining_m_after_k2_k3 = remaining_m_after_k3 - weight_k2\n\n            # Adjust k1_ptr: we can't take more weight-1 items than `remaining_m_after_k2_k3`\n            # The `k1_ptr` is for the *current* `remaining_m_after_k2_k3`.\n            # We want to find the maximum cost from weight-1 items for this remaining capacity.\n            # This is simply `prefix_sum_w1[min(remaining_m_after_k2_k3, len(costs_w1))]`\n            \n            # This part is the critical optimization:\n            # Instead of iterating k1, we can directly use prefix_sum_w1.\n            cost_from_w1 = prefix_sum_w1[min(remaining_m_after_k2_k3, len(costs_w1))]\n            \n            current_max_cost_w1_w2 = current_cost_k2 + cost_from_w1\n            \n            max_total_cost = max(max_total_cost, current_cost_k3 + current_max_cost_w1_w2)\n\n    sys.stdout.write(str(max_total_cost) + '\\n')\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 497,
        "completion_token_count": 1711,
        "thoughts_token_count": 855
    }
}