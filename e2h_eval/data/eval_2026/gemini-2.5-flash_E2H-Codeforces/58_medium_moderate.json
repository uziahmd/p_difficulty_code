{
    "start": 1758294816.4332006,
    "end": 1758294908.422847,
    "start-formatted": "2025-09-20 00:13 KST",
    "end-formatted": "2025-09-20 00:15 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "**Finding Minimal Edges for Odd Cycles: A Strategic Approach**\n\nOkay, so the goal is to figure out the fewest edges (`t`) needed to turn a graph into one that *has* an odd-length cycle, and then count up the different ways (`w`) to do that. Let's break this down systematically.\n\nFirst thing: if the graph *already* contains an odd cycle, the answer is simple - `t` is zero, and there's only one way to add *nothing*. Detecting this requires checking if the graph is *bipartite*. We can use a BFS or DFS-based 2-coloring approach for each connected component. If we find any conflicts (two adjacent vertices with the same color), it's not bipartite, and we're done.\n\nIf the graph *is* bipartite, we have some work to do. We know that to introduce an odd cycle, we must add edges that disrupt the bipartite structure. A bipartite graph is a collection of connected components which we split into two color sets.  Think of it this way: to mess up the 2-coloring, we need to add an edge that connects vertices of the *same* color *within the same connected component*.  This is the key.\n\nLet's look at `t = 1`. Can we always make this happen? Yes, if some connected component has two vertices with the same color that aren't already connected, we can add a single edge and make an odd cycle. We just need to sum this over all components where such pairs exist.\n\nNow, here's where it gets interesting. What if `t = 1` *isn't* possible? That means *every* connected component is just a single vertex or a single edge. In this case, we need at least *two* edges (`t = 2`).\n\nIf all components are isolated vertices and edges, it can be visualized as a forest of paths of length 0 or 1. If we attempt to add a new edge, it must be the case that either, that edge already exists (looping back to the beginning) or that we have created a cycle of at least 3 edges by creating a triangle.\n\nSo with `t=2`, we can identify edges which could be completed to form a triangle. For each edge, there might be a third vertex not connected to either edge endpoint. For a given edge `(u, v)`, we want to find vertices `w` that aren't neighbors of either `u` or `v`, and then add edges `(u,w)` and `(v,w)`. The total sum of ways to add this is `count_t2_ways`, where it might be possible that we create a few extra triangles by adding a few more edges.\n\nThere's the slight possibility that by merging two connected components (and adding two edges `(u,v)`, and `(x,y)`), but this is not considered because we just said all components can be converted into single isolated vertices or edges.\n\nFinally, we'll return to `t=3` if the graph is particularly sparse, and the strategies for `t=1` and `t=2` don't apply.\n",
    "response": "The problem asks us to find the minimum number of edges `t` to add to a given undirected graph to form a simple cycle of odd length, and `w`, the number of ways to do so. The graph is initially without loops or parallel edges. We cannot add loops or parallel edges.\n\nAn undirected graph contains an odd cycle if and only if it is not bipartite. This property is central to solving the problem.\n\nWe can determine `t` and `w` by checking possibilities in increasing order of `t`.\n\n**Step 1: Check for `t=0` (Graph already contains an odd cycle)**\n\nWe can check if the graph contains an odd cycle using a 2-coloring algorithm (BFS or DFS).\nFor each connected component:\n1.  Start a traversal (BFS or DFS) from an unvisited vertex `s`, assigning it color 0.\n2.  During traversal, for each neighbor `v` of current vertex `u`:\n    *   If `v` is unvisited, assign it the opposite color of `u` and add it to the queue/stack.\n    *   If `v` is visited and has the same color as `u`, then we have found an odd cycle. In this case, `t=0` and `w=1`. We can print `0 1` and terminate.\n3.  If the traversal completes for a component without finding any color conflicts, that component is bipartite.\n\nIf all connected components are successfully 2-colored, the entire graph is bipartite, meaning it contains no odd cycles. We proceed to check for `t > 0`.\n\n**Step 2: Check for `t=1` (Graph is bipartite, add one edge)**\n\nIf the graph is bipartite, we need to add at least one edge. To form an odd cycle by adding a single edge `(u,v)`, `u` and `v` must be in the same connected component and have the same color.\nAfter 2-coloring the graph (from Step 1), for each connected component:\n1.  Count the number of vertices assigned color 0 (`count_color[0]`) and color 1 (`count_color[1]`).\n2.  If `count_color[0] >= 2` or `count_color[1] >= 2` in any component, then `t=1` is possible.\n    *   The number of ways to choose two vertices of the same color within this component is `count_color[0] * (count_color[0] - 1) / 2` for color 0, plus `count_color[1] * (count_color[1] - 1) / 2` for color 1.\n    *   Since the component is bipartite, no existing edge connects two vertices of the same color, so all these pairs are valid for adding an edge.\n    *   `w` is the sum of these counts over all components that satisfy the condition.\n    *   Print `1 w` and terminate.\n\nIf `t=1` is not possible, it means that in every connected component, `count_color[0] < 2` AND `count_color[1] < 2`. This implies that each connected component is either an isolated vertex (e.g., `A`, `count_color[0]=1, count_color[1]=0`) or a single edge (e.g., `A-B`, `A` color 0, `B` color 1, `count_color[0]=1, count_color[1]=1`). In this scenario, we must add at least two edges.\n\n**Step 3: Check for `t=2` (Graph is bipartite, `t=1` not possible, add two edges)**\n\nIf `t=1` is not possible, all components are isolated vertices or single edges.\nThe simplest odd cycle is a triangle (length 3). We can form a triangle by adding two edges.\nThere are two main ways to form an odd cycle of length 3 by adding two edges:\n1.  **Using an existing edge:** Pick an existing edge `(u,v)`. Find a third vertex `w` such that `w` is not `u`, not `v`, not adjacent to `u`, and not adjacent to `v`. We can then add edges `(u,w)` and `(v,w)` to form the triangle `u-w-v-u`.\n    *   For each existing edge `(u,v)` in the graph:\n        *   Count the number of available vertices `w`. This is `n - (deg(u) + deg(v) - |N(u) \\cap N(v)|) - 2`. The term `deg(u) + deg(v) - |N(u) \\cap N(v)|` represents the size of `N(u) \\cup N(v)`. Adding `u` and `v` themselves, we get `|N(u) \\cup N(v) \\cup \\{u,v\\}|`. The number of vertices *not* in this set is `n - |N(u) \\cup N(v) \\cup \\{u,v\\}|`. This simplifies to `n - deg(u) - deg(v) + |N(u) \\cap N(v)|`.\n        *   Let this count be `num_w`. If `num_w > 0`, we add `num_w` to `ways_t2_option1`.\n    *   `ways_t2_option1` is the total number of ways to form a triangle using an existing edge.\n\n2.  **Using two isolated vertices:** Pick two isolated vertices `u` and `v` (vertices with degree 0). Add an edge `(u,v)`. Then pick another isolated vertex `w`. Add edges `(u,w)` and `(v,w)`. This forms a triangle `u-w-v-u`. This is essentially the same as option 1 if we consider the edge `(u,v)` to be the first added edge, and then we add `(u,w)` and `(v,w)`. But it's simpler to think of it as picking 3 isolated vertices.\n    *   Let `num_isolated_vertices` be the count of vertices with degree 0.\n    *   If `num_isolated_vertices >= 3`:\n        *   We can choose 3 such vertices in `num_isolated_vertices * (num_isolated_vertices - 1) * (num_isolated_vertices - 2) / 6` ways. For each set of 3 vertices `{u,v,w}`, we add edges `(u,v), (v,w), (w,u)`. This forms a triangle. This is `t=3`.\n        *   However, if `t=2` is possible, we should prefer `t=2`.\n    *   If `num_isolated_vertices >= 1` and `m > 0`:\n        *   Pick an isolated vertex `w`. Pick an existing edge `(u,v)`. Add `(w,u)` and `(w,v)`. This forms a triangle. This is covered by Option 1, where `deg(u)=1, deg(v)=1` (if `u,v` are endpoints of an isolated edge) and `|N(u) \\cap N(v)|=0`. So `num_w = n - 1 - 1 + 0 = n-2`. This is not correct.\n        *   Let's re-evaluate the `num_w` for option 1: `n - deg(u) - deg(v) + |N(u) \\cap N(v)|`. This formula correctly counts vertices `w` that are not `u`, not `v`, not adjacent to `u`, not adjacent to `v`.\n        *   Consider the case where `u,v` form an isolated edge. `deg(u)=1, deg(v)=1`, `N(u)=\\{v\\}, N(v)=\\{u\\}`, `|N(u) \\cap N(v)|=0`.\n        *   `num_w = n - 1 - 1 + 0 = n-2`.\n        *   This counts all other `n-2` vertices. If any of these `n-2` vertices are isolated, they are included.\n        *   This formula sums up correctly.\n\nSo, for `t=2`, `w` is `ways_t2_option1`. Print `2 ways_t2_option1` and terminate.\n\n**Step 4: Check for `t=3` (Graph is bipartite, `t=1` and `t=2` not possible)**\n\nIf `t=0, t=1, t=2` are not possible, it implies:\n*   The graph is bipartite.\n*   No component has two same-colored vertices (all components are isolated vertices or single edges).\n*   For every existing edge `(u,v)`, all other `n-2` vertices are either `u`, `v`, or connected to `u` or `v`. That is, `n - deg(u) - deg(v) + |N(u) \\cap N(v)| = 0` for all edges `(u,v)`. This means `N(u) \\cup N(v) \\cup \\{u,v\\}` covers all `n` vertices. This implies a very dense graph or a very small `n`.\n\nIn this case, we must add at least 3 edges. The smallest odd cycle we can form is a triangle.\nTo form a triangle `(A,B,C)` with 3 new edges, we must pick three distinct vertices `A, B, C` that are not already connected to each other.\nThe number of ways to do this is `n * (n-1) * (n-2) / 6`.\nHowever, we must ensure these three vertices are not connected *at all*. If any pair `(A,B)` is already connected, it would be `t=2`.\nSince `t=2` was not possible, it implies that for any edge `(u,v)`, all other `w` are connected to `u` or `v`.\nIf `m=0` (the graph has no edges), then `t=0` (no odd cycle), `t=1` (no same-colored pair in a component, as all are isolated vertices), `t=2` (no existing edges to form a triangle).\nSo if `m=0`, then `t=3`. We pick any three distinct vertices `u,v,w` and add `(u,v), (v,w), (w,u)`.\nThe number of ways is `n * (n-1) * (n-2) / 6`.\nPrint `3 (n * (n-1) * (n-2) / 6)` and terminate.\n\n**Final Algorithm Structure:**\n\n```python\nimport collections\nimport sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    adj = collections.defaultdict(list)\n    edges = set() # Store edges for quick lookup (u,v) and (v,u)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n        edges.add(tuple(sorted((u, v))))\n\n    # Step 1: Check for t=0 (graph already has an odd cycle)\n    color = [-1] * (n + 1) # -1: unvisited, 0: color 0, 1: color 1\n    has_odd_cycle = False\n    \n    for i in range(1, n + 1):\n        if color[i] == -1:\n            q = collections.deque()\n            q.append(i)\n            color[i] = 0\n            \n            while q:\n                u = q.popleft()\n                for v in adj[u]:\n                    if color[v] == -1:\n                        color[v] = 1 - color[u]\n                        q.append(v)\n                    elif color[v] == color[u]:\n                        has_odd_cycle = True\n                        break\n                if has_odd_cycle:\n                    break\n        if has_odd_cycle:\n            break\n            \n    if has_odd_cycle:\n        print(\"0 1\")\n        return\n\n    # Graph is bipartite.\n    # Step 2: Check for t=1\n    ways_t1 = 0\n    visited_component = [False] * (n + 1)\n    \n    for i in range(1, n + 1):\n        if not visited_component[i]:\n            component_nodes = []\n            q = collections.deque([i])\n            visited_component[i] = True\n            component_nodes.append(i)\n            \n            head = 0\n            while head < len(component_nodes):\n                u = component_nodes[head]\n                head += 1\n                for v in adj[u]:\n                    if not visited_component[v]:\n                        visited_component[v] = True\n                        component_nodes.append(v)\n            \n            count_color0 = 0\n            count_color1 = 0\n            for node in component_nodes:\n                if color[node] == 0:\n                    count_color0 += 1\n                else:\n                    count_color1 += 1\n            \n            ways_t1 += count_color0 * (count_color0 - 1) // 2\n            ways_t1 += count_color1 * (count_color1 - 1) // 2\n            \n    if ways_t1 > 0:\n        print(f\"1 {ways_t1}\")\n        return\n\n    # Graph is bipartite, and t=1 is not possible.\n    # This implies all components are isolated vertices or single edges.\n    # Step 3: Check for t=2\n    ways_t2 = 0\n    \n    # Option 1: Add (u,w) and (v,w) to an existing edge (u,v) to form a triangle.\n    # Requires an existing edge (u,v) and a vertex w not connected to u or v.\n    # The number of such w is n - deg(u) - deg(v) + |N(u) intersect N(v)|\n    \n    # Precompute degrees and neighbor sets for efficient calculation\n    degrees = [0] * (n + 1)\n    neighbor_sets = [set() for _ in range(n + 1)]\n    for u in range(1, n + 1):\n        degrees[u] = len(adj[u])\n        neighbor_sets[u].update(adj[u])\n\n    for u_orig, v_orig in edges: # Iterate over existing edges\n        # Calculate common neighbors\n        common_neighbors = len(neighbor_sets[u_orig].intersection(neighbor_sets[v_orig]))\n        \n        # Calculate number of vertices 'w' that are not u, v, or adjacent to u or v\n        # Total vertices - (u, v) - (neighbors of u excluding v) - (neighbors of v excluding u and its neighbors)\n        # Simplified: n - |N(u) U N(v) U {u,v}|\n        # |N(u) U N(v) U {u,v}| = |N(u)| + |N(v)| - |N(u) intersect N(v)| + 2 (for u,v themselves)\n        # = deg(u) + deg(v) - common_neighbors + 2\n        \n        # So, vertices not in this set: n - (deg(u) + deg(v) - common_neighbors + 2)\n        # This is n - deg(u) - deg(v) + common_neighbors - 2\n        \n        # More accurately: n - (deg(u)-1) - (deg(v)-1) - common_neighbors + 2\n        # This is n - (deg(u) + deg(v) - common_neighbors - 2)\n        \n        # Let's use the formula: n - (size of N(u) U N(v) U {u,v})\n        # size of N(u) U N(v) = deg(u) + deg(v) - common_neighbors\n        # size of N(u) U N(v) U {u,v} = deg(u) + deg(v) - common_neighbors + 2 (because u,v are not in N(u), N(v) unless they are loops, which are not allowed)\n        # So, num_w = n - (degrees[u_orig] + degrees[v_orig] - common_neighbors + 2)\n        \n        # The simpler formula derived in thought: n - deg(u) - deg(v) + |N(u) intersect N(v)|\n        # This counts vertices that are not u, not v, not in N(u), not in N(v).\n        # This is exactly what we need for 'w' to form a triangle (u,v,w) where (u,w) and (v,w) are new edges.\n        num_w = n - degrees[u_orig] - degrees[v_orig] + common_neighbors\n        ways_t2 += num_w\n            \n    if ways_t2 > 0:\n        print(f\"2 {ways_t2}\")\n        return\n\n    # Graph is bipartite, t=1 not possible, t=2 not possible.\n    # This implies the graph has no edges (m=0), or for every edge (u,v), \n    # all other n-2 vertices are connected to u or v.\n    # Step 4: Check for t=3\n    \n    # If m=0, all vertices are isolated.\n    # We need to pick 3 distinct vertices and add 3 edges to form a triangle.\n    # Number of ways to choose 3 vertices from n: nC3\n    if n >= 3:\n        ways_t3 = n * (n - 1) * (n - 2) // 6\n        print(f\"3 {ways_t3}\")\n    else:\n        # If n < 3, it's impossible to form a cycle of length > 1.\n        # This case should not be reached based on problem constraints or implies \n        # that even n=0,1,2 cannot form a cycle.\n        # However, problem says \"cycle of odd length, consisting of more than one vertex\".\n        # Minimum cycle length is 3. So n must be at least 3.\n        # If n < 3, no cycle is possible.\n        # But for competitive programming, assume n >= 3 when t=3 is the answer.\n        pass\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import collections\nimport sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    adj = collections.defaultdict(list)\n    edges = set() # Store edges for quick lookup (u,v) and (v,u)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n        edges.add(tuple(sorted((u, v))))\n\n    # Step 1: Check for t=0 (graph already has an odd cycle)\n    color = [-1] * (n + 1) # -1: unvisited, 0: color 0, 1: color 1\n    has_odd_cycle = False\n    \n    for i in range(1, n + 1):\n        if color[i] == -1:\n            q = collections.deque()\n            q.append(i)\n            color[i] = 0\n            \n            while q:\n                u = q.popleft()\n                for v in adj[u]:\n                    if color[v] == -1:\n                        color[v] = 1 - color[u]\n                        q.append(v)\n                    elif color[v] == color[u]:\n                        has_odd_cycle = True\n                        break\n                if has_odd_cycle:\n                    break\n        if has_odd_cycle:\n            break\n            \n    if has_odd_cycle:\n        print(\"0 1\")\n        return\n\n    # Graph is bipartite.\n    # Step 2: Check for t=1\n    ways_t1 = 0\n    visited_component = [False] * (n + 1)\n    \n    for i in range(1, n + 1):\n        if not visited_component[i]:\n            component_nodes = []\n            q = collections.deque([i])\n            visited_component[i] = True\n            component_nodes.append(i)\n            \n            head = 0\n            while head < len(component_nodes):\n                u = component_nodes[head]\n                head += 1\n                for v in adj[u]:\n                    if not visited_component[v]:\n                        visited_component[v] = True\n                        component_nodes.append(v)\n            \n            count_color0 = 0\n            count_color1 = 0\n            for node in component_nodes:\n                if color[node] == 0:\n                    count_color0 += 1\n                else:\n                    count_color1 += 1\n            \n            ways_t1 += count_color0 * (count_color0 - 1) // 2\n            ways_t1 += count_color1 * (count_color1 - 1) // 2\n            \n    if ways_t1 > 0:\n        print(f\"1 {ways_t1}\")\n        return\n\n    # Graph is bipartite, and t=1 is not possible.\n    # This implies all components are isolated vertices or single edges.\n    # Step 3: Check for t=2\n    ways_t2 = 0\n    \n    # Option 1: Add (u,w) and (v,w) to an existing edge (u,v) to form a triangle.\n    # Requires an existing edge (u,v) and a vertex w not connected to u or v.\n    # The number of such w is n - deg(u) - deg(v) + |N(u) intersect N(v)|\n    \n    # Precompute degrees and neighbor sets for efficient calculation\n    degrees = [0] * (n + 1)\n    neighbor_sets = [set() for _ in range(n + 1)]\n    for u in range(1, n + 1):\n        degrees[u] = len(adj[u])\n        neighbor_sets[u].update(adj[u])\n\n    for u_orig, v_orig in edges: # Iterate over existing edges\n        # Calculate common neighbors\n        common_neighbors = len(neighbor_sets[u_orig].intersection(neighbor_sets[v_orig]))\n        \n        # Calculate number of vertices 'w' that are not u, v, or adjacent to u or v\n        # Total vertices - (u, v) - (neighbors of u excluding v) - (neighbors of v excluding u and its neighbors)\n        # Simplified: n - |N(u) U N(v) U {u,v}|\n        # |N(u) U N(v) U {u,v}| = |N(u)| + |N(v)| - |N(u) intersect N(v)| + 2 (for u,v themselves)\n        # = deg(u) + deg(v) - common_neighbors + 2\n        \n        # So, vertices not in this set: n - (deg(u) + deg(v) - common_neighbors + 2)\n        # This is n - deg(u) - deg(v) + common_neighbors - 2\n        \n        # More accurately: n - (deg(u)-1) - (deg(v)-1) - common_neighbors + 2\n        # This is n - (deg(u) + deg(v) - common_neighbors - 2)\n        \n        # Let's use the formula: n - (size of N(u) U N(v) U {u,v})\n        # size of N(u) U N(v) = deg(u) + deg(v) - common_neighbors\n        # size of N(u) U N(v) U {u,v} = deg(u) + deg(v) - common_neighbors + 2 (because u,v are not in N(u), N(v) unless they are loops, which are not allowed)\n        # So, num_w = n - (degrees[u_orig] + degrees[v_orig] - common_neighbors + 2)\n        \n        # The simpler formula derived in thought: n - deg(u) - deg(v) + |N(u) intersect N(v)|\n        # This counts vertices that are not u, not v, not in N(u), not in N(v).\n        # This is exactly what we need for 'w' to form a triangle (u,v,w) where (u,w) and (v,w) are new edges.\n        num_w = n - degrees[u_orig] - degrees[v_orig] + common_neighbors\n        ways_t2 += num_w\n            \n    if ways_t2 > 0:\n        print(f\"2 {ways_t2}\")\n        return\n\n    # Graph is bipartite, t=1 not possible, t=2 not possible.\n    # This implies the graph has no edges (m=0), or for every edge (u,v), \n    # all other n-2 vertices are connected to u or v.\n    # Step 4: Check for t=3\n    \n    # If m=0, all vertices are isolated.\n    # We need to pick 3 distinct vertices and add 3 edges to form a triangle.\n    # Number of ways to choose 3 vertices from n: nC3\n    if n >= 3:\n        ways_t3 = n * (n - 1) * (n - 2) // 6\n        print(f\"3 {ways_t3}\")\n    else:\n        # If n < 3, it's impossible to form a cycle of length > 1.\n        # This case should not be reached based on problem constraints or implies \n        # that even n=0,1,2 cannot form a cycle.\n        # However, problem says \"cycle of odd length, consisting of more than one vertex\".\n        # Minimum cycle length is 3. So n must be at least 3.\n        # If n < 3, no cycle is possible.\n        # But for competitive programming, assume n >= 3 when t=3 is the answer.\n        pass\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 604,
        "completion_token_count": 4297,
        "thoughts_token_count": 7064
    }
}