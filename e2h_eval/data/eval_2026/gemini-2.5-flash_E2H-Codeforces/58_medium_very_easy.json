{
    "start": 1758294847.0995975,
    "end": 1758294928.784311,
    "start-formatted": "2025-09-20 00:14 KST",
    "end-formatted": "2025-09-20 00:15 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "**Understanding the Minimum Edges to Add for an Odd Cycle**\n\nAlright, let's break this down. The problem's asking me to figure out the fewest edges, let's call it *t*, I need to toss into a graph to force it to have an odd-length cycle, and the number of distinct ways, *w*, I can do it.  \n\nFirst, I know that if a graph already has an odd cycle, it's not bipartite. So, I need to check if the graph is bipartite. I can do this using BFS or DFS, assigning colors to vertices. If I ever find an edge where both ends have the same color, that's an odd cycle, and `t` is 0, and there is one way.\n\nIf it *is* bipartite, the fun begins.\n\n*   **Case t=0:** If the original graph contains an odd cycle, `t` is 0 and `w` is 1 (the original graph).\n*   **Case t=1:** If it's bipartite, I need to add at least one edge. The crucial part: to make the graph non-bipartite with *one* edge, I need to connect two vertices within the *same* partition. So, I check for components, color them (0 or 1), and count how many pairs of the same color I can create an edge between. The sum of these pairs across all components gives me `w`.\n*   **Case t=2:** Now, if I *can't* do it with one edge (`t=1`), I need to add two edges. This means the graph is bipartite, but all its connected components are either just single vertices or single edges. To create an odd cycle, I have to add two edges in a certain way. If I have a bunch of isolated vertices and edges, a triangle might form (u,v,w)\n\nTo clarify my approach:\n\n1.  **Bipartite Check:** I'll run a modified BFS or DFS to color the graph. If I find an inconsistency (two connected nodes with same color), it contains an odd cycle, and I'm done (`t=0`).\n2.  **Count Partitions:** If it's bipartite, I note the sizes of each color partition within each connected component.\n3.  **t=1 Calculation:** I calculate `w` by summing the possible edge pairs within the same color partition for each component.\n4.  **t=2 Calculation:** The tricky part. If `w=0`, it means my graph has only isolated vertices and edges (singletons or pairs). To form an odd cycle of size at least 3, I need 2 edges, (u, v) and (v,w) where (u,w) is an edge. If i have an isolated vertex, and an existing edge (a,b). I add edge (a,v) and (b,v).\n\nI will count the cases:\nm is the number of edges and n is the number of vertices.\n\n*   **Case m > 0**: If number of isolated vertices `N_iso` is larger than zero, then `t=2` and count `m * N_iso`. If m = 0, no edge.\n*   **Case m = 0**: If the number of vertices is 3 or greater, the t=3, the number of ways is calculated with `n * (n - 1) * (n - 2) // 6`. Otherwise is not possible, impossible.\n",
    "response": "The problem asks us to find the minimum number of edges `t` to add to a given graph to form a simple cycle of odd length (length at least 3), and the number of ways `w` to do so.\n\nA graph contains an odd cycle if and only if it is not bipartite. So, we are looking for the minimum number of edges to add to make the graph non-bipartite.\n\nWe can analyze this problem by considering the minimum number of edges `t` required:\n\n**Step 1: Check if the graph already contains an odd cycle (`t=0`).**\nWe can use a Breadth-First Search (BFS) or Depth-First Search (DFS) to perform a 2-coloring (bipartite check) on each connected component of the graph.\n- Initialize `color` array for all vertices to -1 (unvisited).\n- For each unvisited vertex `i`:\n    - Start a BFS/DFS from `i`, assigning `color[i] = 0`.\n    - When traversing an edge `(u, v)`:\n        - If `v` is unvisited (`color[v] == -1`), assign `color[v] = 1 - color[u]` and add `v` to the queue/stack.\n        - If `v` is visited and `color[v] == color[u]`, an odd cycle is detected. In this case, `t=0` and `w=1` (there's 1 way to add 0 edges). We can immediately print `0 1` and exit.\n    - If the component is fully traversed and no conflict is found, it is bipartite. Store the counts of vertices in each partition (say, `c0` and `c1`) for this component.\n\n**Step 2: If the graph is bipartite, check if `t=1` is possible.**\nIf no odd cycle was found in Step 1, the entire graph is bipartite. To form an odd cycle by adding one edge `(u, v)`, `u` and `v` must be in the same connected component and have the same color (i.e., belong to the same partition).\n- For each bipartite component with partition sizes `c0` and `c1`:\n    - The number of ways to pick two distinct vertices from `P_0` is `c0 * (c0 - 1) / 2`.\n    - The number of ways to pick two distinct vertices from `P_1` is `c1 * (c1 - 1) / 2`.\n    - Since the component is bipartite, there are no existing edges between vertices of the same color, so all these pairs represent valid new edges.\n- Sum these counts over all bipartite components to get `ways_t1`.\n- If `ways_t1 > 0`: `t=1`. Print `1 ways_t1` and exit.\n\n**Step 3: If `t=1` is not possible, check if `t=2` is possible.**\nIf `ways_t1 = 0`, it means for every bipartite component, `c0 <= 1` and `c1 <= 1`. This implies that every connected component is either an isolated vertex (size 1) or an isolated edge (size 2). In such a graph, we cannot form an odd cycle by adding just one edge. We need to add at least two edges.\n\nConsider forming an odd cycle of length 3 (a triangle) by adding two edges. Let the added edges be `(u, v)` and `(v, w)`. For this to form a triangle, `(u, w)` must be an existing edge.\n- For this to work, `u, v, w` must be distinct.\n- `(u, w)` is an existing edge. Since all existing components are isolated edges or vertices, `u` and `w` must form an isolated edge. They will have different colors (e.g., `color[u]=0, color[w]=1`).\n- `v` must be a vertex not connected to `u` or `w`. Since `ways_t1=0`, `v` must be an isolated vertex (a component of size 1). Adding `(u,v)` and `(v,w)` would connect `v` to `u` and `w`.\n- The number of ways to do this is `m * num_isolated_vertices`, where `m` is the number of existing edges and `num_isolated_vertices` is the count of isolated vertices.\n- If `m > 0` and `num_isolated_vertices > 0`: `t=2`. Print `2 (m * num_isolated_vertices)` and exit.\n\n**Step 4: If `t=2` is not possible, then `t=3` is required.**\nThis scenario happens if either:\na) `m = 0` (the graph has no edges, all `n` vertices are isolated). In this case, `num_isolated_vertices = n`.\nb) `num_isolated_vertices = 0` (the graph consists only of disjoint edges, `n = 2m`).\n\nIn both these cases, we need to add 3 edges to form an odd cycle. The smallest odd cycle is a triangle.\n- **Case 4a: `m = 0` (all `n` vertices are isolated).**\n    - To form a triangle, we need to choose 3 distinct vertices `u, v, w` and add edges `(u,v), (v,w), (w,u)`.\n    - The number of ways to choose 3 vertices from `n` is `n * (n - 1) * (n - 2) / 6`.\n    - This requires `n >= 3`. If `n < 3`, it's impossible to form an odd cycle, but the problem implies it's always possible. For `n < 3`, this formula yields 0. The problem example `3 0` implies `t=3, w=1`.\n    - So, if `n < 3`, no cycle of length 3 is possible. If `n=3`, `w=1`.\n    - Print `3 (n * (n - 1) * (n - 2) // 6)`.\n\n- **Case 4b: `num_isolated_vertices = 0` (graph is a collection of `m` disjoint edges).**\n    - To form a triangle, we need an isolated vertex (which we don't have) or to use existing edges.\n    - We need to pick 3 distinct existing edges, say `(u1, v1)`, `(u2, v2)`, `(u3, v3)`.\n    - Then we can add 3 edges connecting these components to form a \"super-triangle\". For example, add `(u1, u2)`, `(u2, u3)`, `(u3, u1)`. This results in an odd cycle `u1-u2-u3-u1`.\n    - The number of ways to choose 3 existing edges from `m` is `m * (m - 1) * (m - 2) / 6`.\n    - This requires `m >= 3`.\n    - Print `3 (m * (m - 1) * (m - 2) // 6)`.\n\nNotice that for `t=3`, the number of ways is `n * (n - 1) * (n - 2) // 6` (if `m=0`) or `m * (m - 1) * (m - 2) // 6` (if `num_isolated_vertices=0`). This is a single `t=3` case.\nThe total number of vertices `n` can be small. If `n < 3`, no odd cycle of length 3 is possible. The problem statement guarantees `n >= 1`. An odd cycle must have length at least 3. If `n < 3`, it's impossible to form such a cycle. However, example `3 0` implies `t=3, w=1`. This means for `n=3, m=0`, we choose 3 vertices (1 way) and connect them to form a triangle.\nThe logic for `t=3` should be:\nIf `n < 3`, it's impossible (this case won't be reached as `n>=3` for any of the `t=3` ways to be non-zero).\nIf `m=0` (all `n` vertices are isolated), ways are `n * (n-1) * (n-2) // 6`.\nIf `num_isolated_vertices=0` (all `n` vertices are part of `m` disjoint edges), ways are `m * (m-1) * (m-2) // 6`.\nIf `m=1, n=2`, `num_isolated_vertices=0`. `m*(m-1)*(m-2)//6 = 0`.\nIf `m=2, n=4`, `num_isolated_vertices=0`. `m*(m-1)*(m-2)//6 = 0`.\nIf `m=0, n=2`, `num_isolated_vertices=2`. `n*(n-1)*(n-2)//6 = 0`.\nSo, `t=3` ways is only non-zero if `n>=3` and `m=0`, or `m>=3` and `num_isolated_vertices=0`.\nThis is just `max(n * (n-1) * (n-2) // 6, m * (m-1) * (m-2) // 6)`. No, it's not max. It's one or the other.\nIf `m=0`, then `num_isolated_vertices=n`. Then `t=3` ways are `n*(n-1)*(n-2)//6`.\nIf `m>0` and `num_isolated_vertices=0`, then `t=3` ways are `m*(m-1)*(m-2)//6`.\nThese are mutually exclusive conditions.\n\nFinal logic for `t=3`:\nIf `m == 0`:\n  `ways_t3 = n * (n - 1) * (n - 2) // 6`\nElse (`num_isolated_vertices == 0`):\n  `ways_t3 = m * (m - 1) * (m - 2) // 6`\nPrint `3 ways_t3`.\n\n```python\nimport sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    \n    adj = [[] for _ in range(n + 1)]\n    edges = []\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n        edges.append((u, v))\n\n    color = [-1] * (n + 1)\n    bipartite_components_info = []\n    \n    # Step 1: Check for existing odd cycle (t=0)\n    # Perform 2-coloring (bipartite check) for each connected component\n    for i in range(1, n + 1):\n        if color[i] == -1:\n            q = deque()\n            q.append((i, 0)) # (vertex, color)\n            color[i] = 0\n            \n            current_c0 = 1 # count of vertices with color 0\n            current_c1 = 0 # count of vertices with color 1\n            component_is_bipartite = True\n            \n            while q:\n                u, u_color = q.popleft()\n                \n                for v in adj[u]:\n                    if color[v] == -1:\n                        color[v] = 1 - u_color\n                        if color[v] == 0:\n                            current_c0 += 1\n                        else:\n                            current_c1 += 1\n                        q.append((v, color[v]))\n                    elif color[v] == u_color:\n                        # Found an odd cycle\n                        print(\"0 1\")\n                        return\n            \n            # If the component is bipartite, store its partition sizes\n            if component_is_bipartite:\n                bipartite_components_info.append((current_c0, current_c1))\n\n    # If we reached here, the graph is bipartite.\n    \n    # Step 2: Check if t=1 is possible\n    ways_t1 = 0\n    for c0, c1 in bipartite_components_info:\n        ways_t1 += c0 * (c0 - 1) // 2\n        ways_t1 += c1 * (c1 - 1) // 2\n    \n    if ways_t1 > 0:\n        print(f\"1 {ways_t1}\")\n        return\n\n    # If we reached here, t=1 is not possible.\n    # This means for every bipartite component, c0 <= 1 and c1 <= 1.\n    # So, each component is either an isolated vertex or an isolated edge.\n    \n    # Count isolated vertices\n    num_isolated_vertices = 0\n    for c0, c1 in bipartite_components_info:\n        if c0 == 1 and c1 == 0: # Component is a single vertex\n            num_isolated_vertices += 1\n        # Note: if c0=0, c1=1, it's also a single vertex. The BFS initializes c0=1 for the starting node.\n        # So a single node component will always be (1,0) if it's the first node visited in its component.\n        # A component that is an edge will be (1,1).\n\n    # Step 3: Check if t=2 is possible\n    # We need an existing edge (u,w) and an isolated vertex v.\n    # Add (u,v) and (v,w) to form a triangle u-v-w-u.\n    ways_t2 = m * num_isolated_vertices\n    \n    if ways_t2 > 0:\n        print(f\"2 {ways_t2}\")\n        return\n\n    # If we reached here, t=2 is not possible.\n    # This means either m=0 (no existing edges) OR num_isolated_vertices=0 (no isolated vertices).\n    # In both cases, we need to add 3 edges (t=3).\n    \n    # Step 4: t=3 is required\n    ways_t3 = 0\n    if m == 0: # Graph is just isolated vertices\n        # Need to pick 3 vertices to form a triangle\n        if n >= 3:\n            ways_t3 = n * (n - 1) * (n - 2) // 6\n    else: # Graph is just disjoint edges (num_isolated_vertices == 0)\n        # Need to pick 3 disjoint edges and connect them to form a \"super-triangle\"\n        # e.g., edges (u1,v1), (u2,v2), (u3,v3). Add (u1,u2), (u2,u3), (u3,u1).\n        if m >= 3:\n            ways_t3 = m * (m - 1) * (m - 2) // 6\n    \n    print(f\"3 {ways_t3}\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    \n    adj = [[] for _ in range(n + 1)]\n    edges = []\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n        edges.append((u, v))\n\n    color = [-1] * (n + 1)\n    bipartite_components_info = []\n    \n    # Step 1: Check for existing odd cycle (t=0)\n    # Perform 2-coloring (bipartite check) for each connected component\n    for i in range(1, n + 1):\n        if color[i] == -1:\n            q = deque()\n            q.append((i, 0)) # (vertex, color)\n            color[i] = 0\n            \n            current_c0 = 1 # count of vertices with color 0\n            current_c1 = 0 # count of vertices with color 1\n            component_is_bipartite = True\n            \n            while q:\n                u, u_color = q.popleft()\n                \n                for v in adj[u]:\n                    if color[v] == -1:\n                        color[v] = 1 - u_color\n                        if color[v] == 0:\n                            current_c0 += 1\n                        else:\n                            current_c1 += 1\n                        q.append((v, color[v]))\n                    elif color[v] == u_color:\n                        # Found an odd cycle\n                        print(\"0 1\")\n                        return\n            \n            # If the component is bipartite, store its partition sizes\n            if component_is_bipartite:\n                bipartite_components_info.append((current_c0, current_c1))\n\n    # If we reached here, the graph is bipartite.\n    \n    # Step 2: Check if t=1 is possible\n    ways_t1 = 0\n    for c0, c1 in bipartite_components_info:\n        ways_t1 += c0 * (c0 - 1) // 2\n        ways_t1 += c1 * (c1 - 1) // 2\n    \n    if ways_t1 > 0:\n        print(f\"1 {ways_t1}\")\n        return\n\n    # If we reached here, t=1 is not possible.\n    # This means for every bipartite component, c0 <= 1 and c1 <= 1.\n    # So, each component is either an isolated vertex or an isolated edge.\n    \n    # Count isolated vertices\n    num_isolated_vertices = 0\n    for c0, c1 in bipartite_components_info:\n        if c0 == 1 and c1 == 0: # Component is a single vertex\n            num_isolated_vertices += 1\n        # Note: if c0=0, c1=1, it's also a single vertex. The BFS initializes c0=1 for the starting node.\n        # So a single node component will always be (1,0) if it's the first node visited in its component.\n        # A component that is an edge will be (1,1).\n\n    # Step 3: Check if t=2 is possible\n    # We need an existing edge (u,w) and an isolated vertex v.\n    # Add (u,v) and (v,w) to form a triangle u-v-w-u.\n    ways_t2 = m * num_isolated_vertices\n    \n    if ways_t2 > 0:\n        print(f\"2 {ways_t2}\")\n        return\n\n    # If we reached here, t=2 is not possible.\n    # This means either m=0 (no existing edges) OR num_isolated_vertices=0 (no isolated vertices).\n    # In both cases, we need to add 3 edges (t=3).\n    \n    # Step 4: t=3 is required\n    ways_t3 = 0\n    if m == 0: # Graph is just isolated vertices\n        # Need to pick 3 vertices to form a triangle\n        if n >= 3:\n            ways_t3 = n * (n - 1) * (n - 2) // 6\n    else: # Graph is just disjoint edges (num_isolated_vertices == 0)\n        # Need to pick 3 disjoint edges and connect them to form a \"super-triangle\"\n        # e.g., edges (u1,v1), (u2,v2), (u3,v3). Add (u1,u2), (u2,u3), (u3,u1).\n        if m >= 3:\n            ways_t3 = m * (m - 1) * (m - 2) // 6\n    \n    print(f\"3 {ways_t3}\")\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 604,
        "completion_token_count": 3516,
        "thoughts_token_count": 7038
    }
}