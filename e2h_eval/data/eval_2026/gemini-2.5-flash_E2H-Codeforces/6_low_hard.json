{
    "start": 1758009286.5494738,
    "end": 1758009322.491664,
    "start-formatted": "2025-09-16 16:54 KST",
    "end-formatted": "2025-09-16 16:55 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "**Breaking Down This Competitive Programming Problem**\n\nOkay, so I've got this competitive programming problem in front of me, and my immediate goal is to figure out the most efficient way to solve it. It's all about finding these two non-overlapping vouchers that, when combined, meet a specific duration target and minimize the overall cost. Let me quickly recap the key elements:\n\n*   **The Input:** I'm dealing with `n` vouchers, each defined by a departure day (`li`), an arrival day (`ri`), and a cost (`costi`).  I'm also given a target duration, `x`.\n*   **The Constraints:** The vouchers need to be non-overlapping (meaning they don't share any days).  Their durations must add up to `x`.  My objective is to find the pair with the lowest combined cost. If no such pair exists, the output should be -1.\n*   **The Goal:** Find two vouchers (i, j) that meet the non-overlapping condition, the sum of their duration (`x`) and minimize the total cost (`cost_i + cost_j`).\n\nAlright, let's analyze this.  The constraints on `n` and `x` (up to 2 * 10^5) are important. They clearly point toward a solution that's better than O(N^2) – something like O(N log N) or ideally O(N).  The ranges of `l`, `r`, and `cost` also have implications. Large values of `cost` mean I'll have to use 64-bit integers.\n\nMy first thought is the brute-force approach: iterating through all possible pairs of vouchers.  However, this O(N^2) solution is way too slow for the problem constraints. I need to be smarter.\n\nThe core challenge seems to be efficiently finding the second voucher (`j`) for a given first voucher (`i`). I can define the duration of voucher `i` as `d_i = ri - li + 1`. So, for a given `i`, I'm searching for a `j` where `d_j = x - d_i`. The disjoint condition then has to be met which is either `ri < lj` or `rj < li`.\n\nThis is where things get a bit tricky. I need a faster way to search for these `j` vouchers that satisfy both duration and non-overlapping constraints.  I'm still thinking about how to optimize the search process beyond a simple nested loop, maybe using a data structure or sorting to improve the lookup time. I need an efficient way to find that matching `j` for each `i`. This is the crux of the problem.\n",
    "response": "The problem asks us to find two non-overlapping vouchers `i` and `j` such that the sum of their durations `(ri - li + 1) + (rj - lj + 1)` equals a given value `x`, and their total cost `costi + costj` is minimized. If no such pair exists, we should print -1.\n\nLet `d_k = rk - lk + 1` be the duration of voucher `k`. We are looking for two vouchers `i` and `j` such that `d_i + d_j = x`.\nTwo vouchers `i` and `j` are non-overlapping if `ri < lj` or `rj < li`.\n\nA brute-force approach of checking all `N*(N-1)/2` pairs of vouchers would be `O(N^2)`, which is too slow for `N = 2 * 10^5`. We need a more efficient approach, likely `O(N log N)` or `O(N)`.\n\nThe key idea is to iterate through each voucher `i` and efficiently find the best possible second voucher `j`.\n\nLet's categorize the vouchers by their departure day `l` and arrival day `r`. The maximum value for `l` and `r` is `2 * 10^5`. Let's denote this maximum day as `MAX_DAY = 2 * 10^5`.\n\nWe can maintain information about the minimum cost of a voucher that ends at a certain day `r` and has a specific duration.\nSince we need to find `d_j = x - d_i`, we can iterate through all possible durations `d_i` from `1` to `x-1`.\nFor a fixed `d_i`, we need `d_j = x - d_i`.\n\nConsider processing vouchers in a specific order. Let's sort the vouchers by their departure day `l`.\nWhen we process a voucher `i`, we are looking for a voucher `j` such that:\n1.  `d_j = x - d_i`\n2.  `cost_j` is minimal.\n3.  They don't intersect. This means either `ri < lj` or `rj < li`.\n\nThe condition `rj < li` is easier to handle if we process vouchers sorted by `li`.\nWhen we are at voucher `i` (which starts at `li`), any voucher `j` we have already processed (i.e., `lj <= li`) could potentially satisfy `rj < li`.\n\nLet's refine this:\nWe want to find `min(cost_i + cost_j)` such that `d_i + d_j = x` and `(ri < lj)` or `(rj < li)`.\nThe maximum duration of a single voucher is `MAX_DAY`. So `d_i` can range from `1` to `MAX_DAY`.\nThe target duration `x` can also be up to `MAX_DAY`.\n\nWe can iterate through all possible departure days `day` from `1` to `MAX_DAY`.\nFor each `day`, we can consider two types of operations:\n1.  **Vouchers ending on `day - 1`**: These vouchers `k` (`rk = day - 1`) become available to be paired with any future voucher `i` that starts at `li >= day`.\n2.  **Vouchers starting on `day`**: These vouchers `i` (`li = day`) can be paired with any previously available voucher `k` that ended on `rk < day`.\n\nLet's maintain an array (or dictionary) `min_cost_for_duration[duration]` which stores the minimum cost of a voucher with that `duration` *that has already been processed and is available to be paired*.\nThe \"available\" condition is crucial. A voucher `k` is available to be paired with voucher `i` (which starts at `li`) if `rk < li`.\n\nLet's use an array `min_cost_ending_before[duration][day]` to store the minimum cost of a voucher with `duration` that ends before `day`. This would be too large.\nInstead, we can iterate through the days `d` from `1` to `MAX_DAY`.\nFor each `day`:\n1.  **Update minimum costs for durations**: For all vouchers `k` that *end* on `day - 1` (i.e., `rk = day - 1`), their costs become relevant for future vouchers `i` that start at `li >= day`. We need to update a data structure that stores `min_cost_for_duration[duration]` for such vouchers.\n    Let `min_cost_duration[duration]` be the minimum cost of a voucher `k` with `d_k = duration` that has `rk < current_day`.\n    When we are at `current_day`, we iterate through all vouchers `k` with `rk = current_day - 1`. For each such voucher, we update `min_cost_duration[d_k] = min(min_cost_duration[d_k], cost_k)`.\n2.  **Process vouchers starting on `day`**: For each voucher `i` that *starts* on `day` (i.e., `li = day`):\n    *   Calculate its duration `d_i = ri - li + 1`.\n    *   Calculate the required duration for the second voucher `d_j = x - d_i`.\n    *   If `d_j > 0` and `d_j <= MAX_DAY`, check `min_cost_duration[d_j]`. If `min_cost_duration[d_j]` is not infinity, then we have found a potential pair. The total cost would be `cost_i + min_cost_duration[d_j]`. Update the overall minimum answer.\n\nThis approach ensures that `rj < li` (the second part of the non-intersection condition) is satisfied, because `min_cost_duration` only considers vouchers that ended before the current `li`.\n\nLet's organize the vouchers:\nStore vouchers in two lists: `vouchers_by_start_day[day]` and `vouchers_by_end_day[day]`.\n`vouchers_by_start_day[day]` will contain `(r, cost, duration)` for vouchers starting on `day`.\n`vouchers_by_end_day[day]` will contain `(l, cost, duration)` for vouchers ending on `day`.\n\nInitialize `min_total_cost = infinity`.\nInitialize `min_cost_for_duration[d]` to infinity for all `d` from `1` to `MAX_DAY`. This array will store the minimum cost of a voucher with duration `d` that has *already finished* (i.e., `r < current_day`).\n\nIterate `current_day` from `1` to `MAX_DAY`:\n\n1.  **Process vouchers ending on `current_day - 1`**:\n    For each voucher `(l, cost, duration)` in `vouchers_by_end_day[current_day - 1]`:\n    `min_cost_for_duration[duration] = min(min_cost_for_duration[duration], cost)`\n    This updates the minimum cost for a voucher of `duration` that has finished by `current_day - 1`.\n\n2.  **Process vouchers starting on `current_day`**:\n    For each voucher `(r, cost, duration)` in `vouchers_by_start_day[current_day]`:\n    Let `d_i = duration`.\n    Let `d_j_required = x - d_i`.\n    If `1 <= d_j_required <= MAX_DAY` and `min_cost_for_duration[d_j_required]` is not infinity:\n        `min_total_cost = min(min_total_cost, cost + min_cost_for_duration[d_j_required])`\n\nAfter iterating through all `current_day` values, if `min_total_cost` is still infinity, it means no valid pair was found. Otherwise, `min_total_cost` holds the answer.\n\n**Data Structures**:\n*   `vouchers_by_start_day`: A list of lists (or `defaultdict(list)`). `vouchers_by_start_day[day]` stores `(r, cost, duration)` tuples. Max index `MAX_DAY`.\n*   `vouchers_by_end_day`: Same structure. `vouchers_by_end_day[day]` stores `(l, cost, duration)` tuples. Max index `MAX_DAY`.\n*   `min_cost_for_duration`: A list (or array) of size `MAX_DAY + 1`. `min_cost_for_duration[d]` stores minimum cost. Initialize with a large value (e.g., `2 * 10^9 + 7` as costs are up to `10^9`).\n\n**Maximum values**:\n`MAX_DAY = 2 * 10^5`.\n`x` up to `2 * 10^5`.\n`duration` up to `2 * 10^5`.\n\n**Complexity**:\n*   **Initialization**: `O(MAX_DAY)` for `min_cost_for_duration`.\n*   **Populating `vouchers_by_start_day` and `vouchers_by_end_day`**: `O(N)` for reading input and appending.\n*   **Main Loop**: Iterates `MAX_DAY` times.\n    *   Inside the loop, `vouchers_by_end_day[current_day - 1]` and `vouchers_by_start_day[current_day]` are iterated. The total number of `(r, cost, duration)` or `(l, cost, duration)` tuples across all days is `N`. So, the total work for these inner loops over all `current_day` is `O(N)`.\n*   **Total Time Complexity**: `O(N + MAX_DAY)`. Given `N, MAX_DAY <= 2 * 10^5`, this is efficient enough.\n*   **Space Complexity**: `O(N + MAX_DAY)` for storing vouchers and `min_cost_for_duration`.\n\n**Edge Cases**:\n*   No two vouchers satisfy the conditions: `min_total_cost` remains `infinity`, print -1.\n*   `x` is very small: `d_j_required` might be 0 or negative. The `1 <= d_j_required <= MAX_DAY` check handles this.\n*   `x` is very large: `d_j_required` might exceed `MAX_DAY`. The `1 <= d_j_required <= MAX_DAY` check handles this.\n\nLet's use `float('inf')` for infinity and `2 * 10**5 + 1` for `MAX_DAY_COORD` to be safe.\n\n```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n\n    # Max coordinate for day (r, l) is 2 * 10^5\n    # Max duration is also 2 * 10^5\n    MAX_COORD = 2 * 10**5 + 1 # Use 1-based indexing for days\n\n    # vouchers_by_start_day[day] stores a list of (r, cost, duration) for vouchers starting on 'day'\n    vouchers_by_start_day = [[] for _ in range(MAX_COORD)]\n    # vouchers_by_end_day[day] stores a list of (l, cost, duration) for vouchers ending on 'day'\n    vouchers_by_end_day = [[] for _ in range(MAX_COORD)]\n\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        duration = r - l + 1\n        vouchers_by_start_day[l].append((r, cost, duration))\n        vouchers_by_end_day[r].append((l, cost, duration))\n\n    # min_cost_for_duration[d] stores the minimum cost of a voucher with duration 'd'\n    # that has already finished (i.e., its 'r' is less than the current processing day).\n    min_cost_for_duration = [float('inf')] * (MAX_COORD + 1)\n\n    min_total_cost = float('inf')\n\n    # Iterate through each possible day from 1 to MAX_COORD\n    for current_day in range(1, MAX_COORD):\n        # Step 1: Update min_cost_for_duration for vouchers that end on current_day - 1\n        # These vouchers are now \"available\" to be paired with any voucher starting on or after current_day.\n        # We only care about vouchers that finished strictly before current_day, so we use current_day - 1.\n        if current_day > 1: # Only process if current_day - 1 is a valid day\n            for l_prev, cost_prev, duration_prev in vouchers_by_end_day[current_day - 1]:\n                min_cost_for_duration[duration_prev] = min(min_cost_for_duration[duration_prev], cost_prev)\n\n        # Step 2: Process vouchers that start on current_day\n        # For each such voucher, try to find a suitable preceding voucher.\n        for r_curr, cost_curr, duration_curr in vouchers_by_start_day[current_day]:\n            remaining_duration_needed = x - duration_curr\n            \n            # Check if the needed duration is valid and within bounds\n            if 1 <= remaining_duration_needed <= MAX_COORD:\n                # If there's an available voucher with the required duration\n                if min_cost_for_duration[remaining_duration_needed] != float('inf'):\n                    # The current voucher (starts on current_day) and the found voucher (ended before current_day)\n                    # are guaranteed to be non-overlapping.\n                    current_pair_cost = cost_curr + min_cost_for_duration[remaining_duration_needed]\n                    min_total_cost = min(min_total_cost, current_pair_cost)\n\n    if min_total_cost == float('inf'):\n        print(-1)\n    else:\n        print(min_total_cost)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n\n    # Max coordinate for day (r, l) is 2 * 10^5\n    # Max duration is also 2 * 10^5\n    MAX_COORD = 2 * 10**5 + 1 # Use 1-based indexing for days\n\n    # vouchers_by_start_day[day] stores a list of (r, cost, duration) for vouchers starting on 'day'\n    vouchers_by_start_day = [[] for _ in range(MAX_COORD)]\n    # vouchers_by_end_day[day] stores a list of (l, cost, duration) for vouchers ending on 'day'\n    vouchers_by_end_day = [[] for _ in range(MAX_COORD)]\n\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        duration = r - l + 1\n        vouchers_by_start_day[l].append((r, cost, duration))\n        vouchers_by_end_day[r].append((l, cost, duration))\n\n    # min_cost_for_duration[d] stores the minimum cost of a voucher with duration 'd'\n    # that has already finished (i.e., its 'r' is less than the current processing day).\n    min_cost_for_duration = [float('inf')] * (MAX_COORD + 1)\n\n    min_total_cost = float('inf')\n\n    # Iterate through each possible day from 1 to MAX_COORD\n    for current_day in range(1, MAX_COORD):\n        # Step 1: Update min_cost_for_duration for vouchers that end on current_day - 1\n        # These vouchers are now \"available\" to be paired with any voucher starting on or after current_day.\n        # We only care about vouchers that finished strictly before current_day, so we use current_day - 1.\n        if current_day > 1: # Only process if current_day - 1 is a valid day\n            for l_prev, cost_prev, duration_prev in vouchers_by_end_day[current_day - 1]:\n                min_cost_for_duration[duration_prev] = min(min_cost_for_duration[duration_prev], cost_prev)\n\n        # Step 2: Process vouchers that start on current_day\n        # For each such voucher, try to find a suitable preceding voucher.\n        for r_curr, cost_curr, duration_curr in vouchers_by_start_day[current_day]:\n            remaining_duration_needed = x - duration_curr\n            \n            # Check if the needed duration is valid and within bounds\n            if 1 <= remaining_duration_needed <= MAX_COORD:\n                # If there's an available voucher with the required duration\n                if min_cost_for_duration[remaining_duration_needed] != float('inf'):\n                    # The current voucher (starts on current_day) and the found voucher (ended before current_day)\n                    # are guaranteed to be non-overlapping.\n                    current_pair_cost = cost_curr + min_cost_for_duration[remaining_duration_needed]\n                    min_total_cost = min(min_total_cost, current_pair_cost)\n\n    if min_total_cost == float('inf'):\n        print(-1)\n    else:\n        print(min_total_cost)\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 798,
        "completion_token_count": 3263,
        "thoughts_token_count": 773
    }
}