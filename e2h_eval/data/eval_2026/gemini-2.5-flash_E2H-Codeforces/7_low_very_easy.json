{
    "start": 1758009316.7004724,
    "end": 1758009366.9951289,
    "start-formatted": "2025-09-16 16:55 KST",
    "end-formatted": "2025-09-16 16:56 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "**Breaking Down the Snowflake Graph Problem**\n\nOkay, so I'm being asked to figure out if a given number `n` could represent the number of vertices in a special type of graph called a \"snowflake graph.\" My first thought is to understand how these graphs are built. It's about a central vertex, then connecting it to `k` more vertices, and then recursively connecting each \"leaf\" node to `k` *more* nodes. This recursive connection happens at least once.\n\nLet's use a variable `d` to represent how many times we perform this recursive connection step. The problem explicitly says `d` has to be at least 1.\n\nI started to write out the vertex counts:\n*   Initial state: 1 (the center).\n*   Add `k` nodes, now the total is `1 + k`.\n*   Then add `k * k` more leaves: `1 + k + k^2`.\n*   If we repeat this process `d` times, it quickly becomes a geometric series. After thinking about this, I realize the total vertices will be the sum of a geometric series: `1 + k + k^2 + ... + k^m`, where `m = d + 1`. This sum is equal to `(k^(m+1) - 1) / (k - 1)`.\n\nSo, the core of the problem is determining if I can find integers `k > 1` and `m >= 2` such that `n = (k^(m+1) - 1) / (k - 1)`. This can be rearranged as `n = 1 + k + k^2 + ... + k^m` for integer values `k > 1` and `m >= 2`.\n\nNow, considering the constraints, `n` is up to 10^18. I'll need an efficient way to check if an `n` can be expressed in this form, given that k > 1 and m >= 2.\n\nLet me think of a simple first scenario. If I start with the simplest case where m = 2, then `n = 1 + k + k^2`. I can solve for k. Doing the algebra, using the quadratic formula, `k = (-1 ± sqrt(4n - 3)) / 2`.\nThis means finding if n is a \"snowflake number\" when `m = 2` boils down to checking if `4n - 3` is a perfect square and whether the resulting `k` is an integer and is > 1. This gives me a starting point for developing an algorithm.\n",
    "response": "The problem asks us to determine if a given integer `n` can be the number of vertices in a \"snowflake\" graph. A snowflake graph is constructed as follows:\n1. Start with 1 central vertex.\n2. Connect the central vertex to `k` new vertices, where `k > 1`.\n3. Each vertex that is connected to only one other vertex (i.e., a leaf node) is connected to `k` more new vertices. This step must be performed at least once.\n\nLet's analyze the number of vertices:\n- Initially, there is 1 central vertex.\n- Step 2 adds `k` vertices. Total vertices: `1 + k`. These `k` vertices are leaves.\n- Step 3 is performed `d` times, where `d >= 1`.\n  - After the 1st time Step 3 is performed: Each of the `k` leaves from the previous step connects to `k` new vertices. So, `k * k = k^2` new vertices are added. Total vertices: `1 + k + k^2`. These `k^2` vertices are now leaves.\n  - After the 2nd time Step 3 is performed: Each of the `k^2` leaves from the previous step connects to `k` new vertices. So, `k^2 * k = k^3` new vertices are added. Total vertices: `1 + k + k^2 + k^3`. These `k^3` vertices are now leaves.\n  - In general, after Step 3 is performed `d` times: The total number of vertices will be `1 + k + k^2 + ... + k^(d+1)`.\n\nLet `m = d+1`. Since `d >= 1`, we have `m >= 2`.\nThe total number of vertices `n` can be expressed as the sum of a geometric series:\n`n = 1 + k + k^2 + ... + k^m`\nThis sum can be written as `n = (k^(m+1) - 1) / (k - 1)`.\n\nWe need to check if for a given `n` (`1 <= n <= 10^18`), there exist integers `k > 1` and `m >= 2` satisfying this equation.\n\nLet's consider two main cases for `m`:\n\n**Case 1: `m = 2`**\nIf `m = 2`, then `n = 1 + k + k^2`.\nThis is a quadratic equation in `k`: `k^2 + k + (1 - n) = 0`.\nUsing the quadratic formula, `k = (-1 ± sqrt(1 - 4(1 - n))) / 2 = (-1 ± sqrt(4n - 3)) / 2`.\nFor `k` to be a valid integer greater than 1:\n1. `4n - 3` must be a perfect square. Let `4n - 3 = S^2` for some integer `S`.\n2. `S` must be positive.\n3. `k = (-1 + S) / 2` must be an integer greater than 1.\n   This means `S - 1` must be an even number greater than 2, so `S` must be an odd number greater than 3.\n   If `S` is odd, `S-1` is even, so `k` is an integer.\n   If `S > 3`, then `S-1 > 2`, so `k > 1`.\n   \nWe can check this by calculating `S = sqrt(4n - 3)`. If `S` is an integer, `S` is odd, and `S > 3`, then `n` is a valid snowflake number.\n\n**Case 2: `m >= 3`**\nIf `m >= 3`, then `n = 1 + k + k^2 + ... + k^m`.\nSince `k > 1`, we have `k^m < n`. This implies `k < n^(1/m)`.\nSince `m >= 3`, `k < n^(1/3)`.\nFor `n = 10^18`, `k < (10^18)^(1/3) = 10^6`.\nThis suggests that `k` can be iterated up to `10^6`.\n\nFor each `k` from `2` up to `10^6`:\nWe need to find if there exists an `m >= 3` such that `n = (k^(m+1) - 1) / (k - 1)`.\nRearranging the equation: `n * (k - 1) = k^(m+1) - 1`.\nSo, `k^(m+1) = n * (k - 1) + 1`.\nLet `target = n * (k - 1) + 1`. We need to check if `target` is a perfect power of `k`, specifically `k^(m+1)` for some `m >= 3`.\nThis means `target` must be `k^p` for some exponent `p = m+1 >= 4`.\nWe can find `p` by taking the `k`-th root of `target`, i.e., `p = log_k(target)`.\nSince `k` can be up to `10^6`, `k^p` can quickly exceed `10^18`.\nFor `k=2`, `2^p <= 10^18` implies `p <= log2(10^18) approx 18 * log2(10) approx 18 * 3.32 approx 59.79`. So `p` can be up to `59`.\nFor `k=10^6`, `(10^6)^p <= 10^18` implies `6p <= 18`, so `p <= 3`. However, we need `p >= 4` for `m >= 3`. So for `k=10^6`, there is no `m >= 3`.\nThe maximum `p` decreases as `k` increases. For `k=10^5`, `p <= 3.6`, so `p=3` is not enough.\nThe maximum `k` for which `m >= 3` (i.e., `p >= 4`) is possible is when `k^4 <= 10^18`, so `k <= (10^18)^(1/4) = 10^(4.5) approx 31622`.\nSo we only need to iterate `k` from `2` up to approximately `31622`.\n\nFor each `k` in this range:\nCalculate `target = n * (k - 1) + 1`.\nCheck if `target` is a perfect power of `k` with exponent `p >= 4`.\nWe can do this by iteratively multiplying `k` by itself: `cur_power = k`.\n`cur_power = k`\n`cur_power = k*k`\n`cur_power = k*k*k`\n...\nKeep multiplying `cur_power` by `k` and check if it equals `target`. Be careful to handle potential overflow if `cur_power` exceeds `10^18`.\nA more robust way is to use binary search for `p` or just `pow(k, p)` and check for equality.\nSince `p` is relatively small, we can iterate `p` from `4` upwards.\n`cur_val = k`\n`p_val = 1`\nWhile `cur_val < target / k` (to prevent overflow before multiplication) and `p_val <= 60`:\n  `cur_val *= k`\n  `p_val += 1`\nIf `cur_val == target` and `p_val >= 4`, then we found a valid `k` and `m=p_val-1`.\n\n**Edge Cases and Small `n`:**\n- `n=1`: `1 = (k^(m+1)-1)/(k-1)`. If `m=2`, `1 = 1+k+k^2` which is impossible for `k>1`. If `m>=3`, `1 = 1+k+...+k^m` which is also impossible. So `n=1` is \"NO\".\n- `n=2`: `2 = 1+k+k^2...`. Impossible for `k>1`. So `n=2` is \"NO\".\n- `n=3`: `3 = 1+k+k^2...`. Impossible for `k>1`. So `n=3` is \"NO\".\n- `n=6`: `6 = 1+k+k^2`. `k^2+k-5=0`. `D = 1-4(-5)=21` not a square.\n           `6 = 1+k+k^2+k^3...`. No `k>=2` works. `k=2` implies `1+2+4=7 > 6`. So `n=6` is \"NO\".\n\n**Combined Strategy:**\n1. Handle small `n` values that are known to be \"NO\" (e.g., `n < 7`). Based on examples, `n=1,2,3,6` are NO.\n2. Check Case 1: `m = 2`.\n   Calculate `val = 4n - 3`.\n   Check if `val` is a perfect square. Let `S = int(sqrt(val))`.\n   If `S*S == val` and `S` is odd and `S > 3` (which ensures `k = (S-1)/2 > 1`), then `n` is a \"YES\".\n3. Check Case 2: `m >= 3`.\n   Iterate `k` from `2` up to `31622` (or `int(n**(1/4)) + 2` to be safe, max `31624` for `10^18`).\n   For each `k`:\n     Calculate `target = n * (k - 1) + 1`.\n     If `target` is too large (e.g., `target / (k-1)` would overflow `n` or `target` itself overflows `10^18`), skip `k`.\n     We need to check if `target` is `k^p` for some `p >= 4`.\n     A simple way is to calculate `p_root = round(target**(1/p))` for `p=4,5,...` up to `log_k(10^18)`.\n     Or, use `log(target, k)` to find `p`.\n     A more robust way:\n     `current_power_of_k = 1`\n     `exponent = 0`\n     While `current_power_of_k <= target / k` (to avoid overflow during multiplication) and `exponent <= 60`:\n       `current_power_of_k *= k`\n       `exponent += 1`\n     If `current_power_of_k == target` and `exponent >= 4`, then `n` is a \"YES\".\n     (Note: `exponent` here is `m+1`, so `m = exponent - 1`. `m >= 3` implies `exponent >= 4`).\n\nIf neither case yields a \"YES\", then `n` is a \"NO\".\n\n```python\nimport math\n\ndef solve():\n    n = int(input())\n\n    # Case 1: m = 2, n = 1 + k + k^2\n    # k^2 + k + (1 - n) = 0\n    # Discriminant D = 1 - 4(1 - n) = 4n - 3\n    # k = (-1 + sqrt(4n - 3)) / 2\n    \n    # Check if 4n - 3 is a perfect square\n    val_for_k2 = 4 * n - 3\n    if val_for_k2 >= 0:\n        s = int(math.isqrt(val_for_k2)) # isqrt is for integer square root\n        if s * s == val_for_k2:\n            # For k to be an integer, s must be odd.\n            # For k > 1, (-1 + s) / 2 > 1 => -1 + s > 2 => s > 3.\n            if (s % 2 == 1) and (s > 3):\n                print(\"YES\")\n                return\n\n    # Case 2: m >= 3, n = 1 + k + k^2 + ... + k^m\n    # n = (k^(m+1) - 1) / (k - 1)\n    # k^(m+1) = n * (k - 1) + 1\n    # Since m >= 3, the exponent (m+1) >= 4.\n    # Also, k^m < n, so k < n^(1/m).\n    # For m=3, k < n^(1/3). For m=4, k < n^(1/4).\n    # Max n = 10^18. If m=4, k < (10^18)^(1/4) = 10^4.5 approx 31622.\n    # If m=3, k < (10^18)^(1/3) = 10^6.\n    # So k can go up to 10^6. The upper bound for iterating k is approximately 10^6.\n    # The exponent p = m+1. For k=2, 2^p <= 10^18 => p <= log2(10^18) approx 59.79.\n    # So max p is around 60.\n\n    # Iterate k from 2 up to a reasonable limit.\n    # If k^4 > n, then for m >= 3 (i.e. m+1 >= 4), k^(m+1) > n.\n    # So we only need to check k such that k^4 <= n.\n    # k <= n^(1/4). For n=10^18, k <= 31622.\n    # We can iterate k up to 10^6 because n^(1/3) is the looser bound.\n    # However, for larger k, the exponent p = m+1 becomes smaller.\n    # For k=10^6, k^(m+1) <= 10^18 implies (m+1) <= 3. But we need m+1 >= 4.\n    # So the effective upper bound for k is indeed around 31622.\n    \n    # Let's set a slightly generous upper bound for k to be safe.\n    # Max k for m=3 is 10^6. Max k for m=4 is 31622.\n    # Max k for m=5 is 10^3.6 = 3981.\n    # Max k for m=6 is 10^3 = 1000.\n    # Max k for m=18 is 10^1 = 10.\n    # So k can be iterated up to 10^6.\n    \n    # The loop for k only needs to go up to roughly n^(1/3) which is 10^6 for n=10^18.\n    # For k > 10^6, k^3 already exceeds 10^18.\n    # So if n = 1 + k + k^2 + k^3 + ... + k^m, then k^m < n.\n    # If m >= 3, then k^3 < n, so k < n^(1/3).\n    # For n=10^18, k < 10^6.\n    \n    # Iterate k from 2 up to 10^6.\n    for k in range(2, 10**6 + 1):\n        # We need to find if n = 1 + k + ... + k^m for some m >= 3\n        # This is equivalent to checking if n * (k-1) + 1 is a perfect power of k, say k^p, where p >= 4.\n        \n        # Calculate target = n * (k - 1) + 1\n        # Check for potential overflow before multiplication if k-1 is large\n        if k - 1 > (10**18 - 1) // n: # check if n * (k-1) + 1 would exceed 10^18\n            continue # If n * (k-1) itself would exceed 10^18, no need to check further for this k\n        \n        target = n * (k - 1) + 1\n\n        # Now check if target is k^p for p >= 4\n        # We can find p by taking the p-th root of target.\n        # Or, we can iterate p. Max p is around 60.\n        \n        # Calculate k^p iteratively\n        current_k_power = k\n        exponent = 1 # current_k_power is k^exponent\n        \n        while True:\n            # Check for overflow before multiplying current_k_power by k\n            if current_k_power > target // k: # current_k_power * k would exceed target\n                break\n            \n            current_k_power *= k\n            exponent += 1\n            \n            if current_k_power == target:\n                # We found target = k^exponent\n                # We need m >= 3, which means exponent = m+1 >= 4\n                if exponent >= 4:\n                    print(\"YES\")\n                    return\n                else: # exponent is 1, 2, or 3. Not enough for m >= 3.\n                    break # No need to continue for this k, as higher powers will be even larger.\n            \n            # If current_k_power exceeds target, it means target is not a perfect power of k\n            if current_k_power > target:\n                break\n            \n            # Optimization: if exponent gets too large (e.g., > 60 for k=2), break\n            # For k=2, 2^60 is already > 10^18.\n            # No need to check for very large exponents.\n            if exponent > 60: \n                break # target is not a power of k up to a reasonable exponent\n\n    print(\"NO\")\n\nnum_test_cases = int(input())\nfor _ in range(num_test_cases):\n    solve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef solve():\n    n = int(input())\n\n    # Case 1: m = 2, n = 1 + k + k^2\n    # k^2 + k + (1 - n) = 0\n    # Discriminant D = 1 - 4(1 - n) = 4n - 3\n    # k = (-1 + sqrt(4n - 3)) / 2\n    \n    # Check if 4n - 3 is a perfect square\n    val_for_k2 = 4 * n - 3\n    if val_for_k2 >= 0:\n        s = int(math.isqrt(val_for_k2)) # isqrt is for integer square root\n        if s * s == val_for_k2:\n            # For k to be an integer, s must be odd.\n            # For k > 1, (-1 + s) / 2 > 1 => -1 + s > 2 => s > 3.\n            if (s % 2 == 1) and (s > 3):\n                print(\"YES\")\n                return\n\n    # Case 2: m >= 3, n = 1 + k + k^2 + ... + k^m\n    # n = (k^(m+1) - 1) / (k - 1)\n    # k^(m+1) = n * (k - 1) + 1\n    # Since m >= 3, the exponent (m+1) >= 4.\n    # Also, k^m < n, so k < n^(1/m).\n    # For m=3, k < n^(1/3). For m=4, k < n^(1/4).\n    # Max n = 10^18. If m=4, k < (10^18)^(1/4) = 10^4.5 approx 31622.\n    # If m=3, k < (10^18)^(1/3) = 10^6.\n    # So k can go up to 10^6. The upper bound for iterating k is approximately 10^6.\n    # The exponent p = m+1. For k=2, 2^p <= 10^18 => p <= log2(10^18) approx 59.79.\n    # So max p is around 60.\n\n    # Iterate k from 2 up to a reasonable limit.\n    # If k^4 > n, then for m >= 3 (i.e. m+1 >= 4), k^(m+1) > n.\n    # So we only need to check k such that k^4 <= n.\n    # k <= n^(1/4). For n=10^18, k <= 31622.\n    # We can iterate k up to 10^6 because n^(1/3) is the looser bound.\n    # However, for larger k, the exponent p = m+1 becomes smaller.\n    # For k=10^6, k^(m+1) <= 10^18 implies (m+1) <= 3. But we need m+1 >= 4.\n    # So the effective upper bound for k is indeed around 31622.\n    \n    # Let's set a slightly generous upper bound for k to be safe.\n    # Max k for m=3 is 10^6. Max k for m=4 is 31622.\n    # Max k for m=5 is 10^3.6 = 3981.\n    # Max k for m=6 is 10^3 = 1000.\n    # Max k for m=18 is 10^1 = 10.\n    # So k can be iterated up to 10^6.\n    \n    # The loop for k only needs to go up to roughly n^(1/3) which is 10^6 for n=10^18.\n    # For k > 10^6, k^3 already exceeds 10^18.\n    # So if n = 1 + k + k^2 + k^3 + ... + k^m, then k^m < n.\n    # If m >= 3, then k^3 < n, so k < n^(1/3).\n    # For n=10^18, k < 10^6.\n    \n    # Iterate k from 2 up to 10^6.\n    for k in range(2, 10**6 + 1):\n        # We need to find if n = 1 + k + ... + k^m for some m >= 3\n        # This is equivalent to checking if n * (k-1) + 1 is a perfect power of k, say k^p, where p >= 4.\n        \n        # Calculate target = n * (k - 1) + 1\n        # Check for potential overflow before multiplication if k-1 is large\n        if k - 1 > (10**18 - 1) // n: # check if n * (k-1) + 1 would exceed 10^18\n            continue # If n * (k-1) itself would exceed 10^18, no need to check further for this k\n        \n        target = n * (k - 1) + 1\n\n        # Now check if target is k^p for p >= 4\n        # We can find p by taking the p-th root of target.\n        # Or, we can iterate p. Max p is around 60.\n        \n        # Calculate k^p iteratively\n        current_k_power = k\n        exponent = 1 # current_k_power is k^exponent\n        \n        while True:\n            # Check for overflow before multiplying current_k_power by k\n            if current_k_power > target // k: # current_k_power * k would exceed target\n                break\n            \n            current_k_power *= k\n            exponent += 1\n            \n            if current_k_power == target:\n                # We found target = k^exponent\n                # We need m >= 3, which means exponent = m+1 >= 4\n                if exponent >= 4:\n                    print(\"YES\")\n                    return\n                else: # exponent is 1, 2, or 3. Not enough for m >= 3.\n                    break # No need to continue for this k, as higher powers will be even larger.\n            \n            # If current_k_power exceeds target, it means target is not a perfect power of k\n            if current_k_power > target:\n                break\n            \n            # Optimization: if exponent gets too large (e.g., > 60 for k=2), break\n            # For k=2, 2^60 is already > 10^18.\n            # No need to check for very large exponents.\n            if exponent > 60: \n                break # target is not a power of k up to a reasonable exponent\n\n    print(\"NO\")\n\nnum_test_cases = int(input())\nfor _ in range(num_test_cases):\n    solve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 569,
        "completion_token_count": 4294,
        "thoughts_token_count": 792
    }
}