{
    "start": 1758294851.0267022,
    "end": 1758294935.2531195,
    "start-formatted": "2025-09-20 00:14 KST",
    "end-formatted": "2025-09-20 00:15 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "**Analyzing the Competitive Programming Problem: Finding Minimum Edges for an Odd Cycle**\n\nAlright, let's dive into this graph problem. The core is figuring out the minimum number of edges, `t`, needed to transform a graph into one with an odd-length cycle, and then the number of ways, `w`, we can do it.\n\nMy first thought is always to exploit the relationship between odd cycles and graph bipartiteness. A graph contains an odd cycle *if and only if* it's not bipartite. So, the initial check is crucial. I'll use BFS or DFS to 2-color the graph. If I find an edge connecting vertices of the same color during the 2-coloring process within any component, it's a dead giveaway: `t = 0` (no additional edges needed), and `w` is simply 1 (the already-existing odd cycle).\n\nNow, if the entire graph *is* bipartite, the fun begins. We need to *introduce* an odd cycle. An odd cycle requires at least three vertices, so let's analyze `t=1`. To get an odd cycle with a single added edge, the two endpoints of the edge must be in the same connected component and have the *same* color. If this is possible, `t=1`. I'll count the number of such pairs for each component to determine the number of ways `w` to add an edge. This corresponds to `(cnt0 * (cnt0 - 1) / 2) + (cnt1 * (cnt1 - 1) / 2)` where `cnt0` and `cnt1` are the numbers of vertices of each color in each connected component and sum over all connected components.\n\nIf `t=1` isn't possible, it means every component has at most one vertex of each color (or is empty). That implies our graph has components with at most two vertices. In this situation, the next logical step is to consider `t=2`.\n\nWith `t=2`, we want to add two edges to create an odd cycle. If we add the edges `(u, v)` and `(v, w)`, where `u, v, w` are distinct, this is only possible if `u` and `w` are in the same component but have different colors. We will need an edge that connects a vertex to different vertices in different components. So `w` will need to connect with other components that only contain one node.\nLet `P_diff` be the sum of products of `cnt0` and `cnt1` across all components; if n>2. We can add to edge such that there is a path with even length connecting the endpoints. If one endpoint has isolated neighbors, we can form an odd-cycle.  Then `w = P_diff * (n - 2)`, where `n` is the number of vertices and `n-2` is the possible choice for a middle vertex.\n\nIf `n = 2` or there are no edges, it's still bipartite. `t=2` won't work that way. We'll need `t=3` for a cycle of length 3 (if `n` is at least 3), implying we have three separate components or isolated vertices. In the case where the input graph has *no* edges, `t` must be 3, with `w` equal to `n choose 3` (n*(n-1)*(n-2)/6) as we can add any cycle to the graph.\n\nIn summary, this requires carefully checking graph bipartiteness, calculating color counts for each component, and analyzing the possible configurations of components to deduce `t` and `w` correctly.\n",
    "response": "The problem asks us to find the minimum number of edges `t` to add to a given undirected graph to form a simple cycle of odd length, and `w` the number of ways to do so. A simple cycle means each vertex occurs at most once.\n\nFirst, let's understand the properties of odd cycles. A graph contains an odd cycle if and only if it is not bipartite. A bipartite graph is one whose vertices can be divided into two disjoint sets, say U and V, such that every edge connects a vertex in U to one in V. This is equivalent to saying the graph can be 2-colored without any adjacent vertices having the same color.\n\nWe can determine if a graph is bipartite using Breadth-First Search (BFS) or Depth-First Search (DFS). We iterate through all connected components of the graph. For each unvisited vertex, we start a traversal, assigning it color 0. All its neighbors are assigned color 1, their unvisited neighbors color 0, and so on. If we ever encounter an edge connecting two vertices of the same color, we have found an odd cycle.\n\nLet's break down the problem into cases based on the minimum number of edges `t` to add:\n\n**Case 0: `t = 0` (An odd cycle already exists)**\nIf, during our 2-coloring process, we find an edge connecting two vertices of the same color, it means the graph already contains an odd cycle. In this scenario, no edges need to be added.\nOutput: `0 1` (1 way to \"form\" an odd cycle, which is to acknowledge the existing one).\n\n**Case 1: `t = 1` (Add one edge)**\nIf the graph is bipartite (i.e., no odd cycle was found in Case 0), we need to add at least one edge.\nAdding a single edge `(u, v)` will form an odd cycle if and only if:\n1. `u` and `v` are in the same connected component.\n2. `u` and `v` have the same color in the 2-coloring of that component.\n   (Because if they have the same color, the path between them in the original graph must have an even length. Adding an edge `(u,v)` closes this path, creating a cycle of length `even + 1 = odd`).\n\nTo count the number of ways (`w`) for `t=1`:\nFor each connected component, perform a 2-coloring. Count the number of vertices colored 0 (`cnt0`) and the number of vertices colored 1 (`cnt1`).\nThe number of ways to choose two vertices of the same color within this component is `cnt0 * (cnt0 - 1) / 2` (both color 0) plus `cnt1 * (cnt1 - 1) / 2` (both color 1).\nSum these counts over all connected components. This sum is `w`.\nIf `w > 0`, then `t=1`. Output: `1 w`.\n\n**Case 2: `t = 2` (Add two edges)**\nIf `t=0` and `t=1` are not possible, it means the graph is bipartite, and for every connected component `C_i`, `cnt0_i * (cnt0_i - 1) / 2 + cnt1_i * (cnt1_i - 1) / 2 = 0`. This implies that for every component, `cnt0_i < 2` and `cnt1_i < 2`. Therefore, each connected component has at most 2 vertices.\nFor example:\n- A single vertex component `{v}`: `cnt0=1, cnt1=0` (or vice versa).\n- A two-vertex component `{u,w}` with an edge `(u,w)`: `cnt0=1, cnt1=1`.\n\nIn this scenario, we need to add two edges. Consider adding edges `(u, v)` and `(v, w)`. This forms a path `u-v-w`. If `u` and `w` are already in the same connected component and have different colors, then there is an odd-length path `u-...-w` between them. Adding `(u,v)` and `(v,w)` forms a cycle `u-v-w-...-u` of length `1 + 1 + length(path(w,u)) = 2 + odd = odd`. This creates an odd cycle.\nFor this to work:\n1. `u` and `w` must be distinct vertices in the same connected component and have different colors.\n2. `v` must be a vertex distinct from `u` and `w`.\n\nSince `t=1` was not possible, all components have size at most 2. The only components that can provide `u` and `w` with different colors are those with an existing edge (e.g., `{u,w}` with edge `(u,w)`).\nThe number of such pairs `(u,w)` is simply the number of existing edges `m` in the graph. (Each edge `(u,w)` connects two vertices of different colors).\nThe number of choices for `v` is `n - 2` (any vertex except `u` and `w`).\nSo, the number of ways `w` for `t=2` is `m * (n - 2)`.\nThis is valid if `m > 0` and `n >= 3`.\nIf `m > 0` and `n >= 3`, then `t=2`. Output: `2 w`.\n\n**Case 3: `t = 3` (Add three edges)**\nIf `t=0, t=1, t=2` are not possible, it means:\n- The graph is bipartite.\n- All components have size at most 2.\n- `m = 0` (no edges in the graph). This means all vertices are isolated.\nIn this case, we must add three edges to form a minimal odd cycle (a triangle). We need to pick three distinct vertices `u, v, w` and add edges `(u,v), (v,w), (w,u)`.\nThis is possible if `n >= 3`.\nThe number of ways `w` is the number of ways to choose 3 distinct vertices from `n`, which is `n C 3 = n * (n-1) * (n-2) / 6`.\nIf `n >= 3`, then `t=3`. Output: `3 w`.\n\n**Summary of Algorithm:**\n\n1.  **Initialization**:\n    - `adj`: Adjacency list for the graph.\n    - `color`: Array to store colors (0 or 1) for each vertex, initialized to -1 (unvisited).\n    - `has_odd_cycle`: Boolean flag, initialized to `False`.\n    - `ways_t1`: Counter for `t=1` ways, initialized to 0.\n    - `num_nodes_in_component`: List to store `[cnt0, cnt1]` for each component.\n\n2.  **Iterate through vertices for BFS/DFS**:\n    For `i` from 1 to `n`:\n        If `color[i]` is -1 (vertex `i` is unvisited):\n            Start a BFS from `i`:\n                `q = deque([(i, 0)])`\n                `color[i] = 0`\n                `current_cnt0 = 1`, `current_cnt1 = 0`\n                While `q` is not empty:\n                    `u, c = q.popleft()`\n                    For each neighbor `v` of `u`:\n                        If `color[v]` is -1:\n                            `color[v] = 1 - c`\n                            If `1-c == 0`, `current_cnt0 += 1`\n                            Else `current_cnt1 += 1`\n                            `q.append((v, 1-c))`\n                        Else if `color[v] == c`:\n                            `has_odd_cycle = True`\n                            (No need to break, continue BFS to fully color component for `t=1` calculation, though `has_odd_cycle` means we'll exit early later).\n            `num_nodes_in_component.append([current_cnt0, current_cnt1])`\n\n3.  **Determine `t` and `w`**:\n    - If `has_odd_cycle` is `True`:\n        Print `0 1`.\n    - Else (`has_odd_cycle` is `False`, graph is bipartite):\n        For each `[cnt0, cnt1]` in `num_nodes_in_component`:\n            `ways_t1 += (cnt0 * (cnt0 - 1) // 2)`\n            `ways_t1 += (cnt1 * (cnt1 - 1) // 2)`\n        If `ways_t1 > 0`:\n            Print `1 ways_t1`.\n        Else (`ways_t1 == 0`):\n            This implies all components have `cnt0 < 2` and `cnt1 < 2` (i.e., components of size 1 or 2).\n            If `m > 0` and `n >= 3`:\n                `ways_t2 = m * (n - 2)`\n                Print `2 ways_t2`.\n            Else (`m == 0` or `n < 3`):\n                If `n >= 3`:\n                    `ways_t3 = n * (n - 1) * (n - 2) // 6`\n                    Print `3 ways_t3`.\n                Else (`n < 3`):\n                    A cycle of odd length must have at least 3 vertices. If `n < 3`, no such cycle can be formed. The problem statement guarantees `n >= 1`. The examples clarify that `n=3, m=0` gives `3 1`. For `n=1` or `n=2`, it's impossible. However, competitive programming problems usually imply that a solution exists for valid inputs, and `n=1,2` would be invalid for `t=3`. So we assume `n>=3` if we reach this point.\n\n**Example Walkthroughs:**\n\n1.  **Input:** `4 4 \\n 1 2 \\n 1 3 \\n 4 2 \\n 4 3`\n    - Adjacency list: `1:[2,3], 2:[1,4], 3:[1,4], 4:[2,3]`\n    - Start BFS from 1:\n        - `color[1]=0`\n        - `q = [(1,0)]`\n        - Pop `(1,0)`. Neighbors `2,3`.\n            - `color[2]=1`, `q.append((2,1))`\n            - `color[3]=1`, `q.append((3,1))`\n        - Pop `(2,1)`. Neighbors `1,4`.\n            - `color[1]` is 0, `c` is 1. Different colors. OK.\n            - `color[4]=0`, `q.append((4,0))`\n        - Pop `(3,1)`. Neighbors `1,4`.\n            - `color[1]` is 0, `c` is 1. Different colors. OK.\n            - `color[4]` is 0, `c` is 1. Different colors. OK.\n        - Pop `(4,0)`. Neighbors `2,3`.\n            - `color[2]` is 1, `c` is 0. Different colors. OK.\n            - `color[3]` is 1, `c` is 0. Different colors. OK.\n    - BFS finishes. No odd cycle found. Graph is bipartite.\n    - Component 1: `cnt0=2` (vertices 1,4), `cnt1=2` (vertices 2,3).\n    - `ways_t1 = (2*(2-1)//2) + (2*(2-1)//2) = 1 + 1 = 2`.\n    - `ways_t1 > 0`.\n    - Output: `1 2`.\n\n2.  **Input:** `3 3 \\n 1 2 \\n 2 3 \\n 3 1`\n    - Adjacency list: `1:[2,3], 2:[1,3], 3:[1,2]`\n    - Start BFS from 1:\n        - `color[1]=0`\n        - `q = [(1,0)]`\n        - Pop `(1,0)`. Neighbors `2,3`.\n            - `color[2]=1`, `q.append((2,1))`\n            - `color[3]=1`, `q.append((3,1))`\n        - Pop `(2,1)`. Neighbors `1,3`.\n            - `color[1]` is 0, `c` is 1. Different colors. OK.\n            - `color[3]` is 1, `c` is 1. **Same colors!** `has_odd_cycle = True`.\n    - `has_odd_cycle` is `True`.\n    - Output: `0 1`.\n\n3.  **Input:** `3 0`\n    - Adjacency list: empty.\n    - Start BFS from 1: `color[1]=0`. Component {1}: `cnt0=1, cnt1=0`.\n    - Start BFS from 2: `color[2]=0`. Component {2}: `cnt0=1, cnt1=0`.\n    - Start BFS from 3: `color[3]=0`. Component {3}: `cnt0=1, cnt1=0`.\n    - No odd cycle found. Graph is bipartite.\n    - `ways_t1`: For each component, `(1*(1-1)//2) + (0*(0-1)//2) = 0`. Total `ways_t1 = 0`.\n    - `ways_t1 == 0`.\n    - `m = 0`.\n    - `m == 0`.\n    - `n = 3 >= 3`.\n    - `ways_t3 = 3 * (3-1) * (3-2) // 6 = 3 * 2 * 1 // 6 = 1`.\n    - Output: `3 1`.\n\n```python\nimport sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    \n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n\n    color = [-1] * (n + 1) # -1: unvisited, 0: color 0, 1: color 1\n    has_odd_cycle = False\n    \n    # Store counts of color 0 and color 1 for each component\n    # This is needed for t=1 calculation\n    component_counts = [] \n\n    # Perform BFS for 2-coloring on all components\n    for i in range(1, n + 1):\n        if color[i] == -1: # If vertex i is unvisited, start a new BFS for a new component\n            q = deque()\n            q.append((i, 0)) # (vertex, color)\n            color[i] = 0\n            \n            current_cnt0 = 1\n            current_cnt1 = 0\n            \n            component_has_odd_cycle = False\n\n            while q:\n                u, c = q.popleft()\n\n                for v in adj[u]:\n                    if color[v] == -1: # Unvisited neighbor\n                        color[v] = 1 - c\n                        if 1 - c == 0:\n                            current_cnt0 += 1\n                        else:\n                            current_cnt1 += 1\n                        q.append((v, 1 - c))\n                    elif color[v] == c: # Neighbor has the same color, an odd cycle is found\n                        component_has_odd_cycle = True\n                        \n            if component_has_odd_cycle:\n                has_odd_cycle = True\n            \n            component_counts.append((current_cnt0, current_cnt1))\n\n    # Case 0: Odd cycle already exists\n    if has_odd_cycle:\n        print(\"0 1\")\n        return\n\n    # If no odd cycle exists, the graph is bipartite.\n    # Calculate ways for t=1\n    ways_t1 = 0\n    for cnt0, cnt1 in component_counts:\n        # Ways to choose 2 vertices of color 0 in this component\n        ways_t1 += (cnt0 * (cnt0 - 1)) // 2\n        # Ways to choose 2 vertices of color 1 in this component\n        ways_t1 += (cnt1 * (cnt1 - 1)) // 2\n    \n    if ways_t1 > 0:\n        print(f\"1 {ways_t1}\")\n        return\n\n    # If t=1 is not possible, it means all components have at most 1 vertex of each color.\n    # So, each component has size at most 2.\n    # For example, {v} (size 1), or {u,w} with edge (u,w) (size 2).\n    \n    # Case 2: Try to add 2 edges\n    # This involves picking two vertices u, w from the same component that have different colors\n    # (i.e., they are connected by an existing edge), and a third vertex v (any other vertex).\n    # Then add edges (u,v) and (v,w). This forms an odd cycle u-v-w-...-u.\n    # The number of pairs (u,w) with different colors connected by an edge is simply 'm'.\n    # The number of choices for 'v' is n-2 (any vertex not u or w).\n    \n    if m > 0 and n >= 3:\n        ways_t2 = m * (n - 2)\n        print(f\"2 {ways_t2}\")\n        return\n\n    # Case 3: Try to add 3 edges\n    # This means m=0 (no edges in the graph) or n < 3.\n    # If m=0, all vertices are isolated. We must form a triangle (cycle of length 3).\n    # This requires 3 distinct vertices.\n    if n >= 3:\n        ways_t3 = (n * (n - 1) * (n - 2)) // 6\n        print(f\"3 {ways_t3}\")\n        return\n    \n    # If n < 3, it's impossible to form an odd cycle (min length 3).\n    # Based on problem constraints and examples, this case should not be reached\n    # if a solution is expected. For n=1 or n=2, no odd cycle can be formed.\n    # However, for competitive programming, it's safer to assume valid inputs\n    # lead to one of the above cases.\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    \n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n\n    color = [-1] * (n + 1) # -1: unvisited, 0: color 0, 1: color 1\n    has_odd_cycle = False\n    \n    # Store counts of color 0 and color 1 for each component\n    # This is needed for t=1 calculation\n    component_counts = [] \n\n    # Perform BFS for 2-coloring on all components\n    for i in range(1, n + 1):\n        if color[i] == -1: # If vertex i is unvisited, start a new BFS for a new component\n            q = deque()\n            q.append((i, 0)) # (vertex, color)\n            color[i] = 0\n            \n            current_cnt0 = 1\n            current_cnt1 = 0\n            \n            component_has_odd_cycle = False\n\n            while q:\n                u, c = q.popleft()\n\n                for v in adj[u]:\n                    if color[v] == -1: # Unvisited neighbor\n                        color[v] = 1 - c\n                        if 1 - c == 0:\n                            current_cnt0 += 1\n                        else:\n                            current_cnt1 += 1\n                        q.append((v, 1 - c))\n                    elif color[v] == c: # Neighbor has the same color, an odd cycle is found\n                        component_has_odd_cycle = True\n                        \n            if component_has_odd_cycle:\n                has_odd_cycle = True\n            \n            component_counts.append((current_cnt0, current_cnt1))\n\n    # Case 0: Odd cycle already exists\n    if has_odd_cycle:\n        print(\"0 1\")\n        return\n\n    # If no odd cycle exists, the graph is bipartite.\n    # Calculate ways for t=1\n    ways_t1 = 0\n    for cnt0, cnt1 in component_counts:\n        # Ways to choose 2 vertices of color 0 in this component\n        ways_t1 += (cnt0 * (cnt0 - 1)) // 2\n        # Ways to choose 2 vertices of color 1 in this component\n        ways_t1 += (cnt1 * (cnt1 - 1)) // 2\n    \n    if ways_t1 > 0:\n        print(f\"1 {ways_t1}\")\n        return\n\n    # If t=1 is not possible, it means all components have at most 1 vertex of each color.\n    # So, each component has size at most 2.\n    # For example, {v} (size 1), or {u,w} with edge (u,w) (size 2).\n    \n    # Case 2: Try to add 2 edges\n    # This involves picking two vertices u, w from the same component that have different colors\n    # (i.e., they are connected by an existing edge), and a third vertex v (any other vertex).\n    # Then add edges (u,v) and (v,w). This forms an odd cycle u-v-w-...-u.\n    # The number of pairs (u,w) with different colors connected by an edge is simply 'm'.\n    # The number of choices for 'v' is n-2 (any vertex not u or w).\n    \n    if m > 0 and n >= 3:\n        ways_t2 = m * (n - 2)\n        print(f\"2 {ways_t2}\")\n        return\n\n    # Case 3: Try to add 3 edges\n    # This means m=0 (no edges in the graph) or n < 3.\n    # If m=0, all vertices are isolated. We must form a triangle (cycle of length 3).\n    # This requires 3 distinct vertices.\n    if n >= 3:\n        ways_t3 = (n * (n - 1) * (n - 2)) // 6\n        print(f\"3 {ways_t3}\")\n        return\n    \n    # If n < 3, it's impossible to form an odd cycle (min length 3).\n    # Based on problem constraints and examples, this case should not be reached\n    # if a solution is expected. For n=1 or n=2, no odd cycle can be formed.\n    # However, for competitive programming, it's safer to assume valid inputs\n    # lead to one of the above cases.\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 594,
        "completion_token_count": 4382,
        "thoughts_token_count": 5587
    }
}