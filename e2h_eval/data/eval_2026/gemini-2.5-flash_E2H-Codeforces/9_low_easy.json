{
    "start": 1758009523.7546701,
    "end": 1758009692.8962386,
    "start-formatted": "2025-09-16 16:58 KST",
    "end-formatted": "2025-09-16 17:01 KST",
    "gpu": 2,
    "pid": 9,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Selling Souvenirs\n\nAfter several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.This morning, as usual, Petya will come to the market. Petya has n different souvenirs to sell; ith souvenir is characterised by its weight wi and cost ci. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than m, and total cost is maximum possible.Help Petya to determine maximum possible total cost.\n\n## Input\nThe first line contains two integers n and m (1 ≤ n ≤ 100000, 1 ≤ m ≤ 300000) — the number of Petya's souvenirs and total weight that he can carry to the market.Then n lines follow. ith line contains two integers wi and ci (1 ≤ wi ≤ 3, 1 ≤ ci ≤ 109) — the weight and the cost of ith souvenir.\n\n## Output\nPrint one number — maximum possible total cost of souvenirs that Petya can carry to the market.\n\n## Example\n### Input\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\n### Output\n['0', '3', '10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "**Thinking Through the \"Selling Souvenirs\" Problem**\n\nOkay, I've got this \"Selling Souvenirs\" problem, which is essentially a knapsack variation. The goal is to maximize the total cost of souvenirs within a weight limit.  The specifics are: `n` souvenirs, a maximum weight capacity `m`, each souvenir `i` has a weight `wi` and a cost `ci`. The constraint is that each `wi` can only be 1, 2, or 3.  The values of `n` and `m` are large, up to 100,000 and 300,000, respectively, and costs are up to 10^9.\n\nImmediately, my mind goes to the fact that typical dynamic programming knapsack solutions are likely too slow given those large values of `n` and `m`. An O(n*m) approach would be around 3 * 10^10 operations, which is way too heavy. However, the small possible weights (1, 2, or 3) is a huge clue.  This screams \"specialized approach\" to me.\n\nSince the weights are small, it makes sense to group the souvenirs by their weights. I'll sort the costs within each weight category in descending order, because it's always optimal to pick the most expensive items first.  Let's define three lists: `costs1`, `costs2`, and `costs3` for the costs of items with weights 1, 2, and 3, respectively, and ensure they are sorted in descending order.\n\nNow, my objective is to maximize the total cost `C` subject to the weight constraint, where the total weight used should not exceed `m`. This translates to finding a combination of souvenirs from the three weight groups such that `1 * count1 + 2 * count2 + 3 * count3 <= m`.\n\nA direct dynamic programming approach, like `dp[w]` = max cost for weight `w` wouldn't be efficient given `m`. However, since items have such low weights, I should think about combining items.\n\nHere's my idea: I'll iterate through the possible number of weight-3 souvenirs (`k3`). For each `k3`, I calculate the cost of those souvenirs and then I'm left with a reduced capacity, `m - 3 * k3`. This smaller problem involves choosing souvenirs of weights 1 and 2 to fill that remaining capacity. This creates a nested loop structure.\n\nSo, I iterate `k3` from 0 up to `m/3`. For each `k3`, I calculate its cost from `costs3`.  Then I have the subproblem to fill the remaining weight `m_remaining = m - 3 * k3` using only souvenirs of weight 1 and 2.\n\nThis subproblem (using only weights 1 and 2) is another knapsack problem in itself! Within that, I can iterate the number of weight-2 souvenirs (`k2`) from 0 up to `m_remaining / 2`.  For each `k2`, I calculate its corresponding cost using `costs2`, and the remainder can be filled by weight-1 souvenirs. I can then use that combination for the total cost. I'll need to keep track of the maximum total cost found across all these iterations. This nested structure seems promising.\n",
    "response": "```python\nimport sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    # Group souvenirs by weight and store their costs.\n    # It's always optimal to pick the most expensive souvenirs first,\n    # so we'll sort them in descending order later.\n    costs1 = []\n    costs2 = []\n    costs3 = []\n\n    for _ in range(n):\n        w, c = map(int, sys.stdin.readline().split())\n        if w == 1:\n            costs1.append(c)\n        elif w == 2:\n            costs2.append(c)\n        else: # w == 3\n            costs3.append(c)\n\n    # Sort costs in descending order to easily pick the most valuable items\n    costs1.sort(reverse=True)\n    costs2.sort(reverse=True)\n    costs3.sort(reverse=True)\n\n    # Precompute prefix sums for costs to quickly get sum of top k items\n    # For costs1, P1[k] = sum of costs of top k items of weight 1\n    # P1[0] = 0, P1[1] = costs1[0], P1[2] = costs1[0] + costs1[1], etc.\n    P1 = [0] * (len(costs1) + 1)\n    for i in range(len(costs1)):\n        P1[i+1] = P1[i] + costs1[i]\n\n    P2 = [0] * (len(costs2) + 1)\n    for i in range(len(costs2)):\n        P2[i+1] = P2[i] + costs2[i]\n\n    P3 = [0] * (len(costs3) + 1)\n    for i in range(len(costs3)):\n        P3[i+1] = P3[i] + costs3[i]\n\n    max_total_cost = 0\n\n    # Iterate over the number of souvenirs of weight 3 (k3)\n    # The maximum number of weight 3 items we can pick is m/3.\n    # We iterate k3 from 0 up to min(len(costs3), m/3).\n    for k3 in range(len(costs3) + 1):\n        current_weight3_cost = P3[k3]\n        current_weight3_used = k3 * 3\n\n        if current_weight3_used > m:\n            break # Cannot pick k3 items of weight 3\n\n        remaining_weight_capacity = m - current_weight3_used\n\n        # Now we need to fill remaining_weight_capacity using items of weight 1 and 2.\n        # This is the \"two-pointer\" or \"sliding window\" part.\n        # We try to use as many weight 2 items as possible, then fill with weight 1 items.\n        # Or, we can iterate k2 (number of weight 2 items) and then fill with k1 (number of weight 1 items).\n        # The optimized approach is to iterate k2 and use the precomputed P1.\n\n        # Iterate over the number of souvenirs of weight 2 (k2)\n        # The maximum number of weight 2 items we can pick is remaining_weight_capacity / 2.\n        # We iterate k2 from 0 up to min(len(costs2), remaining_weight_capacity / 2).\n        \n        # Initialize k2 to its maximum possible value for the current remaining_weight_capacity\n        # This is effectively the right pointer for weight 2 items.\n        k2 = min(len(costs2), remaining_weight_capacity // 2)\n        \n        # We can optimize this inner loop.\n        # Instead of iterating k2, we can iterate k1 (number of weight 1 items) and then determine k2.\n        # Or, we can iterate k2 and calculate the optimal k1.\n        # The problem asks for max cost, so for a fixed k3, we want max cost from (1,2) items.\n        # For a fixed k3, we have `rem_w = m - 3*k3`. We want to maximize `cost1 + cost2`\n        # for `k1*1 + k2*2 <= rem_w`.\n        # This subproblem (knapsack with weights 1 and 2) can be solved efficiently.\n        # A common technique for weights 1 and 2 is to iterate `k2` (number of items of weight 2)\n        # and then take as many items of weight 1 as possible.\n        \n        # Maximize cost from weight 1 and 2 items for current remaining_weight_capacity\n        # Let's use the two-pointer approach as described in the thought process:\n        # Iterate k2 (number of weight 2 items) from max possible down to 0.\n        # For each k2, calculate remaining weight for k1 items.\n        \n        # The two-pointer approach for (1,2) items:\n        # `k1` is the number of weight 1 items, `k2` is the number of weight 2 items.\n        # `k1_ptr` starts at 0, `k2_ptr` starts at max possible for `remaining_weight_capacity`.\n        # `current_cost_1_2` tracks the best cost for weight 1 and 2 items.\n        \n        # Initialize for the subproblem:\n        # Max number of weight 2 items we can take if we take 0 weight 1 items.\n        sub_k2 = min(len(costs2), remaining_weight_capacity // 2)\n        sub_current_cost_1_2 = P2[sub_k2]\n\n        # Max number of weight 1 items we can take if we take 0 weight 2 items.\n        sub_k1 = min(len(costs1), remaining_weight_capacity)\n        sub_current_cost_1_2 = max(sub_current_cost_1_2, P1[sub_k1])\n        \n        # This is the crucial part: iterate through the number of weight 2 items.\n        # For each `k2` (number of items of weight 2), calculate the max `k1` (number of items of weight 1).\n        # We want to find `max(P1[k1] + P2[k2])` such that `k1 + 2*k2 <= remaining_weight_capacity`.\n        \n        # Let's iterate `k2` from 0 up to `len(costs2)`.\n        # For each `k2`, calculate `rem_w_for_1 = remaining_weight_capacity - 2*k2`.\n        # Then, `k1 = min(len(costs1), rem_w_for_1)`.\n        # This would be another loop, potentially leading to O(M/3 * M/2) which is too slow.\n        \n        # The correct optimization for the (1,2) knapsack:\n        # Iterate `k2` from 0 up to `min(len(costs2), remaining_weight_capacity // 2)`.\n        # For each `k2`, calculate the current cost from weight 2 items: `P2[k2]`.\n        # Calculate the remaining weight for weight 1 items: `rem_w_for_1 = remaining_weight_capacity - 2 * k2`.\n        # The optimal number of weight 1 items is `min(len(costs1), rem_w_for_1)`.\n        # Add the cost from these weight 1 items: `P1[min(len(costs1), rem_w_for_1)]`.\n        # Update the maximum cost found for this `k3`.\n        \n        # This inner loop is O(M_rem / 2). Total complexity O(M/3 * M/2) = O(M^2). Still too slow.\n        # What if we iterate over k1 and k2 in a combined way?\n        # The \"two-pointer\" or \"sliding window\" approach works like this:\n        # For a fixed `k3`, we have `rem_w = m - 3*k3`.\n        # We want to maximize `P1[k1] + P2[k2]` s.t. `k1 + 2*k2 <= rem_w`.\n        # Let `k2` be the number of weight 2 items. Iterate `k2` from 0 up to `len(costs2)`.\n        # For each `k2`, `current_cost_2 = P2[k2]`.\n        # The weight used by `k2` items is `2*k2`.\n        # The remaining weight for weight 1 items is `rem_w - 2*k2`.\n        # The number of weight 1 items we can pick is `k1 = min(len(costs1), rem_w - 2*k2)`.\n        # The cost for weight 1 items is `P1[k1]`.\n        # Total cost for this `(k2, k1)` combination is `current_cost_2 + P1[k1]`.\n        # This is `O(M/3 * N2)` or `O(M/3 * M/2)` if N2 is limited by M. This is too slow.\n\n        # The key observation for the (1,2) subproblem:\n        # If we have `W` capacity for items of weight 1 and 2,\n        # we can iterate `k2` (number of weight 2 items).\n        # For each `k2`, we use `2*k2` weight, and `W - 2*k2` for weight 1 items.\n        # The cost is `P2[k2] + P1[min(len(costs1), W - 2*k2)]`.\n        # This still leads to `O(M)` for the inner part.\n        \n        # A more efficient way for the (1,2) subproblem:\n        # We have `rem_w` capacity.\n        # Let `k1` be the number of weight 1 items and `k2` be the number of weight 2 items.\n        # We want to maximize `P1[k1] + P2[k2]` such that `k1 + 2*k2 <= rem_w`.\n        # Iterate `k1` from `len(costs1)` down to 0. (This is `O(N1)`).\n        # For each `k1`, `rem_w_for_2 = rem_w - k1`.\n        # The maximum `k2` we can take is `min(len(costs2), rem_w_for_2 // 2)`.\n        # This is also `O(N1 * N2)` or `O(N1 * M)`.\n        \n        # The solution for (1,2) items with capacity `W` should be `O(W)` or `O(N1+N2)`.\n        # Let's fix `k1` (number of weight 1 items).\n        # `k1` can go from 0 up to `min(len(costs1), remaining_weight_capacity)`.\n        # For each `k1`, `current_cost_1 = P1[k1]`.\n        # `rem_w_for_2 = remaining_weight_capacity - k1`.\n        # Max `k2` is `min(len(costs2), rem_w_for_2 // 2)`.\n        # Cost is `P1[k1] + P2[k2]`.\n        # This is `O(N1)` or `O(M)` for the inner loop.\n        # Total `O(M/3 * M) = O(M^2)`. This is the issue.\n\n        # The actual \"two-pointer\" approach for the (1,2) problem:\n        # Let `k1_count` be the number of items of weight 1, `k2_count` for weight 2.\n        # `current_max_cost_1_2` for the current `rem_w`.\n        # We iterate `k1_count` from 0 up to `min(len(costs1), rem_w)`.\n        # For each `k1_count`, `rem_w_for_2 = rem_w - k1_count`.\n        # We need to find the best `k2_count` for `rem_w_for_2`.\n        # This implies `k2_count = min(len(costs2), rem_w_for_2 // 2)`.\n        # This is `O(N1)` or `O(M)` for the inner loop.\n        \n        # This is the standard approach for knapsack with small weights.\n        # The total complexity is `O(M/W_max * (N1 + W_max))`.\n        # Max number of items of weight 3 is `k3_max = m // 3`.\n        # For each `k3` from `0` to `k3_max`:\n        #   `rem_w = m - 3 * k3`.\n        #   We need to solve the (1,2) knapsack for `rem_w`.\n        #   Let `best_cost_1_2[w]` be the max cost for `w` capacity using (1,2) items.\n        #   We can precompute `best_cost_1_2` array up to `m`.\n        #   `best_cost_1_2[w]` = max cost for capacity `w` using only items of weight 1 and 2.\n        #   This itself can be computed in `O(m)` time.\n        #   `dp[w]` = max cost for capacity `w`.\n        #   For weight 1 items: `dp[w] = max(dp[w], dp[w-1] + costs1[k])`.\n        #   For weight 2 items: `dp[w] = max(dp[w], dp[w-2] + costs2[k])`.\n        #   This is `O(N*M)` if we consider all items.\n        #   But using prefix sums, `best_cost_1_2[w]` can be found by iterating `k2` from `0` to `w/2`.\n        #   `best_cost_1_2[w] = max_{k2} (P2[k2] + P1[min(len(costs1), w - 2*k2)])`.\n        #   This takes `O(w)` time.\n        #   So computing `best_cost_1_2` for all `w` up to `m` takes `O(m^2)`. Still too slow.\n\n        # The correct approach to the (1,2) subproblem in O(N1 + N2 + M) is:\n        # `current_total_cost_1_2 = 0`\n        # `k1_count = 0`\n        # `k2_count = min(len(costs2), remaining_weight_capacity // 2)`\n        # `current_total_cost_1_2 = P2[k2_count]`\n        # `current_max_for_rem_w = current_total_cost_1_2`\n\n        # Iterate `k1_count` from 0 up to `min(len(costs1), remaining_weight_capacity)`:\n        #   `current_total_cost_1_2 += costs1[k1_count]` (if `k1_count > 0`)\n        #   `weight_used_by_1 = k1_count * 1`\n        #   `rem_w_for_2 = remaining_weight_capacity - weight_used_by_1`\n        #   While `k2_count > 0` and `2 * k2_count > rem_w_for_2`:\n        #       `current_total_cost_1_2 -= costs2[k2_count - 1]`\n        #       `k2_count -= 1`\n        #   `current_max_for_rem_w = max(current_max_for_rem_w, current_total_cost_1_2)`\n        # This is the standard two-pointer for the (1,2) subproblem.\n        # For a fixed `k3`, this inner loop (for `k1` and `k2`) takes `O(N1 + N2)` time.\n        # Total time complexity: `O(M/3 * (N1 + N2))`.\n        # Given N1, N2 can be up to 10^5, M/3 can be 10^5. So (10^5 * 10^5) is too slow.\n\n        # The constraints `N <= 100000`, `M <= 300000`.\n        # My previous analysis for the (1,2) subproblem was incorrect.\n        # The (1,2) subproblem can be solved in O(N1 + N2) or O(M_rem) time.\n        # For a fixed `k3`, `rem_w = m - 3*k3`.\n        # We want to find `max(P1[k1] + P2[k2])` such that `k1 + 2*k2 <= rem_w`.\n        # Let's iterate `k2` from 0 up to `min(len(costs2), rem_w // 2)`.\n        # For each `k2`, calculate `cost2 = P2[k2]`.\n        # The remaining weight is `rem_w - 2*k2`.\n        # The number of weight 1 items we can take is `k1 = min(len(costs1), rem_w - 2*k2)`.\n        # The cost is `cost2 + P1[k1]`.\n        # This is `O(M_rem)` for each `k3`.\n        # Total: `O(M/3 * M_rem)` which is `O(M^2)`.\n\n        # Okay, the problem is solvable in O(M + N) or O(M log N) or O(N log N).\n        # The constraint `wi <= 3` is critical.\n        # Let's consider `dp[w]` as the maximum value for weight `w`.\n        # `dp` array size `m+1`.\n        # `dp[0] = 0`, `dp[i] = -infinity` for `i > 0`.\n        # For each item `(w, c)`:\n        #   For `j` from `m` down to `w`:\n        #     `dp[j] = max(dp[j], dp[j-w] + c)`\n        # This is `O(N*M)`, too slow.\n\n        # Since weights are small, we can use a specialized DP.\n        # For each weight `w` from 1 to 3:\n        #   Iterate through `cost_list_w` (sorted descending).\n        #   For each `c` in `cost_list_w`:\n        #     For `j` from `m` down to `w`:\n        #       `dp[j] = max(dp[j], dp[j-w] + c)`\n        # This is `O(N*M)` again.\n\n        # The solution for small weights is usually to group items by weight.\n        # Let's re-examine the (1,2) subproblem.\n        # We need to compute `f(W)` = max cost for capacity `W` using items of weight 1 and 2.\n        # `f(W) = max_{k2=0 to W/2} (P2[k2] + P1[min(len(costs1), W - 2*k2)])`.\n        # This `f(W)` can be computed for all `W` from 0 to `m` in `O(m)` total time.\n        # How?\n        # Let `current_k2` be the number of weight 2 items.\n        # Let `current_cost_1_2 = 0`.\n        # `k1_ptr = 0` (number of weight 1 items).\n        # `k2_ptr = min(len(costs2), W // 2)`.\n        # `current_cost_1_2 = P2[k2_ptr]`\n        # For `k1_ptr` from 0 to `min(len(costs1), W)`:\n        #   `cost_from_1 = P1[k1_ptr]`\n        #   `rem_w_for_2 = W - k1_ptr`\n        #   While `k2_ptr > 0` and `2 * k2_ptr > rem_w_for_2`:\n        #       `k2_ptr -= 1`\n        #   `cost_from_2 = P2[k2_ptr]`\n        #   `f(W) = max(f(W), cost_from_1 + cost_from_2)`.\n        # This is `O(W)` for each `W`. Still `O(M^2)` to precompute `f(W)` for all `W`.\n\n        # The actual trick is that `f(W)` can be computed in `O(W)` total for all `W` up to `M`.\n        # `f[w]` stores the maximum cost for weight `w` using only items of weight 1 and 2.\n        # `f[w]` can be computed using a sliding window approach.\n        # `k2` iterates from `0` to `len(costs2)`.\n        # `k1` iterates from `len(costs1)` down to `0`.\n        # `current_cost_1 = 0`.\n        # `k1_idx = 0`.\n        # `k2_idx = min(len(costs2), m // 2)`.\n        # `current_cost_1_2 = P2[k2_idx]` (cost from weight 2 items, for `k1_idx=0`)\n        # `current_max_cost_1_2 = current_cost_1_2`\n        # For `k1_idx` from 1 to `len(costs1)`:\n        #   `current_cost_1_2 += costs1[k1_idx - 1]`\n        #   `current_weight_1 = k1_idx`\n        #   `remaining_w_for_2 = m - current_weight_1`\n        #   While `k2_idx > 0` and `2 * k2_idx > remaining_w_for_2`:\n        #       `current_cost_1_2 -= costs2[k2_idx - 1]`\n        #       `k2_idx -= 1`\n        #   If `current_weight_1 + 2 * k2_idx <= m`:\n        #       `current_max_cost_1_2 = max(current_max_cost_1_2, current_cost_1_2)`\n        # This computes the best (1,2) combination for the *total* capacity `m`.\n        # We need it for `rem_w`.\n\n        # Let's reconsider the structure:\n        # Iterate `k3` from 0 to `min(len(costs3), m/3)`.\n        #   `current_cost = P3[k3]`.\n        #   `rem_w = m - 3*k3`.\n        #   Now we need to find the max cost for `rem_w` using weight 1 and 2 items.\n        #   This part should be `O(1)` if we precompute.\n        #   Let `dp12[w]` be the max cost using weight 1 and 2 items for capacity `w`.\n        #   `dp12` can be computed in `O(m)` total time.\n        #   `dp12[0] = 0`.\n        #   `k2 = 0`\n        #   `current_cost_12_sum = 0`\n        #   `best_cost_so_far_for_weight_12 = 0`\n        #   For `w` from 0 to `m`:\n        #       While `k2 < len(costs2)` and `2*(k2+1) <= w`:\n        #           `current_cost_12_sum += costs2[k2]`\n        #           `k2 += 1`\n        #       `dp12[w] = max(dp12[w-1] if w > 0 else 0, current_cost_12_sum + P1[min(len(costs1), w - 2*k2)])`\n        # This is not how `dp12` is computed.\n        # `dp12[w]` is the maximum value for weight `w` using items of weight 1 and 2.\n        # Iterate `k1` from `0` to `len(costs1)`.\n        #   For `w` from `k1` to `m`:\n        #     `dp12[w] = max(dp12[w], P1[k1] + P2[min(len(costs2), (w-k1)//2)])`\n        # Still `O(N1*M)`.\n\n        # The correct approach to precompute `dp12[w]` for all `w` up to `m` in `O(M + N1 + N2)`:\n        # `dp12 = [0] * (m + 1)`\n        # `k2_ptr = 0` (index for costs2)\n        # `current_cost_from_2 = 0`\n        # For `w` from 0 to `m`:\n        #     # Try to add another item of weight 2\n        #     while `k2_ptr < len(costs2)` and `2 * (k2_ptr + 1) <= w`:\n        #         `current_cost_from_2 += costs2[k2_ptr]`\n        #         `k2_ptr += 1`\n        #     \n        #     # Calculate cost for current `w` using `k2_ptr` items of weight 2\n        #     # and as many weight 1 items as possible for remaining capacity.\n        #     `rem_w_for_1 = w - 2 * k2_ptr`\n        #     `cost_from_1 = P1[min(len(costs1), rem_w_for_1)]`\n        #     `dp12[w] = current_cost_from_2 + cost_from_1`\n        #     \n        #     # This `dp12[w]` calculation is for a specific `k2_ptr`.\n        #     # We need to consider all combinations of `k1` and `k2`.\n        #     # The previous `dp12[w]` should be `max(dp12[w-1], current_cost_from_2 + cost_from_1)`\n        #     # This is tricky.\n        \n        # Let's use the standard \"two pointers\" to find `max_cost_1_2(W)` for a given `W`.\n        # It takes `O(N1 + N2)` time for ONE `W`.\n        # This is what I called `O(M/3 * (N1 + N2))` earlier.\n        # `N1 + N2` can be up to `N=100000`. `M/3` can be `100000`.\n        # So `10^5 * 10^5` is `10^10`, too slow.\n\n        # The key insight must be that `k3` does not need to be iterated up to `M/3`.\n        # Or, the (1,2) subproblem can be solved faster than `O(N1+N2)` within the loop.\n\n        # What if `k3` is small? Then `rem_w` is large.\n        # What if `k3` is large? Then `rem_w` is small.\n        # The number of weight 3 items is at most `N` and at most `M/3`.\n        # Let `num_k3 = min(len(costs3), m // 3)`.\n        # Let `num_k2 = min(len(costs2), m // 2)`.\n        # Let `num_k1 = min(len(costs1), m)`.\n\n        # The approach that is `O(M + N)` or `O(M log N)` or `O(N log N)`:\n        # 1. Sort costs for each weight category (done).\n        # 2. Compute prefix sums (done).\n        # 3. Iterate `k3` from 0 to `min(len(costs3), m // 3)`.\n        #    `current_cost_k3 = P3[k3]`.\n        #    `rem_w = m - 3*k3`.\n        #    Now we need to find `max_cost_1_2(rem_w)`.\n        #    This `max_cost_1_2(rem_w)` is the tricky part.\n\n        # Let's try to compute `max_cost_1_2(w)` for all `w` from `0` to `m` efficiently.\n        # `max_cost_1_2[w]` = max cost for weight `w` using only items of weight 1 and 2.\n        # `max_cost_1_2 = [0] * (m + 1)`\n        # `k2_count = 0`\n        # `current_cost_for_k2 = 0`\n        # For `k1_count` from 0 to `len(costs1)`:\n        #   `current_cost_for_k1 = P1[k1_count]`\n        #   `weight_used_by_k1 = k1_count * 1`\n        #   If `weight_used_by_k1 > m`: break\n        #   `remaining_capacity_for_2 = m - weight_used_by_k1`\n        #   \n        #   # Now, for this `k1_count`, we need to find the best `k2_count` such that `2*k2_count <= remaining_capacity_for_2`.\n        #   # This `k2_count` is `min(len(costs2), remaining_capacity_for_2 // 2)`.\n        #   # Let's call this `optimal_k2_for_this_rem_cap`.\n        #   `optimal_k2_for_this_rem_cap = min(len(costs2), remaining_capacity_for_2 // 2)`\n        #   `cost_from_optimal_k2 = P2[optimal_k2_for_this_rem_cap]`\n        #   \n        #   # The total cost for this `k1_count` is `current_cost_for_k1 + cost_from_optimal_k2`.\n        #   # This is a candidate for `max_total_cost`.\n        #   `max_total_cost = max(max_total_cost, current_cost_for_k1 + cost_from_optimal_k2)`\n        #\n        # This is `O(N1)` for the (1,2) problem for the *total* `m`.\n        # But we need it for `rem_w`.\n        #\n        # The actual solution for the (1,2) subproblem for *all* `W` up to `M` in `O(M + N1 + N2)`:\n        # `max_cost_1_2 = [0] * (m + 1)`\n        # `k2_idx = 0`\n        # `current_cost_2 = 0`\n        # For `w` from 0 to `m`:\n        #     # Option 1: Don't take any more weight 2 items than `k2_idx`\n        #     # `cost_from_1 = P1[min(len(costs1), w - 2 * k2_idx)]`\n        #     # `current_val = current_cost_2 + cost_from_1`\n        #     \n        #     # Option 2: Try to take one more weight 2 item if possible\n        #     `val_with_k2_idx_items = current_cost_2 + P1[min(len(costs1), w - 2 * k2_idx)]`\n        #     \n        #     `val_with_k2_idx_plus_1_items = -1` # sentinel for impossible\n        #     if `k2_idx + 1 <= len(costs2)` and `2 * (k2_idx + 1) <= w`:\n        #         `val_with_k2_idx_plus_1_items = (current_cost_2 + costs2[k2_idx]) + P1[min(len(costs1), w - 2 * (k2_idx + 1))]`\n        #     \n        #     `max_cost_1_2[w] = max(val_with_k2_idx_items, val_with_k2_idx_plus_1_items)`\n        #     if `w > 0`: `max_cost_1_2[w] = max(max_cost_1_2[w], max_cost_1_2[w-1])`\n        #     \n        #     # If `val_with_k2_idx_plus_1_items` was better, advance `k2_idx` for next `w`.\n        #     # This logic is flawed. We need to find the best `k2_idx` for each `w`.\n        #     # The two-pointer approach for precomputing `max_cost_1_2` for all `w` is:\n        #\n        # `max_cost_1_2 = [0] * (m + 1)`\n        # `k2_ptr = 0`\n        # `current_cost_2_items = 0`\n        # For `w` from 0 to `m`:\n        #     # `max_cost_1_2[w]` should be `max(max_cost_1_2[w-1], ...)`\n        #     # The value for `w` can be formed by `w-1` and adding a weight 1 item,\n        #     # or `w-2` and adding a weight 2 item.\n        #     # This is the standard DP, which is `O(M)` for each item type.\n        #     # For weight 1 items: `dp[w] = max(dp[w], dp[w-1] + c1)`\n        #     # For weight 2 items: `dp[w] = max(dp[w], dp[w-2] + c2)`\n        #     # If we have many items of the same weight, we use the specific DP.\n        #     # For weight 1 items: `for i in range(len(costs1)): for w from m down to 1: dp[w] = max(dp[w], dp[w-1] + costs1[i])` -> O(N1*M)\n        #     # This is where the prefix sums come in.\n        #\n        # `max_cost_1_2 = [0] * (m + 1)`\n        # `k2_idx = len(costs2)`\n        # `current_cost_2 = P2[k2_idx]`\n        # For `k1_idx` from 0 to `len(costs1)`:\n        #     `cost_1 = P1[k1_idx]`\n        #     `weight_1 = k1_idx`\n        #     `remaining_w = m - weight_1`\n        #     \n        #     while `k2_idx > 0` and `2 * k2_idx > remaining_w`:\n        #         `k2_idx -= 1`\n        #         `current_cost_2 = P2[k2_idx]`\n        #     \n        #     `current_total_weight = weight_1 + 2 * k2_idx`\n        #     if `current_total_weight <= m`:\n        #         `max_total_cost = max(max_total_cost, cost_1 + current_cost_2)`\n        # This is for `m` total.\n        \n        # The problem is that the `k3` loop means `rem_w` changes.\n        # We need `max_cost_1_2[w]` for *all* `w` from `0` to `m`.\n        # This `max_cost_1_2` array is what the `O(M + N1 + N2)` part computes.\n        \n        # Let `dp_12[w]` be the maximum value for weight `w` using only weight 1 and weight 2 items.\n        # `dp_12 = [0] * (m + 1)`\n        # `k2_ptr = 0`\n        # `current_cost_2_items = 0`\n        # For `w` from 0 to `m`:\n        #     # Option 1: Don't take any weight 2 items, only weight 1 items.\n        #     `val1 = P1[min(len(costs1), w)]`\n        #     \n        #     # Option 2: Consider `k2_ptr` items of weight 2 and weight 1 items for remaining capacity.\n        #     # This `k2_ptr` should be adjusted for each `w`.\n        #     # The `k2_ptr` should be the maximum `k2` such that `2*k2 <= w`.\n        #     `k2_for_w = min(len(costs2), w // 2)`\n        #     `val2 = P2[k2_for_w] + P1[min(len(costs1), w - 2 * k2_for_w)]`\n        #     \n        #     # This is not enough, because `P2[k2_for_w]` might not be optimal.\n        #     # Example: `w=3`. `k2_for_w = 1`. `val2 = P2[1] + P1[1]`.\n        #     # But `P1[3]` might be better.\n        #     # The `max_cost_1_2[w]` should be calculated using a sweep line / two pointers.\n        #\n        # `max_cost_1_2 = [0] * (m + 1)`\n        # `k1_ptr = 0`\n        # `k2_ptr = min(len(costs2), m // 2)`\n        # `current_sum_1_2 = P2[k2_ptr]`\n        # For `w` from 0 to `m`:\n        #     # Adjust `k1_ptr` for `w`.\n        #     # `k1_ptr` should be `min(len(costs1), w)`.\n        #     # `cost_from_1 = P1[k1_ptr]`\n        #     # `rem_w_for_2 = w - k1_ptr`\n        #     # `k2_ptr_for_w = min(len(costs2), rem_w_for_2 // 2)`\n        #     # `cost_from_2 = P2[k2_ptr_for_w]`\n        #     # `max_cost_1_2[w] = cost_from_1 + cost_from_2`\n        #     # This is `O(M)`.\n        #     # But this is wrong. The `k1_ptr` for `w` should be determined by the loop.\n        \n        # Let's try the DP approach for `max_cost_1_2` again, but correctly.\n        # `dp_12[w]` = max cost for capacity `w` using only weight 1 and 2 items.\n        # `dp_12 = [0] * (m + 1)`\n        # `k2_idx = 0`\n        # `current_cost_2 = 0`\n        # For `k1_idx` from 0 to `len(costs1)`:\n        #     `cost_1 = P1[k1_idx]`\n        #     `weight_1 = k1_idx`\n        #     \n        #     # For this fixed `k1_idx`, we want to find the best `k2_idx` for each `w`.\n        #     # This is not how `dp_12` is built.\n        #     # `dp_12` must be built by iterating `w` from 0 to `m`.\n        #     # For each `w`, calculate `dp_12[w]`.\n        #\n        # The correct linear scan for `dp_12[w]` for all `w` up to `m`:\n        # `dp_12 = [0] * (m + 1)`\n        # `k2_ptr = 0` # Number of weight 2 items currently considered\n        # `current_cost_2 = 0` # Sum of costs of `k2_ptr` weight 2 items\n        # For `w` from 0 to `m`:\n        #     # Option 1: Take `k1` items of weight 1 and `k2` items of weight 2.\n        #     # `k1` and `k2` must sum to `w`.\n        #     # We maintain `k2_ptr` such that `2*k2_ptr` is the largest even weight less than or equal to `w`.\n        #     # This is not quite right. `k2_ptr` should be the number of weight 2 items.\n        #     \n        #     # `dp_12[w]` is the maximum of:\n        #     # 1. `dp_12[w-1]` (if `w > 0`, don't add anything, or add weight 1 item)\n        #     # 2. `dp_12[w-2]` (if `w > 1`, add weight 2 item)\n        #     # But this is for a limited number of items. We have many items.\n        #     # For many items, it's `dp[w] = max(dp[w-1]+c1, dp[w-2]+c2)` if we only have one of each.\n        #     # With many items, it's `dp[w] = max(dp[w-1]+costs1[i], dp[w-2]+costs2[j])`.\n        #     # This is where the prefix sums are used.\n        #\n        # `dp_12 = [0] * (m + 1)`\n        # `k2_idx = 0` # Pointer to the next best weight 2 item to consider\n        # `current_cost_2 = 0` # Sum of costs of weight 2 items up to `k2_idx-1`\n        # For `w` from 0 to `m`:\n        #     # `dp_12[w]` is the max cost for capacity `w`.\n        #     # It can be formed by `P1[k1] + P2[k2]` where `k1 + 2*k2 = w`.\n        #     # Or `k1 + 2*k2 <= w` for optimal packing.\n        #     \n        #     # For each `w`, we consider taking `k2` items of weight 2, and `k1` items of weight 1.\n        #     # The maximum `k2` is `w // 2`.\n        #     # The number of weight 1 items is `w - 2*k2`.\n        #     \n        #     # We need to find `max_{k2=0 to min(len(costs2), w//2)} (P2[k2] + P1[min(len(costs1), w - 2*k2)])`.\n        #     # This inner loop is `O(w)`. So `O(M^2)` total. This is the problem.\n        #\n        # The trick for `max_cost_1_2[w]` for all `w` in `O(M + N1 + N2)`:\n        # `max_cost_1_2 = [0] * (m + 1)`\n        # `k2_ptr = 0`\n        # `current_sum_k2 = 0`\n        # For `k1_ptr` from 0 to `len(costs1)`:\n        #     `current_sum_k1 = P1[k1_ptr]`\n        #     `weight_k1 = k1_ptr`\n        #     \n        #     `remaining_w_for_2_items = m - weight_k1`\n        #     \n        #     # `k2_ptr` should be limited by `len(costs2)` and `remaining_w_for_2_items`.\n        #     # We need to find the optimal `k2_ptr` for *each* `w` from `weight_k1` to `m`.\n        #     # This is still not the right way to think about it.\n        \n        # Let's consider the items.\n        # We have `N1` items of weight 1, `N2` of weight 2, `N3` of weight 3.\n        # `max_total_cost = 0`.\n        # `current_cost_12_subproblem = 0`.\n        # `k2_ptr = 0`.\n        # `k1_ptr = 0`.\n        # For `k3` from 0 to `min(len(costs3), m // 3)`:\n        #     `cost_3 = P3[k3]`\n        #     `weight_3 = k3 * 3`\n        #     `rem_w = m - weight_3`\n        #     \n        #     # Now, solve `k1*1 + k2*2 <= rem_w` for max `P1[k1] + P2[k2]`.\n        #     # This is the \"two-pointer\" part for the (1,2) subproblem.\n        #     # `k1_ptr` iterates from `0` to `min(len(costs1), rem_w)`.\n        #     # `k2_ptr` starts at `min(len(costs2), rem_w // 2)` and decreases.\n        #     # We need to compute `max_cost_1_2(rem_w)` in `O(1)` or `O(log M)` time.\n        #     # This implies `max_cost_1_2` array is precomputed.\n        \n        # Let's precompute `max_cost_1_2[w]` for all `w` from `0` to `m`.\n        # `max_cost_1_2 = [0] * (m + 1)`\n        # `k2_idx = 0` # Number of items of weight 2 currently considered.\n        # `current_cost_2_sum = 0` # Sum of costs of `k2_idx` items of weight 2.\n        # For `k1_idx` from 0 to `len(costs1)`:\n        #     `cost_1_sum = P1[k1_idx]`\n        #     `weight_1_used = k1_idx`\n        #     \n        #     `max_possible_weight_for_this_k1 = weight_1_used + 2 * len(costs2)`\n        #     \n        #     # The actual weight `w` is `weight_1_used + 2 * k2_idx_actual`.\n        #     # We need to fill `max_cost_1_2[w]` for all `w`.\n        #     \n        #     # This is the correct dynamic programming for the (1,2) subproblem.\n        #     # `dp[w]` = max cost for weight `w` using (1,2) items.\n        #     # `dp = [0] * (m + 1)`\n        #     # For `i` from 0 to `len(costs1)-1`:\n        #     #    For `w` from `m` down to `1`:\n        #     #        `dp[w] = max(dp[w], dp[w-1] + costs1[i])`\n        #     # For `i` from 0 to `len(costs2)-1`:\n        #     #    For `w` from `m` down to `2`:\n        #     #        `dp[w] = max(dp[w], dp[w-2] + costs2[i])`\n        #     # This is `O(N1*M + N2*M)`, too slow.\n        \n        # The key is that `max_cost_1_2[w]` can be computed using a sliding window.\n        # `max_cost_1_2 = [0] * (m + 1)`\n        # `k1_count = 0`\n        # `current_val_1 = 0`\n        # `k2_count = 0`\n        # `current_val_2 = 0`\n        # For `w` from 0 to `m`:\n        #     # Try to add a weight 1 item\n        #     `val_with_1 = 0`\n        #     if `w >= 1` and `k1_count < len(costs1)`:\n        #         `val_with_1 = current_val_1 + costs1[k1_count]`\n        #     \n        #     # Try to add a weight 2 item\n        #     `val_with_2 = 0`\n        #     if `w >= 2` and `k2_count < len(costs2)`:\n        #         `val_with_2 = current_val_2 + costs2[k2_count]`\n        #     \n        #     # This is not DP.\n        \n        # The efficient way to compute `max_cost_1_2[w]` for all `w` up to `m`:\n        # `max_cost_1_2 = [0] * (m + 1)`\n        # `k2_ptr = min(len(costs2), m // 2)` # Start k2_ptr at max possible for total M\n        # `current_cost_1_2_sum = P2[k2_ptr]` # Sum for k2_ptr items of weight 2\n        # For `k1_ptr` from 0 to `len(costs1)`:\n        #     `current_weight_1 = k1_ptr`\n        #     `current_cost_1 = P1[k1_ptr]`\n        #     \n        #     `remaining_w_for_2 = m - current_weight_1`\n        #     \n        #     # Shrink `k2_ptr` if it's too large for `remaining_w_for_2`\n        #     while `k2_ptr > 0` and `2 * k2_ptr > remaining_w_for_2`:\n        #         `k2_ptr -= 1`\n        #         `current_cost_1_2_sum = P2[k2_ptr]` # Update sum to new k2_ptr\n        #     \n        #     # If `current_weight_1 + 2 * k2_ptr <= m`:\n        #     # This is the cost for total capacity `m` using `k1_ptr` and `k2_ptr`.\n        #     # `max_total_cost = max(max_total_cost, current_cost_1 + current_cost_1_2_sum)`\n        #     \n        #     # This is still not precomputing `max_cost_1_2[w]` for varying `w`.\n        #     # This computes the optimal for `m` directly.\n        \n        # The `max_cost_1_2[w]` array precomputation in `O(M + N1 + N2)`:\n        # `max_cost_1_2 = [0] * (m + 1)`\n        # `k2_idx = 0`\n        # `current_cost_2 = 0`\n        # `current_max_val_1_2 = 0`\n        # For `w` from 0 to `m`:\n        #     # Option 1: Don't use any weight 2 items, only weight 1 items.\n        #     # This is `P1[min(len(costs1), w)]`.\n        #     `option1_val = P1[min(len(costs1), w)]`\n        #     \n        #     # Option 2: Use `k2_idx` items of weight 2, and fill remaining with weight 1.\n        #     # `k2_idx` is the maximum number of weight 2 items that can fit into `w`.\n        #     # This `k2_idx` needs to be updated.\n        #     while `k2_idx < len(costs2)` and `2 * (k2_idx + 1) <= w`:\n        #         `current_cost_2 += costs2[k2_idx]`\n        #         `k2_idx += 1`\n        #     \n        #     `rem_w_for_1 = w - 2 * k2_idx`\n        #     `option2_val = current_cost_2 + P1[min(len(costs1), rem_w_for_1)]`\n        #     \n        #     `max_cost_1_2[w] = max(option1_val, option2_val)`\n        #     if `w > 0`: `max_cost_1_2[w] = max(max_cost_1_2[w], max_cost_1_2[w-1])` # ensures non-decreasing\n        # This is `O(M + N2 + N1)`. This seems correct!\n        # `k2_idx` only increases, `P1` lookup is `O(1)`. `current_cost_2` only increases.\n        # Total `O(M + N1 + N2)` to build `max_cost_1_2`.\n        \n        # Then, the main loop:\n        # `max_total_cost = 0`\n        # For `k3` from 0 to `min(len(costs3), m // 3)`:\n        #     `current_cost_3 = P3[k3]`\n        #     `weight_3_used = k3 * 3`\n        #     `rem_w = m - weight_3_used`\n        #     `max_total_cost = max(max_total_cost, current_cost_3 + max_cost_1_2[rem_w])`\n        # This loop is `O(M/3)`.\n        # Total complexity: `O(M + N1 + N2 + M/3) = O(M + N)`. This is efficient enough!\n\n    # Precompute max_cost_1_2[w] for all w from 0 to m\n    max_cost_1_2 = [0] * (m + 1)\n    k2_idx = 0  # Pointer to the next best weight 2 item to consider\n    current_cost_2 = 0 # Sum of costs of weight 2 items taken (up to k2_idx-1)\n\n    for w in range(m + 1):\n        # Option 1: Only use weight 1 items up to capacity w.\n        # This uses P1[min(len(costs1), w)]\n        option1_val = P1[min(len(costs1), w)]\n\n        # Option 2: Use some weight 2 items and fill the rest with weight 1 items.\n        # `k2_idx` should be the maximum number of weight 2 items that can fit into `w`\n        # if we are prioritizing weight 2 items (amongst 1 and 2).\n        \n        # Advance k2_idx as much as possible for current `w`.\n        # `k2_idx` is the count of weight 2 items.\n        # `current_cost_2` is the sum of costs of `k2_idx` items.\n        while k2_idx < len(costs2) and 2 * (k2_idx + 1) <= w:\n            current_cost_2 += costs2[k2_idx]\n            k2_idx += 1\n        \n        # Calculate remaining capacity for weight 1 items after taking `k2_idx` items of weight 2.\n        rem_w_for_1 = w - 2 * k2_idx\n        option2_val = current_cost_2 + P1[min(len(costs1), rem_w_for_1)]\n        \n        # max_cost_1_2[w] is the maximum of these two options.\n        max_cost_1_2[w] = max(option1_val, option2_val)\n        \n        # Also, ensure that max_cost_1_2 is non-decreasing.\n        # If we can achieve `X` for `w-1`, we can also achieve `X` for `w` (by not adding anything).\n        if w > 0:\n            max_cost_1_2[w] = max(max_cost_1_2[w], max_cost_1_2[w-1])\n\n    # Main loop: Iterate over the number of souvenirs of weight 3 (k3)\n    max_total_cost = 0\n    for k3 in range(len(costs3) + 1):\n        current_cost_3 = P3[k3]\n        current_weight_3_used = k3 * 3\n\n        if current_weight_3_used > m:\n            break # Cannot pick k3 items of weight 3\n\n        remaining_weight_capacity = m - current_weight_3_used\n        \n        # Add the maximum cost from weight 1 and 2 items for the remaining capacity\n        max_total_cost = max(max_total_cost, current_cost_3 + max_cost_1_2[remaining_weight_capacity])\n\n    sys.stdout.write(str(max_total_cost) + '\\n')\n\nsolve()\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    # Group souvenirs by weight and store their costs.\n    # It's always optimal to pick the most expensive souvenirs first,\n    # so we'll sort them in descending order later.\n    costs1 = []\n    costs2 = []\n    costs3 = []\n\n    for _ in range(n):\n        w, c = map(int, sys.stdin.readline().split())\n        if w == 1:\n            costs1.append(c)\n        elif w == 2:\n            costs2.append(c)\n        else: # w == 3\n            costs3.append(c)\n\n    # Sort costs in descending order to easily pick the most valuable items\n    costs1.sort(reverse=True)\n    costs2.sort(reverse=True)\n    costs3.sort(reverse=True)\n\n    # Precompute prefix sums for costs to quickly get sum of top k items\n    # For costs1, P1[k] = sum of costs of top k items of weight 1\n    # P1[0] = 0, P1[1] = costs1[0], P1[2] = costs1[0] + costs1[1], etc.\n    P1 = [0] * (len(costs1) + 1)\n    for i in range(len(costs1)):\n        P1[i+1] = P1[i] + costs1[i]\n\n    P2 = [0] * (len(costs2) + 1)\n    for i in range(len(costs2)):\n        P2[i+1] = P2[i] + costs2[i]\n\n    P3 = [0] * (len(costs3) + 1)\n    for i in range(len(costs3)):\n        P3[i+1] = P3[i] + costs3[i]\n\n    max_total_cost = 0\n\n    # Iterate over the number of souvenirs of weight 3 (k3)\n    # The maximum number of weight 3 items we can pick is m/3.\n    # We iterate k3 from 0 up to min(len(costs3), m/3).\n    for k3 in range(len(costs3) + 1):\n        current_weight3_cost = P3[k3]\n        current_weight3_used = k3 * 3\n\n        if current_weight3_used > m:\n            break # Cannot pick k3 items of weight 3\n\n        remaining_weight_capacity = m - current_weight3_used\n\n        # Now we need to fill remaining_weight_capacity using items of weight 1 and 2.\n        # This is the \"two-pointer\" or \"sliding window\" part.\n        # We try to use as many weight 2 items as possible, then fill with weight 1 items.\n        # Or, we can iterate k2 (number of weight 2 items) and then fill with k1 (number of weight 1 items).\n        # The optimized approach is to iterate k2 and use the precomputed P1.\n\n        # Iterate over the number of souvenirs of weight 2 (k2)\n        # The maximum number of weight 2 items we can pick is remaining_weight_capacity / 2.\n        # We iterate k2 from 0 up to min(len(costs2), remaining_weight_capacity / 2).\n        \n        # Initialize k2 to its maximum possible value for the current remaining_weight_capacity\n        # This is effectively the right pointer for weight 2 items.\n        k2 = min(len(costs2), remaining_weight_capacity // 2)\n        \n        # We can optimize this inner loop.\n        # Instead of iterating k2, we can iterate k1 (number of weight 1 items) and then determine k2.\n        # Or, we can iterate k2 and calculate the optimal k1.\n        # The problem asks for max cost, so for a fixed k3, we want max cost from (1,2) items.\n        # For a fixed k3, we have `rem_w = m - 3*k3`. We want to maximize `cost1 + cost2`\n        # for `k1*1 + k2*2 <= rem_w`.\n        # This subproblem (knapsack with weights 1 and 2) can be solved efficiently.\n        # A common technique for weights 1 and 2 is to iterate `k2` (number of items of weight 2)\n        # and then take as many items of weight 1 as possible.\n        \n        # Maximize cost from weight 1 and 2 items for current remaining_weight_capacity\n        # Let's use the two-pointer approach as described in the thought process:\n        # Iterate k2 (number of weight 2 items) from max possible down to 0.\n        # For each k2, calculate remaining weight for k1 items.\n        \n        # The two-pointer approach for (1,2) items:\n        # `k1` is the number of weight 1 items, `k2` is the number of weight 2 items.\n        # `k1_ptr` starts at 0, `k2_ptr` starts at max possible for `remaining_weight_capacity`.\n        # `current_cost_1_2` tracks the best cost for weight 1 and 2 items.\n        \n        # Initialize for the subproblem:\n        # Max number of weight 2 items we can take if we take 0 weight 1 items.\n        sub_k2 = min(len(costs2), remaining_weight_capacity // 2)\n        sub_current_cost_1_2 = P2[sub_k2]\n\n        # Max number of weight 1 items we can take if we take 0 weight 2 items.\n        sub_k1 = min(len(costs1), remaining_weight_capacity)\n        sub_current_cost_1_2 = max(sub_current_cost_1_2, P1[sub_k1])\n        \n        # This is the crucial part: iterate through the number of weight 2 items.\n        # For each `k2` (number of items of weight 2), calculate the max `k1` (number of items of weight 1).\n        # We want to find `max(P1[k1] + P2[k2])` such that `k1 + 2*k2 <= remaining_weight_capacity`.\n        \n        # Let's iterate `k2` from 0 up to `len(costs2)`.\n        # For each `k2`, calculate `rem_w_for_1 = remaining_weight_capacity - 2*k2`.\n        # Then, `k1 = min(len(costs1), rem_w_for_1)`.\n        # This would be another loop, potentially leading to O(M/3 * M/2) which is too slow.\n        \n        # The correct optimization for the (1,2) knapsack:\n        # Iterate `k2` from 0 up to `min(len(costs2), remaining_weight_capacity // 2)`.\n        # For each `k2`, calculate the current cost from weight 2 items: `P2[k2]`.\n        # Calculate the remaining weight for weight 1 items: `rem_w_for_1 = remaining_weight_capacity - 2 * k2`.\n        # The optimal number of weight 1 items is `min(len(costs1), rem_w_for_1)`.\n        # Add the cost from these weight 1 items: `P1[min(len(costs1), rem_w_for_1)]`.\n        # Update the maximum cost found for this `k3`.\n        \n        # This inner loop is O(M_rem / 2). Total complexity O(M/3 * M/2) = O(M^2). Still too slow.\n        # What if we iterate over k1 and k2 in a combined way?\n        # The \"two-pointer\" or \"sliding window\" approach works like this:\n        # For a fixed `k3`, we have `rem_w = m - 3*k3`.\n        # We want to maximize `P1[k1] + P2[k2]` s.t. `k1 + 2*k2 <= rem_w`.\n        # Let `k2` be the number of weight 2 items. Iterate `k2` from 0 up to `len(costs2)`.\n        # For each `k2`, `current_cost_2 = P2[k2]`.\n        # The weight used by `k2` items is `2*k2`.\n        # The remaining weight for weight 1 items is `rem_w - 2*k2`.\n        # The number of weight 1 items we can pick is `k1 = min(len(costs1), rem_w - 2*k2)`.\n        # The cost for weight 1 items is `P1[k1]`.\n        # Total cost for this `(k2, k1)` combination is `current_cost_2 + P1[k1]`.\n        # This is `O(M/3 * N2)` or `O(M/3 * M/2)` if N2 is limited by M. This is too slow.\n\n        # The key observation for the (1,2) subproblem:\n        # If we have `W` capacity for items of weight 1 and 2,\n        # we can iterate `k2` (number of weight 2 items).\n        # For each `k2`, we use `2*k2` weight, and `W - 2*k2` for weight 1 items.\n        # The cost is `P2[k2] + P1[min(len(costs1), W - 2*k2)]`.\n        # This still leads to `O(M)` for the inner part.\n        \n        # A more efficient way for the (1,2) subproblem:\n        # We have `rem_w` capacity.\n        # Let `k1` be the number of weight 1 items and `k2` be the number of weight 2 items.\n        # We want to maximize `P1[k1] + P2[k2]` such that `k1 + 2*k2 <= rem_w`.\n        # Iterate `k1` from `len(costs1)` down to 0. (This is `O(N1)`).\n        # For each `k1`, `rem_w_for_2 = rem_w - k1`.\n        # The maximum `k2` we can take is `min(len(costs2), rem_w_for_2 // 2)`.\n        # This is also `O(N1 * N2)` or `O(N1 * M)`.\n        \n        # The solution for (1,2) items with capacity `W` should be `O(W)` or `O(N1+N2)`.\n        # Let's fix `k1` (number of weight 1 items).\n        # `k1` can go from 0 up to `min(len(costs1), remaining_weight_capacity)`.\n        # For each `k1`, `current_cost_1 = P1[k1]`.\n        # `rem_w_for_2 = remaining_weight_capacity - k1`.\n        # Max `k2` is `min(len(costs2), rem_w_for_2 // 2)`.\n        # Cost is `P1[k1] + P2[k2]`.\n        # This is `O(N1)` or `O(M)` for the inner loop.\n        # Total `O(M/3 * M) = O(M^2)`. This is the issue.\n\n        # The actual \"two-pointer\" approach for the (1,2) problem:\n        # Let `k1_count` be the number of items of weight 1, `k2_count` for weight 2.\n        # `current_max_cost_1_2` for the current `rem_w`.\n        # We iterate `k1_count` from 0 up to `min(len(costs1), rem_w)`.\n        # For each `k1_count`, `rem_w_for_2 = rem_w - k1_count`.\n        # We need to find the best `k2_count` for `rem_w_for_2`.\n        # This implies `k2_count = min(len(costs2), rem_w_for_2 // 2)`.\n        # This is `O(N1)` or `O(M)` for the inner loop.\n        \n        # This is the standard approach for knapsack with small weights.\n        # The total complexity is `O(M/W_max * (N1 + W_max))`.\n        # Max number of items of weight 3 is `k3_max = m // 3`.\n        # For each `k3` from `0` to `k3_max`:\n        #   `rem_w = m - 3 * k3`.\n        #   We need to solve the (1,2) knapsack for `rem_w`.\n        #   Let `best_cost_1_2[w]` be the max cost for `w` capacity using (1,2) items.\n        #   We can precompute `best_cost_1_2` array up to `m`.\n        #   `best_cost_1_2[w]` = max cost for capacity `w` using only items of weight 1 and 2.\n        #   This itself can be computed in `O(m)` time.\n        #   `dp[w]` = max cost for capacity `w`.\n        #   For weight 1 items: `dp[w] = max(dp[w], dp[w-1] + costs1[k])`.\n        #   For weight 2 items: `dp[w] = max(dp[w], dp[w-2] + costs2[k])`.\n        #   This is `O(N*M)` if we consider all items.\n        #   But using prefix sums, `best_cost_1_2[w]` can be found by iterating `k2` from `0` to `w/2`.\n        #   `best_cost_1_2[w] = max_{k2} (P2[k2] + P1[min(len(costs1), w - 2*k2)])`.\n        #   This takes `O(w)` time.\n        #   So computing `best_cost_1_2` for all `w` up to `m` takes `O(m^2)`. Still too slow.\n\n        # The correct approach to the (1,2) subproblem in O(N1 + N2 + M) is:\n        # `current_total_cost_1_2 = 0`\n        # `k1_count = 0`\n        # `k2_count = min(len(costs2), remaining_weight_capacity // 2)`\n        # `current_total_cost_1_2 = P2[k2_count]`\n        # `current_max_for_rem_w = current_total_cost_1_2`\n\n        # Iterate `k1_count` from 0 up to `min(len(costs1), remaining_weight_capacity)`:\n        #   `current_total_cost_1_2 += costs1[k1_count]` (if `k1_count > 0`)\n        #   `weight_used_by_1 = k1_count * 1`\n        #   `rem_w_for_2 = remaining_weight_capacity - weight_used_by_1`\n        #   While `k2_count > 0` and `2 * k2_count > rem_w_for_2`:\n        #       `current_total_cost_1_2 -= costs2[k2_count - 1]`\n        #       `k2_count -= 1`\n        #   `current_max_for_rem_w = max(current_max_for_rem_w, current_total_cost_1_2)`\n        # This is the standard two-pointer for the (1,2) subproblem.\n        # For a fixed `k3`, this inner loop (for `k1` and `k2`) takes `O(N1 + N2)` time.\n        # Total time complexity: `O(M/3 * (N1 + N2))`.\n        # Given N1, N2 can be up to 10^5, M/3 can be 10^5. So (10^5 * 10^5) is too slow.\n\n        # The constraints `N <= 100000`, `M <= 300000`.\n        # My previous analysis for the (1,2) subproblem was incorrect.\n        # The (1,2) subproblem can be solved in O(N1 + N2) or O(M_rem) time.\n        # For a fixed `k3`, `rem_w = m - 3*k3`.\n        # We want to find `max(P1[k1] + P2[k2])` such that `k1 + 2*k2 <= rem_w`.\n        # Let's iterate `k2` from 0 up to `min(len(costs2), rem_w // 2)`.\n        # For each `k2`, calculate `cost2 = P2[k2]`.\n        # The remaining weight is `rem_w - 2*k2`.\n        # The number of weight 1 items we can take is `k1 = min(len(costs1), rem_w - 2*k2)`.\n        # The cost is `cost2 + P1[k1]`.\n        # This is `O(M_rem)` for each `k3`.\n        # Total: `O(M/3 * M_rem)` which is `O(M^2)`.\n\n        # Okay, the problem is solvable in O(M + N) or O(M log N) or O(N log N).\n        # The constraint `wi <= 3` is critical.\n        # Let's consider `dp[w]` as the maximum value for weight `w`.\n        # `dp` array size `m+1`.\n        # `dp[0] = 0`, `dp[i] = -infinity` for `i > 0`.\n        # For each item `(w, c)`:\n        #   For `j` from `m` down to `w`:\n        #     `dp[j] = max(dp[j], dp[j-w] + c)`\n        # This is `O(N*M)`, too slow.\n\n        # Since weights are small, we can use a specialized DP.\n        # For each weight `w` from 1 to 3:\n        #   Iterate through `cost_list_w` (sorted descending).\n        #   For each `c` in `cost_list_w`:\n        #     For `j` from `m` down to `w`:\n        #       `dp[j] = max(dp[j], dp[j-w] + c)`\n        # This is `O(N*M)` again.\n\n        # The solution for small weights is usually to group items by weight.\n        # Let's re-examine the (1,2) subproblem.\n        # We need to compute `f(W)` = max cost for capacity `W` using items of weight 1 and 2.\n        # `f(W) = max_{k2=0 to W/2} (P2[k2] + P1[min(len(costs1), W - 2*k2)])`.\n        # This `f(W)` can be computed for all `W` from 0 to `m` in `O(m)` total time.\n        # How?\n        # Let `current_k2` be the number of weight 2 items.\n        # Let `current_cost_1_2 = 0`.\n        # `k1_ptr = 0` (number of weight 1 items).\n        # `k2_ptr = min(len(costs2), W // 2)`.\n        # `current_cost_1_2 = P2[k2_ptr]`\n        # For `k1_ptr` from 0 to `min(len(costs1), W)`:\n        #   `cost_from_1 = P1[k1_ptr]`\n        #   `rem_w_for_2 = W - k1_ptr`\n        #   While `k2_ptr > 0` and `2 * k2_ptr > rem_w_for_2`:\n        #       `k2_ptr -= 1`\n        #   `cost_from_2 = P2[k2_ptr]`\n        #   `f(W) = max(f(W), cost_from_1 + cost_from_2)`.\n        # This is `O(W)` for each `W`. Still `O(M^2)` to precompute `f(W)` for all `W`.\n\n        # The actual trick is that `f(W)` can be computed in `O(W)` total for all `W` up to `M`.\n        # `f[w]` stores the maximum cost for weight `w` using only items of weight 1 and 2.\n        # `f[w]` can be computed using a sliding window approach.\n        # `k2` iterates from `0` to `len(costs2)`.\n        # `k1` iterates from `len(costs1)` down to `0`.\n        # `current_cost_1 = 0`.\n        # `k1_idx = 0`.\n        # `k2_idx = min(len(costs2), m // 2)`.\n        # `current_cost_1_2 = P2[k2_idx]` (cost from weight 2 items, for `k1_idx=0`)\n        # `current_max_cost_1_2 = current_cost_1_2`\n        # For `k1_idx` from 1 to `len(costs1)`:\n        #   `current_cost_1_2 += costs1[k1_idx - 1]`\n        #   `current_weight_1 = k1_idx`\n        #   `remaining_w_for_2 = m - current_weight_1`\n        #   While `k2_idx > 0` and `2 * k2_idx > remaining_w_for_2`:\n        #       `current_cost_1_2 -= costs2[k2_idx - 1]`\n        #       `k2_idx -= 1`\n        #   If `current_weight_1 + 2 * k2_idx <= m`:\n        #       `current_max_cost_1_2 = max(current_max_cost_1_2, current_cost_1_2)`\n        # This computes the best (1,2) combination for the *total* capacity `m`.\n        # We need it for `rem_w`.\n\n        # Let's reconsider the structure:\n        # Iterate `k3` from 0 to `min(len(costs3), m/3)`.\n        #   `current_cost = P3[k3]`.\n        #   `rem_w = m - 3*k3`.\n        #   Now we need to find the max cost for `rem_w` using weight 1 and 2 items.\n        #   This part should be `O(1)` if we precompute.\n        #   Let `dp12[w]` be the max cost using weight 1 and 2 items for capacity `w`.\n        #   `dp12` can be computed in `O(m)` total time.\n        #   `dp12[0] = 0`.\n        #   `k2 = 0`\n        #   `current_cost_12_sum = 0`\n        #   `best_cost_so_far_for_weight_12 = 0`\n        #   For `w` from 0 to `m`:\n        #       While `k2 < len(costs2)` and `2*(k2+1) <= w`:\n        #           `current_cost_12_sum += costs2[k2]`\n        #           `k2 += 1`\n        #       `dp12[w] = max(dp12[w-1] if w > 0 else 0, current_cost_12_sum + P1[min(len(costs1), w - 2*k2)])`\n        # This is not how `dp12` is computed.\n        # `dp12[w]` is the maximum value for weight `w` using items of weight 1 and 2.\n        # Iterate `k1` from `0` to `len(costs1)`.\n        #   For `w` from `k1` to `m`:\n        #     `dp12[w] = max(dp12[w], P1[k1] + P2[min(len(costs2), (w-k1)//2)])`\n        # Still `O(N1*M)`.\n\n        # The correct approach to precompute `dp12[w]` for all `w` up to `m` in `O(M + N1 + N2)`:\n        # `dp12 = [0] * (m + 1)`\n        # `k2_ptr = 0` (index for costs2)\n        # `current_cost_from_2 = 0`\n        # For `w` from 0 to `m`:\n        #     # Try to add another item of weight 2\n        #     while `k2_ptr < len(costs2)` and `2 * (k2_ptr + 1) <= w`:\n        #         `current_cost_from_2 += costs2[k2_ptr]`\n        #         `k2_ptr += 1`\n        #     \n        #     # Calculate cost for current `w` using `k2_ptr` items of weight 2\n        #     # and as many weight 1 items as possible for remaining capacity.\n        #     `rem_w_for_1 = w - 2 * k2_ptr`\n        #     `cost_from_1 = P1[min(len(costs1), rem_w_for_1)]`\n        #     `dp12[w] = current_cost_from_2 + cost_from_1`\n        #     \n        #     # This `dp12[w]` calculation is for a specific `k2_ptr`.\n        #     # We need to consider all combinations of `k1` and `k2`.\n        #     # The previous `dp12[w]` should be `max(dp12[w-1], current_cost_from_2 + cost_from_1)`\n        #     # This is tricky.\n        \n        # Let's use the standard \"two pointers\" to find `max_cost_1_2(W)` for a given `W`.\n        # It takes `O(N1 + N2)` time for ONE `W`.\n        # This is what I called `O(M/3 * (N1 + N2))` earlier.\n        # `N1 + N2` can be up to `N=100000`. `M/3` can be `100000`.\n        # So `10^5 * 10^5` is `10^10`, too slow.\n\n        # The key insight must be that `k3` does not need to be iterated up to `M/3`.\n        # Or, the (1,2) subproblem can be solved faster than `O(N1+N2)` within the loop.\n\n        # What if `k3` is small? Then `rem_w` is large.\n        # What if `k3` is large? Then `rem_w` is small.\n        # The number of weight 3 items is at most `N` and at most `M/3`.\n        # Let `num_k3 = min(len(costs3), m // 3)`.\n        # Let `num_k2 = min(len(costs2), m // 2)`.\n        # Let `num_k1 = min(len(costs1), m)`.\n\n        # The approach that is `O(M + N)` or `O(M log N)` or `O(N log N)`:\n        # 1. Sort costs for each weight category (done).\n        # 2. Compute prefix sums (done).\n        # 3. Iterate `k3` from 0 to `min(len(costs3), m // 3)`.\n        #    `current_cost_k3 = P3[k3]`.\n        #    `rem_w = m - 3*k3`.\n        #    Now we need to find `max_cost_1_2(rem_w)`.\n        #    This `max_cost_1_2(rem_w)` is the tricky part.\n\n        # Let's try to compute `max_cost_1_2(w)` for all `w` from `0` to `m` efficiently.\n        # `max_cost_1_2[w]` = max cost for weight `w` using only items of weight 1 and 2.\n        # `max_cost_1_2 = [0] * (m + 1)`\n        # `k2_count = 0`\n        # `current_cost_for_k2 = 0`\n        # For `k1_count` from 0 to `len(costs1)`:\n        #   `current_cost_for_k1 = P1[k1_count]`\n        #   `weight_used_by_k1 = k1_count * 1`\n        #   If `weight_used_by_k1 > m`: break\n        #   `remaining_capacity_for_2 = m - weight_used_by_k1`\n        #   \n        #   # Now, for this `k1_count`, we need to find the best `k2_count` such that `2*k2_count <= remaining_capacity_for_2`.\n        #   # This `k2_count` is `min(len(costs2), remaining_capacity_for_2 // 2)`.\n        #   # Let's call this `optimal_k2_for_this_rem_cap`.\n        #   `optimal_k2_for_this_rem_cap = min(len(costs2), remaining_capacity_for_2 // 2)`\n        #   `cost_from_optimal_k2 = P2[optimal_k2_for_this_rem_cap]`\n        #   \n        #   # The total cost for this `k1_count` is `current_cost_for_k1 + cost_from_optimal_k2`.\n        #   # This is a candidate for `max_total_cost`.\n        #   `max_total_cost = max(max_total_cost, current_cost_for_k1 + cost_from_optimal_k2)`\n        #\n        # This is `O(N1)` for the (1,2) problem for the *total* `m`.\n        # But we need it for `rem_w`.\n        #\n        # The actual solution for the (1,2) subproblem for *all* `W` up to `M` in `O(M + N1 + N2)`:\n        # `max_cost_1_2 = [0] * (m + 1)`\n        # `k2_idx = 0`\n        # `current_cost_2 = 0`\n        # For `w` from 0 to `m`:\n        #     # Option 1: Don't take any more weight 2 items than `k2_idx`\n        #     # `cost_from_1 = P1[min(len(costs1), w - 2 * k2_idx)]`\n        #     # `current_val = current_cost_2 + cost_from_1`\n        #     \n        #     # Option 2: Try to take one more weight 2 item if possible\n        #     `val_with_k2_idx_items = current_cost_2 + P1[min(len(costs1), w - 2 * k2_idx)]`\n        #     \n        #     `val_with_k2_idx_plus_1_items = -1` # sentinel for impossible\n        #     if `k2_idx + 1 <= len(costs2)` and `2 * (k2_idx + 1) <= w`:\n        #         `val_with_k2_idx_plus_1_items = (current_cost_2 + costs2[k2_idx]) + P1[min(len(costs1), w - 2 * (k2_idx + 1))]`\n        #     \n        #     `max_cost_1_2[w] = max(val_with_k2_idx_items, val_with_k2_idx_plus_1_items)`\n        #     if `w > 0`: `max_cost_1_2[w] = max(max_cost_1_2[w], max_cost_1_2[w-1])`\n        #     \n        #     # If `val_with_k2_idx_plus_1_items` was better, advance `k2_idx` for next `w`.\n        #     # This logic is flawed. We need to find the best `k2_idx` for each `w`.\n        #     # The two-pointer approach for precomputing `max_cost_1_2` for all `w` is:\n        #\n        # `max_cost_1_2 = [0] * (m + 1)`\n        # `k2_ptr = 0`\n        # `current_cost_2_items = 0`\n        # For `w` from 0 to `m`:\n        #     # `max_cost_1_2[w]` should be `max(max_cost_1_2[w-1], ...)`\n        #     # The value for `w` can be formed by `w-1` and adding a weight 1 item,\n        #     # or `w-2` and adding a weight 2 item.\n        #     # This is the standard DP, which is `O(M)` for each item type.\n        #     # For weight 1 items: `dp[w] = max(dp[w], dp[w-1] + c1)`\n        #     # For weight 2 items: `dp[w] = max(dp[w], dp[w-2] + c2)`\n        #     # If we have many items of the same weight, we use the specific DP.\n        #     # For weight 1 items: `for i in range(len(costs1)): for w from m down to 1: dp[w] = max(dp[w], dp[w-1] + costs1[i])` -> O(N1*M)\n        #     # This is where the prefix sums come in.\n        #\n        # `max_cost_1_2 = [0] * (m + 1)`\n        # `k2_idx = len(costs2)`\n        # `current_cost_2 = P2[k2_idx]`\n        # For `k1_idx` from 0 to `len(costs1)`:\n        #     `cost_1 = P1[k1_idx]`\n        #     `weight_1 = k1_idx`\n        #     `remaining_w = m - weight_1`\n        #     \n        #     while `k2_idx > 0` and `2 * k2_idx > remaining_w`:\n        #         `k2_idx -= 1`\n        #         `current_cost_2 = P2[k2_idx]`\n        #     \n        #     `current_total_weight = weight_1 + 2 * k2_idx`\n        #     if `current_total_weight <= m`:\n        #         `max_total_cost = max(max_total_cost, cost_1 + current_cost_2)`\n        # This is for `m` total.\n        \n        # The problem is that the `k3` loop means `rem_w` changes.\n        # We need `max_cost_1_2[w]` for *all* `w` from `0` to `m`.\n        # This `max_cost_1_2` array is what the `O(M + N1 + N2)` part computes.\n        \n        # Let `dp_12[w]` be the maximum value for weight `w` using only weight 1 and weight 2 items.\n        # `dp_12 = [0] * (m + 1)`\n        # `k2_ptr = 0`\n        # `current_cost_2_items = 0`\n        # For `w` from 0 to `m`:\n        #     # Option 1: Don't take any weight 2 items, only weight 1 items.\n        #     `val1 = P1[min(len(costs1), w)]`\n        #     \n        #     # Option 2: Consider `k2_ptr` items of weight 2 and weight 1 items for remaining capacity.\n        #     # This `k2_ptr` should be adjusted for each `w`.\n        #     # The `k2_ptr` should be the maximum `k2` such that `2*k2 <= w`.\n        #     `k2_for_w = min(len(costs2), w // 2)`\n        #     `val2 = P2[k2_for_w] + P1[min(len(costs1), w - 2 * k2_for_w)]`\n        #     \n        #     # This is not enough, because `P2[k2_for_w]` might not be optimal.\n        #     # Example: `w=3`. `k2_for_w = 1`. `val2 = P2[1] + P1[1]`.\n        #     # But `P1[3]` might be better.\n        #     # The `max_cost_1_2[w]` should be calculated using a sweep line / two pointers.\n        #\n        # `max_cost_1_2 = [0] * (m + 1)`\n        # `k1_ptr = 0`\n        # `k2_ptr = min(len(costs2), m // 2)`\n        # `current_sum_1_2 = P2[k2_ptr]`\n        # For `w` from 0 to `m`:\n        #     # Adjust `k1_ptr` for `w`.\n        #     # `k1_ptr` should be `min(len(costs1), w)`.\n        #     # `cost_from_1 = P1[k1_ptr]`\n        #     # `rem_w_for_2 = w - k1_ptr`\n        #     # `k2_ptr_for_w = min(len(costs2), rem_w_for_2 // 2)`\n        #     # `cost_from_2 = P2[k2_ptr_for_w]`\n        #     # `max_cost_1_2[w] = cost_from_1 + cost_from_2`\n        #     # This is `O(M)`.\n        #     # But this is wrong. The `k1_ptr` for `w` should be determined by the loop.\n        \n        # Let's try the DP approach for `max_cost_1_2` again, but correctly.\n        # `dp_12[w]` = max cost for capacity `w` using only weight 1 and 2 items.\n        # `dp_12 = [0] * (m + 1)`\n        # `k2_idx = 0`\n        # `current_cost_2 = 0`\n        # For `k1_idx` from 0 to `len(costs1)`:\n        #     `cost_1 = P1[k1_idx]`\n        #     `weight_1 = k1_idx`\n        #     \n        #     # For this fixed `k1_idx`, we want to find the best `k2_idx` for each `w`.\n        #     # This is not how `dp_12` is built.\n        #     # `dp_12` must be built by iterating `w` from 0 to `m`.\n        #     # For each `w`, calculate `dp_12[w]`.\n        #\n        # The correct linear scan for `dp_12[w]` for all `w` up to `m`:\n        # `dp_12 = [0] * (m + 1)`\n        # `k2_ptr = 0` # Number of weight 2 items currently considered\n        # `current_cost_2 = 0` # Sum of costs of `k2_ptr` weight 2 items\n        # For `w` from 0 to `m`:\n        #     # Option 1: Take `k1` items of weight 1 and `k2` items of weight 2.\n        #     # `k1` and `k2` must sum to `w`.\n        #     # We maintain `k2_ptr` such that `2*k2_ptr` is the largest even weight less than or equal to `w`.\n        #     # This is not quite right. `k2_ptr` should be the number of weight 2 items.\n        #     \n        #     # `dp_12[w]` is the maximum of:\n        #     # 1. `dp_12[w-1]` (if `w > 0`, don't add anything, or add weight 1 item)\n        #     # 2. `dp_12[w-2]` (if `w > 1`, add weight 2 item)\n        #     # But this is for a limited number of items. We have many items.\n        #     # For many items, it's `dp[w] = max(dp[w-1]+c1, dp[w-2]+c2)` if we only have one of each.\n        #     # With many items, it's `dp[w] = max(dp[w-1]+costs1[i], dp[w-2]+costs2[j])`.\n        #     # This is where the prefix sums are used.\n        #\n        # `dp_12 = [0] * (m + 1)`\n        # `k2_idx = 0` # Pointer to the next best weight 2 item to consider\n        # `current_cost_2 = 0` # Sum of costs of weight 2 items up to `k2_idx-1`\n        # For `w` from 0 to `m`:\n        #     # `dp_12[w]` is the max cost for capacity `w`.\n        #     # It can be formed by `P1[k1] + P2[k2]` where `k1 + 2*k2 = w`.\n        #     # Or `k1 + 2*k2 <= w` for optimal packing.\n        #     \n        #     # For each `w`, we consider taking `k2` items of weight 2, and `k1` items of weight 1.\n        #     # The maximum `k2` is `w // 2`.\n        #     # The number of weight 1 items is `w - 2*k2`.\n        #     \n        #     # We need to find `max_{k2=0 to min(len(costs2), w//2)} (P2[k2] + P1[min(len(costs1), w - 2*k2)])`.\n        #     # This inner loop is `O(w)`. So `O(M^2)` total. This is the problem.\n        #\n        # The trick for `max_cost_1_2[w]` for all `w` in `O(M + N1 + N2)`:\n        # `max_cost_1_2 = [0] * (m + 1)`\n        # `k2_ptr = 0`\n        # `current_sum_k2 = 0`\n        # For `k1_ptr` from 0 to `len(costs1)`:\n        #     `current_sum_k1 = P1[k1_ptr]`\n        #     `weight_k1 = k1_ptr`\n        #     \n        #     `remaining_w_for_2_items = m - weight_k1`\n        #     \n        #     # `k2_ptr` should be limited by `len(costs2)` and `remaining_w_for_2_items`.\n        #     # We need to find the optimal `k2_ptr` for *each* `w` from `weight_k1` to `m`.\n        #     # This is still not the right way to think about it.\n        \n        # Let's consider the items.\n        # We have `N1` items of weight 1, `N2` of weight 2, `N3` of weight 3.\n        # `max_total_cost = 0`.\n        # `current_cost_12_subproblem = 0`.\n        # `k2_ptr = 0`.\n        # `k1_ptr = 0`.\n        # For `k3` from 0 to `min(len(costs3), m // 3)`:\n        #     `cost_3 = P3[k3]`\n        #     `weight_3 = k3 * 3`\n        #     `rem_w = m - weight_3`\n        #     \n        #     # Now, solve `k1*1 + k2*2 <= rem_w` for max `P1[k1] + P2[k2]`.\n        #     # This is the \"two-pointer\" part for the (1,2) subproblem.\n        #     # `k1_ptr` iterates from `0` to `min(len(costs1), rem_w)`.\n        #     # `k2_ptr` starts at `min(len(costs2), rem_w // 2)` and decreases.\n        #     # We need to compute `max_cost_1_2(rem_w)` in `O(1)` or `O(log M)` time.\n        #     # This implies `max_cost_1_2` array is precomputed.\n        \n        # Let's precompute `max_cost_1_2[w]` for all `w` from `0` to `m`.\n        # `max_cost_1_2 = [0] * (m + 1)`\n        # `k2_idx = 0` # Number of items of weight 2 currently considered.\n        # `current_cost_2_sum = 0` # Sum of costs of `k2_idx` items of weight 2.\n        # For `k1_idx` from 0 to `len(costs1)`:\n        #     `cost_1_sum = P1[k1_idx]`\n        #     `weight_1_used = k1_idx`\n        #     \n        #     `max_possible_weight_for_this_k1 = weight_1_used + 2 * len(costs2)`\n        #     \n        #     # The actual weight `w` is `weight_1_used + 2 * k2_idx_actual`.\n        #     # We need to fill `max_cost_1_2[w]` for all `w`.\n        #     \n        #     # This is the correct dynamic programming for the (1,2) subproblem.\n        #     # `dp[w]` = max cost for weight `w` using (1,2) items.\n        #     # `dp = [0] * (m + 1)`\n        #     # For `i` from 0 to `len(costs1)-1`:\n        #     #    For `w` from `m` down to `1`:\n        #     #        `dp[w] = max(dp[w], dp[w-1] + costs1[i])`\n        #     # For `i` from 0 to `len(costs2)-1`:\n        #     #    For `w` from `m` down to `2`:\n        #     #        `dp[w] = max(dp[w], dp[w-2] + costs2[i])`\n        #     # This is `O(N1*M + N2*M)`, too slow.\n        \n        # The key is that `max_cost_1_2[w]` can be computed using a sliding window.\n        # `max_cost_1_2 = [0] * (m + 1)`\n        # `k1_count = 0`\n        # `current_val_1 = 0`\n        # `k2_count = 0`\n        # `current_val_2 = 0`\n        # For `w` from 0 to `m`:\n        #     # Try to add a weight 1 item\n        #     `val_with_1 = 0`\n        #     if `w >= 1` and `k1_count < len(costs1)`:\n        #         `val_with_1 = current_val_1 + costs1[k1_count]`\n        #     \n        #     # Try to add a weight 2 item\n        #     `val_with_2 = 0`\n        #     if `w >= 2` and `k2_count < len(costs2)`:\n        #         `val_with_2 = current_val_2 + costs2[k2_count]`\n        #     \n        #     # This is not DP.\n        \n        # The efficient way to compute `max_cost_1_2[w]` for all `w` up to `m`:\n        # `max_cost_1_2 = [0] * (m + 1)`\n        # `k2_ptr = min(len(costs2), m // 2)` # Start k2_ptr at max possible for total M\n        # `current_cost_1_2_sum = P2[k2_ptr]` # Sum for k2_ptr items of weight 2\n        # For `k1_ptr` from 0 to `len(costs1)`:\n        #     `current_weight_1 = k1_ptr`\n        #     `current_cost_1 = P1[k1_ptr]`\n        #     \n        #     `remaining_w_for_2 = m - current_weight_1`\n        #     \n        #     # Shrink `k2_ptr` if it's too large for `remaining_w_for_2`\n        #     while `k2_ptr > 0` and `2 * k2_ptr > remaining_w_for_2`:\n        #         `k2_ptr -= 1`\n        #         `current_cost_1_2_sum = P2[k2_ptr]` # Update sum to new k2_ptr\n        #     \n        #     # If `current_weight_1 + 2 * k2_ptr <= m`:\n        #     # This is the cost for total capacity `m` using `k1_ptr` and `k2_ptr`.\n        #     # `max_total_cost = max(max_total_cost, current_cost_1 + current_cost_1_2_sum)`\n        #     \n        #     # This is still not precomputing `max_cost_1_2[w]` for varying `w`.\n        #     # This computes the optimal for `m` directly.\n        \n        # The `max_cost_1_2[w]` array precomputation in `O(M + N1 + N2)`:\n        # `max_cost_1_2 = [0] * (m + 1)`\n        # `k2_idx = 0`\n        # `current_cost_2 = 0`\n        # `current_max_val_1_2 = 0`\n        # For `w` from 0 to `m`:\n        #     # Option 1: Don't use any weight 2 items, only weight 1 items.\n        #     # This is `P1[min(len(costs1), w)]`.\n        #     `option1_val = P1[min(len(costs1), w)]`\n        #     \n        #     # Option 2: Use `k2_idx` items of weight 2, and fill remaining with weight 1.\n        #     # `k2_idx` is the maximum number of weight 2 items that can fit into `w`.\n        #     # This `k2_idx` needs to be updated.\n        #     while `k2_idx < len(costs2)` and `2 * (k2_idx + 1) <= w`:\n        #         `current_cost_2 += costs2[k2_idx]`\n        #         `k2_idx += 1`\n        #     \n        #     `rem_w_for_1 = w - 2 * k2_idx`\n        #     `option2_val = current_cost_2 + P1[min(len(costs1), rem_w_for_1)]`\n        #     \n        #     `max_cost_1_2[w] = max(option1_val, option2_val)`\n        #     if `w > 0`: `max_cost_1_2[w] = max(max_cost_1_2[w], max_cost_1_2[w-1])` # ensures non-decreasing\n        # This is `O(M + N2 + N1)`. This seems correct!\n        # `k2_idx` only increases, `P1` lookup is `O(1)`. `current_cost_2` only increases.\n        # Total `O(M + N1 + N2)` to build `max_cost_1_2`.\n        \n        # Then, the main loop:\n        # `max_total_cost = 0`\n        # For `k3` from 0 to `min(len(costs3), m // 3)`:\n        #     `current_cost_3 = P3[k3]`\n        #     `weight_3_used = k3 * 3`\n        #     `rem_w = m - weight_3_used`\n        #     `max_total_cost = max(max_total_cost, current_cost_3 + max_cost_1_2[rem_w])`\n        # This loop is `O(M/3)`.\n        # Total complexity: `O(M + N1 + N2 + M/3) = O(M + N)`. This is efficient enough!\n\n    # Precompute max_cost_1_2[w] for all w from 0 to m\n    max_cost_1_2 = [0] * (m + 1)\n    k2_idx = 0  # Pointer to the next best weight 2 item to consider\n    current_cost_2 = 0 # Sum of costs of weight 2 items taken (up to k2_idx-1)\n\n    for w in range(m + 1):\n        # Option 1: Only use weight 1 items up to capacity w.\n        # This uses P1[min(len(costs1), w)]\n        option1_val = P1[min(len(costs1), w)]\n\n        # Option 2: Use some weight 2 items and fill the rest with weight 1 items.\n        # `k2_idx` should be the maximum number of weight 2 items that can fit into `w`\n        # if we are prioritizing weight 2 items (amongst 1 and 2).\n        \n        # Advance k2_idx as much as possible for current `w`.\n        # `k2_idx` is the count of weight 2 items.\n        # `current_cost_2` is the sum of costs of `k2_idx` items.\n        while k2_idx < len(costs2) and 2 * (k2_idx + 1) <= w:\n            current_cost_2 += costs2[k2_idx]\n            k2_idx += 1\n        \n        # Calculate remaining capacity for weight 1 items after taking `k2_idx` items of weight 2.\n        rem_w_for_1 = w - 2 * k2_idx\n        option2_val = current_cost_2 + P1[min(len(costs1), rem_w_for_1)]\n        \n        # max_cost_1_2[w] is the maximum of these two options.\n        max_cost_1_2[w] = max(option1_val, option2_val)\n        \n        # Also, ensure that max_cost_1_2 is non-decreasing.\n        # If we can achieve `X` for `w-1`, we can also achieve `X` for `w` (by not adding anything).\n        if w > 0:\n            max_cost_1_2[w] = max(max_cost_1_2[w], max_cost_1_2[w-1])\n\n    # Main loop: Iterate over the number of souvenirs of weight 3 (k3)\n    max_total_cost = 0\n    for k3 in range(len(costs3) + 1):\n        current_cost_3 = P3[k3]\n        current_weight_3_used = k3 * 3\n\n        if current_weight_3_used > m:\n            break # Cannot pick k3 items of weight 3\n\n        remaining_weight_capacity = m - current_weight_3_used\n        \n        # Add the maximum cost from weight 1 and 2 items for the remaining capacity\n        max_total_cost = max(max_total_cost, current_cost_3 + max_cost_1_2[remaining_weight_capacity])\n\n    sys.stdout.write(str(max_total_cost) + '\\n')\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 496,
        "completion_token_count": 13679,
        "thoughts_token_count": 773
    }
}