{
    "start": 1758285122.0499635,
    "end": 1758285178.8371854,
    "start-formatted": "2025-09-19 21:32 KST",
    "end-formatted": "2025-09-19 21:32 KST",
    "gpu": 2,
    "pid": 30,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# TV Game\n\nThere is a new TV game on BerTV. In this game two players get a number A consisting of 2n digits. Before each turn players determine who will make the next move. Each player should make exactly n moves. On it's turn i-th player takes the leftmost digit of A and appends it to his or her number Si. After that this leftmost digit is erased from A. Initially the numbers of both players (S1 and S2) are «empty». Leading zeroes in numbers A, S1, S2 are allowed. In the end of the game the first player gets S1 dollars, and the second gets S2 dollars.One day Homer and Marge came to play the game. They managed to know the number A beforehand. They want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize. Help them.\n\n## Input\nThe first line contains integer n (1 ≤ n ≤ 18). The second line contains integer A consisting of exactly 2n digits. This number can have leading zeroes.\n\n## Output\nOutput the line of 2n characters «H» and «M» — the sequence of moves of Homer and Marge, which gives them maximum possible total prize. Each player must make exactly n moves. If there are several solutions, output any of them.\n\n## Example\n### Input\n['2\\n1234', '2\\n9911']\n\n### Output\n['HHMM', 'HMHM']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "**Tackling the TV Game**\n\nAlright, I'm facing this \"TV Game\" problem, and I need a Python script to crack it. Let's break down my thoughts. The core of it is a competitive scenario with two players, Homer and Marge. They're given a number `A` which has an even number of digits, specifically `2n` digits.  Each player gets `n` moves, taking the leftmost digit from `A` in each turn and appending it to their own number, `S1` for Homer and `S2` for Marge.  The objective is to *maximize* the sum of `S1` and `S2`. I need to figure out the best sequence of moves, represented as 'H' for Homer and 'M' for Marge.\n\nI went through the provided example with `n=2` and `A=\"1234\"`, playing out different scenarios.  It's clear that the order of picking digits significantly affects the final sum. The initial exploration showed me that picking the smaller digits early results in a lower overall total. I played it through with various move sequences, trying to understand the nuances of the interaction.\n\nHere's the key: the position of a digit in the original number `A` dictates its \"significance\" in the players' final numbers. A digit taken early will occupy a higher-order place value (e.g., tens, hundreds).\n\nEssentially, I need a strategy to decide which player gets which digit, and ideally, I'm aiming for an *optimal* allocation of digits to maximize the total sum.  I need to consider the impact of each digit's position. It feels like this can be a *greedy* approach, which I'll be exploring for the logic. I can think about this problem as splitting the digits into two sets.\n",
    "response": "```python\nimport sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n    a_str = sys.stdin.readline().strip()\n\n    # The problem asks to maximize S1 + S2.\n    # S1 and S2 are formed by taking n digits each from A,\n    # maintaining their relative order.\n    # The total sum S1 + S2 is maximized when the sum of digits\n    # at each position (weighted by power of 10) is maximized.\n    #\n    # Consider the digits of A: d_0, d_1, ..., d_{2n-1}.\n    #\n    # If Homer takes d_i and Marge takes d_j (where i < j),\n    # and these are the k-th digits taken by Homer and Marge respectively,\n    # then d_i contributes d_i * 10^(n-1-k_Homer) to S1,\n    # and d_j contributes d_j * 10^(n-1-k_Marge) to S2.\n    #\n    # The crucial insight is that the sum S1 + S2 is maximized\n    # if we assign the most significant digits (leftmost digits from A)\n    # to the player who will make it a most significant digit in their number.\n    #\n    # For example, if we have 2n digits, d_0, ..., d_{2n-1}.\n    # Homer takes n digits, Marge takes n digits.\n    # S1 = d_x0 * 10^(n-1) + d_x1 * 10^(n-2) + ... + d_x(n-1) * 10^0\n    # S2 = d_y0 * 10^(n-1) + d_y1 * 10^(n-2) + ... + d_y(n-1) * 10^0\n    # where {x0, ..., x(n-1)} and {y0, ..., y(n-1)} are disjoint sets of indices\n    # from {0, ..., 2n-1}, and x0 < x1 < ... and y0 < y1 < ...\n    #\n    # The total sum S1 + S2 can be thought of as a sum of contributions from each digit d_i.\n    # Each digit d_i will contribute d_i * 10^p to either S1 or S2, for some power p.\n    # The power p depends on how many digits were taken *before* d_i by the same player.\n    #\n    # Let's consider the digits in pairs: (d_0, d_1), (d_2, d_3), ..., (d_{2n-2}, d_{2n-1}).\n    # For each pair (d_k, d_{k+1}):\n    # If Homer takes d_k and Marge takes d_{k+1}, this uses up one of Homer's choices and one of Marge's choices.\n    # If Homer takes d_k and Marge takes d_{k+1}, and these are the i-th digits for H and M respectively,\n    # then d_k contributes d_k * 10^(n-1-i) to S1, and d_{k+1} contributes d_{k+1} * 10^(n-1-i) to S2.\n    #\n    # The problem simplifies greatly because the relative order is preserved.\n    # This means the *k*-th digit taken by Homer will always be at position `n-1-k` in `S1` (0-indexed from right).\n    # Same for Marge and `S2`.\n    #\n    # To maximize the sum, we want to assign larger digits to higher powers of 10.\n    # The highest powers of 10 (10^(n-1)) will come from the *first* digit taken by each player.\n    # The next highest (10^(n-2)) will come from the *second* digit taken by each player, and so on.\n    #\n    # So, for the first digit of S1 and S2 (which get multiplied by 10^(n-1)), we should assign the two largest digits from A.\n    # But we can't just pick any two largest. We must pick d_i and d_j such that i < j.\n    #\n    # This is not a simple greedy choice on individual digits.\n    #\n    # Let's consider the total sum S1 + S2.\n    # S1 = sum_{k=0}^{n-1} (digit_H_k * 10^(n-1-k))\n    # S2 = sum_{k=0}^{n-1} (digit_M_k * 10^(n-1-k))\n    # S1 + S2 = sum_{k=0}^{n-1} ((digit_H_k + digit_M_k) * 10^(n-1-k))\n    #\n    # Where digit_H_k is the (k+1)-th digit Homer takes, and digit_M_k is the (k+1)-th digit Marge takes.\n    #\n    # To maximize this sum, we need to maximize (digit_H_k + digit_M_k) for each k, especially for small k (high powers of 10).\n    #\n    # This means for the highest power of 10 (k=0), we want to pick two digits d_i and d_j (i < j) from A\n    # such that d_i + d_j is maximized.\n    # If Homer takes d_i and Marge takes d_j, then d_i becomes digit_H_0 and d_j becomes digit_M_0.\n    #\n    # This implies a greedy strategy:\n    # For the k-th pair of digits (from the left of the remaining A) to be assigned to Homer and Marge's (k+1)-th positions:\n    # We look at the current leftmost available digit, say `d_x`.\n    # And the next leftmost available digit, say `d_y`.\n    #\n    # If Homer takes `d_x` and Marge takes `d_y`, their sum is `d_x + d_y`.\n    # If Marge takes `d_x` and Homer takes `d_y`, their sum is `d_x + d_y`.\n    #\n    # The problem states \"maximizes their total prize\".\n    # The sum `S1 + S2` is maximized if, for each position `k` (from `n-1` down to `0`),\n    # the sum of the `k`-th digit of `S1` and the `k`-th digit of `S2` is maximized.\n    #\n    # Let's process the digits of A in pairs: (A[0], A[1]), (A[2], A[3]), ..., (A[2n-2], A[2n-1]).\n    # For each pair of digits A[i] and A[i+1]:\n    # Homer needs to take n digits, Marge needs to take n digits.\n    #\n    # Consider the first two digits, A[0] and A[1].\n    # Homer will take one, Marge will take the other.\n    # If Homer takes A[0] and Marge takes A[1], then S1 starts with A[0] and S2 starts with A[1].\n    # If Marge takes A[0] and Homer takes A[1], then S1 starts with A[1] and S2 starts with A[0].\n    #\n    # The contribution to S1 + S2 from these two digits will be:\n    # (A[0] * 10^(n-1) + A[1] * 10^(n-1)) if H takes A[0] and M takes A[1]\n    # OR (A[1] * 10^(n-1) + A[0] * 10^(n-1)) if M takes A[0] and H takes A[1]\n    #\n    # In both cases, the sum of their values is (A[0] + A[1]) * 10^(n-1).\n    # This means for the first pair of digits taken (d_H_0 and d_M_0), it doesn't matter who takes which,\n    # as long as they are the first two digits to be assigned to S1 and S2.\n    # The sum (d_H_0 + d_M_0) * 10^(n-1) is fixed if we pick A[0] and A[1] for these roles.\n    #\n    # This logic applies to all pairs.\n    # The problem constraints (n <= 18) suggest that 2n is up to 36.\n    # A simple greedy approach works:\n    # For each pair of digits (A[2k], A[2k+1]):\n    # One player takes A[2k], the other takes A[2k+1].\n    # This uses up one move for Homer and one for Marge.\n    # This happens `n` times.\n    #\n    # If Homer takes A[2k] and Marge takes A[2k+1], then the sequence is 'H', 'M'.\n    # If Marge takes A[2k] and Homer takes A[2k+1], then the sequence is 'M', 'H'.\n    #\n    # Which choice is better?\n    # Homer wants to maximize S1. Marge wants to maximize S2.\n    # They jointly want to maximize S1 + S2.\n    #\n    # The total sum S1 + S2 is `sum_{k=0}^{n-1} ((digit_H_k + digit_M_k) * 10^(n-1-k))`.\n    #\n    # Consider the first pair of digits (A[0], A[1]).\n    # They will be the first digits of S1 and S2 (multiplied by 10^(n-1)).\n    # Their sum (A[0] + A[1]) * 10^(n-1) is fixed, regardless of who takes which.\n    #\n    # Consider the second pair of digits (A[2], A[3]).\n    # They will be the second digits of S1 and S2 (multiplied by 10^(n-2)).\n    # Their sum (A[2] + A[3]) * 10^(n-2) is fixed, regardless of who takes which.\n    #\n    # ...\n    #\n    # Consider the last pair of digits (A[2n-2], A[2n-1]).\n    # They will be the last digits of S1 and S2 (multiplied by 10^0).\n    # Their sum (A[2n-2] + A[2n-1]) * 10^0 is fixed, regardless of who takes which.\n    #\n    # This means that the total sum S1 + S2 is *always the same*, regardless of the sequence of moves,\n    # as long as Homer takes n digits and Marge takes n digits.\n    #\n    # Let's re-verify this.\n    # Suppose Homer takes d_i as his k-th digit and Marge takes d_j as her k-th digit.\n    # This means there are k digits before d_i that Homer took, and k digits before d_j that Marge took.\n    # The indices x_0, ..., x_{k-1} are Homer's previous choices.\n    # The indices y_0, ..., y_{k-1} are Marge's previous choices.\n    #\n    # The total number of digits processed up to this point is (k+1) + (k+1) = 2k+2.\n    #\n    # Let's trace the example: n=2, A=\"1234\"\n    #\n    # Case 1: HHMM\n    # H takes '1' (Homer's 1st, S1=\"1\")\n    # H takes '2' (Homer's 2nd, S1=\"12\")\n    # M takes '3' (Marge's 1st, S2=\"3\")\n    # M takes '4' (Marge's 2nd, S2=\"34\")\n    # Total = 12 + 34 = 46\n    #\n    # S1 = 1*10^1 + 2*10^0\n    # S2 = 3*10^1 + 4*10^0\n    # S1+S2 = (1+3)*10^1 + (2+4)*10^0 = 4*10 + 6*1 = 46\n    #\n    # Case 2: HMHM\n    # H takes '1' (Homer's 1st, S1=\"1\")\n    # M takes '2' (Marge's 1st, S2=\"2\")\n    # H takes '3' (Homer's 2nd, S1=\"13\")\n    # M takes '4' (Marge's 2nd, S2=\"24\")\n    # Total = 13 + 24 = 37\n    #\n    # S1 = 1*10^1 + 3*10^0\n    # S2 = 2*10^1 + 4*10^0\n    # S1+S2 = (1+2)*10^1 + (3+4)*10^0 = 3*10 + 7*1 = 37\n    #\n    # My previous reasoning was flawed. The sum S1 + S2 is *not* always the same.\n    # The digits `digit_H_k` and `digit_M_k` are *not* necessarily `A[2k]` and `A[2k+1]`.\n    # They are the k-th digits *taken by that player*.\n    #\n    # Let's re-examine S1 + S2 = sum_{k=0}^{n-1} ((digit_H_k + digit_M_k) * 10^(n-1-k)).\n    #\n    # In HHMM:\n    # k=0: digit_H_0 = A[0]='1', digit_M_0 = A[2]='3'. Sum = (1+3)*10^1 = 40\n    # k=1: digit_H_1 = A[1]='2', digit_M_1 = A[3]='4'. Sum = (2+4)*10^0 = 6\n    # Total = 40 + 6 = 46.\n    #\n    # In HMHM:\n    # k=0: digit_H_0 = A[0]='1', digit_M_0 = A[1]='2'. Sum = (1+2)*10^1 = 30\n    # k=1: digit_H_1 = A[2]='3', digit_M_1 = A[3]='4'. Sum = (3+4)*10^0 = 7\n    # Total = 30 + 7 = 37.\n    #\n    # The goal is to maximize `(digit_H_k + digit_M_k)` for small `k`.\n    # This means the largest digits from A should be assigned to `digit_H_0` and `digit_M_0`.\n    # The next largest to `digit_H_1` and `digit_M_1`, and so on.\n    #\n    # We have `2n` digits in A. Let's denote them `d_0, d_1, ..., d_{2n-1}`.\n    # We need to choose `n` digits for Homer and `n` for Marge.\n    #\n    # The problem is to find a permutation of 'H' and 'M' (n of each) that maximizes the sum.\n    #\n    # This is a dynamic programming problem.\n    # Let `dp[h_count][m_count][idx]` be the maximum sum of (S1_prefix + S2_prefix)\n    # where `h_count` digits have been assigned to Homer, `m_count` to Marge,\n    # and we are considering digits from `A[idx]` onwards.\n    # The state needs to capture the *current* value of S1 and S2, not just their sum.\n    # This would be `dp[h_count][m_count]` storing `(current_S1, current_S2)`.\n    # But `current_S1` and `current_S2` can be very large numbers.\n    #\n    # The total number of digits is `2n`. `n` is up to 18. `2n` is up to 36.\n    # A DP state `dp[h_taken][m_taken][idx]` would be `18 * 18 * 36`.\n    #\n    # What does `dp[h_taken][m_taken]` store?\n    # It should store the maximum sum of `(digit_H_k + digit_M_k)` for the remaining digits.\n    #\n    # Let `dp[i][j]` be the maximum *remaining* sum we can get if `i` digits have been taken by Homer\n    # and `j` digits have been taken by Marge.\n    # The current digit we are considering from A is `A[i+j]`.\n    #\n    # `dp[i][j]` = max total prize from `A[i+j ... 2n-1]` given `i` moves for H and `j` for M already made.\n    #\n    # Base case: `dp[n][n] = 0`.\n    #\n    # Transitions:\n    # `dp[i][j]`\n    #   Option 1: Homer takes `A[i+j]`.\n    #     New `S1` digit: `A[i+j]` at position `n-1-i`.\n    #     Contribution: `int(A[i+j]) * (10**(n-1-i))`\n    #     Recursive call: `dp[i+1][j]`\n    #     Total for this option: `int(A[i+j]) * (10**(n-1-i)) + dp[i+1][j]`\n    #   Option 2: Marge takes `A[i+j]`.\n    #     New `S2` digit: `A[i+j]` at position `n-1-j`.\n    #     Contribution: `int(A[i+j]) * (10**(n-1-j))`\n    #     Recursive call: `dp[i][j+1]`\n    #     Total for this option: `int(A[i+j]) * (10**(n-1-j)) + dp[i][j+1]`\n    #\n    # We need to store the path as well.\n    # `memo = {}`\n    # `path = {}`\n    #\n    # `solve(h_count, m_count)` function:\n    # `idx = h_count + m_count`\n    # If `idx == 2*n`: return 0\n    # If `(h_count, m_count)` in `memo`: return `memo[(h_count, m_count)]`\n    #\n    # `current_digit = int(a_str[idx])`\n    #\n    # `res_h = -1` (or some very small number)\n    # `res_m = -1`\n    #\n    # If `h_count < n`:\n    #   `val_h = current_digit * (10**(n-1-h_count))`\n    #   `res_h = val_h + solve(h_count + 1, m_count)`\n    #\n    # If `m_count < n`:\n    #   `val_m = current_digit * (10**(n-1-m_count))`\n    #   `res_m = val_m + solve(h_count, m_count + 1)`\n    #\n    # Compare `res_h` and `res_m`:\n    # If `res_h >= res_m`:\n    #   `memo[(h_count, m_count)] = res_h`\n    #   `path[(h_count, m_count)] = 'H'`\n    # Else:\n    #   `memo[(h_count, m_count)] = res_m`\n    #   `path[(h_count, m_count)] = 'M'`\n    #\n    # Return `memo[(h_count, m_count)]`\n    #\n    # After calling `solve(0, 0)`, reconstruct the path.\n    #\n    # `n` up to 18. `10**(n-1)` can be `10**17`. This fits in standard integers.\n    # The total sum can be `n * 9 * 10**(n-1)`. For n=18, this is `18 * 9 * 10^17 = 162 * 10^17 = 1.62 * 10^19`.\n    # Python handles large integers automatically. This is fine.\n    #\n    # Let's trace `n=2, A=\"1234\"`\n    # `solve(0,0)`: idx=0, digit='1'\n    #   Homer takes '1': `val_h = 1 * (10**(2-1-0)) = 1 * 10^1 = 10`\n    #     `res_h = 10 + solve(1,0)`\n    #     `solve(1,0)`: idx=1, digit='2'\n    #       Homer takes '2': `val_h = 2 * (10**(2-1-1)) = 2 * 10^0 = 2`\n    #         `res_h = 2 + solve(2,0)`\n    #         `solve(2,0)`: idx=2, digit='3'. H_count=2 (n), so Homer cannot move.\n    #           Marge takes '3': `val_m = 3 * (10**(2-1-0)) = 3 * 10^1 = 30`\n    #             `res_m = 30 + solve(2,1)`\n    #             `solve(2,1)`: idx=3, digit='4'. H_count=2, M_count=1.\n    #               Homer cannot move.\n    #               Marge takes '4': `val_m = 4 * (10**(2-1-1)) = 4 * 10^0 = 4`\n    #                 `res_m = 4 + solve(2,2)`\n    #                 `solve(2,2)`: idx=4. Base case. Returns 0.\n    #               `res_m = 4 + 0 = 4`. `memo[(2,1)] = 4`. `path[(2,1)] = 'M'`.\n    #             `res_m = 30 + 4 = 34`. `memo[(2,0)] = 34`. `path[(2,0)] = 'M'`.\n    #           `res_h` for `solve(1,0)` is `2 + 34 = 36`.\n    #       Marge takes '2': `val_m = 2 * (10**(2-1-0)) = 2 * 10^1 = 20`\n    #         `res_m = 20 + solve(1,1)`\n    #         `solve(1,1)`: idx=2, digit='3'. H_count=1, M_count=1.\n    #           Homer takes '3': `val_h = 3 * (10**(2-1-1)) = 3 * 10^0 = 3`\n    #             `res_h = 3 + solve(2,1)` (already computed as 4) = 3 + 4 = 7\n    #           Marge takes '3': `val_m = 3 * (10**(2-1-1)) = 3 * 10^0 = 3`\n    #             `res_m = 3 + solve(1,2)`\n    #             `solve(1,2)`: idx=3, digit='4'. H_count=1, M_count=2 (n).\n    #               Homer takes '4': `val_h = 4 * (10**(2-1-1)) = 4 * 10^0 = 4`\n    #                 `res_h = 4 + solve(2,2)` (0) = 4\n    #               `memo[(1,2)] = 4`. `path[(1,2)] = 'H'`.\n    #             `res_m = 3 + 4 = 7`.\n    #           Compare `res_h` (7) and `res_m` (7) for `solve(1,1)`. Let's pick H.\n    #           `memo[(1,1)] = 7`. `path[(1,1)] = 'H'`.\n    #         `res_m` for `solve(1,0)` is `20 + 7 = 27`.\n    #       Compare `res_h` (36) and `res_m` (27) for `solve(1,0)`. `res_h` is better.\n    #       `memo[(1,0)] = 36`. `path[(1,0)] = 'H'`.\n    #     `res_h` for `solve(0,0)` is `10 + 36 = 46`.\n    #\n    #   Marge takes '1': `val_m = 1 * (10**(2-1-0)) = 1 * 10^1 = 10`\n    #     `res_m = 10 + solve(0,1)`\n    #     `solve(0,1)`: idx=1, digit='2'.\n    #       Homer takes '2': `val_h = 2 * (10**(2-1-0)) = 2 * 10^1 = 20`\n    #         `res_h = 20 + solve(1,1)` (already computed as 7) = 20 + 7 = 27\n    #       Marge takes '2': `val_m = 2 * (10**(2-1-1)) = 2 * 10^0 = 2`\n    #         `res_m = 2 + solve(0,2)`\n    #         `solve(0,2)`: idx=2, digit='3'. H_count=0, M_count=2 (n).\n    #           Homer takes '3': `val_h = 3 * (10**(2-1-0)) = 3 * 10^1 = 30`\n    #             `res_h = 30 + solve(1,2)` (already computed as 4) = 30 + 4 = 34\n    #           `memo[(0,2)] = 34`. `path[(0,2)] = 'H'`.\n    #         `res_m` for `solve(0,1)` is `2 + 34 = 36`.\n    #       Compare `res_h` (27) and `res_m` (36) for `solve(0,1)`. `res_m` is better.\n    #       `memo[(0,1)] = 36`. `path[(0,1)] = 'M'`.\n    #     `res_m` for `solve(0,0)` is `10 + 36 = 46`.\n    #\n    # Compare `res_h` (46) and `res_m` (46) for `solve(0,0)`. Both are equal.\n    # The problem states \"If there are several solutions, output any of them.\"\n    # So if `res_h >= res_m`, we pick 'H'. This means `HHMM` will be chosen.\n    #\n    # This DP approach seems correct.\n    #\n    # Implementation details:\n    # Use `sys.setrecursionlimit` for larger `n`. Max recursion depth is `2n`. `2*18 = 36`. Default is 1000, so it's fine.\n    # `memo` and `path` dictionaries.\n\n    memo = {}\n    path = {}\n\n    def calculate_max_prize(h_count, m_count):\n        idx = h_count + m_count\n\n        if idx == 2 * n:\n            return 0\n\n        if (h_count, m_count) in memo:\n            return memo[(h_count, m_count)]\n\n        current_digit = int(a_str[idx])\n\n        res_h = -1\n        if h_count < n:\n            val_h = current_digit * (10**(n - 1 - h_count))\n            res_h = val_h + calculate_max_prize(h_count + 1, m_count)\n\n        res_m = -1\n        if m_count < n:\n            val_m = current_digit * (10**(n - 1 - m_count))\n            res_m = val_m + calculate_max_prize(h_count, m_count + 1)\n\n        if res_h >= res_m: # If equal, prefer Homer (as per problem example output for \"1234\" is HHMM, not MMHH)\n            memo[(h_count, m_count)] = res_h\n            path[(h_count, m_count)] = 'H'\n        else:\n            memo[(h_count, m_count)] = res_m\n            path[(h_count, m_count)] = 'M'\n        \n        return memo[(h_count, m_count)]\n\n    calculate_max_prize(0, 0)\n\n    # Reconstruct path\n    result_sequence = []\n    h_current = 0\n    m_current = 0\n    while h_current + m_current < 2 * n:\n        move = path[(h_current, m_current)]\n        result_sequence.append(move)\n        if move == 'H':\n            h_current += 1\n        else:\n            m_current += 1\n    \n    sys.stdout.write(\"\".join(result_sequence) + \"\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n    a_str = sys.stdin.readline().strip()\n\n    # The problem asks to maximize S1 + S2.\n    # S1 and S2 are formed by taking n digits each from A,\n    # maintaining their relative order.\n    # The total sum S1 + S2 is maximized when the sum of digits\n    # at each position (weighted by power of 10) is maximized.\n    #\n    # Consider the digits of A: d_0, d_1, ..., d_{2n-1}.\n    #\n    # If Homer takes d_i and Marge takes d_j (where i < j),\n    # and these are the k-th digits taken by Homer and Marge respectively,\n    # then d_i contributes d_i * 10^(n-1-k_Homer) to S1,\n    # and d_j contributes d_j * 10^(n-1-k_Marge) to S2.\n    #\n    # The crucial insight is that the sum S1 + S2 is maximized\n    # if we assign the most significant digits (leftmost digits from A)\n    # to the player who will make it a most significant digit in their number.\n    #\n    # For example, if we have 2n digits, d_0, ..., d_{2n-1}.\n    # Homer takes n digits, Marge takes n digits.\n    # S1 = d_x0 * 10^(n-1) + d_x1 * 10^(n-2) + ... + d_x(n-1) * 10^0\n    # S2 = d_y0 * 10^(n-1) + d_y1 * 10^(n-2) + ... + d_y(n-1) * 10^0\n    # where {x0, ..., x(n-1)} and {y0, ..., y(n-1)} are disjoint sets of indices\n    # from {0, ..., 2n-1}, and x0 < x1 < ... and y0 < y1 < ...\n    #\n    # The total sum S1 + S2 can be thought of as a sum of contributions from each digit d_i.\n    # Each digit d_i will contribute d_i * 10^p to either S1 or S2, for some power p.\n    # The power p depends on how many digits were taken *before* d_i by the same player.\n    #\n    # Let's consider the digits in pairs: (d_0, d_1), (d_2, d_3), ..., (d_{2n-2}, d_{2n-1}).\n    # For each pair (d_k, d_{k+1}):\n    # If Homer takes d_k and Marge takes d_{k+1}, this uses up one of Homer's choices and one of Marge's choices.\n    # If Homer takes d_k and Marge takes d_{k+1}, and these are the i-th digits for H and M respectively,\n    # then d_k contributes d_k * 10^(n-1-i) to S1, and d_{k+1} contributes d_{k+1} * 10^(n-1-i) to S2.\n    #\n    # The problem simplifies greatly because the relative order is preserved.\n    # This means the *k*-th digit taken by Homer will always be at position `n-1-k` in `S1` (0-indexed from right).\n    # Same for Marge and `S2`.\n    #\n    # To maximize the sum, we want to assign larger digits to higher powers of 10.\n    # The highest powers of 10 (10^(n-1)) will come from the *first* digit taken by each player.\n    # The next highest (10^(n-2)) will come from the *second* digit taken by each player, and so on.\n    #\n    # So, for the first digit of S1 and S2 (which get multiplied by 10^(n-1)), we should assign the two largest digits from A.\n    # But we can't just pick any two largest. We must pick d_i and d_j such that i < j.\n    #\n    # This is not a simple greedy choice on individual digits.\n    #\n    # Let's consider the total sum S1 + S2.\n    # S1 = sum_{k=0}^{n-1} (digit_H_k * 10^(n-1-k))\n    # S2 = sum_{k=0}^{n-1} (digit_M_k * 10^(n-1-k))\n    # S1 + S2 = sum_{k=0}^{n-1} ((digit_H_k + digit_M_k) * 10^(n-1-k))\n    #\n    # Where digit_H_k is the (k+1)-th digit Homer takes, and digit_M_k is the (k+1)-th digit Marge takes.\n    #\n    # To maximize this sum, we need to maximize (digit_H_k + digit_M_k) for each k, especially for small k (high powers of 10).\n    #\n    # This means for the highest power of 10 (k=0), we want to pick two digits d_i and d_j (i < j) from A\n    # such that d_i + d_j is maximized.\n    # If Homer takes d_i and Marge takes d_j, then d_i becomes digit_H_0 and d_j becomes digit_M_0.\n    #\n    # This implies a greedy strategy:\n    # For the k-th pair of digits (from the left of the remaining A) to be assigned to Homer and Marge's (k+1)-th positions:\n    # We look at the current leftmost available digit, say `d_x`.\n    # And the next leftmost available digit, say `d_y`.\n    #\n    # If Homer takes `d_x` and Marge takes `d_y`, their sum is `d_x + d_y`.\n    # If Marge takes `d_x` and Homer takes `d_y`, their sum is `d_x + d_y`.\n    #\n    # The problem states \"maximizes their total prize\".\n    # The sum `S1 + S2` is maximized if, for each position `k` (from `n-1` down to `0`),\n    # the sum of the `k`-th digit of `S1` and the `k`-th digit of `S2` is maximized.\n    #\n    # Let's process the digits of A in pairs: (A[0], A[1]), (A[2], A[3]), ..., (A[2n-2], A[2n-1]).\n    # For each pair of digits A[i] and A[i+1]:\n    # Homer needs to take n digits, Marge needs to take n digits.\n    #\n    # Consider the first two digits, A[0] and A[1].\n    # Homer will take one, Marge will take the other.\n    # If Homer takes A[0] and Marge takes A[1], then S1 starts with A[0] and S2 starts with A[1].\n    # If Marge takes A[0] and Homer takes A[1], then S1 starts with A[1] and S2 starts with A[0].\n    #\n    # The contribution to S1 + S2 from these two digits will be:\n    # (A[0] * 10^(n-1) + A[1] * 10^(n-1)) if H takes A[0] and M takes A[1]\n    # OR (A[1] * 10^(n-1) + A[0] * 10^(n-1)) if M takes A[0] and H takes A[1]\n    #\n    # In both cases, the sum of their values is (A[0] + A[1]) * 10^(n-1).\n    # This means for the first pair of digits taken (d_H_0 and d_M_0), it doesn't matter who takes which,\n    # as long as they are the first two digits to be assigned to S1 and S2.\n    # The sum (d_H_0 + d_M_0) * 10^(n-1) is fixed if we pick A[0] and A[1] for these roles.\n    #\n    # This logic applies to all pairs.\n    # The problem constraints (n <= 18) suggest that 2n is up to 36.\n    # A simple greedy approach works:\n    # For each pair of digits (A[2k], A[2k+1]):\n    # One player takes A[2k], the other takes A[2k+1].\n    # This uses up one move for Homer and one for Marge.\n    # This happens `n` times.\n    #\n    # If Homer takes A[2k] and Marge takes A[2k+1], then the sequence is 'H', 'M'.\n    # If Marge takes A[2k] and Homer takes A[2k+1], then the sequence is 'M', 'H'.\n    #\n    # Which choice is better?\n    # Homer wants to maximize S1. Marge wants to maximize S2.\n    # They jointly want to maximize S1 + S2.\n    #\n    # The total sum S1 + S2 is `sum_{k=0}^{n-1} ((digit_H_k + digit_M_k) * 10^(n-1-k))`.\n    #\n    # Consider the first pair of digits (A[0], A[1]).\n    # They will be the first digits of S1 and S2 (multiplied by 10^(n-1)).\n    # Their sum (A[0] + A[1]) * 10^(n-1) is fixed, regardless of who takes which.\n    #\n    # Consider the second pair of digits (A[2], A[3]).\n    # They will be the second digits of S1 and S2 (multiplied by 10^(n-2)).\n    # Their sum (A[2] + A[3]) * 10^(n-2) is fixed, regardless of who takes which.\n    #\n    # ...\n    #\n    # Consider the last pair of digits (A[2n-2], A[2n-1]).\n    # They will be the last digits of S1 and S2 (multiplied by 10^0).\n    # Their sum (A[2n-2] + A[2n-1]) * 10^0 is fixed, regardless of who takes which.\n    #\n    # This means that the total sum S1 + S2 is *always the same*, regardless of the sequence of moves,\n    # as long as Homer takes n digits and Marge takes n digits.\n    #\n    # Let's re-verify this.\n    # Suppose Homer takes d_i as his k-th digit and Marge takes d_j as her k-th digit.\n    # This means there are k digits before d_i that Homer took, and k digits before d_j that Marge took.\n    # The indices x_0, ..., x_{k-1} are Homer's previous choices.\n    # The indices y_0, ..., y_{k-1} are Marge's previous choices.\n    #\n    # The total number of digits processed up to this point is (k+1) + (k+1) = 2k+2.\n    #\n    # Let's trace the example: n=2, A=\"1234\"\n    #\n    # Case 1: HHMM\n    # H takes '1' (Homer's 1st, S1=\"1\")\n    # H takes '2' (Homer's 2nd, S1=\"12\")\n    # M takes '3' (Marge's 1st, S2=\"3\")\n    # M takes '4' (Marge's 2nd, S2=\"34\")\n    # Total = 12 + 34 = 46\n    #\n    # S1 = 1*10^1 + 2*10^0\n    # S2 = 3*10^1 + 4*10^0\n    # S1+S2 = (1+3)*10^1 + (2+4)*10^0 = 4*10 + 6*1 = 46\n    #\n    # Case 2: HMHM\n    # H takes '1' (Homer's 1st, S1=\"1\")\n    # M takes '2' (Marge's 1st, S2=\"2\")\n    # H takes '3' (Homer's 2nd, S1=\"13\")\n    # M takes '4' (Marge's 2nd, S2=\"24\")\n    # Total = 13 + 24 = 37\n    #\n    # S1 = 1*10^1 + 3*10^0\n    # S2 = 2*10^1 + 4*10^0\n    # S1+S2 = (1+2)*10^1 + (3+4)*10^0 = 3*10 + 7*1 = 37\n    #\n    # My previous reasoning was flawed. The sum S1 + S2 is *not* always the same.\n    # The digits `digit_H_k` and `digit_M_k` are *not* necessarily `A[2k]` and `A[2k+1]`.\n    # They are the k-th digits *taken by that player*.\n    #\n    # Let's re-examine S1 + S2 = sum_{k=0}^{n-1} ((digit_H_k + digit_M_k) * 10^(n-1-k)).\n    #\n    # In HHMM:\n    # k=0: digit_H_0 = A[0]='1', digit_M_0 = A[2]='3'. Sum = (1+3)*10^1 = 40\n    # k=1: digit_H_1 = A[1]='2', digit_M_1 = A[3]='4'. Sum = (2+4)*10^0 = 6\n    # Total = 40 + 6 = 46.\n    #\n    # In HMHM:\n    # k=0: digit_H_0 = A[0]='1', digit_M_0 = A[1]='2'. Sum = (1+2)*10^1 = 30\n    # k=1: digit_H_1 = A[2]='3', digit_M_1 = A[3]='4'. Sum = (3+4)*10^0 = 7\n    # Total = 30 + 7 = 37.\n    #\n    # The goal is to maximize `(digit_H_k + digit_M_k)` for small `k`.\n    # This means the largest digits from A should be assigned to `digit_H_0` and `digit_M_0`.\n    # The next largest to `digit_H_1` and `digit_M_1`, and so on.\n    #\n    # We have `2n` digits in A. Let's denote them `d_0, d_1, ..., d_{2n-1}`.\n    # We need to choose `n` digits for Homer and `n` for Marge.\n    #\n    # The problem is to find a permutation of 'H' and 'M' (n of each) that maximizes the sum.\n    #\n    # This is a dynamic programming problem.\n    # Let `dp[h_count][m_count][idx]` be the maximum sum of (S1_prefix + S2_prefix)\n    # where `h_count` digits have been assigned to Homer, `m_count` to Marge,\n    # and we are considering digits from `A[idx]` onwards.\n    # The state needs to capture the *current* value of S1 and S2, not just their sum.\n    # This would be `dp[h_count][m_count]` storing `(current_S1, current_S2)`.\n    # But `current_S1` and `current_S2` can be very large numbers.\n    #\n    # The total number of digits is `2n`. `n` is up to 18. `2n` is up to 36.\n    # A DP state `dp[h_taken][m_taken][idx]` would be `18 * 18 * 36`.\n    #\n    # What does `dp[h_taken][m_taken]` store?\n    # It should store the maximum sum of `(digit_H_k + digit_M_k)` for the remaining digits.\n    #\n    # Let `dp[i][j]` be the maximum *remaining* sum we can get if `i` digits have been taken by Homer\n    # and `j` digits have been taken by Marge.\n    # The current digit we are considering from A is `A[i+j]`.\n    #\n    # `dp[i][j]` = max total prize from `A[i+j ... 2n-1]` given `i` moves for H and `j` for M already made.\n    #\n    # Base case: `dp[n][n] = 0`.\n    #\n    # Transitions:\n    # `dp[i][j]`\n    #   Option 1: Homer takes `A[i+j]`.\n    #     New `S1` digit: `A[i+j]` at position `n-1-i`.\n    #     Contribution: `int(A[i+j]) * (10**(n-1-i))`\n    #     Recursive call: `dp[i+1][j]`\n    #     Total for this option: `int(A[i+j]) * (10**(n-1-i)) + dp[i+1][j]`\n    #   Option 2: Marge takes `A[i+j]`.\n    #     New `S2` digit: `A[i+j]` at position `n-1-j`.\n    #     Contribution: `int(A[i+j]) * (10**(n-1-j))`\n    #     Recursive call: `dp[i][j+1]`\n    #     Total for this option: `int(A[i+j]) * (10**(n-1-j)) + dp[i][j+1]`\n    #\n    # We need to store the path as well.\n    # `memo = {}`\n    # `path = {}`\n    #\n    # `solve(h_count, m_count)` function:\n    # `idx = h_count + m_count`\n    # If `idx == 2*n`: return 0\n    # If `(h_count, m_count)` in `memo`: return `memo[(h_count, m_count)]`\n    #\n    # `current_digit = int(a_str[idx])`\n    #\n    # `res_h = -1` (or some very small number)\n    # `res_m = -1`\n    #\n    # If `h_count < n`:\n    #   `val_h = current_digit * (10**(n-1-h_count))`\n    #   `res_h = val_h + solve(h_count + 1, m_count)`\n    #\n    # If `m_count < n`:\n    #   `val_m = current_digit * (10**(n-1-m_count))`\n    #   `res_m = val_m + solve(h_count, m_count + 1)`\n    #\n    # Compare `res_h` and `res_m`:\n    # If `res_h >= res_m`:\n    #   `memo[(h_count, m_count)] = res_h`\n    #   `path[(h_count, m_count)] = 'H'`\n    # Else:\n    #   `memo[(h_count, m_count)] = res_m`\n    #   `path[(h_count, m_count)] = 'M'`\n    #\n    # Return `memo[(h_count, m_count)]`\n    #\n    # After calling `solve(0, 0)`, reconstruct the path.\n    #\n    # `n` up to 18. `10**(n-1)` can be `10**17`. This fits in standard integers.\n    # The total sum can be `n * 9 * 10**(n-1)`. For n=18, this is `18 * 9 * 10^17 = 162 * 10^17 = 1.62 * 10^19`.\n    # Python handles large integers automatically. This is fine.\n    #\n    # Let's trace `n=2, A=\"1234\"`\n    # `solve(0,0)`: idx=0, digit='1'\n    #   Homer takes '1': `val_h = 1 * (10**(2-1-0)) = 1 * 10^1 = 10`\n    #     `res_h = 10 + solve(1,0)`\n    #     `solve(1,0)`: idx=1, digit='2'\n    #       Homer takes '2': `val_h = 2 * (10**(2-1-1)) = 2 * 10^0 = 2`\n    #         `res_h = 2 + solve(2,0)`\n    #         `solve(2,0)`: idx=2, digit='3'. H_count=2 (n), so Homer cannot move.\n    #           Marge takes '3': `val_m = 3 * (10**(2-1-0)) = 3 * 10^1 = 30`\n    #             `res_m = 30 + solve(2,1)`\n    #             `solve(2,1)`: idx=3, digit='4'. H_count=2, M_count=1.\n    #               Homer cannot move.\n    #               Marge takes '4': `val_m = 4 * (10**(2-1-1)) = 4 * 10^0 = 4`\n    #                 `res_m = 4 + solve(2,2)`\n    #                 `solve(2,2)`: idx=4. Base case. Returns 0.\n    #               `res_m = 4 + 0 = 4`. `memo[(2,1)] = 4`. `path[(2,1)] = 'M'`.\n    #             `res_m = 30 + 4 = 34`. `memo[(2,0)] = 34`. `path[(2,0)] = 'M'`.\n    #           `res_h` for `solve(1,0)` is `2 + 34 = 36`.\n    #       Marge takes '2': `val_m = 2 * (10**(2-1-0)) = 2 * 10^1 = 20`\n    #         `res_m = 20 + solve(1,1)`\n    #         `solve(1,1)`: idx=2, digit='3'. H_count=1, M_count=1.\n    #           Homer takes '3': `val_h = 3 * (10**(2-1-1)) = 3 * 10^0 = 3`\n    #             `res_h = 3 + solve(2,1)` (already computed as 4) = 3 + 4 = 7\n    #           Marge takes '3': `val_m = 3 * (10**(2-1-1)) = 3 * 10^0 = 3`\n    #             `res_m = 3 + solve(1,2)`\n    #             `solve(1,2)`: idx=3, digit='4'. H_count=1, M_count=2 (n).\n    #               Homer takes '4': `val_h = 4 * (10**(2-1-1)) = 4 * 10^0 = 4`\n    #                 `res_h = 4 + solve(2,2)` (0) = 4\n    #               `memo[(1,2)] = 4`. `path[(1,2)] = 'H'`.\n    #             `res_m = 3 + 4 = 7`.\n    #           Compare `res_h` (7) and `res_m` (7) for `solve(1,1)`. Let's pick H.\n    #           `memo[(1,1)] = 7`. `path[(1,1)] = 'H'`.\n    #         `res_m` for `solve(1,0)` is `20 + 7 = 27`.\n    #       Compare `res_h` (36) and `res_m` (27) for `solve(1,0)`. `res_h` is better.\n    #       `memo[(1,0)] = 36`. `path[(1,0)] = 'H'`.\n    #     `res_h` for `solve(0,0)` is `10 + 36 = 46`.\n    #\n    #   Marge takes '1': `val_m = 1 * (10**(2-1-0)) = 1 * 10^1 = 10`\n    #     `res_m = 10 + solve(0,1)`\n    #     `solve(0,1)`: idx=1, digit='2'.\n    #       Homer takes '2': `val_h = 2 * (10**(2-1-0)) = 2 * 10^1 = 20`\n    #         `res_h = 20 + solve(1,1)` (already computed as 7) = 20 + 7 = 27\n    #       Marge takes '2': `val_m = 2 * (10**(2-1-1)) = 2 * 10^0 = 2`\n    #         `res_m = 2 + solve(0,2)`\n    #         `solve(0,2)`: idx=2, digit='3'. H_count=0, M_count=2 (n).\n    #           Homer takes '3': `val_h = 3 * (10**(2-1-0)) = 3 * 10^1 = 30`\n    #             `res_h = 30 + solve(1,2)` (already computed as 4) = 30 + 4 = 34\n    #           `memo[(0,2)] = 34`. `path[(0,2)] = 'H'`.\n    #         `res_m` for `solve(0,1)` is `2 + 34 = 36`.\n    #       Compare `res_h` (27) and `res_m` (36) for `solve(0,1)`. `res_m` is better.\n    #       `memo[(0,1)] = 36`. `path[(0,1)] = 'M'`.\n    #     `res_m` for `solve(0,0)` is `10 + 36 = 46`.\n    #\n    # Compare `res_h` (46) and `res_m` (46) for `solve(0,0)`. Both are equal.\n    # The problem states \"If there are several solutions, output any of them.\"\n    # So if `res_h >= res_m`, we pick 'H'. This means `HHMM` will be chosen.\n    #\n    # This DP approach seems correct.\n    #\n    # Implementation details:\n    # Use `sys.setrecursionlimit` for larger `n`. Max recursion depth is `2n`. `2*18 = 36`. Default is 1000, so it's fine.\n    # `memo` and `path` dictionaries.\n\n    memo = {}\n    path = {}\n\n    def calculate_max_prize(h_count, m_count):\n        idx = h_count + m_count\n\n        if idx == 2 * n:\n            return 0\n\n        if (h_count, m_count) in memo:\n            return memo[(h_count, m_count)]\n\n        current_digit = int(a_str[idx])\n\n        res_h = -1\n        if h_count < n:\n            val_h = current_digit * (10**(n - 1 - h_count))\n            res_h = val_h + calculate_max_prize(h_count + 1, m_count)\n\n        res_m = -1\n        if m_count < n:\n            val_m = current_digit * (10**(n - 1 - m_count))\n            res_m = val_m + calculate_max_prize(h_count, m_count + 1)\n\n        if res_h >= res_m: # If equal, prefer Homer (as per problem example output for \"1234\" is HHMM, not MMHH)\n            memo[(h_count, m_count)] = res_h\n            path[(h_count, m_count)] = 'H'\n        else:\n            memo[(h_count, m_count)] = res_m\n            path[(h_count, m_count)] = 'M'\n        \n        return memo[(h_count, m_count)]\n\n    calculate_max_prize(0, 0)\n\n    # Reconstruct path\n    result_sequence = []\n    h_current = 0\n    m_current = 0\n    while h_current + m_current < 2 * n:\n        move = path[(h_current, m_current)]\n        result_sequence.append(move)\n        if move == 'H':\n            h_current += 1\n        else:\n            m_current += 1\n    \n    sys.stdout.write(\"\".join(result_sequence) + \"\\n\")\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 431,
        "completion_token_count": 7198,
        "thoughts_token_count": 817
    }
}