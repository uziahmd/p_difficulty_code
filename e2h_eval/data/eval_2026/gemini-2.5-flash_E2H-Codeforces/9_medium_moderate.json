{
    "start": 1758011926.9155493,
    "end": 1758012110.8000488,
    "start-formatted": "2025-09-16 17:38 KST",
    "end-formatted": "2025-09-16 17:41 KST",
    "gpu": 2,
    "pid": 9,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Selling Souvenirs\n\nAfter several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.This morning, as usual, Petya will come to the market. Petya has n different souvenirs to sell; ith souvenir is characterised by its weight wi and cost ci. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than m, and total cost is maximum possible.Help Petya to determine maximum possible total cost.\n\n## Input\nThe first line contains two integers n and m (1 ≤ n ≤ 100000, 1 ≤ m ≤ 300000) — the number of Petya's souvenirs and total weight that he can carry to the market.Then n lines follow. ith line contains two integers wi and ci (1 ≤ wi ≤ 3, 1 ≤ ci ≤ 109) — the weight and the cost of ith souvenir.\n\n## Output\nPrint one number — maximum possible total cost of souvenirs that Petya can carry to the market.\n\n## Example\n### Input\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\n### Output\n['0', '3', '10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "**My Thinking on Solving the \"Selling Souvenirs\" Problem**\n\nOkay, so I'm tackling this competitive programming problem – it's a variation of the knapsack problem, and the goal is to maximize the total cost of souvenirs within a weight limit. The key here is the constraints: a large number of souvenirs (`n` up to 100,000) and a large maximum weight (`m` up to 300,000), along with weights of only 1, 2, or 3. The large input sizes immediately rule out a straightforward `O(n*m)` dynamic programming approach, which would be too slow.\n\nBecause the item weights are so limited (1, 2, or 3), I need to leverage this fact for optimization. I'm thinking of categorizing the souvenirs into three groups based on their weights and sorting each group in descending order of cost. Then, I can compute prefix sums for each group to represent the cumulative cost of the most expensive items.\n\nThe problem, then, becomes about finding the optimal number of items of each weight (k1, k2, k3) that maximizes the total cost while staying within the weight limit. I initially considered iterating through the possible values of k3 (number of weight 3 items), and then solving a 2-type knapsack subproblem for the remaining weight. The dynamic programming for the subproblem, however, would still be too slow.\n\nThen, I shifted to iterating through the number of weight 1 items.  I realized that it would involve nested loops, one for each possible combination of item counts, leading to an O(m^2) solution (where m is the weight limit), which is still too slow.\n\nThe crucial insight seems to be that small weights should be handled very specifically. I realized that since there are only three weights, and with prefix sums pre-computed, a potentially more efficient approach might exist.  I considered trying to define the dynamic programming differently, and saw that the prefix sums would let me calculate quickly.\n\nI then started thinking along the lines of a standard DP where `dp[w]` is the maximum cost for total weight `w`, building up the solution. When trying to incorporate all the weights using nested loops, I arrived at O(N*M) complexity, but this would still be too slow given the constraints.\n\nThen, I came back to the idea of the bounded knapsack.  For weight 2, I would have `N_2` items, with costs `c2_1 >= c2_2 >=...`.  The question is how to use dynamic programming. But this led me back to O(n*m).\n\nFinally, I got to the idea of using the choice sets and processing by item types. This approach seems promising, since the total is still small, and all the information will be calculated as a prefix sum. But even this would be too slow.\n\nSo, I’m back to focusing on how to combine prefix sums and weight combinations efficiently, but still struggling with finding an approach that isn't at least O(m^2) or O(N*M). I need to somehow avoid iterating through all possible combinations. I feel like there's a neat dynamic programming trick to exploit the small weight range. I’ll need to come back to the drawing board...\n",
    "response": "The problem asks us to select a subset of souvenirs to maximize total cost, given a maximum total weight `m`. Each souvenir `i` has a weight `w_i` and a cost `c_i`. The key constraint is that `w_i` can only be 1, 2, or 3. `n` can be up to `100000` and `m` up to `300000`.\n\nA standard 0/1 knapsack solution with `O(n*m)` complexity would be too slow given the constraints. However, the small range of `w_i` values (1, 2, 3) is a strong hint for optimization.\n\n**1. Categorize and Sort Souvenirs:**\nFirst, separate the souvenirs into three lists based on their weights: `items1` (for `w=1`), `items2` (for `w=2`), and `items3` (for `w=3`). For each list, sort the costs in descending order. This is because to maximize cost for a given weight, we should always pick the most expensive items first.\n\n**2. Precompute Prefix Sums:**\nFor each sorted list of costs, compute prefix sums.\nLet `P1[k]` be the sum of costs of the `k` most expensive items of weight 1.\nSimilarly, `P2[k]` for weight 2, and `P3[k]` for weight 3.\nThese prefix sum arrays allow us to quickly find the maximum cost for taking `k` items of a specific weight type. `P_type[0]` should be 0.\n\n**3. Dynamic Programming Approach:**\nLet `dp[w]` be the maximum possible cost for a total weight `w` using the chosen souvenirs. We want to find `max(dp[w])` for `0 <= w <= m`.\nInitialize `dp[0] = 0` and `dp[j] = -1` (or a very small negative number) for `j > 0`. `-1` signifies that a weight `j` is not reachable.\n\nWe can process items by weight type.\n**A. Process items of weight 1:**\nFor each `k1` from 0 up to `len(items1)`:\n  If `k1 <= m`, then `dp[k1]` can be at least `P1[k1]`.\n  `dp[k1] = max(dp[k1], P1[k1])`.\nThis step effectively populates `dp` with optimal costs using only items of weight 1.\n\n**B. Process items of weight 2:**\nNow, we want to combine items of weight 1 and weight 2.\nFor each `k2` from 1 up to `len(items2)`:\n  Let `cost2 = P2[k2]` and `weight2 = 2 * k2`.\n  If `weight2 > m`, we can stop for this `k2`.\n  We iterate `j` from `m` down to `weight2`.\n  `dp[j] = max(dp[j], dp[j - weight2] + cost2)`\n  This update rule considers taking `k2` items of weight 2 *in addition to* whatever items (of weight 1) were used to achieve `dp[j - weight2]`. This is the standard 0/1 knapsack DP update, applied to \"bundles\" of `k2` items.\n  However, this approach is `O(len(items2) * m)`, which is `O(N*M)` in the worst case, still too slow.\n\n**Optimized DP for Small Weights:**\nThe issue with the above DP is that we are iterating through `k` items of a type, each time updating `m` states.\nA more efficient approach for items with small, fixed weights (like 1, 2, 3) is to use a slightly different DP structure.\n\nLet `dp[w]` store the maximum cost for a total weight `w`.\nInitialize `dp[0] = 0`, and `dp[j] = -1` for `j > 0`.\n\n**1. Incorporate items of weight 1:**\nThis is straightforward. For each `k` from `1` to `len(items1)`:\n  `dp[k] = max(dp[k], P1[k])`. (Only if `k <= m`)\n  After this, `dp[w]` represents the max cost for weight `w` using only items of weight 1.\n\n**2. Incorporate items of weight 2:**\nWe want to find the max cost for `w` using items of weight 1 and 2.\nFor each `w` from `0` to `m`:\n  `max_cost_for_w = dp[w]` (current best using only weight 1 items)\n  For `k2` from `1` up to `len(items2)`:\n    `current_weight_2 = 2 * k2`\n    `current_cost_2 = P2[k2]`\n    If `w >= current_weight_2` and `dp[w - current_weight_2] != -1`:\n      `max_cost_for_w = max(max_cost_for_w, dp[w - current_weight_2] + current_cost_2)`\n  `dp[w] = max_cost_for_w` (store the updated value).\nThis is still `O(m * len(items2)) = O(m*N)`, which is too slow.\n\n**The correct approach for small weights and bounded items:**\nThe small number of distinct weights (1, 2, 3) allows us to use a DP where the state `dp[w]` stores the maximum cost for weight `w`.\nWhen processing a new type of item (e.g., weight 2), we need to iterate over all possible counts `k2` of that item type.\nFor each `k2` (number of items of weight 2):\n  `cost_k2 = P2[k2]`\n  `weight_k2 = 2 * k2`\n  If `weight_k2 > m`, break.\n  We want to update `dp[j]` by considering `k2` items of weight 2.\n  `dp_new[j] = max(dp_new[j], dp_old[j - weight_k2] + cost_k2)`\nThis is still `O(len(items2) * m)`.\n\nThe crucial optimization for small weights (like `W=2` or `W=3`) in a knapsack-like problem, when we have many items of the same weight, is to use a deque (double-ended queue) for a sliding window maximum.\nFor a fixed `k1` (number of items of weight 1), we need to solve:\n`maximize P2[k2] + P3[k3]` subject to `2*k2 + 3*k3 <= M_rem`.\nThis is a 2-type knapsack. Let `dp23[w]` be the max cost for weight `w` using only items of weight 2 and 3.\nWe can compute `dp23[w]` for all `w` from `0` to `m` in `O(m)` time using the deque optimization.\n\n**Detailed `O(M)` computation for `dp23[w]` (max cost from items of weight 2 and 3):**\nLet `dp_tmp[w]` be the max cost using only items of weight 2.\n`dp_tmp[w] = P2[w/2]` if `w` is even and `w/2 <= len(items2)`, else `-1`.\nNow, we want to combine `dp_tmp` with items of weight 3.\nFor each `j` from `0` to `m`:\n  `dp23[j] = dp_tmp[j]` (base case: don't take any items of weight 3).\nFor each remainder `r` in `0, 1, 2` (since `w_i=3`):\n  Use a deque to find `max_{k3} (dp_tmp[j - 3*k3] + P3[k3])` for `j % 3 == r`.\n  This is a standard technique for \"bounded knapsack\" or \"multiple items of same weight\" problems.\n  For each `j` in `range(r, m+1, 3)`:\n    `val = dp_tmp[j] - P3[j/3]` (if `dp_tmp[j]` is reachable).\n    While deque is not empty and `dp_tmp[deque.back()] - P3[deque.back()/3]` is less than `val`:\n      `deque.pop_back()`\n    `deque.push_back(j)`\n    While deque is not empty and `j - deque.front() > 3 * len(items3)` (or `j - deque.front() > m`):\n      `deque.pop_front()`\n    If `deque` is not empty and `dp_tmp[deque.front()] != -1`:\n      `dp23[j] = max(dp23[j], dp_tmp[deque.front()] + P3[j/3])`\nThis is still incorrect. The deque optimization is for unbounded knapsack or for a single item type with multiple copies. Here we have prefix sums `P3[k3]`, which means taking `k3` items of weight 3.\n\n**The actual solution for small weights:**\nThe problem can be solved by iterating over the number of items of one type (say, weight 3), and then solving the remaining problem for weights 1 and 2.\nLet `k3` be the number of items of weight 3. `k3` can range from `0` to `m/3`.\nFor each `k3`:\n  `current_cost3 = P3[k3]`\n  `remaining_weight = m - 3 * k3`\n  If `remaining_weight < 0`, continue.\n  Now we need to pick `k1` items of weight 1 and `k2` items of weight 2 such that `k1 + 2*k2 <= remaining_weight` and `P1[k1] + P2[k2]` is maximized.\n  Let `dp12[w]` be the maximum cost for weight `w` using items of weight 1 and 2.\n  We can compute `dp12[w]` for all `w` from `0` to `m` in `O(m)` time.\n\n**How to compute `dp12[w]` for all `w` in `O(m)`:**\nInitialize `dp12[w] = P1[w]` for `w` from `0` to `len(items1)`, and `-1` otherwise.\nNow, we incorporate items of weight 2.\nFor each `k2` from `1` to `len(items2)`:\n  `cost_k2 = P2[k2]`\n  `weight_k2 = 2 * k2`\n  If `weight_k2 > m`, break.\n  For `j` from `m` down to `weight_k2`:\n    If `dp12[j - weight_k2] != -1`:\n      `dp12[j] = max(dp12[j], dp12[j - weight_k2] + cost_k2)`\nThis is still `O(len(items2) * m)`.\n\nThe trick is that the `dp` array for items of weight 1 and 2 can be computed by iterating over `k2` (number of items of weight 2) and for each `k2`, calculating the best `k1`.\n`dp12[w]` = `max_{k2} (P2[k2] + P1[w - 2*k2])` for valid `k2`.\nThis means iterating `k2` from `0` to `w/2`. This is `O(w)` for each `w`, so `O(m^2)` total.\n\n**Final optimized approach (based on common competitive programming solutions for this problem type):**\nThe key is that the weights are very small.\nLet `dp[w]` be the maximum cost for total weight `w`.\nInitialize `dp[0]=0`, `dp[j]=-1` for `j>0`.\n\n1. **Process items of weight 1:**\n   For `k1` from `1` to `len(items1)`:\n     If `k1 <= m`: `dp[k1] = max(dp[k1], P1[k1])`\n   This step takes `O(min(m, N))` time.\n\n2. **Process items of weight 2:**\n   Create a temporary `new_dp` array.\n   For `k2` from `0` to `len(items2)`:\n     `current_cost2 = P2[k2]`\n     `current_weight2 = 2 * k2`\n     If `current_weight2 > m`, break.\n     For `j` from `0` to `m - current_weight2`:\n       If `dp[j] != -1`:\n         `new_dp[j + current_weight2] = max(new_dp[j + current_weight2], dp[j] + current_cost2)`\n   Then, `dp = new_dp`.\n   This step takes `O(len(items2) * m) = O(N*M)`. This is the part that needs to be faster.\n\nThe `O(N*M)` complexity comes from the nested loops where `k2` can be `O(N)` and `j` can be `O(M)`.\nInstead, we can iterate over `k1` and `k2` directly.\nThe maximum number of items of weight 1 is `m`. The maximum number of items of weight 2 is `m/2`.\nThe maximum number of items of weight 3 is `m/3`.\nThe total number of items `N` is `10^5`. `m` is `3*10^5`.\n\nConsider the maximum number of items of weight 2 (`k2_max = m/2`) and weight 3 (`k3_max = m/3`).\nThe maximum number of items of weight 1 (`k1_max = m`).\nIf we iterate `k2` from `0` to `min(len(items2), m/2)`:\n  `cost_k2 = P2[k2]`\n  `weight_k2 = 2 * k2`\n  For `k3` from `0` to `min(len(items3), (m - weight_k2)/3)`:\n    `cost_k3 = P3[k3]`\n    `weight_k3 = 3 * k3`\n    `remaining_capacity = m - weight_k2 - weight_k3`\n    `cost_k1 = P1[min(len(items1), remaining_capacity)]`\n    `total_cost = cost_k1 + cost_k2 + cost_k3`\n    Update `max_total_cost`.\n\nThis is `O(m/2 * m/3) = O(m^2)`. This is still too slow.\n\nThe correct approach is to use a slightly modified DP for the two largest weights (2 and 3), and then combine with weight 1 items.\nLet `dp_23[w]` be the maximum cost for weight `w` using only items of weight 2 and 3.\n`dp_23` array of size `m+1`, initialized to `-1` (except `dp_23[0]=0`).\nIterate `k2` from `0` to `len(items2)`:\n  `current_cost2 = P2[k2]`\n  `current_weight2 = 2 * k2`\n  If `current_weight2 > m`, break.\n  For `k3` from `0` to `len(items3)`:\n    `current_cost3 = P3[k3]`\n    `current_weight3 = 3 * k3`\n    If `current_weight2 + current_weight3 > m`, break.\n    `dp_23[current_weight2 + current_weight3] = max(dp_23[current_weight2 + current_weight3], current_cost2 + current_cost3)`\nThis populates `dp_23` for *exact* sums of `2*k2 + 3*k3`.\nThen, we need to make `dp_23` store the maximum for *up to* weight `w`.\n`for j in range(1, m+1): dp_23[j] = max(dp_23[j], dp_23[j-1])` (This makes it monotonic, but not correct for combinations).\n\nThe correct way to compute `dp_23[w]` for all `w` in `O(M)` is as follows:\nInitialize `dp_23[0] = 0`, `dp_23[j] = -1` for `j > 0`.\nFor `k2` from `1` to `len(items2)`:\n  `cost2 = items2[k2-1]` (cost of the `k2`-th most expensive item of weight 2)\n  For `j` from `m` down to `2`:\n    If `dp_23[j-2] != -1`:\n      `dp_23[j] = max(dp_23[j], dp_23[j-2] + cost2)`\nThis is for unbounded knapsack. For 0/1 knapsack (taking specific items), it's `dp[j] = max(dp[j], dp[j-w] + c)`.\nThis would be `O(N_2 * M)`.\n\nLet's use the `O(M)` DP approach for small weights.\n`dp[w]` = maximum cost for total weight `w`.\nInitialize `dp[0]=0`, `dp[j]=-1` for `j>0`.\nThis `dp` array will be used to combine items of weight 2 and 3.\n\n**Function to calculate DP for a given item type:**\n`def compute_dp(current_dp, costs, weight_val, max_m):`\n  `new_dp = list(current_dp)`\n  `for k in range(len(costs)):`  # k is 0-indexed count of items taken\n    `num_items = k + 1`\n    `current_cost_sum = prefix_sums[weight_val][num_items]`\n    `current_weight_sum = num_items * weight_val`\n    `if current_weight_sum > max_m: break`\n    `for j in range(max_m, current_weight_sum - 1, -1):`\n      `if current_dp[j - current_weight_sum] != -1:`\n        `new_dp[j] = max(new_dp[j], current_dp[j - current_weight_sum] + current_cost_sum)`\n  `return new_dp`\nThis is `O(N_type * M)`, which is too slow.\n\nThe only way to achieve `O(M)` for multiple types is if the number of distinct items of each type is small.\nHere, we have `N_W` items of weight `W`. We can take `k` items of weight `W`. The cost is `P_W[k]`.\nThis is a bounded knapsack problem.\n`dp[w]` = max cost for weight `w`.\nInitialize `dp[0]=0`, `dp[j]=-1` for `j>0`.\n\nFor weight `W=2`:\n  Iterate `k2` from `0` to `len(items2)`:\n    `cost_k2 = P2[k2]`\n    `weight_k2 = 2 * k2`\n    If `weight_k2 > m`, break.\n    `dp_temp[weight_k2] = max(dp_temp[weight_k2], cost_k2)` (this would be for *exactly* `weight_k2`).\n\nThe correct way to combine the three types:\nSort `items1`, `items2`, `items3` in descending order.\nCompute prefix sums `P1`, `P2`, `P3`.\n\nInitialize `max_total_cost = 0`.\nIterate `k3` from `0` up to `min(len(items3), m // 3)`:\n  `cost_k3 = P3[k3]`\n  `weight_k3 = 3 * k3`\n  `remaining_m_after_k3 = m - weight_k3`\n\n  Now, we need to maximize `P1[k1] + P2[k2]` for `k1 + 2*k2 <= remaining_m_after_k3`.\n  Let `current_max_for_12 = 0`.\n  Iterate `k2` from `0` up to `min(len(items2), remaining_m_after_k3 // 2)`:\n    `cost_k2 = P2[k2]`\n    `weight_k2 = 2 * k2`\n    `remaining_m_after_k2 = remaining_m_after_k3 - weight_k2`\n    `cost_k1 = P1[min(len(items1), remaining_m_after_k2)]`\n    `current_max_for_12 = max(current_max_for_12, cost_k1 + cost_k2)`\n  `max_total_cost = max(max_total_cost, cost_k3 + current_max_for_12)`\n\nThis is `O( (m/3) * (m/2) ) = O(m^2)`, which is too slow.\n\nThe solution must be `O(M)` or `O(M log M)`.\nThe key is that the number of items of weight 2 and 3 can be small relative to `m` if `N` is small.\nBut `N` can be `10^5`, so `len(items2)` or `len(items3)` can be `10^5`.\n\nA common trick for this specific problem (small weights, large N, large M) is to use a meet-in-the-middle approach or a specialized DP that leverages the small weights.\nThe DP state `dp[w]` should represent the maximum cost for weight `w`.\nWe can compute `dp[w]` for items of weight 2 and 3.\n`dp[w]` = `max_{k2, k3} (P2[k2] + P3[k3])` such that `2*k2 + 3*k3 = w`.\nThis can be computed in `O(m)` using a deque for each `w % 2` (for `w=2`) and for each `w % 3` (for `w=3`).\nThis is because `P2[k2]` and `P3[k3]` are concave (sum of decreasing values).\n\nLet `dp_23[w]` be the max cost for weight `w` using items of weight 2 and 3.\nInitialize `dp_23[w] = -1` for all `w`, `dp_23[0] = 0`.\nFor `k2` from `0` to `len(items2)`:\n  `cost_2 = P2[k2]`\n  `weight_2 = 2*k2`\n  If `weight_2 > m`, break.\n  `dp_23[weight_2] = max(dp_23[weight_2], cost_2)`.\nThis initializes `dp_23` only for specific even weights using only weight 2 items.\n\nTo correctly combine items of weight 2 and 3 into `dp_23`:\nLet `f[w]` be the max cost for weight `w` using items of weight 2.\n`f[w] = P2[w/2]` if `w` is even and `w/2 <= len(items2)`, else `-1`.\nThen, to combine with items of weight 3:\n`dp_23[w] = max_{k3} (f[w - 3*k3] + P3[k3])`.\nThis `max_{k3}` can be found efficiently.\nFor each remainder `r` in `0, 1, 2` (for `w % 3`):\n  We need to find `max_{k3} (f[j - 3*k3] + P3[k3])` where `j = r, r+3, r+6, ...`.\n  Let `j = 3*q + r`. We want `max_{k3} (f[3*(q-k3) + r] + P3[k3])`.\n  Let `idx = q-k3`. We want `max_{idx} (f[3*idx + r] + P3[q-idx])`.\n  This is a convolution-like form `max_{idx} (A[idx] + B[q-idx])`, which can be solved with a sliding window maximum using a deque.\n  For each `r` from `0` to `2`:\n    `deque` stores indices `idx`.\n    For `q` from `0` to `(m-r)//3`:\n      `j = 3*q + r`\n      `val_f = f[j]`\n      `val_p3 = P3[q]`\n      While `deque` is not empty and `deque.front()` is too far (e.g., `q - deque.front() > len(items3)`):\n        `deque.pop_front()`\n      While `deque` is not empty and `f[3*deque.back()+r] + P3[q-deque.back()]` is less than or equal to `f[j] + P3[0]` (this part is tricky).\n      This is for `max(A[i] + B[j-i])` where `A[i]` is `f[3*i+r]` and `B[k]` is `P3[k]`.\n      The values `P3[k]` are sums of decreasing numbers, so `P3[k]` is concave.\n      The deque optimization is for `max_{0 <= k <= K} (val[j-k*W] + k*C)`.\n      Here, `P3[k]` is not `k*C`.\n\nThe problem is a variation of the multiple-choice knapsack problem.\nThe most efficient way for this specific problem (weights 1, 2, 3) is usually:\n1. Sort items and compute prefix sums `P1, P2, P3`.\n2. Initialize `dp[w]` as `P1[w]` for `w <= len(items1)`, and `0` otherwise.\n3. Iterate `k2` from `0` to `len(items2)`:\n   `cost_2 = P2[k2]`\n   `weight_2 = 2 * k2`\n   If `weight_2 > m`, break.\n   For `j` from `m` down to `weight_2`:\n     `if dp[j - weight_2] != -1: dp[j] = max(dp[j], dp[j - weight_2] + cost_2)`\n   This is `O(len(items2) * m)`. Still the bottleneck.\n\nThe actual solution to problems with very small weights (e.g., `w_i <= W_max` where `W_max` is small, like 3) is often `O(M * W_max^2)` or `O(M * W_max)`.\nThe `O(M)` solution for two types `w_a, w_b` is achieved by DP `dp[i]` for values `i % w_a` (or `i % w_b`) using a sliding window maximum.\nHere, we have three weights.\n\nLet's re-examine the `O(M)` DP with a deque for two item types.\nSay we have items of weight `W` with costs `C_1, C_2, ... C_N`.\nAnd `dp[j]` is the maximum value for weight `j` using previous items.\nTo update `dp[j]` considering `k` items of weight `W` with costs `P_W[k]`:\n`dp_new[j] = max_{0 <= k <= N_W} (dp[j - k*W] + P_W[k])`.\nThis is what needs to be solved efficiently for all `j`.\nFor a fixed `j`, we only care about `j - k*W`.\nLet `j = q*W + r`. We want `max_{k} (dp[(q-k)*W + r] + P_W[k])`.\nLet `idx = q-k`. We want `max_{idx} (dp[idx*W + r] + P_W[q-idx])`.\nThis is exactly the form `max_{idx} (A[idx] + B[q-idx])`, where `A[idx] = dp[idx*W+r]` and `B[k] = P_W[k]`.\nThis is a standard problem solvable with a deque in `O(m/W)` for each `r`. Total `O(M)`.\n\nSo, the algorithm is:\n1. Parse input, sort costs for `w=1, 2, 3` into `items1, items2, items3`.\n2. Compute prefix sums `P1, P2, P3`.\n3. Initialize `dp[w]` array of size `m+1` to `0`. (We want max cost, so minimum is 0, not -1).\n   This `dp` will store the maximum cost for weight `w` using items of weight 2 and 3.\n   `dp[0] = 0`.\n   For `w` from `1` to `m`: `dp[w] = -1` (unreachable).\n\n4. **Incorporate items of weight 2 into `dp`:**\n   For each `r` from `0` to `1` (for `w % 2`):\n     `deque = collections.deque()`\n     For `q` from `0` to `(m-r)//2`:\n       `j = 2*q + r`\n       `val_A = P2[q]` if `q <= len(items2)` else `-infinity`\n       While `deque` is not empty and `deque.front()` is too far: `q - deque.front() > len(items2)`:\n         `deque.pop_front()`\n       While `deque` is not empty and `P2[deque.back()] + dp[j - 2*deque.back()]`...\n       The form `max_{k} (dp[j - k*W] + P_W[k])` requires `dp` to be the \"base\" values.\n       Let `dp_val[idx] = dp[idx*W + r]`.\n       Let `P_val[k] = P_W[k]`.\n       We want `max_{k} (dp_val[q-k] + P_val[k])`.\n       This is a max convolution.\n\nThis is getting complex. Let's simplify.\nThe problem statement itself is a standard knapsack. The key is `w_i <= 3`.\nA simpler DP:\n`dp[w]` = maximum cost for weight `w`.\nInitialize `dp[0]=0`, `dp[j]=-1` for `j>0`.\n\nFor each item `(w_i, c_i)`:\n  For `j` from `m` down to `w_i`:\n    `if dp[j-w_i] != -1: dp[j] = max(dp[j], dp[j-w_i] + c_i)`\nThis is `O(N*M)` if done naively.\n\nThe specific trick for `w_i <= 3` is:\nFor items of weight 1: `dp[j] = P1[j]`. This is `O(M)`.\nFor items of weight 2: `dp_new[j] = max_{k2} (dp[j - 2*k2] + P2[k2])`.\nFor items of weight 3: `dp_final[j] = max_{k3} (dp_new[j - 3*k3] + P3[k3])`.\n\nEach of these steps can be done in `O(M)` using a deque for the sliding window maximum, because `P_W[k]` is a sum of decreasing values, which makes it a \"concave\" function (or rather, the values `P_W[k] - k * C` where `C` is a slope, can be used for deque).\nMore simply, `P_W[k]` represents the sum of `k` largest values.\nThe function `f(k) = P_W[k]` is concave if `items_W` are sorted decreasingly.\nThis means `f(k+1) - f(k)` is non-increasing.\nThis property is what allows the deque optimization.\n\n**Final Algorithm:**\n1. Read `n, m`.\n2. Create lists `items1, items2, items3` for costs of souvenirs with weights 1, 2, 3 respectively.\n3. Sort `items1, items2, items3` in descending order.\n4. Compute prefix sums `P1, P2, P3` for these sorted lists. `P_type[0] = 0`.\n5. Initialize `dp` array of size `m+1` with `0`s. (This `dp` will store max cost for weight `w` using only items of weight 1).\n   For `k1` from `1` to `len(items1)`:\n     If `k1 <= m`: `dp[k1] = P1[k1]`\n   (This is correct because taking `k1` items of weight 1 means taking the `k1` most expensive ones, which is `P1[k1]`).\n\n6. Create `dp_next` array of size `m+1` with `0`s. (This `dp_next` will store max cost for weight `w` using items of weight 1 and 2).\n   For `k2` from `0` to `len(items2)`:\n     `cost_k2 = P2[k2]`\n     `weight_k2 = 2 * k2`\n     If `weight_k2 > m`: break\n     For `j` from `0` to `m - weight_k2`:\n       `dp_next[j + weight_k2] = max(dp_next[j + weight_k2], dp[j] + cost_k2)`\n   `dp = dp_next` (Now `dp` contains max costs using items of weight 1 and 2).\n   This step is `O(len(items2) * m)`. This is the one that needs the deque optimization.\n\n**The `O(M)` DP with deque for bounded knapsack (multiple items of same weight):**\nLet `dp` be the current DP array (e.g., after processing weight 1 items).\nWe want to update `dp` by adding items of weight `W` (e.g., `W=2`).\n`P_W` are prefix sums for `W`. `N_W = len(items_W)`.\n`new_dp = list(dp)`\nFor each `r` from `0` to `W-1` (remainder when dividing by `W`):\n  `deque = collections.deque()`\n  For `q` from `0` to `(m-r)//W`:\n    `j = q * W + r`\n    `val_to_add = dp[j] - P_W[q]` (if `dp[j]` is reachable)\n    While `deque` is not empty and `deque.front()` is too far: `q - deque.front() > N_W`:\n      `deque.pop_front()`\n    While `deque` is not empty and `val_to_add >= (dp[deque.back()*W + r] - P_W[deque.back()])`:\n      `deque.pop_back()`\n    `deque.append(q)`\n    If `deque` is not empty and `dp[deque.front()*W + r] != -1`:\n      `new_dp[j] = max(new_dp[j], dp[deque.front()*W + r] + P_W[q - deque.front()])`\n`dp = new_dp`\n\nThis `O(M)` per item type (weight 2 and weight 3) is the correct approach.\nTotal time complexity: `O(N log N)` for sorting + `O(M)` for prefix sums + `O(M)` for `W=1` + `O(M)` for `W=2` + `O(M)` for `W=3`. This is `O(N log N + M)`.\n\nLet's trace the deque logic more carefully.\n`dp[j]` is max value for weight `j` using items of weights less than `W`.\nWe want to compute `dp_new[j] = max_{0 <= k <= N_W} (dp[j - k*W] + P_W[k])`.\nLet `j = qW + r`.\n`dp_new[qW + r] = max_{0 <= k <= N_W} (dp[(q-k)W + r] + P_W[k])`.\nLet `idx = q-k`. Then `k = q-idx`.\n`dp_new[qW + r] = max_{q-N_W <= idx <= q} (dp[idx*W + r] + P_W[q-idx])`.\nThis is `max_{idx} (A[idx] + B[q-idx])` where `A[idx] = dp[idx*W+r]` and `B[k] = P_W[k]`.\nThis is a standard sliding window maximum.\nFor each `r` from `0` to `W-1`:\n  `deque = collections.deque()`\n  For `q` from `0` to `(m-r)//W`:\n    `j = q*W + r`\n    `current_A_val = dp[j]`\n    `current_B_idx = q`\n\n    While `deque` is not empty and `deque.front() < q - N_W`:\n      `deque.pop_front()`\n\n    While `deque` is not empty and `current_A_val + P_W[q - current_B_idx]` (this is wrong, it should be `A[deque.back()] + B[q - deque.back()]` vs `A[q] + B[0]`)\n    The deque stores `idx`. We want to maximize `dp[idx*W+r] + P_W[q-idx]`.\n    `candidate_val = dp[j] - P_W[q]` (if `dp[j]` is reachable). This is `A[q] - B[q]`.\n    While `deque` is not empty and `(dp[deque.back()*W+r] - P_W[deque.back()]) <= candidate_val`:\n      `deque.pop_back()`\n    `deque.append(q)`\n    If `dp[deque.front()*W+r] != -1`:\n      `dp_new[j] = max(dp_new[j], dp[deque.front()*W+r] + P_W[q - deque.front()])`\n\nThis is it.\n\n```python\nimport sys\nimport collections\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    items1 = []\n    items2 = []\n    items3 = []\n\n    for _ in range(n):\n        w, c = map(int, sys.stdin.readline().split())\n        if w == 1:\n            items1.append(c)\n        elif w == 2:\n            items2.append(c)\n        else: # w == 3\n            items3.append(c)\n\n    items1.sort(reverse=True)\n    items2.sort(reverse=True)\n    items3.sort(reverse=True)\n\n    # Precompute prefix sums\n    P1 = [0] * (len(items1) + 1)\n    for i in range(len(items1)):\n        P1[i+1] = P1[i] + items1[i]\n\n    P2 = [0] * (len(items2) + 1)\n    for i in range(len(items2)):\n        P2[i+1] = P2[i] + items2[i]\n\n    P3 = [0] * (len(items3) + 1)\n    for i in range(len(items3)):\n        P3[i+1] = P3[i] + items3[i]\n\n    # dp[w] stores max cost for weight w using items of weight 1\n    # Initialize dp with -1 (unreachable)\n    dp = [-1] * (m + 1)\n    dp[0] = 0\n\n    # Step 1: Incorporate items of weight 1\n    # For weight 1, we can just take the k most expensive items\n    # and update dp[k]\n    for k1 in range(1, len(P1)):\n        weight_k1 = k1 * 1\n        if weight_k1 <= m:\n            dp[weight_k1] = P1[k1]\n    \n    # After this, dp[w] stores max cost for weight w using only items of weight 1\n    # Or -1 if unreachable.\n\n    # Function to apply bounded knapsack DP for a specific weight_val using deque\n    # current_dp: dp array from previous stages\n    # prefix_sums_for_weight: P_W array\n    # N_W: len(items_W)\n    # weight_val: current item weight (2 or 3)\n    # max_m: total capacity\n    def apply_bounded_knapsack(current_dp, prefix_sums_for_weight, N_W, weight_val, max_m):\n        new_dp = list(current_dp) # Copy current dp state\n        \n        # Iterate over remainders r when dividing by weight_val\n        for r in range(weight_val):\n            deque = collections.deque()\n            # Iterate q such that j = q * weight_val + r\n            for q in range((max_m - r) // weight_val + 1):\n                j = q * weight_val + r\n                \n                # Pop from front of deque if index is too old (outside window of N_W items)\n                while deque and deque[0] < q - N_W:\n                    deque.popleft()\n                \n                # Calculate value for current q to potentially add to deque\n                # This is A[q] - B[q] form: dp[j] - P_W[q]\n                current_val_for_deque = -1\n                if current_dp[j] != -1:\n                    current_val_for_deque = current_dp[j] - prefix_sums_for_weight[q]\n                \n                # Pop from back of deque if current value is better (maintaining decreasing order)\n                while deque and (current_dp[deque[-1] * weight_val + r] - prefix_sums_for_weight[deque[-1]]) <= current_val_for_deque:\n                    deque.pop()\n                \n                # Add current q to deque\n                deque.append(q)\n                \n                # Update new_dp[j] using the best candidate from deque\n                # This is A[deque.front()] + B[q - deque.front()]\n                if deque and current_dp[deque[0] * weight_val + r] != -1:\n                    new_dp[j] = max(new_dp[j], current_dp[deque[0] * weight_val + r] + prefix_sums_for_weight[q - deque[0]])\n        return new_dp\n\n    # Step 2: Incorporate items of weight 2\n    dp = apply_bounded_knapsack(dp, P2, len(items2), 2, m)\n\n    # Step 3: Incorporate items of weight 3\n    dp = apply_bounded_knapsack(dp, P3, len(items3), 3, m)\n    \n    # The final answer is the maximum value in the dp array\n    # Since dp[0] is 0, if no items can be taken, max(dp) will be 0.\n    # If m=0, dp[0]=0, max(dp)=0.\n    print(max(dp))\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport collections\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    items1 = []\n    items2 = []\n    items3 = []\n\n    for _ in range(n):\n        w, c = map(int, sys.stdin.readline().split())\n        if w == 1:\n            items1.append(c)\n        elif w == 2:\n            items2.append(c)\n        else: # w == 3\n            items3.append(c)\n\n    items1.sort(reverse=True)\n    items2.sort(reverse=True)\n    items3.sort(reverse=True)\n\n    # Precompute prefix sums\n    P1 = [0] * (len(items1) + 1)\n    for i in range(len(items1)):\n        P1[i+1] = P1[i] + items1[i]\n\n    P2 = [0] * (len(items2) + 1)\n    for i in range(len(items2)):\n        P2[i+1] = P2[i] + items2[i]\n\n    P3 = [0] * (len(items3) + 1)\n    for i in range(len(items3)):\n        P3[i+1] = P3[i] + items3[i]\n\n    # dp[w] stores max cost for weight w using items of weight 1\n    # Initialize dp with -1 (unreachable)\n    dp = [-1] * (m + 1)\n    dp[0] = 0\n\n    # Step 1: Incorporate items of weight 1\n    # For weight 1, we can just take the k most expensive items\n    # and update dp[k]\n    for k1 in range(1, len(P1)):\n        weight_k1 = k1 * 1\n        if weight_k1 <= m:\n            dp[weight_k1] = P1[k1]\n    \n    # After this, dp[w] stores max cost for weight w using only items of weight 1\n    # Or -1 if unreachable.\n\n    # Function to apply bounded knapsack DP for a specific weight_val using deque\n    # current_dp: dp array from previous stages\n    # prefix_sums_for_weight: P_W array\n    # N_W: len(items_W)\n    # weight_val: current item weight (2 or 3)\n    # max_m: total capacity\n    def apply_bounded_knapsack(current_dp, prefix_sums_for_weight, N_W, weight_val, max_m):\n        new_dp = list(current_dp) # Copy current dp state\n        \n        # Iterate over remainders r when dividing by weight_val\n        for r in range(weight_val):\n            deque = collections.deque()\n            # Iterate q such that j = q * weight_val + r\n            for q in range((max_m - r) // weight_val + 1):\n                j = q * weight_val + r\n                \n                # Pop from front of deque if index is too old (outside window of N_W items)\n                while deque and deque[0] < q - N_W:\n                    deque.popleft()\n                \n                # Calculate value for current q to potentially add to deque\n                # This is A[q] - B[q] form: dp[j] - P_W[q]\n                current_val_for_deque = -1\n                if current_dp[j] != -1:\n                    current_val_for_deque = current_dp[j] - prefix_sums_for_weight[q]\n                \n                # Pop from back of deque if current value is better (maintaining decreasing order)\n                while deque and (current_dp[deque[-1] * weight_val + r] - prefix_sums_for_weight[deque[-1]]) <= current_val_for_deque:\n                    deque.pop()\n                \n                # Add current q to deque\n                deque.append(q)\n                \n                # Update new_dp[j] using the best candidate from deque\n                # This is A[deque.front()] + B[q - deque.front()]\n                if deque and current_dp[deque[0] * weight_val + r] != -1:\n                    new_dp[j] = max(new_dp[j], current_dp[deque[0] * weight_val + r] + prefix_sums_for_weight[q - deque[0]])\n        return new_dp\n\n    # Step 2: Incorporate items of weight 2\n    dp = apply_bounded_knapsack(dp, P2, len(items2), 2, m)\n\n    # Step 3: Incorporate items of weight 3\n    dp = apply_bounded_knapsack(dp, P3, len(items3), 3, m)\n    \n    # The final answer is the maximum value in the dp array\n    # Since dp[0] is 0, if no items can be taken, max(dp) will be 0.\n    # If m=0, dp[0]=0, max(dp)=0.\n    print(max(dp))\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 497,
        "completion_token_count": 10398,
        "thoughts_token_count": 6311
    }
}