{
    "start": 1758294861.3043156,
    "end": 1758295031.2850711,
    "start-formatted": "2025-09-20 00:14 KST",
    "end-formatted": "2025-09-20 00:17 KST",
    "gpu": 2,
    "pid": 28,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vasily the Bear and Beautiful Strings\n\nVasily the Bear loves beautiful strings. String s is beautiful if it meets the following criteria:   String s only consists of characters 0 and 1, at that character 0 must occur in string s exactly n times, and character 1 must occur exactly m times.  We can obtain character g from string s with some (possibly, zero) number of modifications. The character g equals either zero or one. A modification of string with length at least two is the following operation: we replace two last characters from the string by exactly one other character. This character equals one if it replaces two zeros, otherwise it equals zero. For example, one modification transforms string \"01010\" into string \"0100\", two modifications transform it to \"011\". It is forbidden to modify a string with length less than two.Help the Bear, count the number of beautiful strings. As the number of beautiful strings can be rather large, print the remainder after dividing the number by 1000000007 (109 + 7). \n\n## Input\nThe first line of the input contains three space-separated integers n, m, g (0 ≤ n, m ≤ 105, n + m ≥ 1, 0 ≤ g ≤ 1).\n\n## Output\nPrint a single integer — the answer to the problem modulo 1000000007 (109 + 7).\n\n## Example\n### Input\n['1 1 0', '2 2 0', '1 1 1']\n\n### Output\n['2', '4', '0']\n\n## Note\nIn the first sample the beautiful strings are: \"01\", \"10\".In the second sample the beautiful strings are: \"0011\", \"1001\", \"1010\", \"1100\".In the third sample there are no beautiful strings.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "**Analyzing \"Beautiful Strings\" and the Binary Operation**\n\nOkay, so I'm tackling this competitive programming problem involving \"beautiful strings.\" The goal is to figure out how many strings of a given length, composed of zeros and ones, produce a specific target character after applying a unique modification operation. This operation is essentially a reduction, taking the last two characters of the string and replacing them with a single, new character based on a set of rules.\n\nMy initial approach involved looking at this as a kind of bitwise operation. I tried mapping zeros and ones to numbers and found that the operation looked like a \"NOT (A OR B)\" or `NOT (00)` -> `1` and everything else -> `0`. I then used XOR and tried to model the process, but that didn't work. The right combination, it turns out, is to just evaluate the last 2 digits, which is `(x == 0 && y == 0) ? 1 : 0`. The right expression can be written as `f(x, y)` =  `1` if `x=0 && y=0`, and 0 otherwise.\n\nIt feels like the order of operations should not matter. I proved that the function `f(x,y)` is associative, which means the order *shouldn't* matter. We can reduce the string in any order. The right-to-left reduction method is a bit easier to visualize. I even found a transformation that changed this into an AND operation (by flipping the bits). But somehow, after applying this assumption, I was arriving at wrong results.\n\nThe key insight is that even though the underlying operation is associative, the problem *defines* a specific right-to-left reduction. That fixed order of operation turns out to be very important. If the string starts with a one, the end result is always zero. If the first character is zero, the answer is just the opposite of what's left after the removal operation.\n\nSo, I need to focus on this strict, right-to-left reduction and the number of strings that map to a target value `g`. The solution boils down to checking the first character and the reduction in each step.\n",
    "response": "The problem asks us to count the number of binary strings containing exactly `n` zeros and `m` ones that reduce to a target character `g` (either 0 or 1). The reduction rule is: replace the two last characters `xy` with a new character `z`. `z=1` if `x=0` and `y=0`; `z=0` otherwise. This operation is applied `n+m-1` times until a single character remains.\n\nLet's denote the operation as `f(x, y)`.\n`f(0,0) = 1`\n`f(0,1) = 0`\n`f(1,0) = 0`\n`f(1,1) = 0`\n\nFor a string `s = s_1 s_2 ... s_k`, the reduction is performed by repeatedly replacing the last two characters. This means the reduction is right-associative: `R(s_1 s_2 ... s_k) = f(s_1, f(s_2, ... f(s_{k-1}, s_k)...))`.\n\nLet's analyze the properties of this reduction:\n1.  **If a string starts with '1'**: `R(1 s_2 ... s_k) = f(1, R(s_2 ... s_k))`. From the definition of `f`, `f(1, X)` is always `0` regardless of `X`. So, any string starting with '1' reduces to '0'.\n2.  **If a string starts with '0'**: `R(0 s_2 ... s_k) = f(0, R(s_2 ... s_k))`.\n    If `R(s_2 ... s_k) = 0`, then `f(0,0) = 1`.\n    If `R(s_2 ... s_k) = 1`, then `f(0,1) = 0`.\n    So, if a string starts with '0', its result is `1 - R(s_2 ... s_k)`.\n\nLet `k = n+m` be the length of the string.\nLet `s = s_1 s_2 ... s_k`.\nLet `first_one_idx` be the index of the first '1' in the string (1-indexed). If there are no '1's, `first_one_idx = k+1`.\n\n*   **Case 1: `s_1 = 1`**\n    The string starts with '1'. As established above, `R(s) = 0`.\n    This applies to all strings that start with '1'. The number of such strings is `C(n+m-1, n)` (choose `n` positions for '0's from the remaining `n+m-1` characters).\n\n*   **Case 2: `s_1 = 0`**\n    The string starts with '0'. `R(s) = 1 - R(s_2 ... s_k)`.\n    Let `s' = s_2 ... s_k`. `s'` has `n-1` zeros and `m` ones.\n    If `m=0` (all characters are '0'):\n    The string is `00...0` (`n` zeros).\n    `R(0) = 0`.\n    `R(00) = f(0, R(0)) = f(0,0) = 1`.\n    `R(000) = f(0, R(00)) = f(0,1) = 0`.\n    `R(0000) = f(0, R(000)) = f(0,0) = 1`.\n    The pattern is: `R(0...0)` (length `N`) is `0` if `N` is odd, and `1` if `N` is even.\n    So, if `m=0`, `R(s) = (n+1) % 2`. (Result is 0 if n is odd, 1 if n is even).\n\n    Now consider `m > 0` and `s_1 = 0`.\n    `R(s) = 1 - R(s_2 ... s_k)`.\n    Let `s_j` be the first '1' in `s`. So `s_1=...=s_{j-1}=0` and `s_j=1`.\n    `R(s_2 ... s_k)`: This string starts with `j-2` zeros, then `s_j=1`.\n    `R(s_2 ... s_k) = f(s_2, f(s_3, ... f(s_{j-1}, f(s_j, ...))...))`.\n    Since `s_j=1`, `f(s_j, ...)` will be `0`.\n    So `R(s_j ... s_k) = 0`.\n    Then `R(s_{j-1} ... s_k) = f(s_{j-1}, R(s_j ... s_k)) = f(0, 0) = 1`.\n    Then `R(s_{j-2} ... s_k) = f(s_{j-2}, R(s_{j-1} ... s_k)) = f(0, 1) = 0`.\n    The result `R(s_i ... s_k)` flips for each preceding '0'.\n    `R(s_2 ... s_k) = (j-2)`-th flip from `R(s_j ... s_k)`.\n    `R(s_2 ... s_k) = (j-2) % 2`. (Result is 0 if j-2 is even, 1 if j-2 is odd).\n    Finally, `R(s) = 1 - R(s_2 ... s_k) = 1 - ((j-2) % 2) = (j-1) % 2`.\n    This means `R(s)=0` if `j-1` is even (i.e., `j` is odd).\n    And `R(s)=1` if `j-1` is odd (i.e., `j` is even).\n\n    So, for `s_1=0` and `m>0`:\n    `R(s)=0` if the first '1' appears at an odd index `j`. (e.g., `01...`, `0001...`)\n    `R(s)=1` if the first '1' appears at an even index `j`. (e.g., `001...`, `00001...`)\n\nCombining all cases:\n\n**Target `g=0`:**\n1.  Strings starting with '1' (requires `m >= 1`): These all reduce to '0'.\n    Number of such strings: `C(n+m-1, n)`.\n2.  Strings starting with '0' (requires `n >= 1`):\n    a.  If `m=0`: String is `0...0` (`n` zeros). Reduces to `0` if `n` is odd.\n        Number of such strings: `1` (if `n` is odd), `0` (if `n` is even).\n    b.  If `m>0`: Reduces to `0` if the first '1' is at an odd index `j`.\n        This means the prefix `0...0` before the first '1' has an even length `j-1`.\n        `j-1` zeros, followed by `1`.\n        The number of '0's before the first '1' must be `0, 2, 4, ...` up to `n-1`.\n        For each `k \\in \\{0, 2, ..., n-1\\}`:\n        We place `k` zeros, then a '1'. The remaining `n-k-1` zeros and `m-1` ones can be arranged in `C(n+m-1-k-1, n-k-1)` ways.\n        Sum `C(n+m-k-2, n-k-1)` for `k=0,2,...,n-1`.\n\n**Target `g=1`:**\n1.  Strings starting with '1' (requires `m >= 1`): These all reduce to '0', so they don't count for `g=1`. Number of such strings: `0`.\n2.  Strings starting with '0' (requires `n >= 1`):\n    a.  If `m=0`: String is `0...0` (`n` zeros). Reduces to `1` if `n` is even.\n        Number of such strings: `1` (if `n` is even), `0` (if `n` is odd).\n    b.  If `m>0`: Reduces to `1` if the first '1' is at an even index `j`.\n        This means the prefix `0...0` before the first '1' has an odd length `j-1`.\n        `j-1` zeros, followed by `1`.\n        The number of '0's before the first '1' must be `1, 3, 5, ...` up to `n-1`.\n        For each `k \\in \\{1, 3, ..., n-1\\}`:\n        We place `k` zeros, then a '1'. The remaining `n-k-1` zeros and `m-1` ones can be arranged in `C(n+m-1-k-1, n-k-1)` ways.\n        Sum `C(n+m-k-2, n-k-1)` for `k=1,3,...,n-1`.\n\n**Special case: `n+m=0` is forbidden by `n+m>=1`.**\n**Special case: `n=0`**\nIf `n=0`, the string consists only of '1's. `1...1` (`m` ones).\nThis string starts with '1', so `R(s) = 0`.\nTherefore, if `n=0`:\n- If `g=0`: Answer is `1` (the string `1...1` reduces to `0`).\n- If `g=1`: Answer is `0`.\n\n**Special case: `m=0`**\nIf `m=0`, the string consists only of '0's. `0...0` (`n` zeros).\n- If `n` is odd: `R(s)=0`.\n- If `n` is even: `R(s)=1`.\nTherefore, if `m=0`:\n- If `g=0`: Answer is `1` if `n` is odd, `0` if `n` is even.\n- If `g=1`: Answer is `1` if `n` is even, `0` if `n` is odd.\n\n**Implementation details:**\nWe need combinations `C(N, K) = N! / (K! * (N-K)!)` modulo `1000000007`.\nPrecompute factorials and inverse factorials.\nThe sum `sum C(A-k, B-k)` where `k` has a fixed parity can be efficiently calculated.\nThe sum `sum_{k=0,2,...}^{n-1} C(n+m-k-2, n-k-1)`\nLet `N' = n+m-2`, `K' = n-1`.\nThe sum is `sum_{k=0,2,...}^{n-1} C(N'-k, K'-k)`.\nThis is `C(N', K') + C(N'-2, K'-2) + C(N'-4, K'-4) + ...`.\nThis is a standard identity: `sum_{i=0}^k C(N-i, K-i) = C(N+1, K) - C(N-k, K-k-1)`.\nNo, this is not exactly that.\nIt's `sum_{i=0}^{\\lfloor (n-1)/2 \\rfloor} C(n+m-2-2i, n-1-2i)`.\n\nLet's use the identity `sum_{i=0}^{N} C(R-i, K) = C(R+1, K+1) - C(R-N, K+1)`.\nThis is not directly applicable.\n\nA simpler approach for the sum:\nLet `f(N_0, N_1, target_g)` be the number of strings with `N_0` zeros and `N_1` ones that reduce to `target_g`.\nWe are looking for `f(n, m, g)`.\n\nIf `n=0`:\n  `f(0, m, 0) = 1`\n  `f(0, m, 1) = 0`\n\nIf `m=0`:\n  `f(n, 0, 0) = 1` if `n` is odd, `0` if `n` is even.\n  `f(n, 0, 1) = 1` if `n` is even, `0` if `n` is odd.\n\nIf `n>0` and `m>0`:\n`Total strings = C(n+m, n)`.\nStrings starting with '1' (`m-1` ones, `n` zeros): `C(n+m-1, n)`. These reduce to `0`.\nStrings starting with '0' (`m` ones, `n-1` zeros): `C(n+m-1, n-1)`.\nLet `A` be the count of strings starting with '1' that reduce to `0`. `A = C(n+m-1, n)`.\nLet `B_0` be the count of strings starting with '0' that reduce to `0`.\nLet `B_1` be the count of strings starting with '0' that reduce to `1`.\nWe know `B_0 + B_1 = C(n+m-1, n-1)`.\n\nFrom the analysis:\nStrings starting with '0' (`0 s_2 ... s_k`) reduce to `0` if the first '1' in `s_2 ... s_k` is at an odd index (relative to `s_2`, i.e., at `s_3, s_5, ...`).\nThis means `s_2=0, s_3=1` OR `s_2=0, s_3=0, s_4=0, s_5=1` etc.\nEquivalently, the number of leading zeros in `s_2 ... s_k` is even (`0, 2, 4, ...`).\nLet `N_0'` be `n-1` and `N_1'` be `m`.\n`B_0 = sum_{k=0,2,...}^{N_0'} C(N_0'+N_1'-1-k, N_0'-k)`. (Number of ways to choose remaining chars after `k` zeros and a '1').\n`B_1 = sum_{k=1,3,...}^{N_0'} C(N_0'+N_1'-1-k, N_0'-k)`.\n\nNotice that for `g=0`, we need `A + B_0`. For `g=1`, we need `B_1`.\n`A = C(n+m-1, n)`.\n`B_0 + B_1 = C(n+m-1, n-1)`.\nWe need to calculate `B_0` and `B_1`.\n\nLet `S(N_0, N_1)` be the count of strings with `N_0` zeros and `N_1` ones that start with '0' and reduce to `0`.\nLet `T(N_0, N_1)` be the count of strings with `N_0` zeros and `N_1` ones that start with '0' and reduce to `1`.\n`S(N_0, N_1) = sum_{k=0,2,...}^{N_0} C(N_0+N_1-1-k, N_0-k)`.\n`T(N_0, N_1) = sum_{k=1,3,...}^{N_0} C(N_0+N_1-1-k, N_0-k)`.\n\nThe sum `sum_{k \\text{ even}} C(X-k, Y-k)` is `C(X+1, Y+1) - sum_{k \\text{ odd}} C(X-k, Y-k)`.\nThere is a known identity for alternating sums of binomial coefficients, but these are not alternating.\nAnother approach:\n`S(N_0, N_1) + T(N_0, N_1) = C(N_0+N_1, N_0)`. This is the total number of strings starting with '0'.\n`S(N_0, N_1) = C(N_0+N_1-1, N_0) - T(N_0-1, N_1)` (if `N_0 > 0`).\n`T(N_0, N_1) = C(N_0+N_1-1, N_0) - S(N_0-1, N_1)` (if `N_0 > 0`).\n\nThis recursive definition is not useful for direct calculation.\nLet's consider the number of leading zeros `k` (before the first '1') in strings starting with '0'.\nFor a string `0...01...` (`k` zeros before the first '1').\nThe length of this prefix `0...01` is `k+1`.\nThe result `R(0...01...)` is `1` if `k` is odd, and `0` if `k` is even.\nSo, for strings starting with '0':\n- To get `g=0`: `k` must be even. `k \\in \\{0, 2, ..., n-1\\}`.\n  For each such `k`, we fix `k` zeros, then a '1'. Remaining `n-1-k` zeros and `m-1` ones.\n  Number of ways: `C((n-1-k)+(m-1), n-1-k) = C(n+m-k-2, n-k-1)`.\n- To get `g=1`: `k` must be odd. `k \\in \\{1, 3, ..., n-1\\}`.\n  For each such `k`, we fix `k` zeros, then a '1'. Remaining `n-1-k` zeros and `m-1` ones.\n  Number of ways: `C((n-1-k)+(m-1), n-1-k) = C(n+m-k-2, n-k-1)`.\n\nThe sum `sum_{i=0}^{\\lfloor (N-1)/2 \\rfloor} C(M-2i, K-2i)` where `M = n+m-2`, `K = n-1`.\nThis is `sum_{i=0}^{\\lfloor (n-1)/2 \\rfloor} C(n+m-2-2i, n-1-2i)`.\nThe indices for `C(N, K)` are `N` and `K`.\nThe upper index `N` decreases by 2, the lower index `K` decreases by 2.\nThis is `C(N,K) + C(N-2,K-2) + C(N-4,K-4) + ...`.\nThis sum is `C(N, K)` if `K=0` or `K=N`.\nIf `K=0`, it's `C(N,0) + C(N-2,0) + ...`. This is `1 + 1 + ...`.\nIf `K=1`, it's `C(N,1) + C(N-2,1) + ...`.\nThis is a sum along a diagonal in Pascal's triangle.\n\nThe sum `sum_{i=0}^{\\lfloor (X-Y)/2 \\rfloor} C(X-i, Y+i)` is `C(X+1, Y)`.\nThis is not quite it.\n\nLet's use a dynamic programming approach for the sums.\n`dp[i][j][parity]` = number of ways to arrange `i` zeros and `j` ones such that the string starts with '0' and the first '1' is at an index leading to `parity` (0 for even, 1 for odd).\nThis is getting complicated.\n\nLet's check the constraints: `n, m <= 10^5`. A DP solution would be `O(N*M)` which is too slow.\nThe sums must be calculated efficiently, likely using a combinatorial identity or a direct formula.\n\nConsider the identity: `sum_{k=0}^N C(M-k, K) = C(M+1, K+1) - C(M-N, K+1)`. (Hockey stick identity variant).\nThis is `sum_{k=0}^N C(N_0'+N_1'-1-k, N_1'-1)`.\nThe form `C(N-k, K-k)` is difficult.\n\nLet's re-examine `n=2, m=2, g=0`.\n`n=2, m=2`. Total length 4.\nStrings starting with '1' (`m=2 >= 1`): `C(2+2-1, 2) = C(3,2) = 3`.\nThese are `1001`, `1010`, `1100`. All reduce to `0`. So these count.\nStrings starting with '0' (`n=2 >= 1`, `m=2 >= 1`): `C(2+2-1, 2-1) = C(3,1) = 3`.\nThese are `0011`, `0101`, `0110`.\nFor these strings, `n-1=1`, `m=2`.\n  `k=0` (even): `C(n+m-k-2, n-k-1) = C(2+2-0-2, 2-0-1) = C(2,1) = 2`.\n    Strings are `0101`, `0110`.\n    `0101`: `k=0` leading zeros before '1'. `R(0101) = 1`. (first '1' at index 2, `k=0`, `0` is even).\n    `0110`: `k=0` leading zeros before '1'. `R(0110) = 1`.\n  `k=1` (odd): `C(n+m-k-2, n-k-1) = C(2+2-1-2, 2-1-1) = C(1,0) = 1`.\n    String is `0011`.\n    `0011`: `k=1` leading zeros before '1'. `R(0011) = 0`. (first '1' at index 3, `k=1`, `1` is odd).\n\nWait, the logic for `R(0...01...)` was: `R(s)=0` if `k` is even, `R(s)=1` if `k` is odd.\nSo for `g=0`:\n  Strings starting with '1' (`C(3,2)=3`) count.\n  Strings starting with '0' (`C(3,1)=3`):\n    `k` must be even. `k=0`. `C(2,1)=2`. Strings `0101`, `0110`. These reduce to `1`. So they DON'T count for `g=0`.\n    `k` must be odd. `k=1`. `C(1,0)=1`. String `0011`. This reduces to `0`. So it DOES count for `g=0`.\nTotal for `g=0` is `3 + 1 = 4`. This matches the example!\n\nSo the logic is:\nIf `g=0`:\n  Count `C(n+m-1, n)` (strings starting with '1')\n  PLUS count strings starting with '0' where `k` (leading zeros before first '1') is odd.\n  This sum is `sum_{k=1,3,...}^{n-1} C(n+m-k-2, n-k-1)`.\nIf `g=1`:\n  Count strings starting with '0' where `k` (leading zeros before first '1') is even.\n  This sum is `sum_{k=0,2,...}^{n-1} C(n+m-k-2, n-k-1)`.\n\nThe sums `S_p(N, M) = sum_{k=p, p+2, ...}^{N} C(N+M-k-1, N-k)`\nwhere `p` is the starting parity (0 or 1).\nThis sum can be computed by iterating `k` and adding `C(N+M-k-1, N-k)`.\nThe maximum value of `k` is `N`. So `k` can go up to `n-1`.\nThe number of terms in the sum is `n/2`. This is `O(n)`.\nSince `n` can be `10^5`, this is too slow. We need `O(1)` or `O(log n)`.\n\nThe identity `sum_{i=0}^N C(R-i, K-i) = C(R+1, K) - C(R-N, K-N-1)` is for a different sum.\nThe sum `sum_{i=0}^N C(R-i, K)` is `C(R+1, K+1) - C(R-N, K+1)`.\nThe sum `sum_{i=0}^N C(i, K)` is `C(N+1, K+1)`.\n\nLet `f(N, K) = C(N, K)`.\nWe need `sum_{i=0}^{\\lfloor (n-1)/2 \\rfloor} C(n+m-2-2i, n-1-2i)`.\nLet `A = n+m-2`, `B = n-1`.\nWe need `sum_{i=0}^{\\lfloor B/2 \\rfloor} C(A-2i, B-2i)`.\n\nThis is a known identity: `sum_{k=0}^{\\lfloor N/2 \\rfloor} C(M-2k, N-2k) = C(M, N+1) - C(M-1, N+1)` for some cases.\nNo, this is `sum_{k=0}^{\\lfloor N/2 \\rfloor} C(N-k, k) = F_{N+1}` (Fibonacci numbers).\n\nLet's try to find the identity for `sum_{k=0}^{\\lfloor N/2 \\rfloor} C(X-2k, Y-2k)`.\nThis can be rewritten as `sum_{j=0}^{\\lfloor N/2 \\rfloor} C(X-2j, (X-Y)-2j)`.\nNo, this is `sum_{k=0}^{\\lfloor (n-1)/2 \\rfloor} C( (n+m-2) - 2k, (n-1) - 2k )`.\nLet `R = n+m-2` and `C = n-1`.\nThe terms are `C(R, C), C(R-2, C-2), C(R-4, C-4), ...`.\nThis is `C(R, C) + C(R-2, C-2) + ... + C(R-2k_max, C-2k_max)`.\nwhere `k_max = floor((n-1)/2)`.\nThis sum is equal to `C(R+1, C+1) - C(R-2k_max, C-2k_max-1)`? No.\n\nLet's try to prove an identity.\n`S = C(R,C) + C(R-2,C-2) + C(R-4,C-4) + ...`\n`S = C(R, R-C) + C(R-2, R-C) + C(R-4, R-C) + ...` if `R-C` is constant. Not the case.\n\nThis sum `sum_{i=0}^k C(N-i, M)` is `C(N+1, M+1) - C(N-k, M+1)`.\nThis is `sum_{i=0}^k C(N-i, N-M-i)` (using `C(N,K)=C(N,N-K)`).\nThe sums are:\n`B_0 = sum_{k=0,2,...}^{n-1} C(n+m-k-2, n-k-1)`\n`B_1 = sum_{k=1,3,...}^{n-1} C(n+m-k-2, n-k-1)`\n\nThe general solution for `sum_{i=0}^k C(N-i, K-i)` is not `O(1)`.\nThis means the sums must be small enough to iterate, or there is a trick.\nThe maximum value of `n-1` is `10^5-1`.\nThe number of terms `(n-1)/2` can be `5*10^4`. This is too much.\n\nIs there a different way to categorize strings starting with '0'?\n`0 s_2 ... s_k` reduces to `g_0 = 1 - R(s_2 ... s_k)`.\n`s_2 ... s_k` has `n-1` zeros and `m` ones.\nLet `dp[zeros][ones][g_val]` be the count of strings with `zeros` and `ones` that reduce to `g_val`.\n`dp[n][m][g]`\nIf `s_1 = 1`: `dp[n][m][0] += C(n+m-1, n)`.\nIf `s_1 = 0`:\n  `dp[n][m][0] += dp[n-1][m][1]`\n  `dp[n][m][1] += dp[n-1][m][0]`\nThis is a recurrence for the total count of strings that reduce to `g`.\n`dp[n][m][g]` is the answer.\nBase cases:\n`dp[0][0][0] = 0`, `dp[0][0][1] = 0` (length < 1)\n`dp[1][0][0] = 1` (string \"0\"), `dp[1][0][1] = 0`\n`dp[0][1][0] = 1` (string \"1\"), `dp[0][1][1] = 0` (actually \"1\" reduces to 1, not 0. `n=0` means string \"11..1\". `R(\"1\")=1`, `R(\"11\")=0`, `R(\"111\")=0`. So `n=0` reduces to `0` if `m>=2` or `m=0` (not possible), and `1` if `m=1`.\nLet's fix the `n=0` case:\nIf `n=0`: string is `1...1` (`m` ones).\n  `R(\"1\") = 1`. (`m=1`)\n  `R(\"11\") = 0`. (`m=2`)\n  `R(\"111\") = 0`. (`m=3`)\n  So if `n=0`:\n    `g=0`: 1 if `m >= 2`, 0 if `m=1`.\n    `g=1`: 1 if `m=1`, 0 if `m >= 2`.\n\nLet's refine the DP state: `dp[N0][N1][result]` is the number of strings with `N0` zeros and `N1` ones that reduce to `result`.\n`MOD = 1000000007`.\n\n`dp[n][m][g]`:\n1. If `n=0`:\n   If `g=0`: return `1` if `m >= 2`, else `0`.\n   If `g=1`: return `1` if `m=1`, else `0`.\n2. If `m=0`:\n   If `g=0`: return `1` if `n` is odd, else `0`.\n   If `g=1`: return `1` if `n` is even, else `0`.\n3. If `n>0` and `m>0`:\n   `ans = 0`\n   (Strings starting with '1')\n   `ans = (ans + C(n+m-1, n)) % MOD` if `g=0`.\n   (Strings starting with '0')\n   `ans = (ans + dp[n-1][m][1-g]) % MOD`\nThis is a 2D DP `dp[n][m]`.\n`dp[i][j][0]` = count of strings with `i` zeros, `j` ones reducing to `0`.\n`dp[i][j][1]` = count of strings with `i` zeros, `j` ones reducing to `1`.\n\n`dp[i][j][0] = ( (j > 0 ? C(i+j-1, i) : 0) + (i > 0 ? dp[i-1][j][1] : 0) ) % MOD`\n`dp[i][j][1] = ( (i > 0 ? dp[i-1][j][0] : 0) ) % MOD`\n\nBase cases for DP:\n`dp[0][0][0] = 0, dp[0][0][1] = 0` (empty string)\nFor `i=1 to n`:\n  `dp[i][0][0] = 1` if `i` is odd, else `0`.\n  `dp[i][0][1] = 1` if `i` is even, else `0`.\nFor `j=1 to m`:\n  `dp[0][j][0] = 1` if `j >= 2`, else `0`.\n  `dp[0][j][1] = 1` if `j=1`, else `0`.\n\nThe DP states `dp[i-1][j]` are needed for `dp[i][j]`.\nThe states `dp[i][j-1]` are needed for `C(i+j-1, i)`.\nThe `C(N,K)` values can be computed on the fly if `N` is small. Here `N` can be `2*10^5`. Precomputing factorials and inverse factorials is necessary.\n\nThe DP table size would be `(N+1)*(M+1)*2`. `10^5 * 10^5` is too large. `10^10` states.\nThis DP approach is also too slow.\n\nThe recurrence `dp[n][m][0] = C(n+m-1, n) + dp[n-1][m][1]` (for `m>0, n>0`)\n`dp[n][m][1] = dp[n-1][m][0]` (for `n>0`)\nThis means `dp[n][m][1] = C(n+m-2, n-1) + dp[n-2][m][1]`\n`dp[n][m][1] = C(n+m-2, n-1) + C(n+m-4, n-2) + dp[n-3][m][1]`\n...\n`dp[n][m][1] = sum_{k=0}^{\\lfloor (n-1)/2 \\rfloor} C(n+m-2-2k, n-1-2k) + dp[n-1-2*floor((n-1)/2)][m][1]`\nThe last term `dp[n_rem][m][1]` where `n_rem` is `0` or `1`.\nIf `n` is odd, `n_rem = 0`. `dp[0][m][1]` is `1` if `m=1`, `0` otherwise.\nIf `n` is even, `n_rem = 1`. `dp[1][m][1]` is `0`.\n\nSo, for `n>0, m>0`:\n`dp[n][m][1] = sum_{k=0}^{\\lfloor (n-1)/2 \\rfloor} C(n+m-2-2k, n-1-2k)`.\nIf `n` is odd: `dp[n][m][1] = sum_{k=0}^{(n-1)/2 - 1} C(n+m-2-2k, n-1-2k) + dp[0][m][1]`\n  `dp[0][m][1]` is `1` if `m=1`, `0` otherwise.\n  The sum is `sum_{k=0}^{(n-1)/2} C(n+m-2-2k, n-1-2k)` where the last term `k=(n-1)/2` is `C(m-1, 0) = 1`.\n  So `dp[n][m][1] = sum_{k=0}^{(n-1)/2} C(n+m-2-2k, n-1-2k)` (this is for `m>0`).\n  This is the sum for `k` even `0, 2, ...` up to `n-1`.\n  This is `B_1` from before.\n\n`dp[n][m][0] = C(n+m-1, n) + dp[n-1][m][1]`.\n`dp[n-1][m][1] = sum_{k=0}^{\\lfloor (n-2)/2 \\rfloor} C(n+m-3-2k, n-2-2k)`. (This is for `n-1 > 0`).\n  This is the sum for `k` odd `1, 3, ...` up to `n-1`.\n  This is `B_0` from before.\n\nSo the problem boils down to calculating `sum_{k=p, p+2, ...}^{N} C(A-k, B-k)` efficiently.\nLet `S(R, C, limit, parity)` be `sum_{k=parity, parity+2, ...}^{limit} C(R-k, C-k)`.\n`R = n+m-2`, `C = n-1`.\n`dp[n][m][1] = S(n+m-2, n-1, n-1, 0)` (if `m>0`).\n`dp[n][m][0] = C(n+m-1, n) + S(n+m-2, n-1, n-1, 1)` (if `m>0`).\n\nThis identity `sum_{k=0}^{\\lfloor N/2 \\rfloor} C(M-2k, K-2k)` can be computed in `O(1)` using a property of Pascal's triangle.\n`C(N,K) + C(N-2,K-2) + C(N-4,K-4) + ...`\nLet `N_0 = n-1`, `M_0 = m`.\nWe need to sum `C(N_0+M_0-1-k, N_0-k)` for `k` with fixed parity.\nThis is `sum C(X-k, Y-k)`.\nThis sum is equal to `C(X+1, Y) - C(X-k_{max}, Y-k_{max}-1)` for general `k`.\nFor specific parities, it's more complex.\n\nA known identity: `sum_{k=0}^N C(A-k, B) = C(A+1, B+1) - C(A-N, B+1)`. (Hockey stick identity)\nAnother identity: `sum_{k=0}^N C(A-k, A-k-B) = C(A+1, A-B) - C(A-N, A-N-B-1)`.\nThis is `sum_{k=0}^N C(A-k, B)`.\nThis is not what we have.\n\nThe sum `sum_{k=0}^{N} C(R-k, K-k)` is `C(R+1, K) - C(R-N, K-N-1)`.\nThis is `C(R+1, K) - C(R-N, K-N-1)`.\nThis is for all `k`.\nWe need for `k` with a specific parity.\n`S_{even} = C(R,C) + C(R-2,C-2) + ...`\n`S_{odd} = C(R-1,C-1) + C(R-3,C-3) + ...`\nLet `N_terms = floor((n-1)/2) + 1`.\n\n`C(N,K) = C(N-1,K) + C(N-1,K-1)`.\n`C(R,C) = C(R-1,C) + C(R-1,C-1)`.\n`C(R-2,C-2) = C(R-3,C-2) + C(R-3,C-3)`.\n`C(R-4,C-4) = C(R-5,C-4) + C(R-5,C-5)`.\nSumming these:\n`S_{even} = sum C(R-2i-1, C-2i) + sum C(R-2i-1, C-2i-1)`.\nThis does not simplify well.\n\nThe sums `sum_{k \\text{ even}} C(A-k, B-k)` and `sum_{k \\text{ odd}} C(A-k, B-k)` can be calculated using `C(N,K) = C(N-1,K) + C(N-1,K-1)` and `C(N,K) = C(N,N-K)`.\nThis is a standard trick in competitive programming.\n`sum_{k=0}^{\\lfloor N/2 \\rfloor} C(X-2k, Y-2k)` can be computed by `C(X+1, Y) - C(X-1, Y-1)`? No.\nThe identity is `sum_{k=0}^{N} C(R-k, K-k) = C(R+1, K) - C(R-N, K-N-1)`.\nLet `S_0 = sum_{k=0,2,...} C(R-k, C-k)` and `S_1 = sum_{k=1,3,...} C(R-k, C-k)`.\nWe need to sum up to `k_max = n-1`.\n`S_0 + S_1 = sum_{k=0}^{k_max} C(R-k, C-k)`.\n`S_0 - S_1 = sum_{k=0}^{k_max} (-1)^k C(R-k, C-k)`.\nThe second sum `sum (-1)^k C(R-k, C-k)` is usually `C(R-k_max-1, C-k_max)` or similar.\nThis is `C(R,C) - C(R-1,C-1) + C(R-2,C-2) - ...`\nThis sum is `C(R-k_max-1, C-k_max)` if `k_max` is even, and `-C(R-k_max-1, C-k_max)` if `k_max` is odd.\nSo, `S_0 - S_1 = (-1)^{k_max} C(R-k_max-1, C-k_max)`.\nAnd `S_0 + S_1 = C(R+1, C) - C(R-k_max, C-k_max-1)`.\nFrom these two equations, `S_0` and `S_1` can be found.\n`2 S_0 = (S_0+S_1) + (S_0-S_1)`.\n`2 S_1 = (S_0+S_1) - (S_0-S_1)`.\nWe need modular inverse of 2. `(MOD+1)/2`.\n\nLet `R = n+m-2`, `C = n-1`. `k_max = n-1`.\n`SumAll = C(R+1, C) - C(R-(n-1), C-(n-1)-1)`.\n`SumAlt = (-1)^{n-1} C(R-(n-1)-1, C-(n-1))`.\n`SumAll = C(n+m-1, n-1) - C(m-1, -1)`. `C(N,-1)` is `0`.\nSo `SumAll = C(n+m-1, n-1)`.\nThis is correct. This is the total number of strings with `n-1` zeros and `m` ones, which is `C((n-1)+m, n-1)`.\n\n`SumAlt = (-1)^{n-1} C(m-2, 0)`.\n`C(m-2, 0)` is `1` if `m-2 >= 0` (i.e., `m >= 2`), otherwise `0`.\nIf `m=1`, `C(m-2,0) = C(-1,0) = 0`. This is correct.\nIf `m=0`, `C(m-2,0) = C(-2,0) = 0`. This is correct.\n\nSo for `n>0, m>0`:\n`SumAll = C(n+m-1, n-1)`.\n`SumAlt = 0` if `m < 2`.\n`SumAlt = (-1)^{n-1}` if `m >= 2`.\n\nLet `MOD = 1000000007`.\n`inv2 = pow(2, MOD-2, MOD)`.\n\nIf `m < 2`:\n  `SumAlt = 0`.\n  `S_0 = (SumAll * inv2) % MOD`.\n  `S_1 = (SumAll * inv2) % MOD`.\n  Wait, this is if `SumAll` is even.\n  `S_0 = (SumAll + SumAlt) * inv2 % MOD`.\n  `S_1 = (SumAll - SumAlt + MOD) * inv2 % MOD`.\n\nFinal calculation for `n>0, m>0`:\n`val_C_n_m_minus_1_n = C(n+m-1, n)` (strings starting with '1')\n`val_C_n_m_minus_1_n_minus_1 = C(n+m-1, n-1)` (total strings starting with '0')\n\n`sum_all_leading_zeros = val_C_n_m_minus_1_n_minus_1`.\n`sum_alt_leading_zeros = 0`.\nIf `m >= 2`:\n  `sum_alt_leading_zeros = 1` if `(n-1)` is even.\n  `sum_alt_leading_zeros = (MOD - 1) % MOD` if `(n-1)` is odd.\n\n`S0_leading_zeros = (sum_all_leading_zeros + sum_alt_leading_zeros) * inv2 % MOD`.\n`S1_leading_zeros = (sum_all_leading_zeros - sum_alt_leading_zeros + MOD) * inv2 % MOD`.\n\n`S0_leading_zeros` is sum for `k` even (`0, 2, ...`). This is `B_1`.\n`S1_leading_zeros` is sum for `k` odd (`1, 3, ...`). This is `B_0`.\n\nIf `g=0`:\n  `ans = (val_C_n_m_minus_1_n + S1_leading_zeros) % MOD`.\nIf `g=1`:\n  `ans = S0_leading_zeros`.\n\nThis covers `n>0, m>0`.\nThe `m=0` and `n=0` cases are handled separately.\n\nLet's test `n=1, m=1, g=0`.\n`n=1, m=1`.\n`val_C_n_m_minus_1_n = C(1,1) = 1`.\n`val_C_n_m_minus_1_n_minus_1 = C(1,0) = 1`.\n`m=1 < 2`, so `sum_alt_leading_zeros = 0`.\n`sum_all_leading_zeros = 1`.\n`S0_leading_zeros = (1+0)*inv2 = inv2`.\n`S1_leading_zeros = (1-0)*inv2 = inv2`.\n`g=0`: `ans = (1 + inv2) % MOD`. This is wrong. Expected 2.\n\nWhat's wrong with `SumAlt = (-1)^{n-1} C(m-2, 0)`?\nThe identity for `sum_{k=0}^N (-1)^k C(R-k, C-k)` is `(-1)^N C(R-N-1, C-N)`.\nHere `N = k_max = n-1`.\nSo `SumAlt = (-1)^{n-1} C(R-(n-1)-1, C-(n-1)) = (-1)^{n-1} C(n+m-2-(n-1)-1, n-1-(n-1)) = (-1)^{n-1} C(m-2, 0)`.\nThis seems correct.\n\nThe issue might be in the definition of `S0_leading_zeros` and `S1_leading_zeros`.\n`S0_leading_zeros` is `sum_{k=0,2,...}^{n-1} C(n+m-k-2, n-k-1)`.\n`S1_leading_zeros` is `sum_{k=1,3,...}^{n-1} C(n+m-k-2, n-k-1)`.\n\nFor `n=1, m=1`:\n`n-1 = 0`.\n`S0_leading_zeros = sum_{k=0}^{0} C(1+1-k-2, 1-k-1) = C(0,0) = 1`. (This is `0` zeros then `1` at start).\n`S1_leading_zeros = sum_{k=1,3,...}^{0} C(...) = 0`.\nSo for `n=1, m=1`:\n  `g=0`: `ans = (C(1,1) + S1_leading_zeros) = (1 + 0) = 1`. (Still wrong, expected 2).\n\nThe string \"01\" has `k=0` leading zeros, reduces to `1`.\nThe string \"10\" starts with `1`, reduces to `0`.\nFor `n=1, m=1, g=0`: only \"10\" counts. Result should be 1. Not 2.\nExample output `2` for `1 1 0`. Strings `01`, `10`.\n`R(\"01\") = f(0,1) = 0`. This matches `g=0`.\n`R(\"10\") = f(1,0) = 0`. This matches `g=0`.\nSo both count. My analysis for `n=1, m=1` is wrong.\n\nLet's re-verify `R(0...01...)` logic.\n`R(01) = 0`. `k=0` (even). My rule: `R=0` if `k` even. Correct.\n`R(001) = f(0, R(01)) = f(0,0) = 1`. `k=1` (odd). My rule: `R=1` if `k` odd. Correct.\n`R(0001) = f(0, R(001)) = f(0,1) = 0`. `k=2` (even). My rule: `R=0` if `k` even. Correct.\n\nOkay, my `R(0...01...)` rule is correct.\nSo for `n=1, m=1, g=0`:\n  Strings starting with '1': `C(1,1)=1` (\"10\"). Reduces to `0`. Counts.\n  Strings starting with '0': `C(1,0)=1` (\"01\").\n    `k=0` (even). `R(\"01\")=0`. Counts.\nTotal is `1+1=2`. This matches the example!\n\nSo the sums `S0_leading_zeros` and `S1_leading_zeros` are correct.\nFor `n=1, m=1`:\n`S0_leading_zeros = 1` (count for `k` even). This is the string \"01\".\n`S1_leading_zeros = 0` (count for `k` odd). No such strings.\n\nMy code for `S0_leading_zeros` and `S1_leading_zeros` based on `SumAll` and `SumAlt` must be wrong.\n`SumAll = C(n+m-1, n-1)`. This is the total number of strings starting with '0'.\n`S0_leading_zeros` is the count of strings starting with '0' with `k` even.\n`S1_leading_zeros` is the count of strings starting with '0' with `k` odd.\n\nLet's re-evaluate `SumAlt = (-1)^{n-1} C(m-2, 0)`.\nThis sum is `sum_{k=0}^{n-1} (-1)^k C(n+m-k-2, n-k-1)`.\nFor `n=1, m=1`: `n-1=0`. `k_max=0`.\n`SumAlt = (-1)^0 C(1+1-0-2, 1-0-1) = C(0,0) = 1`.\n`SumAll = C(1+1-1, 1-1) = C(1,0) = 1`.\n`S0_leading_zeros = (1+1)*inv2 = 2*inv2 = 1`. (Correct, for `k=0` even, string \"01\")\n`S1_leading_zeros = (1-1+MOD)*inv2 = 0`. (Correct, for `k` odd, no strings)\n\nSo the formulas for `S0_leading_zeros` and `S1_leading_zeros` are correct.\nThe overall logic for `n>0, m>0` is:\nIf `g=0`: `ans = (C(n+m-1, n) + S0_leading_zeros) % MOD`.\n  Wait, `R(0...01...)` is `0` if `k` even. `S0_leading_zeros` is for `k` even.\n  So `S0_leading_zeros` contributes to `g=0`.\n  `ans = (C(n+m-1, n) + S0_leading_zeros) % MOD`.\nIf `g=1`: `ans = S1_leading_zeros`.\n  `R(0...01...)` is `1` if `k` odd. `S1_leading_zeros` is for `k` odd.\n  So `S1_leading_zeros` contributes to `g=1`.\n\nLet's recheck `n=1, m=1, g=0`.\n`C(1,1)=1`. `S0_leading_zeros=1`. `S1_leading_zeros=0`.\n`g=0`: `ans = (C(1,1) + S0_leading_zeros) = (1+1) = 2`. Correct!\n\nLet's recheck `n=2, m=2, g=0`.\n`C(n+m-1, n) = C(3,2) = 3`.\n`n-1=1`. `k_max=1`.\n`R = n+m-2 = 2`. `C = n-1 = 1`.\n`SumAll = C(n+m-1, n-1) = C(3,1) = 3`.\n`SumAlt = (-1)^(n-1) C(m-2,0) = (-1)^1 C(0,0) = -1 * 1 = -1`.\n`S0_leading_zeros = (3 + (-1) + MOD) * inv2 % MOD = 2 * inv2 % MOD = 1`.\n`S1_leading_zeros = (3 - (-1) + MOD) * inv2 % MOD = 4 * inv2 % MOD = 2`.\n`g=0`: `ans = (C(3,2) + S0_leading_zeros) = (3 + 1) = 4`. Correct!\n\nLet's recheck `n=1, m=1, g=1`.\n`C(1,1)=1`. `S0_leading_zeros=1`. `S1_leading_zeros=0`.\n`g=1`: `ans = S1_leading_zeros = 0`. Correct!\n\nThe logic seems solid now.\n\nFinal check on edge cases for `m=0` and `n=0`:\n`n=0`: String is `1...1` (`m` ones).\n  `R(\"1\") = 1`. (`m=1`)\n  `R(\"11\") = 0`. (`m=2`)\n  `R(\"111\") = 0`. (`m=3`)\n  So if `n=0`:\n    `g=0`: 1 if `m >= 2`, 0 if `m=1`.\n    `g=1`: 1 if `m=1`, 0 if `m >= 2`.\n  This is correctly handled.\n\n`m=0`: String is `0...0` (`n` zeros).\n  `R(\"0\") = 0`. (`n=1`)\n  `R(\"00\") = 1`. (`n=2`)\n  `R(\"000\") = 0`. (`n=3`)\n  So if `m=0`:\n    `g=0`: 1 if `n` is odd, 0 if `n` is even.\n    `g=1`: 1 if `n` is even, 0 if `n` is odd.\n  This is correctly handled.\n\nThe solution requires precomputing factorials and inverse factorials up to `n+m`. Max `2*10^5`.\nThen `C(N,K)` is `O(1)`.\nThe main logic is `O(1)`.\nTotal time complexity `O(N+M + log MOD)` for precomputation.\n\n```python\nimport sys\n\nMOD = 1000000007\nMAX_NM = 200005 # Max n+m is 10^5 + 10^5 = 2*10^5\n\nfact = [1] * MAX_NM\ninv_fact = [1] * MAX_NM\n\ndef precompute_factorials():\n    for i in range(1, MAX_NM):\n        fact[i] = (fact[i-1] * i) % MOD\n    \n    inv_fact[MAX_NM - 1] = pow(fact[MAX_NM - 1], MOD - 2, MOD)\n    for i in range(MAX_NM - 2, -1, -1):\n        inv_fact[i] = (inv_fact[i+1] * (i+1)) % MOD\n\ndef nCr_mod_p(n, r):\n    if r < 0 or r > n:\n        return 0\n    num = fact[n]\n    den = (inv_fact[r] * inv_fact[n-r]) % MOD\n    return (num * den) % MOD\n\ndef solve():\n    n, m, g = map(int, sys.stdin.readline().split())\n\n    precompute_factorials()\n    \n    # Handle base cases: n=0 or m=0\n    if n == 0:\n        # String consists only of '1's\n        # R(\"1\") = 1\n        # R(\"11\") = 0\n        # R(\"111\") = 0\n        # ...\n        if g == 0:\n            # Result is 0 if m >= 2\n            print(1 if m >= 2 else 0)\n        else: # g == 1\n            # Result is 1 if m == 1\n            print(1 if m == 1 else 0)\n        return\n    \n    if m == 0:\n        # String consists only of '0's\n        # R(\"0\") = 0\n        # R(\"00\") = 1\n        # R(\"000\") = 0\n        # ...\n        # Result is 0 if n is odd, 1 if n is even\n        if g == 0:\n            print(1 if n % 2 == 1 else 0)\n        else: # g == 1\n            print(1 if n % 2 == 0 else 0)\n        return\n\n    # General case: n > 0 and m > 0\n    ans = 0\n    inv2 = pow(2, MOD - 2, MOD)\n\n    # Strings starting with '1'\n    # These all reduce to 0.\n    # Number of such strings: C(n+m-1, n)\n    count_starts_with_1 = nCr_mod_p(n + m - 1, n)\n\n    # Strings starting with '0'\n    # Let k be the number of leading zeros before the first '1'.\n    # R(0...01...) is 0 if k is even.\n    # R(0...01...) is 1 if k is odd.\n\n    # Total number of strings starting with '0'\n    # This is C(n+m-1, n-1)\n    sum_all_leading_zeros = nCr_mod_p(n + m - 1, n - 1)\n\n    # Calculate sum_alt_leading_zeros = sum_{k=0}^{n-1} (-1)^k C(n+m-k-2, n-k-1)\n    # This sum is (-1)^(n-1) * C(m-2, 0)\n    sum_alt_leading_zeros = 0\n    if m >= 2: # C(m-2, 0) is 1 if m-2 >= 0\n        sum_alt_leading_zeros = 1\n    \n    if (n - 1) % 2 == 1: # If n-1 is odd, multiply by -1\n        sum_alt_leading_zeros = (MOD - sum_alt_leading_zeros) % MOD\n\n    # S0_leading_zeros: sum for k even (0, 2, ...) -> reduces to 0\n    S0_leading_zeros = (sum_all_leading_zeros + sum_alt_leading_zeros) * inv2 % MOD\n\n    # S1_leading_zeros: sum for k odd (1, 3, ...) -> reduces to 1\n    S1_leading_zeros = (sum_all_leading_zeros - sum_alt_leading_zeros + MOD) * inv2 % MOD\n\n    if g == 0:\n        ans = (count_starts_with_1 + S0_leading_zeros) % MOD\n    else: # g == 1\n        ans = S1_leading_zeros\n\n    print(ans)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\nMOD = 1000000007\nMAX_NM = 200005 # Max n+m is 10^5 + 10^5 = 2*10^5\n\nfact = [1] * MAX_NM\ninv_fact = [1] * MAX_NM\n\ndef precompute_factorials():\n    for i in range(1, MAX_NM):\n        fact[i] = (fact[i-1] * i) % MOD\n    \n    inv_fact[MAX_NM - 1] = pow(fact[MAX_NM - 1], MOD - 2, MOD)\n    for i in range(MAX_NM - 2, -1, -1):\n        inv_fact[i] = (inv_fact[i+1] * (i+1)) % MOD\n\ndef nCr_mod_p(n, r):\n    if r < 0 or r > n:\n        return 0\n    num = fact[n]\n    den = (inv_fact[r] * inv_fact[n-r]) % MOD\n    return (num * den) % MOD\n\ndef solve():\n    n, m, g = map(int, sys.stdin.readline().split())\n\n    precompute_factorials()\n    \n    # Handle base cases: n=0 or m=0\n    if n == 0:\n        # String consists only of '1's\n        # R(\"1\") = 1\n        # R(\"11\") = 0\n        # R(\"111\") = 0\n        # ...\n        if g == 0:\n            # Result is 0 if m >= 2\n            print(1 if m >= 2 else 0)\n        else: # g == 1\n            # Result is 1 if m == 1\n            print(1 if m == 1 else 0)\n        return\n    \n    if m == 0:\n        # String consists only of '0's\n        # R(\"0\") = 0\n        # R(\"00\") = 1\n        # R(\"000\") = 0\n        # ...\n        # Result is 0 if n is odd, 1 if n is even\n        if g == 0:\n            print(1 if n % 2 == 1 else 0)\n        else: # g == 1\n            print(1 if n % 2 == 0 else 0)\n        return\n\n    # General case: n > 0 and m > 0\n    ans = 0\n    inv2 = pow(2, MOD - 2, MOD)\n\n    # Strings starting with '1'\n    # These all reduce to 0.\n    # Number of such strings: C(n+m-1, n)\n    count_starts_with_1 = nCr_mod_p(n + m - 1, n)\n\n    # Strings starting with '0'\n    # Let k be the number of leading zeros before the first '1'.\n    # R(0...01...) is 0 if k is even.\n    # R(0...01...) is 1 if k is odd.\n\n    # Total number of strings starting with '0'\n    # This is C(n+m-1, n-1)\n    sum_all_leading_zeros = nCr_mod_p(n + m - 1, n - 1)\n\n    # Calculate sum_alt_leading_zeros = sum_{k=0}^{n-1} (-1)^k C(n+m-k-2, n-k-1)\n    # This sum is (-1)^(n-1) * C(m-2, 0)\n    sum_alt_leading_zeros = 0\n    if m >= 2: # C(m-2, 0) is 1 if m-2 >= 0\n        sum_alt_leading_zeros = 1\n    \n    if (n - 1) % 2 == 1: # If n-1 is odd, multiply by -1\n        sum_alt_leading_zeros = (MOD - sum_alt_leading_zeros) % MOD\n\n    # S0_leading_zeros: sum for k even (0, 2, ...) -> reduces to 0\n    S0_leading_zeros = (sum_all_leading_zeros + sum_alt_leading_zeros) * inv2 % MOD\n\n    # S1_leading_zeros: sum for k odd (1, 3, ...) -> reduces to 1\n    S1_leading_zeros = (sum_all_leading_zeros - sum_alt_leading_zeros + MOD) * inv2 % MOD\n\n    if g == 0:\n        ans = (count_starts_with_1 + S0_leading_zeros) % MOD\n    else: # g == 1\n        ans = S1_leading_zeros\n\n    print(ans)\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 559,
        "completion_token_count": 14960,
        "thoughts_token_count": 6139
    }
}