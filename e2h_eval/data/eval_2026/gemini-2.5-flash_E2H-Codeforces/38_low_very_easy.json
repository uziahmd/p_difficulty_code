{
    "start": 1758284976.2817993,
    "end": 1758285004.1173007,
    "start-formatted": "2025-09-19 21:29 KST",
    "end-formatted": "2025-09-19 21:30 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "**Problem Decomposition and Optimization Strategy**\n\nOkay, so I'm tackling this competitive programming problem. My goal is to figure out two key things: the smallest number of nodes (`n`) needed to construct a \"p-reachable\" directed graph, and then the maximum number of unidirectional pairs in *any* such graph with that minimal `n`.  Let's break down the definitions and then strategize.\n\nFirst, \"reachable from each other\" means nodes are in the same Strongly Connected Component (SCC).  The problem defines \"p-reachable\" as having exactly `p` ordered pairs `(u, v)` where `u < v`, and `u` and `v` are mutually reachable.  Unidirectional pairs are straightforward: a path from `u` to `v`, but no path back from `v` to `u`, with the condition that `u` and `v` are distinct.\n\nWe're dealing with directed graphs, and the `u < v` condition suggests an ordering, so I'll assume nodes are numbered `1` to `n`. Now, for Part 1: minimizing `n`.  If nodes `u` and `v` are in the same SCC of size `S`, that contributes `S * (S - 1) / 2` pairs to the `p`-reachable count.  We can express the total `p`-reachable pairs as `sum(S_i * (S_i - 1) / 2)` where `S_i` is the size of each SCC, and the sum of all `S_i` is our total node count `n`.\n\nThe crucial insight is that minimizing `n` means making these SCCs as *large* as possible.  The function `S * (S - 1) / 2` grows quadratically with `S`, so combining more nodes into larger SCCs will allow us to hit the target `p` with fewer overall nodes. My task now is to find this optimal configuration of SCC sizes, `S_1, S_2, ..., S_k`, such that their respective contribution of pairs sums to `p` and their total sum (the number of nodes) is minimized. I need to figure out how to best \"pack\" nodes into these SCCs to satisfy the given value of `p`.\n",
    "response": "The problem asks us to find two values:\n1. The minimum number of nodes `n` required to create a `p`-reachable directed graph.\n2. The maximum number of unidirectional pairs among all `p`-reachable graphs with this minimum `n`.\n\nLet's break down the definitions and requirements:\n\n**1. `p`-reachable graph:**\nA graph is `p`-reachable if it contains exactly `p` ordered pairs of nodes `(u, v)` such that `u < v` and `u` and `v` are reachable from each other.\nNodes `u` and `v` are reachable from each other if there is a path from `u` to `v` and a path from `v` to `u`. This means `u` and `v` belong to the same Strongly Connected Component (SCC).\nIf an SCC has `S` nodes, any two distinct nodes `x, y` within this SCC are reachable from each other. The number of ordered pairs `(u, v)` with `u < v` from this SCC is `S * (S - 1) / 2`.\nIf a graph has multiple SCCs of sizes `S_1, S_2, ..., S_k`, the total number of such pairs is `sum(S_i * (S_i - 1) / 2)` for `i=1` to `k`.\nThe total number of nodes `n` in the graph is `sum(S_i)`.\nWe want to find the minimum `n` such that `sum(S_i * (S_i - 1) / 2) = p`.\n\nTo minimize `n` for a fixed `p`, we should try to use as few SCCs as possible, and make them as large as possible. This is because the function `f(S) = S * (S - 1) / 2` grows quadratically, so using one large SCC is more \"node-efficient\" for generating pairs than multiple small ones. For example, `f(3) = 3`, `f(2) + f(2) = 1 + 1 = 2` (using 4 nodes for 2 pairs), `f(4) = 6`.\n\nWe can find the largest `S` such that `S * (S - 1) / 2 <= p`. Let this be `S_max`.\nThe remaining `p - S_max * (S_max - 1) / 2` pairs must be formed by additional SCCs.\nThis is a greedy approach. We find the largest `S` such that `S * (S - 1) / 2` does not exceed the remaining `p`. We add `S` to our total `n` and subtract `S * (S - 1) / 2` from `p`. We repeat this until `p` becomes 0.\n\nLet `current_p = p`, `min_n = 0`.\nWhile `current_p > 0`:\n  Find the largest integer `S` such that `S * (S - 1) / 2 <= current_p`.\n  This `S` can be found by solving `S^2 - S - 2*current_p <= 0`. The positive root of `S^2 - S - 2*current_p = 0` is `(1 + sqrt(1 + 8*current_p)) / 2`. So, `S = floor((1 + sqrt(1 + 8*current_p)) / 2)`.\n  Add `S` to `min_n`.\n  Subtract `S * (S - 1) / 2` from `current_p`.\n\nExample: `p = 3`\n1. `current_p = 3`. `S = floor((1 + sqrt(1 + 8*3))/2) = floor((1 + sqrt(25))/2) = floor((1+5)/2) = 3`.\n   `min_n = 3`. `current_p = 3 - (3*2/2) = 0`.\nTotal `min_n = 3`.\n\nExample: `p = 4`\n1. `current_p = 4`. `S = floor((1 + sqrt(1 + 8*4))/2) = floor((1 + sqrt(33))/2) = floor((1+5.74)/2) = 3`.\n   `min_n = 3`. `current_p = 4 - (3*2/2) = 1`.\n2. `current_p = 1`. `S = floor((1 + sqrt(1 + 8*1))/2) = floor((1 + sqrt(9))/2) = floor((1+3)/2) = 2`.\n   `min_n = 3 + 2 = 5`. `current_p = 1 - (2*1/2) = 0`.\nTotal `min_n = 5`.\n\n**2. Maximum number of unidirectional pairs:**\nAn ordered pair `(u, v)` is unidirectional if `u != v`, there's a path from `u` to `v`, and no path from `v` to `u`.\nThis means `u` and `v` are in different SCCs, and there's a path from `u`'s SCC to `v`'s SCC in the condensation graph (DAG of SCCs).\n\nTo maximize unidirectional pairs with `n` nodes, we want to arrange the SCCs (whose sizes sum to `n`) in a linear chain.\nSuppose we have SCCs of sizes `S_1, S_2, ..., S_k` such that `sum(S_i) = n`.\nWe can arrange them in a topological order, say `C_1 -> C_2 -> ... -> C_k`. This means we add edges from every node in `C_i` to every node in `C_{i+1}` (or just one edge from `C_i` to `C_{i+1}` is enough to establish reachability).\nFor any `u` in `C_i` and `v` in `C_j` with `i < j`, there is a path from `u` to `v`. Since they are in different SCCs, there is no path from `v` to `u`.\nThe number of such pairs is `S_i * S_j` for all `i < j`.\nSo, the total number of unidirectional pairs is `sum(S_i * S_j)` for all `1 <= i < j <= k`.\n\nThis sum can be calculated efficiently:\n`(sum(S_i))^2 = sum(S_i^2) + 2 * sum(S_i * S_j)` for `i < j`.\nSo, `sum(S_i * S_j)` for `i < j` is `((sum(S_i))^2 - sum(S_i^2)) / 2`.\nSince `sum(S_i) = n`, this simplifies to `(n^2 - sum(S_i^2)) / 2`.\n\nThe greedy strategy for `min_n` gives us a set of SCC sizes `S_1, S_2, ..., S_k`.\nThese are the sizes that minimize `n`.\nFor these specific `S_i` values, we calculate `max_unidirectional_pairs = (n^2 - sum(S_i^2)) / 2`.\n\nLet's re-run the examples:\n\nExample: `p = 3`\n1. `min_n = 3`. The SCC sizes are `[3]`.\n   `sum(S_i) = 3`. `sum(S_i^2) = 3^2 = 9`.\n   `max_unidirectional_pairs = (3^2 - 9) / 2 = (9 - 9) / 2 = 0`.\nOutput: `3 0`.\n\nExample: `p = 4`\n1. `min_n = 5`. The SCC sizes are `[3, 2]`.\n   `sum(S_i) = 3 + 2 = 5`. `sum(S_i^2) = 3^2 + 2^2 = 9 + 4 = 13`.\n   `max_unidirectional_pairs = (5^2 - 13) / 2 = (25 - 13) / 2 = 12 / 2 = 6`.\nOutput: `5 6`.\n\nExample: `p = 0`\n1. `current_p = 0`. Loop doesn't run.\n   `min_n = 0`. `scc_sizes = []`.\n   `max_unidirectional_pairs = (0^2 - 0) / 2 = 0`.\nOutput: `0 0`.\n\nThe maximum value of `p` is `2 * 10^5`.\n`1 + 8*p` can be up to `1 + 8 * 2 * 10^5 = 1 + 1.6 * 10^6`. `sqrt(1.6 * 10^6)` is about `1265`.\nSo `S` will be around `630`.\nThe number of SCCs `k` will be small. The sum `S_i^2` will be `(630)^2` roughly, which is `396900`.\n`n^2` will be `(min_n)^2`. `min_n` can be up to `p` if `p` is formed by `p` SCCs of size `2`.\nFor `p = 2 * 10^5`, `S` is about `632`. `f(632) = 632 * 631 / 2 = 199396`.\n`p_rem = 200000 - 199396 = 604`.\nNext `S` for `p_rem = 604` is `floor((1 + sqrt(1 + 8*604))/2) = floor((1 + sqrt(4833))/2) = floor((1 + 69.5)/2) = 35`.\n`f(35) = 35 * 34 / 2 = 595`.\n`p_rem = 604 - 595 = 9`.\nNext `S` for `p_rem = 9` is `floor((1 + sqrt(1 + 8*9))/2) = floor((1 + sqrt(73))/2) = floor((1 + 8.54)/2) = 4`.\n`f(4) = 4 * 3 / 2 = 6`.\n`p_rem = 9 - 6 = 3`.\nNext `S` for `p_rem = 3` is `floor((1 + sqrt(1 + 8*3))/2) = 3`.\n`f(3) = 3`.\n`p_rem = 3 - 3 = 0`.\nSo for `p = 200000`, SCC sizes are `[632, 35, 4, 3]`.\n`min_n = 632 + 35 + 4 + 3 = 674`.\n`sum(S_i^2) = 632^2 + 35^2 + 4^2 + 3^2 = 399424 + 1225 + 16 + 9 = 400674`.\n`max_unidirectional_pairs = (674^2 - 400674) / 2 = (454276 - 400674) / 2 = 53602 / 2 = 26801`.\nAll calculations fit in standard integer types.\n\nThis approach seems correct and efficient enough.\n\n```python\nimport math\n\ndef solve():\n    p = int(input())\n\n    if p == 0:\n        print(0, 0)\n        return\n\n    min_n = 0\n    sum_s_squared = 0\n    \n    current_p = p\n    \n    # Calculate min_n and sum_s_squared using the greedy approach\n    while current_p > 0:\n        # Find the largest S such that S * (S - 1) / 2 <= current_p\n        # S^2 - S - 2*current_p <= 0\n        # Roots of S^2 - S - 2*current_p = 0 are (1 +/- sqrt(1 + 8*current_p)) / 2\n        # We need the positive root, so S = floor((1 + sqrt(1 + 8*current_p)) / 2)\n        \n        # Using integer square root might be slightly safer or faster\n        # For p up to 2e5, 1+8p up to 1.6e6, sqrt is up to ~1265.\n        # math.isqrt is available in Python 3.8+\n        # If not available, math.floor(math.sqrt(...)) is fine.\n        \n        # Calculate S\n        discriminant = 1 + 8 * current_p\n        s_float = (1 + math.sqrt(discriminant)) / 2\n        s = int(s_float)\n        \n        # Ensure s * (s-1) / 2 does not exceed current_p due to float precision issues\n        # Or, if s is too small, it means s_float was very close to s+1 and int() truncated.\n        # It's better to check s and s+1.\n        # The formula s = int((1 + math.sqrt(1 + 8*current_p)) / 2) usually works.\n        # Let's verify s:\n        while s * (s - 1) // 2 > current_p:\n            s -= 1\n        while (s + 1) * s // 2 <= current_p: # Check if s+1 is also valid\n            s += 1\n        \n        # After the while loops, s should be the largest integer such that s*(s-1)//2 <= current_p\n        # The previous s = int(s_float) might be off by 1 due to floating point precision.\n        # A simpler way to correct s:\n        # s_candidate = int((1 + math.sqrt(discriminant)) / 2)\n        # s = s_candidate\n        # if s * (s - 1) // 2 > current_p:\n        #     s -= 1\n        # elif (s + 1) * s // 2 <= current_p:\n        #     s += 1\n\n        # The initial calculation `s = int(s_float)` might be off by 1.\n        # For example, if `s_float` is `3.9999999999999996`, `int(s_float)` gives `3`.\n        # If `s_float` is `4.0000000000000001`, `int(s_float)` gives `4`.\n        # The `s` we want is `floor((1 + sqrt(1 + 8*current_p)) / 2)`.\n        # `int(math.sqrt(X))` is `floor(sqrt(X))`.\n        # So `s = int((1 + math.isqrt(1 + 8*current_p)) / 2)` if `isqrt` is available.\n        # Otherwise, `s = int((1 + math.floor(math.sqrt(1 + 8*current_p))) / 2)` is more robust.\n        \n        s = int((1 + math.floor(math.sqrt(1 + 8 * current_p))) / 2)\n\n        # It's possible that due to floor on sqrt, `s` might be slightly less than optimal.\n        # Let's check `s+1` as well.\n        if (s + 1) * s // 2 <= current_p:\n            s += 1\n        \n        # Now s is guaranteed to be the largest integer such that s*(s-1)//2 <= current_p\n        \n        min_n += s\n        sum_s_squared += s * s\n        current_p -= s * (s - 1) // 2\n\n    # Calculate max_unidirectional_pairs\n    max_unidirectional_pairs = (min_n * min_n - sum_s_squared) // 2\n\n    print(min_n, max_unidirectional_pairs)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef solve():\n    p = int(input())\n\n    if p == 0:\n        print(0, 0)\n        return\n\n    min_n = 0\n    sum_s_squared = 0\n    \n    current_p = p\n    \n    # Calculate min_n and sum_s_squared using the greedy approach\n    while current_p > 0:\n        # Find the largest S such that S * (S - 1) / 2 <= current_p\n        # S^2 - S - 2*current_p <= 0\n        # Roots of S^2 - S - 2*current_p = 0 are (1 +/- sqrt(1 + 8*current_p)) / 2\n        # We need the positive root, so S = floor((1 + sqrt(1 + 8*current_p)) / 2)\n        \n        # Using integer square root might be slightly safer or faster\n        # For p up to 2e5, 1+8p up to 1.6e6, sqrt is up to ~1265.\n        # math.isqrt is available in Python 3.8+\n        # If not available, math.floor(math.sqrt(...)) is fine.\n        \n        # Calculate S\n        discriminant = 1 + 8 * current_p\n        s_float = (1 + math.sqrt(discriminant)) / 2\n        s = int(s_float)\n        \n        # Ensure s * (s-1) / 2 does not exceed current_p due to float precision issues\n        # Or, if s is too small, it means s_float was very close to s+1 and int() truncated.\n        # It's better to check s and s+1.\n        # The formula s = int((1 + math.sqrt(1 + 8*current_p)) / 2) usually works.\n        # Let's verify s:\n        while s * (s - 1) // 2 > current_p:\n            s -= 1\n        while (s + 1) * s // 2 <= current_p: # Check if s+1 is also valid\n            s += 1\n        \n        # After the while loops, s should be the largest integer such that s*(s-1)//2 <= current_p\n        # The previous s = int(s_float) might be off by 1 due to floating point precision.\n        # A simpler way to correct s:\n        # s_candidate = int((1 + math.sqrt(discriminant)) / 2)\n        # s = s_candidate\n        # if s * (s - 1) // 2 > current_p:\n        #     s -= 1\n        # elif (s + 1) * s // 2 <= current_p:\n        #     s += 1\n\n        # The initial calculation `s = int(s_float)` might be off by 1.\n        # For example, if `s_float` is `3.9999999999999996`, `int(s_float)` gives `3`.\n        # If `s_float` is `4.0000000000000001`, `int(s_float)` gives `4`.\n        # The `s` we want is `floor((1 + sqrt(1 + 8*current_p)) / 2)`.\n        # `int(math.sqrt(X))` is `floor(sqrt(X))`.\n        # So `s = int((1 + math.isqrt(1 + 8*current_p)) / 2)` if `isqrt` is available.\n        # Otherwise, `s = int((1 + math.floor(math.sqrt(1 + 8*current_p))) / 2)` is more robust.\n        \n        s = int((1 + math.floor(math.sqrt(1 + 8 * current_p))) / 2)\n\n        # It's possible that due to floor on sqrt, `s` might be slightly less than optimal.\n        # Let's check `s+1` as well.\n        if (s + 1) * s // 2 <= current_p:\n            s += 1\n        \n        # Now s is guaranteed to be the largest integer such that s*(s-1)//2 <= current_p\n        \n        min_n += s\n        sum_s_squared += s * s\n        current_p -= s * (s - 1) // 2\n\n    # Calculate max_unidirectional_pairs\n    max_unidirectional_pairs = (min_n * min_n - sum_s_squared) // 2\n\n    print(min_n, max_unidirectional_pairs)\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 483,
        "completion_token_count": 3827,
        "thoughts_token_count": 729
    }
}