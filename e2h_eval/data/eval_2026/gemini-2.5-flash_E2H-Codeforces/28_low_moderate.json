{
    "start": 1758285032.9065802,
    "end": 1758285137.8166409,
    "start-formatted": "2025-09-19 21:30 KST",
    "end-formatted": "2025-09-19 21:32 KST",
    "gpu": 2,
    "pid": 28,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vasily the Bear and Beautiful Strings\n\nVasily the Bear loves beautiful strings. String s is beautiful if it meets the following criteria:   String s only consists of characters 0 and 1, at that character 0 must occur in string s exactly n times, and character 1 must occur exactly m times.  We can obtain character g from string s with some (possibly, zero) number of modifications. The character g equals either zero or one. A modification of string with length at least two is the following operation: we replace two last characters from the string by exactly one other character. This character equals one if it replaces two zeros, otherwise it equals zero. For example, one modification transforms string \"01010\" into string \"0100\", two modifications transform it to \"011\". It is forbidden to modify a string with length less than two.Help the Bear, count the number of beautiful strings. As the number of beautiful strings can be rather large, print the remainder after dividing the number by 1000000007 (109 + 7). \n\n## Input\nThe first line of the input contains three space-separated integers n, m, g (0 ≤ n, m ≤ 105, n + m ≥ 1, 0 ≤ g ≤ 1).\n\n## Output\nPrint a single integer — the answer to the problem modulo 1000000007 (109 + 7).\n\n## Example\n### Input\n['1 1 0', '2 2 0', '1 1 1']\n\n### Output\n['2', '4', '0']\n\n## Note\nIn the first sample the beautiful strings are: \"01\", \"10\".In the second sample the beautiful strings are: \"0011\", \"1001\", \"1010\", \"1100\".In the third sample there are no beautiful strings.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "**Understanding the Beautiful String Problem**\n\nOkay, so I'm tackling this competitive programming problem, and it boils down to counting \"beautiful strings.\" The constraints are clear: I'm given `n` zeros, `m` ones, and a target character `g`. A string is \"beautiful\" if it's made up of exactly `n` zeros and `m` ones, and after a specific reduction process, it collapses down to the single character `g`.\n\nThe core of the problem is this reduction operation: I can take the last two characters of a string and replace them with a single character. The rule is, if I have two zeros, they become a one; otherwise, it's a zero.  It's like a cascading reduction.\n\nMy first thought is, this operation seems to be acting from right to left, iteratively merging characters. I need to figure out what this operation does, which I'll denote as `op(c1, c2)` for two characters. I've broken down the cases: `op('0', '0') = '1'`, `op('0', '1') = '0'`, `op('1', '0') = '0'`, `op('1', '1') = '0'`.  It reminds me a bit of XOR, except for the `0, 0` case.\n\nThen, I started considering these characters as integers (0 and 1).  After working through the cases, I realized it's actually the logical NOT of the OR operation: `NOT (x OR y)`.  I can test this out, and indeed, it fits perfectly. This looks promising.\n\nNow, if I let the input string be `s = s_0 s_1 ... s_{L-1}`.  The first modification replaces the last two chars, `s_{L-2}s_{L-1}`, with `c_1 = NOT (s_{L-2} OR s_{L-1})`. Then I repeat this, `c_2 = NOT (s_{L-3} OR c_1)`, and so on until I get a single character, the final result.\n\nThe challenge now is how to efficiently count strings that, after this operation, result in my target, `g`.  It looks like this `NOT (x OR y)` operation will play a central role, so I should be able to optimize it in my code.\n",
    "response": "The problem asks us to count the number of binary strings with `n` zeros and `m` ones such that applying a specific modification operation repeatedly results in a single character `g`. The modification operation replaces the two last characters `c_1 c_2` with a new character `c_new`. `c_new` is '1' if `c_1 c_2` is \"00\", and '0' otherwise (\"01\", \"10\", \"11\").\n\nLet's analyze the modification operation. If we treat '0' as 0 and '1' as 1:\n- `op(0, 0) = 1`\n- `op(0, 1) = 0`\n- `op(1, 0) = 0`\n- `op(1, 1) = 0`\n\nThis operation is equivalent to `NOT (c_1 OR c_2)`.\nLet `s = s_0 s_1 ... s_{L-1}` be the string. The operation processes characters from right to left.\nThe final character `R` is obtained by `R = NOT(s_0 OR NOT(s_1 OR NOT(... OR NOT(s_{L-2} OR s_{L-1})...)))`.\n\nConsider the effect of the operation on the sum of characters modulo 2.\nLet `val(c)` be 0 if `c` is '0', and 1 if `c` is '1'.\n`val(op(c_1, c_2))` is 1 if `c_1=0, c_2=0`, and 0 otherwise.\nThis is equivalent to `(val(c_1) + val(c_2) + 1) mod 2` if we consider `op(0,0)=1`, `op(0,1)=0`, `op(1,0)=0`, `op(1,1)=0`.\nLet's check:\n`val(0)+val(0)+1 = 0+0+1 = 1 mod 2` (Correct: op(0,0)=1)\n`val(0)+val(1)+1 = 0+1+1 = 0 mod 2` (Correct: op(0,1)=0)\n`val(1)+val(0)+1 = 1+0+1 = 0 mod 2` (Correct: op(1,0)=0)\n`val(1)+val(1)+1 = 1+1+1 = 1 mod 2` (Incorrect: op(1,1)=0, but this gives 1)\n\nSo, this `(sum+1) mod 2` rule is not quite right.\nLet's use the `NOT (c_1 OR c_2)` rule.\nThe final character `R` can be simplified based on the number of '1's in the string.\nIf a string contains at least one '1', say `s_k = '1'`, then `s_k OR s_{k+1}` will be '1' regardless of `s_{k+1}`.\nThen `NOT (s_k OR s_{k+1})` will be '0'.\nThis '0' will propagate to the left. `s_{k-1} OR '0'` will be `s_{k-1}`.\nThen `NOT (s_{k-1} OR '0')` will be `NOT (s_{k-1})`.\nEssentially, once a '1' is encountered, the operation becomes `NOT(c_prev OR 1) = NOT(1) = 0`. This '0' then propagates.\nIf `s_k = '1'`, then the operation will result in `NOT(s_{k-1} OR NOT(s_k OR ...))`.\nIf there is at least one '1' in the string:\nThe rightmost '1' will eventually be part of an `(X OR 1)` operation, which yields 1. The `NOT` of this is 0. This '0' then propagates left.\nSo, if `m > 0` (there is at least one '1' in the string), the final character `R` will be '0'.\nThis is because `NOT (X OR Y)` is '0' if `X` or `Y` is '1'. If there's any '1' in the string, it will eventually participate in an `OR` operation, making its result '1', and the subsequent `NOT` will make it '0'. This '0' will then propagate leftwards.\nExample: \"01010\" -> \"0100\" -> \"011\" -> \"00\" -> \"1\". My previous analysis was slightly off.\n\nLet's re-evaluate the operation `NOT(c_1 OR c_2)`:\n`f(s_0 s_1 ... s_{L-1}) = NOT(s_0 OR NOT(s_1 OR NOT(... OR NOT(s_{L-2} OR s_{L-1})...)))`\nThis is equivalent to `s_0 XOR s_1 XOR ... XOR s_{L-1}` if we interpret `NOT(A OR B)` as `A XOR B` when `A, B` are bits.\nLet's check this:\n`0 XOR 0 = 0` (but `op(0,0)=1`)\n`0 XOR 1 = 1` (but `op(0,1)=0`)\n`1 XOR 0 = 1` (but `op(1,0)=0`)\n`1 XOR 1 = 0` (but `op(1,1)=0`)\nThis is not XOR.\n\nLet's use the example from the problem: \"01010\"\nLength 5.\n\"01010\" -> `op('1','0')` is '0'. String becomes \"0100\".\n\"0100\" -> `op('0','0')` is '1'. String becomes \"011\".\n\"011\" -> `op('1','1')` is '0'. String becomes \"00\".\n\"00\" -> `op('0','0')` is '1'. String becomes \"1\".\nSo, `f(\"01010\") = '1'`.\n\nThis operation can be interpreted as:\n`op(x, y) = 1 - (x OR y)` (where x, y are 0 or 1).\nLet `R(s_0 ... s_{k-1})` be the result of reducing a string `s_0 ... s_{k-1}`.\n`R(s_0 ... s_{k-1}) = 1 - (s_0 OR R(s_1 ... s_{k-1}))`. This is not correct because the operation works from right to left.\n`R(s_0 ... s_{L-1}) = R(s_0 ... s_{L-3} (1 - (s_{L-2} OR s_{L-1})))`.\nLet `v_k` be the value of the `k`-th character from the right (0-indexed). So `v_0 = s_{L-1}`, `v_1 = s_{L-2}`, etc.\nThe final result is `R = 1 - (v_{L-1} OR (1 - (v_{L-2} OR (1 - (... OR (1 - (v_1 OR v_0))...))))))`.\nThis is a nested structure.\n\nLet's look at parity of ones.\nIf `m=0`, the string is \"00...0\" (`n` zeros).\n`op(0,0) = 1`.\n`op(X,1) = 0`.\n`op(X,0) = NOT X`.\n\"00...0\" (length `k`)\n\"00\" -> \"1\"\n\"000\" -> \"01\" -> \"0\"\n\"0000\" -> \"001\" -> \"00\" -> \"1\"\n\"00000\" -> \"0001\" -> \"000\" -> \"01\" -> \"0\"\nPattern for `n` zeros:\n`n=1`: \"0\" -> \"0\" (no modification possible)\n`n=2`: \"00\" -> \"1\"\n`n=3`: \"000\" -> \"0\"\n`n=4`: \"0000\" -> \"1\"\n`n=5`: \"00000\" -> \"0\"\nFor `m=0`, the result is '0' if `n` is odd, and '1' if `n` is even and `n >= 2`.\nIf `n=1, m=0`, string is \"0\", result is '0'.\nIf `n=0, m=1`, string is \"1\", result is '1'.\n\nCase 1: `m = 0` (string consists only of '0's)\n- If `n = 0`, `m = 0`, then `n+m=0`, but problem states `n+m >= 1`. So this case is impossible.\n- If `n = 1`, string is \"0\". Result is '0'.\n- If `n >= 2`, string is \"0...0\".\n  - If `n` is odd, result is '0'.\n  - If `n` is even, result is '1'.\nSo, if `m=0`, the target `g` must be `(n%2 == 0 && n>=2) ? 1 : 0`.\nIf `g` matches this, there is 1 such string (\"0...0\"). Otherwise, 0 strings.\n\nCase 2: `m > 0` (string contains at least one '1')\nLet `s = s_0 s_1 ... s_{L-1}` be the string.\nIf `L=1`, then `s_0` is the result. This means `n=0, m=1` (string \"1\") or `n=1, m=0` (string \"0\"). These are handled by Case 1.\nIf `L > 1`:\nThe final character `R` depends on the parity of `m` (number of ones).\nIf `m` is odd, `R = '0'`.\nIf `m` is even, `R = '1'`.\nLet's test this hypothesis.\n\"01010\" (`n=3, m=2`, `m` is even) -> Result '1'. Matches hypothesis.\n\"01\" (`n=1, m=1`, `m` is odd) -> `op('0','1')` is '0'. Result '0'. Matches hypothesis.\n\"10\" (`n=1, m=1`, `m` is odd) -> `op('1','0')` is '0'. Result '0'. Matches hypothesis.\n\"0011\" (`n=2, m=2`, `m` is even) -> `op('1','1')` is '0'. \"0010\" -> `op('1','0')` is '0'. \"000\" -> `op('0','0')` is '1'. \"01\" -> `op('0','1')` is '0'. Result '0'.\nThis contradicts the hypothesis `m` even implies `R='1'`.\nThe example output for `n=2, m=2, g=0` is 4. This means \"0011\", \"1001\", \"1010\", \"1100\" all reduce to '0'.\nMy hypothesis is wrong.\n\nLet's re-examine the operation `op(c1, c2) = 1 - (c1 OR c2)`.\nThe final character is `R = s_0 \\text{ op } s_1 \\text{ op } ... \\text{ op } s_{L-1}` where `op` is right associative.\n`R = s_0 \\text{ op } (s_1 \\text{ op } (... \\text{ op } (s_{L-2} \\text{ op } s_{L-1})...))`\nLet `x_i` be the integer value of `s_i`.\n`R = x_0 \\text{ op } (x_1 \\text{ op } (... \\text{ op } (x_{L-2} \\text{ op } x_{L-1})...))`\nLet `f(a, b) = 1 - (a OR b)`.\n`R = f(x_0, f(x_1, f(... f(x_{L-2}, x_{L-1})...)))`\n\nConsider the value of `R` based on the leftmost character `s_0`.\nIf `s_0 = '1'`, then `R = f(1, X) = 1 - (1 OR X) = 1 - 1 = 0`.\nSo, if `s_0 = '1'`, the result is always '0'.\nThis implies that if `g = '1'`, the string must start with '0'.\nIf `g = '0'`, the string can start with '0' or '1'.\n\nThis is a very strong simplification!\nIf `s_0 = '1'` (i.e., the string starts with '1'), then `R = '0'`.\nThis means any string starting with '1' will reduce to '0'.\nNumber of such strings: `C(n+m-1, n)` (choose positions for `n` zeros in `n+m-1` remaining spots, as `s_0` is fixed as '1').\n\nNow consider strings starting with `s_0 = '0'`.\n`R = f(0, X) = 1 - (0 OR X) = 1 - X`.\nSo, if `s_0 = '0'`, the result `R` is `1 - R'`, where `R'` is the result of reducing the suffix `s_1 ... s_{L-1}`.\nThis means `R` is '0' if `R'` is '1', and `R` is '1' if `R'` is '0'.\nEffectively, if `s_0 = '0'`, the final character is flipped compared to the result of `s_1 ... s_{L-1}`.\n\nLet `res(n, m)` be the result of reducing a string with `n` zeros and `m` ones.\nLet `L = n+m`.\nIf `L=1`:\n  - `n=1, m=0` (\"0\") -> '0'\n  - `n=0, m=1` (\"1\") -> '1'\n\nIf `L > 1`:\n  - If string starts with '1': `s_0 = '1'`. `n` zeros, `m-1` ones remain. Result is '0'.\n  - If string starts with '0': `s_0 = '0'`. `n-1` zeros, `m` ones remain. Result is `1 - res(n-1, m)` (where `res(n-1, m)` is the result of reducing the suffix).\n\nLet `f_N(n, m)` be the final character for a string of `n` zeros and `m` ones, where `N` is the first char.\n`f_1(n, m) = 0` (for `m > 0`)\n`f_0(n, m) = 1 - f_?(n-1, m)` (where `f_?(n-1, m)` is the final character for a string of `n-1` zeros and `m` ones, but we don't know its first character).\n\nThis means the final character only depends on the *first character* of the string and the *total length*.\nLet's trace `f(\"01010\")` from `n=3, m=2`.\n`s_0 = '0'`. So result is `1 - R(\"1010\")`.\n`R(\"1010\")`: starts with '1'. So result is '0'.\nThus `f(\"01010\") = 1 - 0 = 1`. This matches the example!\n\nLet's re-trace \"0011\" (`n=2, m=2`).\n`s_0 = '0'`. Result is `1 - R(\"011\")`.\n`R(\"011\")`: starts with '0'. Result is `1 - R(\"11\")`.\n`R(\"11\")`: starts with '1'. Result is '0'.\nSo `R(\"011\") = 1 - 0 = 1`.\nThen `f(\"0011\") = 1 - 1 = 0`. This also matches the example!\n\nThis implies:\nThe final character `g_final` for a string `s` is:\n- If `s_0 = '1'` (and `m > 0`): `g_final = '0'`.\n- If `s_0 = '0'` (and `n > 0`): `g_final = '1'` if `L-1` is length of suffix `s_1...s_{L-1}` and `(L-1)` reduces to '0'. `g_final = '0'` if `(L-1)` reduces to '1'.\n  Effectively, `g_final = NOT(reduce(s_1...s_{L-1}))`.\n\nLet `R(k)` be the result of reducing a string of length `k` consisting only of '0's.\n`R(1) = '0'`\n`R(2) = '1'`\n`R(3) = '0'`\n`R(4) = '1'`\nSo `R(k) = '0'` if `k` is odd, `R(k) = '1'` if `k` is even and `k>=2`.\n\nLet `res(len)` be the final character if the string has length `len` and starts with '0', and all other characters are '0's.\nThis is exactly `R(len)` as defined above.\nThe sequence of results for `0...0` strings is `0, 1, 0, 1, ...` starting from length 1.\nSo, `R(k) = (k % 2 == 1) ? '0' : '1'` for `k >= 1`. (This is for `k=1` it's '0', `k=2` it's '1', etc.)\n\nNow, let `f(N_0, M_1)` be the final character for a string containing `N_0` zeros and `M_1` ones.\nLet `L = N_0 + M_1`.\nIf `L=0`, impossible.\nIf `L=1`:\n  - `N_0=1, M_1=0`: \"0\" -> '0'.\n  - `N_0=0, M_1=1`: \"1\" -> '1'.\n\nIf `L > 1`:\n  - If the string starts with '1' (`s_0 = '1'`): `f(N_0, M_1) = '0'`. (Requires `M_1 > 0`).\n  - If the string starts with '0' (`s_0 = '0'`): `f(N_0, M_1) = NOT(f(N_0-1, M_1))` (where `f(N_0-1, M_1)` is the result of reducing the suffix `s_1...s_{L-1}`). (Requires `N_0 > 0`).\n\nThis recursive definition means the final character depends on the *first character* and the *total length* `L`.\nLet `G(L)` be the final character if the string has length `L` and `s_0 = '0'`, and `G_1(L)` if `s_0 = '1'`.\n`G_1(L) = '0'` for `L > 0` (as long as `m > 0`).\n`G(L) = NOT(G_?(L-1))`.\nThis is exactly the `R(k)` sequence we found for all '0' strings.\n`G(L) = '0'` if `L` is odd, `G(L) = '1'` if `L` is even and `L>=2`.\nThis means if `s_0 = '0'`, the result is '0' if `L` is odd, '1' if `L` is even (and `L>=2`).\nThis holds for any string, not just all '0's, because the structure of `NOT(s_0 OR X)` is what matters.\n`X` is the result of reducing the suffix. If `X` is '0', `NOT(0 OR 0) = 1`. If `X` is '1', `NOT(0 OR 1) = 0`.\nSo `G(L) = 1 - X`.\n\nLet's consolidate the final character `g_final`:\n1. If `m = 0` (all zeros): String is \"0...0\" of length `n`.\n   - If `n = 1`: \"0\" -> '0'.\n   - If `n >= 2`: `n` even -> '1', `n` odd -> '0'.\n   This can be summarized as `g_final = '0'` if `n` is odd, `g_final = '1'` if `n` is even and `n>=2`.\n\n2. If `m > 0` (at least one '1'):\n   - If string starts with '1' (`s_0 = '1'`): `g_final = '0'`. (Because `f(1, X) = 1 - (1 OR X) = 0`).\n   - If string starts with '0' (`s_0 = '0'`): `g_final = NOT(reduce(s_1...s_{L-1}))`.\n     Let `L = n+m`.\n     The result `g_final` for a string `s_0...s_{L-1}` is '0' if `L` is odd, and '1' if `L` is even and `L>=2`.\n     This is based on the logic that `f(0, X) = 1 - X`, and `f(1, X) = 0`.\n     If `s_0 = '1'`, then `g_final = '0'`.\n     If `s_0 = '0'`, then `g_final = NOT(f(s_1...s_{L-1}))`.\n     This `NOT` operation effectively flips the final result for each leading '0'.\n     So, the final result `g_final` depends on the initial `s_0` and the length `L`.\n     If `s_0 = '1'`, `g_final = '0'`.\n     If `s_0 = '0'`: `g_final = '0'` if `L` is odd, `g_final = '1'` if `L` is even and `L>=2`.\n     This is the same as the all-zeros case.\n\nSo the rule is:\n- If `m = 0`:\n  - `g_final = '0'` if `n` is odd.\n  - `g_final = '1'` if `n` is even and `n >= 2`.\n- If `m > 0`:\n  - If `s_0 = '1'`: `g_final = '0'`.\n  - If `s_0 = '0'`:\n    - `g_final = '0'` if `L = n+m` is odd.\n    - `g_final = '1'` if `L = n+m` is even and `L >= 2`.\n\nLet's check the examples with this rule:\n1. `n=1, m=1, g=0`. `L=2`. `m>0`.\n   - Strings starting with '1': \"10\". `s_0='1'`. `g_final='0'`. This string is counted.\n   - Strings starting with '0': \"01\". `s_0='0'`. `L=2` (even). `g_final='1'`. This string is NOT counted for `g=0`.\n   Total count: 1. Example output is 2. My rule is still wrong.\n\nThe critical insight must be about the parity of `m`.\nThe problem states: \"The character equals one if it replaces two zeros, otherwise it equals zero.\"\n`00 -> 1`\n`01 -> 0`\n`10 -> 0`\n`11 -> 0`\n\nThis is `(c1==0 && c2==0)`.\nLet `s = s_0 s_1 ... s_{L-1}`.\nThe operation is `R_k = f(s_{k-1}, R_{k+1})` where `R_L = s_{L-1}`.\nNo, it's `R_k = f(s_{k-1}, R_k')` where `R_k'` is the result of reducing `s_k ... s_{L-1}`.\nThis is exactly the right-associative interpretation.\nSo `R = s_0 \\text{ op } (s_1 \\text{ op } (... \\text{ op } (s_{L-2} \\text{ op } s_{L-1})...))`\nLet `val(c)` be 0 for '0' and 1 for '1'.\n`val(op(c1, c2)) = 1` if `c1=0, c2=0`. `0` otherwise.\nThis is `(1-val(c1))*(1-val(c2))`. No, this is `(1-c1)*(1-c2)` for `c1, c2` as 0/1. If `c1=0, c2=0`, result is `1*1=1`. If `c1=0, c2=1`, result is `1*0=0`. If `c1=1, c2=0`, result is `0*1=0`. If `c1=1, c2=1`, result is `0*0=0`.\nThis is exactly the behavior!\nSo `op(x,y) = (1-x)(1-y)`.\nLet `R(s)` be the final character.\n`R(s_0 ... s_{L-1}) = (1-s_0)(1-R(s_1 ... s_{L-1}))`.\nBase cases: `R(\"0\") = 0`, `R(\"1\") = 1`.\n\nLet's re-evaluate `n=1, m=1, g=0`. `L=2`.\n\"01\": `R(\"01\") = (1-0)(1-R(\"1\")) = 1 * (1-1) = 0`. This string gives '0'.\n\"10\": `R(\"10\") = (1-1)(1-R(\"0\")) = 0 * (1-0) = 0`. This string gives '0'.\nBoth strings \"01\" and \"10\" reduce to '0'. So for `g=0`, count is 2. This matches example 1!\n\nLet's re-evaluate `n=2, m=2, g=0`. `L=4`.\nStrings: \"0011\", \"0101\", \"0110\", \"1001\", \"1010\", \"1100\". Total `C(4,2)=6` strings.\n`R(\"0011\") = (1-0)(1-R(\"011\")) = 1 - R(\"011\")`.\n  `R(\"011\") = (1-0)(1-R(\"11\")) = 1 - R(\"11\")`.\n    `R(\"11\") = (1-1)(1-R(\"1\")) = 0 * (1-1) = 0`.\n  So `R(\"011\") = 1 - 0 = 1`.\nThus `R(\"0011\") = 1 - 1 = 0`. This string gives '0'.\n\n`R(\"0101\") = (1-0)(1-R(\"101\")) = 1 - R(\"101\")`.\n  `R(\"101\") = (1-1)(1-R(\"01\")) = 0 * (1-R(\"01\")) = 0`.\nThus `R(\"0101\") = 1 - 0 = 1`. This string gives '1'.\n\n`R(\"0110\") = (1-0)(1-R(\"110\")) = 1 - R(\"110\")`.\n  `R(\"110\") = (1-1)(1-R(\"10\")) = 0 * (1-R(\"10\")) = 0`.\nThus `R(\"0110\") = 1 - 0 = 1`. This string gives '1'.\n\n`R(\"1001\") = (1-1)(1-R(\"001\")) = 0`. This string gives '0'.\n`R(\"1010\") = (1-1)(1-R(\"010\")) = 0`. This string gives '0'.\n`R(\"1100\") = (1-1)(1-R(\"100\")) = 0`. This string gives '0'.\n\nStrings reducing to '0': \"0011\", \"1001\", \"1010\", \"1100\". Count is 4. This matches example 2!\n\nThis formula `R(s_0 ... s_{L-1}) = (1-s_0)(1-R(s_1 ... s_{L-1}))` is correct.\nLet `R_k` denote `R(s_k ... s_{L-1})`.\n`R_k = (1-s_k)(1-R_{k+1})`.\nThe final result is `R_0`.\n`R_0 = (1-s_0)(1-R_1) = (1-s_0)(1-(1-s_1)(1-R_2)) = (1-s_0)(1-(1-s_1)(1-(1-s_2)(1-R_3))) ...`\nThis is a nested expression.\nNotice that if any `s_k = 1`, then `(1-s_k)` becomes `0`.\nIf `(1-s_k)` becomes `0`, then `R_k = 0`.\nThis `R_k = 0` value propagates to the left.\n`R_{k-1} = (1-s_{k-1})(1-R_k) = (1-s_{k-1})(1-0) = 1-s_{k-1}`.\n`R_{k-2} = (1-s_{k-2})(1-R_{k-1}) = (1-s_{k-2})(1-(1-s_{k-1})) = (1-s_{k-2})s_{k-1}`.\n`R_{k-3} = (1-s_{k-3})(1-R_{k-2}) = (1-s_{k-3})(1-(1-s_{k-2})s_{k-1})`.\n\nThis pattern is complex. Let's look at the result `R_0` based on the number of '1's.\nIf `m=0`, string is \"0...0\" (`n` zeros).\n`R_0 = (1-0)(1-R_1) = 1-R_1`.\n`R_1 = (1-0)(1-R_2) = 1-R_2`.\n...\n`R_{n-1} = (1-0)(1-R_n) = 1-R_n`.\n`R_n = 0` (base case: string \"0\").\nSo `R_{n-1} = 1-0 = 1`.\n`R_{n-2} = 1-1 = 0`.\n`R_{n-3} = 1-0 = 1`.\n...\n`R_0` is `1` if `n` is even, `0` if `n` is odd.\nThis matches the `m=0` case we found earlier.\nIf `n=1, m=0` (\"0\"), `g_final=0`.\nIf `n=2, m=0` (\"00\"), `g_final=1`.\nIf `n=3, m=0` (\"000\"), `g_final=0`.\nThis is `g_final = (n%2 == 1) ? 0 : 1` for `n >= 1`.\n\nIf `m > 0`:\nLet `k` be the index of the *first* '1' in the string (from the left). `s_k = '1'`.\nSo `s_0, s_1, ..., s_{k-1}` are all '0's.\n`R_k = (1-s_k)(1-R_{k+1}) = (1-1)(1-R_{k+1}) = 0`.\nNow we have `R_k = 0`.\n`R_{k-1} = (1-s_{k-1})(1-R_k) = (1-0)(1-0) = 1`.\n`R_{k-2} = (1-s_{k-2})(1-R_{k-1}) = (1-0)(1-1) = 0`.\n`R_{k-3} = (1-s_{k-3})(1-R_{k-2}) = (1-0)(1-0) = 1`.\n...\nThis pattern `1, 0, 1, 0, ...` goes on until `R_0`.\n`R_0` is `1` if `k` is odd, `0` if `k` is even.\n(Index `k` is 0-indexed. `s_0` is at index 0. If `s_0` is '1', then `k=0`. `R_0` is `0` if `k=0` (even)).\nSo, if the first '1' is at index `k`:\n`g_final = '0'` if `k` is even.\n`g_final = '1'` if `k` is odd.\n\nThis `k` is the number of leading zeros.\nLet `N_0 = k` be the number of leading zeros.\n- If `N_0` is even, `g_final = '0'`.\n- If `N_0` is odd, `g_final = '1'`.\n\nSpecial case: If `m=0`, then `N_0 = n`.\n  - `n` even: `g_final = '0'`. (Contradicts `m=0` analysis where `n` even `g_final='1'`)\n  The `m=0` case is `R_k = (1-s_k)(1-R_{k+1})`.\n  For all zeros, `s_i=0` for all `i`.\n  `R_0 = 1-R_1 = 1-(1-R_2) = R_2 = ...`\n  `R_0 = R_2 = R_4 = ...`\n  `R_1 = 1-R_0`.\n  If `n` is odd, `R_0 = R_{n-1}`. `R_{n-1} = 1-R_n = 1-0 = 1`. So `R_0=1`.\n  If `n` is even, `R_0 = R_n`. `R_n = 0`. So `R_0=0`.\nThis is exactly `g_final = 1` if `n` is odd, `g_final = 0` if `n` is even.\nThis is `g_final = (n%2 == 1) ? 1 : 0` for `n >= 1`.\nThis is the opposite of what I had earlier for `m=0`.\nLet's re-re-check `m=0` case:\n\"0\" (n=1): `R(\"0\")=0`. Formula: `(1%2==1)?1:0` -> 1. Mismatch.\n\"00\" (n=2): `R(\"00\")=(1-0)(1-R(\"0\"))=1-0=1`. Formula: `(2%2==1)?1:0` -> 0. Mismatch.\n\"000\" (n=3): `R(\"000\")=(1-0)(1-R(\"00\"))=1-1=0`. Formula: `(3%2==1)?1:0` -> 1. Mismatch.\nMy `m=0` analysis `g_final = (n%2 == 1) ? 0 : 1` for `n >= 1` was correct.\nThe `R_0 = R_2 = ...` logic is flawed.\n`R_0 = 1-R_1`\n`R_1 = 1-R_2`\n`R_2 = 1-R_3`\n...\n`R_{n-1} = 1-R_n`\n`R_n = 0` (base case for string \"0\")\n`R_{n-1} = 1-0 = 1`.\n`R_{n-2} = 1-R_{n-1} = 1-1 = 0`.\n`R_{n-3} = 1-R_{n-2} = 1-0 = 1`.\nSo `R_k` is `1` if `n-k` is odd, `0` if `n-k` is even.\nWe need `R_0`. So `k=0`.\n`R_0` is `1` if `n` is odd, `0` if `n` is even.\nThis is `g_final = (n%2 == 1) ? 1 : 0` for `n >= 1`.\nThis is still the opposite of my very first `m=0` analysis.\n\nLet's trust the `(1-x)(1-y)` formula and re-derive `m=0` from scratch.\nString `S = \"00...0\"` (length `n`).\n`R(S) = (1-s_0)(1-R(S_suffix))`.\n`R(\"0\") = 0`.\n`R(\"00\") = (1-0)(1-R(\"0\")) = 1*(1-0) = 1`.\n`R(\"000\") = (1-0)(1-R(\"00\")) = 1*(1-1) = 0`.\n`R(\"0000\") = (1-0)(1-R(\"000\")) = 1*(1-0) = 1`.\nSo for `m=0`, `g_final = '0'` if `n` is odd, `g_final = '1'` if `n` is even and `n>=2`.\nThis is indeed `(n%2 == 1) ? 0 : 1` for `n >= 1`. This is the one that matches example `n=2, m=2, g=0` (where \"00\" reduces to '1').\nOkay, my very first `m=0` derivation was correct.\n\nNow for `m > 0`:\nLet `k` be the number of leading zeros. `s_0 = ... = s_{k-1} = '0'`, `s_k = '1'`.\nThe suffix `s_k ... s_{L-1}` has its first character `s_k = '1'`.\nSo `R(s_k ... s_{L-1}) = (1-s_k)(1-R(s_{k+1} ... s_{L-1})) = (1-1)(1-...) = 0`.\nLet `X = R(s_k ... s_{L-1}) = 0`.\nNow we compute `R_0`:\n`R_0 = (1-s_0)(1-R_1)`\n`R_1 = (1-s_1)(1-R_2)`\n...\n`R_{k-1} = (1-s_{k-1})(1-R_k)`\nSince `s_0, ..., s_{k-1}` are all '0's:\n`R_0 = 1-R_1`\n`R_1 = 1-R_2`\n...\n`R_{k-1} = 1-R_k`\nWe know `R_k = 0`.\nSo `R_{k-1} = 1-0 = 1`.\n`R_{k-2} = 1-1 = 0`.\n`R_{k-3} = 1-0 = 1`.\n...\nThe pattern for `R_j` is `1` if `k-j` is odd, `0` if `k-j` is even.\nWe need `R_0`. So `j=0`.\n`R_0` is `1` if `k` is odd.\n`R_0` is `0` if `k` is even.\n\nSo, if `m > 0`:\n`g_final = '0'` if `k` (number of leading zeros) is even.\n`g_final = '1'` if `k` (number of leading zeros) is odd.\n\nWhat if there are no leading zeros? `k=0`. This means `s_0 = '1'`.\nIf `k=0` (even), `g_final = '0'`. This is consistent.\n\nSummary of final character `g_final`:\n1. If `m = 0` (all zeros): String is \"0...0\" of length `n`.\n   - `g_final = '0'` if `n` is odd.\n   - `g_final = '1'` if `n` is even and `n >= 2`.\n   (If `n=0, m=0`, impossible. `n=1, m=0` is length 1, result '0').\n\n2. If `m > 0` (at least one '1'):\n   Let `k` be the number of leading zeros.\n   - `g_final = '0'` if `k` is even.\n   - `g_final = '1'` if `k` is odd.\n   (This applies for `k=0` as well, meaning string starts with '1', `k` is even, `g_final='0'`).\n\nNow we need to count strings for given `n, m, g`.\n\nCase A: `m = 0`.\n  - If `g = 0`: We need `n` to be odd. If `n` is odd, count is 1 (the string \"0...0\"). Else 0.\n  - If `g = 1`: We need `n` to be even and `n >= 2`. If `n` is even and `n >= 2`, count is 1. Else 0.\n  (Note: `n+m>=1` implies `n>=1` here).\n\nCase B: `m > 0`.\n  We need to count strings where the number of leading zeros `k` satisfies `(k%2 == 0)` for `g=0`, or `(k%2 == 1)` for `g=1`.\n  The total length of the string is `L = n+m`.\n  The number of leading zeros `k` can range from `0` to `n`.\n  If `k` leading zeros, then `s_0...s_{k-1}` are '0's. `s_k` must be '1'.\n  The remaining `n-k` zeros and `m-1` ones can be arranged in `L-(k+1)` positions.\n  This means `C( (L-(k+1)), (n-k) )` ways.\n  `C( n+m-k-1, n-k )`.\n  This is the number of ways to arrange the remaining characters after fixing `s_0...s_k`.\n  `k` can be `0, 1, ..., n`.\n  For each `k`, we count `C(n+m-k-1, n-k)` strings.\n  We sum these counts for `k` satisfying the condition.\n\n  `MOD = 1000000007`.\n  Need combinations `C(N, K) = N! / (K! * (N-K)!) mod MOD`.\n  Precompute factorials and inverse factorials.\n\n  Let's compute `ans` based on `g`:\n  If `g = 0`: We need `k` to be even. `k \\in \\{0, 2, 4, ..., n_even\\}`.\n    `ans = sum_{k \\in \\{0,2,...,\\text{even } \\le n\\}} C(n+m-k-1, n-k)`\n  If `g = 1`: We need `k` to be odd. `k \\in \\{1, 3, 5, ..., n_odd\\}`.\n    `ans = sum_{k \\in \\{1,3,...,\\text{odd } \\le n\\}} C(n+m-k-1, n-k)`\n\n  Special condition: `s_k` must be '1'. This requires `m-1 >= 0`. So `m >= 1`.\n  If `m=0`, this case is not applicable.\n  If `m=1`, then `s_k` is the only '1'. The remaining `m-1=0` ones.\n  `C(n+1-k-1, n-k) = C(n-k, n-k) = 1`. This means for each `k`, there is 1 string.\n  Example: `n=1, m=1, g=0`. `L=2`. `m>0`.\n  `g=0` -> `k` must be even.\n  `k` can be `0` (string \"10\") or `1` (string \"01\").\n  If `k=0`: `s_0='1'`. Remaining `n=1` zero, `m-1=0` ones. `C(1+1-0-1, 1-0) = C(1,1)=1`. String \"10\". `k=0` is even, so this string is counted.\n  If `k=1`: `s_0='0', s_1='1'`. Remaining `n-1=0` zeros, `m-1=0` ones. `C(1+1-1-1, 1-1) = C(0,0)=1`. String \"01\". `k=1` is odd, so this string is NOT counted for `g=0`.\n  Total count: 1. But example output is 2. My `m>0` rule is still wrong.\n\nWhat is wrong with `R(s_0 ... s_{L-1}) = (1-s_0)(1-R(s_1 ... s_{L-1}))`?\nLet's check `n=1, m=1, g=0`.\n\"01\": `R(\"01\") = (1-0)(1-R(\"1\")) = 1*(1-1)=0`. This string results in '0'.\n\"10\": `R(\"10\") = (1-1)(1-R(\"0\")) = 0*(1-0)=0`. This string results in '0'.\nBoth strings result in '0'. So for `g=0`, the count is 2. This matches example.\n\nSo the formula `(1-x)(1-y)` is correct.\nAnd my derivations for specific strings \"01\", \"10\", \"0011\", etc. were correct.\nThe problem is with the generalization about `k` leading zeros.\n\nLet `h(string)` be the result.\n`h(X_0 X_1 ... X_{L-1}) = (1-X_0) * (1 - h(X_1 ... X_{L-1}))`.\n`h(X_0 ... X_{L-1})` is 0 if `X_0=1`.\n`h(X_0 ... X_{L-1})` is `1 - h(X_1 ... X_{L-1})` if `X_0=0`.\n\nLet `res_target = g`.\nIf `g=0`:\n  We need `h(s) = 0`.\n  This happens if `s_0 = '1'`.\n  OR if `s_0 = '0'` AND `h(s_1...s_{L-1}) = 1`.\nIf `g=1`:\n  We need `h(s) = 1`.\n  This happens if `s_0 = '0'` AND `h(s_1...s_{L-1}) = 0`.\n  (It can't happen if `s_0 = '1'` because `h(1...) = 0`).\n\nThis recursive definition is the key.\nLet `dp[i][j][target]` be the number of strings with `i` zeros and `j` ones that reduce to `target`.\n`dp[i][j][0]` = count of strings with `i` '0's and `j` '1's reducing to '0'.\n`dp[i][j][1]` = count of strings with `i` '0's and `j` '1's reducing to '1'.\n\nBase cases:\n`dp[1][0][0] = 1` (string \"0\")\n`dp[0][1][1] = 1` (string \"1\")\nAll other `dp[i][j][target]` for `i+j=1` are 0.\n\nFor `i+j > 1`:\nTo get `dp[i][j][0]`:\n  1. String starts with '1': `1...`. Requires `j >= 1`.\n     The suffix `...` has `i` zeros and `j-1` ones.\n     Any such string will reduce to '0'.\n     Number of ways: `C(i+j-1, i)`.\n  2. String starts with '0': `0...`. Requires `i >= 1`.\n     The suffix `...` has `i-1` zeros and `j` ones.\n     This suffix must reduce to '1'.\n     Number of ways: `dp[i-1][j][1]`.\n  So `dp[i][j][0] = ( (j > 0 ? C(i+j-1, i) : 0) + (i > 0 ? dp[i-1][j][1] : 0) ) % MOD`.\n\nTo get `dp[i][j][1]`:\n  1. String starts with '1': `1...`. Requires `j >= 1`.\n     This path always leads to '0'. So this contributes 0 to `dp[i][j][1]`.\n  2. String starts with '0': `0...`. Requires `i >= 1`.\n     The suffix `...` has `i-1` zeros and `j` ones.\n     This suffix must reduce to '0'.\n     Number of ways: `dp[i-1][j][0]`.\n  So `dp[i][j][1] = (i > 0 ? dp[i-1][j][0] : 0) % MOD`.\n\nWe need to compute `dp[n][m][g]`.\nThe maximum `N, M` is `10^5`. A 2D DP table of `10^5 x 10^5` is too large.\nThe `dp[i][j][target]` depends on `dp[i-1][j][target']`. This suggests that `i` is the changing dimension.\nWe can optimize space by only keeping the previous `i` values (current `i` vs `i-1`).\nBut the `j` dimension is still `10^5`. Still too large.\n\nLet's look at the formulas again:\n`dp[i][j][0] = (C(i+j-1, i) + dp[i-1][j][1]) % MOD` (if `j>0, i>0`)\n`dp[i][j][1] = dp[i-1][j][0]` (if `i>0`)\n\nSubstitute `dp[i-1][j][1]` in the first equation:\n`dp[i][j][0] = (C(i+j-1, i) + dp[i-2][j][0]) % MOD` (if `j>0, i>1`)\nThis is a recurrence relation for `dp[i][j][0]`.\nLet `f(i,j) = dp[i][j][0]`.\n`f(i,j) = C(i+j-1, i) + f(i-2, j)` (for `j>0, i>1`)\nBase cases for this `f(i,j)`:\n`f(0,j)`: `i=0`. Only string is `1...1` (j ones). `h(1...1)` is `0`. So `f(0,j)=1` for `j>=1`. `C(j-1,0)=1`.\n`f(1,j)`: `i=1`.\n  `f(1,j) = C(j, 1) + f(-1, j)`. `f(-1,j)` is 0. So `f(1,j) = C(j,1) = j`.\n  Let's check: string starts with '1' (`1...`) or '0' (`0...`).\n  `s_0 = '1'`: `j>=1`. `C(1+j-1, 1) = C(j,1) = j` strings. All reduce to '0'.\n  `s_0 = '0'`: `i=1`. `1` zero. `j` ones. Suffix has `0` zeros, `j` ones.\n    Suffix `1...1` (j ones) reduces to '0' if `j=0` (string \"0\"), or '1' if `j>0`.\n    `dp[0][j][1]` is `1` if `j=1` (string \"1\"), `0` otherwise.\n    So `dp[1][j][0]` for `j>=1`:\n      `j` strings starting with '1' (e.g. \"10\", \"11\", ...). These reduce to '0'.\n      If string starts with '0' (`0...`), suffix has `0` zeros, `j` ones.\n      `dp[0][j][1]` is `0` for `j>1`. `dp[0][1][1]` is `1`.\n      So for `j=1`, `dp[1][1][0] = C(1+1-1, 1) + dp[0][1][1] = C(1,1)+1 = 1+1=2`. Correct for \"01\", \"10\".\n      For `j>1`, `dp[1][j][0] = C(1+j-1, 1) + dp[0][j][1] = C(j,1)+0 = j`. Correct.\n\nSo `f(i,j) = C(i+j-1,i) + f(i-2,j)` for `i>=2, j>=1`.\n`f(i,j) = C(i+j-1,i) + C(i+j-3,i-2) + C(i+j-5,i-4) + ...`\nThe sum stops when `i-2k` becomes `0` or `1`.\nIf `i` is even: `f(i,j) = sum_{k=0}^{i/2-1} C(i-2k+j-1, i-2k) + f(0,j)`.\n  `f(0,j) = 1` for `j>=1`.\n  `f(i,j) = 1 + sum_{k=0}^{i/2-1} C(i-2k+j-1, i-2k)` for `j>=1, i` even.\nIf `i` is odd: `f(i,j) = sum_{k=0}^{(i-1)/2-1} C(i-2k+j-1, i-2k) + f(1,j)`.\n  `f(1,j) = j` for `j>=1`.\n  `f(i,j) = j + sum_{k=0}^{(i-1)/2-1} C(i-2k+j-1, i-2k)` for `j>=1, i` odd.\n\nThis is a sum of combinations.\n`dp[n][m][0]` is `f(n,m)`.\n`dp[n][m][1]` is `dp[n-1][m][0]` (if `n>0`). Which is `f(n-1,m)`.\n\nWhat about `m=0`?\n`dp[n][0][0]`:\n  `n=1, m=0`: `dp[1][0][0]=1` (string \"0\")\n  `n=2, m=0`: `dp[2][0][0]=0` (string \"00\" reduces to '1')\n  `n=3, m=0`: `dp[3][0][0]=1` (string \"000\" reduces to '0')\n  `dp[n][0][0] = (n%2 == 1) ? 1 : 0`.\n`dp[n][0][1]`:\n  `n=1, m=0`: `dp[1][0][1]=0`\n  `n=2, m=0`: `dp[2][0][1]=1`\n  `n=3, m=0`: `dp[3][0][1]=0`\n  `dp[n][0][1] = (n%2 == 0) ? 1 : 0` (for `n>=2`).\n\nFinal calculation:\nIf `m=0`:\n  If `g=0`: return `(n%2 == 1) ? 1 : 0`.\n  If `g=1`: return `(n%2 == 0 && n>=2) ? 1 : 0`.\n  (For `n=0, m=0`, `n+m>=1` implies `n>=1` here. So `n>=1` is always true if `m=0`).\n\nIf `m > 0`:\n  If `g=0`: return `f(n,m)`.\n  If `g=1`: return `f(n-1,m)` (if `n>0`).\n    What if `n=0`? String is `1...1` (`m` ones). `h(1...1)` is `0`. So `dp[0][m][0]=1`. `dp[0][m][1]=0`.\n    If `n=0, m>0`:\n      `g=0`: return 1. (String \"1...1\" reduces to '0').\n      `g=1`: return 0.\n    This is consistent with `f(0,m)=1` for `m>=1`.\n    So for `g=1`, if `n=0`, result is `0`. If `n>0`, result is `f(n-1,m)`.\n\nLet `S(i, j)` be the sum `sum_{k=0}^{i/2-1} C(i-2k+j-1, i-2k)`.\nIf `i` is even, `f(i,j) = (1 + S(i,j)) % MOD`.\nIf `i` is odd, `f(i,j) = (j + S(i,j)) % MOD`.\n\nThis sum `S(i,j)` is a known identity for combinations.\n`sum_{k=0}^{N} C(R+k, k) = C(R+N+1, N)`. This is not exactly it.\n`sum_{k=0}^{N} C(M-k, K)`\nThe sum is `C(j-1+i, i) + C(j-1+i-2, i-2) + C(j-1+i-4, i-4) + ...`\nLet `N_0 = i`, `M_1 = j`.\n`C(N_0+M_1-1, N_0) + C(N_0-2+M_1-1, N_0-2) + ...`\n`C(N_0+M_1-1, M_1-1) + C(N_0-2+M_1-1, M_1-1) + ...`\nThis is a sum of `C(X, M_1-1)` where `X` decreases by 2.\nThis sum can be computed in `O(N)` time. `N` up to `10^5`.\nThis is feasible.\n\nMax value for `N_val` in `C(N_val, K_val)` is `n+m-1` which is `2 * 10^5 - 1`.\nPrecompute factorials up to `2 * 10^5`.\n\n```python\nMOD = 1000000007\nMAX_NM = 200005 # Max n+m-1\n\nfact = [1] * MAX_NM\ninv_fact = [1] * MAX_NM\n\ndef precompute_factorials():\n    for i in range(1, MAX_NM):\n        fact[i] = (fact[i-1] * i) % MOD\n    \n    inv_fact[MAX_NM - 1] = pow(fact[MAX_NM - 1], MOD - 2, MOD)\n    for i in range(MAX_NM - 2, -1, -1):\n        inv_fact[i] = (inv_fact[i+1] * (i+1)) % MOD\n\ndef nCr_mod_p(n, r):\n    if r < 0 or r > n:\n        return 0\n    num = fact[n]\n    den = (inv_fact[r] * inv_fact[n-r]) % MOD\n    return (num * den) % MOD\n\nprecompute_factorials()\n\ndef solve():\n    n, m, g = map(int, input().split())\n\n    # Case 1: m = 0 (string contains only zeros)\n    if m == 0:\n        if n == 0: # n+m >= 1, so this case is not possible\n            print(0)\n            return\n\n        # String is \"0...0\" of length n\n        # R(\"0\") = 0\n        # R(\"00\") = 1\n        # R(\"000\") = 0\n        # R(\"0000\") = 1\n        # Result is 0 if n is odd, 1 if n is even (n >= 2)\n        if n % 2 == 1: # n is odd\n            if g == 0:\n                print(1)\n            else:\n                print(0)\n        else: # n is even\n            if g == 1 and n >= 2: # n=0 case is not possible, n=1 handled by odd\n                print(1)\n            else:\n                print(0)\n        return\n\n    # Case 2: m > 0 (string contains at least one '1')\n    # Let f(i, j) = dp[i][j][0] (number of strings with i zeros, j ones reducing to 0)\n    # Let g(i, j) = dp[i][j][1] (number of strings with i zeros, j ones reducing to 1)\n\n    # Recurrence relations:\n    # f(i, j) = ( (j > 0 ? C(i+j-1, i) : 0) + (i > 0 ? g(i-1, j) : 0) ) % MOD\n    # g(i, j) = (i > 0 ? f(i-1, j) : 0) % MOD\n\n    # Substitute g(i-1, j) into f(i, j) for i >= 1, j >= 1:\n    # f(i, j) = C(i+j-1, i) + f(i-2, j) for i >= 2, j >= 1\n    # Base cases for f(i,j):\n    # f(0, j) = 1 for j >= 1 (string \"1...1\" (j ones) reduces to 0)\n    # f(1, j) = C(1+j-1, 1) + g(0, j) = C(j, 1) + 0 = j for j >= 1 (string starts with '0', suffix \"1...1\" reduces to 0)\n    #   (Actually, g(0,j) = dp[0][j][1] which is 0 for j>=1. So f(1,j)=C(j,1)=j)\n    #   Let's recheck f(1,1): C(1,1)=1. But it should be 2.\n    #   dp[1][1][0] = (C(1+1-1, 1) + dp[0][1][1]) = C(1,1) + 1 = 1+1=2.\n    #   So f(1,j) = C(j,1) + dp[0][j][1].\n    #   dp[0][j][1] is 1 if j=1, 0 otherwise.\n    #   So f(1,1) = C(1,1) + 1 = 2.\n    #   And f(1,j) = C(j,1) + 0 = j for j > 1.\n    #   This means f(1,j) = j if j>1, and 2 if j=1.\n    #   This is not simply j.\n\n    # Let's use the explicit recursion for f(n,m) and g(n,m) (dp[n][m][0] and dp[n][m][1])\n    # The sum formula is `f(i,j) = C(i+j-1,i) + f(i-2,j)`\n    # This sum is `C(i+j-1,i) + C(i+j-3,i-2) + ...`\n    # The terms are `C(X, Y)` where `Y` is `i`, `i-2`, `i-4`, ...\n    # The terms are `C(i+j-1, i)`, `C(i+j-3, i-2)`, `C(i+j-5, i-4)`, ...\n    \n    # We need to calculate `f(n, m)` for `g=0` and `g(n, m)` for `g=1`.\n    # `g(n, m) = f(n-1, m)` (if `n>0`).\n    # If `n=0, m>0`: `g(0,m)=0`.\n\n    ans = 0\n    if g == 0: # Target is '0'\n        # Strings starting with '1' (n zeros, m-1 ones in suffix)\n        # These always reduce to '0'.\n        # Number of such strings: C(n + (m-1), n) = C(n+m-1, n)\n        # This requires m >= 1, which is true in this branch.\n        ans = nCr_mod_p(n + m - 1, n)\n\n        # Strings starting with '0' (n-1 zeros, m ones in suffix)\n        # Suffix must reduce to '1'.\n        # This is `dp[n-1][m][1]`.\n        # If n > 0:\n        if n > 0:\n            # We need to calculate `dp[n-1][m][1]`.\n            # `dp[n-1][m][1] = dp[n-2][m][0]` (if n-1 > 0, i.e., n > 1)\n            # `dp[n-1][m][1] = f(n-2, m)`\n            # If n-1 = 0, i.e., n=1: `dp[0][m][1]`. This is 0 for m>0.\n            \n            if n == 1: # String is \"0\" followed by m ones. Suffix is \"1...1\" (m ones).\n                       # Suffix \"1...1\" reduces to 0. So `dp[0][m][0]` is 1, `dp[0][m][1]` is 0.\n                ans = (ans + 0) % MOD # dp[0][m][1] is 0\n            else: # n > 1. Suffix has n-1 zeros, m ones.\n                  # We need dp[n-1][m][1] = f(n-2,m)\n                \n                # Calculate f(n-2, m)\n                i_val = n - 2\n                j_val = m\n\n                current_f = 0\n                if i_val == 0: # f(0, j_val)\n                    current_f = 1 # String \"1...1\" (j_val ones) reduces to 0.\n                elif i_val == 1: # f(1, j_val)\n                    # f(1, j) = C(j,1) + dp[0][j][1]\n                    # dp[0][j][1] = 1 if j=1, else 0\n                    if j_val == 1:\n                        current_f = (nCr_mod_p(j_val, 1) + 1) % MOD # C(1,1)+1 = 2\n                    else:\n                        current_f = nCr_mod_p(j_val, 1) # C(j,1)=j\n                elif i_val > 1:\n                    # f(i,j) = C(i+j-1,i) + C(i+j-3,i-2) + ...\n                    # Sum C(X, Y) where Y is i_val, i_val-2, ...\n                    # Sum C(i_val+j_val-1, i_val) + C(i_val+j_val-3, i_val-2) + ...\n                    for k_idx in range(i_val, -1, -2):\n                        if k_idx == 0: # Base term f(0, j_val)\n                            current_f = (current_f + 1) % MOD\n                        elif k_idx == 1: # Base term f(1, j_val)\n                            if j_val == 1:\n                                current_f = (current_f + 2) % MOD\n                            else:\n                                current_f = (current_f + nCr_mod_p(j_val, 1)) % MOD\n                        else:\n                            current_f = (current_f + nCr_mod_p(k_idx + j_val - 1, k_idx)) % MOD\n                \n                ans = (ans + current_f) % MOD\n\n    else: # g == 1 (Target is '1')\n        # Strings starting with '1' always reduce to '0'. So they don't contribute.\n        # Strings starting with '0' (n-1 zeros, m ones in suffix)\n        # Suffix must reduce to '0'.\n        # This is `dp[n-1][m][0]`.\n        # If n > 0:\n        if n > 0:\n            # We need to calculate `dp[n-1][m][0] = f(n-1, m)`.\n            i_val = n - 1\n            j_val = m\n\n            current_f = 0\n            if i_val == 0: # f(0, j_val)\n                current_f = 1\n            elif i_val == 1: # f(1, j_val)\n                if j_val == 1:\n                    current_f = 2\n                else:\n                    current_f = nCr_mod_p(j_val, 1)\n            elif i_val > 1:\n                for k_idx in range(i_val, -1, -2):\n                    if k_idx == 0:\n                        current_f = (current_f + 1) % MOD\n                    elif k_idx == 1:\n                        if j_val == 1:\n                            current_f = (current_f + 2) % MOD\n                        else:\n                            current_f = (current_f + nCr_mod_p(j_val, 1)) % MOD\n                    else:\n                        current_f = (current_f + nCr_mod_p(k_idx + j_val - 1, k_idx)) % MOD\n            \n            ans = current_f\n        else: # n=0, m>0. String is \"1...1\". Reduces to 0. Cannot be 1.\n            ans = 0\n    \n    print(ans)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "MOD = 1000000007\nMAX_NM = 200005 # Max n+m-1\n\nfact = [1] * MAX_NM\ninv_fact = [1] * MAX_NM\n\ndef precompute_factorials():\n    for i in range(1, MAX_NM):\n        fact[i] = (fact[i-1] * i) % MOD\n    \n    inv_fact[MAX_NM - 1] = pow(fact[MAX_NM - 1], MOD - 2, MOD)\n    for i in range(MAX_NM - 2, -1, -1):\n        inv_fact[i] = (inv_fact[i+1] * (i+1)) % MOD\n\ndef nCr_mod_p(n, r):\n    if r < 0 or r > n:\n        return 0\n    num = fact[n]\n    den = (inv_fact[r] * inv_fact[n-r]) % MOD\n    return (num * den) % MOD\n\nprecompute_factorials()\n\ndef solve():\n    n, m, g = map(int, input().split())\n\n    # Case 1: m = 0 (string contains only zeros)\n    if m == 0:\n        if n == 0: # n+m >= 1, so this case is not possible\n            print(0)\n            return\n\n        # String is \"0...0\" of length n\n        # R(\"0\") = 0\n        # R(\"00\") = 1\n        # R(\"000\") = 0\n        # R(\"0000\") = 1\n        # Result is 0 if n is odd, 1 if n is even (n >= 2)\n        if n % 2 == 1: # n is odd\n            if g == 0:\n                print(1)\n            else:\n                print(0)\n        else: # n is even\n            if g == 1 and n >= 2: # n=0 case is not possible, n=1 handled by odd\n                print(1)\n            else:\n                print(0)\n        return\n\n    # Case 2: m > 0 (string contains at least one '1')\n    # Let f(i, j) = dp[i][j][0] (number of strings with i zeros, j ones reducing to 0)\n    # Let g(i, j) = dp[i][j][1] (number of strings with i zeros, j ones reducing to 1)\n\n    # Recurrence relations:\n    # f(i, j) = ( (j > 0 ? C(i+j-1, i) : 0) + (i > 0 ? g(i-1, j) : 0) ) % MOD\n    # g(i, j) = (i > 0 ? f(i-1, j) : 0) % MOD\n\n    # Substitute g(i-1, j) into f(i, j) for i >= 1, j >= 1:\n    # f(i, j) = C(i+j-1, i) + f(i-2, j) for i >= 2, j >= 1\n    # Base cases for f(i,j):\n    # f(0, j) = 1 for j >= 1 (string \"1...1\" (j ones) reduces to 0)\n    # f(1, j) = C(1+j-1, 1) + g(0, j) = C(j, 1) + 0 = j for j >= 1 (string starts with '0', suffix \"1...1\" reduces to 0)\n    #   (Actually, g(0,j) = dp[0][j][1] which is 0 for j>=1. So f(1,j)=C(j,1)=j)\n    #   Let's recheck f(1,1): C(1,1)=1. But it should be 2.\n    #   dp[1][1][0] = (C(1+1-1, 1) + dp[0][1][1]) = C(1,1) + 1 = 1+1=2.\n    #   So f(1,j) = C(j,1) + dp[0][j][1].\n    #   dp[0][j][1] is 1 if j=1, 0 otherwise.\n    #   So f(1,1) = C(1,1) + 1 = 2.\n    #   And f(1,j) = C(j,1) + 0 = j for j > 1.\n    #   This means f(1,j) = j if j>1, and 2 if j=1.\n    #   This is not simply j.\n\n    # Let's use the explicit recursion for f(n,m) and g(n,m) (dp[n][m][0] and dp[n][m][1])\n    # The sum formula is `f(i,j) = C(i+j-1,i) + f(i-2,j)`\n    # This sum is `C(i+j-1,i) + C(i+j-3,i-2) + ...`\n    # The terms are `C(X, Y)` where `Y` is `i`, `i-2`, `i-4`, ...\n    # The terms are `C(i+j-1, i)`, `C(i+j-3, i-2)`, `C(i+j-5, i-4)`, ...\n    \n    # We need to calculate `f(n, m)` for `g=0` and `g(n, m)` for `g=1`.\n    # `g(n, m) = f(n-1, m)` (if `n>0`).\n    # If `n=0, m>0`: `g(0,m)=0`.\n\n    ans = 0\n    if g == 0: # Target is '0'\n        # Strings starting with '1' (n zeros, m-1 ones in suffix)\n        # These always reduce to '0'.\n        # Number of such strings: C(n + (m-1), n) = C(n+m-1, n)\n        # This requires m >= 1, which is true in this branch.\n        ans = nCr_mod_p(n + m - 1, n)\n\n        # Strings starting with '0' (n-1 zeros, m ones in suffix)\n        # Suffix must reduce to '1'.\n        # This is `dp[n-1][m][1]`.\n        # If n > 0:\n        if n > 0:\n            # We need to calculate `dp[n-1][m][1]`.\n            # `dp[n-1][m][1] = dp[n-2][m][0]` (if n-1 > 0, i.e., n > 1)\n            # `dp[n-1][m][1] = f(n-2, m)`\n            # If n-1 = 0, i.e., n=1: `dp[0][m][1]`. This is 0 for m>0.\n            \n            if n == 1: # String is \"0\" followed by m ones. Suffix is \"1...1\" (m ones).\n                       # Suffix \"1...1\" reduces to 0. So `dp[0][m][0]` is 1, `dp[0][m][1]` is 0.\n                ans = (ans + 0) % MOD # dp[0][m][1] is 0\n            else: # n > 1. Suffix has n-1 zeros, m ones.\n                  # We need dp[n-1][m][1] = f(n-2,m)\n                \n                # Calculate f(n-2, m)\n                i_val = n - 2\n                j_val = m\n\n                current_f = 0\n                if i_val == 0: # f(0, j_val)\n                    current_f = 1 # String \"1...1\" (j_val ones) reduces to 0.\n                elif i_val == 1: # f(1, j_val)\n                    # f(1, j) = C(j,1) + dp[0][j][1]\n                    # dp[0][j][1] = 1 if j=1, else 0\n                    if j_val == 1:\n                        current_f = (nCr_mod_p(j_val, 1) + 1) % MOD # C(1,1)+1 = 2\n                    else:\n                        current_f = nCr_mod_p(j_val, 1) # C(j,1)=j\n                elif i_val > 1:\n                    # f(i,j) = C(i+j-1,i) + C(i+j-3,i-2) + ...\n                    # Sum C(X, Y) where Y is i_val, i_val-2, ...\n                    # Sum C(i_val+j_val-1, i_val) + C(i_val+j_val-3, i_val-2) + ...\n                    for k_idx in range(i_val, -1, -2):\n                        if k_idx == 0: # Base term f(0, j_val)\n                            current_f = (current_f + 1) % MOD\n                        elif k_idx == 1: # Base term f(1, j_val)\n                            if j_val == 1:\n                                current_f = (current_f + 2) % MOD\n                            else:\n                                current_f = (current_f + nCr_mod_p(j_val, 1)) % MOD\n                        else:\n                            current_f = (current_f + nCr_mod_p(k_idx + j_val - 1, k_idx)) % MOD\n                \n                ans = (ans + current_f) % MOD\n\n    else: # g == 1 (Target is '1')\n        # Strings starting with '1' always reduce to '0'. So they don't contribute.\n        # Strings starting with '0' (n-1 zeros, m ones in suffix)\n        # Suffix must reduce to '0'.\n        # This is `dp[n-1][m][0]`.\n        # If n > 0:\n        if n > 0:\n            # We need to calculate `dp[n-1][m][0] = f(n-1, m)`.\n            i_val = n - 1\n            j_val = m\n\n            current_f = 0\n            if i_val == 0: # f(0, j_val)\n                current_f = 1\n            elif i_val == 1: # f(1, j_val)\n                if j_val == 1:\n                    current_f = 2\n                else:\n                    current_f = nCr_mod_p(j_val, 1)\n            elif i_val > 1:\n                for k_idx in range(i_val, -1, -2):\n                    if k_idx == 0:\n                        current_f = (current_f + 1) % MOD\n                    elif k_idx == 1:\n                        if j_val == 1:\n                            current_f = (current_f + 2) % MOD\n                        else:\n                            current_f = (current_f + nCr_mod_p(j_val, 1)) % MOD\n                    else:\n                        current_f = (current_f + nCr_mod_p(k_idx + j_val - 1, k_idx)) % MOD\n            \n            ans = current_f\n        else: # n=0, m>0. String is \"1...1\". Reduces to 0. Cannot be 1.\n            ans = 0\n    \n    print(ans)\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 569,
        "completion_token_count": 17132,
        "thoughts_token_count": 741
    }
}