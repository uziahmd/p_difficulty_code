{
    "start": 1758009317.860741,
    "end": 1758009372.0108616,
    "start-formatted": "2025-09-16 16:55 KST",
    "end-formatted": "2025-09-16 16:56 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "**Thinking Through Snowflake Vertices**\n\nOkay, so I'm being asked to figure out if a given number, `n`, can represent the number of vertices in a \"snowflake\" graph.  I need to break this down. First, I need to understand what this snowflake graph is.\n\nIt starts with a central vertex. Then, this center connects to `k` other vertices.  Already, I can see a base structure of `1 + k` vertices.  But the critical part is this \"leveling\" – where vertices connected to *only one other* get connected to `k` more.  This step *must* happen at least once.\n\nLet's use \"depth\" to represent the number of times this step is repeated. Since step 3 must be used at least once, the minimum depth is 2.\n\nAt depth 1, we just have the center and the `k` vertices it's connected to. The total number of vertices is `1+k`. This is before the connecting of the single-connected nodes occurs.\n\nBut let's go deeper. With a depth of 2, the `k` vertices connected to the center each connect to `k` new vertices, resulting in `k * k = k^2` new vertices. Now, the total is `1 + k + k^2`. This formula looks promising.\n\nNow, I can see the pattern evolving. If the depth is 3, the `k^2` vertices will each connect to `k` more. Therefore, the number of vertices is `1 + k + k^2 + k^3`.  It seems like I'm dealing with a geometric series.\n\nEssentially, for a snowflake of depth `d`, the number of vertices is of the form:\n`1 + k + k^2 + ... + k^(d-1) = (k^d - 1) / (k - 1)`.\n\nSo, the problem boils down to checking if `n` can be expressed in this form for some valid `k` and `d`.  I'll need to develop an algorithm or check the possibilities to see if n is a valid snowflake node count.\n",
    "response": "The problem asks us to determine if a given number of vertices `n` can form a \"snowflake\" graph. A snowflake is constructed as follows:\n1.  Start with 1 central vertex.\n2.  Connect the central vertex to `k` new vertices, where `k > 1`.\n3.  Each vertex that is connected to only one other vertex is connected to `k` more new vertices. This step must be done at least once.\n\nLet's count the number of vertices based on the construction process.\n\n*   **Initial state:** 1 central vertex. Total = 1.\n*   **After step 2:** The 1 central vertex is connected to `k` new vertices.\n    Total vertices = `1 + k`.\n    These `k` new vertices are currently connected to only one other vertex (the center).\n\n*   **After step 3 (first application):** Each of the `k` vertices from the previous step (which are connected to only one other vertex) is connected to `k` new vertices.\n    This adds `k * k = k^2` new vertices.\n    Total vertices = `1 + k + k^2`.\n    These `k^2` new vertices are now the ones connected to only one other vertex.\n    Since step 3 must be done at least once, the minimum number of vertices in a snowflake is `1 + k + k^2`. This corresponds to a snowflake of depth `d=2` (meaning the \"leaves\" are at level 2 relative to the center).\n\n*   **After step 3 (second application):** Each of the `k^2` vertices from the previous step is connected to `k` new vertices.\n    This adds `k^2 * k = k^3` new vertices.\n    Total vertices = `1 + k + k^2 + k^3`.\n    This corresponds to a snowflake of depth `d=3`.\n\nIn general, if step 3 is applied `d-1` times (for a total depth of `d`, where `d >= 2`), the number of vertices will be:\n`N = 1 + k + k^2 + ... + k^d`\n\nThis is a geometric series sum, which can be written as `N = (k^(d+1) - 1) / (k - 1)`.\n\nSo, for a given `n`, we need to check if there exist integers `k > 1` and `d >= 2` such that `n = 1 + k + ... + k^d`.\n\nLet's analyze the possible values for `d`:\n\n**Case 1: `d = 2`**\n`n = 1 + k + k^2`\nThis is a quadratic equation in `k`: `k^2 + k + (1 - n) = 0`.\nWe can solve for `k` using the quadratic formula: `k = (-1 ± sqrt(1 - 4 * (1 - n))) / 2`\n`k = (-1 ± sqrt(1 - 4 + 4n)) / 2`\n`k = (-1 ± sqrt(4n - 3)) / 2`\nFor `k` to be a valid integer greater than 1:\n1.  `4n - 3` must be a perfect square. Let `4n - 3 = s^2` for some integer `s`.\n2.  `s` must be positive.\n3.  `k = (-1 + s) / 2` must be an integer. This implies `s` must be odd.\n4.  `k > 1`, so `(-1 + s) / 2 > 1`, which means `-1 + s > 2`, so `s > 3`.\n\nWe can check this efficiently: calculate `s = sqrt(4n - 3)`. If `s` is an integer, `s > 3`, and `s` is odd, then `k = (s - 1) / 2` is a valid `k`.\n\n**Case 2: `d >= 3`**\n`n = 1 + k + k^2 + ... + k^d`\n\nFor `k > 1` and `d >= 3`:\n`n = 1 + k + k^2 + ... + k^d`\nWe know `k^d < n`. So `k < n^(1/d)`.\nSince `d >= 3`, `k < n^(1/3)`.\nFor `n = 10^18`, `k < (10^18)^(1/3) = 10^6`.\nThis means `k` can range from `2` to `10^6`. We can iterate through all possible values of `k` in this range.\n\nFor each `k`:\nWe need to find if there exists an integer `d >= 3` such that `n = (k^(d+1) - 1) / (k - 1)`.\nThis is equivalent to `n * (k - 1) + 1 = k^(d+1)`.\nLet `target = n * (k - 1) + 1`. We need to check if `target` is a perfect power of `k`, specifically `k^(d+1)` for some `d >= 3`.\nSince `d >= 3`, `d+1 >= 4`.\nWe can use binary search to find `d+1` for a fixed `k` and `target`.\nThe maximum value of `d+1` is `log_k(n * (k-1) + 1)`. Since `k >= 2`, `d+1 <= log_2(10^18 * 10^6 + 1) approx log_2(10^24) approx 24 * log_2(10) approx 24 * 3.32 approx 80`.\nSo `d+1` is relatively small. We can binary search for `p = d+1` in the range `[4, 80]`.\n\nTo optimize the check for `k^(d+1) = target`:\nWe can compute `k^p` using exponentiation by squaring.\n`k^p` can quickly exceed `10^18`. We need to be careful with overflow if `k^p` is computed directly.\nInstead of binary searching for `p`, we can simply iterate `p` from `4` upwards.\nFor a fixed `k`, start with `current_power = k`.\n`current_sum = 1 + k`.\nThen `current_sum = 1 + k + k^2`.\n`current_sum = 1 + k + k^2 + k^3`.\n...\nKeep adding `k^i` to `current_sum` and check if `current_sum == n`.\nStop if `current_sum` exceeds `n` or `k^i` (the term being added) exceeds `n` (to prevent overflow in `k^i` itself).\n\nThe overall algorithm:\n1.  Handle edge cases: `n < 7` (minimum `1+2+2^2 = 7`) will always be \"NO\".\n2.  **Check for `d=2`:**\n    Calculate `val = 4n - 3`.\n    If `val` is a perfect square `s^2` and `s > 3` and `s` is odd, then `k = (s - 1) / 2` is a valid `k`. Output \"YES\".\n3.  **Check for `d >= 3`:**\n    Iterate `k` from `2` up to `10^6`.\n    For each `k`:\n    Initialize `current_sum = 1 + k`.\n    Initialize `power_of_k = k`.\n    Loop `d = 2` upwards:\n        If `n - current_sum < power_of_k` (i.e., `n < current_sum + power_of_k`), then `n` is too small for this `k` and `d`. Break from inner loop.\n        To avoid overflow when calculating `power_of_k * k`: check `power_of_k > n / k`. If true, `power_of_k * k` will overflow `long long` or exceed `n`. Break from inner loop.\n        `power_of_k *= k`.\n        `current_sum += power_of_k`.\n        If `current_sum == n` and `d >= 2` (which is already ensured by our loop structure starting `d=2` and then `d=3,4,...`), then output \"YES\" and return.\n        If `current_sum > n`, break from inner loop.\n    This loop structure for `d` effectively checks `d=2, 3, ...` for each `k`.\n    The `d=2` case is already handled, so we only need to consider `d >= 3` in this loop.\n    For `d=2`, `current_sum = 1 + k + k^2`. This is already checked.\n    So in the inner loop, we can start `d=3`.\n    Initialize `current_sum = 1 + k + k^2`.\n    Initialize `power_of_k = k^2`.\n    Loop `d = 3` upwards:\n        Check `power_of_k > n / k` for overflow.\n        `power_of_k *= k`.\n        `current_sum += power_of_k`.\n        If `current_sum == n`, output \"YES\".\n        If `current_sum > n`, break.\n        If `d` becomes too large (e.g., `d > 60` for `k=2`), `power_of_k` will definitely exceed `n`.\n\nTotal complexity: `O(sqrt(N))` for `d=2` check (if using `sqrt`) + `O(N^(1/3) * log(N))` for `d >= 3` check (if using `log` for `d` or `O(N^(1/3) * log_k(N))` for iteration).\n`10^6 * log(10^18)` is roughly `10^6 * 60`, which is `6 * 10^7` operations, feasible within 1-2 seconds.\n\nExample walkthrough: `n = 13`\n1. `n < 7` is false.\n2. `d=2` check:\n   `val = 4 * 13 - 3 = 52 - 3 = 49`.\n   `s = sqrt(49) = 7`.\n   `s > 3` is true (`7 > 3`).\n   `s` is odd (`7 % 2 == 1`).\n   All conditions met.\n   `k = (7 - 1) / 2 = 3`.\n   So `n=13` can be formed with `k=3, d=2` (`1 + 3 + 3^2 = 1 + 3 + 9 = 13`). Output \"YES\".\n\nExample walkthrough: `n = 255`\n1. `n < 7` is false.\n2. `d=2` check:\n   `val = 4 * 255 - 3 = 1020 - 3 = 1017`.\n   `sqrt(1017)` is not an integer (`31^2 = 961`, `32^2 = 1024`). So `d=2` fails.\n3. `d >= 3` check:\n   Iterate `k` from `2` up to `10^6`.\n   For `k=2`:\n     `current_sum = 1`.\n     `power_of_k = 1`.\n     `d=0` (conceptually)\n     Loop:\n       `d=1`: `power_of_k = 2`. `current_sum = 1 + 2 = 3`.\n       `d=2`: `power_of_k = 4`. `current_sum = 3 + 4 = 7`.\n       `d=3`: `power_of_k = 8`. `current_sum = 7 + 8 = 15`.\n       `d=4`: `power_of_k = 16`. `current_sum = 15 + 16 = 31`.\n       `d=5`: `power_of_k = 32`. `current_sum = 31 + 32 = 63`.\n       `d=6`: `power_of_k = 64`. `current_sum = 63 + 64 = 127`.\n       `d=7`: `power_of_k = 128`. `current_sum = 127 + 128 = 255`.\n       `current_sum == n`. Output \"YES\".\n\nFinal check on constraints: `n = 10^18`.\n`k` up to `10^6`.\n`power_of_k` can be `k^d`. If `k=2`, `2^60` is approx `10^18`. If `k=10^6`, `(10^6)^3 = 10^18`.\n`power_of_k` and `current_sum` need to be `long long` (Python handles large integers automatically).\nThe `n - current_sum < power_of_k` check is important.\nThe `power_of_k > n / k` check is important to prevent `power_of_k * k` from overflowing and also to quickly stop if `k * power_of_k` would exceed `n`.\n\n```python\nimport math\n\ndef solve():\n    n = int(input())\n\n    # Smallest possible snowflake has k=2, d=2: 1 + 2 + 2^2 = 7 vertices.\n    # If n < 7, it cannot be a snowflake.\n    if n < 7:\n        print(\"NO\")\n        return\n\n    # Case 1: d = 2\n    # n = 1 + k + k^2\n    # k^2 + k + (1 - n) = 0\n    # Using quadratic formula: k = (-1 + sqrt(1 - 4(1 - n))) / 2\n    # k = (-1 + sqrt(4n - 3)) / 2\n    \n    val = 4 * n - 3\n    s_float = math.isqrt(val) # integer square root\n    \n    # Check if val is a perfect square\n    if s_float * s_float == val:\n        # Check if s_float is odd and s_float > 3\n        # s_float must be odd for (-1 + s_float) to be even\n        # k must be > 1, so (-1 + s_float) / 2 > 1 => -1 + s_float > 2 => s_float > 3\n        if s_float % 2 == 1 and s_float > 3:\n            # k = (s_float - 1) // 2\n            # This k would be an integer > 1\n            print(\"YES\")\n            return\n\n    # Case 2: d >= 3\n    # n = 1 + k + k^2 + ... + k^d\n    # For d >= 3, k must be relatively small.\n    # If k=2, n = 1 + 2 + ... + 2^d. 2^d approx n. d approx log2(n). For n=10^18, d approx 60.\n    # If d=3, n = 1 + k + k^2 + k^3. k^3 approx n. k approx n^(1/3). For n=10^18, k approx 10^6.\n    # So k can go up to around 10^6.\n    \n    # Iterate k from 2 up to a reasonable limit (10^6 is sufficient for d >= 3 and n <= 10^18)\n    # The upper bound for k can be further constrained by k < n^(1/3) if d >= 3.\n    # For n=10^18, k_max ~ 10^6.\n    # For k=2, d can be up to ~60.\n    # For k=10^6, d=3 is the only possibility (1 + k + k^2 + k^3).\n    # (10^6)^4 = 10^24, which is > 10^18.\n    \n    # The loop for k should start from 2, but we already handled d=2.\n    # So we are looking for d >= 3 here.\n    # The smallest k for d=3 is k=2, 1 + 2 + 4 + 8 = 15.\n    \n    # Iterate k from 2 up to 10^6\n    # We can optimize the upper bound for k: k^3 < n => k < n^(1/3)\n    # For n=10^18, n^(1/3) = 10^6. So k_max = 10^6.\n    \n    # Iterate k from 2 up to max_k_for_d_ge_3\n    # Use math.isqrt for safety, though 10^6 is a good practical limit.\n    max_k_for_d_ge_3 = int(n**(1/3)) + 2 # Add a small buffer just in case of float precision issues\n    if max_k_for_d_ge_3 > 10**6 + 5: # Cap it to a reasonable constant if n is very large\n        max_k_for_d_ge_3 = 10**6 + 5\n\n    for k in range(2, max_k_for_d_ge_3):\n        current_sum = 1 + k\n        power_of_k = k\n\n        # Start checking for d=2, then d=3, d=4, ...\n        # d=2 is already handled, but this loop structure is simpler and correctly covers d >= 2.\n        # If current_sum becomes n, it means we found a valid (k, d).\n        # We need d >= 2, which is ensured by the loop.\n        \n        # Loop for d, starting effectively from d=2\n        # current_sum = 1 + k\n        # power_of_k = k\n        # The first iteration of the while loop will compute for d=2: 1 + k + k^2\n        # The second iteration will compute for d=3: 1 + k + k^2 + k^3 etc.\n        \n        while True:\n            # Check for overflow before multiplying power_of_k by k\n            # If power_of_k > n / k, then power_of_k * k would exceed n\n            # Also, power_of_k * k could overflow if n is near max_long_long and k is large.\n            # Python handles large integers, so overflow is not an issue, but exceeding n is a good stop condition.\n            if power_of_k > n // k: # Use // for integer division\n                break # Next power_of_k would exceed n, so current_sum will also exceed n\n\n            power_of_k *= k\n            current_sum += power_of_k\n\n            if current_sum == n:\n                # We found a valid k and d.\n                # Since we already handled d=2 separately, any 'YES' from this loop implies d >= 3\n                # (unless n was small and d=2 solution was missed by the separate check, but it shouldn't be).\n                # The d=2 check is robust for any n.\n                # So if we reach here, it's for d >= 3.\n                print(\"YES\")\n                return\n            \n            if current_sum > n:\n                break # current_sum has exceeded n, no solution for this k\n\n    print(\"NO\")\n\n\nt = int(input())\nfor _ in range(t):\n    solve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef solve():\n    n = int(input())\n\n    # Smallest possible snowflake has k=2, d=2: 1 + 2 + 2^2 = 7 vertices.\n    # If n < 7, it cannot be a snowflake.\n    if n < 7:\n        print(\"NO\")\n        return\n\n    # Case 1: d = 2\n    # n = 1 + k + k^2\n    # k^2 + k + (1 - n) = 0\n    # Using quadratic formula: k = (-1 + sqrt(1 - 4(1 - n))) / 2\n    # k = (-1 + sqrt(4n - 3)) / 2\n    \n    val = 4 * n - 3\n    s_float = math.isqrt(val) # integer square root\n    \n    # Check if val is a perfect square\n    if s_float * s_float == val:\n        # Check if s_float is odd and s_float > 3\n        # s_float must be odd for (-1 + s_float) to be even\n        # k must be > 1, so (-1 + s_float) / 2 > 1 => -1 + s_float > 2 => s_float > 3\n        if s_float % 2 == 1 and s_float > 3:\n            # k = (s_float - 1) // 2\n            # This k would be an integer > 1\n            print(\"YES\")\n            return\n\n    # Case 2: d >= 3\n    # n = 1 + k + k^2 + ... + k^d\n    # For d >= 3, k must be relatively small.\n    # If k=2, n = 1 + 2 + ... + 2^d. 2^d approx n. d approx log2(n). For n=10^18, d approx 60.\n    # If d=3, n = 1 + k + k^2 + k^3. k^3 approx n. k approx n^(1/3). For n=10^18, k approx 10^6.\n    # So k can go up to around 10^6.\n    \n    # Iterate k from 2 up to a reasonable limit (10^6 is sufficient for d >= 3 and n <= 10^18)\n    # The upper bound for k can be further constrained by k < n^(1/3) if d >= 3.\n    # For n=10^18, k_max ~ 10^6.\n    # For k=2, d can be up to ~60.\n    # For k=10^6, d=3 is the only possibility (1 + k + k^2 + k^3).\n    # (10^6)^4 = 10^24, which is > 10^18.\n    \n    # The loop for k should start from 2, but we already handled d=2.\n    # So we are looking for d >= 3 here.\n    # The smallest k for d=3 is k=2, 1 + 2 + 4 + 8 = 15.\n    \n    # Iterate k from 2 up to 10^6\n    # We can optimize the upper bound for k: k^3 < n => k < n^(1/3)\n    # For n=10^18, n^(1/3) = 10^6. So k_max = 10^6.\n    \n    # Iterate k from 2 up to max_k_for_d_ge_3\n    # Use math.isqrt for safety, though 10^6 is a good practical limit.\n    max_k_for_d_ge_3 = int(n**(1/3)) + 2 # Add a small buffer just in case of float precision issues\n    if max_k_for_d_ge_3 > 10**6 + 5: # Cap it to a reasonable constant if n is very large\n        max_k_for_d_ge_3 = 10**6 + 5\n\n    for k in range(2, max_k_for_d_ge_3):\n        current_sum = 1 + k\n        power_of_k = k\n\n        # Start checking for d=2, then d=3, d=4, ...\n        # d=2 is already handled, but this loop structure is simpler and correctly covers d >= 2.\n        # If current_sum becomes n, it means we found a valid (k, d).\n        # We need d >= 2, which is ensured by the loop.\n        \n        # Loop for d, starting effectively from d=2\n        # current_sum = 1 + k\n        # power_of_k = k\n        # The first iteration of the while loop will compute for d=2: 1 + k + k^2\n        # The second iteration will compute for d=3: 1 + k + k^2 + k^3 etc.\n        \n        while True:\n            # Check for overflow before multiplying power_of_k by k\n            # If power_of_k > n / k, then power_of_k * k would exceed n\n            # Also, power_of_k * k could overflow if n is near max_long_long and k is large.\n            # Python handles large integers, so overflow is not an issue, but exceeding n is a good stop condition.\n            if power_of_k > n // k: # Use // for integer division\n                break # Next power_of_k would exceed n, so current_sum will also exceed n\n\n            power_of_k *= k\n            current_sum += power_of_k\n\n            if current_sum == n:\n                # We found a valid k and d.\n                # Since we already handled d=2 separately, any 'YES' from this loop implies d >= 3\n                # (unless n was small and d=2 solution was missed by the separate check, but it shouldn't be).\n                # The d=2 check is robust for any n.\n                # So if we reach here, it's for d >= 3.\n                print(\"YES\")\n                return\n            \n            if current_sum > n:\n                break # current_sum has exceeded n, no solution for this k\n\n    print(\"NO\")\n\n\nt = int(input())\nfor _ in range(t):\n    solve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 568,
        "completion_token_count": 4645,
        "thoughts_token_count": 743
    }
}