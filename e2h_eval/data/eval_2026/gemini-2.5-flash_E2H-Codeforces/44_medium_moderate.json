{
    "start": 1758294866.803126,
    "end": 1758294978.6698852,
    "start-formatted": "2025-09-20 00:14 KST",
    "end-formatted": "2025-09-20 00:16 KST",
    "gpu": 2,
    "pid": 44,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Polycarp's Practice\n\nPolycarp is practicing his problem solving skill. He has a list of $$$n$$$ problems with difficulties $$$a_1, a_2, \\dots, a_n$$$, respectively. His plan is to practice for exactly $$$k$$$ days. Each day he has to solve at least one problem from his list. Polycarp solves the problems in the order they are given in his list, he cannot skip any problem from his list. He has to solve all $$$n$$$ problems in exactly $$$k$$$ days.Thus, each day Polycarp solves a contiguous sequence of (consecutive) problems from the start of the list. He can't skip problems or solve them multiple times. As a result, in $$$k$$$ days he will solve all the $$$n$$$ problems.The profit of the $$$j$$$-th day of Polycarp's practice is the maximum among all the difficulties of problems Polycarp solves during the $$$j$$$-th day (i.e. if he solves problems with indices from $$$l$$$ to $$$r$$$ during a day, then the profit of the day is $$$\\max\\limits_{l \\le i \\le r}a_i$$$). The total profit of his practice is the sum of the profits over all $$$k$$$ days of his practice.You want to help Polycarp to get the maximum possible total profit over all valid ways to solve problems. Your task is to distribute all $$$n$$$ problems between $$$k$$$ days satisfying the conditions above in such a way, that the total profit is maximum.For example, if $$$n = 8, k = 3$$$ and $$$a = [5, 4, 2, 6, 5, 1, 9, 2]$$$, one of the possible distributions with maximum total profit is: $$$[5, 4, 2], [6, 5], [1, 9, 2]$$$. Here the total profit equals $$$5 + 6 + 9 = 20$$$.\n\n## Input\nThe first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\le k \\le n \\le 2000$$$) — the number of problems and the number of days, respectively.The second line of the input contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le 2000$$$) — difficulties of problems in Polycarp's list, in the order they are placed in the list (i.e. in the order Polycarp will solve them).\n\n## Output\nIn the first line of the output print the maximum possible total profit.In the second line print exactly $$$k$$$ positive integers $$$t_1, t_2, \\dots, t_k$$$ ($$$t_1 + t_2 + \\dots + t_k$$$ must equal $$$n$$$), where $$$t_j$$$ means the number of problems Polycarp will solve during the $$$j$$$-th day in order to achieve the maximum possible total profit of his practice.If there are many possible answers, you may print any of them.\n\n## Example\n### Input\n['8 3\\n5 4 2 6 5 1 9 2', '5 1\\n1 1 1 1 1', '4 2\\n1 2000 2000 2']\n\n### Output\n['20\\n3 2 3', '1\\n5', '4000\\n2 2']\n\n## Note\nThe first example is described in the problem statement.In the second example there is only one possible distribution.In the third example the best answer is to distribute problems in the following way: $$$[1, 2000], [2000, 2]$$$. The total profit of this distribution is $$$2000 + 2000 = 4000$$$.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "**The Optimization Challenge: Maximizing Problem-Solving Profit**\n\nI'm tackling a competitive programming problem where the goal is to maximize profit over a set number of days (`k`) by strategically solving problems of varying difficulties (`a`). My task is to devise a Python script that takes `n` (number of problems), `k` (number of days), and a list of problem difficulties (`a`) as input, and outputs the maximum achievable profit along with the distribution of problems per day.\n\nThe core idea is this: profit for a day is the maximum difficulty of the problems solved on that day. To maximize the *total* profit (the sum of daily profits), I need to ensure that the sum of the *k* largest problem difficulties is the total profit.\n\nThe winning strategy revolves around identifying the `k` largest problem difficulties within the input list `a`. The problem demands that these largest difficulties become the *maximum* difficulty for one of the `k` days. This means segmenting the `n` problems in a way that each of the `k` largest problems is the maximum of a segment. It’s critical that all problems are solved exactly once.\n\nThe key is in finding the *indices* of these `k` largest problems in the original list. The sorted indices of these `k` largest values define the points where the `k-1` cuts must be placed to ensure the segment maximums correspond to the `k` largest values. The `k-1` cuts neatly partition the problems into `k` groups, ensuring the sum of the maximums is the absolute maximum profit.\n",
    "response": "The problem asks us to divide `n` problems, given by their difficulties `a_1, \\dots, a_n`, into exactly `k` contiguous segments (days). Each day, Polycarp solves a sequence of problems, and the profit for that day is the maximum difficulty among problems solved on that day. We want to maximize the total profit, which is the sum of daily profits. We need to output the maximum total profit and the number of problems solved each day.\n\nTo maximize the sum of `k` values, each value should be as large as possible. The maximum possible profit for any single day is the maximum difficulty of any problem in the entire list `a`. If we could choose `k` problems, each being the maximum of one day, and these `k` problems were the `k` largest problems in the entire list `a`, then their sum would be the absolute maximum possible total profit.\n\nLet's verify if this strategy is achievable:\n1.  **Identify the `k` largest difficulties**: Find the `k` problems with the highest difficulties in the list `a`. If there are ties, we can pick any `k` problems that achieve these `k` highest difficulty values. For example, if `a = [10, 1, 10]` and `k=2`, the two largest difficulties are `10` and `10`.\n2.  **Calculate the maximum total profit**: The sum of these `k` largest difficulties will be the maximum possible total profit.\n\n3.  **Determine the daily distribution**: To achieve this maximum profit, each of the `k` days must have one of these `k` largest problems as its maximum. A simple way to ensure this is to make cuts in such a way that each of these `k` largest problems is the maximum problem in its respective day's segment.\n\n    Let's store the problems along with their original indices: `(difficulty, index)`.\n    Sort these pairs by difficulty in descending order.\n    Take the top `k` pairs. These are `(val_0, idx_0), (val_1, idx_1), \\dots, (val_{k-1}, idx_{k-1})`.\n    The maximum total profit is `sum(val_i for i in range(k))`.\n\n    Now, we need to find `k` segment lengths `t_1, t_2, \\dots, t_k` such that `t_1 + \\dots + t_k = n` and each `t_j > 0`.\n    Let the original indices of these `k` chosen problems be `p_0, p_1, \\dots, p_{k-1}`. Sort these indices in ascending order: `p'_0 < p'_1 < \\dots < p'_{k-1}`.\n\n    We need to make `k-1` cuts to divide the `n` problems into `k` segments. A straightforward approach is to make cuts *after* the first `k-1` of these sorted pivot indices.\n    \n    *   Day 1: Problems from index `0` to `p'_0`.\n    *   Day 2: Problems from index `p'_0 + 1` to `p'_1`.\n    *   ...\n    *   Day `j` (for `j < k`): Problems from index `p'_{j-2} + 1` to `p'_{j-1}`.\n    *   Day `k`: Problems from index `p'_{k-1-1} + 1` to `n-1`.\n\n    Let's refine this:\n    The `k-1` cut points will be `p'_0, p'_1, \\dots, p'_{k-2}`.\n    The segments are defined as follows:\n    1.  Day 1: Problems `a[0 \\dots p'_0]`. The number of problems is `p'_0 - 0 + 1`. The maximum difficulty in this segment will be `a[p'_0]`, because `a[p'_0]` is one of the `k` largest problems overall, so any `a[i]` with `i < p'_0` must have `a[i] \\le a[p'_0]` (otherwise `a[i]` would have been chosen among the top `k` instead of or in addition to `a[p'_0]` if `a[p'_0]` was chosen at all).\n    2.  Day 2: Problems `a[p'_0+1 \\dots p'_1]`. Number of problems is `p'_1 - (p'_0+1) + 1`. Similarly, `a[p'_1]` will be the maximum.\n    3.  ...\n    4.  Day `k-1`: Problems `a[p'_{k-2}+1 \\dots p'_{k-1}]`. Number of problems is `p'_{k-1} - (p'_{k-2}+1) + 1`. `a[p'_{k-1}]` will be the maximum.\n    5.  Day `k`: Problems `a[p'_{k-1}+1 \\dots n-1]`. Number of problems is `(n-1) - (p'_{k-1}+1) + 1`. The maximum of this segment will be `max(a[p'_{k-1}+1 \\dots n-1])`.\n\n    This distribution ensures that the profits for the first `k-1` days are `a[p'_0], a[p'_1], \\dots, a[p'_{k-1}]`. The problem is that the profit for the `k`-th day is `max(a[p'_{k-1}+1 \\dots n-1])`, which is not necessarily one of our chosen `k` largest values. This would mean that one of the `k` largest values (`a[p'_{k-1}]`) is the maximum for day `k-1`, and the actual `k`-th day's maximum is some other value. This would lead to a total profit that is not necessarily the sum of the `k` largest values.\n\n    The correct way to define cuts:\n    We have `k` special indices `p'_0, p'_1, \\dots, p'_{k-1}` (sorted).\n    We need to make `k-1` cuts. These cuts must be placed such that each `p'_j` falls into a different segment, and `a[p'_j]` is the maximum for that segment.\n    The simplest way to achieve this is to make cuts *just before* `k-1` of these `p'_j` problems, or *just after* them.\n    Let's try making cuts *after* `p'_0, p'_1, \\dots, p'_{k-2}`.\n    The segments are:\n    `[0, p'_0]`, `[p'_0+1, p'_1]`, ..., `[p'_{k-2}+1, p'_{k-1}]`, `[p'_{k-1}+1, n-1]`.\n    This creates `k` segments.\n    The lengths of these segments (number of problems per day) are:\n    `t_1 = p'_0 + 1`\n    `t_2 = p'_1 - p'_0`\n    ...\n    `t_{k-1} = p'_{k-1} - p'_{k-2}`\n    `t_k = n - (p'_{k-1} + 1)` (This is the number of problems from `p'_{k-1}+1` to `n-1`. This segment must exist and be non-empty if `p'_{k-1} < n-1`. If `p'_{k-1} = n-1`, then this segment is empty, which is a problem as `t_k` must be positive.)\n\n    The problem states \"Each day he has to solve at least one problem\".\n    The last day must contain `a[p'_{k-1}]` as its maximum. So `p'_{k-1}` must be the end of the `k`-th segment.\n    This means the `k-1` cuts must be at indices `p'_0, p'_1, \\dots, p'_{k-2}`.\n    The segments are:\n    Day 1: `a[0 \\dots p'_0]`. Profit `a[p'_0]`. Length `p'_0 + 1`.\n    Day 2: `a[p'_0+1 \\dots p'_1]`. Profit `a[p'_1]`. Length `p'_1 - p'_0`.\n    ...\n    Day `k-1`: `a[p'_{k-2}+1 \\dots p'_{k-1}]`. Profit `a[p'_{k-1}]`. Length `p'_{k-1} - p'_{k-2}`.\n    Day `k`: This is where the issue is. If we make `k-1` cuts at `p'_0, \\dots, p'_{k-2}`, then the last day would start at `p'_{k-1}+1` and end at `n-1`. But `a[p'_{k-1}]` would not be in this segment. It would be in day `k-1`. This is not what we want.\n\n    The example `a = [5, 4, 2, 6, 5, 1, 9, 2]`, `k = 3`.\n    Top 3 values: `9, 6, 5`. Indices: `6, 3, 0`. Sorted indices: `[0, 3, 6]`.\n    Total profit: `9+6+5=20`.\n    Output `t_j`: `3 2 3`.\n    Day 1: `[5, 4, 2]` (indices `0, 1, 2`). Max `5` (which is `a[0]`). Length `3`.\n    Day 2: `[6, 5]` (indices `3, 4`). Max `6` (which is `a[3]`). Length `2`.\n    Day 3: `[1, 9, 2]` (indices `5, 6, 7`). Max `9` (which is `a[6]`). Length `3`.\n\n    Notice that the chosen indices `0, 3, 6` are each contained within one day's segment, and are the maximum for that segment.\n    The cuts are after index `2` and after index `4`.\n    The sorted pivot indices are `p'_0=0, p'_1=3, p'_2=6`.\n    The cuts are NOT at `p'_0, p'_1`. They are at `p'_0 + (something)`, `p'_1 + (something)`.\n    The cuts are at `p'_0 + 2`, `p'_1 + 1`.\n\n    The key is that we have `k` special problems `a[p'_0], \\dots, a[p'_{k-1}]`. Each of these *must* be the maximum of one day.\n    To ensure this, we can make `k-1` cuts. These cuts must be placed such that each `p'_j` is the maximum of its segment. The simplest way to achieve this is to make `p'_j` the *last* element of its segment.\n    So, the segments *must* end at `p'_0, p'_1, \\dots, p'_{k-1}`.\n    But this would only work if `k=n`. If `k < n`, then segments can contain problems that are not one of the `k` largest problems.\n    The `k` special problems `a[p'_0], \\dots, a[p'_{k-1}]` must be the maximums for their respective days.\n    This means we need to make `k-1` cuts. The indices of these cuts will be `c_0, c_1, \\dots, c_{k-2}`.\n    The segments are `[0 \\dots c_0]`, `[c_0+1 \\dots c_1]`, ..., `[c_{k-2}+1 \\dots n-1]`.\n    Each `p'_j` must fall into one of these segments.\n    And for each segment `[start, end]`, `max(a[start \\dots end])` must be one of the `a[p'_j]` values.\n\n    The simplest way to achieve this is to make cuts *after* `k-1` of the `k` special problems.\n    Let `p'_0, p'_1, \\dots, p'_{k-1}` be the sorted indices of the `k` problems with largest difficulties.\n    We make cuts at `p'_0, p'_1, \\dots, p'_{k-2}`.\n    The problem segments are:\n    1. `[0, p'_0]`\n    2. `[p'_0+1, p'_1]`\n    ...\n    `k-1`. `[p'_{k-2}+1, p'_{k-1}]`\n    `k`. `[p'_{k-1}+1, n-1]`\n\n    This creates `k` segments.\n    The profit for segment `j` (for `j=1 \\dots k-1`) is `a[p'_{j-1}]`.\n    The profit for segment `k` is `max(a[p'_{k-1}+1 \\dots n-1])`.\n    This is not correct because the sum of profits would be `sum(a[p'_0 \\dots p'_{k-1}]) + max(a[p'_{k-1}+1 \\dots n-1]) - a[p'_{k-1}]`.\n    This implies that `a[p'_{k-1}]` is counted as a profit, but the actual profit for day `k` is `max(a[p'_{k-1}+1 \\dots n-1])`.\n    This also doesn't ensure that `a[p'_{k-1}]` is the max of *some* day.\n\n    The correct strategy for setting `t_j` values:\n    1.  Get the `k` largest difficulties and their original indices.\n    2.  Calculate the total profit `S` (sum of these `k` difficulties).\n    3.  Collect the *original indices* of these `k` problems into a list. Let's call it `cut_indices`.\n    4.  Sort `cut_indices` in ascending order.\n    5.  The `k-1` actual cut points will be `cut_indices[0], cut_indices[1], \\dots, cut_indices[k-2]`.\n    6.  The number of problems for each day `t_j` are determined by these cut points.\n        `t_1 = cut_indices[0] + 1` (problems from index `0` up to `cut_indices[0]`)\n        `t_2 = cut_indices[1] - cut_indices[0]` (problems from `cut_indices[0]+1` up to `cut_indices[1]`)\n        ...\n        `t_{k-1} = cut_indices[k-2] - cut_indices[k-3]`\n        `t_k = n - (cut_indices[k-2] + 1)` (problems from `cut_indices[k-2]+1` up to `n-1`)\n\n    This logic is still flawed for the last segment. It implies that `cut_indices[k-1]` is not necessarily the max of the last segment.\n\n    Let's re-evaluate the example: `a = [5, 4, 2, 6, 5, 1, 9, 2]`, `k = 3`.\n    Top 3 values: `(9,6), (6,3), (5,0)`. Sum = `20`.\n    Indices: `0, 3, 6`. Sorted: `[0, 3, 6]`.\n    We need `k-1 = 2` cuts.\n    The example output `3 2 3` implies cuts after index `2` and index `4`.\n    The `cut_indices` are `0, 3, 6`.\n    The segments are `[0,2]`, `[3,4]`, `[5,7]`.\n    Notice that `0` is in `[0,2]`, `3` is in `[3,4]`, `6` is in `[5,7]`.\n    And `a[0]=5` is max of `[5,4,2]`.\n    `a[3]=6` is max of `[6,5]`.\n    `a[6]=9` is max of `[1,9,2]`.\n    This confirms the strategy: each of the `k` chosen problems `a[p'_j]` must be the maximum of one day's segment.\n\n    The actual cuts should be determined by the `k-1` *smallest* indices among `p'_0, \\dots, p'_{k-1}`.\n    No, this is wrong. The example output uses `0, 3, 6` as the indices of the max elements.\n    The cuts are at `2` and `4`.\n    `0` is the first index. `2` is the first cut. So `t_1 = 2 - 0 + 1 = 3`.\n    `3` is the next index. `4` is the second cut. So `t_2 = 4 - (2+1) + 1 = 2`.\n    `6` is the last index. `7` is `n-1`. So `t_3 = 7 - (4+1) + 1 = 3`.\n    The `k-1` cuts are placed at indices `c_0, c_1, \\dots, c_{k-2}`.\n    The `t_j` values are:\n    `t_1 = c_0 + 1`\n    `t_2 = c_1 - c_0`\n    ...\n    `t_{k-1} = c_{k-2} - c_{k-3}`\n    `t_k = n - (c_{k-2} + 1)`\n\n    The crucial insight is that the `k` largest problems `a[p'_0], \\dots, a[p'_{k-1}]` (where `p'_j` are sorted original indices) are the problems that will contribute to the total profit. We need to make `k-1` cuts. These cuts should be placed such that each `a[p'_j]` is the maximum of *some* day, and all `k` problems are used exactly once as a day's max.\n    This means we can make the cuts *after* `k-1` of the `k` chosen indices.\n    Specifically, we make cuts at `p'_0, p'_1, \\dots, p'_{k-2}`.\n    The number of problems in each segment:\n    `t_1 = p'_0 + 1`\n    `t_2 = p'_1 - p'_0`\n    ...\n    `t_{k-1} = p'_{k-2} - p'_{k-3}`\n    `t_k = n - (p'_{k-1} + 1) + (p'_{k-1} - p'_{k-2})`\n    No, this is not correct.\n\n    The segments are defined by `k-1` cut points.\n    We have `k` indices `p'_0, p'_1, \\dots, p'_{k-1}`.\n    We must use `k-1` of these indices as cut points.\n    The best way to ensure all `k` largest values are counted is to make the cuts at `p'_0, p'_1, \\dots, p'_{k-2}`.\n    Then the segments are:\n    `[0 \\dots p'_0]`\n    `[p'_0+1 \\dots p'_1]`\n    ...\n    `[p'_{k-2}+1 \\dots n-1]`\n    This creates `k` segments.\n    The lengths are:\n    `t_1 = p'_0 + 1`\n    `t_2 = p'_1 - p'_0`\n    ...\n    `t_{k-1} = p'_{k-2} - p'_{k-3}`\n    `t_k = n - (p'_{k-2} + 1)`\n\n    Let's check `a = [5, 4, 2, 6, 5, 1, 9, 2]`, `k = 3`. Sorted `p'_j`: `[0, 3, 6]`.\n    Cuts at `p'_0=0` and `p'_1=3`.\n    `t_1 = p'_0 + 1 = 0 + 1 = 1`. Segment `[0,0]`. Max `a[0]=5`.\n    `t_2 = p'_1 - p'_0 = 3 - 0 = 3`. Segment `[1,3]`. Max `a[3]=6`.\n    `t_3 = n - (p'_1 + 1) = 8 - (3+1) = 4`. Segment `[4,7]`. Max `a[6]=9`.\n    The lengths are `1, 3, 4`. This sum is `8`.\n    The profits are `5, 6, 9`. Total `20`. This is correct.\n    This matches the profit, but not the example's problem count output (`3 2 3`).\n    The problem says \"If there are many possible answers, you may print any of them.\" So `1 3 4` is a valid answer.\n\n    Let's try the other example: `a = [1, 2000, 2000, 2]`, `k=2`. Sorted `p'_j`: `[1, 2]`.\n    Cuts at `p'_0=1`.\n    `t_1 = p'_0 + 1 = 1 + 1 = 2`. Segment `[0,1]`. Max `a[1]=2000`.\n    `t_2 = n - (p'_0 + 1) = 4 - (1+1) = 2`. Segment `[2,3]`. Max `a[2]=2000`.\n    Lengths `2, 2`. Sum `4`.\n    Profits `2000, 2000`. Total `4000`.\n    This matches the example output exactly.\n\n    This strategy seems robust.\n    1.  Create `(value, index)` pairs.\n    2.  Sort them by value descending.\n    3.  Take the first `k` pairs. Sum their values for total profit.\n    4.  Extract their indices and sort them ascending. Let these be `p'_0, \\dots, p'_{k-1}`.\n    5.  Calculate `t_j`:\n        `t_1 = p'_0 + 1`\n        For `j` from `2` to `k-1`: `t_j = p'_{j-1} - p'_{j-2}`\n        `t_k = n - (p'_{k-2} + 1)` (This is the segment from `p'_{k-2}+1` to `n-1`)\n        Wait, this last `t_k` calculation is wrong. It should be based on `p'_{k-1}`.\n        The segments are `[0 \\dots p'_0]`, `[p'_0+1 \\dots p'_1]`, ..., `[p'_{k-2}+1 \\dots n-1]`.\n        The `k`th segment starts at `p'_{k-2}+1` and ends at `n-1`.\n        This means the lengths are:\n        `t_1 = p'_0 + 1`\n        `t_2 = p'_1 - p'_0`\n        ...\n        `t_{k-1} = p'_{k-1} - p'_{k-2}`\n        `t_k = n - (p'_{k-1} + 1)`\n        This is if we make cuts at `p'_0, p'_1, \\dots, p'_{k-1}`. But we only need `k-1` cuts.\n        The cuts are *after* `p'_0, p'_1, \\dots, p'_{k-2}`.\n        So the end points of the segments are `p'_0, p'_1, \\dots, p'_{k-2}, n-1`.\n        The `t_j` values are:\n        `t_1 = p'_0 + 1`\n        `t_2 = p'_1 - p'_0`\n        ...\n        `t_{k-1} = p'_{k-2} - p'_{k-3}`\n        `t_k = n - (p'_{k-2} + 1)`\n\n    Let's retry the example `a = [5, 4, 2, 6, 5, 1, 9, 2]`, `k = 3`. Sorted `p'_j`: `[0, 3, 6]`.\n    `k-1 = 2` cuts. The indices for cuts are `p'_0=0` and `p'_1=3`.\n    `t_1 = p'_0 + 1 = 0 + 1 = 1`.\n    `t_2 = p'_1 - p'_0 = 3 - 0 = 3`.\n    `t_3 = n - (p'_1 + 1) = 8 - (3 + 1) = 4`.\n    Result: `1 3 4`. This is a valid output.\n\n    The general algorithm:\n    1. Read `n`, `k`.\n    2. Read list `a`.\n    3. Create a list of `(difficulty, original_index)` pairs: `indexed_a = [(a[i], i) for i in range(n)]`.\n    4. Sort `indexed_a` by difficulty in descending order.\n    5. Select the first `k` elements from the sorted list: `top_k_problems = indexed_a[:k]`.\n    6. Calculate `max_profit = sum(p[0] for p in top_k_problems)`.\n    7. Extract the original indices of these `k` problems: `pivot_indices = sorted([p[1] for p in top_k_problems])`.\n    8. Initialize `day_lengths = []` and `current_start_idx = 0`.\n    9. Iterate `j` from `0` to `k-2` (for the first `k-1` days based on `k-1` pivot indices):\n        `end_idx = pivot_indices[j]`\n        `length = end_idx - current_start_idx + 1`\n        `day_lengths.append(length)`\n        `current_start_idx = end_idx + 1`\n    10. For the last day (`k`-th day):\n        `length = n - current_start_idx`\n        `day_lengths.append(length)`\n    11. Print `max_profit`.\n    12. Print `day_lengths` separated by spaces.\n\n    Let's check the constraint `t_j > 0`.\n    `p'_j` are distinct and sorted.\n    `t_1 = p'_0 + 1 >= 0 + 1 = 1`. (Since `p'_0 >= 0`)\n    `t_j = p'_{j-1} - p'_{j-2}` for `j=2 \\dots k-1`. Since `p'_{j-1} > p'_{j-2}`, `t_j >= 1`.\n    `t_k = n - (p'_{k-2} + 1)`.\n    The sum of `t_1 + \\dots + t_{k-1}` is `(p'_0+1) + (p'_1-p'_0) + \\dots + (p'_{k-2}-p'_{k-3}) = p'_{k-2} + 1`.\n    So `t_k = n - (p'_{k-2} + 1)`.\n    The sum of all `t_j` is `(p'_{k-2} + 1) + (n - (p'_{k-2} + 1)) = n`.\n    This means `t_k` must be at least 1.\n    Since `p'_{k-2}` is an index of one of the `k` largest problems, and `p'_{k-1}` is another one (and `p'_{k-1} > p'_{k-2}`), there must be at least one problem after `p'_{k-2}` that is `p'_{k-1}`.\n    So `p'_{k-2} < n-1` if `k < n`.\n    If `k=n`, then `pivot_indices` will be `[0, 1, \\dots, n-1]`.\n    `k-1` iterations: `j` from `0` to `n-2`.\n    `t_j = p'_j - p'_{j-1}` (for `j > 0`).\n    `t_1 = p'_0 + 1 = 0 + 1 = 1`.\n    `t_2 = p'_1 - p'_0 = 1 - 0 = 1`.\n    ...\n    `t_{n-1} = p'_{n-2} - p'_{n-3} = (n-2) - (n-3) = 1`.\n    Last day `t_n = n - (p'_{n-2} + 1) = n - ((n-2)+1) = n - (n-1) = 1`.\n    So all `t_j=1` for `k=n`, which is correct.\n\nThis algorithm seems correct and covers all cases.\nComplexity:\n- Creating `indexed_a`: O(N)\n- Sorting `indexed_a`: O(N log N)\n- Selecting top `k` and summing: O(k)\n- Extracting and sorting `pivot_indices`: O(k log k)\n- Calculating `day_lengths`: O(k)\nTotal complexity: O(N log N) due to sorting. Given N <= 2000, N log N is feasible (`2000 * log2(2000) approx 2000 * 11 = 22000`).\n\n```python\nimport sys\n\ndef solve():\n    n, k = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    # Step 1: Create (difficulty, original_index) pairs\n    indexed_a = []\n    for i in range(n):\n        indexed_a.append((a[i], i))\n\n    # Step 2: Sort by difficulty in descending order\n    # If difficulties are equal, the original index doesn't matter for sorting\n    # for the purpose of finding the k largest values.\n    indexed_a.sort(key=lambda x: x[0], reverse=True)\n\n    # Step 3: Select the top k problems\n    top_k_problems = indexed_a[:k]\n\n    # Step 4: Calculate the maximum total profit\n    max_profit = sum(p[0] for p in top_k_problems)\n    print(max_profit)\n\n    # Step 5: Extract and sort the original indices of these k problems\n    pivot_indices = []\n    for p in top_k_problems:\n        pivot_indices.append(p[1])\n    pivot_indices.sort() # Sort in ascending order\n\n    # Step 6: Determine the number of problems for each day (t_j)\n    day_lengths = []\n    current_start_idx = 0\n\n    # The first k-1 segments are defined by the first k-1 pivot indices\n    # Each pivot_indices[j] marks the end of a segment\n    for j in range(k - 1):\n        end_idx = pivot_indices[j]\n        length = end_idx - current_start_idx + 1\n        day_lengths.append(length)\n        current_start_idx = end_idx + 1 # Start of next segment\n\n    # The last segment covers the remaining problems\n    # It starts from current_start_idx and goes to n-1\n    last_day_length = n - current_start_idx\n    day_lengths.append(last_day_length)\n\n    # Step 7: Print the day lengths\n    print(*(day_lengths))\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, k = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    # Step 1: Create (difficulty, original_index) pairs\n    indexed_a = []\n    for i in range(n):\n        indexed_a.append((a[i], i))\n\n    # Step 2: Sort by difficulty in descending order\n    # If difficulties are equal, the original index doesn't matter for sorting\n    # for the purpose of finding the k largest values.\n    indexed_a.sort(key=lambda x: x[0], reverse=True)\n\n    # Step 3: Select the top k problems\n    top_k_problems = indexed_a[:k]\n\n    # Step 4: Calculate the maximum total profit\n    max_profit = sum(p[0] for p in top_k_problems)\n    print(max_profit)\n\n    # Step 5: Extract and sort the original indices of these k problems\n    pivot_indices = []\n    for p in top_k_problems:\n        pivot_indices.append(p[1])\n    pivot_indices.sort() # Sort in ascending order\n\n    # Step 6: Determine the number of problems for each day (t_j)\n    day_lengths = []\n    current_start_idx = 0\n\n    # The first k-1 segments are defined by the first k-1 pivot indices\n    # Each pivot_indices[j] marks the end of a segment\n    for j in range(k - 1):\n        end_idx = pivot_indices[j]\n        length = end_idx - current_start_idx + 1\n        day_lengths.append(length)\n        current_start_idx = end_idx + 1 # Start of next segment\n\n    # The last segment covers the remaining problems\n    # It starts from current_start_idx and goes to n-1\n    last_day_length = n - current_start_idx\n    day_lengths.append(last_day_length)\n\n    # Step 7: Print the day lengths\n    print(*(day_lengths))\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 973,
        "completion_token_count": 7485,
        "thoughts_token_count": 8190
    }
}