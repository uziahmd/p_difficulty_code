{
    "start": 1758015866.108382,
    "end": 1758015999.0135024,
    "start-formatted": "2025-09-16 18:44 KST",
    "end-formatted": "2025-09-16 18:46 KST",
    "gpu": 2,
    "pid": 8,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "",
    "response": "```python\nimport sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    edges_data = []\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n        edges_data.append((u, v, c))\n\n    ans = [-1] * m\n    \n    # Calculate total flow out of source\n    total_flow_out_of_source = 0\n    for neighbor, capacity, edge_idx in adj[1]:\n        total_flow_out_of_source += capacity\n\n    # Use a stack for DFS\n    stack = [(1, -1)]  # (current_node, parent_node_in_DFS_tree)\n    visited = [False] * (n + 1)\n    \n    # For each node, store the sum of capacities of edges directed *towards* it\n    # in the current DFS path, considering only edges whose direction is determined.\n    # This is effectively the \"unbalanced\" flow that needs to be balanced by edges\n    # connected to the current node but not yet processed.\n    # For the source (node 1), this is the total flow *out* of it.\n    \n    # We'll use an array `current_balance` to store the net flow into a node\n    # from edges whose direction has been determined.\n    # A positive value means flow is coming *into* the node.\n    # A negative value means flow is going *out of* the node.\n    current_balance = [0] * (n + 1)\n    current_balance[1] = total_flow_out_of_source # Initial flow out of source\n\n    # This is a modified DFS traversal. We want to process nodes in a way that\n    # when we return from a child to its parent, the child's balance is correct.\n    # This means the parent can then use the child's balance to determine the\n    # direction of the edge between them.\n    \n    # We need to store the DFS tree structure to process nodes in post-order.\n    # parent[u] = (p, edge_idx_to_p)\n    parent_info = [None] * (n + 1)\n    dfs_order = [] # Stores nodes in DFS discovery order\n\n    q = [(1, -1, -1)] # (node, parent_node, edge_index_to_parent)\n    dfs_stack = []\n\n    # Build DFS tree and record parent information\n    dfs_stack.append((1, -1, -1)) # (node, parent_node, edge_index_to_parent)\n    visited_dfs_tree = [False] * (n + 1)\n    \n    while dfs_stack:\n        u, p, edge_idx_to_p = dfs_stack.pop()\n\n        if visited_dfs_tree[u]:\n            continue\n        visited_dfs_tree[u] = True\n        dfs_order.append(u)\n        parent_info[u] = (p, edge_idx_to_p)\n\n        for v, c, edge_idx in adj[u]:\n            if v != p and not visited_dfs_tree[v]:\n                dfs_stack.append((v, u, edge_idx))\n    \n    # Process nodes in reverse DFS order (post-order traversal)\n    # This ensures that when we process a node `u`, all its children in the DFS tree\n    # have already been processed, and their `current_balance` values are finalized\n    # with respect to their subtrees.\n    \n    # The balance for node `u` will represent the net flow *into* `u` from its subtree\n    # (including `u` itself).\n    \n    for u in reversed(dfs_order):\n        if u == 1: # Source node, its balance is already set to total flow out.\n            continue\n        \n        # For non-source, non-sink nodes (1 < u < n), the net flow must be 0.\n        # For the sink node (u = n), the net flow into it must be equal to the total flow.\n        \n        # If u is the sink, its balance will be the total flow into it.\n        # If u is an intermediate node, its balance should become 0.\n        # The balance `current_balance[u]` initially only accounts for flow from its children.\n        # The edge connecting `u` to its parent `p` will be used to balance `u`'s flow.\n        \n        p, edge_idx_to_p = parent_info[u]\n        \n        # Determine direction of edge (p, u)\n        # If current_balance[u] is positive, it means there's a net flow *into* u from its subtree.\n        # To balance this, flow must go *out* of u towards p. So p <- u.\n        # If current_balance[u] is negative, it means there's a net flow *out of* u from its subtree.\n        # To balance this, flow must go *into* u from p. So p -> u.\n        # The only exception is the sink node 'n'. For 'n', current_balance[n] will be the\n        # total flow, which is positive. The edge (p, n) must carry flow p -> n.\n        \n        # The problem statement says for 1 < v < n, sum of incoming = sum of outgoing.\n        # This means `current_balance[v]` should be 0 after processing `v` and its parent edge.\n        \n        # For the sink node `n`, `current_balance[n]` will be the total flow that needs to\n        # exit the graph at `n`. This flow must come from its parent.\n        \n        # `current_balance[u]` currently holds the sum of flows from edges within its DFS subtree\n        # that are directed towards `u`, minus flows directed away from `u`.\n        # This includes flows from its children to `u`, and any \"cross-edges\" within its subtree.\n        \n        # Let's refine `current_balance[u]` definition:\n        # It's the sum of `c_i` for edges (x,y) in u's DFS subtree where x->y and y is in subtree,\n        # minus `c_i` for edges (x,y) in u's DFS subtree where x->y and x is in subtree.\n        # This means `current_balance[u]` is the net flow *out* of the subtree rooted at `u`\n        # through the edge (u, p).\n        \n        # When we process `u` in reverse DFS order:\n        # `current_balance[u]` accumulates the net flow from its children.\n        # For each child `v` of `u`, `current_balance[v]` represents the net flow that needs to\n        # go *out* of `v`'s subtree towards `u`.\n        # So, `current_balance[u]` should be updated by adding `current_balance[v]` for each child `v`.\n        \n        # Let's redefine `current_balance[u]` to be the \"excess flow\" at node `u`.\n        # Initially, `current_balance[1]` = total flow out. All others 0.\n        # When processing edge (u, v) with capacity `c` where `v` is a child of `u`:\n        # If flow goes u -> v, then `current_balance[u]` decreases by `c`, `current_balance[v]` increases by `c`.\n        # If flow goes v -> u, then `current_balance[u]` increases by `c`, `current_balance[v]` decreases by `c`.\n\n        # The key is that for any node `u` (1 < u < n), its net flow must be 0.\n        # For node `n`, its net flow must be equal to the total flow.\n        \n        # Let's use `excess[u]` to denote the sum of `c_i` for edges directed *into* `u`\n        # minus sum of `c_i` for edges directed *out of* `u`, considering only edges\n        # that are already assigned a direction.\n        # Initially, `excess[1] = -total_flow_out_of_source` (total flow *out* of 1).\n        # All other `excess[u] = 0`.\n        \n        # When we process `u` in post-order:\n        # All edges within `u`'s subtree (not connecting to `p`) have already been assigned directions.\n        # So `excess[u]` currently reflects the net flow from `u`'s children and internal subtree edges.\n        # We need to determine the direction of the edge (p, u) to make `excess[u]` correct.\n        \n        # If `u == n`:\n        # `excess[n]` should be equal to the total flow out of source.\n        # `excess[n]` currently holds the sum of flows from its children towards `n`\n        # minus flows from `n` towards its children.\n        # The remaining flow `total_flow_out_of_source - excess[n]` must come from `p`.\n        # So, `p -> n`.\n        # The amount of flow is `total_flow_out_of_source - excess[n]`. This must be `c_edge(p,n)`.\n        # The problem statement says `excess[n]` must equal `total_flow_out_of_source`.\n        # This implies that `excess[n]` is the net flow into `n` from all its neighbors *except* `p`.\n        # No, this is incorrect. `excess[n]` is the net flow into `n` from its *subtree*.\n        \n        # Let's restart the definition of `current_balance`.\n        # `current_balance[u]` will represent the net flow *out* of node `u` that still needs to be balanced.\n        # Initially, `current_balance[1] = total_flow_out_of_source`.\n        # For other nodes `u`, `current_balance[u] = 0`.\n        \n        # When we process `u` in reverse DFS order (post-order):\n        # All children `v` of `u` have been processed.\n        # `current_balance[v]` represents the net flow *out* of `v`'s subtree that must pass through the edge (v, u).\n        # So, for each child `v` of `u`, the flow on (v, u) must be `current_balance[v]`.\n        # This means flow goes `v -> u`.\n        # So, `current_balance[u]` increases by `current_balance[v]`.\n        # And `current_balance[v]` becomes 0 (balanced).\n        \n        # This is a bit confusing. Let's use the definition from a common max-flow reconstruction technique:\n        # `balance[u]` = sum of capacities of edges directed *into* `u` - sum of capacities of edges directed *out of* `u`.\n        # For `1 < u < n`, `balance[u]` must be 0.\n        # For `u = 1`, `balance[1]` must be `-TotalFlow`.\n        # For `u = n`, `balance[n]` must be `TotalFlow`.\n        \n        # We can use a DFS from the source (node 1) to build a spanning tree.\n        # Then process nodes in post-order (children before parent).\n        # For each node `u` (starting from leaves up to children of source):\n        # Calculate `current_in_flow[u]` and `current_out_flow[u]` from its children and cross-edges.\n        # The remaining flow `needed_flow` must pass through the edge connecting `u` to its parent `p`.\n        # If `u != n`, `needed_flow` = `current_out_flow[u] - current_in_flow[u]`.\n        # If `needed_flow > 0`, then flow `u -> p`.\n        # If `needed_flow < 0`, then flow `p -> u`.\n        # If `needed_flow = 0`, direction doesn't matter for balance, but problem implies it must be consistent.\n        # The problem guarantees a solution exists, so `needed_flow` will be consistent.\n        \n        # Let `net_flow_into_node[u]` store the net flow into `u` from edges whose directions have been determined.\n        # Initialize `net_flow_into_node = [0] * (n + 1)`.\n        \n        # For the source node 1, we want all its edges to be outgoing.\n        # For the sink node n, we want all its edges to be incoming.\n        \n        # The problem statement:\n        # 1. For each vertex v (1 < v < n), sum of incoming = sum of outgoing.\n        # 2. Vertex 1 has no incoming edges.\n        # 3. The obtained directed graph does not have cycles.\n        \n        # Condition 2 means all edges connected to 1 must be 1 -> neighbor.\n        # We can set these directions first.\n        # For each edge (1, v, c) with index `idx`:\n        # `ans[idx] = 0` (1 -> v).\n        # `net_flow_into_node[v]` += `c`.\n        \n        # After setting source edges, we have a partially directed graph.\n        # `net_flow_into_node[u]` is the net flow into `u` from edges whose direction is fixed.\n        # Now, we need to determine the direction of remaining edges.\n        \n        # The \"no cycles\" condition suggests a topological sort or DFS-based approach.\n        # Since we're given an undirected graph, a DFS tree is a natural choice.\n        \n        # Let's use `balance[u]` to track the sum of capacities of edges directed *into* `u` minus\n        # sum of capacities of edges directed *out of* `u`, for edges whose directions are determined.\n        # Initially `balance[u] = 0` for all `u`.\n        \n        # `dfs_order` contains nodes in the order they are visited.\n        # We process nodes in `reversed(dfs_order)` (post-order traversal).\n        \n        # For each node `u` in reversed DFS order:\n        # If `u` is the source (1), skip. Its edges are handled by children.\n        # Get parent `p` of `u` and edge index `edge_idx_to_p`.\n        # Let `c_pu` be the capacity of edge (p, u).\n        \n        # If `u == n` (sink):\n        # All flow must eventually reach `n`. The net flow into `n` from its subtree\n        # (via its children and internal edges) is `balance[n]`.\n        # The total flow is `total_flow_out_of_source`.\n        # The remaining flow `total_flow_out_of_source - balance[n]` must come from `p`.\n        # So, `p -> n`.\n        # `ans[edge_idx_to_p]` = 0 if `edges_data[edge_idx_to_p]` is (p, n, c_pu), else 1.\n        # `balance[p]` -= `c_pu` (flow goes out of p).\n        # `balance[n]` += `c_pu` (flow goes into n).\n        \n        # If `1 < u < n` (intermediate node):\n        # `balance[u]` must be 0.\n        # The current `balance[u]` reflects the net flow from `u`'s children and internal edges.\n        # If `balance[u] > 0`, it means there's a net flow *into* `u`. To balance, flow must go `u -> p`.\n        # If `balance[u] < 0`, it means there's a net flow *out of* `u`. To balance, flow must go `p -> u`.\n        # If `balance[u] == 0`, the problem implies a unique direction or any is fine.\n        # The condition \"no cycles\" implies a specific direction.\n        # Since we are processing in post-order, `u` is processed before `p`.\n        # If `balance[u]` is not zero, the edge (p, u) must carry flow to make `balance[u]` zero.\n        # If `balance[u] > 0`: `u -> p`. `ans[edge_idx_to_p]` is 0 if `edges_data[edge_idx_to_p]` is (u, p, c_pu), else 1.\n        #   `balance[p]` -= `c_pu`.\n        #   `balance[u]` -= `c_pu`. (now `balance[u]` is 0)\n        # If `balance[u] < 0`: `p -> u`. `ans[edge_idx_to_p]` is 0 if `edges_data[edge_idx_to_p]` is (p, u, c_pu), else 1.\n        #   `balance[p]` += `c_pu`.\n        #   `balance[u]` += `c_pu`. (now `balance[u]` is 0)\n        \n        # This approach seems correct for intermediate nodes.\n        # What about the source? The source (node 1) should have `balance[1] = -total_flow_out_of_source`.\n        # After processing all its children, `balance[1]` should reflect this.\n\n    # Let's try again with `balance[u]` meaning: sum of capacities of edges directed *into* `u`\n    # minus sum of capacities of edges directed *out of* `u`.\n    # Target: `balance[1] = -total_flow_out_of_source`, `balance[n] = total_flow_out_of_source`, `balance[v] = 0` for `1 < v < n`.\n\n    balance = [0] * (n + 1)\n    \n    # DFS to build tree and record parent edges\n    parent_edge_info = [None] * (n + 1) # (parent_node, edge_index_to_parent, capacity)\n    dfs_stack = []\n    visited = [False] * (n + 1)\n    \n    dfs_stack.append((1, -1, -1, -1)) # (node, parent, edge_idx, capacity_to_parent)\n    dfs_nodes_in_order = []\n\n    while dfs_stack:\n        u, p, edge_idx_to_p, capacity_to_p = dfs_stack.pop()\n        \n        if visited[u]:\n            continue\n        visited[u] = True\n        dfs_nodes_in_order.append(u)\n        parent_edge_info[u] = (p, edge_idx_to_p, capacity_to_p)\n\n        for v, c, edge_idx in adj[u]:\n            if not visited[v]:\n                dfs_stack.append((v, u, edge_idx, c))\n\n    # Process nodes in reverse DFS order (post-order)\n    for u in reversed(dfs_nodes_in_order):\n        if u == 1: # Source node, handled by its children\n            continue\n        \n        p, edge_idx_to_p, c_pu = parent_edge_info[u]\n        \n        if u == n: # Sink node\n            # The net flow into the sink must be `total_flow_out_of_source`.\n            # `balance[n]` currently holds the net flow into `n` from its children and cross-edges.\n            # The remaining flow `total_flow_out_of_source - balance[n]` must come from `p`.\n            # This implies `p -> n`.\n            # The capacity of edge (p, u) is `c_pu`.\n            # The flow `total_flow_out_of_source` is the total flow.\n            # So, `p -> n` must be the direction.\n            \n            # Determine direction for edge (p, u)\n            original_u, original_v, _ = edges_data[edge_idx_to_p]\n            if original_u == p and original_v == u:\n                ans[edge_idx_to_p] = 0 # p -> u\n            else: # original_u == u and original_v == p\n                ans[edge_idx_to_p] = 1 # p -> u\n            \n            # Update balances\n            balance[p] -= c_pu # Flow goes out of p\n            balance[u] += c_pu # Flow goes into u\n            \n        else: # Intermediate node (1 < u < n)\n            # For intermediate nodes, `balance[u]` must be 0.\n            # `balance[u]` currently holds the net flow into `u` from its children and cross-edges.\n            # This flow needs to be balanced by the edge (p, u).\n            \n            original_u, original_v, _ = edges_data[edge_idx_to_p]\n            \n            if balance[u] > 0: # Net flow into u is positive, so flow must go u -> p\n                if original_u == u and original_v == p:\n                    ans[edge_idx_to_p] = 0 # u -> p\n                else: # original_u == p and original_v == u\n                    ans[edge_idx_to_p] = 1 # u -> p\n                \n                balance[p] += c_pu # Flow goes into p\n                balance[u] -= c_pu # Flow goes out of u (now balance[u] should be 0)\n                \n            elif balance[u] < 0: # Net flow out of u is positive, so flow must go p -> u\n                if original_u == p and original_v == u:\n                    ans[edge_idx_to_p] = 0 # p -> u\n                else: # original_u == u and original_v == p\n                    ans[edge_idx_to_p] = 1 # p -> u\n                \n                balance[p] -= c_pu # Flow goes out of p\n                balance[u] += c_pu # Flow goes into u (now balance[u] should be 0)\n            else: # balance[u] == 0. This implies the flow on (p, u) is 0.\n                  # This case should not happen if all capacities are positive and a valid flow exists.\n                  # If it does happen, any direction for (p,u) is fine for balance.\n                  # To avoid cycles, we can make it p -> u (towards the source).\n                  # Or, for consistency with the problem structure (flow from 1 to n),\n                  # we could try to direct it away from the source if possible.\n                  # A simpler heuristic for 0-flow edges in a tree is to direct away from root.\n                  # So, p -> u.\n                if original_u == p and original_v == u:\n                    ans[edge_idx_to_p] = 0 # p -> u\n                else: # original_u == u and original_v == p\n                    ans[edge_idx_to_p] = 1 # p -> u\n                \n                balance[p] -= c_pu # Flow goes out of p\n                balance[u] += c_pu # Flow goes into u\n                \n            # After determining direction, balance[u] should become 0.\n            # If it's not 0, there's an issue with logic or problem understanding.\n            # For the problem constraints, it should become 0.\n\n    # After the loop, balance[1] should be -total_flow_out_of_source.\n    # balance[n] should be total_flow_out_of_source.\n    # All other balance[u] should be 0.\n\n    for result in ans:\n        sys.stdout.write(str(result) + '\\n')\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    edges_data = []\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n        edges_data.append((u, v, c))\n\n    ans = [-1] * m\n    \n    # Calculate total flow out of source\n    total_flow_out_of_source = 0\n    for neighbor, capacity, edge_idx in adj[1]:\n        total_flow_out_of_source += capacity\n\n    # Use a stack for DFS\n    stack = [(1, -1)]  # (current_node, parent_node_in_DFS_tree)\n    visited = [False] * (n + 1)\n    \n    # For each node, store the sum of capacities of edges directed *towards* it\n    # in the current DFS path, considering only edges whose direction is determined.\n    # This is effectively the \"unbalanced\" flow that needs to be balanced by edges\n    # connected to the current node but not yet processed.\n    # For the source (node 1), this is the total flow *out* of it.\n    \n    # We'll use an array `current_balance` to store the net flow into a node\n    # from edges whose direction has been determined.\n    # A positive value means flow is coming *into* the node.\n    # A negative value means flow is going *out of* the node.\n    current_balance = [0] * (n + 1)\n    current_balance[1] = total_flow_out_of_source # Initial flow out of source\n\n    # This is a modified DFS traversal. We want to process nodes in a way that\n    # when we return from a child to its parent, the child's balance is correct.\n    # This means the parent can then use the child's balance to determine the\n    # direction of the edge between them.\n    \n    # We need to store the DFS tree structure to process nodes in post-order.\n    # parent[u] = (p, edge_idx_to_p)\n    parent_info = [None] * (n + 1)\n    dfs_order = [] # Stores nodes in DFS discovery order\n\n    q = [(1, -1, -1)] # (node, parent_node, edge_index_to_parent)\n    dfs_stack = []\n\n    # Build DFS tree and record parent information\n    dfs_stack.append((1, -1, -1)) # (node, parent_node, edge_index_to_parent)\n    visited_dfs_tree = [False] * (n + 1)\n    \n    while dfs_stack:\n        u, p, edge_idx_to_p = dfs_stack.pop()\n\n        if visited_dfs_tree[u]:\n            continue\n        visited_dfs_tree[u] = True\n        dfs_order.append(u)\n        parent_info[u] = (p, edge_idx_to_p)\n\n        for v, c, edge_idx in adj[u]:\n            if v != p and not visited_dfs_tree[v]:\n                dfs_stack.append((v, u, edge_idx))\n    \n    # Process nodes in reverse DFS order (post-order traversal)\n    # This ensures that when we process a node `u`, all its children in the DFS tree\n    # have already been processed, and their `current_balance` values are finalized\n    # with respect to their subtrees.\n    \n    # The balance for node `u` will represent the net flow *into* `u` from its subtree\n    # (including `u` itself).\n    \n    for u in reversed(dfs_order):\n        if u == 1: # Source node, its balance is already set to total flow out.\n            continue\n        \n        # For non-source, non-sink nodes (1 < u < n), the net flow must be 0.\n        # For the sink node (u = n), the net flow into it must be equal to the total flow.\n        \n        # If u is the sink, its balance will be the total flow into it.\n        # If u is an intermediate node, its balance should become 0.\n        # The balance `current_balance[u]` initially only accounts for flow from its children.\n        # The edge connecting `u` to its parent `p` will be used to balance `u`'s flow.\n        \n        p, edge_idx_to_p = parent_info[u]\n        \n        # Determine direction of edge (p, u)\n        # If current_balance[u] is positive, it means there's a net flow *into* u from its subtree.\n        # To balance this, flow must go *out* of u towards p. So p <- u.\n        # If current_balance[u] is negative, it means there's a net flow *out of* u from its subtree.\n        # To balance this, flow must go *into* u from p. So p -> u.\n        # The only exception is the sink node 'n'. For 'n', current_balance[n] will be the\n        # total flow, which is positive. The edge (p, n) must carry flow p -> n.\n        \n        # The problem statement says for 1 < v < n, sum of incoming = sum of outgoing.\n        # This means `current_balance[v]` should be 0 after processing `v` and its parent edge.\n        \n        # For the sink node `n`, `current_balance[n]` will be the total flow that needs to\n        # exit the graph at `n`. This flow must come from its parent.\n        \n        # `current_balance[u]` currently holds the sum of flows from edges within its DFS subtree\n        # that are directed towards `u`, minus flows directed away from `u`.\n        # This includes flows from its children to `u`, and any \"cross-edges\" within its subtree.\n        \n        # Let's refine `current_balance[u]` definition:\n        # It's the sum of `c_i` for edges (x,y) in u's DFS subtree where x->y and y is in subtree,\n        # minus `c_i` for edges (x,y) in u's DFS subtree where x->y and x is in subtree.\n        # This means `current_balance[u]` is the net flow *out* of the subtree rooted at `u`\n        # through the edge (u, p).\n        \n        # When we process `u` in reverse DFS order:\n        # `current_balance[u]` accumulates the net flow from its children.\n        # For each child `v` of `u`, `current_balance[v]` represents the net flow that needs to\n        # go *out* of `v`'s subtree towards `u`.\n        # So, `current_balance[u]` should be updated by adding `current_balance[v]` for each child `v`.\n        \n        # Let's redefine `current_balance[u]` to be the \"excess flow\" at node `u`.\n        # Initially, `current_balance[1]` = total flow out. All others 0.\n        # When processing edge (u, v) with capacity `c` where `v` is a child of `u`:\n        # If flow goes u -> v, then `current_balance[u]` decreases by `c`, `current_balance[v]` increases by `c`.\n        # If flow goes v -> u, then `current_balance[u]` increases by `c`, `current_balance[v]` decreases by `c`.\n\n        # The key is that for any node `u` (1 < u < n), its net flow must be 0.\n        # For node `n`, its net flow must be equal to the total flow.\n        \n        # Let's use `excess[u]` to denote the sum of `c_i` for edges directed *into* `u`\n        # minus sum of `c_i` for edges directed *out of* `u`, considering only edges\n        # that are already assigned a direction.\n        # Initially, `excess[1] = -total_flow_out_of_source` (total flow *out* of 1).\n        # All other `excess[u] = 0`.\n        \n        # When we process `u` in post-order:\n        # All edges within `u`'s subtree (not connecting to `p`) have already been assigned directions.\n        # So `excess[u]` currently reflects the net flow from `u`'s children and internal subtree edges.\n        # We need to determine the direction of the edge (p, u) to make `excess[u]` correct.\n        \n        # If `u == n`:\n        # `excess[n]` should be equal to the total flow out of source.\n        # `excess[n]` currently holds the sum of flows from its children towards `n`\n        # minus flows from `n` towards its children.\n        # The remaining flow `total_flow_out_of_source - excess[n]` must come from `p`.\n        # So, `p -> n`.\n        # The amount of flow is `total_flow_out_of_source - excess[n]`. This must be `c_edge(p,n)`.\n        # The problem statement says `excess[n]` must equal `total_flow_out_of_source`.\n        # This implies that `excess[n]` is the net flow into `n` from all its neighbors *except* `p`.\n        # No, this is incorrect. `excess[n]` is the net flow into `n` from its *subtree*.\n        \n        # Let's restart the definition of `current_balance`.\n        # `current_balance[u]` will represent the net flow *out* of node `u` that still needs to be balanced.\n        # Initially, `current_balance[1] = total_flow_out_of_source`.\n        # For other nodes `u`, `current_balance[u] = 0`.\n        \n        # When we process `u` in reverse DFS order (post-order):\n        # All children `v` of `u` have been processed.\n        # `current_balance[v]` represents the net flow *out* of `v`'s subtree that must pass through the edge (v, u).\n        # So, for each child `v` of `u`, the flow on (v, u) must be `current_balance[v]`.\n        # This means flow goes `v -> u`.\n        # So, `current_balance[u]` increases by `current_balance[v]`.\n        # And `current_balance[v]` becomes 0 (balanced).\n        \n        # This is a bit confusing. Let's use the definition from a common max-flow reconstruction technique:\n        # `balance[u]` = sum of capacities of edges directed *into* `u` - sum of capacities of edges directed *out of* `u`.\n        # For `1 < u < n`, `balance[u]` must be 0.\n        # For `u = 1`, `balance[1]` must be `-TotalFlow`.\n        # For `u = n`, `balance[n]` must be `TotalFlow`.\n        \n        # We can use a DFS from the source (node 1) to build a spanning tree.\n        # Then process nodes in post-order (children before parent).\n        # For each node `u` (starting from leaves up to children of source):\n        # Calculate `current_in_flow[u]` and `current_out_flow[u]` from its children and cross-edges.\n        # The remaining flow `needed_flow` must pass through the edge connecting `u` to its parent `p`.\n        # If `u != n`, `needed_flow` = `current_out_flow[u] - current_in_flow[u]`.\n        # If `needed_flow > 0`, then flow `u -> p`.\n        # If `needed_flow < 0`, then flow `p -> u`.\n        # If `needed_flow = 0`, direction doesn't matter for balance, but problem implies it must be consistent.\n        # The problem guarantees a solution exists, so `needed_flow` will be consistent.\n        \n        # Let `net_flow_into_node[u]` store the net flow into `u` from edges whose directions have been determined.\n        # Initialize `net_flow_into_node = [0] * (n + 1)`.\n        \n        # For the source node 1, we want all its edges to be outgoing.\n        # For the sink node n, we want all its edges to be incoming.\n        \n        # The problem statement:\n        # 1. For each vertex v (1 < v < n), sum of incoming = sum of outgoing.\n        # 2. Vertex 1 has no incoming edges.\n        # 3. The obtained directed graph does not have cycles.\n        \n        # Condition 2 means all edges connected to 1 must be 1 -> neighbor.\n        # We can set these directions first.\n        # For each edge (1, v, c) with index `idx`:\n        # `ans[idx] = 0` (1 -> v).\n        # `net_flow_into_node[v]` += `c`.\n        \n        # After setting source edges, we have a partially directed graph.\n        # `net_flow_into_node[u]` is the net flow into `u` from edges whose direction is fixed.\n        # Now, we need to determine the direction of remaining edges.\n        \n        # The \"no cycles\" condition suggests a topological sort or DFS-based approach.\n        # Since we're given an undirected graph, a DFS tree is a natural choice.\n        \n        # Let's use `balance[u]` to track the sum of capacities of edges directed *into* `u` minus\n        # sum of capacities of edges directed *out of* `u`, for edges whose directions are determined.\n        # Initially `balance[u] = 0` for all `u`.\n        \n        # `dfs_order` contains nodes in the order they are visited.\n        # We process nodes in `reversed(dfs_order)` (post-order traversal).\n        \n        # For each node `u` in reversed DFS order:\n        # If `u` is the source (1), skip. Its edges are handled by children.\n        # Get parent `p` of `u` and edge index `edge_idx_to_p`.\n        # Let `c_pu` be the capacity of edge (p, u).\n        \n        # If `u == n` (sink):\n        # All flow must eventually reach `n`. The net flow into `n` from its subtree\n        # (via its children and internal edges) is `balance[n]`.\n        # The total flow is `total_flow_out_of_source`.\n        # The remaining flow `total_flow_out_of_source - balance[n]` must come from `p`.\n        # So, `p -> n`.\n        # `ans[edge_idx_to_p]` = 0 if `edges_data[edge_idx_to_p]` is (p, n, c_pu), else 1.\n        # `balance[p]` -= `c_pu` (flow goes out of p).\n        # `balance[n]` += `c_pu` (flow goes into n).\n        \n        # If `1 < u < n` (intermediate node):\n        # `balance[u]` must be 0.\n        # The current `balance[u]` reflects the net flow from `u`'s children and internal edges.\n        # If `balance[u] > 0`, it means there's a net flow *into* `u`. To balance, flow must go `u -> p`.\n        # If `balance[u] < 0`, it means there's a net flow *out of* `u`. To balance, flow must go `p -> u`.\n        # If `balance[u] == 0`, the problem implies a unique direction or any is fine.\n        # The condition \"no cycles\" implies a specific direction.\n        # Since we are processing in post-order, `u` is processed before `p`.\n        # If `balance[u]` is not zero, the edge (p, u) must carry flow to make `balance[u]` zero.\n        # If `balance[u] > 0`: `u -> p`. `ans[edge_idx_to_p]` is 0 if `edges_data[edge_idx_to_p]` is (u, p, c_pu), else 1.\n        #   `balance[p]` -= `c_pu`.\n        #   `balance[u]` -= `c_pu`. (now `balance[u]` is 0)\n        # If `balance[u] < 0`: `p -> u`. `ans[edge_idx_to_p]` is 0 if `edges_data[edge_idx_to_p]` is (p, u, c_pu), else 1.\n        #   `balance[p]` += `c_pu`.\n        #   `balance[u]` += `c_pu`. (now `balance[u]` is 0)\n        \n        # This approach seems correct for intermediate nodes.\n        # What about the source? The source (node 1) should have `balance[1] = -total_flow_out_of_source`.\n        # After processing all its children, `balance[1]` should reflect this.\n\n    # Let's try again with `balance[u]` meaning: sum of capacities of edges directed *into* `u`\n    # minus sum of capacities of edges directed *out of* `u`.\n    # Target: `balance[1] = -total_flow_out_of_source`, `balance[n] = total_flow_out_of_source`, `balance[v] = 0` for `1 < v < n`.\n\n    balance = [0] * (n + 1)\n    \n    # DFS to build tree and record parent edges\n    parent_edge_info = [None] * (n + 1) # (parent_node, edge_index_to_parent, capacity)\n    dfs_stack = []\n    visited = [False] * (n + 1)\n    \n    dfs_stack.append((1, -1, -1, -1)) # (node, parent, edge_idx, capacity_to_parent)\n    dfs_nodes_in_order = []\n\n    while dfs_stack:\n        u, p, edge_idx_to_p, capacity_to_p = dfs_stack.pop()\n        \n        if visited[u]:\n            continue\n        visited[u] = True\n        dfs_nodes_in_order.append(u)\n        parent_edge_info[u] = (p, edge_idx_to_p, capacity_to_p)\n\n        for v, c, edge_idx in adj[u]:\n            if not visited[v]:\n                dfs_stack.append((v, u, edge_idx, c))\n\n    # Process nodes in reverse DFS order (post-order)\n    for u in reversed(dfs_nodes_in_order):\n        if u == 1: # Source node, handled by its children\n            continue\n        \n        p, edge_idx_to_p, c_pu = parent_edge_info[u]\n        \n        if u == n: # Sink node\n            # The net flow into the sink must be `total_flow_out_of_source`.\n            # `balance[n]` currently holds the net flow into `n` from its children and cross-edges.\n            # The remaining flow `total_flow_out_of_source - balance[n]` must come from `p`.\n            # This implies `p -> n`.\n            # The capacity of edge (p, u) is `c_pu`.\n            # The flow `total_flow_out_of_source` is the total flow.\n            # So, `p -> n` must be the direction.\n            \n            # Determine direction for edge (p, u)\n            original_u, original_v, _ = edges_data[edge_idx_to_p]\n            if original_u == p and original_v == u:\n                ans[edge_idx_to_p] = 0 # p -> u\n            else: # original_u == u and original_v == p\n                ans[edge_idx_to_p] = 1 # p -> u\n            \n            # Update balances\n            balance[p] -= c_pu # Flow goes out of p\n            balance[u] += c_pu # Flow goes into u\n            \n        else: # Intermediate node (1 < u < n)\n            # For intermediate nodes, `balance[u]` must be 0.\n            # `balance[u]` currently holds the net flow into `u` from its children and cross-edges.\n            # This flow needs to be balanced by the edge (p, u).\n            \n            original_u, original_v, _ = edges_data[edge_idx_to_p]\n            \n            if balance[u] > 0: # Net flow into u is positive, so flow must go u -> p\n                if original_u == u and original_v == p:\n                    ans[edge_idx_to_p] = 0 # u -> p\n                else: # original_u == p and original_v == u\n                    ans[edge_idx_to_p] = 1 # u -> p\n                \n                balance[p] += c_pu # Flow goes into p\n                balance[u] -= c_pu # Flow goes out of u (now balance[u] should be 0)\n                \n            elif balance[u] < 0: # Net flow out of u is positive, so flow must go p -> u\n                if original_u == p and original_v == u:\n                    ans[edge_idx_to_p] = 0 # p -> u\n                else: # original_u == u and original_v == p\n                    ans[edge_idx_to_p] = 1 # p -> u\n                \n                balance[p] -= c_pu # Flow goes out of p\n                balance[u] += c_pu # Flow goes into u (now balance[u] should be 0)\n            else: # balance[u] == 0. This implies the flow on (p, u) is 0.\n                  # This case should not happen if all capacities are positive and a valid flow exists.\n                  # If it does happen, any direction for (p,u) is fine for balance.\n                  # To avoid cycles, we can make it p -> u (towards the source).\n                  # Or, for consistency with the problem structure (flow from 1 to n),\n                  # we could try to direct it away from the source if possible.\n                  # A simpler heuristic for 0-flow edges in a tree is to direct away from root.\n                  # So, p -> u.\n                if original_u == p and original_v == u:\n                    ans[edge_idx_to_p] = 0 # p -> u\n                else: # original_u == u and original_v == p\n                    ans[edge_idx_to_p] = 1 # p -> u\n                \n                balance[p] -= c_pu # Flow goes out of p\n                balance[u] += c_pu # Flow goes into u\n                \n            # After determining direction, balance[u] should become 0.\n            # If it's not 0, there's an issue with logic or problem understanding.\n            # For the problem constraints, it should become 0.\n\n    # After the loop, balance[1] should be -total_flow_out_of_source.\n    # balance[n] should be total_flow_out_of_source.\n    # All other balance[u] should be 0.\n\n    for result in ans:\n        sys.stdout.write(str(result) + '\\n')\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 746,
        "completion_token_count": 5617,
        "thoughts_token_count": 0
    }
}