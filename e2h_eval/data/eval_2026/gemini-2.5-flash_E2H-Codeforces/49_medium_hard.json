{
    "start": 1758294911.0304854,
    "end": 1758295024.4439054,
    "start-formatted": "2025-09-20 00:15 KST",
    "end-formatted": "2025-09-20 00:17 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "**Mushroom Strife: A Deep Dive into GCD and LCM Constraints**\n\nAlright, so the task at hand is to figure out the number of mushrooms on each lawn, given some GCD and LCM relationships between them.  We've got `n` lawns, `m` roads, and the GCD and LCM for each connected pair. The mushroom count `A[i]` must be between 1 and 10^6.  First off, we need to understand the fundamental relationship: `GCD(a, b) * LCM(a, b) = a * b`. Using this, and the given `g = GCD(A[u], A[v])` and `l = LCM(A[u], A[v])`, we know `g * l = A[u] * A[v]`.  Crucially, `g` must divide `l`. If it doesn't, we can bail right away; no solution exists.\n\nLet's represent the number of mushrooms on lawn `u` and `v` as `A[u] = g * x` and `A[v] = g * y`. We're left to find `x` and `y` such that `x * y = l / g` and `GCD(x, y) = 1`.  This is key! The `x` and `y` must be coprime.  It boils down to factoring `P = l / g`, and ensuring we have coprime divisors.  Basically, `x` will be the product of some prime factors of `P`, and `y` will be the product of the rest.  We want to identify the divisors of P that are coprime.  There will be at most `2^k` valid combinations.\n\nSo, for each edge, check if `l % g == 0`.  If not, it's a \"NO\".  Let `P = l / g`. We need to assign `A[u] = g*x` and `A[v] = g*y` where `x*y = P` and `GCD(x, y) = 1`.\n\nThe solution involves modeling this as a graph problem. Each node holds an unknown value `A[i]`.  Each edge imposes constraints on the values of the connected nodes.  We can't just brute force because of the potential range of `A[i]` (up to `10^6`).\n\nHere's the plan: We want a strategy where we select the prime factors.  Focus on the exponent of each prime factor for each node.  The core insight is that for each prime `p`, the power of that prime in `A[u]` and `A[v]` must combine to form the prime power in `g` and `l`. Let's say we have the prime `p` such that `p^g_p` is a factor of `g` and `p^l_p` is a factor of `l`. Then, either `p^g_p` divides `A[u]` and `p^l_p` divides `A[v]` OR `p^l_p` divides `A[u]` and `p^g_p` divides `A[v]`. For each prime, we will build a 2-coloring graph.\n\nFor each prime `p`, we will create a graph using a Disjoint Set Union (DSU). If the exponents are equal, use the DSU to force them to be the same value, otherwise, make the exponents different. If we get contradictions we return NO.\n\nThe algorithm:\n1.  **Prime Sieve:** Compute primes up to a maximum value of `10^6`.\n2.  **Factorization:** Factor each `g` and `l` in the input graph.\n3.  **2-Coloring:** For each prime number `p`:\n    *   Build a DSU data structure.\n    *   For each edge `(u, v, g, l)`: Determine the exponent of prime `p` in `g` and `l`.\n    *   If exponents for prime `p` are equal in `g` and `l`, merge u and v in DSU and assign that value to all.\n    *   If exponents for prime `p` are different in `g` and `l`, add the constraints to an edge list of `(u,v,1)` where 1 indicates different. Then run DFS or BFS on the resulting graph.\n4.  **Verification:** Combine the exponents for each node and create the value `A[i]`. Verify if all conditions are met. Return the `A[i]` or \"NO\".",
    "response": "The problem asks us to restore the number of mushrooms `A[i]` on `n` lawns, given `m` roads. For each road connecting lawns `u` and `v`, we are given `g = GCD(A[u], A[v])` and `l = LCM(A[u], A[v])`. We need to output \"YES\" and a valid assignment `A[1], ..., A[n]`, or \"NO\" if no such assignment exists. The values `A[i]` must be between 1 and 10^6.\n\n**Key Mathematical Property:**\nFor any two positive integers `a` and `b`, `GCD(a, b) * LCM(a, b) = a * b`.\nLet `A[u]` and `A[v]` be the number of mushrooms on lawns `u` and `v`.\nThen `g * l = A[u] * A[v]`.\nAlso, `g` must divide `l`. If `l % g != 0` for any given road, then no such `A[u], A[v]` exist, so we output \"NO\".\n\n**Prime Factorization Approach:**\nLet's consider the prime factorization of each `A[i]`. For a prime `p`, let `exp_x(p)` denote the exponent of `p` in the prime factorization of `x`.\nSo, `A[i] = product(p^exp_A[i](p))` over all primes `p`.\nThe properties of GCD and LCM translate to exponents as follows:\nFor any prime `p`:\n`exp_g(p) = min(exp_A[u](p), exp_A[v](p))`\n`exp_l(p) = max(exp_A[u](p), exp_A[v](p))`\n\nThis implies that for each prime `p` and each edge `(u, v)` with given `g, l`:\n1. `exp_g(p)` must be less than or equal to `exp_l(p)`. (This is consistent with `l % g == 0`).\n2. The set of exponents `{exp_A[u](p), exp_A[v](p)}` must be equal to the set `{exp_g(p), exp_l(p)}`.\n\nThis observation is crucial: for each prime `p`, the problem decomposes into `n` independent subproblems, one for each lawn `i`, to determine `exp_A[i](p)`.\n\n**Solving for each prime `p` independently:**\nFor a fixed prime `p`:\nWe need to determine `exp_A[i](p)` for all `i=1..n`. Let's denote this as `e_i`.\nInitialize `e_i = -1` (meaning undecided) for all `i`.\nWe will also need to track if any `e_i` is forced to be a specific value.\n\nWe can use a graph coloring approach or a Disjoint Set Union (DSU) structure. Let's use DSU for efficiency.\nFor each prime `p`:\n  Create a DSU structure for `n` elements. Each element `i` will represent `e_i`.\n  Additionally, for each DSU set (represented by its root `r`), maintain `fixed_val[r]` (the required exponent for `p` if fixed, or `-1` if not) and `parity[i]` (the required parity of `e_i` relative to `e_{root(i)}`).\n  `parity[i]` will be `0` if `e_i = e_{root(i)}` and `1` if `e_i` must be `exp_l(p) + exp_g(p) - e_{root(i)}` (i.e., different from `e_{root(i)}` if `exp_g(p) < exp_l(p)`).\n\n  Iterate through all `m` edges `(u, v, g, l)`:\n    Calculate `g_p = exp_x(g, p)` and `l_p = exp_x(l, p)`.\n    If `g_p == l_p`:\n      Both `e_u` and `e_v` must be `g_p`.\n      This is a \"fix\" operation. `unite(u, v, 0)` (same exponent), and then `fix_exponent(u, g_p)`.\n    If `g_p < l_p`:\n      `e_u` and `e_v` must be `g_p` and `l_p` (in some order).\n      This is a \"difference\" constraint. `unite(u, v, 1)` (different exponents).\n      If `fixed_val[root(u)]` is not `-1`, then `e_v` is determined. `fix_exponent(v, g_p + l_p - fixed_val[root(u)])`.\n      Similarly if `fixed_val[root(v)]` is not `-1`.\n\n  After processing all edges for prime `p`:\n  For each DSU root `r`:\n    If `fixed_val[r] == -1`: We have a choice. Pick `fixed_val[r] = g_p` (or any valid value, e.g., the smaller of the two possible exponents for this prime if `g_p < l_p` occurred in this component, otherwise 0).\n  Now all `e_i` are determined for prime `p`. Store them in `final_exponents[i][p]`.\n  If any inconsistency was found during DSU operations (e.g., trying to fix an exponent to a different value, or trying to merge components with conflicting fixed values and parities), output \"NO\".\n\n**Detailed DSU for exponents:**\nFor each prime `p`:\n`parent[i]`: parent of `i` in DSU.\n`diff[i]`: `0` if `e_i` and `e_{parent[i]}` are the same, `1` if they are different (only relevant if `g_p < l_p` for some edge in the component).\n`val[i]`: the actual exponent `e_i` if `i` is a root and `e_i` is fixed, `-1` otherwise.\n`base_g`: the minimum `g_p` encountered in this component (used as a default for `val[root]` if not fixed).\n`base_l`: the maximum `l_p` encountered in this component.\n\nWhen `unite(u, v, type)`:\n  `root_u, d_u = find(u)`\n  `root_v, d_v = find(v)`\n  If `root_u != root_v`:\n    `parent[root_v] = root_u`\n    `diff[root_v] = (d_u + type + d_v) % 2`\n    // Update `val[root_u]` based on `val[root_v]` and `diff[root_v]`\n    // Update `base_g`, `base_l` for `root_u`\n    // Check for consistency: if both `val[root_u]` and `val[root_v]` are fixed, check if they are consistent with `diff[root_v]`.\n  Else (`root_u == root_v`):\n    If `(d_u + type + d_v) % 2 != 0`: Conflict detected, output \"NO\".\n    // If `type == 0` and `d_u != d_v`: Conflict (e.g., `e_u` same as `e_v` but `e_u` different from `root_u` and `e_v` same as `root_u`).\n\nThis DSU structure needs to handle fixed values and the `g_p`/`l_p` values.\nA simpler DSU for 2-coloring:\nFor each prime `p`, maintain `val[i]` (the exponent `e_i` of `p` for node `i`). Initialize `val[i] = -1`.\nWhen an edge `(u, v, g, l)` has `g_p < l_p`:\n  If `val[u]` is fixed: `val[v]` must be `g_p + l_p - val[u]`. If `val[v]` is fixed and contradicts, \"NO\".\n  If `val[v]` is fixed: `val[u]` must be `g_p + l_p - val[v]`. If `val[u]` is fixed and contradicts, \"NO\".\n  If neither is fixed: Add `(v, g_p, l_p)` to `adj[u]` and `(u, g_p, l_p)` to `adj[v]`.\nWhen an edge `(u, v, g, l)` has `g_p == l_p`:\n  Both `val[u]` and `val[v]` must be `g_p`. If already fixed to something else, \"NO\".\n  Fixed values propagate.\n\nThis is essentially running BFS/DFS for 2-coloring on connected components for each prime.\n1. Precompute primes up to `10^6` using a sieve.\n2. For each node `i`, `final_A[i] = 1`.\n3. For each prime `p` up to `10^6`:\n    `current_exp[i]` for `i=1..n` initialized to `-1`.\n    `adj_p[i]` stores neighbors `j` for which `e_i` and `e_j` must be different.\n    `fixed_nodes_p`: a list of nodes `i` where `e_i` is directly fixed by `g_p == l_p` constraint.\n    For each edge `(u, v, g, l)`:\n        `g_p = get_exponent(g, p)`, `l_p = get_exponent(l, p)`.\n        If `g_p > l_p`, print \"NO\" and exit.\n        If `g_p == l_p`:\n            If `current_exp[u] != -1` and `current_exp[u] != g_p`, print \"NO\" and exit.\n            `current_exp[u] = g_p`. Add `u` to `fixed_nodes_p`.\n            If `current_exp[v] != -1` and `current_exp[v] != g_p`, print \"NO\" and exit.\n            `current_exp[v] = g_p`. Add `v` to `fixed_nodes_p`.\n        Else (`g_p < l_p`):\n            `adj_p[u].append(v)`, `adj_p[v].append(u)`. (These edges imply different exponents)\n\n    Use BFS to propagate fixed values and 2-color components:\n    Queue `q`. Add all `fixed_nodes_p` to `q`.\n    While `q` is not empty:\n        `u = q.pop_front()`.\n        For each `v` in `adj_p[u]`:\n            Required `e_v = g_p + l_p - current_exp[u]`.\n            If `current_exp[v] == -1`:\n                `current_exp[v] = Required_e_v`. `q.push_back(v)`.\n            Else if `current_exp[v] != Required_e_v`:\n                Print \"NO\" and exit.\n    \n    For any `i` where `current_exp[i] == -1` (unvisited component):\n        Start a new BFS from `i`. Set `current_exp[i] = g_p` (arbitrary choice for this component). Add `i` to `q`.\n        Propagate as above. If conflict, \"NO\".\n\n    After all `current_exp[i]` are determined for prime `p`, multiply `final_A[i]` by `p^current_exp[i]`.\n    Check if `final_A[i]` exceeds `10^6`. If so, print \"NO\" and exit.\n\n**Precomputation:**\nSieve of Eratosthenes to get smallest prime factor (SPF) for numbers up to `10^6`. This helps factorize `g` and `l` efficiently.\n`get_exponent(num, p)`: repeatedly divide `num` by `p` and count.\n\n**Complexity:**\n- Sieve: `O(MAX_VAL log log MAX_VAL)`\n- For each prime `p` (up to `MAX_VAL`):\n    - Building `adj_p` and `fixed_nodes_p`: `O(M)`\n    - BFS: `O(N + M)`\n- Total number of primes up to `10^6` is `~78498`.\n- Total time: `O(MAX_VAL log log MAX_VAL + NUM_PRIMES * (N + M))`.\nThis might be too slow if `NUM_PRIMES` is large. `78498 * (10^5 + 10^5)` is too much.\n\n**Optimization for primes:**\nInstead of iterating through ALL primes, iterate through only primes that are factors of any `g` or `l` in the input.\nCollect all unique prime factors from all `g` and `l` values. Let this set be `P_set`.\nMaximum `g, l` is `10^6`. A number up to `10^6` has at most 7 distinct prime factors (`2*3*5*7*11*13*17 = 510510`).\nTotal number of distinct prime factors across all `2M` values: `2M * 7 = 2 * 10^5 * 7 = 1.4 * 10^6`.\nThis is still too many distinct prime factors. The total number of unique prime factors will be at most `NUM_PRIMES_UP_TO_MAX_VAL` (78498).\nSo the approach is `O(MAX_VAL log log MAX_VAL + NUM_UNIQUE_PRIMES * (N + M))`.\n`NUM_UNIQUE_PRIMES` is at most `78498`. This is the bottleneck.\n\nLet's recheck the constraints. `N, M <= 10^5`. `g, l <= 10^6`.\n`78498 * (10^5 + 10^5) = 78498 * 2 * 10^5 = 1.5 * 10^{10}`. This is definitely too slow.\n\n**Alternative strategy for prime factors:**\nInstead of processing prime by prime, process node by node.\nFor each node `i`, what are the constraints on `A[i]`?\n`A[i]` must be `g_k * x_k` for each neighbor `k`, and `A[i]` must divide `l_k`.\nThis implies `A[i]` must be a multiple of `LCM(all g_k)` and a divisor of `GCD(all l_k)`.\nLet `L_i = LCM(g_k)` and `G_i = GCD(l_k)`.\nIf `G_i % L_i != 0` or `L_i > G_i`, then \"NO\".\nSo `A[i]` must be of the form `L_i * X` where `X` divides `G_i / L_i`.\n\nThe prime factorization approach is correct in theory, but the number of primes is too high.\nThe issue is that `N` and `M` are large.\nThe graph for each prime `p` has `N` nodes and `M` edges.\nWe need to avoid iterating over all primes.\n\nConsider a different perspective: for each edge `(u, v, g, l)`, we know `A[u]*A[v] = g*l`.\nAnd `A[u]` must be `g*x` and `A[v]` must be `g*y` where `x*y = l/g` and `GCD(x,y)=1`.\nThe number of choices for `x` is `2^k` where `k` is the number of distinct prime factors of `l/g`. `k <= 7`.\nSo `2^7 = 128` choices for `x`.\nThis means for each edge, there are at most 128 possible values for `A[u]` and 128 for `A[v]`.\n\nWe can use a DSU on the nodes. Each set in the DSU represents a connected component.\nFor each component, we need to find `A[i]` for all `i` in it.\nWhen we process an edge `(u, v, g, l)`:\n  If `u` and `v` are in the same component, say `C`:\n    If `A[u]` is known, `A[v]` is determined. Check consistency.\n    If `A[u]` is not known, we have `A[u] = g*x`, `A[v] = g*y`.\n    `A[u]` and `A[v]` are related by `A[v] = (g*l)/A[u]`.\n    We need to check `GCD(A[u], (g*l)/A[u]) == g`.\n  If `u` and `v` are in different components, merge them.\n\nThis suggests a BFS/DFS approach for components.\nLet `ans[i]` be the final answer for node `i`. Initialize to 0.\n`adj[u]` stores `(v, g, l)` for edges.\nIterate `i` from 1 to `N`. If `ans[i]` is 0:\n  Start BFS/DFS from `i`.\n  `q = deque()`. `q.append(i)`.\n  Try to assign `ans[i]`. What value to pick?\n  `A[i]` must be a multiple of `g` for all neighbors. So `A[i]` must be a multiple of `LCM(g_j)`.\n  `A[i]` must divide `l` for all neighbors. So `A[i]` must divide `GCD(l_j)`.\n  Let `min_val[i] = 1`, `max_val[i] = 10^6`.\n  For each edge `(i, j, g, l)`:\n    `min_val[i] = LCM(min_val[i], g)`\n    `max_val[i] = GCD(max_val[i], l)`\n  If `max_val[i] % min_val[i] != 0` or `min_val[i] > max_val[i]`, output \"NO\".\n  So `A[i]` must be of form `min_val[i] * k` where `k` divides `max_val[i] / min_val[i]`.\n  The number of divisors `k` can be large.\n\nThe crucial observation about exponents `{exp_A[u](p), exp_A[v](p)} = {exp_g(p), exp_l(p)}` is very strong.\nThe issue is the number of distinct primes.\nInstead of `adj_p` and `current_exp[i][p]`, we can work with `adj[i]` and `final_A[i]`.\n`final_A[i]` is initialized to `1`.\n`adj[i]` stores tuples `(v, g, l)`.\nIterate `i` from 1 to `N`. If `final_A[i] == 1`:\n  This means `i` is not yet visited/assigned. Start BFS from `i`.\n  `q = deque()`. `q.append(i)`.\n  `final_A[i] = 1` (or some other initial choice).\n  **This is the problem: what initial choice?**\n  If `A[i]` is set to `1`, then for each neighbor `j` with `(i, j, g, l)`:\n    `A[j] = g*l / A[i] = g*l`.\n    Then check `GCD(A[i], A[j]) == g` and `LCM(A[i], A[j]) == l`.\n    This propagates values. If a node `k` is visited again, check consistency.\n\nThe problem states \"It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 10^6\". This implies `A[i]` are also within `[1, 10^6]`.\nIf we set `A[i] = 1`, then `A[j]` can be `g*l`, which can be `10^6 * 10^6 = 10^12`, exceeding `10^6`.\nSo `A[i]` cannot simply be `1`.\n\nWe need to pick an `A[i]` that is a multiple of `g` and divisor of `l` for all neighbors.\nLet `A[i]` be `g_0` for some arbitrary neighbor.\nFor an edge `(u, v, g, l)`:\nLet `P = l/g`. We need `A[u] = g*x` and `A[v] = g*y` where `x*y = P` and `GCD(x,y)=1`.\nThe possible `x` values are divisors of `P` that are coprime to `P/x`.\nLet `divisors_P(P)` be this set of `x` values.\nFor each edge `(u,v,g,l)`, `A[u]` must be in `g * divisors_P(l/g)`.\nThis can be modeled as a 2-SAT problem for each prime factor.\nFor each prime `p` that appears in any `g` or `l`:\n  For each node `i`, we have two variables: `x_i^p` (meaning `exp_A[i](p) = exp_g(p)`) and `y_i^p` (meaning `exp_A[i](p) = exp_l(p)`).\n  For an edge `(u, v, g, l)`:\n    If `g_p == l_p`: `exp_A[u](p) = g_p` and `exp_A[v](p) = g_p`.\n      This means `x_u^p` is true, `y_u^p` is false. `x_v^p` is true, `y_v^p` is false.\n    If `g_p < l_p`: `(exp_A[u](p) = g_p AND exp_A[v](p) = l_p)` OR `(exp_A[u](p) = l_p AND exp_A[v](p) = g_p)`.\n      This translates to `(x_u^p XOR x_v^p)`.\n      `x_u^p` is true means `y_u^p` is false.\n      `x_u^p` is true means `exp_A[u](p) = g_p`.\n      `y_u^p` is true means `exp_A[u](p) = l_p`.\n      The 2-SAT variables are `var_i_p_g` (node `i` gets `g_p` exponent for prime `p`) and `var_i_p_l` (node `i` gets `l_p` exponent for prime `p`).\n      We need `var_i_p_g XOR var_i_p_l` to be true.\n      For `g_p == l_p`: `var_u_p_g` must be true.\n      For `g_p < l_p`: `(var_u_p_g AND var_v_p_l) OR (var_u_p_l AND var_v_p_g)` must be true.\n      This simplifies to: `var_u_p_g` implies `var_v_p_l`, and `var_u_p_l` implies `var_v_p_g`.\n      And `var_v_p_g` implies `var_u_p_l`, and `var_v_p_l` implies `var_u_p_g`.\n      This is exactly the 2-coloring problem.\n\nThe number of unique prime factors can be at most 78498.\nThe number of variables in 2-SAT would be `2 * N * NUM_UNIQUE_PRIMES`. Too many.\nThe number of clauses `M * NUM_UNIQUE_PRIMES`. Too many.\n\nThe problem statement has `N, M <= 10^5`.\n`2 * 10^5` operations per prime is too much.\nThe total number of edges is `M`.\nThe total number of distinct prime factors in all `g, l` values is `sum(distinct_prime_factors(g_k) + distinct_prime_factors(l_k))` for `k=1..M`.\nThis sum is at most `M * 7 * 2 = 14M`.\nLet `P_total` be the set of all unique prime factors across all `g, l` values.\n`|P_total| <= 78498`.\n\nLet's use the prime-by-prime BFS approach.\nThe `adj_p` graphs are sparse.\n`get_exponent` can be slow if done naively. Precomputing SPF helps.\n`get_exponent(num, p)`:\n  `count = 0`\n  `while num > 0 and num % p == 0:`\n    `count += 1`\n    `num //= p`\n  `return count`\n\nThe issue is that `adj_p` and `current_exp` need to be reset for each prime.\nThe total work for `get_exponent` over all primes for all `g, l` values:\n`sum_{k=1..M} (factorize(g_k) + factorize(l_k))`\nFactorization using SPF is `O(log X)` for number `X`. Total `O(M log MAX_VAL)`. This is fine.\nThe BFS part: `sum_{p in P_total} (N_p + M_p)`, where `N_p` is number of nodes involved for prime `p`, `M_p` is number of edges involved.\n`N_p` can be `N`, `M_p` can be `M`.\nThis is where `NUM_UNIQUE_PRIMES * (N+M)` comes from.\n\nWait, `M_p` is not `M`. `M_p` is the number of edges `(u, v)` where `p` divides `l/g`.\nOr `p` divides `g`.\nAn edge `(u, v, g, l)` only contributes to `adj_p` if `g_p < l_p`.\nAnd only contributes to `fixed_nodes_p` if `g_p == l_p`.\nThe total number of such contributions across all primes is `sum_{k=1..M} sum_{p in P_total} (1 if p divides g_k or l_k else 0)`.\nThis sum is `sum_{k=1..M} (distinct_prime_factors(g_k) + distinct_prime_factors(l_k))`.\nThis sum is at most `14M`.\nSo the total number of edges in all `adj_p` graphs combined is `O(M * log MAX_VAL)` (not `M * 7` because `log MAX_VAL` is the bound for distinct prime factors for a single number, but we consider all primes).\nThe total number of nodes `N` is visited multiple times.\nA node `i` is visited for prime `p` if `p` is a factor of `A[i]`.\nThe total sum of `N_p` over all `p` is `sum_{i=1..N} sum_{p | A[i]} 1`.\nThis is `sum_{i=1..N} distinct_prime_factors(A[i])`.\nThis is `O(N log MAX_VAL)`.\n\nSo the actual complexity is `O(MAX_VAL log log MAX_VAL + M log MAX_VAL + N log MAX_VAL)`.\nThis is efficient enough. `10^6 + 10^5*20 + 10^5*20 = 10^6 + 4*10^6 = 5*10^6`. This should pass.\n\nFinal algorithm:\n1. Sieve to precompute `spf` (smallest prime factor) up to `MAX_VAL = 10^6`.\n2. `final_A[i]` initialized to 1 for `i=1..N`.\n3. Collect all unique prime factors from all `g, l` values into a set `P_total`.\n4. For each prime `p` in `P_total`:\n   a. Initialize `current_exp[i] = -1` for `i=1..N`.\n   b. `adj_p` as list of lists, `fixed_q = deque()`.\n   c. For each edge `(u, v, g, l)`:\n      `g_p = get_exponent(g, p, spf)` (using `spf` for fast factorization).\n      `l_p = get_exponent(l, p, spf)`.\n      If `g_p > l_p`, print \"NO\", exit.\n      If `g_p == l_p`:\n         If `current_exp[u] != -1` and `current_exp[u] != g_p`, print \"NO\", exit.\n         If `current_exp[u] == -1`: `current_exp[u] = g_p`, `fixed_q.append(u)`.\n         If `current_exp[v] != -1` and `current_exp[v] != g_p`, print \"NO\", exit.\n         If `current_exp[v] == -1`: `current_exp[v] = g_p`, `fixed_q.append(v)`.\n      Else (`g_p < l_p`):\n         `adj_p[u].append((v, g_p, l_p))`, `adj_p[v].append((u, g_p, l_p))`.\n   d. Run BFS using `fixed_q` to propagate values.\n      While `fixed_q` is not empty:\n         `u = fixed_q.popleft()`.\n         For `(v, g_p_edge, l_p_edge)` in `adj_p[u]`:\n            `required_exp_v = g_p_edge + l_p_edge - current_exp[u]`.\n            If `current_exp[v] == -1`:\n               `current_exp[v] = required_exp_v`. `fixed_q.append(v)`.\n            Else if `current_exp[v] != required_exp_v`:\n               Print \"NO\", exit.\n   e. For `i=1..N`: If `current_exp[i] == -1` (unvisited component):\n      `current_exp[i] = 0` (or `g_p` from any edge in component, if any). Add `i` to `fixed_q`.\n      Run BFS again, same as step d.\n   f. For `i=1..N`:\n      `final_A[i] *= (p ** current_exp[i])`.\n      If `final_A[i] > 10^6`, print \"NO\", exit.\n5. Print \"YES\" and `final_A`.\n\nThe BFS in step 4.e needs to know `g_p_edge` and `l_p_edge` for the component.\nBetter: for each `i=1..N`: if `current_exp[i] == -1`:\n  Start BFS from `i`. Set `current_exp[i] = 0` (arbitrary choice for an unconnected component).\n  `q_comp = deque()`. `q_comp.append(i)`.\n  While `q_comp` is not empty:\n    `u = q_comp.popleft()`.\n    For `(v, g_p_edge, l_p_edge)` in `adj_p[u]`:\n      `required_exp_v = g_p_edge + l_p_edge - current_exp[u]`.\n      If `current_exp[v] == -1`:\n        `current_exp[v] = required_exp_v`. `q_comp.append(v)`.\n      Else if `current_exp[v] != required_exp_v`:\n        Print \"NO\", exit.\n\nThis covers all cases.\n\n```python\nimport sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    edges_input = []\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        edges_input.append((u - 1, v - 1, g, l)) # 0-indexed\n\n    MAX_VAL = 10**6\n    spf = [0] * (MAX_VAL + 1) # smallest prime factor\n    primes = []\n\n    # Sieve to find smallest prime factor for numbers up to MAX_VAL\n    for i in range(2, MAX_VAL + 1):\n        if spf[i] == 0: # i is prime\n            spf[i] = i\n            primes.append(i)\n        for p in primes:\n            if p > spf[i] or i * p > MAX_VAL:\n                break\n            spf[i * p] = p\n\n    # Function to get exponent of prime p in factorization of num\n    def get_exponent(num, p_val):\n        count = 0\n        if p_val == 0: return 0 # Avoid division by zero if p_val is 0 (shouldn't happen with valid primes)\n        while num > 0 and num % p_val == 0:\n            count += 1\n            num //= p_val\n        return count\n\n    # Function to get prime factors and their exponents for a number\n    def get_prime_factors_with_exponents(num):\n        factors = {}\n        temp_num = num\n        while temp_num > 1:\n            p = spf[temp_num]\n            factors[p] = factors.get(p, 0) + 1\n            temp_num //= p\n        return factors\n\n    all_unique_primes = set()\n    for u, v, g, l in edges_input:\n        if l % g != 0:\n            sys.stdout.write(\"NO\\n\")\n            return\n\n        g_factors = get_prime_factors_with_exponents(g)\n        l_factors = get_prime_factors_with_exponents(l)\n        \n        for p in g_factors:\n            all_unique_primes.add(p)\n        for p in l_factors:\n            all_unique_primes.add(p)\n\n    final_A = [1] * n\n\n    for p in all_unique_primes:\n        current_exp = [-1] * n # -1 means unassigned\n        adj_p = [[] for _ in range(n)] # Stores (neighbor, g_p_edge, l_p_edge) for diff constraints\n        fixed_q = deque()\n\n        for u, v, g, l in edges_input:\n            g_p = get_exponent(g, p)\n            l_p = get_exponent(l, p)\n\n            if g_p > l_p: # This should already be caught by l % g != 0, but good to double check\n                sys.stdout.write(\"NO\\n\")\n                return\n\n            if g_p == l_p:\n                # Both u and v must have exponent g_p\n                if current_exp[u] != -1 and current_exp[u] != g_p:\n                    sys.stdout.write(\"NO\\n\")\n                    return\n                if current_exp[u] == -1:\n                    current_exp[u] = g_p\n                    fixed_q.append(u)\n\n                if current_exp[v] != -1 and current_exp[v] != g_p:\n                    sys.stdout.write(\"NO\\n\")\n                    return\n                if current_exp[v] == -1:\n                    current_exp[v] = g_p\n                    fixed_q.append(v)\n            else: # g_p < l_p, means one has g_p, other has l_p\n                adj_p[u].append((v, g_p, l_p))\n                adj_p[v].append((u, g_p, l_p))\n        \n        # BFS to propagate fixed values\n        while fixed_q:\n            u = fixed_q.popleft()\n            for v, g_p_edge, l_p_edge in adj_p[u]:\n                required_exp_v = g_p_edge + l_p_edge - current_exp[u]\n                if current_exp[v] == -1:\n                    current_exp[v] = required_exp_v\n                    fixed_q.append(v)\n                elif current_exp[v] != required_exp_v:\n                    sys.stdout.write(\"NO\\n\")\n                    return\n        \n        # For any unassigned nodes, start a new BFS (arbitrary assignment for component)\n        for i in range(n):\n            if current_exp[i] == -1:\n                # Start a new component BFS. Arbitrarily assign 0 (g_p for this component).\n                current_exp[i] = 0 \n                q_comp = deque()\n                q_comp.append(i)\n\n                while q_comp:\n                    u = q_comp.popleft()\n                    for v, g_p_edge, l_p_edge in adj_p[u]:\n                        required_exp_v = g_p_edge + l_p_edge - current_exp[u]\n                        if current_exp[v] == -1:\n                            current_exp[v] = required_exp_v\n                            q_comp.append(v)\n                        elif current_exp[v] != required_exp_v:\n                            sys.stdout.write(\"NO\\n\")\n                            return\n\n        # Apply exponents for prime p to final_A\n        for i in range(n):\n            if current_exp[i] > 0: # Only multiply if exponent is positive\n                # Check for overflow before multiplication\n                if MAX_VAL // (p ** current_exp[i]) < final_A[i]:\n                    sys.stdout.write(\"NO\\n\")\n                    return\n                final_A[i] *= (p ** current_exp[i])\n            elif current_exp[i] == 0 and final_A[i] == 0: # This case means initial final_A[i] was 0, but it should be 1.\n                # If current_exp[i] is 0, it means p^0 = 1, so final_A[i] doesn't change due to this prime.\n                # No action needed.\n                pass\n            \n            # Ensure final_A[i] is within bounds\n            if not (1 <= final_A[i] <= MAX_VAL):\n                sys.stdout.write(\"NO\\n\")\n                return\n\n    # Final check for any 0s or out-of-bounds values (shouldn't happen if logic is correct)\n    for val in final_A:\n        if not (1 <= val <= MAX_VAL):\n            sys.stdout.write(\"NO\\n\")\n            return\n\n    sys.stdout.write(\"YES\\n\")\n    sys.stdout.write(\" \".join(map(str, final_A)) + \"\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    edges_input = []\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        edges_input.append((u - 1, v - 1, g, l)) # 0-indexed\n\n    MAX_VAL = 10**6\n    spf = [0] * (MAX_VAL + 1) # smallest prime factor\n    primes = []\n\n    # Sieve to find smallest prime factor for numbers up to MAX_VAL\n    for i in range(2, MAX_VAL + 1):\n        if spf[i] == 0: # i is prime\n            spf[i] = i\n            primes.append(i)\n        for p in primes:\n            if p > spf[i] or i * p > MAX_VAL:\n                break\n            spf[i * p] = p\n\n    # Function to get exponent of prime p in factorization of num\n    def get_exponent(num, p_val):\n        count = 0\n        if p_val == 0: return 0 # Avoid division by zero if p_val is 0 (shouldn't happen with valid primes)\n        while num > 0 and num % p_val == 0:\n            count += 1\n            num //= p_val\n        return count\n\n    # Function to get prime factors and their exponents for a number\n    def get_prime_factors_with_exponents(num):\n        factors = {}\n        temp_num = num\n        while temp_num > 1:\n            p = spf[temp_num]\n            factors[p] = factors.get(p, 0) + 1\n            temp_num //= p\n        return factors\n\n    all_unique_primes = set()\n    for u, v, g, l in edges_input:\n        if l % g != 0:\n            sys.stdout.write(\"NO\\n\")\n            return\n\n        g_factors = get_prime_factors_with_exponents(g)\n        l_factors = get_prime_factors_with_exponents(l)\n        \n        for p in g_factors:\n            all_unique_primes.add(p)\n        for p in l_factors:\n            all_unique_primes.add(p)\n\n    final_A = [1] * n\n\n    for p in all_unique_primes:\n        current_exp = [-1] * n # -1 means unassigned\n        adj_p = [[] for _ in range(n)] # Stores (neighbor, g_p_edge, l_p_edge) for diff constraints\n        fixed_q = deque()\n\n        for u, v, g, l in edges_input:\n            g_p = get_exponent(g, p)\n            l_p = get_exponent(l, p)\n\n            if g_p > l_p: # This should already be caught by l % g != 0, but good to double check\n                sys.stdout.write(\"NO\\n\")\n                return\n\n            if g_p == l_p:\n                # Both u and v must have exponent g_p\n                if current_exp[u] != -1 and current_exp[u] != g_p:\n                    sys.stdout.write(\"NO\\n\")\n                    return\n                if current_exp[u] == -1:\n                    current_exp[u] = g_p\n                    fixed_q.append(u)\n\n                if current_exp[v] != -1 and current_exp[v] != g_p:\n                    sys.stdout.write(\"NO\\n\")\n                    return\n                if current_exp[v] == -1:\n                    current_exp[v] = g_p\n                    fixed_q.append(v)\n            else: # g_p < l_p, means one has g_p, other has l_p\n                adj_p[u].append((v, g_p, l_p))\n                adj_p[v].append((u, g_p, l_p))\n        \n        # BFS to propagate fixed values\n        while fixed_q:\n            u = fixed_q.popleft()\n            for v, g_p_edge, l_p_edge in adj_p[u]:\n                required_exp_v = g_p_edge + l_p_edge - current_exp[u]\n                if current_exp[v] == -1:\n                    current_exp[v] = required_exp_v\n                    fixed_q.append(v)\n                elif current_exp[v] != required_exp_v:\n                    sys.stdout.write(\"NO\\n\")\n                    return\n        \n        # For any unassigned nodes, start a new BFS (arbitrary assignment for component)\n        for i in range(n):\n            if current_exp[i] == -1:\n                # Start a new component BFS. Arbitrarily assign 0 (g_p for this component).\n                current_exp[i] = 0 \n                q_comp = deque()\n                q_comp.append(i)\n\n                while q_comp:\n                    u = q_comp.popleft()\n                    for v, g_p_edge, l_p_edge in adj_p[u]:\n                        required_exp_v = g_p_edge + l_p_edge - current_exp[u]\n                        if current_exp[v] == -1:\n                            current_exp[v] = required_exp_v\n                            q_comp.append(v)\n                        elif current_exp[v] != required_exp_v:\n                            sys.stdout.write(\"NO\\n\")\n                            return\n\n        # Apply exponents for prime p to final_A\n        for i in range(n):\n            if current_exp[i] > 0: # Only multiply if exponent is positive\n                # Check for overflow before multiplication\n                if MAX_VAL // (p ** current_exp[i]) < final_A[i]:\n                    sys.stdout.write(\"NO\\n\")\n                    return\n                final_A[i] *= (p ** current_exp[i])\n            elif current_exp[i] == 0 and final_A[i] == 0: # This case means initial final_A[i] was 0, but it should be 1.\n                # If current_exp[i] is 0, it means p^0 = 1, so final_A[i] doesn't change due to this prime.\n                # No action needed.\n                pass\n            \n            # Ensure final_A[i] is within bounds\n            if not (1 <= final_A[i] <= MAX_VAL):\n                sys.stdout.write(\"NO\\n\")\n                return\n\n    # Final check for any 0s or out-of-bounds values (shouldn't happen if logic is correct)\n    for val in final_A:\n        if not (1 <= val <= MAX_VAL):\n            sys.stdout.write(\"NO\\n\")\n            return\n\n    sys.stdout.write(\"YES\\n\")\n    sys.stdout.write(\" \".join(map(str, final_A)) + \"\\n\")\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 551,
        "completion_token_count": 9263,
        "thoughts_token_count": 5988
    }
}