{
    "start": 1758011811.2716045,
    "end": 1758011901.2466104,
    "start-formatted": "2025-09-16 17:36 KST",
    "end-formatted": "2025-09-16 17:38 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "**Solving the Snowflake Graph Problem**\n\nOkay, so I'm presented with a competitive programming challenge. I need to figure out if a given number, `n`, can represent the total number of vertices in a \"snowflake\" graph.  The snowflake graph is built in layers, with a central vertex and each layer branching out in multiples of `k`.  I'm thinking, this means I need to find `k` and `d` (the number of branching layers) that satisfy the equation.\n\nThe total number of vertices, `n`, will be `1 + k + k^2 + ... + k^(d+1)`.  This is a geometric series sum, so `n = (k^(m+1) - 1) / (k - 1)` where `m = d + 1` (and since d>=1, `m >= 2`). I need to determine if, for a given `n`, I can find integers `k` (greater than 1) and `m` (greater than or equal to 2) that satisfy this equation.\n\nSince `n` can be up to `10^18`, I can't just brute force. However, I can iterate through possible values of `m`, and for each `m`, search for a suitable `k`.   The main idea is to use binary search for `k`, for each `m`.\n\nSince I know `k > 1` and `m >= 2`, the lower bound of k is at least 2. The upper bound of k depends on `n` and `m`, I should set it carefully to avoid overflow and inefficiency. I think the upper bound is about `n**(1/m)` (since the series grows with `k^m`). I can set the upper bound to `int(n**(1/m))+2`\n\nFor each combination of `m` and `k`, I need to compute the geometric series sum (`1 + k + ... + k^m`).  To prevent potential overflows during these multiplications, I need to compute these terms in loop carefully, always checking to make sure term * k is not greater than n.  I'll perform the sum carefully, too, to make sure I don't exceed n. If sum == n, I've found a valid k and m combination.\n\nThe key to efficiency here is the nested binary search. Given the bounds, the loop for m will be small. The computational cost will mainly be within the binary search for k.\n\nHere's my refined logic: For each `m` between 2 and approximately 60, I'll use binary search to determine if there exists an integer `k` (greater than 1) such that the equation holds true.  The binary search will quickly narrow down the possibilities for `k` within a reasonable range.  If I find a valid `k`, I've found my solution; if I exhaust all possible `m` values, then `n` cannot form a snowflake graph.\n\nNow, I just need to write the code and test it thoroughly.\n",
    "response": "The problem asks us to determine if a given number of vertices `n` can form a \"snowflake\" graph. A snowflake graph is constructed based on two parameters: `k` (an integer `k > 1`) and `d` (an integer `d >= 1`).\n\nThe construction rules are:\n1. Start with 1 central vertex.\n2. Connect the central vertex to `k` new vertices.\n   At this point, the total number of vertices is `1 + k`. These `k` new vertices are leaves.\n3. This step is repeated `d` times: Each vertex that is currently a leaf (connected to only one other vertex) is connected to `k` more new vertices.\n\nLet's trace the number of vertices:\n- **Level 0**: 1 central vertex.\n- **Level 1**: `k` vertices connected to the center. Total vertices: `1 + k`. These `k` vertices are leaves.\n- **After 1st application of Step 3 (d=1)**: Each of the `k` Level 1 leaves connects to `k` new vertices. This adds `k * k = k^2` new vertices. These form **Level 2**.\n  Total vertices: `1 + k + k^2`. These `k^2` vertices are now leaves.\n- **After 2nd application of Step 3 (d=2)**: Each of the `k^2` Level 2 leaves connects to `k` new vertices. This adds `k^2 * k = k^3` new vertices. These form **Level 3**.\n  Total vertices: `1 + k + k^2 + k^3`. These `k^3` vertices are now leaves.\n- **After `d` applications of Step 3**: This process continues. The `d`-th application of Step 3 adds `k^(d+1)` vertices, which form **Level `d+1`**.\n  The total number of vertices `n` is the sum of vertices at all levels:\n  `n = 1 + k + k^2 + ... + k^(d+1)`\n\nThis is a geometric series sum. Let `m = d+1`. Since `d >= 1`, `m >= 2`.\nSo, `n = 1 + k + k^2 + ... + k^m`, where `k > 1` and `m >= 2`.\nThe sum can also be written as `n = (k^(m+1) - 1) / (k - 1)`.\n\nWe are given `n` (up to `10^18`) and need to find if such `k` and `m` exist.\n\n**Algorithm:**\n\n1.  **Iterate `m`**:\n    The smallest possible `k` is 2.\n    If `k=2`, then `n = 1 + 2 + 2^2 + ... + 2^m = 2^(m+1) - 1`.\n    Since `n <= 10^18`, we have `2^(m+1) - 1 <= 10^18`, which implies `2^(m+1) <= 10^18 + 1`.\n    Taking `log2` on both sides: `m+1 <= log2(10^18 + 1)`.\n    `log2(10^18) approx 18 * log2(10) approx 18 * 3.3219 = 59.79`.\n    So, `m+1` can be at most 59, which means `m` can be at most 58.\n    Thus, we can iterate `m` from 2 up to 58 (or 59 to be safe, `range(2, 60)` in Python).\n\n2.  **Binary Search for `k` for a fixed `m`**:\n    For a fixed `m`, the function `f(k) = 1 + k + ... + k^m` is strictly increasing for `k > 1`. We can use binary search to find `k`.\n    -   **Lower bound for `k`**: `low = 2`.\n    -   **Upper bound for `k`**: We know `k^m < n`, so `k < n^(1/m)`. A safe upper bound is `int(n**(1/m)) + 2`.\n        For `m=2`, `k_max` is roughly `sqrt(10^18) = 10^9`.\n        For `m=58`, `k_max` is roughly `(10^18)^(1/58) approx 2.04`, so `k` can only be 2 or 3.\n        The `high` value for binary search will be `min(10**9 + 7, int(n**(1/m)) + 2)`.\n\n    -   **Binary Search Loop**:\n        While `low <= high`:\n            `mid = low + (high - low) // 2`\n            Calculate `current_sum = 1 + mid + mid^2 + ... + mid^m`.\n            During this calculation, we must be careful about potential overflows, as `mid^m` can be up to `n` and `mid^(m+1)` can be `n * mid`.\n            We can check `current_term > n // mid` before multiplying `current_term * mid` to avoid overflow and also to detect if the sum will exceed `n` quickly.\n            If `current_sum` exceeds `n` or `mid` is too large (causing overflow during `current_term` calculation), then `mid` is too high, so `high = mid - 1`.\n            If `current_sum == n`, we found a valid `k`, return \"YES\".\n            If `current_sum < n`, `mid` is too low, so `low = mid + 1`.\n\n3.  **Return \"NO\"**: If after checking all `m` values, no valid `k` is found, return \"NO\".\n\n**Complexity Analysis:**\n-   The outer loop for `m` runs `approx 57` times (from 2 to 58).\n-   The inner binary search for `k` runs `log(k_max)` iterations. `k_max` is `n^(1/m)`. So `log(n^(1/m)) = (1/m) * log(n)`.\n-   Inside the binary search, calculating the sum `1 + k + ... + k^m` takes `m` multiplications and additions.\n-   Total complexity for one test case: `sum_{m=2}^{58} ( (1/m) * log(n) * m ) = sum_{m=2}^{58} log(n) = 57 * log(n)`.\n-   `log2(10^18) approx 60`. So for one test case, it's about `57 * 60 approx 3420` operations.\n-   For `t = 10^4` test cases, total operations: `10^4 * 3420 approx 3.4 * 10^7`. This is well within typical time limits for competitive programming (usually `10^8` operations per second).\n\n**Special Case `n < 7`**:\nThe smallest possible snowflake has `k=2, m=2`, resulting in `n = 1 + 2 + 2^2 = 7` vertices. Any `n < 7` cannot form a snowflake. The algorithm implicitly handles this because for `n < 7`, `current_sum` will always be greater than `n` for `m=2, k=2`, leading to `high` being reduced until `low > high`.\n\n```python\nimport sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n\n    # Smallest possible snowflake has n = 1 + 2 + 2^2 = 7 vertices (k=2, d=1, m=2)\n    if n < 7:\n        sys.stdout.write(\"NO\\n\")\n        return\n\n    # Iterate m (d+1), where d >= 1, so m >= 2\n    # Max m: 2^(m+1) - 1 <= 10^18 => m+1 <= 59 => m <= 58\n    for m in range(2, 60): # m from 2 to 59 (inclusive)\n        low = 2\n        # Upper bound for k: k^m < n => k < n^(1/m)\n        # Using a slightly larger bound for safety and to handle potential floating point inaccuracies\n        high = int(n**(1/m)) + 2 \n        # Cap high to prevent excessively large numbers, though n**(1/m) already handles this for large m\n        # For m=2, n=10^18, high can be ~10^9\n        high = min(high, 10**9 + 7) \n\n        while low <= high:\n            k = low + (high - low) // 2\n            \n            # Calculate sum = 1 + k + k^2 + ... + k^m\n            current_sum = 1\n            current_term = 1\n            possible = True\n\n            for _ in range(m): # This loop runs m times to calculate k^1 to k^m\n                # Check for overflow before multiplication and if term*k would exceed n\n                # current_term * k > n implies current_term > n / k\n                if k == 0: # Should not happen as k >= 2\n                    possible = False\n                    break\n                if current_term > n // k:\n                    possible = False\n                    break\n                \n                current_term *= k\n                \n                # Check if current_sum + current_term would exceed n\n                if current_sum > n - current_term:\n                    possible = False\n                    break\n                \n                current_sum += current_term\n            \n            if possible and current_sum == n:\n                sys.stdout.write(\"YES\\n\")\n                return\n            \n            if possible and current_sum < n:\n                low = k + 1\n            else: # current_sum > n or overflow occurred\n                high = k - 1\n    \n    sys.stdout.write(\"NO\\n\")\n\nnum_test_cases = int(sys.stdin.readline())\nfor _ in range(num_test_cases):\n    solve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n\n    # Smallest possible snowflake has n = 1 + 2 + 2^2 = 7 vertices (k=2, d=1, m=2)\n    if n < 7:\n        sys.stdout.write(\"NO\\n\")\n        return\n\n    # Iterate m (d+1), where d >= 1, so m >= 2\n    # Max m: 2^(m+1) - 1 <= 10^18 => m+1 <= 59 => m <= 58\n    for m in range(2, 60): # m from 2 to 59 (inclusive)\n        low = 2\n        # Upper bound for k: k^m < n => k < n^(1/m)\n        # Using a slightly larger bound for safety and to handle potential floating point inaccuracies\n        high = int(n**(1/m)) + 2 \n        # Cap high to prevent excessively large numbers, though n**(1/m) already handles this for large m\n        # For m=2, n=10^18, high can be ~10^9\n        high = min(high, 10**9 + 7) \n\n        while low <= high:\n            k = low + (high - low) // 2\n            \n            # Calculate sum = 1 + k + k^2 + ... + k^m\n            current_sum = 1\n            current_term = 1\n            possible = True\n\n            for _ in range(m): # This loop runs m times to calculate k^1 to k^m\n                # Check for overflow before multiplication and if term*k would exceed n\n                # current_term * k > n implies current_term > n / k\n                if k == 0: # Should not happen as k >= 2\n                    possible = False\n                    break\n                if current_term > n // k:\n                    possible = False\n                    break\n                \n                current_term *= k\n                \n                # Check if current_sum + current_term would exceed n\n                if current_sum > n - current_term:\n                    possible = False\n                    break\n                \n                current_sum += current_term\n            \n            if possible and current_sum == n:\n                sys.stdout.write(\"YES\\n\")\n                return\n            \n            if possible and current_sum < n:\n                low = k + 1\n            else: # current_sum > n or overflow occurred\n                high = k - 1\n    \n    sys.stdout.write(\"NO\\n\")\n\nnum_test_cases = int(sys.stdin.readline())\nfor _ in range(num_test_cases):\n    solve()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 569,
        "completion_token_count": 2391,
        "thoughts_token_count": 6139
    }
}