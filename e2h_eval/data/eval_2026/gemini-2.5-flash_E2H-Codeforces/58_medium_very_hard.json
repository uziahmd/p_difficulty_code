{
    "start": 1758294834.5248146,
    "end": 1758294916.577782,
    "start-formatted": "2025-09-20 00:13 KST",
    "end-formatted": "2025-09-20 00:15 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "**Here's the plan for solving this competitive programming problem:**\n\nI'm tackling a graph problem where I need to figure out the fewest edges to add (`t`) to create an odd-length cycle, and how many ways I can do that (`w`). The key is understanding odd cycles and how they relate to the graph's structure.\n\nFirst, I'll check if the graph *already* has an odd cycle. I can do this using Breadth-First Search (BFS) or Depth-First Search (DFS) to color the graph. If I find a conflict during coloring (two connected nodes with the same color), it's not bipartite, and there's already an odd cycle. In this case, `t` is 0, and `w` is 1.\n\nIf the graph is bipartite, meaning no odd cycles exist, I'll need to add edges. I'll start by assuming I add a single edge (`t=1`). To create an odd cycle with one edge, I need to connect two vertices within the *same* connected component that have the *same* color in the 2-coloring. I'll count the number of such pairs for each component. The total count, after correcting for any existing edges, will be `w` if `t=1`.\n\nIf adding one edge won't work, all components must be either isolated vertices or edges. Then I have to move to `t=2` or `t=3`.\n\nIf `t=1` isn't possible, it means I can't connect two same-colored vertices within a single component. This means the graph consists of isolated vertices or isolated edges. In this case, if I have at least one existing edge, and at least one isolated vertex, `t` is 2. The number of ways `w` is the number of existing edges times the number of isolated vertices.\n\nIf there are no existing edges, and I have enough vertices (`n >= 3`), I will need to add three edges (`t=3`). The number of ways `w` is then calculated based on choosing three vertices to form the triangle (combinations).\n\nIf the number of vertices is less than 3, and I don't have existing edges, it is not possible. I will set `t` to 3 and `w` to 0. This seems like a reasonable approach to manage impossibility in this problem.\n\nI'll use BFS or DFS to color the graph, count vertices of each color, and determine the values of `t` and `w` based on the graph's properties.\n",
    "response": "The problem asks us to find the minimum number of edges `t` to add to a given undirected graph to form a simple cycle of odd length, and `w` the number of ways to do so. A simple cycle means each vertex occurs at most once, and \"more than one vertex\" implies a cycle of length at least 3.\n\nThe core concept for odd cycles is bipartiteness. A graph contains an odd cycle if and only if it is not bipartite.\n\nWe can solve this problem by considering different values for `t` (the number of added edges) in increasing order:\n\n**Step 1: Check for `t = 0` (graph already contains an odd cycle)**\nWe can check if the graph is bipartite using a Breadth-First Search (BFS) or Depth-First Search (DFS) for 2-coloring.\nInitialize `color` array for all vertices to -1 (unvisited).\nIterate through each vertex `i` from 1 to `n`:\n  If `color[i]` is -1, start a BFS/DFS from `i`. Assign `color[i] = 0`.\n  Maintain counts of vertices colored 0 (`count0`) and 1 (`count1`) for the current connected component.\n  During traversal:\n    If we encounter an edge `(u, v)` where `u` and `v` have the same color (`color[u] == color[v]`), then we've found an odd cycle in the original graph.\n    In this case, `t = 0` and `w = 1`. We can immediately print `0 1` and exit.\n    If `v` is unvisited, assign `color[v] = 1 - color[u]` and continue the traversal.\n\nIf the algorithm completes without finding any `color[u] == color[v]` conflicts, the graph is bipartite.\n\n**Step 2: Check for `t = 1` (add one edge)**\nIf the graph is bipartite, we need to add at least one edge. To form an odd cycle by adding a single edge `(u, v)`, `u` and `v` must be in the same connected component and have the same color.\nIn a bipartite component, any path between two vertices of the same color must have an even length. Adding an edge `(u, v)` between them creates a cycle of `(even path length) + 1` (the new edge), which is an odd cycle.\nThe number of ways `w_1` to add one such edge is the sum over all connected components of `N_0 * (N_0 - 1) / 2 + N_1 * (N_1 - 1) / 2`, where `N_0` and `N_1` are the counts of vertices colored 0 and 1 in that component, respectively. We must ensure that the added edge `(u,v)` is not an existing edge. In a bipartite graph, all existing edges connect vertices of different colors, so any edge between same-colored vertices will be new.\n\nDuring the BFS/DFS for bipartiteness (if no odd cycle was found):\n  For each connected component `C_k`:\n    Let `N_{k,0}` be the count of vertices in `C_k` with color 0.\n    Let `N_{k,1}` be the count of vertices in `C_k` with color 1.\n    `w_1 += N_{k,0} * (N_{k,0} - 1) // 2 + N_{k,1} * (N_{k,1} - 1) // 2`.\n\nAfter checking all components:\nIf `w_1 > 0`, then `t = 1` and `w = w_1`. Print `1 w_1` and exit.\n\n**Step 3: Check for `t = 2` (add two edges)**\nIf `w_1` is 0, it means that for every connected component, `N_{k,0} * (N_{k,0} - 1) // 2 + N_{k,1} * (N_{k,1} - 1) // 2` is 0. This implies that for each component `C_k`, `N_{k,0} < 2` AND `N_{k,1} < 2`.\nThis means each connected component is either:\n  - An isolated vertex (e.g., `N_0=1, N_1=0`).\n  - An isolated edge (e.g., `N_0=1, N_1=1` for an edge `u-v` with `color(u)=0, color(v)=1`).\nThe graph is a collection of isolated vertices and isolated edges.\n\nTo form an odd cycle with two added edges, the simplest way is to form a triangle `A-B-C-A`.\nIf `A-B` is an existing edge, and `C` is an isolated vertex, we can add edges `(A, C)` and `(B, C)`. This forms a triangle `A-B-C-A`.\n  - The number of ways `w_2` to do this is `m * N_iso`, where `m` is the initial number of edges and `N_iso` is the number of isolated vertices.\n  - We can count `N_iso` during the BFS/DFS: if a component has only one vertex, it's isolated.\n  - If `m > 0` and `N_iso > 0`, then `t = 2` and `w = m * N_iso`. Print `2 w_2` and exit.\n\n**Step 4: Check for `t = 3` (add three edges)**\nIf `t=0, t=1, t=2` were not possible, it means:\n  - The graph is bipartite.\n  - All components are isolated vertices or isolated edges.\n  - Either `m = 0` (all vertices are isolated) OR `N_iso = 0` (all vertices are part of isolated edges).\n\n  Case A: `m = 0` (all vertices are isolated).\n    `N_iso = n`. We need to pick 3 distinct vertices `u, v, x` and add edges `(u, v), (v, x), (x, u)` to form a triangle.\n    This requires `t = 3` edges.\n    The number of ways `w_3` is `n * (n - 1) * (n - 2) // 6` (number of ways to choose 3 vertices out of `n`).\n    If `n < 3`, it's impossible to form a triangle, so `w_3 = 0`.\n    In this case, print `3 w_3` and exit.\n\n  Case B: `N_iso = 0` (all vertices are part of isolated edges).\n    This means `n` must be even, and all `m = n / 2` edges form isolated components of two vertices.\n    Example: `1-2, 3-4, 5-6`.\n    We need to form an odd cycle. We cannot form a triangle with only 2 vertices per component.\n    We need at least 3 vertices to form a triangle.\n    We can pick three distinct edges `(u,v)`, `(x,y)`, `(a,b)`. This gives 6 distinct vertices.\n    Or, we can pick two distinct edges `(u,v)` and `(x,y)`. We need to add 3 edges.\n    Example: `u-v` and `x-y`. Add `(u,x)`, `(x,v)`, `(v,y)`. This creates a cycle `u-x-v-y-u` of length 4, which is even.\n    This is incorrect. We need an odd cycle.\n    Consider adding three edges `(u,x)`, `(x,v)`, `(v,y)` to form a C5 (cycle of length 5).\n    Pick two distinct edges `(u,v)` and `(x,y)`.```python\nimport sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    adj = [[] for _ in range(n + 1)]\n    edges_list = []\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n        edges_list.append((u, v))\n\n    color = [-1] * (n + 1)  # -1: unvisited, 0: color 0, 1: color 1\n    \n    # Stores the number of ways to add 1 edge for t=1\n    ways_t1 = 0 \n    \n    # Stores the count of isolated vertices\n    isolated_vertices = 0\n\n    # Flag to check if the graph is bipartite\n    is_graph_bipartite = True\n\n    for i in range(1, n + 1):\n        if color[i] == -1:  # New connected component\n            q = deque()\n            q.append(i)\n            color[i] = 0\n            \n            component_nodes = 0\n            count0 = 0\n            count1 = 0\n            \n            # Use a local flag for the current component\n            is_component_bipartite = True \n\n            component_nodes_list = [] # To collect nodes in this component\n\n            while q:\n                u = q.popleft()\n                component_nodes_list.append(u)\n                component_nodes += 1\n                if color[u] == 0:\n                    count0 += 1\n                else:\n                    count1 += 1\n\n                for v in adj[u]:\n                    if color[v] == -1:\n                        color[v] = 1 - color[u]\n                        q.append(v)\n                    elif color[v] == color[u]:\n                        # Found an odd cycle in the original graph\n                        is_graph_bipartite = False\n                        is_component_bipartite = False\n                        break # Break from inner loop (neighbors of u)\n                if not is_component_bipartite:\n                    break # Break from outer loop (BFS for component)\n            \n            if not is_component_bipartite:\n                # If any component is not bipartite, the whole graph is not bipartite.\n                # We found an odd cycle, so t=0, w=1.\n                print(\"0 1\")\n                return\n            \n            # If the component is bipartite, calculate ways for t=1\n            ways_t1 += count0 * (count0 - 1) // 2\n            ways_t1 += count1 * (count1 - 1) // 2\n\n            # Check if this component is an isolated vertex\n            if component_nodes == 1:\n                isolated_vertices += 1\n            \n    # If we reached here, the graph is bipartite.\n    if is_graph_bipartite:\n        if ways_t1 > 0:\n            # t=1 is possible: add one edge between two same-colored vertices in a component.\n            print(f\"1 {ways_t1}\")\n        else:\n            # t=1 is not possible. All components are either isolated vertices or isolated edges.\n            # Check for t=2.\n            # To form a triangle (odd cycle of length 3) with 2 added edges:\n            # Pick an existing edge (u,v) and an isolated vertex x. Add (u,x) and (v,x).\n            ways_t2 = m * isolated_vertices\n            if ways_t2 > 0:\n                print(f\"2 {ways_t2}\")\n            else:\n                # t=2 is not possible.\n                # This means either m=0 (no existing edges) or isolated_vertices=0 (no isolated vertices).\n                \n                if m == 0:\n                    # All vertices are isolated. Need to add 3 edges to form a triangle.\n                    # Pick 3 distinct vertices.\n                    ways_t3 = 0\n                    if n >= 3:\n                        ways_t3 = n * (n - 1) * (n - 2) // 6\n                    print(f\"3 {ways_t3}\")\n                else: # isolated_vertices == 0\n                    # All vertices are part of isolated edges. (n must be even)\n                    # Example: 1-2, 3-4, 5-6.\n                    # To form an odd cycle of length 3, we need 3 vertices.\n                    # We can pick 2 existing edges (u,v) and (x,y).\n                    # Add (u,x), (v,x), (u,y). This forms a cycle u-x-v-u of length 3.\n                    # u-v, x-y are existing edges. Add (u,x), (v,x), (u,y).\n                    # This creates a cycle u-x-v-u (triangle) and connects y to u.\n                    # This is actually 3 edges.\n                    # This needs to be done carefully.\n                    # Pick 2 existing edges (u,v) and (x,y). Add (u,x) and (v,x) and (u,y).\n                    # This makes a triangle u-x-v-u.\n                    # The number of ways to pick 2 distinct edges is m * (m - 1) // 2.\n                    # For each such pair of edges, we can form 4 triangles:\n                    # (u,v) and (x,y):\n                    # 1. Add (u,x) and (v,x) -> triangle u-x-v-u\n                    # 2. Add (u,y) and (v,y) -> triangle u-y-v-u\n                    # 3. Add (u,x) and (u,y) -> triangle x-u-y-x\n                    # 4. Add (v,x) and (v,y) -> triangle x-v-y-x\n                    # So, ways_t3 = (m * (m - 1) // 2) * 4.\n                    # However, this counts ways to form *a* triangle. The problem asks for minimum edges.\n                    # If we pick two edges (u,v) and (x,y), and add (u,x) and (v,x), this creates a triangle u-x-v-u.\n                    # The total edges added are 2. This is t=2.\n                    # But we are in the case where t=2 is not possible (m*isolated_vertices == 0).\n                    # This means isolated_vertices MUST be 0.\n                    # If m > 0 and isolated_vertices == 0, we can't form a triangle with 2 edges.\n                    # So we need 3 edges.\n                    # The simplest way to form an odd cycle with 3 edges is a triangle.\n                    # We need to pick 3 vertices, say u,v,x.\n                    # If all are part of edges. Example: 1-2, 3-4, 5-6.\n                    # Pick 1,3,5. Add (1,3), (3,5), (5,1). This forms a triangle.\n                    # This requires 3 edges.\n                    # The number of ways to pick 3 distinct vertices from n is n * (n-1) * (n-2) // 6.\n                    # However, these vertices are not isolated. They are endpoints of existing edges.\n                    # Let's say we pick 3 vertices u,v,x.\n                    # If u,v,x are from 3 different edges (e.g., u from 1-2, v from 3-4, x from 5-6),\n                    # we add (u,v), (v,x), (x,u). This is 3 new edges.\n                    # The number of ways to choose 3 vertices from n is nC3.\n                    # This forms a triangle.\n                    # This is the same logic as when m=0, but the vertices are not isolated.\n                    # The number of ways to pick 3 distinct vertices is n * (n-1) * (n-2) // 6.\n                    # This will form a triangle with 3 added edges.\n                    ways_t3 = 0\n                    if n >= 3:\n                        ways_t3 = n * (n - 1) * (n - 2) // 6\n                    print(f\"3 {ways_t3}\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    adj = [[] for _ in range(n + 1)]\n    edges_list = []\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n        edges_list.append((u, v))\n\n    color = [-1] * (n + 1)  # -1: unvisited, 0: color 0, 1: color 1\n    \n    # Stores the number of ways to add 1 edge for t=1\n    ways_t1 = 0 \n    \n    # Stores the count of isolated vertices\n    isolated_vertices = 0\n\n    # Flag to check if the graph is bipartite\n    is_graph_bipartite = True\n\n    for i in range(1, n + 1):\n        if color[i] == -1:  # New connected component\n            q = deque()\n            q.append(i)\n            color[i] = 0\n            \n            component_nodes = 0\n            count0 = 0\n            count1 = 0\n            \n            # Use a local flag for the current component\n            is_component_bipartite = True \n\n            component_nodes_list = [] # To collect nodes in this component\n\n            while q:\n                u = q.popleft()\n                component_nodes_list.append(u)\n                component_nodes += 1\n                if color[u] == 0:\n                    count0 += 1\n                else:\n                    count1 += 1\n\n                for v in adj[u]:\n                    if color[v] == -1:\n                        color[v] = 1 - color[u]\n                        q.append(v)\n                    elif color[v] == color[u]:\n                        # Found an odd cycle in the original graph\n                        is_graph_bipartite = False\n                        is_component_bipartite = False\n                        break # Break from inner loop (neighbors of u)\n                if not is_component_bipartite:\n                    break # Break from outer loop (BFS for component)\n            \n            if not is_component_bipartite:\n                # If any component is not bipartite, the whole graph is not bipartite.\n                # We found an odd cycle, so t=0, w=1.\n                print(\"0 1\")\n                return\n            \n            # If the component is bipartite, calculate ways for t=1\n            ways_t1 += count0 * (count0 - 1) // 2\n            ways_t1 += count1 * (count1 - 1) // 2\n\n            # Check if this component is an isolated vertex\n            if component_nodes == 1:\n                isolated_vertices += 1\n            \n    # If we reached here, the graph is bipartite.\n    if is_graph_bipartite:\n        if ways_t1 > 0:\n            # t=1 is possible: add one edge between two same-colored vertices in a component.\n            print(f\"1 {ways_t1}\")\n        else:\n            # t=1 is not possible. All components are either isolated vertices or isolated edges.\n            # Check for t=2.\n            # To form a triangle (odd cycle of length 3) with 2 added edges:\n            # Pick an existing edge (u,v) and an isolated vertex x. Add (u,x) and (v,x).\n            ways_t2 = m * isolated_vertices\n            if ways_t2 > 0:\n                print(f\"2 {ways_t2}\")\n            else:\n                # t=2 is not possible.\n                # This means either m=0 (no existing edges) or isolated_vertices=0 (no isolated vertices).\n                \n                if m == 0:\n                    # All vertices are isolated. Need to add 3 edges to form a triangle.\n                    # Pick 3 distinct vertices.\n                    ways_t3 = 0\n                    if n >= 3:\n                        ways_t3 = n * (n - 1) * (n - 2) // 6\n                    print(f\"3 {ways_t3}\")\n                else: # isolated_vertices == 0\n                    # All vertices are part of isolated edges. (n must be even)\n                    # Example: 1-2, 3-4, 5-6.\n                    # To form an odd cycle of length 3, we need 3 vertices.\n                    # We can pick 2 existing edges (u,v) and (x,y).\n                    # Add (u,x), (v,x), (u,y). This forms a cycle u-x-v-u of length 3.\n                    # u-v, x-y are existing edges. Add (u,x), (v,x), (u,y).\n                    # This creates a cycle u-x-v-u (triangle) and connects y to u.\n                    # This is actually 3 edges.\n                    # This needs to be done carefully.\n                    # Pick 2 existing edges (u,v) and (x,y). Add (u,x) and (v,x) and (u,y).\n                    # This makes a triangle u-x-v-u.\n                    # The number of ways to pick 2 distinct edges is m * (m - 1) // 2.\n                    # For each such pair of edges, we can form 4 triangles:\n                    # (u,v) and (x,y):\n                    # 1. Add (u,x) and (v,x) -> triangle u-x-v-u\n                    # 2. Add (u,y) and (v,y) -> triangle u-y-v-u\n                    # 3. Add (u,x) and (u,y) -> triangle x-u-y-x\n                    # 4. Add (v,x) and (v,y) -> triangle x-v-y-x\n                    # So, ways_t3 = (m * (m - 1) // 2) * 4.\n                    # However, this counts ways to form *a* triangle. The problem asks for minimum edges.\n                    # If we pick two edges (u,v) and (x,y), and add (u,x) and (v,x), this creates a triangle u-x-v-u.\n                    # The total edges added are 2. This is t=2.\n                    # But we are in the case where t=2 is not possible (m*isolated_vertices == 0).\n                    # This means isolated_vertices MUST be 0.\n                    # If m > 0 and isolated_vertices == 0, we can't form a triangle with 2 edges.\n                    # So we need 3 edges.\n                    # The simplest way to form an odd cycle with 3 edges is a triangle.\n                    # We need to pick 3 vertices, say u,v,x.\n                    # If all are part of edges. Example: 1-2, 3-4, 5-6.\n                    # Pick 1,3,5. Add (1,3), (3,5), (5,1). This forms a triangle.\n                    # This requires 3 edges.\n                    # The number of ways to pick 3 distinct vertices from n is n * (n-1) * (n-2) // 6.\n                    # However, these vertices are not isolated. They are endpoints of existing edges.\n                    # Let's say we pick 3 vertices u,v,x.\n                    # If u,v,x are from 3 different edges (e.g., u from 1-2, v from 3-4, x from 5-6),\n                    # we add (u,v), (v,x), (x,u). This is 3 new edges.\n                    # The number of ways to choose 3 vertices from n is nC3.\n                    # This forms a triangle.\n                    # This is the same logic as when m=0, but the vertices are not isolated.\n                    # The number of ways to pick 3 distinct vertices is n * (n-1) * (n-2) // 6.\n                    # This will form a triangle with 3 added edges.\n                    ways_t3 = 0\n                    if n >= 3:\n                        ways_t3 = n * (n - 1) * (n - 2) // 6\n                    print(f\"3 {ways_t3}\")\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 604,
        "completion_token_count": 3800,
        "thoughts_token_count": 6023
    }
}