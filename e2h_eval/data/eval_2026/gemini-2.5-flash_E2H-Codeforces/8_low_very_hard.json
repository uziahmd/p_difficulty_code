{
    "start": 1758009379.5866544,
    "end": 1758009486.522217,
    "start-formatted": "2025-09-16 16:56 KST",
    "end-formatted": "2025-09-16 16:58 KST",
    "gpu": 2,
    "pid": 8,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "**Tackling the Flawed Flow Problem**\n\nOkay, so I'm looking at this \"Flawed Flow\" problem, and my initial thoughts are about breaking it down systematically. I need a Python script to handle this, but first, I have to *really* understand the conditions.\n\nThe input is straightforward: `n` vertices, `m` edges, and the edges themselves with flow capacities. The challenge lies in converting this undirected graph into a directed acyclic graph (DAG) that represents a maximum flow. The capacities (`ci`) are *the* max flow values, I just need to find the correct edge directions.\n\nThe crucial conditions are: flow conservation, source (vertex 1) having no incoming edges, and the graph being acyclic. This acyclicity is a major clue! With the source condition, it strongly hints at using topological sorting. Flow in a DAG naturally goes from earlier nodes to later nodes in the topological order.\n\nThe source (1) is easy – all edges connected to it must point *outward*.  This means I need to make sure every edge connected to node 1 has its `di` set accordingly.\n\nThe flow conservation at all intermediate nodes (1 < `v` < `n`) is also vital. The flow coming in *must* equal the flow going out at each of these vertices.\n\nAcyclicity gives me confidence I can solve this. With a standard max-flow approach, I need to ensure the graph *remains* acyclic after orientation. This is the core challenge.\n\nThe bit about the sink (vertex `n`) is a little ambiguous. While it doesn't *explicitly* state that `n` can't have outgoing edges, in practice for max-flow, this is typical. I'll make the assumption that we are looking for the total flow from 1 to `n`, so that any edges that go out of `n` don't contribute to the \"flow\" we are considering here. If they did, it would require a slight modification to the usual max flow definition.\n\nThe problem guarantees existence of a solution, and the graph's connectivity is given. It’s about orienting edges in a way that satisfies the conditions. My strategy will be to determine edge directions to get the maximum flow. I think a topological sorting or a similar algorithm will be important. I need to design an algorithm for a Python script to take this input and produce the directed graph output. Let's start thinking about how to build that algorithm...\n",
    "response": "The problem asks us to direct edges in a given undirected graph, each with a specified flow volume `ci`, such that:\n1.  For any intermediate vertex `v` (1 < `v` < `n`), the sum of incoming flow equals the sum of outgoing flow.\n2.  Vertex 1 (source) has no incoming edges.\n3.  The resulting directed graph has no cycles.\n\nWe are guaranteed that a solution always exists and that the given `ci` values correspond to a maximum flow.\n\nThe core idea is to determine the direction of flow for each edge. Since the graph must be acyclic and vertex 1 has no incoming edges, this implies that flow generally moves \"away\" from vertex 1 and \"towards\" vertex `n`. This structure is characteristic of a Directed Acyclic Graph (DAG).\n\nLet's consider the flow balance for each vertex. For any vertex `v` (1 < `v` < `n`), the net flow (sum of outgoing flow minus sum of incoming flow) must be zero. For vertex 1, the net flow must be non-negative (all flow is outgoing). For vertex `n`, the net flow must be non-positive (all flow is incoming, if `n` is a pure sink).\n\nThe problem states that the given `ci` values represent a maximum flow. A common technique to find directions in a max-flow context, especially with acyclicity, is to use a topological sort or a similar level-based approach. If we can assign a \"level\" or \"distance\" to each node such that flow always goes from a lower level to a higher level, that would satisfy acyclicity.\n\nA standard way to determine flow directions in a network is to find a cut (S, T) where S contains the source and T contains the sink. All edges crossing this cut from S to T must be directed from S to T. However, finding such a global cut can be complicated.\n\nA simpler approach, given the acyclicity and source/sink properties, is to use a breadth-first search (BFS) or depth-first search (DFS) starting from the source (vertex 1). If we can direct edges such that we always traverse from an unvisited node to a visited node, or from a node with a smaller \"distance\" to a node with a larger \"distance\", we can achieve acyclicity.\n\nLet's maintain the `balance` for each vertex `v`. Initially, all balances are 0.\nWhen we direct an edge `u -> v` with flow `c`:\n*   `balance[u]` decreases by `c` (flow leaves `u`).\n*   `balance[v]` increases by `c` (flow enters `v`).\n\nThe goal is that for `1 < v < n`, `balance[v]` should be 0. For `v=1`, `balance[1]` should be `-(total max flow)`. For `v=n`, `balance[n]` should be `+(total max flow)`.\n\nConsider a BFS-like approach:\nStart a traversal from vertex 1. Maintain a queue of vertices whose flow balance needs to be resolved.\nInitially, the source vertex 1 has no incoming edges. All its adjacent edges *must* be outgoing.\nSo, for each edge `(1, u)` with flow `c`:\n*   Direct `1 -> u`.\n*   `balance[1]` decreases by `c`.\n*   `balance[u]` increases by `c`.\n*   Add `u` to a queue if its balance is now non-zero and it's not `n`.\n\nThis doesn't quite work because a node `u` might have multiple edges, and we don't know which direction to pick for subsequent edges.\n\nA more robust approach relies on the fact that the graph is connected and a solution always exists. We can use a DFS-like approach to build a spanning tree (or forest).\n\nLet's use a standard graph traversal (like BFS or DFS) to assign levels or distances from the source. Since the graph is undirected, we can run a BFS from vertex 1 to find the shortest path distances `dist[v]` to all other vertices. This gives a topological ordering if we direct edges from `u` to `v` where `dist[u] < dist[v]`.\n\nHowever, the specific flow values `ci` might not allow this simple `dist[u] < dist[v]` rule for all edges. An edge `(u, v)` with `dist[u] > dist[v]` would imply flow `v -> u`, which is fine as long as it doesn't create a cycle and flow conservation holds.\n\nThe crucial observation is that if we consider the *net flow* for each node, we can determine directions.\nFor each node `v`, let `incoming_needed[v]` be the sum of `ci` for all edges `(u, v)` where `u` has already been processed and `u -> v` was chosen.\nLet `outgoing_needed[v]` be the sum of `ci` for all edges `(v, w)` where `w` has already been processed and `v -> w` was chosen.\n\nThis problem is a classic application of a \"potential function\" or \"topological ordering\" idea in flow networks. Since acyclicity is required, we can think of assigning a \"rank\" or \"level\" to each node, and all flow must go from lower rank to higher rank.\n\nLet's maintain `current_flow_in[v]` and `current_flow_out[v]` for each vertex `v`.\nWe can use a queue for vertices that need their balance resolved.\nInitially, vertex 1 needs to push out all its flow.\nFor any vertex `v` (1 < `v` < `n`), we need `current_flow_in[v] == current_flow_out[v]`.\n\nA common strategy for this type of problem is to use a **topological sort** based on the flow.\nSince vertex 1 has no incoming edges, all its adjacent edges must be outgoing.\nWe can process vertices in an order that ensures acyclicity. A simple way to do this is to use a DFS, but carefully.\n\nLet's maintain `flow_balance[v]` for each node `v`, which is `sum(incoming_flow) - sum(outgoing_flow)`.\nInitially, `flow_balance[v] = 0` for all `v`.\n\nWe can use a modified DFS. When we visit a node `u` for the first time, we haven't decided the direction of its incident edges yet.\nWe want to direct edges such that `flow_balance[v]` becomes 0 for `1 < v < n`.\n\nConsider a DFS from vertex 1.\nWhen DFS visits `u`:\nFor each unvisited neighbor `v` of `u`:\n  Recursively call DFS on `v`.\n  After DFS `v` returns, we need to decide the direction of `(u, v)`.\n  If `flow_balance[v]` is positive (meaning `v` has more incoming flow than outgoing flow decided so far), then `u` must send flow to `v` to help `v` balance out. So `u -> v`.\n  If `flow_balance[v]` is negative (meaning `v` has more outgoing flow than incoming flow decided so far), then `v` must send flow to `u` to help `u` balance out. So `v -> u`.\n  The `flow_balance[u]` and `flow_balance[v]` are updated based on this decision.\n\nThis approach is tricky because `flow_balance[v]` might be affected by edges not yet processed by the DFS.\n\nA simpler approach that works for similar problems where acyclicity is required:\n1.  Initialize `net_flow_at_node[v] = 0` for all `v`.\n2.  Initialize `parent[v] = -1` for all `v`.\n3.  Use a queue for BFS, starting with vertex 1.\n4.  When processing `u` from the queue:\n    For each edge `(u, v)` (where `v` is an adjacent node, and this edge hasn't been directed yet):\n    *   If `v` is `n`: We can direct `u -> n` with flow `c`. Update `net_flow_at_node[u] -= c`.\n    *   If `v` is an intermediate node (`1 < v < n`):\n        *   If `net_flow_at_node[u]` is positive (meaning `u` has more incoming flow than outgoing flow so far): We need to direct `u -> v` to decrease `net_flow_at_node[u]`.\n        *   If `net_flow_at_node[u]` is negative (meaning `u` has more outgoing flow than incoming flow so far): We need to direct `v -> u` to increase `net_flow_at_node[u]`.\n        *   This greedy choice won't always work because `v` might also need to balance its flow.\n\nLet's use the provided guarantee: \"a solution always exists.\" This implies there's a unique way to satisfy flow conservation and acyclicity for intermediate nodes, given source/sink properties.\n\nThe problem can be solved by processing nodes in a specific order. Since vertex 1 has no incoming edges, all flow on its incident edges must go *out*.\nFor any other node `v` (1 < `v` < `n`), the total flow in must equal total flow out.\n\nConsider the total flow `F_total` leaving node 1. This must be equal to the total flow entering node `n`.\nLet `current_flow_balance[v]` be the sum of flow that has *entered* `v` minus the sum of flow that has *left* `v` so far.\nInitially, `current_flow_balance[v] = 0` for all `v`.\n\nWe can use a **DFS** to direct edges. The key idea is that when DFS returns from a child `v` to its parent `u`, we know the \"net flow imbalance\" at `v` that needs to be resolved through the edge `(u, v)`.\n\n```python\nimport sys\n\ndef solve():\n    n, m = map(sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    edges_input = []\n    for i in range(m):\n        a, b, c = map(sys.stdin.readline().split())\n        edges_input.append((a, b, c, i)) # Store original index\n        adj[a].append((b, c, i))\n        adj[b].append((a, c, i))\n\n    # flow_balance[v] will store the net flow that needs to be resolved at node v\n    # A positive value means v has received more flow than it has sent out (so far)\n    # A negative value means v has sent out more flow than it has received (so far)\n    # For intermediate nodes (1 < v < n), this should be 0 at the end.\n    # For source (1), it will be negative (all flow sent out).\n    # For sink (n), it will be positive (all flow received).\n    flow_balance = [0] * (n + 1)\n    \n    visited = [False] * (n + 1)\n    \n    # Store the direction for each edge. result[i] = 0 means a -> b, 1 means b -> a\n    result = [0] * m\n\n    # DFS function to determine edge directions\n    # u: current node\n    # p: parent of u in the DFS tree (to avoid going back immediately)\n    def dfs(u, p):\n        visited[u] = True\n\n        # Total flow that needs to be balanced for node u through its children\n        # This will be the sum of flow_balance[child] for children already processed\n        # plus flow_balance[u] itself from other edges\n        current_node_balance = 0 \n\n        for v, c, edge_idx in adj[u]:\n            if v == p:\n                continue # Skip the edge to parent\n\n            if not visited[v]:\n                # If v is not visited, it's a child in the DFS tree\n                # Recursively call DFS for v\n                dfs(v, u)\n\n                # After DFS(v) returns, flow_balance[v] contains the net flow\n                # that v needs to send to u (if positive) or receive from u (if negative)\n                # to satisfy flow conservation within its subtree.\n                \n                # If flow_balance[v] > 0, v has an excess of incoming flow.\n                # This excess must be sent to u. So, u <- v.\n                if flow_balance[v] > 0:\n                    result[edge_idx] = 1 # Direction is v -> u\n                    current_node_balance += flow_balance[v] # u receives flow from v\n                # If flow_balance[v] <= 0, v has a deficit of incoming flow (or balanced).\n                # This deficit must be covered by u. So, u -> v.\n                else: # flow_balance[v] <= 0\n                    result[edge_idx] = 0 # Direction is u -> v\n                    current_node_balance += flow_balance[v] # u sends flow to v (negative value)\n\n            else:\n                # If v is visited and not parent, it's a back-edge or cross-edge.\n                # This edge is not part of the DFS tree.\n                # We need to decide its direction.\n                # Since we want acyclicity, flow should generally go from \"earlier\" to \"later\" nodes.\n                # In a DFS, an already visited node `v` is \"earlier\" than `u` (if `v` is not parent).\n                # So, flow should go `v -> u`.\n                # This ensures no cycles are formed by back-edges.\n                # (This is a common heuristic for DAGs, assuming DFS order implies topological order)\n                # However, this might conflict with flow conservation.\n                # The problem statement guarantees a solution exists.\n                # The \"current_node_balance\" for u is built up from its children.\n                # The balance for u itself is the sum of flows on edges not in the DFS tree.\n                \n                # For edges not in the DFS tree, we can assume flow goes from the node that was visited earlier to the node visited later.\n                # In a DFS, if v is visited and not the parent, it means v was visited before u.\n                # So we direct v -> u.\n                # This ensures acyclicity for non-tree edges.\n                if visited[v] and v != p: # It's a cross-edge or back-edge\n                    # We need to decide direction. To ensure acyclicity, if v was visited before u,\n                    # we typically direct v -> u.\n                    # This means u receives flow c from v.\n                    # This will contribute to current_node_balance for u.\n                    # However, this decision for non-tree edges is tricky.\n                    # A better way is to only use tree edges for balancing, and then resolve non-tree edges.\n                    # But the DFS approach below uses the total flow of the edge directly.\n                    pass # Handled below by the balance calculation\n\n        # Now, current_node_balance reflects the net flow from children in the DFS tree.\n        # We need to consider the initial flow of edges (u, v, c) where v is not parent and not a child in DFS tree.\n        # This part of the logic needs to be careful.\n        # The flow_balance[u] should represent the total net flow that u needs to handle\n        # from all its incident edges *except* the one connecting to its parent in DFS.\n        \n        # Let's restart the DFS logic with a clearer idea:\n        # flow_balance[v] will store the *unresolved* flow at node v.\n        # When DFS returns from v to u, flow_balance[v] tells us how much net flow v\n        # needs to send/receive through the (u,v) edge to become balanced.\n\n        # The initial values for flow_balance[v] are all 0.\n        # In the DFS, when we process an edge (u, v) with flow c:\n        # If v is unvisited:\n        #   Call dfs(v, u).\n        #   When dfs(v, u) returns, flow_balance[v] holds the net flow that needs to pass between u and v\n        #   to balance v and its subtree.\n        #   If flow_balance[v] > 0, it means v has an excess of flow from its subtree, which must go to u.\n        #     So, v -> u. Update flow_balance[u] += flow_balance[v].\n        #   If flow_balance[v] < 0, it means v needs more flow for its subtree, which must come from u.\n        #     So, u -> v. Update flow_balance[u] += flow_balance[v].\n        #   The flow on edge (u,v) is c. The actual flow on (u,v) is abs(flow_balance[v]).\n        #   This is not correct. The total flow on edge (u,v) is c, not flow_balance[v].\n        #   flow_balance[v] should be the *net* flow that has been decided for v, not the total flow.\n\n        # Let's try to define flow_balance[v] as the sum of flow_ci for incoming edges minus sum of flow_ci for outgoing edges.\n        # When DFS returns from v to u, flow_balance[v] should be 0 if v is an intermediate node.\n        # If flow_balance[v] is not 0, it means v needs to send/receive flow through (u,v).\n        # This means flow_balance[v] stores the *excess incoming* flow that v has accumulated from its children.\n        # This excess must be passed to u. So, flow_balance[u] += flow_balance[v].\n        # The direction of (u,v) is v -> u.\n\n        # Let's re-evaluate the DFS state:\n        # `flow_at_node[v]` will store the sum of flow values `c` for edges `(x, v)` that have been directed `x -> v`\n        # minus sum of flow values `c` for edges `(v, y)` that have been directed `v -> y`.\n        # When DFS(u, p) is called, `flow_at_node[u]` is 0.\n        # When DFS returns from `v` to `u`:\n        #   If `v` is `n`: `flow_at_node[u]` decreases by `c` (u -> n).\n        #   If `v` is `1`: `flow_at_node[u]` increases by `c` (1 -> u).\n        #   If `1 < v < n`: `flow_at_node[v]` must be 0.\n        #     If `flow_at_node[v]` is positive, it means `v` has more incoming flow than outgoing within its subtree.\n        #       This excess must go to `u`. So `v -> u`. `flow_at_node[u] += c`.\n        #     If `flow_at_node[v]` is negative, it means `v` needs more flow. This must come from `u`.\n        #       So `u -> v`. `flow_at_node[u] -= c`.\n\n        # This logic is sound for tree edges. What about non-tree edges?\n        # A common trick is to only use tree edges for flow balancing.\n        # Non-tree edges (u, v) where v is already visited and not parent:\n        # Direct them from v to u (to maintain acyclicity based on DFS entry/exit times).\n        # This means u receives flow c from v.\n        # So, `flow_at_node[u] += c`.\n\n        # Let's use `net_flow_sum[v]` to store the sum of `c` for edges directed into `v` MINUS sum of `c` for edges directed out of `v`.\n        # We want `net_flow_sum[v] == 0` for `1 < v < n`.\n        # The DFS will return the `net_flow_sum` for the subtree rooted at `u`, excluding the edge to its parent.\n\n        current_net_flow_in_subtree = 0\n\n        for v_neighbor, c_flow, edge_idx in adj[u]:\n            if v_neighbor == p:\n                continue\n\n            if not visited[v_neighbor]:\n                # This is a tree edge (u, v_neighbor)\n                # Recursively call DFS for the child\n                child_net_flow_contribution = dfs(v_neighbor, u)\n\n                # After the recursive call, child_net_flow_contribution represents the net flow\n                # that needs to pass through the edge (u, v_neighbor) to balance v_neighbor and its subtree.\n                # If child_net_flow_contribution > 0: v_neighbor has an excess of incoming flow from its subtree.\n                #   This excess must go to u. So, direction is v_neighbor -> u.\n                #   u receives flow `c_flow` from v_neighbor.\n                #   We must set `result[edge_idx] = 1` (v_neighbor -> u).\n                #   `current_net_flow_in_subtree` for `u` increases by `c_flow`.\n                if child_net_flow_contribution > 0:\n                    result[edge_idx] = 1  # v_neighbor -> u\n                    current_net_flow_in_subtree += c_flow\n                # If child_net_flow_contribution <= 0: v_neighbor needs flow (or is balanced) from u.\n                #   This means u sends flow to v_neighbor. So, direction is u -> v_neighbor.\n                #   u sends flow `c_flow` to v_neighbor.\n                #   We must set `result[edge_idx] = 0` (u -> v_neighbor).\n                #   `current_net_flow_in_subtree` for `u` decreases by `c_flow`.\n                else: # child_net_flow_contribution <= 0\n                    result[edge_idx] = 0  # u -> v_neighbor\n                    current_net_flow_in_subtree -= c_flow\n            else:\n                # This is a back-edge or cross-edge (u, v_neighbor) where v_neighbor is already visited.\n                # To maintain acyclicity and ensure flow goes from \"earlier\" to \"later\" nodes in DFS order,\n                # we direct flow from v_neighbor to u.\n                # This means u receives flow `c_flow` from v_neighbor.\n                # We must set `result[edge_idx] = 1` (v_neighbor -> u).\n                # `current_net_flow_in_subtree` for `u` increases by `c_flow`.\n                # This only applies if the edge hasn't been directed yet.\n                # We need to make sure we don't process the same edge twice.\n                # The `visited` array ensures this for tree edges. For non-tree edges,\n                # we need an additional check, e.g., using a `directed_edges` set.\n                # However, the problem guarantees a solution. The DFS approach for tree edges\n                # and a consistent rule for non-tree edges is usually sufficient.\n                # If an edge (u, v_neighbor) is a back-edge, it means v_neighbor was visited before u.\n                # So we direct v_neighbor -> u.\n                # This means u receives flow c_flow.\n                # This assumes that the edge direction has not been set by DFS from v_neighbor.\n                # This is true if v_neighbor is an ancestor of u.\n                # If v_neighbor is not an ancestor, it's a cross-edge.\n                # For simplicity, if visited[v_neighbor] and v_neighbor != p, assume v_neighbor -> u.\n                # This means `u` receives `c_flow`.\n                # This implies `current_net_flow_in_subtree += c_flow`.\n                # However, this logic is incorrect. If `v_neighbor` is visited, its `net_flow_sum` has already been resolved.\n                # The contribution of this edge to `u`'s balance must be determined by the flow conservation at `u`.\n\n                # The correct way to handle non-tree edges in this DFS approach:\n                # If `v_neighbor` is visited and `v_neighbor != p`, it means `v_neighbor` is an ancestor or a node in another subtree.\n                # In a max-flow DAG, flow always goes from source to sink.\n                # If `v_neighbor` was visited earlier in DFS than `u`, then `v_neighbor` is \"closer\" to the source.\n                # So, flow should go `v_neighbor -> u`.\n                # This means `u` receives `c_flow` from `v_neighbor`.\n                if visited[v_neighbor] and v_neighbor != p:\n                    # Only direct if not already set.\n                    # We need to ensure each edge is directed exactly once.\n                    # The `adj` list stores (neighbor, flow, original_index).\n                    # We can use a `directed_status` array for this.\n                    if result[edge_idx] == 0: # Check if it's still default (undirected)\n                        # This edge is from v_neighbor to u (v_neighbor -> u).\n                        result[edge_idx] = 1 # Set direction to v_neighbor -> u\n                        current_net_flow_in_subtree += c_flow\n                    # If result[edge_idx] is already 1, it means u -> v_neighbor has been set by previous DFS call.\n                    # This implies v_neighbor was a child of u, which is a contradiction with `visited[v_neighbor]`.\n                    # So this check is for robustness.\n                    \n        # After processing all neighbors (children in DFS tree and back/cross edges):\n        # `current_net_flow_in_subtree` now represents the net flow for `u` from its children and non-tree edges.\n        # If `u` is the sink node (`n`), it should accumulate all incoming flow.\n        # If `u` is the source node (`1`), it should send out all its flow.\n        # If `u` is an intermediate node (`1 < u < n`), its net flow must be 0.\n        \n        # The DFS function should return the net flow that needs to be passed to its parent `p`.\n        # This net flow is `current_net_flow_in_subtree`.\n        # For node `u`, its balance `net_flow_sum[u]` should be `current_net_flow_in_subtree`.\n        # This will be used by its parent to decide the direction of the (p, u) edge.\n        return current_net_flow_in_subtree\n\n    # Start DFS from source vertex 1.\n    # The parent of source is None, represented by 0.\n    dfs(1, 0)\n\n    # Print results\n    for d in result:\n        sys.stdout.write(str(d) + '\\n')\n\nsolve()\n\n```\nThe DFS logic for handling edge directions and flow balance is subtle. Let's refine `dfs(u, p)`:\n\n`dfs(u, p)` should return the net flow that `u` *pushes towards* `p` (if positive) or *pulls from* `p` (if negative). This is the flow that `u` and its entire subtree needs to balance with the rest of the graph via the `(u, p)` edge.\n\n1.  Initialize `visited[u] = True`.\n2.  Initialize `flow_imbalance_at_u = 0`. This variable will accumulate the net flow that `u` needs to pass to/from its parent `p`.\n3.  For each edge `(u, v_neighbor)` with flow `c_flow` (and original index `edge_idx`):\n    a.  If `v_neighbor == p`, skip (don't go back to parent).\n    b.  If `v_neighbor` is *not* visited:\n        i.  `child_imbalance = dfs(v_neighbor, u)`. This is the net flow `v_neighbor` needs to pass to/from `u`.\n        ii. If `child_imbalance > 0`: `v_neighbor` wants to send `c_flow` to `u`. So, `v_neighbor -> u`. Set `result[edge_idx] = 1`. Add `c_flow` to `flow_imbalance_at_u`.\n        iii. If `child_imbalance <= 0`: `v_neighbor` wants to receive `c_flow` from `u`. So, `u -> v_neighbor`. Set `result[edge_idx] = 0`. Subtract `c_flow` from `flow_imbalance_at_u`.\n    c.  If `v_neighbor` *is* visited (and `v_neighbor != p`): This is a back-edge or cross-edge.\n        i.  To ensure acyclicity, flow should go from the node visited earlier to the node visited later in DFS. Since `v_neighbor` is already visited, it means `v_neighbor` was visited *before* `u`. So, direct `v_neighbor -> u`.\n        ii. This means `u` receives `c_flow` from `v_neighbor`. Add `c_flow` to `flow_imbalance_at_u`.\n        iii. Set `result[edge_idx] = 1`. (This assumes `result[edge_idx]` was not set by DFS from `v_neighbor`'s side. If `v_neighbor` is an ancestor of `u`, it's not set. If `v_neighbor` is in another subtree, it might have been set.)\n        To prevent double processing or conflicting directions, we can use a `directed` array for edges. `directed[edge_idx]` stores if it's directed.\n        \nLet's refine the handling of `visited` and `result` to ensure each edge is processed once.\nWe can use a `set` of `(u, v)` tuples for directed edges or just rely on the `result` array's initial state.\n\n```python\nimport sys\n\n# Optimized input reading\ninput = sys.stdin.readline\n\ndef solve():\n    n, m = map(int, input().split())\n\n    adj = [[] for _ in range(n + 1)]\n    # Store edges as (neighbor, flow_capacity, original_index)\n    # original_index is crucial for outputting directions in the correct order\n    for i in range(m):\n        u, v, c = map(int, input().split())\n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n\n    # result[i] will store 0 if the i-th edge is a -> b, and 1 if b -> a.\n    # Initialize with a default value (e.g., -1) to indicate not yet directed.\n    result = [-1] * m\n    \n    # visited[v] to keep track of visited nodes in DFS\n    visited = [False] * (n + 1)\n\n    # dfs(u, p) returns the net flow that needs to be passed through the edge (u, p)\n    # to balance node u and its entire subtree.\n    # A positive return value means u wants to send flow UP to p. (p <- u)\n    # A negative return value means u wants to receive flow FROM p. (p -> u)\n    # The magnitude of this value will be the total flow on the edge (u, p).\n    def dfs(u, p):\n        visited[u] = True\n        \n        # This variable accumulates the net flow that needs to be passed through (u, p)\n        # to balance u and its children.\n        # If positive, u needs to send this amount to p.\n        # If negative, u needs to receive this amount from p.\n        net_flow_imbalance_at_u = 0\n\n        for v, c, edge_idx in adj[u]:\n            if v == p:\n                continue # Skip the edge to parent\n\n            if result[edge_idx] != -1: # This edge has already been directed by another DFS call\n                # This can happen for non-tree edges (cross-edges) where v was processed,\n                # and (v, u) was directed as v -> u.\n                # If result[edge_idx] is 0, it means u -> v. So u sends c.\n                # If result[edge_idx] is 1, it means v -> u. So u receives c.\n                # We need to reflect this in u's balance.\n                if result[edge_idx] == 0: # u -> v\n                    net_flow_imbalance_at_u -= c\n                else: # v -> u\n                    net_flow_imbalance_at_u += c\n                continue\n\n            if not visited[v]:\n                # This is a tree edge (u, v). v is a child of u in the DFS tree.\n                \n                # Recursively call DFS for the child v.\n                # child_imbalance will be the net flow that v needs to pass to/from u.\n                child_imbalance = dfs(v, u)\n\n                # Determine direction of (u, v) based on child_imbalance:\n                if child_imbalance > 0:\n                    # v has an excess of incoming flow from its subtree, needs to send it to u.\n                    # So, direction is v -> u.\n                    result[edge_idx] = 1 # v -> u\n                    net_flow_imbalance_at_u += c # u receives flow c from v\n                else: # child_imbalance <= 0\n                    # v needs flow from u (or is balanced and doesn't care, but u still has to provide flow if needed by its other children).\n                    # So, direction is u -> v.\n                    result[edge_idx] = 0 # u -> v\n                    net_flow_imbalance_at_u -= c # u sends flow c to v\n\n            else:\n                # This is a back-edge or cross-edge (u, v) where v is already visited and v != p.\n                # To maintain acyclicity, flow should go from the node visited earlier to the node visited later.\n                # Since v is visited, it was visited before u (or is an ancestor).\n                # So, direct v -> u.\n                result[edge_idx] = 1 # v -> u\n                net_flow_imbalance_at_u += c # u receives flow c from v\n        \n        # After processing all neighbors, net_flow_imbalance_at_u holds the total\n        # net flow that u needs to send/receive through its parent edge (u, p).\n        # Except for the sink node (n), which can accumulate all flow.\n        if u == n:\n            # The sink node 'n' does not need to balance its flow to 0.\n            # It should accumulate all incoming flow.\n            # So, it doesn't need to pass any flow up to its parent for balancing.\n            # It effectively \"absorbs\" all the flow.\n            return 0 # Signifies that 'n' is balanced w.r.t. its parent.\n        \n        # For intermediate nodes (1 < u < n), net_flow_imbalance_at_u must be 0.\n        # This is guaranteed by the problem statement that a solution exists.\n        # So, whatever the value of net_flow_imbalance_at_u is, that's what u needs to pass to its parent.\n        return net_flow_imbalance_at_u\n\n    # Start DFS from source vertex 1. Parent of source is 0 (dummy).\n    dfs(1, 0)\n\n    # Print results\n    for d in result:\n        sys.stdout.write(str(d) + '\\n')\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\n# Optimized input reading\ninput = sys.stdin.readline\n\ndef solve():\n    n, m = map(int, input().split())\n\n    adj = [[] for _ in range(n + 1)]\n    # Store edges as (neighbor, flow_capacity, original_index)\n    # original_index is crucial for outputting directions in the correct order\n    for i in range(m):\n        u, v, c = map(int, input().split())\n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n\n    # result[i] will store 0 if the i-th edge is a -> b, and 1 if b -> a.\n    # Initialize with a default value (e.g., -1) to indicate not yet directed.\n    result = [-1] * m\n    \n    # visited[v] to keep track of visited nodes in DFS\n    visited = [False] * (n + 1)\n\n    # dfs(u, p) returns the net flow that needs to be passed through the edge (u, p)\n    # to balance node u and its entire subtree.\n    # A positive return value means u wants to send flow UP to p. (p <- u)\n    # A negative return value means u wants to receive flow FROM p. (p -> u)\n    # The magnitude of this value will be the total flow on the edge (u, p).\n    def dfs(u, p):\n        visited[u] = True\n        \n        # This variable accumulates the net flow that needs to be passed through (u, p)\n        # to balance u and its children.\n        # If positive, u needs to send this amount to p.\n        # If negative, u needs to receive this amount from p.\n        net_flow_imbalance_at_u = 0\n\n        for v, c, edge_idx in adj[u]:\n            if v == p:\n                continue # Skip the edge to parent\n\n            if result[edge_idx] != -1: # This edge has already been directed by another DFS call\n                # This can happen for non-tree edges (cross-edges) where v was processed,\n                # and (v, u) was directed as v -> u.\n                # If result[edge_idx] is 0, it means u -> v. So u sends c.\n                # If result[edge_idx] is 1, it means v -> u. So u receives c.\n                # We need to reflect this in u's balance.\n                if result[edge_idx] == 0: # u -> v\n                    net_flow_imbalance_at_u -= c\n                else: # v -> u\n                    net_flow_imbalance_at_u += c\n                continue\n\n            if not visited[v]:\n                # This is a tree edge (u, v). v is a child of u in the DFS tree.\n                \n                # Recursively call DFS for the child v.\n                # child_imbalance will be the net flow that v needs to pass to/from u.\n                child_imbalance = dfs(v, u)\n\n                # Determine direction of (u, v) based on child_imbalance:\n                if child_imbalance > 0:\n                    # v has an excess of incoming flow from its subtree, needs to send it to u.\n                    # So, direction is v -> u.\n                    result[edge_idx] = 1 # v -> u\n                    net_flow_imbalance_at_u += c # u receives flow c from v\n                else: # child_imbalance <= 0\n                    # v needs flow from u (or is balanced and doesn't care, but u still has to provide flow if needed by its other children).\n                    # So, direction is u -> v.\n                    result[edge_idx] = 0 # u -> v\n                    net_flow_imbalance_at_u -= c # u sends flow c to v\n\n            else:\n                # This is a back-edge or cross-edge (u, v) where v is already visited and v != p.\n                # To maintain acyclicity, flow should go from the node visited earlier to the node visited later.\n                # Since v is visited, it was visited before u (or is an ancestor).\n                # So, direct v -> u.\n                result[edge_idx] = 1 # v -> u\n                net_flow_imbalance_at_u += c # u receives flow c from v\n        \n        # After processing all neighbors, net_flow_imbalance_at_u holds the total\n        # net flow that u needs to send/receive through its parent edge (u, p).\n        # Except for the sink node (n), which can accumulate all flow.\n        if u == n:\n            # The sink node 'n' does not need to balance its flow to 0.\n            # It should accumulate all incoming flow.\n            # So, it doesn't need to pass any flow up to its parent for balancing.\n            # It effectively \"absorbs\" all the flow.\n            return 0 # Signifies that 'n' is balanced w.r.t. its parent.\n        \n        # For intermediate nodes (1 < u < n), net_flow_imbalance_at_u must be 0.\n        # This is guaranteed by the problem statement that a solution exists.\n        # So, whatever the value of net_flow_imbalance_at_u is, that's what u needs to pass to its parent.\n        return net_flow_imbalance_at_u\n\n    # Start DFS from source vertex 1. Parent of source is 0 (dummy).\n    dfs(1, 0)\n\n    # Print results\n    for d in result:\n        sys.stdout.write(str(d) + '\\n')\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 746,
        "completion_token_count": 8250,
        "thoughts_token_count": 790
    }
}