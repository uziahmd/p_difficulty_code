{
    "start": 1758284945.4272242,
    "end": 1758285011.713603,
    "start-formatted": "2025-09-19 21:29 KST",
    "end-formatted": "2025-09-19 21:30 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "**Tackling the Odd Cycle Problem**\n\nOkay, so I'm facing this competitive programming problem. I need to figure out the minimum number of edges, `t`, and the number of ways, `w`, to add edges to an undirected graph to create an odd-length cycle. My first instinct is to dive into the core properties of odd cycles and how they relate to the graph's structure.\n\nThe key observation here is that a graph contains an odd cycle if and only if it's not bipartite. Simple enough. So, if I can determine if the original graph is bipartite, I can immediately solve the problem. If it *is* bipartite, the answer is `t=1` and `w` will be determined by how many ways I can add an edge to make the bipartite graph not bipartite.\n\nIf there's already an odd cycle in the input graph, then I'm done. `t = 0` and `w = 1` - the problem's trivial in this case. My main focus shifts to bipartite graphs. If the original graph isn't bipartite, I'll need to use a bipartite checking algorithm and apply the same logic as the initial graph.\n\nIf the graph *is* bipartite, I can decompose it into connected components. Within each component, I can partition the nodes into two sets, U and V.  Adding a single edge between two nodes *within* the same partition (either both in U or both in V) will result in an odd cycle. This is because any path between those two nodes within the component is going to be even, and adding that edge makes it odd.\n\nNow, to calculate the number of ways to add that single edge, I'll have to consider each connected component individually. The number of ways to pick two nodes from within U is  `|U| * (|U| - 1) / 2`, and similarly, the number of ways to pick two nodes within V is  `|V| * (|V| - 1) / 2`. The total number of ways to create an odd cycle is the sum of these calculations across all connected components. It's a matter of counting pairs, essentially. I must remember that the new added edge cannot already exist, and that only adding an edge creates a simple cycle of odd length; if `t=1`, then the `w` will be determined by the added edge, and its interactions with the base bipartite graph.\n",
    "response": "The problem asks us to find the minimum number of edges `t` to add to a given undirected graph to form a simple cycle of odd length, and `w` - the number of ways to do so.\n\nA graph contains an odd cycle if and only if it is not bipartite. If the graph is bipartite, all its cycles are of even length. Adding an edge `(u, v)` to a bipartite graph can create an odd cycle if and only if `u` and `v` are in the same connected component and belong to the same partition (have the same color) in a 2-coloring.\n\nWe can analyze the problem by considering the minimum number of edges `t` required:\n\n**Case 0: `t = 0`**\nIf the graph already contains an odd cycle, then `t = 0` and `w = 1`.\nTo check this, we can perform a 2-coloring (bipartite check) on each connected component using BFS or DFS.\nDuring the 2-coloring process:\n1. Start BFS/DFS from an unvisited vertex `s`, assign it color 0.\n2. For each neighbor `v` of a vertex `u`:\n   a. If `v` is unvisited, assign it the opposite color of `u` and continue traversal.\n   b. If `v` is visited and has the same color as `u`, then we have found an edge connecting two vertices of the same color. This indicates an odd cycle in the current connected component. In this case, `t = 0` and `w = 1`. We can immediately print the result and exit.\n\n**Case 1: `t = 1`**\nIf the graph does not contain an odd cycle (i.e., all its connected components are bipartite), we need to add at least one edge.\nTo form an odd cycle by adding one edge `(u, v)`, `u` and `v` must satisfy two conditions:\n1. `u` and `v` must be in the same connected component.\n2. `u` and `v` must have the same color in the 2-coloring of that component.\n3. The edge `(u, v)` must not already exist.\n\nLet's perform the 2-coloring for all connected components. For each component `C_i`, let `N_0_i` be the number of vertices in partition 0 and `N_1_i` be the number of vertices in partition 1.\nThe number of pairs `(u, v)` within `C_i` such that `u` and `v` have the same color is `N_0_i * (N_0_i - 1) / 2 + N_1_i * (N_1_i - 1) / 2`.\nWe need to subtract any existing edges between vertices of the same color. Since the graph is bipartite, there are no such edges.\nSo, the total number of ways to add one edge to form an odd cycle is the sum over all components `C_i`:\n`w = sum(N_0_i * (N_0_i - 1) / 2 + N_1_i * (N_1_i - 1) / 2)` for all `i`.\nIf `w > 0`, then `t = 1`. We print `1` and `w`.\n\n**Case 2: `t = 2`**\nIf `t` is not 0 or 1, it means the graph is bipartite and adding one edge within any component does not form an odd cycle. This implies that for every component `C_i`, either `N_0_i < 2` or `N_1_i < 2`. This means each component is either a single vertex, or a path of length at most 1 (an edge or two disconnected vertices). In essence, each component has at most one vertex in one partition, and at most one vertex in the other partition. This is not quite right. If `N_0_i * (N_0_i - 1) / 2 + N_1_i * (N_1_i - 1) / 2 = 0`, it means `N_0_i < 2` AND `N_1_i < 2`. So, each component has at most 1 vertex in each partition. This means each component is either an isolated vertex or an isolated edge.\nIn this scenario, to form an odd cycle, we must connect two different connected components.\nSuppose we have `k` connected components. We need to select two distinct components, say `C_i` and `C_j`.\nWe pick a vertex `u` from `C_i` and a vertex `v` from `C_j`. We add an edge `(u, v)`.\nNow, `u` and `v` are in the same component. To form an odd cycle, we need to add another edge `(x, y)` such that `x` and `y` are in the same component (the new merged component) and have the same color.\nIf we add an edge `(u, v)`, the component `C_i` and `C_j` merge. Let `u` have color `c_u` in `C_i` and `v` have color `c_v` in `C_j`. We can re-color `C_j` if needed so that `c_u` and `c_v` are different (e.g., if `u` is 0 and `v` is 0, we can flip `C_j` to make `v` 1). After this, the merged component is bipartite.\nNow we need to add an edge within this merged component that connects two vertices of the same color.\nThis means we need to add two edges: `(u, v)` and `(x, y)`.\nThe minimum `t` for this would be 2.\nWe need to pick two vertices `u` and `v` from different components, say `C_i` and `C_j`, and an edge `(u,v)`. Then we pick two vertices `x` and `y` from the newly formed component `C_i \\cup C_j` (or other components) that are of the same color, and add edge `(x,y)`.\nThis seems complicated. Let's simplify.\nIf `t=1` is not possible, it means every component is an isolated vertex or an isolated edge.\nIf we have `k` isolated vertices (components of size 1) and `l` isolated edges (components of size 2).\nTotal vertices `n = k + 2l`.\nTo form an odd cycle with two edges:\n1. Pick two distinct isolated vertices `u, v`. Add edge `(u, v)`. Now we have a component `u-v`. This is bipartite. We need another edge. But we can't add an edge within `u-v` to form an odd cycle. If we add `(u,x)` and `(v,x)`, we form a triangle. This needs 3 vertices.\n2. Pick an isolated vertex `u` and an isolated edge `v-w`. Add edge `(u, v)`. Now we have a path `w-v-u`. This is bipartite. We can add edge `(u, w)` to form a triangle `u-v-w`. This uses 2 edges.\n   Number of ways: `k` choices for `u`, `l` choices for `v-w`, 2 choices for which endpoint of `v-w` to connect to `u` (say `v`), then connect `u` to `w`.\n   So `k * l * 2` ways.\nThis forms a triangle, which is an odd cycle. So `t = 2` is possible if `k > 0` and `l > 0`.\n\nWhat if `k = 0` (only isolated edges) or `l = 0` (only isolated vertices)?\nIf `l = 0`, all components are isolated vertices. `n` isolated vertices.\nTo form an odd cycle, we need at least 3 vertices.\nWe pick 3 distinct vertices `u, v, w`. Add edges `(u, v)`, `(v, w)`, `(w, u)`. This forms a triangle. `t = 3`.\nNumber of ways: `n * (n - 1) * (n - 2) / 6`.\nIf `k = 0`, all components are isolated edges. `m` isolated edges. `2m` vertices.\nPick two edges `e1=(u,v)` and `e2=(x,y)`.\nAdd `(u,x)` and `(v,y)`. This forms a cycle `u-e1-v-y-e2-x-u`. Length 4. Even.\nAdd `(u,x)` and `(v,x)`. This forms `u-e1-v-x-u`. Length 3. Odd.\nNumber of ways: `l * (l - 1) / 2` ways to choose two edges.\nFor each pair of edges `(u,v)` and `(x,y)`, there are 4 ways to connect them to form a triangle:\n  `(u,x), (v,x)`\n  `(u,y), (v,y)`\n  `(v,x), (u,x)` (same as first)\n  `(v,y), (u,y)` (same as second)\nSo 2 distinct ways to choose the connections: `(u,x), (v,x)` or `(u,y), (v,y)`.\nTotal ways: `l * (l - 1) / 2 * 2 = l * (l - 1)`.\nThis forms a triangle, which is an odd cycle. So `t = 2` is possible if `l > 1`.\n\nCombining `t=2` analysis:\nIf `k > 0` and `l > 0`: `t = 2`, `w = k * l * 2`.\nIf `k = 0` and `l > 1`: `t = 2`, `w = l * (l - 1)`.\nIf `k > 2` and `l = 0`: `t = 3`, `w = n * (n - 1) * (n - 2) / 6`.\n\nLet's refine the logic for `t=2`.\nIf `t=1` is not possible, it means for every component `C_i`, `N_0_i < 2` AND `N_1_i < 2`. This implies each component is either an isolated vertex or an isolated edge.\nLet `num_isolated_vertices` be the count of components with 1 vertex.\nLet `num_isolated_edges` be the count of components with 2 vertices (an edge).\nLet `num_components = num_isolated_vertices + num_isolated_edges`.\n\nIf `num_isolated_vertices > 0` and `num_isolated_edges > 0`:\n   We can pick an isolated vertex `u` and an isolated edge `(v, w)`. Add edges `(u, v)` and `(u, w)`. This forms a triangle `u-v-w-u`.\n   `t = 2`.\n   `w = num_isolated_vertices * num_isolated_edges * 2` (2 ways to connect `u` to the endpoints of `(v,w)`).\n   Example: `u` to `v`, `u` to `w`. Or `u` to `w`, `u` to `v`. These are the same set of edges.\n   No, it's `u` connected to `v` and `u` connected to `w`. This is one way for a choice of `u` and `(v,w)`.\n   The two choices are: connect `u` to `v` and `u` to `w`. This is one way.\n   The `2` comes from picking an isolated vertex `u` (1 way), picking an isolated edge `(v,w)` (1 way).\n   The two edges to add are `(u,v)` and `(u,w)`.\n   This is `num_isolated_vertices * num_isolated_edges` ways.\n\n   Wait, the example output `3 0` -> `3 1`. `n=3, m=0`.\n   Components: {1}, {2}, {3}. `num_isolated_vertices = 3`, `num_isolated_edges = 0`.\n   My logic: `k=3, l=0`. `t=3`, `w = 3*2*1/6 = 1`. This matches.\n\n   Example output `4 4`, edges `(1,2), (1,3), (4,2), (4,3)`.\n   Component 1: {1,2,3,4}.\n   Coloring: 1(0), 2(1), 3(1), 4(0).\n   Edge (1,2): 0-1 OK\n   Edge (1,3): 0-1 OK\n   Edge (4,2): 0-1 OK\n   Edge (4,3): 0-1 OK\n   This component is bipartite.\n   Partition 0: {1, 4}, Partition 1: {2, 3}.\n   `N_0 = 2`, `N_1 = 2`.\n   Ways to add 1 edge: `N_0 * (N_0 - 1) / 2 + N_1 * (N_1 - 1) / 2`\n   `= 2 * 1 / 2 + 2 * 1 / 2 = 1 + 1 = 2`.\n   So `t = 1`, `w = 2`. This matches example output `1 2`.\n\n   Let's re-evaluate `t=2` logic.\n   If `t=1` is not possible, it means all components `C_i` have `N_0_i < 2` AND `N_1_i < 2`.\n   This means each component `C_i` is either:\n   1. An isolated vertex (e.g., `{v}`, `N_0=1, N_1=0` or `N_0=0, N_1=1`).\n   2. An isolated edge (e.g., `{u,v}` with edge `(u,v)`, `N_0=1, N_1=1`).\n\n   Let `V_iso` be the set of isolated vertices. `num_V_iso = |V_iso|`.\n   Let `E_iso` be the set of isolated edges. `num_E_iso = |E_iso|`.\n\n   To get `t=2`:\n   **Option A: Connect an isolated vertex to an isolated edge.**\n   Pick `u \\in V_iso` (1 way). Pick `(v,w) \\in E_iso` (1 way).\n   Add edges `(u,v)` and `(u,w)`. This forms a triangle `u-v-w-u`. This is an odd cycle.\n   Number of ways: `num_V_iso * num_E_iso`. (Each pair `(u, (v,w))` gives one way of adding edges).\n   This is valid if `num_V_iso > 0` and `num_E_iso > 0`.\n\n   **Option B: Connect two isolated edges.**\n   Pick `(u,v) \\in E_iso` (1 way). Pick `(x,y) \\in E_iso`, `(x,y) \\ne (u,v)` (1 way).\n   Add edges `(u,x)` and `(v,x)`. This forms a triangle `u-v-x-u`. This is an odd cycle.\n   Number of ways to choose two distinct isolated edges: `num_E_iso * (num_E_iso - 1) / 2`.\n   For each pair of edges `(u,v)` and `(x,y)`, there are 2 ways to form a triangle:\n     1. Add `(u,x)` and `(v,x)`.\n     2. Add `(u,y)` and `(v,y)`.\n   So, `(num_E_iso * (num_E_iso - 1) / 2) * 2 = num_E_iso * (num_E_iso - 1)`.\n   This is valid if `num_E_iso > 1`.\n\n   If `t=2` is the minimum:\n   `w = (num_V_iso * num_E_iso) + (num_E_iso * (num_E_iso - 1))`.\n   This is valid if `num_V_iso > 0` and `num_E_iso > 0`, OR `num_E_iso > 1`.\n\n   **Case 3: `t = 3`**\n   If `t=2` is not possible, it means:\n   - `num_V_iso = 0` OR `num_E_iso = 0`. AND\n   - `num_E_iso < 2`.\n   Combining these: `num_E_iso` must be 0 or 1.\n   If `num_E_iso = 0`: All components are isolated vertices.\n     We need at least 3 vertices to form a triangle.\n     Pick 3 distinct isolated vertices `u, v, w`. Add edges `(u,v), (v,w), (w,u)`.\n     `t = 3`.\n     `w = num_V_iso * (num_V_iso - 1) * (num_V_iso - 2) / 6`.\n     This is valid if `num_V_iso > 2`.\n   If `num_E_iso = 1`: This means there's one isolated edge `(u,v)` and the rest are isolated vertices.\n     The `num_V_iso` must be 0 for `t=2` not to be possible.\n     So, `num_E_iso = 1` and `num_V_iso = 0`.\n     This means the graph is just one isolated edge. `n=2, m=1`.\n     To form an odd cycle, we need at least 3 vertices. This is impossible with `n=2`.\n     Wait, the problem states `n` vertices and `m` edges. `n` can be larger than `2m`.\n     If `num_E_iso = 1` and `num_V_iso = 0`, it implies `n=2, m=1`.\n     Then `t=3` is not possible, as we need 3 vertices.\n     This means `n` must be at least 3 to form any cycle. If `n < 3`, no cycle is possible.\n     The problem states \"simple cycle of an odd length, consisting of more than one vertex\". A cycle must have at least 3 vertices.\n     So if `n < 3`, `t` is impossible. The problem constraints `1 <= n <= 100000`. So `n` can be 1 or 2.\n\nLet's organize the logic:\n\n1. **Initialization:**\n   `adj`: adjacency list.\n   `color`: array for 2-coloring, -1 for unvisited.\n   `visited_comp`: array to track visited vertices for component processing.\n   `is_bipartite = True`.\n   `num_isolated_vertices = 0`.\n   `num_isolated_edges = 0`.\n   `total_vertices_in_bipartite_components = 0`.\n   `total_edges_in_bipartite_components = 0`.\n\n2. **Iterate through vertices to find components and check bipartiteness:**\n   For `v` from 1 to `n`:\n     If `v` is not visited (`visited_comp[v]` is false):\n       `current_comp_nodes = 0`.\n       `current_comp_edges = 0`.\n       `count_color_0 = 0`.\n       `count_color_1 = 0`.\n       `q = deque([(v, 0)])` (vertex, color).\n       `visited_comp[v] = True`.\n       `color[v] = 0`.\n       `count_color_0 = 1`.\n       `current_comp_nodes = 1`.\n       `comp_bipartite = True`.\n       `q_nodes = [v]` (nodes in current component for later processing).\n\n       BFS loop:\n       While `q` is not empty:\n         `u, c = q.popleft()`.\n         For `neighbor` in `adj[u]`:\n           `current_comp_edges += 1`.\n           If `color[neighbor] == -1`: // Unvisited\n             `color[neighbor] = 1 - c`.\n             If `1 - c == 0`: `count_color_0 += 1`.\n             Else: `count_color_1 += 1`.\n             `visited_comp[neighbor] = True`.\n             `current_comp_nodes += 1`.\n             `q.append((neighbor, 1 - c))`.\n             `q_nodes.append(neighbor)`.\n           Else if `color[neighbor] == c`: // Same color, odd cycle found\n             `is_bipartite = False`.\n             `comp_bipartite = False`.\n             Break BFS.\n         If not `comp_bipartite`: Break BFS.\n\n       If not `is_bipartite`:\n         Print `0 1` and exit.\n\n       // If current component is bipartite, store its properties\n       If `comp_bipartite`:\n         `current_comp_edges /= 2` (each edge counted twice).\n         If `current_comp_nodes == 1`:\n           `num_isolated_vertices += 1`.\n         Else if `current_comp_nodes == 2` and `current_comp_edges == 1`:\n           `num_isolated_edges += 1`.\n         Else: // A bipartite component with more than 2 vertices or more than 1 edge\n           `total_vertices_in_bipartite_components += current_comp_nodes`.\n           `total_edges_in_bipartite_components += current_comp_edges`.\n           `num_V_0 += count_color_0`.\n           `num_V_1 += count_color_1`.\n\n3. **If the graph is bipartite (no odd cycle found yet):**\n   `t = -1`, `w = -1`.\n\n   **Check for `t = 1`:**\n   `ways_t1 = 0`.\n   If `total_vertices_in_bipartite_components > 0`: // Components that are not just isolated vertices/edges\n     `ways_t1 = num_V_0 * (num_V_0 - 1) // 2 + num_V_1 * (num_V_1 - 1) // 2`.\n     // Subtract existing edges if any, but `num_V_0` and `num_V_1` count vertices across all \"complex\" bipartite components.\n     // This means `ways_t1` counts all pairs of same-colored vertices in these components.\n     // These components are bipartite, so no existing edges connect same-colored vertices.\n     // So `ways_t1` is correct.\n     If `ways_t1 > 0`:\n       Print `1 ways_t1` and exit.\n\n   **Check for `t = 2`:**\n   `ways_t2 = 0`.\n   If `num_isolated_vertices > 0` and `num_isolated_edges > 0`:\n     `ways_t2 += num_isolated_vertices * num_isolated_edges`.\n   If `num_isolated_edges > 1`:\n     `ways_t2 += num_isolated_edges * (num_isolated_edges - 1)`.\n\n   If `ways_t2 > 0`:\n     Print `2 ways_t2` and exit.\n\n   **Check for `t = 3`:**\n   If `num_isolated_vertices > 2`:\n     `ways_t3 = num_isolated_vertices * (num_isolated_vertices - 1) * (num_isolated_vertices - 2) // 6`.\n     Print `3 ways_t3` and exit.\n\n   **What if none of the above?**\n   This means `n < 3` or no way to form a cycle.\n   The problem guarantees `n >= 1`.\n   If `n=1` or `n=2`, no cycle can be formed.\n   If `n=1`: `num_isolated_vertices = 1`, `num_isolated_edges = 0`. `ways_t1=0, ways_t2=0, ways_t3=0`.\n   If `n=2, m=0`: `num_isolated_vertices = 2`, `num_isolated_edges = 0`. `ways_t1=0, ways_t2=0, ways_t3=0`.\n   If `n=2, m=1`: `num_isolated_vertices = 0`, `num_isolated_edges = 1`. `ways_t1=0, ways_t2=0, ways_t3=0`.\n   In these cases, `t` would be impossible, but the problem implies a solution exists.\n   The minimum number of vertices for an odd cycle is 3. If `n < 3`, no solution.\n   The problem implies a solution exists. This means `n >= 3`.\n   So, one of the above conditions must be met.\n\nLet's refine the component processing for `num_V_0` and `num_V_1`.\nThese should represent the counts of vertices in partitions 0 and 1, respectively, *across all components that are not isolated vertices or isolated edges*.\n\nRevised logic for `num_V_0` and `num_V_1`:\nInitialize `num_V_0 = 0`, `num_V_1 = 0`.\nWhen processing a bipartite component:\n  If `current_comp_nodes == 1`: `num_isolated_vertices += 1`.\n  Else if `current_comp_nodes == 2` and `current_comp_edges == 1`: `num_isolated_edges += 1`.\n  Else: `num_V_0 += count_color_0`, `num_V_1 += count_color_1`.\n\nThis should cover all cases.\n\n```python\nimport sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n\n    color = [-1] * (n + 1) # -1: unvisited, 0: color 0, 1: color 1\n    visited_comp = [False] * (n + 1) # visited for component finding\n\n    # Variables for t=0 check\n    found_odd_cycle_in_graph = False\n\n    # Variables for t=1 check\n    num_V0_complex_bipartite = 0 # Count of vertices in partition 0 from \"complex\" bipartite components\n    num_V1_complex_bipartite = 0 # Count of vertices in partition 1 from \"complex\" bipartite components\n\n    # Variables for t=2 and t=3 check\n    num_isolated_vertices = 0 # Components with 1 vertex\n    num_isolated_edges = 0    # Components with 2 vertices and 1 edge\n\n    for i in range(1, n + 1):\n        if not visited_comp[i]:\n            # Start BFS for a new component\n            q = deque()\n            q.append((i, 0)) # (vertex, color)\n            color[i] = 0\n            visited_comp[i] = True\n\n            current_comp_nodes = 0\n            current_comp_edges_count = 0 # To count edges within this component\n            current_comp_color0_count = 0\n            current_comp_color1_count = 0\n            \n            comp_is_bipartite = True\n            \n            comp_nodes_list = [] # To get all nodes in this component\n\n            head = 0\n            q_list = [(i, 0)] # Use a list as a deque for performance in some cases, or just use deque\n            \n            while head < len(q_list):\n                u, c = q_list[head]\n                head += 1\n                \n                current_comp_nodes += 1\n                if c == 0:\n                    current_comp_color0_count += 1\n                else:\n                    current_comp_color1_count += 1\n\n                for v_neighbor in adj[u]:\n                    current_comp_edges_count += 1\n                    if color[v_neighbor] == -1: # Unvisited\n                        color[v_neighbor] = 1 - c\n                        visited_comp[v_neighbor] = True\n                        q_list.append((v_neighbor, 1 - c))\n                    elif color[v_neighbor] == c: # Visited and same color -> odd cycle\n                        comp_is_bipartite = False\n                        break\n                if not comp_is_bipartite:\n                    break\n            \n            if not comp_is_bipartite:\n                found_odd_cycle_in_graph = True\n                break # Exit outer loop, no need to check other components\n\n            # If component is bipartite, categorize it\n            current_comp_edges_count //= 2 # Each edge counted twice\n\n            if current_comp_nodes == 1:\n                num_isolated_vertices += 1\n            elif current_comp_nodes == 2 and current_comp_edges_count == 1:\n                num_isolated_edges += 1\n            else: # This is a \"complex\" bipartite component\n                num_V0_complex_bipartite += current_comp_color0_count\n                num_V1_complex_bipartite += current_comp_color1_count\n\n    if found_odd_cycle_in_graph:\n        print(\"0 1\")\n        return\n\n    # Check for t=1\n    ways_t1 = 0\n    if num_V0_complex_bipartite > 0 or num_V1_complex_bipartite > 0:\n        # We can form an odd cycle by adding an edge between two same-colored vertices\n        # within any of the \"complex\" bipartite components.\n        # Since these components are bipartite, no such edges exist initially.\n        ways_t1 = (num_V0_complex_bipartite * (num_V0_complex_bipartite - 1) // 2) + \\\n                  (num_V1_complex_bipartite * (num_V1_complex_bipartite - 1) // 2)\n    \n    if ways_t1 > 0:\n        print(f\"1 {ways_t1}\")\n        return\n\n    # Check for t=2\n    ways_t2 = 0\n    # Option A: Connect an isolated vertex to an isolated edge\n    if num_isolated_vertices > 0 and num_isolated_edges > 0:\n        ways_t2 += num_isolated_vertices * num_isolated_edges\n    \n    # Option B: Connect two isolated edges\n    if num_isolated_edges > 1:\n        ways_t2 += num_isolated_edges * (num_isolated_edges - 1) # Choose 2 edges, say (u,v) and (x,y). Connect (u,x) and (v,x) OR (u,y) and (v,y).\n                                                                # No, it's (num_isolated_edges choose 2) * 2 ways to connect.\n                                                                # (N * (N-1) / 2) * 2 = N * (N-1)\n    if ways_t2 > 0:\n        print(f\"2 {ways_t2}\")\n        return\n    \n    # Check for t=3\n    ways_t3 = 0\n    # Connect three isolated vertices to form a triangle\n    if num_isolated_vertices > 2:\n        ways_t3 = num_isolated_vertices * (num_isolated_vertices - 1) * (num_isolated_vertices - 2) // 6\n    \n    if ways_t3 > 0:\n        print(f\"3 {ways_t3}\")\n        return\n\n    # This case should ideally not be reached if n >= 3, as one of the above will apply.\n    # If n < 3, no cycle is possible, but problem constraints allow n=1,2.\n    # However, problem wording implies a solution always exists.\n    # For n=1,2, m=0 or m=1, the above counts will be 0.\n    # Example: n=3, m=0 -> 3 isolated vertices. num_isolated_vertices=3. -> t=3, w=1.\n    # This path is correct.\n\n    # If we reach here, it means no cycle can be formed. This shouldn't happen for n>=3.\n    # For n=1,2 it would happen, but the problem implies a solution.\n    # For competitive programming, if the problem guarantees a solution,\n    # one of the above conditions must be met.\n    # If n=1 or n=2, it's impossible to form a cycle (min 3 vertices).\n    # The problem implies a solution exists, so perhaps n >= 3 is implicitly assumed for problem-solvable cases.\n    # Or, if n<3, the output could be 0 0 or similar, but not specified.\n    # Given the examples, n=3, m=0 -> 3 1. This implies n=3 is the minimum for t=3.\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n\n    color = [-1] * (n + 1) # -1: unvisited, 0: color 0, 1: color 1\n    visited_comp = [False] * (n + 1) # visited for component finding\n\n    # Variables for t=0 check\n    found_odd_cycle_in_graph = False\n\n    # Variables for t=1 check\n    num_V0_complex_bipartite = 0 # Count of vertices in partition 0 from \"complex\" bipartite components\n    num_V1_complex_bipartite = 0 # Count of vertices in partition 1 from \"complex\" bipartite components\n\n    # Variables for t=2 and t=3 check\n    num_isolated_vertices = 0 # Components with 1 vertex\n    num_isolated_edges = 0    # Components with 2 vertices and 1 edge\n\n    for i in range(1, n + 1):\n        if not visited_comp[i]:\n            # Start BFS for a new component\n            q = deque()\n            q.append((i, 0)) # (vertex, color)\n            color[i] = 0\n            visited_comp[i] = True\n\n            current_comp_nodes = 0\n            current_comp_edges_count = 0 # To count edges within this component\n            current_comp_color0_count = 0\n            current_comp_color1_count = 0\n            \n            comp_is_bipartite = True\n            \n            comp_nodes_list = [] # To get all nodes in this component\n\n            head = 0\n            q_list = [(i, 0)] # Use a list as a deque for performance in some cases, or just use deque\n            \n            while head < len(q_list):\n                u, c = q_list[head]\n                head += 1\n                \n                current_comp_nodes += 1\n                if c == 0:\n                    current_comp_color0_count += 1\n                else:\n                    current_comp_color1_count += 1\n\n                for v_neighbor in adj[u]:\n                    current_comp_edges_count += 1\n                    if color[v_neighbor] == -1: # Unvisited\n                        color[v_neighbor] = 1 - c\n                        visited_comp[v_neighbor] = True\n                        q_list.append((v_neighbor, 1 - c))\n                    elif color[v_neighbor] == c: # Visited and same color -> odd cycle\n                        comp_is_bipartite = False\n                        break\n                if not comp_is_bipartite:\n                    break\n            \n            if not comp_is_bipartite:\n                found_odd_cycle_in_graph = True\n                break # Exit outer loop, no need to check other components\n\n            # If component is bipartite, categorize it\n            current_comp_edges_count //= 2 # Each edge counted twice\n\n            if current_comp_nodes == 1:\n                num_isolated_vertices += 1\n            elif current_comp_nodes == 2 and current_comp_edges_count == 1:\n                num_isolated_edges += 1\n            else: # This is a \"complex\" bipartite component\n                num_V0_complex_bipartite += current_comp_color0_count\n                num_V1_complex_bipartite += current_comp_color1_count\n\n    if found_odd_cycle_in_graph:\n        print(\"0 1\")\n        return\n\n    # Check for t=1\n    ways_t1 = 0\n    if num_V0_complex_bipartite > 0 or num_V1_complex_bipartite > 0:\n        # We can form an odd cycle by adding an edge between two same-colored vertices\n        # within any of the \"complex\" bipartite components.\n        # Since these components are bipartite, no such edges exist initially.\n        ways_t1 = (num_V0_complex_bipartite * (num_V0_complex_bipartite - 1) // 2) + \\\n                  (num_V1_complex_bipartite * (num_V1_complex_bipartite - 1) // 2)\n    \n    if ways_t1 > 0:\n        print(f\"1 {ways_t1}\")\n        return\n\n    # Check for t=2\n    ways_t2 = 0\n    # Option A: Connect an isolated vertex to an isolated edge\n    if num_isolated_vertices > 0 and num_isolated_edges > 0:\n        ways_t2 += num_isolated_vertices * num_isolated_edges\n    \n    # Option B: Connect two isolated edges\n    if num_isolated_edges > 1:\n        ways_t2 += num_isolated_edges * (num_isolated_edges - 1) # Choose 2 edges, say (u,v) and (x,y). Connect (u,x) and (v,x) OR (u,y) and (v,y).\n                                                                # No, it's (num_isolated_edges choose 2) * 2 ways to connect.\n                                                                # (N * (N-1) / 2) * 2 = N * (N-1)\n    if ways_t2 > 0:\n        print(f\"2 {ways_t2}\")\n        return\n    \n    # Check for t=3\n    ways_t3 = 0\n    # Connect three isolated vertices to form a triangle\n    if num_isolated_vertices > 2:\n        ways_t3 = num_isolated_vertices * (num_isolated_vertices - 1) * (num_isolated_vertices - 2) // 6\n    \n    if ways_t3 > 0:\n        print(f\"3 {ways_t3}\")\n        return\n\n    # This case should ideally not be reached if n >= 3, as one of the above will apply.\n    # If n < 3, no cycle is possible, but problem constraints allow n=1,2.\n    # However, problem wording implies a solution always exists.\n    # For n=1,2, m=0 or m=1, the above counts will be 0.\n    # Example: n=3, m=0 -> 3 isolated vertices. num_isolated_vertices=3. -> t=3, w=1.\n    # This path is correct.\n\n    # If we reach here, it means no cycle can be formed. This shouldn't happen for n>=3.\n    # For n=1,2 it would happen, but the problem implies a solution.\n    # For competitive programming, if the problem guarantees a solution,\n    # one of the above conditions must be met.\n    # If n=1 or n=2, it's impossible to form a cycle (min 3 vertices).\n    # The problem implies a solution exists, so perhaps n >= 3 is implicitly assumed for problem-solvable cases.\n    # Or, if n<3, the output could be 0 0 or similar, but not specified.\n    # Given the examples, n=3, m=0 -> 3 1. This implies n=3 is the minimum for t=3.\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 603,
        "completion_token_count": 7843,
        "thoughts_token_count": 775
    }
}