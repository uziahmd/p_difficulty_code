{
    "start": 1758284907.7761467,
    "end": 1758284980.9316168,
    "start-formatted": "2025-09-19 21:28 KST",
    "end-formatted": "2025-09-19 21:29 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "**Solving the Odd Cycle Problem**\n\nAlright, let's break this down. I've got this competitive programming problem: minimize the added edges and count the ways to create an odd-length cycle in a graph.  The core challenge is finding the smallest number of edges and how many different ways to add them. The graph is simple, so no loops or parallel edges allowed.\n\nMy initial thought is to tackle this by checking for odd cycles first and then figure out how to add edges to make an odd cycle when needed.  The key concept I'm working with is the connection between odd cycles and bipartite graphs. A graph *has* an odd cycle if and only if it's *not* bipartite.  If the graph already contains an odd cycle, I know `t` (the number of added edges) is zero and `w` (the number of ways) is just one. That's my first check: see if there's already an odd cycle.\n\nHow to check if the graph is bipartite?  I'll use BFS or DFS for 2-coloring. I'll start at a vertex, color it, and then color its neighbors with the opposite color, and so on. If I encounter a conflict, like trying to assign a different color to a vertex that already has one, or an edge connecting two vertices of the same color, then I've found an odd cycle, and the graph isn't bipartite.\n\nSo, here's my plan:\n\n**Case 1: Existing Odd Cycles:** Iterate through the connected components. If any component isn't bipartite, I've got an odd cycle already.  In this case, `t = 0` and `w = 1`.\n\n**Case 2:  No Odd Cycles (Graph is bipartite):** If everything is bipartite, I have to *add* edges.  Since a bipartite graph only has even-length cycles, I need to add an edge to make an odd cycle. To do that, I'll need to add an edge between two nodes of the *same* color *within* the *same connected component.* If I added an edge that connected nodes of different colors within a connected component, I would get an even cycle, not an odd one. This is because any path in a bipartite graph between vertices of the same color must be even.\n\nThis tells me I have to add at least one edge, so `t = 1` in this case. Now, I need to figure out how many ways to add that edge, to calculate `w`. I have to determine the number of ways to pick two nodes of the same color from the same connected component and add an edge between them. I'm going to have to carefully consider the structure of each connected component to figure that out.\n",
    "response": "The problem asks us to find the minimum number of edges `t` to add to a given undirected graph to form a simple cycle of odd length, and `w`, the number of ways to do so.\n\nA graph contains an odd-length cycle if and only if it is not bipartite. This property is key to solving the problem.\n\nWe can categorize the solution into three main cases based on the minimum number of edges `t` required:\n\n**Case 0: `t = 0`**\nIf the given graph already contains an odd-length cycle, then `t = 0`. There is only `w = 1` way to achieve this (by adding no edges).\nTo check this, we can perform a 2-coloring (bipartite check) on each connected component of the graph. We use BFS or DFS for this.\nFor each unvisited vertex, start a traversal (e.g., BFS), assigning it color 0. All its neighbors get color 1, neighbors of color 1 get color 0, and so on. If we ever encounter an edge connecting two vertices of the same color, we've found an odd-length cycle.\nIf we successfully color all components without finding any same-color edges, the graph is bipartite.\n\n**Case 1: `t = 1`**\nIf the graph is bipartite (i.e., `t=0` is not possible), we need to add at least one edge.\nTo form an odd-length cycle in a bipartite graph, we must add an edge between two vertices that belong to the *same partition set* (i.e., have the same color) within the *same connected component*.\nIf we add an edge `(u, v)` where `u` and `v` are in the same component and have the same color, this edge, combined with any path between `u` and `v` in the original component, will form an odd-length cycle. The path between `u` and `v` in a bipartite graph, if `u` and `v` have the same color, must have an even length. Adding the edge `(u, v)` makes the cycle length `even_path_length + 1`, which is odd.\nSo, if there is any connected component with at least 3 vertices, we can potentially add an edge between two vertices of the same color.\nSpecifically, if a component has `S0` vertices of color 0 and `S1` vertices of color 1, we can add an edge between any two distinct vertices of color 0, or any two distinct vertices of color 1. The number of ways to do this is `S0 * (S0 - 1) / 2 + S1 * (S1 - 1) / 2`.\nWe sum these counts over all connected components. If this sum is greater than 0, then `t = 1` and `w` is this sum.\nNote that we must ensure the added edge does not create a parallel edge or a loop. Since the problem guarantees no loops or parallel edges initially, and we are adding an edge between two vertices that are *not* already connected (otherwise, it would have been detected as an odd cycle in Case 0, or it would be a parallel edge), this condition is naturally met.\n\n**Case 2: `t = 2`**\nIf `t=0` and `t=1` are not possible, it means all connected components are bipartite, and no single component has enough vertices of the same color to form an odd cycle by adding one edge. This implies that all connected components must be \"trivial\" in some sense for `t=1` to fail.\nSpecifically, for `S0 * (S0 - 1) / 2 + S1 * (S1 - 1) / 2` to be 0 for all components, it means:\n*   `S0 < 2` (i.e., `S0` is 0 or 1) AND `S1 < 2` (i.e., `S1` is 0 or 1).\nThis implies that every connected component has at most 2 vertices.\n*   Components of size 1 (isolated vertex): `S0=1, S1=0` or `S0=0, S1=1`.\n*   Components of size 2 (an edge): `S0=1, S1=1`.\nIn this scenario, to form an odd cycle, we must connect vertices from different components.\nAdding two edges `(u, v)` and `(v, w)` where `u, v, w` are distinct, can form a path of length 2. If `u` and `w` are in different components, and `v` is a new vertex (or an existing one), this doesn't directly form a cycle.\nThe simplest way to form an odd cycle with two added edges is to take two vertices `u` and `v` from different connected components, say `C_i` and `C_j`, and add an edge `(u, v)`. This merges `C_i` and `C_j` into a larger bipartite component. Now, we need to add a second edge to form an odd cycle. This second edge must connect two vertices of the same color within this new merged component.\nHowever, a more direct approach is to pick two distinct vertices `u` and `v` from the graph and add two edges `(u, x)` and `(v, x)` to some *new* vertex `x` (not possible, we only add edges between existing vertices).\nThe problem states \"add edges to the given graph\". We are adding edges between existing vertices.\nIf we add two edges `(u, v)` and `(v, w)` where `u, v, w` are distinct vertices, and `u, v, w` are from different components, or say `u, v` from `C_1` and `w` from `C_2`.\nSuppose we have `k` connected components, `C_1, ..., C_k`.\nWe can pick any two distinct vertices `u` and `v` from the graph. If `u` and `v` are in the same component, `t=1` would have been possible. So `u` and `v` must be in different components.\nLet `u` be in `C_i` and `v` be in `C_j` (`i != j`).\nWe add an edge `(u, v)`. Now `C_i` and `C_j` merge into a larger bipartite component. The path length `u -- v` is 1 (odd).\nTo form an odd cycle, we need to add another edge. If we add an edge `(x, y)` such that `x` and `y` are of the same color in the newly merged `C_i \\cup C_j` component, we form an odd cycle.\nThe simplest odd cycle we can form using two added edges is a cycle of length 3 (a triangle). We need three distinct vertices `u, v, w`. If no two of them are connected, we add `(u, v)`, `(v, w)`, `(w, u)`. This is `t=3`.\nBut we are looking for `t=2`.\nIf `t=1` fails, it means all components have `S0 <= 1` and `S1 <= 1`.\nThis implies that every component is either an isolated vertex or a single edge.\nLet `N_iso` be the number of isolated vertices.\nLet `N_edge` be the number of components that are single edges.\nThe total number of vertices is `n`. `n = N_iso + 2 * N_edge`.\n\nIf we have at least two isolated vertices, say `u` and `v`. We can add an edge `(u, x)` and `(v, x)` where `x` is *any other* vertex in the graph.\nThis is not right. We need to form an odd cycle.\nConsider three distinct vertices `u, v, w`.\nIf we add `(u, v)` and `(u, w)`, these two edges form a path of length 2 `v - u - w`. If `v` and `w` are not connected, and `v, w` are in different components, adding `(v, w)` would make an odd cycle of length 3. This would be `t=3`.\n\nLet's re-evaluate the `t=2` case.\nIf `t=1` is not possible, it means all components are either isolated vertices or single edges.\nTo form an odd cycle with two edges, we need to pick three distinct vertices `u, v, w`.\nThe two edges must be `(u, v)` and `(v, w)` (forming a path `u-v-w`) and `u` and `w` must not be connected. If we then add `(u, w)`, it's `t=3`.\nAlternatively, we add `(u, v)` and `(u, w)`. This is a path `v-u-w`.\nIf `u, v, w` are distinct vertices, and `u` is connected to `v` and `w` by adding two edges, then `v` and `w` are at distance 2 from each other. If `v` and `w` are in different components, and `u` is also in a different component, this could work.\nSuppose we have `N_iso` isolated vertices. We can pick two distinct isolated vertices `u` and `v`. Add edge `(u, v)`. This forms a component of size 2. Now we need to add another edge to form an odd cycle. This would require `t=1` within this component, which isn't possible (it only has 2 vertices).\nSo, we must use three vertices `u, v, w`.\nIf `u, v, w` are all isolated vertices, we add `(u, v)` and `(v, w)`. Now we have a path `u-v-w`. `u` and `w` are in the same component, and have the same color relative to `v`. We need to add an edge between `u` and `w`. This requires `t=3`.\n\nThe only way to get `t=2` is if we can merge two components with one edge, and then add another edge to make an odd cycle within the merged component.\nThis means we need to take two components, `C_i` and `C_j`, and merge them by adding an edge `(u, v)` where `u \\in C_i, v \\in C_j`.\nAfter merging, the new component `C_i \\cup C_j` is still bipartite. Let `U = U_i \\cup U_j` and `V = V_i \\cup V_j` be its partitions (assuming `v` is colored opposite to `u`).\nNow, we need to add a second edge `(x, y)` such that `x, y` are in `C_i \\cup C_j` and `x, y` have the same color.\nThis means we need `|U| >= 2` or `|V| >= 2` in the merged component.\nSince `t=1` failed, `|U_k| <= 1` and `|V_k| <= 1` for all original components `C_k`.\nIf we merge `C_i` and `C_j` by `(u, v)`:\n*   If `u \\in U_i, v \\in V_j`, then `U` becomes `U_i \\cup U_j` and `V` becomes `V_i \\cup V_j`.\n*   If `u \\in U_i, v \\in U_j`, then `U` becomes `U_i \\cup V_j` and `V` becomes `V_i \\cup U_j` (after recoloring `C_j`).\nIn any case, `|U| = |U_i| + |U_j|` and `|V| = |V_i| + |V_j|` (or similar sums).\nFor `|U| >= 2` or `|V| >= 2`, we need `|U_i| + |U_j| >= 2` or `|V_i| + |V_j| >= 2`.\nSince `|U_k| <= 1` and `|V_k| <= 1`, this means we need two components each contributing at least one vertex to `U` (or `V`).\nThis is equivalent to saying we need at least two components that are not just isolated vertices.\nNo, this is simpler: we need to form a cycle of length 3 or more.\nThe simplest odd cycle is a triangle. To form a triangle `u-v-w-u` with two added edges, say `(u, v)` and `(v, w)`, we need `(u, w)` to be an existing edge. But `t=0` failed, so no odd cycle exists.\nSo we need to add two edges.\nIf `t=1` is not possible, it means all components are isolated vertices or single edges.\nLet `N_iso` be the number of isolated vertices.\nLet `N_edge` be the number of components that are single edges.\nTotal vertices `n = N_iso + 2 * N_edge`.\n\nIf `N_iso >= 1` and `N_edge >= 1`:\nTake an isolated vertex `u`. Take an edge component `(v, w)`.\nAdd edges `(u, v)` and `(u, w)`.\nThis creates a cycle `u-v-w-u` of length 3. This uses 2 added edges.\nThe number of ways `w` for this case: `N_iso * N_edge`.\nThis is the minimum `t=2` if `N_iso >= 1` and `N_edge >= 1`.\n\nIf `N_iso >= 3`:\nTake three distinct isolated vertices `u, v, x`. Add edges `(u, v)` and `(v, x)`.\nThis forms a path `u-v-x`. `u` and `x` are now in the same component, and have the same color.\nWe can't add `(u, x)` because that would be `t=3`.\nThis is not correct. We are forming a path `u-v-x`. This is bipartite.\nWe need to form an odd cycle.\nIf we add `(u, v)` and `(v, w)` where `u, v, w` are isolated vertices, this doesn't form an odd cycle. It forms a path `u-v-w`. This path is bipartite.\nWe need to add two edges such that they form an odd cycle.\nThe *only* way to form an odd cycle with two edges is to connect two vertices `u, v` from different components, and then add a second edge `(x, y)` between two vertices of the same color in the resulting merged component.\nBut if `t=1` failed, it means every component `C_k` has `|U_k| <= 1` and `|V_k| <= 1`.\nWhen we merge `C_i` and `C_j` with an edge `(u, v)`, `u \\in C_i, v \\in C_j`.\nThe new component has `U = U_i \\cup U_j` and `V = V_i \\cup V_j` (or similar, depending on coloring).\nSince `|U_k| <= 1` and `|V_k| <= 1` for all `k`, then `|U| <= 2` and `|V| <= 2`.\nFor `t=1` to be possible in the merged component, we need `|U| >= 2` or `|V| >= 2`.\nThis means we need to find two components `C_i, C_j` such that `|U_i| + |U_j| >= 2` or `|V_i| + |V_j| >= 2`.\nThis can happen if:\n1.  `C_i` has `|U_i|=1`, `C_j` has `|U_j|=1`. Then `|U|=2`. This is two isolated vertices.\n2.  `C_i` has `|U_i|=1`, `C_j` has `|U_j|=0` (but `|V_j|=1`). This is one isolated vertex and one edge.\n\nLet's list the types of components when `t=1` fails:\n*   Type A: Isolated vertex (e.g., `u`). `S0=1, S1=0` (or `S0=0, S1=1`).\n*   Type B: Single edge (e.g., `u-v`). `S0=1, S1=1`.\n\nIf we have `N_A` components of Type A and `N_B` components of Type B.\nTotal vertices `n = N_A * 1 + N_B * 2`.\n\n**Option 2.1: Connect two Type A components and one other component.**\nPick two distinct isolated vertices `u, v`. Add edge `(u, v)`. Now `u-v` is a component.\nPick another vertex `x` from any other component (could be another isolated vertex, or from an edge component).\nAdd edge `(u, x)`.\nThis creates a path `v-u-x`. If `v` and `x` are not connected, and `v` and `x` are in different components, this is `t=2`.\nIf `v` and `x` are not connected, and `v` and `x` are in the same component, this is `t=2`.\nThis is still not forming an odd cycle with 2 edges.\nThe only way to form an odd cycle of length 3 with two edges is if we have an edge `(u, v)` already, and we add `(u, w)` and `(v, w)`. This means we need `N_B >= 1`.\nIf we have an edge `(u, v)` (Type B component). We need to connect a third vertex `w` to both `u` and `v`.\nIf `w` is an isolated vertex (Type A component): Add `(u, w)` and `(v, w)`. This forms a triangle `u-v-w-u`. This uses 2 added edges.\nNumber of ways: `N_A * N_B`. (Pick one isolated vertex, pick one edge component).\nThis is the `t=2` solution if `N_A >= 1` and `N_B >= 1`.\n\n**Option 2.2: Connect three Type A components.**\nIf `N_A >= 3` and `N_B = 0`.\nPick three distinct isolated vertices `u, v, w`. Add edges `(u, v)` and `(v, w)`.\nThis forms a path `u-v-w`. This is a bipartite component. It doesn't contain an odd cycle. We need `t=3` for `(u,w)`.\nSo, if `N_A >= 3` and `N_B = 0`, then `t=2` is not possible.\n\n**Summary for `t=2`:**\n`t=2` is possible if and only if there exists at least one isolated vertex AND at least one component that is a single edge.\nIn this case, `t=2` and `w = N_A * N_B`.\nThis forms a triangle `u-v-w-u` by taking an isolated vertex `w` and an edge `(u, v)`, and adding edges `(u, w)` and `(v, w)`.\n\n**Case 3: `t = 3`**\nIf `t=0`, `t=1`, `t=2` are not possible, it means:\n*   Graph is bipartite.\n*   All components have `S0 <= 1` and `S1 <= 1`.\n*   Either `N_A = 0` (all components are single edges) OR `N_B = 0` (all components are isolated vertices).\n    *   If `N_B = 0`, then all components are isolated vertices. We need at least 3 isolated vertices (`N_A >= 3`).\n        Pick three distinct isolated vertices `u, v, w`. Add edges `(u, v)`, `(v, w)`, `(w, u)`. This forms a triangle.\n        `t=3`. Number of ways `w = N_A * (N_A - 1) * (N_A - 2) / 6`.\n    *   If `N_A = 0`, then all components are single edges.\n        Pick three distinct components `(u_1, v_1)`, `(u_2, v_2)`, `(u_3, v_3)`.\n        We need to add 3 edges to form an odd cycle.\n        For example, `(v_1, u_2)`, `(v_2, u_3)`, `(v_3, u_1)`. This forms a cycle of length 6 (even).\n        This case is more complex.\n        The simplest odd cycle is a triangle. We need three vertices `u, v, w`.\n        If all components are single edges, we have `N_B` components. Each has 2 vertices.\n        If we pick 3 vertices, say `u, v, w`.\n        If `u, v, w` are from 3 different edge components, then adding `(u, v), (v, w), (w, u)` costs 3 edges. `w = N_B * (N_B - 1) * (N_B - 2) / 6 * 2^3`. (Each edge component has 2 choices for a vertex).\n        This is `t=3`.\n        The number of ways to pick 3 distinct vertices from 3 distinct edge components: `(N_B choose 3) * 2^3`.\n        If `n < 3`, then `t=3` is impossible. The problem says \"cycle of more than one vertex\", which implies length >= 3. If `n < 3`, we can't form a cycle.\n        However, `n` can be up to `2*10^5`. If `n < 3`, `t=3` is the minimum possible, but `w=0`.\n\nLet's refine the logic for `t=3`.\nIf `t=0, t=1, t=2` are not possible, it means:\n1.  Graph is bipartite.\n2.  All connected components `C_k` have `|U_k| <= 1` and `|V_k| <= 1`.\n3.  Either `N_A = 0` (no isolated vertices) or `N_B = 0` (no edge components).\n    *   If `N_B = 0`: All components are isolated vertices. `N_A = n`.\n        We need to form a triangle. This requires 3 distinct vertices `u, v, w`.\n        We add edges `(u, v), (v, w), (w, u)`. This costs `t=3`.\n        Number of ways `w = n * (n-1) * (n-2) / 6`.\n        This is valid if `n >= 3`. If `n < 3`, then `t=3` is impossible (`w=0`).\n    *   If `N_A = 0`: All components are single edges. `N_B = n/2`.\n        We need to form an odd cycle.\n        The smallest odd cycle is a triangle. This requires 3 distinct vertices `u, v, w`.\n        These 3 vertices must come from 3 distinct edge components, e.g., `(u, u'), (v, v'), (w, w')`.\n        We add edges `(u, v), (v, w), (w, u)`. This costs `t=3`.\n        Number of ways `w = (N_B choose 3) * 2^3`. (Choose 3 edge components, then choose 1 vertex from each of the 3 components).\n        This is valid if `N_B >= 3` (i.e., `n >= 6`). If `N_B < 3`, then `t=3` is impossible (`w=0`).\n\n**Detailed Algorithm:**\n\n1.  **Initialization:**\n    *   `adj`: adjacency list.\n    *   `color`: array to store 0/1 color for each vertex, or -1 if unvisited.\n    *   `visited`: boolean array for BFS/DFS.\n    *   `is_bipartite = True`.\n    *   `num_isolated_vertices = 0`.\n    *   `num_edge_components = 0`.\n    *   `ways_t1 = 0`.\n\n2.  **Iterate through vertices `i` from 1 to `n`:**\n    *   If `i` is not `visited`:\n        *   Start BFS/DFS from `i`.\n        *   `current_component_is_bipartite = True`.\n        *   `count0 = 0`, `count1 = 0`.\n        *   `q = deque([i])`, `color[i] = 0`, `visited[i] = True`, `count0 = 1`.\n        *   `component_vertices = [i]`.\n        *   While `q` is not empty:\n            *   `u = q.popleft()`.\n            *   For `v` in `adj[u]`:\n                *   If `color[v] == -1`:\n                    *   `color[v] = 1 - color[u]`.\n                    *   `visited[v] = True`.\n                    *   `q.append(v)`.\n                    *   `component_vertices.append(v)`.\n                    *   If `color[v] == 0`, `count0 += 1`. Else `count1 += 1`.\n                *   Else if `color[v] == color[u]`:\n                    *   `current_component_is_bipartite = False`.\n        *   After BFS/DFS for component:\n            *   If `not current_component_is_bipartite`:\n                *   `is_bipartite = False`.\n                *   Break from outer loop (no need to check further components).\n            *   Else (`current_component_is_bipartite` is True):\n                *   `ways_t1 += count0 * (count0 - 1) // 2`.\n                *   `ways_t1 += count1 * (count1 - 1) // 2`.\n                *   If `len(component_vertices) == 1`:\n                    *   `num_isolated_vertices += 1`.\n                *   Else if `len(component_vertices) == 2` and `len(adj[component_vertices[0]]) == 1`: (i.e., a single edge)\n                    *   `num_edge_components += 1`.\n\n3.  **Determine `t` and `w`:**\n    *   If `not is_bipartite`:\n        *   `t = 0`, `w = 1`.\n    *   Else if `ways_t1 > 0`:\n        *   `t = 1`, `w = ways_t1`.\n    *   Else if `num_isolated_vertices > 0` and `num_edge_components > 0`:\n        *   `t = 2`, `w = num_isolated_vertices * num_edge_components`.\n    *   Else: (`t=0, t=1, t=2` failed)\n        *   `t = 3`.\n        *   If `num_isolated_vertices == n`: (all components are isolated vertices)\n            *   If `n >= 3`: `w = n * (n - 1) * (n - 2) // 6`.\n            *   Else: `w = 0`. (Cannot form a triangle with < 3 vertices)\n        *   Else if `num_edge_components == n // 2`: (all components are single edges)\n            *   If `n // 2 >= 3`: `w = (n // 2) * (n // 2 - 1) * (n // 2 - 2) // 6 * (2**3)`.\n            *   Else: `w = 0`. (Cannot form a triangle with < 3 edge components)\n        *   Else: This case should not be reached if the logic for `t=0, t=1, t=2` is exhaustive.\n            If `t=1` fails, it implies `count0 <= 1` and `count1 <= 1` for all components.\n            This means all components are either isolated vertices (`count0=1, count1=0` or `count0=0, count1=1`) or single edges (`count0=1, count1=1`).\n            So, `num_isolated_vertices + num_edge_components` must be the total number of components.\n            If `t=2` fails, it means `num_isolated_vertices = 0` OR `num_edge_components = 0`.\n            So, either all components are isolated vertices, or all components are single edges.\n            The `else` branch correctly covers these two sub-cases for `t=3`.\n\nFinal check on edge cases:\n*   `n < 3`:\n    *   If `n=1, m=0`: Isolated vertex. `t=3`, `w=0`. Correct.\n    *   If `n=2, m=0`: Two isolated vertices. `t=3`, `w=0`. Correct.\n    *   If `n=2, m=1` (`1-2`): One edge component. `t=3`, `w=0`. Correct.\n\nExample 1:\n4 4\n1 2\n1 3\n4 2\n4 3\nGraph: (1-2, 1-3, 4-2, 4-3).\nComponent 1: {1,2,3,4}.\nBFS from 1: color[1]=0\nq=[1]\npop 1: neighbors 2,3. color[2]=1, color[3]=1. q=[2,3]\npop 2: neighbors 1,4. color[1]=0 (match), color[4]=0. q=[3,4]\npop 3: neighbors 1,4. color[1]=0 (match), color[4]=0 (match).\ncolor[4]=0 (from 2) and neighbor 3 (color[3]=1). OK.\npop 4: neighbors 2,3. color[2]=1 (match), color[3]=1 (match).\nColors: 1:0, 2:1, 3:1, 4:0.\nThis component is bipartite.\ncount0=2 ({1,4}), count1=2 ({2,3}).\nways_t1 += 2*(2-1)//2 + 2*(2-1)//2 = 1 + 1 = 2.\nResult: `t=1, w=2`. Matches example.\n\nExample 2:\n3 3\n1 2\n2 3\n3 1\nGraph: (1-2, 2-3, 3-1). Triangle.\nBFS from 1: color[1]=0\nq=[1]\npop 1: neighbors 2,3. color[2]=1, color[3]=1. q=[2,3]\npop 2: neighbors 1,3. color[1]=0 (match). color[3]=1. `color[3]` is 1, `color[2]` is 1. `color[3] == color[2]`. Odd cycle found.\nResult: `t=0, w=1`. Matches example.\n\nExample 3:\n3 0\nGraph: 1, 2, 3 (three isolated vertices).\nBFS from 1: color[1]=0. count0=1, count1=0. isolated.\nBFS from 2: color[2]=0. count0=1, count1=0. isolated.\nBFS from 3: color[3]=0. count0=1, count1=0. isolated.\n`is_bipartite = True`. `ways_t1 = 0`.\n`num_isolated_vertices = 3`. `num_edge_components = 0`.\n`num_isolated_vertices > 0` and `num_edge_components > 0` is false.\nElse branch for `t=3`.\n`num_isolated_vertices == n` is true (3 == 3).\n`n >= 3` is true.\n`w = 3 * (3-1) * (3-2) // 6 = 3 * 2 * 1 // 6 = 1`.\nResult: `t=3, w=1`. Matches example.\n\nThe logic seems sound.\n\n```python\nimport sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    \n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n\n    color = [-1] * (n + 1) # -1: unvisited, 0: color 0, 1: color 1\n    visited = [False] * (n + 1)\n    \n    is_graph_bipartite = True\n    ways_t1 = 0\n    num_isolated_vertices = 0\n    num_edge_components = 0\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            current_component_is_bipartite = True\n            \n            q = deque()\n            q.append(i)\n            color[i] = 0\n            visited[i] = True\n            \n            component_nodes = []\n            component_nodes.append(i)\n            \n            count0 = 1\n            count1 = 0\n            \n            head = 0\n            while head < len(component_nodes): # Manual queue for potentially large components\n                u = component_nodes[head]\n                head += 1\n\n                for v in adj[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        color[v] = 1 - color[u]\n                        component_nodes.append(v)\n                        if color[v] == 0:\n                            count0 += 1\n                        else:\n                            count1 += 1\n                        # q.append(v) # Use manual queue to avoid deque overhead for many nodes\n                    elif color[v] == color[u]:\n                        current_component_is_bipartite = False\n            \n            # After processing the component\n            if not current_component_is_bipartite:\n                is_graph_bipartite = False\n                # If we found an odd cycle, t=0, w=1. No need to process further components.\n                # However, the loop structure will break out after this component.\n                break \n            else:\n                # This component is bipartite. Calculate ways for t=1 within this component.\n                ways_t1 += count0 * (count0 - 1) // 2\n                ways_t1 += count1 * (count1 - 1) // 2\n                \n                if len(component_nodes) == 1:\n                    num_isolated_vertices += 1\n                elif len(component_nodes) == 2 and len(adj[component_nodes[0]]) == 1: # A single edge component\n                    num_edge_components += 1\n    \n    # Determine t and w based on analysis\n    if not is_graph_bipartite:\n        print(0, 1)\n    elif ways_t1 > 0:\n        print(1, ways_t1)\n    elif num_isolated_vertices > 0 and num_edge_components > 0:\n        # t=2: connect an isolated vertex to both ends of an edge component\n        print(2, num_isolated_vertices * num_edge_components)\n    else:\n        # t=3: All components are either isolated vertices OR all are single edges\n        t = 3\n        w = 0\n        if num_isolated_vertices == n: # All components are isolated vertices\n            if n >= 3:\n                w = n * (n - 1) * (n - 2) // 6 # Combinations of 3 vertices (C(n,3))\n            else:\n                w = 0 # Not enough vertices to form a triangle\n        elif num_edge_components == n // 2: # All components are single edges\n            if n // 2 >= 3: # Need at least 3 edge components\n                # Choose 3 edge components, then choose 1 vertex from each of the 3 components\n                # (n//2 choose 3) * 2*2*2\n                num_components_of_type_B = n // 2\n                w = num_components_of_type_B * (num_components_of_type_B - 1) * (num_components_of_type_B - 2) // 6 * (2**3)\n            else:\n                w = 0 # Not enough edge components to form a triangle\n        # If n < 3, w will be 0 from above conditions.\n        print(t, w)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    \n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n\n    color = [-1] * (n + 1) # -1: unvisited, 0: color 0, 1: color 1\n    visited = [False] * (n + 1)\n    \n    is_graph_bipartite = True\n    ways_t1 = 0\n    num_isolated_vertices = 0\n    num_edge_components = 0\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            current_component_is_bipartite = True\n            \n            q = deque()\n            q.append(i)\n            color[i] = 0\n            visited[i] = True\n            \n            component_nodes = []\n            component_nodes.append(i)\n            \n            count0 = 1\n            count1 = 0\n            \n            head = 0\n            while head < len(component_nodes): # Manual queue for potentially large components\n                u = component_nodes[head]\n                head += 1\n\n                for v in adj[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        color[v] = 1 - color[u]\n                        component_nodes.append(v)\n                        if color[v] == 0:\n                            count0 += 1\n                        else:\n                            count1 += 1\n                        # q.append(v) # Use manual queue to avoid deque overhead for many nodes\n                    elif color[v] == color[u]:\n                        current_component_is_bipartite = False\n            \n            # After processing the component\n            if not current_component_is_bipartite:\n                is_graph_bipartite = False\n                # If we found an odd cycle, t=0, w=1. No need to process further components.\n                # However, the loop structure will break out after this component.\n                break \n            else:\n                # This component is bipartite. Calculate ways for t=1 within this component.\n                ways_t1 += count0 * (count0 - 1) // 2\n                ways_t1 += count1 * (count1 - 1) // 2\n                \n                if len(component_nodes) == 1:\n                    num_isolated_vertices += 1\n                elif len(component_nodes) == 2 and len(adj[component_nodes[0]]) == 1: # A single edge component\n                    num_edge_components += 1\n    \n    # Determine t and w based on analysis\n    if not is_graph_bipartite:\n        print(0, 1)\n    elif ways_t1 > 0:\n        print(1, ways_t1)\n    elif num_isolated_vertices > 0 and num_edge_components > 0:\n        # t=2: connect an isolated vertex to both ends of an edge component\n        print(2, num_isolated_vertices * num_edge_components)\n    else:\n        # t=3: All components are either isolated vertices OR all are single edges\n        t = 3\n        w = 0\n        if num_isolated_vertices == n: # All components are isolated vertices\n            if n >= 3:\n                w = n * (n - 1) * (n - 2) // 6 # Combinations of 3 vertices (C(n,3))\n            else:\n                w = 0 # Not enough vertices to form a triangle\n        elif num_edge_components == n // 2: # All components are single edges\n            if n // 2 >= 3: # Need at least 3 edge components\n                # Choose 3 edge components, then choose 1 vertex from each of the 3 components\n                # (n//2 choose 3) * 2*2*2\n                num_components_of_type_B = n // 2\n                w = num_components_of_type_B * (num_components_of_type_B - 1) * (num_components_of_type_B - 2) // 6 * (2**3)\n            else:\n                w = 0 # Not enough edge components to form a triangle\n        # If n < 3, w will be 0 from above conditions.\n        print(t, w)\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 603,
        "completion_token_count": 8635,
        "thoughts_token_count": 766
    }
}