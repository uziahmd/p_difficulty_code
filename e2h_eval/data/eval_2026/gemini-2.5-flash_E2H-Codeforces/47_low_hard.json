{
    "start": 1758284874.0118651,
    "end": 1758284888.3180797,
    "start-formatted": "2025-09-19 21:27 KST",
    "end-formatted": "2025-09-19 21:28 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "**Thinking Through LCM Minimization**\n\nOkay, so I'm tackling this problem of finding the smallest non-negative integer *k* that minimizes the least common multiple of *a + k* and *b + k*. Essentially, I'm trying to find the *k* that gets those two numbers as \"close together\" in terms of their LCM as possible. It's a classic number theory challenge.\n\nFirst, I define *x = a + k* and *y = b + k*. Minimizing *lcm(x, y)* is the core of the problem.  The LCM can be expressed as *(x * y) / gcd(x, y)*.  That's my starting point. And I also recognize I can establish *d = b - a*.\n\nSince the LCM is symmetric, I can safely assume *a <= b*. If I didn't, I could just swap them, no problem. If *a = b*, the solution is simple: *k = 0* since that makes both numbers equal to *a*.\n\nNow, the trick is to use the GCD property. Let's assume *a < b*, so *d > 0*. If *g = gcd(a + k, b + k)*, then *g* must divide the difference between them, which is *b - a = d*.  This means *g* has to be a divisor of *d*. This is the key insight.\n\nThe goal is to minimize that LCM. If I want to minimize *lcm(a + k, b + k)*, I really want to maximize the GCD. A large GCD shrinks the LCM. So, I have to figure out how to force that.  I know that *a + k* has to be a multiple of *g*, for some divisor *g* of *d*.\n\nSo, I need to find the smallest *k* that makes *a + k* a multiple of *g*. If *g* divides *a*, then *k* is 0. If *g* does not divide *a*, I want the smallest multiple of *g* that is greater than or equal to *a*.\n\nTo be more precise, if I can find the smallest *m* such that *m * g >= a*, then *a+k = m * g*, and *k = m * g - a*. I've got my formula for *k* now. The smaller the divisor of *d* I choose, the higher the *k* value, and conversely, the bigger the divisor, the smaller *k*. I want the *k* that results in the smallest *lcm*.  It's an interesting interplay between those factors.\n",
    "response": "```python\nimport sys\nimport math\n\ndef solve():\n    a, b = map(int, sys.stdin.readline().split())\n\n    if a == b:\n        print(0)\n        return\n\n    # Ensure a < b\n    if a > b:\n        a, b = b, a\n\n    diff = b - a\n\n    min_lcm = float('inf')\n    best_k = 0\n\n    # Iterate through divisors of diff\n    # The maximum value of diff is 10^9 - 1, sqrt(10^9) approx 31622\n    for g_candidate in range(1, int(math.sqrt(diff)) + 1):\n        if diff % g_candidate == 0:\n            divisors = [g_candidate]\n            if g_candidate * g_candidate != diff:\n                divisors.append(diff // g_candidate)\n\n            for g in divisors:\n                # We need a+k to be a multiple of g.\n                # a+k = m*g for some integer m.\n                # k = m*g - a.\n                # Since k >= 0, m*g >= a.\n                # The smallest m*g that is >= a is found by:\n                # If a is a multiple of g, a_plus_k_val = a. Then k = 0.\n                # If a is not a multiple of g, a_plus_k_val = (floor(a/g) + 1) * g.\n                # This can be written as:\n                # a_plus_k_val = ((a + g - 1) // g) * g\n                # Or, more simply, if a % g == 0, then a_plus_k_val = a.\n                # Else, a_plus_k_val = a - (a % g) + g.\n                \n                if a % g == 0:\n                    current_a_plus_k = a\n                else:\n                    current_a_plus_k = a - (a % g) + g\n                \n                current_k = current_a_plus_k - a\n                \n                # Calculate b+k\n                current_b_plus_k = b + current_k\n                \n                # Check if gcd(a+k, b+k) is indeed g\n                # If gcd(a+k, b+k) is a multiple of g, say G, then G must also divide diff.\n                # Since g divides diff, and g divides a+k, and g divides b+k,\n                # then g must divide gcd(a+k, b+k).\n                # So gcd(a+k, b+k) will be some multiple of g, say g_prime = M * g.\n                # We want to use g_prime for LCM calculation, not g.\n                # This is because (a+k)/g_prime and (b+k)/g_prime will be coprime.\n                \n                # The actual gcd of (a+k) and (b+k) is gcd(a+k, (b+k)-(a+k)) = gcd(a+k, diff).\n                # Since a+k is a multiple of g, and diff is a multiple of g,\n                # gcd(a+k, diff) will also be a multiple of g.\n                actual_gcd = math.gcd(current_a_plus_k, diff)\n                \n                # Calculate LCM using the actual_gcd\n                current_lcm = (current_a_plus_k // actual_gcd) * current_b_plus_k\n\n                if current_lcm < min_lcm:\n                    min_lcm = current_lcm\n                    best_k = current_k\n                elif current_lcm == min_lcm:\n                    best_k = min(best_k, current_k)\n\n    print(best_k)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\n\ndef solve():\n    a, b = map(int, sys.stdin.readline().split())\n\n    if a == b:\n        print(0)\n        return\n\n    # Ensure a < b\n    if a > b:\n        a, b = b, a\n\n    diff = b - a\n\n    min_lcm = float('inf')\n    best_k = 0\n\n    # Iterate through divisors of diff\n    # The maximum value of diff is 10^9 - 1, sqrt(10^9) approx 31622\n    for g_candidate in range(1, int(math.sqrt(diff)) + 1):\n        if diff % g_candidate == 0:\n            divisors = [g_candidate]\n            if g_candidate * g_candidate != diff:\n                divisors.append(diff // g_candidate)\n\n            for g in divisors:\n                # We need a+k to be a multiple of g.\n                # a+k = m*g for some integer m.\n                # k = m*g - a.\n                # Since k >= 0, m*g >= a.\n                # The smallest m*g that is >= a is found by:\n                # If a is a multiple of g, a_plus_k_val = a. Then k = 0.\n                # If a is not a multiple of g, a_plus_k_val = (floor(a/g) + 1) * g.\n                # This can be written as:\n                # a_plus_k_val = ((a + g - 1) // g) * g\n                # Or, more simply, if a % g == 0, then a_plus_k_val = a.\n                # Else, a_plus_k_val = a - (a % g) + g.\n                \n                if a % g == 0:\n                    current_a_plus_k = a\n                else:\n                    current_a_plus_k = a - (a % g) + g\n                \n                current_k = current_a_plus_k - a\n                \n                # Calculate b+k\n                current_b_plus_k = b + current_k\n                \n                # Check if gcd(a+k, b+k) is indeed g\n                # If gcd(a+k, b+k) is a multiple of g, say G, then G must also divide diff.\n                # Since g divides diff, and g divides a+k, and g divides b+k,\n                # then g must divide gcd(a+k, b+k).\n                # So gcd(a+k, b+k) will be some multiple of g, say g_prime = M * g.\n                # We want to use g_prime for LCM calculation, not g.\n                # This is because (a+k)/g_prime and (b+k)/g_prime will be coprime.\n                \n                # The actual gcd of (a+k) and (b+k) is gcd(a+k, (b+k)-(a+k)) = gcd(a+k, diff).\n                # Since a+k is a multiple of g, and diff is a multiple of g,\n                # gcd(a+k, diff) will also be a multiple of g.\n                actual_gcd = math.gcd(current_a_plus_k, diff)\n                \n                # Calculate LCM using the actual_gcd\n                current_lcm = (current_a_plus_k // actual_gcd) * current_b_plus_k\n\n                if current_lcm < min_lcm:\n                    min_lcm = current_lcm\n                    best_k = current_k\n                elif current_lcm == min_lcm:\n                    best_k = min(best_k, current_k)\n\n    print(best_k)\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 421,
        "completion_token_count": 899,
        "thoughts_token_count": 742
    }
}