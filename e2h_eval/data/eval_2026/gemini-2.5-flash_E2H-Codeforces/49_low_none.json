{
    "start": 1758284908.2312088,
    "end": 1758284937.8296897,
    "start-formatted": "2025-09-19 21:28 KST",
    "end-formatted": "2025-09-19 21:28 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "**Solving the Mushroom Strife Problem**\n\nOkay, so I'm looking at this \"Mushroom Strife\" problem, and it's a classic graph coloring/constraint satisfaction puzzle.  We've got these lawns represented as nodes and roads as edges, where each edge has a GCD and LCM constraint. My initial thought is, this seems solvable with some clever number theory and graph traversal.\n\nThe core of the problem is figuring out valid mushroom counts for each lawn. I know that for any two numbers, the product of their GCD and LCM is equal to the product of the numbers themselves. So, if we have lawns 'u' and 'v' connected by an edge, with GCD 'g' and LCM 'l', then the product of their mushroom counts, `x_u * x_v`, must equal `g * l`.\n\nMore importantly, `g` has to divide both `x_u` and `x_v`, and both `x_u` and `x_v` have to divide `l`.  The crucial insight here is that if we define `x_u = g * a'` and `x_v = g * b'`, then `a'` and `b'` must be coprime factors of `l/g`.\n\nGiven the problem constraints, where 'n' and 'm' are relatively small (up to 1000), and the GCD and LCM values are up to 10^6, this suggests a manageable computational complexity. It feels like a graph-based solution is the way to go. I need to make sure that the assigned mushroom counts satisfy these constraints across all edges. My strategy involves assigning values and then verifying the GCD and LCM of each edge, looking for inconsistencies. A depth-first or breadth-first search might work, propagating constraints and backtracking if I hit an impossible assignment. The key is in efficient factorization of `l/g` and checking for coprime pairs.\n",
    "response": "The problem asks us to assign a positive integer `x_i` to each lawn `i` (from 1 to `n`) such that for every given road between lawns `u` and `v` with specified `GCD(x_u, x_v) = g` and `LCM(x_u, x_v) = l`, these conditions are met. We are guaranteed that `1 <= x_i <= 10^6`.\n\n**Key Properties of GCD and LCM:**\nFor any two positive integers `a` and `b`:\n1. `GCD(a, b) * LCM(a, b) = a * b`.\n2. `a` must be a multiple of `GCD(a, b)`.\n3. `b` must be a multiple of `GCD(a, b)`.\n4. `LCM(a, b)` must be a multiple of `a`.\n5. `LCM(a, b)` must be a multiple of `b`.\n\nFrom these properties, if an edge connects `u` and `v` with `g` and `l`:\n- `x_u` must be a multiple of `g`.\n- `x_v` must be a multiple of `g`.\n- `x_u` must divide `l`.\n- `x_v` must divide `l`.\n- `x_u * x_v = g * l`.\n\n**Initial Constraints on `x_i`:**\nFor each lawn `i`, `x_i` must be a multiple of `g` for *all* edges connected to `i`. This means `x_i` must be a multiple of `LCM_g_i = LCM(g_1, g_2, ..., g_k)` where `g_j` are the GCDs of edges connected to `i`.\nSimilarly, `x_i` must divide `l` for *all* edges connected to `i`. This means `x_i` must divide `GCD_l_i = GCD(l_1, l_2, ..., l_k)` where `l_j` are the LCMs of edges connected to `i`.\n\nSo, for each `x_i`, we know it must be of the form `k * LCM_g_i` and `k * LCM_g_i` must divide `GCD_l_i`.\nThis implies `LCM_g_i` must divide `GCD_l_i`. If not, no solution exists.\nLet `P_i = LCM_g_i` and `Q_i = GCD_l_i`. Then `x_i` must be a multiple of `P_i` and a divisor of `Q_i`.\nAlso, `x_i` must be between 1 and 10^6.\n\n**Graph Traversal and Propagation:**\nThe problem can be modeled as finding values for nodes in a graph. Since the values `x_i` are related, we can use a graph traversal approach (like BFS or DFS) to determine values.\n\n1. **Initialize `ans[i]`:** For each node `i`, initialize `ans[i]` to 0 (unknown).\n2. **Precompute `P_i` and `Q_i`:**\n   - For each node `i`, `P_i` is the LCM of all `g` values from edges connected to `i`.\n   - For each node `i`, `Q_i` is the GCD of all `l` values from edges connected to `i`.\n   - If `P_i` does not divide `Q_i`, then no solution exists. Output \"NO\".\n   - If `P_i > 10^6`, no solution exists. Output \"NO\".\n   - If `Q_i < P_i`, no solution exists. Output \"NO\".\n   - If `Q_i > 10^6`, no solution exists. Output \"NO\".\n   - If `P_i == Q_i`, then `x_i` must be `P_i`. Set `ans[i] = P_i`. Add `i` to a queue for propagation.\n3. **Propagation (BFS):**\n   - Use a queue for nodes whose `ans` value has been determined.\n   - While the queue is not empty, dequeue a node `u`.\n   - For each neighbor `v` of `u` connected by an edge with `g, l`:\n     - If `ans[v]` is already determined:\n       - Check if `GCD(ans[u], ans[v]) == g` and `LCM(ans[u], ans[v]) == l`. If not, output \"NO\".\n     - If `ans[v]` is not determined:\n       - We know `ans[u] * ans[v] = g * l`. So `ans[v] = (g * l) / ans[u]`.\n       - Check if `(g * l)` is divisible by `ans[u]`. If not, output \"NO\".\n       - Let `candidate_x_v = (g * l) / ans[u]`.\n       - Check if `candidate_x_v` is a multiple of `P_v` and a divisor of `Q_v`. If not, output \"NO\".\n       - Check if `1 <= candidate_x_v <= 10^6`. If not, output \"NO\".\n       - Check if `GCD(ans[u], candidate_x_v) == g` and `LCM(ans[u], candidate_x_v) == l`. If not, output \"NO\".\n       - If all checks pass, set `ans[v] = candidate_x_v` and enqueue `v`.\n4. **Handle Disconnected Components / Remaining Undetermined Nodes:**\n   - After the BFS, some nodes might still have `ans[i] = 0` (if the graph is disconnected or if no node's `P_i == Q_i`).\n   - For any such node `i`, we can try to pick `x_i = P_i`. This is the smallest possible valid value for `x_i` and satisfies `P_i | x_i` and `x_i | Q_i`. If `P_i` is not valid (e.g., `P_i > 10^6`), then no solution exists.\n   - Set `ans[i] = P_i` for all remaining `i` and enqueue them.\n   - Run another BFS pass to propagate these values.\n   - If after this, any `ans[i]` is still 0, it means `n > m` and there are isolated nodes. For isolated nodes, we can assign `ans[i] = 1`. (The problem states `n` lawns and `m` roads, so if `m=0`, all nodes are isolated).\n5. **Final Validation:**\n   - After all values are determined, iterate through all original edges `(u, v)` with `g, l`.\n   - Verify `GCD(ans[u], ans[v]) == g` and `LCM(ans[u], ans[v]) == l`. If any check fails, output \"NO\".\n   - Verify `1 <= ans[i] <= 10^6` for all `i`. If not, output \"NO\".\n   - If all checks pass, output \"YES\" and then the `ans` array.\n\n**Edge Cases and Optimizations:**\n- `n=1, m=0`: Output \"YES\", \"1\". (The code handles this by initializing `ans[0]=1` if `m=0` and `n=1`).\n- `GCD(a, b)` and `LCM(a, b)` functions: Python's `math.gcd` is efficient. For LCM, `(a * b) // math.gcd(a, b)`. Be careful with potential overflow if `a * b` exceeds standard integer limits before division, but here `a, b <= 10^6`, so `a*b <= 10^12`, which fits in standard Python integers.\n- `P_i` and `Q_i` calculation:\n    - `P_i` is `LCM_g_i`. Initialize `P_i = 1`. For each `g` on an incident edge, `P_i = LCM(P_i, g)`.\n    - `Q_i` is `GCD_l_i`. Initialize `Q_i = 0` (or the first `l` value). For each `l` on an incident edge, `Q_i = GCD(Q_i, l)`. If a node has no edges, `P_i=1`, `Q_i=0` (effectively infinite, meaning any value is a divisor). We can set `Q_i = 10^6` for isolated nodes. For nodes with no edges, `x_i=1` is a safe default.\n- The maximum value of `P_i` or `Q_i` can be `10^6`.\n\n**Implementation Details:**\n- Adjacency list `adj` to store edges: `adj[u] = [(v, g, l), ...]`.\n- `ans` array of size `n+1`.\n- `P` and `Q` arrays of size `n+1`.\n- Use a `deque` for BFS queue.\n\n```python\nimport math\nfrom collections import deque\n\n# Function to calculate LCM\ndef lcm(a, b):\n    if a == 0 or b == 0: # LCM is 0 if either number is 0\n        return 0\n    return (a * b) // math.gcd(a, b)\n\ndef solve():\n    n, m = map(int, input().split())\n\n    # Handle the n=1, m=0 case\n    if n == 1 and m == 0:\n        print(\"YES\")\n        print(\"1\")\n        return\n\n    adj = [[] for _ in range(n + 1)]\n    edges = [] # Store all edges to re-validate at the end\n\n    # Initialize P_i (LCM of incident GCDs) and Q_i (GCD of incident LCMs)\n    # P_i starts at 1 (identity for LCM)\n    # Q_i starts at 0 (identity for GCD, effectively infinite, will be updated to first l)\n    P = [1] * (n + 1)\n    Q = [0] * (n + 1)\n    has_edges = [False] * (n + 1) # To track if a node has any edges\n\n    for _ in range(m):\n        u, v, g, l = map(int, input().split())\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l))\n        edges.append((u, v, g, l))\n        has_edges[u] = True\n        has_edges[v] = True\n\n        # Update P_u, P_v, Q_u, Q_v\n        P[u] = lcm(P[u], g)\n        P[v] = lcm(P[v], g)\n        \n        if Q[u] == 0: Q[u] = l # First l for node u\n        else: Q[u] = math.gcd(Q[u], l)\n        \n        if Q[v] == 0: Q[v] = l # First l for node v\n        else: Q[v] = math.gcd(Q[v], l)\n\n    ans = [0] * (n + 1)\n    q = deque()\n\n    # Initial checks and populate queue\n    for i in range(1, n + 1):\n        if not has_edges[i]: # Isolated node\n            ans[i] = 1 # Default to 1 for isolated nodes\n            continue\n\n        # Check conditions for P_i and Q_i\n        # P_i must divide Q_i\n        if Q[i] % P[i] != 0:\n            print(\"NO\")\n            return\n        # Values must be within 1 and 10^6\n        if not (1 <= P[i] <= 10**6 and 1 <= Q[i] <= 10**6):\n            print(\"NO\")\n            return\n\n        # If P_i == Q_i, then x_i must be P_i\n        if P[i] == Q[i]:\n            ans[i] = P[i]\n            q.append(i)\n    \n    # BFS to propagate values\n    while q:\n        u = q.popleft()\n\n        for v, g, l in adj[u]:\n            if ans[v] == 0: # If v's value is not yet determined\n                # From x_u * x_v = g * l, we get x_v = (g * l) / x_u\n                if (g * l) % ans[u] != 0:\n                    print(\"NO\")\n                    return\n                \n                candidate_x_v = (g * l) // ans[u]\n\n                # Check if candidate_x_v satisfies its own P_v, Q_v constraints\n                if candidate_x_v % P[v] != 0 or Q[v] % candidate_x_v != 0:\n                    print(\"NO\")\n                    return\n                \n                # Check if candidate_x_v is within bounds\n                if not (1 <= candidate_x_v <= 10**6):\n                    print(\"NO\")\n                    return\n\n                # Check if GCD and LCM match for (u, v) with candidate_x_v\n                if math.gcd(ans[u], candidate_x_v) != g or lcm(ans[u], candidate_x_v) != l:\n                    print(\"NO\")\n                    return\n                \n                ans[v] = candidate_x_v\n                q.append(v)\n            else: # If v's value is already determined, just validate\n                if math.gcd(ans[u], ans[v]) != g or lcm(ans[u], ans[v]) != l:\n                    print(\"NO\")\n                    return\n    \n    # After BFS, if some nodes are still undetermined (ans[i] == 0),\n    # it means they were part of a component where no P_i == Q_i,\n    # or they are isolated nodes that were not explicitly handled by P_i/Q_i.\n    # We can try to assign P_i to them and run another validation.\n    # For isolated nodes, ans[i] is already 1.\n    for i in range(1, n + 1):\n        if ans[i] == 0:\n            ans[i] = P[i] # Try the minimum valid value\n            if not (1 <= ans[i] <= 10**6): # P[i] could be > 10^6\n                print(\"NO\")\n                return\n            q.append(i) # Add to queue for propagation/validation\n\n    # Run BFS again for any newly determined values\n    while q:\n        u = q.popleft()\n        for v, g, l in adj[u]:\n            if ans[v] == 0: # This should ideally not happen if graph is connected\n                # If we reach here, it implies a bug in logic or a very specific graph structure\n                # where P[i] assignment didn't fully propagate.\n                # Re-calculate candidate_x_v and validate as before.\n                if (g * l) % ans[u] != 0:\n                    print(\"NO\")\n                    return\n                candidate_x_v = (g * l) // ans[u]\n                if candidate_x_v % P[v] != 0 or Q[v] % candidate_x_v != 0:\n                    print(\"NO\")\n                    return\n                if not (1 <= candidate_x_v <= 10**6):\n                    print(\"NO\")\n                    return\n                if math.gcd(ans[u], candidate_x_v) != g or lcm(ans[u], candidate_x_v) != l:\n                    print(\"NO\")\n                    return\n                ans[v] = candidate_x_v\n                q.append(v)\n            else: # Validate existing values\n                if math.gcd(ans[u], ans[v]) != g or lcm(ans[u], ans[v]) != l:\n                    print(\"NO\")\n                    return\n\n    # Final check: Ensure all values are determined and valid\n    for i in range(1, n + 1):\n        if ans[i] == 0: # This can happen for isolated nodes if m=0 and n>1\n            ans[i] = 1 # Default to 1 for truly isolated nodes without any constraints\n        if not (1 <= ans[i] <= 10**6):\n            print(\"NO\")\n            return\n            \n    # Final verification of all edges\n    for u, v, g, l in edges:\n        if math.gcd(ans[u], ans[v]) != g or lcm(ans[u], ans[v]) != l:\n            print(\"NO\")\n            return\n\n    print(\"YES\")\n    print(*(ans[1:]))\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\nfrom collections import deque\n\n# Function to calculate LCM\ndef lcm(a, b):\n    if a == 0 or b == 0: # LCM is 0 if either number is 0\n        return 0\n    return (a * b) // math.gcd(a, b)\n\ndef solve():\n    n, m = map(int, input().split())\n\n    # Handle the n=1, m=0 case\n    if n == 1 and m == 0:\n        print(\"YES\")\n        print(\"1\")\n        return\n\n    adj = [[] for _ in range(n + 1)]\n    edges = [] # Store all edges to re-validate at the end\n\n    # Initialize P_i (LCM of incident GCDs) and Q_i (GCD of incident LCMs)\n    # P_i starts at 1 (identity for LCM)\n    # Q_i starts at 0 (identity for GCD, effectively infinite, will be updated to first l)\n    P = [1] * (n + 1)\n    Q = [0] * (n + 1)\n    has_edges = [False] * (n + 1) # To track if a node has any edges\n\n    for _ in range(m):\n        u, v, g, l = map(int, input().split())\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l))\n        edges.append((u, v, g, l))\n        has_edges[u] = True\n        has_edges[v] = True\n\n        # Update P_u, P_v, Q_u, Q_v\n        P[u] = lcm(P[u], g)\n        P[v] = lcm(P[v], g)\n        \n        if Q[u] == 0: Q[u] = l # First l for node u\n        else: Q[u] = math.gcd(Q[u], l)\n        \n        if Q[v] == 0: Q[v] = l # First l for node v\n        else: Q[v] = math.gcd(Q[v], l)\n\n    ans = [0] * (n + 1)\n    q = deque()\n\n    # Initial checks and populate queue\n    for i in range(1, n + 1):\n        if not has_edges[i]: # Isolated node\n            ans[i] = 1 # Default to 1 for isolated nodes\n            continue\n\n        # Check conditions for P_i and Q_i\n        # P_i must divide Q_i\n        if Q[i] % P[i] != 0:\n            print(\"NO\")\n            return\n        # Values must be within 1 and 10^6\n        if not (1 <= P[i] <= 10**6 and 1 <= Q[i] <= 10**6):\n            print(\"NO\")\n            return\n\n        # If P_i == Q_i, then x_i must be P_i\n        if P[i] == Q[i]:\n            ans[i] = P[i]\n            q.append(i)\n    \n    # BFS to propagate values\n    while q:\n        u = q.popleft()\n\n        for v, g, l in adj[u]:\n            if ans[v] == 0: # If v's value is not yet determined\n                # From x_u * x_v = g * l, we get x_v = (g * l) / x_u\n                if (g * l) % ans[u] != 0:\n                    print(\"NO\")\n                    return\n                \n                candidate_x_v = (g * l) // ans[u]\n\n                # Check if candidate_x_v satisfies its own P_v, Q_v constraints\n                if candidate_x_v % P[v] != 0 or Q[v] % candidate_x_v != 0:\n                    print(\"NO\")\n                    return\n                \n                # Check if candidate_x_v is within bounds\n                if not (1 <= candidate_x_v <= 10**6):\n                    print(\"NO\")\n                    return\n\n                # Check if GCD and LCM match for (u, v) with candidate_x_v\n                if math.gcd(ans[u], candidate_x_v) != g or lcm(ans[u], candidate_x_v) != l:\n                    print(\"NO\")\n                    return\n                \n                ans[v] = candidate_x_v\n                q.append(v)\n            else: # If v's value is already determined, just validate\n                if math.gcd(ans[u], ans[v]) != g or lcm(ans[u], ans[v]) != l:\n                    print(\"NO\")\n                    return\n    \n    # After BFS, if some nodes are still undetermined (ans[i] == 0),\n    # it means they were part of a component where no P_i == Q_i,\n    # or they are isolated nodes that were not explicitly handled by P_i/Q_i.\n    # We can try to assign P_i to them and run another validation.\n    # For isolated nodes, ans[i] is already 1.\n    for i in range(1, n + 1):\n        if ans[i] == 0:\n            ans[i] = P[i] # Try the minimum valid value\n            if not (1 <= ans[i] <= 10**6): # P[i] could be > 10^6\n                print(\"NO\")\n                return\n            q.append(i) # Add to queue for propagation/validation\n\n    # Run BFS again for any newly determined values\n    while q:\n        u = q.popleft()\n        for v, g, l in adj[u]:\n            if ans[v] == 0: # This should ideally not happen if graph is connected\n                # If we reach here, it implies a bug in logic or a very specific graph structure\n                # where P[i] assignment didn't fully propagate.\n                # Re-calculate candidate_x_v and validate as before.\n                if (g * l) % ans[u] != 0:\n                    print(\"NO\")\n                    return\n                candidate_x_v = (g * l) // ans[u]\n                if candidate_x_v % P[v] != 0 or Q[v] % candidate_x_v != 0:\n                    print(\"NO\")\n                    return\n                if not (1 <= candidate_x_v <= 10**6):\n                    print(\"NO\")\n                    return\n                if math.gcd(ans[u], candidate_x_v) != g or lcm(ans[u], candidate_x_v) != l:\n                    print(\"NO\")\n                    return\n                ans[v] = candidate_x_v\n                q.append(v)\n            else: # Validate existing values\n                if math.gcd(ans[u], ans[v]) != g or lcm(ans[u], ans[v]) != l:\n                    print(\"NO\")\n                    return\n\n    # Final check: Ensure all values are determined and valid\n    for i in range(1, n + 1):\n        if ans[i] == 0: # This can happen for isolated nodes if m=0 and n>1\n            ans[i] = 1 # Default to 1 for truly isolated nodes without any constraints\n        if not (1 <= ans[i] <= 10**6):\n            print(\"NO\")\n            return\n            \n    # Final verification of all edges\n    for u, v, g, l in edges:\n        if math.gcd(ans[u], ans[v]) != g or lcm(ans[u], ans[v]) != l:\n            print(\"NO\")\n            return\n\n    print(\"YES\")\n    print(*(ans[1:]))\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 542,
        "completion_token_count": 3918,
        "thoughts_token_count": 720
    }
}