{
    "start": 1758009389.790458,
    "end": 1758009477.139517,
    "start-formatted": "2025-09-16 16:56 KST",
    "end-formatted": "2025-09-16 16:57 KST",
    "gpu": 2,
    "pid": 8,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "**Solving the \"Flawed Flow\" Problem**\n\nAlright, I'm tackling this \"Flawed Flow\" problem. It's about directing edges in an undirected graph while satisfying flow constraints. The core of it seems to be ensuring flow conservation at each intermediate vertex, no incoming edges at the source, no cycles in the directed graph, and, importantly, finding a *valid* maximum flow. Luckily, the problem statement says a solution *always* exists, which simplifies things considerably.\n\nThe first thing that pops out is that the 'no-cycles' constraint forces the directed graph to be a DAG. This immediately brings topological sorting to mind. If I can find a topological ordering, all edges will necessarily point from an earlier vertex in the ordering to a later one, which inherently avoids cycles. This seems like a promising direction to explore.\n\nNow, let's break down the conditions. The flow conservation rule at vertices *other than the source and sink* is the key.  At any vertex, the incoming flow must equal the outgoing flow. The source has no incoming flow, and the sink can have only incoming flow. The total flow leaving the source and entering the sink should be equal.\n\nThe no-cycles condition is a very strong one. Knowing I can have a DAG, it makes me think I can build up the flow greedily.  I start with the source – all edges connected to it must be directed outwards.  This sets the direction for some edges and their associated flow. For example, if there's an edge (1, u) with flow 'c', then I know it's 1 -> u.  This \"uses up\" 'c' units of outgoing flow from vertex 1 and creates a \"surplus\" of 'c' incoming flow at vertex u.  Then, I need to propagate that information to vertex u, making sure its outgoing flow is equal to this incoming flow, and so on.\n\nPerhaps I can maintain a balance for each vertex, tracking its net \"deficit\" or \"surplus\" of flow. Initially, I assume all edges can go either way. Once I direct an edge, it changes the balance of the two associated vertices. For a vertex, I want to keep track of its total *potential* incoming and outgoing flow (considering edges that could be incoming or outgoing), which I can gradually adjust. I'll have to be careful about that adjustment as I direct edges. I can't let a vertex become \"overfull\" by directing edges into it.\n\nI need a systematic way to process the edges and direct them. The topological sort idea will be instrumental.  I suspect I can start at the source and \"flood\" the flow outward, resolving edge directions step-by-step to build this DAG, always making sure I'm respecting the flow conservation rules and the no-cycles constraint.\n",
    "response": "The problem asks us to direct each edge `(a_i, b_i)` with a given flow volume `c_i` such that:\n1. For any intermediate vertex `v` (1 < `v` < `n`), the sum of incoming flow equals the sum of outgoing flow.\n2. Vertex 1 (source) has no incoming edges.\n3. The resulting directed graph contains no cycles.\n\nThe problem guarantees that a solution always exists. We need to output `0` if the flow is `a_i -> b_i` and `1` if `b_i -> a_i`.\n\nThe key conditions are \"no incoming edges for vertex 1\" and \"no cycles\". The no-cycles condition implies that the resulting graph must be a Directed Acyclic Graph (DAG). In a DAG, there must be at least one source (a vertex with no incoming edges) and at least one sink (a vertex with no outgoing edges). Our problem explicitly states vertex 1 is the source and vertex `n` is the sink (implicitly, by flow conservation for others).\n\nThe condition \"vertex 1 has no incoming edges\" means all edges incident to vertex 1 must be directed *outwards* from 1. This gives us a starting point.\n\nLet's consider a standard approach for problems involving DAGs and flow-like properties: processing vertices in a topological order or using a queue-based approach (like Kahn's algorithm for topological sort).\n\nWe can maintain the \"net flow deficit\" for each vertex. For an intermediate vertex `v`, its net flow must be zero. If we direct an edge `u -> v`, `v` receives `c` flow. If `v -> u`, `v` sends `c` flow.\nLet `balance[v]` be the sum of `c_i` for edges directed *into* `v` minus the sum of `c_i` for edges directed *out of* `v`. We want `balance[v] = 0` for `1 < v < n`.\n\nThe no-cycles condition is crucial. If we direct edges such that we always move \"forward\" in some sense, we can avoid cycles. A common strategy is to process vertices that have \"fulfilled\" their incoming flow requirements or have a known state.\n\nLet's try a queue-based approach:\n1. **Initialization:**\n   - Create an adjacency list `adj` for the undirected graph, storing `(neighbor, flow_volume, edge_index)`.\n   - Create an array `result` of size `m` to store the output directions.\n   - For each vertex `v` (1 to `n`), calculate `total_flow_sum[v]`, which is the sum of `c_i` for all edges incident to `v`. This represents the total \"capacity\" or \"potential\" flow that must pass through `v` (either incoming or outgoing).\n   - Initialize `current_in_flow[v] = 0` for all `v`. This will track the actual incoming flow for `v` as we direct edges.\n   - Initialize a queue `q`.\n\n2. **Source Processing:**\n   - Vertex 1 must have all its incident edges directed outwards. For each edge `(1, u)` with flow `c` and index `idx`:\n     - Direct it `1 -> u`. This means `result[idx] = 0` if `a_idx = 1` and `b_idx = u`, or `result[idx] = 1` if `a_idx = u` and `b_idx = 1`.\n     - Add `c` to `current_in_flow[u]`.\n   - Add vertex 1 to the queue `q`. (Although vertex 1 doesn't need flow conservation, adding it allows us to process its neighbors and propagate flow).\n\n3. **BFS-like Traversal:**\n   - While the queue `q` is not empty:\n     - Dequeue a vertex `u`.\n     - For each neighbor `v` of `u` connected by an edge `(u, v)` with flow `c` and index `idx`:\n       - If the direction of this edge `(u, v)` has already been determined (i.e., `result[idx]` is set), skip it.\n       - We need to decide the direction of `(u, v)`. Since `u` has been processed (or is being processed), and we're trying to build a DAG, we want to direct edges away from `u` if possible, or towards `u` if necessary to satisfy `v`'s conservation.\n       - A simpler approach, given the \"no cycles\" condition, is to use a traversal that implicitly defines a topological order.\n       - The problem statement \"vertex with number 1 has no incoming edges\" and \"the obtained directed graph does not have cycles\" strongly suggests that we can process vertices in a way that all edges are directed from a \"visited\" or \"processed\" vertex to an \"unvisited\" or \"partially processed\" vertex.\n\nLet's refine the queue-based approach:\nThe core idea is that for any vertex `v` (1 < `v` < `n`), its total incoming flow must eventually equal its total outgoing flow. The total potential flow through `v` is `total_flow_sum[v]`. If `current_in_flow[v]` is the sum of flows from edges *already directed into* `v`, then `total_flow_sum[v] - current_in_flow[v]` must be the sum of flows from edges that will eventually be directed *out of* `v`. This must also equal the sum of flows from edges that will eventually be directed *into* `v` (from neighbors not yet processed or whose edges are not yet directed).\n\nThis looks like a topological sort approach. A vertex `v` can be processed once all its incoming edges have been directed. If `v` is not `n`, then the sum of its incoming flows (`current_in_flow[v]`) must equal the sum of its outgoing flows. The remaining flow `total_flow_sum[v] - current_in_flow[v]` must be directed *out* of `v`.\n\nLet's use a `visited` array to keep track of edges whose directions have been set.\nInitialize `visited_edge[m] = False`.\n`current_flow_balance[v]` will store `sum(incoming_c) - sum(outgoing_c)` for vertex `v`. We want this to be 0 for intermediate vertices.\n\n1. **Graph Representation:**\n   `adj[u]` stores a list of `(v, c, edge_idx, original_a, original_b)` for each neighbor `v`.\n   `result[edge_idx]` stores 0 or 1.\n   `degree[v]` stores the count of undirected edges incident to `v`.\n   `in_degree[v]` stores the count of incoming edges for `v` that are *yet to be satisfied* by other nodes (this is more for a standard topological sort).\n   `flow_in_sum[v]` stores the total flow into `v` from edges whose direction has been decided.\n\n2. **Algorithm using a queue:**\n   - Initialize `flow_in_sum[v] = 0` for all `v`.\n   - Initialize `result` array.\n   - Initialize `edge_directed[edge_idx] = False`.\n   - Create a queue `q`.\n\n   - **Process vertex 1:**\n     - Add 1 to `q`.\n     - For each edge `(1, u)` with flow `c` and index `idx` (where `original_a = 1, original_b = u`):\n       - `result[idx] = 0` (flow `1 -> u`).\n       - `flow_in_sum[u] += c`.\n       - `edge_directed[idx] = True`.\n       - If `u` is not `n`, and `flow_in_sum[u]` reaches `total_flow_sum[u] / 2` (meaning half the total potential flow through `u` has entered `u`), then `u` is ready to be processed for its outgoing edges. Add `u` to `q`. (This is a bit tricky, `total_flow_sum[u]` is total of all incident edges. If `u` is an intermediate node, then `sum(in_flows) = sum(out_flows)`. So `sum(all_incident_flows) = 2 * sum(in_flows)`. So `sum(in_flows) = sum(all_incident_flows) / 2`).\n\n   - **BFS Loop:**\n     - While `q` is not empty:\n       - Dequeue `u`.\n       - For each edge `(u, v)` with flow `c` and index `idx`:\n         - If `edge_directed[idx]` is `True`, continue (already processed).\n         - This edge `(u, v)` must be directed `u -> v` to satisfy `u`'s outgoing flow requirement (since `u` is now processed and its incoming flow is settled).\n         - `result[idx] = 0` if `original_a=u, original_b=v`; `result[idx] = 1` if `original_a=v, original_b=u`.\n         - `edge_directed[idx] = True`.\n         - `flow_in_sum[v] += c`.\n         - If `v` is not `n`, and `flow_in_sum[v] == total_flow_sum[v] / 2`:\n           - Add `v` to `q`.\n\nThis approach seems robust. It starts from vertex 1, directs all its edges outwards. Then, any vertex `u` that receives half its total incident flow (meaning its incoming flow is complete) is added to the queue. When `u` is dequeued, all its remaining undirected incident edges must be directed outwards from `u` to satisfy flow conservation. This process continues until all edges are directed. Since a solution is guaranteed and must be a DAG, this greedy approach should work.\n\nLet's refine the `total_flow_sum` and `flow_in_sum` logic.\nFor each vertex `v`, let `total_incident_flow[v]` be the sum of `c_i` for all edges incident to `v`.\nFor an intermediate vertex `v` (1 < `v` < `n`), the sum of incoming flows must equal the sum of outgoing flows. Thus, `sum(incoming_flows) = total_incident_flow[v] / 2`.\nFor vertex 1, all edges are outgoing.\nFor vertex `n`, all edges are effectively incoming (or some outgoing if `n` were also a source, but problem implies `n` is a sink).\n\nThe problem states \"vertex with number 1 has no incoming edges\". This is very specific. It doesn't say anything about vertex `n` having no outgoing edges. However, for an intermediate node `v` (1 < `v` < `n`), `sum(in) = sum(out)`. The total flow `F` from 1 to `n` means `sum(out from 1) = F` and `sum(in to n) = F`.\n\nLet's use `current_flow[v]` to track `sum(incoming_flow) - sum(outgoing_flow)` for each vertex `v`.\nInitially, `current_flow[v] = 0` for all `v`.\nWhen we direct `u -> v` with flow `c`:\n`current_flow[u] -= c`\n`current_flow[v] += c`\n\nWe need to ensure `current_flow[v] = 0` for `1 < v < n`.\nFor vertex 1, `current_flow[1]` should be `-(Total Flow)`.\nFor vertex `n`, `current_flow[n]` should be `+(Total Flow)`.\n\nThe no-cycles condition is the tricky part. A simple BFS from source 1, always directing edges away from visited nodes, might create cycles if there are multiple paths or if a node's full incoming flow isn't determined yet.\n\nConsider a simpler perspective:\nWe have `m` edges. Each edge `(a_i, b_i)` with `c_i` flow can be `a_i -> b_i` or `b_i -> a_i`.\nLet `x_i = 0` if `a_i -> b_i`, `x_i = 1` if `b_i -> a_i`.\nFor each vertex `v` (1 < `v` < `n`):\n`sum_{j where a_j=v and x_j=1} c_j + sum_{j where b_j=v and x_j=0} c_j = sum_{j where a_j=v and x_j=0} c_j + sum_{j where b_j=v and x_j=1} c_j`\nThis is `sum(incoming) = sum(outgoing)`.\n\nThis can be rewritten as:\n`sum_{j where a_j=v} c_j * (1-x_j) + sum_{j where b_j=v} c_j * x_j = sum_{j where a_j=v} c_j * x_j + sum_{j where b_j=v} c_j * (1-x_j)`\n`sum_{j where a_j=v} c_j * (1-2x_j) + sum_{j where b_j=v} c_j * (2x_j-1) = 0`\nThis simplifies to `sum_{j where a_j=v} c_j * (1-2x_j) - sum_{j where b_j=v} c_j * (1-2x_j) = 0`.\nLet `d_j = 1-2x_j`. If `x_j=0` (a_j -> b_j), `d_j=1`. If `x_j=1` (b_j -> a_j), `d_j=-1`.\nSo `d_j` is `1` if flow is `a_j -> b_j`, `-1` if flow is `b_j -> a_j`.\nThen for `v` (1 < `v` < `n`):\n`sum_{j where a_j=v} c_j * d_j + sum_{j where b_j=v} c_j * (-d_j) = 0`\nThis is `sum_{j where a_j=v} c_j * d_j - sum_{j where b_j=v} c_j * d_j = 0`.\nThis is just `net_flow_out_of_v = 0`.\n\nThe condition \"vertex 1 has no incoming edges\" means for any edge `(1, u)`, it must be `1 -> u`.\nIf `a_j = 1`, then `x_j = 0`, so `d_j = 1`.\nIf `b_j = 1`, then `x_j = 1`, so `d_j = -1`.\nIn both cases, `d_j` determines the direction *out* of 1.\n\nThe no-cycles condition is key. If we can find a topological ordering, then all edges must go from an earlier vertex to a later vertex.\nA standard way to find a topological ordering and process nodes is Kahn's algorithm, which uses in-degrees. However, here edges are undirected initially.\n\nLet's maintain for each vertex `v` the `current_balance[v]`: sum of flow into `v` minus sum of flow out of `v`.\nInitially, `current_balance[v] = 0` for all `v`.\nWe want `current_balance[v] = 0` for `1 < v < n`.\n\nConsider a queue `Q`. Add vertex `1` to `Q`.\nWhen we extract `u` from `Q`:\nWe know that `u` is ready to \"send out\" flow. All edges incident to `u` that haven't been directed yet must be directed *outwards* from `u`.\nFor each neighbor `v` of `u` connected by an edge `(u, v)` with flow `c` and original index `idx`:\n  If `result[idx]` is not set:\n    Direct edge `u -> v`.\n    If `original_a[idx] == u`: `result[idx] = 0`.\n    If `original_b[idx] == u`: `result[idx] = 1`.\n    Update `current_balance[v] += c`.\n    Update `current_balance[u] -= c`.\n    If `v != n` and `current_balance[v]` becomes `total_incident_flow[v] / 2` (or rather, if `current_balance[v]` is now positive and equals half the total flow through it, meaning all its incoming flow is accounted for), add `v` to `Q`.\n\nThis approach is slightly flawed. `current_balance[v]` should be `sum(incoming) - sum(outgoing)`.\nIf `current_balance[v]` becomes `0` for an intermediate vertex `v`, it means all its incident edges have been directed and its flow conservation is met. We can add it to a queue of \"finished\" nodes.\n\nLet's use `flow_received[v]` for the sum of flow *into* `v` from directed edges.\nAnd `total_incident_flow[v]` for the sum of `c_i` for all edges incident to `v`.\nFor `1 < v < n`, we need `flow_received[v] = total_incident_flow[v] / 2`.\n\n1. **Initialization:**\n   - `adj`: list of `(neighbor, flow_c, edge_idx, original_a, original_b)` for each vertex.\n   - `result`: array of size `m`, initialized to -1 (undirected).\n   - `flow_received[v] = 0` for all `v`.\n   - `total_incident_flow[v] = 0` for all `v`.\n   - For each edge `(a, b, c, idx)` in input:\n     - Add `(b, c, idx, a, b)` to `adj[a]`.\n     - Add `(a, c, idx, a, b)` to `adj[b]`.\n     - `total_incident_flow[a] += c`.\n     - `total_incident_flow[b] += c`.\n\n   - `q`: a `collections.deque`.\n\n2. **Start with Source (vertex 1):**\n   - For each edge `(1, u)` with flow `c` and index `idx` (assume `original_a = 1, original_b = u`):\n     - `result[idx] = 0` (direct `1 -> u`).\n     - `flow_received[u] += c`.\n   - Add `1` to `q`. (Vertex 1 is effectively \"processed\" for its outgoing edges as they are all directed).\n\n3. **BFS Traversal:**\n   - While `q` is not empty:\n     - Dequeue `u`.\n     - For each neighbor `v` of `u` connected by edge `(u, v)` with flow `c` and index `idx` (where `original_a, original_b` are the original endpoints):\n       - If `result[idx]` is not -1, this edge has already been directed, skip.\n       - **Decision:**\n         - If `u` is vertex 1, we already handled its outgoing edges. This loop is for processing other nodes.\n         - If `u` is not vertex `n`, `u` must satisfy `flow_received[u] == total_incident_flow[u] / 2`.\n         - If `u` has been dequeued, it means `u` has received all its incoming flow. To satisfy flow conservation, all its remaining undirected edges must be directed *outwards* from `u`.\n         - So, direct `u -> v`.\n         - If `original_a == u`: `result[idx] = 0`.\n         - Else (`original_b == u`): `result[idx] = 1`.\n         - `flow_received[v] += c`.\n         - If `v != n` and `flow_received[v] == total_incident_flow[v] / 2`:\n           - Add `v` to `q`.\n\nThis refined algorithm seems correct. It ensures that any vertex `u` dequeued from `q` has already received all its necessary incoming flow (or is the source). Then, it directs all its *remaining* undirected edges outwards. This guarantees flow conservation for `u` (if `u != n`) and prevents cycles because edges are always directed from an already processed node to a not-yet-fully-processed node.\n\nExample walk-through:\nInput:\n3 3\n3 2 10 (edge 0)\n1 2 10 (edge 1)\n3 1 5  (edge 2)\n\n`adj`:\n1: [(2, 10, 1, 1, 2), (3, 5, 2, 3, 1)]\n2: [(3, 10, 0, 3, 2), (1, 10, 1, 1, 2)]\n3: [(2, 10, 0, 3, 2), (1, 5, 2, 3, 1)]\n\n`total_incident_flow`:\n1: 10 + 5 = 15\n2: 10 + 10 = 20\n3: 10 + 5 = 15\n\n`flow_received`: [0, 0, 0, 0]\n`result`: [-1, -1, -1]\n`q`: deque()\n\n**Step 2: Start with Source (vertex 1)**\n- Add 1 to `q`. `q = [1]`\n- Edge `(1, 2)` (flow 10, idx 1, original_a=1, original_b=2):\n  - `result[1] = 0` (1 -> 2)\n  - `flow_received[2] += 10` (now `flow_received[2] = 10`)\n- Edge `(3, 1)` (flow 5, idx 2, original_a=3, original_b=1):\n  - `result[2] = 1` (1 -> 3) (since `original_b=1`, we want `b -> a` i.e. `1 -> 3`)\n  - `flow_received[3] += 5` (now `flow_received[3] = 5`)\n\n**Step 3: BFS Traversal**\n`q = [1]`\nDequeue `u = 1`.\nNeighbors of 1: (2, 10, 1, 1, 2), (3, 5, 2, 3, 1)\n- Edge (1, 2): `result[1]` is 0, already directed. Skip.\n- Edge (3, 1): `result[2]` is 1, already directed. Skip.\n`q = []`\n\nNow check if any new nodes are ready for queueing based on `flow_received`.\n- For `v = 2`: `flow_received[2] = 10`. `total_incident_flow[2] = 20`. `20/2 = 10`.\n  Since `v != n` (2 != 3) and `flow_received[2] == total_incident_flow[2] / 2`, add 2 to `q`. `q = [2]`.\n- For `v = 3`: `flow_received[3] = 5`. `total_incident_flow[3] = 15`. `15/2` is not 5. So 3 is not ready.\n\n`q = [2]`\nDequeue `u = 2`.\nNeighbors of 2: (3, 10, 0, 3, 2), (1, 10, 1, 1, 2)\n- Edge (1, 2): `result[1]` is 0, already directed. Skip.\n- Edge (3, 2): `result[0]` is -1. Direct `2 -> 3`.\n  - `original_a = 3, original_b = 2`. We want `2 -> 3`. So `original_b` is the source, `original_a` is the sink. `result[0] = 1`.\n  - `flow_received[3] += 10` (now `flow_received[3] = 5 + 10 = 15`).\n  - `v = 3`. `v == n` (3 == 3). So we don't add `n` to `q`.\n`q = []`\n\nAll edges are directed.\n`result = [1, 0, 1]`\nThis matches the example output.\n\nThis algorithm seems correct and handles the conditions. The \"no cycles\" condition is implicitly satisfied because we always direct edges from a \"processed\" node (whose incoming flow is fully determined) to an \"unprocessed\" node.\n\nThe maximum number of vertices `n` and edges `m` are `2 * 10^5`.\n- Initializing `adj`, `total_incident_flow`: O(N+M)\n- Processing source 1: O(degree(1))\n- BFS loop: Each edge is processed once to determine its direction. Each vertex is enqueued/dequeued once. O(N+M).\nTotal time complexity: O(N+M).\nSpace complexity: O(N+M) for adjacency list, results, flow arrays.\nThis should be efficient enough.\n\n```python\nimport sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    # adj[u] stores (neighbor, flow_c, edge_idx, original_a, original_b)\n    adj = [[] for _ in range(n + 1)]\n    \n    # Store original edge info to correctly determine 0 or 1 for output\n    edges_info = []\n\n    # total_incident_flow[v]: sum of flow_c for all edges connected to v\n    total_incident_flow = [0] * (n + 1)\n    \n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        edges_info.append((u, v, c))\n        adj[u].append((v, c, i, u, v))\n        adj[v].append((u, c, i, u, v))\n        total_incident_flow[u] += c\n        total_incident_flow[v] += c\n\n    # result[edge_idx]: 0 for a_i -> b_i, 1 for b_i -> a_i\n    result = [-1] * m\n    \n    # flow_received[v]: sum of flow_c for edges already directed INTO v\n    flow_received = [0] * (n + 1)\n    \n    q = deque()\n\n    # Process source (vertex 1)\n    # All edges incident to vertex 1 must be directed outwards from 1.\n    for neighbor, flow_c, edge_idx, original_a, original_b in adj[1]:\n        if result[edge_idx] == -1: # If not yet directed\n            # Direct 1 -> neighbor\n            if original_a == 1:\n                result[edge_idx] = 0 # 1 -> neighbor\n            else: # original_b == 1\n                result[edge_idx] = 1 # 1 -> neighbor (original_b -> original_a)\n            \n            flow_received[neighbor] += flow_c\n            \n            # If neighbor is an intermediate node and has received all its required incoming flow,\n            # add it to the queue to process its outgoing edges.\n            # An intermediate node v needs sum(incoming_flow) = total_incident_flow[v] / 2\n            if neighbor != n and flow_received[neighbor] == total_incident_flow[neighbor] // 2:\n                q.append(neighbor)\n    \n    # Add 1 to queue after processing its initial edges.\n    # We add 1 to the queue to ensure its neighbors are checked, but 1 itself\n    # doesn't need flow_received check as it's the source.\n    # The initial loop above already adds neighbors of 1 to q if they are ready.\n    # So, we don't need to add 1 itself to the queue.\n\n    # BFS traversal\n    while q:\n        u = q.popleft()\n\n        # For vertex u, all its remaining undirected incident edges must be directed outwards from u\n        for neighbor, flow_c, edge_idx, original_a, original_b in adj[u]:\n            if result[edge_idx] == -1: # If this edge is not yet directed\n                # Direct u -> neighbor\n                if original_a == u:\n                    result[edge_idx] = 0 # u -> neighbor\n                else: # original_b == u\n                    result[edge_idx] = 1 # u -> neighbor (original_b -> original_a)\n                \n                flow_received[neighbor] += flow_c\n                \n                # If neighbor is an intermediate node and has received all its required incoming flow,\n                # add it to the queue to process its outgoing edges.\n                if neighbor != n and flow_received[neighbor] == total_incident_flow[neighbor] // 2:\n                    q.append(neighbor)\n\n    for i in range(m):\n        sys.stdout.write(str(result[i]) + '\\n')\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    # adj[u] stores (neighbor, flow_c, edge_idx, original_a, original_b)\n    adj = [[] for _ in range(n + 1)]\n    \n    # Store original edge info to correctly determine 0 or 1 for output\n    edges_info = []\n\n    # total_incident_flow[v]: sum of flow_c for all edges connected to v\n    total_incident_flow = [0] * (n + 1)\n    \n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        edges_info.append((u, v, c))\n        adj[u].append((v, c, i, u, v))\n        adj[v].append((u, c, i, u, v))\n        total_incident_flow[u] += c\n        total_incident_flow[v] += c\n\n    # result[edge_idx]: 0 for a_i -> b_i, 1 for b_i -> a_i\n    result = [-1] * m\n    \n    # flow_received[v]: sum of flow_c for edges already directed INTO v\n    flow_received = [0] * (n + 1)\n    \n    q = deque()\n\n    # Process source (vertex 1)\n    # All edges incident to vertex 1 must be directed outwards from 1.\n    for neighbor, flow_c, edge_idx, original_a, original_b in adj[1]:\n        if result[edge_idx] == -1: # If not yet directed\n            # Direct 1 -> neighbor\n            if original_a == 1:\n                result[edge_idx] = 0 # 1 -> neighbor\n            else: # original_b == 1\n                result[edge_idx] = 1 # 1 -> neighbor (original_b -> original_a)\n            \n            flow_received[neighbor] += flow_c\n            \n            # If neighbor is an intermediate node and has received all its required incoming flow,\n            # add it to the queue to process its outgoing edges.\n            # An intermediate node v needs sum(incoming_flow) = total_incident_flow[v] / 2\n            if neighbor != n and flow_received[neighbor] == total_incident_flow[neighbor] // 2:\n                q.append(neighbor)\n    \n    # Add 1 to queue after processing its initial edges.\n    # We add 1 to the queue to ensure its neighbors are checked, but 1 itself\n    # doesn't need flow_received check as it's the source.\n    # The initial loop above already adds neighbors of 1 to q if they are ready.\n    # So, we don't need to add 1 itself to the queue.\n\n    # BFS traversal\n    while q:\n        u = q.popleft()\n\n        # For vertex u, all its remaining undirected incident edges must be directed outwards from u\n        for neighbor, flow_c, edge_idx, original_a, original_b in adj[u]:\n            if result[edge_idx] == -1: # If this edge is not yet directed\n                # Direct u -> neighbor\n                if original_a == u:\n                    result[edge_idx] = 0 # u -> neighbor\n                else: # original_b == u\n                    result[edge_idx] = 1 # u -> neighbor (original_b -> original_a)\n                \n                flow_received[neighbor] += flow_c\n                \n                # If neighbor is an intermediate node and has received all its required incoming flow,\n                # add it to the queue to process its outgoing edges.\n                if neighbor != n and flow_received[neighbor] == total_incident_flow[neighbor] // 2:\n                    q.append(neighbor)\n\n    for i in range(m):\n        sys.stdout.write(str(result[i]) + '\\n')\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 736,
        "completion_token_count": 6810,
        "thoughts_token_count": 832
    }
}