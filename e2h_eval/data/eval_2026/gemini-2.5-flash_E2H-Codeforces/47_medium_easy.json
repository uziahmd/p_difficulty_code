{
    "start": 1758294766.230942,
    "end": 1758294827.12299,
    "start-formatted": "2025-09-20 00:12 KST",
    "end-formatted": "2025-09-20 00:13 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "**The Quest for Minimal LCM**\n\nOkay, so I'm on a mission: given two integers, `a` and `b`, I need to find the smallest non-negative integer `k` that makes the least common multiple (LCM) of `a+k` and `b+k` as small as possible.  If multiple `k` values tie for the minimum LCM, I have to pick the smallest one.\n\nMy approach? Let's call `x = a+k` and `y = b+k`.  The LCM of `x` and `y` is calculated as `(x * y) / gcd(x, y)`, where `gcd` is the greatest common divisor. Now, if the two numbers `a` and `b` are equal, `k=0` is the answer.\n\nI can represent the `gcd` of `x` and `y` with a `g`.  This `g` divides `x` and `y`. It must then divide their difference, which is `b - a`.  I'll call this difference `d`.  This means `g` must be a divisor of `d`.\n\nMy strategy will be to consider each divisor `g` of `d`. For each `g`, I'll determine the smallest `k` that makes both `a+k` and `b+k` multiples of `g`.  This means that for each `g`, I can find a smallest `k` called `k_g`.\n\nTo calculate the `k_g`, I can use `g` to get the smallest value of `k`, and it's calculated using the formula `(g - (a % g)) % g`.  Then `lcm(a+k, b+k)`. Then I take the minimum `k` from the calculations.\n\nI'll iterate through all the divisors of `d`, compute the corresponding `k` values, and keep track of the smallest LCM found so far along with its associated `k`. The solution will be the smallest `k` that yielded the global minimum LCM across all tested divisors.\n",
    "response": "The problem asks us to find the smallest non-negative integer `k` such that `lcm(a+k, b+k)` is minimized. If multiple `k` values yield the same minimum LCM, we should choose the smallest `k`.\n\nLet `x = a+k` and `y = b+k`. We want to minimize `lcm(x, y)`.\nWe know that `lcm(x, y) = (x * y) / gcd(x, y)`.\n\nFirst, let's handle the special case where `a = b`.\nIf `a = b`, then `lcm(a+k, b+k) = lcm(a+k, a+k) = a+k`. To minimize `a+k`, we should choose the smallest possible non-negative `k`, which is `k=0`. In this case, `lcm(a, a) = a`. So, if `a=b`, the answer is `0`.\n\nNow, assume `a != b`.\nLet `g = gcd(a+k, b+k)`.\nSince `g` divides both `a+k` and `b+k`, it must also divide their difference: `(b+k) - (a+k) = b - a`.\nLet `diff = abs(b - a)`. Thus, `g` must be a divisor of `diff`.\n\nThis observation is key: we can iterate through all possible values of `g`, which are the divisors of `diff`. For each divisor `g`, we want to find a `k` such that `gcd(a+k, b+k)` is at least `g`, and then calculate the `lcm`. To minimize `lcm(x,y)`, we want `x` and `y` to be small and `gcd(x,y)` to be large.\n\nFor a chosen divisor `g` of `diff`:\nWe need `a+k` to be a multiple of `g`. The smallest non-negative `k` that satisfies this condition is `k_g = (g - (a % g)) % g`.\nLet's verify this formula:\n- If `a` is already a multiple of `g` (i.e., `a % g == 0`), then `k_g = (g - 0) % g = 0`. This means `a+0` is a multiple of `g`.\n- If `a` is not a multiple of `g` (i.e., `a % g != 0`), then `k_g = g - (a % g)`. This `k_g` makes `a+k_g` the smallest multiple of `g` that is greater than or equal to `a`.\nWith this `k_g`, `a+k_g` is a multiple of `g`.\nSince `diff` is a multiple of `g` (by definition of `g` being a divisor of `diff`), and `b+k_g = (a+k_g) + diff`, it follows that `b+k_g` will also be a multiple of `g`.\nSo, for each divisor `g` of `diff`, we can find a `k_g` such that both `a+k_g` and `b+k_g` are multiples of `g`.\n\nWe will iterate through all divisors `g` of `diff`:\n1. Calculate `k_g = (g - (a % g)) % g`.\n2. Calculate `val_a = a + k_g` and `val_b = b + k_g`.\n3. Calculate `current_lcm = (val_a * val_b) // math.gcd(val_a, val_b)`.\n4. Keep track of the minimum `current_lcm` found so far and the corresponding `k_g`. If multiple `k_g` values yield the same minimum `lcm`, we choose the smallest `k_g`.\n\n**Algorithm Steps:**\n\n1.  Read integers `a` and `b`.\n2.  If `a == b`, print `0` and exit.\n3.  Calculate `diff = abs(b - a)`.\n4.  Find all divisors of `diff`. We can do this by iterating `i` from `1` up to `sqrt(diff)`. If `i` divides `diff`, then both `i` and `diff // i` are divisors. Store them in a set to handle duplicates automatically.\n5.  Initialize `min_lcm = float('inf')` (a very large number) and `best_k = 0`. `best_k` will be updated as we find better `k` values. `k=0` is a valid candidate for `k_g` (when `g=1` and `a%1==0`), so it's a reasonable initial value for `best_k` or it will be correctly set by the first `g` processed.\n6.  For each divisor `g` in the set of divisors:\n    a.  Calculate `k_g = (g - (a % g)) % g`.\n    b.  Calculate `val_a = a + k_g` and `val_b = b + k_g`.\n    c.  Calculate `current_lcm = (val_a * val_b) // math.gcd(val_a, val_b)`.\n    d.  If `current_lcm < min_lcm`:\n        Set `min_lcm = current_lcm`.\n        Set `best_k = k_g`.\n    e.  Else if `current_lcm == min_lcm`:\n        Set `best_k = min(best_k, k_g)` (to ensure we pick the smallest `k`).\n7.  Print `best_k`.\n\n**Example: a=6, b=10**\n\n1.  `a=6, b=10`. `a != b`.\n2.  `diff = abs(10 - 6) = 4`.\n3.  Divisors of `4`: `1, 2, 4`.\n4.  Initialize `min_lcm = inf`, `best_k = 0`.\n\n    *   **g = 1**:\n        `k_1 = (1 - (6 % 1)) % 1 = 0`.\n        `val_a = 6+0 = 6`, `val_b = 10+0 = 10`.\n        `current_lcm = (6 * 10) // gcd(6, 10) = 60 // 2 = 30`.\n        `min_lcm = 30`, `best_k = 0`.\n\n    *   **g = 2**:\n        `k_2 = (2 - (6 % 2)) % 2 = 0`.\n        `val_a = 6+0 = 6`, `val_b = 10+0 = 10`.\n        `current_lcm = (6 * 10) // gcd(6, 10) = 30`.\n        `current_lcm == min_lcm`, so `best_k = min(0, 0) = 0`.\n\n    *   **g = 4**:\n        `k_4 = (4 - (6 % 4)) % 4 = (4 - 2) % 4 = 2`.\n        `val_a = 6+2 = 8`, `val_b = 10+2 = 12`.\n        `current_lcm = (8 * 12) // gcd(8, 12) = 96 // 4 = 24`.\n        `current_lcm < min_lcm`, so `min_lcm = 24`, `best_k = 2`.\n\n5.  After checking all divisors, the final `best_k` is `2`.\n\n**Complexity:**\n-   Finding divisors: `O(sqrt(diff))`. `diff` can be up to `10^9`, so `sqrt(10^9)` is about `31622`. This is efficient.\n-   Number of divisors: For `N <= 10^9`, the maximum number of divisors is 576 (for `735134400`).\n-   For each divisor: A few arithmetic operations and `math.gcd`. `math.gcd` is efficient (Euclidean algorithm).\nOverall complexity is dominated by finding divisors, which is fast enough.\nThe values `a+k` and `b+k` can be up to `~2 * 10^9`. Their product can be up to `~4 * 10^{18}`, which fits within standard 64-bit integer types and is handled automatically by Python's arbitrary-precision integers.\n\n```python\nimport math\n\ndef solve():\n    a, b = map(int, input().split())\n\n    # Special case: if a and b are equal, lcm(a+k, b+k) = a+k.\n    # To minimize this, choose the smallest non-negative k, which is 0.\n    if a == b:\n        print(0)\n        return\n\n    # Calculate the absolute difference between a and b.\n    # The gcd(a+k, b+k) must be a divisor of this difference.\n    diff = abs(b - a)\n\n    # Find all divisors of 'diff'.\n    # We iterate up to the square root of 'diff'. If 'i' divides 'diff',\n    # then 'i' and 'diff // i' are both divisors.\n    divisors = set()\n    for i in range(1, int(math.sqrt(diff)) + 1):\n        if diff % i == 0:\n            divisors.add(i)\n            divisors.add(diff // i)\n    \n    # Initialize minimum LCM found so far to infinity and the best k to 0.\n    # k=0 is always a candidate (corresponding to g=1), so it's a safe initial value for best_k.\n    min_lcm = float('inf')\n    best_k = 0 \n\n    # Iterate through each divisor 'g' of 'diff'.\n    # For each 'g', we find the smallest non-negative 'k_g' such that (a + k_g) is a multiple of 'g'.\n    # Since 'diff' is a multiple of 'g', (b + k_g) will also be a multiple of 'g'.\n    for g in divisors:\n        # Calculate k_g: the smallest non-negative k such that (a + k) % g == 0.\n        # This can be derived as k = (-a) % g. In Python, for positive a and g,\n        # (g - (a % g)) % g correctly yields this value.\n        k_g = (g - (a % g)) % g\n        \n        val_a = a + k_g\n        val_b = b + k_g\n        \n        # Calculate the LCM for the current a+k and b+k.\n        # lcm(x, y) = (x * y) // gcd(x, y)\n        current_lcm = (val_a * val_b) // math.gcd(val_a, val_b)\n        \n        # Update min_lcm and best_k if a smaller LCM is found.\n        if current_lcm < min_lcm:\n            min_lcm = current_lcm\n            best_k = k_g\n        # If the current LCM is equal to the minimum LCM, choose the smaller k.\n        elif current_lcm == min_lcm:\n            best_k = min(best_k, k_g)\n\n    print(best_k)\n\n# Call the solve function to execute the program.\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef solve():\n    a, b = map(int, input().split())\n\n    # Special case: if a and b are equal, lcm(a+k, b+k) = a+k.\n    # To minimize this, choose the smallest non-negative k, which is 0.\n    if a == b:\n        print(0)\n        return\n\n    # Calculate the absolute difference between a and b.\n    # The gcd(a+k, b+k) must be a divisor of this difference.\n    diff = abs(b - a)\n\n    # Find all divisors of 'diff'.\n    # We iterate up to the square root of 'diff'. If 'i' divides 'diff',\n    # then 'i' and 'diff // i' are both divisors.\n    divisors = set()\n    for i in range(1, int(math.sqrt(diff)) + 1):\n        if diff % i == 0:\n            divisors.add(i)\n            divisors.add(diff // i)\n    \n    # Initialize minimum LCM found so far to infinity and the best k to 0.\n    # k=0 is always a candidate (corresponding to g=1), so it's a safe initial value for best_k.\n    min_lcm = float('inf')\n    best_k = 0 \n\n    # Iterate through each divisor 'g' of 'diff'.\n    # For each 'g', we find the smallest non-negative 'k_g' such that (a + k_g) is a multiple of 'g'.\n    # Since 'diff' is a multiple of 'g', (b + k_g) will also be a multiple of 'g'.\n    for g in divisors:\n        # Calculate k_g: the smallest non-negative k such that (a + k) % g == 0.\n        # This can be derived as k = (-a) % g. In Python, for positive a and g,\n        # (g - (a % g)) % g correctly yields this value.\n        k_g = (g - (a % g)) % g\n        \n        val_a = a + k_g\n        val_b = b + k_g\n        \n        # Calculate the LCM for the current a+k and b+k.\n        # lcm(x, y) = (x * y) // gcd(x, y)\n        current_lcm = (val_a * val_b) // math.gcd(val_a, val_b)\n        \n        # Update min_lcm and best_k if a smaller LCM is found.\n        if current_lcm < min_lcm:\n            min_lcm = current_lcm\n            best_k = k_g\n        # If the current LCM is equal to the minimum LCM, choose the smaller k.\n        elif current_lcm == min_lcm:\n            best_k = min(best_k, k_g)\n\n    print(best_k)\n\n# Call the solve function to execute the program.\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 421,
        "completion_token_count": 2700,
        "thoughts_token_count": 7862
    }
}