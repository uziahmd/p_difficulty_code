{
    "start": 1758284866.6923554,
    "end": 1758284896.5067215,
    "start-formatted": "2025-09-19 21:27 KST",
    "end-formatted": "2025-09-19 21:28 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "**Thinking Through the LCM Minimization Problem**\n\nOkay, so I'm tackling this problem where I need to minimize the least common multiple (LCM) of `a+k` and `b+k`. The goal is to find the smallest non-negative integer `k` that achieves this.\n\nMy first thought is to transform the problem. Let's make things a bit simpler and define `x = a+k` and `y = b+k`.  Now, the problem boils down to minimizing `lcm(x, y)`. I know that the LCM is related to the greatest common divisor (GCD) through the formula: `lcm(x, y) = (x * y) / gcd(x, y)`.  The key here seems to be understanding how `gcd(x, y)` behaves.\n\nLet `g = gcd(x, y)`. I can see that since `x = a+k` and `y = b+k`, then `y - x = b - a`. Since `g` divides both `x` and `y`, it *must* also divide their difference, `y - x`. This observation is crucial. So `g` must be a divisor of `D = |b - a|`.\n\nNow, I consider the edge case where `a = b`. In that situation, `D` is zero, and minimizing the LCM is straightforward.  `gcd(a+k, b+k)` will just be `a+k`. To minimize the LCM, I'll set `k` to zero because it makes `a+k` equal to `a`.\n\nIf `a` is not equal to `b`, I know `g` must be a divisor of `D`. This means I should iterate through all possible divisors of `D`. For each possible value of `g`, I need to find the smallest `k >= 0` such that `gcd(a+k, b+k)` is equal to that chosen `g`.\n\nIf I have a chosen `g`, then it must be a divisor of `a+k` *and* `b+k`. Since `g` divides `b-a` and I have that `g` divides `a+k`, then `g` will *also* divide `b+k`. This simplifies my condition down to:  `g` must divide `a+k`.  So, `a+k` must be a multiple of `g`. That means I have an equation `a+k = m * g` where `m` is an integer.\n\nI want the *smallest* non-negative `k`. So,  `k = m * g - a`. This means I need to find the smallest `m` for which `m * g` is greater than or equal to `a`.  This is straightforward. `m` will be `ceil(a / g)`.  If `a` is already a multiple of `g` (i.e. `a % g == 0`), then the minimum value of `k` is 0. If it's not a multiple, I need to find the next smallest multiple, which translates to `k = (g - (a % g)) % g`. I think that's it!\n",
    "response": "The problem asks us to find the smallest non-negative integer `k` such that `lcm(a+k, b+k)` is minimized. If there are multiple `k` values yielding the same minimum LCM, we choose the smallest `k`.\n\nLet `x = a+k` and `y = b+k`. We want to minimize `lcm(x, y)`.\nWe know that `lcm(x, y) = (x * y) / gcd(x, y)`.\n\nLet `g = gcd(x, y)`. Since `g` divides both `x` and `y`, it must also divide their difference `y - x`.\n`y - x = (b+k) - (a+k) = b - a`.\nSo, `g` must be a divisor of `|b - a|`.\n\nLet `D = |b - a|`.\n\n**Case 1: `a = b`**\nIf `a = b`, then `D = 0`. In this case, `x = a+k` and `y = a+k`.\n`lcm(a+k, a+k) = a+k`.\nTo minimize `a+k`, we should choose the smallest possible non-negative `k`, which is `k=0`.\nThe minimum LCM is `a`.\n\n**Case 2: `a != b`**\nIf `a != b`, then `D > 0`. `g` must be a positive divisor of `D`.\nWe can iterate through all divisors `g` of `D`. For each `g`, we want to find the smallest `k \\ge 0` such that `gcd(a+k, b+k)` is `g`.\n\nThe conditions for `gcd(a+k, b+k) = g` are:\n1. `g` must divide `a+k`.\n2. `g` must divide `b+k`.\n3. `gcd((a+k)/g, (b+k)/g)` must be `1`.\n\nSince `g` divides `D = |b-a|`, if `g` divides `a+k`, it will automatically divide `b+k = (a+k) + (b-a)` (or `b+k = (a+k) - (a-b)`). So condition 2 is implied by condition 1 and `g | D`.\nThus, for a given `g`, we need `a+k` to be a multiple of `g`.\nThe smallest `k \\ge 0` such that `a+k` is a multiple of `g` can be found as follows:\nIf `a % g == 0`, then `a` is already a multiple of `g`. The smallest `k` is `0`.\nIf `a % g != 0`, then `a+k` must be the next multiple of `g` after `a`. This means `a+k = a - (a % g) + g`. So `k = g - (a % g)`.\nThis can be compactly written as `k = (g - (a % g)) % g`.\n\nFor each divisor `g` of `D`:\n1. Calculate `k = (g - (a % g)) % g`.\n2. Calculate `current_lcm = lcm(a+k, b+k) = ((a+k) * (b+k)) // g`. (Note: `gcd(a+k, b+k)` is guaranteed to be a multiple of `g`. It might be `g` or a multiple of `g`. The problem asks to minimize `lcm`, so we don't strictly need `gcd((a+k)/g, (b+k)/g) == 1`. We just need `a+k` to be a multiple of `g` and then calculate `lcm` for that `k`.)\n3. Keep track of the minimum `lcm` found so far and the corresponding smallest `k`.\n\n**Algorithm:**\n1. Initialize `min_lcm` to infinity and `ans_k` to 0.\n2. If `a == b`, print `0` and exit.\n3. Calculate `D = abs(b - a)`.\n4. Find all divisors of `D`. Iterate `i` from `1` up to `sqrt(D)`.\n   If `i` divides `D`:\n     `g = i` is a divisor.\n     `g_prime = D // i` is also a divisor.\n     Process both `g` and `g_prime`.\n     For each divisor `current_g` (which is `g` or `g_prime`):\n       Calculate `k = (current_g - (a % current_g)) % current_g`.\n       Calculate `val_a = a + k`.\n       Calculate `val_b = b + k`.\n       Calculate `current_lcm = (val_a // current_g) * val_b`. (This is `(val_a * val_b) / current_g` because `current_g` divides `val_a`, so `val_a // current_g` is an integer, avoiding potential floating point issues or large intermediate products before division. Also, `val_a` and `val_b` are `a+k` and `b+k`. `gcd(a+k, b+k)` is guaranteed to be a multiple of `current_g`. So `lcm(a+k, b+k) = (a+k)(b+k)/gcd(a+k,b+k)`. If we use `current_g` in place of `gcd(a+k,b+k)`, we are calculating `(a+k)(b+k)/current_g`. This value might not be the true LCM, but it is a lower bound on the LCM if `current_g` were the actual GCD. However, the problem asks to minimize `lcm(a+k, b+k)`, not `(a+k)(b+k)/g`. So we should calculate the true LCM for each `k`.)\n       A more robust way to calculate `lcm(val_a, val_b)`:\n       `common_divisor = math.gcd(val_a, val_b)`\n       `current_lcm = (val_a // common_divisor) * val_b`\n       \n       Compare `current_lcm` with `min_lcm`:\n       If `current_lcm < min_lcm`:\n         `min_lcm = current_lcm`\n         `ans_k = k`\n       Else if `current_lcm == min_lcm`:\n         `ans_k = min(ans_k, k)` (choose smallest `k`)\n5. Print `ans_k`.\n\n**Example Walkthrough (6, 10):**\n`a = 6, b = 10`. `D = |10 - 6| = 4`.\nDivisors of 4 are 1, 2, 4.\n\n- **`g = 1`**:\n  `k = (1 - (6 % 1)) % 1 = (1 - 0) % 1 = 1 % 1 = 0`.\n  `val_a = 6+0 = 6`, `val_b = 10+0 = 10`.\n  `lcm(6, 10) = (6 * 10) / gcd(6, 10) = 60 / 2 = 30`.\n  `min_lcm = 30`, `ans_k = 0`.\n\n- **`g = 2`**:\n  `k = (2 - (6 % 2)) % 2 = (2 - 0) % 2 = 2 % 2 = 0`.\n  `val_a = 6+0 = 6`, `val_b = 10+0 = 10`.\n  `lcm(6, 10) = 30`.\n  `current_lcm` (30) is not less than `min_lcm` (30). `ans_k = min(0, 0) = 0`.\n\n  Wait, the example says `k=2` for `(6, 10)`. My current logic for `k` is wrong.\n  The `k` calculation `k = (g - (a % g)) % g` finds the smallest `k` such that `a+k` is a multiple of `g`.\n  This is correct. However, `gcd(a+k, b+k)` doesn't have to be `g`. It just has to be a multiple of `g`.\n  The core idea is that `gcd(a+k, b+k)` MUST be a divisor of `D`. So we iterate through all possible values of `actual_gcd = g_val` which are divisors of `D`.\n  For each `g_val`, we want to find the smallest `k \\ge 0` such that `g_val` divides `a+k`.\n  This `k` is `(g_val - (a % g_val)) % g_val`.\n  Let's re-run with this corrected understanding for `g_val`:\n\n- **`g_val = 1`**:\n  `k = (1 - (6 % 1)) % 1 = 0`.\n  `val_a = 6+0 = 6`, `val_b = 10+0 = 10`.\n  `lcm(6, 10) = 30`.\n  `min_lcm = 30`, `ans_k = 0`.\n\n- **`g_val = 2`**:\n  `k = (2 - (6 % 2)) % 2 = 0`.\n  `val_a = 6+0 = 6`, `val_b = 10+0 = 10`.\n  `lcm(6, 10) = 30`.\n  `ans_k = min(0, 0) = 0`. (No change)\n\n- **`g_val = 4`**:\n  `k = (4 - (6 % 4)) % 4 = (4 - 2) % 4 = 2 % 4 = 2`.\n  `val_a = 6+2 = 8`, `val_b = 10+2 = 12`.\n  `lcm(8, 12) = (8 * 12) / gcd(8, 12) = 96 / 4 = 24`.\n  `current_lcm` (24) is less than `min_lcm` (30).\n  `min_lcm = 24`, `ans_k = 2`.\n\nAfter checking all divisors, `ans_k = 2`. This matches the example!\n\nThe logic seems correct now. The key is that `gcd(a+k, b+k)` must be a divisor of `|b-a|`. We iterate through all possible values `g_val` for this `gcd`. For each `g_val`, we find the smallest `k` such that `a+k` is a multiple of `g_val`. Then we calculate the `lcm(a+k, b+k)` for *that specific* `k` and `g_val` and update our minimum.\n\n**Constraints:**\n`1 <= a, b <= 10^9`.\n`D = |b-a|` can be up to `10^9`.\nNumber of divisors for `N <= 10^9` is at most around 1344 (for `735134400`).\nFor each divisor, we do a few arithmetic operations and `gcd`. `math.gcd` is efficient.\nThe overall complexity will be `O(sqrt(D))` for finding divisors, and `O(log(max(a,b)))` for `gcd` for each divisor. This is efficient enough.\n\n```python\nimport math\n\ndef solve():\n    a, b = map(int, input().split())\n\n    if a == b:\n        print(0)\n        return\n\n    diff = abs(b - a)\n    \n    min_lcm = float('inf')\n    ans_k = 0\n\n    # Find all divisors of diff\n    divisors = set()\n    for i in range(1, int(math.sqrt(diff)) + 1):\n        if diff % i == 0:\n            divisors.add(i)\n            divisors.add(diff // i)\n    \n    # Iterate through each divisor 'g_val' which could be gcd(a+k, b+k)\n    for g_val in divisors:\n        # We need a+k to be a multiple of g_val.\n        # k = (g_val - (a % g_val)) % g_val gives the smallest non-negative k\n        # such that a+k is a multiple of g_val.\n        \n        k = (g_val - (a % g_val)) % g_val\n        \n        val_a = a + k\n        val_b = b + k\n        \n        # Calculate lcm(val_a, val_b)\n        # lcm(x, y) = (x * y) / gcd(x, y)\n        current_gcd = math.gcd(val_a, val_b)\n        current_lcm = (val_a // current_gcd) * val_b # (val_a * val_b) // current_gcd to avoid overflow if val_a*val_b is too large, but val_a//current_gcd is safer and equivalent.\n\n        if current_lcm < min_lcm:\n            min_lcm = current_lcm\n            ans_k = k\n        elif current_lcm == min_lcm:\n            ans_k = min(ans_k, k) # Choose the smallest k for tie-breaking\n\n    print(ans_k)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef solve():\n    a, b = map(int, input().split())\n\n    if a == b:\n        print(0)\n        return\n\n    diff = abs(b - a)\n    \n    min_lcm = float('inf')\n    ans_k = 0\n\n    # Find all divisors of diff\n    divisors = set()\n    for i in range(1, int(math.sqrt(diff)) + 1):\n        if diff % i == 0:\n            divisors.add(i)\n            divisors.add(diff // i)\n    \n    # Iterate through each divisor 'g_val' which could be gcd(a+k, b+k)\n    for g_val in divisors:\n        # We need a+k to be a multiple of g_val.\n        # k = (g_val - (a % g_val)) % g_val gives the smallest non-negative k\n        # such that a+k is a multiple of g_val.\n        \n        k = (g_val - (a % g_val)) % g_val\n        \n        val_a = a + k\n        val_b = b + k\n        \n        # Calculate lcm(val_a, val_b)\n        # lcm(x, y) = (x * y) / gcd(x, y)\n        current_gcd = math.gcd(val_a, val_b)\n        current_lcm = (val_a // current_gcd) * val_b # (val_a * val_b) // current_gcd to avoid overflow if val_a*val_b is too large, but val_a//current_gcd is safer and equivalent.\n\n        if current_lcm < min_lcm:\n            min_lcm = current_lcm\n            ans_k = k\n        elif current_lcm == min_lcm:\n            ans_k = min(ans_k, k) # Choose the smallest k for tie-breaking\n\n    print(ans_k)\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 422,
        "completion_token_count": 3205,
        "thoughts_token_count": 810
    }
}