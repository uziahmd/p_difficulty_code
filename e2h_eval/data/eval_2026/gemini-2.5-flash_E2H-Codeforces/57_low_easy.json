{
    "start": 1758284878.164316,
    "end": 1758284945.4256794,
    "start-formatted": "2025-09-19 21:27 KST",
    "end-formatted": "2025-09-19 21:29 KST",
    "gpu": 2,
    "pid": 57,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Olympiad\n\nA boy named Vasya has taken part in an Olympiad. His teacher knows that in total Vasya got at least x points for both tours of the Olympiad. The teacher has the results of the first and the second tour of the Olympiad but the problem is, the results have only points, no names. The teacher has to know Vasya's chances.Help Vasya's teacher, find two numbers — the best and the worst place Vasya could have won. Note that the total results' table sorts the participants by the sum of points for both tours (the first place has the participant who has got the most points). If two or more participants have got the same number of points, it's up to the jury to assign places to them according to their choice. It is guaranteed that each participant of the Olympiad participated in both tours of the Olympiad.\n\n## Input\nThe first line contains two space-separated integers n, x (1 ≤ n ≤ 105; 0 ≤ x ≤ 2·105) — the number of Olympiad participants and the minimum number of points Vasya earned.The second line contains n space-separated integers: a1, a2, ..., an (0 ≤ ai ≤ 105) — the participants' points in the first tour.The third line contains n space-separated integers: b1, b2, ..., bn (0 ≤ bi ≤ 105) — the participants' points in the second tour.The participants' points are given in the arbitrary order. It is guaranteed that Vasya was present in the Olympiad — there are two integers i, j (1 ≤ i, j ≤ n) such, that ai + bj ≥ x.\n\n## Output\nPrint two space-separated integers — the best and the worst place Vasya could have got on the Olympiad.\n\n## Example\n### Input\n['5 2\\n1 1 1 1 1\\n1 1 1 1 1', '6 7\\n4 3 5 6 4 4\\n8 6 0 4 3 4']\n\n### Output\n['1 5', '1 5']\n\n## Note\nIn the first text sample all 5 participants earn 2 points each in any case. Depending on the jury's decision, Vasya can get the first (the best) as well as the last (the worst) fifth place.In the second test sample in the best case scenario Vasya wins again: he can win 12 points and become the absolute winner if the total results' table looks like that — {4:8, 6:4, 3:6, 4:4, 4:3, 5:0}.In this table all participants are sorted by decreasing points and we can see how much a participant earned in the first and in the second tour.In the worst case scenario Vasya can get the fifth place if the table looks like that — {4:8, 4:6, 6:4, 5:4, 4:3, 3:0}, and he earned 4 and 3 points in the first and second tours, correspondingly.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "**Maximizing and Minimizing Vasya's Olympiad Rank**\n\nOkay, so I need to figure out Vasya's best and worst possible ranks in this Olympiad. I've got the total number of participants, `n`, Vasya's minimum total points, `x`, and the scores from the two tours, `a` and `b`. The key is that Vasya's total score is at least `x`, but I don't know his individual scores from each tour.  I need to find the best-case and worst-case scenarios, given the flexibility the jury has with tie-breaking.\n\nMy immediate thought is, since the final ranking is based on total points and the jury can arbitrarily assign ranks to tied participants, I need to focus on maximizing and minimizing Vasya's total score relative to everyone else's.  Sorting the scores seems like a good starting point.  `a` and `b` contain *all* the scores from both tours, so by sorting them, I can analyze how Vasya might fit into the overall distribution.\n\n**Best Rank Strategy:**\n\nTo achieve the best possible rank for Vasya, I need to strategically assign the highest possible total score. Since `a_i + b_j >= x`, I need to find score combinations in `a` and `b` that yield the largest total, while still satisfying this condition. I can make the assumption that Vasya has the maximum possible total score given the constraint.\n",
    "response": "The problem asks us to find the best and worst possible ranks for Vasya in an Olympiad, given `n` participants, a minimum total score `x` Vasya achieved, and two lists of `n` scores for the first and second tours, respectively. The scores in the lists are not associated with specific participants.\n\nThe ranking rules are:\n1. Participants are sorted by the sum of points for both tours in decreasing order.\n2. If multiple participants have the same total points, the jury can assign places arbitrarily. This means if `k` people have the highest score `S`, they can occupy ranks `1` to `k`.\n   - To find the best rank, we assume Vasya gets rank `P + 1` if `P` people have strictly more points than him, and he is among `Q` people (including himself) who have his score.\n   - To find the worst rank, we assume Vasya gets rank `P + Q` under the same conditions.\n\nThe core challenge is that we don't know which `a_i` corresponds to which `b_j`. We only know that Vasya's scores `a_V` and `b_V` must be from the given lists, and `a_V + b_V >= x`.\n\nLet's sort both score lists: `a` in ascending order and `b` in ascending order. This helps in efficiently finding pairs.\n\n### Finding the Best Possible Rank for Vasya\n\nTo achieve the best rank, Vasya wants to maximize his total score, and minimize the number of people who score higher than or equal to him.\nWe can assume Vasya gets the highest possible score. Since `a_i + b_j >= x` must hold for Vasya's scores, the optimal strategy for Vasya to maximize his score is to take the largest available `a_i` and the largest available `b_j`. Let's say he takes `a[n-1]` and `b[n-1]`. His score would be `a[n-1] + b[n-1]`. This score is guaranteed to be at least `x` (as shown in the example reasoning for `x_max`).\n\nLet `a_max = a[n-1]` and `b_max = b[n-1]`. Vasya's score would be `S_V = a_max + b_max`.\nNow, we need to consider the other `n-1` participants. To make Vasya's rank as good as possible, we want to minimize the scores of other participants. We also need to pair up the remaining `n-1` scores from `a` and `n-1` scores from `b`. The best way to do this is to pair the smallest `a_i` with the smallest `b_j`, the second smallest `a_i` with the second smallest `b_j`, and so on. This creates `n-1` pairs `(a[0], b[0]), (a[1], b[1]), ..., (a[n-2], b[n-2])`.\nThe scores for these `n-1` participants would be `a[k] + b[k]` for `k` from `0` to `n-2`.\nVasya's best rank would be `1` because he has the highest possible score `a_max + b_max`, and no one else can achieve this score using the remaining points. Even if someone else could, the jury can assign him rank 1.\n\nThus, the best rank for Vasya is always `1`.\n\n### Finding the Worst Possible Rank for Vasya\n\nTo find the worst rank, Vasya wants to minimize his total score *while still satisfying `a_V + b_V >= x`*, and maximize the number of people who score strictly higher than him, or equal to him.\n\nLet's iterate through all possible scores `a_i` that Vasya could have gotten from the first tour. For a chosen `a_i`, Vasya must have gotten some `b_j` such that `a_i + b_j >= x`. To minimize his score, he should choose the smallest `b_j` that satisfies `b_j >= x - a_i`.\nThis means for each `a_i`, Vasya's minimum possible score is `a_i + b_k`, where `b_k` is the smallest element in `b` such that `b_k >= x - a_i`. We can find `b_k` efficiently using binary search (specifically, `bisect_left` in Python) on the sorted `b` array. If no such `b_k` exists, then `a_i` cannot be Vasya's score from the first tour.\n\nLet `S_V` be Vasya's total score. We want to find the maximum number of participants who can score `S_P >= S_V` (where `S_P` is another participant's score).\nTo maximize this count, we want to make Vasya's score `S_V` as low as possible, subject to `S_V >= x`.\nThe problem statement guarantees that \"there are two integers `i, j` (1 <= i, j <= n) such, that `a_i + b_j >= x`\". This means there's always a valid way for Vasya to achieve at least `x` points.\n\nLet's try to match participants to maximize their scores. We have `n` scores in `a` and `n` scores in `b`.\nSort `a` in ascending order and `b` in ascending order.\nTo maximize the number of people who score higher than Vasya, we should pair the largest `a_i` with the largest `b_j`, the second largest with the second largest, and so on. This is not quite right because Vasya's scores are also from these lists.\n\nLet's consider the `n` pairs `(a_i, b_j)` that could be formed. There are `n!` ways to pair them up. We need to find the pairing that results in the worst rank for Vasya.\n\nThe strategy to maximize the number of people who score `S_P >= S_V` is as follows:\n1. Sort `a` in ascending order.\n2. Sort `b` in ascending order.\n\nNow, for each participant `k` (from `0` to `n-1`), we can try to pair `a[k]` with `b[n-1-k]`. This forms `n` pairs `(a[0], b[n-1]), (a[1], b[n-2]), ..., (a[n-1], b[0])`.\nThe scores for these `n` pairs would be `a[0]+b[n-1]`, `a[1]+b[n-2]`, ..., `a[n-1]+b[0]`.\nThis pairing strategy (smallest `a` with largest `b`, etc.) tends to make the sums more \"even\" or \"spread out\" rather than creating very high and very low scores. This is a common strategy in problems where you want to maximize the sum of minimums or minimize the sum of maximums.\n\nLet's consider the `n` possible total scores that Vasya could have achieved if he picked `a[k]` and `b[n-1-k]` for some `k`.\nFor each `k` from `0` to `n-1`:\n   Let `Vasya_a = a[k]`.\n   Let `Vasya_b = b[n-1-k]`.\n   If `Vasya_a + Vasya_b < x`, this pairing is not valid for Vasya. We need to ensure Vasya's score is at least `x`.\n\nThis is a matching problem. We want to find a permutation `p` of `(0, ..., n-1)` such that if participant `i` gets `a[i]` and `b[p[i]]`, Vasya's rank is maximized.\nThis is equivalent to finding a permutation `p` such that:\n1. One participant, say `k`, has `a[k] + b[p[k]] >= x`. This is Vasya.\n2. The number of participants `j` such that `a[j] + b[p[j]] >= a[k] + b[p[k]]` is maximized.\n\nLet's fix Vasya's scores `(a_V, b_V)` such that `a_V + b_V >= x`.\nTo maximize his rank, we want to maximize the number of participants `P` whose scores `S_P` are `S_P >= S_V`.\nThis means we should try to make `S_V` as small as possible (but still `>= x`), and make other participants' scores as large as possible.\n\nConsider the sorted lists `a` and `b`.\nWe want to find a pairing `(a_i, b_j)` for Vasya such that `a_i + b_j >= x`.\nFor the remaining `n-1` participants, we pair up the remaining `n-1` scores from `a` and `n-1` scores from `b` to maximize their scores.\nThis is exactly the scenario that the \"worst case\" example illustrates.\nIn the example: `a = [4, 3, 5, 6, 4, 4]`, `b = [8, 6, 0, 4, 3, 4]`, `n=6`, `x=7`.\nSorted `a`: `[3, 4, 4, 4, 5, 6]`\nSorted `b`: `[0, 3, 4, 4, 6, 8]`\n\nThe example output's worst case table is `{4:8, 4:6, 6:4, 5:4, 4:3, 3:0}`.\nLet's analyze this pairing:\nScores:\n`4+8 = 12`\n`4+6 = 10`\n`6+4 = 10`\n`5+4 = 9`\n`4+3 = 7` (Vasya's score)\n`3+0 = 3`\n\nVasya's score is `7`.\nScores `>= 7`: `12, 10, 10, 9, 7`. There are 5 such scores.\nVasya's rank is 5.\nThis pairing uses `a = [3,4,4,4,5,6]` and `b = [0,3,4,4,6,8]`.\nThe pairs are:\n`(4,8)` - uses `a[3]` and `b[5]`\n`(4,6)` - uses `a[2]` and `b[4]`\n`(6,4)` - uses `a[5]` and `b[3]`\n`(5,4)` - uses `a[4]` and `b[2]`\n`(4,3)` - uses `a[1]` and `b[1]` (Vasya)\n`(3,0)` - uses `a[0]` and `b[0]`\n\nNotice that this pairing is formed by taking `a` and `b` sorted, and then effectively picking `a[i]` and `b[j]` for Vasya, and then pairing the remaining `n-1` `a`s with the remaining `n-1` `b`s.\nThe specific pairing in the example for `n=6`:\n`a_sorted = [3, 4, 4, 4, 5, 6]`\n`b_sorted = [0, 3, 4, 4, 6, 8]`\nVasya gets `a[1]=4` and `b[1]=3`, total `7`.\nThe remaining `a` values are `[3, 4, 4, 5, 6]` (indices `0,2,3,4,5`).\nThe remaining `b` values are `[0, 4, 4, 6, 8]` (indices `0,2,3,4,5`).\nTo maximize the number of people scoring `>=7`, we want to maximize the scores of the remaining people.\nThis is achieved by pairing the largest remaining `a` with largest remaining `b`, etc.\nSo, we can use a two-pointer approach or similar.\n\nLet's maintain two pointers, `ptr_a` for `a_sorted` and `ptr_b` for `b_sorted`.\n`ptr_a` starts at `0`, `ptr_b` starts at `n-1`.\nWe want to find the number of pairs `(a[i], b[j])` such that `a[i] + b[j] >= x`.\nThis is a standard problem: count pairs `(a_i, b_j)` such that `a_i + b_j >= x`.\nSort `a` (ascending) and `b` (ascending).\nInitialize `count = 0`.\nInitialize `ptr_a = 0` (smallest `a`), `ptr_b = n-1` (largest `b`).\nWhile `ptr_a < n` and `ptr_b >= 0`:\n  If `a[ptr_a] + b[ptr_b] >= x`:\n    This `a[ptr_a]` can be paired with `b[ptr_b]` to form a score `>=x`.\n    This pairing is \"strong\" enough. We count it as one such pair.\n    To maximize the number of such pairs, we use `a[ptr_a]` (the smallest remaining `a`) with `b[ptr_b]` (the largest remaining `b`).\n    Increment `count`.\n    Move `ptr_a` forward (`ptr_a += 1`).\n    Move `ptr_b` backward (`ptr_b -= 1`).\n  Else (`a[ptr_a] + b[ptr_b] < x`):\n    This `a[ptr_a]` is too small to form a sum `>=x` even with the largest available `b[ptr_b]`.\n    So, `a[ptr_a]` cannot form a sum `>=x` with any of `b[0...ptr_b]`.\n    We must use `a[ptr_a]` with some `b_j` such that `a[ptr_a] + b_j < x`.\n    To maximize the number of pairs that *do* sum to `>=x`, we should discard `a[ptr_a]` from consideration for forming a high sum.\n    Move `ptr_a` forward (`ptr_a += 1`).\n\nThe `count` found by this two-pointer approach represents the maximum number of participants (including Vasya) who can achieve a total score of at least `x`.\nWhy?\nEach time `a[ptr_a] + b[ptr_b] >= x`, we form a pair. We use the smallest available `a` (`a[ptr_a]`) and the largest available `b` (`b[ptr_b]`). This pairing strategy is optimal for maximizing such pairs. If `a[ptr_a]` can form a sum `>=x` with `b[ptr_b]`, it means `a[ptr_a]` is \"strong\" enough. We pair it with `b[ptr_b]` to \"save\" other larger `a` values for potentially more pairs. If `a[ptr_a] + b[ptr_b] < x`, then `a[ptr_a]` cannot form a sum `>=x` with any `b_j` (since `b_j <= b[ptr_b]`). So `a[ptr_a]` must be paired with some `b_j` such that `a[ptr_a] + b_j < x`. This `a[ptr_a]` cannot contribute to a sum `>=x`. We discard it and look at `a[ptr_a+1]`.\n\nThe `count` obtained is the maximum number of participants who can achieve a score of at least `x`.\nIn the worst-case scenario, Vasya is one of these `count` participants, and the jury assigns him the last place among them. So, his worst rank would be `count`.\n\nLet's re-verify with the example:\n`a_sorted = [3, 4, 4, 4, 5, 6]`\n`b_sorted = [0, 3, 4, 4, 6, 8]`\n`x = 7`\n\n`ptr_a = 0`, `ptr_b = 5`, `count = 0`\n1. `a[0]=3`, `b[5]=8`. `3+8 = 11 >= 7`. `count = 1`. `ptr_a = 1`, `ptr_b = 4`.\n2. `a[1]=4`, `b[4]=6`. `4+6 = 10 >= 7`. `count = 2`. `ptr_a = 2`, `ptr_b = 3`.\n3. `a[2]=4`, `b[3]=4`. `4+4 = 8 >= 7`. `count = 3`. `ptr_a = 3`, `ptr_b = 2`.\n4. `a[3]=4`, `b[2]=4`. `4+4 = 8 >= 7`. `count = 4`. `ptr_a = 4`, `ptr_b = 1`.\n5. `a[4]=5`, `b[1]=3`. `5+3 = 8 >= 7`. `count = 5`. `ptr_a = 5`, `ptr_b = 0`.\n6. `a[5]=6`, `b[0]=0`. `6+0 = 6 < 7`. `ptr_a = 6`.\nLoop terminates because `ptr_a = 6` (not `< n`).\n\nThe `count` is `5`.\nThis matches the example's worst rank of `5`.\n\nSo, the best rank is `1`. The worst rank is the result of the two-pointer count.\n\n### Algorithm Summary:\n1. Read `n` and `x`.\n2. Read list `a` and sort it in ascending order.\n3. Read list `b` and sort it in ascending order.\n4. Calculate worst rank:\n   - Initialize `worst_rank = 0`.\n   - Initialize `ptr_a = 0` (for `a_sorted`).\n   - Initialize `ptr_b = n - 1` (for `b_sorted`).\n   - While `ptr_a < n` and `ptr_b >= 0`:\n     - If `a[ptr_a] + b[ptr_b] >= x`:\n       - Increment `worst_rank`.\n       - Increment `ptr_a`.\n       - Decrement `ptr_b`.\n     - Else (`a[ptr_a] + b[ptr_b] < x`):\n       - Increment `ptr_a`. (This `a[ptr_a]` cannot form a pair `>=x` with any remaining `b` values, so we discard it and move to the next `a`).\n5. Print `1` (for best rank) and `worst_rank`.\n\nThis approach is efficient: sorting takes `O(N log N)`, and the two-pointer scan takes `O(N)`. Total time complexity `O(N log N)`. Space complexity `O(N)` for storing sorted lists (or `O(1)` if sorting in-place and input lists can be modified).\n\nConstraints: `n <= 10^5`, `x <= 2 * 10^5`, `a_i, b_i <= 10^5`.\n`a_i + b_j` can be up to `2 * 10^5`. `x` is also in this range.\n`N log N` for `N=10^5` is fine. `10^5 * log(10^5) approx 10^5 * 17`, which is about `1.7 * 10^6` operations, well within typical time limits.\n\n```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    # Sort both arrays\n    a.sort()\n    b.sort()\n\n    # Best possible rank for Vasya is always 1\n    # Vasya can achieve the highest possible score by taking the largest a_i and largest b_j.\n    # No other participant can achieve a higher score using the remaining points.\n    # If multiple participants achieve the same top score, the jury can assign Vasya rank 1.\n    best_rank = 1\n\n    # Worst possible rank for Vasya\n    # This involves finding the maximum number of participants (including Vasya)\n    # who can achieve a total score of at least x.\n    # Vasya would then be assigned the last place among these participants.\n    \n    worst_rank = 0\n    ptr_a = 0\n    ptr_b = n - 1\n\n    while ptr_a < n and ptr_b >= 0:\n        if a[ptr_a] + b[ptr_b] >= x:\n            # This pair (a[ptr_a], b[ptr_b]) can form a sum >= x.\n            # We count this as one participant who met the criteria.\n            # To maximize such participants, we use the smallest available 'a'\n            # and the largest available 'b' to form a valid pair.\n            # This \"saves\" larger 'a' values and smaller 'b' values for other potential pairs.\n            worst_rank += 1\n            ptr_a += 1\n            ptr_b -= 1\n        else:\n            # a[ptr_a] is too small to form a sum >= x even with the largest available b[ptr_b].\n            # This means a[ptr_a] cannot form a sum >= x with any b_j (where j <= ptr_b).\n            # So, a[ptr_a] must be paired with some b_j such that a[ptr_a] + b_j < x.\n            # We effectively \"discard\" a[ptr_a] from forming a sum >= x and move to the next a.\n            ptr_a += 1\n            \n    sys.stdout.write(f\"{best_rank} {worst_rank}\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    # Sort both arrays\n    a.sort()\n    b.sort()\n\n    # Best possible rank for Vasya is always 1\n    # Vasya can achieve the highest possible score by taking the largest a_i and largest b_j.\n    # No other participant can achieve a higher score using the remaining points.\n    # If multiple participants achieve the same top score, the jury can assign Vasya rank 1.\n    best_rank = 1\n\n    # Worst possible rank for Vasya\n    # This involves finding the maximum number of participants (including Vasya)\n    # who can achieve a total score of at least x.\n    # Vasya would then be assigned the last place among these participants.\n    \n    worst_rank = 0\n    ptr_a = 0\n    ptr_b = n - 1\n\n    while ptr_a < n and ptr_b >= 0:\n        if a[ptr_a] + b[ptr_b] >= x:\n            # This pair (a[ptr_a], b[ptr_b]) can form a sum >= x.\n            # We count this as one participant who met the criteria.\n            # To maximize such participants, we use the smallest available 'a'\n            # and the largest available 'b' to form a valid pair.\n            # This \"saves\" larger 'a' values and smaller 'b' values for other potential pairs.\n            worst_rank += 1\n            ptr_a += 1\n            ptr_b -= 1\n        else:\n            # a[ptr_a] is too small to form a sum >= x even with the largest available b[ptr_b].\n            # This means a[ptr_a] cannot form a sum >= x with any b_j (where j <= ptr_b).\n            # So, a[ptr_a] must be paired with some b_j such that a[ptr_a] + b_j < x.\n            # We effectively \"discard\" a[ptr_a] from forming a sum >= x and move to the next a.\n            ptr_a += 1\n            \n    sys.stdout.write(f\"{best_rank} {worst_rank}\\n\")\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 872,
        "completion_token_count": 5096,
        "thoughts_token_count": 775
    }
}