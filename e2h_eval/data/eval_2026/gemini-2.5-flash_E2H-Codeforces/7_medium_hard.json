{
    "start": 1758015875.253385,
    "end": 1758015968.9296508,
    "start-formatted": "2025-09-16 18:44 KST",
    "end-formatted": "2025-09-16 18:46 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "**Analyzing Snowflake Graph Construction and Vertex Count**\n\nOkay, so I'm presented with a competitive programming problem where I need to figure out if a given number, `n`, can represent a \"snowflake\" graph. A snowflake starts with a center vertex connected to `k` other vertices, where `k` is greater than 1. Then, any vertex connected to only one other vertex gets connected to `k` *new* vertices. This step must be done at least once, and this process can be repeated.\n\nLet's break down the vertex count. If we apply the growth step `d` times, with `d` being greater than or equal to 1, then the total vertices can be expressed using geometric series. For `d=1`, we get `1 + k + k^2`, which corresponds to `n = (k^(2+1)-1)/(k-1) = 1+k+k^2` and is valid. For any value of d, the number of vertices,  `n`, can be described as `1 + k + k^2 + k^3 + ... + k^M`, where `M = d+1` and we know that `d` must be at least one so  `M` is greater than or equal to 2.  Thus `n = (k^(M+1) - 1) / (k-1)`. This has to be the formula to determine the `n` vertices of the snowflake for some integer values for `k > 1` and `M >= 2`.\n\nNow, here's where it gets interesting: I'm given `n` and need to figure out if there exist suitable `k` and `M` that fit that formula. The trick is recognizing that I need a valid `k > 1`, that does not overflow. The problem specifies a maximum of `10^18` for `n`, which puts some constraints on `k` and `M`.  If `k = 2`, the equation is `n = 2^(M+1) - 1`. The goal is to identify if we have the right values of `k` and `M` within the bounds provided.\n\nSo, when `M=2`, the equation becomes `n = 1 + k + k^2`. I can solve for `k` using the quadratic formula, and if the result is an integer, `k` becomes valid. The key check here is to see if `4n - 3` is a perfect square.  I have to ensure that `k` turns out greater than `1` and that, of course, the value is an integer.\n\nFor `M` greater than or equal to 3, things get a bit more complex. Since `n` can be large, a brute-force approach could be computationally slow. A key realization is that `k` is smaller than `n^(1/M)`.  If `k` is large, or `M` is large, we can potentially exceed `10^18` pretty quickly, so some bounds are necessary. I'll need to run this for all possible M's to test.\n\nI'll iterate `M` from 3 up to a certain point (let's say 58, as the log bounds indicated). For each `M`, I can employ binary search to look for the appropriate value of `k`. The bounds of that search are from 2 up to a safe value, perhaps up to `10^6 + 7`, given the maximum bound on `n = 10^18`. A safe upper limit for `k` within that is going to be `int(n**(1/M))`.  Within this search, I'll calculate `1 + k + k^2 + k^3 + ...` until I reach a number larger or equal to `n`. I'll optimize that part by avoiding any overflows using iterative checks and by using modular arithmetic/integer division to test for overflows. If the calculated sum matches `n`, I've found a valid snowflake; otherwise, I keep searching.\n\nI should start by checking some special cases, where `n = 1`, `2`, `3`, `4`, `5`, or `6`, to avoid the most computationally expensive test. I know that `n=1` is not a snowflake, and if all M's don't work, return 'NO'. I'll have to use optimized methods to calculate those geometric series sums without overflows, considering that `n` can go up to `10^18`, and perform calculations in a manner that avoids arithmetic overflow.\n",
    "response": "A snowflake is an undirected graph constructed according to specific rules. We are given `n`, the total number of vertices, and need to determine if a snowflake with `n` vertices can exist for some `k > 1`.\n\nLet's analyze the structure of a snowflake:\n1. Start with 1 central vertex.\n2. Connect the central vertex to `k` new vertices (level 1).\n3. This step must be done at least once: Each vertex connected to only one other vertex is connected to `k` more new vertices.\n\nLet `M` be the number of levels of vertices beyond the central vertex.\n- If step 3 is applied `d` times, then `M = d+1`.\n- The problem states \"This step should be done at least once\", so `d >= 1`. This implies `M >= 2`.\n\nLet's count the vertices:\n- 1 central vertex.\n- `k` vertices at level 1.\n- If step 3 is applied once (`d=1`, `M=2`): Each of the `k` level 1 vertices gets `k` new children. So `k * k = k^2` vertices at level 2.\n  Total vertices: `1 + k + k^2`.\n- If step 3 is applied twice (`d=2`, `M=3`): Each of the `k^2` level 2 vertices gets `k` new children. So `k^2 * k = k^3` vertices at level 3.\n  Total vertices: `1 + k + k^2 + k^3`.\n- In general, if step 3 is applied `d` times, there will be `k^(d+1)` vertices at level `d+1`.\n  The total number of vertices `n` will be `1 + k + k^2 + ... + k^(d+1)`.\n  Let `M = d+1`. Since `d >= 1`, we have `M >= 2`.\n  So, `n = 1 + k + k^2 + ... + k^M`.\n  This is a geometric series sum: `n = (k^(M+1) - 1) / (k - 1)`.\n\nWe need to find if there exist integers `k > 1` and `M >= 2` such that `n = 1 + k + ... + k^M`.\n\n**Constraints:**\n- `n <= 10^18`\n- `k > 1`\n- `M >= 2`\n\n**Algorithm:**\n\n1.  **Smallest `n`**: The smallest possible snowflake occurs when `k=2` and `M=2`.\n    `n = 1 + 2 + 2^2 = 1 + 2 + 4 = 7`.\n    Therefore, for any `n < 7`, the answer is \"NO\".\n\n2.  **Case `M = 2`**:\n    `n = 1 + k + k^2`.\n    This is a quadratic equation `k^2 + k + (1 - n) = 0`.\n    Using the quadratic formula, `k = (-1 +/- sqrt(1 - 4(1 - n))) / 2 = (-1 +/- sqrt(4n - 3)) / 2`.\n    For `k` to be an integer greater than 1:\n    - `4n - 3` must be a perfect square. Let `S = sqrt(4n - 3)`.\n    - `S` must be an integer.\n    - `k = (-1 + S) / 2` (since `k > 0`).\n    - `k > 1` implies `(-1 + S) / 2 > 1`, so `S - 1 > 2`, meaning `S > 3`.\n    - `S` must be odd for `S - 1` to be even, ensuring `k` is an integer.\n    If all these conditions are met, return \"YES\".\n\n3.  **Case `M >= 3`**:\n    We need to iterate through possible values of `M`.\n    What is the maximum `M`? If `k=2` (the smallest `k`), `n = 2^(M+1) - 1`.\n    Since `n <= 10^18`, `2^(M+1) - 1 <= 10^18`, so `2^(M+1) <= 10^18 + 1`.\n    `M+1 <= log2(10^18 + 1)`. `log2(10^18)` is approximately `59.79`.\n    So, `M+1` can be at most `59`, which means `M` can be at most `58`.\n    We iterate `M` from `3` to `58`.\n\n    For each `M`, we need to find if there exists an integer `k > 1` such that `n = 1 + k + ... + k^M`.\n    The function `f(k) = 1 + k + ... + k^M` is strictly increasing for `k > 1`. We can use binary search to find `k`.\n    - **Lower bound for `k`**: `k_low = 2`.\n    - **Upper bound for `k`**: We know `k^M < n`, so `k < n^(1/M)`.\n      A safe upper bound for `k` is `int(n**(1/M)) + 2`. For `M=3` and `n=10^18`, this is `int(10^6) + 2 = 1000002`. This upper bound decreases as `M` increases.\n\n    **Binary Search for `k`**:\n    `k_low = 2`, `k_high = int(round(n**(1/M))) + 2`.\n    While `k_low <= k_high`:\n        `mid_k = (k_low + k_high) // 2`.\n        If `mid_k < 2`, set `k_low = 2` and continue (or break if `k_low` becomes too small, though `k_low` starts at 2).\n        Calculate `current_sum = 1 + mid_k + ... + mid_k^M`. This sum must be computed carefully to avoid overflow, comparing intermediate sums/terms with `n`.\n        ```python\n        def calculate_sum(k_val, M_val, target_n):\n            current_sum = 1\n            current_term = 1\n            for _ in range(M_val): # M_val terms after the initial 1\n                # Check for current_term * k_val overflow or exceeding target_n\n                if k_val > target_n // current_term: # current_term * k_val > target_n\n                    return target_n + 1 # Signal too large\n                current_term *= k_val\n\n                # Check for current_sum + current_term overflow or exceeding target_n\n                if current_term > target_n - current_sum: # current_sum + current_term > target_n\n                    return target_n + 1 # Signal too large\n                current_sum += current_term\n            return current_sum\n        ```\n        Compare `calculated_n = calculate_sum(mid_k, M, n)`:\n        - If `calculated_n == n`: return \"YES\".\n        - If `calculated_n < n`: `k_low = mid_k + 1` (try larger `k`).\n        - If `calculated_n > n`: `k_high = mid_k - 1` (try smaller `k`).\n\n4.  **No Solution Found**: If after checking all `M` (including `M=2`), no `k` is found, return \"NO\".\n\n**Time Complexity Analysis:**\n- Small `n` check: O(1).\n- `M=2` check: O(log N) for `sqrt` or O(1) if `sqrt` is treated as constant time.\n- Loop for `M` from `3` to `58`: `56` iterations.\n- Inside `M` loop: Binary search for `k`. The range for `k` is up to `10^6`. `log_2(10^6)` is about `20`.\n- Inside binary search: `calculate_sum` function iterates `M` times. Max `M` is `58`.\n- Total operations: `56 * 20 * 58` which is approximately `65000` operations per test case.\n- With `t = 10^4` test cases, total operations are `6.5 * 10^8`. This might be too slow for Python.\n\nLet's re-evaluate the binary search complexity. The `k_high` is `n^(1/M)`.\nThe number of binary search iterations is `log(n^(1/M)) = (1/M) * log(n)`.\nThe `calculate_sum` function takes `M` operations.\nSo, for each `M`, the complexity is `M * (1/M) * log(n) = log(n)`.\nTotal complexity: `sum_{M=3}^{58} log(n) = (58 - 3 + 1) * log(n) = 56 * log(n)`.\n`log_2(10^18)` is approximately `60`.\nTotal operations: `56 * 60` approximately `3360` operations per test case.\nWith `t = 10^4` test cases, total operations are `3360 * 10^4 = 3.36 * 10^7`. This is well within typical time limits for Python.\n\n```python\nimport sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n\n    # Smallest snowflake is 1 + 2 + 2^2 = 7.\n    # So n < 7 cannot be a snowflake.\n    if n < 7:\n        sys.stdout.write(\"NO\\n\")\n        return\n\n    # Case M = 2: n = 1 + k + k^2\n    # k^2 + k + (1 - n) = 0\n    # Discriminant = 1 - 4(1 - n) = 1 - 4 + 4n = 4n - 3\n    discriminant = 4 * n - 3\n    \n    # Check if discriminant is a perfect square\n    s = int(discriminant**0.5)\n    if s * s == discriminant:\n        # k = (-1 + s) / 2\n        # For k > 1, we need -1 + s > 2, so s > 3\n        # Also, s must be odd for (-1 + s) to be even\n        if s > 3 and (s - 1) % 2 == 0:\n            # k = (s - 1) // 2\n            # No need to explicitly calculate k, just check existence\n            sys.stdout.write(\"YES\\n\")\n            return\n\n    # Case M >= 3: n = 1 + k + k^2 + ... + k^M\n    # Max M is around 58 (for k=2, 2^59 - 1 approx 10^18)\n    # Iterate M from 3 to 58\n    for M in range(3, 59):\n        # Binary search for k\n        k_low = 2\n        # k^M < n implies k < n^(1/M)\n        # Add a small buffer for float precision\n        k_high = int(n**(1/M)) + 2 \n        \n        # Upper bound for k can be large for small M (e.g., M=3, k_high approx 10^6)\n        # Cap k_high to avoid unnecessarily large search space in case of precision issues\n        # 10^6 is a safe upper bound for k for M>=3 and n<=10^18\n        # (1+k+k^2+k^3 for k=10^6 is already > 10^18)\n        k_high = min(k_high, 10**6 + 7) \n\n        while k_low <= k_high:\n            mid_k = (k_low + k_high) // 2\n            if mid_k < 2: # k must be > 1\n                k_low = 2\n                continue\n\n            # Calculate sum = 1 + mid_k + ... + mid_k^M\n            current_sum = 1\n            current_term = 1\n            possible_n = 0 # To store the sum, or n+1 if it overflows/exceeds n\n\n            for _ in range(M): # M terms after the initial 1\n                # Check for current_term * mid_k overflow or exceeding n\n                # current_term * mid_k > n is equivalent to mid_k > n / current_term\n                if current_term > n // mid_k: \n                    possible_n = n + 1 # Signal too large\n                    break\n                current_term *= mid_k\n\n                # Check for current_sum + current_term overflow or exceeding n\n                # current_sum + current_term > n is equivalent to current_term > n - current_sum\n                if current_term > n - current_sum:\n                    possible_n = n + 1 # Signal too large\n                    break\n                current_sum += current_term\n            else: # Loop completed without overflow\n                possible_n = current_sum\n\n            if possible_n == n:\n                sys.stdout.write(\"YES\\n\")\n                return\n            elif possible_n < n:\n                k_low = mid_k + 1\n            else: # possible_n > n\n                k_high = mid_k - 1\n    \n    sys.stdout.write(\"NO\\n\")\n\n\nnum_test_cases = int(sys.stdin.readline())\nfor _ in range(num_test_cases):\n    solve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n\n    # Smallest snowflake is 1 + 2 + 2^2 = 7.\n    # So n < 7 cannot be a snowflake.\n    if n < 7:\n        sys.stdout.write(\"NO\\n\")\n        return\n\n    # Case M = 2: n = 1 + k + k^2\n    # k^2 + k + (1 - n) = 0\n    # Discriminant = 1 - 4(1 - n) = 1 - 4 + 4n = 4n - 3\n    discriminant = 4 * n - 3\n    \n    # Check if discriminant is a perfect square\n    s = int(discriminant**0.5)\n    if s * s == discriminant:\n        # k = (-1 + s) / 2\n        # For k > 1, we need -1 + s > 2, so s > 3\n        # Also, s must be odd for (-1 + s) to be even\n        if s > 3 and (s - 1) % 2 == 0:\n            # k = (s - 1) // 2\n            # No need to explicitly calculate k, just check existence\n            sys.stdout.write(\"YES\\n\")\n            return\n\n    # Case M >= 3: n = 1 + k + k^2 + ... + k^M\n    # Max M is around 58 (for k=2, 2^59 - 1 approx 10^18)\n    # Iterate M from 3 to 58\n    for M in range(3, 59):\n        # Binary search for k\n        k_low = 2\n        # k^M < n implies k < n^(1/M)\n        # Add a small buffer for float precision\n        k_high = int(n**(1/M)) + 2 \n        \n        # Upper bound for k can be large for small M (e.g., M=3, k_high approx 10^6)\n        # Cap k_high to avoid unnecessarily large search space in case of precision issues\n        # 10^6 is a safe upper bound for k for M>=3 and n<=10^18\n        # (1+k+k^2+k^3 for k=10^6 is already > 10^18)\n        k_high = min(k_high, 10**6 + 7) \n\n        while k_low <= k_high:\n            mid_k = (k_low + k_high) // 2\n            if mid_k < 2: # k must be > 1\n                k_low = 2\n                continue\n\n            # Calculate sum = 1 + mid_k + ... + mid_k^M\n            current_sum = 1\n            current_term = 1\n            possible_n = 0 # To store the sum, or n+1 if it overflows/exceeds n\n\n            for _ in range(M): # M terms after the initial 1\n                # Check for current_term * mid_k overflow or exceeding n\n                # current_term * mid_k > n is equivalent to mid_k > n / current_term\n                if current_term > n // mid_k: \n                    possible_n = n + 1 # Signal too large\n                    break\n                current_term *= mid_k\n\n                # Check for current_sum + current_term overflow or exceeding n\n                # current_sum + current_term > n is equivalent to current_term > n - current_sum\n                if current_term > n - current_sum:\n                    possible_n = n + 1 # Signal too large\n                    break\n                current_sum += current_term\n            else: # Loop completed without overflow\n                possible_n = current_sum\n\n            if possible_n == n:\n                sys.stdout.write(\"YES\\n\")\n                return\n            elif possible_n < n:\n                k_low = mid_k + 1\n            else: # possible_n > n\n                k_high = mid_k - 1\n    \n    sys.stdout.write(\"NO\\n\")\n\n\nnum_test_cases = int(sys.stdin.readline())\nfor _ in range(num_test_cases):\n    solve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 568,
        "completion_token_count": 3247,
        "thoughts_token_count": 6887
    }
}