{
    "start": 1758294841.43011,
    "end": 1758294956.7487664,
    "start-formatted": "2025-09-20 00:14 KST",
    "end-formatted": "2025-09-20 00:15 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "**Initial Assessment and Problem Decomposition**\n\nAlright, let's break this down. We've got a graph problem where the values on the vertices need to respect GCD and LCM constraints on edges. My initial thought is to transform this into a more manageable form. The GCD and LCM relationship is key – it gives us  `x * y = g * l` for an edge with values `g` and `l`. This tells me immediately that the *relationship* between adjacent values, rather than their absolute values, is the important bit.\n\nSince the constraints involve GCD and LCM, I'm thinking about prime factorization. It's the standard tool for dealing with these types of relationships. The limits on mushroom counts (1 to 10^6) are very helpful here as they place bounds on the exponents of the primes we'll be dealing with.\n\n**Refining Constraints and Graph Representation**\n\nSo, the fundamental equation for edge  `(u, v)` is `a_u * a_v = g * l`. Crucially, both `g` divides `a_u` and `a_v`, and both `a_u` and `a_v` divide `l`. We can rewrite this as `a_u = g * x` and `a_v = g * y`  where `x*y = P = l/g` and `GCD(x,y) = 1`. This leads me to believe that for any given prime `p`, the exponent of `p` in either `a_u` or `a_v` (but not both) must divide the prime factorization of P (which is l/g).\n\nThat means we've effectively reduced the edge constraint into deciding which prime powers (from the prime factors of l/g) divide `a_u` and which ones divide `a_v`. This transforms the complex constraint on the edges into simpler constraints on the exponents of primes in the node values. The problem, now, is to determine a valid assignment of prime exponents for each node in a way that respects the constraints.\n\n**The Power of Prime Exponents and 2-Coloring**\n\nIf we look at just one prime `p`, this translates to `min(v_p(a_u), v_p(a_v)) = v_p(g)` and `max(v_p(a_u), v_p(a_v)) = v_p(l)`. So for the prime `p`, we need to have either  `v_p(a_u) = v_p(g)` and `v_p(a_v) = v_p(l)` or vice versa. This structure immediately makes me think of a 2-coloring problem – the graph needs to be colored so that on any edge the two nodes have different colors. And if an edge has `g=l`, we must assign both nodes the same color.\n\n**Algorithm Design and Implementation**\n\nThe approach will be the following:\n\n1.  **Precompute Prime Factorizations:** Do this at the start.\n2.  **Iterate Primes:** Go through all relevant prime numbers (those that are factors of the g and l values).\n3.  **Graph Coloring:** For each prime `p`, create a 2-coloring for the graph:\n    *   Initialize the exponent for each node to -1 (unassigned).\n    *   For each component, start a DFS/BFS.\n    *   When an edge has g=l, we must enforce `e_p(u) == e_p(v)` for that edge. This will force a single value for connected nodes, effectively fixing their color.\n    *   When an edge has g != l, we need `e_p(u) != e_p(v)`. Check to see if the nodes already have a conflicting color.\n\n4.  **Validate Solution:** After the assignment of exponents for a prime, for each node make sure that the assigned exponents are within the range 0 to log base p of 10^6. Reconstruct the actual values as the product of prime powers and verify the GCD and LCM constraints on all edges.\n\n**Dealing with Constraints**\n\nOne crucial thing that is not completely defined is the initial assignment. If, for any prime p, there are no imposed colors, then the assignment of exponents can be anything that satisfies the 1 to 10^6 limits.\n\n*   Edges where `g == l`: This means the nodes are constrained to have the same value for all primes. Enforce that requirement within each connected component, and if there is ever a contradiction between the two nodes, report \"NO\".\n*   Edges where `g != l`: Use the 2-coloring algorithm. Pick an arbitrary color to start for the component.\n\nThis approach",
    "response": "The problem asks us to restore the number of mushrooms `a_i` on `n` lawns, given `m` roads. For each road connecting lawns `u` and `v`, we are given `g = GCD(a_u, a_v)` and `l = LCM(a_u, a_v)`. The mushroom counts must be between 1 and 10^6.\n\n**Key Mathematical Property:**\nFor any two positive integers `x` and `y`, `GCD(x, y) * LCM(x, y) = x * y`.\nThis implies `a_u * a_v = g * l`.\nAlso, `g` must divide `l`. If `g` does not divide `l` for any road, no solution exists.\n\nLet `v_p(N)` denote the exponent of the prime `p` in the prime factorization of `N`.\nFrom the properties of GCD and LCM:\n`v_p(g) = min(v_p(a_u), v_p(a_v))`\n`v_p(l) = max(v_p(a_u), v_p(a_v))`\n\nThis means that for any prime `p`, the set of exponents `{v_p(a_u), v_p(a_v)}` must be equal to the set `{v_p(g), v_p(l)}`.\nThis crucial observation decouples the problem into independent subproblems for each prime `p`.\nFor each prime `p`, we need to assign an exponent `e_p(i) = v_p(a_i)` to each lawn `i`.\nFor every road `(u, v)` with given `g` and `l`:\nThe pair `(e_p(u), e_p(v))` must be either `(v_p(g), v_p(l))` or `(v_p(l), v_p(g))`.\n\n**Algorithm Breakdown:**\n\n1.  **Precomputation (Prime Factorization):**\n    We need to find `v_p(N)` efficiently for `N` up to `10^6`. We can use a sieve to find the smallest prime factor (SPF) for all numbers up to `10^6`. Then, `v_p(N)` can be computed by repeatedly dividing `N` by its SPF.\n    A dictionary `prime_factorization[N]` can store `p: exponent` pairs for each `N`.\n    A list `all_primes` will store all unique prime factors encountered in `g` and `l` values.\n\n2.  **Initial Checks and Data Structures:**\n    *   For each road `(u, v)` with `g, l`:\n        *   If `l % g != 0`, output \"NO\" and exit.\n        *   Store edges in an adjacency list `adj[u] = [(v, g, l)]`.\n    *   Initialize `a[i] = 1` for all `i=1..n`. This `a[i]` will accumulate `p^{e_p(i)}` for all primes `p`.\n\n3.  **Solve for Each Prime `p`:**\n    For each prime `p` in `all_primes`:\n    a.  **Initialize `e_p_val[i] = -1`** for all `i=1..n`. This array will store `v_p(a_i)`.\n    b.  **Process \"fixed\" constraints:** Iterate through all edges `(u, v)` with `(g, l)`:\n        *   Calculate `G_p = v_p(g)` and `L_p = v_p(l)`.\n        *   If `G_p == L_p`: This means `e_p(u)` and `e_p(v)` must both be `G_p`.\n            *   If `e_p_val[u]` is already assigned and not `G_p`, conflict -> \"NO\".\n            *   If `e_p_val[v]` is already assigned and not `G_p`, conflict -> \"NO\".\n            *   Set `e_p_val[u] = G_p` and `e_p_val[v] = G_p`.\n    c.  **Propagate fixed values using BFS:**\n        *   Create a queue and add all `i` where `e_p_val[i]` is now `!= -1`.\n        *   While the queue is not empty:\n            *   Dequeue `u`.\n            *   For each neighbor `v` of `u` with edge `(u, v, g_uv, l_uv)`:\n                *   Calculate `G_p = v_p(g_uv)` and `L_p = v_p(l_uv)`.\n                *   If `G_p == L_p`:\n                    *   If `e_p_val[u] != G_p`, conflict -> \"NO\".\n                    *   If `e_p_val[v] == -1`, set `e_p_val[v] = G_p` and enqueue `v`.\n                    *   Else if `e_p_val[v] != G_p`, conflict -> \"NO\".\n                *   Else (`G_p != L_p`):\n                    *   If `e_p_val[u]` is not `G_p` and not `L_p`, conflict -> \"NO\" (this node's value was fixed by another edge to something inconsistent).\n                    *   If `e_p_val[v] == -1`:\n                        *   If `e_p_val[u] == G_p`, set `e_p_val[v] = L_p` and enqueue `v`.\n                        *   Else (`e_p_val[u] == L_p`), set `e_p_val[v] = G_p` and enqueue `v`.\n                    *   Else (`e_p_val[v]` is assigned):\n                        *   If `{e_p_val[u], e_p_val[v]}` is not `{G_p, L_p}`, conflict -> \"NO\".\n    d.  **Handle 2-colorable components:** Some nodes might still have `e_p_val[i] = -1`. These belong to connected components where all edges have `G_p != L_p`. These components are 2-colorable.\n        *   For each `i` from `1` to `n`:\n            *   If `e_p_val[i] == -1`:\n                *   This is the start of a new 2-colorable component. We have two choices for `e_p_val[i]` (either `G_p` or `L_p` from any adjacent edge, or 0 if isolated).\n                *   Let's try one choice: `e_p_val[i] = 0` (a safe default, or `v_p(g)` for first neighbor if exists).\n                *   Perform a BFS from `i` to determine `e_p_val` for all nodes in this component, using the `G_p + L_p - e_p_val[u]` logic.\n                *   During this BFS, store the resulting exponents in `current_exp_option1`.\n                *   After the BFS, check if any `a_j = a[j] * p^{current_exp_option1[j]}` would exceed `10^6`.\n                *   If it does, or if any conflict was found during BFS, we must try the other option (flip all `G_p` and `L_p` assignments in this component).\n                *   If both options lead to conflict or exceed `10^6`, output \"NO\".\n                *   If one option works, apply it. If both work, pick one (e.g., the one that makes `a_j` smaller).\n                *   This \"try both options\" is complex. A simpler approach: Just try one option. If it fails due to `a_j > 10^6`, output \"NO\". If it's valid, use it. If it's valid, but there's a different assignment for the same component that also works and makes `a_j` smaller, we don't care, any valid solution is fine.\n                *   **Revised 2-colorable component handling:**\n                    *   Create `temp_e_p_val` array for this component's BFS.\n                    *   Start BFS from `i`. Assign `temp_e_p_val[i] = 0` (or `v_p(g)` from first edge if available).\n                    *   Propagate values. If any conflict, this branch fails.\n                    *   After BFS, check `a_j * p^{temp_e_p_val[j]}` for all `j` in component. If any exceeds `10^6`, this branch fails.\n                    *   If this branch fails, try assigning `temp_e_p_val[i]` to `v_p(l)` (if `v_p(g)` was used before) and repeat. If `0` was used, try `v_p(l_ij)` for some edge `(i,j)` if `v_p(g_ij)` was `0`.\n                    *   This is still tricky. Let's simplify:\n                        Maintain `e_p_val[i]` as the final exponents.\n                        For nodes `i` with `e_p_val[i] == -1`:\n                            Start a BFS/DFS from `i`. Assign `e_p_val[i] = 0` (or `v_p(g)` for an arbitrary adjacent edge).\n                            Propagate values. During propagation, if a node `v` is visited and `e_p_val[v]` is `-1`, assign `e_p_val[v]` based on `e_p_val[u]`. If `e_p_val[v]` is already set, verify consistency. If any conflict, output \"NO\".\n                            After this component's `e_p_val` are set, check `a_j * p^{e_p_val[j]}`. If any `a_j` exceeds `10^6`, then the chosen starting `e_p_val[i]` was wrong. We need to flip all assignments in this component.\n                            To do this efficiently: keep track of `e_p_val_option1` and `e_p_val_option2` for each component.\n                            `e_p_val_option1[i]` is based on `e_p_val[start_node] = G_p_start`.\n                            `e_p_val_option2[i]` is based on `e_p_val[start_node] = L_p_start`.\n                            Compute both. Check which one is valid (all values `p^{e_p(i)}` multiply `a_i` to `<= 10^6`). If neither, \"NO\". If both, pick one. If only one, pick that one.\n\n4.  **Final Construction and Validation:**\n    *   Once `e_p_val[i]` is determined for all `i` and all primes `p`:\n    *   For each `i` from `1` to `n`:\n        *   For each prime `p` in `all_primes`:\n            *   `a[i] *= p^{e_p_val[i]}`.\n            *   If `a[i] > 10^6` at any point, output \"NO\" and exit.\n    *   After computing all `a[i]`, perform a final check: for each edge `(u, v)` with `g, l`:\n        *   `GCD(a[u], a[v])` must be `g`.\n        *   `LCM(a[u], a[v])` must be `l`.\n        *   If any check fails, output \"NO\".\n\n5.  **Output:** If all checks pass, output \"YES\" and then `a[1], ..., a[n]`.\n\n**Optimization for 2-colorable components:**\nInstead of computing two options and checking `10^6` limit, we can be more direct.\nFor a 2-colorable component, if `p` is a prime, and `v_p(g_uv) != v_p(l_uv)` for all edges `(u,v)` in the component:\nLet `e_p_min = min(v_p(g_uv), v_p(l_uv))` and `e_p_max = max(v_p(g_uv), v_p(l_uv))` for any edge in the component. All nodes will be assigned either `e_p_min` or `e_p_max`.\nIf we assign `e_p_val[start_node] = e_p_min`, we get one set of assignments. If `e_p_val[start_node] = e_p_max`, we get the other.\nWe need to check which choice keeps `a_i <= 10^6`.\nFor each node `i`, we have two potential values for `e_p(i)`: `e_p_val_A[i]` and `e_p_val_B[i]`.\nWe need to pick one for each `i`. The decision for `i` implies the decision for all nodes in its 2-colorable component.\nSo, for each such component, calculate `product_p_A = product(p^{e_p_val_A[j]})` for all `j` in the component, and `product_p_B = product(p^{e_p_val_B[j]})`.\nWe need to choose the option (A or B) that results in `a_j * product_p <= 10^6`.\nIf `a_j * p^{e_p_val_A[j]}` is valid for all `j` in component, but `a_j * p^{e_p_val_B[j]}` is not, use A.\nIf `a_j * p^{e_p_val_B[j]}` is valid for all `j` in component, but `a_j * p^{e_p_val_A[j]}` is not, use B.\nIf both are valid, pick the one that results in smaller `a_j` values (e.g., sum of exponents is smaller).\nIf neither is valid, output \"NO\".\n\nThis approach handles all constraints and edge cases. The maximum value `10^6` means that the number of primes to consider is limited, and the exponents `e_p(i)` are also small. The overall complexity will be dominated by prime factorization and the BFS/DFS traversals for each prime.\n\n```python\nimport sys\nimport math\nfrom collections import deque\n\n# Max value for numbers\nMAX_VAL = 10**6\n\n# Sieve for smallest prime factor (SPF)\nspf = [0] * (MAX_VAL + 1)\nprimes = []\n\ndef sieve():\n    for i in range(2, MAX_VAL + 1):\n        if spf[i] == 0: # i is prime\n            spf[i] = i\n            primes.append(i)\n        for p in primes:\n            if p > spf[i] or i * p > MAX_VAL:\n                break\n            spf[i * p] = p\n\n# Function to get prime factorization of N\n# Returns a dictionary {prime: exponent}\ndef get_prime_factorization(n):\n    factors = {}\n    if n == 0:\n        return factors\n    while n > 1:\n        p = spf[n]\n        count = 0\n        while n % p == 0:\n            count += 1\n            n //= p\n        factors[p] = count\n    return factors\n\n# Function to get v_p(N)\ndef get_v_p(n, p, precomputed_factors=None):\n    if precomputed_factors is not None and p in precomputed_factors:\n        return precomputed_factors[p]\n    \n    if n == 0: # Conventionally, v_p(0) is infinity, but here numbers are >= 1\n        return 0 # Should not happen based on problem constraints (1 <= G, L)\n    \n    count = 0\n    while n > 0 and n % p == 0:\n        count += 1\n        n //= p\n    return count\n\n# Main solution logic\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    all_prime_factors_set = set()\n\n    # Store edges and collect all prime factors from G and L\n    edges_data = []\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        edges_data.append((u, v, g, l))\n\n        if l % g != 0:\n            sys.stdout.write(\"NO\\n\")\n            return\n\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l)) # Graph is undirected\n\n        # Precompute factors for g and l\n        g_factors = get_prime_factorization(g)\n        l_factors = get_prime_factorization(l)\n        \n        for p in g_factors:\n            all_prime_factors_set.add(p)\n        for p in l_factors:\n            all_prime_factors_set.add(p)\n    \n    # Sort primes for consistent processing\n    all_primes = sorted(list(all_prime_factors_set))\n\n    # a[i] stores the final mushroom count for lawn i\n    a = [1] * (n + 1)\n    \n    # Store precomputed prime factorizations for all g and l values\n    # This avoids recomputing factors for the same g/l multiple times\n    g_l_factorizations = {}\n    for u, v, g, l in edges_data:\n        if g not in g_l_factorizations:\n            g_l_factorizations[g] = get_prime_factorization(g)\n        if l not in g_l_factorizations:\n            g_l_factorizations[l] = get_prime_factorization(l)\n\n    # Solve for each prime independently\n    for p in all_primes:\n        e_p_val = [-1] * (n + 1) # Exponent of p for each node\n        \n        q = deque()\n\n        # Phase 1: Propagate fixed values (where G_p == L_p)\n        for u, v, g, l in edges_data:\n            g_factors_u = g_l_factorizations[g]\n            l_factors_u = g_l_factorizations[l]\n            G_p = get_v_p(g, p, g_factors_u)\n            L_p = get_v_p(l, p, l_factors_u)\n\n            if G_p == L_p:\n                if e_p_val[u] != -1 and e_p_val[u] != G_p:\n                    sys.stdout.write(\"NO\\n\")\n                    return\n                if e_p_val[v] != -1 and e_p_val[v] != G_p:\n                    sys.stdout.write(\"NO\\n\")\n                    return\n                if e_p_val[u] == -1:\n                    e_p_val[u] = G_p\n                    q.append(u)\n                if e_p_val[v] == -1:\n                    e_p_val[v] = G_p\n                    q.append(v)\n        \n        # BFS to propagate values from Phase 1\n        visited_in_phase1 = [False] * (n + 1)\n        while q:\n            u = q.popleft()\n            if visited_in_phase1[u]:\n                continue\n            visited_in_phase1[u] = True\n\n            for v_node, g_uv, l_uv in adj[u]:\n                g_factors_uv = g_l_factorizations[g_uv]\n                l_factors_uv = g_l_factorizations[l_uv]\n                G_p_uv = get_v_p(g_uv, p, g_factors_uv)\n                L_p_uv = get_v_p(l_uv, p, l_factors_uv)\n\n                if e_p_val[v_node] == -1:\n                    # If G_p_uv == L_p_uv, then v_node must take G_p_uv\n                    if G_p_uv == L_p_uv:\n                        if e_p_val[u] != G_p_uv: # u was fixed to something else\n                            sys.stdout.write(\"NO\\n\")\n                            return\n                        e_p_val[v_node] = G_p_uv\n                        q.append(v_node)\n                    # If G_p_uv != L_p_uv, then v_node must take the other value\n                    else:\n                        if e_p_val[u] == G_p_uv:\n                            e_p_val[v_node] = L_p_uv\n                            q.append(v_node)\n                        elif e_p_val[u] == L_p_uv:\n                            e_p_val[v_node] = G_p_uv\n                            q.append(v_node)\n                        else: # e_p_val[u] is fixed to a value not G_p_uv or L_p_uv\n                            sys.stdout.write(\"NO\\n\")\n                            return\n                else: # e_p_val[v_node] is already assigned\n                    # Check consistency\n                    if G_p_uv == L_p_uv:\n                        if e_p_val[u] != G_p_uv or e_p_val[v_node] != G_p_uv:\n                            sys.stdout.write(\"NO\\n\")\n                            return\n                    else:\n                        if not ({e_p_val[u], e_p_val[v_node]} == {G_p_uv, L_p_uv}):\n                            sys.stdout.write(\"NO\\n\")\n                            return\n\n        # Phase 2: Handle unassigned nodes (2-colorable components)\n        for i in range(1, n + 1):\n            if e_p_val[i] == -1:\n                # Start a new BFS for this component\n                q_component = deque()\n                \n                # Option 1: assign i to 0 (or G_p for first edge)\n                # We need to decide for the whole component.\n                # Let's find the max exponent that would be assigned in this component for this prime\n                # If it's a 2-colorable component, all nodes will have either the 'min' or 'max' exponent\n                # based on the edge constraints. We need to pick the assignment that keeps a[i] within MAX_VAL.\n                \n                # Collect all possible (G_p, L_p) pairs for edges in this component\n                component_edges_p_vals = set()\n                q_temp = deque()\n                q_temp.append(i)\n                visited_temp = [False] * (n + 1)\n                visited_temp[i] = True\n                \n                component_nodes = []\n\n                while q_temp:\n                    u_temp = q_temp.popleft()\n                    component_nodes.append(u_temp)\n                    for v_node_temp, g_uv_temp, l_uv_temp in adj[u_temp]:\n                        if not visited_temp[v_node_temp] and e_p_val[v_node_temp] == -1:\n                            visited_temp[v_node_temp] = True\n                            q_temp.append(v_node_temp)\n                        \n                        g_factors_temp = g_l_factorizations[g_uv_temp]\n                        l_factors_temp = g_l_factorizations[l_uv_temp]\n                        G_p_temp = get_v_p(g_uv_temp, p, g_factors_temp)\n                        L_p_temp = get_v_p(l_uv_temp, p, l_factors_temp)\n                        component_edges_p_vals.add((min(G_p_temp, L_p_temp), max(G_p_temp, L_p_temp)))\n\n                # If component_edges_p_vals is empty, it's an isolated node.\n                # e_p_val can be 0.\n                if not component_edges_p_vals:\n                    e_p_val[i] = 0\n                    continue\n\n                # All (G_p, L_p) pairs in this component must be consistent\n                # i.e., min(G_p, L_p) must be the same for all, and max(G_p, L_p) must be the same for all\n                min_G_p = float('inf')\n                max_L_p = 0\n                for gp, lp in component_edges_p_vals:\n                    min_G_p = min(min_G_p, gp)\n                    max_L_p = max(max_L_p, lp)\n                \n                # Check consistency of min/max values across edges in this component\n                for gp, lp in component_edges_p_vals:\n                    if gp != min_G_p or lp != max_L_p:\n                        sys.stdout.write(\"NO\\n\")\n                        return\n\n                # Now we have two choices for this component:\n                # Option A: start_node gets min_G_p, others follow\n                # Option B: start_node gets max_L_p, others follow\n                \n                # Try Option A\n                temp_e_p_val_A = list(e_p_val) # copy current state\n                q_component.append(i)\n                temp_e_p_val_A[i] = min_G_p\n                \n                valid_A = True\n                visited_component = [False] * (n + 1)\n                visited_component[i] = True\n\n                while q_component:\n                    u_comp = q_component.popleft()\n                    for v_node_comp, g_uv_comp, l_uv_comp in adj[u_comp]:\n                        if e_p_val[v_node_comp] != -1: # Already assigned from other component\n                            continue\n\n                        g_factors_comp = g_l_factorizations[g_uv_comp]\n                        l_factors_comp = g_l_factorizations[l_uv_comp]\n                        G_p_comp = get_v_p(g_uv_comp, p, g_factors_comp)\n                        L_p_comp = get_v_p(l_uv_comp, p, l_factors_comp)\n\n                        if temp_e_p_val_A[v_node_comp] == -1:\n                            if temp_e_p_val_A[u_comp] == G_p_comp:\n                                temp_e_p_val_A[v_node_comp] = L_p_comp\n                                q_component.append(v_node_comp)\n                            elif temp_e_p_val_A[u_comp] == L_p_comp:\n                                temp_e_p_val_A[v_node_comp] = G_p_comp\n                                q_component.append(v_node_comp)\n                            else: # Should not happen if logic is correct\n                                valid_A = False\n                                break\n                        else: # temp_e_p_val_A[v_node_comp] is already assigned\n                            if not ({temp_e_p_val_A[u_comp], temp_e_p_val_A[v_node_comp]} == {G_p_comp, L_p_comp}):\n                                valid_A = False\n                                break\n                    if not valid_A: break\n\n                if valid_A:\n                    for node_idx in component_nodes:\n                        if a[node_idx] > MAX_VAL // (p**temp_e_p_val_A[node_idx]):\n                            valid_A = False\n                            break\n                \n                # If Option A is not valid, try Option B\n                if not valid_A:\n                    # Reset for Option B\n                    temp_e_p_val_B = list(e_p_val)\n                    q_component = deque()\n                    q_component.append(i)\n                    temp_e_p_val_B[i] = max_L_p\n\n                    valid_B = True\n                    visited_component = [False] * (n + 1)\n                    visited_component[i] = True\n\n                    while q_component:\n                        u_comp = q_component.popleft()\n                        for v_node_comp, g_uv_comp, l_uv_comp in adj[u_comp]:\n                            if e_p_val[v_node_comp] != -1:\n                                continue\n\n                            g_factors_comp = g_l_factorizations[g_uv_comp]\n                            l_factors_comp = g_l_factorizations[l_uv_comp]\n                            G_p_comp = get_v_p(g_uv_comp, p, g_factors_comp)\n                            L_p_comp = get_v_p(l_uv_comp, p, l_factors_comp)\n\n                            if temp_e_p_val_B[v_node_comp] == -1:\n                                if temp_e_p_val_B[u_comp] == G_p_comp:\n                                    temp_e_p_val_B[v_node_comp] = L_p_comp\n                                    q_component.append(v_node_comp)\n                                elif temp_e_p_val_B[u_comp] == L_p_comp:\n                                    temp_e_p_val_B[v_node_comp] = G_p_comp\n                                    q_component.append(v_node_comp)\n                                else:\n                                    valid_B = False\n                                    break\n                            else:\n                                if not ({temp_e_p_val_B[u_comp], temp_e_p_val_B[v_node_comp]} == {G_p_comp, L_p_comp}):\n                                    valid_B = False\n                                    break\n                        if not valid_B: break\n\n                    if valid_B:\n                        for node_idx in component_nodes:\n                            if a[node_idx] > MAX_VAL // (p**temp_e_p_val_B[node_idx]):\n                                valid_B = False\n                                break\n                \n                # Apply the valid option\n                if valid_A and valid_B:\n                    # Both options are valid, choose the one with smaller sum of exponents (to keep numbers smaller)\n                    sum_exp_A = sum(temp_e_p_val_A[node_idx] for node_idx in component_nodes)\n                    sum_exp_B = sum(temp_e_p_val_B[node_idx] for node_idx in component_nodes)\n                    if sum_exp_A <= sum_exp_B:\n                        for node_idx in component_nodes:\n                            e_p_val[node_idx] = temp_e_p_val_A[node_idx]\n                    else:\n                        for node_idx in component_nodes:\n                            e_p_val[node_idx] = temp_e_p_val_B[node_idx]\n                elif valid_A:\n                    for node_idx in component_nodes:\n                        e_p_val[node_idx] = temp_e_p_val_A[node_idx]\n                elif valid_B:\n                    for node_idx in component_nodes:\n                        e_p_val[node_idx] = temp_e_p_val_B[node_idx]\n                else:\n                    sys.stdout.write(\"NO\\n\")\n                    return\n        \n        # Multiply p^e_p_val[i] into a[i]\n        for i in range(1, n + 1):\n            if e_p_val[i] == -1: # Isolated node not connected to any edge involving this prime\n                e_p_val[i] = 0 # Default to 0 exponent\n            \n            # Check for overflow before multiplication\n            if p**e_p_val[i] > MAX_VAL: # If p^e_p_val[i] itself is too large\n                sys.stdout.write(\"NO\\n\")\n                return\n\n            if a[i] > MAX_VAL // (p**e_p_val[i]):\n                sys.stdout.write(\"NO\\n\")\n                return\n            a[i] *= (p**e_p_val[i])\n\n    # Final verification\n    for u, v, g_orig, l_orig in edges_data:\n        # Calculate GCD and LCM for assigned a[u], a[v]\n        current_g = math.gcd(a[u], a[v])\n        current_l = (a[u] * a[v]) // current_g # Using property: LCM(x,y) = (x*y)/GCD(x,y)\n\n        if current_g != g_orig or current_l != l_orig:\n            sys.stdout.write(\"NO\\n\")\n            return\n\n    sys.stdout.write(\"YES\\n\")\n    sys.stdout.write(\" \".join(map(str, a[1:])) + \"\\n\")\n\n# Precompute SPF table\nsieve()\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\nfrom collections import deque\n\n# Max value for numbers\nMAX_VAL = 10**6\n\n# Sieve for smallest prime factor (SPF)\nspf = [0] * (MAX_VAL + 1)\nprimes = []\n\ndef sieve():\n    for i in range(2, MAX_VAL + 1):\n        if spf[i] == 0: # i is prime\n            spf[i] = i\n            primes.append(i)\n        for p in primes:\n            if p > spf[i] or i * p > MAX_VAL:\n                break\n            spf[i * p] = p\n\n# Function to get prime factorization of N\n# Returns a dictionary {prime: exponent}\ndef get_prime_factorization(n):\n    factors = {}\n    if n == 0:\n        return factors\n    while n > 1:\n        p = spf[n]\n        count = 0\n        while n % p == 0:\n            count += 1\n            n //= p\n        factors[p] = count\n    return factors\n\n# Function to get v_p(N)\ndef get_v_p(n, p, precomputed_factors=None):\n    if precomputed_factors is not None and p in precomputed_factors:\n        return precomputed_factors[p]\n    \n    if n == 0: # Conventionally, v_p(0) is infinity, but here numbers are >= 1\n        return 0 # Should not happen based on problem constraints (1 <= G, L)\n    \n    count = 0\n    while n > 0 and n % p == 0:\n        count += 1\n        n //= p\n    return count\n\n# Main solution logic\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    all_prime_factors_set = set()\n\n    # Store edges and collect all prime factors from G and L\n    edges_data = []\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        edges_data.append((u, v, g, l))\n\n        if l % g != 0:\n            sys.stdout.write(\"NO\\n\")\n            return\n\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l)) # Graph is undirected\n\n        # Precompute factors for g and l\n        g_factors = get_prime_factorization(g)\n        l_factors = get_prime_factorization(l)\n        \n        for p in g_factors:\n            all_prime_factors_set.add(p)\n        for p in l_factors:\n            all_prime_factors_set.add(p)\n    \n    # Sort primes for consistent processing\n    all_primes = sorted(list(all_prime_factors_set))\n\n    # a[i] stores the final mushroom count for lawn i\n    a = [1] * (n + 1)\n    \n    # Store precomputed prime factorizations for all g and l values\n    # This avoids recomputing factors for the same g/l multiple times\n    g_l_factorizations = {}\n    for u, v, g, l in edges_data:\n        if g not in g_l_factorizations:\n            g_l_factorizations[g] = get_prime_factorization(g)\n        if l not in g_l_factorizations:\n            g_l_factorizations[l] = get_prime_factorization(l)\n\n    # Solve for each prime independently\n    for p in all_primes:\n        e_p_val = [-1] * (n + 1) # Exponent of p for each node\n        \n        q = deque()\n\n        # Phase 1: Propagate fixed values (where G_p == L_p)\n        for u, v, g, l in edges_data:\n            g_factors_u = g_l_factorizations[g]\n            l_factors_u = g_l_factorizations[l]\n            G_p = get_v_p(g, p, g_factors_u)\n            L_p = get_v_p(l, p, l_factors_u)\n\n            if G_p == L_p:\n                if e_p_val[u] != -1 and e_p_val[u] != G_p:\n                    sys.stdout.write(\"NO\\n\")\n                    return\n                if e_p_val[v] != -1 and e_p_val[v] != G_p:\n                    sys.stdout.write(\"NO\\n\")\n                    return\n                if e_p_val[u] == -1:\n                    e_p_val[u] = G_p\n                    q.append(u)\n                if e_p_val[v] == -1:\n                    e_p_val[v] = G_p\n                    q.append(v)\n        \n        # BFS to propagate values from Phase 1\n        visited_in_phase1 = [False] * (n + 1)\n        while q:\n            u = q.popleft()\n            if visited_in_phase1[u]:\n                continue\n            visited_in_phase1[u] = True\n\n            for v_node, g_uv, l_uv in adj[u]:\n                g_factors_uv = g_l_factorizations[g_uv]\n                l_factors_uv = g_l_factorizations[l_uv]\n                G_p_uv = get_v_p(g_uv, p, g_factors_uv)\n                L_p_uv = get_v_p(l_uv, p, l_factors_uv)\n\n                if e_p_val[v_node] == -1:\n                    # If G_p_uv == L_p_uv, then v_node must take G_p_uv\n                    if G_p_uv == L_p_uv:\n                        if e_p_val[u] != G_p_uv: # u was fixed to something else\n                            sys.stdout.write(\"NO\\n\")\n                            return\n                        e_p_val[v_node] = G_p_uv\n                        q.append(v_node)\n                    # If G_p_uv != L_p_uv, then v_node must take the other value\n                    else:\n                        if e_p_val[u] == G_p_uv:\n                            e_p_val[v_node] = L_p_uv\n                            q.append(v_node)\n                        elif e_p_val[u] == L_p_uv:\n                            e_p_val[v_node] = G_p_uv\n                            q.append(v_node)\n                        else: # e_p_val[u] is fixed to a value not G_p_uv or L_p_uv\n                            sys.stdout.write(\"NO\\n\")\n                            return\n                else: # e_p_val[v_node] is already assigned\n                    # Check consistency\n                    if G_p_uv == L_p_uv:\n                        if e_p_val[u] != G_p_uv or e_p_val[v_node] != G_p_uv:\n                            sys.stdout.write(\"NO\\n\")\n                            return\n                    else:\n                        if not ({e_p_val[u], e_p_val[v_node]} == {G_p_uv, L_p_uv}):\n                            sys.stdout.write(\"NO\\n\")\n                            return\n\n        # Phase 2: Handle unassigned nodes (2-colorable components)\n        for i in range(1, n + 1):\n            if e_p_val[i] == -1:\n                # Start a new BFS for this component\n                q_component = deque()\n                \n                # Option 1: assign i to 0 (or G_p for first edge)\n                # We need to decide for the whole component.\n                # Let's find the max exponent that would be assigned in this component for this prime\n                # If it's a 2-colorable component, all nodes will have either the 'min' or 'max' exponent\n                # based on the edge constraints. We need to pick the assignment that keeps a[i] within MAX_VAL.\n                \n                # Collect all possible (G_p, L_p) pairs for edges in this component\n                component_edges_p_vals = set()\n                q_temp = deque()\n                q_temp.append(i)\n                visited_temp = [False] * (n + 1)\n                visited_temp[i] = True\n                \n                component_nodes = []\n\n                while q_temp:\n                    u_temp = q_temp.popleft()\n                    component_nodes.append(u_temp)\n                    for v_node_temp, g_uv_temp, l_uv_temp in adj[u_temp]:\n                        if not visited_temp[v_node_temp] and e_p_val[v_node_temp] == -1:\n                            visited_temp[v_node_temp] = True\n                            q_temp.append(v_node_temp)\n                        \n                        g_factors_temp = g_l_factorizations[g_uv_temp]\n                        l_factors_temp = g_l_factorizations[l_uv_temp]\n                        G_p_temp = get_v_p(g_uv_temp, p, g_factors_temp)\n                        L_p_temp = get_v_p(l_uv_temp, p, l_factors_temp)\n                        component_edges_p_vals.add((min(G_p_temp, L_p_temp), max(G_p_temp, L_p_temp)))\n\n                # If component_edges_p_vals is empty, it's an isolated node.\n                # e_p_val can be 0.\n                if not component_edges_p_vals:\n                    e_p_val[i] = 0\n                    continue\n\n                # All (G_p, L_p) pairs in this component must be consistent\n                # i.e., min(G_p, L_p) must be the same for all, and max(G_p, L_p) must be the same for all\n                min_G_p = float('inf')\n                max_L_p = 0\n                for gp, lp in component_edges_p_vals:\n                    min_G_p = min(min_G_p, gp)\n                    max_L_p = max(max_L_p, lp)\n                \n                # Check consistency of min/max values across edges in this component\n                for gp, lp in component_edges_p_vals:\n                    if gp != min_G_p or lp != max_L_p:\n                        sys.stdout.write(\"NO\\n\")\n                        return\n\n                # Now we have two choices for this component:\n                # Option A: start_node gets min_G_p, others follow\n                # Option B: start_node gets max_L_p, others follow\n                \n                # Try Option A\n                temp_e_p_val_A = list(e_p_val) # copy current state\n                q_component.append(i)\n                temp_e_p_val_A[i] = min_G_p\n                \n                valid_A = True\n                visited_component = [False] * (n + 1)\n                visited_component[i] = True\n\n                while q_component:\n                    u_comp = q_component.popleft()\n                    for v_node_comp, g_uv_comp, l_uv_comp in adj[u_comp]:\n                        if e_p_val[v_node_comp] != -1: # Already assigned from other component\n                            continue\n\n                        g_factors_comp = g_l_factorizations[g_uv_comp]\n                        l_factors_comp = g_l_factorizations[l_uv_comp]\n                        G_p_comp = get_v_p(g_uv_comp, p, g_factors_comp)\n                        L_p_comp = get_v_p(l_uv_comp, p, l_factors_comp)\n\n                        if temp_e_p_val_A[v_node_comp] == -1:\n                            if temp_e_p_val_A[u_comp] == G_p_comp:\n                                temp_e_p_val_A[v_node_comp] = L_p_comp\n                                q_component.append(v_node_comp)\n                            elif temp_e_p_val_A[u_comp] == L_p_comp:\n                                temp_e_p_val_A[v_node_comp] = G_p_comp\n                                q_component.append(v_node_comp)\n                            else: # Should not happen if logic is correct\n                                valid_A = False\n                                break\n                        else: # temp_e_p_val_A[v_node_comp] is already assigned\n                            if not ({temp_e_p_val_A[u_comp], temp_e_p_val_A[v_node_comp]} == {G_p_comp, L_p_comp}):\n                                valid_A = False\n                                break\n                    if not valid_A: break\n\n                if valid_A:\n                    for node_idx in component_nodes:\n                        if a[node_idx] > MAX_VAL // (p**temp_e_p_val_A[node_idx]):\n                            valid_A = False\n                            break\n                \n                # If Option A is not valid, try Option B\n                if not valid_A:\n                    # Reset for Option B\n                    temp_e_p_val_B = list(e_p_val)\n                    q_component = deque()\n                    q_component.append(i)\n                    temp_e_p_val_B[i] = max_L_p\n\n                    valid_B = True\n                    visited_component = [False] * (n + 1)\n                    visited_component[i] = True\n\n                    while q_component:\n                        u_comp = q_component.popleft()\n                        for v_node_comp, g_uv_comp, l_uv_comp in adj[u_comp]:\n                            if e_p_val[v_node_comp] != -1:\n                                continue\n\n                            g_factors_comp = g_l_factorizations[g_uv_comp]\n                            l_factors_comp = g_l_factorizations[l_uv_comp]\n                            G_p_comp = get_v_p(g_uv_comp, p, g_factors_comp)\n                            L_p_comp = get_v_p(l_uv_comp, p, l_factors_comp)\n\n                            if temp_e_p_val_B[v_node_comp] == -1:\n                                if temp_e_p_val_B[u_comp] == G_p_comp:\n                                    temp_e_p_val_B[v_node_comp] = L_p_comp\n                                    q_component.append(v_node_comp)\n                                elif temp_e_p_val_B[u_comp] == L_p_comp:\n                                    temp_e_p_val_B[v_node_comp] = G_p_comp\n                                    q_component.append(v_node_comp)\n                                else:\n                                    valid_B = False\n                                    break\n                            else:\n                                if not ({temp_e_p_val_B[u_comp], temp_e_p_val_B[v_node_comp]} == {G_p_comp, L_p_comp}):\n                                    valid_B = False\n                                    break\n                        if not valid_B: break\n\n                    if valid_B:\n                        for node_idx in component_nodes:\n                            if a[node_idx] > MAX_VAL // (p**temp_e_p_val_B[node_idx]):\n                                valid_B = False\n                                break\n                \n                # Apply the valid option\n                if valid_A and valid_B:\n                    # Both options are valid, choose the one with smaller sum of exponents (to keep numbers smaller)\n                    sum_exp_A = sum(temp_e_p_val_A[node_idx] for node_idx in component_nodes)\n                    sum_exp_B = sum(temp_e_p_val_B[node_idx] for node_idx in component_nodes)\n                    if sum_exp_A <= sum_exp_B:\n                        for node_idx in component_nodes:\n                            e_p_val[node_idx] = temp_e_p_val_A[node_idx]\n                    else:\n                        for node_idx in component_nodes:\n                            e_p_val[node_idx] = temp_e_p_val_B[node_idx]\n                elif valid_A:\n                    for node_idx in component_nodes:\n                        e_p_val[node_idx] = temp_e_p_val_A[node_idx]\n                elif valid_B:\n                    for node_idx in component_nodes:\n                        e_p_val[node_idx] = temp_e_p_val_B[node_idx]\n                else:\n                    sys.stdout.write(\"NO\\n\")\n                    return\n        \n        # Multiply p^e_p_val[i] into a[i]\n        for i in range(1, n + 1):\n            if e_p_val[i] == -1: # Isolated node not connected to any edge involving this prime\n                e_p_val[i] = 0 # Default to 0 exponent\n            \n            # Check for overflow before multiplication\n            if p**e_p_val[i] > MAX_VAL: # If p^e_p_val[i] itself is too large\n                sys.stdout.write(\"NO\\n\")\n                return\n\n            if a[i] > MAX_VAL // (p**e_p_val[i]):\n                sys.stdout.write(\"NO\\n\")\n                return\n            a[i] *= (p**e_p_val[i])\n\n    # Final verification\n    for u, v, g_orig, l_orig in edges_data:\n        # Calculate GCD and LCM for assigned a[u], a[v]\n        current_g = math.gcd(a[u], a[v])\n        current_l = (a[u] * a[v]) // current_g # Using property: LCM(x,y) = (x*y)/GCD(x,y)\n\n        if current_g != g_orig or current_l != l_orig:\n            sys.stdout.write(\"NO\\n\")\n            return\n\n    sys.stdout.write(\"YES\\n\")\n    sys.stdout.write(\" \".join(map(str, a[1:])) + \"\\n\")\n\n# Precompute SPF table\nsieve()\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 542,
        "completion_token_count": 7888,
        "thoughts_token_count": 7918
    }
}