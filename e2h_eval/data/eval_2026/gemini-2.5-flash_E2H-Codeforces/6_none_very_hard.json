{
    "start": 1758015864.8157442,
    "end": 1758015891.8326712,
    "start-formatted": "2025-09-16 18:44 KST",
    "end-formatted": "2025-09-16 18:44 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "",
    "response": "```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    vouchers = []\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        vouchers.append((l, r, cost))\n\n    vouchers.sort()\n\n    min_cost = float('inf')\n    \n    # max_coord = 2 * 10**5 + 1\n    # max_coord = max(r for _, r, _ in vouchers) + 1\n    max_coord = 200001\n\n    # dp_right[end_day] stores the minimum cost of a voucher ending at end_day\n    # for a given duration. This will be updated as we iterate through vouchers sorted by start day.\n    # dp_right[duration][end_day]\n    # To optimize space, we can use a segment tree or similar structure,\n    # or iterate through possible durations and update minimum costs.\n    # A simpler approach is to precompute minimum costs for vouchers ending at or before a certain day.\n\n    # This array will store for each duration `d`, the minimum cost of a voucher\n    # that has duration `d` and ends at or before a certain day.\n    # min_cost_for_duration_ending_at[duration][end_day]\n    # We can optimize this by only storing the minimum cost for each duration,\n    # and then updating a \"current best\" for a given duration.\n\n    # Let's try iterating through vouchers sorted by their start times.\n    # For each voucher (l_i, r_i, cost_i), we want to find another voucher (l_j, r_j, cost_j)\n    # such that r_j < l_i or r_i < l_j, and (r_i - l_i + 1) + (r_j - l_j + 1) == x.\n\n    # The condition r_j < l_i is easier to handle if we process vouchers by l_i.\n    # The condition r_i < l_j is easier to handle if we process vouchers by r_i.\n\n    # Let's try sorting by l_i.\n    # When considering voucher `i` (l_i, r_i, cost_i):\n    # We need to find a voucher `j` such that `r_j < l_i` and `duration_i + duration_j == x`.\n    # `duration_j = x - duration_i`.\n    # We need to find `min_cost_j` among vouchers `j` that satisfy these conditions.\n\n    # We can maintain an array `min_cost_ending_before[duration]`\n    # This array would store the minimum cost of a voucher with `duration` that has already ended.\n    # However, \"already ended\" depends on the current `l_i`.\n\n    # Let's create a list of vouchers grouped by their start day.\n    # `vouchers_by_start_day[start_day]` will be a list of (r, cost) for vouchers starting on `start_day`.\n    \n    # We need to process events: voucher starts and voucher ends.\n    # A sweep-line approach might work.\n    # Events could be (day, type, voucher_index). Type: 0 for start, 1 for end.\n\n    # Let's consider `min_cost_for_duration[d]` as the minimum cost of a voucher\n    # that has duration `d` and *has already ended*.\n    # When we are at day `k` in the sweep-line, `min_cost_for_duration[d]` should contain\n    # the minimum cost of a voucher with duration `d` such that its `r` value is less than `k`.\n\n    # `min_cost_at_day[day]` will store an array where `min_cost_at_day[day][duration]`\n    # is the minimum cost of a voucher with that duration ending on `day`.\n    # This is too much memory if `day` goes up to 2e5.\n\n    # Let `min_cost_ending_on_or_before_day[d]` be the minimum cost of a voucher with duration `d`\n    # that ends on or before the current sweep line position.\n    \n    # Let's use `min_cost_for_duration_ending_at[d]` to store the minimum cost of a voucher with duration `d`\n    # that ends at the current day `k`.\n    # And `min_cost_for_duration_ending_before_day[d]` to store the minimum cost of a voucher with duration `d`\n    # that ends *before* the current day `k`.\n    \n    # This is still tricky. Let's try a different approach.\n    # Group vouchers by their start day `l`.\n    # `vouchers_starting_on_day[l]` will be a list of `(r, cost)` for vouchers starting on day `l`.\n    \n    vouchers_by_l = [[] for _ in range(max_coord + 1)]\n    for l, r, cost in vouchers:\n        vouchers_by_l[l].append((r, cost))\n\n    # `min_cost_ending_at_day[d]` stores the minimum cost of a voucher with duration `d`\n    # that has already ended (its `r` is less than the current day `k`).\n    # Initialize with infinity.\n    min_cost_ending_at_day = [float('inf')] * (x + 1) # Max duration can be x.\n\n    # Iterate `k` from 1 to `max_coord` (or `max_coord - 1` since `l` can be up to `max_coord - 1`)\n    # `k` represents the current day we are considering.\n    # When we are at day `k`, we consider all vouchers that *start* on day `k`.\n    # For each such voucher `(r_i, cost_i)`:\n    #   Let `duration_i = r_i - k + 1`.\n    #   We need to find a voucher `j` such that `duration_j = x - duration_i` and `r_j < k`.\n    #   The minimum cost for such a `duration_j` is `min_cost_ending_at_day[duration_j]`.\n    #   If `min_cost_ending_at_day[duration_j]` is not infinity, we can form a pair.\n    #   Update `min_cost = min(min_cost, cost_i + min_cost_ending_at_day[duration_j])`.\n    # After processing all vouchers starting on day `k`:\n    #   We need to update `min_cost_ending_at_day` with vouchers that *end* on day `k-1`.\n    #   This is the tricky part. We need to efficiently query for `r_j < k`.\n\n    # Let's maintain `min_cost_for_duration[duration]` which stores the minimum cost of a voucher\n    # with `duration` that has already been processed (its `r` value is less than `current_l`).\n    # This is effectively what `min_cost_ending_at_day` was intended for.\n    # The `min_cost_for_duration` array should be updated as we sweep through the days.\n\n    # `min_cost_for_duration[d]` stores the minimum cost of a voucher with duration `d`\n    # that has ended *before* the current day `k`.\n    # When we are at day `k`, we can add vouchers that ended on `k-1` to this data structure.\n\n    # Let's use `dp[duration]` to store the minimum cost of a voucher with that `duration`\n    # encountered so far, such that its end day `r` is less than the current day `l`.\n    \n    # `min_cost_for_dur[duration]` stores the minimum cost of a voucher with given duration\n    # that has ended at or before `current_day - 1`.\n    min_cost_for_dur = [float('inf')] * (x + 1)\n\n    # `vouchers_ending_on_day[r]` will be a list of `(duration, cost)` for vouchers ending on day `r`.\n    vouchers_by_r = [[] for _ in range(max_coord + 1)]\n    for l, r, cost in vouchers:\n        duration = r - l + 1\n        vouchers_by_r[r].append((duration, cost))\n\n    ans = float('inf')\n\n    # Iterate through days from 1 to max_coord\n    for current_day in range(1, max_coord + 1):\n        # 1. Process vouchers that start on `current_day`.\n        # For each voucher `(r_i, cost_i)` starting on `current_day`:\n        #   `duration_i = r_i - current_day + 1`.\n        #   If `duration_i < x`:\n        #     `needed_duration = x - duration_i`.\n        #     If `needed_duration >= 1` and `needed_duration <= x` and `min_cost_for_dur[needed_duration]` is not infinity:\n        #       `ans = min(ans, cost_i + min_cost_for_dur[needed_duration])`.\n        for r_i, cost_i in vouchers_by_l[current_day]:\n            duration_i = r_i - current_day + 1\n            if duration_i < x: # Ensure the other voucher has positive duration\n                needed_duration = x - duration_i\n                if 1 <= needed_duration <= x and min_cost_for_dur[needed_duration] != float('inf'):\n                    ans = min(ans, cost_i + min_cost_for_dur[needed_duration])\n        \n        # 2. Update `min_cost_for_dur` with vouchers that end on `current_day`.\n        # These vouchers will be available for future `current_day'` where `current_day' > current_day`.\n        for duration_j, cost_j in vouchers_by_r[current_day]:\n            if duration_j <= x: # Only consider durations relevant to sum x\n                min_cost_for_dur[duration_j] = min(min_cost_for_dur[duration_j], cost_j)\n\n    if ans == float('inf'):\n        print(-1)\n    else:\n        print(ans)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    vouchers = []\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        vouchers.append((l, r, cost))\n\n    vouchers.sort()\n\n    min_cost = float('inf')\n    \n    # max_coord = 2 * 10**5 + 1\n    # max_coord = max(r for _, r, _ in vouchers) + 1\n    max_coord = 200001\n\n    # dp_right[end_day] stores the minimum cost of a voucher ending at end_day\n    # for a given duration. This will be updated as we iterate through vouchers sorted by start day.\n    # dp_right[duration][end_day]\n    # To optimize space, we can use a segment tree or similar structure,\n    # or iterate through possible durations and update minimum costs.\n    # A simpler approach is to precompute minimum costs for vouchers ending at or before a certain day.\n\n    # This array will store for each duration `d`, the minimum cost of a voucher\n    # that has duration `d` and ends at or before a certain day.\n    # min_cost_for_duration_ending_at[duration][end_day]\n    # We can optimize this by only storing the minimum cost for each duration,\n    # and then updating a \"current best\" for a given duration.\n\n    # Let's try iterating through vouchers sorted by their start times.\n    # For each voucher (l_i, r_i, cost_i), we want to find another voucher (l_j, r_j, cost_j)\n    # such that r_j < l_i or r_i < l_j, and (r_i - l_i + 1) + (r_j - l_j + 1) == x.\n\n    # The condition r_j < l_i is easier to handle if we process vouchers by l_i.\n    # The condition r_i < l_j is easier to handle if we process vouchers by r_i.\n\n    # Let's try sorting by l_i.\n    # When considering voucher `i` (l_i, r_i, cost_i):\n    # We need to find a voucher `j` such that `r_j < l_i` and `duration_i + duration_j == x`.\n    # `duration_j = x - duration_i`.\n    # We need to find `min_cost_j` among vouchers `j` that satisfy these conditions.\n\n    # We can maintain an array `min_cost_ending_before[duration]`\n    # This array would store the minimum cost of a voucher with `duration` that has already ended.\n    # However, \"already ended\" depends on the current `l_i`.\n\n    # Let's create a list of vouchers grouped by their start day.\n    # `vouchers_by_start_day[start_day]` will be a list of (r, cost) for vouchers starting on `start_day`.\n    \n    # We need to process events: voucher starts and voucher ends.\n    # A sweep-line approach might work.\n    # Events could be (day, type, voucher_index). Type: 0 for start, 1 for end.\n\n    # Let's consider `min_cost_for_duration[d]` as the minimum cost of a voucher\n    # that has duration `d` and *has already ended*.\n    # When we are at day `k` in the sweep-line, `min_cost_for_duration[d]` should contain\n    # the minimum cost of a voucher with duration `d` such that its `r` value is less than `k`.\n\n    # `min_cost_at_day[day]` will store an array where `min_cost_at_day[day][duration]`\n    # is the minimum cost of a voucher with that duration ending on `day`.\n    # This is too much memory if `day` goes up to 2e5.\n\n    # Let `min_cost_ending_on_or_before_day[d]` be the minimum cost of a voucher with duration `d`\n    # that ends on or before the current sweep line position.\n    \n    # Let's use `min_cost_for_duration_ending_at[d]` to store the minimum cost of a voucher with duration `d`\n    # that ends at the current day `k`.\n    # And `min_cost_for_duration_ending_before_day[d]` to store the minimum cost of a voucher with duration `d`\n    # that ends *before* the current day `k`.\n    \n    # This is still tricky. Let's try a different approach.\n    # Group vouchers by their start day `l`.\n    # `vouchers_starting_on_day[l]` will be a list of `(r, cost)` for vouchers starting on day `l`.\n    \n    vouchers_by_l = [[] for _ in range(max_coord + 1)]\n    for l, r, cost in vouchers:\n        vouchers_by_l[l].append((r, cost))\n\n    # `min_cost_ending_at_day[d]` stores the minimum cost of a voucher with duration `d`\n    # that has already ended (its `r` is less than the current day `k`).\n    # Initialize with infinity.\n    min_cost_ending_at_day = [float('inf')] * (x + 1) # Max duration can be x.\n\n    # Iterate `k` from 1 to `max_coord` (or `max_coord - 1` since `l` can be up to `max_coord - 1`)\n    # `k` represents the current day we are considering.\n    # When we are at day `k`, we consider all vouchers that *start* on day `k`.\n    # For each such voucher `(r_i, cost_i)`:\n    #   Let `duration_i = r_i - k + 1`.\n    #   We need to find a voucher `j` such that `duration_j = x - duration_i` and `r_j < k`.\n    #   The minimum cost for such a `duration_j` is `min_cost_ending_at_day[duration_j]`.\n    #   If `min_cost_ending_at_day[duration_j]` is not infinity, we can form a pair.\n    #   Update `min_cost = min(min_cost, cost_i + min_cost_ending_at_day[duration_j])`.\n    # After processing all vouchers starting on day `k`:\n    #   We need to update `min_cost_ending_at_day` with vouchers that *end* on day `k-1`.\n    #   This is the tricky part. We need to efficiently query for `r_j < k`.\n\n    # Let's maintain `min_cost_for_duration[duration]` which stores the minimum cost of a voucher\n    # with `duration` that has already been processed (its `r` value is less than `current_l`).\n    # This is effectively what `min_cost_ending_at_day` was intended for.\n    # The `min_cost_for_duration` array should be updated as we sweep through the days.\n\n    # `min_cost_for_duration[d]` stores the minimum cost of a voucher with duration `d`\n    # that has ended *before* the current day `k`.\n    # When we are at day `k`, we can add vouchers that ended on `k-1` to this data structure.\n\n    # Let's use `dp[duration]` to store the minimum cost of a voucher with that `duration`\n    # encountered so far, such that its end day `r` is less than the current day `l`.\n    \n    # `min_cost_for_dur[duration]` stores the minimum cost of a voucher with given duration\n    # that has ended at or before `current_day - 1`.\n    min_cost_for_dur = [float('inf')] * (x + 1)\n\n    # `vouchers_ending_on_day[r]` will be a list of `(duration, cost)` for vouchers ending on day `r`.\n    vouchers_by_r = [[] for _ in range(max_coord + 1)]\n    for l, r, cost in vouchers:\n        duration = r - l + 1\n        vouchers_by_r[r].append((duration, cost))\n\n    ans = float('inf')\n\n    # Iterate through days from 1 to max_coord\n    for current_day in range(1, max_coord + 1):\n        # 1. Process vouchers that start on `current_day`.\n        # For each voucher `(r_i, cost_i)` starting on `current_day`:\n        #   `duration_i = r_i - current_day + 1`.\n        #   If `duration_i < x`:\n        #     `needed_duration = x - duration_i`.\n        #     If `needed_duration >= 1` and `needed_duration <= x` and `min_cost_for_dur[needed_duration]` is not infinity:\n        #       `ans = min(ans, cost_i + min_cost_for_dur[needed_duration])`.\n        for r_i, cost_i in vouchers_by_l[current_day]:\n            duration_i = r_i - current_day + 1\n            if duration_i < x: # Ensure the other voucher has positive duration\n                needed_duration = x - duration_i\n                if 1 <= needed_duration <= x and min_cost_for_dur[needed_duration] != float('inf'):\n                    ans = min(ans, cost_i + min_cost_for_dur[needed_duration])\n        \n        # 2. Update `min_cost_for_dur` with vouchers that end on `current_day`.\n        # These vouchers will be available for future `current_day'` where `current_day' > current_day`.\n        for duration_j, cost_j in vouchers_by_r[current_day]:\n            if duration_j <= x: # Only consider durations relevant to sum x\n                min_cost_for_dur[duration_j] = min(min_cost_for_dur[duration_j], cost_j)\n\n    if ans == float('inf'):\n        print(-1)\n    else:\n        print(ans)\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 799,
        "completion_token_count": 2448,
        "thoughts_token_count": 0
    }
}