{
    "start": 1758016319.101267,
    "end": 1758016427.2680318,
    "start-formatted": "2025-09-16 18:51 KST",
    "end-formatted": "2025-09-16 18:53 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "**I've got a competitive programming problem on my hands, and I'm diving in!** The challenge is to figure out if a given number, *n*, could be the total number of vertices in a \"snowflake\" graph.\n\nFirst, I need to understand how these snowflake graphs are built. It starts with a central vertex. This center connects to *k* other vertices, where *k* must be bigger than 1. Then, each of those \"outer\" vertices (connected to only one other vertex) sprouts *k* more vertices. This last step is crucial and must be done at least once.\n\nNow, let's break down the vertex count. At the center (Level 0), there's 1 vertex. Level 1 has *k* vertices. Level 2 has *k* times *k*, or *k* squared vertices. This keeps going. If we apply the growth rule *d* times, the total number of vertices becomes: 1 + *k* + *k* squared + ... + *k* to the power of (*d* + 1).\n\nI can represent this using a geometric series formula, where *n* equals (*k* to the power of (*d* + 2) - 1) divided by (*k* - 1). My goal is to find if, for any given *n*, I can find whole numbers for *k* (greater than 1) and *d* (at least 1) that make this equation work. Also, the maximum value of *n* is 10^18.\n\nHere's my strategy: I'll start with the simplest case: *d* equals 1. This means *n* equals 1 plus *k* plus *k* squared. I'll rearrange this equation into a quadratic. Using the quadratic formula, I can solve for *k*.  The catch is, *k* needs to be a positive whole number. This means (4*n - 3) has to be a perfect square.  Also the result should be above one.\n\nIf the *d=1* case doesn't work, I'll move on to a broader approach, where *d* can be more than 1. I'll set *p* equal to (*d* + 2). Since *d* is at least 1, then *p* is at least 3, and *n* can be calculated using a geometric sum.  I know that k raised to the power of (*p* - 1) is less than *n*.  I also recognize that I have an equation *n* = (k to the power of p - 1) / (k - 1)  that will be useful. This leads me to iterate the possibilities where *p* is at least 3. If n+1 is a power of 2, k will be 2.\n\nIn this scenario, I know I must start with k=2 and test *p* values from 4 up to 60. Then, I need to do a more efficient binary search where *k* ranges up to the floor of *n*^(1/(p-1)).\n\nTo avoid overflow issues, particularly when calculating *k* to a large power, I will write a function to safely calculate the sum, checking for a potential overflow at each step. By the sum calculation, I will test for an overflow by seeing if *k* is greater than *n* divided by the current term. If there's an overflow during *k* to a power, then the result of the function will simulate an overflow. I'll test each iteration for equivalency to *n*, then adjust the bounds until I have tested the bounds.\n\nIf no solution is found after this systematic checking, the answer is \"NO\".\n",
    "response": "The problem asks us to determine if a given number `n` ($1 \\le n \\le 10^{18}$) can be the total number of vertices in a \"snowflake\" graph. A snowflake is constructed as follows:\n1. Start with 1 vertex (the center).\n2. Connect the center vertex to `k` new vertices, where `k > 1`.\n3. Each vertex that is connected to only one other vertex is connected by edges to `k` more new vertices. This step must be done at least once.\n\nLet's analyze the number of vertices.\n- Level 0: 1 center vertex.\n- Level 1: `k` vertices connected to the center.\n- Level 2: Each of the `k` vertices at Level 1 is connected to `k` new vertices. So, `k * k = k^2` vertices at Level 2.\n- This process continues. If step 3 is applied `d` times, the graph will have vertices up to depth `d+1`.\nThe total number of vertices `n` will be the sum of vertices at each level:\n`n = 1 + k + k^2 + ... + k^(d+1)`\n\nThis is a geometric series sum. Let `p = d+2`. Since `d \\ge 1`, we must have `p \\ge 3`.\nThe formula for the sum is `n = (k^p - 1) / (k - 1)`.\nWe need to find if there exist integers `k > 1` and `p \\ge 3` that satisfy this equation for a given `n`.\n\nWe can split this into two cases based on `p`.\n\n**Case 1: `p = 3`**\nThis corresponds to `d = 1`, the smallest possible snowflake.\nThe equation becomes `n = 1 + k + k^2`.\nRearranging, we get a quadratic equation in `k`: `k^2 + k + (1 - n) = 0`.\nUsing the quadratic formula, `k = (-1 \\pm \\sqrt{1 - 4(1 - n)}) / 2 = (-1 \\pm \\sqrt{4n - 3}) / 2`.\nFor `k` to be a positive integer greater than 1:\n1. `4n - 3` must be a perfect square. Let `4n - 3 = S^2` for some integer `S`.\n2. `k = (-1 + S) / 2` (since `k > 0`, we take the positive root).\n3. `k > 1`, which implies `(-1 + S) / 2 > 1 \\Rightarrow -1 + S > 2 \\Rightarrow S > 3`.\n4. `S - 1` must be an even number, which means `S` must be odd. Since `S^2 = 4n - 3`, `S^2` is odd, so `S` must be odd. This condition is automatically satisfied.\n\nSo, for `p=3`, we check if `4n - 3` is a perfect square `S^2` and if `S > 3`. If both are true, then `n` is a valid snowflake count.\n\n**Case 2: `p > 3`**\nHere `p` can range from `4` upwards.\nSince `k > 1`, the smallest `k` is `2`.\nIf `k = 2`, `n = 1 + 2 + ... + 2^(p-1) = 2^p - 1`.\nSo, if `n+1` is a power of 2, then `k=2` is a valid base, provided `p = \\log_2(n+1) \\ge 4`.\n\nFor general `k \\ge 2` and `p \\ge 4`:\n`n = 1 + k + k^2 + ... + k^(p-1)`.\nWe know `k^(p-1) < n`. This implies `k < n^{1/(p-1)}`.\nSince `n \\le 10^{18}`:\n- If `p=4`, `k < (10^{18})^{1/3} = 10^6`.\n- If `p=5`, `k < (10^{18})^{1/4} \\approx 31622`.\n- As `p` increases, the upper bound for `k` decreases rapidly.\n- The maximum possible value for `p-1` occurs when `k=2`. `2^(p-1) < 10^{18} \\Rightarrow p-1 < \\log_2(10^{18}) \\approx 59.79`. So `p-1` can be at most `59`, which means `p` can be at most `60`.\n\nThis means we only need to iterate `p` from `4` to `60`. For each `p`, we can use binary search to find `k`.\nThe function `f(k) = 1 + k + ... + k^(p-1)` is monotonically increasing for `k > 1`.\nThe search range for `k` is `[2, \\text{upper_bound}]`. A loose upper bound for `k` is `\\lceil n^{1/(p-1)} \\rceil + 2`. A practical upper limit for `k` for `p \\ge 4` is `10^6 + 2`, which can be capped at `2 \\cdot 10^9` (the max `k` for `p=3`).\n\nInside the binary search, we need to calculate `current_n = 1 + mid + mid^2 + ... + mid^(p-1)`. We must be careful about potential overflows, especially if `mid^p` is calculated directly. Python handles large integers automatically, but for efficiency and to generalize the logic, we can compute the sum iteratively and stop early if `current_n` exceeds `n`.\n\n**`calculate_sum` function:**\nThis helper function computes `1 + k + ... + k^(p-1)` and checks if it exceeds `n_limit` at any point.\n```python\ndef calculate_sum(k, p, n_limit):\n    current_sum = 0\n    term = 1\n    for _ in range(p):\n        # Check if adding 'term' would exceed n_limit\n        if term > n_limit - current_sum:\n            return n_limit + 1  # Indicate that sum exceeds n_limit\n        current_sum += term\n        \n        # If this is not the last term, prepare the next term (term * k)\n        if _ < p - 1:\n            # Check for overflow of term * k before multiplication\n            # If k is too large, term * k would exceed n_limit\n            if k > n_limit // term: # n_limit // term is the max value term can be before term * k exceeds n_limit\n                return n_limit + 1\n            term *= k\n    return current_sum\n```\n\n**Overall Algorithm:**\n1. **Initial check for `n < 7`:** The smallest possible snowflake has `k=2, p=3`, which gives `n = 1+2+2^2 = 7`. Any `n < 7` cannot be a snowflake. (The problem example shows `n=1,2,3,6` are NO).\n2. **Check `p = 3`:**\n   `val = 4 * n - 3`.\n   If `val < 0`, continue.\n   `S = round(val**0.5)`.\n   If `S * S == val` and `S > 3`: return \"YES\".\n3. **Check `p \\in [4, 60]`:**\n   Iterate `p` from `4` to `60`.\n   For each `p`:\n     Perform binary search for `k` in the range `[2, \\text{high_k}]`.\n     `high_k` can be determined by `n^{1/(p-1)}`. For `p=4`, `high_k \\approx 10^6`. For `p=60`, `high_k \\approx 3`. A safe upper bound for `k` in binary search can be `min(int(n**(1/(p-1))) + 2, 2 * 10**9)`.\n     `low = 2`, `high = min(int(n**(1/(p-1))) + 2, 2 * 10**9)` (or just `2 * 10**9` as a loose upper bound).\n     While `low <= high`:\n       `mid = low + (high - low) // 2`\n       `current_n = calculate_sum(mid, p, n)`\n       If `current_n == n`: return \"YES\".\n       If `current_n < n`: `low = mid + 1`.\n       Else (`current_n > n`): `high = mid - 1`.\n4. If no solution is found after all checks, return \"NO\".\n\n**Edge Case Considerations:**\n- `n=1`: Smallest valid `n` is `7`. So `n=1` is \"NO\". My `calculate_sum` for `p=3` and `n=1` would yield `4*1-3=1`, `S=1`, which fails `S>3`. For `p \\ge 4`, `calculate_sum(k, p, 1)` for `k \\ge 2` will always be `> 1`. So `n=1` correctly returns \"NO\".\n\nThe constraints `t \\le 10^4` and `n \\le 10^{18}` mean the solution needs to be efficient. The `p=3` check is `O(1)` (sqrt and integer checks). The loop for `p` runs about 57 times. Inside the loop, binary search runs `log(10^6)` to `log(3)` iterations (approx 20 to 2). `calculate_sum` runs `p` iterations (approx 60). So total complexity is roughly `57 * 20 * 60` operations in the worst case, which is very fast for `10^4` test cases.\n\n```python\nimport sys\n\ndef calculate_sum(k, p, n_limit):\n    \"\"\"\n    Calculates the sum 1 + k + k^2 + ... + k^(p-1)\n    and returns n_limit + 1 if the sum exceeds n_limit.\n    \"\"\"\n    current_sum = 0\n    term = 1\n    for _ in range(p):\n        # Check if adding 'term' would exceed n_limit\n        if term > n_limit - current_sum:\n            return n_limit + 1  # Indicate that sum exceeds n_limit\n        current_sum += term\n        \n        # If this is not the last term, prepare the next term (term * k)\n        if _ < p - 1:\n            # Check for overflow of term * k before multiplication\n            # If k is too large, term * k would exceed n_limit\n            # This check is 'term * k > n_limit', rewritten to avoid direct multiplication\n            if k > n_limit // term:\n                return n_limit + 1\n            term *= k\n    return current_sum\n\ndef solve():\n    n = int(sys.stdin.readline())\n\n    # Smallest snowflake has k=2, p=3 => n = 1 + 2 + 2^2 = 7\n    # Any n < 7 cannot be a snowflake.\n    # The problem examples show n=1,2,3,6 are NO.\n    if n < 7:\n        sys.stdout.write(\"NO\\n\")\n        return\n\n    # Case 1: p = 3 (d = 1)\n    # n = 1 + k + k^2\n    # k^2 + k + (1 - n) = 0\n    # k = (-1 + sqrt(1 - 4(1-n))) / 2 = (-1 + sqrt(4n - 3)) / 2\n    \n    val = 4 * n - 3\n    \n    # Calculate integer square root\n    s_float = val**0.5\n    s_int = int(s_float)\n\n    # Check if 4n - 3 is a perfect square\n    if s_int * s_int == val:\n        # Check adjacent integers for floating point precision issues\n        # (s_int+1)*(s_int+1) could also be val if s_float was slightly rounded down\n        if (s_int + 1) * (s_int + 1) == val:\n            s_int += 1\n        \n        # k = (-1 + S) / 2\n        # For k > 1, S must be > 3.\n        # S must also be odd for (-1 + S) to be even, but S^2 = 4n-3 implies S^2 is odd, so S is odd.\n        if s_int > 3:\n            sys.stdout.write(\"YES\\n\")\n            return\n            \n    # Case 2: p > 3 (d > 1)\n    # Iterate p from 4 up to 60.\n    # Max p for n=10^18 is when k=2. 2^(p-1) <= 10^18 => p-1 <= log2(10^18) approx 59.79. So p-1 max 59, p max 60.\n    for p in range(4, 61):\n        # Binary search for k\n        # k >= 2\n        # k < n^(1/(p-1))\n        # Upper bound for k: For p=4, n=10^18 => k < (10^18)^(1/3) = 10^6.\n        # For p=60, n=10^18 => k < (10^18)^(1/59) approx 2.000... so k can only be 2.\n        # A safe upper bound for k in binary search\n        # min(int(n**(1/(p-1))) + 2, 2 * 10**9) is a good upper bound.\n        # 2*10^9 is roughly sqrt(4*10^18), max k for p=3.\n        low = 2\n        high = min(int(n**(1/(p-1))) + 2, 2 * 10**9) \n\n        while low <= high:\n            mid = low + (high - low) // 2\n            \n            # If mid is too small (e.g., 0 or 1), it's not a valid k\n            if mid < 2: \n                low = 2 # Ensure low starts at 2\n                continue\n\n            current_n = calculate_sum(mid, p, n)\n\n            if current_n == n:\n                sys.stdout.write(\"YES\\n\")\n                return\n            elif current_n < n:\n                low = mid + 1\n            else: # current_n > n\n                high = mid - 1\n                \n    sys.stdout.write(\"NO\\n\")\n\nnum_test_cases = int(sys.stdin.readline())\nfor _ in range(num_test_cases):\n    solve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef calculate_sum(k, p, n_limit):\n    \"\"\"\n    Calculates the sum 1 + k + k^2 + ... + k^(p-1)\n    and returns n_limit + 1 if the sum exceeds n_limit.\n    \"\"\"\n    current_sum = 0\n    term = 1\n    for _ in range(p):\n        # Check if adding 'term' would exceed n_limit\n        if term > n_limit - current_sum:\n            return n_limit + 1  # Indicate that sum exceeds n_limit\n        current_sum += term\n        \n        # If this is not the last term, prepare the next term (term * k)\n        if _ < p - 1:\n            # Check for overflow of term * k before multiplication\n            # If k is too large, term * k would exceed n_limit\n            # This check is 'term * k > n_limit', rewritten to avoid direct multiplication\n            if k > n_limit // term:\n                return n_limit + 1\n            term *= k\n    return current_sum\n\ndef solve():\n    n = int(sys.stdin.readline())\n\n    # Smallest snowflake has k=2, p=3 => n = 1 + 2 + 2^2 = 7\n    # Any n < 7 cannot be a snowflake.\n    # The problem examples show n=1,2,3,6 are NO.\n    if n < 7:\n        sys.stdout.write(\"NO\\n\")\n        return\n\n    # Case 1: p = 3 (d = 1)\n    # n = 1 + k + k^2\n    # k^2 + k + (1 - n) = 0\n    # k = (-1 + sqrt(1 - 4(1-n))) / 2 = (-1 + sqrt(4n - 3)) / 2\n    \n    val = 4 * n - 3\n    \n    # Calculate integer square root\n    s_float = val**0.5\n    s_int = int(s_float)\n\n    # Check if 4n - 3 is a perfect square\n    if s_int * s_int == val:\n        # Check adjacent integers for floating point precision issues\n        # (s_int+1)*(s_int+1) could also be val if s_float was slightly rounded down\n        if (s_int + 1) * (s_int + 1) == val:\n            s_int += 1\n        \n        # k = (-1 + S) / 2\n        # For k > 1, S must be > 3.\n        # S must also be odd for (-1 + S) to be even, but S^2 = 4n-3 implies S^2 is odd, so S is odd.\n        if s_int > 3:\n            sys.stdout.write(\"YES\\n\")\n            return\n            \n    # Case 2: p > 3 (d > 1)\n    # Iterate p from 4 up to 60.\n    # Max p for n=10^18 is when k=2. 2^(p-1) <= 10^18 => p-1 <= log2(10^18) approx 59.79. So p-1 max 59, p max 60.\n    for p in range(4, 61):\n        # Binary search for k\n        # k >= 2\n        # k < n^(1/(p-1))\n        # Upper bound for k: For p=4, n=10^18 => k < (10^18)^(1/3) = 10^6.\n        # For p=60, n=10^18 => k < (10^18)^(1/59) approx 2.000... so k can only be 2.\n        # A safe upper bound for k in binary search\n        # min(int(n**(1/(p-1))) + 2, 2 * 10**9) is a good upper bound.\n        # 2*10^9 is roughly sqrt(4*10^18), max k for p=3.\n        low = 2\n        high = min(int(n**(1/(p-1))) + 2, 2 * 10**9) \n\n        while low <= high:\n            mid = low + (high - low) // 2\n            \n            # If mid is too small (e.g., 0 or 1), it's not a valid k\n            if mid < 2: \n                low = 2 # Ensure low starts at 2\n                continue\n\n            current_n = calculate_sum(mid, p, n)\n\n            if current_n == n:\n                sys.stdout.write(\"YES\\n\")\n                return\n            elif current_n < n:\n                low = mid + 1\n            else: # current_n > n\n                high = mid - 1\n                \n    sys.stdout.write(\"NO\\n\")\n\nnum_test_cases = int(sys.stdin.readline())\nfor _ in range(num_test_cases):\n    solve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 569,
        "completion_token_count": 3545,
        "thoughts_token_count": 7414
    }
}