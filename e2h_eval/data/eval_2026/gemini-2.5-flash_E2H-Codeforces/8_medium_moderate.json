{
    "start": 1758011831.0175302,
    "end": 1758011926.9149098,
    "start-formatted": "2025-09-16 17:37 KST",
    "end-formatted": "2025-09-16 17:38 KST",
    "gpu": 2,
    "pid": 8,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "**Analyzing the \"Flawed Flow\" Problem**\n\nAlright, let's dive into this \"Flawed Flow\" problem. We're given an undirected graph with flow values on each edge, and our task is to determine the direction of each edge while adhering to some crucial constraints. Vertex 1 is our source, and vertex *n* is the sink.\n\nHere's the breakdown of my thought process:\n\n*   **The Core Conditions:** We need to ensure *flow conservation* at every intermediate vertex – what comes in must go out. Vertex 1, the source, has no incoming flow, and by design, all the flow has to end up at the sink. We also need an *acyclic* directed graph – no cycles allowed.\n*   **Acyclicity and Topological Sorting:** The acyclicity constraint is a big hint. It implies a topological ordering might be useful. If we can process nodes in an order that respects the flow direction, we can avoid cycles.\n*   **Balance and Net Flow:** My initial thoughts focused on maintaining a \"balance\" for each vertex. For an intermediate vertex, the incoming flow must equal outgoing flow. Node 1 has a flow deficit (all outgoing). Node *n* has a flow surplus (all incoming). Let's use the term `current_net_flow[v]`. This sum needs to be zero for every intermediate node, negative for node 1, and positive for node *n*.\n*   **\"Ready\" Nodes and a Queue:** The problem seems tailor-made for a queue-based or BFS-like approach. We're looking for nodes that are \"ready\" to send or receive flow. A node is \"ready\" if all its flow requirements have been met.\n*   **Iterative Refinement:** We'll be iterating over edges. We start with node 1 since it's the source. We'll adjust the `current_flow_balance` of vertices as we assign directions to edges.\n*   **Edge Direction and the Topological Sort:** When we process an edge `(u, v)` with flow `c`, the key is to determine which direction is valid: `u -> v` or `v -> u`. We need to use `current_flow_balance[v]` to decide. \n*   **The Kahn's Algorithm Approach:** This seems close to a Kahn's Algorithm-style topological sort. We process nodes in a directed way from source to sink. By the time we process a node, it should have received all the needed incoming flows or not received any needed incoming flows from earlier nodes. Nodes are only added to the queue if their *remaining incoming flow balance* is zero - all flows must go from outgoing edges. By this process, the problem is solvable, since the problem statement assumes a valid solution will be possible.\n\nThe strategy that seems most promising is:\n\n1.  Create an adjacency list for each vertex.\n2.  Maintain a `current_flow_balance` (or net flow) for each vertex (intermediate nodes initially store half of the total flow at their vertices). Node 1 initially is added to the queue, and is treated differently.\n3.  Use a queue and start at the source (node 1).\n4.  Direct edges from the current node in the queue to its neighbors. The logic: `current_flow_balance[v] -= flow`.\n5.  If any node receives all the needed incoming flow (`current_flow_balance[v]` becomes zero). Add that node to the queue.\n6.  This process guarantees acyclicity and satisfies flow conservation.\n\nThe key thing is ensuring no cycles and directing all flow correctly from the source to the sink. By iteratively balancing the flow at each node and ensuring each edge is in the correct topological order (from \"earlier\" node to a \"later\" node in the topological order), we can resolve this.\n",
    "response": "The problem asks us to determine the direction of flow for each edge in a given undirected graph, such that several conditions are met: flow conservation at intermediate vertices, no incoming flow at the source (vertex 1), and no cycles in the resulting directed graph. We are given the flow volume for each edge.\n\nLet's break down the conditions and devise a strategy:\n\n1.  **Flow Conservation for Intermediate Vertices (1 < v < n):** For any intermediate vertex `v`, the sum of flow volumes of incoming edges must equal the sum of flow volumes of outgoing edges. This implies that if we sum up the flow volumes of all edges incident to `v`, this total sum must be an even number. Half of this total must be incoming flow, and the other half must be outgoing flow. Let `total_adj_flow[v]` be the sum of flow volumes of all edges incident to `v`. Then, `v` needs to receive `total_adj_flow[v] / 2` units of flow.\n\n2.  **Source Condition (v = 1):** Vertex 1 has no incoming edges. This means all edges connected to vertex 1 must be directed *out* of vertex 1.\n\n3.  **Sink Condition (v = n):** While not explicitly stated, in a standard max-flow problem, the sink (vertex `n`) has no outgoing edges. This is a natural consequence of flow conservation and acyclicity. All edges connected to vertex `n` must be directed *into* vertex `n`.\n\n4.  **Acyclicity:** The obtained directed graph must not have cycles. This is a strong hint towards a topological ordering approach. If we always direct edges from \"earlier\" nodes to \"later\" nodes in a topological sense, we guarantee acyclicity.\n\n**Algorithm Idea (Topological Sort based):**\n\nWe can use a queue-based approach similar to Kahn's algorithm for topological sorting. The core idea is to identify nodes that are \"ready\" to send out flow and process them.\n\n1.  **Initialization:**\n    *   Store the original `(a_i, b_i)` for each edge `i` to determine the output direction (0 or 1).\n    *   Build an adjacency list `adj[v]` for each vertex `v`, storing `(neighbor, flow_volume, original_edge_index)`.\n    *   Calculate `total_adj_flow[v]` for all `v`: the sum of flow volumes of all edges incident to `v`.\n    *   Initialize `required_incoming_flow[v]` for each vertex `v`:\n        *   For intermediate vertices `v` (1 < `v` < `n`): `required_incoming_flow[v] = total_adj_flow[v] / 2`. This represents the amount of flow `v` still needs to receive.\n        *   For the source `v = 1`: `required_incoming_flow[1] = 0` (it needs no incoming flow).\n        *   For the sink `v = n`: This value is not directly used in this balancing logic, as it's the final destination for flow.\n    *   Initialize a queue `q`.\n    *   Add vertex 1 (the source) to the queue, as it needs no incoming flow and can start sending flow immediately.\n    *   Initialize `ans` array of size `m` with `None` to store the directions.\n\n2.  **Processing Loop:**\n    *   While the queue `q` is not empty:\n        *   Dequeue a vertex `u`.\n        *   For each neighbor `v` of `u` connected by an edge with flow `c` and original index `idx`:\n            *   If `ans[idx]` is already set, this edge has been directed by `v` (meaning `v -> u`). Skip it.\n            *   Otherwise, this edge `(u, v)` is still undirected. Since `u` is being processed (it has received all its required incoming flow, or is the source), it must now send flow *out* through its remaining undirected edges. So, direct the edge as `u -> v`.\n            *   Set `ans[idx]`: If the original edge was `(a_i, b_i)` and `a_i == u`, then `ans[idx] = 0`. Otherwise (`b_i == u`), `ans[idx] = 1`.\n            *   If `v` is an intermediate vertex (1 < `v` < `n`):\n                *   Decrement `required_incoming_flow[v]` by `c` (as `v` just received `c` units of flow from `u`).\n                *   If `required_incoming_flow[v]` becomes 0, it means `v` has now received all its required incoming flow. `v` is now \"ready\" to send out flow through its remaining undirected edges. Add `v` to the queue.\n            *   If `v` is the sink `n`: No further action is needed for `v`'s balance; it simply accepts the flow.\n            *   If `v` is the source `1`: This case should not happen. Our algorithm directs edges from `u` to `v` where `u` is \"earlier\" than `v`. If `v=1`, it implies `u -> 1`, which contradicts the condition that vertex 1 has no incoming edges. This won't occur because vertex 1 is only ever added to the queue initially, and it will direct its edges outwards.\n\n3.  **Output:** Print the `ans` array.\n\n**Why this works:**\n\n*   **Source Condition:** Vertex 1 is the first node added to the queue. All its incident edges will be directed `1 -> v`, satisfying `deg_in[1] = 0`.\n*   **Flow Conservation for Intermediate Nodes:** For an intermediate node `v`, `required_incoming_flow[v]` tracks how much flow it still needs to receive. Once `required_incoming_flow[v]` becomes 0, `v` is added to the queue. When `v` is dequeued, it means it has accumulated exactly `total_adj_flow[v] / 2` incoming flow. All its remaining undirected edges *must* be outgoing to satisfy `deg_out[v] = total_adj_flow[v] / 2`.\n*   **Sink Condition:** The sink `n` is never added to the queue (unless it's an intermediate node, which it isn't). Edges connected to `n` will be directed `u -> n` when `u` is processed, ensuring all flow goes into `n`.\n*   **Acyclicity:** By always directing edges from a processed node `u` (which has satisfied its incoming flow requirements) to an unprocessed node `v` (which is still accumulating incoming flow, or is the sink), we ensure that we are building a topological ordering. An edge `u -> v` implies `u` comes before `v`. This process inherently creates a DAG.\n\n**Example Walkthrough (First Example):**\n`n=3, m=3`\nEdges:\n`0: (3, 2, 10)`\n`1: (1, 2, 10)`\n`2: (3, 1, 5)`\n\n`edges_info = [(3, 2), (1, 2), (3, 1)]`\n\n`adj`:\n`1: [(2, 10, 1), (3, 5, 2)]`\n`2: [(3, 10, 0), (1, 10, 1)]`\n`3: [(2, 10, 0), (1, 5, 2)]`\n\n`total_adj_flow`:\n`1: 10 + 5 = 15`\n`2: 10 + 10 = 20`\n`3: 10 + 5 = 15`\n\n`required_incoming_flow`:\n`1: 0`\n`2: 20 / 2 = 10`\n`3: N/A`\n\n`ans = [None, None, None]`\n`q = deque([1])`\n\n**Iteration 1 (`u = 1`):**\n*   Neighbor `(v=2, flow=10, idx=1)`:\n    *   `ans[1]` is `None`. `edges_info[1]` is `(1, 2)`. `u=1` is `edges_info[1][0]`. So, `ans[1] = 0` (direction `1 -> 2`).\n    *   `v=2` is intermediate. `required_incoming_flow[2] -= 10`. Becomes `10 - 10 = 0`.\n    *   `required_incoming_flow[2] == 0`, so `q.append(2)`.\n*   Neighbor `(v=3, flow=5, idx=2)`:\n    *   `ans[2]` is `None`. `edges_info[2]` is `(3, 1)`. `u=1` is `edges_info[2][1]`. So, `ans[2] = 1` (direction `1 -> 3`).\n    *   `v=3` is the sink. No balance update.\n\n`q` is now `deque([2])`. `ans = [None, 0, 1]`\n\n**Iteration 2 (`u = 2`):**\n*   Neighbor `(v=3, flow=10, idx=0)`:\n    *   `ans[0]` is `None`. `edges_info[0]` is `(3, 2)`. `u=2` is `edges_info[0][1]`. So, `ans[0] = 1` (direction `2 -> 3`).\n    *   `v=3` is the sink. No balance update.\n*   Neighbor `(v=1, flow=10, idx=1)`:\n    *   `ans[1]` is `0` (already directed `1 -> 2`). Skip.\n\n`q` is now `deque([])`. Loop ends.\nFinal `ans = [1, 0, 1]`. This matches the example output.\n\n```python\nimport collections\nimport sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    # Store original edge info to determine direction output (0 or 1)\n    # edges_info[i] = (u_original, v_original) for i-th edge\n    edges_info = []\n    \n    # Adjacency list: adj[u] = list of (neighbor, flow_volume, edge_index)\n    adj = [[] for _ in range(n + 1)]\n    \n    # total_adj_flow[v] = sum of flow volumes of all edges incident to v\n    total_adj_flow = [0] * (n + 1)\n\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        edges_info.append((u, v))\n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n        total_adj_flow[u] += c\n        total_adj_flow[v] += c\n\n    # required_incoming_flow[v]:\n    # For intermediate nodes (1 < v < n), this is total_adj_flow[v] / 2.\n    # For source (v=1), it's 0.\n    # For sink (v=n), it's not directly used for balancing.\n    required_incoming_flow = [0] * (n + 1)\n    for v in range(2, n): # Only for intermediate nodes\n        required_incoming_flow[v] = total_adj_flow[v] // 2\n\n    # Queue for nodes ready to send out flow\n    q = collections.deque()\n    q.append(1) # Start with the source node\n\n    # ans[i] stores the direction of the i-th edge\n    # 0 means edges_info[i][0] -> edges_info[i][1]\n    # 1 means edges_info[i][1] -> edges_info[i][0]\n    ans = [None] * m\n\n    while q:\n        u = q.popleft()\n\n        # Iterate over neighbors of u\n        for v, flow, edge_idx in adj[u]:\n            if ans[edge_idx] is not None:\n                # This edge has already been directed\n                continue\n\n            # Direct the edge u -> v\n            original_u, original_v = edges_info[edge_idx]\n            if original_u == u:\n                ans[edge_idx] = 0 # Flow is u -> v\n            else: # original_v == u\n                ans[edge_idx] = 1 # Flow is u -> v (which means original_v -> original_u)\n\n            # Update required_incoming_flow for neighbor v if it's an intermediate node\n            if 1 < v < n:\n                required_incoming_flow[v] -= flow\n                if required_incoming_flow[v] == 0:\n                    # v has received all its required incoming flow, it's ready to send out\n                    q.append(v)\n            # If v is the sink (n), no action needed for required_incoming_flow.\n            # If v is the source (1), this path u->1 should not happen in a valid flow.\n\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + '\\n')\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import collections\nimport sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    # Store original edge info to determine direction output (0 or 1)\n    # edges_info[i] = (u_original, v_original) for i-th edge\n    edges_info = []\n    \n    # Adjacency list: adj[u] = list of (neighbor, flow_volume, edge_index)\n    adj = [[] for _ in range(n + 1)]\n    \n    # total_adj_flow[v] = sum of flow volumes of all edges incident to v\n    total_adj_flow = [0] * (n + 1)\n\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        edges_info.append((u, v))\n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n        total_adj_flow[u] += c\n        total_adj_flow[v] += c\n\n    # required_incoming_flow[v]:\n    # For intermediate nodes (1 < v < n), this is total_adj_flow[v] / 2.\n    # For source (v=1), it's 0.\n    # For sink (v=n), it's not directly used for balancing.\n    required_incoming_flow = [0] * (n + 1)\n    for v in range(2, n): # Only for intermediate nodes\n        required_incoming_flow[v] = total_adj_flow[v] // 2\n\n    # Queue for nodes ready to send out flow\n    q = collections.deque()\n    q.append(1) # Start with the source node\n\n    # ans[i] stores the direction of the i-th edge\n    # 0 means edges_info[i][0] -> edges_info[i][1]\n    # 1 means edges_info[i][1] -> edges_info[i][0]\n    ans = [None] * m\n\n    while q:\n        u = q.popleft()\n\n        # Iterate over neighbors of u\n        for v, flow, edge_idx in adj[u]:\n            if ans[edge_idx] is not None:\n                # This edge has already been directed\n                continue\n\n            # Direct the edge u -> v\n            original_u, original_v = edges_info[edge_idx]\n            if original_u == u:\n                ans[edge_idx] = 0 # Flow is u -> v\n            else: # original_v == u\n                ans[edge_idx] = 1 # Flow is u -> v (which means original_v -> original_u)\n\n            # Update required_incoming_flow for neighbor v if it's an intermediate node\n            if 1 < v < n:\n                required_incoming_flow[v] -= flow\n                if required_incoming_flow[v] == 0:\n                    # v has received all its required incoming flow, it's ready to send out\n                    q.append(v)\n            # If v is the sink (n), no action needed for required_incoming_flow.\n            # If v is the source (1), this path u->1 should not happen in a valid flow.\n\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + '\\n')\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 746,
        "completion_token_count": 3097,
        "thoughts_token_count": 7158
    }
}