{
    "start": 1758284905.1558468,
    "end": 1758284960.2399526,
    "start-formatted": "2025-09-19 21:28 KST",
    "end-formatted": "2025-09-19 21:29 KST",
    "gpu": 2,
    "pid": 44,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Polycarp's Practice\n\nPolycarp is practicing his problem solving skill. He has a list of $$$n$$$ problems with difficulties $$$a_1, a_2, \\dots, a_n$$$, respectively. His plan is to practice for exactly $$$k$$$ days. Each day he has to solve at least one problem from his list. Polycarp solves the problems in the order they are given in his list, he cannot skip any problem from his list. He has to solve all $$$n$$$ problems in exactly $$$k$$$ days.Thus, each day Polycarp solves a contiguous sequence of (consecutive) problems from the start of the list. He can't skip problems or solve them multiple times. As a result, in $$$k$$$ days he will solve all the $$$n$$$ problems.The profit of the $$$j$$$-th day of Polycarp's practice is the maximum among all the difficulties of problems Polycarp solves during the $$$j$$$-th day (i.e. if he solves problems with indices from $$$l$$$ to $$$r$$$ during a day, then the profit of the day is $$$\\max\\limits_{l \\le i \\le r}a_i$$$). The total profit of his practice is the sum of the profits over all $$$k$$$ days of his practice.You want to help Polycarp to get the maximum possible total profit over all valid ways to solve problems. Your task is to distribute all $$$n$$$ problems between $$$k$$$ days satisfying the conditions above in such a way, that the total profit is maximum.For example, if $$$n = 8, k = 3$$$ and $$$a = [5, 4, 2, 6, 5, 1, 9, 2]$$$, one of the possible distributions with maximum total profit is: $$$[5, 4, 2], [6, 5], [1, 9, 2]$$$. Here the total profit equals $$$5 + 6 + 9 = 20$$$.\n\n## Input\nThe first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\le k \\le n \\le 2000$$$) — the number of problems and the number of days, respectively.The second line of the input contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le 2000$$$) — difficulties of problems in Polycarp's list, in the order they are placed in the list (i.e. in the order Polycarp will solve them).\n\n## Output\nIn the first line of the output print the maximum possible total profit.In the second line print exactly $$$k$$$ positive integers $$$t_1, t_2, \\dots, t_k$$$ ($$$t_1 + t_2 + \\dots + t_k$$$ must equal $$$n$$$), where $$$t_j$$$ means the number of problems Polycarp will solve during the $$$j$$$-th day in order to achieve the maximum possible total profit of his practice.If there are many possible answers, you may print any of them.\n\n## Example\n### Input\n['8 3\\n5 4 2 6 5 1 9 2', '5 1\\n1 1 1 1 1', '4 2\\n1 2000 2000 2']\n\n### Output\n['20\\n3 2 3', '1\\n5', '4000\\n2 2']\n\n## Note\nThe first example is described in the problem statement.In the second example there is only one possible distribution.In the third example the best answer is to distribute problems in the following way: $$$[1, 2000], [2000, 2]$$$. The total profit of this distribution is $$$2000 + 2000 = 4000$$$.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "**Tackling Polycarp's Practice: A Pythonic Solution**\n\nOkay, so I'm looking at this \"Polycarp's Practice\" problem, and my initial thought is: Python, definitely Python. It's got the list manipulation power I need here. Let's break down the problem. We've got *n* problems, *k* days, and an array *a* of problem difficulties. The goal is to maximize the total profit, which is the sum of the maximum difficulty solved on each day. Contiguous sequences, at least one problem per day, exactly *k* days... I see it.\n\nThe key to unlocking this problem is realizing that to *maximize* the sum of the daily maximums, I need to make each daily maximum as large as possible.  And the largest daily maximums I can possibly achieve come from the largest values in the *entire* input array *a*. If I can somehow assign the *k* largest difficulties to be the daily maximums, I've got the optimal solution. It's a greedy approach at heart.\n\nSo, here's the plan. First, I'll find the *k* largest values in *a*. Then, I'll identify their *indices* in the original array. This part is crucial for maintaining the problem order. Once I have those indices, I can sort them in ascending order. Those sorted indices will become the split points for my *k* days. \n\nLet's say the indices of the *k* largest values are `idx_1, idx_2, ..., idx_k`. The splitting is then: Day 1 goes from index 0 to `idx_1`, Day 2 from `idx_1 + 1` to `idx_2` and so on, until the last day that goes from `idx_{k-1} + 1` to the end of the array. The maximum difficulty for each day is guaranteed to be one of the *k* largest values, guaranteeing the maximum profit. \n\nThat gives me the answer: I can calculate the sum of those *k* largest values to get the maximum total profit, and I can output the lengths of each segment as the number of problems solved on each day. Piece of cake! Python, here I come!\n",
    "response": "The problem asks us to partition `n` problems, given as a list of difficulties `a_1, a_2, ..., a_n`, into `k` contiguous segments. Each segment represents problems solved on a single day. The profit for a day is the maximum difficulty among problems solved on that day. We need to maximize the total profit (sum of daily profits) and output the maximum profit along with the number of problems solved each day.\n\n**Key Insight:**\n\nTo maximize the sum of `k` daily maximums, we should try to make each daily maximum as large as possible. The largest possible values for daily maximums will come from the largest difficulties in the entire list `a`.\n\nConsider the `k` largest difficulties present in the entire list `a`. Let these be `M_1, M_2, ..., M_k`. If we can arrange our `k` daily segments such that each of these `k` values `M_i` becomes the maximum difficulty for one of the `k` days, then the total profit will be `sum(M_i)`. This sum is the absolute maximum possible total profit, because any daily profit cannot exceed the maximum difficulty solved on that day, and the sum of `k` such maximums cannot exceed the sum of the `k` largest difficulties available in the entire list `a`.\n\n**Strategy:**\n\n1.  **Identify the `k` largest difficulties:** Create pairs of `(difficulty, original_index)` for all problems. Sort these pairs in descending order based on difficulty. Take the top `k` pairs. The sum of their difficulties will be our maximum total profit.\n2.  **Determine split points:** The original indices of these `k` largest difficulties will serve as our split points. Sort these `k` indices in ascending order. Let these sorted indices be `idx_1, idx_2, ..., idx_k`.\n3.  **Construct segments:**\n    *   The first day will solve problems from index `0` up to `idx_1`. The number of problems is `idx_1 + 1`. The maximum difficulty for this day will be `a[idx_1]` (one of our `M` values).\n    *   The `j`-th day (for `1 < j <= k`) will solve problems from index `idx_{j-1} + 1` up to `idx_j`. The number of problems is `idx_j - idx_{j-1}`. The maximum difficulty for this day will be `a[idx_j]` (another `M` value).\n    *   The `k`-th day will solve problems from index `idx_{k-1} + 1` up to `n-1` (the end of the list). The number of problems is `n - (idx_{k-1} + 1)`. The maximum difficulty for this day will be `a[idx_k]` (which must be within this segment since `idx_k` is the last of the `k` chosen indices, and all problems after it are included in this last segment).\n\nThis strategy guarantees that each of the `k` largest difficulties `M_i` is the maximum within its respective segment because we explicitly place a segment boundary right after each of these `M_i` problems (except for the last one, which simply marks the end of its segment).\n\n**Example Walkthrough:**\n\n`n = 8, k = 3`, `a = [5, 4, 2, 6, 5, 1, 9, 2]`\n\n1.  **Pairs (difficulty, index):**\n    `(5,0), (4,1), (2,2), (6,3), (5,4), (1,5), (9,6), (2,7)`\n\n2.  **Sort by difficulty (descending) and take top `k=3`:**\n    *   `(9,6)`\n    *   `(6,3)`\n    *   `(5,0)` (or `(5,4)`. If there are ties in difficulty, any choice is fine. Let's pick `(5,0)` for now).\n    \n    Maximum total profit = `9 + 6 + 5 = 20`.\n\n3.  **Original indices of chosen problems:** `6, 3, 0`.\n\n4.  **Sort indices (ascending):** `0, 3, 6`. These are `idx_1=0, idx_2=3, idx_3=6`.\n\n5.  **Calculate daily problem counts (`t_j`):**\n    *   Day 1: Problems from index `0` to `idx_1=0`. Count: `idx_1 + 1 = 0 + 1 = 1`. (Problems: `[5]`)\n    *   Day 2: Problems from index `idx_1+1=1` to `idx_2=3`. Count: `idx_2 - idx_1 = 3 - 0 = 3`. (Problems: `[4, 2, 6]`)\n    *   Day 3: Problems from index `idx_2+1=4` to `n-1=7`. Count: `n - (idx_2 + 1) = 8 - (3 + 1) = 4`. (Problems: `[5, 1, 9, 2]`)\n\n    This gives `t = [1, 3, 4]`.\n    Total profit: `max(5) + max(4,2,6) + max(5,1,9,2) = 5 + 6 + 9 = 20`. This matches.\n\n    *Wait, the example output is `3 2 3` for `20`. My current choice of `(5,0)` leads to `1 3 4`. What if I picked `(5,4)` instead of `(5,0)`?*\n\n    Let's retry step 2 with `(5,4)`:\n    *   `(9,6)`\n    *   `(6,3)`\n    *   `(5,4)`\n\n    Indices: `6, 3, 4`. Sorted indices: `3, 4, 6`.\n    `idx_1=3, idx_2=4, idx_3=6`.\n\n    *   Day 1: Problems from `0` to `idx_1=3`. Count: `idx_1 + 1 = 3 + 1 = 4`. (Problems: `[5, 4, 2, 6]`)\n    *   Day 2: Problems from `idx_1+1=4` to `idx_2=4`. Count: `idx_2 - idx_1 = 4 - 3 = 1`. (Problems: `[5]`)\n    *   Day 3: Problems from `idx_2+1=5` to `n-1=7`. Count: `n - (idx_2 + 1) = 8 - (4 + 1) = 3`. (Problems: `[1, 9, 2]`)\n\n    This gives `t = [4, 1, 3]`. Total profit: `max(5,4,2,6) + max(5) + max(1,9,2) = 6 + 5 + 9 = 20`.\n    This is also a valid solution. The problem states \"If there are many possible answers, you may print any of them.\"\n\n    *What about the example output `3 2 3`?*\n    This implies indices `2, 4, 7`.\n    Problems: `[5, 4, 2], [6, 5], [1, 9, 2]`\n    Maxes: `5, 6, 9`. Sum = `20`.\n    The indices `2, 4, 7` correspond to `a[2]=2`, `a[4]=5`, `a[7]=2`. These are not the `k` largest elements.\n    However, `a[2]` is not the max of `[5,4,2]`. `a[0]=5` is.\n    `a[4]` is the max of `[6,5]`. `a[3]=6` is.\n    `a[7]` is not the max of `[1,9,2]`. `a[6]=9` is.\n\n    Ah, the example output `[5, 4, 2], [6, 5], [1, 9, 2]` means the *end index of each segment*.\n    Day 1 ends at index 2 (length 3).\n    Day 2 ends at index 4 (length 2).\n    Day 3 ends at index 7 (length 3).\n    The critical indices are `2, 4, 7`.\n    The maximums are `a[0]=5`, `a[3]=6`, `a[6]=9`.\n    These are indeed the 3 largest values from `a` (5, 6, 9).\n    The indices of these maximums are `0, 3, 6`.\n\n    My strategy:\n    1. Find `k` largest difficulties and their indices.\n    2. Sum difficulties for total profit.\n    3. Sort the *indices* of these `k` largest difficulties. Let them be `p_1, p_2, ..., p_k`.\n    4. The segment lengths are:\n        *   `t_1 = p_1 + 1`\n        *   `t_2 = p_2 - p_1`\n        *   ...\n        *   `t_j = p_j - p_{j-1}`\n        *   ...\n        *   `t_k = n - p_{k-1} - 1` (This is wrong. It should be `n - (p_{k-1} + 1)` which is `n - p_{k-1} - 1`). No, the last segment starts at `p_{k-1} + 1` and goes to `n-1`. The number of elements is `(n-1) - (p_{k-1} + 1) + 1 = n - p_{k-1} - 1`.\n        \n    Let's re-evaluate the segment lengths with `p_1, ..., p_k` being the sorted indices of the chosen `k` largest values.\n    `p_0 = -1` (conceptual start before index 0)\n    `t_j = p_j - p_{j-1}` for `j=1 ... k-1`\n    `t_k = n - 1 - p_{k-1}`. (This is `n - (p_{k-1} + 1)` problems, as the `k`-th segment starts at `p_{k-1}+1` and ends at `n-1`).\n\n    Let's use the indices `0, 3, 6` for `a = [5, 4, 2, 6, 5, 1, 9, 2]`.\n    `p_1 = 0, p_2 = 3, p_3 = 6`.\n    `t_1 = p_1 - (-1) = 0 - (-1) = 1`. (Problems `a[0]`)\n    `t_2 = p_2 - p_1 = 3 - 0 = 3`. (Problems `a[1]` to `a[3]`)\n    `t_3 = p_3 - p_2 = 6 - 3 = 3`. (Problems `a[4]` to `a[6]`)\n\n    This sums to `1 + 3 + 3 = 7`. This is not `n=8`.\n    The issue is that `p_j` marks the *position* of the maximum element for day `j`. The segment for day `j` ends at `p_j`.\n    So, the segment lengths are:\n    `t_1 = p_1 + 1` (problems from index 0 to `p_1`)\n    `t_2 = p_2 - p_1` (problems from index `p_1+1` to `p_2`)\n    ...\n    `t_j = p_j - p_{j-1}` (problems from index `p_{j-1}+1` to `p_j`)\n    ...\n    `t_k = n - (p_{k-1} + 1)` (problems from index `p_{k-1}+1` to `n-1`)\n    The last segment needs to cover all remaining problems up to `n-1`.\n    The *end indices* of the segments are `p_1, p_2, ..., p_{k-1}, n-1`.\n    Let's use `p_0 = -1` as a virtual start.\n    The segment lengths are: `(p_1 - p_0), (p_2 - p_1), ..., (p_{k-1} - p_{k-2}), (n-1 - p_{k-1})`.\n    This doesn't quite work because the `p_j` are indices of the *chosen maximums*, not necessarily the end of segments.\n\n    Let's refine:\n    1.  Collect `(value, original_index)` for all `a_i`.\n    2.  Sort these pairs by `value` in descending order.\n    3.  Take the top `k` pairs. Sum their `value`s for the total profit.\n    4.  Extract the `original_index`es from these `k` pairs. Let this list of indices be `critical_indices`.\n    5.  Sort `critical_indices` in ascending order.\n    6.  Now, we need to divide the problems into `k` days. Each day must contain at least one problem. The `critical_indices` mark problems that *must* be included in some day's segment, and ideally, they should be the maximum for that day.\n    \n    The simplest way to use `critical_indices` as split points is:\n    Day 1: Problems from `0` up to `critical_indices[0]`.\n    Day 2: Problems from `critical_indices[0] + 1` up to `critical_indices[1]`.\n    ...\n    Day `k-1`: Problems from `critical_indices[k-2] + 1` up to `critical_indices[k-1]`.\n    Day `k`: Problems from `critical_indices[k-1] + 1` up to `n-1`.\n\n    This partitioning ensures that each `a[critical_indices[j]]` is included in its own segment. Since `critical_indices[j]` is one of the `k` largest values, and we've isolated it into a segment that ends exactly at `critical_indices[j]` (for `j < k-1`), or contains it and continues to the end (for `j = k-1`), it will be the maximum for that segment (or at least one of the maximums, if there are other problems with the same difficulty in that segment).\n\n    Let `critical_indices` be `P = [p_0, p_1, ..., p_{k-1}]` after sorting.\n    The lengths `t_j` are:\n    `t_1 = p_0 + 1`\n    `t_2 = p_1 - p_0`\n    ...\n    `t_j = p_{j-1} - p_{j-2}` (for `j` from 2 to `k-1`)\n    `t_k = n - (p_{k-1} + 1)` (this is the number of problems from `p_{k-1} + 1` to `n-1`).\n\n    Let's re-apply to `a = [5, 4, 2, 6, 5, 1, 9, 2]`, `k=3`.\n    Chosen difficulties: `9, 6, 5`.\n    Their indices: `6, 3, 0`.\n    Sorted `critical_indices` `P = [0, 3, 6]`.\n    \n    `t_1 = P[0] + 1 = 0 + 1 = 1`. (Problems `a[0]`)\n    `t_2 = P[1] - P[0] = 3 - 0 = 3`. (Problems `a[1]` to `a[3]`)\n    `t_3 = n - (P[1] + 1) = 8 - (3 + 1) = 4`. (Problems `a[4]` to `a[7]`)\n    \n    Resulting `t` list: `[1, 3, 4]`.\n    Total problems: `1 + 3 + 4 = 8`. Correct.\n    Daily profits: `max(a[0])=5`, `max(a[1..3])=max(4,2,6)=6`, `max(a[4..7])=max(5,1,9,2)=9`.\n    Total profit: `5 + 6 + 9 = 20`. Correct.\n\n    This matches my earlier calculation and is a valid solution. The example output `3 2 3` is just *one* of the valid solutions. My strategy provides *a* valid solution.\n\n**Implementation Details:**\n\n*   Store `(difficulty, index)` pairs.\n*   Sort them.\n*   Extract `k` largest difficulties and their original indices.\n*   Sum difficulties for total profit.\n*   Sort the `k` indices.\n*   Calculate `t_j` values as described: `t_1 = indices[0] + 1`, `t_j = indices[j-1] - indices[j-2]` for `j=2...k-1`, and `t_k = n - 1 - indices[k-2]` (this is `n - (indices[k-1] + 1)`).\n    Let's use `prev_idx = -1`.\n    For `i` from `0` to `k-2`:\n        `current_idx = sorted_indices[i]`\n        `t_list.append(current_idx - prev_idx)`\n        `prev_idx = current_idx`\n    Finally, `t_list.append(n - 1 - prev_idx)`.\n\n    Let `sorted_indices` be `[p_0, p_1, ..., p_{k-1}]`.\n    `t_1 = p_0 - (-1) = p_0 + 1`\n    `t_2 = p_1 - p_0`\n    ...\n    `t_k = (n - 1) - p_{k-1}` (This is `n - 1 - p_{k-1}` problems, from `p_{k-1}+1` to `n-1` inclusive).\n\n    Let's re-verify the last segment length.\n    If the last split point is `p_{k-1}`, the last segment starts at `p_{k-1} + 1` and goes to `n-1`.\n    Number of elements = `(n-1) - (p_{k-1} + 1) + 1 = n - 1 - p_{k-1} - 1 + 1 = n - p_{k-1} - 1`.\n    This is incorrect for the `t_k` definition.\n    The sum of `t_j` must be `n`.\n    `t_1 = p_0 + 1`\n    `t_2 = p_1 - p_0`\n    ...\n    `t_{k-1} = p_{k-2} - p_{k-3}`\n    `t_k = n - (p_{k-1} + 1)` (This is the number of problems from `p_{k-1}+1` to `n-1`).\n    This is `n - 1 - p_{k-1}` problems.\n\n    Let's use the example `P = [0, 3, 6]` for `n=8, k=3`.\n    `t_1 = P[0] + 1 = 0 + 1 = 1`.\n    `t_2 = P[1] - P[0] = 3 - 0 = 3`.\n    `t_3 = P[2] - P[1] = 6 - 3 = 3`.\n    Sum = `1 + 3 + 3 = 7`. This is not `n=8`.\n\n    The issue is that `P` contains `k` indices. We need `k-1` split points to divide `n` items into `k` segments.\n    The `k` chosen problems are `a[p_0], a[p_1], ..., a[p_{k-1}]`.\n    We want to make sure each of these is the maximum of *some* day.\n    The most straightforward way is to make `a[p_0]` the max of day 1, `a[p_1]` the max of day 2, ..., `a[p_{k-1}]` the max of day `k`.\n\n    This means:\n    Day 1: problems `a[0]` to `a[p_0]`. Length `p_0 + 1`.\n    Day 2: problems `a[p_0+1]` to `a[p_1]`. Length `p_1 - p_0`.\n    ...\n    Day `k-1`: problems `a[p_{k-2}+1]` to `a[p_{k-1}]`. Length `p_{k-1} - p_{k-2}`.\n    Day `k`: problems `a[p_{k-1}+1]` to `a[n-1]`. Length `n - (p_{k-1} + 1)`.\n\n    Let's re-calculate `t_j` for `P = [0, 3, 6]` with `n=8, k=3`:\n    `t_1 = P[0] + 1 = 0 + 1 = 1`.\n    `t_2 = P[1] - P[0] = 3 - 0 = 3`.\n    `t_3 = n - (P[1] + 1) = 8 - (3 + 1) = 4`.\n    This gives `[1, 3, 4]`. Sum = `8`. Correct. This logic is sound.\n\n    The problem is that `P[k-1]` (which is `P[2]=6` in the example) does not necessarily mark the end of the `k-1`-th segment. It could be the maximum *within* the last segment. My previous attempt `t_3 = n - (P[1] + 1)` used `P[1]` as the last actual split point. This means `a[P[2]]` (which is `a[6]=9`) is *included* in the last segment, and it *is* the maximum of that segment.\n\n    So, the `k-1` split points are `p_0, p_1, ..., p_{k-2}`.\n    The last problem `a[p_{k-1}]` is simply guaranteed to be included in the last segment.\n    \n    The split points are effectively `p_0`, `p_1`, ..., `p_{k-2}`.\n    `t_1 = p_0 + 1`\n    `t_2 = p_1 - p_0`\n    ...\n    `t_{k-1} = p_{k-2} - p_{k-3}`\n    `t_k = n - (p_{k-2} + 1)` (This is problems from `p_{k-2} + 1` to `n-1`).\n\n    Let's use `P = [0, 3, 6]` for `n=8, k=3`.\n    The split points are `P[0]=0, P[1]=3`. (We need `k-1 = 2` split points).\n    `t_1 = P[0] + 1 = 0 + 1 = 1`.\n    `t_2 = P[1] - P[0] = 3 - 0 = 3`.\n    `t_3 = n - (P[1] + 1) = 8 - (3 + 1) = 4`.\n    This gives `[1, 3, 4]`. This is consistent and sums to `n`.\n\n    This is the most robust way to calculate `t_j` values.\n    `t_list = []`\n    `prev_idx = -1`\n    For `i` from `0` to `k-2`:\n        `current_idx = sorted_critical_indices[i]`\n        `t_list.append(current_idx - prev_idx)`\n        `prev_idx = current_idx`\n    `t_list.append(n - 1 - prev_idx)` (This is the count of problems from `prev_idx + 1` to `n-1`).\n\n    Let's test this with `P = [0, 3, 6]` and `n=8, k=3`.\n    `prev_idx = -1`\n    `i = 0`: `current_idx = P[0] = 0`. `t_list.append(0 - (-1)) = 1`. `prev_idx = 0`.\n    `i = 1`: `current_idx = P[1] = 3`. `t_list.append(3 - 0) = 3`. `prev_idx = 3`.\n    Loop ends (since `i` goes up to `k-2 = 1`).\n    `t_list.append(n - 1 - prev_idx) = 8 - 1 - 3 = 4`.\n    Final `t_list = [1, 3, 4]`. This seems correct and robust.\n\nFinal check on constraints: `1 <= k <= n <= 2000`. `a_i <= 2000`.\nTime complexity:\n*   Creating pairs: O(N)\n*   Sorting pairs: O(N log N)\n*   Extracting `k` indices: O(K)\n*   Sorting `k` indices: O(K log K)\n*   Calculating `t_j`: O(K)\nOverall: O(N log N) dominated by sorting. Given N=2000, N log N is fine.\n\n```python\nimport sys\n\ndef solve():\n    n, k = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    # Step 1: Create pairs of (difficulty, original_index)\n    # We need original_index to reconstruct segment lengths later.\n    problems_with_indices = []\n    for i in range(n):\n        problems_with_indices.append((a[i], i))\n\n    # Step 2: Sort problems by difficulty in descending order.\n    # If difficulties are equal, the order of indices doesn't matter for total profit,\n    # but it might change the specific t_j values. Any valid t_j is fine.\n    problems_with_indices.sort(key=lambda x: x[0], reverse=True)\n\n    # Step 3: Select the top k problems (those with the highest difficulties).\n    # Calculate the total profit and collect their original indices.\n    total_profit = 0\n    critical_indices = []\n    for i in range(k):\n        total_profit += problems_with_indices[i][0]\n        critical_indices.append(problems_with_indices[i][1])\n\n    # Step 4: Sort the collected indices in ascending order.\n    # These indices will determine the boundaries of our daily segments.\n    critical_indices.sort()\n\n    # Step 5: Calculate the number of problems for each day (t_j).\n    # The segments are formed by splitting *after* the first k-1 critical problems.\n    # The last segment will include the last critical problem and all subsequent problems up to n-1.\n    \n    t_values = []\n    prev_idx = -1 # Represents the index before the first problem (conceptually -1)\n\n    # For the first k-1 segments, the length is the difference between current critical index\n    # and the previous critical index (or -1 for the first one).\n    for i in range(k - 1):\n        current_idx = critical_indices[i]\n        t_values.append(current_idx - prev_idx)\n        prev_idx = current_idx\n    \n    # The last segment takes all remaining problems from prev_idx + 1 up to n-1.\n    # The number of problems is (n-1) - (prev_idx + 1) + 1 = n - 1 - prev_idx\n    t_values.append(n - 1 - prev_idx)\n\n    # Print the results\n    print(total_profit)\n    print(*(t_values))\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, k = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    # Step 1: Create pairs of (difficulty, original_index)\n    # We need original_index to reconstruct segment lengths later.\n    problems_with_indices = []\n    for i in range(n):\n        problems_with_indices.append((a[i], i))\n\n    # Step 2: Sort problems by difficulty in descending order.\n    # If difficulties are equal, the order of indices doesn't matter for total profit,\n    # but it might change the specific t_j values. Any valid t_j is fine.\n    problems_with_indices.sort(key=lambda x: x[0], reverse=True)\n\n    # Step 3: Select the top k problems (those with the highest difficulties).\n    # Calculate the total profit and collect their original indices.\n    total_profit = 0\n    critical_indices = []\n    for i in range(k):\n        total_profit += problems_with_indices[i][0]\n        critical_indices.append(problems_with_indices[i][1])\n\n    # Step 4: Sort the collected indices in ascending order.\n    # These indices will determine the boundaries of our daily segments.\n    critical_indices.sort()\n\n    # Step 5: Calculate the number of problems for each day (t_j).\n    # The segments are formed by splitting *after* the first k-1 critical problems.\n    # The last segment will include the last critical problem and all subsequent problems up to n-1.\n    \n    t_values = []\n    prev_idx = -1 # Represents the index before the first problem (conceptually -1)\n\n    # For the first k-1 segments, the length is the difference between current critical index\n    # and the previous critical index (or -1 for the first one).\n    for i in range(k - 1):\n        current_idx = critical_indices[i]\n        t_values.append(current_idx - prev_idx)\n        prev_idx = current_idx\n    \n    # The last segment takes all remaining problems from prev_idx + 1 up to n-1.\n    # The number of problems is (n-1) - (prev_idx + 1) + 1 = n - 1 - prev_idx\n    t_values.append(n - 1 - prev_idx)\n\n    # Print the results\n    print(total_profit)\n    print(*(t_values))\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 973,
        "completion_token_count": 6676,
        "thoughts_token_count": 832
    }
}