{
    "start": 1758009279.7098432,
    "end": 1758009323.556388,
    "start-formatted": "2025-09-16 16:54 KST",
    "end-formatted": "2025-09-16 16:55 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "**Thinking Through a Tricky Interval Problem**\n\nAlright, let's dive into this competitive programming problem. I've got to find two non-overlapping vouchers that add up to a specific duration, `x`, while keeping their combined cost as low as possible. If I can't find a pair that meets the criteria, I need to output -1. Straightforward, right? Well, with `n` and `x` potentially hitting 2 * 10^5, brute force is out the window. That `O(n^2)` approach will be a non-starter. I need to be smarter, aiming for something closer to `O(n log n)` or ideally, `O(n)`.\n\nI'm thinking, let's break this down piece by piece. First, I need to get a handle on the input: `n`, `x`, and all the voucher details (`li`, `ri`, `costi`). Calculating the duration of each voucher (`ri - li + 1`) is simple enough. The critical part is the non-overlapping condition. It means the vouchers either completely finish before the other starts. Mathematically, this boils down to `ri < lj` or `rj < li`.\n\nThe core of the problem is minimizing the sum of costs (`cost_i + cost_j`) while satisfying the duration requirement (`(ri - li + 1) + (rj - lj + 1) = x`) and the non-overlapping constraint.\n\nMy mind is racing. I can fix one voucher and then hunt for the best partner. Let's fix voucher `i`. If `d_i` is its duration, then the other voucher `j`'s duration `d_j` *must* be `x - d_i`. I'll also need to consider the non-overlapping criteria, which translates to finding a voucher `j` that's either completely before or completely after `i`.\n\nThe upper bound on `li` and `ri` is 2 * 10^5, which is interesting. It suggests that there *might* be a day-based data structure in play. Now, to make this efficient, I can consider iterating over all vouchers `i` and trying to locate the optimal `j`. The key is to somehow sort or structure the vouchers to facilitate an efficient search for this ideal `j`.\n\nA standard technique for non-overlapping interval problems is to sort either by start time or end time. Maybe that's the way to go. Suppose I sort them by their start days, `li`. With a voucher `i`, I need a `j` with the right duration. I have to think about which of these durations can actually be combined, but I see a path emerging. I'm going to sort by starting time `li` and try to move from there. Let's see how this plays out...\n",
    "response": "The problem asks us to find two non-overlapping vouchers `i` and `j` such that the sum of their durations is exactly `x`, and their total cost `cost_i + cost_j` is minimized.\n\nLet's define the duration of a voucher `k` as `duration_k = r_k - l_k + 1`.\nTwo vouchers `i` and `j` don't intersect if `r_i < l_j` or `r_j < l_i`. This means one voucher must end strictly before the other begins.\n\nThe constraints are `n, x, l_i, r_i <= 2 * 10^5`, and `cost_i <= 10^9`. An `O(N^2)` solution is too slow. We need something closer to `O(N log N)` or `O(N)`.\n\nWe can iterate through each voucher `i` and try to find the best matching voucher `j`. For a fixed voucher `i`, its duration is `d_i = r_i - l_i + 1`. We need to find a voucher `j` with duration `d_j = x - d_i`. If `d_j <= 0`, then no such `j` exists for this `i`.\n\nThe non-overlapping condition `r_i < l_j` or `r_j < l_i` suggests processing intervals based on their start or end times. Let's consider processing all vouchers.\n\n**Algorithm Idea:**\nWe can iterate through all possible end days `ri` for the first voucher. For each `ri`, we want to find the best second voucher `j` that starts after `ri`.\n\nLet's group vouchers by their start day `l_i`. We can use an array of lists, `vouchers_by_start_day[day]`, where each list contains `(r_k, cost_k, duration_k)` for vouchers starting on `day`.\n\nWe will maintain an auxiliary data structure, say `min_cost_for_duration[duration]`, which stores the minimum cost of a voucher with that specific `duration` encountered so far. Initialize `min_cost_for_duration` with infinity for all durations. The maximum possible duration is `MAX_COORD = 2 * 10^5`.\n\nWe iterate through the days `d` from `1` to `MAX_COORD`:\n1.  **Update `min_cost_for_duration`**: For all vouchers `(l_k, r_k, cost_k)` that *end* on `d-1` (i.e., `r_k = d-1`), we can consider them as candidates for the \"first\" voucher. We update `min_cost_for_duration[duration_k]` with `cost_k` if `cost_k` is smaller than the current value.\n    To efficiently retrieve vouchers ending on `d-1`, we can pre-process all vouchers and store them in an array of lists, `vouchers_by_end_day[day]`, similar to `vouchers_by_start_day`.\n\n2.  **Find best pair**: For all vouchers `(l_j, r_j, cost_j)` that *start* on `d` (i.e., `l_j = d`), these are potential \"second\" vouchers. For each such voucher `j`:\n    a.  Calculate its duration `d_j = r_j - l_j + 1`.\n    b.  Calculate the required duration for the first voucher: `d_i = x - d_j`.\n    c.  If `d_i > 0` and `min_cost_for_duration[d_i]` is not infinity, it means we have previously encountered a voucher `i` with duration `d_i` that ends before `l_j` (specifically, its `r_i` was `d-1` or earlier).\n    d.  The total cost for this pair `(i, j)` would be `min_cost_for_duration[d_i] + cost_j`. Update the overall minimum total cost found so far.\n\nThe overall minimum cost will be the answer. If no such pair is found, it remains infinity, and we print -1.\n\n**Detailed Steps:**\n1.  Initialize `min_total_cost = infinity` (e.g., `float('inf')`).\n2.  Create two lists of lists (or dictionaries mapping day to list of vouchers):\n    *   `vouchers_ending_on[day]`: Stores `(cost_k, duration_k)` for vouchers that end on `day`.\n    *   `vouchers_starting_on[day]`: Stores `(cost_k, duration_k)` for vouchers that start on `day`.\n    The maximum day coordinate is `MAX_COORD = 2 * 10^5`. So, arrays of size `MAX_COORD + 1` are suitable.\n3.  Populate `vouchers_ending_on` and `vouchers_starting_on`:\n    For each input voucher `(l, r, cost)`:\n    `duration = r - l + 1`\n    `vouchers_ending_on[r].append((cost, duration))`\n    `vouchers_starting_on[l].append((cost, duration))`\n4.  Initialize `min_cost_for_duration = array of size (MAX_COORD + 1)` with `infinity`. This array will store the minimum cost of a voucher with a given duration that has *already ended*.\n5.  Iterate `current_day` from `1` to `MAX_COORD`:\n    a.  **Process vouchers ending on `current_day - 1`**:\n        For each `(cost_k, duration_k)` in `vouchers_ending_on[current_day - 1]`:\n            `min_cost_for_duration[duration_k] = min(min_cost_for_duration[duration_k], cost_k)`\n    b.  **Process vouchers starting on `current_day`**:\n        For each `(cost_j, duration_j)` in `vouchers_starting_on[current_day]`:\n            `required_duration_i = x - duration_j`\n            If `1 <= required_duration_i <= MAX_COORD` and `min_cost_for_duration[required_duration_i]` is not infinity:\n                `min_total_cost = min(min_total_cost, min_cost_for_duration[required_duration_i] + cost_j)`\n6.  Finally, if `min_total_cost` is still `infinity`, print `-1`. Otherwise, print `min_total_cost`.\n\n**Example Walkthrough (First Sample):**\n`n=4, x=5`\nVouchers: `(1,3,4), (1,2,5), (5,6,1), (1,2,4)`\n\n`MAX_COORD = 6`\n`vouchers_ending_on = [[] for _ in range(7)]`\n`vouchers_starting_on = [[] for _ in range(7)]`\n`min_cost_for_duration = [inf for _ in range(7)]`\n`min_total_cost = inf`\n\nPopulate `vouchers_ending_on` and `vouchers_starting_on`:\nVoucher (1,3,4): dur=3. `v_end[3].append((4,3))`, `v_start[1].append((4,3))`\nVoucher (1,2,5): dur=2. `v_end[2].append((5,2))`, `v_start[1].append((5,2))`\nVoucher (5,6,1): dur=2. `v_end[6].append((1,2))`, `v_start[5].append((1,2))`\nVoucher (1,2,4): dur=2. `v_end[2].append((4,2))`, `v_start[1].append((4,2))`\n\nSorted by day:\n`v_end`: `[[], [], [(5,2), (4,2)], [(4,3)], [], [], [(1,2)]]`\n`v_start`: `[[], [(4,3), (5,2), (4,2)], [], [], [], [(1,2)], []]`\n\nIterate `current_day` from 1 to 6:\n\n`current_day = 1`:\n  `v_end[0]` is empty. `min_cost_for_duration` unchanged.\n  `v_start[1]`:\n    `(cost=4, dur=3)`: `req_dur_i = 5-3=2`. `min_cost_for_duration[2]` is `inf`. No update.\n    `(cost=5, dur=2)`: `req_dur_i = 5-2=3`. `min_cost_for_duration[3]` is `inf`. No update.\n    `(cost=4, dur=2)`: `req_dur_i = 5-2=3`. `min_cost_for_duration[3]` is `inf`. No update.\n\n`current_day = 2`:\n  `v_end[1]` is empty. `min_cost_for_duration` unchanged.\n  `v_start[2]` is empty.\n\n`current_day = 3`:\n  `v_end[2]`:\n    `(cost=5, dur=2)`: `min_cost_for_duration[2] = min(inf, 5) = 5`.\n    `(cost=4, dur=2)`: `min_cost_for_duration[2] = min(5, 4) = 4`.\n  `v_start[3]` is empty.\n  `min_cost_for_duration = [inf, inf, 4, inf, inf, inf, inf]`\n\n`current_day = 4`:\n  `v_end[3]`:\n    `(cost=4, dur=3)`: `min_cost_for_duration[3] = min(inf, 4) = 4`.\n  `v_start[4]` is empty.\n  `min_cost_for_duration = [inf, inf, 4, 4, inf, inf, inf]`\n\n`current_day = 5`:\n  `v_end[4]` is empty. `min_cost_for_duration` unchanged.\n  `v_start[5]`:\n    `(cost=1, dur=2)`: `req_dur_i = 5-2=3`. `min_cost_for_duration[3]` is `4`.\n      `min_total_cost = min(inf, 4 + 1) = 5`.\n\n`current_day = 6`:\n  `v_end[5]` is empty. `min_cost_for_duration` unchanged.\n  `v_start[6]` is empty.\n\nFinal `min_total_cost = 5`.\n\n**Time Complexity:**\n*   Populating `vouchers_ending_on` and `vouchers_starting_on`: `O(N)`\n*   Iterating `current_day` from 1 to `MAX_COORD`: `O(MAX_COORD)` iterations.\n    *   Inside the loop, processing `vouchers_ending_on[current_day - 1]` and `vouchers_starting_on[current_day]` takes time proportional to the number of vouchers on that day.\n    *   The total number of vouchers across all days in `vouchers_ending_on` is `N`. Same for `vouchers_starting_on`.\n    *   Each update to `min_cost_for_duration` and `min_total_cost` is `O(1)`.\nTotal time complexity: `O(N + MAX_COORD)`. Given `N, MAX_COORD <= 2 * 10^5`, this is efficient enough.\n\n**Space Complexity:**\n*   `vouchers_ending_on`, `vouchers_starting_on`: `O(N + MAX_COORD)` to store all vouchers and the day lists.\n*   `min_cost_for_duration`: `O(MAX_COORD)`\nTotal space complexity: `O(N + MAX_COORD)`.\n\nThis approach correctly handles the non-overlapping condition because when we consider a voucher `j` starting on `current_day`, any voucher `i` whose cost is in `min_cost_for_duration` must have ended on or before `current_day - 1`. This ensures `r_i < l_j`.\n\n```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n\n    MAX_COORD = 2 * 10**5\n    \n    # vouchers_ending_on[day] stores (cost, duration) for vouchers that end on 'day'\n    vouchers_ending_on = [[] for _ in range(MAX_COORD + 1)]\n    # vouchers_starting_on[day] stores (cost, duration) for vouchers that start on 'day'\n    vouchers_starting_on = [[] for _ in range(MAX_COORD + 1)]\n\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        duration = r - l + 1\n        vouchers_ending_on[r].append((cost, duration))\n        vouchers_starting_on[l].append((cost, duration))\n\n    # min_cost_for_duration[d] stores the minimum cost of a voucher\n    # with duration 'd' that has already ended by the current day (current_day - 1).\n    min_cost_for_duration = [float('inf')] * (MAX_COORD + 1)\n\n    min_total_cost = float('inf')\n\n    # Iterate through each possible day from 1 to MAX_COORD\n    for current_day in range(1, MAX_COORD + 1):\n        \n        # Step 1: Update min_cost_for_duration with vouchers that ended on (current_day - 1)\n        # These vouchers are candidates for the \"first\" voucher.\n        if current_day > 1: # Only process if current_day - 1 is a valid day\n            for cost_k, duration_k in vouchers_ending_on[current_day - 1]:\n                min_cost_for_duration[duration_k] = min(min_cost_for_duration[duration_k], cost_k)\n        \n        # Step 2: For vouchers starting on current_day, try to find a matching \"first\" voucher\n        # These are candidates for the \"second\" voucher.\n        for cost_j, duration_j in vouchers_starting_on[current_day]:\n            required_duration_i = x - duration_j\n            \n            # Check if the required duration is valid (positive and within bounds)\n            if 1 <= required_duration_i <= MAX_COORD:\n                # If we found a suitable first voucher that ended before current_day\n                if min_cost_for_duration[required_duration_i] != float('inf'):\n                    min_total_cost = min(min_total_cost, min_cost_for_duration[required_duration_i] + cost_j)\n\n    if min_total_cost == float('inf'):\n        sys.stdout.write(\"-1\\n\")\n    else:\n        sys.stdout.write(str(int(min_total_cost)) + \"\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n\n    MAX_COORD = 2 * 10**5\n    \n    # vouchers_ending_on[day] stores (cost, duration) for vouchers that end on 'day'\n    vouchers_ending_on = [[] for _ in range(MAX_COORD + 1)]\n    # vouchers_starting_on[day] stores (cost, duration) for vouchers that start on 'day'\n    vouchers_starting_on = [[] for _ in range(MAX_COORD + 1)]\n\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        duration = r - l + 1\n        vouchers_ending_on[r].append((cost, duration))\n        vouchers_starting_on[l].append((cost, duration))\n\n    # min_cost_for_duration[d] stores the minimum cost of a voucher\n    # with duration 'd' that has already ended by the current day (current_day - 1).\n    min_cost_for_duration = [float('inf')] * (MAX_COORD + 1)\n\n    min_total_cost = float('inf')\n\n    # Iterate through each possible day from 1 to MAX_COORD\n    for current_day in range(1, MAX_COORD + 1):\n        \n        # Step 1: Update min_cost_for_duration with vouchers that ended on (current_day - 1)\n        # These vouchers are candidates for the \"first\" voucher.\n        if current_day > 1: # Only process if current_day - 1 is a valid day\n            for cost_k, duration_k in vouchers_ending_on[current_day - 1]:\n                min_cost_for_duration[duration_k] = min(min_cost_for_duration[duration_k], cost_k)\n        \n        # Step 2: For vouchers starting on current_day, try to find a matching \"first\" voucher\n        # These are candidates for the \"second\" voucher.\n        for cost_j, duration_j in vouchers_starting_on[current_day]:\n            required_duration_i = x - duration_j\n            \n            # Check if the required duration is valid (positive and within bounds)\n            if 1 <= required_duration_i <= MAX_COORD:\n                # If we found a suitable first voucher that ended before current_day\n                if min_cost_for_duration[required_duration_i] != float('inf'):\n                    min_total_cost = min(min_total_cost, min_cost_for_duration[required_duration_i] + cost_j)\n\n    if min_total_cost == float('inf'):\n        sys.stdout.write(\"-1\\n\")\n    else:\n        sys.stdout.write(str(int(min_total_cost)) + \"\\n\")\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 799,
        "completion_token_count": 3548,
        "thoughts_token_count": 737
    }
}