{
    "start": 1758284940.0543864,
    "end": 1758284991.976526,
    "start-formatted": "2025-09-19 21:29 KST",
    "end-formatted": "2025-09-19 21:29 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "**Initial Thoughts and Problem Decomposition**\n\nOkay, so I'm tackling this \"Mushroom Strife\" problem. The core is figuring out the mushroom count on each lawn, given some constraints based on GCDs and LCMs across connecting roads. I need a Python solution, naturally.\n\nFirst, I need to really understand what's going on. We have `n` lawns, or vertices in a graph, and `m` roads, or edges. Each edge gives me the GCD and LCM of the mushroom counts on the connected lawns. I'm after the mushroom count for each lawn, ranging from 1 to 10^6. The catch is that there might be no valid assignment.\n\n**Key Property & Mathematical Formulation**\n\nRight, the key is knowing that the product of the GCD and LCM of two numbers always equals their product: `GCD(x,y) * LCM(x,y) = x * y`.  Let's call the mushroom counts `a` and `b` for two connected lawns. With given `g = GCD(a,b)` and `l = LCM(a,b)`, we get `g * l = a * b`.\n\nThen, I'm thinking, `a` and `b` must both be multiples of `g`.  So, I can rewrite them as `a = g * A` and `b = g * B`, where `A` and `B` are coprime (their GCD is 1). Substituting this into `g * l = a * b`, gives us `g*l = g^2 * A * B`, which simplifies to `l = g * A * B`.  Then, `A * B = l / g`. This is crucial.\n\n**Constraint and Implications**\n\nThis tells me that for any two connected lawns `u` and `v` with mushrooms `a_u` and `a_v`:\n1.  `a_u` and `a_v` need to be multiples of `g`.\n2.  `a_u * a_v = g * l`.\n3.  `LCM(a_u, a_v) = l` (and this is implied).\nAlso, if `l` isn't divisible by `g`, that's a dead end – no solution exists for that edge.\n\nThe constraint of `1 <= a_i <= 10^6`, and `1 <= g, l <= 10^6` is definitely important. If `l` is not divisible by `g`, there can be no solution. If it is divisible, then I'm looking for factors of `l/g`, and they must be coprime.\n\n**Graph Structure and Approach**\n\nThe lawns and roads naturally form a graph structure.  The graph can be disconnected, which means I can tackle each component individually.\n\nMy initial thought for a solution is iterative. I'll need some kind of `ans` array to hold the mushroom counts. I'll initialize it with placeholders and then iteratively assign values, constrained by those GCD and LCM conditions. It's almost like a constraint propagation problem.  Perhaps I can maintain a set of potential values for each lawn and shrink it as I process edges.\n",
    "response": "```python\nimport sys\nimport math\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    if n == 0:\n        print(\"YES\")\n        print()\n        return\n\n    adj = [[] for _ in range(n + 1)]\n    edges = []\n\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        edges.append((u, v, g, l))\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l))\n\n    # ans[i] stores the determined number of mushrooms for lawn i.\n    # Initially, all are 0 (unknown).\n    ans = [0] * (n + 1)\n    \n    # Store the prime factors and their exponents for each number.\n    # precompute_factors[k] = {p1: e1, p2: e2, ...} for k.\n    precompute_factors = [None] * (10**6 + 1)\n\n    # Function to get prime factors of a number\n    def get_prime_factors(num):\n        if num == 0: return {} # Handle 0 case if needed, but numbers are >=1\n        if num == 1: return {}\n        if precompute_factors[num] is not None:\n            return precompute_factors[num]\n\n        factors = {}\n        d = 2\n        temp = num\n        while d * d <= temp:\n            while temp % d == 0:\n                factors[d] = factors.get(d, 0) + 1\n                temp //= d\n            d += 1\n        if temp > 1:\n            factors[temp] = factors.get(temp, 0) + 1\n        precompute_factors[num] = factors\n        return factors\n\n    # Function to reconstruct number from prime factors\n    def reconstruct_num(factors_dict):\n        num = 1\n        for p, e in factors_dict.items():\n            num *= (p ** e)\n        return num\n\n    # Function to check if a divides b\n    def divides(a, b):\n        return b % a == 0\n\n    # Function to calculate GCD of two numbers from their factorizations\n    def calculate_gcd_factors(factors1, factors2):\n        gcd_factors = {}\n        for p in factors1:\n            if p in factors2:\n                gcd_factors[p] = min(factors1[p], factors2[p])\n        return reconstruct_num(gcd_factors)\n\n    # Function to calculate LCM of two numbers from their factorizations\n    def calculate_lcm_factors(factors1, factors2):\n        lcm_factors = {}\n        for p in factors1:\n            lcm_factors[p] = factors1[p]\n        for p in factors2:\n            lcm_factors[p] = max(lcm_factors.get(p, 0), factors2[p])\n        return reconstruct_num(lcm_factors)\n\n    # Main loop for processing connected components\n    for start_node in range(1, n + 1):\n        if ans[start_node] != 0: # Already processed\n            continue\n\n        # For each connected component, we need to determine the 'base' prime factorization.\n        # This is represented by `current_factors_base[p] = (min_exp, max_exp)`\n        # for each prime `p`.\n        # `ans[i]` will be `reconstruct_num(current_factors_base)` for some `i`,\n        # but `ans[i]` itself stores the actual value.\n        \n        # `node_factor_info[u]` stores the prime factorization for `a_u`.\n        # Each `a_u` is represented as a dictionary {p: exponent}.\n        # `a_u` = `base_value` * `relative_factors_u`.\n        # We need to determine `base_value` and `relative_factors_u`.\n        # `relative_factors_u` is a dict {p: exponent_diff} which will be relative to `a_start_node`.\n        \n        # We will use a BFS/DFS to traverse the component.\n        # For the first node in the component (`start_node`), we can initially assume\n        # its value is 1 (or any valid value), and then adjust it later.\n        # A better approach: for each node `u`, we will store `a_u_factors` which is\n        # a dictionary of prime factors and their exponents.\n        # We also need to keep track of the `a_u_factors` for all nodes in the component.\n\n        # `node_factors[u]` will store the prime factorization of `a_u`.\n        # Initially, it's unknown for all nodes.\n        # When we process a node `u` and determine its `node_factors[u]`,\n        # we can propagate this information.\n        \n        # Let's try a different approach. For each prime `p`, we want to find its exponent\n        # in `a_i`. Let `exp_p[i]` be the exponent of `p` in `a_i`.\n        # For an edge (u, v, g, l), let `exp_p_g` be exponent of `p` in `g`,\n        # and `exp_p_l` be exponent of `p` in `l`.\n        # We know `min(exp_p[u], exp_p[v]) = exp_p_g`\n        # We know `max(exp_p[u], exp_p[v]) = exp_p_l`\n        # This means for each prime `p`:\n        # `{exp_p[u], exp_p[v]} = {exp_p_g, exp_p_l}` as a set.\n        # So, `exp_p[u] + exp_p[v] = exp_p_g + exp_p_l`.\n\n        # We can use BFS/DFS. For the first node `start_node` in a component,\n        # we can arbitrarily assign `exp_p[start_node]` to be `exp_p_g` for some edge\n        # (start_node, neighbor, g, l). Then `exp_p[neighbor]` would be `exp_p_l`.\n        # Or, we can assign `exp_p[start_node]` to be `exp_p_l`, then `exp_p[neighbor]` would be `exp_p_g`.\n        # This suggests a 2-coloring type problem for exponents.\n        # For each prime `p`, and for each connected component:\n        # We can define `x_i` as `exp_p[i] - exp_p_g_ref` for some reference `g`.\n        # Or more simply, `exp_p[i]` can be `base_exp_p + offset_p[i]`.\n        # `offset_p[i]` would be 0 or 1, depending on which of `exp_p_g` or `exp_p_l` it takes.\n\n        # Let's define `diff[u]` as the exponent difference relative to `start_node`.\n        # `exp_p[u] = exp_p[start_node] + diff[u]`.\n        # For an edge (u, v, g, l):\n        # `min(exp_p[u], exp_p[v]) = exp_p_g`\n        # `max(exp_p[u], exp_p[v]) = exp_p_l`\n        # We can't directly assign `exp_p[start_node]` because it could be different for different primes.\n\n        # Let's assign `a_start_node` to be 1 initially. This is a bad idea, as it might\n        # violate `g | a_start_node`.\n        # A better way is to determine `a_start_node` based on its neighbors.\n        # For each prime `p`, we need to determine `exp_p[i]` for all `i` in the component.\n\n        # For a connected component, fix an arbitrary node `u` in it.\n        # For each prime `p`, we can iterate through the component using BFS/DFS.\n        # `exp_p_val[i]` stores the exponent of `p` for node `i`.\n        # `exp_p_val[i]` can be `exp_p_g` or `exp_p_l` for an edge.\n        # We can try to assign a value to `exp_p_val[start_node]` for each prime `p`.\n        # The range of possible values for `exp_p_val[i]` is `[0, log_p(10^6)]`.\n        \n        # Let's try setting `ans[start_node]` to a specific value and propagate.\n        # What value? For an edge (u, v, g, l), if `g` does not divide `l`, it's impossible.\n        # `l % g == 0` must hold.\n        # Let `X = l / g`. We need `a_u = g * A`, `a_v = g * B` such that `A * B = X` and `GCD(A, B) = 1`.\n        # This means `A` and `B` must be coprime factors of `X`.\n        # For any prime `p` dividing `X`, `p` must divide either `A` or `B`, but not both.\n        # So, for each prime factor `p` of `X`, its entire exponent `exp_p_X` must go to either `A` or `B`.\n        # This means `a_u` must be `g * (product of some prime powers of X)`\n        # and `a_v` must be `g * (product of remaining prime powers of X)`.\n        \n        # We can represent `a_u` as `g_u * P_u` where `P_u` is a product of prime powers.\n        # For an edge `(u, v, g, l)`:\n        # `a_u = g * A`, `a_v = g * B` where `A * B = l/g` and `GCD(A,B)=1`.\n        # This means `a_u` must be a multiple of `g`, and `a_v` must be a multiple of `g`.\n        # Also, `a_u` must divide `l`, and `a_v` must divide `l`.\n        # More specifically, `lcm(a_u, a_v) = l`.\n        # This implies `a_u` must be of the form `g * \\prod p_i^{e_i}` where `p_i^{e_i}` are prime powers that divide `l/g`.\n        # And `a_v` must be of the form `g * \\prod p_j^{f_j}` where `p_j^{f_j}` are the remaining prime powers.\n\n        # Let `factors_g = get_prime_factors(g)` and `factors_l = get_prime_factors(l)`.\n        # For each prime `p`, let `exp_g = factors_g.get(p, 0)` and `exp_l = factors_l.get(p, 0)`.\n        # Then `exp_p[u]` and `exp_p[v]` must be `exp_g` and `exp_l` in some order.\n        # That is, `{exp_p[u], exp_p[v]} = {exp_g, exp_l}` as a set.\n        # This implies `exp_p[u] + exp_p[v] = exp_g + exp_l`.\n\n        # This is a 2-coloring problem for each prime `p` independently.\n        # For each prime `p` that appears in any `g` or `l` in the component:\n        # We need to assign `exp_p[i]` for each node `i` in the component.\n        # `exp_p[i]` can be `exp_g` or `exp_l` from an edge (i, j, g, l).\n        # Let's define `relative_exp_p[i]` for node `i` in a component.\n        # `relative_exp_p[i]` is 0 or 1.\n        # For an edge (u, v, g, l), let `exp_g = factors_g.get(p, 0)` and `exp_l = factors_l.get(p, 0)`.\n        # If `relative_exp_p[u] == 0`, then `exp_p[u]` is `exp_g`.\n        # If `relative_exp_p[u] == 1`, then `exp_p[u]` is `exp_l`.\n        # This is incorrect. The exponents are not fixed to `exp_g` or `exp_l` globally.\n        # They are fixed *relative to each other* for an edge.\n\n        # Correct approach for 2-coloring:\n        # For each prime `p`:\n        #   Create a graph where nodes are `1..n`.\n        #   For each edge `(u, v, g, l)`:\n        #     `exp_g = get_prime_factors(g).get(p, 0)`\n        #     `exp_l = get_prime_factors(l).get(p, 0)`\n        #     If `exp_g > exp_l`, this is invalid (GCD must be <= LCM).\n        #     If `exp_g == exp_l`, then `exp_p[u]` must be `exp_g` and `exp_p[v]` must be `exp_g`.\n        #       This means all nodes in this connected component must have `exp_g` for prime `p`.\n        #     If `exp_g < exp_l`:\n        #       Then `{exp_p[u], exp_p[v]} = {exp_g, exp_l}`.\n        #       We can assign `exp_p[u] = exp_g` and `exp_p[v] = exp_l`, OR `exp_p[u] = exp_l` and `exp_p[v] = exp_g`.\n        #       This is a 2-coloring problem.\n        #       Let `offset[i]` be 0 or 1.\n        #       If `offset[i] == 0`, `exp_p[i]` takes the \"smaller\" value (`exp_g` for some edge).\n        #       If `offset[i] == 1`, `exp_p[i]` takes the \"larger\" value (`exp_l` for some edge).\n        #       This is still tricky because `exp_g` and `exp_l` vary per edge.\n\n        # Let's try to determine `a_i` directly.\n        # `ans[i]` stores the value of `a_i`.\n        # `lower_bound[i]` and `upper_bound[i]` for `a_i`.\n        # This is too complex. The 2-coloring for each prime exponent is the standard approach for this kind of problem.\n\n        # Let `component_nodes` be the list of nodes in the current connected component.\n        # For each node `i` in `component_nodes`, `a_i` must be a value `[1, 10^6]`.\n        # For each prime `p` up to `10^6`:\n        # `exp_for_prime[p][i]` will store the exponent of `p` in `a_i`.\n        # Initialize `exp_for_prime` with -1 (unknown).\n\n        # Collect all unique primes involved in the current component\n        component_primes = set()\n        for u in range(1, n + 1):\n            if ans[u] == 0: # Only consider nodes not yet processed\n                for v, g, l in adj[u]:\n                    if ans[v] == 0:\n                        if not divides(g, l):\n                            print(\"NO\")\n                            return\n                        for p in get_prime_factors(g): component_primes.add(p)\n                        for p in get_prime_factors(l): component_primes.add(p)\n        \n        # For each prime `p`, we will try to assign exponents to nodes in the current component.\n        # `exp_val[i]` will store the exponent of `p` for node `i`.\n        # `exp_val[i]` is initialized to -1 (unknown).\n        # `color[i]` will store 0 or 1 for bipartite graph coloring.\n        # `color[i] = 0` means `exp_val[i]` takes the 'base' exponent.\n        # `color[i] = 1` means `exp_val[i]` takes the 'flipped' exponent.\n        \n        # `prime_exp_assignments[p][i]` stores the exponent of prime `p` for node `i`.\n        prime_exp_assignments = {p: [-1] * (n + 1) for p in component_primes}\n\n        # `bipartite_color[i]` stores the color (0 or 1) for node `i` in the bipartite graph\n        # that determines the exponent \"flip\" for each prime.\n        # This `bipartite_color` is universal for all primes in a component.\n        # `bipartite_color[i]` is initialized to -1 (uncolored).\n        bipartite_color = [-1] * (n + 1)\n        \n        q = [start_node]\n        bipartite_color[start_node] = 0 # Start coloring the component with 0\n        component_nodes = []\n        component_nodes_set = set() # To quickly check if a node belongs to this component\n        \n        head = 0\n        while head < len(q):\n            u = q[head]\n            head += 1\n            component_nodes.append(u)\n            component_nodes_set.add(u)\n\n            for v_neighbor, g_uv, l_uv in adj[u]:\n                if ans[v_neighbor] != 0: # Already processed node from another component\n                    continue\n                \n                # Check consistency for already colored nodes\n                if bipartite_color[v_neighbor] != -1:\n                    if bipartite_color[v_neighbor] == bipartite_color[u]:\n                        # If u and v have same color, but they are connected, this is an odd cycle.\n                        # This means for some prime p, exp_p[u] and exp_p[v] must be different.\n                        # But if they have the same color, their exponents would be derived similarly,\n                        # potentially leading to exp_p[u] == exp_p[v].\n                        # This part needs careful thought.\n                        # If u and v have the same color, it means for any prime p,\n                        # (exp_p[u] - exp_p_g_ref) and (exp_p[v] - exp_p_g_ref) have the same parity.\n                        # Which means exp_p[u] and exp_p[v] have the same parity.\n                        # But we need {exp_p[u], exp_p[v]} to be {exp_p_g, exp_p_l}.\n                        # If exp_p_g != exp_p_l, then exp_p[u] and exp_p[v] must be different.\n                        # This implies that `bipartite_color[u]` and `bipartite_color[v]` must be different.\n                        # So if `bipartite_color[v_neighbor] == bipartite_color[u]`, it's an odd cycle,\n                        # and implies NO solution.\n                        \n                        # However, this is only true if for *all* relevant primes, exp_g < exp_l.\n                        # If for an edge (u, v, g, l) and a prime p, exp_p_g == exp_p_l,\n                        # then exp_p[u] == exp_p[v] == exp_p_g. In this case, same colors are fine for this prime.\n                        # The bipartite coloring is about which of {exp_g, exp_l} each node gets.\n                        # If exp_g == exp_l, then both nodes must get exp_g. This doesn't impose a color difference.\n                        # If exp_g < exp_l, then one gets exp_g, the other gets exp_l. This forces a color difference.\n                        \n                        # So, if `bipartite_color[v_neighbor] == bipartite_color[u]`, we must check consistency for all primes.\n                        # For an edge (u, v, g, l), if `bipartite_color[u] == bipartite_color[v]`,\n                        # then for every prime `p`, `get_prime_factors(g).get(p,0)` MUST BE EQUAL TO `get_prime_factors(l).get(p,0)`.\n                        # If for any prime `p`, `get_prime_factors(g).get(p,0) != get_prime_factors(l).get(p,0)`,\n                        # then it's an odd cycle where it's not allowed, so \"NO\".\n                        \n                        for p_val in get_prime_factors(g_uv):\n                            exp_g = get_prime_factors(g_uv).get(p_val, 0)\n                            exp_l = get_prime_factors(l_uv).get(p_val, 0)\n                            if exp_g != exp_l:\n                                print(\"NO\")\n                                return\n                        for p_val in get_prime_factors(l_uv): # Check primes in L that might not be in G\n                            exp_g = get_prime_factors(g_uv).get(p_val, 0)\n                            exp_l = get_prime_factors(l_uv).get(p_val, 0)\n                            if exp_g != exp_l:\n                                print(\"NO\")\n                                return\n                else: # Uncolored neighbor\n                    bipartite_color[v_neighbor] = 1 - bipartite_color[u]\n                    q.append(v_neighbor)\n        \n        # Now, `bipartite_color` is assigned for all nodes in the component.\n        # For each prime `p` in `component_primes`:\n        #   We need to determine `exp_p_base` and `exp_p_flip`\n        #   such that for each edge `(u, v, g, l)` in the component:\n        #     If `bipartite_color[u] == 0` and `bipartite_color[v] == 1`:\n        #       `{exp_p_base, exp_p_flip}` must be `{get_prime_factors(g).get(p,0), get_prime_factors(l).get(p,0)}`.\n        #       So `exp_p[u] = exp_p_base` and `exp_p[v] = exp_p_flip`.\n        #     If `bipartite_color[u] == 1` and `bipartite_color[v] == 0`:\n        #       `exp_p[u] = exp_p_flip` and `exp_p[v] = exp_p_base`.\n        #     If `bipartite_color[u] == bipartite_color[v]`:\n        #       Then `get_prime_factors(g).get(p,0)` MUST BE EQUAL TO `get_prime_factors(l).get(p,0)`.\n        #       And `exp_p[u] = exp_p[v] = get_prime_factors(g).get(p,0)`.\n        #       In this case, `exp_p_base = exp_p_flip = get_prime_factors(g).get(p,0)`.\n        \n        # Determine `exp_p_base` and `exp_p_flip` for each prime `p`.\n        # Initialize `exp_p_base_val[p]` and `exp_p_flip_val[p]` to -1 (unknown).\n        exp_p_base_val = {p: -1 for p in component_primes}\n        exp_p_flip_val = {p: -1 for p in component_primes}\n\n        for u in component_nodes:\n            for v_neighbor, g_uv, l_uv in adj[u]:\n                if v_neighbor not in component_nodes_set: # Only consider edges within current component\n                    continue\n\n                for p in component_primes:\n                    exp_g = get_prime_factors(g_uv).get(p, 0)\n                    exp_l = get_prime_factors(l_uv).get(p, 0)\n\n                    if exp_g > exp_l: # Should have been caught by initial check\n                        print(\"NO\")\n                        return\n\n                    if exp_g == exp_l:\n                        # Both nodes must have exp_g for this prime\n                        if exp_p_base_val[p] == -1:\n                            exp_p_base_val[p] = exp_g\n                            exp_p_flip_val[p] = exp_g\n                        elif exp_p_base_val[p] != exp_g or exp_p_flip_val[p] != exp_g:\n                            print(\"NO\") # Conflict\n                            return\n                    else: # exp_g < exp_l\n                        if bipartite_color[u] == 0 and bipartite_color[v_neighbor] == 1:\n                            if exp_p_base_val[p] == -1:\n                                exp_p_base_val[p] = exp_g\n                                exp_p_flip_val[p] = exp_l\n                            elif exp_p_base_val[p] != exp_g or exp_p_flip_val[p] != exp_l:\n                                print(\"NO\") # Conflict\n                                return\n                        elif bipartite_color[u] == 1 and bipartite_color[v_neighbor] == 0:\n                            if exp_p_base_val[p] == -1:\n                                exp_p_base_val[p] = exp_l\n                                exp_p_flip_val[p] = exp_g\n                            elif exp_p_base_val[p] != exp_l or exp_p_flip_val[p] != exp_g:\n                                print(\"NO\") # Conflict\n                                return\n                        # If bipartite_color[u] == bipartite_color[v_neighbor], this is an odd cycle.\n                        # We already checked this: if exp_g != exp_l, it's \"NO\".\n                        # If we reach here, it must be that this case was correctly handled by the check above.\n\n        # Now, assign actual exponents to each node\n        for u in component_nodes:\n            current_node_factors = {}\n            for p in component_primes:\n                if bipartite_color[u] == 0:\n                    if exp_p_base_val[p] == -1: # Prime not involved in any edge, can be 0.\n                        current_node_factors[p] = 0\n                    else:\n                        current_node_factors[p] = exp_p_base_val[p]\n                else: # bipartite_color[u] == 1\n                    if exp_p_flip_val[p] == -1: # Prime not involved, can be 0.\n                        current_node_factors[p] = 0\n                    else:\n                        current_node_factors[p] = exp_p_flip_val[p]\n            \n            val = reconstruct_num(current_node_factors)\n            if not (1 <= val <= 10**6):\n                print(\"NO\")\n                return\n            ans[u] = val\n\n    # After assigning all values, verify all edges\n    for u, v, g, l in edges:\n        if ans[u] == 0 or ans[v] == 0: # Should not happen if all components processed\n            print(\"NO\") # Error in logic if this happens\n            return\n        \n        calculated_gcd = math.gcd(ans[u], ans[v])\n        calculated_lcm = (ans[u] * ans[v]) // calculated_gcd\n\n        if calculated_gcd != g or calculated_lcm != l:\n            print(\"NO\")\n            return\n\n    print(\"YES\")\n    print(*(ans[1:]))\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    if n == 0:\n        print(\"YES\")\n        print()\n        return\n\n    adj = [[] for _ in range(n + 1)]\n    edges = []\n\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        edges.append((u, v, g, l))\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l))\n\n    # ans[i] stores the determined number of mushrooms for lawn i.\n    # Initially, all are 0 (unknown).\n    ans = [0] * (n + 1)\n    \n    # Store the prime factors and their exponents for each number.\n    # precompute_factors[k] = {p1: e1, p2: e2, ...} for k.\n    precompute_factors = [None] * (10**6 + 1)\n\n    # Function to get prime factors of a number\n    def get_prime_factors(num):\n        if num == 0: return {} # Handle 0 case if needed, but numbers are >=1\n        if num == 1: return {}\n        if precompute_factors[num] is not None:\n            return precompute_factors[num]\n\n        factors = {}\n        d = 2\n        temp = num\n        while d * d <= temp:\n            while temp % d == 0:\n                factors[d] = factors.get(d, 0) + 1\n                temp //= d\n            d += 1\n        if temp > 1:\n            factors[temp] = factors.get(temp, 0) + 1\n        precompute_factors[num] = factors\n        return factors\n\n    # Function to reconstruct number from prime factors\n    def reconstruct_num(factors_dict):\n        num = 1\n        for p, e in factors_dict.items():\n            num *= (p ** e)\n        return num\n\n    # Function to check if a divides b\n    def divides(a, b):\n        return b % a == 0\n\n    # Function to calculate GCD of two numbers from their factorizations\n    def calculate_gcd_factors(factors1, factors2):\n        gcd_factors = {}\n        for p in factors1:\n            if p in factors2:\n                gcd_factors[p] = min(factors1[p], factors2[p])\n        return reconstruct_num(gcd_factors)\n\n    # Function to calculate LCM of two numbers from their factorizations\n    def calculate_lcm_factors(factors1, factors2):\n        lcm_factors = {}\n        for p in factors1:\n            lcm_factors[p] = factors1[p]\n        for p in factors2:\n            lcm_factors[p] = max(lcm_factors.get(p, 0), factors2[p])\n        return reconstruct_num(lcm_factors)\n\n    # Main loop for processing connected components\n    for start_node in range(1, n + 1):\n        if ans[start_node] != 0: # Already processed\n            continue\n\n        # For each connected component, we need to determine the 'base' prime factorization.\n        # This is represented by `current_factors_base[p] = (min_exp, max_exp)`\n        # for each prime `p`.\n        # `ans[i]` will be `reconstruct_num(current_factors_base)` for some `i`,\n        # but `ans[i]` itself stores the actual value.\n        \n        # `node_factor_info[u]` stores the prime factorization for `a_u`.\n        # Each `a_u` is represented as a dictionary {p: exponent}.\n        # `a_u` = `base_value` * `relative_factors_u`.\n        # We need to determine `base_value` and `relative_factors_u`.\n        # `relative_factors_u` is a dict {p: exponent_diff} which will be relative to `a_start_node`.\n        \n        # We will use a BFS/DFS to traverse the component.\n        # For the first node in the component (`start_node`), we can initially assume\n        # its value is 1 (or any valid value), and then adjust it later.\n        # A better approach: for each node `u`, we will store `a_u_factors` which is\n        # a dictionary of prime factors and their exponents.\n        # We also need to keep track of the `a_u_factors` for all nodes in the component.\n\n        # `node_factors[u]` will store the prime factorization of `a_u`.\n        # Initially, it's unknown for all nodes.\n        # When we process a node `u` and determine its `node_factors[u]`,\n        # we can propagate this information.\n        \n        # Let's try a different approach. For each prime `p`, we want to find its exponent\n        # in `a_i`. Let `exp_p[i]` be the exponent of `p` in `a_i`.\n        # For an edge (u, v, g, l), let `exp_p_g` be exponent of `p` in `g`,\n        # and `exp_p_l` be exponent of `p` in `l`.\n        # We know `min(exp_p[u], exp_p[v]) = exp_p_g`\n        # We know `max(exp_p[u], exp_p[v]) = exp_p_l`\n        # This means for each prime `p`:\n        # `{exp_p[u], exp_p[v]} = {exp_p_g, exp_p_l}` as a set.\n        # So, `exp_p[u] + exp_p[v] = exp_p_g + exp_p_l`.\n\n        # We can use BFS/DFS. For the first node `start_node` in a component,\n        # we can arbitrarily assign `exp_p[start_node]` to be `exp_p_g` for some edge\n        # (start_node, neighbor, g, l). Then `exp_p[neighbor]` would be `exp_p_l`.\n        # Or, we can assign `exp_p[start_node]` to be `exp_p_l`, then `exp_p[neighbor]` would be `exp_p_g`.\n        # This suggests a 2-coloring type problem for exponents.\n        # For each prime `p`, and for each connected component:\n        # We can define `x_i` as `exp_p[i] - exp_p_g_ref` for some reference `g`.\n        # Or more simply, `exp_p[i]` can be `base_exp_p + offset_p[i]`.\n        # `offset_p[i]` would be 0 or 1, depending on which of `exp_p_g` or `exp_p_l` it takes.\n\n        # Let's define `diff[u]` as the exponent difference relative to `start_node`.\n        # `exp_p[u] = exp_p[start_node] + diff[u]`.\n        # For an edge (u, v, g, l):\n        # `min(exp_p[u], exp_p[v]) = exp_p_g`\n        # `max(exp_p[u], exp_p[v]) = exp_p_l`\n        # We can't directly assign `exp_p[start_node]` because it could be different for different primes.\n\n        # Let's assign `a_start_node` to be 1 initially. This is a bad idea, as it might\n        # violate `g | a_start_node`.\n        # A better way is to determine `a_start_node` based on its neighbors.\n        # For each prime `p`, we need to determine `exp_p[i]` for all `i` in the component.\n\n        # For a connected component, fix an arbitrary node `u` in it.\n        # For each prime `p`, we can iterate through the component using BFS/DFS.\n        # `exp_p_val[i]` stores the exponent of `p` for node `i`.\n        # `exp_p_val[i]` can be `exp_p_g` or `exp_p_l` for an edge.\n        # We can try to assign a value to `exp_p_val[start_node]` for each prime `p`.\n        # The range of possible values for `exp_p_val[i]` is `[0, log_p(10^6)]`.\n        \n        # Let's try setting `ans[start_node]` to a specific value and propagate.\n        # What value? For an edge (u, v, g, l), if `g` does not divide `l`, it's impossible.\n        # `l % g == 0` must hold.\n        # Let `X = l / g`. We need `a_u = g * A`, `a_v = g * B` such that `A * B = X` and `GCD(A, B) = 1`.\n        # This means `A` and `B` must be coprime factors of `X`.\n        # For any prime `p` dividing `X`, `p` must divide either `A` or `B`, but not both.\n        # So, for each prime factor `p` of `X`, its entire exponent `exp_p_X` must go to either `A` or `B`.\n        # This means `a_u` must be `g * (product of some prime powers of X)`\n        # and `a_v` must be `g * (product of remaining prime powers of X)`.\n        \n        # We can represent `a_u` as `g_u * P_u` where `P_u` is a product of prime powers.\n        # For an edge `(u, v, g, l)`:\n        # `a_u = g * A`, `a_v = g * B` where `A * B = l/g` and `GCD(A,B)=1`.\n        # This means `a_u` must be a multiple of `g`, and `a_v` must be a multiple of `g`.\n        # Also, `a_u` must divide `l`, and `a_v` must divide `l`.\n        # More specifically, `lcm(a_u, a_v) = l`.\n        # This implies `a_u` must be of the form `g * \\prod p_i^{e_i}` where `p_i^{e_i}` are prime powers that divide `l/g`.\n        # And `a_v` must be of the form `g * \\prod p_j^{f_j}` where `p_j^{f_j}` are the remaining prime powers.\n\n        # Let `factors_g = get_prime_factors(g)` and `factors_l = get_prime_factors(l)`.\n        # For each prime `p`, let `exp_g = factors_g.get(p, 0)` and `exp_l = factors_l.get(p, 0)`.\n        # Then `exp_p[u]` and `exp_p[v]` must be `exp_g` and `exp_l` in some order.\n        # That is, `{exp_p[u], exp_p[v]} = {exp_g, exp_l}` as a set.\n        # This implies `exp_p[u] + exp_p[v] = exp_g + exp_l`.\n\n        # This is a 2-coloring problem for each prime `p` independently.\n        # For each prime `p` that appears in any `g` or `l` in the component:\n        # We need to assign `exp_p[i]` for each node `i` in the component.\n        # `exp_p[i]` can be `exp_g` or `exp_l` from an edge (i, j, g, l).\n        # Let's define `relative_exp_p[i]` for node `i` in a component.\n        # `relative_exp_p[i]` is 0 or 1.\n        # For an edge (u, v, g, l), let `exp_g = factors_g.get(p, 0)` and `exp_l = factors_l.get(p, 0)`.\n        # If `relative_exp_p[u] == 0`, then `exp_p[u]` is `exp_g`.\n        # If `relative_exp_p[u] == 1`, then `exp_p[u]` is `exp_l`.\n        # This is incorrect. The exponents are not fixed to `exp_g` or `exp_l` globally.\n        # They are fixed *relative to each other* for an edge.\n\n        # Correct approach for 2-coloring:\n        # For each prime `p`:\n        #   Create a graph where nodes are `1..n`.\n        #   For each edge `(u, v, g, l)`:\n        #     `exp_g = get_prime_factors(g).get(p, 0)`\n        #     `exp_l = get_prime_factors(l).get(p, 0)`\n        #     If `exp_g > exp_l`, this is invalid (GCD must be <= LCM).\n        #     If `exp_g == exp_l`, then `exp_p[u]` must be `exp_g` and `exp_p[v]` must be `exp_g`.\n        #       This means all nodes in this connected component must have `exp_g` for prime `p`.\n        #     If `exp_g < exp_l`:\n        #       Then `{exp_p[u], exp_p[v]} = {exp_g, exp_l}`.\n        #       We can assign `exp_p[u] = exp_g` and `exp_p[v] = exp_l`, OR `exp_p[u] = exp_l` and `exp_p[v] = exp_g`.\n        #       This is a 2-coloring problem.\n        #       Let `offset[i]` be 0 or 1.\n        #       If `offset[i] == 0`, `exp_p[i]` takes the \"smaller\" value (`exp_g` for some edge).\n        #       If `offset[i] == 1`, `exp_p[i]` takes the \"larger\" value (`exp_l` for some edge).\n        #       This is still tricky because `exp_g` and `exp_l` vary per edge.\n\n        # Let's try to determine `a_i` directly.\n        # `ans[i]` stores the value of `a_i`.\n        # `lower_bound[i]` and `upper_bound[i]` for `a_i`.\n        # This is too complex. The 2-coloring for each prime exponent is the standard approach for this kind of problem.\n\n        # Let `component_nodes` be the list of nodes in the current connected component.\n        # For each node `i` in `component_nodes`, `a_i` must be a value `[1, 10^6]`.\n        # For each prime `p` up to `10^6`:\n        # `exp_for_prime[p][i]` will store the exponent of `p` in `a_i`.\n        # Initialize `exp_for_prime` with -1 (unknown).\n\n        # Collect all unique primes involved in the current component\n        component_primes = set()\n        for u in range(1, n + 1):\n            if ans[u] == 0: # Only consider nodes not yet processed\n                for v, g, l in adj[u]:\n                    if ans[v] == 0:\n                        if not divides(g, l):\n                            print(\"NO\")\n                            return\n                        for p in get_prime_factors(g): component_primes.add(p)\n                        for p in get_prime_factors(l): component_primes.add(p)\n        \n        # For each prime `p`, we will try to assign exponents to nodes in the current component.\n        # `exp_val[i]` will store the exponent of `p` for node `i`.\n        # `exp_val[i]` is initialized to -1 (unknown).\n        # `color[i]` will store 0 or 1 for bipartite graph coloring.\n        # `color[i] = 0` means `exp_val[i]` takes the 'base' exponent.\n        # `color[i] = 1` means `exp_val[i]` takes the 'flipped' exponent.\n        \n        # `prime_exp_assignments[p][i]` stores the exponent of prime `p` for node `i`.\n        prime_exp_assignments = {p: [-1] * (n + 1) for p in component_primes}\n\n        # `bipartite_color[i]` stores the color (0 or 1) for node `i` in the bipartite graph\n        # that determines the exponent \"flip\" for each prime.\n        # This `bipartite_color` is universal for all primes in a component.\n        # `bipartite_color[i]` is initialized to -1 (uncolored).\n        bipartite_color = [-1] * (n + 1)\n        \n        q = [start_node]\n        bipartite_color[start_node] = 0 # Start coloring the component with 0\n        component_nodes = []\n        component_nodes_set = set() # To quickly check if a node belongs to this component\n        \n        head = 0\n        while head < len(q):\n            u = q[head]\n            head += 1\n            component_nodes.append(u)\n            component_nodes_set.add(u)\n\n            for v_neighbor, g_uv, l_uv in adj[u]:\n                if ans[v_neighbor] != 0: # Already processed node from another component\n                    continue\n                \n                # Check consistency for already colored nodes\n                if bipartite_color[v_neighbor] != -1:\n                    if bipartite_color[v_neighbor] == bipartite_color[u]:\n                        # If u and v have same color, but they are connected, this is an odd cycle.\n                        # This means for some prime p, exp_p[u] and exp_p[v] must be different.\n                        # But if they have the same color, their exponents would be derived similarly,\n                        # potentially leading to exp_p[u] == exp_p[v].\n                        # This part needs careful thought.\n                        # If u and v have the same color, it means for any prime p,\n                        # (exp_p[u] - exp_p_g_ref) and (exp_p[v] - exp_p_g_ref) have the same parity.\n                        # Which means exp_p[u] and exp_p[v] have the same parity.\n                        # But we need {exp_p[u], exp_p[v]} to be {exp_p_g, exp_p_l}.\n                        # If exp_p_g != exp_p_l, then exp_p[u] and exp_p[v] must be different.\n                        # This implies that `bipartite_color[u]` and `bipartite_color[v]` must be different.\n                        # So if `bipartite_color[v_neighbor] == bipartite_color[u]`, it's an odd cycle,\n                        # and implies NO solution.\n                        \n                        # However, this is only true if for *all* relevant primes, exp_g < exp_l.\n                        # If for an edge (u, v, g, l) and a prime p, exp_p_g == exp_p_l,\n                        # then exp_p[u] == exp_p[v] == exp_p_g. In this case, same colors are fine for this prime.\n                        # The bipartite coloring is about which of {exp_g, exp_l} each node gets.\n                        # If exp_g == exp_l, then both nodes must get exp_g. This doesn't impose a color difference.\n                        # If exp_g < exp_l, then one gets exp_g, the other gets exp_l. This forces a color difference.\n                        \n                        # So, if `bipartite_color[v_neighbor] == bipartite_color[u]`, we must check consistency for all primes.\n                        # For an edge (u, v, g, l), if `bipartite_color[u] == bipartite_color[v]`,\n                        # then for every prime `p`, `get_prime_factors(g).get(p,0)` MUST BE EQUAL TO `get_prime_factors(l).get(p,0)`.\n                        # If for any prime `p`, `get_prime_factors(g).get(p,0) != get_prime_factors(l).get(p,0)`,\n                        # then it's an odd cycle where it's not allowed, so \"NO\".\n                        \n                        for p_val in get_prime_factors(g_uv):\n                            exp_g = get_prime_factors(g_uv).get(p_val, 0)\n                            exp_l = get_prime_factors(l_uv).get(p_val, 0)\n                            if exp_g != exp_l:\n                                print(\"NO\")\n                                return\n                        for p_val in get_prime_factors(l_uv): # Check primes in L that might not be in G\n                            exp_g = get_prime_factors(g_uv).get(p_val, 0)\n                            exp_l = get_prime_factors(l_uv).get(p_val, 0)\n                            if exp_g != exp_l:\n                                print(\"NO\")\n                                return\n                else: # Uncolored neighbor\n                    bipartite_color[v_neighbor] = 1 - bipartite_color[u]\n                    q.append(v_neighbor)\n        \n        # Now, `bipartite_color` is assigned for all nodes in the component.\n        # For each prime `p` in `component_primes`:\n        #   We need to determine `exp_p_base` and `exp_p_flip`\n        #   such that for each edge `(u, v, g, l)` in the component:\n        #     If `bipartite_color[u] == 0` and `bipartite_color[v] == 1`:\n        #       `{exp_p_base, exp_p_flip}` must be `{get_prime_factors(g).get(p,0), get_prime_factors(l).get(p,0)}`.\n        #       So `exp_p[u] = exp_p_base` and `exp_p[v] = exp_p_flip`.\n        #     If `bipartite_color[u] == 1` and `bipartite_color[v] == 0`:\n        #       `exp_p[u] = exp_p_flip` and `exp_p[v] = exp_p_base`.\n        #     If `bipartite_color[u] == bipartite_color[v]`:\n        #       Then `get_prime_factors(g).get(p,0)` MUST BE EQUAL TO `get_prime_factors(l).get(p,0)`.\n        #       And `exp_p[u] = exp_p[v] = get_prime_factors(g).get(p,0)`.\n        #       In this case, `exp_p_base = exp_p_flip = get_prime_factors(g).get(p,0)`.\n        \n        # Determine `exp_p_base` and `exp_p_flip` for each prime `p`.\n        # Initialize `exp_p_base_val[p]` and `exp_p_flip_val[p]` to -1 (unknown).\n        exp_p_base_val = {p: -1 for p in component_primes}\n        exp_p_flip_val = {p: -1 for p in component_primes}\n\n        for u in component_nodes:\n            for v_neighbor, g_uv, l_uv in adj[u]:\n                if v_neighbor not in component_nodes_set: # Only consider edges within current component\n                    continue\n\n                for p in component_primes:\n                    exp_g = get_prime_factors(g_uv).get(p, 0)\n                    exp_l = get_prime_factors(l_uv).get(p, 0)\n\n                    if exp_g > exp_l: # Should have been caught by initial check\n                        print(\"NO\")\n                        return\n\n                    if exp_g == exp_l:\n                        # Both nodes must have exp_g for this prime\n                        if exp_p_base_val[p] == -1:\n                            exp_p_base_val[p] = exp_g\n                            exp_p_flip_val[p] = exp_g\n                        elif exp_p_base_val[p] != exp_g or exp_p_flip_val[p] != exp_g:\n                            print(\"NO\") # Conflict\n                            return\n                    else: # exp_g < exp_l\n                        if bipartite_color[u] == 0 and bipartite_color[v_neighbor] == 1:\n                            if exp_p_base_val[p] == -1:\n                                exp_p_base_val[p] = exp_g\n                                exp_p_flip_val[p] = exp_l\n                            elif exp_p_base_val[p] != exp_g or exp_p_flip_val[p] != exp_l:\n                                print(\"NO\") # Conflict\n                                return\n                        elif bipartite_color[u] == 1 and bipartite_color[v_neighbor] == 0:\n                            if exp_p_base_val[p] == -1:\n                                exp_p_base_val[p] = exp_l\n                                exp_p_flip_val[p] = exp_g\n                            elif exp_p_base_val[p] != exp_l or exp_p_flip_val[p] != exp_g:\n                                print(\"NO\") # Conflict\n                                return\n                        # If bipartite_color[u] == bipartite_color[v_neighbor], this is an odd cycle.\n                        # We already checked this: if exp_g != exp_l, it's \"NO\".\n                        # If we reach here, it must be that this case was correctly handled by the check above.\n\n        # Now, assign actual exponents to each node\n        for u in component_nodes:\n            current_node_factors = {}\n            for p in component_primes:\n                if bipartite_color[u] == 0:\n                    if exp_p_base_val[p] == -1: # Prime not involved in any edge, can be 0.\n                        current_node_factors[p] = 0\n                    else:\n                        current_node_factors[p] = exp_p_base_val[p]\n                else: # bipartite_color[u] == 1\n                    if exp_p_flip_val[p] == -1: # Prime not involved, can be 0.\n                        current_node_factors[p] = 0\n                    else:\n                        current_node_factors[p] = exp_p_flip_val[p]\n            \n            val = reconstruct_num(current_node_factors)\n            if not (1 <= val <= 10**6):\n                print(\"NO\")\n                return\n            ans[u] = val\n\n    # After assigning all values, verify all edges\n    for u, v, g, l in edges:\n        if ans[u] == 0 or ans[v] == 0: # Should not happen if all components processed\n            print(\"NO\") # Error in logic if this happens\n            return\n        \n        calculated_gcd = math.gcd(ans[u], ans[v])\n        calculated_lcm = (ans[u] * ans[v]) // calculated_gcd\n\n        if calculated_gcd != g or calculated_lcm != l:\n            print(\"NO\")\n            return\n\n    print(\"YES\")\n    print(*(ans[1:]))\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 552,
        "completion_token_count": 6664,
        "thoughts_token_count": 803
    }
}