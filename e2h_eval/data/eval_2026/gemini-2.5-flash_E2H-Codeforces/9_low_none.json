{
    "start": 1758009477.1401937,
    "end": 1758009501.6300452,
    "start-formatted": "2025-09-16 16:57 KST",
    "end-formatted": "2025-09-16 16:58 KST",
    "gpu": 2,
    "pid": 9,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Selling Souvenirs\n\nAfter several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.This morning, as usual, Petya will come to the market. Petya has n different souvenirs to sell; ith souvenir is characterised by its weight wi and cost ci. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than m, and total cost is maximum possible.Help Petya to determine maximum possible total cost.\n\n## Input\nThe first line contains two integers n and m (1 ≤ n ≤ 100000, 1 ≤ m ≤ 300000) — the number of Petya's souvenirs and total weight that he can carry to the market.Then n lines follow. ith line contains two integers wi and ci (1 ≤ wi ≤ 3, 1 ≤ ci ≤ 109) — the weight and the cost of ith souvenir.\n\n## Output\nPrint one number — maximum possible total cost of souvenirs that Petya can carry to the market.\n\n## Example\n### Input\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\n### Output\n['0', '3', '10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "**Knapsack with a Twist: My Approach to \"Selling Souvenirs\"**\n\nOkay, so I'm tackling this \"Selling Souvenirs\" problem, which screams knapsack variation to me.  We've got `n` souvenirs, each with a weight (`w_i`) and a cost (`c_i`), and a weight limit `m`.  Classic knapsack! But, the standard dynamic programming approach (O(n*m)) is going to be far too slow, given the constraints.  That's where the *genius* of the problem lies: the weights can only be 1, 2, or 3.\n\nThis narrows down the possibilities dramatically.  My first instinct is to sort the souvenirs.  For each weight (1, 2, and 3), I'll make a list and sort those souvenirs in descending order based on their cost.  That way, when I'm \"filling\" the knapsack, I'm always picking the most valuable item for its weight.\n\nI'm thinking of three lists: `costs1`, `costs2`, and `costs3`, holding the costs of the souvenirs for each weight.\n\nThen, the actual selection: I need to choose `k1` souvenirs of weight 1, `k2` of weight 2, and `k3` of weight 3, such that `k1 + 2*k2 + 3*k3 <= m`.  The total cost then is just the sum of the top `k1` elements of `costs1`, the top `k2` from `costs2`, and the top `k3` from `costs3`.\n\nGiven the limits on `m`, iterating over all possible values of `k1`, `k2`, and `k3` directly is still not the fastest. But I see an opportunity here!  The key is that the weights are limited to three values.  If I choose how many weight 3 items to take, this simplifies the problem!\n\nI can iterate through the number of weight 3 souvenirs I take (from 0 up to `m/3`). For each possible value of `k3`, I calculate the cost of those items (`sum(costs3[:k3])`), and adjust my available weight.  The remaining problem then becomes finding the optimal combination of weight 1 and 2 items to fill the remaining weight. This is now much more manageable. The range of `k3` is now from 0 to 100000. For each value of `k3`, the remaining weight is only determined by `k3`.\n\nI feel I am on the right track now!\n",
    "response": "```python\nimport sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    # Categorize souvenirs by weight\n    costs1 = []\n    costs2 = []\n    costs3 = []\n\n    for _ in range(n):\n        w, c = map(int, sys.stdin.readline().split())\n        if w == 1:\n            costs1.append(c)\n        elif w == 2:\n            costs2.append(c)\n        else: # w == 3\n            costs3.append(c)\n\n    # Sort costs for each weight type in descending order\n    costs1.sort(reverse=True)\n    costs2.sort(reverse=True)\n    costs3.sort(reverse=True)\n\n    # Precompute prefix sums for costs\n    # This allows O(1) lookup for sum of top k items\n    prefix_sum1 = [0] * (len(costs1) + 1)\n    for i in range(len(costs1)):\n        prefix_sum1[i+1] = prefix_sum1[i] + costs1[i]\n\n    prefix_sum2 = [0] * (len(costs2) + 1)\n    for i in range(len(costs2)):\n        prefix_sum2[i+1] = prefix_sum2[i] + costs2[i]\n\n    prefix_sum3 = [0] * (len(costs3) + 1)\n    for i in range(len(costs3)):\n        prefix_sum3[i+1] = prefix_sum3[i] + costs3[i]\n\n    max_total_cost = 0\n\n    # Iterate over the number of items of weight 2 (k2)\n    # The maximum number of weight 2 items we can take is m/2.\n    # We can take at most len(costs2) items.\n    # So k2 ranges from 0 up to min(m // 2, len(costs2)).\n    for k2 in range(min(m // 2, len(costs2)) + 1):\n        current_cost_k2 = prefix_sum2[k2]\n        remaining_weight = m - k2 * 2\n\n        # To fill the remaining_weight, we use items of weight 1 and 3.\n        # This is a 2-type knapsack problem.\n        # We can iterate over the number of items of weight 3 (k3).\n        # The maximum number of weight 3 items we can take is remaining_weight / 3.\n        # We can take at most len(costs3) items.\n        # So k3 ranges from 0 up to min(remaining_weight // 3, len(costs3)).\n        for k3 in range(min(remaining_weight // 3, len(costs3)) + 1):\n            current_cost_k3 = prefix_sum3[k3]\n            remaining_weight_after_k3 = remaining_weight - k3 * 3\n\n            # With the remaining_weight_after_k3, we can only take items of weight 1.\n            # The number of weight 1 items (k1) we can take is\n            # min(remaining_weight_after_k3 // 1, len(costs1)).\n            k1 = min(remaining_weight_after_k3, len(costs1))\n            current_cost_k1 = prefix_sum1[k1]\n\n            # Calculate total cost for this combination of k1, k2, k3\n            current_total_cost = current_cost_k1 + current_cost_k2 + current_cost_k3\n            max_total_cost = max(max_total_cost, current_total_cost)\n\n    sys.stdout.write(str(max_total_cost) + '\\n')\n\n# Call the solver function\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    # Categorize souvenirs by weight\n    costs1 = []\n    costs2 = []\n    costs3 = []\n\n    for _ in range(n):\n        w, c = map(int, sys.stdin.readline().split())\n        if w == 1:\n            costs1.append(c)\n        elif w == 2:\n            costs2.append(c)\n        else: # w == 3\n            costs3.append(c)\n\n    # Sort costs for each weight type in descending order\n    costs1.sort(reverse=True)\n    costs2.sort(reverse=True)\n    costs3.sort(reverse=True)\n\n    # Precompute prefix sums for costs\n    # This allows O(1) lookup for sum of top k items\n    prefix_sum1 = [0] * (len(costs1) + 1)\n    for i in range(len(costs1)):\n        prefix_sum1[i+1] = prefix_sum1[i] + costs1[i]\n\n    prefix_sum2 = [0] * (len(costs2) + 1)\n    for i in range(len(costs2)):\n        prefix_sum2[i+1] = prefix_sum2[i] + costs2[i]\n\n    prefix_sum3 = [0] * (len(costs3) + 1)\n    for i in range(len(costs3)):\n        prefix_sum3[i+1] = prefix_sum3[i] + costs3[i]\n\n    max_total_cost = 0\n\n    # Iterate over the number of items of weight 2 (k2)\n    # The maximum number of weight 2 items we can take is m/2.\n    # We can take at most len(costs2) items.\n    # So k2 ranges from 0 up to min(m // 2, len(costs2)).\n    for k2 in range(min(m // 2, len(costs2)) + 1):\n        current_cost_k2 = prefix_sum2[k2]\n        remaining_weight = m - k2 * 2\n\n        # To fill the remaining_weight, we use items of weight 1 and 3.\n        # This is a 2-type knapsack problem.\n        # We can iterate over the number of items of weight 3 (k3).\n        # The maximum number of weight 3 items we can take is remaining_weight / 3.\n        # We can take at most len(costs3) items.\n        # So k3 ranges from 0 up to min(remaining_weight // 3, len(costs3)).\n        for k3 in range(min(remaining_weight // 3, len(costs3)) + 1):\n            current_cost_k3 = prefix_sum3[k3]\n            remaining_weight_after_k3 = remaining_weight - k3 * 3\n\n            # With the remaining_weight_after_k3, we can only take items of weight 1.\n            # The number of weight 1 items (k1) we can take is\n            # min(remaining_weight_after_k3 // 1, len(costs1)).\n            k1 = min(remaining_weight_after_k3, len(costs1))\n            current_cost_k1 = prefix_sum1[k1]\n\n            # Calculate total cost for this combination of k1, k2, k3\n            current_total_cost = current_cost_k1 + current_cost_k2 + current_cost_k3\n            max_total_cost = max(max_total_cost, current_total_cost)\n\n    sys.stdout.write(str(max_total_cost) + '\\n')\n\n# Call the solver function\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 487,
        "completion_token_count": 896,
        "thoughts_token_count": 784
    }
}