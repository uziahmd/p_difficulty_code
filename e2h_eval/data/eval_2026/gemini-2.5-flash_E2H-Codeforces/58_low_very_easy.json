{
    "start": 1758284887.484388,
    "end": 1758284943.610688,
    "start-formatted": "2025-09-19 21:28 KST",
    "end-formatted": "2025-09-19 21:29 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "**Breaking Down the Odd Cycle Problem**\n\nOkay, so I'm tackling this competitive programming problem. The goal is to figure out the minimum number of edges, `t`, I need to add to an undirected graph to create a simple odd-length cycle, and then count how many ways, `w`, I can do it.  My mind immediately goes to the properties of odd cycles.  We know that a graph contains an odd cycle *if and only if* it's not bipartite. That's the key.\n\n**First Step: Bipartiteness Check**\n\nI need to start by checking if the graph is *already* non-bipartite. That's Case 0.  If it *does* contain an odd cycle already, then `t` is trivially 0, and `w` is just 1 (do nothing!). To test for bipartiteness, I'll run BFS or DFS. I'll color vertices as I go, alternating colors (0 and 1).  If I ever find an edge where both ends have the same color, boom, it's not bipartite, and I've got my answer for that case.\n\n**Moving on to the Bipartite Case**\n\nIf the graph *is* bipartite (Case 1), I know I need to add edges. The absolute minimum is one edge, `t=1`.  Adding a single edge can create an odd cycle, but only if that edge connects two vertices of the *same* color in the bipartite partitioning.  I'll think about how to find such edge.\n\n**Analyzing Components**\n\nI need to consider each connected component separately.  For each component, I'll run a BFS/DFS to get the color-based partitioning (L and R). Adding an edge within the L-partition or within the R-partition will do the trick.  The number of ways this is possible in each component is the number of edges I could create within each color, which is |L| * (|L| - 1) / 2 + |R| * (|R| - 1) / 2 . I need to make sure to count the number of such edges in each component. I will need to iterate each vertex within each component. And also I should double check that such edge will not produce a cycle of even length when created.\n\n**Edge Cases and Considerations**\n\nI have to be careful about a few things. First, the problem specifies a *simple* cycle. I need to make sure I don't introduce a cycle of even length when adding my edge. I think the procedure of adding an edge within the L-partition or the R-partition should guarantee an odd cycle. I will also make sure that I don't add duplicate edges to create cycles, and that I'm only counting unique ways to make a new cycle.\n\nI will iterate through all the components and perform the above operations.\n",
    "response": "The problem asks us to find the minimum number of edges `t` to add to a given undirected graph to form a simple cycle of odd length, and `w` the number of ways to do so.\n\nA graph contains an odd cycle if and only if it is not bipartite.\n\nWe can use Breadth-First Search (BFS) or Depth-First Search (DFS) to check if the graph is bipartite. During this process, we can also identify connected components and the size of partitions within each component.\n\nLet's define `colors` array, initialized to -1 (unvisited).\n`color[v] = 0` or `color[v] = 1` indicates the partition set `v` belongs to.\n`is_bipartite = True` initially.\n`component_sizes = []` to store `(size_L, size_R)` for each bipartite component.\n\nIterate `i` from 1 to `n`:\n  If `vertex i` is unvisited:\n    Start a BFS/DFS from `i`.\n    `current_component_is_bipartite = True`\n    `count_L = 0`, `count_R = 0`\n    Queue `Q` = `[(i, 0)]` (vertex `i`, color 0)\n    `color[i] = 0`\n    While `Q` is not empty:\n      `u, c = Q.pop_front()`\n      If `c == 0`: `count_L += 1`\n      Else: `count_R += 1`\n      For each neighbor `v` of `u`:\n        If `color[v] == -1` (unvisited):\n          `color[v] = 1 - c`\n          `Q.push((v, 1 - c))`\n        Else if `color[v] == c` (same color as `u`):\n          `is_bipartite = False`\n          `current_component_is_bipartite = False`\n          (We can break early from this component's BFS/DFS if we only need to know if the graph is bipartite. For `t=1` and `t=2` cases, we need component info, so we might need to complete the component's traversal, but once `is_bipartite` is `False`, we know `t=0`.)\n    If `current_component_is_bipartite`:\n      `component_sizes.append((count_L, count_R))`\n\nNow, based on `is_bipartite`:\n\n**Case 0: `is_bipartite == False`**\nThe graph already contains an odd cycle.\nMinimum edges to add `t = 0`.\nNumber of ways `w = 1` (do nothing).\n\n**Case 1: `is_bipartite == True`**\nThe graph is bipartite. We need to add at least one edge.\n\n  **Subcase 1.1: Can we achieve `t = 1`?**\n  To form an odd cycle by adding one edge, we must add an edge `(u, v)` where `u` and `v` are in the same connected component and belong to the same partition set (e.g., both color 0 or both color 1).\n  The number of ways `w_1` to do this is the sum over all bipartite connected components of:\n  `count_L * (count_L - 1) / 2` (pairs within L) + `count_R * (count_R - 1) / 2` (pairs within R).\n  We must subtract any existing edges between `u` and `v` that are already present. However, since the graph is bipartite, there are no existing edges between vertices of the same partition set.\n  So, `w_1 = sum(L * (L - 1) // 2 + R * (R - 1) // 2 for L, R in component_sizes)`.\n\n  If `w_1 > 0`:\n    Minimum edges to add `t = 1`.\n    Number of ways `w = w_1`.\n\n  **Subcase 1.2: If `w_1 == 0`, can we achieve `t = 2`?**\n  This means no component has `L > 1` or `R > 1`. All components are paths or isolated vertices, specifically, `L <= 1` and `R <= 1` for all components.\n  This implies all components are either singletons (L=1, R=0 or L=0, R=1) or single edges (L=1, R=1).\n  To form an odd cycle with two added edges, we must connect two distinct connected components.\n  Let the two added edges be `(u, v)` and `(x, y)`.\n  We need to pick two components `C_1` and `C_2` (possibly the same component if it has at least 3 vertices).\n  If we pick two vertices `u, v` from different components `C_1` and `C_2`, and they have colors `c_u` and `c_v` respectively.\n  To form an odd cycle, we need to add edges `(u, v)` and `(v, u)` (not possible) or `(u, x)` and `(x, y)` and `(y, u)`.\n  The simplest way to form an odd cycle with two edges is to pick three distinct vertices `u, v, x` and add edges `(u, v)` and `(v, x)` such that `u` and `x` are already connected by an edge. This forms a triangle.\n  Or, pick two distinct vertices `u, v` and add edges `(u, v)` and `(u, v)`. Not possible.\n  The typical way to form an odd cycle with 2 edges is to pick 3 vertices `A, B, C` and add edges `(A, B)` and `(B, C)` such that `(A, C)` is an existing edge. This forms a triangle.\n  Since the graph is bipartite, there are no existing triangles. So this is not how it works.\n\n  Let's consider the structure:\n  We have a bipartite graph. We want to add two edges `e_1, e_2` to form an odd cycle.\n  The new cycle must contain at least one of `e_1, e_2`.\n  If an odd cycle uses exactly one new edge, say `e_1=(u,v)`, then `u` and `v` must be in the same partition set and connected by an even path. This is `t=1` case. Since `w_1=0`, this doesn't happen.\n  So, the new cycle must use *both* `e_1` and `e_2`.\n  Let `e_1 = (u, v)` and `e_2 = (x, y)`.\n  The path formed by `e_1`, some original path `P_1`, `e_2`, some original path `P_2` must be an odd cycle.\n  Consider adding edges `(u, v)` and `(u, x)` where `u, v, x` are distinct.\n  If `v` and `x` are in the same component and have the same color, then adding `(u,v)` and `(u,x)` will create an odd cycle `u-v-...-x-u`. The path `v-...-x` has even length. `u-v` and `u-x` add 2 to length. So total length is even+2 = even. This doesn't create an odd cycle.\n  This thinking is incorrect.\n\n  Let's use the color property.\n  Suppose we add edges `(u, v)` and `(x, y)`.\n  If `u, v, x, y` are all distinct and in different components.\n  Or `u, v` are in one component and `x, y` in another.\n  If we add `(u, v)` and `(v, x)` where `u, v, x` are distinct vertices.\n  The path `u-v-x` has length 2.\n  If `u` and `x` are in the same component and have different colors, adding `(u,v)` and `(v,x)` will create a cycle `u-v-x-...-u`.\n  The path `u-...-x` has odd length because `u` and `x` have different colors.\n  So total length is `1 (u-v) + 1 (v-x) + odd (u-...-x) = 2 + odd = odd`.\n  This creates an odd cycle.\n\n  So, we need to pick three distinct vertices `u, v, x`.\n  Add edge `(u, v)` and `(v, x)`.\n  Condition: `u` and `x` must be in the same component and have different colors. (This is always true for any two vertices in the same bipartite component connected by a path of odd length).\n  This strategy requires `u, v, x` to be distinct.\n  Let `u` be in `C_1`, `v` in `C_2`, `x` in `C_1`.\n  `u` and `x` are in the same component `C_1`.\n  `v` is in a different component `C_2`.\n  Number of ways:\n  Pick a component `C_1` with `L_1, R_1` vertices.\n  Pick `u` from `C_1` (say color 0), `x` from `C_1` (say color 1). `L_1 * R_1` ways.\n  Pick `v` from any other component `C_2`. `N - (L_1 + R_1)` choices for `v`.\n  Total ways for this: `sum_over_C1 (L_1 * R_1 * (N - (L_1 + R_1)))`.\n  This is the number of ways to pick `u, x` from one component and `v` from another.\n  Then add `(u, v)` and `(v, x)`. These two edges are distinct and do not create loops or parallel edges.\n  This forms an odd cycle of length `1 (u-v) + 1 (v-x) + (odd path from x to u)`.\n\n  Let's count how many pairs of vertices `(u, x)` are there such that `u` and `x` are in the same component and have different colors. This is `sum(L * R for L, R in component_sizes)`. Let this sum be `P_diff`.\n  The number of choices for `v` that is not `u` or `x` is `N - 2`.\n  So, `P_diff * (N - 2)` ways.\n  However, this counts ordered triples `(u, v, x)`.\n  If we pick `u, x` from `C_1` (different colors), and `v` from `C_2`.\n  We add `(u, v)` and `(v, x)`.\n  Total ways for `t=2`:\n  Iterate over each component `C_i` with `L_i, R_i` vertices.\n  For each `C_i`, we can pick `u` from `L_i`, `x` from `R_i` (`L_i * R_i` ways).\n  Then pick `v` from *any* of the remaining `N - (L_i + R_i)` vertices.\n  Summing this over all `C_i`: `sum(L_i * R_i * (N - (L_i + R_i)) for L_i, R_i in component_sizes)`.\n  This is `w_2`.\n\n  If `w_1 == 0` and `w_2 > 0`:\n    Minimum edges to add `t = 2`.\n    Number of ways `w = w_2`.\n\n  **Subcase 1.3: If `w_1 == 0` and `w_2 == 0`, can we achieve `t = 3`?**\n  `w_1 = 0` implies `L <= 1` and `R <= 1` for all components. So components are isolated vertices or single edges.\n  `w_2 = 0` implies `L * R * (N - (L + R)) = 0` for all components.\n  Since `L <= 1, R <= 1`, `L*R` can be 0 (isolated vertex) or 1 (single edge).\n  If `L*R = 1` (a component is a single edge `(u,x)`), then `N - (L+R) = N - 2`.\n  If `N - 2 > 0`, then `w_2 > 0`.\n  So `w_2 = 0` implies either `L*R=0` for all components OR `N-2=0`.\n  If `N=1` or `N=2`, then `N-2=0`.\n  If `N=1`, it's an isolated vertex. `L=1, R=0`. `w_1=0, w_2=0`.\n  If `N=2`, it's either two isolated vertices or one edge.\n    - Two isolated vertices: `C_1=(1,0), C_2=(1,0)`. `w_1=0`. `w_2=0`.\n    - One edge: `C_1=(1,1)`. `w_1=0`. `w_2=0`.\n  In these cases (`N=1` or `N=2`), we cannot form an odd cycle with `t=1` or `t=2` edges.\n  For `N=1`, we need to add a loop, which is forbidden. We need at least 3 vertices for an odd cycle. So `t` is impossible. Wait, the problem says \"consisting of more than one vertex\". My interpretation of \"simple cycle\" means distinct vertices, so min length 3.\n  If `N=1`, `t=3` is not possible. The problem guarantees `N >= 1`.\n  If `N=2`, we have `A, B`.\n    - `A, B` isolated: add `(A,B), (B,A), (A,A)`. Forbidden. Min 3 vertices for odd cycle.\n    - `(A,B)` exists: already bipartite. Need 3rd vertex. Not possible.\n  So for `N=1` or `N=2`, `t` is impossible if `w_1=0, w_2=0`.\n  The problem statement implies `t` is always possible. This means `N >= 3` if `t=3`.\n\n  If `w_1 = 0` and `w_2 = 0`, it means all connected components are either isolated vertices (`L=1, R=0` or `L=0, R=1`) or single edges (`L=1, R=1`), AND if there's any component that is a single edge, then `N-2` must be 0 (i.e., `N=2`).\n  So if `N > 2`, then all `L*R` must be 0, meaning all components are isolated vertices.\n  In this scenario, `m=0` (no edges at all).\n  We need to pick three distinct vertices `u, v, x` and add edges `(u,v), (v,x), (x,u)`.\n  This forms a triangle, which is an odd cycle of length 3.\n  The number of ways `w_3` is `N * (N-1) * (N-2) / (3 * 2 * 1)` (choose 3 vertices).\n  This is `N choose 3`.\n  If `N >= 3`:\n    Minimum edges to add `t = 3`.\n    Number of ways `w = N * (N - 1) * (N - 2) // 6`.\n\nFinal Logic:\n1. Perform BFS/DFS to check bipartiteness and get component sizes `(L, R)`.\n2. If graph is not bipartite: `t = 0, w = 1`.\n3. If graph is bipartite:\n   a. Calculate `w_1 = sum(L * (L - 1) // 2 + R * (R - 1) // 2 for L, R in component_sizes)`.\n   b. If `w_1 > 0`: `t = 1, w = w_1`.\n   c. Else (`w_1 == 0`):\n      i. Calculate `w_2 = sum(L * R * (N - (L + R)) for L, R in component_sizes)`.\n      ii. If `w_2 > 0`: `t = 2, w = w_2`.\n      iii. Else (`w_2 == 0`):\n          `t = 3, w = N * (N - 1) * (N - 2) // 6`. (This handles `N < 3` correctly as `w` will be 0, which implies `t=3` is not possible, but problem implies it's always possible. The constraints are `N >= 1`. If `N < 3`, `N*(N-1)*(N-2)` is 0. If `N=1` or `N=2`, a cycle of length > 1 is impossible. The problem statement \"consisting of more than one vertex\" for an odd cycle implies minimum length 3. So `N=1, N=2` cannot form an odd cycle. This means the problem implies `N >= 3` if `t=3`.\n          The examples cover `N=3, M=0` resulting in `t=3, w=1`. `3*2*1/6 = 1`. This confirms `N choose 3` for `t=3`.\n\nLet's trace the examples:\n\nExample 1:\n4 4\n1 2\n1 3\n4 2\n4 3\nGraph: 1-2, 1-3, 4-2, 4-3.\nBFS from 1:\ncolor[1]=0\nQ=[(1,0)]\nPop (1,0). Neighbors 2,3.\n  color[2]=1, Q.push((2,1))\n  color[3]=1, Q.push((3,1))\nQ=[(2,1), (3,1)]\nPop (2,1). Neighbors 1,4.\n  color[1]=0 (different from 1). OK.\n  color[4]=0, Q.push((4,0))\nQ=[(3,1), (4,0)]\nPop (3,1). Neighbors 1,4.\n  color[1]=0 (different from 1). OK.\n  color[4]=0 (different from 1). OK.\nQ=[(4,0)]\nPop (4,0). Neighbors 2,3.\n  color[2]=1 (different from 0). OK.\n  color[3]=1 (different from 0). OK.\nQ=[]\nAll vertices visited. No conflicts. Graph is bipartite.\nComponent: {1,2,3,4}.\nPartition L={1,4} (color 0), R={2,3} (color 1).\n`L=2, R=2`.\n`is_bipartite = True`.\n`component_sizes = [(2,2)]`.\n\nCalculate `w_1`:\n`L*(L-1)//2 + R*(R-1)//2 = 2*(2-1)//2 + 2*(2-1)//2 = 1 + 1 = 2`.\n`w_1 = 2`.\nSince `w_1 > 0`, `t = 1, w = 2`.\nOutput: `1 2`. Correct.\n\nExample 2:\n3 3\n1 2\n2 3\n3 1\nGraph: 1-2, 2-3, 3-1. This is a triangle.\nBFS from 1:\ncolor[1]=0\nQ=[(1,0)]\nPop (1,0). Neighbors 2,3.\n  color[2]=1, Q.push((2,1))\n  color[3]=1, Q.push((3,1))\nQ=[(2,1), (3,1)]\nPop (2,1). Neighbors 1,3.\n  color[1]=0 (different from 1). OK.\n  color[3]=1 (same as 2). Conflict! `is_bipartite = False`.\nWe found an odd cycle.\n`is_bipartite = False`.\n`t = 0, w = 1`.\nOutput: `0 1`. Correct.\n\nExample 3:\n3 0\nGraph: 3 isolated vertices.\nBFS from 1:\ncolor[1]=0. L=1, R=0. Component (1,0).\nBFS from 2:\ncolor[2]=0. L=1, R=0. Component (1,0).\nBFS from 3:\ncolor[3]=0. L=1, R=0. Component (1,0).\n`is_bipartite = True`.\n`component_sizes = [(1,0), (1,0), (1,0)]`.\n\nCalculate `w_1`:\nFor each component `(1,0)`: `1*(1-1)//2 + 0*(0-1)//2 = 0 + 0 = 0`.\nSum over all components: `w_1 = 0 + 0 + 0 = 0`.\nSince `w_1 == 0`, move to `t=2` case.\n\nCalculate `w_2`: `N=3`.\nFor each component `(L, R) = (1,0)`:\n`L * R * (N - (L + R)) = 1 * 0 * (3 - (1+0)) = 0`.\nSum over all components: `w_2 = 0 + 0 + 0 = 0`.\nSince `w_2 == 0`, move to `t=3` case.\n\nCalculate `w_3`:\n`t = 3`.\n`w = N * (N - 1) * (N - 2) // 6 = 3 * (3 - 1) * (3 - 2) // 6 = 3 * 2 * 1 // 6 = 1`.\nOutput: `3 1`. Correct.\n\nThe logic seems sound.\n\n```python\nimport sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n\n    colors = [-1] * (n + 1) # -1: unvisited, 0: color 0, 1: color 1\n    is_graph_bipartite = True\n    component_sizes = [] # Stores (count_L, count_R) for each bipartite component\n\n    for i in range(1, n + 1):\n        if colors[i] == -1:\n            q = deque()\n            q.append((i, 0)) # (vertex, color)\n            colors[i] = 0\n            \n            current_component_is_bipartite = True\n            count_L = 0\n            count_R = 0\n            \n            # Store vertices in current component to count L and R\n            component_vertices = []\n            \n            head = 0 # manually manage queue for performance, or use list.pop(0)\n            while head < len(q):\n                u, c = q[head]\n                head += 1\n\n                component_vertices.append(u)\n\n                if c == 0:\n                    count_L += 1\n                else:\n                    count_R += 1\n\n                for v in adj[u]:\n                    if colors[v] == -1:\n                        colors[v] = 1 - c\n                        q.append((v, 1 - c))\n                    elif colors[v] == c:\n                        is_graph_bipartite = False\n                        current_component_is_bipartite = False\n            \n            # After processing a component, if it was bipartite, save its partition sizes\n            if current_component_is_bipartite:\n                component_sizes.append((count_L, count_R))\n\n    if not is_graph_bipartite:\n        # Case 0: Graph already contains an odd cycle\n        print(0, 1)\n    else:\n        # Case 1: Graph is bipartite\n        # Try t = 1\n        w1 = 0\n        for l_size, r_size in component_sizes:\n            # Add edge between two vertices of same color within a component\n            # Number of pairs of vertices in L: L*(L-1)/2\n            # Number of pairs of vertices in R: R*(R-1)/2\n            w1 += l_size * (l_size - 1) // 2\n            w1 += r_size * (r_size - 1) // 2\n        \n        if w1 > 0:\n            print(1, w1)\n        else:\n            # Try t = 2\n            w2 = 0\n            # To form an odd cycle with 2 edges, pick 3 distinct vertices u, v, x.\n            # Add edges (u,v) and (v,x).\n            # If u and x are in the same component and have different colors,\n            # then path u-...-x has odd length.\n            # Cycle u-v-x-...-u has length 1 + 1 + odd = odd.\n            \n            # Iterate through each component C_i\n            for l_size, r_size in component_sizes:\n                # Pick u from L_i, x from R_i (or vice versa). L_i * R_i ways.\n                # Pick v from any vertex not in C_i. N - (L_i + R_i) ways.\n                # Total for this C_i: (L_i * R_i) * (N - (L_i + R_i))\n                w2 += l_size * r_size * (n - (l_size + r_size))\n            \n            if w2 > 0:\n                print(2, w2)\n            else:\n                # Try t = 3\n                # This implies all components are isolated vertices or single edges,\n                # and if there are single edges, N must be 2.\n                # So if N > 2, all components must be isolated vertices (m=0).\n                # To form an odd cycle (a triangle), pick 3 distinct vertices and add 3 edges.\n                # Number of ways to choose 3 vertices from N: N C 3\n                if n >= 3:\n                    w3 = n * (n - 1) * (n - 2) // 6\n                else:\n                    # Should not happen based on problem constraints and examples\n                    # if n < 3, it's impossible to form an odd cycle (min length 3).\n                    # The problem implies it's always possible. This means n >= 3\n                    # will always be true if we reach this point.\n                    w3 = 0 \n                print(3, w3)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n\n    colors = [-1] * (n + 1) # -1: unvisited, 0: color 0, 1: color 1\n    is_graph_bipartite = True\n    component_sizes = [] # Stores (count_L, count_R) for each bipartite component\n\n    for i in range(1, n + 1):\n        if colors[i] == -1:\n            q = deque()\n            q.append((i, 0)) # (vertex, color)\n            colors[i] = 0\n            \n            current_component_is_bipartite = True\n            count_L = 0\n            count_R = 0\n            \n            # Store vertices in current component to count L and R\n            component_vertices = []\n            \n            head = 0 # manually manage queue for performance, or use list.pop(0)\n            while head < len(q):\n                u, c = q[head]\n                head += 1\n\n                component_vertices.append(u)\n\n                if c == 0:\n                    count_L += 1\n                else:\n                    count_R += 1\n\n                for v in adj[u]:\n                    if colors[v] == -1:\n                        colors[v] = 1 - c\n                        q.append((v, 1 - c))\n                    elif colors[v] == c:\n                        is_graph_bipartite = False\n                        current_component_is_bipartite = False\n            \n            # After processing a component, if it was bipartite, save its partition sizes\n            if current_component_is_bipartite:\n                component_sizes.append((count_L, count_R))\n\n    if not is_graph_bipartite:\n        # Case 0: Graph already contains an odd cycle\n        print(0, 1)\n    else:\n        # Case 1: Graph is bipartite\n        # Try t = 1\n        w1 = 0\n        for l_size, r_size in component_sizes:\n            # Add edge between two vertices of same color within a component\n            # Number of pairs of vertices in L: L*(L-1)/2\n            # Number of pairs of vertices in R: R*(R-1)/2\n            w1 += l_size * (l_size - 1) // 2\n            w1 += r_size * (r_size - 1) // 2\n        \n        if w1 > 0:\n            print(1, w1)\n        else:\n            # Try t = 2\n            w2 = 0\n            # To form an odd cycle with 2 edges, pick 3 distinct vertices u, v, x.\n            # Add edges (u,v) and (v,x).\n            # If u and x are in the same component and have different colors,\n            # then path u-...-x has odd length.\n            # Cycle u-v-x-...-u has length 1 + 1 + odd = odd.\n            \n            # Iterate through each component C_i\n            for l_size, r_size in component_sizes:\n                # Pick u from L_i, x from R_i (or vice versa). L_i * R_i ways.\n                # Pick v from any vertex not in C_i. N - (L_i + R_i) ways.\n                # Total for this C_i: (L_i * R_i) * (N - (L_i + R_i))\n                w2 += l_size * r_size * (n - (l_size + r_size))\n            \n            if w2 > 0:\n                print(2, w2)\n            else:\n                # Try t = 3\n                # This implies all components are isolated vertices or single edges,\n                # and if there are single edges, N must be 2.\n                # So if N > 2, all components must be isolated vertices (m=0).\n                # To form an odd cycle (a triangle), pick 3 distinct vertices and add 3 edges.\n                # Number of ways to choose 3 vertices from N: N C 3\n                if n >= 3:\n                    w3 = n * (n - 1) * (n - 2) // 6\n                else:\n                    # Should not happen based on problem constraints and examples\n                    # if n < 3, it's impossible to form an odd cycle (min length 3).\n                    # The problem implies it's always possible. This means n >= 3\n                    # will always be true if we reach this point.\n                    w3 = 0 \n                print(3, w3)\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 604,
        "completion_token_count": 6373,
        "thoughts_token_count": 820
    }
}