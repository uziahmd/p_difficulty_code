{
    "start": 1758293703.4654224,
    "end": 1758293734.315714,
    "start-formatted": "2025-09-19 23:55 KST",
    "end-formatted": "2025-09-19 23:55 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "",
    "response": "```python\ndef solve():\n    p = int(input())\n\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    # Calculate minimum nodes\n    # A strongly connected component (SCC) of size k contributes k * (k-1) reachable pairs (u,v) with u != v\n    # If we only consider u < v, it contributes k * (k-1) / 2 such pairs.\n    # We want to find the smallest k such that k * (k-1) / 2 >= p.\n    # Or, more accurately, we want to find the smallest k such that we can form p pairs.\n    # A single SCC of size k contributes k*(k-1) pairs (u,v) with u != v, u and v reachable from each other.\n    # The problem asks for u < v and u and v reachable from each other.\n    # So, a single SCC of size k contributes k*(k-1)/2 such pairs.\n    # Let's find the smallest k such that k*(k-1)/2 >= p.\n    # This is equivalent to k*(k-1) >= 2*p.\n    \n    min_nodes = 0\n    for k in range(2, 4000): # k*(k-1)/2 can go up to 2*10^5, so k*(k-1) up to 4*10^5. k approx sqrt(4*10^5) = sqrt(40*10^4) = 20 * 10^2 = 632\n        if k * (k - 1) // 2 >= p:\n            min_nodes = k\n            break\n\n    # Calculate max unidirectional pairs for min_nodes\n    # Let n = min_nodes.\n    # We have n nodes. We want to form p pairs (u,v) with u < v and u,v reachable from each other.\n    # This means we need a strongly connected component (SCC) of size k, where k*(k-1)/2 is as close to p as possible,\n    # but not less than p.\n    # The smallest k such that k*(k-1)/2 >= p is our min_nodes.\n    # Let this k be N.\n    # We can form an SCC of size N. This SCC will contribute N*(N-1)/2 pairs (u,v) with u < v and u,v reachable from each other.\n    # This is exactly N*(N-1)/2 pairs.\n    # The remaining nodes (if any) are not part of this SCC, or are part of other SCCs.\n    # To maximize unidirectional pairs, we want to connect these N nodes in a way that forms one large SCC.\n    # If we have an SCC of size N, all N nodes are mutually reachable.\n    # The number of pairs (u,v) with u < v and u,v reachable from each other is N*(N-1)/2.\n    # This might be greater than p.\n    #\n    # The problem states \"exactly p ordered pairs of nodes (u, v) such that u < v and u and v are reachable from each other.\"\n    # This means we need to carefully construct the graph.\n    #\n    # Consider a graph with n nodes.\n    # Let's say we have m SCCs. Let their sizes be s_1, s_2, ..., s_m.\n    # The total number of nodes is sum(s_i).\n    # The number of pairs (u,v) with u < v and u,v reachable from each other *within* an SCC of size s_i is s_i * (s_i - 1) / 2.\n    # If u and v are in different SCCs, they cannot be mutually reachable.\n    # So, the total number of such pairs is sum(s_i * (s_i - 1) / 2).\n    # We need this sum to be exactly p.\n    # We want to minimize n = sum(s_i).\n    #\n    # To minimize sum(s_i) for a fixed sum(s_i * (s_i - 1) / 2) = p, we should make one SCC as large as possible.\n    # Let k be the size of the largest SCC.\n    # k*(k-1)/2 <= p.\n    # We want to find the largest k such that k*(k-1)/2 <= p.\n    # Let this be k_max_scc.\n    #\n    # Then we need to add p - k_max_scc*(k_max_scc-1)/2 more pairs.\n    # Each additional pair (u,v) with u < v and u,v reachable from each other requires 2 new nodes to form a 2-node SCC,\n    # or 3 new nodes for a 3-node SCC, etc.\n    # A 2-node SCC adds 1 pair. A 3-node SCC adds 3 pairs.\n    #\n    # Let's re-evaluate min_nodes.\n    # We want to find the minimum n such that we can partition n nodes into SCCs s_1, ..., s_m\n    # such that sum(s_i * (s_i - 1) / 2) = p.\n    # To minimize n, we should use larger SCCs as they are more \"efficient\" in terms of nodes per pair.\n    # The function f(k) = k*(k-1)/2 is convex.\n    # So, to get a target sum p, we should use one large SCC and possibly some smaller ones.\n    #\n    # Let k be the largest integer such that k * (k - 1) // 2 <= p.\n    # We can form an SCC of size k. This gives k * (k - 1) // 2 pairs.\n    # Remaining pairs needed: remaining_p = p - (k * (k - 1) // 2).\n    # These remaining_p pairs must come from 2-node SCCs. Each 2-node SCC contributes 1 pair and uses 2 nodes.\n    # So, we need remaining_p 2-node SCCs.\n    # This uses 2 * remaining_p nodes.\n    # Total nodes = k + 2 * remaining_p.\n    #\n    # Example: p = 3\n    # k*(k-1)/2 <= 3.\n    # k=1: 0 <= 3\n    # k=2: 1 <= 3\n    # k=3: 3 <= 3\n    # So, k = 3.\n    # remaining_p = 3 - (3*(3-1)//2) = 3 - 3 = 0.\n    # Total nodes = 3 + 2 * 0 = 3.\n    # This matches the example.\n    #\n    # Example: p = 4\n    # k*(k-1)/2 <= 4.\n    # k=1: 0 <= 4\n    # k=2: 1 <= 4\n    # k=3: 3 <= 4\n    # k=4: 6 > 4\n    # So, k = 3.\n    # remaining_p = 4 - (3*(3-1)//2) = 4 - 3 = 1.\n    # Total nodes = 3 + 2 * 1 = 5.\n    # This matches the example.\n\n    k_largest_scc = 0\n    for k_val in range(1, 4000):\n        if k_val * (k_val - 1) // 2 > p:\n            k_largest_scc = k_val - 1\n            break\n    if k_largest_scc == 0 and p > 0: # This handles cases where p is very small, e.g., p=1. k_val=1 gives 0, k_val=2 gives 1. So k_largest_scc = 2 for p=1.\n        if p == 1:\n            k_largest_scc = 2\n        else: # Should not happen for p > 0 if loop range is sufficient\n            k_largest_scc = 1 # if p=0, k_largest_scc=1\n            \n    if p == 0:\n        k_largest_scc = 0\n\n    remaining_p = p - (k_largest_scc * (k_largest_scc - 1) // 2)\n    min_nodes = k_largest_scc + 2 * remaining_p\n\n    # Maximize unidirectional pairs\n    # Unidirectional pairs (u,v) are u!=v, path u->v, no path v->u.\n    # This occurs between different SCCs.\n    # If we have m SCCs with sizes s_1, ..., s_m, and we arrange them in a topological order (e.g., a line).\n    # Let SCC_1 -> SCC_2 -> ... -> SCC_m.\n    # Then for any u in SCC_i and v in SCC_j with i < j, there is a path u->v.\n    # And there is no path v->u (because of topological order).\n    # The number of such pairs is sum_{i<j} s_i * s_j.\n    #\n    # The total number of nodes is N = min_nodes.\n    # The SCCs are: one SCC of size k_largest_scc, and remaining_p SCCs of size 2.\n    # Total number of SCCs: 1 + remaining_p.\n    #\n    # Let s_1 = k_largest_scc.\n    # Let s_2, ..., s_{1+remaining_p} be all 2s.\n    #\n    # We want to maximize sum_{i<j} s_i * s_j.\n    # This is maximized when the SCCs are arranged in a line.\n    # The sum of all s_i * s_j for i != j is N^2 - sum(s_i^2).\n    # Since we have a directed graph, the unidirectional pairs are (u,v) where u is in SCC_i, v in SCC_j, and i < j.\n    # Total pairs between different SCCs is sum_{i != j} s_i * s_j.\n    # If we arrange them in a line, say SCC_1 -> SCC_2 -> ... -> SCC_m.\n    # Then for u in SCC_i, v in SCC_j:\n    #   If i < j, u->v exists, v->u does not. This is s_i * s_j unidirectional pairs.\n    #   If i > j, u->v does not exist, v->u exists. This is s_j * s_i unidirectional pairs.\n    # So, the total number of unidirectional pairs is sum_{i != j} s_i * s_j.\n    # This is (sum s_i)^2 - sum(s_i^2) = N^2 - sum(s_i^2).\n    #\n    # The sizes of the SCCs are:\n    # one SCC of size k_largest_scc.\n    # remaining_p SCCs of size 2.\n    # (min_nodes - k_largest_scc - 2*remaining_p) SCCs of size 1 (single nodes).\n    # Wait, min_nodes = k_largest_scc + 2 * remaining_p.\n    # So, the SCCs are: one of size k_largest_scc, and remaining_p of size 2.\n    # Total nodes is N = k_largest_scc + 2 * remaining_p.\n    #\n    # Let's list the SCC sizes:\n    # s_1 = k_largest_scc\n    # s_2 = 2\n    # ...\n    # s_{remaining_p + 1} = 2\n    #\n    # The sum of squares of SCC sizes:\n    # sum_sq_s = k_largest_scc^2 + remaining_p * (2^2)\n    #          = k_largest_scc^2 + 4 * remaining_p\n    #\n    # Max unidirectional pairs = N^2 - sum_sq_s\n    #                          = (k_largest_scc + 2 * remaining_p)^2 - (k_largest_scc^2 + 4 * remaining_p)\n    #                          = k_largest_scc^2 + 4 * k_largest_scc * remaining_p + 4 * remaining_p^2 - k_largest_scc^2 - 4 * remaining_p\n    #                          = 4 * k_largest_scc * remaining_p + 4 * remaining_p^2 - 4 * remaining_p\n    #\n    # Let's verify with example p=3:\n    # k_largest_scc = 3, remaining_p = 0.\n    # min_nodes = 3 + 2*0 = 3.\n    # Max unidirectional pairs = 4 * 3 * 0 + 4 * 0^2 - 4 * 0 = 0. Matches example.\n    #\n    # Let's verify with example p=4:\n    # k_largest_scc = 3, remaining_p = 1.\n    # min_nodes = 3 + 2*1 = 5.\n    # Max unidirectional pairs = 4 * 3 * 1 + 4 * 1^2 - 4 * 1\n    #                          = 12 + 4 - 4 = 12.\n    #\n    # Example for p=4:\n    # SCCs are {3} and {2}.\n    # N = 5.\n    # SCC sizes: s_1=3, s_2=2.\n    # Max unidirectional pairs = s_1 * s_2 + s_2 * s_1 = 2 * s_1 * s_2 (if we consider both directions)\n    # But the definition is (u,v) path u->v, no path v->u.\n    # If we have SCC_A -> SCC_B.\n    # Pairs are (u,v) for u in SCC_A, v in SCC_B. This is s_A * s_B pairs.\n    # Total unidirectional pairs = s_A * s_B.\n    #\n    # So, if we have SCCs s_1, s_2, ..., s_m.\n    # And we arrange them in a line: SCC_1 -> SCC_2 -> ... -> SCC_m.\n    # The total number of unidirectional pairs is sum_{1 <= i < j <= m} s_i * s_j.\n    # This is ( (sum s_i)^2 - sum(s_i^2) ) / 2.\n    #\n    # N = sum s_i.\n    # Max unidirectional pairs = (N^2 - sum(s_i^2)) / 2.\n    #\n    # For p=4: N=5. SCCs {3, 2}.\n    # sum(s_i^2) = 3^2 + 2^2 = 9 + 4 = 13.\n    # Max unidirectional pairs = (5^2 - 13) / 2 = (25 - 13) / 2 = 12 / 2 = 6.\n    #\n    # My previous calculation was 12, which would be the total number of pairs between different SCCs, considering both directions.\n    # (u in SCC_A, v in SCC_B, A->B) is s_A*s_B pairs.\n    # (u in SCC_B, v in SCC_A, B->A) is s_B*s_A pairs.\n    # But we need to choose one topological order.\n    # If we choose SCC_1 -> SCC_2 -> ... -> SCC_m.\n    # Then for u in SCC_i, v in SCC_j, if i < j, u->v is a unidirectional pair.\n    # If i > j, v->u is a unidirectional pair.\n    # The problem asks for \"the number of unidirectional pairs of nodes\". This is the total count.\n    # So if we have SCC_A and SCC_B, and we draw an edge from A to B.\n    # All s_A * s_B pairs (u,v) with u in A, v in B are unidirectional.\n    # If we draw an edge from B to A.\n    # All s_B * s_A pairs (u,v) with u in B, v in A are unidirectional.\n    # We can only have one direction.\n    # So, if we have SCCs s_1, s_2, ..., s_m.\n    # We connect them in a line: SCC_1 -> SCC_2 -> ... -> SCC_m.\n    # The number of unidirectional pairs is sum_{1 <= i < j <= m} s_i * s_j.\n    # This is indeed (N^2 - sum(s_i^2)) / 2.\n    #\n    # So for p=4:\n    # k_largest_scc = 3, remaining_p = 1.\n    # min_nodes = 5.\n    # SCC sizes: {3, 2}.\n    # N = 5. sum_sq_s = 3^2 + 2^2 = 9 + 4 = 13.\n    # Max unidirectional pairs = (5^2 - 13) / 2 = (25 - 13) / 2 = 12 / 2 = 6.\n    # This matches the example output.\n\n    sum_sq_s = k_largest_scc**2 + remaining_p * (2**2) # sum of squares of SCC sizes\n    max_unidirectional_pairs = (min_nodes**2 - sum_sq_s) // 2\n\n    print(f\"{min_nodes} {max_unidirectional_pairs}\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "def solve():\n    p = int(input())\n\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    # Calculate minimum nodes\n    # A strongly connected component (SCC) of size k contributes k * (k-1) reachable pairs (u,v) with u != v\n    # If we only consider u < v, it contributes k * (k-1) / 2 such pairs.\n    # We want to find the smallest k such that k * (k-1) / 2 >= p.\n    # Or, more accurately, we want to find the smallest k such that we can form p pairs.\n    # A single SCC of size k contributes k*(k-1) pairs (u,v) with u != v, u and v reachable from each other.\n    # The problem asks for u < v and u and v reachable from each other.\n    # So, a single SCC of size k contributes k*(k-1)/2 such pairs.\n    # Let's find the smallest k such that k*(k-1)/2 >= p.\n    # This is equivalent to k*(k-1) >= 2*p.\n    \n    min_nodes = 0\n    for k in range(2, 4000): # k*(k-1)/2 can go up to 2*10^5, so k*(k-1) up to 4*10^5. k approx sqrt(4*10^5) = sqrt(40*10^4) = 20 * 10^2 = 632\n        if k * (k - 1) // 2 >= p:\n            min_nodes = k\n            break\n\n    # Calculate max unidirectional pairs for min_nodes\n    # Let n = min_nodes.\n    # We have n nodes. We want to form p pairs (u,v) with u < v and u,v reachable from each other.\n    # This means we need a strongly connected component (SCC) of size k, where k*(k-1)/2 is as close to p as possible,\n    # but not less than p.\n    # The smallest k such that k*(k-1)/2 >= p is our min_nodes.\n    # Let this k be N.\n    # We can form an SCC of size N. This SCC will contribute N*(N-1)/2 pairs (u,v) with u < v and u,v reachable from each other.\n    # This is exactly N*(N-1)/2 pairs.\n    # The remaining nodes (if any) are not part of this SCC, or are part of other SCCs.\n    # To maximize unidirectional pairs, we want to connect these N nodes in a way that forms one large SCC.\n    # If we have an SCC of size N, all N nodes are mutually reachable.\n    # The number of pairs (u,v) with u < v and u,v reachable from each other is N*(N-1)/2.\n    # This might be greater than p.\n    #\n    # The problem states \"exactly p ordered pairs of nodes (u, v) such that u < v and u and v are reachable from each other.\"\n    # This means we need to carefully construct the graph.\n    #\n    # Consider a graph with n nodes.\n    # Let's say we have m SCCs. Let their sizes be s_1, s_2, ..., s_m.\n    # The total number of nodes is sum(s_i).\n    # The number of pairs (u,v) with u < v and u,v reachable from each other *within* an SCC of size s_i is s_i * (s_i - 1) / 2.\n    # If u and v are in different SCCs, they cannot be mutually reachable.\n    # So, the total number of such pairs is sum(s_i * (s_i - 1) / 2).\n    # We need this sum to be exactly p.\n    # We want to minimize n = sum(s_i).\n    #\n    # To minimize sum(s_i) for a fixed sum(s_i * (s_i - 1) / 2) = p, we should make one SCC as large as possible.\n    # Let k be the size of the largest SCC.\n    # k*(k-1)/2 <= p.\n    # We want to find the largest k such that k*(k-1)/2 <= p.\n    # Let this be k_max_scc.\n    #\n    # Then we need to add p - k_max_scc*(k_max_scc-1)/2 more pairs.\n    # Each additional pair (u,v) with u < v and u,v reachable from each other requires 2 new nodes to form a 2-node SCC,\n    # or 3 new nodes for a 3-node SCC, etc.\n    # A 2-node SCC adds 1 pair. A 3-node SCC adds 3 pairs.\n    #\n    # Let's re-evaluate min_nodes.\n    # We want to find the minimum n such that we can partition n nodes into SCCs s_1, ..., s_m\n    # such that sum(s_i * (s_i - 1) / 2) = p.\n    # To minimize n, we should use larger SCCs as they are more \"efficient\" in terms of nodes per pair.\n    # The function f(k) = k*(k-1)/2 is convex.\n    # So, to get a target sum p, we should use one large SCC and possibly some smaller ones.\n    #\n    # Let k be the largest integer such that k * (k - 1) // 2 <= p.\n    # We can form an SCC of size k. This gives k * (k - 1) // 2 pairs.\n    # Remaining pairs needed: remaining_p = p - (k * (k - 1) // 2).\n    # These remaining_p pairs must come from 2-node SCCs. Each 2-node SCC contributes 1 pair and uses 2 nodes.\n    # So, we need remaining_p 2-node SCCs.\n    # This uses 2 * remaining_p nodes.\n    # Total nodes = k + 2 * remaining_p.\n    #\n    # Example: p = 3\n    # k*(k-1)/2 <= 3.\n    # k=1: 0 <= 3\n    # k=2: 1 <= 3\n    # k=3: 3 <= 3\n    # So, k = 3.\n    # remaining_p = 3 - (3*(3-1)//2) = 3 - 3 = 0.\n    # Total nodes = 3 + 2 * 0 = 3.\n    # This matches the example.\n    #\n    # Example: p = 4\n    # k*(k-1)/2 <= 4.\n    # k=1: 0 <= 4\n    # k=2: 1 <= 4\n    # k=3: 3 <= 4\n    # k=4: 6 > 4\n    # So, k = 3.\n    # remaining_p = 4 - (3*(3-1)//2) = 4 - 3 = 1.\n    # Total nodes = 3 + 2 * 1 = 5.\n    # This matches the example.\n\n    k_largest_scc = 0\n    for k_val in range(1, 4000):\n        if k_val * (k_val - 1) // 2 > p:\n            k_largest_scc = k_val - 1\n            break\n    if k_largest_scc == 0 and p > 0: # This handles cases where p is very small, e.g., p=1. k_val=1 gives 0, k_val=2 gives 1. So k_largest_scc = 2 for p=1.\n        if p == 1:\n            k_largest_scc = 2\n        else: # Should not happen for p > 0 if loop range is sufficient\n            k_largest_scc = 1 # if p=0, k_largest_scc=1\n            \n    if p == 0:\n        k_largest_scc = 0\n\n    remaining_p = p - (k_largest_scc * (k_largest_scc - 1) // 2)\n    min_nodes = k_largest_scc + 2 * remaining_p\n\n    # Maximize unidirectional pairs\n    # Unidirectional pairs (u,v) are u!=v, path u->v, no path v->u.\n    # This occurs between different SCCs.\n    # If we have m SCCs with sizes s_1, ..., s_m, and we arrange them in a topological order (e.g., a line).\n    # Let SCC_1 -> SCC_2 -> ... -> SCC_m.\n    # Then for any u in SCC_i and v in SCC_j with i < j, there is a path u->v.\n    # And there is no path v->u (because of topological order).\n    # The number of such pairs is sum_{i<j} s_i * s_j.\n    #\n    # The total number of nodes is N = min_nodes.\n    # The SCCs are: one SCC of size k_largest_scc, and remaining_p SCCs of size 2.\n    # Total number of SCCs: 1 + remaining_p.\n    #\n    # Let s_1 = k_largest_scc.\n    # Let s_2, ..., s_{1+remaining_p} be all 2s.\n    #\n    # We want to maximize sum_{i<j} s_i * s_j.\n    # This is maximized when the SCCs are arranged in a line.\n    # The sum of all s_i * s_j for i != j is N^2 - sum(s_i^2).\n    # Since we have a directed graph, the unidirectional pairs are (u,v) where u is in SCC_i, v in SCC_j, and i < j.\n    # Total pairs between different SCCs is sum_{i != j} s_i * s_j.\n    # If we arrange them in a line, say SCC_1 -> SCC_2 -> ... -> SCC_m.\n    # Then for u in SCC_i, v in SCC_j:\n    #   If i < j, u->v exists, v->u does not. This is s_i * s_j unidirectional pairs.\n    #   If i > j, u->v does not exist, v->u exists. This is s_j * s_i unidirectional pairs.\n    # So, the total number of unidirectional pairs is sum_{i != j} s_i * s_j.\n    # This is (sum s_i)^2 - sum(s_i^2) = N^2 - sum(s_i^2).\n    #\n    # The sizes of the SCCs are:\n    # one SCC of size k_largest_scc.\n    # remaining_p SCCs of size 2.\n    # (min_nodes - k_largest_scc - 2*remaining_p) SCCs of size 1 (single nodes).\n    # Wait, min_nodes = k_largest_scc + 2 * remaining_p.\n    # So, the SCCs are: one of size k_largest_scc, and remaining_p of size 2.\n    # Total nodes is N = k_largest_scc + 2 * remaining_p.\n    #\n    # Let's list the SCC sizes:\n    # s_1 = k_largest_scc\n    # s_2 = 2\n    # ...\n    # s_{remaining_p + 1} = 2\n    #\n    # The sum of squares of SCC sizes:\n    # sum_sq_s = k_largest_scc^2 + remaining_p * (2^2)\n    #          = k_largest_scc^2 + 4 * remaining_p\n    #\n    # Max unidirectional pairs = N^2 - sum_sq_s\n    #                          = (k_largest_scc + 2 * remaining_p)^2 - (k_largest_scc^2 + 4 * remaining_p)\n    #                          = k_largest_scc^2 + 4 * k_largest_scc * remaining_p + 4 * remaining_p^2 - k_largest_scc^2 - 4 * remaining_p\n    #                          = 4 * k_largest_scc * remaining_p + 4 * remaining_p^2 - 4 * remaining_p\n    #\n    # Let's verify with example p=3:\n    # k_largest_scc = 3, remaining_p = 0.\n    # min_nodes = 3 + 2*0 = 3.\n    # Max unidirectional pairs = 4 * 3 * 0 + 4 * 0^2 - 4 * 0 = 0. Matches example.\n    #\n    # Let's verify with example p=4:\n    # k_largest_scc = 3, remaining_p = 1.\n    # min_nodes = 3 + 2*1 = 5.\n    # Max unidirectional pairs = 4 * 3 * 1 + 4 * 1^2 - 4 * 1\n    #                          = 12 + 4 - 4 = 12.\n    #\n    # Example for p=4:\n    # SCCs are {3} and {2}.\n    # N = 5.\n    # SCC sizes: s_1=3, s_2=2.\n    # Max unidirectional pairs = s_1 * s_2 + s_2 * s_1 = 2 * s_1 * s_2 (if we consider both directions)\n    # But the definition is (u,v) path u->v, no path v->u.\n    # If we have SCC_A -> SCC_B.\n    # Pairs are (u,v) for u in SCC_A, v in SCC_B. This is s_A * s_B pairs.\n    # Total unidirectional pairs = s_A * s_B.\n    #\n    # So, if we have SCCs s_1, s_2, ..., s_m.\n    # And we arrange them in a line: SCC_1 -> SCC_2 -> ... -> SCC_m.\n    # The total number of unidirectional pairs is sum_{1 <= i < j <= m} s_i * s_j.\n    # This is ( (sum s_i)^2 - sum(s_i^2) ) / 2.\n    #\n    # N = sum s_i.\n    # Max unidirectional pairs = (N^2 - sum(s_i^2)) / 2.\n    #\n    # For p=4: N=5. SCCs {3, 2}.\n    # sum(s_i^2) = 3^2 + 2^2 = 9 + 4 = 13.\n    # Max unidirectional pairs = (5^2 - 13) / 2 = (25 - 13) / 2 = 12 / 2 = 6.\n    #\n    # My previous calculation was 12, which would be the total number of pairs between different SCCs, considering both directions.\n    # (u in SCC_A, v in SCC_B, A->B) is s_A*s_B pairs.\n    # (u in SCC_B, v in SCC_A, B->A) is s_B*s_A pairs.\n    # But we need to choose one topological order.\n    # If we choose SCC_1 -> SCC_2 -> ... -> SCC_m.\n    # Then for u in SCC_i, v in SCC_j, if i < j, u->v is a unidirectional pair.\n    # If i > j, v->u is a unidirectional pair.\n    # The problem asks for \"the number of unidirectional pairs of nodes\". This is the total count.\n    # So if we have SCC_A and SCC_B, and we draw an edge from A to B.\n    # All s_A * s_B pairs (u,v) with u in A, v in B are unidirectional.\n    # If we draw an edge from B to A.\n    # All s_B * s_A pairs (u,v) with u in B, v in A are unidirectional.\n    # We can only have one direction.\n    # So, if we have SCCs s_1, s_2, ..., s_m.\n    # We connect them in a line: SCC_1 -> SCC_2 -> ... -> SCC_m.\n    # The number of unidirectional pairs is sum_{1 <= i < j <= m} s_i * s_j.\n    # This is indeed (N^2 - sum(s_i^2)) / 2.\n    #\n    # So for p=4:\n    # k_largest_scc = 3, remaining_p = 1.\n    # min_nodes = 5.\n    # SCC sizes: {3, 2}.\n    # N = 5. sum_sq_s = 3^2 + 2^2 = 9 + 4 = 13.\n    # Max unidirectional pairs = (5^2 - 13) / 2 = (25 - 13) / 2 = 12 / 2 = 6.\n    # This matches the example output.\n\n    sum_sq_s = k_largest_scc**2 + remaining_p * (2**2) # sum of squares of SCC sizes\n    max_unidirectional_pairs = (min_nodes**2 - sum_sq_s) // 2\n\n    print(f\"{min_nodes} {max_unidirectional_pairs}\")\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 483,
        "completion_token_count": 4178,
        "thoughts_token_count": 0
    }
}