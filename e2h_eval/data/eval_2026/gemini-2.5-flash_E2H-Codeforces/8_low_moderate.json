{
    "start": 1758009393.2491264,
    "end": 1758009486.5108125,
    "start-formatted": "2025-09-16 16:56 KST",
    "end-formatted": "2025-09-16 16:58 KST",
    "gpu": 2,
    "pid": 8,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "**Solving the Flawed Flow Problem**\n\nOkay, so I'm looking at this \"Flawed Flow\" problem, and my immediate goal is to figure out a Python script to tackle it. Let's break down my thought process.\n\nFirst, I've got the setup. We have an undirected graph with capacities on the edges, a source (vertex 1), and a sink (vertex `n`). The goal is to direct the edges and calculate the flow in each direction, making it an acyclic directed graph with a maximum flow.\n\nAnalyzing the core conditions is key. Flow conservation is crucial, especially for all the internal vertices (not the source or sink). This means the incoming flow must equal the outgoing flow at each vertex.  I also see that vertex 1 has no incoming edges. This tells me that all edges connected to the source must flow outwards.\n\nThe acyclicity constraint is a big hint. Since the source has no incoming edges, and we're looking for a DAG (directed acyclic graph), it feels like all flow must proceed \"forward\" from the source to the sink.  This suggests that a topological sort might be the backbone of a solution. If I can assign directions consistently with some topological ordering, I can guarantee acyclicity.\n\nNow, considering the flow at the sink (vertex `n`). The problem statement doesn't explicitly restrict outgoing edges from the sink, but it feels intuitive that in a *max-flow* scenario, we'd expect all flow to *end* at the sink.\n\nSo, here's my general strategy: I need to find some direction assignments for the edges such that:\n\n1.  Edges connected to the source (vertex 1) flow outwards.\n2.  The resulting graph is acyclic.\n3.  Flow is conserved at all internal vertices.\n4.  And importantly, the overall flow, from source to sink, has to be the maximum possible.\n\nI'm thinking I'll try to build this incrementally. Start with the source, and then see if I can propagate flow according to a topological order, ensuring the conservation constraints are satisfied at each internal node. I have a hunch that, if I can find a valid flow using this strategy, it will also be a maximum flow solution since the problem guarantees a valid solution exists, assuming the conditions are fulfilled.\n",
    "response": "The problem asks us to direct each edge of a given undirected graph, which has a specified flow volume `c_i` for each edge, such that the resulting directed graph represents a valid maximum flow. The conditions are:\n1.  For any internal vertex `v` (1 < `v` < `n`), the sum of incoming flow volumes equals the sum of outgoing flow volumes.\n2.  Vertex 1 (source) has no incoming edges.\n3.  The resulting directed graph is acyclic.\n4.  The flow should be a correct maximum flow (this is guaranteed to be possible).\n\nLet's analyze the conditions:\n\n*   **Source (vertex 1):** \"No incoming edges\" means all edges connected to vertex 1 must be directed *outwards* from vertex 1. This gives us initial directions for some edges.\n*   **Acyclicity:** This is a strong constraint. Combined with vertex 1 being the source and `n` being the sink, it implies that the flow generally moves from \"earlier\" vertices to \"later\" vertices in some topological ordering.\n*   **Flow Conservation:** For any internal vertex `v`, `sum(incoming flow) = sum(outgoing flow)`. This is the core of flow problems.\n\nConsider the total flow `F_v` passing through any cut `(S, T)` where `1 \\in S` and `n \\in T`. The total flow exiting `S` must be equal to the total flow entering `T`. Specifically, the total flow leaving vertex 1 must equal the total flow entering vertex `n`.\n\nLet's define `current_outflow[v]` as the sum of flow volumes `c_i` for edges already directed *out* of `v`.\nLet's define `current_inflow[v]` as the sum of flow volumes `c_i` for edges already directed *into* `v`.\n\nFor vertex 1, all its incident edges must be directed outwards. So, for an edge `(1, b)` with volume `c`, we direct it `1 -> b`. This adds `c` to `current_outflow[1]` and `current_inflow[b]`.\n\nFor vertex `n`, it's the sink. While the problem doesn't explicitly state it has no outgoing edges, in a typical max-flow setting, it only receives flow. More importantly, the problem guarantees a solution exists and requires acyclicity. This implies that flow should generally move towards `n`.\n\n**Strategy: Topological Sort / DFS-based approach**\n\nThe acyclicity condition is key. If we can assign directions such that all flow edges point from a vertex with a smaller \"level\" to a vertex with a larger \"level\", acyclicity is guaranteed. Since vertex 1 has no incoming edges, it can be considered the start of a topological sort.\n\nHowever, we don't know the topological order beforehand. We need to determine directions based on flow conservation. Let's consider the total flow `S_v` that *must* eventually pass through vertex `v` on its way from 1 to `n`. This isn't straightforward.\n\nA more direct approach using flow conservation and a \"deficit\" idea:\nFor any vertex `v` (1 < `v` < `n`), we need `sum(incoming flow) = sum(outgoing flow)`.\nLet `balance[v]` be `sum(outgoing flow) - sum(incoming flow)`. We want `balance[v] = 0` for `1 < v < n`.\nFor vertex 1, all edges must be outgoing, so `balance[1]` will be positive (total flow leaving source).\nFor vertex `n`, it will be negative (total flow entering sink).\n\nConsider a Depth First Search (DFS) starting from vertex 1. When we traverse an edge `(u, v)` from `u` to `v`:\n1.  If `v` is `n`, we can direct `u -> n`. This contributes to the total flow into `n`.\n2.  If `v` is already visited and `u` is its parent in the DFS tree, we don't re-process it.\n3.  If `v` is already visited and `u` is *not* its parent (i.e., `(u,v)` is a back-edge or cross-edge), we have to be careful not to create cycles. Since the final graph must be acyclic, any such edge `(u,v)` must be directed either `u -> v` or `v -> u` such that it respects some topological order. If we're doing a DFS, and `v` has already been *finished* (all its descendants visited and processed), then `v -> u` would be a back-edge in the directed graph, which is problematic for acyclicity if `u` is an ancestor of `v`. If `v` is currently in the recursion stack (i.e., `v` is an ancestor of `u`), then `u -> v` would be a back-edge, forming a cycle. This suggests that during DFS, we should only direct edges from `u` to `v` if `v` has not been visited, or `v` has been visited and is not an ancestor of `u` and `v` is not `n`.\n\nThis problem structure often lends itself to a specific type of DFS:\nMaintain `current_flow_balance[v]` for each vertex `v`. Initially, all are 0.\nWhen we direct an edge `u -> v` with flow `c`:\n`current_flow_balance[u] -= c`\n`current_flow_balance[v] += c`\n\nThe key insight for acyclicity and flow conservation is to process vertices in a way that allows us to fulfill their flow balance requirements. Since vertex 1 has no incoming edges, all its incident edges must be outgoing. This is a starting point.\n\nLet's maintain `excess[v]` for each vertex `v`, representing `sum(incoming_flow) - sum(outgoing_flow)` for edges whose directions have been decided. Initially, `excess[v] = 0` for all `v`.\n\nWe can use a DFS from source 1.\nWhen we visit a vertex `u`, we iterate through its neighbors `v`.\n1.  If `v` is the parent of `u` in the DFS tree, we skip it for now. We will decide the direction of `(parent, u)` when returning from `u`.\n2.  If `v` is `n`, we can direct `u -> n`. This is always safe for acyclicity relative to `n` (as `n` is the sink, no outgoing edges are expected from `n` to `u` to form a cycle). We update `excess[u]` and `excess[n]`.\n3.  If `v` is already visited (and not parent), it's a cross-edge or back-edge. To ensure acyclicity, we must direct `v -> u` if `v` was visited *before* `u` in the DFS traversal, or `u -> v` if `u` was visited *before* `v`. A simpler approach for acyclicity is to only direct `u -> v` if `v` has not been visited yet (tree edge), or `v -> u` if `v` has been fully explored (processed).\n\nLet's try a simpler DFS approach, focusing on satisfying the flow balance for each vertex *except* source and sink.\nWe'll use `flow_deficit[v]` to track `sum(incoming_flow) - sum(outgoing_flow)` for edges whose directions are *already determined*.\nInitially, `flow_deficit[v] = 0` for all `v`.\nWe also need to keep track of visited vertices `visited[v]` and the parent in the DFS tree `parent[v]`.\n`edge_directions` will store the final answer.\n\n```python\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    edges_input_order = []\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n        edges_input_order.append((u, v, c))\n\n    # flow_balance[v] stores sum(incoming flow) - sum(outgoing flow)\n    # We want flow_balance[v] = 0 for 1 < v < n.\n    # For v=1, it will be negative (total flow out).\n    # For v=n, it will be positive (total flow in).\n    flow_balance = [0] * (n + 1)\n    \n    # edge_directions[i] = 0 if a_i -> b_i, 1 if b_i -> a_i\n    # Initialize with -1 to mark as undecided\n    edge_directions = [-1] * m\n\n    visited = [False] * (n + 1)\n    \n    # Stack for iterative DFS\n    # Each element is (u, parent_u_idx, neighbor_idx)\n    # parent_u_idx is the index of the edge connecting u to its parent\n    # neighbor_idx is the index of the next neighbor to visit from u\n    stack = [(1, -1, 0)] # (current_node, parent_edge_idx, neighbor_iterator_index)\n    visited[1] = True\n    \n    # Store the path for back-tracking\n    path_stack = []\n\n    # Main DFS loop\n    while stack:\n        u, parent_edge_idx, neighbor_idx = stack.pop()\n        \n        # If neighbor_idx is -1, it means we are returning from processing all children of u\n        # This is where we decide the direction of the edge (parent[u], u)\n        if neighbor_idx == -1:\n            # If u is not the source (1) and not the sink (n), its flow_balance must be 0.\n            # Any remaining non-zero balance must be handled by the edge to its parent.\n            if u != 1 and u != n:\n                if flow_balance[u] != 0:\n                    # The edge (parent_node, u) must carry this remaining balance.\n                    # parent_node is the other end of edges_input_order[parent_edge_idx]\n                    original_u, original_v, flow_c = edges_input_order[parent_edge_idx]\n                    \n                    # Determine which end of the parent_edge_idx is the parent_node\n                    parent_node = original_u if original_v == u else original_v\n\n                    if flow_balance[u] > 0: # u has an excess of incoming flow, so parent_node -> u\n                        # This means flow_c should go from parent_node to u\n                        # If (original_u, original_v) is (parent_node, u), then direction is 0\n                        # If (original_u, original_v) is (u, parent_node), then direction is 1\n                        if original_u == parent_node:\n                            edge_directions[parent_edge_idx] = 0\n                        else:\n                            edge_directions[parent_edge_idx] = 1\n                        \n                        flow_balance[parent_node] += flow_c # Parent receives flow from this edge\n                        flow_balance[u] -= flow_c # u's balance becomes 0\n                    else: # flow_balance[u] < 0, u has an excess of outgoing flow, so u -> parent_node\n                        # This means flow_c should go from u to parent_node\n                        # If (original_u, original_v) is (u, parent_node), then direction is 0\n                        # If (original_u, original_v) is (parent_node, u), then direction is 1\n                        if original_u == u:\n                            edge_directions[parent_edge_idx] = 0\n                        else:\n                            edge_directions[parent_edge_idx] = 1\n                        \n                        flow_balance[parent_node] -= flow_c # Parent sends flow through this edge\n                        flow_balance[u] += flow_c # u's balance becomes 0\n            continue # Finished processing u and its parent edge\n\n        # Push back u to continue processing its neighbors after the current one\n        stack.append((u, parent_edge_idx, neighbor_idx + 1))\n        \n        # Process current neighbor\n        if neighbor_idx < len(adj[u]):\n            v, c, edge_idx = adj[u][neighbor_idx]\n\n            if not visited[v]:\n                visited[v] = True\n                # This is a tree edge. We provisionally direct u -> v.\n                # This is a temporary direction for DFS traversal. The final direction\n                # for this edge will be decided when returning from v.\n                # Push v to stack.\n                stack.append((v, edge_idx, 0)) # v's parent edge is edge_idx\n            elif edge_directions[edge_idx] == -1: # Cross-edge or back-edge to an already visited node\n                # If v is already visited and its direction hasn't been set,\n                # we must direct it to avoid cycles.\n                # The acyclicity condition is crucial here. If v was visited\n                # and processed *before* u (i.e., v is not an ancestor of u in the DFS tree,\n                # and u is not an ancestor of v), then we can direct u -> v.\n                # A common strategy for DFS and acyclicity is to direct all cross/back edges\n                # from a \"higher\" DFS discovery time to a \"lower\" DFS discovery time,\n                # or from a visited node to a currently visiting node.\n                # Since we are processing neighbors of u, and v is already visited,\n                # we direct u -> v. This is usually safe for acyclicity in the context\n                # of a spanning tree if v is not an ancestor of u.\n                # Or, more robustly, if v is already completely processed (not on path_stack),\n                # direct u -> v. If v is on path_stack, then u -> v would be a back edge,\n                # forming a cycle. However, the problem guarantees a solution exists and\n                # the graph is connected.\n                \n                # A simpler approach for cross/back edges:\n                # If v is already visited, direct v -> u. This ensures flow generally moves\n                # from earlier-visited nodes to later-visited nodes, or from\n                # already-processed subtrees into the current subtree.\n                # This direction is generally safe for acyclicity.\n                \n                # Let's try directing u -> v for cross-edges.\n                # This contributes to u's outflow and v's inflow.\n                original_u, original_v, flow_c = edges_input_order[edge_idx]\n                \n                if original_u == u: # Original edge was (u, v), so u -> v is direction 0\n                    edge_directions[edge_idx] = 0\n                else: # Original edge was (v, u), so u -> v is direction 1\n                    edge_directions[edge_idx] = 1\n                \n                flow_balance[u] -= flow_c\n                flow_balance[v] += flow_c\n        else: # All neighbors of u processed, mark for post-order processing\n            stack.append((u, parent_edge_idx, -1)) # Sentinel for post-order processing\n\n    # Output the results\n    for direction in edge_directions:\n        sys.stdout.write(str(direction) + '\\n')\n\n```\n\nThe DFS approach described above, where we decide the direction of `(parent, u)` when returning from `u` based on `flow_balance[u]`, is a standard technique for these types of problems (e.g., Eulerian path reconstruction or flow problems on trees/DAGs). For cross-edges/back-edges (where `v` is visited but not the parent of `u`), we need a consistent rule that ensures acyclicity. Directing `u -> v` for such edges if `v` is already visited and `edge_directions[edge_idx]` is `-1` is a common choice.\n\nLet's refine the DFS logic for cross-edges and back-edges.\nA standard DFS creates a DFS tree. Edges can be:\n1.  **Tree edges:** `(u, v)` where `v` is unvisited. These form the DFS tree.\n2.  **Back edges:** `(u, v)` where `v` is an ancestor of `u` in the DFS tree.\n3.  **Forward edges:** `(u, v)` where `v` is a descendant of `u` (not direct child). This is rare in undirected graphs if we only consider `(u,v)` once.\n4.  **Cross edges:** `(u, v)` where `v` is neither an ancestor nor a descendant of `u`.\n\nTo ensure acyclicity, we must not direct `u -> v` for back edges. If `v` is an ancestor of `u`, we must direct `v -> u`. For cross edges, either `u -> v` or `v -> u` might work, as long as it respects a topological order. A simple rule is to always direct from the node visited earlier in DFS to the node visited later, or from the node whose subtree has been completely processed to the node whose subtree is currently being processed.\n\nA robust way to handle this is to use discovery and finish times (or just discovery times `disc[v]` and `on_stack[v]` to detect back-edges).\n`disc[v]` = discovery time of `v`.\n`on_stack[v]` = true if `v` is currently in the recursion stack (i.e., `v` is an ancestor of the current node).\n\nLet's use a cleaner iterative DFS:\n\n```python\nimport sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    # Store edges in input order to map edge_idx to original (u,v,c)\n    edges_input_order = []\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n        edges_input_order.append((u, v, c))\n\n    # flow_balance[v] = sum(incoming flow) - sum(outgoing flow) for decided edges\n    # We want flow_balance[v] = 0 for 1 < v < n.\n    flow_balance = [0] * (n + 1)\n    \n    # edge_directions[i]: 0 if a_i -> b_i, 1 if b_i -> a_i\n    # Initialize with -1 to mark as undecided\n    edge_directions = [-1] * m\n\n    visited = [False] * (n + 1)\n    \n    # Stack for iterative DFS. Each element: (u, parent_edge_idx)\n    # parent_edge_idx is the index of the edge connecting u to its parent in DFS tree.\n    # It's -1 for the source (node 1).\n    stack = [(1, -1)] \n    visited[1] = True\n    \n    # The DFS traversal will be managed by two lists:\n    # `dfs_order`: stores nodes in discovery order.\n    # `dfs_parent_edge`: stores the parent edge index for each node in `dfs_order`.\n    dfs_order = []\n    dfs_parent_edge = [-1] * (n + 1) # Stores parent edge index for each node\n    \n    # Simulate DFS to build the DFS tree and identify cross/back edges\n    dfs_stack = [(1, -1)] # (node, parent_edge_idx)\n    \n    # We need to explicitly track discovery order to process edges correctly\n    # For each node, we need to know which neighbors have been visited and which edge it came from\n    \n    # `parent_map[v]` stores the edge_idx that connects `v` to its parent in the DFS tree.\n    # `parent_map[1]` remains -1.\n    \n    # `iterators[u]` will store the index of the next neighbor to visit for `u`\n    iterators = [0] * (n + 1)\n\n    # Main DFS loop for building the tree and deciding cross-edge directions\n    # This loop pushes nodes onto `dfs_order` in post-order (when returning from children)\n    # This is effectively a standard iterative DFS:\n    # When processing u, push u onto `path_stack` (for detecting back-edges)\n    # For each neighbor v:\n    #   If v unvisited: recurse (or push to stack). (u,v) is a tree edge.\n    #   If v visited and v is on `path_stack` (ancestor of u): (u,v) is a back-edge. Direct v -> u.\n    #   If v visited and v is not on `path_stack` (cross-edge): Direct u -> v.\n    # When all children of u are processed, pop u from `path_stack`.\n    \n    # Using a single stack for iterative DFS (pre-order and post-order processing)\n    # Stack elements: (u, parent_edge_idx, current_neighbor_idx)\n    # If current_neighbor_idx is -1, it means we're in post-order processing for u.\n    \n    dfs_iter_stack = [(1, -1, 0)] # (node, parent_edge_idx, neighbor_iterator_index)\n    visited[1] = True\n    \n    # A set to keep track of nodes currently in the recursion stack (for back-edge detection)\n    on_recursion_stack = {1} \n    \n    while dfs_iter_stack:\n        u, parent_edge_idx, neighbor_iter_idx = dfs_iter_stack.pop()\n        \n        # Post-order processing for u\n        if neighbor_iter_idx == -1:\n            on_recursion_stack.remove(u)\n            # This is where we decide the direction of the edge (parent_node, u)\n            # based on flow_balance[u]. This is done at the end of the DFS.\n            continue\n        \n        # Pre-order processing for u / Process neighbors of u\n        # Push u back onto stack for potential future neighbors or post-order processing\n        dfs_iter_stack.append((u, parent_edge_idx, neighbor_iter_idx + 1))\n        \n        if neighbor_iter_idx < len(adj[u]):\n            v, c, edge_idx = adj[u][neighbor_iter_idx]\n            \n            # Skip if this is the parent edge (already handled by parent_edge_idx)\n            if edge_idx == parent_edge_idx:\n                continue\n\n            if not visited[v]:\n                visited[v] = True\n                on_recursion_stack.add(v)\n                dfs_iter_stack.append((v, edge_idx, 0)) # Process v next\n                # Tree edge (u,v). We don't set direction yet, it's decided on return from v.\n                # But we can provisionally say u -> v for balance updates for other edges.\n                # No, better to leave it undecided.\n            elif edge_directions[edge_idx] == -1: # Already visited, and this edge hasn't been directed\n                # This is a cross-edge or a back-edge.\n                # To maintain acyclicity and ensure flow generally moves forward:\n                # If v is an ancestor of u (i.e., v is on_recursion_stack), it's a back-edge.\n                # Direct v -> u.\n                # Otherwise (v is a cross-node, already fully explored), direct u -> v.\n                \n                original_u, original_v, flow_c = edges_input_order[edge_idx]\n                \n                if v in on_recursion_stack: # v is an ancestor of u, so it's a back-edge\n                    # Direct v -> u\n                    if original_u == v: # Original edge (v, u), so v -> u is direction 0\n                        edge_directions[edge_idx] = 0\n                    else: # Original edge (u, v), so v -> u is direction 1\n                        edge_directions[edge_idx] = 1\n                    \n                    flow_balance[v] -= flow_c # v sends flow\n                    flow_balance[u] += flow_c # u receives flow\n                else: # v is a cross-node (already visited and processed)\n                    # Direct u -> v\n                    if original_u == u: # Original edge (u, v), so u -> v is direction 0\n                        edge_directions[edge_idx] = 0\n                    else: # Original edge (v, u), so u -> v is direction 1\n                        edge_directions[edge_idx] = 1\n                    \n                    flow_balance[u] -= flow_c # u sends flow\n                    flow_balance[v] += flow_c # v receives flow\n        else:\n            # All neighbors processed for u, push sentinel for post-order processing\n            dfs_iter_stack.append((u, parent_edge_idx, -1))\n\n    # Now, process the DFS stack in reverse order of discovery (post-order traversal)\n    # to set directions for tree edges.\n    # The `dfs_iter_stack` naturally gives post-order if we process `u` after all its children.\n    # The current `dfs_iter_stack` has entries `(u, parent_edge_idx, -1)` for post-order.\n    # Let's re-do the DFS, but this time, store nodes for post-order processing.\n    \n    # Reset visited for the second pass (or just use `dfs_order` collected from first pass)\n    # A standard way is to use a stack for post-order:\n    # 1. Push root.\n    # 2. While stack not empty: pop u, add to `post_order_nodes` (or `dfs_order`). For each child v, push v.\n    # 3. Reverse `post_order_nodes`. This gives topological order.\n    \n    # Let's use the first DFS to collect nodes in post-order, then iterate backwards.\n    # `dfs_iter_stack` has `(u, parent_edge_idx, -1)` when `u` is ready for post-order processing.\n    # We need to know the parent_node for each u.\n    \n    # A simpler way for post-order traversal:\n    # Perform DFS. When a node `u` is *finished* (all its children visited and processed),\n    # add `u` to a list `post_order_nodes`.\n    # Then iterate `post_order_nodes` in reverse.\n    \n    post_order_nodes = []\n    visited_for_post_order = [False] * (n + 1)\n    \n    # Store parent edge index for each node in the DFS tree\n    parent_edge_for_node = [-1] * (n + 1)\n\n    # Iterative DFS for post-order traversal\n    dfs_stack_post = [(1, -1)] # (node, parent_edge_idx) - parent_edge_idx is the edge connecting node to its parent\n    visited_for_post_order[1] = True\n\n    # This stack will store (u, parent_edge_idx, iter_idx) for state management\n    # and (u, parent_edge_idx, -1) as a marker for when u should be added to post_order_nodes\n    processing_stack = [(1, -1, 0)] \n    \n    while processing_stack:\n        u, p_edge_idx, iter_idx = processing_stack.pop()\n        \n        if iter_idx == -1: # Marker: u and its subtree have been fully processed\n            post_order_nodes.append(u)\n            parent_edge_for_node[u] = p_edge_idx # Store parent_edge_idx for this node\n            continue\n\n        # Push back for next neighbor or post-order marker\n        processing_stack.append((u, p_edge_idx, iter_idx + 1))\n        \n        if iter_idx < len(adj[u]):\n            v, c, edge_idx = adj[u][iter_idx]\n            \n            if edge_idx == p_edge_idx: # Skip parent edge\n                continue\n            \n            if not visited_for_post_order[v]:\n                visited_for_post_order[v] = True\n                processing_stack.append((v, edge_idx, 0))\n        else:\n            # All neighbors of u processed, push marker for post-order\n            processing_stack.append((u, p_edge_idx, -1))\n            \n    # Now, `post_order_nodes` contains nodes in post-order (children before parent).\n    # Iterate through `post_order_nodes` to decide tree edge directions.\n    # This ensures that when we decide direction for (parent_node, u), all children of u\n    # have already had their flow_balance resolved.\n    \n    for u in post_order_nodes:\n        if u == 1 or u == n: # Source and sink don't need their balance to be 0\n            continue\n        \n        # If flow_balance[u] is not 0, it must be resolved by the edge connecting u to its parent.\n        if flow_balance[u] != 0:\n            parent_edge_idx = parent_edge_for_node[u]\n            if parent_edge_idx == -1: # Should not happen for u != 1\n                continue \n            \n            original_u_edge, original_v_edge, flow_c = edges_input_order[parent_edge_idx]\n            \n            # Determine the parent node\n            parent_node = original_u_edge if original_v_edge == u else original_v_edge\n\n            if flow_balance[u] > 0: # u has an excess of incoming flow, so parent_node -> u\n                # This means flow_c should go from parent_node to u\n                if original_u_edge == parent_node:\n                    edge_directions[parent_edge_idx] = 0 # parent_node -> u\n                else:\n                    edge_directions[parent_edge_idx] = 1 # u <- parent_node\n                \n                flow_balance[parent_node] += flow_c # Parent receives flow\n                flow_balance[u] -= flow_c # u's balance becomes 0\n            else: # flow_balance[u] < 0, u has an excess of outgoing flow, so u -> parent_node\n                # This means flow_c should go from u to parent_node\n                if original_u_edge == u:\n                    edge_directions[parent_edge_idx] = 0 # u -> parent_node\n                else:\n                    edge_directions[parent_edge_idx] = 1 # parent_node <- u\n                \n                flow_balance[parent_node] -= flow_c # Parent sends flow\n                flow_balance[u] += flow_c # u's balance becomes 0\n\n    # Output the results\n    for direction in edge_directions:\n        sys.stdout.write(str(direction) + '\\n')\n\n# Ensure fast I/O\nsys.setrecursionlimit(2 * 10**5 + 500) # Max N is 2*10^5, so recursion depth might be an issue with recursive DFS\n# For iterative DFS, this limit is not strictly necessary, but good practice.\n# The iterative DFS above avoids actual recursion depth issues.\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    # Store edges in input order to map edge_idx to original (u,v,c)\n    edges_input_order = []\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n        edges_input_order.append((u, v, c))\n\n    # flow_balance[v] = sum(incoming flow) - sum(outgoing flow) for decided edges\n    # We want flow_balance[v] = 0 for 1 < v < n.\n    flow_balance = [0] * (n + 1)\n    \n    # edge_directions[i]: 0 if a_i -> b_i, 1 if b_i -> a_i\n    # Initialize with -1 to mark as undecided\n    edge_directions = [-1] * m\n\n    visited = [False] * (n + 1)\n    \n    # Stack for iterative DFS. Each element: (u, parent_edge_idx)\n    # parent_edge_idx is the index of the edge connecting u to its parent in DFS tree.\n    # It's -1 for the source (node 1).\n    stack = [(1, -1)] \n    visited[1] = True\n    \n    # The DFS traversal will be managed by two lists:\n    # `dfs_order`: stores nodes in discovery order.\n    # `dfs_parent_edge`: stores the parent edge index for each node in `dfs_order`.\n    dfs_order = []\n    dfs_parent_edge = [-1] * (n + 1) # Stores parent edge index for each node\n    \n    # Simulate DFS to build the DFS tree and identify cross/back edges\n    dfs_stack = [(1, -1)] # (node, parent_edge_idx)\n    \n    # We need to explicitly track discovery order to process edges correctly\n    # For each node, we need to know which neighbors have been visited and which edge it came from\n    \n    # `parent_map[v]` stores the edge_idx that connects `v` to its parent in the DFS tree.\n    # `parent_map[1]` remains -1.\n    \n    # `iterators[u]` will store the index of the next neighbor to visit for `u`\n    iterators = [0] * (n + 1)\n\n    # Main DFS loop for building the tree and deciding cross-edge directions\n    # This loop pushes nodes onto `dfs_order` in post-order (when returning from children)\n    # This is effectively a standard iterative DFS:\n    # When processing u, push u onto `path_stack` (for detecting back-edges)\n    # For each neighbor v:\n    #   If v unvisited: recurse (or push to stack). (u,v) is a tree edge.\n    #   If v visited and v is on `path_stack` (ancestor of u): (u,v) is a back-edge. Direct v -> u.\n    #   If v visited and v is not on `path_stack` (cross-edge): Direct u -> v.\n    # When all children of u are processed, pop u from `path_stack`.\n    \n    # Using a single stack for iterative DFS (pre-order and post-order processing)\n    # Stack elements: (u, parent_edge_idx, current_neighbor_idx)\n    # If current_neighbor_idx is -1, it means we're in post-order processing for u.\n    \n    dfs_iter_stack = [(1, -1, 0)] # (node, parent_edge_idx, neighbor_iterator_index)\n    visited[1] = True\n    \n    # A set to keep track of nodes currently in the recursion stack (for back-edge detection)\n    on_recursion_stack = {1} \n    \n    while dfs_iter_stack:\n        u, parent_edge_idx, neighbor_iter_idx = dfs_iter_stack.pop()\n        \n        # Post-order processing for u\n        if neighbor_iter_idx == -1:\n            on_recursion_stack.remove(u)\n            # This is where we decide the direction of the edge (parent_node, u)\n            # based on flow_balance[u]. This is done at the end of the DFS.\n            continue\n        \n        # Pre-order processing for u / Process neighbors of u\n        # Push u back onto stack for potential future neighbors or post-order processing\n        dfs_iter_stack.append((u, parent_edge_idx, neighbor_iter_idx + 1))\n        \n        if neighbor_iter_idx < len(adj[u]):\n            v, c, edge_idx = adj[u][neighbor_iter_idx]\n            \n            # Skip if this is the parent edge (already handled by parent_edge_idx)\n            if edge_idx == parent_edge_idx:\n                continue\n\n            if not visited[v]:\n                visited[v] = True\n                on_recursion_stack.add(v)\n                dfs_iter_stack.append((v, edge_idx, 0)) # Process v next\n                # Tree edge (u,v). We don't set direction yet, it's decided on return from v.\n                # But we can provisionally say u -> v for balance updates for other edges.\n                # No, better to leave it undecided.\n            elif edge_directions[edge_idx] == -1: # Already visited, and this edge hasn't been directed\n                # This is a cross-edge or a back-edge.\n                # To maintain acyclicity and ensure flow generally moves forward:\n                # If v is an ancestor of u (i.e., v is on_recursion_stack), it's a back-edge.\n                # Direct v -> u.\n                # Otherwise (v is a cross-node, already fully explored), direct u -> v.\n                \n                original_u, original_v, flow_c = edges_input_order[edge_idx]\n                \n                if v in on_recursion_stack: # v is an ancestor of u, so it's a back-edge\n                    # Direct v -> u\n                    if original_u == v: # Original edge (v, u), so v -> u is direction 0\n                        edge_directions[edge_idx] = 0\n                    else: # Original edge (u, v), so v -> u is direction 1\n                        edge_directions[edge_idx] = 1\n                    \n                    flow_balance[v] -= flow_c # v sends flow\n                    flow_balance[u] += flow_c # u receives flow\n                else: # v is a cross-node (already visited and processed)\n                    # Direct u -> v\n                    if original_u == u: # Original edge (u, v), so u -> v is direction 0\n                        edge_directions[edge_idx] = 0\n                    else: # Original edge (v, u), so u -> v is direction 1\n                        edge_directions[edge_idx] = 1\n                    \n                    flow_balance[u] -= flow_c # u sends flow\n                    flow_balance[v] += flow_c # v receives flow\n        else:\n            # All neighbors processed for u, push sentinel for post-order processing\n            dfs_iter_stack.append((u, parent_edge_idx, -1))\n\n    # Now, process the DFS stack in reverse order of discovery (post-order traversal)\n    # to set directions for tree edges.\n    # The `dfs_iter_stack` naturally gives post-order if we process `u` after all its children.\n    # The current `dfs_iter_stack` has entries `(u, parent_edge_idx, -1)` for post-order.\n    # Let's re-do the DFS, but this time, store nodes for post-order processing.\n    \n    # Reset visited for the second pass (or just use `dfs_order` collected from first pass)\n    # A standard way is to use a stack for post-order:\n    # 1. Push root.\n    # 2. While stack not empty: pop u, add to `post_order_nodes` (or `dfs_order`). For each child v, push v.\n    # 3. Reverse `post_order_nodes`. This gives topological order.\n    \n    # Let's use the first DFS to collect nodes in post-order, then iterate backwards.\n    # `dfs_iter_stack` has `(u, parent_edge_idx, -1)` when `u` is ready for post-order processing.\n    # We need to know the parent_node for each u.\n    \n    # A simpler way for post-order traversal:\n    # Perform DFS. When a node `u` is *finished* (all its children visited and processed),\n    # add `u` to a list `post_order_nodes`.\n    # Then iterate `post_order_nodes` in reverse.\n    \n    post_order_nodes = []\n    visited_for_post_order = [False] * (n + 1)\n    \n    # Store parent edge index for each node in the DFS tree\n    parent_edge_for_node = [-1] * (n + 1)\n\n    # Iterative DFS for post-order traversal\n    dfs_stack_post = [(1, -1)] # (node, parent_edge_idx) - parent_edge_idx is the edge connecting node to its parent\n    visited_for_post_order[1] = True\n\n    # This stack will store (u, parent_edge_idx, iter_idx) for state management\n    # and (u, parent_edge_idx, -1) as a marker for when u should be added to post_order_nodes\n    processing_stack = [(1, -1, 0)] \n    \n    while processing_stack:\n        u, p_edge_idx, iter_idx = processing_stack.pop()\n        \n        if iter_idx == -1: # Marker: u and its subtree have been fully processed\n            post_order_nodes.append(u)\n            parent_edge_for_node[u] = p_edge_idx # Store parent_edge_idx for this node\n            continue\n\n        # Push back for next neighbor or post-order marker\n        processing_stack.append((u, p_edge_idx, iter_idx + 1))\n        \n        if iter_idx < len(adj[u]):\n            v, c, edge_idx = adj[u][iter_idx]\n            \n            if edge_idx == p_edge_idx: # Skip parent edge\n                continue\n            \n            if not visited_for_post_order[v]:\n                visited_for_post_order[v] = True\n                processing_stack.append((v, edge_idx, 0))\n        else:\n            # All neighbors of u processed, push marker for post-order\n            processing_stack.append((u, p_edge_idx, -1))\n            \n    # Now, `post_order_nodes` contains nodes in post-order (children before parent).\n    # Iterate through `post_order_nodes` to decide tree edge directions.\n    # This ensures that when we decide direction for (parent_node, u), all children of u\n    # have already had their flow_balance resolved.\n    \n    for u in post_order_nodes:\n        if u == 1 or u == n: # Source and sink don't need their balance to be 0\n            continue\n        \n        # If flow_balance[u] is not 0, it must be resolved by the edge connecting u to its parent.\n        if flow_balance[u] != 0:\n            parent_edge_idx = parent_edge_for_node[u]\n            if parent_edge_idx == -1: # Should not happen for u != 1\n                continue \n            \n            original_u_edge, original_v_edge, flow_c = edges_input_order[parent_edge_idx]\n            \n            # Determine the parent node\n            parent_node = original_u_edge if original_v_edge == u else original_v_edge\n\n            if flow_balance[u] > 0: # u has an excess of incoming flow, so parent_node -> u\n                # This means flow_c should go from parent_node to u\n                if original_u_edge == parent_node:\n                    edge_directions[parent_edge_idx] = 0 # parent_node -> u\n                else:\n                    edge_directions[parent_edge_idx] = 1 # u <- parent_node\n                \n                flow_balance[parent_node] += flow_c # Parent receives flow\n                flow_balance[u] -= flow_c # u's balance becomes 0\n            else: # flow_balance[u] < 0, u has an excess of outgoing flow, so u -> parent_node\n                # This means flow_c should go from u to parent_node\n                if original_u_edge == u:\n                    edge_directions[parent_edge_idx] = 0 # u -> parent_node\n                else:\n                    edge_directions[parent_edge_idx] = 1 # parent_node <- u\n                \n                flow_balance[parent_node] -= flow_c # Parent sends flow\n                flow_balance[u] += flow_c # u's balance becomes 0\n\n    # Output the results\n    for direction in edge_directions:\n        sys.stdout.write(str(direction) + '\\n')\n\n# Ensure fast I/O\nsys.setrecursionlimit(2 * 10**5 + 500) # Max N is 2*10^5, so recursion depth might be an issue with recursive DFS\n# For iterative DFS, this limit is not strictly necessary, but good practice.\n# The iterative DFS above avoids actual recursion depth issues.\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 746,
        "completion_token_count": 7295,
        "thoughts_token_count": 761
    }
}