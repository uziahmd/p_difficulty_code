{
    "start": 1758011814.3835642,
    "end": 1758011930.9417822,
    "start-formatted": "2025-09-16 17:36 KST",
    "end-formatted": "2025-09-16 17:38 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "**Alright, here's my breakdown of this \"Rudolf and Snowflakes\" problem.** I'm tasked with writing a Python script to determine if a given number `n` can be represented as the total number of vertices in a special type of graph—a snowflake. The snowflake has a center vertex and connected branches, with a specific rule for how new vertices are added. The key is understanding how the total number of vertices changes with the number of branches and how deep the \"snowflake\" grows.\n\nI've figured out the formula: `N = (k^(d+1) - 1) / (k - 1)`. `N` is the total number of vertices, `k` is the branching factor (how many new vertices each existing one connects to), and `d` represents how many \"layers\" or levels are beyond the center vertex. The crucial point is that `d` must be at least 2 for a valid snowflake, meaning the base shape has at least three vertices (center + *k* first layer vertices). This is because the rule \"Each vertex that is connected to only one other vertex is connected by edges to `k` more new vertices\" must be applied at least once.\n\nMy plan is to use this formula and apply a combination of pre-computation and direct calculation. Given `n`, I need to determine if suitable integers `k > 1` and `d >= 2` exist. First, I want to pre-compute the total number of vertices for all possible snowflake configurations with a reasonable range of parameters. This pre-computation significantly speeds up finding a solution for most values of `n`. Second, for the few `n` values that are not present in the precomputed values, I will use a direct computation method for the `d=2` case. This covers the most important ranges for our `k` value.\n\nSo, here's the overall strategy:\n\n1.  **Pre-computation:** I'm going to iterate through the possible `k` values (from 2 up to around 10^6, because values larger than this require excessive computation) and, for each `k`, compute the total number of vertices (`N`) for increasing `d` values (starting with `d = 2`). I'll stop the `d` iteration when `N` exceeds `10^18`. I will store these computed `N` values in a set to speed up lookup for each query. Because `d` grows slowly with increasing `k` (because `k^d <= 10^18`), this approach will cover the vast majority of solutions efficiently.\n2.  **Test Case Handling:** For each input `n`, I'll first check if `n` exists in my precomputed set. If it is, then `n` is a snowflake. If it is not, I'll then separately check the special `d=2` case which is handled efficiently, with a direct integer root calculation. If that is not a solution, then I'll output \"NO\".\n\nThe pre-computation is the key to an efficient solution. It lets me cover the majority of cases quickly. The remaining few cases with higher values are handled with a more direct check for the special `d=2` condition that is efficiently computable. I'm going to create a Python script that implements this strategy to get the answer.",
    "response": "The problem asks us to determine if a given number `n` can represent the total number of vertices in a \"snowflake\" graph. A snowflake is constructed based on two parameters: `k` (an integer `k > 1`) and `d` (the \"depth\" of the snowflake, representing how many times a certain rule is applied).\n\nLet's analyze the construction rules:\n1.  **Initial vertex:** Start with 1 vertex (the center).\n2.  **First expansion:** The center is connected to `k` new vertices. Total vertices: `1 + k`.\n3.  **Subsequent expansions:** \"Each vertex that is connected to only one other vertex is connected by edges to `k` more new vertices.\" This step must be done *at least once*.\n\nLet `m` be the number of times this \"subsequent expansion\" step is performed. According to the rule, `m >= 1`.\n\n*   If `m = 1`: The `k` vertices from the first expansion are leaves (connected only to the center). Each of these `k` vertices is connected to `k` new vertices. This adds `k * k = k^2` new vertices.\n    Total vertices: `1 + k + k^2`.\n*   If `m = 2`: The `k^2` vertices added in the previous step are now leaves. Each of these `k^2` vertices is connected to `k` new vertices. This adds `k^2 * k = k^3` new vertices.\n    Total vertices: `1 + k + k^2 + k^3`.\n\nIn general, if the \"subsequent expansion\" step is performed `m` times, the total number of vertices will be `N = 1 + k + k^2 + ... + k^(m+1)`.\nLet `d_eff = m+1`. Since `m >= 1`, we must have `d_eff >= 2`.\nSo, a snowflake must have `N = 1 + k + k^2 + ... + k^D` vertices, where `k > 1` and `D >= 2`.\n\nThis is a geometric series sum: `N = (k^(D+1) - 1) / (k - 1)`. We need to check if a given `n` can be expressed in this form for some `k > 1` and `D >= 2`.\n\nThe input `n` can be up to `10^{18}`.\n\nWe can categorize the search for `k` and `D` into two main cases:\n\n**Case 1: `D = 2`**\nIf `D = 2`, then `n = 1 + k + k^2`.\nThis is a quadratic equation in `k`: `k^2 + k + (1 - n) = 0`.\nUsing the quadratic formula, `k = (-1 ± sqrt(1 - 4(1)(1 - n))) / 2 = (-1 ± sqrt(1 - 4 + 4n)) / 2 = (-1 ± sqrt(4n - 3)) / 2`.\nFor `k` to be a valid integer greater than 1:\n1.  `4n - 3` must be a perfect square. Let `4n - 3 = s^2` for some integer `s`.\n2.  `s` must be odd (since `4n - 3` is always odd, `s^2` must be odd, so `s` must be odd). This ensures `(-1 + s)` is even, making `k` an integer.\n3.  `k = (-1 + s) / 2` must be greater than 1. This means `-1 + s > 2`, so `s > 3`.\n\nSo, for `D=2`, we can check if `4n - 3` is a perfect square `s^2` and if `s > 3`. If both conditions hold, then `n` is a valid snowflake number. This check is efficient as it involves `sqrt` and basic arithmetic.\n\n**Case 2: `D >= 3`**\nFor `D >= 3`, the value of `k` cannot be very large.\nIf `k=2`, `n = 1 + 2 + ... + 2^D`. The maximum `D` occurs when `2^D` is roughly `n`. For `n = 10^{18}`, `2^D <= 10^{18}` implies `D <= log2(10^{18}) = 18 * log2(10) approx 18 * 3.32 approx 59.79`. So `D` can go up to about 59 or 60.\nIf `D=3`, `n = 1 + k + k^2 + k^3`. `k^3 < n`, so `k < n^(1/3)`. For `n = 10^{18}`, `k < (10^{18})^(1/3) = 10^6`.\nIf `D=4`, `k < n^(1/4)`. For `n = 10^{18}`, `k < (10^{18})^(1/4) = 10^{4.5} approx 31622`.\nAs `D` increases, the maximum possible `k` decreases rapidly. The maximum `k` for `D >= 3` is `10^6`.\n\nThis observation suggests a precomputation strategy:\nWe can precompute all possible snowflake numbers `n = 1 + k + ... + k^D` for `k` from 2 up to `10^6` (the maximum `k` when `D=3`) and `D >= 2`. Store these numbers in a hash set for fast lookups.\n\n**Precomputation Algorithm:**\nInitialize an empty set `snowflake_numbers`.\nIterate `k` from 2 up to `10^6`:\n  Initialize `current_sum = 1` and `term = 1`.\n  Initialize `D_exponent = 0` (represents the current power of `k` in `term`).\n  Loop indefinitely (or until `current_sum` exceeds `MAX_N`):\n    Calculate `next_term = term * k`.\n    If `next_term` would overflow `MAX_N` (i.e., `next_term > MAX_N` or `term > MAX_N // k`): break.\n    `term = next_term`.\n    `D_exponent += 1`.\n    If `current_sum > MAX_N - term`: break.\n    `current_sum += term`.\n    If `D_exponent >= 2` (meaning `1+k+k^2` or more terms):\n      Add `current_sum` to `snowflake_numbers`.\n    If `current_sum > MAX_N`: break.\n    If `D_exponent > 60` (an upper bound for `D` even for `k=2`): break.\n\nThe maximum number of elements in `snowflake_numbers` is about `2.7 * 10^6`. This precomputation takes a fraction of a second.\n\n**Overall Solution:**\n\n1.  **Precomputation:** Run the precomputation algorithm described above to populate `snowflake_numbers`.\n2.  **For each test case `n`:**\n    a.  **Check precomputed values:** If `n` is in `snowflake_numbers`, print \"YES\".\n    b.  **Check `D=2` for large `k`:** Else, calculate `val = 4n - 3`.\n        i.  Compute `s = math.isqrt(val)`.\n        ii. If `s * s == val` (meaning `val` is a perfect square) AND `s > 3`:\n            (The condition `s > 3` implies `k = (-1+s)/2 > 1`. Also, `s` will be odd, so `k` will be an integer.)\n            Print \"YES\".\n        iii. Else: Print \"NO\".\n\nThis approach covers all valid `(k, D)` pairs:\n*   `D >= 3`: Covered by precomputation (since max `k` is `10^6`).\n*   `D = 2, k <= 10^6`: Covered by precomputation.\n*   `D = 2, k > 10^6`: Covered by the separate `D=2` check.\n\n```python\nimport math\nimport sys\n\n# Set maximum value for n\nMAX_N = 10**18\n\n# Precompute all possible snowflake numbers for D >= 2 and k <= 10^6\n# This covers all cases for D >= 3 (since max k for D=3 is 10^6)\n# and D=2 for k <= 10^6.\nsnowflake_numbers = set()\n\n# Iterate k from 2 up to 10^6 (inclusive)\n# Max k for D=3 is approximately 10^6 (since (10^6)^3 = 10^18)\nMAX_K_FOR_PRECOMPUTATION = 10**6\n\nfor k in range(2, MAX_K_FOR_PRECOMPUTATION + 1):\n    current_sum = 1\n    term = 1\n    D_exponent = 0  # Represents the current power of k in term (k^D_exponent)\n\n    while True:\n        # Calculate next term: term * k\n        # Check for overflow before multiplication\n        # Python handles large integers automatically, so explicit overflow check for term * k isn't strictly needed for Python's int type,\n        # but checking against MAX_N is crucial to keep numbers within bounds.\n        if term > MAX_N // k: # If term * k would exceed MAX_N\n            break\n        term *= k\n        D_exponent += 1\n        \n        # Check for overflow before addition\n        if current_sum > MAX_N - term: # If current_sum + term would exceed MAX_N\n            break\n        current_sum += term\n        \n        # A snowflake must have D_exponent >= 2 (meaning at least 1 + k + k^2 vertices)\n        if D_exponent >= 2:\n            snowflake_numbers.add(current_sum)\n        \n        # If the sum itself exceeds MAX_N, no further terms for this k will be valid\n        if current_sum > MAX_N:\n            break\n        \n        # Optimization: D_exponent cannot exceed ~60 for k=2 to stay within 10^18.\n        # For larger k, D_exponent will be even smaller.\n        if D_exponent > 60: \n            break\n\ndef solve():\n    n = int(sys.stdin.readline())\n\n    # Check if n is in the precomputed set (covers D >= 3 for any k, and D=2 for k <= 10^6)\n    if n in snowflake_numbers:\n        sys.stdout.write(\"YES\\n\")\n        return\n\n    # Handle the remaining case: D = 2 and k > 10^6\n    # n = 1 + k + k^2\n    # k^2 + k + (1 - n) = 0\n    # k = (-1 + sqrt(1 - 4(1)(1-n))) / 2\n    # k = (-1 + sqrt(4n - 3)) / 2\n\n    val = 4 * n - 3\n    \n    # If val is negative, sqrt is not real.\n    # For n >= 1, 4n-3 >= 1, so val will not be negative.\n    \n    s = math.isqrt(val) # Integer square root\n\n    if s * s == val: # Check if val is a perfect square\n        # k = (-1 + s) / 2\n        # s must be odd for (-1 + s) to be even, which it will be since 4n-3 is odd.\n        # k must be > 1\n        if s > 3: # This implies (-1 + s) / 2 > 1\n            sys.stdout.write(\"YES\\n\")\n            return\n\n    sys.stdout.write(\"NO\\n\")\n\n\nnum_test_cases = int(sys.stdin.readline())\nfor _ in range(num_test_cases):\n    solve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\nimport sys\n\n# Set maximum value for n\nMAX_N = 10**18\n\n# Precompute all possible snowflake numbers for D >= 2 and k <= 10^6\n# This covers all cases for D >= 3 (since max k for D=3 is 10^6)\n# and D=2 for k <= 10^6.\nsnowflake_numbers = set()\n\n# Iterate k from 2 up to 10^6 (inclusive)\n# Max k for D=3 is approximately 10^6 (since (10^6)^3 = 10^18)\nMAX_K_FOR_PRECOMPUTATION = 10**6\n\nfor k in range(2, MAX_K_FOR_PRECOMPUTATION + 1):\n    current_sum = 1\n    term = 1\n    D_exponent = 0  # Represents the current power of k in term (k^D_exponent)\n\n    while True:\n        # Calculate next term: term * k\n        # Check for overflow before multiplication\n        # Python handles large integers automatically, so explicit overflow check for term * k isn't strictly needed for Python's int type,\n        # but checking against MAX_N is crucial to keep numbers within bounds.\n        if term > MAX_N // k: # If term * k would exceed MAX_N\n            break\n        term *= k\n        D_exponent += 1\n        \n        # Check for overflow before addition\n        if current_sum > MAX_N - term: # If current_sum + term would exceed MAX_N\n            break\n        current_sum += term\n        \n        # A snowflake must have D_exponent >= 2 (meaning at least 1 + k + k^2 vertices)\n        if D_exponent >= 2:\n            snowflake_numbers.add(current_sum)\n        \n        # If the sum itself exceeds MAX_N, no further terms for this k will be valid\n        if current_sum > MAX_N:\n            break\n        \n        # Optimization: D_exponent cannot exceed ~60 for k=2 to stay within 10^18.\n        # For larger k, D_exponent will be even smaller.\n        if D_exponent > 60: \n            break\n\ndef solve():\n    n = int(sys.stdin.readline())\n\n    # Check if n is in the precomputed set (covers D >= 3 for any k, and D=2 for k <= 10^6)\n    if n in snowflake_numbers:\n        sys.stdout.write(\"YES\\n\")\n        return\n\n    # Handle the remaining case: D = 2 and k > 10^6\n    # n = 1 + k + k^2\n    # k^2 + k + (1 - n) = 0\n    # k = (-1 + sqrt(1 - 4(1)(1-n))) / 2\n    # k = (-1 + sqrt(4n - 3)) / 2\n\n    val = 4 * n - 3\n    \n    # If val is negative, sqrt is not real.\n    # For n >= 1, 4n-3 >= 1, so val will not be negative.\n    \n    s = math.isqrt(val) # Integer square root\n\n    if s * s == val: # Check if val is a perfect square\n        # k = (-1 + s) / 2\n        # s must be odd for (-1 + s) to be even, which it will be since 4n-3 is odd.\n        # k must be > 1\n        if s > 3: # This implies (-1 + s) / 2 > 1\n            sys.stdout.write(\"YES\\n\")\n            return\n\n    sys.stdout.write(\"NO\\n\")\n\n\nnum_test_cases = int(sys.stdin.readline())\nfor _ in range(num_test_cases):\n    solve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 569,
        "completion_token_count": 2810,
        "thoughts_token_count": 8191
    }
}