{
    "start": 1758284910.2646277,
    "end": 1758285000.5040455,
    "start-formatted": "2025-09-19 21:28 KST",
    "end-formatted": "2025-09-19 21:30 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "**Breaking Down the Mushroom Strife Problem**\n\nOkay, so I'm looking at this \"Mushroom Strife\" problem. The user wants me to find a valid distribution of mushroom counts across lawns, given constraints based on the GCD and LCM of mushroom counts for connected lawns. My immediate instinct is to dissect this mathematically and see if I can derive some relationships that might simplify the problem.\n\nFirst things first, I need to check if the input is even *possible*. The core property of GCD and LCM is that the product of two numbers equals the product of their GCD and LCM. This means that if `lcm(a,b)` isn't divisible by `gcd(a,b)`, there's no solution for that pair, and I can immediately output \"NO\". I need to build that check right into my initial pass.\n\nNow, let's think about how to represent the problem. I have `n` unknown mushroom counts, and each edge introduces a constraint.  Each edge (u, v) gives me `gcd(m_u, m_v)` and `lcm(m_u, m_v)`, effectively defining an equation: `m_u * m_v = g * l`. I know `m_u` and `m_v` must be factors of `l` and multiples of `g`. That seems promising!\n\nThis feels like a graph problem. Each lawn is a vertex, and each road is an edge with these GCD/LCM constraints. I'm thinking I can represent the constraints as a graph, and see if I can propagate solutions. I need to make sure I don't introduce any contradictions. The limits are up to 10^5 for n, so this is computationally reasonable. Now, I need to figure out the most efficient way to solve this. I'll start by checking all the initial edge constraints, and then move on to propagating the constraints across the graph. Let's dig deeper!\n",
    "response": "The problem asks us to find the number of mushrooms on `n` lawns, given `m` roads. For each road connecting lawns `u` and `v`, we are given `gcd(m_u, m_v)` and `lcm(m_u, m_v)`. If a solution exists, we output \"YES\" and the `n` mushroom counts; otherwise, \"NO\". Mushroom counts are between 1 and 10^6.\n\n**Key Properties of GCD and LCM:**\nFor any two positive integers `a` and `b`:\n1.  `a * b = gcd(a, b) * lcm(a, b)`\n2.  `gcd(a, b)` must divide both `a` and `b`.\n3.  `a` and `b` must divide `lcm(a, b)`.\n4.  `gcd(a, b)` must divide `lcm(a, b)`. If `lcm(a, b) % gcd(a, b) != 0`, no such `a, b` exist.\n\nLet `g = gcd(m_u, m_v)` and `l = lcm(m_u, m_v)`.\nFrom property 1, `m_u * m_v = g * l`.\nFrom property 2, `m_u = g * x` and `m_v = g * y` for some integers `x, y` where `gcd(x, y) = 1`.\nSubstituting these into `m_u * m_v = g * l`:\n`(g * x) * (g * y) = g * l`\n`g^2 * x * y = g * l`\n`g * x * y = l`\nSo, `x * y = l / g`. Let `P = l / g`.\nNow we need to find `m_u = g * x` and `m_v = g * y` such that `x * y = P` and `gcd(x, y) = 1`.\nThis means `x` and `y` must be coprime factors of `P`.\n\n**Algorithm:**\n\n1.  **Initial Checks:**\n    *   For each edge `(u, v, g, l)`:\n        *   If `l % g != 0`, then no solution exists. Print \"NO\" and exit.\n        *   Store the edge information. We can use an adjacency list `adj[u]` storing `(v, g, l)`.\n\n2.  **Graph Traversal (Connected Components):**\n    The problem can be viewed as finding mushroom counts in a graph. Since the mushroom count for a lawn `u` influences its neighbors, we can process each connected component independently. We use a Disjoint Set Union (DSU) data structure to keep track of connected components and their associated constraints. Each node `i` in the DSU will store `val[i]` which is `m_i / m_{root_of_component}`.\n\n3.  **DSU Structure and Operations:**\n    *   `parent[i]`: Stores the parent of node `i` in the DSU tree.\n    *   `val[i]`: Stores `m_i / m_{parent[i]}`. This is a relative value.\n    *   `find(i)`:\n        *   If `parent[i] == i`, then `i` is the root. Return `(i, 1)` (root's relative value to itself is 1).\n        *   Otherwise, recursively call `find(parent[i])`. Let `(root, root_val_to_parent)` be the result.\n        *   Update `parent[i] = root`.\n        *   Update `val[i] = val[i] * root_val_to_parent`. This path compression updates `val[i]` to `m_i / m_{root}`.\n        *   Return `(root, val[i])`.\n\n4.  **Processing Edges with DSU:**\n    For each edge `(u, v, g, l)`:\n    *   Find the roots and relative values for `u` and `v`: `(root_u, val_u_to_root)` and `(root_v, val_v_to_root)`.\n    *   If `root_u == root_v`:\n        *   Both `u` and `v` are already in the same component. We need to check consistency.\n        *   We have `m_u = m_{root_u} * val_u_to_root` and `m_v = m_{root_u} * val_v_to_root`.\n        *   Substitute into `gcd(m_u, m_v) = g` and `lcm(m_u, m_v) = l`:\n            *   `gcd(m_{root_u} * val_u_to_root, m_{root_u} * val_v_to_root) = g`\n            *   `m_{root_u} * gcd(val_u_to_root, val_v_to_root) = g`\n            *   `lcm(m_{root_u} * val_u_to_root, m_{root_u} * val_v_to_root) = l`\n            *   `m_{root_u} * lcm(val_u_to_root, val_v_to_root) = l`\n        *   From these, we can derive `m_{root_u}`:\n            `m_{root_u} = g / gcd(val_u_to_root, val_v_to_root)`\n            `m_{root_u} = l / lcm(val_u_to_root, val_v_to_root)`\n        *   These two values for `m_{root_u}` must be consistent. Check if `g * lcm(val_u_to_root, val_v_to_root) == l * gcd(val_u_to_root, val_v_to_root)`. If not, print \"NO\" and exit.\n        *   Also, `m_{root_u}` derived from `g` must be an integer, and `m_{root_u}` derived from `l` must be an integer. Check if `g % gcd(val_u_to_root, val_v_to_root) != 0` (or `l % lcm(...) != 0`). If so, print \"NO\" and exit.\n        *   If `component_val[root_u]` (the fixed value for `m_{root_u}`) is already set, check if the newly derived `m_{root_u}` is consistent with it. If not, print \"NO\" and exit.\n        *   If `component_val[root_u]` is not set, set it to the derived value.\n        *   If it is set, update it by taking `gcd(current_val, new_val)`. This is because `m_{root_u}` must satisfy all constraints, so it must be a common divisor of all possible values. (Actually, it must be exactly the value derived from each constraint. If they differ, it's impossible. So we check equality.)\n        *   **Correction for `component_val`:** Instead of `gcd`, we should check if the new `m_{root_u}` value is equal to the existing `component_val[root_u]`. If they are different, it's a contradiction. If `component_val[root_u]` is 0 (not set), set it.\n\n    *   If `root_u != root_v`:\n        *   Merge the components. Assume we merge `root_v` into `root_u`.\n        *   We have `m_u = m_{root_u} * val_u_to_root` and `m_v = m_{root_v} * val_v_to_root`.\n        *   We also know `m_u * m_v = g * l`.\n        *   `gcd(m_u, m_v) = g` implies `gcd(m_{root_u} * val_u_to_root, m_{root_v} * val_v_to_root) = g`.\n        *   `lcm(m_u, m_v) = l` implies `lcm(m_{root_u} * val_u_to_root, m_{root_v} * val_v_to_root) = l`.\n        *   Let `m_{root_v} = m_{root_u} * K`. Then `parent[root_v] = root_u` and `val[root_v] = K`.\n        *   Substituting `m_{root_v}`:\n            `m_u = m_{root_u} * val_u_to_root`\n            `m_v = m_{root_u} * K * val_v_to_root`\n        *   Now apply the GCD/LCM properties:\n            `m_{root_u} * gcd(val_u_to_root, K * val_v_to_root) = g`\n            `m_{root_u} * lcm(val_u_to_root, K * val_v_to_root) = l`\n        *   From `g * lcm(A, B) = l * gcd(A, B)` (where `A=val_u_to_root`, `B=K*val_v_to_root`), we get:\n            `g * (A * B / gcd(A, B)) = l * gcd(A, B)`\n            `g * A * B = l * gcd(A, B)^2`\n            `g * val_u_to_root * K * val_v_to_root = l * gcd(val_u_to_root, K * val_v_to_root)^2`\n        *   We need to solve for `K`.\n        *   Let `P = l / g`. We know `m_u * m_v = g * l`.\n        *   `m_{root_u} * val_u_to_root * m_{root_v} * val_v_to_root = g * l`\n        *   `m_{root_u} * m_{root_v} = g * l / (val_u_to_root * val_v_to_root)`\n        *   Let `X = m_{root_u}` and `Y = m_{root_v}`. We need to find `X, Y` such that `gcd(X * val_u_to_root, Y * val_v_to_root) = g` and `lcm(X * val_u_to_root, Y * val_v_to_root) = l`.\n        *   The simplest way to merge is to try to determine `K = m_{root_v} / m_{root_u}`.\n        *   We have `m_u = g * x` and `m_v = g * y` where `x * y = l/g` and `gcd(x, y) = 1`.\n        *   So, `m_{root_u} * val_u_to_root` must be `g * x` and `m_{root_v} * val_v_to_root` must be `g * y` (or vice versa).\n        *   This means `m_{root_u} = g * x / val_u_to_root` and `m_{root_v} = g * y / val_v_to_root`.\n        *   For `m_{root_u}` and `m_{root_v}` to be integers, `val_u_to_root` must divide `g * x`, and `val_v_to_root` must divide `g * y`.\n        *   Let `K = m_{root_v} / m_{root_u} = (g * y / val_v_to_root) / (g * x / val_u_to_root) = (y * val_u_to_root) / (x * val_v_to_root)`.\n        *   The values `x` and `y` are unknown. `x` and `y` are coprime factors of `l/g`.\n        *   We iterate through all possible pairs `(x, y)` such that `x * y = l/g` and `gcd(x, y) = 1`.\n        *   For each such pair, we calculate `K_cand = (y * val_u_to_root) / (x * val_v_to_root)`.\n        *   We check if `K_cand` is an integer. If not, skip.\n        *   If `K_cand` is an integer, we test if it's consistent with `m_u, m_v` and `g, l`.\n            *   `m_u_val = m_{root_u} * val_u_to_root`\n            *   `m_v_val = m_{root_u} * K_cand * val_v_to_root`\n            *   We need `gcd(m_u_val, m_v_val) = g` and `lcm(m_u_val, m_v_val) = l`.\n            *   This implies `m_{root_u} * gcd(val_u_to_root, K_cand * val_v_to_root) = g`.\n            *   So, `m_{root_u} = g / gcd(val_u_to_root, K_cand * val_v_to_root)`.\n            *   Let `req_root_u = g / gcd(val_u_to_root, K_cand * val_v_to_root)`.\n            *   If `g % gcd(val_u_to_root, K_cand * val_v_to_root) != 0`, this `K_cand` is not valid.\n            *   If `component_val[root_u]` is already set and `component_val[root_u] != req_root_u`, this `K_cand` is not valid.\n            *   If `component_val[root_v]` is already set and `component_val[root_v] != req_root_u * K_cand`, this `K_cand` is not valid.\n            *   If `lcm(req_root_u * val_u_to_root, req_root_u * K_cand * val_v_to_root) != l`, this `K_cand` is not valid.\n            *   If all checks pass, then `K_cand` is a valid relative value. We merge `root_v` into `root_u`: `parent[root_v] = root_u`, `val[root_v] = K_cand`.\n            *   If `component_val[root_u]` was not set, set it to `req_root_u`.\n            *   If `component_val[root_v]` was not set, set it to `req_root_u * K_cand`.\n            *   Since there can be only one valid `K`, we can break after finding the first one. If no `K` is found, print \"NO\" and exit.\n\n5.  **Final Assignment:**\n    After processing all edges:\n    *   Iterate `i` from 1 to `n`.\n    *   Find `(root_i, val_i_to_root) = find(i)`.\n    *   If `component_val[root_i]` is 0 (meaning no explicit constraint fixed the root's value), set `component_val[root_i] = 1`. This is a valid default as `m_i >= 1`.\n    *   Calculate `ans[i] = component_val[root_i] * val_i_to_root`.\n    *   Check if `ans[i]` is within `[1, 10^6]`. If not, print \"NO\" and exit.\n\n6.  **Output:** Print \"YES\" and then `ans[1], ..., ans[n]`.\n\n**Optimization for finding coprime factors of `P = l/g`:**\nTo find `x, y` such that `x * y = P` and `gcd(x, y) = 1`:\n1.  Prime factorize `P`. Let `P = p_1^{a_1} * p_2^{a_2} * ... * p_k^{a_k}`.\n2.  For `x` and `y` to be coprime, each prime factor `p_j` must belong entirely to either `x` or `y`. It cannot be split.\n3.  So, `x` must be a product of some `p_j^{a_j}` terms, and `y` will be the product of the remaining `p_j^{a_j}` terms.\n4.  This means `x` must be of the form `product(p_j^{a_j})` for a subset of `j`s, and `y = P / x`.\n5.  There are `2^k` such pairs `(x, y)`. `k` is the number of distinct prime factors of `P`. Since `P <= 10^6`, the maximum `k` is for `2 * 3 * 5 * 7 * 11 * 13 * 17 = 510510`, so `k` can be at most 7. `2^7 = 128`, which is small enough to iterate.\n\n**Implementation Details:**\n*   `gcd(a, b)`: Use `math.gcd`.\n*   `lcm(a, b)`: `(a * b) // gcd(a, b)`. Be careful with potential overflow if `a*b` exceeds typical integer limits, but here `a, b` are relative values up to `10^6`, so `a*b` could be `10^12`. `lcm` can also be large. We need to use `//` for integer division. `lcm` values can be up to `10^6`. `val_u_to_root` can be up to `10^6`. `lcm(val_u_to_root, K_cand * val_v_to_root)` can exceed `10^6`. Max value for `K_cand * val_v_to_root` is `10^6 * 10^6 = 10^12`. This means `lcm` could be `10^12`. Python handles large integers automatically.\n*   The `component_val` for roots should be initialized to 0 (or `None`).\n*   Max mushroom count is `10^6`. `val` can be `10^6`. `m_root` can be `10^6`. `ans[i]` can be `10^6 * 10^6 = 10^12`. This is a problem. The problem states `m_i <= 10^6`. So `component_val[root_i] * val_i_to_root` must be `<= 10^6`. This is a crucial check. If any `ans[i]` exceeds `10^6`, output \"NO\".\n\n**Revised DSU `val` and `component_val` logic (to handle large numbers):**\n\nThe `val[i]` stores `m_i / m_{parent[i]}`. This can be a large number.\nThe `component_val[root]` stores the actual value `m_{root}`.\nWhen `find(i)` is called, `val[i]` is updated to `m_i / m_{root_i}`.\nWhen merging `root_v` into `root_u`, we set `parent[root_v] = root_u` and `val[root_v] = K_cand`.\nThe `K_cand` is `m_{root_v} / m_{root_u}`.\nThis means `val[root_v]` is `K_cand`.\nSo `find(root_v)` would return `(root_u, K_cand)`.\n\nLet's re-evaluate the maximum possible values for `val[i]`.\nIf `m_i = 10^6` and `m_{root} = 1`, then `val[i]` can be `10^6`.\nIf `m_i = 1` and `m_{root} = 10^6`, then `val[i]` can be `1/10^6`.\nThis suggests `val[i]` should store `m_i / m_{root}` as a rational number (fraction) or as a pair `(numerator, denominator)`.\nHowever, `m_u = g * x` and `m_v = g * y`. `m_u` and `m_v` are integers.\n`m_u = m_{root} * val_u_to_root`. `val_u_to_root` must be an integer or `m_{root}` must be a fraction to make `m_u` integer.\nThe problem statement implies `m_i` are integers. So `val_i_to_root` must be an integer.\nThis means `m_i` must be a multiple of `m_{root}`. This is not necessarily true. For example, `m_u=6, m_v=10`. `gcd=2, lcm=30`. `m_u=2*3, m_v=2*5`. If `m_{root}=10`, then `m_u = 6/10 * m_{root}`.\nThis suggests `val[i]` should store `m_i / m_{root}` as a fraction `(num, den)`.\n\nLet `val[i]` be `(num_i, den_i)` such that `m_i / m_{parent[i]} = num_i / den_i`.\n`find(i)`:\n  If `parent[i] == i`, return `(i, (1, 1))`.\n  `(root, (n_p, d_p)) = find(parent[i])`\n  `n = num_i * n_p`\n  `d = den_i * d_p`\n  `g_cd = gcd(n, d)`\n  `n /= g_cd`, `d /= g_cd`\n  `parent[i] = root`\n  `val[i] = (n, d)`\n  Return `(root, (n, d))`\n\nWhen processing edge `(u, v, g, l)`:\n`(root_u, (num_u, den_u)) = find(u)`\n`(root_v, (num_v, den_v)) = find(v)`\n\nIf `root_u == root_v`:\n  `m_u = m_{root_u} * (num_u / den_u)`\n  `m_v = m_{root_u} * (num_v / den_v)`\n  `gcd(m_{root_u} * num_u / den_u, m_{root_u} * num_v / den_v) = g`\n  `lcm(m_{root_u} * num_u / den_u, m_{root_u} * num_v / den_v) = l`\n  This implies `m_{root_u} * (gcd(num_u/den_u, num_v/den_v))` is not right.\n  We need to use `m_u = (m_{root_u} * num_u) // den_u` and `m_v = (m_{root_u} * num_v) // den_v`.\n  For `m_u` and `m_v` to be integers, `m_{root_u} * num_u` must be divisible by `den_u`, and `m_{root_u} * num_v` by `den_v`.\n  Let `m_{root_u} = X`.\n  `gcd(X * num_u / den_u, X * num_v / den_v) = g`\n  `lcm(X * num_u / den_u, X * num_v / den_v) = l`\n  Let `A = num_u / den_u` and `B = num_v / den_v`.\n  `gcd(X * A, X * B) = X * gcd(A, B)` is only true if A, B are integers.\n  Let `A = n_u/d_u`, `B = n_v/d_v`.\n  `X * n_u / d_u` and `X * n_v / d_v` must be integers.\n  `X` must be a multiple of `lcm(d_u, d_v)`. Let `X = k * lcm(d_u, d_v)`.\n  Then `m_u = k * lcm(d_u, d_v) * n_u / d_u` and `m_v = k * lcm(d_u, d_v) * n_v / d_v`.\n  Let `D = lcm(d_u, d_v)`.\n  `m_u = k * D * n_u / d_u`\n  `m_v = k * D * n_v / d_v`\n  Now `m_u` and `m_v` are integers.\n  `gcd(k * D * n_u / d_u, k * D * n_v / d_v) = g`\n  `k * gcd(D * n_u / d_u, D * n_v / d_v) = g`\n  So `k = g / gcd(D * n_u / d_u, D * n_v / d_v)`.\n  This `k` must be an integer.\n  Also, `lcm(k * D * n_u / d_u, k * D * n_v / d_v) = l`.\n  `k * lcm(D * n_u / d_u, D * n_v / d_v) = l`.\n  This gives another `k`. Both must be consistent.\n  `m_{root_u} = X = k * D`.\n  This value `m_{root_u}` must be consistent with `component_val[root_u]`.\n  Also, `m_u, m_v` must be `<= 10^6`.\n\nThis fractional approach is more robust.\n`component_val[root]` will store the actual integer `m_{root}`.\n`val[i]` will store `(num, den)` representing `m_i / m_{parent[i]}`.\n`component_val_min_X[root]` will store the minimum `X` such that `X * num / den` is integer for all `(num, den)` in the component. This is `lcm` of all `den` in the component.\nWhen `find(i)` returns `(root, (N, D))`, `N/D` is `m_i / m_{root}`.\nThen `m_i = m_{root} * N / D`. For `m_i` to be an integer, `m_{root}` must be a multiple of `D / gcd(N, D)`.\nSo `m_{root}` must be a multiple of `D_prime = D // gcd(N, D)`.\n`component_val_min_X[root]` should be `lcm` of all `D_prime` values encountered for that root.\nInitialize `component_val_min_X[root] = 1`. When processing an edge `(u, v, g, l)` and `find(u)` returns `(root_u, (N_u, D_u))`, we update `component_val_min_X[root_u] = lcm(component_val_min_X[root_u], D_u // gcd(N_u, D_u))`.\n\nLet's simplify. `m_i` are integers.\n`m_u = m_{root_u} * (num_u / den_u)` means `m_u * den_u = m_{root_u} * num_u`.\n`m_v = m_{root_v} * (num_v / den_v)` means `m_v * den_v = m_{root_v} * num_v`.\nWhen `root_u == root_v`:\nLet `X = m_{root_u}`.\n`m_u = X * num_u / den_u`\n`m_v = X * num_v / den_v`\n`m_u, m_v` must be integers. So `X * num_u` must be divisible by `den_u`, and `X * num_v` by `den_v`.\nLet `gcd_X_nu_du = gcd(X * num_u, den_u)`. Then `den_u / gcd_X_nu_du` must be 1.\nThis is equivalent to `X` being a multiple of `den_u / gcd(X, den_u)` and `num_u` being a multiple of `den_u / gcd(X, den_u)`.\nThis is becoming too complex. The original values `g, l` are up to `10^6`. `m_i` are up to `10^6`.\n`m_u = g * x`, `m_v = g * y`. `x, y` are coprime factors of `l/g`.\n`x, y` can be up to `10^6`.\n`val_u_to_root` (from `m_u / m_{root_u}`) can be `10^6`.\nSo if `m_u = 10^6`, `m_{root_u} = 1`, `val_u_to_root = 10^6`.\nIf `m_u = 1`, `m_{root_u} = 10^6`, `val_u_to_root = 1/10^6`. This cannot be. `m_i` must be `m_{root_i} * val_i_to_root_integer`.\nThis implies `m_i` is always a multiple of `m_{root_i}`. This is a strong assumption.\n\nLet's re-read the problem statement: \"numbers on the roads on the initial map were no less that 1 and did not exceed 10^6\". This applies to GCD and LCM.\n\"restore the number of mushrooms on every lawn\". These are `m_i`.\nExample 3: `3 2`, edges `(3, 2, 1, 2)`, `(3, 1, 1, 10)`. Output `YES\\n5 1 2`.\n`m_1=5, m_2=1, m_3=2`.\nEdge `(3, 2, 1, 2)`: `m_3=2, m_2=1`. `gcd(2,1)=1`, `lcm(2,1)=2`. OK.\nEdge `(3, 1, 1, 10)`: `m_3=2, m_1=5`. `gcd(2,5)=1`, `lcm(2,5)=10`. OK.\nIn this case, `m_1=5, m_2=1, m_3=2`. If we pick `root=1`, `m_1=5`.\n`m_2 = m_1 * (1/5)`. `m_3 = m_1 * (2/5)`.\nThis confirms that `val` must be fractional.\n\nCorrected DSU `val` and `component_val` logic with fractions:\n*   `parent[i]`: Parent of node `i`.\n*   `val[i]`: `(num, den)` such that `m_i / m_{parent[i]} = num / den`.\n*   `component_val[root]`: Stores the actual integer value `m_{root}` if determined, otherwise 0.\n\n`find(i)`:\n  If `parent[i] == i`, return `(i, (1, 1))`.\n  `(root, (n_p, d_p)) = find(parent[i])`\n  `(n_curr, d_curr) = val[i]`\n  `n_new = n_curr * n_p`\n  `d_new = d_curr * d_p`\n  `g_cd = gcd(n_new, d_new)`\n  `n_new //= g_cd`\n  `d_new //= g_cd`\n  `parent[i] = root`\n  `val[i] = (n_new, d_new)`\n  Return `(root, (n_new, d_new))`\n\nWhen processing edge `(u, v, g, l)`:\n`(root_u, (num_u, den_u)) = find(u)`\n`(root_v, (num_v, den_v)) = find(v)`\n\nIf `root_u == root_v`:\n  Let `X = m_{root_u}`.\n  `m_u = X * num_u / den_u`\n  `m_v = X * num_v / den_v`\n  For `m_u, m_v` to be integers, `X * num_u` must be divisible by `den_u` and `X * num_v` by `den_v`.\n  Let `A = num_u * den_v`, `B = num_v * den_u`. `D = den_u * den_v`.\n  `m_u = X * A / D`, `m_v = X * B / D`.\n  `m_u = X * num_u * den_v / (den_u * den_v)`\n  `m_v = X * num_v * den_u / (den_u * den_v)`\n  Let `C_u = num_u * den_v`, `C_v = num_v * den_u`.\n  `m_u = X * C_u / D`, `m_v = X * C_v / D`.\n  Need `X * C_u` to be divisible by `D` and `X * C_v` by `D`.\n  This is equivalent to `X` being a multiple of `D / gcd(C_u, D)` and `D / gcd(C_v, D)`.\n  So `X` must be a multiple of `lcm(D / gcd(C_u, D), D / gcd(C_v, D))`.\n  Let `min_X_mult = lcm(D // gcd(C_u, D), D // gcd(C_v, D))`.\n  Now, `m_u = (X / min_X_mult) * (min_X_mult * C_u / D)`\n  `m_v = (X / min_X_mult) * (min_X_mult * C_v / D)`\n  Let `X' = X / min_X_mult`. And `val_u_eff = min_X_mult * C_u / D`, `val_v_eff = min_X_mult * C_v / D`.\n  These `val_u_eff, val_v_eff` are integers.\n  `gcd(X' * val_u_eff, X' * val_v_eff) = g`\n  `X' * gcd(val_u_eff, val_v_eff) = g`\n  So `X' = g / gcd(val_u_eff, val_v_eff)`.\n  If `g % gcd(val_u_eff, val_v_eff) != 0`, then impossible.\n  `m_{root_u} = X = X' * min_X_mult`.\n  Check if `lcm(X * num_u / den_u, X * num_v / den_v) == l`.\n  If `component_val[root_u]` is set and `component_val[root_u] != X`, then impossible.\n  Set `component_val[root_u] = X`.\n  Also check `X <= 10^6`.\n\nIf `root_u != root_v`:\n  We want to find `K = m_{root_v} / m_{root_u}`.\n  `m_u = m_{root_u} * num_u / den_u`\n  `m_v = m_{root_v} * num_v / den_v = m_{root_u} * K * num_v / den_v`\n  Let `P = l / g`. We know `m_u * m_v = g * l`.\n  `m_{root_u}^2 * K * (num_u/den_u) * (num_v/den_v) = g * l`\n  `m_{root_u}^2 * K * (num_u * num_v) / (den_u * den_v) = g * l`\n  This is still not easy.\n  Instead, iterate `x, y` for `m_u = g*x, m_v = g*y`.\n  Then `m_{root_u} * num_u / den_u = g*x` and `m_{root_v} * num_v / den_v = g*y`.\n  `m_{root_u} = g * x * den_u / num_u`\n  `m_{root_v} = g * y * den_v / num_v`\n  For these to be integers, `g * x * den_u` must be divisible by `num_u`, and `g * y * den_v` by `num_v`.\n  Let `m_u_val_cand = g*x`, `m_v_val_cand = g*y`.\n  If `(g*x*den_u) % num_u != 0` or `(g*y*den_v) % num_v != 0`, this pair `(x,y)` is invalid.\n  `X_cand = (g*x*den_u) // num_u`\n  `Y_cand = (g*y*den_v) // num_v`\n  If `X_cand > 10^6` or `Y_cand > 10^6`, this pair `(x,y)` is invalid.\n  If `component_val[root_u]` is set and `component_val[root_u] != X_cand`, invalid.\n  If `component_val[root_v]` is set and `component_val[root_v] != Y_cand`, invalid.\n  If valid, we found `X_cand` and `Y_cand`.\n  Merge `root_v` into `root_u`: `parent[root_v] = root_u`.\n  `val[root_v] = (Y_cand, X_cand)` (since `m_{root_v} / m_{root_u} = Y_cand / X_cand`).\n  Set `component_val[root_u] = X_cand`, `component_val[root_v] = Y_cand`.\n  Break from `x, y` loop. If no such `x, y` found, then impossible.\n\nFinal Check:\nIterate `i` from 1 to `n`.\n`(root_i, (N_i, D_i)) = find(i)`.\nIf `component_val[root_i]` is 0, set `component_val[root_i] = 1`.\n`ans[i] = component_val[root_i] * N_i / D_i`.\nIf `(component_val[root_i] * N_i) % D_i != 0`, then impossible.\n`ans[i] = (component_val[root_i] * N_i) // D_i`.\nIf `ans[i] <= 0` or `ans[i] > 10^6`, then impossible.\n\nThis fractional DSU approach looks correct and covers all cases.\nMax `num`, `den` can be `10^6`. Products like `num_curr * num_p` can be `10^12`. Python handles large integers.\n\n```python\nimport math\n\ndef gcd(a, b):\n    return math.gcd(a, b)\n\ndef lcm(a, b):\n    if a == 0 or b == 0:\n        return 0\n    return (a * b) // gcd(a, b)\n\n# DSU with path compression and value tracking (fractional)\n# parent[i]: parent of node i\n# val[i]: (numerator, denominator) representing m_i / m_parent[i]\nparent = []\nval = [] # Stores (num, den) for m_i / m_parent[i]\ncomponent_val = [] # Stores actual integer value m_root for component root\n\ndef init_dsu(n_nodes):\n    global parent, val, component_val\n    parent = list(range(n_nodes + 1))\n    val = [(1, 1)] * (n_nodes + 1) # m_i / m_parent[i] = 1/1 initially\n    component_val = [0] * (n_nodes + 1) # 0 means not yet determined\n\ndef find(i):\n    if parent[i] == i:\n        return i, (1, 1) # Root, relative value to itself is 1/1\n    \n    root, (n_p, d_p) = find(parent[i]) # Recurse for parent\n    \n    # Current node's relative value to its direct parent\n    n_curr, d_curr = val[i]\n    \n    # Calculate m_i / m_root = (m_i / m_parent[i]) * (m_parent[i] / m_root)\n    n_new = n_curr * n_p\n    d_new = d_curr * d_p\n    \n    common = gcd(n_new, d_new)\n    n_new //= common\n    d_new //= common\n    \n    parent[i] = root # Path compression\n    val[i] = (n_new, d_new) # Update relative value to root\n    \n    return root, (n_new, d_new)\n\ndef get_prime_factors(num):\n    factors = []\n    d = 2\n    temp = num\n    while d * d <= temp:\n        if temp % d == 0:\n            factors.append(d)\n            while temp % d == 0:\n                temp //= d\n        d += 1\n    if temp > 1:\n        factors.append(temp)\n    return factors\n\ndef solve():\n    n, m = map(int, input().split())\n\n    init_dsu(n)\n    \n    edges = []\n    for _ in range(m):\n        u, v, g, l = map(int, input().split())\n        edges.append((u, v, g, l))\n        \n        if l % g != 0:\n            print(\"NO\")\n            return\n\n    for u, v, g, l in edges:\n        root_u, (num_u, den_u) = find(u)\n        root_v, (num_v, den_v) = find(v)\n\n        # Case 1: u and v are already in the same component\n        if root_u == root_v:\n            # m_u = X * num_u / den_u\n            # m_v = X * num_v / den_v\n            # X = m_root_u\n            \n            # For m_u, m_v to be integers, X*num_u must be divisible by den_u, etc.\n            # Find the smallest integer X_mult such that X_mult * num_u / den_u and X_mult * num_v / den_v are integers.\n            # This X_mult is lcm(den_u / gcd(X_mult, den_u), den_v / gcd(X_mult, den_v))\n            # More simply, X must be a multiple of D_u = den_u / gcd(num_u, den_u) and D_v = den_v / gcd(num_v, den_v)\n            # No, this is wrong. X * N / D is integer means D divides X*N.\n            # So X must be a multiple of D / gcd(X, D) * (something for N).\n            # Let's derive the effective integer values for m_u and m_v relative to X.\n            # m_u = X * num_u / den_u\n            # m_v = X * num_v / den_v\n            # To make these integers, X must be a multiple of den_u and den_v.\n            # More accurately, X must be a multiple of lcm(den_u/gcd(X,den_u), den_v/gcd(X,den_v))\n            # Let's use the explicit integer values.\n            # m_u_actual = m_{root_u} * num_u / den_u\n            # m_v_actual = m_{root_u} * num_v / den_v\n            \n            # The actual values of m_u and m_v must be integers.\n            # Let M_u_val = m_{root_u} * num_u\n            # Let M_v_val = m_{root_u} * num_v\n            # m_u = M_u_val / den_u\n            # m_v = M_v_val / den_v\n            # gcd(m_u, m_v) = g\n            # lcm(m_u, m_v) = l\n            \n            # The constraints are on m_u and m_v.\n            # Let X = component_val[root_u]. If it's 0, we'll try to determine it.\n            # If X is already determined:\n            if component_val[root_u] != 0:\n                X = component_val[root_u]\n                if (X * num_u) % den_u != 0 or (X * num_v) % den_v != 0:\n                    print(\"NO\")\n                    return\n                m_u_cand = (X * num_u) // den_u\n                m_v_cand = (X * num_v) // den_v\n                \n                if gcd(m_u_cand, m_v_cand) != g or lcm(m_u_cand, m_v_cand) != l:\n                    print(\"NO\")\n                    return\n            else: # X is not determined, we need to find it\n                # We know m_u = g*x, m_v = g*y where x*y = l/g and gcd(x,y)=1\n                # And m_u = X * num_u / den_u\n                # And m_v = X * num_v / den_v\n                # So X = m_u * den_u / num_u = m_v * den_v / num_v\n                \n                P = l // g\n                prime_factors_P = get_prime_factors(P)\n                \n                found_X = False\n                # Iterate through all combinations of factors for x and y\n                for i in range(1 << len(prime_factors_P)):\n                    x = 1\n                    for j in range(len(prime_factors_P)):\n                        if (i >> j) & 1:\n                            x *= prime_factors_P[j]\n                    y = P // x\n                    \n                    # Try (m_u, m_v) = (g*x, g*y)\n                    m_u_cand = g * x\n                    m_v_cand = g * y\n                    \n                    if (m_u_cand * den_u) % num_u == 0 and (m_v_cand * den_v) % num_v == 0:\n                        X_cand_1 = (m_u_cand * den_u) // num_u\n                        X_cand_2 = (m_v_cand * den_v) // num_v\n                        \n                        if X_cand_1 == X_cand_2: # Found a consistent X\n                            X = X_cand_1\n                            if X <= 0 or X > 10**6:\n                                continue # X must be within bounds\n                            \n                            # Double check with current GCD/LCM\n                            if gcd(m_u_cand, m_v_cand) == g and lcm(m_u_cand, m_v_cand) == l:\n                                component_val[root_u] = X\n                                found_X = True\n                                break\n                    \n                    # Try (m_u, m_v) = (g*y, g*x)\n                    m_u_cand = g * y\n                    m_v_cand = g * x\n                    \n                    if (m_u_cand * den_u) % num_u == 0 and (m_v_cand * den_v) % num_v == 0:\n                        X_cand_1 = (m_u_cand * den_u) // num_u\n                        X_cand_2 = (m_v_cand * den_v) // num_v\n                        \n                        if X_cand_1 == X_cand_2: # Found a consistent X\n                            X = X_cand_1\n                            if X <= 0 or X > 10**6:\n                                continue # X must be within bounds\n                            \n                            # Double check with current GCD/LCM\n                            if gcd(m_u_cand, m_v_cand) == g and lcm(m_u_cand, m_v_cand) == l:\n                                component_val[root_u] = X\n                                found_X = True\n                                break\n                \n                if not found_X:\n                    print(\"NO\")\n                    return\n\n        # Case 2: u and v are in different components, merge them\n        else:\n            # We want to merge root_v into root_u.\n            # This means parent[root_v] = root_u, and val[root_v] = m_root_v / m_root_u\n            # Let K = m_root_v / m_root_u = (num_K, den_K)\n            # m_u = m_root_u * num_u / den_u\n            # m_v = m_root_v * num_v / den_v = m_root_u * K * num_v / den_v\n            \n            # Iterate through possible (x, y) pairs for (m_u, m_v)\n            P = l // g\n            prime_factors_P = get_prime_factors(P)\n            \n            merged = False\n            for i in range(1 << len(prime_factors_P)):\n                x = 1\n                for j in range(len(prime_factors_P)):\n                    if (i >> j) & 1:\n                        x *= prime_factors_P[j]\n                y = P // x\n\n                # Try (m_u, m_v) = (g*x, g*y)\n                m_u_cand = g * x\n                m_v_cand = g * y\n                \n                # Check if m_root_u and m_root_v would be integers and in range\n                # m_root_u = m_u_cand * den_u / num_u\n                # m_root_v = m_v_cand * den_v / num_v\n                if (m_u_cand * den_u) % num_u == 0 and (m_v_cand * den_v) % num_v == 0:\n                    X_cand = (m_u_cand * den_u) // num_u\n                    Y_cand = (m_v_cand * den_v) // num_v\n                    \n                    if X_cand > 0 and X_cand <= 10**6 and Y_cand > 0 and Y_cand <= 10**6:\n                        # Check for consistency if component_val is already set\n                        if component_val[root_u] != 0 and component_val[root_u] != X_cand:\n                            pass # Inconsistent, try next (x,y)\n                        elif component_val[root_v] != 0 and component_val[root_v] != Y_cand:\n                            pass # Inconsistent, try next (x,y)\n                        else:\n                            # Valid K = Y_cand / X_cand found\n                            parent[root_v] = root_u\n                            common_k = gcd(Y_cand, X_cand)\n                            val[root_v] = (Y_cand // common_k, X_cand // common_k)\n                            \n                            if component_val[root_u] == 0:\n                                component_val[root_u] = X_cand\n                            if component_val[root_v] == 0:\n                                component_val[root_v] = Y_cand\n                            \n                            merged = True\n                            break\n                \n                if merged: break # Found a way to merge, no need to try (g*y, g*x) or other pairs\n\n                # Try (m_u, m_v) = (g*y, g*x)\n                m_u_cand = g * y\n                m_v_cand = g * x\n                \n                if (m_u_cand * den_u) % num_u == 0 and (m_v_cand * den_v) % num_v == 0:\n                    X_cand = (m_u_cand * den_u) // num_u\n                    Y_cand = (m_v_cand * den_v) // num_v\n                    \n                    if X_cand > 0 and X_cand <= 10**6 and Y_cand > 0 and Y_cand <= 10**6:\n                        if component_val[root_u] != 0 and component_val[root_u] != X_cand:\n                            pass\n                        elif component_val[root_v] != 0 and component_val[root_v] != Y_cand:\n                            pass\n                        else:\n                            parent[root_v] = root_u\n                            common_k = gcd(Y_cand, X_cand)\n                            val[root_v] = (Y_cand // common_k, X_cand // common_k)\n                            \n                            if component_val[root_u] == 0:\n                                component_val[root_u] = X_cand\n                            if component_val[root_v] == 0:\n                                component_val[root_v] = Y_cand\n                            \n                            merged = True\n                            break\n            \n            if not merged:\n                print(\"NO\")\n                return\n\n    # After processing all edges, calculate final mushroom counts\n    ans = [0] * (n + 1)\n    for i in range(1, n + 1):\n        root_i, (num_i, den_i) = find(i)\n        \n        # If root's value is not determined, set it to 1 (smallest possible positive integer)\n        if component_val[root_i] == 0:\n            component_val[root_i] = 1\n        \n        # Calculate m_i = m_root_i * num_i / den_i\n        X = component_val[root_i]\n        \n        if (X * num_i) % den_i != 0:\n            print(\"NO\")\n            return\n        \n        m_i_final = (X * num_i) // den_i\n        \n        if m_i_final <= 0 or m_i_final > 10**6:\n            print(\"NO\")\n            return\n        \n        ans[i] = m_i_final\n    \n    print(\"YES\")\n    print(*(ans[1:]))\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef gcd(a, b):\n    return math.gcd(a, b)\n\ndef lcm(a, b):\n    if a == 0 or b == 0:\n        return 0\n    return (a * b) // gcd(a, b)\n\n# DSU with path compression and value tracking (fractional)\n# parent[i]: parent of node i\n# val[i]: (numerator, denominator) representing m_i / m_parent[i]\nparent = []\nval = [] # Stores (num, den) for m_i / m_parent[i]\ncomponent_val = [] # Stores actual integer value m_root for component root\n\ndef init_dsu(n_nodes):\n    global parent, val, component_val\n    parent = list(range(n_nodes + 1))\n    val = [(1, 1)] * (n_nodes + 1) # m_i / m_parent[i] = 1/1 initially\n    component_val = [0] * (n_nodes + 1) # 0 means not yet determined\n\ndef find(i):\n    if parent[i] == i:\n        return i, (1, 1) # Root, relative value to itself is 1/1\n    \n    root, (n_p, d_p) = find(parent[i]) # Recurse for parent\n    \n    # Current node's relative value to its direct parent\n    n_curr, d_curr = val[i]\n    \n    # Calculate m_i / m_root = (m_i / m_parent[i]) * (m_parent[i] / m_root)\n    n_new = n_curr * n_p\n    d_new = d_curr * d_p\n    \n    common = gcd(n_new, d_new)\n    n_new //= common\n    d_new //= common\n    \n    parent[i] = root # Path compression\n    val[i] = (n_new, d_new) # Update relative value to root\n    \n    return root, (n_new, d_new)\n\ndef get_prime_factors(num):\n    factors = []\n    d = 2\n    temp = num\n    while d * d <= temp:\n        if temp % d == 0:\n            factors.append(d)\n            while temp % d == 0:\n                temp //= d\n        d += 1\n    if temp > 1:\n        factors.append(temp)\n    return factors\n\ndef solve():\n    n, m = map(int, input().split())\n\n    init_dsu(n)\n    \n    edges = []\n    for _ in range(m):\n        u, v, g, l = map(int, input().split())\n        edges.append((u, v, g, l))\n        \n        if l % g != 0:\n            print(\"NO\")\n            return\n\n    for u, v, g, l in edges:\n        root_u, (num_u, den_u) = find(u)\n        root_v, (num_v, den_v) = find(v)\n\n        # Case 1: u and v are already in the same component\n        if root_u == root_v:\n            # m_u = X * num_u / den_u\n            # m_v = X * num_v / den_v\n            # X = m_root_u\n            \n            # For m_u, m_v to be integers, X*num_u must be divisible by den_u, etc.\n            # Find the smallest integer X_mult such that X_mult * num_u / den_u and X_mult * num_v / den_v are integers.\n            # This X_mult is lcm(den_u / gcd(X_mult, den_u), den_v / gcd(X_mult, den_v))\n            # More simply, X must be a multiple of D_u = den_u / gcd(num_u, den_u) and D_v = den_v / gcd(num_v, den_v)\n            # No, this is wrong. X * N / D is integer means D divides X*N.\n            # So X must be a multiple of D / gcd(X, D) * (something for N).\n            # Let's derive the effective integer values for m_u and m_v relative to X.\n            # m_u = X * num_u / den_u\n            # m_v = X * num_v / den_v\n            # To make these integers, X must be a multiple of den_u and den_v.\n            # More accurately, X must be a multiple of lcm(den_u/gcd(X,den_u), den_v/gcd(X,den_v))\n            # Let's use the explicit integer values.\n            # m_u_actual = m_{root_u} * num_u / den_u\n            # m_v_actual = m_{root_u} * num_v / den_v\n            \n            # The actual values of m_u and m_v must be integers.\n            # Let M_u_val = m_{root_u} * num_u\n            # Let M_v_val = m_{root_u} * num_v\n            # m_u = M_u_val / den_u\n            # m_v = M_v_val / den_v\n            # gcd(m_u, m_v) = g\n            # lcm(m_u, m_v) = l\n            \n            # The constraints are on m_u and m_v.\n            # Let X = component_val[root_u]. If it's 0, we'll try to determine it.\n            # If X is already determined:\n            if component_val[root_u] != 0:\n                X = component_val[root_u]\n                if (X * num_u) % den_u != 0 or (X * num_v) % den_v != 0:\n                    print(\"NO\")\n                    return\n                m_u_cand = (X * num_u) // den_u\n                m_v_cand = (X * num_v) // den_v\n                \n                if gcd(m_u_cand, m_v_cand) != g or lcm(m_u_cand, m_v_cand) != l:\n                    print(\"NO\")\n                    return\n            else: # X is not determined, we need to find it\n                # We know m_u = g*x, m_v = g*y where x*y = l/g and gcd(x,y)=1\n                # And m_u = X * num_u / den_u\n                # And m_v = X * num_v / den_v\n                # So X = m_u * den_u / num_u = m_v * den_v / num_v\n                \n                P = l // g\n                prime_factors_P = get_prime_factors(P)\n                \n                found_X = False\n                # Iterate through all combinations of factors for x and y\n                for i in range(1 << len(prime_factors_P)):\n                    x = 1\n                    for j in range(len(prime_factors_P)):\n                        if (i >> j) & 1:\n                            x *= prime_factors_P[j]\n                    y = P // x\n                    \n                    # Try (m_u, m_v) = (g*x, g*y)\n                    m_u_cand = g * x\n                    m_v_cand = g * y\n                    \n                    if (m_u_cand * den_u) % num_u == 0 and (m_v_cand * den_v) % num_v == 0:\n                        X_cand_1 = (m_u_cand * den_u) // num_u\n                        X_cand_2 = (m_v_cand * den_v) // num_v\n                        \n                        if X_cand_1 == X_cand_2: # Found a consistent X\n                            X = X_cand_1\n                            if X <= 0 or X > 10**6:\n                                continue # X must be within bounds\n                            \n                            # Double check with current GCD/LCM\n                            if gcd(m_u_cand, m_v_cand) == g and lcm(m_u_cand, m_v_cand) == l:\n                                component_val[root_u] = X\n                                found_X = True\n                                break\n                    \n                    # Try (m_u, m_v) = (g*y, g*x)\n                    m_u_cand = g * y\n                    m_v_cand = g * x\n                    \n                    if (m_u_cand * den_u) % num_u == 0 and (m_v_cand * den_v) % num_v == 0:\n                        X_cand_1 = (m_u_cand * den_u) // num_u\n                        X_cand_2 = (m_v_cand * den_v) // num_v\n                        \n                        if X_cand_1 == X_cand_2: # Found a consistent X\n                            X = X_cand_1\n                            if X <= 0 or X > 10**6:\n                                continue # X must be within bounds\n                            \n                            # Double check with current GCD/LCM\n                            if gcd(m_u_cand, m_v_cand) == g and lcm(m_u_cand, m_v_cand) == l:\n                                component_val[root_u] = X\n                                found_X = True\n                                break\n                \n                if not found_X:\n                    print(\"NO\")\n                    return\n\n        # Case 2: u and v are in different components, merge them\n        else:\n            # We want to merge root_v into root_u.\n            # This means parent[root_v] = root_u, and val[root_v] = m_root_v / m_root_u\n            # Let K = m_root_v / m_root_u = (num_K, den_K)\n            # m_u = m_root_u * num_u / den_u\n            # m_v = m_root_v * num_v / den_v = m_root_u * K * num_v / den_v\n            \n            # Iterate through possible (x, y) pairs for (m_u, m_v)\n            P = l // g\n            prime_factors_P = get_prime_factors(P)\n            \n            merged = False\n            for i in range(1 << len(prime_factors_P)):\n                x = 1\n                for j in range(len(prime_factors_P)):\n                    if (i >> j) & 1:\n                        x *= prime_factors_P[j]\n                y = P // x\n\n                # Try (m_u, m_v) = (g*x, g*y)\n                m_u_cand = g * x\n                m_v_cand = g * y\n                \n                # Check if m_root_u and m_root_v would be integers and in range\n                # m_root_u = m_u_cand * den_u / num_u\n                # m_root_v = m_v_cand * den_v / num_v\n                if (m_u_cand * den_u) % num_u == 0 and (m_v_cand * den_v) % num_v == 0:\n                    X_cand = (m_u_cand * den_u) // num_u\n                    Y_cand = (m_v_cand * den_v) // num_v\n                    \n                    if X_cand > 0 and X_cand <= 10**6 and Y_cand > 0 and Y_cand <= 10**6:\n                        # Check for consistency if component_val is already set\n                        if component_val[root_u] != 0 and component_val[root_u] != X_cand:\n                            pass # Inconsistent, try next (x,y)\n                        elif component_val[root_v] != 0 and component_val[root_v] != Y_cand:\n                            pass # Inconsistent, try next (x,y)\n                        else:\n                            # Valid K = Y_cand / X_cand found\n                            parent[root_v] = root_u\n                            common_k = gcd(Y_cand, X_cand)\n                            val[root_v] = (Y_cand // common_k, X_cand // common_k)\n                            \n                            if component_val[root_u] == 0:\n                                component_val[root_u] = X_cand\n                            if component_val[root_v] == 0:\n                                component_val[root_v] = Y_cand\n                            \n                            merged = True\n                            break\n                \n                if merged: break # Found a way to merge, no need to try (g*y, g*x) or other pairs\n\n                # Try (m_u, m_v) = (g*y, g*x)\n                m_u_cand = g * y\n                m_v_cand = g * x\n                \n                if (m_u_cand * den_u) % num_u == 0 and (m_v_cand * den_v) % num_v == 0:\n                    X_cand = (m_u_cand * den_u) // num_u\n                    Y_cand = (m_v_cand * den_v) // num_v\n                    \n                    if X_cand > 0 and X_cand <= 10**6 and Y_cand > 0 and Y_cand <= 10**6:\n                        if component_val[root_u] != 0 and component_val[root_u] != X_cand:\n                            pass\n                        elif component_val[root_v] != 0 and component_val[root_v] != Y_cand:\n                            pass\n                        else:\n                            parent[root_v] = root_u\n                            common_k = gcd(Y_cand, X_cand)\n                            val[root_v] = (Y_cand // common_k, X_cand // common_k)\n                            \n                            if component_val[root_u] == 0:\n                                component_val[root_u] = X_cand\n                            if component_val[root_v] == 0:\n                                component_val[root_v] = Y_cand\n                            \n                            merged = True\n                            break\n            \n            if not merged:\n                print(\"NO\")\n                return\n\n    # After processing all edges, calculate final mushroom counts\n    ans = [0] * (n + 1)\n    for i in range(1, n + 1):\n        root_i, (num_i, den_i) = find(i)\n        \n        # If root's value is not determined, set it to 1 (smallest possible positive integer)\n        if component_val[root_i] == 0:\n            component_val[root_i] = 1\n        \n        # Calculate m_i = m_root_i * num_i / den_i\n        X = component_val[root_i]\n        \n        if (X * num_i) % den_i != 0:\n            print(\"NO\")\n            return\n        \n        m_i_final = (X * num_i) // den_i\n        \n        if m_i_final <= 0 or m_i_final > 10**6:\n            print(\"NO\")\n            return\n        \n        ans[i] = m_i_final\n    \n    print(\"YES\")\n    print(*(ans[1:]))\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 552,
        "completion_token_count": 13072,
        "thoughts_token_count": 729
    }
}