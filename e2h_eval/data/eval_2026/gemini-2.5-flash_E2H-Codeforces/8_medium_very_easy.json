{
    "start": 1758011901.2473507,
    "end": 1758012009.6202502,
    "start-formatted": "2025-09-16 17:38 KST",
    "end-formatted": "2025-09-16 17:40 KST",
    "gpu": 2,
    "pid": 8,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "**Problem-Solving Journey for \"Flawed Flow\"**\n\nOkay, so I'm tackling this \"Flawed Flow\" problem. It's about directing edges in a graph to represent a valid max flow from node 1 to node n. The given capacities are valid, so I just need to figure out the directions, given that for all intermediate nodes, the sum of incoming flow must equal outgoing flow, there are no cycles, and node 1 has no incoming flow.\n\nMy initial thoughts are centered around these core conditions. The \"no cycles\" part screams topological sort, and since node 1 has no incoming edges, it must be the source. So, I need to find some kind of ordering, and I'm guessing edges will mostly follow that order.\n\nThe conservation rule is central: `in_flow = out_flow` for intermediate nodes. I could try to maintain a `balance` at each node, adjusting it as I orient edges. Basically, if I direct an edge towards a node, I increase its balance; if I direct away, I decrease it. The challenge is that I don't know the final flow yet.\n\nSo, for each intermediate node `v`, it must start with a balance of zero at the end. I can think of it as \"potential\" versus \"actual\" flow.\n\nSince the problem guarantees a solution, this suggests that there's a certain structure I can exploit. Maybe I could somehow find a topological sort of the graph by enforcing that balance rule. I could process nodes iteratively. For instance, the \"no cycles\" condition is very restrictive and could simplify this significantly.\n\nThe trick could be: process vertices that are \"ready\" to make a decision. I could start from node 1, and process its outgoing edges, since this is forced by the condition that no incoming edges. Then I could use a topological sort. I need to handle all the intermediate nodes.\n\nI could work with a queue and push nodes into the queue. Initially, push all neighbours of `1`, as the direction for all edges with node 1 can be known. Each time a node gets processed, it pushes more nodes into the queue as their \"balance\" is determined. I need to keep track of the remaining \"undirected\" edges. When a node has only one undirected edge remaining, I should be able to determine which direction is required to make the balance equal to zero. This should keep pushing nodes into the queue, so the loop continues until all nodes' balances are zero.\n\nFor any edge `(u, v, c)` if `v` has only one undirected edge remaining, if `current_balance[v]` > 0, the edge is `v -> u`. If `current_balance[v]` < 0, the edge is `u -> v`. This should work, I think.\n",
    "response": "The problem asks us to direct each edge `(a_i, b_i)` with a given flow volume `c_i` such that the resulting directed graph satisfies three conditions:\n1.  **Flow Conservation:** For each vertex `v` (1 < v < n), the sum of `c_i` of incoming edges equals the sum of `c_i` of outgoing edges.\n2.  **Source Condition:** Vertex `1` (the source) has no incoming edges.\n3.  **Acyclicity:** The obtained directed graph does not have cycles.\n\nWe need to output `0` if the `i`-th edge is directed `a_i -> b_i` and `1` if it's directed `b_i -> a_i`.\n\nLet's analyze the conditions:\n\n**Condition 2: Vertex 1 has no incoming edges.**\nThis is a strong constraint. For any edge `(1, u, c)`, it must be directed `1 -> u`. We can use this to initialize our process.\n\n**Condition 1: Flow Conservation for intermediate vertices (1 < v < n).**\nFor any intermediate vertex `v`, the net flow into `v` must be zero. Let's maintain a `current_net_in_flow[v]` for each vertex `v`. Initially, all `current_net_in_flow[v]` are `0`.\nWhen we direct an edge `u -> v` with flow `c`:\n*   `current_net_in_flow[u]` decreases by `c` (flow leaves `u`).\n*   `current_net_in_flow[v]` increases by `c` (flow enters `v`).\nOur goal is that for `1 < v < n`, the final `current_net_in_flow[v]` must be `0`.\n\n**Condition 3: No cycles.**\nThis implies that there exists a topological ordering of the vertices. This is crucial as it suggests a processing order. If we can ensure that we always direct edges from a \"lower\" level vertex to a \"higher\" level vertex, we can avoid cycles.\n\n**Combined Strategy (Topological Sort based):**\n\nThe problem can be solved using a queue-based approach similar to Kahn's algorithm for topological sort. We identify vertices whose flow balance can be determined and use that to direct their incident edges.\n\n1.  **Data Structures:**\n    *   `adj[v]`: A list of tuples `(neighbor, flow_capacity, edge_index)` for each vertex `v`.\n    *   `ans[edge_index]`: An array to store the final direction for each edge (0 for `a_i -> b_i`, 1 for `b_i -> a_i`).\n    *   `current_net_in_flow[v]`: An array to keep track of the net flow into each vertex `v`. Initialize to `0` for all `v`.\n    *   `undirected_degree[v]`: An array to keep track of the number of *undirected* edges still incident to `v`. Initialize by counting edges.\n    *   `q`: A queue to store vertices whose flow balance is \"determined\" or whose last remaining edge can be directed.\n\n2.  **Initialization (Handle Source `1`):**\n    For every edge `(u, v, c, idx)` in the input:\n    *   If `u == 1` (and `v != 1`):\n        *   Direct `1 -> v`. Set `ans[idx] = 0`.\n        *   Update `current_net_in_flow[1] -= c`.\n        *   Update `current_net_in_flow[v] += c`.\n        *   Decrement `undirected_degree[1]` and `undirected_degree[v]`.\n    *   If `v == 1` (and `u != 1`):\n        *   Direct `1 -> u`. Set `ans[idx] = 1`.\n        *   Update `current_net_in_flow[1] -= c`.\n        *   Update `current_net_in_flow[u] += c`.\n        *   Decrement `undirected_degree[1]` and `undirected_degree[u]`.\n\n    After processing all edges connected to `1`, iterate through all vertices `v` from `2` to `n-1`. If `undirected_degree[v] == 1`, add `v` to the queue `q`. These are vertices that have only one remaining undirected edge.\n\n3.  **Main Loop (BFS-like):**\n    While the queue `q` is not empty:\n    *   Dequeue a vertex `v`.\n    *   If `v == n` (the sink), skip it. The sink doesn't need to balance its flow to zero. Its `current_net_in_flow` will naturally become the total max flow `F`.\n    *   Find the unique remaining undirected edge `(v, u, c, idx)` incident to `v`.\n    *   **Determine direction:**\n        *   If `current_net_in_flow[v] > 0`: Vertex `v` has received more flow than it has sent. To balance, it *must* send `current_net_in_flow[v]` flow through the edge `(v, u)`. So, direct `v -> u`.\n            *   Set `ans[idx] = 0` if `v` was `a_i` in the original input, `1` if `v` was `b_i`.\n            *   Update `current_net_in_flow[v] -= c`.\n            *   Update `current_net_in_flow[u] += c`.\n        *   If `current_net_in_flow[v] < 0`: Vertex `v` has sent more flow than it has received. To balance, it *must* receive `abs(current_net_in_flow[v])` flow through the edge `(v, u)`. So, direct `u -> v`.\n            *   Set `ans[idx] = 1` if `v` was `a_i` in the original input, `0` if `v` was `b_i`.\n            *   Update `current_net_in_flow[v] += c`.\n            *   Update `current_net_in_flow[u] -= c`.\n        *   *(Note: `current_net_in_flow[v]` should be `0` at this point if `v` is an intermediate node and `c` is the only remaining flow to balance. The problem guarantees a solution exists, so `abs(current_net_in_flow[v])` must be equal to `c`.)*\n\n    *   Decrement `undirected_degree[u]`.\n    *   If `undirected_degree[u] == 1` and `u != 1` and `u != n`, add `u` to the queue `q`.\n\nThis process ensures that for any intermediate node `v` that gets processed, its `current_net_in_flow[v]` becomes `0`. The \"no cycles\" condition is naturally satisfied because we process nodes in an order that implies a topological sort: nodes with only one remaining edge are \"leaf-like\" in the remaining undirected graph, and by directing that edge, they are effectively removed, potentially making other nodes \"leaf-like\". This process continues until all intermediate nodes are balanced.\n\nThe source `1` will have a negative `current_net_in_flow` (total flow leaving), and the sink `n` will have a positive `current_net_in_flow` (total flow entering), which is consistent with max-flow definitions.\n\n**Example Walkthrough (First Sample Case):**\n`n=3, m=3`\nEdges:\n1.  `(3, 2, 10)`\n2.  `(1, 2, 10)`\n3.  `(3, 1, 5)`\n\n`adj` lists:\n`1: [(2, 10, 1), (3, 5, 2)]` (original indices 1-based, adjusted to 0-based for code)\n`2: [(3, 10, 0), (1, 10, 1)]`\n`3: [(2, 10, 0), (1, 5, 2)]`\n\n`current_net_in_flow = [0, 0, 0]`\n`undirected_degree = [2, 2, 2]` (for vertices 1, 2, 3)\n`ans = [-1, -1, -1]`\n\n**Initialization (Handle Source 1):**\n*   Edge `(1, 2, 10, 1)`: `1 -> 2`. `ans[1] = 0`.\n    `current_net_in_flow[0] -= 10` (`-10`)\n    `current_net_in_flow[1] += 10` (`10`)\n    `undirected_degree[0] -= 1` (`1`)\n    `undirected_degree[1] -= 1` (`1`)\n*   Edge `(3, 1, 5, 2)`: `1` is involved. `u=3, v=1`. Must be `1 -> 3`. `ans[2] = 1` (since original was 3->1).\n    `current_net_in_flow[0] -= 5` (`-15`)\n    `current_net_in_flow[2] += 5` (`5`)\n    `undirected_degree[2] -= 1` (`1`)\n    `undirected_degree[0] -= 1` (`0`)\n\nCurrent state:\n`current_net_in_flow = [-15, 10, 5]` (for vertices 1, 2, 3)\n`undirected_degree = [0, 1, 1]`\n`ans = [-1, 0, 1]` (edge 0 still undirected)\n\n**Populate Queue:**\n*   `v=2`: `undirected_degree[1] == 1`. Add `2` to `q`.\n*   `v=3`: `undirected_degree[2] == 1`. Add `3` to `q`.\n`q = [2, 3]`\n\n**Main Loop:**\n\n1.  Dequeue `v = 2`.\n    *   `current_net_in_flow[1] = 10 > 0`. `v` needs to send flow.\n    *   The only remaining undirected edge for `2` is `(3, 2, 10, 0)`.\n    *   Direction must be `2 -> 3`.\n    *   Original edge was `(3, 2)`. So `3 -> 2` is `ans=1`, `2 -> 3` is `ans=0`. Set `ans[0] = 0`.\n    *   `current_net_in_flow[1] -= 10` (`0`)\n    *   `current_net_in_flow[2] += 10` (`15`)\n    *   Neighbor `u = 3`. `undirected_degree[2] -= 1` (`0`).\n    *   `undirected_degree[2] == 0`. Don't add `3` to queue.\n\nCurrent state:\n`current_net_in_flow = [-15, 0, 15]`\n`undirected_degree = [0, 0, 0]`\n`ans = [0, 0, 1]`\n`q = [3]`\n\n2.  Dequeue `v = 3`.\n    *   `v` is the sink (`n`). Skip.\n\n`q` is empty. Loop ends.\n\nFinal `ans`:\n`ans[0] = 0` (original edge (3,2,10), now 2->3)\n`ans[1] = 0` (original edge (1,2,10), now 1->2)\n`ans[2] = 1` (original edge (3,1,5), now 1->3)\n\nOutput for the sample: `1\\n0\\n1`\nMy calculated `ans` is `[0, 0, 1]`.\nWait, the sample output is `1\\n0\\n1`.\nThis means:\nEdge 0: `(3,2,10)` -> `2 -> 3` (my `ans[0]=0`)\nEdge 1: `(1,2,10)` -> `1 -> 2` (my `ans[1]=0`)\nEdge 2: `(3,1,5)` -> `1 -> 3` (my `ans[2]=1`)\n\nThe sample output is `1\\n0\\n1`.\nLet's check the sample output's meaning:\n1. `(3,2,10)` -> `1` means `2 -> 3`. (Matches my `ans[0]=0`)\n2. `(1,2,10)` -> `0` means `1 -> 2`. (Matches my `ans[1]=0`)\n3. `(3,1,5)` -> `1` means `1 -> 3`. (Matches my `ans[2]=1`)\n\nMy output matches the sample output if the problem statement's `di` mapping is `0` for `ai -> bi` and `1` for `bi -> ai`.\nThe sample output for the first edge is `1`. For `(3,2,10)`, `a=3, b=2`. `1` means `b -> a`, so `2 -> 3`.\nFor the second edge `(1,2,10)`, `a=1, b=2`. `0` means `a -> b`, so `1 -> 2`.\nFor the third edge `(3,1,5)`, `a=3, b=1`. `1` means `b -> a`, so `1 -> 3`.\n\nThe sample output is `1\\n0\\n1`. My calculated `ans` values are `[0, 0, 1]`.\nLet's check the meaning of `ans[idx]` for `idx=0` (edge `(3,2,10)`). My code says `ans[0]=0`.\nThis means `a_0 -> b_0`, i.e., `3 -> 2`.\nBut the sample says `1`, meaning `b_0 -> a_0`, i.e., `2 -> 3`.\nThere's a mismatch in my interpretation of `ans[idx]` vs the problem's `di`.\n\nMy `ans` array stores the direction relative to the *original* `(a_i, b_i)` pair.\n`ans[idx] = 0` means `a_i -> b_i`.\n`ans[idx] = 1` means `b_i -> a_i`.\n\nLet's trace carefully the first edge direction:\nEdge `(3,2,10)` is `edges[0]`. `a_0=3, b_0=2`.\nIn my code, when `v=2` is processed, `current_net_in_flow[1]` is `10`. `v=2` needs to send flow.\nThe edge is `(2,3,10,0)`. Vertex `2` is `a_i` and `3` is `b_i` from its perspective.\nMy code directs `2 -> 3`.\nThe original edge was `(3,2)`. So `a_0=3, b_0=2`.\nIf `2 -> 3`, this is `b_0 -> a_0`. So `ans[0]` should be `1`.\n\nMy code logic for setting `ans[idx]` was:\n`ans[idx] = 0` if `v` was `a_i` in the original input AND `v -> u`.\n`ans[idx] = 1` if `v` was `a_i` in the original input AND `u -> v`.\n`ans[idx] = 1` if `v` was `b_i` in the original input AND `v -> u`.\n`ans[idx] = 0` if `v` was `b_i` in the original input AND `u -> v`.\n\nLet's store the original `(a_i, b_i)` for each edge.\n`edges_info[idx] = (a_i, b_i)`.\n\nWhen processing `v` and its unique undirected neighbor `u` via edge `idx`:\nIf `v` is `edges_info[idx][0]` (i.e. `v == a_idx`):\n    If `v -> u` (send flow): `ans[idx] = 0`\n    If `u -> v` (receive flow): `ans[idx] = 1`\nIf `v` is `edges_info[idx][1]` (i.e. `v == b_idx`):\n    If `v -> u` (send flow): `ans[idx] = 1`\n    If `u -> v` (receive flow): `ans[idx] = 0`\n\nLet's re-trace with this corrected `ans` logic:\n\n**Initialization (Handle Source 1):**\nOriginal edges: `(3,2,10,0)`, `(1,2,10,1)`, `(3,1,5,2)`\n`edges_info = [(3,2), (1,2), (3,1)]`\n\n*   Edge `(1,2,10,1)`: `a_1=1, b_1=2`. `u=1, v=2`.\n    `1` is `a_1`. Must be `1 -> 2`. So `ans[1] = 0`.\n    `current_net_in_flow[0] -= 10` (`-10`)\n    `current_net_in_flow[1] += 10` (`10`)\n    `undirected_degree[0] -= 1` (`1`)\n    `undirected_degree[1] -= 1` (`1`)\n*   Edge `(3,1,5,2)`: `a_2=3, b_2=1`. `u=3, v=1`.\n    `1` is `b_2`. Must be `1 -> 3`. So `ans[2] = 1`.\n    `current_net_in_flow[0] -= 5` (`-15`)\n    `current_net_in_flow[2] += 5` (`5`)\n    `undirected_degree[2] -= 1` (`1`)\n    `undirected_degree[0] -= 1` (`0`)\n\nCurrent state:\n`current_net_in_flow = [-15, 10, 5]` (for vertices 1, 2, 3)\n`undirected_degree = [0, 1, 1]`\n`ans = [-1, 0, 1]`\n`q = [2, 3]`\n\n**Main Loop:**\n\n1.  Dequeue `v = 2`.\n    *   `current_net_in_flow[1] = 10 > 0`. `v=2` needs to send flow.\n    *   Unique undirected edge for `2` is `(3, 2, 10, 0)`. `idx=0`.\n    *   `edges_info[0] = (3,2)`. `v=2` is `b_0`.\n    *   Direction `2 -> 3`. `v=2` sends flow (`v -> u`).\n    *   Since `v` is `b_0` and `v -> u`, `ans[0]` must be `1`.\n    *   `current_net_in_flow[1] -= 10` (`0`)\n    *   `current_net_in_flow[2] += 10` (`15`)\n    *   Neighbor `u = 3`. `undirected_degree[2] -= 1` (`0`).\n    *   `undirected_degree[2] == 0`. Don't add `3` to queue.\n\nCurrent state:\n`current_net_in_flow = [-15, 0, 15]`\n`undirected_degree = [0, 0, 0]`\n`ans = [1, 0, 1]`\n`q = [3]`\n\n2.  Dequeue `v = 3`.\n    *   `v` is the sink (`n`). Skip.\n\n`q` is empty. Loop ends.\n\nFinal `ans`: `[1, 0, 1]`. This matches the sample output!\n\nThe logic for setting `ans[idx]` is crucial and needs to be correct.\n\n```python\nimport sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    # Store edges along with their original index and endpoints\n    # adj[u] will store (v, capacity, edge_idx, original_a, original_b)\n    adj = [[] for _ in range(n)]\n    edges_info = [] # To store (original_a, original_b) for each edge_idx\n    \n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        u -= 1 # 0-indexed\n        v -= 1 # 0-indexed\n        \n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n        edges_info.append((u, v))\n\n    # current_net_in_flow[v]: net flow into vertex v\n    current_net_in_flow = [0] * n\n    # undirected_degree[v]: number of undirected edges incident to v\n    undirected_degree = [0] * n\n    # ans[i]: direction for i-th edge (0 for a_i -> b_i, 1 for b_i -> a_i)\n    ans = [-1] * m\n\n    # Calculate initial undirected_degree for all vertices\n    for i in range(m):\n        u, v = edges_info[i]\n        undirected_degree[u] += 1\n        undirected_degree[v] += 1\n\n    q = deque()\n\n    # Phase 1: Handle edges connected to source (vertex 0)\n    # Vertex 0 must have no incoming edges. All connected edges must be outgoing.\n    # To avoid modifying adj list while iterating, collect edges to process\n    edges_from_source = []\n    for neighbor, capacity, edge_idx in adj[0]:\n        if ans[edge_idx] == -1: # Only process if not already directed\n            edges_from_source.append((0, neighbor, capacity, edge_idx))\n    \n    for u, v, c, edge_idx in edges_from_source:\n        # u is source (0), v is neighbor\n        # Direction must be u -> v (0 -> neighbor)\n        \n        # Determine original a_i, b_i for this edge_idx\n        orig_a, orig_b = edges_info[edge_idx]\n        if orig_a == u: # Original was u -> v\n            ans[edge_idx] = 0 # u -> v\n        else: # Original was v -> u\n            ans[edge_idx] = 1 # u -> v (which is orig_b -> orig_a)\n\n        current_net_in_flow[u] -= c\n        current_net_in_flow[v] += c\n        \n        undirected_degree[u] -= 1\n        undirected_degree[v] -= 1\n        \n        # If neighbor v now has only one undirected edge left and it's not source/sink\n        if undirected_degree[v] == 1 and v != 0 and v != n - 1:\n            q.append(v)\n\n    # Phase 2: Process vertices with one remaining undirected edge\n    while q:\n        v = q.popleft()\n\n        # If v is already balanced or has no more edges to direct (e.g. processed by other neighbor)\n        if undirected_degree[v] != 1:\n            continue\n        \n        # Find the unique remaining undirected edge for v\n        # Iterate through adj[v] to find the edge that hasn't been directed yet\n        unique_undirected_edge = None\n        for neighbor, capacity, edge_idx in adj[v]:\n            if ans[edge_idx] == -1:\n                unique_undirected_edge = (neighbor, capacity, edge_idx)\n                break\n        \n        if unique_undirected_edge is None:\n            # This can happen if v was added to queue, but its last edge was directed\n            # by processing its neighbor first.\n            continue \n\n        u, c, edge_idx = unique_undirected_edge\n        \n        # Determine direction based on v's current net flow\n        # v must balance its flow to 0 (for 1 < v < n)\n        \n        orig_a, orig_b = edges_info[edge_idx]\n        \n        if current_net_in_flow[v] > 0:\n            # v has received more flow, so it must send flow out through (v, u)\n            # Direction: v -> u\n            if orig_a == v:\n                ans[edge_idx] = 0 # v -> u\n            else: # orig_b == v\n                ans[edge_idx] = 1 # v -> u (which is orig_b -> orig_a)\n            \n            current_net_in_flow[v] -= c\n            current_net_in_flow[u] += c\n        elif current_net_in_flow[v] < 0:\n            # v has sent more flow, so it must receive flow in through (u, v)\n            # Direction: u -> v\n            if orig_a == v:\n                ans[edge_idx] = 1 # u -> v (which is orig_b -> orig_a)\n            else: # orig_b == v\n                ans[edge_idx] = 0 # u -> v\n            \n            current_net_in_flow[v] += c\n            current_net_in_flow[u] -= c\n        # If current_net_in_flow[v] == 0, this means the sum of remaining flows\n        # must be zero. This case shouldn't happen for a node with 1 undirected edge\n        # unless c is 0, which is not allowed. The problem guarantees a solution,\n        # so current_net_in_flow[v] will be non-zero and equal to +/- c.\n\n        undirected_degree[v] -= 1\n        undirected_degree[u] -= 1\n\n        # If neighbor u now has only one undirected edge left and it's not source/sink\n        if undirected_degree[u] == 1 and u != 0 and u != n - 1:\n            q.append(u)\n\n    # Output the results\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + '\\n')\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    # Store edges along with their original index and endpoints\n    # adj[u] will store (v, capacity, edge_idx, original_a, original_b)\n    adj = [[] for _ in range(n)]\n    edges_info = [] # To store (original_a, original_b) for each edge_idx\n    \n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        u -= 1 # 0-indexed\n        v -= 1 # 0-indexed\n        \n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n        edges_info.append((u, v))\n\n    # current_net_in_flow[v]: net flow into vertex v\n    current_net_in_flow = [0] * n\n    # undirected_degree[v]: number of undirected edges incident to v\n    undirected_degree = [0] * n\n    # ans[i]: direction for i-th edge (0 for a_i -> b_i, 1 for b_i -> a_i)\n    ans = [-1] * m\n\n    # Calculate initial undirected_degree for all vertices\n    for i in range(m):\n        u, v = edges_info[i]\n        undirected_degree[u] += 1\n        undirected_degree[v] += 1\n\n    q = deque()\n\n    # Phase 1: Handle edges connected to source (vertex 0)\n    # Vertex 0 must have no incoming edges. All connected edges must be outgoing.\n    # To avoid modifying adj list while iterating, collect edges to process\n    edges_from_source = []\n    for neighbor, capacity, edge_idx in adj[0]:\n        if ans[edge_idx] == -1: # Only process if not already directed\n            edges_from_source.append((0, neighbor, capacity, edge_idx))\n    \n    for u, v, c, edge_idx in edges_from_source:\n        # u is source (0), v is neighbor\n        # Direction must be u -> v (0 -> neighbor)\n        \n        # Determine original a_i, b_i for this edge_idx\n        orig_a, orig_b = edges_info[edge_idx]\n        if orig_a == u: # Original was u -> v\n            ans[edge_idx] = 0 # u -> v\n        else: # Original was v -> u\n            ans[edge_idx] = 1 # u -> v (which is orig_b -> orig_a)\n\n        current_net_in_flow[u] -= c\n        current_net_in_flow[v] += c\n        \n        undirected_degree[u] -= 1\n        undirected_degree[v] -= 1\n        \n        # If neighbor v now has only one undirected edge left and it's not source/sink\n        if undirected_degree[v] == 1 and v != 0 and v != n - 1:\n            q.append(v)\n\n    # Phase 2: Process vertices with one remaining undirected edge\n    while q:\n        v = q.popleft()\n\n        # If v is already balanced or has no more edges to direct (e.g. processed by other neighbor)\n        if undirected_degree[v] != 1:\n            continue\n        \n        # Find the unique remaining undirected edge for v\n        # Iterate through adj[v] to find the edge that hasn't been directed yet\n        unique_undirected_edge = None\n        for neighbor, capacity, edge_idx in adj[v]:\n            if ans[edge_idx] == -1:\n                unique_undirected_edge = (neighbor, capacity, edge_idx)\n                break\n        \n        if unique_undirected_edge is None:\n            # This can happen if v was added to queue, but its last edge was directed\n            # by processing its neighbor first.\n            continue \n\n        u, c, edge_idx = unique_undirected_edge\n        \n        # Determine direction based on v's current net flow\n        # v must balance its flow to 0 (for 1 < v < n)\n        \n        orig_a, orig_b = edges_info[edge_idx]\n        \n        if current_net_in_flow[v] > 0:\n            # v has received more flow, so it must send flow out through (v, u)\n            # Direction: v -> u\n            if orig_a == v:\n                ans[edge_idx] = 0 # v -> u\n            else: # orig_b == v\n                ans[edge_idx] = 1 # v -> u (which is orig_b -> orig_a)\n            \n            current_net_in_flow[v] -= c\n            current_net_in_flow[u] += c\n        elif current_net_in_flow[v] < 0:\n            # v has sent more flow, so it must receive flow in through (u, v)\n            # Direction: u -> v\n            if orig_a == v:\n                ans[edge_idx] = 1 # u -> v (which is orig_b -> orig_a)\n            else: # orig_b == v\n                ans[edge_idx] = 0 # u -> v\n            \n            current_net_in_flow[v] += c\n            current_net_in_flow[u] -= c\n        # If current_net_in_flow[v] == 0, this means the sum of remaining flows\n        # must be zero. This case shouldn't happen for a node with 1 undirected edge\n        # unless c is 0, which is not allowed. The problem guarantees a solution,\n        # so current_net_in_flow[v] will be non-zero and equal to +/- c.\n\n        undirected_degree[v] -= 1\n        undirected_degree[u] -= 1\n\n        # If neighbor u now has only one undirected edge left and it's not source/sink\n        if undirected_degree[u] == 1 and u != 0 and u != n - 1:\n            q.append(u)\n\n    # Output the results\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + '\\n')\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 746,
        "completion_token_count": 6268,
        "thoughts_token_count": 5934
    }
}