{
    "start": 1758294766.9933465,
    "end": 1758294817.6536126,
    "start-formatted": "2025-09-20 00:12 KST",
    "end-formatted": "2025-09-20 00:13 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "**Solving the Neko Does Maths Problem**\n\nAlright, let's break this down. My goal is to find the smallest non-negative integer `k` that minimizes the least common multiple (LCM) of `a+k` and `b+k`. I'm an expert, so I know a bit about number theory, and I've quickly figured out that I'll need to work with the greatest common divisor (GCD) and its relationship to LCM: `lcm(x, y) = (x * y) / gcd(x, y)`.\n\nFirst, I realize that `gcd(a+k, b+k)` must be a divisor of the absolute difference between `a` and `b`. So, I'll calculate `diff = abs(b - a)`. If `a` and `b` are equal, the answer is trivially `k=0`.\n\nNow, if they are different, I know that the GCD will be a divisor of `diff`, and I'll iterate through all the divisors `d` of `diff`, which is where my number theory knowledge comes in handy. For each `d`, I need to find the smallest `k` that makes `a+k` a multiple of `d`. This will give me `k = (d - (a % d)) % d`. Then, I'll calculate `b+k`, compute the GCD of `a+k` and `b+k`, and finally the LCM. I need to keep track of the smallest LCM I've found so far and the corresponding `k` value.\n\nThe clever part is realizing I can iterate through the divisors in pairs. I iterate from 1 up to the square root of `diff`. For each divisor `i`, I calculate `d1 = i` and `d2 = diff // i`. Then, I compute the corresponding `k` values and LCMs for both `d1` and `d2`. After iterating through all the pairs, I have the smallest LCM and the corresponding `k`.\n\nI know Python's integer arithmetic will handle large values gracefully. I set up my code and test it with several examples. Finally, I confirm this process works, the edge cases are handled, and Iâ€™m ready to submit my solution.\n",
    "response": "The problem asks us to find a non-negative integer `k` such that `lcm(a+k, b+k)` is minimized. If multiple `k` values yield the same minimum LCM, we should choose the smallest `k`.\n\nLet `x = a+k` and `y = b+k`. We want to minimize `lcm(x, y)`.\nWe know that `lcm(x, y) = (x * y) / gcd(x, y)`.\nAlso, `gcd(x, y) = gcd(a+k, b+k)`.\nA fundamental property of GCD is `gcd(A, B) = gcd(A, B-A)`. Applying this, we get:\n`gcd(a+k, b+k) = gcd(a+k, (b+k) - (a+k)) = gcd(a+k, b-a)`.\nThis implies that `gcd(a+k, b+k)` must be a divisor of `abs(b-a)`.\n\nLet `diff = abs(b-a)`.\nIf `a = b`, then `diff = 0`. In this case, `gcd(a+k, b+k) = gcd(a+k, a+k) = a+k`.\n`lcm(a+k, b+k) = lcm(a+k, a+k) = a+k`.\nTo minimize `a+k` for `k \\ge 0`, we choose `k=0`. So if `a=b`, the answer is `0`.\n\nIf `a \\ne b`, then `diff > 0`.\nWe know that `d = gcd(a+k, b+k)` must be a divisor of `diff`.\nThis observation is key: we can iterate through all possible divisors `d` of `diff`. For each `d`, we try to find the smallest non-negative `k` such that `a+k` is a multiple of `d`.\nIf `a+k` is a multiple of `d`, then `a+k \\equiv 0 \\pmod d`, which means `k \\equiv -a \\pmod d`.\nThe smallest non-negative `k` satisfying this is `k = (d - (a % d)) % d`.\nLet's call this `k_val`.\nFor this `k_val`, `a+k_val` is a multiple of `d`.\nAlso, `b+k_val = (a+diff) + k_val = (a+k_val) + diff`. Since `a+k_val` is a multiple of `d` and `diff` is a multiple of `d` (because `d` is a divisor of `diff`), `b+k_val` will also be a multiple of `d`.\nThus, for this `k_val`, both `a+k_val` and `b+k_val` are multiples of `d`, so `gcd(a+k_val, b+k_val)` is at least `d`.\n\nThe algorithm is as follows:\n1. Handle the base case: If `a = b`, print `0` and exit.\n2. Calculate `diff = abs(b - a)`.\n3. Initialize `min_lcm` and `best_k`. A good starting point is `k=0`:\n   `current_gcd = math.gcd(a, b)`\n   `min_lcm = (a * b) // current_gcd`\n   `best_k = 0`\n4. Iterate through all divisors `d` of `diff`. Divisors come in pairs `(i, diff // i)`. We can iterate `i` from `1` up to `sqrt(diff)`.\n   For each `i` that divides `diff`:\n   a. Consider `d1 = i`.\n      Calculate `cur_k = (d1 - (a % d1)) % d1`.\n      Calculate `val1 = a + cur_k` and `val2 = b + cur_k`.\n      Calculate `current_lcm = (val1 * val2) // math.gcd(val1, val2)`.\n      If `current_lcm < min_lcm`: update `min_lcm = current_lcm` and `best_k = cur_k`.\n      Else if `current_lcm == min_lcm`: update `best_k = min(best_k, cur_k)` (to ensure the smallest `k` is chosen).\n   b. If `i * i != diff`, consider `d2 = diff // i`.\n      Repeat the same calculations as for `d1` with `d2`.\n5. After checking all divisors, `best_k` will hold the smallest non-negative `k` that minimizes the LCM. Print `best_k`.\n\n**Complexity:**\n- `a, b` up to `10^9`.\n- `diff` up to `10^9`.\n- Finding divisors takes `O(sqrt(diff))` time. `sqrt(10^9)` is approximately `31622`.\n- For each divisor, calculating `gcd` takes `O(log(max(a+k, b+k)))`. `a+k, b+k` can be up to `2 * 10^9`. `log(2 * 10^9)` is about `31`.\n- The number of divisors for a number up to `10^9` is at most `576`.\n- Total time complexity: `O(sqrt(diff) + num_divisors * log(max(a,b)))`, which is well within typical time limits for competitive programming (e.g., `31622 + 576 * 31 \\approx 49478` operations).\n- Python's arbitrary-precision integers handle large products like `val1 * val2` without overflow.\n\nExample `a=6, b=10`:\n`diff = 4`.\nInitial: `k=0`, `lcm(6,10) = 30`. `min_lcm=30, best_k=0`.\nDivisors of 4: `1, 2, 4`.\n- `d=1`: `cur_k = (1 - (6%1))%1 = 0`. `lcm(6,10)=30`. `min_lcm=30, best_k=0`.\n- `d=2`: `cur_k = (2 - (6%2))%2 = 0`. `lcm(6,10)=30`. `min_lcm=30, best_k=0`.\n- `d=4`: `cur_k = (4 - (6%4))%4 = 2`. `lcm(6+2, 10+2) = lcm(8,12) = 24`. `24 < 30`, so `min_lcm=24, best_k=2`.\nFinal `best_k=2`.\n\n```python\nimport math\n\ndef solve():\n    a, b = map(int, input().split())\n\n    if a == b:\n        print(0)\n        return\n\n    diff = abs(b - a)\n\n    # Initialize with k=0\n    # Current values are a, b\n    current_gcd = math.gcd(a, b)\n    min_lcm = (a * b) // current_gcd\n    best_k = 0\n\n    # Iterate through divisors of diff\n    # Divisors come in pairs (i, diff // i)\n    for i in range(1, int(math.sqrt(diff)) + 1):\n        if diff % i == 0:\n            # Process d1 = i\n            d1 = i\n            cur_k1 = (d1 - (a % d1)) % d1\n            \n            val1_k1 = a + cur_k1\n            val2_k1 = b + cur_k1\n            \n            current_gcd1 = math.gcd(val1_k1, val2_k1)\n            lcm1 = (val1_k1 * val2_k1) // current_gcd1\n            \n            if lcm1 < min_lcm:\n                min_lcm = lcm1\n                best_k = cur_k1\n            elif lcm1 == min_lcm:\n                best_k = min(best_k, cur_k1)\n\n            # Process d2 = diff // i, if it's different from d1\n            if i * i != diff:\n                d2 = diff // i\n                cur_k2 = (d2 - (a % d2)) % d2\n                \n                val1_k2 = a + cur_k2\n                val2_k2 = b + cur_k2\n                \n                current_gcd2 = math.gcd(val1_k2, val2_k2)\n                lcm2 = (val1_k2 * val2_k2) // current_gcd2\n                \n                if lcm2 < min_lcm:\n                    min_lcm = lcm2\n                    best_k = cur_k2\n                elif lcm2 == min_lcm:\n                    best_k = min(best_k, cur_k2)\n                    \n    print(best_k)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef solve():\n    a, b = map(int, input().split())\n\n    if a == b:\n        print(0)\n        return\n\n    diff = abs(b - a)\n\n    # Initialize with k=0\n    # Current values are a, b\n    current_gcd = math.gcd(a, b)\n    min_lcm = (a * b) // current_gcd\n    best_k = 0\n\n    # Iterate through divisors of diff\n    # Divisors come in pairs (i, diff // i)\n    for i in range(1, int(math.sqrt(diff)) + 1):\n        if diff % i == 0:\n            # Process d1 = i\n            d1 = i\n            cur_k1 = (d1 - (a % d1)) % d1\n            \n            val1_k1 = a + cur_k1\n            val2_k1 = b + cur_k1\n            \n            current_gcd1 = math.gcd(val1_k1, val2_k1)\n            lcm1 = (val1_k1 * val2_k1) // current_gcd1\n            \n            if lcm1 < min_lcm:\n                min_lcm = lcm1\n                best_k = cur_k1\n            elif lcm1 == min_lcm:\n                best_k = min(best_k, cur_k1)\n\n            # Process d2 = diff // i, if it's different from d1\n            if i * i != diff:\n                d2 = diff // i\n                cur_k2 = (d2 - (a % d2)) % d2\n                \n                val1_k2 = a + cur_k2\n                val2_k2 = b + cur_k2\n                \n                current_gcd2 = math.gcd(val1_k2, val2_k2)\n                lcm2 = (val1_k2 * val2_k2) // current_gcd2\n                \n                if lcm2 < min_lcm:\n                    min_lcm = lcm2\n                    best_k = cur_k2\n                elif lcm2 == min_lcm:\n                    best_k = min(best_k, cur_k2)\n                    \n    print(best_k)\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 422,
        "completion_token_count": 2134,
        "thoughts_token_count": 6453
    }
}