{
    "start": 1758294931.2785037,
    "end": 1758295005.9713326,
    "start-formatted": "2025-09-20 00:15 KST",
    "end-formatted": "2025-09-20 00:16 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "**Unveiling the Optimal Directed Graph**\n\nAlright, let's dissect this competitive programming puzzle. My goal is to craft a directed graph that satisfies two criteria: first, it must be *p*-reachable (meaning it contains a specific number of ordered node pairs that are mutually reachable); and second, I want to minimize the total number of nodes in this graph. Simultaneously, I'm tasked with maximizing the number of unidirectional pairs - those connections where a path exists in one direction, but not the reverse.\n\nEssentially, I need to balance the number of nodes with the count of bidirectional connections.\n\nLet's break down the rules: mutual reachability means nodes belong to the same *strongly connected component* (SCC). A graph is *p*-reachable when the sum of bidirectional pairs across all its SCCs equals *p*. To minimize nodes, I realize that grouping them into larger SCCs is key. The formula for the pairs in a SCC (x * (x-1)/2) grows quickly, so fewer large groups give the smallest number of nodes. This translates to an integer partition problem, where I try to express *p* as a sum of these SCC pair counts, minimizing the sum of SCC sizes.\n\nMy greedy strategy unfolds this way: I find the largest possible SCC size (*x*) such that its contribution doesn't exceed the current *p* value. I keep reducing *p* by the SCC's contribution and repeat until *p* hits zero. The total nodes are calculated.\n\nNow, to maximize unidirectional pairs, I want to minimize shared reachability across SCCs, which is done when I arrange the SCCs in a line. In this topological order, all node pairs between different SCCs are unidirectional, maximizing our goal. The total unidirectional pairs, then, are calculated by the total of all possible edges between SCCs.\n\nIn summary, the solution boils down to a greedy approach to determine the minimum number of nodes, and then carefully ordering SCCs to maximize the unidirectional count.\n",
    "response": "The problem asks us to find two values for a given integer `p`:\n1. The minimum number of nodes `n` required to create a directed graph that has exactly `p` ordered pairs `(u, v)` such that `u < v` and `u` and `v` are reachable from each other.\n2. Among all such graphs with the minimum number of nodes `n`, the maximum number of unidirectional pairs of nodes. An ordered pair `(u, v)` is unidirectional if `u \\neq v`, there's a path from `u` to `v`, and no path from `v` to `u`.\n\nLet's analyze the conditions:\n\n**1. `p`-reachable pairs:**\nThe condition \"u and v are reachable from each other\" means that `u` and `v` belong to the same strongly connected component (SCC).\nIf an SCC has `s` nodes, any two distinct nodes `u, v` within this SCC are mutually reachable. The number of ordered pairs `(u, v)` with `u < v` within this SCC is `s * (s - 1) / 2`.\nLet `f(s) = s * (s - 1) / 2`.\nIf a graph has `k` SCCs with sizes `s_1, s_2, ..., s_k`, the total number of `p`-reachable pairs is `P = \\sum_{i=1}^k f(s_i)`.\nThe total number of nodes in the graph is `n = \\sum_{i=1}^k s_i`.\nWe need `P = p`, and we want to minimize `n`.\n\nTo minimize `n` for a fixed `p`, we should use as few nodes as possible to achieve the sum `p`. Since `f(s)` grows quadratically (`f(s) \\approx s^2/2`), it's more efficient (in terms of nodes) to use larger SCCs than many small ones. For example, `f(3)=3` (uses 3 nodes), while `f(2)=1`. To get `p=3`, we could use one SCC of size 3 (total 3 nodes) or three SCCs of size 2 (total 6 nodes). The former is better.\nThis suggests a greedy approach: always pick the largest possible SCC size `s` such that `f(s) \\le p`.\n\n**Algorithm for minimum `n`:**\nInitialize `min_n = 0`, `scc_sizes_sum_sq = 0`.\nLet `current_p = p`.\nWhile `current_p > 0`:\n  a. Find the largest integer `s` such that `s * (s - 1) / 2 \\le current_p`.\n     This can be found by solving `s^2 - s - 2 * current_p \\le 0`. The positive root of `s^2 - s - 2 * current_p = 0` is `(1 + \\sqrt{1 + 8 * current_p}) / 2`.\n     So, `s_candidate = \\lfloor (1 + \\sqrt{1 + 8 * current_p}) / 2 \\rfloor`.\n     To be safe against floating-point precision errors, we can verify and adjust `s_candidate`:\n     `s = int((1 + math.sqrt(1 + 8 * current_p)) / 2)`\n     If `s * (s - 1) // 2 > current_p`: `s -= 1`\n     If `(s + 1) * s // 2 <= current_p`: `s += 1`\n  b. Add `s` to `min_n`.\n  c. Add `s*s` to `scc_sizes_sum_sq`. (This will be used for the second part of the problem).\n  d. Subtract `s * (s - 1) / 2` from `current_p`.\n\n**2. Maximum unidirectional pairs:**\nOnce we have determined the minimum number of nodes `min_n` and the sizes of the SCCs `s_1, s_2, ..., s_k` (which sum up to `min_n`), we want to maximize the number of unidirectional pairs.\nA pair `(u, v)` is unidirectional if `u \\to v` and `v \\not\\to u`.\n- If `u` and `v` are in the same SCC, they are mutually reachable, so `(u, v)` is not unidirectional. There are `2p` such ordered pairs in total (counting both `(u,v)` and `(v,u)` for each `u<v` pair).\n- If `u` and `v` are in different SCCs, say `u \\in S_i` and `v \\in S_j` (`i \\neq j`), then `u` and `v` are not mutually reachable. To maximize unidirectional pairs, we should ensure that for every such pair of SCCs `S_i, S_j`, there's a path in one direction but not the other.\nThis is achieved by arranging the SCCs in a linear order, e.g., `S_1 \\to S_2 \\to \\dots \\to S_k`. This means we add edges from some node in `S_i` to some node in `S_{i+1}` (and transitively, `S_i \\to S_j` for all `i < j`).\nWith this construction:\n  - For `u \\in S_i, v \\in S_j` where `i < j`: there is a path `u \\to v`, but no path `v \\to u`. So, `(u, v)` is unidirectional. The number of such pairs is `|S_i| * |S_j|`.\n  - For `u \\in S_i, v \\in S_j` where `i > j`: there is a path `v \\to u`, but no path `u \\to v`. So, `(u, v)` is NOT unidirectional (but `(v, u)` is).\n\nThe total number of unidirectional pairs `(u, v)` (where `u \\in S_i, v \\in S_j` and `i < j`) is `\\sum_{1 \\le i < j \\le k} s_i * s_j`.\nThis sum can be expressed using the identity:\n`(\\sum s_i)^2 = \\sum s_i^2 + 2 * \\sum_{i < j} s_i * s_j`.\nSo, `\\sum_{i < j} s_i * s_j = ( (\\sum s_i)^2 - \\sum s_i^2 ) / 2`.\nSince `\\sum s_i = min_n` and `\\sum s_i^2 = scc_sizes_sum_sq`, the maximum number of unidirectional pairs is `(min_n^2 - scc_sizes_sum_sq) / 2`.\n\n**Example `p=4`:**\n1. Find `min_n`:\n   - `current_p = 4`.\n   - `s = int((1 + math.sqrt(1 + 8*4)) / 2) = int((1 + math.sqrt(33)) / 2) = int((1 + 5.74) / 2) = 3`.\n   - `f(3) = 3*2/2 = 3`. This is `\\le 4`.\n   - `f(3+1) = f(4) = 4*3/2 = 6`. This is `> 4`. So `s=3` is correct.\n   - `min_n = 3`. `scc_sizes_sum_sq = 3*3 = 9`. `current_p = 4 - 3 = 1`.\n   - `current_p = 1`.\n   - `s = int((1 + math.sqrt(1 + 8*1)) / 2) = int((1 + math.sqrt(9)) / 2) = int((1 + 3) / 2) = 2`.\n   - `f(2) = 2*1/2 = 1`. This is `\\le 1`.\n   - `f(2+1) = f(3) = 3*2/2 = 3`. This is `> 1`. So `s=2` is correct.\n   - `min_n = 3 + 2 = 5`. `scc_sizes_sum_sq = 9 + 2*2 = 13`. `current_p = 1 - 1 = 0`.\n   - Loop ends. `min_n = 5`.\n2. Maximize unidirectional pairs:\n   - `max_unidirectional_pairs = (min_n^2 - scc_sizes_sum_sq) / 2 = (5^2 - 13) / 2 = (25 - 13) / 2 = 12 / 2 = 6`.\nOutput: `5 6`. This matches the example.\n\n**Edge Case `p=0`:**\n- `current_p = 0`. The loop `while current_p > 0` does not execute.\n- `min_n = 0`. `scc_sizes_sum_sq = 0`.\n- `max_unidirectional_pairs = (0^2 - 0) / 2 = 0`.\nOutput: `0 0`. This matches the example.\n\nThe maximum value of `p` is `2 * 10^5`.\n`min_n` will be at most `2 * p` (if all SCCs are size 2). So `min_n` can be up to `4 * 10^5`.\n`min_n^2` can be up to `(4 * 10^5)^2 = 1.6 * 10^{11}`, which fits in standard 64-bit integers and Python handles large integers automatically.\n`scc_sizes_sum_sq` also fits.\n\n```python\nimport math\n\ndef solve():\n    p = int(input())\n\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    min_n = 0\n    scc_sizes_sum_sq = 0\n    current_p = p\n\n    while current_p > 0:\n        # Find the largest integer s such that s * (s - 1) / 2 <= current_p\n        # Solving s^2 - s - 2 * current_p <= 0\n        # s approx (1 + sqrt(1 + 8 * current_p)) / 2\n        \n        # Calculate s_candidate using floating point, then adjust to integer\n        s = int((1 + math.sqrt(1 + 8 * current_p)) / 2)\n        \n        # Adjust s to be robust against floating point inaccuracies\n        # Ensure s * (s - 1) // 2 is indeed the largest possible value <= current_p\n        while s * (s - 1) // 2 > current_p:\n            s -= 1\n        while (s + 1) * s // 2 <= current_p:\n            s += 1\n            \n        min_n += s\n        scc_sizes_sum_sq += s * s\n        current_p -= s * (s - 1) // 2\n\n    # Calculate maximum unidirectional pairs\n    # Total pairs (u,v) with u!=v is min_n * (min_n - 1)\n    # Pairs (u,v) where u,v are in same SCC is sum(s_i * (s_i - 1)) = 2 * p\n    # The remaining pairs are u in S_i, v in S_j, i!=j.\n    # To maximize unidirectional, arrange SCCs in a line S_1 -> S_2 -> ... -> S_k\n    # Unidirectional pairs are sum_{i<j} s_i * s_j\n    # This sum is ((sum s_i)^2 - sum s_i^2) / 2\n    # Which is (min_n^2 - scc_sizes_sum_sq) / 2\n    max_unidirectional_pairs = (min_n * min_n - scc_sizes_sum_sq) // 2\n\n    print(f\"{min_n} {max_unidirectional_pairs}\")\n\nif __name__ == '__main__':\n    solve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef solve():\n    p = int(input())\n\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    min_n = 0\n    scc_sizes_sum_sq = 0\n    current_p = p\n\n    while current_p > 0:\n        # Find the largest integer s such that s * (s - 1) / 2 <= current_p\n        # Solving s^2 - s - 2 * current_p <= 0\n        # s approx (1 + sqrt(1 + 8 * current_p)) / 2\n        \n        # Calculate s_candidate using floating point, then adjust to integer\n        s = int((1 + math.sqrt(1 + 8 * current_p)) / 2)\n        \n        # Adjust s to be robust against floating point inaccuracies\n        # Ensure s * (s - 1) // 2 is indeed the largest possible value <= current_p\n        while s * (s - 1) // 2 > current_p:\n            s -= 1\n        while (s + 1) * s // 2 <= current_p:\n            s += 1\n            \n        min_n += s\n        scc_sizes_sum_sq += s * s\n        current_p -= s * (s - 1) // 2\n\n    # Calculate maximum unidirectional pairs\n    # Total pairs (u,v) with u!=v is min_n * (min_n - 1)\n    # Pairs (u,v) where u,v are in same SCC is sum(s_i * (s_i - 1)) = 2 * p\n    # The remaining pairs are u in S_i, v in S_j, i!=j.\n    # To maximize unidirectional, arrange SCCs in a line S_1 -> S_2 -> ... -> S_k\n    # Unidirectional pairs are sum_{i<j} s_i * s_j\n    # This sum is ((sum s_i)^2 - sum s_i^2) / 2\n    # Which is (min_n^2 - scc_sizes_sum_sq) / 2\n    max_unidirectional_pairs = (min_n * min_n - scc_sizes_sum_sq) // 2\n\n    print(f\"{min_n} {max_unidirectional_pairs}\")\n\nif __name__ == '__main__':\n    solve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 482,
        "completion_token_count": 2838,
        "thoughts_token_count": 7985
    }
}