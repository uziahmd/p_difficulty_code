{
    "start": 1758294754.5151663,
    "end": 1758294811.1287835,
    "start-formatted": "2025-09-20 00:12 KST",
    "end-formatted": "2025-09-20 00:13 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "**Here's how I'm thinking about this problem:**\n\nI need to find the smallest non-negative integer `k` that minimizes the least common multiple (lcm) of `a+k` and `b+k`. My approach involves a few key observations. First, I know that `lcm(x, y) = (x * y) / gcd(x, y)`.  I'm going to let `A = a + k` and `B = b + k`.  I also realize that the greatest common divisor, `g = gcd(A, B)`, must divide the difference between `A` and `B`, which is just `b - a`.  I'll call this difference `d = |b - a|`.\n\nSo, the problem becomes finding the `k` that minimizes `lcm(a+k, b+k)` by cleverly choosing `k` to leverage the divisors of `d`. This means I should iterate through all the divisors of `d`. For each divisor, `g`, I try to find a `k` that ensures both `a+k` and `b+k` are divisible by `g`.\n\nTo find this `k` for a given `g`, I compute `k = (g - (a % g)) % g`. This ensures that `a + k` becomes a multiple of `g`. And since `g` divides `d`, and `b + k = (a + k) + (b - a)`, it also ensures that `b+k` is a multiple of `g`. I'm using the modulo operator for a clever wrap-around to ensure that `k` is non-negative and the smallest possible for the required divisibility.\n\nFor each such `k` corresponding to each `g`, I calculate the `lcm(a+k, b+k)` and keep track of the smallest `lcm` I've found so far and the `k` that produced it. If two `k` values give the same minimal `lcm`, I'll pick the smaller `k`.\n\nThere's a special case I need to handle. If `a` equals `b`, the difference `d` is zero. In this case, `lcm(a+k, b+k)` is simply `a+k`. The minimum of this expression is when `k=0`. My algorithm should account for that.\n\nI'm making sure my code efficiently finds the divisors of `d` by iterating up to the square root of `d`.  I'll also need to use the `gcd` function (from the `math` module) to compute the greatest common divisor efficiently. Finally, to handle potentially large values, I'm using Python's integer division.\n",
    "response": "The problem asks us to find the smallest non-negative integer `k` such that `lcm(a+k, b+k)` is minimized. If multiple `k` values yield the same minimum `lcm`, we must choose the smallest `k`.\n\nLet `A = a+k` and `B = b+k`. We want to minimize `lcm(A, B)`.\nWe know the relationship `lcm(A, B) = (A * B) / gcd(A, B)`.\n\nA key property of the greatest common divisor (GCD) is that `gcd(X, Y)` divides `|X - Y|`.\nIn our case, `gcd(a+k, b+k)` must divide `|(b+k) - (a+k)| = |b - a|`.\nLet `d = |b - a|`. So, `gcd(a+k, b+k)` must be a divisor of `d`.\n\nThis observation is crucial because `d` is a fixed value (independent of `k`). This means we only need to consider `k` values that lead to `gcd(a+k, b+k)` being one of the divisors of `d`.\n\nThe strategy is as follows:\n1.  **Handle the special case `a = b`**: If `a` and `b` are equal, then `a+k` and `b+k` are always equal. `lcm(a+k, a+k) = a+k`. To minimize `a+k`, we must choose the smallest non-negative `k`, which is `k=0`. So, if `a=b`, the answer is `0`.\n\n2.  **Calculate `d = |b - a|`**: For `a != b`, `d` will be a positive integer.\n\n3.  **Find all divisors of `d`**: We can do this efficiently by iterating from `1` up to `sqrt(d)`. If `i` divides `d`, then both `i` and `d/i` are divisors. The number of divisors for `d <= 10^9` is relatively small (at most a few hundred).\n\n4.  **Iterate through each divisor `g` of `d`**: For each `g`, we want to find the smallest non-negative `k` such that `gcd(a+k, b+k)` is at least `g`. The simplest way to guarantee `g` divides both `a+k` and `b+k` is to make `a+k` a multiple of `g`.\n    *   The smallest non-negative `k` such that `a+k` is a multiple of `g` can be calculated as `k = (g - (a % g)) % g`.\n        *   If `a % g == 0`, then `k = 0`. `a+k = a` is a multiple of `g`.\n        *   If `a % g != 0`, then `k = g - (a % g)`. `a+k = a + (g - (a % g))` will be the next multiple of `g` after `a`.\n    *   With this `k`, `a+k` is a multiple of `g`. Since `g` is a divisor of `d = b-a`, `b-a` is a multiple of `g`.\n    *   Therefore, `b+k = (a+k) + (b-a)` must also be a multiple of `g`.\n    *   So, this `k` ensures that both `a+k` and `b+k` are multiples of `g`. Consequently, `gcd(a+k, b+k)` will be at least `g`.\n\n5.  **Calculate `lcm` for the current `k`**:\n    *   Let `num1 = a+k` and `num2 = b+k`.\n    *   Calculate `current_lcm = (num1 * num2) // math.gcd(num1, num2)`.\n    *   Python's integers handle arbitrary precision, so `num1 * num2` will not overflow, even though `a, b` can be up to `10^9` and `k` can be up to `10^9`, making `num1, num2` up to `2 * 10^9` and their product up to `4 * 10^{18}`.\n\n6.  **Update minimum `lcm` and `best_k`**:\n    *   Initialize `min_lcm` to infinity and `best_k` to `0`.\n    *   If `current_lcm < min_lcm`, update `min_lcm = current_lcm` and `best_k = k`.\n    *   If `current_lcm == min_lcm`, update `best_k = min(best_k, k)` to satisfy the requirement of choosing the smallest `k` in case of ties.\n\n7.  **Print `best_k`**: After checking all divisors `g`, `best_k` will hold the smallest `k` that minimizes `lcm(a+k, b+k)`.\n\nThis approach ensures that `k=0` is also considered, as `g=gcd(a,b)` is always a divisor of `d=|b-a|`, and for `g=gcd(a,b)`, the calculated `k` will be `0`.\n\nExample walkthrough (a=6, b=10):\n1.  `a != b`.\n2.  `d = |10 - 6| = 4`.\n3.  Divisors of `4`: `{1, 2, 4}`.\n4.  Initialize `min_lcm = inf`, `best_k = 0`.\n    *   **g = 1**:\n        *   `k = (1 - (6 % 1)) % 1 = 0`.\n        *   `num1 = 6+0 = 6`, `num2 = 10+0 = 10`.\n        *   `current_lcm = (6 * 10) // gcd(6, 10) = 60 // 2 = 30`.\n        *   `min_lcm = 30`, `best_k = 0`.\n    *   **g = 2**:\n        *   `k = (2 - (6 % 2)) % 2 = 0`.\n        *   `num1 = 6+0 = 6`, `num2 = 10+0 = 10`.\n        *   `current_lcm = (6 * 10) // gcd(6, 10) = 60 // 2 = 30`.\n        *   `current_lcm == min_lcm`. `best_k = min(0, 0) = 0`.\n    *   **g = 4**:\n        *   `k = (4 - (6 % 4)) % 4 = (4 - 2) % 4 = 2`.\n        *   `num1 = 6+2 = 8`, `num2 = 10+2 = 12`.\n        *   `current_lcm = (8 * 12) // gcd(8, 12) = 96 // 4 = 24`.\n        *   `current_lcm < min_lcm` (24 < 30). `min_lcm = 24`, `best_k = 2`.\n5.  All divisors processed. Print `best_k = 2`.\n\n```python\nimport math\n\ndef solve():\n    a, b = map(int, input().split())\n\n    # Special case: if a and b are equal, lcm(a+k, b+k) = a+k.\n    # To minimize a+k, we choose the smallest non-negative k, which is 0.\n    if a == b:\n        print(0)\n        return\n\n    # d is the absolute difference between a and b.\n    # gcd(a+k, b+k) must divide (b+k) - (a+k) = b-a.\n    # So gcd(a+k, b+k) must be a divisor of d.\n    d = abs(b - a)\n\n    # Find all divisors of d.\n    divisors_of_d = set()\n    # Iterate up to sqrt(d) to find divisors efficiently.\n    for i in range(1, int(d**0.5) + 1):\n        if d % i == 0:\n            divisors_of_d.add(i)\n            divisors_of_d.add(d // i)\n\n    min_lcm = float('inf')\n    best_k = 0 # Initialize best_k to 0, which is the smallest possible k.\n               # This helps in tie-breaking if lcm(a,b) is the minimum,\n               # as k=0 will be considered by g=gcd(a,b).\n\n    # Iterate over each possible value for gcd(a+k, b+k), which must be a divisor 'g' of d.\n    for g in divisors_of_d:\n        # We need to find the smallest non-negative k such that a+k is a multiple of g.\n        # The formula (g - (a % g)) % g handles both cases correctly:\n        # If a % g == 0, k = 0.\n        # If a % g != 0, k = g - (a % g).\n        k = (g - (a % g)) % g\n        \n        num1 = a + k\n        num2 = b + k\n        \n        # Calculate lcm(num1, num2) using the formula: lcm(x, y) = (x * y) // gcd(x, y)\n        # Python's integers handle arbitrary size, so num1 * num2 won't overflow.\n        current_lcm = (num1 * num2) // math.gcd(num1, num2)\n        \n        # Check if this k yields a smaller LCM or an equal LCM with a smaller k.\n        if current_lcm < min_lcm:\n            min_lcm = current_lcm\n            best_k = k\n        elif current_lcm == min_lcm:\n            # If LCMs are equal, choose the smallest k.\n            best_k = min(best_k, k)\n            \n    print(best_k)\n\n# Call the solve function to run the program.\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef solve():\n    a, b = map(int, input().split())\n\n    # Special case: if a and b are equal, lcm(a+k, b+k) = a+k.\n    # To minimize a+k, we choose the smallest non-negative k, which is 0.\n    if a == b:\n        print(0)\n        return\n\n    # d is the absolute difference between a and b.\n    # gcd(a+k, b+k) must divide (b+k) - (a+k) = b-a.\n    # So gcd(a+k, b+k) must be a divisor of d.\n    d = abs(b - a)\n\n    # Find all divisors of d.\n    divisors_of_d = set()\n    # Iterate up to sqrt(d) to find divisors efficiently.\n    for i in range(1, int(d**0.5) + 1):\n        if d % i == 0:\n            divisors_of_d.add(i)\n            divisors_of_d.add(d // i)\n\n    min_lcm = float('inf')\n    best_k = 0 # Initialize best_k to 0, which is the smallest possible k.\n               # This helps in tie-breaking if lcm(a,b) is the minimum,\n               # as k=0 will be considered by g=gcd(a,b).\n\n    # Iterate over each possible value for gcd(a+k, b+k), which must be a divisor 'g' of d.\n    for g in divisors_of_d:\n        # We need to find the smallest non-negative k such that a+k is a multiple of g.\n        # The formula (g - (a % g)) % g handles both cases correctly:\n        # If a % g == 0, k = 0.\n        # If a % g != 0, k = g - (a % g).\n        k = (g - (a % g)) % g\n        \n        num1 = a + k\n        num2 = b + k\n        \n        # Calculate lcm(num1, num2) using the formula: lcm(x, y) = (x * y) // gcd(x, y)\n        # Python's integers handle arbitrary size, so num1 * num2 won't overflow.\n        current_lcm = (num1 * num2) // math.gcd(num1, num2)\n        \n        # Check if this k yields a smaller LCM or an equal LCM with a smaller k.\n        if current_lcm < min_lcm:\n            min_lcm = current_lcm\n            best_k = k\n        elif current_lcm == min_lcm:\n            # If LCMs are equal, choose the smallest k.\n            best_k = min(best_k, k)\n            \n    print(best_k)\n\n# Call the solve function to run the program.\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 422,
        "completion_token_count": 2407,
        "thoughts_token_count": 6943
    }
}