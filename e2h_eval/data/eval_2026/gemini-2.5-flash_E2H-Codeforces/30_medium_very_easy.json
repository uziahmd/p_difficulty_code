{
    "start": 1758294996.219895,
    "end": 1758295061.3623612,
    "start-formatted": "2025-09-20 00:16 KST",
    "end-formatted": "2025-09-20 00:17 KST",
    "gpu": 2,
    "pid": 30,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# TV Game\n\nThere is a new TV game on BerTV. In this game two players get a number A consisting of 2n digits. Before each turn players determine who will make the next move. Each player should make exactly n moves. On it's turn i-th player takes the leftmost digit of A and appends it to his or her number Si. After that this leftmost digit is erased from A. Initially the numbers of both players (S1 and S2) are «empty». Leading zeroes in numbers A, S1, S2 are allowed. In the end of the game the first player gets S1 dollars, and the second gets S2 dollars.One day Homer and Marge came to play the game. They managed to know the number A beforehand. They want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize. Help them.\n\n## Input\nThe first line contains integer n (1 ≤ n ≤ 18). The second line contains integer A consisting of exactly 2n digits. This number can have leading zeroes.\n\n## Output\nOutput the line of 2n characters «H» and «M» — the sequence of moves of Homer and Marge, which gives them maximum possible total prize. Each player must make exactly n moves. If there are several solutions, output any of them.\n\n## Example\n### Input\n['2\\n1234', '2\\n9911']\n\n### Output\n['HHMM', 'HMHM']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "**The Dynamic Duo: Conquering the TV Game**\n\nAlright, let's break this down. The \"TV Game\" problem screams for a dynamic programming approach, and I think I've cracked the code. The core is recognizing the significance of each digit's position in the final numbers. It's not just about picking the biggest numbers; it's about *where* you put them. This gives it a positional value, this is key.\n\nMy thought process began by understanding the rules and quickly shifted to maximizing the total prize, (S1 + S2). I looked at the digits in the number A one by one (from left to right) and noticed the first digit will contribute the most because of the higher powers of 10. The key insight is, where a digit lands in the number matters greatly and this can be formalized by thinking of where in Homer’s or Marge’s number it will sit and its contribution to the final prize.\n\nThis seemed complex until I noticed the total prize could be broken down digit by digit based on each player's respective move. Each digit can belong in one spot, but where? I thought of state, that state had to be the decision, and this can be formalized by DP. So I started thinking of how much each digit will be if Homer takes it, and how much if Marge takes it. Then it was a simple matter of choosing the option that maximized total.\n\nI decided that the right way to optimize is to build a `dp` table that holds the maximum sum of the digits from a current digit onwards. I needed the `dp` table to keep track of the index into `A`, and the number of digits Homer and Marge had already selected. And the choices made would determine the \"best path.\" I need to store the choice to make it \"backtrackable\". I kept this table size modest and feasible to calculate given the bounds given in the problem.\n\nGiven the bounds (n up to 18), I created a Dynamic Programming state:\n`dp[i][h_cnt] = maximum total prize from digits A[i..2n-1] with Homer taking h_cnt digits up to index i-1.` The number of Marge's taken digits can be implicitly calculated as `i - h_cnt`. The size of the `dp` and `choice` tables is calculated and determined to be practical.\n\nWe then proceed backwards from the last digit to build up our optimal answer. At each digit, we can chose whether to give it to homer or Marge (keeping in mind that they both have limited moves). At each decision, calculate, from this point, the value. If homer takes it, then add this number times his `power_of_10[current_h_count]`.\nIf Marge takes it then we do the same, this is how you decide which one should take it, we choose the one that maximizes our sum. I need to keep track of which option (Homer/Marge) I picked to make sure I reconstruct the best path later.\n\nThis \"backtracking\" is simple, using the `choice` table.\nReconstructing the chosen moves, is merely traversing my \"choices\" in the `choice` matrix. Then I just string the moves as a string to match the format of the output.\n\nI have a feeling this will give the optimal solution. I think I've fully grasped the problem's underlying principles, so I can create an elegant, efficient code for it. I am confident that this approach will deliver the correct result in a timely fashion. This looks correct to me, let's implement and see it fly.\n",
    "response": "```python\nimport sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n    A_str = sys.stdin.readline().strip()\n    \n    # Convert the input string A into a list of integers\n    A = [int(digit) for digit in A_str]\n    \n    total_digits = 2 * n\n    \n    # dp[i][h_taken] stores the maximum total prize from digits A[i:]\n    # given that Homer has already taken h_taken digits from A[0...i-1].\n    # m_taken (digits Marge has taken) is implicitly i - h_taken.\n    # Initialize with 0. For unreachable states, the value will remain 0 if they don't lead to a valid final state,\n    # or will be overwritten with a positive value.\n    # We use a 2D array of size (total_digits + 1) x (n + 1).\n    dp = [[0] * (n + 1) for _ in range(total_digits + 1)]\n    \n    # choice[i][h_taken] stores 'H' or 'M' for the optimal choice at this state.\n    # We use a 2D array of size total_digits x (n + 1).\n    choice = [[''] * (n + 1) for _ in range(total_digits)]\n    \n    # Precompute powers of 10 for efficiency.\n    # powers_of_10[k] will store 10^k.\n    # The maximum power needed is 10^(n-1).\n    powers_of_10 = [1] * n\n    for k in range(1, n):\n        powers_of_10[k] = powers_of_10[k-1] * 10\n\n    # Iterate backwards from the last digit (index total_digits - 1) down to the first (index 0).\n    for i in range(total_digits - 1, -1, -1):\n        current_digit_val = A[i]\n        \n        # Iterate through possible counts of digits Homer has taken so far.\n        # h_taken can range from max(0, i - n) to min(n, i).\n        # The loop range (0 to n) covers all possibilities, and invalid states are skipped inside.\n        for h_taken in range(n + 1):\n            m_taken = i - h_taken # Calculate m_taken based on current index and h_taken\n            \n            # Check if this state is valid: both players must have taken between 0 and n digits.\n            if not (0 <= h_taken <= n and 0 <= m_taken <= n):\n                continue\n            \n            option_H_val = -1 # Initialize with -1 to indicate an invalid option if player cannot move\n            if h_taken < n: # If Homer has not taken all his n digits, he can take this one.\n                # This digit will be Homer's (h_taken + 1)-th digit.\n                # Its positional value is 10^(n - 1 - h_taken).\n                val_H = current_digit_val * powers_of_10[n - 1 - h_taken]\n                option_H_val = val_H + dp[i+1][h_taken+1]\n            \n            option_M_val = -1 # Initialize with -1 to indicate an invalid option\n            if m_taken < n: # If Marge has not taken all her n digits, she can take this one.\n                # This digit will be Marge's (m_taken + 1)-th digit.\n                # Its positional value is 10^(n - 1 - m_taken).\n                val_M = current_digit_val * powers_of_10[n - 1 - m_taken]\n                option_M_val = val_M + dp[i+1][h_taken]\n            \n            # Determine the maximum prize and store the choice.\n            # If option_H_val is greater or equal, Homer makes the move.\n            # This handles ties by preferring Homer, as per problem statement \"output any of them\".\n            if option_H_val >= option_M_val:\n                dp[i][h_taken] = option_H_val\n                choice[i][h_taken] = 'H'\n            else:\n                dp[i][h_taken] = option_M_val\n                choice[i][h_taken] = 'M'\n\n    # Reconstruct the path of moves.\n    result_moves = []\n    current_h_taken = 0 # Start with Homer having taken 0 digits.\n    \n    # Iterate from the first digit (index 0) to the last.\n    for i in range(total_digits):\n        move = choice[i][current_h_taken]\n        result_moves.append(move)\n        \n        if move == 'H':\n            current_h_taken += 1 # If Homer takes the digit, increment his count for the next state.\n        # If Marge takes the digit ('M'), current_h_taken remains the same for the next state.\n        # m_taken would increase, but it's not explicitly tracked in current_h_taken.\n            \n    sys.stdout.write(\"\".join(result_moves) + \"\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n    A_str = sys.stdin.readline().strip()\n    \n    # Convert the input string A into a list of integers\n    A = [int(digit) for digit in A_str]\n    \n    total_digits = 2 * n\n    \n    # dp[i][h_taken] stores the maximum total prize from digits A[i:]\n    # given that Homer has already taken h_taken digits from A[0...i-1].\n    # m_taken (digits Marge has taken) is implicitly i - h_taken.\n    # Initialize with 0. For unreachable states, the value will remain 0 if they don't lead to a valid final state,\n    # or will be overwritten with a positive value.\n    # We use a 2D array of size (total_digits + 1) x (n + 1).\n    dp = [[0] * (n + 1) for _ in range(total_digits + 1)]\n    \n    # choice[i][h_taken] stores 'H' or 'M' for the optimal choice at this state.\n    # We use a 2D array of size total_digits x (n + 1).\n    choice = [[''] * (n + 1) for _ in range(total_digits)]\n    \n    # Precompute powers of 10 for efficiency.\n    # powers_of_10[k] will store 10^k.\n    # The maximum power needed is 10^(n-1).\n    powers_of_10 = [1] * n\n    for k in range(1, n):\n        powers_of_10[k] = powers_of_10[k-1] * 10\n\n    # Iterate backwards from the last digit (index total_digits - 1) down to the first (index 0).\n    for i in range(total_digits - 1, -1, -1):\n        current_digit_val = A[i]\n        \n        # Iterate through possible counts of digits Homer has taken so far.\n        # h_taken can range from max(0, i - n) to min(n, i).\n        # The loop range (0 to n) covers all possibilities, and invalid states are skipped inside.\n        for h_taken in range(n + 1):\n            m_taken = i - h_taken # Calculate m_taken based on current index and h_taken\n            \n            # Check if this state is valid: both players must have taken between 0 and n digits.\n            if not (0 <= h_taken <= n and 0 <= m_taken <= n):\n                continue\n            \n            option_H_val = -1 # Initialize with -1 to indicate an invalid option if player cannot move\n            if h_taken < n: # If Homer has not taken all his n digits, he can take this one.\n                # This digit will be Homer's (h_taken + 1)-th digit.\n                # Its positional value is 10^(n - 1 - h_taken).\n                val_H = current_digit_val * powers_of_10[n - 1 - h_taken]\n                option_H_val = val_H + dp[i+1][h_taken+1]\n            \n            option_M_val = -1 # Initialize with -1 to indicate an invalid option\n            if m_taken < n: # If Marge has not taken all her n digits, she can take this one.\n                # This digit will be Marge's (m_taken + 1)-th digit.\n                # Its positional value is 10^(n - 1 - m_taken).\n                val_M = current_digit_val * powers_of_10[n - 1 - m_taken]\n                option_M_val = val_M + dp[i+1][h_taken]\n            \n            # Determine the maximum prize and store the choice.\n            # If option_H_val is greater or equal, Homer makes the move.\n            # This handles ties by preferring Homer, as per problem statement \"output any of them\".\n            if option_H_val >= option_M_val:\n                dp[i][h_taken] = option_H_val\n                choice[i][h_taken] = 'H'\n            else:\n                dp[i][h_taken] = option_M_val\n                choice[i][h_taken] = 'M'\n\n    # Reconstruct the path of moves.\n    result_moves = []\n    current_h_taken = 0 # Start with Homer having taken 0 digits.\n    \n    # Iterate from the first digit (index 0) to the last.\n    for i in range(total_digits):\n        move = choice[i][current_h_taken]\n        result_moves.append(move)\n        \n        if move == 'H':\n            current_h_taken += 1 # If Homer takes the digit, increment his count for the next state.\n        # If Marge takes the digit ('M'), current_h_taken remains the same for the next state.\n        # m_taken would increase, but it's not explicitly tracked in current_h_taken.\n            \n    sys.stdout.write(\"\".join(result_moves) + \"\\n\")\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 432,
        "completion_token_count": 1243,
        "thoughts_token_count": 8192
    }
}