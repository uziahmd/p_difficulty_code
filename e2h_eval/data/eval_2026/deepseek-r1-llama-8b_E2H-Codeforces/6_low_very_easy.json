{
    "start": 1758103526.1379504,
    "end": 1758103680.7933342,
    "start-formatted": "2025-09-17 19:05 KST",
    "end-formatted": "2025-09-17 19:08 KST",
    "gpu": 2,
    "pid": 6,
    "use_openrouter": false,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let me read it carefully.\n\nThe problem is about Leha who wants to split his vacation into two parts using two vouchers. The goal is to find the minimal total cost of such two vouchers that don't overlap and their durations add up exactly to x.\n\nHmm, let's break down the problem.\n\nSo, each voucher has a start day li, end day ri, and cost. The duration is ri - li + 1. We need to choose two different vouchers i and j such that:\n\n1. Their durations sum to exactly x.\n2. They don't intersect. That means either the end of one is before the start of the other, or vice versa.\n3. The total cost is as small as possible.\n\nIf no such pair exists, we output -1.\n\nFirst, I need to think about how to approach this efficiently. Since n can be up to 2*10^5, any O(n^2) approach would be way too slow. So we need a smarter way.\n\nLet me think about the steps needed:\n\n1. For each voucher, calculate its duration. Then, for each voucher, we can look for another voucher whose duration is exactly x minus this duration.\n\n2. But how do we efficiently find such vouchers that don't overlap with the current one?\n\nWait, but even if we can find all possible pairs where durations add up to x, checking whether they are non-overlapping could take time. So perhaps we can pre-process the vouchers in some way.\n\nAnother idea: group vouchers by their duration. For each voucher, compute what duration it needs (x - current_duration), then look for vouchers with that duration that don't overlap with it.\n\nBut how do we check for non-overlapping efficiently?\n\nAlternatively, for each voucher i, we can find all vouchers j with duration d = x - duration_i, and then check if they are non-overlapping and keep track of the minimal cost.\n\nBut again, for each i, finding j's could be expensive if not done properly.\n\nWait, maybe we can sort the vouchers based on their end times. Then, for a given voucher i, all possible j's that end before i start can be found quickly using binary search. Similarly, those that start after i ends can be found quickly.\n\nYes, that makes sense.\n\nSo here's a plan:\n\n- Precompute the duration for each voucher.\n\n- Create a dictionary mapping each duration to a list of vouchers. Each entry will store the list of vouchers with that duration, sorted by their end time.\n\nThen, for each voucher i:\n\n- Compute required duration d = x - duration_i.\n\n- If d is not present in the dictionary, skip.\n\n- Else, for each voucher j in the list for d, check if i and j are non-overlapping.\n\nBut wait, even within the same duration group, this could be O(n) per voucher, which is still 2e10 operations—way too slow.\n\nSo we need a better way.\n\nAlternative approach: For each voucher i, we want to find the cheapest possible voucher j where:\n\n- duration_j = x - duration_i\n\n- j doesn't overlap with i.\n\nWe can structure this as follows:\n\nFor each voucher i:\n\n   required_d = x - duration_i\n\n   if required_d < 0: continue\n\n   Now, look for all vouchers j with duration required_d.\n\n   Among these j's, find those that are non-overlapping with i.\n\n   Among those, pick the one with the smallest cost.\n\n   Keep track of the global minimum.\n\nBut how do we efficiently find the minimal cost j for each i?\n\nWait, perhaps for each duration d, we can pre-sort the vouchers in some way that allows us to quickly find the minimal cost j that doesn't overlap with i.\n\nSo for each d, we have a list of vouchers with duration d. Let's sort this list by their end time. Also, for each such list, we can keep track of the minimal cost up to a certain end time.\n\nWait, perhaps for each d, we can process the vouchers in a way that allows for efficient querying.\n\nAnother thought: for each d, we can create two sorted lists: one sorted by end time, and another sorted by start time. Then, when considering a voucher i, we can perform binary searches to find all j's that end before i starts, or start after i ends.\n\nMoreover, for each d, we can have the vouchers sorted by end time, and for each position, keep the minimal cost so far. Similarly, sorted by start time, keep the minimal cost for each position.\n\nThis way, for a given i, when looking for j's with duration d that end before i starts, we can find all such j's in the sorted list by end time, and query the minimal cost up to the point where j's end <= i's start.\n\nSimilarly, for j's that start after i ends, we can query the minimal cost among j's that start",
    "response": "To solve this problem, we need to find two non-overlapping vouchers whose combined duration equals exactly `x` days and whose total cost is minimized. If no such pair exists, we should return `-1`.\n\n### Approach\n1. **Precompute Durations**: For each voucher, compute its duration as `ri - li + 1`.\n2. **Group Vouchers by Duration**: Create a dictionary where each key is a duration and the value is a list of vouchers with that duration. Each list will be sorted by the end day (`ri`) for efficient querying.\n3. **For Each Voucher, Find Complementary Duration**: For each voucher, determine the required complementary duration as `x - current_duration`. Check if this complementary duration exists in our dictionary.\n4. **Efficient Search for Non-overlapping Vouchers**: For each voucher, use binary search to find all possible non-overlapping vouchers with the complementary duration. Maintain a structure that allows us to quickly find the minimum cost among these non-overlapping vouchers.\n\n### Solution Code\n```python\nimport bisect\n\nn, x = map(int, input().split())\nvouchers = []\nfor _ in range(n):\n    l, r, c = map(int, input().split())\n    vouchers.append((l, r, c))\n\n# Precompute durations and group them\nduration_dict = {}\nfor l, r, c in vouchers:\n    d = r - l + 1\n    if d not in duration_dict:\n        duration_dict[d] = []\n    duration_dict[d].append((r, c))\n\n# Sort each duration group by end time (r)\nfor d in duration_dict:\n    duration_dict[d].sort(key=lambda x: x[0])\n\nmin_total_cost = float('inf')\n\nfor i in range(n):\n    li, ri, ci = vouchers[i]\n    current_d = ri - li + 1\n    target_d = x - current_d\n    if target_d < 0:\n        continue\n    if target_d not in duration_dict:\n        continue\n    # Now look for j's with duration target_d\n    # Case 1: j ends before i starts\n    # Find all j's with r <= li -1\n    j_list = duration_dict[target_d]\n    # Binary search for li-1 in the r values\n    # We can extract the r values into a separate list for bisect\n    rs = [j[0] for j in j_list]\n    pos = bisect.bisect_right(rs, li - 1)\n    if pos > 0:\n        # The minimal cost in the first pos elements\n        # To get this, precompute a prefix min array\n        # Alternatively, since the list is sorted, but for each position, it's not straightforward\n        # So perhaps we need another approach\n        # Alternative idea: for each j in j_list, if j.r <= li-1, then it's a candidate\n        # But checking each j is O(k), which could be too slow\n        # Instead, we can pre-sort j_list by r, and for each i, find the earliest j that satisfies r <= li-1\n        # Then, among those, find the one with minimal cost\n        # Since j_list is sorted, we can iterate from 0 to pos-1\n        # But even that could be O(n) per i, which is 2e5 * 2e5 = 4e10 operations, which is way too slow\n        # So this approach won't work. We need a better way\n        # Another idea: for each duration d, precompute the prefix minima of cost\n        # So for j_list, create a list of costs and compute prefix minima\n        # Then, for any position pos, the minimal cost up to pos is prefix_min[pos]\n        # This way, when we find pos, we can get the minimal cost in O(1)\n        # Similarly for the other case\n        # Let's implement this\n        # First, for each d in duration_dict, create two arrays: sorted by r and their prefix minima\n        # So during preprocessing, for each d, after sorting by r, compute prefix_min array\n        # Then, for any pos, the minimal cost is prefix_min[pos]\n\n# Preprocessing step\nprefix_min = {}\nfor d in duration_dict:\n    j_list = duration_dict[d]\n    sorted_rs = [j[0] for j in j_list]\n    costs = [j[1] for j in j_list]\n    # Compute prefix minima\n    pm = []\n    if not j_list:\n        continue\n    pm.append(costs[0])\n    for i in range(1, len(j_list)):\n        pm.append(min(pm[-1], costs[i]))\n    prefix_min[d] = (sorted_rs, pm)\n\n# Now, for each i, process both cases\nfor i in range(n):\n    li, ri, ci = vouchers[i]\n    current_d = ri - li + 1\n    target_d = x - current_d\n    if target_d < 0:\n        continue\n    if target_d not in prefix_min:\n        continue\n    # Get the sorted rs and prefix_min for target_d\n    sorted_rs, prefix_mins = prefix_min[target_d]\n    # Case 1: j ends before i starts (r_j <= li-1)\n    # Find the rightmost r_j <= li-1\n    pos = bisect.bisect_right(sorted_rs, li - 1)\n    if pos > 0:\n        min_cost_case1 = prefix_mins[pos-1]\n        total_cost = min_cost_case1 + ci\n        if total_cost < min_total_cost:\n            min_total_cost = total_cost\n    # Case 2: j starts after i ends (lj >= ri + 1)\n    # Find the leftmost lj >= ri + 1\n    pos = bisect.bisect_left(sorted_rs, ri + 1)\n    if pos < len(sorted_rs):\n        min_cost_case2 = prefix_mins[pos]\n        total_cost = min_cost_case2 + ci\n        if total_cost < min_total_cost:\n            min_total_cost = total_cost\n\nif min_total_cost != float('inf'):\n    print(min_total_cost)\nelse:\n    print(-1)\n```\n\n### Explanation\n1. **Precompute Durations**: Each voucher's duration is calculated and stored.\n2. **Group by Duration**: Vouchers are grouped by their duration for quick access.\n3. **Sort and Prefix Minima**: For each duration group, vouchers are sorted by their end day, and a prefix minima array is created to quickly find the minimum cost up to any point.\n4. **Binary Search for Non-overlapping Vouchers**: For each voucher, binary search is used to find potential non-overlapping vouchers efficiently. The prefix minima array helps in quickly finding the minimum cost for valid vouchers.\n5. **Calculate Minimum Cost**: The minimal total cost is tracked and updated for each valid pair of vouchers. If no valid pairs are found, `-1` is returned.",
    "ground_truth": "N/A",
    "extracted_answer": "import bisect\n\nn, x = map(int, input().split())\nvouchers = []\nfor _ in range(n):\n    l, r, c = map(int, input().split())\n    vouchers.append((l, r, c))\n\n# Precompute durations and group them\nduration_dict = {}\nfor l, r, c in vouchers:\n    d = r - l + 1\n    if d not in duration_dict:\n        duration_dict[d] = []\n    duration_dict[d].append((r, c))\n\n# Sort each duration group by end time (r)\nfor d in duration_dict:\n    duration_dict[d].sort(key=lambda x: x[0])\n\nmin_total_cost = float('inf')\n\nfor i in range(n):\n    li, ri, ci = vouchers[i]\n    current_d = ri - li + 1\n    target_d = x - current_d\n    if target_d < 0:\n        continue\n    if target_d not in duration_dict:\n        continue\n    # Now look for j's with duration target_d\n    # Case 1: j ends before i starts\n    # Find all j's with r <= li -1\n    j_list = duration_dict[target_d]\n    # Binary search for li-1 in the r values\n    # We can extract the r values into a separate list for bisect\n    rs = [j[0] for j in j_list]\n    pos = bisect.bisect_right(rs, li - 1)\n    if pos > 0:\n        # The minimal cost in the first pos elements\n        # To get this, precompute a prefix min array\n        # Alternatively, since the list is sorted, but for each position, it's not straightforward\n        # So perhaps we need another approach\n        # Alternative idea: for each j in j_list, if j.r <= li-1, then it's a candidate\n        # But checking each j is O(k), which could be too slow\n        # Instead, we can pre-sort j_list by r, and for each i, find the earliest j that satisfies r <= li-1\n        # Then, among those, find the one with minimal cost\n        # Since j_list is sorted, we can iterate from 0 to pos-1\n        # But even that could be O(n) per i, which is 2e5 * 2e5 = 4e10 operations, which is way too slow\n        # So this approach won't work. We need a better way\n        # Another idea: for each duration d, precompute the prefix minima of cost\n        # So for j_list, create a list of costs and compute prefix minima\n        # Then, for any position pos, the minimal cost up to pos is prefix_min[pos]\n        # This way, when we find pos, we can get the minimal cost in O(1)\n        # Similarly for the other case\n        # Let's implement this\n        # First, for each d in duration_dict, create two arrays: sorted by r and their prefix minima\n        # So during preprocessing, for each d, after sorting by r, compute prefix_min array\n        # Then, for any pos, the minimal cost is prefix_min[pos]\n\n# Preprocessing step\nprefix_min = {}\nfor d in duration_dict:\n    j_list = duration_dict[d]\n    sorted_rs = [j[0] for j in j_list]\n    costs = [j[1] for j in j_list]\n    # Compute prefix minima\n    pm = []\n    if not j_list:\n        continue\n    pm.append(costs[0])\n    for i in range(1, len(j_list)):\n        pm.append(min(pm[-1], costs[i]))\n    prefix_min[d] = (sorted_rs, pm)\n\n# Now, for each i, process both cases\nfor i in range(n):\n    li, ri, ci = vouchers[i]\n    current_d = ri - li + 1\n    target_d = x - current_d\n    if target_d < 0:\n        continue\n    if target_d not in prefix_min:\n        continue\n    # Get the sorted rs and prefix_min for target_d\n    sorted_rs, prefix_mins = prefix_min[target_d]\n    # Case 1: j ends before i starts (r_j <= li-1)\n    # Find the rightmost r_j <= li-1\n    pos = bisect.bisect_right(sorted_rs, li - 1)\n    if pos > 0:\n        min_cost_case1 = prefix_mins[pos-1]\n        total_cost = min_cost_case1 + ci\n        if total_cost < min_total_cost:\n            min_total_cost = total_cost\n    # Case 2: j starts after i ends (lj >= ri + 1)\n    # Find the leftmost lj >= ri + 1\n    pos = bisect.bisect_left(sorted_rs, ri + 1)\n    if pos < len(sorted_rs):\n        min_cost_case2 = prefix_mins[pos]\n        total_cost = min_cost_case2 + ci\n        if total_cost < min_total_cost:\n            min_total_cost = total_cost\n\nif min_total_cost != float('inf'):\n    print(min_total_cost)\nelse:\n    print(-1)",
    "score": 1,
    "metadata": {
        "prompt_token_count": 687,
        "completion_token_count": 1479,
        "thoughts_token_count": 1025
    }
}