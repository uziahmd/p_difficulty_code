{
    "start": 1758278117.5589767,
    "end": 1758278324.5039244,
    "start-formatted": "2025-09-19 19:35 KST",
    "end-formatted": "2025-09-19 19:38 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "Okay, so I have this problem to solve where I need to determine if it's possible to assign Rebel spaceships to bases in such a way that no two paths between them intersect. Hmm, the paths are straight lines from each spaceship to its assigned base.\n\nLet me read the problem again to make sure I understand. We have R rebel ships and B bases. We need a perfect matching—each ship to exactly one base and vice versa. But the crucial part is that any two paths (from ship to base) shouldn't intersect. So the arrangement must be such that when you draw all these straight lines, they don't cross each other.\n\nThe input gives coordinates for the ships and the bases. The output is Yes or No based on whether such an assignment exists.\n\nHmm, how do I approach this? Well, since both R and B are up to 10, which is manageable, maybe we can try all possible permutations of assigning ships to bases and check for each permutation whether the corresponding paths are non-intersecting.\n\nWait, but even though R and B are small, trying all possible permutations might be feasible. Because 10! is about 3.6 million, which is acceptable for Python.\n\nBut wait, the number of permutations would be the factorial of min(R, B). Because if R != B, then it's impossible as the assignment has to be a perfect matching, so R must equal B. Oh, right, the problem statement says \"R Rebel spaceships\" and \"B bases\", so if R != B, the answer is automatically 'No'. Wait, no: the first line says 1 ≤ R, B ≤ 10. So, for example, if R=3 and B=3, it's okay. But if R=2 and B=3, it's impossible because it's not a perfect matching—so the output would be 'No' because the numbers don't match.\n\nWait, the problem says \"R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base.\" So R must equal B. Otherwise, it's impossible. So the first thing I should check is whether R equals B. If not, output 'No'.\n\nSo the first step in the code is to read R and B, and if R != B, immediately return 'No'.\n\nAssuming R = B, then we need to find a perfect matching between the ships and the bases such that all the connecting lines are non-crossing.\n\nHow do we check for non-crossing lines?\n\nEach path is a straight line from a ship to a base. For all pairs of lines, none should intersect except at their endpoints. So, for any two ships i and j, and their respective bases b_i and b_j, the line from i to b_i should not cross any other line from j to b_j unless it's the same line.\n\nWait, but the problem says that the paths are from base to its assigned spaceship. Wait, the problem says: \"any two (straight) paths – from a base to its assigned spaceship\". So each path is from base to ship.\n\nWait, no: the problem says \"from a base to its assigned spaceship\". So each path starts at a base and goes to a ship. Or wait, is it from ship to base? Because in the note, it says \"connect Rebels and bases in order\"—like ship to base.\n\nWait, the problem statement says \"paths—from a base to its assigned spaceship\". So each path is a line from the base to the ship. So for each ship and base, the path is a straight line from base to ship.\n\nBut wait, no. Wait, the path is from the base to its assigned spaceship. So the line is from base point to ship point.\n\nSo, for example, if a base is at (0,0) and a ship is at (2,0), the path is the line from (0,0) to (2,0).\n\nWait, but the problem says that any two such paths should not intersect. So, for any two pairs of base and ship, the lines connecting them must not cross each other.\n\nSo, the problem reduces to finding a bijection between the ships and the bases such that all the lines connecting them (from base to ship) form a set of non-crossing lines.\n\nHmm, how can we model this?\n\nI remember that non-crossing line segments can be modeled using planar graphs, and perhaps using some kind of ordering or sorting to ensure that the lines are arranged properly.\n\nAlternatively, perhaps the problem can be thought of as arranging the lines in a way that they form a non-crossing matching.\n\nWait, another approach: think of the lines as edges in a graph, and we need to arrange them so that they don't cross. One way to model this is by ensuring that the lines are either nested or non-overlapping.\n\nWait, perhaps the way to check is to represent the lines as a set of line segments,",
    "response": "To solve this problem, we need to determine if it's possible to assign Rebel spaceships to bases such that each spaceship is assigned to exactly one base and vice versa, with the condition that no two paths (from a base to its assigned spaceship) intersect.\n\n### Approach\n1. **Check for Perfect Matching**: First, check if the number of Rebel spaceships (R) equals the number of bases (B). If they are not equal, output \"No\" immediately because a perfect matching is impossible.\n2. **Generate All Permutations**: Since R and B can be up to 10, generating all permutations of assigning ships to bases is feasible. For each permutation, check if the corresponding paths form non-crossing lines.\n3. **Check for Non-Crossing Paths**: For each permutation, convert the base points to ship points and check if any two paths intersect. If any permutation satisfies the non-crossing condition, output \"Yes\". If none do, output \"No\".\n\n### Solution Code\n```python\nimport sys\nfrom itertools import permutations\n\ndef readints():\n    return list(map(int, sys.stdin.readline().split()))\n\nR, B = map(int, sys.stdin.readline().split())\nships = []\nfor _ in range(R):\n    x, y = map(int, sys.stdin.readline().split())\n    ships.append((x, y))\nbases = []\nfor _ in range(B):\n    x, y = map(int, sys.stdin.readline().split())\n    bases.append((x, y))\n\nif R != B:\n    print(\"No\")\n    sys.exit()\n\n# Now R == B, so generate all possible permutations of assignments\nfor perm in permutations(range(R)):\n    assignment = list(perm)\n    # Create the list of line segments: from base[i] to ship[assignment[i]]\n    segments = []\n    for i in range(R):\n        base = bases[i]\n        ship = ships[assignment[i]]\n        segments.append((base, ship))\n    \n    # Check if any two segments intersect\n    ok = True\n    for i in range(len(segments)):\n        for j in range(i+1, len(segments)):\n            seg1 = segments[i]\n            seg2 = segments[j]\n            if segments_intersect(seg1, seg2):\n                ok = False\n                break\n        if not ok:\n            break\n    if ok:\n        print(\"Yes\")\n        sys.exit()\nprint(\"No\")\n\ndef segments_intersect(a, b):\n    a1, a2 = a\n    b1, b2 = b\n    def ccw(A, B, C):\n        return (B[0]-A[0])*(C[1]-A[1]) - (B[1]-A[1])*(C[0]-A[0])\n    if ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 and \\\n       ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0:\n        return True\n    return False\n```\n\n### Explanation\n1. **Reading Input**: The code reads the input values for the coordinates of Rebel spaceships and bases.\n2. **Check for Perfect Matching**: If the number of ships (R) does not match the number of bases (B), it immediately outputs \"No\".\n3. **Permutations and Assignments**: The code generates all possible permutations of assigning ships to bases.\n4. **Non-Crossing Check**: For each permutation, it converts the assignment into line segments and checks if any two segments intersect using the `segments_intersect` function.\n5. **Intersection Check Function**: This function uses the concept of the orientation of points to determine if two line segments intersect without actually drawing them.\n\nThis approach ensures that all possible assignments are checked efficiently, leveraging the small constraint size (up to 10) to ensure feasibility.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom itertools import permutations\n\ndef readints():\n    return list(map(int, sys.stdin.readline().split()))\n\nR, B = map(int, sys.stdin.readline().split())\nships = []\nfor _ in range(R):\n    x, y = map(int, sys.stdin.readline().split())\n    ships.append((x, y))\nbases = []\nfor _ in range(B):\n    x, y = map(int, sys.stdin.readline().split())\n    bases.append((x, y))\n\nif R != B:\n    print(\"No\")\n    sys.exit()\n\n# Now R == B, so generate all possible permutations of assignments\nfor perm in permutations(range(R)):\n    assignment = list(perm)\n    # Create the list of line segments: from base[i] to ship[assignment[i]]\n    segments = []\n    for i in range(R):\n        base = bases[i]\n        ship = ships[assignment[i]]\n        segments.append((base, ship))\n    \n    # Check if any two segments intersect\n    ok = True\n    for i in range(len(segments)):\n        for j in range(i+1, len(segments)):\n            seg1 = segments[i]\n            seg2 = segments[j]\n            if segments_intersect(seg1, seg2):\n                ok = False\n                break\n        if not ok:\n            break\n    if ok:\n        print(\"Yes\")\n        sys.exit()\nprint(\"No\")\n\ndef segments_intersect(a, b):\n    a1, a2 = a\n    b1, b2 = b\n    def ccw(A, B, C):\n        return (B[0]-A[0])*(C[1]-A[1]) - (B[1]-A[1])*(C[0]-A[0])\n    if ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 and \\\n       ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0:\n        return True\n    return False",
    "score": -1,
    "metadata": {
        "prompt_token_count": 462,
        "completion_token_count": 803,
        "thoughts_token_count": 1025
    }
}