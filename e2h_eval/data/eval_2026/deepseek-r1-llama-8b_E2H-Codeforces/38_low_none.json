{
    "start": 1758278584.778935,
    "end": 1758279279.126744,
    "start-formatted": "2025-09-19 19:43 KST",
    "end-formatted": "2025-09-19 19:54 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "Okay, so I have this problem to solve, and I'm a bit stuck but let's try to think through it step by step.\n\nThe problem is about directed graphs and certain properties. Let me read the problem again to make sure I understand it.\n\nWe need to find two things for a given p:\n1. The minimum number of nodes required to create a p-reachable directed graph.\n2. Among all such graphs with this minimum number of nodes, find the maximum number of unidirectional pairs possible.\n\nHmm. So, what's a p-reachable directed graph? Oh right, it's one that has exactly p ordered pairs (u, v) where u < v, and u and v are reachable from each other. So these are the edges that form a bidirectional connection between two nodes where u is less than v. Each such edge contributes 1 to p.\n\nWait, but wait: the condition says u < v. So for each pair (u, v) with u < v, if they are mutually reachable, then it's counted towards p. So the total p is the count of such unordered pairs in the graph.\n\nSo, the graph must have exactly p such edges. But how does that translate into the structure of the graph?\n\nThe first part of the problem is to find the minimal number of nodes needed to achieve exactly p such pairs. Then, among all such graphs, find the maximum possible number of unidirectional pairs.\n\nWhat's a unidirectional pair? It's an ordered pair (u, v) where u != v, there's a path from u to v, but no path from v to u. So in other words, it's a directed edge that's present in one direction but not the other, and for which there exists a path in that direction.\n\nWait, but the definition says \"there exists a path from u to v\" and \"there are no paths from v to u\". So it's not just the direct edge; it's any path. So even if there's no direct edge, as long as u can reach v via some path and v can't reach u, it counts.\n\nBut how do we model this?\n\nLet me think about the structure of the graph. For the minimal number of nodes, perhaps the graph is a DAG, but maybe it's better to have strongly connected components arranged in a particular way.\n\nWait, but for the p-reachable condition, the graph must have exactly p such unordered pairs where u < v and they are reachable from each other in both directions. Wait no, because the definition is that u and v are reachable from each other, so that's a mutual reachability, which implies that the pair (u, v) is counted once in p. So for each such pair, p increases by 1.\n\nSo the graph must have exactly p such pairs.\n\nNow, to minimize the number of nodes, we need to arrange the graph such that each added node contributes as much as possible to the p count.\n\nWait, but perhaps the minimal number of nodes is achieved when the graph is a collection of certain structures. Let's think about how p is built.\n\nEach strongly connected component (SCC) in the graph contributes a certain number of such pairs. For example, if an SCC has k nodes, the number of unordered pairs (u, v) where u < v and they are mutually reachable is C(k, 2) = k*(k-1)/2. Because all nodes are reachable from each other within the component.\n\nBut wait, no. Because the condition is that u < v, so for a component with k nodes, the number of such pairs is indeed the number of unordered pairs where u < v, which is the same as the number of edges in an undirected complete graph on k nodes, divided by 2 if considering each edge once. Wait, no, for a complete undirected graph, the number of ordered pairs (u, v) with u < v is exactly C(k, 2).\n\nSo each SCC contributes C(k, 2) to p. Now, the problem is that the overall p is the sum of C(k_i, 2) for each SCC in the graph.\n\nSo, to get exactly p such pairs, we can model the problem as finding a set of integers k_1, k_2, ..., k_m such that the sum of C(k_i, 2) equals p. And we need to find the minimal sum of k_i's such that their squares summed and subtracted gives 2p.\n\nBecause C(k,2) = k*(k-1)/2. Summing over all i, the sum is p. So the equation is sum_{i} [k_i * (k_i -1)] / 2 = p.\n\nWe can multiply both sides by 2 to get sum(k_i^2 -k_i) = 2p.\n\nWhich can be rewritten as sum(k_i^2) - sum(k_i) = 2p.\n\n",
    "response": "To solve this problem, we need to determine the minimum number of nodes required to create a p-reachable directed graph and, among all such graphs with the minimum number of nodes, find the maximum number of unidirectional pairs.\n\n### Approach\n\n1. **Understanding p-reachable Graph**: A p-reachable directed graph has exactly `p` ordered pairs `(u, v)` where `u < v` and both nodes are mutually reachable. This means each such pair contributes 1 to `p`.\n\n2. **Strongly Connected Components (SCCs)**: Each SCC in the graph contributes a number of such pairs equal to the combination formula `C(k, 2)`, where `k` is the number of nodes in the SCC. The total `p` is the sum of these contributions from all SCCs.\n\n3. **Minimizing Nodes**: To minimize the number of nodes, we need to decompose `p` into sums of `C(k_i, 2)` values using as few terms as possible. This is achieved by finding the largest possible `k_i` values that contribute to `p`.\n\n4. **Maximizing Unidirectional Pairs**: Among all minimal node configurations, the maximum number of unidirectional pairs is found by structuring the graph such that each edge in an SCC is bidirectional, thus minimizing unidirectional pairs.\n\n### Solution Code\n\n```python\nimport math\n\ndef minimal_nodes(p):\n    if p == 0:\n        return (0, 0)\n    # We need to express 2p as sum of k_i^2 - k_i, which is sum(k_i(k_i-1))\n    target = 2 * p\n    max_k = int(math.sqrt(target)) + 2  # Just to be safe\n    min_nodes = 0\n    best_k = []\n    \n    for k in range(max_k, 0, -1):\n        rem = target - k*(k-1)\n        if rem >= 0:\n            count = 1\n            if rem > 0:\n                # See if we can split rem into multiple k's\n                # Find the largest possible m where m(m-1) <= rem\n                m = int(math.sqrt(rem)) + 1\n                while m >=1:\n                    m_sq = m*(m-1)\n                    if m_sq > rem:\n                        break\n                    count +=1\n                    rem -= m_sq\n                    m -=1\n                if rem !=0:\n                    # No solution with this k\n                    continue\n                else:\n                    total = k + sum([m for m in range(1, m+1)])\n                    if total < min_nodes or (total == min_nodes and len(best_k) < len([k] + list(range(1, m+1)))):\n                        min_nodes = total\n                        best_k = [k] + list(range(1, m+1))\n            else:\n                count =1\n                total =k\n                if total < min_nodes:\n                    min_nodes = total\n                    best_k = [k]\n    return (min_nodes, max_uni)\n\ndef max_uni(n):\n    # In the minimal configuration, the graph is a single SCC.\n    # So no unidirectional pairs.\n    return 0\n\n# Read input\np = int(input().strip())\nif p ==0:\n    print(\"0 0\")\nelse:\n    min_nodes, _ = minimal_nodes(p)\n    print(f\"{min_nodes} 0\")\n\n# Wait, but the sample shows for p=3, output is 3 0, and for p=4 it's 5 6. Hmm, something's wrong.\n\nWait, I think I made a mistake in the initial approach. The problem requires that the graph is p-reachable, which is defined as having exactly p unordered pairs (u, v) where u < v and they are mutually reachable. But earlier I thought of it as C(k_i, 2), but perhaps that's not the case because the condition is u < v, which is one way.\n\nWait, no. The definition says that the graph is p-reachable if it contains exactly p ordered pairs (u, v) such that u < v and u and v are reachable from each other. So for each such pair, it's counted once in p.\n\nBut wait, since u < v, each such pair is unique. So for an SCC with k nodes, the number of such pairs is C(k, 2), because for each pair (u, v) where u < v, they are reachable from each other.\n\nSo the initial approach stands.\n\nWait, but let's look at the sample input:\n\nFor p=3, the minimal nodes is 3. How does that happen?\n\nIf we have 3 nodes forming a single SCC, then the number of such pairs is C(3,2)=3, which matches p=3.\n\nIn this case, there are no unidirectional pairs because all edges are bidirectional. So the maximum unidirectional pairs is 0.\n\nFor p=4, what's the minimal nodes? Let's see.\n\nWe need sum(C(k_i, 2)) =4.\n\nPossible options:\n- One component with k=4: C(4,2)=6>4 → no.\n- Two components: 3 and 2 → C(3,2)+C(2,2) =3+1=4. So nodes needed are 3+2=5.\n\nIs there a better option? Maybe 2 components of 3 and 2? Or 4 and 1? No, because C(4,2)=6>4.\n\nSo minimal nodes is 5.\n\nNow, how to maximize the number of unidirectional pairs in such a graph.\n\nWait, but in a DAG, each edge is unidirectional. So if the graph is structured as a DAG, each edge is unidirectional, but within each SCC, edges are bidirectional.\n\nWait, but in our case, the minimal node configuration is achieved by having two SCCs: one of size 3 and another of size 2. So within each SCC, all edges are bidirectional, contributing nothing to unidirectional pairs. Between the SCCs, all edges are directed from the smaller component to the larger one, making them unidirectional.\n\nSo the number of unidirectional pairs would be the product of the sizes of the two components, because for each node in the smaller component, there are edges to each node in the larger component.\n\nSo 3 * 2 =6 unidirectional pairs. Hence, the sample output for p=4 is 5 6.\n\nSo the initial approach needs to be adjusted to consider the structure that allows for maximum unidirectional pairs.\n\nThus, the steps are:\n\n1. For the given p, find the minimal number of nodes by decomposing p into sums of C(k_i, 2).\n\n2. Then, construct a graph where between SCCs, all edges are directed from the smaller component to the larger one, maximizing the number of unidirectional pairs.\n\nSo, the maximum number of unidirectional pairs is the sum over all pairs of components (A, B) where |A| < |B| of |A| * |B|.\n\nThis is because for each node in the smaller component, there are edges to all nodes in the larger component.\n\nSo, the algorithm should:\n\n- Decompose p into a set of C(k_i, 2) terms, finding the minimal sum of k_i.\n\n- Sort the k_i in descending order.\n\n- Compute the number of unidirectional pairs as the sum for i < j of k_i * k_j.\n\nThus, the code needs to:\n\n- Find the decomposition of 2p into sum(k_i^2 -k_i) = 2p.\n\n- Once the decomposition is found, sort the k_i in descending order.\n\n- Calculate the maximum unidirectional pairs as the sum of products of all pairs where i < j.\n\nThis changes the approach.\n\nSo, the revised plan is:\n\n1. Express 2p as sum(k_i^2 - k_i) for some integers k_i.\n\n2. Find the decomposition with the minimal sum of k_i.\n\n3. Once the k_i are determined, sort them in non-increasing order.\n\n4. The maximum unidirectional pairs is the sum for i < j of k_i * k_j.\n\nSo, the function to find the minimal nodes will need to correctly find the decomposition.\n\nLet me think about how to implement this.\n\nThe minimal number of nodes is achieved when the sum of k_i is minimized, given that sum(k_i*(k_i-1)/2) = p.\n\nThis can be approached by trying to find the largest possible k_i first.\n\nFor example, for p=3:\n\nsum(k_i*(k_i-1)/2) =3 → sum(k_i^2 -k_i) =6.\n\nLooking for the largest k where k*(k-1) <=6:\n\nk=3: 3*2=6 → yes. So k=3, sum is 3.\n\nFor p=4:\n\nsum(k_i*(k_i-1)/2) =4 → sum(k_i^2 -k_i) =8.\n\nLooking for the largest k where k*(k-1) <=8:\n\nk=3: 3*2=6, remaining 8-6=2. Now, find k where k*(k-1) =2: k=2 (2*1=2). So sum is 3+2=5.\n\nAnother option could be k=4: 4*3=12>8 → no.\n\nAnother option: 2 and 3, same as above.\n\nThus, the minimal nodes is 5.\n\nSo the function minimal_nodes should find the decomposition correctly.\n\nOnce the decomposition is found, the next step is to compute the maximum unidirectional pairs.\n\nLet me think about the code.\n\nFirst, handle the case when p=0: output 0 0.\n\nElse, compute 2p.\n\nThen, find the decomposition of 2p into sum(k_i^2 -k_i).\n\nThis can be done by trying the largest possible k first.\n\nOnce the decomposition is found, sort the k_i in descending order.\n\nCompute the sum of k_i * k_j for all i < j.\n\nSo, the code outline is:\n\ndef minimal_nodes_and_unidirectional(p):\n    if p ==0:\n        return (0,0)\n    target = 2*p\n    k_list = []\n    current = target\n    for k in range(int(math.sqrt(target)), 0, -1):\n        rem = current - (k*(k-1))\n        if rem >=0:\n            k_list.append(k)\n            current = rem\n            if current ==0:\n                break\n        # Try splitting rem into smaller k's\n        # Not sure how to do this yet; perhaps it's better to try all possible decompositions.\n        # Alternatively, use dynamic programming or backtracking, but that might be too slow for large p.\n        # For the purposes of this problem, perhaps the initial approach suffices.\n    # Now, process the k_list\n    # However, the above approach may not find all possible decompositions, leading to incorrect results for certain p.\n    # So, perhaps a better approach is needed.\n    # Alternative approach:\n    # We can model this as finding a sequence of k_i such that sum(k_i^2 -k_i) = target, and sum(k_i) is minimized.\n    # This is similar to integer partitioning with constraints.\n    # Since this is a programming competition problem, perhaps a greedy approach is sufficient.\n    # But I'm not sure; perhaps the initial approach works for small p, but fails for larger ones.\n\nWait, perhaps the initial approach isn't sufficient. Let's think of another way.\n\nEach term in the decomposition is (k_i^2 -k_i) = k_i*(k_i -1). We need to sum these to get 2p.\n\nThe goal is to find a set of integers {k_i} such that their squares minus themselves sum to 2p, and the sum of k_i is minimized.\n\nThis is equivalent to finding the minimal number of nodes by choosing the largest possible k_i first.\n\nAn efficient way to find this is to start from the largest possible k and subtract until the remainder is zero.\n\nLet me try to code this.\n\nFunction minimal_nodes(p):\n\nif p ==0:\n    return 0, 0\ntarget = 2*p\nnodes = []\ncurrent = target\nfor k in range(int(math.sqrt(current)), 0, -1):\n    rem = current - (k*(k-1))\n    if rem <0:\n        continue\n    nodes.append(k)\n    current = rem\n    if current ==0:\n        break\n# After this loop, current may still be positive, so we need to find more terms.\n# Now, for the remaining current, try smaller k's.\nwhile current >0:\n    k = int(math.sqrt(current))\n    while k >=1:\n        rem = current - (k*(k-1))\n        if rem >=0:\n            nodes.append(k)\n            current = rem\n            break\n        else:\n            k -=1\n    if current ==0:\n        break\n\nBut this may not always work, as sometimes you need to add smaller k's.\n\nWait, perhaps this isn't the right approach. Another idea is to use the fact that the minimal number of nodes is achieved by using the largest possible k_i.\n\nBut I'm not entirely sure.\n\nAlternatively, perhaps the minimal number of nodes is the smallest n such that the sum of C(m, 2) for m=1 to n is >= p.\n\nWait, but that's not necessarily the case because the decomposition can be into different components.\n\nAlternatively, perhaps the minimal number of nodes is the minimal n where the maximal possible sum of C(k_i, 2) is >=p.\n\nBut this is getting complicated.\n\nPerhaps for the purposes of this problem, considering the sample and trying to find a pattern.\n\nSample Input 1: p=3.\n\nSolution: 3 nodes, one component. Unidirectional pairs:0.\n\nSample Input 2: p=4.\n\nSolution:5 nodes, two components of 3 and 2. Unidirectional pairs:3*2=6.\n\nAnother test case: p=0 → 0 nodes, 0 unidirectional.\n\np=1: target=2.\n\nLooking for k where k*(k-1) =2 → k=2 (since 2*1=2). So nodes=2. Unidirectional pairs:0.\n\np=6: target=12.\n\nLooking for k where k*(k-1)=12 → k=4 (4*3=12). So nodes=4. Unidirectional pairs:0.\n\np=7: target=14.\n\nCheck for k=4: 4*3=12 → rem=2. So k=2 (2*1=2). Total nodes=4+2=6.\n\nUnidirectional pairs:4*2=8.\n\nSo the output would be 6 8.\n\nHmm, so for p=7, the minimal nodes is 6, and maximum unidirectional is 8.\n\nSo, the code should correctly handle this.\n\nThus, the steps are:\n\n1. For the given p, compute target=2*p.\n\n2. Find a decomposition of target into a sum of (k_i*(k_i-1)).\n\n3. The minimal number of nodes is the sum of k_i.\n\n4. Once the k_i are found, sort them in descending order.\n\n5. Compute the sum of k_i * k_j for all i < j. This gives the maximum number of unidirectional pairs.\n\nSo, the code should:\n\n- Find the decomposition of 2p into a sum of (k_i^2 -k_i), using as few terms as possible, each term being the largest possible.\n\nImplementing this decomposition correctly is crucial.\n\nBut how?\n\nOne approach is to use a greedy algorithm: at each step, choose the largest possible k_i such that k_i*(k_i-1) <= remaining target. Subtract this value from the target and proceed.\n\nThis ensures that each step uses the largest possible k_i, which helps in minimizing the total number of nodes.\n\nLet's try this approach:\n\nFor example, p=4 → target=8.\n\nLargest k where k*(k-1) <=8 is k=3 (3*2=6). Remaining target=2. Next, k=2 (2*1=2). Remaining target=0. So nodes=3+2=5.\n\nWhich is correct.\n\nFor p=7 → target=14.\n\nLargest k is 4 (4*3=12). Remaining=2. Next k=2. Total nodes=4+2=6.\n\nWhich is correct.\n\nAnother example: p=10 → target=20.\n\nLargest k is 5 (5*4=20). So nodes=5.\n\nNo unidirectional pairs, as it's a single component.\n\nAnother example: p=11 → target=22.\n\nLargest k is 5 (5*4=20). Remaining=2. Next k=2. Nodes=5+2=7.\n\nUnidirectional pairs:5*2=10.\n\nThus, the code should implement this.\n\nSo, the code will:\n\n- Handle p=0 separately.\n\n- For other p, compute target=2*p.\n\n- Use a loop to find the largest possible k_i at each step.\n\n- Once the decomposition is complete, sum the k_i to get the minimal nodes.\n\n- Then, compute the unidirectional pairs by summing all k_i * k_j for i < j.\n\nThus, the code can be written as follows.\n\nBut wait, the code may fail for certain cases. For example, if after choosing the largest possible k_i, the remaining target cannot be decomposed further. So the code must ensure that the entire target is covered.\n\nLet's test for p=5 → target=10.\n\nLargest k is 4 (4*3=12>10 → no. So k=3 (3*2=6). Remaining=4.\n\nNext, k=2 (2*1=2). Remaining=2.\n\nNext, k=2 again (2*1=2). Remaining=0.\n\nTotal nodes=3+2+2=7.\n\nBut wait, is there a better decomposition?\n\nYes: 3 + 3 → 3*(3-1)=6, 3*(3-1)=6. Sum is 12>10. No.\n\nAnother option: 4 and 1 → 4*3=12>10. No.\n\nAlternative decomposition: 3 and 2 and 2 (sum 6+2+2=10). So nodes=3+2+2=7.\n\nAlternatively, is there a way to get fewer nodes? Like 4 and 3: 4*3=12>10. No.\n\nSo the code's approach is correct.\n\nThus, the code can proceed with this logic.\n\nNow, implementing this in Python.\n\nThe code will read p, compute target=2*p, and then greedily select the largest possible k_i.\n\nOnce the k_i are selected, sort them in descending order and compute the sum of products for i<j.\n\nFinally, output the minimal nodes and the maximum unidirectional pairs.\n\nThus, the code is as follows.\n\nBut wait, in the sample input, for p=3, the minimal nodes is 3, and for p=4, it's 5. So the code should output 3 0 and 5 6, respectively.\n\nTesting the code for p=4:\n\ntarget=8.\n\nk starts at sqrt(8)≈2.828 → floor is 2. Check k=3: 3*2=6 ≤8 → yes. Subtract 6 → rem=2.\n\nNext, k=2: 2*1=2 ≤2 → subtract, rem=0. So k_list=[3,2]. Nodes=5.\n\nUnidirectional pairs:3*2=6.\n\nWhich matches the sample.\n\nThus, the code should correctly handle the sample.\n\nAnother test case: p=0 → output 0 0.\n\nAnother test case: p=1 → target=2.\n\nk=2: 2*1=2. So nodes=2. Unidirectional pairs:0.\n\nAnother test case: p=6 → target=12.\n\nk=4: 4*3=12. So nodes=4. Unidirectional pairs:0.\n\nAnother test case: p=7 → target=14.\n\nk=4:4*3=12. Rem=2. k=2:2*1=2. Nodes=4+2=6. Unidirectional pairs:4*2=8.\n\nThus, the code seems to handle all cases correctly.\n\nNow, writing the code.\n\nBut wait, the function to compute the maximum unidirectional pairs must consider all possible pairs of components.\n\nThus, the code will:\n\n- After collecting all k_i, sort them in descending order.\n\n- Compute the sum of k_i * k_j for all i < j.\n\nThis can be done using a prefix sum approach.\n\nFor example, if the sorted list is [a, b, c], the sum is a*b + a*c + b*c.\n\nWhich is equal to (a + b + c)^2 - (a^2 + b^2 + c^2) ) / 2.\n\nBut since we're dealing with integers, perhaps it's easier to just loop through all pairs.\n\nBut for efficiency, especially for large p, it's better to compute it with a formula.\n\nBut given the constraints, perhaps a loop is acceptable.\n\nThus, the code:\n\nRead p.\n\nIf p is 0, print 0 0.\n\nElse:\n\nCompute target = 2*p.\n\nInitialize k_list = empty list.\n\ncurrent = target.\n\nLoop k from floor(sqrt(current)) down to 1:\n\n   if k*(k-1) <= current:\n\n      add k to k_list.\n\n      current -= k*(k-1).\n\n      if current ==0: break.\n\nIf current is not zero, then we need to find smaller k's.\n\nWait, but according to the earlier logic, the largest k will always cover as much as possible, leaving a remainder that can be covered by smaller k's.\n\nBut perhaps the initial loop misses some cases.\n\nThus, in the code, after the initial loop, if current is not zero, we need to find smaller k's.\n\nBut in practice, the initial loop may not find a complete decomposition, so perhaps the code needs to handle it differently.\n\nBut perhaps the initial loop is sufficient.\n\nAlternatively, perhaps the initial loop can be modified to try all possible k's down to 1.\n\nBut that may be time-consuming for large p.\n\nBut given that p can be up to 2e5, the code must be efficient.\n\nThus, the code proceeds as follows:\n\nRead p.\n\nIf p==0: print 0 0.\n\nElse:\n\ntarget = 2*p.\n\nk_list = []\n\ncurrent = target.\n\nfor k in range(int(math.isqrt(current)), 0, -1):\n\n   if k*(k-1) <= current:\n\n       k_list.append(k)\n\n       current -= k*(k-1)\n\n       if current ==0:\n\n           break\n\nif current !=0:\n\n   # This indicates that the decomposition is not possible with the initial approach.\n\n   # Thus, perhaps the code needs to backtrack.\n\n   # But this is a problem because for some p, the decomposition may not be possible with the initial approach.\n\n   # For example, p=2: target=4.\n\n   # k=2: 2*1=2. current=4-2=2.\n\n   # Then, k=2 again: 2*1=2. current=0.\n\n   # So nodes=2+2=4.\n\n   # But perhaps there's a better decomposition.\n\n   # Alternatively, perhaps the initial approach is sufficient.\n\nBut wait, for p=2, target=4.\n\nThe decomposition would be 2 and 2.\n\nThus, the code would output nodes=4, unidirectional pairs=2*2=4.\n\nBut wait, the minimal nodes might be 3.\n\nBecause 3 nodes in a single component: C(3,2)=3, which is more than p=2.\n\nSo that's not possible. So, perhaps the initial approach is correct.\n\nThus, perhaps the code is correct.\n\nBut I'm not entirely sure, but given time constraints, I'll proceed with this approach.\n\nThus, the final code is as follows.\n",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef minimal_nodes(p):\n    if p == 0:\n        return (0, 0)\n    # We need to express 2p as sum of k_i^2 - k_i, which is sum(k_i(k_i-1))\n    target = 2 * p\n    max_k = int(math.sqrt(target)) + 2  # Just to be safe\n    min_nodes = 0\n    best_k = []\n    \n    for k in range(max_k, 0, -1):\n        rem = target - k*(k-1)\n        if rem >= 0:\n            count = 1\n            if rem > 0:\n                # See if we can split rem into multiple k's\n                # Find the largest possible m where m(m-1) <= rem\n                m = int(math.sqrt(rem)) + 1\n                while m >=1:\n                    m_sq = m*(m-1)\n                    if m_sq > rem:\n                        break\n                    count +=1\n                    rem -= m_sq\n                    m -=1\n                if rem !=0:\n                    # No solution with this k\n                    continue\n                else:\n                    total = k + sum([m for m in range(1, m+1)])\n                    if total < min_nodes or (total == min_nodes and len(best_k) < len([k] + list(range(1, m+1)))):\n                        min_nodes = total\n                        best_k = [k] + list(range(1, m+1))\n            else:\n                count =1\n                total =k\n                if total < min_nodes:\n                    min_nodes = total\n                    best_k = [k]\n    return (min_nodes, max_uni)\n\ndef max_uni(n):\n    # In the minimal configuration, the graph is a single SCC.\n    # So no unidirectional pairs.\n    return 0\n\n# Read input\np = int(input().strip())\nif p ==0:\n    print(\"0 0\")\nelse:\n    min_nodes, _ = minimal_nodes(p)\n    print(f\"{min_nodes} 0\")\n\n# Wait, but the sample shows for p=3, output is 3 0, and for p=4 it's 5 6. Hmm, something's wrong.\n\nWait, I think I made a mistake in the initial approach. The problem requires that the graph is p-reachable, which is defined as having exactly p unordered pairs (u, v) where u < v and they are mutually reachable. But earlier I thought of it as C(k_i, 2), but perhaps that's not the case because the condition is u < v, which is one way.\n\nWait, no. The definition says that the graph is p-reachable if it contains exactly p ordered pairs (u, v) such that u < v and u and v are reachable from each other. So for each such pair, it's counted once in p.\n\nBut wait, since u < v, each such pair is unique. So for an SCC with k nodes, the number of such pairs is C(k, 2), because for each pair (u, v) where u < v, they are reachable from each other.\n\nSo the initial approach stands.\n\nWait, but let's look at the sample input:\n\nFor p=3, the minimal nodes is 3. How does that happen?\n\nIf we have 3 nodes forming a single SCC, then the number of such pairs is C(3,2)=3, which matches p=3.\n\nIn this case, there are no unidirectional pairs because all edges are bidirectional. So the maximum unidirectional pairs is 0.\n\nFor p=4, what's the minimal nodes? Let's see.\n\nWe need sum(C(k_i, 2)) =4.\n\nPossible options:\n- One component with k=4: C(4,2)=6>4 → no.\n- Two components: 3 and 2 → C(3,2)+C(2,2) =3+1=4. So nodes needed are 3+2=5.\n\nIs there a better option? Maybe 2 components of 3 and 2? Or 4 and 1? No, because C(4,2)=6>4.\n\nSo minimal nodes is 5.\n\nNow, how to maximize the number of unidirectional pairs in such a graph.\n\nWait, but in a DAG, each edge is unidirectional. So if the graph is structured as a DAG, each edge is unidirectional, but within each SCC, edges are bidirectional.\n\nWait, but in our case, the minimal node configuration is achieved by having two SCCs: one of size 3 and another of size 2. So within each SCC, all edges are bidirectional, contributing nothing to unidirectional pairs. Between the SCCs, all edges are directed from the smaller component to the larger one, making them unidirectional.\n\nSo the number of unidirectional pairs would be the product of the sizes of the two components, because for each node in the smaller component, there are edges to each node in the larger component.\n\nSo 3 * 2 =6 unidirectional pairs. Hence, the sample output for p=4 is 5 6.\n\nSo the initial approach needs to be adjusted to consider the structure that allows for maximum unidirectional pairs.\n\nThus, the steps are:\n\n1. For the given p, find the minimal number of nodes by decomposing p into sums of C(k_i, 2).\n\n2. Then, construct a graph where between SCCs, all edges are directed from the smaller component to the larger one, maximizing the number of unidirectional pairs.\n\nSo, the maximum number of unidirectional pairs is the sum over all pairs of components (A, B) where |A| < |B| of |A| * |B|.\n\nThis is because for each node in the smaller component, there are edges to all nodes in the larger component.\n\nSo, the algorithm should:\n\n- Decompose p into a set of C(k_i, 2) terms, finding the minimal sum of k_i.\n\n- Sort the k_i in descending order.\n\n- Compute the number of unidirectional pairs as the sum for i < j of k_i * k_j.\n\nThus, the code needs to:\n\n- Find the decomposition of 2p into sum(k_i^2 -k_i) = 2p.\n\n- Once the decomposition is found, sort the k_i in descending order.\n\n- Calculate the maximum unidirectional pairs as the sum of products of all pairs where i < j.\n\nThis changes the approach.\n\nSo, the revised plan is:\n\n1. Express 2p as sum(k_i^2 - k_i) for some integers k_i.\n\n2. Find the decomposition with the minimal sum of k_i.\n\n3. Once the k_i are determined, sort them in non-increasing order.\n\n4. The maximum unidirectional pairs is the sum for i < j of k_i * k_j.\n\nSo, the function to find the minimal nodes will need to correctly find the decomposition.\n\nLet me think about how to implement this.\n\nThe minimal number of nodes is achieved when the sum of k_i is minimized, given that sum(k_i*(k_i-1)/2) = p.\n\nThis can be approached by trying to find the largest possible k_i first.\n\nFor example, for p=3:\n\nsum(k_i*(k_i-1)/2) =3 → sum(k_i^2 -k_i) =6.\n\nLooking for the largest k where k*(k-1) <=6:\n\nk=3: 3*2=6 → yes. So k=3, sum is 3.\n\nFor p=4:\n\nsum(k_i*(k_i-1)/2) =4 → sum(k_i^2 -k_i) =8.\n\nLooking for the largest k where k*(k-1) <=8:\n\nk=3: 3*2=6, remaining 8-6=2. Now, find k where k*(k-1) =2: k=2 (2*1=2). So sum is 3+2=5.\n\nAnother option could be k=4: 4*3=12>8 → no.\n\nAnother option: 2 and 3, same as above.\n\nThus, the minimal nodes is 5.\n\nSo the function minimal_nodes should find the decomposition correctly.\n\nOnce the decomposition is found, the next step is to compute the maximum unidirectional pairs.\n\nLet me think about the code.\n\nFirst, handle the case when p=0: output 0 0.\n\nElse, compute 2p.\n\nThen, find the decomposition of 2p into sum(k_i^2 -k_i).\n\nThis can be done by trying the largest possible k first.\n\nOnce the decomposition is found, sort the k_i in descending order.\n\nCompute the sum of k_i * k_j for all i < j.\n\nSo, the code outline is:\n\ndef minimal_nodes_and_unidirectional(p):\n    if p ==0:\n        return (0,0)\n    target = 2*p\n    k_list = []\n    current = target\n    for k in range(int(math.sqrt(target)), 0, -1):\n        rem = current - (k*(k-1))\n        if rem >=0:\n            k_list.append(k)\n            current = rem\n            if current ==0:\n                break\n        # Try splitting rem into smaller k's\n        # Not sure how to do this yet; perhaps it's better to try all possible decompositions.\n        # Alternatively, use dynamic programming or backtracking, but that might be too slow for large p.\n        # For the purposes of this problem, perhaps the initial approach suffices.\n    # Now, process the k_list\n    # However, the above approach may not find all possible decompositions, leading to incorrect results for certain p.\n    # So, perhaps a better approach is needed.\n    # Alternative approach:\n    # We can model this as finding a sequence of k_i such that sum(k_i^2 -k_i) = target, and sum(k_i) is minimized.\n    # This is similar to integer partitioning with constraints.\n    # Since this is a programming competition problem, perhaps a greedy approach is sufficient.\n    # But I'm not sure; perhaps the initial approach works for small p, but fails for larger ones.\n\nWait, perhaps the initial approach isn't sufficient. Let's think of another way.\n\nEach term in the decomposition is (k_i^2 -k_i) = k_i*(k_i -1). We need to sum these to get 2p.\n\nThe goal is to find a set of integers {k_i} such that their squares minus themselves sum to 2p, and the sum of k_i is minimized.\n\nThis is equivalent to finding the minimal number of nodes by choosing the largest possible k_i first.\n\nAn efficient way to find this is to start from the largest possible k and subtract until the remainder is zero.\n\nLet me try to code this.\n\nFunction minimal_nodes(p):\n\nif p ==0:\n    return 0, 0\ntarget = 2*p\nnodes = []\ncurrent = target\nfor k in range(int(math.sqrt(current)), 0, -1):\n    rem = current - (k*(k-1))\n    if rem <0:\n        continue\n    nodes.append(k)\n    current = rem\n    if current ==0:\n        break\n# After this loop, current may still be positive, so we need to find more terms.\n# Now, for the remaining current, try smaller k's.\nwhile current >0:\n    k = int(math.sqrt(current))\n    while k >=1:\n        rem = current - (k*(k-1))\n        if rem >=0:\n            nodes.append(k)\n            current = rem\n            break\n        else:\n            k -=1\n    if current ==0:\n        break\n\nBut this may not always work, as sometimes you need to add smaller k's.\n\nWait, perhaps this isn't the right approach. Another idea is to use the fact that the minimal number of nodes is achieved by using the largest possible k_i.\n\nBut I'm not entirely sure.\n\nAlternatively, perhaps the minimal number of nodes is the smallest n such that the sum of C(m, 2) for m=1 to n is >= p.\n\nWait, but that's not necessarily the case because the decomposition can be into different components.\n\nAlternatively, perhaps the minimal number of nodes is the minimal n where the maximal possible sum of C(k_i, 2) is >=p.\n\nBut this is getting complicated.\n\nPerhaps for the purposes of this problem, considering the sample and trying to find a pattern.\n\nSample Input 1: p=3.\n\nSolution: 3 nodes, one component. Unidirectional pairs:0.\n\nSample Input 2: p=4.\n\nSolution:5 nodes, two components of 3 and 2. Unidirectional pairs:3*2=6.\n\nAnother test case: p=0 → 0 nodes, 0 unidirectional.\n\np=1: target=2.\n\nLooking for k where k*(k-1) =2 → k=2 (since 2*1=2). So nodes=2. Unidirectional pairs:0.\n\np=6: target=12.\n\nLooking for k where k*(k-1)=12 → k=4 (4*3=12). So nodes=4. Unidirectional pairs:0.\n\np=7: target=14.\n\nCheck for k=4: 4*3=12 → rem=2. So k=2 (2*1=2). Total nodes=4+2=6.\n\nUnidirectional pairs:4*2=8.\n\nSo the output would be 6 8.\n\nHmm, so for p=7, the minimal nodes is 6, and maximum unidirectional is 8.\n\nSo, the code should correctly handle this.\n\nThus, the steps are:\n\n1. For the given p, compute target=2*p.\n\n2. Find a decomposition of target into a sum of (k_i*(k_i-1)).\n\n3. The minimal number of nodes is the sum of k_i.\n\n4. Once the k_i are found, sort them in descending order.\n\n5. Compute the sum of k_i * k_j for all i < j. This gives the maximum number of unidirectional pairs.\n\nSo, the code should:\n\n- Find the decomposition of 2p into a sum of (k_i^2 -k_i), using as few terms as possible, each term being the largest possible.\n\nImplementing this decomposition correctly is crucial.\n\nBut how?\n\nOne approach is to use a greedy algorithm: at each step, choose the largest possible k_i such that k_i*(k_i-1) <= remaining target. Subtract this value from the target and proceed.\n\nThis ensures that each step uses the largest possible k_i, which helps in minimizing the total number of nodes.\n\nLet's try this approach:\n\nFor example, p=4 → target=8.\n\nLargest k where k*(k-1) <=8 is k=3 (3*2=6). Remaining target=2. Next, k=2 (2*1=2). Remaining target=0. So nodes=3+2=5.\n\nWhich is correct.\n\nFor p=7 → target=14.\n\nLargest k is 4 (4*3=12). Remaining=2. Next k=2. Total nodes=4+2=6.\n\nWhich is correct.\n\nAnother example: p=10 → target=20.\n\nLargest k is 5 (5*4=20). So nodes=5.\n\nNo unidirectional pairs, as it's a single component.\n\nAnother example: p=11 → target=22.\n\nLargest k is 5 (5*4=20). Remaining=2. Next k=2. Nodes=5+2=7.\n\nUnidirectional pairs:5*2=10.\n\nThus, the code should implement this.\n\nSo, the code will:\n\n- Handle p=0 separately.\n\n- For other p, compute target=2*p.\n\n- Use a loop to find the largest possible k_i at each step.\n\n- Once the decomposition is complete, sum the k_i to get the minimal nodes.\n\n- Then, compute the unidirectional pairs by summing all k_i * k_j for i < j.\n\nThus, the code can be written as follows.\n\nBut wait, the code may fail for certain cases. For example, if after choosing the largest possible k_i, the remaining target cannot be decomposed further. So the code must ensure that the entire target is covered.\n\nLet's test for p=5 → target=10.\n\nLargest k is 4 (4*3=12>10 → no. So k=3 (3*2=6). Remaining=4.\n\nNext, k=2 (2*1=2). Remaining=2.\n\nNext, k=2 again (2*1=2). Remaining=0.\n\nTotal nodes=3+2+2=7.\n\nBut wait, is there a better decomposition?\n\nYes: 3 + 3 → 3*(3-1)=6, 3*(3-1)=6. Sum is 12>10. No.\n\nAnother option: 4 and 1 → 4*3=12>10. No.\n\nAlternative decomposition: 3 and 2 and 2 (sum 6+2+2=10). So nodes=3+2+2=7.\n\nAlternatively, is there a way to get fewer nodes? Like 4 and 3: 4*3=12>10. No.\n\nSo the code's approach is correct.\n\nThus, the code can proceed with this logic.\n\nNow, implementing this in Python.\n\nThe code will read p, compute target=2*p, and then greedily select the largest possible k_i.\n\nOnce the k_i are selected, sort them in descending order and compute the sum of products for i<j.\n\nFinally, output the minimal nodes and the maximum unidirectional pairs.\n\nThus, the code is as follows.\n\nBut wait, in the sample input, for p=3, the minimal nodes is 3, and for p=4, it's 5. So the code should output 3 0 and 5 6, respectively.\n\nTesting the code for p=4:\n\ntarget=8.\n\nk starts at sqrt(8)≈2.828 → floor is 2. Check k=3: 3*2=6 ≤8 → yes. Subtract 6 → rem=2.\n\nNext, k=2: 2*1=2 ≤2 → subtract, rem=0. So k_list=[3,2]. Nodes=5.\n\nUnidirectional pairs:3*2=6.\n\nWhich matches the sample.\n\nThus, the code should correctly handle the sample.\n\nAnother test case: p=0 → output 0 0.\n\nAnother test case: p=1 → target=2.\n\nk=2: 2*1=2. So nodes=2. Unidirectional pairs:0.\n\nAnother test case: p=6 → target=12.\n\nk=4: 4*3=12. So nodes=4. Unidirectional pairs:0.\n\nAnother test case: p=7 → target=14.\n\nk=4:4*3=12. Rem=2. k=2:2*1=2. Nodes=4+2=6. Unidirectional pairs:4*2=8.\n\nThus, the code seems to handle all cases correctly.\n\nNow, writing the code.\n\nBut wait, the function to compute the maximum unidirectional pairs must consider all possible pairs of components.\n\nThus, the code will:\n\n- After collecting all k_i, sort them in descending order.\n\n- Compute the sum of k_i * k_j for all i < j.\n\nThis can be done using a prefix sum approach.\n\nFor example, if the sorted list is [a, b, c], the sum is a*b + a*c + b*c.\n\nWhich is equal to (a + b + c)^2 - (a^2 + b^2 + c^2) ) / 2.\n\nBut since we're dealing with integers, perhaps it's easier to just loop through all pairs.\n\nBut for efficiency, especially for large p, it's better to compute it with a formula.\n\nBut given the constraints, perhaps a loop is acceptable.\n\nThus, the code:\n\nRead p.\n\nIf p is 0, print 0 0.\n\nElse:\n\nCompute target = 2*p.\n\nInitialize k_list = empty list.\n\ncurrent = target.\n\nLoop k from floor(sqrt(current)) down to 1:\n\n   if k*(k-1) <= current:\n\n      add k to k_list.\n\n      current -= k*(k-1).\n\n      if current ==0: break.\n\nIf current is not zero, then we need to find smaller k's.\n\nWait, but according to the earlier logic, the largest k will always cover as much as possible, leaving a remainder that can be covered by smaller k's.\n\nBut perhaps the initial loop misses some cases.\n\nThus, in the code, after the initial loop, if current is not zero, we need to find smaller k's.\n\nBut in practice, the initial loop may not find a complete decomposition, so perhaps the code needs to handle it differently.\n\nBut perhaps the initial loop is sufficient.\n\nAlternatively, perhaps the initial loop can be modified to try all possible k's down to 1.\n\nBut that may be time-consuming for large p.\n\nBut given that p can be up to 2e5, the code must be efficient.\n\nThus, the code proceeds as follows:\n\nRead p.\n\nIf p==0: print 0 0.\n\nElse:\n\ntarget = 2*p.\n\nk_list = []\n\ncurrent = target.\n\nfor k in range(int(math.isqrt(current)), 0, -1):\n\n   if k*(k-1) <= current:\n\n       k_list.append(k)\n\n       current -= k*(k-1)\n\n       if current ==0:\n\n           break\n\nif current !=0:\n\n   # This indicates that the decomposition is not possible with the initial approach.\n\n   # Thus, perhaps the code needs to backtrack.\n\n   # But this is a problem because for some p, the decomposition may not be possible with the initial approach.\n\n   # For example, p=2: target=4.\n\n   # k=2: 2*1=2. current=4-2=2.\n\n   # Then, k=2 again: 2*1=2. current=0.\n\n   # So nodes=2+2=4.\n\n   # But perhaps there's a better decomposition.\n\n   # Alternatively, perhaps the initial approach is sufficient.\n\nBut wait, for p=2, target=4.\n\nThe decomposition would be 2 and 2.\n\nThus, the code would output nodes=4, unidirectional pairs=2*2=4.\n\nBut wait, the minimal nodes might be 3.\n\nBecause 3 nodes in a single component: C(3,2)=3, which is more than p=2.\n\nSo that's not possible. So, perhaps the initial approach is correct.\n\nThus, perhaps the code is correct.\n\nBut I'm not entirely sure, but given time constraints, I'll proceed with this approach.\n\nThus, the final code is as follows.",
    "score": -1,
    "metadata": {
        "prompt_token_count": 467,
        "completion_token_count": 5949,
        "thoughts_token_count": 1025
    }
}