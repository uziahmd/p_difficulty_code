{
    "start": 1758282053.67206,
    "end": 1758283935.6534088,
    "start-formatted": "2025-09-19 20:40 KST",
    "end-formatted": "2025-09-19 21:12 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "Okay, so I need to solve this problem where given two integers a and b, I have to find the smallest non-negative integer k such that the LCM of (a+k) and (b+k) is minimized. And if there are multiple k's that give the same minimal LCM, pick the smallest one.\n\nHmm. Let me think about how to approach this.\n\nFirst, let's understand what's happening when we add k to both a and b. The new numbers are a + k and b + k. But wait, since a and b could be in any order, maybe I should first compute the difference between them. Oh right, because if a is larger than b, then adding k to both doesn't change their difference. So the difference is fixed as |a - b|. Let's denote d = |a - b|.\n\nSo the problem reduces to finding k such that the two numbers x = a + k and y = b + k have their LCM minimized. Since x and y differ by d, which is fixed, perhaps the optimal k can be found by considering their greatest common divisor (gcd).\n\nWait, because for two numbers x and y, LCM(x, y) = (x * y) / GCD(x, y). So to minimize the LCM, we need to maximize the GCD of x and y.\n\nSo our goal is to find x and y such that x = a + k, y = b + k, and GCD(x, y) is as large as possible. Because the higher the GCD, the lower the LCM.\n\nSo the key is to find the maximum possible g such that g divides both x and y, which implies g must divide their difference, which is d. So g must be a divisor of d.\n\nTherefore, the plan is:\n\n1. Compute d = |a - b|.\n2. Find all possible divisors of d.\n3. For each divisor g, check if it's possible to choose k such that g divides both a + k and b + k.\n4. Among all possible g's, find the largest possible g, and then compute the corresponding k.\n\nWait, but how do we find the k for a given g?\n\nLet's see. Since g divides x and y, which are a +k and b +k, respectively. So:\n\na + k ≡ 0 mod g\nb + k ≡ 0 mod g\n\nSubtracting these equations gives (a - b) ≡ 0 mod g. Which is true because d is a multiple of g.\n\nSo for a given g (divisor of d), we can find the required k. Let's express the congruence:\n\na + k ≡ 0 mod g → k ≡ (-a) mod g\nSimilarly, since d is fixed, perhaps it's easier to set up k based on the remainder of a mod g.\n\nWait, but for each g, which is a divisor of d, we can compute the required k as follows:\n\nLet r = a mod g. Then, k must be equal to (g - r) mod g. Because a + k ≡ 0 mod g → k ≡ (-r) mod g. So the smallest non-negative k for this g is (g - r) % g.\n\nBut wait, since k has to be non-negative, that's correct.\n\nSo the steps would be:\n\n- Compute d = |a - b|\n- If d is 0 (a == b), then any k will make LCM(a+k, b+k) = a +k. So the minimal is when k is 0.\n- Else, find all divisors of d.\n- For each divisor g, compute the minimal k that makes g the GCD of a +k and b +k.\n- For each such g, calculate the resulting LCM and track the minimum.\n\nWait, but why not consider all possible g's that are divisors of d, including those that are factors but not necessarily maximal? Because a larger g would lead to a smaller LCM, so we should prioritize larger g's.\n\nSo the plan is to iterate through all possible divisors g of d in descending order. For each g, compute the minimal k needed to make g a common divisor, then compute the LCM for that g and k, and keep track of the minimal LCM and the corresponding k.\n\nOnce we find the first g (the largest possible) that gives the minimal LCM, that's our answer.\n\nWait, but perhaps different g's can yield the same LCM. For example, maybe a larger g gives a higher LCM than a smaller one. No, that doesn't make sense because the LCM is inversely related to the GCD. So higher GCD leads to lower LCM.\n\nWait, no. Wait, for two numbers x and y, LCM(x, y) is x*y / GCD(x, y). So higher GCD means lower LCM. So yes, for a fixed d, the maximum possible GCD would give the minimal LCM.\n\nSo the approach is to find the largest possible g (divisor of d) such that when we choose k to make g the GCD, the LCM is as small as possible.\n\nBut wait, perhaps for a certain g, the k computed may not be the minimal possible. Or perhaps for a certain g, the LCM is lower than others.\n\nWait, but for each g, the minimal k is (g - (a mod g)) % g. Then, for that k, the LCM is (a +k) * (b +k) / g.\n\nWait, but a +k is a multiple of g, and similarly for b +k. So the LCM is ( (a +k)/g ) * ( (b +k)/g ) * g → which is (a +k)(b +k)/(g^2) * g → (a +k)(b +k)/g.\n\nWait, no. Wait, since (a +k) and (b +k) are both multiples of g, their LCM is the product divided by the GCD, which is at least g. But since g is a divisor of both, the GCD could be a multiple of g. Hmm, that complicates things.\n\nWait, no. Because we're choosing g such that it's the maximum possible divisor of d. So when we select the largest possible g, then the GCD of (a +k) and (b +k) is exactly g, because any larger divisor would have been considered earlier.\n\nWait, maybe not. Because when you add k, the GCD could be a multiple of g. So perhaps, for a given g, the actual GCD is a multiple of g.\n\nWait, for example: suppose d is 12. Let’s say g is 6. Then, the difference is 12. When you add k such that a +k is divisible by 6, and b +k is also divisible by 6. So their GCD is at least 6. But could it be higher? Like 12?\n\nWell, if a +k and b +k are both multiples of 12, then their GCD is 12. So in that case, the GCD is a multiple of g.\n\nSo perhaps, for a given g, the actual GCD could be a multiple of g, which might allow for a higher GCD, leading to a lower LCM.\n\nHmm, so perhaps the way to approach this is to generate all possible divisors of d, but in such a way that for each possible g, which is a divisor, the maximum possible GCD is considered.\n\nWait, but that's more complex. So perhaps the initial approach isn't sufficient.\n\nAlternatively, perhaps the best approach is to generate all possible g's that are divisors of d, and for each g, compute the minimal k that allows a +k and b +k to be multiples of g, then compute the LCM for that k and see which gives the minimal LCM.\n\nWait, but this could miss cases where the GCD is a multiple of g, thus possibly leading to a better LCM.\n\nSo perhaps, the initial approach of trying all possible divisors of d and computing the minimal k for each is correct, but perhaps the way to compute the LCM for each case is to compute the GCD of a +k and b +k, and then use that to compute the LCM.\n\nBut that sounds computationally expensive, especially since d can be up to 1e9, which has a lot of divisors.\n\nWait, but for d=1e9, the number of divisors is manageable. For example, 1e9 is 2^9 *5^9, so number of divisors is (9+1)*(9+1)=100, which is manageable.\n\nSo perhaps the plan is:\n\n1. Compute d = |a - b|\n\n   If d == 0, return k=0.\n\n2. Else, find all divisors of d, sorted in decreasing order.\n\n3. For each divisor g in this list:\n\n   a. Compute the required k. Since a +k must be divisible by g, k = (g - (a % g)) % g.\n\n      Similarly, b +k must be divisible by g, which it will be because (b +k) = (b - a) + (a +k). Since d is a multiple of g, and a +k is a multiple of g, b +k will also be a multiple of g.\n\n   b. Compute the current_gcd = GCD(a +k, b +k). Since a +k and b +k are both multiples of g, current_gcd is at least g. However, it could be higher, like 2g, 3g, etc.\n\n   c. Compute the LCM as (a +k) * (b +k) // current_gcd.\n\n   d. Keep track of the minimal LCM and the corresponding k.\n\n4. After processing all divisors, choose the k with the smallest value in case of ties (i.e., same LCM).\n\nWait, but this seems computationally feasible because the number of divisors is limited.\n\nBut wait, for each g, the current_gcd could be larger than g, which may affect the LCM. So perhaps, for each possible g (divisor of d), we need to compute the minimal k that makes a +k and b +k both multiples of g, and then compute the actual GCD for those values.\n\nBut this could be time-consuming because for each g, we have to compute the GCD, which is O(log n) time.\n\nBut given that the number of g's is limited (like up to 1e5 or so for d=1e9), it's manageable.\n\nSo let's outline the steps again:\n\nCompute d = abs(a - b)\n\nIf d == 0:\n\n   Then a and b are equal. So a +k and b +k are equal. Their LCM is a +k, which is minimized when k is 0. So output k=0.\n\nElse:\n\n   Generate all divisors of d, including 1 and d.\n\n   Sort the divisors in descending order.\n\n   For each divisor g in this list:\n\n      Compute k = (g - (a % g)) % g.\n\n      Then, compute x = a +k, y = b +k.\n\n      Compute current_gcd = gcd(x, y).\n\n      current_lcm = x * y // current_gcd.\n\n      Keep track of the minimal current_lcm and the smallest k that achieves it.\n\n   After all g's are processed, output the smallest k that gives the minimal LCM.\n\nBut wait, is the current_gcd always a multiple of g? Because x and y are multiples of g, yes. So the GCD(x, y) must be a multiple of g. So current_gcd = g * m, where m is an integer >=1.\n\nSo the minimal LCM for this case would be (x * y) / (g * m) = (x/g * y/g) / m.\n\nSince m is a factor, perhaps the LCM is minimized when m is as large as possible. But I'm not sure.\n\nWait, but for each g, the minimal k is determined. But perhaps for a larger g, even though it's a divisor of d, the k is such that the GCD is higher, leading to a lower LCM.\n\nSo the process is, for each possible g (divisor of d), compute the minimal k for that g, compute the actual GCD of (a +k, b +k), compute the LCM, and track the minimal LCM and the corresponding k.\n\nOnce all g's are processed, choose the smallest k that gives the minimal LCM.\n\nBut how efficient is this?\n\nFor each g, we perform:\n\n- Calculating k: O(1)\n- Calculating x and y: O(1)\n- Calculating GCD(x, y): O(log(max(x,y))), which is acceptable for numbers up to 1e9.\n\nGiven that the number of g's is up to around 1e5 (for d=1e9, which has 100 divisors as earlier thought), this is manageable.\n\nSo now, the steps to implement:\n\n1. Read a and b.\n\n2. Compute d = abs(a - b)\n\n3. If d == 0:\n\n   Output 0.\n\n4. Else:\n\n   Generate all divisors of d.\n\n   Sort them in descending order.\n\n   For each g in sorted_divisors:\n\n      Compute k = (g - (a % g)) % g.\n\n      x = a +k\n\n      y = b +k\n\n      current_gcd = gcd(x, y)\n\n      current_lcm = (x * y) // current_gcd\n\n      Compare to the current minimal LCM.\n\n      If this current_lcm is less than the minimal, update the minimal and record k.\n\n      Else if current_lcm is equal to the minimal, but k is smaller than the recorded k, update the k.\n\n5. After processing all g's, output the minimal k.\n\nWait, but when d is zero, a and b are equal, so x and y are both a +k, which is the same for both. So the LCM is x, which is a +k. To minimize this, k is zero.\n\nNow, the next thing is to find all the divisors of d.\n\nHow to generate all the divisors of d?\n\nWe can factorize d into its prime factors, then generate all possible products.\n\nBut factorizing d could take some time if d is up to 1e9. But for 1e9, trial division is manageable.\n\nSo here's how to find the divisors:\n\nFunction to get all divisors of a number n.\n\nInitialize a list of divisors.\n\nFor i from 1 to sqrt(n):\n\n   if i divides n:\n\n      add i to the list.\n\n      if i != n/i, add n/i to the list.\n\nThen, sort the list, and remove duplicates.\n\nThen, sort the list in descending order.\n\nWait, but for n=0, this is undefined, but in our case, d is at least 1 when it's non-zero.\n\nSo the function for getting all divisors:\n\ndef get_divisors(n):\n\n    divisors = set()\n\n    for i in range(1, int(math.sqrt(n)) +1):\n\n        if n % i ==0:\n\n            divisors.add(i)\n\n            divisors.add(n//i)\n\n    return sorted(divisors, reverse=True)\n\nWait, but wait, for n=0, but in our case, d is non-zero.\n\nSo, that's okay.\n\nOnce we have the divisors in descending order, we can proceed.\n\nTesting this approach on the sample input:\n\nSample 1:\n\nInput: 6 10 → d = 4.\n\nDivisors of 4: 4, 2, 1.\n\nProcess each g:\n\ng=4:\n\nk = (4 - (6 mod 4)) mod4 → 6 mod4 is 2 → 4-2=2 → k=2.\n\nx=8, y=12. GCD is 4. LCM = (8*12)/4 =24.\n\ng=2:\n\nk=(2 - (6%2)) mod2 → 6 mod2 is 0 → k=0.\n\nx=6, y=10. GCD is 2. LCM is (6*10)/2=30.\n\ng=1:\n\nk= (1 - (6%1)) mod1 → 0.\n\nx=6, y=10. GCD is 2. LCM is 30.\n\nSo for g=4, the LCM is 24, which is better than 30. So the minimal is 24, with k=2.\n\nWhich matches the sample.\n\nAnother test case: 21 31 → d=10.\n\nDivisors of 10: 10,5,2,1.\n\nProcess each g:\n\ng=10:\n\nk= (10 - (21 mod10)) mod10 → 21 mod10 is1 → 10-1=9 →k=9.\n\nx=30, y=40. GCD is 10. LCM is 30*40/10=120.\n\ng=5:\n\nk=(5 - (21 mod5)) mod5 →21 mod5 is1 →5-1=4 →k=4.\n\nx=25, y=35. GCD is5. LCM=25*35/5=175.\n\ng=2:\n\nk= (2 - (21%2)) mod2 →21 mod2 is1 →2-1=1 →k=1.\n\nx=22, y=32. GCD is 2. LCM= (22*32)/2=352.\n\ng=1:\n\nk=0.\n\nx=21, y=31. GCD is1. LCM= 21*31=651.\n\nSo the minimal is 120, achieved at k=9.\n\nWhich matches the sample.\n\nThird test case:5 10 →d=5.\n\nDivisors:5,1.\n\ng=5:\n\nk=(5 - (5 mod5)) mod5 →0.\n\nx=5, y=10 → GCD 5, LCM 10.\n\ng=1:\n\nk=0.\n\nx=5, y=10 → GCD 5, LCM 10.\n\nSo the minimal is 10, achieved at k=0.\n\nWhich matches the sample.\n\nSo the approach works.\n\nNow, let's think about edge cases.\n\nCase 1: a and b are equal. Output is 0.\n\nCase 2: a=1, b=2 →d=1.\n\nDivisors:1.\n\ng=1:\n\nk= (1 - (1 mod1)) mod1 →0.\n\nx=1, y=2 → GCD 1 → LCM 2.\n\nNo other options.\n\nSo output 0.\n\nCase3: a=2, b=4 →d=2.\n\nDivisors:2,1.\n\ng=2:\n\nk= (2 - (2 mod2)) mod2 →0.\n\nx=2, y=4 → GCD 2 → LCM 4.\n\ng=1:\n\nk=0.\n\nx=2, y=4 → GCD 2 → LCM4.\n\nSame result.\n\nSo the minimal k is 0.\n\nAnother case: a=3, b=7 →d=4.\n\nDivisors:4,2,1.\n\ng=4:\n\nk= (4 - (3 mod4)) →3 mod4 is3 →4-3=1 →k=1.\n\nx=4, y=8 → GCD4 → LCM 32.\n\ng=2:\n\nk= (2 - (3 mod2)) →3 mod2=1 →2-1=1 →k=1.\n\nx=4, y=8 → GCD4 → LCM32.\n\nWait, but for g=2, k is 1. So x=4, y=8. Same as for g=4. So the LCM is same.\n\nSo for both g=4 and g=2, the k is 1.\n\nSo the minimal LCM is 32, achieved with k=1.\n\nBut what about other g's? For g=1, k=0. x=3, y=7. GCD1, LCM21>32. So the minimal is 32.\n\nSo the code would correctly return 1.\n\nWait, but in the code, when processing g=4 and g=2, the k is the same, but the GCD for x and y is higher for g=4.\n\nWait, but in the code, for each g, we compute the actual GCD, not just g.\n\nSo for g=4, x=4, y=8, GCD is4.\n\nFor g=2, x=4, y=8, GCD is4 as well.\n\nSo in both cases, the LCM is (4*8)/4=32.\n\nSo whether you choose g=4 or g=2, the LCM is same.\n\nSo in this case, the code would pick the first g (4) and the k is 1.\n\nSo the code would return k=1.\n\nWhich is correct.\n\nAnother test case: a=8, b=12 →d=4.\n\ng=4:\n\nk= (4 - (8 mod4)) →0.\n\nx=8, y=12 → GCD4, LCM (8*12)/4=24.\n\ng=2:\n\nk= (2 - (8 mod2)) →0.\n\nx=8, y=12 → GCD4, LCM24.\n\nSame result.\n\ng=1: k=0, x=8, y=12, GCD4, LCM24.\n\nSo the minimal is 24, achieved with k=0.\n\nThus, the code returns 0.\n\nAnother case: a=9, b=15 →d=6.\n\nDivisors of6:6,3,2,1.\n\ng=6:\n\nk= (6 - (9 mod6)) →9 mod6 is3 →6-3=3 →k=3.\n\nx=12, y=18 → GCD6 → LCM 36.\n\ng=3:\n\nk= (3 - (9 mod3)) →0.\n\nx=9, y=15 → GCD3 → LCM (9*15)/3=45.\n\ng=2:\n\nk= (2 - (9 mod2)) →9 mod2=1 →2-1=1 →k=1.\n\nx=10, y=16 → GCD2 → LCM (10*16)/2=80.\n\ng=1:\n\nk=0.\n\nx=9, y=15 → GCD3 → LCM45.\n\nSo the minimal is 36, achieved with k=3.\n\nSo the code will process the divisors in order 6,3,2,1.\n\nAt g=6, the LCM is36. Then, for g=3, LCM is45, which is higher. So the minimal is36, k=3.\n\nSo the code works.\n\nNow, let's think about the implementation.\n\nIn Python, we can read a and b as integers.\n\nCompute d=abs(a -b).\n\nIf d==0: print 0.\n\nElse:\n\nGenerate all divisors of d.\n\nSort them in descending order.\n\nFor each g in the sorted list:\n\nCompute the remainder r = a % g.\n\nk = (g - r) % g.\n\nx = a +k\n\ny = b +k\n\nCompute current_gcd = math.gcd(x, y)\n\ncurrent_lcm = (x * y) // current_gcd\n\nCompare to the minimal lcm and k.\n\nNow, what about when d is zero? That's when a and b are equal.\n\nSo, for example, a=5, b=5.\n\nThen, any k will make x and y equal, so LCM is x. To minimize, choose k=0.\n\nSo the code correctly handles that.\n\nNow, let's think about the code.\n\nImplementing the get_divisors function.\n\nWait, but for n=0, but in our case, d is non-zero when we enter this part.\n\nSo:\n\nimport math\n\ndef get_divisors(n):\n    divisors = set()\n    for i in range(1, int(math.isqrt(n)) +1):\n        if n % i ==0:\n            divisors.add(i)\n            divisors.add(n//i)\n    return sorted(divisors, reverse=True)\n\nWait, but in Python, for n=1, it will return [1].\n\nTesting with n=6: divisors are 1,2,3,6. Sorted in reverse order:6,3,2,1.\n\nYes.\n\nSo, the code for the problem:\n\nRead a, b.\n\nCompute d=abs(a -b).\n\nIf d ==0:\n\n   print(0)\n\nelse:\n\n   divisors = get_divisors(d)\n\n   min_lcm = None\n\n   best_k = None\n\n   for g in divisors:\n\n       r = a % g\n\n       k = (g - r) % g\n\n       x = a +k\n\n       y = b +k\n\n       current_gcd = math.gcd(x, y)\n\n       current_lcm = (x * y) // current_gcd\n\n       if min_lcm is None or current_lcm < min_lcm or (current_lcm == min_lcm and k < best_k):\n\n           min_lcm = current_lcm\n\n           best_k = k\n\n   print(best_k)\n\nWait, but wait: in the code, for each g, we compute the k, then x and y, then the current_gcd, then the current_lcm. We then compare it to the current min.\n\nBut in the code above, the variable 'best_k' is initialized as None. So when the first iteration occurs, min_lcm is None, so it will set min_lcm to current_lcm and best_k to k.\n\nWhat if all current_lcm are the same? Like when a and b are equal.\n\nWait, no, because when d=0, we handle that before. So in the else clause, d is non-zero.\n\nWait, but in the else clause, d is non-zero, so a and b are different. So for g=1, the k will be 0, but x and y are a and b, which are different, so their GCD is 1, and their LCM is a*b.\n\nBut other g's could have higher GCDs.\n\nBut the code correctly processes all g's.\n\nSo the code should work.\n\nNow, testing.\n\nSample Input 1:\n\n6 10 → d=4.\n\ndivisors:4,2,1.\n\nFor g=4: k=2 → x=8, y=12 → GCD4 → LCM24.\n\nmin_lcm is 24, best_k=2.\n\ng=2: k=0 → x=6, y=10 → GCD2 → LCM30.\n\ncurrent_lcm is 30 >24 → no change.\n\ng=1: k=0 → x=6, y=10 → GCD2 → LCM30. Still no change.\n\nThus, best_k is 2.\n\nSample Input 2:\n\n21 31 →d=10.\n\ndivisors:10,5,2,1.\n\ng=10: k=9 → x=30, y=40 → GCD10 → LCM 30*40 /10 =120.\n\ng=5: k=4 → x=25, y=35 → GCD5 → LCM 175.\n\ng=2: k=1 →x=22, y=32 → GCD2 → LCM 352.\n\ng=1: k=0 → x=21, y=31 → GCD1 → LCM 651.\n\nThus, min is 120, k=9.\n\nSample Input 3:\n\n5 10 →d=5.\n\ndivisors:5,1.\n\ng=5: k=0 → x=5, y=10 → GCD5 → LCM10.\n\ng=1: k=0 → x=5, y=10 → GCD5 → LCM10.\n\nSo the min is 10, achieved with k=0.\n\nThus, code works.\n\nAnother test case: a=3, b=7 →d=4.\n\ndivisors:4,2,1.\n\ng=4: k= (4 -3%4) = (4-3)=1 →k=1.\n\nx=4, y=8 → GCD4 → LCM 32.\n\ng=2: k= (2 -3%2) → 3%2=1 →2-1=1 →k=1.\n\nx=4, y=8 → GCD4 → LCM32.\n\ng=1: k=0 →x=3, y=7 →GCD1 → LCM21.\n\nThus, the minimal is32, achieved with k=1.\n\nThus, code returns 1.\n\nSo the code works.\n\nNow, what about when d=1?\n\na=1, b=2.\n\ndivisors:1.\n\ng=1: k=0.\n\nx=1, y=2 → GCD1 → LCM2.\n\nThus, output is0.\n\nAnother case: a=0, b=5 →d=5.\n\nWait, but in the problem statement, a and b are at least 1. So no.\n\nWait, according to the problem statement, a and b are between 1 and 1e9, inclusive.\n\nSo no issues with a or b being zero.\n\nAnother case: a=7, b=14 →d=7.\n\ndivisors:7,1.\n\ng=7:\n\nk= (7 -7%7) mod7 →0.\n\nx=7, y=14 → GCD7 → LCM 14.\n\ng=1: k=0 →x=7, y=14 → GCD7 → LCM14.\n\nThus, minimal is14, achieved with k=0.\n\nThus, code returns0.\n\nNow, what about when a=9, b=15 →d=6.\n\ndivisors:6,3,2,1.\n\ng=6: k=3 →x=12, y=18 → GCD6 → LCM36.\n\ng=3: k=0 →x=9, y=15 → GCD3 → LCM45.\n\ng=2: k=1 →x=10, y=16 → GCD2 → LCM 80.\n\ng=1: k=0 →x=9, y=15 → GCD3 → LCM45.\n\nThus, minimal is36, k=3.\n\nThus, code returns3.\n\nAll tests seem to pass.\n\nNow, the code needs to read from stdin, which is a single line with two integers.\n\nSo, in Python:\n\nimport sys\nimport math\n\ndef get_divisors(n):\n    divisors = set()\n    for i in range(1, int(math.isqrt(n)) +1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n//i)\n    return sorted(divisors, reverse=True)\n\na, b = map(int, sys.stdin.readline().split())\nd = abs(a - b)\nif d == 0:\n    print(0)\nelse:\n    divisors = get_divisors(d)\n    min_lcm = None\n    best_k = None\n    for g in divisors:\n        r = a % g\n        k = (g - r) % g\n        x = a + k\n        y = b + k\n        current_gcd = math.gcd(x, y)\n        current_lcm = (x * y) // current_gcd\n        if min_lcm is None or current_lcm < min_lcm or (current_lcm == min_lcm and k < best_k):\n            min_lcm = current_lcm\n            best_k = k\n    print(best_k)\n\nWait, but in Python, the math.gcd function returns the absolute value, but since x and y are positive, it's fine.\n\nTesting the code with the sample inputs:\n\nSample Input 1:\n\n['6 10', '21 31', '5 10']\n\nSample Output:\n\n['2', '9', '0']\n\nThe code should process these correctly.\n\nYes.\n\nNow, another edge case: a=2, b=4 →d=2.\n\ndivisors:2,1.\n\ng=2: k=0 →x=2, y=4 → GCD2 → LCM4.\n\ng=1: k=0 →x=2, y=4 → GCD2 → LCM4.\n\nThus, best_k is 0.\n\nThus, the code returns 0.\n\nAnother case: a=1, b=3 →d=2.\n\ndivisors:2,1.\n\ng=2:\n\nr=1%2=1 →k=(2-1) mod2=1.\n\nx=2, y=4 → GCD2 → LCM4.\n\ng=1:\n\nk=0 →x=1, y=3 → GCD1 → LCM3.\n\nSo the minimal is4, achieved with k=1.\n\nThus, code returns1.\n\nYes.\n\nThus, the code should handle all cases correctly.\n",
    "response": "To solve this problem, we need to find the smallest non-negative integer \\( k \\) such that the least common multiple (LCM) of \\( a + k \\) and \\( b + k \\) is minimized. If there are multiple values of \\( k \\) that yield the same minimal LCM, we should choose the smallest \\( k \\).\n\n### Approach\n1. **Problem Analysis**: The key insight is that the difference between \\( a \\) and \\( b \\), denoted as \\( d \\), remains constant when \\( k \\) is added to both. The goal is to maximize the greatest common divisor (GCD) of \\( a + k \\) and \\( b + k \\) because a higher GCD results in a smaller LCM.\n\n2. **Divisors of Difference**: Compute all divisors of \\( d \\). For each divisor \\( g \\), determine the smallest \\( k \\) such that both \\( a + k \\) and \\( b + k \\) are multiples of \\( g \\).\n\n3. **Compute LCM for Each Divisor**: For each divisor \\( g \\), compute the corresponding \\( k \\) and then calculate the LCM of \\( a + k \\) and \\( b + k \\). Track the minimum LCM and the smallest \\( k \\) that achieves it.\n\n4. **Efficiency Considerations**: The number of divisors of \\( d \\) is manageable even for large values of \\( d \\) (up to \\( 10^9 \\)), making this approach feasible.\n\n### Solution Code\n```python\nimport sys\nimport math\n\ndef get_divisors(n):\n    divisors = set()\n    for i in range(1, int(math.isqrt(n)) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sorted(divisors, reverse=True)\n\na, b = map(int, sys.stdin.readline().split())\nd = abs(a - b)\nif d == 0:\n    print(0)\nelse:\n    divisors = get_divisors(d)\n    min_lcm = None\n    best_k = None\n    for g in divisors:\n        r = a % g\n        k = (g - r) % g\n        x = a + k\n        y = b + k\n        current_gcd = math.gcd(x, y)\n        current_lcm = (x * y) // current_gcd\n        if (min_lcm is None or \n            current_lcm < min_lcm or \n            (current_lcm == min_lcm and k < best_k)):\n            min_lcm = current_lcm\n            best_k = k\n    print(best_k)\n```\n\n### Explanation\n1. **Reading Input**: The code reads the integers \\( a \\) and \\( b \\).\n2. **Compute Difference**: Calculate \\( d \\) as the absolute difference between \\( a \\) and \\( b \\).\n3. **Handle Equal Values**: If \\( a \\) and \\( b \\) are equal, the answer is \\( k = 0 \\) since any \\( k \\) will not change their LCM.\n4. **Generate Divisors**: Compute all divisors of \\( d \\) and sort them in descending order.\n5. **Evaluate Each Divisor**: For each divisor \\( g \\), compute the smallest \\( k \\) that makes \\( a + k \\) and \\( b + k \\) multiples of \\( g \\). Calculate the LCM for these values and track the minimum LCM and corresponding \\( k \\).\n6. **Output Result**: Print the smallest \\( k \\) that yields the minimal LCM.\n\nThis approach efficiently finds the optimal \\( k \\) by leveraging the properties of divisors and GCD, ensuring the solution is both correct and efficient.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\n\ndef get_divisors(n):\n    divisors = set()\n    for i in range(1, int(math.isqrt(n)) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sorted(divisors, reverse=True)\n\na, b = map(int, sys.stdin.readline().split())\nd = abs(a - b)\nif d == 0:\n    print(0)\nelse:\n    divisors = get_divisors(d)\n    min_lcm = None\n    best_k = None\n    for g in divisors:\n        r = a % g\n        k = (g - r) % g\n        x = a + k\n        y = b + k\n        current_gcd = math.gcd(x, y)\n        current_lcm = (x * y) // current_gcd\n        if (min_lcm is None or \n            current_lcm < min_lcm or \n            (current_lcm == min_lcm and k < best_k)):\n            min_lcm = current_lcm\n            best_k = k\n    print(best_k)",
    "score": 1,
    "metadata": {
        "prompt_token_count": 392,
        "completion_token_count": 795,
        "thoughts_token_count": 7079
    }
}