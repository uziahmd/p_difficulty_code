{
    "start": 1758284037.4828746,
    "end": 1758286345.2883105,
    "start-formatted": "2025-09-19 21:13 KST",
    "end-formatted": "2025-09-19 21:52 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let me read it carefully.\n\nThe problem is about Vitaly and a graph theory problem. We need to find the minimum number of edges to add to form a simple cycle of odd length, with more than one vertex. And also count the number of ways to do this.\n\nHmm. So the graph is undirected, no loops or parallel edges. It's not necessarily connected.\n\nFirst, I think I should understand what's required. We need to find the smallest t such that adding t edges can form an odd-length cycle (at least 3 vertices). Also, w is the number of ways to achieve this.\n\nWait, but how? Because adding edges could create multiple possible cycles. But the key is that the resulting cycle must be simple (no repeated vertices) and of odd length.\n\nSo, my approach needs to be something like:\n\n1. For each connected component in the graph, determine if it already has a cycle. If it's a tree, then adding edges to form a cycle might be needed.\n2. But since we're looking for an odd-length cycle, perhaps we should consider the parity of the connected components.\n\nWait, maybe I should think differently. The minimal t would depend on the structure of the graph. For example, if there's a cycle already, then t could be zero if it's odd.\n\nWait, let's think step by step.\n\nCase 1: The graph already contains a cycle of odd length. Then t=0, w=1 because only one way (do nothing).\n\nCase 2: The graph doesn't have any odd-length cycles. Then we need to find the minimal t and the number of ways to add edges to create such a cycle.\n\nWait, but how?\n\nI recall that in graph theory, a cycle is formed when a connected component has a cycle. So, perhaps we need to look at each connected component separately.\n\nWait, but the cycle can consist of multiple connected components? No, because adding edges can't connect two disconnected components into a single cycle unless you add edges between them, but that would complicate the structure.\n\nWait, no. Because the cycle must be a simple cycle. So, to form a cycle, all nodes must be in a single connected component. Because otherwise, the cycle would require moving through different components, which isn't possible without adding edges between them.\n\nWait, no. Wait, adding edges between two connected components will merge them into a single component. So, perhaps the minimal way is to first connect some components and then form a cycle within that.\n\nBut how does that affect the parity of the cycle?\n\nAlternatively, perhaps each connected component contributes to the possibility of forming an odd cycle.\n\nLet me think about the necessary conditions for a connected component to have an even or odd cycle.\n\nIn a connected component, if it's a tree, adding one edge creates exactly one cycle. The length of that cycle depends on the path between the two nodes where the new edge is added. So, the length is equal to the distance between those two nodes plus one.\n\nBut wait, in a tree, the distance between two nodes is unique. So, the cycle created by adding an edge between two nodes u and v is of length d(u, v) + 1.\n\nSo, the parity of this cycle is (d(u, v) + 1) mod 2.\n\nNow, the problem is to find the minimal t such that after adding t edges, the graph has a cycle of odd length.\n\nSo, for each connected component, we can compute the minimal number of edges to add to create an odd cycle, considering whether the component is already a tree or has cycles.\n\nWait, perhaps the steps are:\n\n1. For each connected component, check if it has a cycle. If it does, and that cycle is of odd length, then that component can contribute to the solution.\n\n   So, if any component already has an odd cycle, then t is 0, w is 1.\n\n2. If none of the connected components have an odd cycle, then we need to add edges.\n\n   How?\n\n   For each connected component, we can compute how many edges we need to add to create an odd cycle. Then, choose the minimal total across all components.\n\nBut wait, how can adding edges to a single component create an odd cycle?\n\nBecause the existing component may have even cycles, but by adding certain edges, we can turn it into having an odd cycle.\n\nWait, perhaps we can model each connected component as either being able to form an odd cycle with a certain cost (number of edges to add) and a certain number of ways.\n\nThen, the overall t is the minimal sum of edges across all components, and the w is the sum of ways for each chosen component.\n\nWait, but the way to combine components is unclear. Because adding edges can connect components, which may allow for multiple ways to form cycles.\n\nAlternatively, perhaps the minimal t is determined by the minimal t among all connected components, considering their own possibilities.\n\nWait, perhaps each connected component can be considered as a candidate for contributing to the solution. So, for each connected component, compute the minimal edges needed to form an odd cycle within that component, and the number of ways to do so. Then, the overall t is the minimal such value across all components, and the w is the sum of the ways for each component used.\n\nBut I'm not sure.\n\nAnother angle: To form an odd cycle, the graph must have at least one connected component with an odd cycle.\n\nSo, perhaps the steps are:\n\n- Find all connected components.\n\n- For each component, compute whether it can be turned into an odd cycle by adding edges, and what's the minimal number of edges needed, and how many ways.\n\n- Then, pick the component(s) that require the least edges, and sum their ways.\n\nWait, but how?\n\nAlternatively, perhaps the minimal t is the minimal between:\n\na) The minimal edges needed to add to any single component to make it have an odd cycle.\n\nb) The minimal edges needed to connect two components in such a way that together they form an odd cycle.\n\nBut that seems complicated.\n\nWait, perhaps it's easier to think in terms of each connected component and its properties.\n\nEach connected component can be:\n\n- A tree (no cycles). Then, adding one edge creates exactly one cycle. The parity of this cycle depends on the distance between the two nodes.\n\n   So, for a tree, the minimal edges to add is 1. And the number of ways is the number of pairs of nodes at a certain parity distance.\n\nWait, but wait: for a tree, adding any edge between two nodes u and v creates a cycle of length d(u, v) + 1. So, to get an odd cycle, we need d(u, v) to be even (since d+1 is odd). So, the number of such pairs is the number of node pairs with even distance.\n\nBut wait, in a tree, for any pair of nodes u and v, the distance is fixed. So, for each tree, the number of such pairs is the number of pairs of nodes where the distance is even.\n\nSo, for each tree component, the minimal t is 1, and the number of ways is the count of such pairs.\n\nBut wait, another possibility is that the component is already cyclic but has only even-length cycles. In that case, adding an edge that forms an odd-length cycle would be needed.\n\nWait, but if the component is already cyclic, but all cycles are even, then adding any edge could create an odd cycle. Or maybe not.\n\nWait, no. Adding an edge could create multiple new cycles, including possibly an odd one.\n\nWait, for example, suppose the component is a cycle of even length. Then, adding an edge between two nodes that are two apart in the original cycle would create a triangle, which is an odd cycle.\n\nWait, perhaps in a connected component that is already cyclic, but with all cycles even, adding any single edge could create an odd cycle.\n\nSo, in that case, the minimal t is 1, and the number of ways is the number of possible edges that can be added to create an odd cycle.\n\nWait, but how do we compute that?\n\nThis is getting a bit complicated. Let me try to outline the steps:\n\n1. Check each connected component.\n\n   For each component, determine if it has an odd cycle. If any component has an odd cycle, then t=0, w=1.\n\n   Else, proceed.\n\n2. For each component, compute the minimal number of edges to add to create an odd cycle, and the number of ways.\n\n   The options are:\n\n   a) For a tree: adding one edge, which creates a cycle of length d(u, v)+1. We need d(u, v) to be even. So, the number of such pairs is the count of even-distance node pairs.\n\n   b) For a component that is a cycle of even length: adding any single edge that connects two nodes at an odd distance in the cycle (so that the new edge creates a cycle of length 2+1=3, which is odd). Alternatively, perhaps adding an edge that creates a triangle.\n\nWait, no. Suppose the original cycle is even. Adding an edge between two nodes that are adjacent in the original cycle would create a cycle of length 3, which is odd.\n\nYes, because the new edge connects two adjacent nodes in the original cycle, creating a triangle.\n\nSo, in that case, the number of such edges is the number of edges in the original cycle.\n\nBut wait, the component is a cycle. So, it has n edges for n nodes. Each edge is between consecutive nodes.\n\nAdding any of these edges would create a triangle, which is an odd cycle.\n\nSo, the number of ways is the number of edges in the component.\n\nSo, for a component that is a cycle with even length, the minimal t is 1, and the number of ways is the number of edges in the component.\n\nWait, but the component may have multiple cycles, some even and some odd. Like if it's a graph with both even and odd cycles. But in our case, the initial check would have found that there's already an odd cycle, so this situation wouldn't be considered here.\n\nSo, for each component:\n\nIf it has an odd cycle, then it's done.\n\nElse:\n\n   If it's a tree, then to create an odd cycle, add one edge where the distance between u and v is even. The number of ways is the number of such pairs.\n\n   Else, if it's a cycle of even length, then adding any edge from the existing edges in the cycle will create a triangle, which is an odd cycle. So, the number of ways is the number of edges in the component.\n\nWait, but perhaps the component has more than just cycles. Like, it's a graph that's not a tree nor a single cycle. For example, it could have multiple cycles, but all even. Then, adding an edge could create an odd cycle.\n\nIn such a case, how do we compute the minimal t and the number of ways?\n\nHmm, this is getting tricky.\n\nAlternatively, perhaps the minimal t is 1 for all cases where the component doesn't have an odd cycle, but the way to compute the number of ways varies.\n\nWait, but I think that for each connected component, the minimal edges needed to create an odd cycle is either 1 (if it's a tree or a cycle with even length), or more if it's a more complex graph.\n\nWait, perhaps not. Because in some cases, adding one edge might not be sufficient. For example, if the component is a graph with multiple even-length cycles, but adding one edge may not create an odd cycle. So, we might need to add more edges.\n\nBut that complicates things. So, perhaps the minimal t is either 1 or 2.\n\nWait, perhaps for any component that doesn't have an odd cycle, the minimal t is 1. Because adding one edge can create an odd cycle in most cases.\n\nWait, let's think: for a tree, adding one edge creates exactly one cycle. So, if that cycle is odd, then done. Otherwise, no. But for a tree, it's possible to have a pair of nodes at even distance, which when connected, creates an odd cycle.\n\nSo, the minimal t is 1 for trees.\n\nFor a component that's a cycle of even length, adding one edge between adjacent nodes creates a triangle, which is odd.\n\nSo, again, minimal t is 1.\n\nWhat about a component that's a graph with multiple even-length cycles but no odd ones? Adding one edge may create an odd cycle.\n\nBut I'm not sure. For example, imagine a graph that is a square (4 nodes, 4 edges, each node connected in a cycle). This is an even cycle. Adding an edge between any two adjacent nodes creates a triangle (odd cycle). So t=1, ways=4.\n\nAnother example: take two triangles connected by a single edge. Wait, no, that's a connected component with an odd cycle (each triangle is odd), so that's already handled.\n\nAlternatively, imagine a graph that's a hexagon (6 nodes, 6 edges). Adding an edge between two opposite nodes (distance 3) creates a triangle? No, wait, the distance is 3, so adding that edge would create a cycle of length 4, which is even. Hmm, that's a problem.\n\nWait, in a hexagon, adding an edge between nodes 1 and 4 would create a cycle 1-2-3-4-1, which is length 4 (even). So, that's not good.\n\nBut adding an edge between adjacent nodes (like 1-2) creates a triangle 1-2-3-1, which is odd.\n\nAh right. So in the hexagon case, adding any edge between adjacent nodes in the original cycle creates a triangle, which is an odd cycle.\n\nSo, in that case, the number of ways is 6 (the number of edges in the component).\n\nSo, the minimal t is 1, and the ways are 6.\n\nSo, for any component that is a cycle (even length), adding one edge between adjacent nodes creates an odd cycle. So, the minimal t is 1, and the number of ways is the number of edges in the component.\n\nBut what about a component that is more complex, like a cube (each face is a square). It's a 3D structure, but in graph terms, it's a planar graph with cycles of even length. Adding one edge may not create an odd cycle.\n\nWait, but in the cube, each face is a square (even). But perhaps there are other cycles, like the space diagonals, but I'm not sure.\n\nAlternatively, perhaps adding an edge between two nodes that are two steps apart in some cycle could create an odd cycle.\n\nWait, maybe I'm overcomplicating. Perhaps for any component that doesn't have an odd cycle, the minimal t is 1, and the number of ways is either the number of edges (for cycles) or the number of node pairs with even distances (for trees).\n\nBut I'm not sure about more complex graphs. Maybe for all components that don't have an odd cycle, the minimal t is 1, and the number of ways is determined based on the component's structure.\n\nSo, putting it all together:\n\nWe need to process each connected component.\n\nFor each component:\n\n- If it has an odd cycle: then the answer is t=0, w=1.\n\n- Else:\n\n   - If it's a tree: then the minimal t is 1, and the number of ways is the number of node pairs at even distance.\n\n   - Else (it's a cyclic graph but all cycles are even):\n\n      - Minimal t is 1, and the number of ways is the number of edges in the component.\n\nSo, the overall approach is:\n\n1. For each connected component, determine whether it has an odd cycle.\n\n   How?\n\n   Well, a connected component has an odd cycle if and only if it has a node with an odd degree in the component's induced subgraph.\n\n   Because, in a tree, all nodes have degrees less than the number of nodes. Wait, no, that's not correct. Wait, the presence of an odd cycle implies that the component's graph has an Eulerian trail, but perhaps that's not helpful.\n\n   Alternatively, a connected component has an odd cycle if and only if the number of nodes with odd degree is at least two. Or perhaps not.\n\n   Wait, according to graph theory, a connected graph has an Eulerian circuit (which is a cycle that uses every edge exactly once) if and only if every node has even degree.\n\n   So, if a connected component has an Eulerian circuit, then all cycles in it must be even? Or not necessarily.\n\n   Hmm, perhaps another approach: the component has an odd cycle if and only if it has at least one node with an odd degree.\n\n   Because, in a tree, all nodes have degrees >=1, but no cycles. So, in a tree, all nodes have even degrees except the leaves, which have degree 1 (odd). So, a tree with more than one node has at least two leaves, hence at least two nodes with odd degrees. So, in a tree, the number of nodes with odd degree is two or more.\n\n   So, for a connected component, the presence of an odd cycle requires that the component has at least two nodes with odd degrees.\n\n   Wait, no. Because, for a cycle of even length, all nodes have even degrees. So, in that case, the component has zero nodes with odd degrees.\n\n   So, perhaps the correct condition is: a connected component has an odd cycle if and only if it has at least one node with an odd degree, and the component is not a tree.\n\n   Wait, no. Because in a tree, all nodes have even degrees except for the leaves (degree 1, which is odd). So, trees have multiple nodes with odd degrees. So, a tree cannot have an odd cycle.\n\n   So, the correct condition is: a connected component has an odd cycle if and only if it has at least one node with an odd degree and it's not a tree.\n\n   So, for each connected component, we can compute the number of nodes with odd degrees.\n\n   If the component is a tree: number of nodes with odd degree is non-zero (two or more).\n\n   Else, if the component is not a tree and has at least one node with an odd degree: then it has an odd cycle.\n\n   Else, the component is a tree or a cycle with all even degrees (so no odd cycle).\n\nWait, perhaps the condition is that the component has an odd cycle if and only if it is not a tree and the number of nodes with odd degree is at least one.\n\nNo, wait: in a tree, the number of nodes with odd degree is at least two. So, a tree has no cycles, so no odd cycles.\n\nIn a connected component that's not a tree, if it has exactly two nodes with odd degrees, then it has an Eulerian path, but not necessarily a cycle. But if it has more than two nodes with odd degrees, then it's impossible to have an Eulerian path, but it still may have cycles.\n\nWait, perhaps I'm getting stuck here. Let me think about the algorithm:\n\nFor each connected component:\n\n   Compute the degrees of each node.\n\n   Count the number of nodes with odd degree.\n\n   If the component is a tree: it has at least two nodes with odd degrees, but no cycles.\n\n   Else, if the number of nodes with odd degrees is >=2: then it has an odd cycle.\n\n   Else, the component is a cycle of even length, and thus no odd cycles.\n\nSo, the steps for each component are:\n\n1. Determine if it's a tree or not.\n\n   A tree has exactly n-1 edges, and is connected.\n\n   So, for a connected component with c nodes, if the number of edges is c-1, it's a tree.\n\n2. If it's a tree: no cycles, so no odd cycles. So, to create an odd cycle, we need to add edges.\n\n3. Else, if the component has an odd number of nodes with odd degrees: then it has an odd cycle.\n\n   Because, in a connected graph, the number of nodes with odd degrees must be even. So, if it's odd, then the graph has at least one cycle, which is of odd length.\n\n   Because, in a connected graph, the sum of degrees is even. So, the number of nodes with odd degrees must be even. So, if it's >=2 and even, it may have even cycles, but if it's >=2 and odd, it must have an odd cycle.\n\n   So, in our case, for a connected component that's not a tree:\n\n   - If the number of nodes with odd degrees is >=2 and even: then it has even cycles, but perhaps also some odd cycles.\n\n   Wait, but if the number is even, then it's possible that all cycles are even. Or, it may have some odd cycles.\n\n   Hmm, this is getting complicated.\n\nAlternatively, perhaps the correct condition is: a connected component has an odd cycle if and only if it is not a tree and the number of nodes with odd degrees is at least one (but since in a connected graph, it's even, this may not hold).\n\nWait, no. Because in a connected graph, the number of nodes with odd degrees must be even. So, the number of nodes with odd degrees can't be odd.\n\nSo, in a connected component, the number of nodes with odd degrees is even.\n\nThus, the condition for the component having an odd cycle is:\n\nEither:\n\n   a) The component is a tree → no cycles, so no.\n\nOR\n\n   b) The component is not a tree, and it has at least two nodes with odd degrees. Then, it has an odd cycle.\n\nWait, no. Because if a connected component is not a tree and has exactly two nodes with odd degrees, it has an Eulerian path, but no cycles. So, no odd cycles.\n\nWait, no. Because a connected graph with exactly two nodes of odd degree has an Eulerian path, but no cycles. So, it's acyclic except for the path.\n\nSo, for a connected component that's not a tree:\n\n   If the number of nodes with odd degree is zero → it's a cycle of even length.\n\n   If the number is two → it's a connected graph with an Eulerian path, but no cycles.\n\n   If the number is four or more → then it has at least one cycle, and possibly an odd cycle.\n\nSo, perhaps the correct condition is:\n\nA connected component has an odd cycle if and only if it is not a tree and the number of nodes with odd degree is at least two.\n\nWait, no. Because a connected component that is not a tree and has exactly two nodes with odd degrees does not have any cycles (except for the Eulerian path), so it can't have an odd cycle.\n\nOnly when the number of nodes with odd degrees is >= four, or when the component has a cycle plus some extra connections leading to an odd cycle.\n\nHmm, this is getting too tangled.\n\nMaybe the better approach is to consider that a connected component has an odd cycle if it is not a tree and has at least one node with an odd degree. But given that in a connected graph, the number of nodes with odd degrees is even, this would mean that the number is at least two.\n\nWait, perhaps I'm overcomplicating. Let me think about the problem differently.\n\nThe key is to find if the component has any cycle of odd length. So, perhaps for each connected component, we can perform a BFS-based approach to detect the existence of an odd-length cycle.\n\nBut that might be computationally expensive for large n.\n\nAlternatively, perhaps the following is true:\n\nIn a connected component, if the number of nodes with odd degree is at least two and the component is not a tree, then the component has an odd cycle.\n\nBecause, in such a case, the component has an Eulerian trail but also has some cycles.\n\nWait, perhaps that's not necessarily true. Because if the component is a connected graph with two nodes of odd degrees, it has an Eulerian path but no cycles.\n\nSo, perhaps the condition is:\n\nA connected component has an odd cycle if and only if it is not a tree and the number of nodes with odd degrees is >= 2 and the component is not a tree.\n\nWait, no. Because a connected component that is not a tree and has exactly two nodes with odd degrees has no cycles (except the path), so no odd cycles.\n\nSo, perhaps the correct condition is:\n\nA connected component has an odd cycle if and only if it is not a tree and the number of nodes with odd degrees is >=4.\n\nWait, but that's not necessarily true. For example, a graph with a triangle (three nodes, three edges). It has three nodes each with degree 2 (even), but the component is a triangle, which is an odd cycle. So, in this case, the number of nodes with odd degrees is zero, which contradicts the earlier condition.\n\nSo, that approach is flawed.\n\nHmm. Maybe the correct condition is:\n\nA connected component has an odd cycle if and only if it has an Euler tour (i.e., all nodes have even degrees) and it's not a tree.\n\nWait, no. Because a tree has no cycles, and a connected graph with all even degrees is a single cycle or multiple cycles.\n\nWait, perhaps the correct way is:\n\nA connected component has an odd cycle if it's not a tree and the number of nodes with odd degrees is at least one.\n\nBut since in a connected graph, the number of nodes with odd degrees is even, this can't be.\n\nSo, perhaps the correct condition is:\n\nA connected component has an odd cycle if it's not a tree and the number of nodes with odd degrees is >= 2.\n\nBut in a connected graph, the number of nodes with odd degrees must be even.\n\nSo, the number of nodes with odd degrees can be 0, 2, 4, etc.\n\nThus, for a connected component that is not a tree:\n\n- If the number of nodes with odd degrees is 0 → it's a cycle of even length.\n\n- If it's 2 → it has an Eulerian path, no cycles, so no odd cycles.\n\n- If it's >=4 → it has cycles, and at least one odd cycle.\n\nWait, but how to confirm that?\n\nLet me think of examples.\n\nExample 1: A triangle (3 nodes, 3 edges). Number of nodes with odd degrees: 3. Which is odd, but wait, in reality, each node has degree 2, which is even. So, no, in this case, the number is zero. So, perhaps my earlier thought was wrong.\n\nWait, in a triangle, each node has degree 2 (even). So, the number of nodes with odd degrees is zero.\n\nThus, a triangle has zero nodes with odd degrees, but it has an odd cycle.\n\nSo, the condition is not based on the number of nodes with odd degrees.\n\nHmm, this is confusing.\n\nAlternative approach: perhaps to find whether a component has an odd cycle, we can perform a BFS-based search, tracking the distance from the starting node. If during BFS, we find a back edge that forms a cycle of odd length, then the component has an odd cycle.\n\nBut for the purposes of competitive programming, this may not be efficient for large n and m.\n\nSo, perhaps for each connected component, we can compute whether it has an odd cycle as follows:\n\n- If the component is a tree: no.\n\n- Else, if the component has any cycle (i.e., it's not a tree) and the length of that cycle is odd.\n\nBut determining the parity of any cycle in the component is difficult.\n\nAlternatively, perhaps the parity of any cycle in the component can be determined by checking the parity of the number of edges in a spanning tree.\n\nWait, but I'm not sure.\n\nPerhaps I'm stuck, and I need to think of the problem from a different angle.\n\nSo, let's restate the problem:\n\nWe need to find the minimal number of edges to add to the graph to form a simple cycle of odd length, consisting of more than one vertex. Also, compute the number of ways to do this.\n\nThe output is t and w.\n\nNow, t is the minimal number of edges to add. So, for each connected component, compute the minimal edges needed to create an odd cycle in that component, and then choose the minimal across all components.\n\nBut how do the components interact? Because adding edges to one component may allow it to form a cycle, but perhaps combining with another component can create a larger cycle.\n\nWait, but adding edges can't connect two components unless we add edges between them. But then, the merged component may have a larger structure.\n\nBut for the minimal t, perhaps it's better to consider only individual components, because connecting two components would require adding at least one edge, which may not be better than the minimal t for a single component.\n\nSo, perhaps the minimal t is the minimal between:\n\na) The minimal edges needed to create an odd cycle in a single component.\n\nb) The minimal edges needed to connect two components and then create an odd cycle in the merged component.\n\nBut this seems complicated.\n\nAlternatively, perhaps the minimal t is the minimal between the minimal edges needed for any single component, or the sum of the minimal edges needed for two components to form a bridge between them and then create an odd cycle.\n\nBut how?\n\nAlternatively, perhaps the minimal t is the minimal t among all components' individual t, because connecting components would require adding edges to bridge them, which would require at least one edge, and then adding more edges to form a cycle.\n\nWhich could be more than the individual t.\n\nThus, perhaps the minimal t is determined by the individual components.\n\nSo, the approach is:\n\n1. For each connected component, compute the minimal t_i and the number of ways w_i to create an odd cycle in that component.\n\n   t_i is 0 if the component has an odd cycle.\n\n   Else:\n\n      If the component is a tree: t_i = 1, w_i = number of node pairs with even distance.\n\n      Else: t_i = 1, w_i = number of edges in the component.\n\n2. Among all components, find the minimal t_i. That's the overall t.\n\n   Sum the corresponding w_i's for those components that contribute to this minimal t.\n\n3. Additionally, consider the possibility of connecting two components, which may allow for a lower t.\n\nWait, but that's the part I'm not sure about.\n\nWait, perhaps the minimal t can sometimes be achieved by combining two components. For example, suppose component A is a tree requiring t=1, and component B is a tree requiring t=1. Combining them requires adding one edge to connect them, but then the combined component has two trees connected, but the overall structure may not form a cycle.\n\nWait, perhaps that's not sufficient. So, perhaps combining two components would require more than one edge to form a cycle.\n\nAlternatively, perhaps the minimal t is indeed determined by the individual components, and the case where two components are connected is not useful for a lower t.\n\nThus, perhaps the steps are:\n\nCompute for each component:\n\nIf it has an odd cycle: contribute t=0, w=1.\n\nElse, compute its own t and w.\n\nThen, the overall t is the minimal t across all components. The w is the sum of the w_i's for the components that achieve this minimal t.\n\nBut what if combining two components can result in a lower t?\n\nWait, suppose component A is a tree (t=1, w=5), and component B is a tree (t=1, w=3). Combining them requires adding one edge, which makes the combined component a single tree with two connected components, but that's not a cycle. So, no.\n\nAlternatively, perhaps combining two components requires more edges to form a cycle.\n\nSo, perhaps the minimal t is indeed the minimal t of individual components.\n\nThus, the plan is:\n\nFor each connected component, compute whether it has an odd cycle.\n\nIf any component has an odd cycle, then t=0, w=1.\n\nElse, for each component, compute t_i and w_i as follows:\n\nIf the component is a tree: t_i=1, w_i is the number of pairs of nodes with even distance.\n\nElse: t_i=1, w_i is the number of edges in the component.\n\nThen, the minimal t is the minimal t_i across all components, and the w is the sum of w_i for those components with t_i equal to the minimal t.\n\nBut wait, what about components that are not trees and have even cycles? For those, adding one edge between adjacent nodes creates a triangle, which is an odd cycle. So, t_i=1, w_i is the number of edges.\n\nBut what about components that are not trees and have even cycles but also have other structures that could allow for an odd cycle with fewer edges?\n\nI think that in such cases, the minimal t is still 1.\n\nSo, putting it all together.\n\nThe algorithm steps are:\n\n1. Read the input graph.\n\n2. Split the graph into connected components.\n\n3. For each component:\n\n   a) Check if it's a tree:\n\n      i) A tree has exactly c-1 edges, where c is the number of nodes in the component.\n\n      ii) If yes, then it's a tree.\n\n   b) Check if the component has an odd cycle:\n\n      i) For a tree: no.\n\n      ii) For a non-tree component:\n\n          - Compute the number of nodes with odd degrees.\n\n          - If the component is not a tree and the number of nodes with odd degrees is at least two, then it has an odd cycle.\n\n   c) If the component has an odd cycle: add it to a list of 'good' components, which contribute t=0 and w=1.\n\n4. If any 'good' component exists, output t=0 and w=1.\n\n5. Else:\n\n   a) For each component, compute t_i and w_i:\n\n      i) For a tree:\n\n         - t_i = 1.\n\n         - Compute the number of pairs of nodes with even distance in the tree. This is the number of ways.\n\n      ii) For a non-tree component:\n\n         - t_i = 1.\n\n         - The number of edges in the component is w_i.\n\n   b) Collect all t_i and w_i.\n\n   c) Find the minimal t_i across all components. Let this be min_t.\n\n   d) Sum the w_i's of all components where t_i == min_t. Let this be total_w.\n\n   e) Output min_t and total_w.\n\nSo, the crux now is how to compute, for each tree component, the number of pairs of nodes with even distance.\n\nHow to compute that?\n\nFor a tree, the distance between any two nodes is unique.\n\nWe can compute for each node, the number of nodes at even distance and the number of nodes at odd distance.\n\nThen, the total number of even-distance pairs is the sum over all nodes of (count_even / 2), but wait, that's not correct because each pair is counted twice.\n\nAlternatively, for each node u, the number of nodes v where the distance between u and v is even is E_u.\n\nThen, the total number of even-distance pairs is (sum(E_u) ) / 2.\n\nBecause each pair (u, v) is counted once for u and once for v.\n\nSo, the steps for a tree component are:\n\n- Perform BFS or DFS to compute the distance from each node to all others.\n\n- For each node u, count the number of nodes v where distance(u, v) is even.\n\n- Sum all E_u and divide by 2.\n\nSo, the number of even-distance pairs is sum(E_u)/2.\n\nNow, the question is, how to compute the distance from each node to all others efficiently.\n\nBut for a tree with c nodes, BFS from each node is O(c^2), which is acceptable for small c, but could be a problem for large c.\n\nWait, but for n up to 1e5 or something, this approach is not feasible. However, in competitive programming, the constraints are usually manageable.\n\nAssuming that n is up to 1e5, but for each component, the BFS is manageable.\n\nWait, but if a component has 1e5 nodes, performing BFS from each node is O(1e10), which is impossible.\n\nSo, perhaps we need a smarter approach.\n\nAlternative approach for counting even-distance pairs in a tree:\n\nIn a tree, the distance between two nodes u and v is equal to the depth[u] + depth[v] - 2*depth[lca(u, v)], where lca is the lowest common ancestor.\n\nBut computing this for all pairs is O(n^2), which is not feasible.\n\nHmm, but perhaps there's a pattern.\n\nIn a tree, for a given node u, the number of nodes at even distance from u is equal to the number of nodes in the subtree where the depth difference is even.\n\nBut I'm not sure.\n\nAlternatively, note that for a tree, the distance between u and v is even if and only if u and v are in the same parity level in the BFS tree.\n\nWait, perhaps the distance between u and v is even if their depths have the same parity.\n\nBecause, the distance is depth[u] + depth[v] - 2 * depth[lca].\n\nIf depth[u] and depth[v] are both even or both odd, then their sum is even, and subtracting 2*d (even) gives an even result.\n\nThus, the distance between u and v is even if and only if u and v have the same parity in their depths.\n\nSo, for each node, the number of nodes at even distance is the number of nodes with the same depth parity.\n\nThus, for a tree, the number of even-distance pairs is the sum over all nodes of the count of nodes with the same parity in their depth, divided by 2.\n\nWait, no. Because for each node u, the number of nodes v with same parity is s. Then, the number of pairs involving u is s*(s-1)/2, but that's for unordered pairs.\n\nWait, perhaps the total number of even-distance pairs is the sum for each node u of the count of nodes v where depth parity of v is the same as u's, minus the number of u itself.\n\nThen, the total is (sum for each u of count_u) / 2, where count_u is the number of nodes with same parity as u.\n\nBecause each pair (u, v) is counted once in u's count and once in v's count.\n\nSo, for each node u, count_u is the number of nodes v where depth[v] has the same parity as depth[u]. Then, the total even-distance pairs is (sum(count_u for all u)) / 2.\n\nBecause each pair is counted twice",
    "response": "To solve this problem, we need to determine the minimum number of edges to add to a graph to form a simple cycle of odd length and count the number of ways to achieve this. The graph is undirected, has no loops or parallel edges, and may not be connected.\n\n### Approach\n1. **Identify Connected Components**: The graph is split into connected components. Each component is processed individually.\n2. **Check for Existing Odd Cycles**: For each component, check if it already contains an odd-length cycle. If any component has an odd cycle, the result is immediately known: 0 edges to add and 1 way.\n3. **Tree Components**: If a component is a tree (has exactly one fewer edge than nodes), compute the minimum edges needed and the number of ways to form an odd cycle by adding one edge between nodes at even distances.\n4. **Non-Tree Components**: For non-tree components, determine if they can form an odd cycle by adding one edge. The number of ways is based on the number of edges in the component.\n5. **Calculate Results**: Find the minimum edges needed across all components and sum the ways for those components contributing to this minimum.\n\n### Solution Code\n```python\nimport sys\nfrom collections import deque\n\ndef main():\n    sys.setrecursionlimit(1 << 25)\n    n, m = map(int, sys.stdin.readline().split())\n    edges = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b = map(int, sys.stdin.readline().split())\n        a -= 1\n        b -= 1\n        edges[a].append(b)\n        edges[b].append(a)\n    \n    visited = [False] * n\n    components = []\n    \n    for i in range(n):\n        if not visited[i]:\n            q = deque()\n            q.append(i)\n            visited[i] = True\n            comp_nodes = []\n            comp_edges = 0\n            while q:\n                u = q.popleft()\n                comp_nodes.append(u)\n                for v in edges[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        q.append(v)\n            c = len(comp_nodes)\n            e = 0\n            for u in comp_nodes:\n                for v in edges[u]:\n                    if v in comp_nodes_set:\n                        e += 1\n            comp_edges = e\n            components.append((comp_nodes, c, e))\n            comp_nodes_set = set(comp_nodes)\n    \n    good = False\n    for comp in components:\n        nodes, c, e = comp\n        if e == c - 1:\n            is_tree = True\n        else:\n            degrees = [0] * c\n            for u in range(c):\n                degrees[u] = len(edges[nodes[u]])\n            odd_degrees = sum(1 for d in degrees if d % 2 != 0)\n            if odd_degrees >= 2:\n                is_tree = False\n                has_odd_cycle = True\n            else:\n                is_tree = False\n                has_odd_cycle = False\n        if not is_tree:\n            if odd_degrees >= 2:\n                good = True\n    \n    if good:\n        print(\"0 1\")\n        return\n    \n    min_t = float('inf')\n    total_w = 0\n    \n    for comp in components:\n        nodes, c, e = comp\n        if e == c - 1:\n            t_i = 1\n            w_i = 0\n            depth = {}\n            q = deque()\n            q.append(nodes[0])\n            depth[nodes[0]] = 0\n            while q:\n                u = q.popleft()\n                for v in edges[u]:\n                    if v not in depth:\n                        depth[v] = depth[u] + 1\n                        q.append(v)\n            same_parity = 0\n            for node in nodes:\n                parity = depth[node]\n                cnt = 0\n                for other in nodes:\n                    if other == node:\n                        continue\n                    if depth[other] % 2 == parity % 2:\n                        cnt += 1\n                same_parity += cnt\n            total = same_parity // 2\n            w_i = total\n        else:\n            t_i = 1\n            w_i = e\n        if t_i < min_t:\n            min_t = t_i\n            total_w = w_i\n        elif t_i == min_t:\n            total_w += w_i\n    \n    print(f\"{min_t} {total_w}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The graph is read and stored as an adjacency list.\n2. **Connected Components**: Using BFS, each connected component is identified, and its nodes, size, and edges are recorded.\n3. **Checking for Odd Cycles**: For each component, check if it forms an odd cycle by examining node degrees.\n4. **Handling Trees and Non-Trees**: For trees, compute the number of pairs of nodes with even distances. For non-trees, the number of ways is based on the component's edges.\n5. **Result Calculation**: Determine the minimum edges needed and sum the ways to form the cycle, then output the results.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef main():\n    sys.setrecursionlimit(1 << 25)\n    n, m = map(int, sys.stdin.readline().split())\n    edges = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b = map(int, sys.stdin.readline().split())\n        a -= 1\n        b -= 1\n        edges[a].append(b)\n        edges[b].append(a)\n    \n    visited = [False] * n\n    components = []\n    \n    for i in range(n):\n        if not visited[i]:\n            q = deque()\n            q.append(i)\n            visited[i] = True\n            comp_nodes = []\n            comp_edges = 0\n            while q:\n                u = q.popleft()\n                comp_nodes.append(u)\n                for v in edges[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        q.append(v)\n            c = len(comp_nodes)\n            e = 0\n            for u in comp_nodes:\n                for v in edges[u]:\n                    if v in comp_nodes_set:\n                        e += 1\n            comp_edges = e\n            components.append((comp_nodes, c, e))\n            comp_nodes_set = set(comp_nodes)\n    \n    good = False\n    for comp in components:\n        nodes, c, e = comp\n        if e == c - 1:\n            is_tree = True\n        else:\n            degrees = [0] * c\n            for u in range(c):\n                degrees[u] = len(edges[nodes[u]])\n            odd_degrees = sum(1 for d in degrees if d % 2 != 0)\n            if odd_degrees >= 2:\n                is_tree = False\n                has_odd_cycle = True\n            else:\n                is_tree = False\n                has_odd_cycle = False\n        if not is_tree:\n            if odd_degrees >= 2:\n                good = True\n    \n    if good:\n        print(\"0 1\")\n        return\n    \n    min_t = float('inf')\n    total_w = 0\n    \n    for comp in components:\n        nodes, c, e = comp\n        if e == c - 1:\n            t_i = 1\n            w_i = 0\n            depth = {}\n            q = deque()\n            q.append(nodes[0])\n            depth[nodes[0]] = 0\n            while q:\n                u = q.popleft()\n                for v in edges[u]:\n                    if v not in depth:\n                        depth[v] = depth[u] + 1\n                        q.append(v)\n            same_parity = 0\n            for node in nodes:\n                parity = depth[node]\n                cnt = 0\n                for other in nodes:\n                    if other == node:\n                        continue\n                    if depth[other] % 2 == parity % 2:\n                        cnt += 1\n                same_parity += cnt\n            total = same_parity // 2\n            w_i = total\n        else:\n            t_i = 1\n            w_i = e\n        if t_i < min_t:\n            min_t = t_i\n            total_w = w_i\n        elif t_i == min_t:\n            total_w += w_i\n    \n    print(f\"{min_t} {total_w}\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 570,
        "completion_token_count": 1089,
        "thoughts_token_count": 8193
    }
}