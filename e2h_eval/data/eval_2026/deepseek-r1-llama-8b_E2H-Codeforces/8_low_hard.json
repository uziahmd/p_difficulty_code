{
    "start": 1758103786.3127613,
    "end": 1758103929.2911837,
    "start-formatted": "2025-09-17 19:09 KST",
    "end-formatted": "2025-09-17 19:12 KST",
    "gpu": 2,
    "pid": 8,
    "use_openrouter": false,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "Okay, so I have this problem where I need to determine the direction of each edge in a flow network such that the resulting graph satisfies certain conditions. Let me try to understand what's being asked here.\n\nThe problem states that we have an undirected graph with n vertices and m edges. The source is vertex 1, and the sink is vertex n. Each edge has a certain flow value. My task is to assign a direction to each edge (either ai → bi or bi → ai) such that:\n\n1. For every vertex v (except the source and sink), the sum of incoming flows equals the sum of outgoing flows.\n2. The source has no incoming edges.\n3. The resulting directed graph has no cycles.\n\nAdditionally, the total flow should be the maximum possible. But since the input ensures a solution exists, I don't have to worry about that part.\n\nHmm. So how do I approach this? Let's think.\n\nFirst, I remember that in a flow network, the maximum flow can be found using algorithms like the Dinic's algorithm. But this problem isn't directly about computing the flow; it's about determining the directions after the flow is already determined.\n\nWait, but maybe the directions are determined by the residual graph used in the max-flow computation. Because during the flow computation, edges are considered as either forward or backward (residual). So perhaps the direction of each original edge in the flow corresponds to the way it was used in the augmenting path steps.\n\nBut how can I reconstruct the direction for each edge based on the max-flow result?\n\nAlternatively, perhaps I can model this as a graph where each node (except the source and sink) must have equal in-degree and out-degree. Wait, no: for all v except source and sink, in-degree equals out-degree. For the source, in-degree is zero. For the sink, the out-degree is whatever the flow is, but the in-degree can be anything.\n\nWait, but in the directed graph, each edge contributes to the in-degree and out-degree of its endpoints. So for each edge (ai, bi, ci), if we direct it from ai to bi, then ai's out-degree increases by ci, and bi's in-degree increases by ci. If directed the other way, vice versa.\n\nSo the problem reduces to choosing for each edge whether to add ci to the out-degree of ai and in-degree of bi, or the reverse, such that:\n\n- For all v ≠ 1, n: sum of in-degrees = sum of out-degrees.\n- Source has in-degree 0.\n- No cycles exist.\n\nWait, but the sum of in-degrees equals sum of out-degrees for all nodes except possibly the source and sink. Because for the source, in-degree is 0, and for the sink, it's allowed to have any in-degree (but in our case, it's the sink, so the flow goes into it, so it's allowed).\n\nWait, more accurately: the conservation law says that the sum of all flows leaving the source is equal to the sum entering the sink. For intermediate nodes, the sum of flows in equals the sum of flows out.\n\nSo for each node v (excluding source and sink), the sum of the flows from edges directed towards v (in-degree) must equal the sum of flows from edges directed away from v (out-degree).\n\nSo the problem is to assign a direction to each edge such that this condition holds for all non-source/sink nodes, and also ensure that the directed graph has no cycles.\n\nBut how do I find such a direction?\n\nAn alternative approach: think of the problem as building a graph where for each edge (a, b), we choose the direction such that the flow conservation is satisfied.\n\nLet me think about the degrees. Each edge contributes ci to either a's out or b's in, etc. So for each node v, the sum of the chosen directions' ci for edges incident to v must balance: the sum of outgoing edges equals the sum of incoming edges, except for source and sink.\n\nWait, but for the source, the sum of outgoing edges is the total flow, and for the sink, the sum of incoming edges is the total flow. So the problem is to assign directions such that for all v != 1 and v != n, the sum of edges leaving v equals the sum of edges entering v.\n\nBut how do I compute this?\n\nI recall that in the context of the max-flow algorithm, each edge in the residual graph represents a possible backward flow. Maybe the directions of the edges in the residual graph can help us determine the direction of the original edges.\n\nWait, perhaps I can model the problem as follows: the direction of each edge in the original undirected graph will be set based on whether it's part of the residual graph or not. Or perhaps the other way around.\n\nAlternatively, perhaps the direction of each edge in the flow network is determined by the BFS tree used in the max-flow algorithm. For example, in Din",
    "response": "To solve this problem, we need to determine the direction of each edge in a flow network such that the resulting directed graph satisfies specific conditions. The goal is to ensure that the sum of incoming flows equals the sum of outgoing flows for all intermediate nodes, the source has no incoming edges, and the graph has no cycles.\n\n### Approach\n1. **Graph Representation**: Represent the given undirected graph using adjacency lists. Each edge will be stored with its flow value.\n2. **Max-Flow Computation**: Use the Dinic's algorithm to compute the maximum flow from the source (vertex 1) to the sink (vertex n). This helps in determining the direction of the edges based on the residual graph.\n3. **Residual Graph Analysis**: After computing the max-flow, analyze the residual graph. For each edge, if it is part of the residual graph, it indicates that the original edge was used in the reverse direction during the flow computation. Otherwise, it remains in its original direction.\n4. **Direction Assignment**: Based on the residual graph, assign the direction of each edge such that the flow conservation and cycle-free condition are satisfied.\n\n### Solution Code\n```python\nimport sys\nfrom collections import deque\n\nclass Edge:\n    def __init__(self, to, rev, capacity):\n        self.to = to\n        self.rev = rev\n        self.capacity = capacity\n\nclass Dinic:\n    def __init__(self, n):\n        self.size = n\n        self.graph = [[] for _ in range(n)]\n    \n    def add_edge(self, fr, to, cap):\n        forward = Edge(to, len(self.graph[to]), cap)\n        backward = Edge(fr, len(self.graph[fr]), 0)\n        self.graph[fr].append(forward)\n        self.graph[to].append(backward)\n    \n    def bfs_level(self, s, t, level):\n        q = deque()\n        level[:] = [-1]*self.size\n        level[s] = 0\n        q.append(s)\n        while q:\n            v = q.popleft()\n            for edge in self.graph[v]:\n                if edge.capacity > 0 and level[edge.to] == -1:\n                    level[edge.to] = level[v] + 1\n                    q.append(edge.to)\n                    if edge.to == t:\n                        return\n        return\n    \n    def dfs_flow(self, v, t, flow, level, ptr):\n        if v == t:\n            return flow\n        while ptr[v] < len(self.graph[v]):\n            edge = self.graph[v][ptr[v]]\n            if edge.capacity > 0 and level[v] < level[edge.to]:\n                min_flow = min(flow, edge.capacity)\n                result = self.dfs_flow(edge.to, t, min_flow, level, ptr)\n                if result > 0:\n                    edge.capacity -= result\n                    self.graph[edge.to][edge.rev].capacity += result\n                    return result\n            ptr[v] += 1\n        return 0\n    \n    def max_flow(self, s, t):\n        flow = 0\n        level = [-1]*self.size\n        while True:\n            self.bfs_level(s, t, level)\n            if level[t] == -1:\n                return flow\n            ptr = [0]*self.size\n            while True:\n                f = self.dfs_flow(s, t, float('inf'), level, ptr)\n                if f == 0:\n                    break\n                flow += f\n            level = [-1]*self.size\n        return flow\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    m = int(input[idx+1])\n    idx +=2\n    edges = []\n    for _ in range(m):\n        a = int(input[idx])-1\n        b = int(input[idx+1])-1\n        c = int(input[idx+2])\n        edges.append( (a, b, c) )\n        idx +=3\n    \n    dinic = Dinic(n)\n    for a, b, c in edges:\n        dinic.add_edge(a, b, c)\n    \n    maxf = dinic.max_flow(0, n-1)\n    \n    res = [0]*m\n    for i in range(m):\n        a, b, c = edges[i]\n        u = a\n        v = b\n        if dinic.graph[u][0].to == v and dinic.graph[u][0].capacity > 0:\n            res[i] = 1\n        else:\n            res[i] = 0\n    \n    for r in res:\n        print(1 if r else 0)\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\nThe solution involves reading the input graph, constructing the flow network using the Dinic's algorithm, and then determining the direction of each edge based on the residual graph after computing the maximum flow. The directions are determined by checking if each edge was part of the residual graph or not, ensuring the resulting directed graph satisfies all given conditions.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\nclass Edge:\n    def __init__(self, to, rev, capacity):\n        self.to = to\n        self.rev = rev\n        self.capacity = capacity\n\nclass Dinic:\n    def __init__(self, n):\n        self.size = n\n        self.graph = [[] for _ in range(n)]\n    \n    def add_edge(self, fr, to, cap):\n        forward = Edge(to, len(self.graph[to]), cap)\n        backward = Edge(fr, len(self.graph[fr]), 0)\n        self.graph[fr].append(forward)\n        self.graph[to].append(backward)\n    \n    def bfs_level(self, s, t, level):\n        q = deque()\n        level[:] = [-1]*self.size\n        level[s] = 0\n        q.append(s)\n        while q:\n            v = q.popleft()\n            for edge in self.graph[v]:\n                if edge.capacity > 0 and level[edge.to] == -1:\n                    level[edge.to] = level[v] + 1\n                    q.append(edge.to)\n                    if edge.to == t:\n                        return\n        return\n    \n    def dfs_flow(self, v, t, flow, level, ptr):\n        if v == t:\n            return flow\n        while ptr[v] < len(self.graph[v]):\n            edge = self.graph[v][ptr[v]]\n            if edge.capacity > 0 and level[v] < level[edge.to]:\n                min_flow = min(flow, edge.capacity)\n                result = self.dfs_flow(edge.to, t, min_flow, level, ptr)\n                if result > 0:\n                    edge.capacity -= result\n                    self.graph[edge.to][edge.rev].capacity += result\n                    return result\n            ptr[v] += 1\n        return 0\n    \n    def max_flow(self, s, t):\n        flow = 0\n        level = [-1]*self.size\n        while True:\n            self.bfs_level(s, t, level)\n            if level[t] == -1:\n                return flow\n            ptr = [0]*self.size\n            while True:\n                f = self.dfs_flow(s, t, float('inf'), level, ptr)\n                if f == 0:\n                    break\n                flow += f\n            level = [-1]*self.size\n        return flow\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    m = int(input[idx+1])\n    idx +=2\n    edges = []\n    for _ in range(m):\n        a = int(input[idx])-1\n        b = int(input[idx+1])-1\n        c = int(input[idx+2])\n        edges.append( (a, b, c) )\n        idx +=3\n    \n    dinic = Dinic(n)\n    for a, b, c in edges:\n        dinic.add_edge(a, b, c)\n    \n    maxf = dinic.max_flow(0, n-1)\n    \n    res = [0]*m\n    for i in range(m):\n        a, b, c = edges[i]\n        u = a\n        v = b\n        if dinic.graph[u][0].to == v and dinic.graph[u][0].capacity > 0:\n            res[i] = 1\n        else:\n            res[i] = 0\n    \n    for r in res:\n        print(1 if r else 0)\n\nif __name__ == '__main__':\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 658,
        "completion_token_count": 1045,
        "thoughts_token_count": 1025
    }
}