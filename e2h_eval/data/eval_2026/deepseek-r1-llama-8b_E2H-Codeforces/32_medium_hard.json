{
    "start": 1758281875.678926,
    "end": 1758283571.6744032,
    "start-formatted": "2025-09-19 20:37 KST",
    "end-formatted": "2025-09-19 21:06 KST",
    "gpu": 2,
    "pid": 32,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Array Stabilization\n\nYou are given an array $$$a$$$ consisting of $$$n$$$ integer numbers.Let instability of the array be the following value: $$$\\max\\limits_{i = 1}^{n} a_i - \\min\\limits_{i = 1}^{n} a_i$$$.You have to remove exactly one element from this array to minimize instability of the resulting $$$(n-1)$$$-elements array. Your task is to calculate the minimum possible instability.\n\n## Input\nThe first line of the input contains one integer $$$n$$$ ($$$2 \\le n \\le 10^5$$$) — the number of elements in the array $$$a$$$.The second line of the input contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le 10^5$$$) — elements of the array $$$a$$$.\n\n## Output\nPrint one integer — the minimum possible instability of the array if you have to remove exactly one element from the array $$$a$$$.\n\n## Example\n### Input\n['4\\n1 3 3 7', '2\\n1 100000']\n\n### Output\n['2', '0']\n\n## Note\nIn the first example you can remove $$$7$$$ then instability of the remaining array will be $$$3 - 1 = 2$$$.In the second example you can remove either $$$1$$$ or $$$100000$$$ then instability of the remaining array will be $$$100000 - 100000 = 0$$$ and $$$1 - 1 = 0$$$ correspondingly.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "Okay, so I have this problem where I need to find the minimum possible instability of an array after removing exactly one element. The instability is defined as the difference between the maximum and minimum elements in the array. Hmm.\n\nLet me think about how to approach this. First, I need to understand what happens when we remove each element. For each element, I can compute what the new max and min would be in the remaining array, then calculate the instability and find the minimum among all these possibilities.\n\nBut wait, considering that n can be up to 1e5, iterating through each element and for each, checking the max and min of the remaining elements would be too slow. Because for each element, finding the max and min could take O(n) time, leading to O(n^2), which is definitely not feasible for n=1e5.\n\nSo I need a smarter way to compute this without having to recompute max and min for every possible removal.\n\nHmm. Let's think about the initial max and min of the entire array. When I remove an element, the new max could either stay the same or decrease if I removed the current max. Similarly, the new min could stay the same or increase if I removed the current min.\n\nWait, but that's only true if the element I'm removing is either the max or the min. What if I remove an element that's neither? Then the max and min remain the same as the original array's max and min, right?\n\nWait no. If the array has multiple max elements, like if there are multiple 7s in the first example, then removing one 7 doesn't change the max. Similarly, if the array has multiple mins, removing one doesn't affect the min.\n\nSo perhaps I should precompute:\n\n- The global max and count how many times it appears.\n- The global min and count how many times it appears.\n\nThen, when considering removing an element, if the element is the current max, we need to check if there are other max elements. If yes, then the new max remains the same; otherwise, the new max is the next highest value in the array.\n\nSimilarly for the min.\n\nThis sounds promising. So here's the plan:\n\n1. Compute the global max (max_val) and its count (max_count).\n2. Compute the global min (min_val) and its count (min_count).\n3. For each element a[i] in the array:\n   a. If a[i] == max_val:\n      i. If max_count > 1: Removing this a[i] won't change the max. So the new max is still max_val.\n      ii. Else: The new max is the second_max, which we'll need to find.\n   b. Else if a[i] < max_val: The max remains max_val, since there are other elements with higher values.\n   c. Similarly for min: if a[i] is the min, and its count is 1, then the new min is the second_min. Otherwise, it remains the same.\n4. Once the new max and min are determined after removing a[i], compute the instability and track the minimum across all i.\n\nBut wait, how do I efficiently find the second_max and second_min without scanning the entire array each time?\n\nI think we can precompute the second_max and second_min along with their counts. But let me think about it.\n\nWait, maybe not. Because for each a[i], depending on whether it's the max or min, we may need to adjust the new max or min. So perhaps during the iteration, for each a[i], we can determine what the new max and min would be if we remove it.\n\nLet me outline the steps again:\n\n- Precompute the global max, its count, and the next highest value (second_max). Similarly for min.\n\nHow to compute second_max:\n\nWe can iterate through the array and track the top two max values.\n\nFor example, initialize max1 and max2. For each element:\n\n- If the element is larger than max1, then max2 becomes max1, and max1 becomes this element.\n- Else if the element is larger than max2, then max2 updates.\n\nThis way, after processing all elements, max2 is the second_max. But wait, this only works if there are at least two elements. Also, if there are multiple max1s, then max2 may not capture the second occurrence.\n\nWait, no. For example, if the array is [7,7,5], the max1 is 7, max2 is 5. But if we remove one 7, the max remains 7. So our approach correctly captures that.\n\nSimilarly for min. So the plan is:\n\nCompute:\n\n- max_val, max_count, second_max\n- min_val, min_count, second_min\n\nOnce we have these, for each a[i], we can check if it's equal to max_val or min_val.\n\nCase 1: a[i] is equal to max_val.\n\nIf max_count > 1: after removing a[i], the max remains max_val because there are other instances.\n\nElse: the new max is second_max.\n\nCase 2: a[i] is not max_val: the max remains max_val.\n\nSimilarly for min:\n\nIf a[i] is min_val:\n\nIf min_count > 1: min remains min_val.\n\nElse: new min is second_min.\n\nElse: min remains min_val.\n\nWait, but when a[i] is not the max or min, removing it won't affect the max or min. So the new max is the original max, and the new min is the original min.\n\nSo for each a[i], the new max and min are:\n\nif a[i] == max_val:\n   if max_count > 1:\n       new_max = max_val\n   else:\n       new_max = second_max\nelse:\n   new_max = max_val\n\nSimilarly for min:\n\nif a[i] == min_val:\n   if min_count > 1:\n       new_min = min_val\n   else:\n       new_min = second_min\nelse:\n   new_min = min_val\n\nSo once we have new_max and new_min for each a[i], the instability is new_max - new_min. We need to find the minimum such value across all a[i].\n\nYes, that makes sense.\n\nNow, the question is: how to compute the second_max and second_min, and their counts.\n\nWait, no. Wait, in the case where a[i] is max_val, and max_count is 1, then the new max is second_max. But what if the second_max is not present? Like, for example, if all elements are the same except one.\n\nWait, for example, array [5,5,5,5]. Then max_val is 5, max_count is 4, second_max is 5.\n\nIf we remove any element, the max remains 5.\n\nAnother example: array [10, 8, 8, 7]. Max_val is 10, max_count is 1. So second_max is 8. So when we remove 10, the new max is 8.\n\nSimilarly for min.\n\nSo, the process is:\n\nCompute max_val, count how many times it occurs. Then find the next highest value in the array, which is the second_max.\n\nSame for min_val: find the next smallest value, which is second_min.\n\nBut how to compute second_max and second_min.\n\nLet's think about computing max_val, max_count, and second_max.\n\nInitialize max_val to the first element. max_count = 1. second_max = None.\n\nThen for each element in array:\n\nif current element > max_val:\n   second_max = max_val\n   max_val = current element\n   max_count = 1\nelif current element == max_val:\n   max_count += 1\nelse:\n   if current element > second_max:\n       second_max = current element\n\nWait, but this approach might miss some cases. For example, if the array is [10, 9, 9, 8], the max_val is 10, count 1, second_max is 9.\n\nIf we remove 10, the new max is 9.\n\nBut what if the array is [10, 9, 8, 10]. So max_val is 10, count is 2. So when any of the 10s are removed, the max remains 10.\n\nBut if we have [10, 10, 9], then when one 10 is removed, the count is 1, but the second_max is 10.\n\nWait, no. The second_max would be 10 in this case, because the array has multiple 10s.\n\nWait, no. Let me see:\n\nIn [10,10,9], the initial max_val is 10, count 2. second_max is 10.\n\nBecause when processing the second 10, it's equal to max_val, so we don't update second_max. So when you remove one 10, the max is still 10.\n\nYes.\n\nSo the algorithm correctly captures that.\n\nSimilarly for the second_max.\n\nSo, the code for computing max_val, max_count, and second_max would be something like:\n\nmax_val = a[0]\nmax_count = 1\nsecond_max = None\n\nfor num in a[1:]:\n    if num > max_val:\n        second_max = max_val\n        max_val = num\n        max_count = 1\n    elif num == max_val:\n        max_count += 1\n    else:\n        if second_max is None or num > second_max:\n            second_max = num\n\nWait, but this will miss cases where the second_max could be updated by a number less than the previous second_max but higher than others. Hmm, maybe not. Because for example, in the array [10, 8, 9], when processing 8, it's less than 10, so we check if it's greater than second_max (None). So second_max becomes 8. Then 9 comes in: 9 is less than 10, but more than 8. So second_max is updated to 9. Correct.\n\nYes, this seems correct.\n\nSimilarly for the min:\n\nmin_val = a[0]\nmin_count = 1\nsecond_min = None\n\nfor num in a[1:]:\n    if num < min_val:\n        second_min = min_val\n        min_val = num\n        min_count = 1\n    elif num == min_val:\n        min_count += 1\n    else:\n        if second_min is None or num < second_min:\n            second_min = num\n\nWait, no. Let's see:\n\nFor the array [1,3,3,7], the min is 1, count 1. second_min is 3. So when we remove 1, the new min is 3.\n\nWhich is correct.\n\nAnother example: [1,2,3,4,5], min is 1, count 1, second_min is 2.\n\nRemoving 1: new min is 2.\n\nYes.\n\nSo with these variables, for each element a[i], we can compute new_max and new_min.\n\nWait, but in the first sample input:\n\nInput array is [1,3,3,7]. So max_val is 7, max_count is 1. second_max is 3.\n\nmin_val is 1, count 1. second_min is 3.\n\nWhen we remove 7, the new max is 3, min is 1. So instability is 3-1=2.\n\nWhich is correct.\n\nIn the second sample input: [1,100000]. So max_val is 100000, count 1. second_max is 1. min_val is 1, count 1. second_min is 100000.\n\nWhen we remove 1: new max is 100000, new min is 100000. So instability is 0.\n\nWhen we remove 100000: new max is 1, min is 1. Instability 0.\n\nSo yes, the approach works.\n\nSo now, the plan is:\n\n1. Read the array.\n\n2. Compute max_val, max_count, second_max.\n\n3. Compute min_val, min_count, second_min.\n\n4. For each element a_i in the array:\n\n   a. Check if a_i is max_val.\n\n      i. If yes:\n\n         - if max_count > 1: new_max remains max_val.\n\n         - else: new_max is second_max.\n\n      ii. else: new_max remains max_val.\n\n   b. Similarly, check if a_i is min_val.\n\n      i. if yes:\n\n         - if min_count >1: new_min remains min_val.\n\n         - else: new_min is second_min.\n\n      ii. else: new_min remains min_val.\n\n   c. Calculate the instability as new_max - new_min.\n\n5. Find the minimum instability across all a_i.\n\n6. Output that minimum.\n\nBut wait, what if the array has all elements the same? For example, [5,5,5]. Then max_val is 5, max_count 3, second_max 5. min_val is 5, count 3, second_min 5.\n\nRemoving any element: new_max is 5, new_min is 5. Instability is 0.\n\nSo the code should handle that.\n\nAnother test case: [5,5,5,7]. Max_val is 7, count 1. Second_max is5. Min_val is 5, count 3. second_min is 5.\n\nWhen we remove 7: new_max is5, new_min is5. Instability 0.\n\nWhen we remove any 5: new_max remains7, new_min remains5. Instability is 2.\n\nSo the minimum is 0.\n\nSo the approach correctly captures this.\n\nNow, the next step is to implement this in Python.\n\nBut how to handle the computation of max_val, max_count, second_max, etc.\n\nSo in code:\n\nRead n, then the array.\n\nCompute max_val, max_count, second_max.\n\nCompute min_val, min_count, second_min.\n\nThen for each element in a:\n\nCheck if it's the max_val.\n\nCompute new_max as per the conditions.\n\nSimilarly for new_min.\n\nCalculate instability and keep track of the minimum.\n\nNow, let's think about edge cases.\n\nEdge Case 1: n=2.\n\nLike the sample input: [1, 100000].\n\nAs discussed earlier.\n\nEdge Case 2: All elements same.\n\nn=5, all 5. Removing any gives instability 0.\n\nEdge Case 3: Array with multiple max and min.\n\nFor example, [3,3,5,5]. So when you remove a 3: new max is5, min is3. Instability 2.\n\nWhen you remove a 5: new max is5, min is3. Instability 2.\n\nWait, but the initial array has max 5, count 2. So removing one 5 leaves another 5. So new_max remains5.\n\nSimilarly for the min.\n\nSo code correctly computes new_max and new_min.\n\nAnother Edge Case: [10, 9, 8, 7, 6].\n\nMax is10, count1. second_max is9.\n\nMin is6, count1. second_min is7.\n\nIf we remove 10: new_max is9, new_min is6. instability 3.\n\nIf we remove 6: new_min is7, new_max is10. instability 3.\n\nWait, but is that the minimum possible?\n\nYes, because any other element's removal leaves the max as10, min as6. So instability is4.\n\nSo the minimal is3.\n\nSo the code should correctly compute that.\n\nNow, let's proceed to write the code.\n\nFirst, read n.\n\nThen read the array as a list of integers.\n\nCompute max_val, max_count, second_max.\n\nInitialize max_val to the first element, max_count=1, second_max = None.\n\nThen loop from the second element:\n\nfor num in a[1:]:\n    if num > max_val:\n        second_max = max_val\n        max_val = num\n        max_count =1\n    elif num == max_val:\n        max_count +=1\n    else:\n        if second_max is None or num > second_max:\n            second_max = num\n\nSimilarly for min_val, min_count, second_min.\n\nOnce that's done, for each num in a:\n\nCompute new_max and new_min.\n\nnew_max:\n\nif num == max_val:\n\n    if max_count >1:\n\n        new_max = max_val\n\n    else:\n\n        new_max = second_max\n\nelse:\n\n    new_max = max_val\n\nSimilarly for new_min:\n\nif num == min_val:\n\n    if min_count >1:\n\n        new_min = min_val\n\n    else:\n\n        new_min = second_min\n\nelse:\n\n    new_min = min_val\n\nThen compute instability = new_max - new_min.\n\nKeep track of the minimum.\n\nFinally, output that minimum.\n\nBut wait, what if the array has only one element after removing? No, because n>=2, and we're removing exactly one element, so the resulting array is n-1 >=1, so no issue.\n\nWait, no. The problem statement says n >=2, so when we remove one, the array has at least 1 element.\n\nSo no problem.\n\nNow, let's test with the sample inputs.\n\nSample Input 1:\n\n4\n\n1 3 3 7\n\nAfter processing:\n\nmax_val is7, count1, second_max3.\n\nmin_val is1, count1, second_min3.\n\nFor each element:\n\n1: is min_val, count1.\n\nso new_min is second_min3.\n\nnew_max is7.\n\nInstability 7-3=4.\n\n3: not max or min.\n\nnew_max is7, new_min is1. instability 6.\n\nanother 3: same as above.\n\n7: is max_val, count1.\n\nso new_max is second_max3.\n\nnew_min is1.\n\ninstability 2.\n\nSo the minimum is 2.\n\nSample Input 2:\n\n2\n\n1 100000\n\nmax_val 1e5, count1, second_max1.\n\nmin_val1, count1, second_min1e5.\n\nEach element:\n\n1: is min_val, count1.\n\nnew_min is1e5.\n\nnew_max is1e5.\n\nso instability 0.\n\n1e5: is max_val, count1.\n\nnew_max is1.\n\nnew_min is1.\n\nso instability 0.\n\nSo the minimum is 0.\n\nSo code seems correct.\n\nNow, what about the case where the second_max is None?\n\nWait, can that happen?\n\nNo, because the array has at least 2 elements, and for the max_val, the second_max is computed as the next largest number.\n\nWait, suppose the array is [5,5,5,5]. Then, max_val is5, count4.\n\nsecond_max is5.\n\nSo when we remove any element, new_max is5.\n\nNo problem.\n\nAnother case: [5,5,5,4].\n\nmax_val is5, count3.\n\nsecond_max is4.\n\nSo when we remove a 5, new_max is5 (since count was 3>1).\n\nThus, correct.\n\nWhat about [5,4,3,2,1]. Max is5, count1. second_max4.\n\nWhen we remove5, new_max is4.\n\nYes.\n\nSo the code handles that.\n\nNow, what about the case where after removing the max, the new_max is the second_max, but the second_max is not present in the array.\n\nWait, no. Because the second_max is always the next highest value in the array.\n\nSo, for example, in [10,9,8], when you remove 10, the new_max is9.\n\nWhich is correct.\n\nSo, the code seems solid.\n\nNow, let's proceed to write the code.\n\nRead n.\n\nRead the array.\n\nCompute max_val, max_count, second_max.\n\nCompute min_val, min_count, second_min.\n\nLoop over each number in the array:\n\nCompute new_max and new_min as described.\n\nCalculate instability.\n\nFind the minimum.\n\nPrint the minimum.\n\nImplementing this in Python.\n\nBut wait, how about when all elements are same? Like [5,5,5,5]. Then, for any element, new_max is5, new_min is5. So instability 0.\n\nYes.\n\nAnother case: [1,2,3,4,5]. Removing 3: new_max is5, new_min is1. Instability4.\n\nBut if I remove5: new_max is4, new_min is1. Instability3.\n\nWhich is better.\n\nSo the code will find that.\n\nSo, in code:\n\nn = int(input())\na = list(map(int, input().split()))\n\n# Compute max_val, max_count, second_max\nmax_val = a[0]\nmax_count = 1\nsecond_max = None\nfor num in a[1:]:\n    if num > max_val:\n        second_max = max_val\n        max_val = num\n        max_count = 1\n    elif num == max_val:\n        max_count += 1\n    else:\n        if second_max is None or num > second_max:\n            second_max = num\n\n# Compute min_val, min_count, second_min\nmin_val = a[0]\nmin_count = 1\nsecond_min = None\nfor num in a[1:]:\n    if num < min_val:\n        second_min = min_val\n        min_val = num\n        min_count = 1\n    elif num == min_val:\n        min_count += 1\n    else:\n        if second_min is None or num < second_min:\n            second_min = num\n\nmin_instability = float('inf')\nfor num in a:\n    # Compute new_max\n    if num == max_val:\n        if max_count > 1:\n            new_max = max_val\n        else:\n            new_max = second_max\n    else:\n        new_max = max_val\n\n    # Compute new_min\n    if num == min_val:\n        if min_count > 1:\n            new_min = min_val\n        else:\n            new_min = second_min\n    else:\n        new_min = min_val\n\n    instability = new_max - new_min\n    if instability < min_instability:\n        min_instability = instability\n\nprint(min_instability)\n\nWait, but what if second_max is None? Can that happen?\n\nNo, because in the initial computation, the max_val is set to the first element, and for the rest, if any number is larger, second_max is set to the previous max_val.\n\nWait, but in the case where the array has only two elements, both same.\n\nLike [5,5]. Then, max_val is5, count2.\n\nsecond_max is5 (because in the loop, when the second 5 is processed, it's equal to max_val, so no change to second_max.\n\nSo for any element, when you remove it, the max and min remain the same.\n\nSo the code is safe.\n\nTesting the code with the sample inputs.\n\nSample 1:\n\nInput:\n\n4\n\n1 3 3 7\n\nProcessing:\n\nmax_val is7, count1.\n\nsecond_max is3.\n\nmin_val is1, count1.\n\nsecond_min is3.\n\nFor each element:\n\n1:\n\nnew_max is7.\n\nnew_min is3.\n\ninstability 4.\n\n3:\n\nnew_max is7.\n\nnew_min is1.\n\ninstability 6.\n\nanother 3:\n\nsame as above.\n\n7:\n\nnew_max is3.\n\nnew_min is1.\n\ninstability 2.\n\nSo min is 2.\n\nSample 2:\n\n2\n\n1 100000\n\nmax_val 1e5, count1, second_max1.\n\nmin_val1, count1, second_min1e5.\n\nFor each element:\n\n1: new_max is1e5, new_min is1e5. instability 0.\n\n1e5: new_max is1, new_min is1. instability 0.\n\nSo min is 0.\n\nSo code works.\n\nAnother test case:\n\nn=5\n\narray [10,9,8,7,6]\n\nmax_val 10, count1, second_max9.\n\nmin_val6, count1, second_min7.\n\nFor each element:\n\n10: new_max is9, new_min6. instability 3.\n\n9: new_max is10, new_min6. instability4.\n\n8: new_max10, new_min6. inst 4.\n\n7: same, inst4.\n\n6: new_max10, new_min7. inst3.\n\nSo the minimum is3.\n\nSo the code will output3.\n\nAnother test case: [5,5,5,5].\n\nAll elements same.\n\nFor any element, new_max is5, new_min5. inst0.\n\nSo code outputs0.\n\nAnother test case: [5,4,5,3,5].\n\nmax_val5, count3.\n\nsecond_max4.\n\nmin_val3, count1.\n\nsecond_min4.\n\nIf I remove a 5: new_max is5 (count remains 2), new_min3. instability 2.\n\nIf I remove 3: new_max5, new_min4. inst1.\n\nSo the minimum is1.\n\nSo code should compute that.\n\nSo, the code seems correct.\n\nNow, let's think about performance.\n\nn is up to 1e5. Each loop runs in O(n), so overall O(n) time, which is acceptable.\n\nSpace is O(1), since we just need the variables.\n\nSo the code should pass all test cases.\n",
    "response": "To solve this problem, we need to determine the minimum possible instability of an array after removing exactly one element. The instability is defined as the difference between the maximum and minimum values in the array.\n\n### Approach\n1. **Understanding Instability**: The instability of an array is the difference between its maximum and minimum values. When we remove an element, the new instability depends on whether the removed element was the current maximum or minimum.\n2. **Precomputation**: To efficiently compute the effect of removing each element, we precompute:\n   - The maximum value (`max_val`) and how many times it occurs (`max_count`).\n   - The second highest value (`second_max`), which will be needed if the maximum value is removed and there are no other instances left.\n   - The minimum value (`min_val`) and how many times it occurs (`min_count`).\n   - The second lowest value (`second_min`), which will be needed if the minimum value is removed and there are no other instances left.\n3. **Iterate and Compute**: For each element in the array, determine the new maximum and minimum values after removing that element. Use these values to compute the instability and track the minimum instability across all possible removals.\n\n### Solution Code\n```python\nn = int(input())\na = list(map(int, input().split()))\n\n# Compute max_val, max_count, and second_max\nmax_val = a[0]\nmax_count = 1\nsecond_max = None\nfor num in a[1:]:\n    if num > max_val:\n        second_max = max_val\n        max_val = num\n        max_count = 1\n    elif num == max_val:\n        max_count += 1\n    else:\n        if second_max is None or num > second_max:\n            second_max = num\n\n# Compute min_val, min_count, and second_min\nmin_val = a[0]\nmin_count = 1\nsecond_min = None\nfor num in a[1:]:\n    if num < min_val:\n        second_min = min_val\n        min_val = num\n        min_count = 1\n    elif num == min_val:\n        min_count += 1\n    else:\n        if second_min is None or num < second_min:\n            second_min = num\n\nmin_instability = float('inf')\nfor num in a:\n    # Determine new_max\n    if num == max_val:\n        if max_count > 1:\n            new_max = max_val\n        else:\n            new_max = second_max\n    else:\n        new_max = max_val\n    \n    # Determine new_min\n    if num == min_val:\n        if min_count > 1:\n            new_min = min_val\n        else:\n            new_min = second_min\n    else:\n        new_min = min_val\n    \n    instability = new_max - new_min\n    if instability < min_instability:\n        min_instability = instability\n\nprint(min_instability)\n```\n\n### Explanation\n1. **Reading Input**: The input consists of the number of elements and the array itself.\n2. **Precompute Values**: We iterate through the array to find the maximum, its count, and the second highest value. Similarly, we find the minimum, its count, and the second lowest value.\n3. **Calculate Instability for Each Removal**: For each element, we determine the new maximum and minimum values if that element were removed. We then compute the instability and keep track of the minimum instability found.\n4. **Output Result**: Finally, we print the minimum instability.\n\nThis approach ensures that we efficiently compute the required values without repeatedly scanning the entire array, making it suitable for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "n = int(input())\na = list(map(int, input().split()))\n\n# Compute max_val, max_count, and second_max\nmax_val = a[0]\nmax_count = 1\nsecond_max = None\nfor num in a[1:]:\n    if num > max_val:\n        second_max = max_val\n        max_val = num\n        max_count = 1\n    elif num == max_val:\n        max_count += 1\n    else:\n        if second_max is None or num > second_max:\n            second_max = num\n\n# Compute min_val, min_count, and second_min\nmin_val = a[0]\nmin_count = 1\nsecond_min = None\nfor num in a[1:]:\n    if num < min_val:\n        second_min = min_val\n        min_val = num\n        min_count = 1\n    elif num == min_val:\n        min_count += 1\n    else:\n        if second_min is None or num < second_min:\n            second_min = num\n\nmin_instability = float('inf')\nfor num in a:\n    # Determine new_max\n    if num == max_val:\n        if max_count > 1:\n            new_max = max_val\n        else:\n            new_max = second_max\n    else:\n        new_max = max_val\n    \n    # Determine new_min\n    if num == min_val:\n        if min_count > 1:\n            new_min = min_val\n        else:\n            new_min = second_min\n    else:\n        new_min = min_val\n    \n    instability = new_max - new_min\n    if instability < min_instability:\n        min_instability = instability\n\nprint(min_instability)",
    "score": 1,
    "metadata": {
        "prompt_token_count": 430,
        "completion_token_count": 756,
        "thoughts_token_count": 5349
    }
}