{
    "start": 1758278107.625097,
    "end": 1758278323.522632,
    "start-formatted": "2025-09-19 19:35 KST",
    "end-formatted": "2025-09-19 19:38 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "Okay, so I have this problem to solve, and I'm a bit nervous because it's from a competitive programming contest. Let me read the problem statement carefully.\n\nThe problem is about assigning Rebel spaceships to guard B bases. We need to make sure that every base has exactly one guardian and each spaceship is assigned to exactly one base. So, essentially, we're looking for a perfect matching between R Rebels and B bases. But there's an additional constraint: any two paths from a base to its assigned spaceship shouldn't intersect. Oh right, the paths are straight lines in the galaxy plane, and they can't cross each other. \n\nSo, what's the approach here? Hmm. Let's think.\n\nFirst, I need to model this as a graph problem. The key is that the matching must not only be perfect but also that the corresponding edges (from each base to its assigned ship) form a non-crossing set of lines.\n\nWait, but how do I represent this? Maybe I should model it as a bipartite graph where one set is the bases and the other is the ships. Each edge represents a possible assignment. Then, the problem reduces to finding a perfect matching where all the edges in the matching form a non-crossing arrangement.\n\nBut how do I check for the non-crossing condition? That's the tricky part.\n\nI remember that when you have points on a plane and you want to connect them without crossings, it's related to something called a convex hull or perhaps some kind of planar matching. Or maybe it's about the order in which the points are arranged along some path.\n\nWait, another thought: if the bases and ships are both points in the plane, then the lines connecting them won't cross if their endpoints are ordered correctly. For example, if all the points lie on a convex polygon, then a certain matching like a non-crossing chord diagram would work.\n\nAlternatively, perhaps the way to ensure no two lines cross is to have the matching edges form a set of non-overlapping segments. So, for each pair of connected base and ship, the line segment doesn't intersect with any other such segment in the matching.\n\nSo, how can I model this? Maybe I can generate all possible perfect matchings and then check each one for the non-crossing condition. Since R and B are up to 10, the maximum possible size is small enough for brute-force approaches.\n\nYes, because for R=10 and B=10, the number of perfect matchings is 10! = 3,628,800. Wait, but wait: actually, R and B are the same since it's a perfect matching. Because each base is matched to exactly one ship and vice versa. So, for R=10 and B=10, it's 10! possibilities. Which is manageable for a computer.\n\nSo the plan is:\n\n1. Generate all possible perfect matchings between the R ships and B bases.\n2. For each matching, check whether all the connecting lines (base to ship) are non-crossing.\n3. If any such matching exists, output \"Yes\". Otherwise, \"No\".\n\nBut wait, the problem says that the first line has R and B, but it's possible that R != B, but the problem statement says that it's a perfect matching. So, the initial check is that R equals B. Because otherwise, it's impossible to have a perfect matching. Oh right, because a perfect matching requires that the number of elements in each set is equal. So, if R != B, the answer is immediately \"No\".\n\nSo, step zero: if R != B, output \"No\".\n\nOtherwise, proceed.\n\nSo, for each possible permutation of the ships being assigned to the bases, we need to check if the lines don't cross.\n\nBut wait, how do I represent the bases and ships? Each base is a point, each ship is a point. For each matching, I'll have to connect each base to its assigned ship and see if any two lines cross.\n\nBut checking for line segment intersections is a computational geometry problem. How to do that efficiently.\n\nLet me think about how to represent two line segments and check if they intersect.\n\nThe line segments are between a base and a ship. So, each is a straight line between two points.\n\nTo check if two line segments AB and CD intersect, I can use the standard cross product-based approach.\n\nWait, but for multiple line segments, how do I check all possible pairs?\n\nSo, for a given matching, the lines are all the base-ship connections. For each pair of lines (A-B and C-D), I need to check if their segments intersect. If any pair does, the matching is invalid.\n\nSo, for each matching:\n\n- For each pair of line segments in the matching, check if they intersect. If any pair does, discard this matching.\n\nIf none of the pairs intersect, then this is a valid solution.\n\nSo, the steps are:\n\nFor each possible permutation P (matching from ships to bases):\n\n  ",
    "response": "To solve this problem, we need to determine if it's possible to assign Rebel spaceships to guard B bases such that each base has exactly one guardian, each spaceship has exactly one assigned base, and the connecting paths do not intersect.\n\n### Approach\n1. **Check for Perfect Matching**: The first step is to check if the number of Rebel spaceships (R) equals the number of bases (B). If they are not equal, it's impossible to form a perfect matching, and we immediately return \"No\".\n\n2. **Generate All Possible Matchings**: Since R and B can be up to 10, we can generate all possible permutations of assigning ships to bases. Each permutation represents a potential perfect matching.\n\n3. **Check for Non-Crossing Paths**: For each permutation (matching), we need to ensure that the lines connecting each base to its assigned spaceship do not intersect. This involves checking each pair of lines in the current matching for any intersections.\n\n4. **Intersection Check**: To check if two line segments intersect, we use the cross product method. This helps determine the relative orientation of points to decide if the segments intersect.\n\n### Solution Code\n```python\nimport sys\nfrom itertools import permutations\n\ndef readints():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef ccw(A, B, C):\n    return (B[0]-A[0])*(C[1]-A[1]) - (B[1]-A[1])*(C[0]-A[0])\n\ndef segments_intersect(s1, s2):\n    A, B = s1\n    C, D = s2\n    return ccw(A, B, C) * ccw(A, B, D) < 0 and ccw(C, D, A) * ccw(C, D, B) < 0\n\ndef main():\n    data = sys.stdin.read().split()\n    ptr = 0\n    R = int(data[ptr])\n    ptr +=1\n    B = int(data[ptr])\n    ptr +=1\n    \n    ships = []\n    for _ in range(R):\n        x = int(data[ptr])\n        y = int(data[ptr+1])\n        ptr +=2\n        ships.append( (x,y) )\n    \n    bases = []\n    for _ in range(B):\n        x = int(data[ptr])\n        y = int(data[ptr+1])\n        ptr +=2\n        bases.append( (x,y) )\n    \n    if R != B:\n        print(\"No\")\n        return\n    \n    # Now generate all possible matchings\n    found = False\n    for perm in permutations(range(R)):\n        matched = [False]*R\n        valid = True\n        for i in range(R):\n            matched[i] = True\n            ship_i = ships[i]\n            base_i = bases[perm[i]]\n            # Now, check all pairs of segments in this matching\n            for j in range(i):\n                if matched[j]:\n                    ship_j = ships[j]\n                    base_j = bases[perm[j]]\n                    seg1 = (base_j, base_i)\n                    seg2 = (base_i, base_j)\n                    seg1_rev = (base_i, base_j)\n                    seg2_rev = (base_j, base_i)\n                    if segments_intersect(seg1_rev, seg2_rev):\n                        valid = False\n                        break\n            if not valid:\n                break\n        if valid:\n            found = True\n            break\n    \n    print(\"Yes\" if found else \"No\")\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into coordinates for both ships and bases.\n2. **Perfect Matching Check**: If R does not equal B, output \"No\".\n3. **Generating Permutations**: Using permutations from the itertools library, we generate all possible ways to assign ships to bases.\n4. **Checking Segments**: For each permutation, we check if any of the connecting lines intersect using the `segments_intersect` function, which uses the cross product to determine orientation.\n5. **Output Result**: If a valid non-crossing permutation is found, print \"Yes\". Otherwise, print \"No\".\n\nThis approach ensures that we efficiently check all possible assignments and validate them for non-crossing paths, providing a correct solution to the problem.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom itertools import permutations\n\ndef readints():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef ccw(A, B, C):\n    return (B[0]-A[0])*(C[1]-A[1]) - (B[1]-A[1])*(C[0]-A[0])\n\ndef segments_intersect(s1, s2):\n    A, B = s1\n    C, D = s2\n    return ccw(A, B, C) * ccw(A, B, D) < 0 and ccw(C, D, A) * ccw(C, D, B) < 0\n\ndef main():\n    data = sys.stdin.read().split()\n    ptr = 0\n    R = int(data[ptr])\n    ptr +=1\n    B = int(data[ptr])\n    ptr +=1\n    \n    ships = []\n    for _ in range(R):\n        x = int(data[ptr])\n        y = int(data[ptr+1])\n        ptr +=2\n        ships.append( (x,y) )\n    \n    bases = []\n    for _ in range(B):\n        x = int(data[ptr])\n        y = int(data[ptr+1])\n        ptr +=2\n        bases.append( (x,y) )\n    \n    if R != B:\n        print(\"No\")\n        return\n    \n    # Now generate all possible matchings\n    found = False\n    for perm in permutations(range(R)):\n        matched = [False]*R\n        valid = True\n        for i in range(R):\n            matched[i] = True\n            ship_i = ships[i]\n            base_i = bases[perm[i]]\n            # Now, check all pairs of segments in this matching\n            for j in range(i):\n                if matched[j]:\n                    ship_j = ships[j]\n                    base_j = bases[perm[j]]\n                    seg1 = (base_j, base_i)\n                    seg2 = (base_i, base_j)\n                    seg1_rev = (base_i, base_j)\n                    seg2_rev = (base_j, base_i)\n                    if segments_intersect(seg1_rev, seg2_rev):\n                        valid = False\n                        break\n            if not valid:\n                break\n        if valid:\n            found = True\n            break\n    \n    print(\"Yes\" if found else \"No\")\n\nif __name__ == '__main__':\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 463,
        "completion_token_count": 896,
        "thoughts_token_count": 1025
    }
}