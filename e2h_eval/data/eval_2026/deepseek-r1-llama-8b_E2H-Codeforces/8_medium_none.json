{
    "start": 1758140906.3904831,
    "end": 1758142089.8574598,
    "start-formatted": "2025-09-18 05:28 KST",
    "end-formatted": "2025-09-18 05:48 KST",
    "gpu": 2,
    "pid": 8,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "Okay, so I have this problem where I need to determine the direction of each edge in a flow network such that the resulting graph satisfies certain conditions. Let me try to understand the problem step by step.\n\nThe problem states that we have an undirected graph with n vertices and m edges. The source is vertex 1, and the sink is vertex n. Each edge has a certain flow value. My task is to assign a direction to each edge (either ai → bi or bi → ai) such that:\n\n1. For every vertex v (except the source and sink), the sum of incoming flows equals the sum of outgoing flows.\n2. The source has no incoming edges.\n3. The resulting directed graph has no cycles.\n\nHmm, okay. So the directed graph needs to be a DAG (Directed Acyclic Graph) because there are no cycles. Also, the flow conservation must hold for all internal nodes.\n\nI remember that in maximum flow problems, the flow directions are determined by the residual graph, which is a DAG. So maybe I can model this as finding a way to orient the edges such that the residual graph is a DAG and satisfies the flow constraints.\n\nWait, but how do I approach this? Maybe I can think of it in terms of the standard max-flow min-cut theorem. The edges that are part of the cut will have their flow directed towards the source, and those not in the cut will have their flow directed towards the sink.\n\nBut wait, in this problem, we're given the edge capacities and need to assign directions. So perhaps the correct approach is to construct a directed acyclic graph where each edge's direction is such that the flow from the source to the sink is maximized, and the flow conservation is satisfied.\n\nSo, how do I determine the direction for each edge? One approach is to perform a BFS or DFS to assign directions based on the levels of the nodes. Like, assign edges from lower level to higher levels, ensuring that the flow is directed away from the source.\n\nLet me think: suppose I start by assigning the source as level 0. Then, for each node, its adjacent edges could be directed either way. But I need to ensure that the flow from each node to its neighbors doesn't create cycles and satisfies the flow conservation.\n\nAnother thought: for each edge, if the flow is part of the maximum flow, then the direction should be such that it contributes to the flow. But since the graph is undirected, I'm not sure how to directly infer the direction from the flow value alone.\n\nWait, the problem says that the solution is unique in some sense. Because the problem statement mentions that a solution exists and any correct solution is acceptable. So maybe the way to assign directions is to build a directed graph that is a DAG, and for each node except the source, the sum of outgoing edges equals the sum of incoming edges. But how?\n\nPerhaps I can model this by first building a tree structure from the source, and then for each node, assign the edges in a way that the flow is directed towards the sink. Alternatively, I can use the concept of a bipartitioning the graph into layers based on distances from the source.\n\nWait, another idea: for each edge (u, v), if u is closer to the source than v in a BFS traversal, then direct the edge from u to v. Otherwise, direct it from v to u. This way, the graph becomes a DAG because edges only go from lower levels to higher levels. Also, this ensures that the flow conservation is satisfied because each node except the source will have equal in-degree and out-degree.\n\nBut does this always work? Let me test it against the sample input.\n\nSample Input:\n3 3\n3 2 10\n1 2 10\n3 1 5\n\nSample Output:\n1\n0\n1\n\nSo the edges are:\n\nEdge 1: 3-2 with ci=10. Since in BFS from source (1), 1 is level 0. Node 2 is at level 1, node 3 is at level 1. So both edges 1 and 2 are connected to level 0 and 1. How do we decide their directions?\n\nWait, let's see the output:\n\nEdge 1 is directed as 3→2 (di=1). Edge 2 is directed as 1→2 (di=0). Edge 3 is directed as 3→1 (di=1).\n\nSo in this case, the edges are directed such that:\n\n1→2 (flow 10), 3→2 (flow 10), and 3→1 (flow 5). \n\nBut wait, the flow from 3→1 is 5. So that's a path from 3 to 1, but since 1 is the source, that's allowed.\n\nBut how did the algorithm decide the directions?\n\nIn the BFS, node 1 is level 0. Nodes 2 and 3 are level 1. For each edge:\n\nBetween 1 and 2: since 1 is level 0, and 2 is level 1, the edge is directed from 1→2.\n\nBetween 3 and 2: both are level 1. So which direction? Hmm, perhaps in this case, the edge is directed towards the node that is part of the 'sink' side. Or perhaps the edge between two nodes of the same level can be directed either way, but ensuring that the flow is consistent.\n\nWait, but in the sample, edge 3→2 is directed as 3→2, which would send 10 units to node 2. Then, node 2 has an incoming flow of 10 (from 1) and 10 (from 3), making a total of 20. But wait, that's not equal to the outgoing flow. Oh no, wait, no. Wait, node 2 is connected to 1 and 3. If edge 1→2 is 10, edge 3→2 is 10, then node 2's incoming is 20, but what about outgoing? It's connected to 1 via edge 2→1? No, in the sample output, edge 3 is directed as 3→1, so edge 3 is 3→1.\n\nWait, I'm getting confused. Let me think again.\n\nIn the sample, the directed edges are:\n\n1→2 (ci=10)\n3→2 (ci=10)\n3→1 (ci=5)\n\nNow, let's check the flow conservation.\n\nFor node 2: incoming from 1 (10) and 3 (10) → total 20. Outgoing is to nowhere else except possibly 3 and 1. But in the directed graph, node 2's outgoing edges are none except to 3? Wait no, node 2 is only connected to 1 and 3. But in the directed graph, node 2 is receiving from 1 and 3, and has no outgoing edges? Because node 2 is not the sink. Wait, but the sink is node 3. So node 2's outgoing edges would have to be towards node 3.\n\nWait, but in the sample, node 2's outgoing edges are zero because in the directed graph, it's only receiving. But that can't be right because then the sum of outgoing would be zero, but the sum of incoming is 20. So that would violate condition 1.\n\nHmm, maybe I misunderstood the sample. Let me re-examine the note in the problem statement.\n\nThe note says that in the first test case, 10 flow units pass through the path, and 5 units pass directly from source to sink. So the flow is 10 +5 =15 units total. So the flow goes from 1→2 and 3→2, but also 3→1.\n\nWait, perhaps the flow isn't just moving from 1 to 3 but also from 3 to 1. But that's impossible because 1 is the source, so it can't have incoming edges. Oh wait, no, in the directed graph, node 1 has no incoming edges, so all edges connected to 1 must be outgoing. So edge 3→1 is outgoing from 3 and into 1.\n\nWait, but 1 is the source, so it can't have incoming edges. So edge 3→1 is outgoing from 3, which is allowed.\n\nSo, let's calculate the flow for each node.\n\nNode 1: only outgoing edge is 3→1, which has ci=5. So sum of outgoing is 5, incoming is 0. Correct.\n\nNode 2: incoming from 1 (10) and 3 (10) → total 20. Outgoing edges: none? Because in the directed graph, edges from 2 would go to other nodes. But where?\n\nWait, perhaps node 2's outgoing edges are 2→3, but that's not part of the sample's directed edges. Hmm, I'm getting a bit stuck.\n\nAlternatively, maybe the way to model this is that the directed graph is a DAG, and each edge's direction is chosen such that the flow is routed from the source to the sink, respecting the capacity constraints. So, for each edge (u, v), if u is in a lower level (distance from source) than v, then the edge is directed u→v. If they are in the same level, the edge can be directed either way, but perhaps in a way that allows the flow to pass.\n\nBut how do I implement this?\n\nAn alternative approach is to model the problem as building a directed graph with the required properties. So, for each edge (u, v), we need to decide whether to direct it as u→v or v→u. Once directed, the sum of flows into each node (except source and sink) must equal the sum of flows out.\n\nOne way to achieve this is to assign a level to each node, where the level is the distance from the source. Then, for each edge, if u is at level l and v is at level l+1, direct it from u to v. If u and v are at the same level, perhaps we can choose the direction that allows the flow to pass, ensuring that the in-degree equals the out-degree for all internal nodes.\n\nWait, but how do I compute the levels? Because the graph might have multiple paths, but the BFS approach would assign the shortest distance from the source as the level.\n\nOnce the levels are computed, each edge (u, v) is directed as u→v if level[u] < level[v]. If level[u] == level[v], then the direction is determined based on some other criteria, perhaps the smaller index or something else.\n\nThis approach should result in a DAG, as all edges go from lower levels to higher levels.\n\nBut does this satisfy the flow conservation? Let's see.\n\nSuppose for a node v (not source nor sink), its incoming edges come from nodes u with level less than level[v], and outgoing edges go to nodes w with level greater than level[v]. So, the sum of flows into v must equal the sum of flows out of v, because each flow into v must come from a lower level and leave to a higher level.\n\nYes! Because in the directed graph, the in-degree and out-degree for each node except source and sink must be equal. Because for each edge coming into v, the flow must exit via some other edge, but since the graph is a DAG, each flow into v must leave through another edge, possibly after some steps.\n\nWait, no. That's not necessarily true. For example, consider a node v that is a leaf node in the DAG. Its outgoing edges may not balance the incoming edges. Hmm, maybe I'm missing something.\n\nWait, no. Because the levels are assigned such that all edges go from lower to higher levels. So for any node v, the sum of flows into v is equal to the sum of flows out of v. Because each flow into v must come from a node u with a lower level, and must then flow to a node w with a higher level. But wait, that's not sufficient because the flow can pass through multiple steps.\n\nWait, perhaps the key is that the in-degree equals the out-degree for each node except the source and sink. Because for each edge u→v, it contributes 1 to the out-degree of u and 1 to the in-degree of v. So, if all nodes except the source and sink have equal in-degree and out-degree, then the sum of incoming flows equals the sum of outgoing flows.\n\nYes, that makes sense. Because each unit of flow entering a node must leave through another edge, hence the sum of incoming equals the sum of outgoing.\n\nSo, to model this, the steps I need to take are:\n\n1. Compute the level (distance from the source) for each node using BFS.\n2. For each edge, if u is at a lower level than v, direct it u→v. Otherwise, if u is at a higher level, direct it v→u. If u and v are at the same level, perhaps we can choose arbitrarily, but need to ensure that the flow is correctly routed.\n\nWait, but when u and v are at the same level, directing the edge either way can affect the flow conservation. So perhaps, in that case, we need to choose the direction such that the flow is balanced.\n\nWait, but how? Because in the case where u and v are at the same level, if the edge is directed u→v, then v's out-degree increases by one, but it's in-degree also depends on other edges. Hmm, maybe I'm overcomplicating.\n\nPerhaps the best approach is to perform BFS to assign levels, and then for each edge (u, v), if level[u] < level[v], direct it u→v; else if level[v] < level[u], direct it v→u; and if they are equal, choose the direction that allows the flow to pass. But I'm not sure how to handle the same-level case.\n\nWait, perhaps in the same-level case, the edge can be directed either way, but in a way that doesn't create cycles. Since the overall graph is a DAG, all edges are directed from lower levels to higher, so same-level edges can't form cycles because they would require a path that goes up in levels, which is impossible.\n\nBut in the same-level case, how to choose the direction? Maybe the direction doesn't matter for the flow conservation, as long as the in-degree equals the out-degree. Or perhaps it's better to direct the edge from the node with the higher index to the lower index, but I'm not sure.\n\nAlternatively, perhaps for same-level edges, we can choose the direction based on some arbitrary rule, like preferring the direction that allows more flow to pass through, but I don't know how to determine that without knowing the flow values.\n\nWait, but the problem states that the solution is unique or any correct solution is acceptable. So perhaps, for same-level edges, it's acceptable to choose either direction as long as the overall conditions are met.\n\nSo, the plan is:\n\n- Perform BFS starting from the source (node 1) to compute the level of each node.\n- For each edge (u, v, c_i), compare the levels of u and v:\n   - if level[u] < level[v]: direct u → v.\n   - else if level[v] < level[u]: direct v → u.\n   - else: choose any direction, say u → v or v → u. But how?\n\nWait, but for same-level edges, the direction choice may affect the flow conservation. For example, if u and v are at the same level and the edge is directed u → v, then v's in-degree increases by 1, but its out-degree must also increase. But since v's level is same as u's, the edges from v can only go to higher levels.\n\nHmm, but in this case, the in-degree and out-degree for v would still be equal because for each edge coming into v, there must be an edge leaving v to a higher level. So, perhaps for same-level edges, directing them either way is fine as long as the overall graph remains a DAG.\n\nSo, to proceed:\n\nImplement BFS to assign levels.\n\nFor each edge:\n\nIf level[u] < level[v]: u → v.\n\nElse if level[v] < level[u]: v → u.\n\nElse: choose the direction based on some criteria, like the order of u and v. For example, if u < v, then u → v; else, v → u.\n\nWait, but in the sample input, let's see:\n\nSample Input 1:\n\n3 nodes.\n\nEdges:\n\n3-2 with c=10.\n\n1-2 with c=10.\n\n3-1 with c=5.\n\nBFS levels:\n\n1 is level 0.\n\n2 and 3 are level 1.\n\nSo for edge 3-2: same level. So according to our rule, perhaps we can choose to direct 3→2 or 2→3.\n\nIn the sample output, edge 3-2 is directed as 3→2 (output line 1 is 1).\n\nSo, in this case, the edge is directed from 3 to 2.\n\nSimilarly, edge 1-2 is directed as 1→2 (output line 2 is 0).\n\nEdge 3-1: 3 is level 1, 1 is level 0. So 3 is higher level, so the edge is directed as 1→3? No, wait, no. Wait, 3 is level 1, 1 is level 0. So for edge 3-1, since 1 has lower level, the edge is directed as 1→3. But the sample output for the third edge is 1, meaning it's directed as 3→1.\n\nWait, that contradicts my earlier approach. So perhaps I've made a mistake in the logic.\n\nWait, the third edge is 3-1 with c=5. According to the levels, 1 is level 0, 3 is level 1. So for this edge, since 1's level is lower than 3's, the edge should be directed as 1→3. But in the sample output, it's directed as 3→1. So that suggests that my initial approach is incorrect.\n\nHmm, so what's going on here. In the sample, the edge 3-1 is directed as 3→1, which is against the level-based approach.\n\nSo perhaps the level-based approach is not sufficient.\n\nAlternative idea: maybe the direction is determined by the presence of a augmenting path in the residual graph. But I'm not sure.\n\nAnother approach: think about the residual graph. The direction of each edge in the original graph determines whether it's part of the residual graph or not. An edge is part of the residual graph if it's not saturated. So, for each edge (u, v) with capacity c, if the flow is f, then the residual graph has two edges: u→v with capacity f, and v→u with capacity c-f.\n\nBut the maximum flow requires that the residual graph is a DAG. So, in the directed graph, each edge is directed in a way that the residual graph is a DAG.\n\nWait, but how does that help me assign directions?\n\nPerhaps, the direction of each edge is determined by whether it's on the path from the source to the sink in the residual graph or not.\n\nAlternatively, maybe the direction is determined by the way the flow is pushed through the graph during a specific flow algorithm, like the Dinic's algorithm.\n\nBut I'm not sure how to model that.\n\nWait, perhaps the correct way is to model the problem as a directed graph where each edge is oriented such that the flow is directed from u to v if v is reachable from u in the BFS tree, but that's vague.\n\nAnother thought: in a DAG, the direction of the edges must be such that all edges go from earlier layers to later layers. So, the BFS levels can be used to assign the direction.\n\nBut in the sample, the edge 3→1 is directed as 3→1, but according to BFS levels, 1 is level 0, 3 is level 1, so the edge should be directed from 1 to 3. But the sample directs it as 3→1, which is the opposite.\n\nSo, perhaps my initial approach is wrong. What's different in the sample?\n\nIn the sample, the edge 3→1 has flow 5. So, the flow is going from 3 to 1, which is against the level-based approach. But why is that allowed?\n\nBecause in the problem statement, the flow can go in any direction as long as the conditions are satisfied. So perhaps the level-based approach isn't the right way.\n\nWait, maybe the problem isn't about the maximum flow in terms of the standard maximum flow, but rather the maximum possible flow under the given edge directions. So, perhaps the direction assignment must ensure that the flow can be pushed along the directed edges, and the sum of flows is maximized.\n\nBut how do I find the direction that allows the maximum flow?\n\nHmm, perhaps I should model this as a DAG where each edge's direction is chosen to allow the maximum possible flow, subject to the constraints.\n\nWait, but the problem statement says that the solution is unique, so perhaps there's a deterministic way to assign the directions.\n\nAnother idea: the direction of each edge is determined by whether the node is part of the source's side or the sink's side in a bipartition of the graph. But I'm not sure.\n\nAlternatively, perhaps the problem can be approached by considering the flow conservation constraints as a system of equations. For each node, the sum of incoming flows equals the sum of outgoing flows. Except for the source and sink.\n\nBut solving this system for the direction of edges seems computationally challenging, especially given the constraints on the problem size (n up to 2e5, m up to 2e5).\n\nWait, but perhaps the problem can be transformed into a problem of finding a spanning tree that connects all nodes and directs the edges in such a way that the tree is a DAG. Then, for each edge not in the tree, we can choose a direction that doesn't create cycles.\n\nBut I'm not sure.\n\nWait, another thought: the problem is similar to determining the direction of edges in a way that the graph is a DAG, and each node (except source and sink) has equal in-degree and out-degree. Additionally, the source has no incoming edges.\n\nSo, perhaps the approach is to construct a DAG where the edges are directed in such a way that the flow can be pushed from the source to the sink, respecting the capacities, and the flow conservation is satisfied.\n\nThis sounds like building a residual graph where each edge is directed in a way that the residual graph is a DAG.\n\nBut I'm not sure how to compute this.\n\nMaybe the correct approach is to find a way to assign directions so that the graph is a DAG and the flow conservation is satisfied. To do this, perhaps we can model the problem as follows:\n\nWe need to assign a direction to each edge such that:\n\n1. The directed graph is a DAG.\n\n2. For each node v (1 < v < n), the sum of outgoing flows equals the sum of incoming flows.\n\n3. The source has no incoming edges.\n\n4. The sink has no outgoing edges.\n\nWait, no, the sink can have outgoing edges, but it's the end point. So, the sink can have incoming edges, but no outgoing edges (since it's the sink).\n\nWait, no. The sink can have incoming edges, but no outgoing edges. Because it's the destination.\n\nSo, for the sink, the sum of incoming flows is the total flow, and the sum of outgoing flows is zero.\n\nSo, for all other nodes, the sum of incoming flows equals the sum of outgoing flows.\n\nSo, how to model this?\n\nOne way is to think of the problem as building a directed graph where each edge is directed such that the graph is a DAG, and the in-degree equals the out-degree for all non-source and non-sink nodes.\n\nThis sounds like finding a Eulerian trail, but I'm not sure.\n\nAlternatively, perhaps the correct approach is to find a way to model the problem using a bipartition of the nodes, but I'm not sure.\n\nAnother idea: since the graph is connected, perhaps the solution can be built by choosing a root (the source) and building a tree where each node points to its parent, and then directing the edges accordingly. For the remaining edges, direct them in a way that doesn't create cycles.\n\nBut I'm not sure.\n\nWait, perhaps the correct approach is to assign the direction of each edge based on the BFS levels, but in the case where nodes are at the same level, assign the direction based on some other criteria, like the node's index.\n\nIn the sample, the edge 3-1 is directed as 3→1, even though 1 is at a lower level. So perhaps the level-based approach isn't sufficient.\n\nHmm, perhaps the problem requires a more sophisticated approach, such as finding a s-t DAG where each edge is directed in a way that the flow can pass through, and the flow conservation holds.\n\nBut how to implement this efficiently?\n\nAnother approach: the problem is equivalent to finding a DAG orientation of the graph such that for each node v (excluding source and sink), the sum of the capacities of edges directed into v equals the sum of the capacities of edges directed out of v. Additionally, the source has no incoming edges.\n\nThis is known as the \"Eulerian orientation\" problem, but I'm not familiar with the exact solution method.\n\nWait, upon checking, I recall that in a connected undirected graph, it's possible to assign directions to the edges to form a Eulerian circuit. But that's when all nodes except possibly two have equal in-degree and out-degree.\n\nIn this problem, the source and sink have degrees that are not equal, but the other nodes must have equal in and out degrees.\n\nSo, perhaps the problem reduces to finding an Eulerian orientation for the graph, which can be done by choosing a root and orienting edges away from the root.\n\nWait, that makes sense. Because for each node except the source, the sum of outgoing edges equals the sum of incoming edges.\n\nSo, perhaps the solution is to choose the source as the root, and perform a BFS or DFS to assign directions. For each edge (u, v), if u is visited before v, direct it u→v; otherwise, direct it v→u.\n\nWait, but that's similar to the level-based approach.\n\nLet me test this on the sample.\n\nSample Input 1:\n\n3 nodes.\n\nEdges:\n\n3-2 (10), 1-2 (10), 3-1 (5).\n\nBFS starting from 1:\n\n- Level of 1 is 0.\n\n- Visit 1's neighbors: 2 and 3.\n\n- Assign level 1 to 2 and 3.\n\nFor each edge:\n\n3-2: same level. So, according to the BFS approach, since 3 is reached after 2, perhaps the edge is directed from 2 to 3? Or from 3 to 2?\n\nWait, in the BFS, nodes are processed in order. So, perhaps for same-level edges, the direction is determined by the order in which the nodes were visited. But that might complicate things.\n\nAlternatively, for same-level edges, the direction is arbitrary as long as it doesn't create cycles.\n\nIn the sample, edge 3-2 is directed as 3→2, which is allowed.\n\nEdge 1-2 is directed as 1→2.\n\nEdge 3-1 is directed as 3→1.\n\nWhich aligns with the sample output.\n\nSo, perhaps the correct approach is to perform BFS, and for each edge (u, v):\n\n- if u is visited before v, direct it u→v.\n\n- else, direct it v→u.\n\nBut how to track which node was visited first.\n\nWait, perhaps during BFS, when processing node u, for each neighbor v, if v hasn't been visited yet, set the direction as u→v. Else, set the direction as v→u.\n\nWait, but that may not work because in BFS, nodes are processed in order of their discovery, so for same-level nodes, the order is determined by their labels.\n\nWait, perhaps for same-level edges, the direction is determined by the order of the nodes in the adjacency list. For example, if u is listed before v in the adjacency list of the other node, then the edge is directed u→v.\n\nBut this might not be straightforward.\n\nAlternatively, for each edge (u, v), if u is visited before v in BFS, direct it u→v; else, direct it v→u.\n\nBut in BFS, the order of visiting is determined by the order of the nodes in the queue. So, if during BFS, node u is dequeued before v, then u is marked as visited before v. So for the edge (u, v), if u is visited before v, direct it u→v. Else, direct it v→u.\n\nBut wait, in the sample, for the edge 3-1:\n\nDuring BFS, node 1 is dequeued first, and it's processed. So, when processing 1's edges, 2 and 3 are added to the queue. Let's say the order is 2 comes before 3.\n\nWhen processing 2, it looks at its edges. Suppose 3 is already in the queue but not processed. When processing 3, it looks at its edges.\n\nSo, for the edge 3-1: u is 3, v is 1. When processing 3, 1 is already visited. So, the edge is directed as 3→1.\n\nWhich matches the sample.\n\nSimilarly, for edge 3-2: during processing 3, 2 is already visited. So, the edge is directed as 3→2.\n\nFor edge 1-2: during processing 1, 2 is not visited, so it's directed as 1→2.\n\nSo, this seems to work.\n\nThus, the steps are:\n\n1. Perform BFS starting from the source (node 1) to compute the order of visiting each node.\n\n2. For each edge (u, v, c), if u is visited before v in BFS, direct it u→v. Else, direct it v→u.\n\nThis ensures that the directed graph is a DAG, because edges are only directed from nodes visited earlier to those visited later. Thus, no cycles are possible.\n\nAdditionally, for each node v (other than source and sink), the sum of incoming edges' capacities equals the sum of outgoing edges' capacities.\n\nWait, but is this always true?\n\nLet me think about the in-degree and out-degree for each node.\n\nEach edge (u, v) contributes 1 to the out-degree of u and 1 to the in-degree of v.\n\nSince the graph is a DAG, the in-degree and out-degree for each node are equal, except for the source and sink.\n\nBecause, in a DAG, the source has out-degree >0 and in-degree 0. The sink has in-degree >0 and out-degree 0. All other nodes have in-degree equal to out-degree.\n\nThus, the sum of incoming flows equals the sum of outgoing flows for each node except the source and sink.\n\nSo, this approach should work.\n\nSo, the plan is:\n\n- Perform BFS starting from the source, keeping track of the order in which nodes are visited.\n\n- For each edge (u, v), if u was visited before v, direct it u→v; else, direct it v→u.\n\nThis will ensure that the directed graph is a DAG, and the flow conservation is satisfied.\n\nSo, now the task is to implement this.\n\nNow, to implement this, I'll need to:\n\n1. Read the input and build the graph.\n\n2. Perform BFS from node 1, tracking the order of visitation.\n\n3. For each edge, determine the direction based on the visitation order.\n\nBut how to represent the edges and track the direction.\n\nImplementation Steps:\n\nRead n and m.\n\nRead the m edges, storing each as a tuple (u, v, c). Also, keep track of the index of each edge in the input, as we need to output the direction for each in the order of input.\n\nPerform BFS starting from node 1.\n\nMaintain a visited array and a queue.\n\nFor each node when it's dequeued, add all its edges to the queue, marking them as visited.\n\nBut wait, in BFS, each node is enqueued once when it's first discovered.\n\nBut for the purpose of determining the visitation order, the order in which nodes are processed (dequeued) is what matters.\n\nSo, during BFS, for each node, when it is dequeued, process all its adjacent edges.\n\nFor each edge (u, v), when u is being processed, if v hasn't been visited yet, mark it as visited and enqueue it.\n\nWait, but in this case, the visitation order is determined by the order in which nodes are dequeued.\n\nOnce the BFS is complete, for each edge (u, v), if u was visited before v, direct it u→v; else, v→u.\n\nBut wait, during BFS, u is the current node being processed. So, for the edge (u, v), if v hasn't been visited before, then when u is processed, v is added to the queue, and thus, u is visited before v.\n\nBut for edges where both u and v are in the same level, their visitation order is determined by the order in which they were added to the queue.\n\nThus, during BFS, for each node, when it's dequeued, for each of its edges, if the other node hasn't been visited, add it to the queue and mark it as visited.\n\nIn this way, the order in which nodes are visited is determined by the BFS traversal.\n\nOnce the BFS is done, for each edge (u, v), we check whether u was visited before v. If yes, direction is u→v (di=0?), else v→u (di=1).\n\nWait, the problem specifies that di=0 means ai→bi, di=1 means bi→ai.\n\nSo, for each edge (u, v, c_i), after determining the direction, if it's directed as u→v, output 0. Else, output 1.\n\nThus, the code outline is:\n\nRead n, m.\n\nedges = []\nfor _ in range(m):\n    a, b, c = map(int, input().split())\n    edges.append( (a, b, c) )\n\nCompute BFS levels and visitation order.\n\nvisited = [False] * (n+1)\norder = []\nqueue = deque()\nqueue.append(1)\nvisited[1] = True\norder.append(1)\n\nwhile queue:\n    u = queue.popleft()\n    for (v, c) in adj[u]:\n        if not visited[v]:\n            visited[v] = True\n            order.append(v)\n            queue.append(v)\n\nThen, for each edge (u, v, c):\n\nif u was visited before v:\n\n   direction is u→v → output 0\n\nelse:\n\n   direction is v→u → output 1\n\nBut wait, no. Because during BFS, when you process u's edges, you enqueue v only if it hasn't been visited before. So, for an edge (u, v), if v is in the order before u, that can't happen because u is processed before v.\n\nWait, no. Because during BFS, u is dequeued, and then for each of its edges, v is added to the queue only if not visited. So, if v was added before u, then u would have been enqueued later.\n\nThus, for an edge (u, v), if in the order list, u comes before v, then during BFS, u was processed before v, so when u was processed, v was not yet visited. So, the edge (u, v) is directed as u→v.\n\nElse, if v comes before u in the order list, then when u was processed, v had already been visited. So, the edge (u, v) is directed as v→u.\n\nThus, for each edge (u, v), if u appears before v in the order list, output 0; else, output 1.\n\nBut wait, the order list is the order in which nodes are dequeued, which is the BFS order.\n\nSo, for each edge (u, v), if u is in the order before v → output 0.\n\nElse → output 1.\n\nThus, the code can be written as:\n\nfor i in range(m):\n    a, b, c = edges[i]\n    if order.index(a) < order.index(b):\n        print(0)\n    else:\n        print(1)\n\nBut wait, this would be very inefficient for large n and m, as for each edge, we're doing two lookups in the order list, which is O(n) per lookup. For m up to 2e5, this would be O(m*n), which is 4e10 operations—way too slow.\n\nSo, this approach is not feasible.\n\nThus, I need a way to quickly determine for each edge (u, v) whether u was visited before v during BFS.\n\nAn alternative approach is to create a dictionary that maps each node to its position in the order list.\n\npos_in_order = {node: idx for idx, node in enumerate(order)}\n\nThen, for each edge (u, v), if pos_in_order[u] < pos_in_order[v], output 0; else, output 1.\n\nBut creating this dictionary is O(n), which is manageable.\n\nSo, the steps are:\n\nAfter performing BFS, create a dictionary mapping each node to its position in the order list.\n\nThen, for each edge (u, v), compare their positions.\n\nThis way, each edge is processed in O(1) time.\n\nThus, the code is feasible.\n\nTesting this approach with the sample:\n\nSample Input 1:\n\n3 nodes.\n\nEdges:\n\n3-2 (10), 1-2 (10), 3-1 (5).\n\nBFS order:\n\nStart with 1.\n\nProcess 1's edges: 2 and 3.\n\nSuppose the order is [1, 2, 3].\n\nSo, for edge 3-2: u=3, v=2. pos_in_order[3] is 2, pos_in_order[2] is 1. So 3 comes after 2. So, the edge is directed as v→u → output 1.\n\nWait, no, in the sample, the edge 3-2 is directed as 3→2, which would be output 0.\n\nWait, but according to the order, 2 comes before 3. So, for the edge (3, 2), pos_in_order[3] is 2, pos_in_order[2] is ",
    "response": "To solve this problem, we need to determine the direction of each edge in a flow network such that the resulting graph satisfies specific conditions. The goal is to ensure that the graph is a Directed Acyclic Graph (DAG) and that the flow conservation holds for all internal nodes.\n\n### Approach\n1. **Breadth-First Search (BFS)**: We start by performing BFS from the source node (node 1). This helps us determine the order in which nodes are visited. The BFS ensures that each node is processed level by level, which helps in directing the edges correctly.\n2. **Order Tracking**: During BFS, we maintain the order of node visitation. This order is crucial as it helps in determining the direction of each edge.\n3. **Edge Direction Assignment**: For each edge, if the starting node (u) is visited before the ending node (v) in BFS, the edge is directed from u to v. Otherwise, it is directed from v to u. This ensures that the resulting graph is a DAG and satisfies the flow conservation constraints.\n\n### Solution Code\n```python\nimport sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n\n    edges = []\n    for _ in range(m):\n        a = int(input[idx])\n        b = int(input[idx+1])\n        c = int(input[idx+2])\n        edges.append((a, b, c))\n        idx += 3\n\n    # Perform BFS to determine the order of visiting nodes\n    adj = [[] for _ in range(n+1)]\n    for a, b, c in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n\n    visited = [False] * (n + 1)\n    order = []\n    q = deque()\n    q.append(1)\n    visited[1] = True\n    order.append(1)\n\n    while q:\n        u = q.popleft()\n        for v in adj[u]:\n            if not visited[v]:\n                visited[v] = True\n                order.append(v)\n                q.append(v)\n\n    # Create a position map for quick lookup\n    pos_in_order = {node: i for i, node in enumerate(order)}\n\n    # Prepare the output\n    output = []\n    for a, b, c in edges:\n        if pos_in_order[a] < pos_in_order[b]:\n            output.append('0')\n        else:\n            output.append('1')\n\n    print('\\n'.join(output))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into the number of nodes, edges, and the list of edges with their capacities.\n2. **BFS Initialization**: We initialize BFS from the source node (node 1) to determine the order of node visitation.\n3. **BFS Execution**: Using a queue, we process each node, marking them as visited and enqueuing their neighbors if they haven't been visited yet.\n4. **Order Mapping**: After BFS completes, we create a mapping from each node to its position in the visitation order.\n5. **Edge Direction Determination**: For each edge, we check the positions of its endpoints in the visitation order to determine the correct direction and store the result.\n6. **Output**: Finally, we print the directions for each edge in the required format.\n\nThis approach ensures that the resulting directed graph is a DAG and satisfies the flow conservation constraints efficiently.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n\n    edges = []\n    for _ in range(m):\n        a = int(input[idx])\n        b = int(input[idx+1])\n        c = int(input[idx+2])\n        edges.append((a, b, c))\n        idx += 3\n\n    # Perform BFS to determine the order of visiting nodes\n    adj = [[] for _ in range(n+1)]\n    for a, b, c in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n\n    visited = [False] * (n + 1)\n    order = []\n    q = deque()\n    q.append(1)\n    visited[1] = True\n    order.append(1)\n\n    while q:\n        u = q.popleft()\n        for v in adj[u]:\n            if not visited[v]:\n                visited[v] = True\n                order.append(v)\n                q.append(v)\n\n    # Create a position map for quick lookup\n    pos_in_order = {node: i for i, node in enumerate(order)}\n\n    # Prepare the output\n    output = []\n    for a, b, c in edges:\n        if pos_in_order[a] < pos_in_order[b]:\n            output.append('0')\n        else:\n            output.append('1')\n\n    print('\\n'.join(output))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 650,
        "completion_token_count": 747,
        "thoughts_token_count": 8193
    }
}