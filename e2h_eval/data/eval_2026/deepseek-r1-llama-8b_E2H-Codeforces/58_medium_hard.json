{
    "start": 1758284310.44892,
    "end": 1758286834.8314297,
    "start-formatted": "2025-09-19 21:18 KST",
    "end-formatted": "2025-09-19 22:00 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let me read it carefully.\n\nThe problem is about Vitaly and a graph theory problem. We need to find the minimum number of edges to add to form a simple cycle of odd length, with more than one vertex. And also count the number of ways to do this.\n\nHmm. So the graph is undirected, no loops or parallel edges. It's not necessarily connected.\n\nThe output should be two numbers: t, the minimal edges to add, and w, the number of ways.\n\nLet me think about what constitutes a cycle here. A simple cycle means each vertex appears at most once. And the cycle must be of odd length, more than one vertex.\n\nSo for example, in a triangle (3 nodes), that's a cycle of length 3, which is odd. If there's already such a cycle, then t is zero, and w is one.\n\nBut if the graph doesn't have any cycles, we need to find the minimal edges to add so that a cycle is formed, and that cycle has an odd length.\n\nWait, but the cycle could consist of a new set of nodes as well, right? Or maybe not—because adding edges can connect existing components.\n\nWait, the problem allows adding edges anywhere, even between disconnected components. So the minimal approach might involve connecting two components that together form a cycle.\n\nSo let's consider some cases.\n\nCase 1: The graph is already connected. Then, perhaps we can find a way to create an odd-length cycle by adding just one edge.\n\nWait, no. For example, a tree is connected, but adding one edge creates exactly one cycle. But the length of that cycle depends on the path between two nodes.\n\nSo for example, if the tree has a diameter of even length, adding an edge between two ends would create a cycle of even length. Which we don't want.\n\nAlternatively, if there are two paths between two nodes, and their sum is even or odd, etc.\n\nWait, maybe it's better to model this as looking for the minimal number of edges to add to form any cycle, regardless of its structure, and then among those cycles, find the ones that are of odd length, and pick the minimal t and count w.\n\nBut wait, the problem requires that the resulting cycle is of odd length. So t is the minimal number of edges needed to form such a cycle, considering all possible ways to add edges.\n\nHmm. So first, for each possible way to add edges, see if it forms an odd-length cycle. Among all possible such ways, find the minimal t.\n\nWait, but how?\n\nI think the approach is to model this by considering the connected components of the graph. Because adding edges can only happen within or between components.\n\nWait, no. Adding edges can connect two different components, but that's not directly creating a cycle unless the two components have certain structures.\n\nWait, but the key is that to form a cycle, you need at least a path that connects back to itself. So perhaps, the minimal way is to find two vertices u and v, such that the shortest path between them is even or odd in length, and then adding an edge between u and v will create a cycle whose length is the sum of the path plus 1.\n\nWait, that's an interesting thought. Because adding an edge between u and v where u and v are already in the same component will create a cycle of length equal to the distance between u and v plus one. Wait, no. Because the distance is the length of the shortest path. Adding an edge between u and v would create a cycle that goes from u to v via the shortest path, then the added edge. So the length is (distance + 1).\n\nSo for example, if the distance between u and v is 2 (so there's a path of length 2 between them), adding an edge creates a cycle of length 3, which is odd.\n\nSo if any pair of nodes u and v in the same component have a distance that is even, adding an edge between them would create a cycle of odd length (distance +1 is odd). So the minimal number of edges is 1, because that's all you need to add.\n\nWait, but wait. What if the component is a tree. Then, adding an edge between any two nodes in the same component creates exactly one cycle. The length of that cycle is the sum of the distances along the two paths from u to v plus 1, but actually, the length is the sum of the two path lengths plus 1, but that's not correct. Wait, no. The cycle created by adding an edge between u and v is the sum of the path from u to v through one way, plus the added edge. So the length is (number of edges in the path) + 1.\n\nSo the length is (path_length + 1). So if the path_length is even, adding the edge would make the cycle length even +1, which is odd. So that's good.\n\nWait, but if the path_length is even, then adding that edge gives a cycle of odd length.\n\nSimilarly, if the path_length is odd, adding the edge makes the cycle even.\n\nSo to form an odd-length cycle, we need to add an edge between two nodes u and v in the same component where the shortest path between u and v is even.\n\nThus, for each connected component, if there exists a pair of nodes u and v in the same component with even distance, then adding one edge between u and v would create an odd-length cycle.\n\nIn that case, the minimal t is 1, and the number of ways is the number of such pairs.\n\nBut wait, perhaps some components require more than one edge to be added to form an odd-length cycle.\n\nWait, for example, in a component that is a single node (n=1, m=0). To form a cycle, we need at least two nodes. So adding an edge isn't enough. So in such a case, we need to add two edges to form a triangle (but wait, a single node can't form a cycle of length more than one. So if the component has only one node, it's impossible to form a cycle, so we have to look elsewhere.\n\nWait, the problem says that the cycle must consist of more than one vertex. So in the case where all connected components are single nodes except for one, say, a component with two nodes and no edges. Then adding one edge between them forms a cycle of length 2, which is even, so not acceptable. So in this case, we have to add another edge to form a triangle with a third node.\n\nWait, but if the component has two nodes and no edge, adding one edge creates a cycle of length 2, which is even. Not acceptable. So we need to add two edges: for example, between node A and B, and then between A and C. Now, the cycle is A-B-A-C-A, but that's a cycle of length 4, which is even again. Hmm, wait, that's not helpful.\n\nWait, no. Maybe I'm getting confused.\n\nLet me think differently.\n\nTo form a cycle, we need a path that starts and ends at the same node without repeating any nodes. So the minimal cycle is a triangle (3 nodes), which is odd.\n\nSo, the strategy is:\n\n- For each connected component, determine whether it's possible to create a cycle of odd length by adding edges. Then, for each such possibility, calculate how many edges are needed and the number of ways.\n\nBut since the problem requires the minimal t, we need to find the smallest number of edges across all possibilities.\n\nSo let's break down the problem into steps.\n\nFirst, for each connected component, determine the minimal number of edges that need to be added to form an odd-length cycle.\n\nThen, among all these possibilities, select the minimal t, and sum the number of ways across all components.\n\nWait, but adding edges can connect components as well. So perhaps, the minimal t could be achieved by adding edges between two components.\n\nHmm, this complicates things.\n\nLet me think about each connected component.\n\nFor a connected component, if it's possible to form a cycle of odd length by adding edges within the component, then the minimal edges needed is 1 (if there exists a pair of nodes with even distance in the component). Otherwise, perhaps we need to connect it to another component.\n\nWait, but what if the component is a single node? Then, it's impossible to form a cycle, so we have to combine it with other components.\n\nSo, perhaps the approach is:\n\n1. For each connected component, compute the minimal number of edges that can be added within the component to form an odd cycle, if possible.\n\n2. For each pair of connected components, compute the minimal number of edges needed to connect them in such a way that together they form an odd cycle.\n\n3. Among all possibilities, find the overall minimal t, and the total ways.\n\nSo, let's model each component.\n\nCase 1: A component is a single node.\n\nTo form a cycle, we need at least two nodes. So, if this component is alone, we can't form a cycle on its own. So, we must connect it with another component.\n\nCase 2: A component is a tree.\n\nIn a tree, adding one edge creates exactly one cycle. The length of the cycle is the sum of the two path lengths from the two endpoints of the added edge, plus one.\n\nWait, no. Let me clarify: when you add an edge between u and v in a tree, the cycle formed is the path from u to v in the tree plus the added edge. So the length of the cycle is (distance(u, v) + 1).\n\nSo, if the distance is even, the cycle length is even+1=odd. Good.\n\nIf the distance is odd, the cycle length is even. Bad.\n\nSo, for a tree, to find if adding one edge can create an odd cycle, we need to find two nodes u and v in the component such that their distance is even.\n\nIf such a pair exists, then adding one edge is sufficient.\n\nSo for each tree component, we need to check if there exists a pair of nodes with even distance.\n\nIf yes, then for this component, the minimal edges is 1, and the number of ways is the count of such pairs.\n\nIf not, then we cannot form a cycle in this component by adding one edge; perhaps we need to connect it to another component.\n\nCase 3: A component has a cycle already.\n\nIf the component has a cycle, but all cycles in it are even-length, then perhaps adding one edge can create an odd-length cycle.\n\nWait, no. Because the component may already have cycles, but perhaps they are even.\n\nWait, for example, a component is a square (cycle of 4). Adding an edge between two non-adjacent nodes may create a triangle. Like, imagine a square with four nodes: A-B-C-D-A. If we add an edge between A and C, the cycle becomes A-B-C-A, which is a triangle (length 3). So, yes.\n\nSo, in this case, adding one edge is sufficient.\n\nBut wait, what's the distance between A and C in the square? It's 2 (A-B-C). So adding the edge between them creates a cycle of length 3, which is odd.\n\nSo, in this case, the component can form a cycle with one additional edge.\n\nSo, for any component that is not a tree and has a cycle, but perhaps the existing cycles are even, adding an edge can create an odd cycle.\n\nWait, but perhaps not always.\n\nHmm, maybe the approach is that for any component that is not a tree (i.e., has a cycle), then it's possible to form an odd cycle by adding one edge, provided that the component has at least two nodes.\n\nBecause, for example, in a component that's a triangle, it's already an odd cycle, so t is 0.\n\nBut for a component like a square, adding one edge can create a smaller cycle.\n\nSo, perhaps, for any component that is connected and has more than one node, it can contribute a way to form an odd cycle with t=0, 1, or 2 edges, depending on whether it already has an odd cycle, or can form one by adding 1 or more edges.\n\nBut this seems complicated.\n\nAn alternative approach is to model each connected component and determine the minimal edges required for that component to form an odd cycle, either alone or in combination with other components.\n\nBut perhaps it's easier to think about the entire graph.\n\nLet me consider the following steps:\n\n1. Find all connected components.\n\n2. For each component, determine whether it's possible to form an odd cycle by adding some edges within it, possibly requiring 0, 1, or 2 edges.\n\n3. Also, consider the possibility of combining two components, perhaps via adding one edge between them, to form an odd cycle.\n\nSo, for each component, compute the minimal edges required to form an odd cycle in that component, and the number of ways.\n\nThen, compare all possibilities across all components and combinations of components to find the minimal t and the corresponding w.\n\nSo, let's think about each component.\n\nFor a component with size 1 (n=1):\n\n- No edges can form a cycle. So, we need to connect it with other components.\n\nFor a component with size >=2:\n\n- Check if it already contains an odd cycle.\n\n   - If yes, then t=0 for this component, w=1.\n\n- Else, check if adding 1 edge can create an odd cycle.\n\n   - If there exists u and v in the component with even distance, then adding one edge between u and v creates a cycle of odd length. So t=1, w is the number of such pairs.\n\n- Else, perhaps we need to add two edges.\n\nWait, why else? Because if all pairs have odd distance, then adding one edge would create a cycle of even length, which is not allowed. So, perhaps, we need to add two edges to form an odd cycle.\n\nHow?\n\nFor example, if the component is a tree with all node pairs having odd distance. Then, adding two edges may allow for an odd cycle.\n\nBut how?\n\nAlternatively, perhaps the component is such that adding two edges can create a cycle of odd length.\n\nBut I'm not sure. Let's think of an example.\n\nSuppose we have a tree that is a straight line of three nodes: A-B-C. The distance between A and C is 2 (even). So adding an edge between A and C creates a cycle of length 3 (odd). So, in this case, t=1, w=1.\n\nWait, but earlier I thought that if the distance is even, adding the edge is good.\n\nSo, perhaps the initial analysis holds.\n\nWait, maybe the condition is: in a component, if there exists any pair of nodes with even distance, then adding one edge is sufficient.\n\nOtherwise, adding two edges may be needed.\n\nSo, for a component where all node pairs have an odd distance, then any added edge will create a cycle of even length (since the distance is odd, adding the edge creates a cycle of length (distance +1) = even).\n\nSo, in that case, adding one edge won't help. So, perhaps, we need to add two edges.\n\nBut how?\n\nWell, suppose we have a component that's a tree where all pairs have odd distance. Then, perhaps adding two edges can create a cycle of odd length.\n\nFor example, take the component as a chain of four nodes: A-B-C-D. The distance between A and D is 3 (odd). So adding an edge between A and D would create a cycle of length 4 (even). Not good.\n\nBut if we add two edges: between A and C, and between B and D. Then, the cycle could be A-B-D-C-A, which is a cycle of length 4, even. Hmm, not helpful.\n\nWait, maybe I'm approaching this wrong.\n\nAlternatively, perhaps for a component that's a tree with all pairs having odd distance, we can't form an odd cycle by adding edges within the component. So, we have to connect it with another component.\n\nBut how?\n\nWait, perhaps the component is a single node. So, to form a cycle, we need to add edges to create a triangle.\n\nSo, for a single node, to form a cycle, we need to add at least two edges to connect it to two other nodes, forming a triangle.\n\nSo, the minimal t would be 2, and the number of ways is the number of ways to choose two other nodes in other components.\n\nWait, but this is getting complicated.\n\nMaybe the steps are as follows:\n\nCompute for each connected component:\n\n- Whether it's possible to form an odd cycle by adding edges within it.\n\n- The minimal number of edges required.\n\n- The number of ways to do so.\n\nAdditionally, compute the possibility of connecting two components via one edge to form an odd cycle.\n\nSo, for each pair of components (including itself?), compute whether adding an edge between them can form an odd cycle.\n\nWait, perhaps the minimal t can be achieved either by adding edges within a single component or by connecting two components.\n\nSo, for each component, compute:\n\n- The minimal edges required to form an odd cycle within it.\n\n- The number of ways.\n\nThen, for each pair of components, compute whether adding an edge between them can create an odd cycle. For such pairs, the minimal edges is 1, and the number of ways is the product of the number of ways for each component to contribute to forming a cycle.\n\nWait, perhaps not. Because adding an edge between two components may create a cycle that uses nodes from both.\n\nBut how to model that.\n\nAlternatively, perhaps the minimal t is the minimum of:\n\n- All the minimal edges required for each component to form an odd cycle within itself.\n\n- 1, multiplied by the number of pairs of components that can be connected to form an odd cycle.\n\nWait, perhaps that's the way to go.\n\nSo, let's outline the steps.\n\n1. For each connected component, determine the minimal number of edges required to form an odd cycle within it. Also, compute the number of ways to do this.\n\n   - For a component with size 1: it's impossible to form a cycle alone. So, the minimal edges required is 2 (to connect to two other nodes, forming a triangle). The number of ways is the number of ways to choose two other nodes from other components.\n\n   - For a component with size >=2:\n\n      a. Check if it already has an odd cycle. If yes, minimal t is 0, ways is 1.\n\n      b. Else, check if there exists a pair of nodes in the component with even distance. If yes, then minimal t is 1, ways is the count of such pairs.\n\n      c. Else, minimal t is 2, ways is the number of ways to add two edges to form an odd cycle.\n\n         How? Well, perhaps in this case, the component is a tree with all pairs having odd distance. So, adding two edges can form a cycle.\n\n         But I'm not sure. This part is unclear.\n\n2. For each pair of components (C1, C2), determine if adding an edge between them can create an odd cycle. If so, the minimal edges is 1, and the number of ways is the product of the number of ways for C1 and C2 to contribute to the cycle.\n\nWait, but how does adding an edge between two components form a cycle? Because the edge connects two nodes in different components, so the cycle would use nodes from both components.\n\nWait, for example, if C1 is a tree with a single node (A), and C2 is a triangle (B-C-D-B). Adding an edge between A and B creates a cycle A-B-C-D-B-A, which is length 5, odd.\n\nSo, in this case, adding one edge between C1 and C2 forms an odd cycle. So, for this pair, the minimal edges is 1, and the number of ways is the number of ways to choose u in C1 and v in C2.\n\nBut wait, in this case, C1 is a single node, so the number of ways is 1 * 3 (the number of nodes in C2) ?\n\nNo, because adding an edge between A and any of the three nodes in C2 would suffice. So, for each node in C2, there's a way. So, for C1, the number of ways is 1 (only one node), and for C2, the number of ways is 3 (each node can be connected). So, the total ways is 1 * 3 = 3.\n\nBut in this scenario, the minimal t is 1.\n\nSo, for each pair of components, compute whether adding one edge between them can form an odd cycle.\n\nIf yes, then for this pair, the minimal edges is 1, and the number of ways is the product of the ways in each component to contribute to the cycle.\n\nWait, but what defines the ways for each component in this case?\n\nPerhaps, for the pair (C1, C2), the number of ways is the number of possible edges between C1 and C2 that, when added, form an odd cycle.\n\nWhich is the number of edges between C1 and C2.\n\nBut wait, no. Because adding any edge between C1 and C2 may or may not form an odd cycle.\n\nWait, no. Because the cycle length would be the distance between u (in C1) and v (in C2) plus 1. So, if the distance between u and v is even, then the cycle length is odd.\n\nSo, for any pair u in C1, v in C2, the distance between u and v is the sum of the distances from u to any node in C1's component and from v to any node in C2's component. Since u is in C1 and v is in C2, and the components are separate, the distance is (d_u + d_v), where d_u is the distance from u to any node in C1 (which is zero, because C1 is connected), and d_v is the distance from v to any node in C2 (also zero). Wait, no. Because u is in C1, and v is in C2. The distance between u and v is the sum of the distances from u to any node in C1 (which is zero, as u is in C1) plus the distance from v to any node in C2 (zero, as v is in C2). Wait, that's not correct.\n\nWait, no. The distance between u and v is the minimal path length through the graph. Since the two components are separate, the distance between u and v is infinity. Wait, but that's not correct. Because in the original graph, u and v are in different components, so the distance between them is undefined. So, when we add an edge between them, the distance becomes 1, which is odd.\n\nWait, that's a crucial point. When we add an edge between u in C1 and v in C2, the cycle formed is u-v-u, which is a cycle of length 2, which is even. So that's not acceptable.\n\nWait, no. Because the cycle must consist of more than one vertex. So, a cycle of length 2 is not allowed.\n\nSo, adding an edge between u and v (from different components) creates a cycle of length 2, which is even. So that's not good.\n\nWait, so in that case, adding an edge between two components is not helpful, because it forms a cycle of even length.\n\nSo, the only way to form an odd cycle is either:\n\n- Within a component, adding 0, 1, or 2 edges.\n\n- Or, connecting three components in a way that forms an odd cycle.\n\nWait, but that seems complicated.\n\nAlternatively, perhaps the only way to form an odd cycle is within a single component, because adding edges between components can't create a cycle of odd length greater than 2, which is invalid.\n\nWait, that's a critical insight.\n\nBecause adding an edge between two components creates a cycle of length 2, which is even. So, such an addition doesn't help us.\n\nSo, the conclusion is that to form an odd cycle, we must form it entirely within a single connected component, either by adding 0, 1, or 2 edges.\n\nSo, now the problem reduces to:\n\nFor each connected component, compute the minimal edges required to form an odd cycle within that component, and the number of ways.\n\nThen, among all components, find the minimal t, and sum the number of ways across all components that contribute to that minimal t.\n\nWait, but wait: perhaps the minimal t is achieved by using multiple components.\n\nBut according to the above reasoning, adding edges between components can't help, because the cycle formed is even.\n\nSo, the only way to form an odd cycle is to have it entirely within a single component.\n\nSo, that simplifies things.\n\nSo, now the steps are:\n\nFor each connected component:\n\n1. If the component has size 1: To form a cycle, we need to connect it to two other components, adding two edges.\n\n   So, minimal t is 2.\n\n   Number of ways: the number of ways to choose two other nodes from other components, multiplied by the number of edges between this component and those two nodes.\n\n   Wait, no. Because the single-node component needs to connect to two other nodes, forming a triangle.\n\n   So, the single node must connect to two distinct nodes in other components.\n\n   So, the number of ways is (k choose 2), where k is the total number of nodes in other components.\n\n   But no, because each edge is considered as a unique option.\n\n   Alternatively, the number of ways is (sum over all possible pairs of nodes in other components of the product of the number of ways to add edges between the single node and each of them).\n\n   Hmm, perhaps it's easier to model this as:\n\n   - The single component can't form a cycle on its own. So, to form a cycle, it must be connected to at least two other nodes, which implies that the component must be connected to at least two other components, each contributing one node.\n\n   So, for each pair of nodes in other components, add two edges: one from the single node to each of them. This forms a cycle of length 3 (single node, node1, node2) → length is 3, which is odd.\n\n   So, the minimal t is 2.\n\n   The number of ways is the number of possible pairs of nodes in other components, multiplied by the number of ways to connect the single node to each of them.\n\n   Wait, but in the problem statement, the edges are added as sets. So, the order doesn't matter. So, choosing node A and node B from other components is the same as choosing node B and node A.\n\n   So, the number of ways is the number of unordered pairs of nodes in other components, multiplied by 1 (since the single node can only connect to each node once).\n\n   So, the number of ways is C, where C is the number of ways to choose two distinct nodes from other components.\n\n   But wait, other components may have varying numbers of nodes. So, it's the sum over all pairs of components (C_i, C_j), i < j, of the product of the number of nodes in C_i and C_j.\n\n   Because for each such pair, the single component can connect to any node in C_i and any node in C_j.\n\n   So, the total number of ways is the sum for all i < j of (size(C_i) * size(C_j)).\n\n   Additionally, the single component can connect to a component with at least two nodes, selecting any two nodes in that component. Wait, no, because in that case, the single node connects to two nodes in the same component. But that would require adding two edges, but perhaps the two nodes are already connected in that component, but that's irrelevant.\n\n   So, the total number of ways for the single component is the sum of size(C_i) * size(C_j) for all i < j, where C_i and C_j are components different from the single component.\n\n   But this is getting complicated. Maybe the minimal t for the single component is 2, and the number of ways is the sum of the products of sizes of all pairs of other components.\n\n   But if there are less than two other components, then it's impossible. For example, if the graph has only one component (the single node), then it's impossible to form a cycle, so the answer is that it's impossible.\n\n   But the problem statement says that the graph is given, and it's possible to form a cycle. Or wait, no—the problem doesn't specify that. So, we have to handle cases where it's impossible.\n\n   Wait, but the problem requires us to find t and w. So, if it's impossible, then t is infinity, and w is zero.\n\n   So, we need to consider that.\n\nSo, summarizing:\n\nFor each connected component:\n\n- If the component has size 1:\n\n   a. To form a cycle, we need to connect it to two other components. Each connection adds one edge.\n\n   b. So, minimal t is 2.\n\n   c. Number of ways is the sum of (size of C_i) * (size of C_j) for all i < j, where C_i and C_j are components different from the single component.\n\n   d. However, if there are less than two other components, then it's impossible. So, for a single component, if there are less than two other components, the minimal t is infinity.\n\n- Else:\n\n   a. Check if the component has an odd cycle. If yes, t=0, w=1.\n\n   b. Else, check if there exists a pair of nodes in the component with even distance. If yes, t=1, w is the count of such pairs.\n\n   c. Else, t=2, w is the number of ways to add two edges to form an odd cycle.\n\nBut wait, in the case of a component that is a tree with all node pairs having odd distance, adding two edges may or may not form an odd cycle.\n\nThis is the tricky part.\n\nIn such a component, adding two edges may create a cycle, but what's the length?\n\nIt depends on how the edges are added.\n\nFor example, consider a chain of three nodes: A-B-C. The distance between A and C is 2 (even). So, adding an edge between A and C creates a cycle of length 3 (odd), which is good. So, in this case, the minimal t is 1.\n\nWait, but earlier I thought that if the component is a tree with all pairs having odd distance, then the minimal t is 1.\n\nBut this contradicts that assumption.\n\nSo perhaps my earlier reasoning was incorrect.\n\nWait, perhaps the condition is that if the component has any two nodes with even distance, then adding one edge is sufficient.\n\nElse, if the component is a tree, but it's impossible to find such a pair, then adding two edges is needed.\n\nSo, perhaps the step is:\n\nFor a component:\n\n- If it's a tree:\n\n   - Compute the number of pairs of nodes with even distance.\n\n   - If any such pair exists, then t=1, w is the count of such pairs.\n\n   - Else, t=2, and the number of ways is ... ?\n\nBut how to compute the number of ways when t=2.\n\nWait, in a tree where all pairs have odd distance, adding two edges can form a cycle.\n\nBut how? Because adding two edges can create a cycle, but what's the length.\n\nLet me think of an example.\n\nTake a star-shaped tree: a central node connected to three leaves: A, B, C.\n\nThe distances:\n\nA-B: 2 (through central node)\n\nA-C: 2\n\nB-C: 2.\n\nSo, all pairs have even distance.\n\nSo, adding an edge between A and B would create a cycle of length 3.\n\nSo, in this case, it's handled by the t=1 case.\n\nWait, but in this case, the component is a tree, but all pairs have even distance. So, adding one edge is sufficient.\n\nWait, maybe I made a mistake earlier.\n\nWait, let's re-examine:\n\nIn a tree, the distance between any two nodes is the number of edges on the unique path between them.\n\nSo, the parity of the distance depends on the path length.\n\nSo, for a tree, the parity of the distance between u and v is equal to the depth of u XOR depth of v, where depth is the distance from the root.\n\nBecause in a tree, the path between u and v is the path from u to the root, then from the root to v. The sum of the depths minus twice the depth of the lowest common ancestor (LCA) is the distance between u and v.\n\nWait, maybe not. Let's think differently.\n\nIn a tree, the parity of the distance between u and v is equal to the parity of (depth[u] - 2*depth[lca(u,v)] + depth[v]).\n\nWhich simplifies to the parity of (depth[u] + depth[v]).\n\nBecause 2*d is even.\n\nSo, the parity of the distance between u and v is the same as the parity of (depth[u] + depth[v]).\n\nSo, for the entire tree, if the root has even depth (say, 0), then:\n\n- For any node at depth even, any node at depth even will have even distance.\n\n- Any node at depth even and node at depth odd will have odd distance.\n\n- Similarly for nodes at depth odd.\n\nSo, in a tree, if the root's depth is even, then there are some pairs of nodes with even distance, specifically those in the same parity.\n\nSo, for a tree, if the root has even depth, then all nodes at even levels can form pairs with even distance.\n\nSo, in such a tree, adding one edge between any two nodes at even levels will create a cycle of odd length.\n\nSo, the component can be handled with t=1.\n\nWait, but what if the root's depth is odd.\n\nThen, the same logic applies: nodes at even levels and nodes at odd levels have odd distance.\n\nSo, any two nodes with the same parity (even or odd) in the tree will have even distance.\n\nSo, in this case, adding one edge between any two nodes with the same parity will create a cycle of odd length.\n\nSo, in any tree, there exist pairs of nodes with even distance, so adding one edge is sufficient.\n\nWait, that's a crucial realization.\n\nSo, for any tree component, adding one edge between any two nodes with even distance will create a cycle of odd length.\n\nThus, for a tree component, the minimal t is 1, and the number of ways is the number of such pairs.\n\nSo, this simplifies the problem.\n\nThus, for each component:\n\n- If the component is a tree:\n\n   t=1, w=count of pairs of nodes with even distance.\n\n- Else:\n\n   Check if the component has an odd cycle. If yes, t=0, w=1.\n\n   Else:\n\n      Check if there's a pair with even distance. If yes, t=1, w=count.\n\n      Else:\n\n         t=2, w=... ?\n\nWait, but when is it possible for a component (not a tree) to have no pairs of nodes with even distance?\n\nBecause, in a component that is not a tree, it has at least one cycle.\n\nSo, in such a component, perhaps there exists a pair of nodes with even distance.\n\nBecause the presence of a cycle implies that there are at least two nodes at even distance.\n\nWait, for example, a cycle of even length. Any two opposite nodes have even distance.\n\nBut what about a component that is a single cycle of even length, say, a square (A-B-C-D-A). The distances between A and C is 2 (even), A and B is 1 (odd), etc.\n\nSo, in this component, there are pairs with even distance. So, adding one edge between A and C creates a cycle of length 3, which is odd.\n\nThus, for any component that is not a tree, there exists a pair of nodes with even distance.\n\nSo, for such components, t=1.\n\nSo, putting it all together:\n\nFor each connected component:\n\n- If the component is a single node:\n\n   a. To form a cycle, it must connect to two other nodes in other components.\n\n   b. So, minimal t is 2.\n\n   c. The number of ways is the sum of size(C_i) * size(C_j) for all i < j, where C_i and C_j are other components.\n\n   d. However, if there are fewer than two other components, it's impossible, so t is infinity.\n\n- Else if the component is a tree:\n\n   a. Minimal t is 1.\n\n   b. The number of ways is the count of pairs of nodes with even distance.\n\n- Else (component is not a tree):\n\n   a. Minimal t is 0 if it already has an odd cycle.\n\n   b. Else, t=1, since there exists a pair with even distance.\n\n   c. Number of ways is the count of such pairs.\n\nWait, but wait: in a component that is not a tree, but all cycles are even-length. Does it have a pair with even distance?\n\nYes, because in a cycle, the distance between two nodes diametrically opposite is even.\n\nThus, for any component that is not a tree, the minimal t is 1, except if the component already has an odd cycle.\n\nWait, no.\n\nWait, if the component has an odd cycle, then t=0.\n\nElse, for a component that is not a tree, it must have at least one cycle. In that case, the component has a pair of nodes with even distance.\n\nSo, t=1, w is the count of such pairs.\n\nSo, the revised algorithm is:\n\nFor each component:\n\n- If size is 1:\n\n   - Need to connect to two other components. So, t=2.\n\n   - Ways: sum over all i<j of (size(C_i)*size(C_j)).\n\n   - But if the number of other components is less than 2, it's impossible.\n\n- Else:\n\n   - If it's a tree: t=1, ways is the count of pairs with even distance.\n\n   - Else:\n\n      - If the component has an odd cycle: t=0, ways=1.\n\n      - Else: t=1, ways is the count of pairs with even distance.\n\nThus, the minimal t across all components is the minimal of all component's t.\n\nBut wait, no. Because each component contributes a possible way to form an odd cycle.\n\nSo, the minimal t",
    "response": "To solve this problem, we need to determine the minimum number of edges to add to a graph to form a simple cycle of odd length and count the number of ways to achieve this. The graph is undirected, has no loops or parallel edges, and may not be connected.\n\n### Approach\n1. **Identify Connected Components**: The graph is divided into connected components. Each component can be analyzed separately to determine the minimum edges needed to form an odd-length cycle.\n2. **Single Node Component**: If a component consists of a single node, it must connect to two other nodes from different components to form a cycle, requiring 2 edges.\n3. **Tree Components**: For tree components, check if there exists a pair of nodes with an even distance. If such a pair exists, adding one edge between them creates an odd-length cycle.\n4. **Non-Tree Components**: For components that are not trees, check if they already contain an odd-length cycle. If not, check for pairs of nodes with even distances to determine if adding one edge can form an odd-length cycle.\n\n### Solution Code\n```python\nimport sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx +=1\n\n    edges = [[] for _ in range(n+1)]\n    for _ in range(m):\n        a = int(input[idx])\n        idx +=1\n        b = int(input[idx])\n        idx +=1\n        edges[a].append(b)\n        edges[b].append(a)\n\n    visited = [False] * (n+1)\n    components = []\n\n    for v in range(1, n+1):\n        if not visited[v]:\n            q = deque()\n            q.append(v)\n            visited[v] = True\n            comp = []\n            while q:\n                u = q.popleft()\n                comp.append(u)\n                for nei in edges[u]:\n                    if not visited[nei]:\n                        visited[nei] = True\n                        q.append(nei)\n            components.append(comp)\n\n    # Process each component\n    min_t = float('inf')\n    total_ways = 0\n\n    for comp in components:\n        size = len(comp)\n        if size == 1:\n            # Need to connect to two other components\n            num_other = len(components) -1\n            if num_other < 2:\n                # Impossible\n                continue\n            ways = 0\n            for i in range(len(components)):\n                if i == 0: continue\n                for j in range(i+1, len(components)):\n                    if i != 0 and j !=0:\n                        ways += size * size * (len(components[i]) * len(components[j]))\n            if ways >0:\n                if 2 < min_t:\n                    min_t =2\n                    total_ways = ways\n                elif 2 == min_t and ways > total_ways:\n                    total_ways = ways\n            continue\n        # Else, size >=2\n        # Check if it's a tree\n        if len(edges[comp[0]] + edges[comp[-1]]) == len(set(edges[comp[0]] + edges[comp[-1]]))):\n            # It's a tree\n            depth = {comp[0]:0}\n            q = deque()\n            q.append(comp[0])\n            while q:\n                u = q.popleft()\n                for v in edges[u]:\n                    if v not in depth:\n                        depth[v] = depth[u] +1\n                        q.append(v)\n            even_pairs = 0\n            for u in comp:\n                for v in comp:\n                    if u != v:\n                        if (depth[u] + depth[v]) %2 ==0:\n                            even_pairs +=1\n            if even_pairs >0:\n                if 1 < min_t:\n                    min_t =1\n                    total_ways = even_pairs\n                elif 1 == min_t and even_pairs > total_ways:\n                    total_ways = even_pairs\n                continue\n        # Else, not a tree. Check if it has an odd cycle\n        has_odd_cycle = False\n        # To detect if any cycle is odd, perform BFS and track distances\n        visited_bfs = {u: {} for u in comp}\n        for u in comp:\n            visited_bfs[u][u] =0\n            q = deque()\n            q.append(u)\n            found = False\n            while q:\n                current = q.popleft()\n                for nei in edges[current]:\n                    if nei not in visited_bfs[current]:\n                        visited_bfs[current][nei] = visited_bfs[current][current] +1\n                        q.append(nei)\n                        if visited_bfs[current][nei] %2 ==1:\n                            # Found a path of odd length back to u\n                            # So, there's an odd cycle\n                            found = True\n                            break\n                if found:\n                    break\n            if found:\n                has_odd_cycle = True\n                break\n        if has_odd_cycle:\n            if 0 < min_t:\n                min_t =0\n                total_ways =1\n            elif 0 == min_t and 1 > total_ways:\n                total_ways =1\n            continue\n        else:\n            # Not a tree, not having odd cycle, but must have even pairs\n            # So, t=1\n            even_pairs =0\n            for u in comp:\n                for v in comp:\n                    if u !=v:\n                        d =0\n                        q = deque()\n                        q.append(u)\n                        dist = {u:0}\n                        while q:\n                            curr = q.popleft()\n                            for nei in edges[curr]:\n                                if nei not in dist:\n                                    dist[nei] = dist[curr] +1\n                                    q.append(nei)\n                                    if (dist[curr] +1 + dist[nei]) %2 ==0:\n                                        pass\n                                    else:\n                                        d = dist[nei]\n                                        break\n                            else:\n                                continue\n                            break\n                        if d != -1:\n                            even_pairs +=1\n                        else:\n                            # Compute distance using BFS\n                            dist = {}\n                            q = deque()\n                            q.append(u)\n                            dist[u] =0\n                            found = False\n                            while q:\n                                curr = q.popleft()\n                                for nei in edges[curr]:\n                                    if nei not in dist:\n                                        dist[nei] = dist[curr]+1\n                                        q.append(nei)\n                                        if (dist[curr]+1 + dist[nei]) %2 ==0:\n                                            # Possible even pair\n                                            pass\n                                        else:\n                                            d = dist[nei]\n                                            break\n                                else:\n                                    continue\n                                break\n                            if d != -1:\n                                even_pairs +=1\n                        if even_pairs >0:\n                            break\n            if even_pairs >0:\n                if 1 < min_t:\n                    min_t =1\n                    total_ways = even_pairs\n                elif 1 == min_t and even_pairs > total_ways:\n                    total_ways = even_pairs\n                continue\n            else:\n                # This should not happen as non-tree has cycles, but handle it\n                min_t =2\n                # How? Need to find two edges to form a triangle\n                # But how?\n                # Maybe it's impossible, but according to earlier logic, it should have some even pairs\n                # So, perhaps this case won't happen, but for now, skip\n                continue\n\n    if min_t == float('inf'):\n        print(\"Impossible\")\n        return\n\n    print(f\"{min_t} {total_ways}\")\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\nThe solution involves identifying connected components in the graph and analyzing each component to determine the minimum number of edges required to form an odd-length cycle. For single-node components, two edges are needed to form a cycle. For tree components, one edge is sufficient if there exists a pair of nodes with an even distance. For non-tree components, one edge is also sufficient if they do not already contain an odd-length cycle. The solution efficiently checks each component and computes the minimal edges and ways accordingly.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx +=1\n\n    edges = [[] for _ in range(n+1)]\n    for _ in range(m):\n        a = int(input[idx])\n        idx +=1\n        b = int(input[idx])\n        idx +=1\n        edges[a].append(b)\n        edges[b].append(a)\n\n    visited = [False] * (n+1)\n    components = []\n\n    for v in range(1, n+1):\n        if not visited[v]:\n            q = deque()\n            q.append(v)\n            visited[v] = True\n            comp = []\n            while q:\n                u = q.popleft()\n                comp.append(u)\n                for nei in edges[u]:\n                    if not visited[nei]:\n                        visited[nei] = True\n                        q.append(nei)\n            components.append(comp)\n\n    # Process each component\n    min_t = float('inf')\n    total_ways = 0\n\n    for comp in components:\n        size = len(comp)\n        if size == 1:\n            # Need to connect to two other components\n            num_other = len(components) -1\n            if num_other < 2:\n                # Impossible\n                continue\n            ways = 0\n            for i in range(len(components)):\n                if i == 0: continue\n                for j in range(i+1, len(components)):\n                    if i != 0 and j !=0:\n                        ways += size * size * (len(components[i]) * len(components[j]))\n            if ways >0:\n                if 2 < min_t:\n                    min_t =2\n                    total_ways = ways\n                elif 2 == min_t and ways > total_ways:\n                    total_ways = ways\n            continue\n        # Else, size >=2\n        # Check if it's a tree\n        if len(edges[comp[0]] + edges[comp[-1]]) == len(set(edges[comp[0]] + edges[comp[-1]]))):\n            # It's a tree\n            depth = {comp[0]:0}\n            q = deque()\n            q.append(comp[0])\n            while q:\n                u = q.popleft()\n                for v in edges[u]:\n                    if v not in depth:\n                        depth[v] = depth[u] +1\n                        q.append(v)\n            even_pairs = 0\n            for u in comp:\n                for v in comp:\n                    if u != v:\n                        if (depth[u] + depth[v]) %2 ==0:\n                            even_pairs +=1\n            if even_pairs >0:\n                if 1 < min_t:\n                    min_t =1\n                    total_ways = even_pairs\n                elif 1 == min_t and even_pairs > total_ways:\n                    total_ways = even_pairs\n                continue\n        # Else, not a tree. Check if it has an odd cycle\n        has_odd_cycle = False\n        # To detect if any cycle is odd, perform BFS and track distances\n        visited_bfs = {u: {} for u in comp}\n        for u in comp:\n            visited_bfs[u][u] =0\n            q = deque()\n            q.append(u)\n            found = False\n            while q:\n                current = q.popleft()\n                for nei in edges[current]:\n                    if nei not in visited_bfs[current]:\n                        visited_bfs[current][nei] = visited_bfs[current][current] +1\n                        q.append(nei)\n                        if visited_bfs[current][nei] %2 ==1:\n                            # Found a path of odd length back to u\n                            # So, there's an odd cycle\n                            found = True\n                            break\n                if found:\n                    break\n            if found:\n                has_odd_cycle = True\n                break\n        if has_odd_cycle:\n            if 0 < min_t:\n                min_t =0\n                total_ways =1\n            elif 0 == min_t and 1 > total_ways:\n                total_ways =1\n            continue\n        else:\n            # Not a tree, not having odd cycle, but must have even pairs\n            # So, t=1\n            even_pairs =0\n            for u in comp:\n                for v in comp:\n                    if u !=v:\n                        d =0\n                        q = deque()\n                        q.append(u)\n                        dist = {u:0}\n                        while q:\n                            curr = q.popleft()\n                            for nei in edges[curr]:\n                                if nei not in dist:\n                                    dist[nei] = dist[curr] +1\n                                    q.append(nei)\n                                    if (dist[curr] +1 + dist[nei]) %2 ==0:\n                                        pass\n                                    else:\n                                        d = dist[nei]\n                                        break\n                            else:\n                                continue\n                            break\n                        if d != -1:\n                            even_pairs +=1\n                        else:\n                            # Compute distance using BFS\n                            dist = {}\n                            q = deque()\n                            q.append(u)\n                            dist[u] =0\n                            found = False\n                            while q:\n                                curr = q.popleft()\n                                for nei in edges[curr]:\n                                    if nei not in dist:\n                                        dist[nei] = dist[curr]+1\n                                        q.append(nei)\n                                        if (dist[curr]+1 + dist[nei]) %2 ==0:\n                                            # Possible even pair\n                                            pass\n                                        else:\n                                            d = dist[nei]\n                                            break\n                                else:\n                                    continue\n                                break\n                            if d != -1:\n                                even_pairs +=1\n                        if even_pairs >0:\n                            break\n            if even_pairs >0:\n                if 1 < min_t:\n                    min_t =1\n                    total_ways = even_pairs\n                elif 1 == min_t and even_pairs > total_ways:\n                    total_ways = even_pairs\n                continue\n            else:\n                # This should not happen as non-tree has cycles, but handle it\n                min_t =2\n                # How? Need to find two edges to form a triangle\n                # But how?\n                # Maybe it's impossible, but according to earlier logic, it should have some even pairs\n                # So, perhaps this case won't happen, but for now, skip\n                continue\n\n    if min_t == float('inf'):\n        print(\"Impossible\")\n        return\n\n    print(f\"{min_t} {total_ways}\")\n\nif __name__ == '__main__':\n    main()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 569,
        "completion_token_count": 1719,
        "thoughts_token_count": 8193
    }
}