{
    "start": 1758103657.8831224,
    "end": 1758103786.3123522,
    "start-formatted": "2025-09-17 19:07 KST",
    "end-formatted": "2025-09-17 19:09 KST",
    "gpu": 2,
    "pid": 7,
    "use_openrouter": false,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let me read it carefully.\n\nThe problem is about determining whether a snowflake graph with n vertices can exist. The snowflake is constructed in a specific way, and I need to check for each test case if such a graph is possible.\n\nLet's break down the snowflake structure. The initial graph has one vertex. Then, we add k new vertices connected to this initial one. So after the first step, there are 1 + k = k+1 vertices. But wait, the initial step is when you connect the initial vertex to k new ones, which means each of those k has one edge (to the initial), so they are leaves. \n\nThen, each leaf that has only one connection (so any of these new ones) must be connected to k new vertices. And this step must be done at least once. So the process is:\n\n- Start with 1 node.\n- Add layer 1: connect to k nodes. Now total is 1 + k.\n- For each leaf in layer 1 (those k nodes), add layer 2: each connects to k new nodes. So each contributes k nodes, but since each leaf adds k, total added in layer 2 is k * k = k². So total becomes 1 +k +k².\n\nBut wait, the problem says that each step where a vertex has degree 1 (i.e., a leaf) must add k new children. And this step is done at least once. So the minimal snowflake is when after adding layer 1, we perform the expansion step once. So the minimal case is when k=4, as in the example, which gives 1+4+4*4 = 21? Or wait, let me calculate.\n\nWait, in the example given, for k=4, the smallest snowflake has 9 vertices. Let me see: 1 (root) + 4 (layer 1) + 4*4=16 (layer 2). Wait, that's 1 +4 +16=21. But the sample input says 9 is output as NO. Hmm, maybe I'm misunderstanding.\n\nWait, the sample input includes 9, and the output is 'NO'. So perhaps my understanding is wrong.\n\nWait the problem says that each vertex that is connected by edges to only one other vertex (i.e., leaves) must be connected by edges to k new vertices. This step should be done at least once.\n\nSo for the minimal case, the process is:\n\nStart with 1 node.\n\nAdd layer 1: connect to k nodes. So total is 1 +k.\n\nThen, for each of those k nodes, add k children. So layer 2 has k*k nodes.\n\nThus, the minimal snowflake has 1 +k +k^2 nodes.\n\nWait, but in the sample input, when n=9, the answer is 'NO', but 9 doesn't fit into 1 +k +k² for any integer k>1. Let's check:\n\nn=9: 1 +k +k² =9 → k² +k -8=0 → discriminant is 1+32=33, sqrt(33)=5.744, so roots (-1 ±5.744)/2 → positive root is (4.744)/2 ≈ 2.372. So k can't be an integer. Hence, 9 is not possible, which matches the sample.\n\nAnother sample is 6: the output is 'NO'. Let's see if any k satisfies 1 +k +k² =6. 1 +k +k²=6 → k² +k -5=0. Discriminant 1+20=21, sqrt(21) ~4.583, roots (-1 +4.583)/2 ~1.791. Not integer. So 6 is not a sum of 1 +k +k².\n\nWhat about 13? 1 +k +k²=13 → k² +k -12=0 → roots (-1 ±sqrt(49))/2 → (7-1)/2=3. So k=3. So yes, for k=3, 1+3+9=13, which is correct. So the sample's 13 is 'YES'.\n\nSimilarly, 15: Let's see. 1 +k +k²=15 → k² +k -14=0. Discriminant 1+56=57, sqrt(57)~7.55. Roots (-1+7.55)/2 ≈ 3.27. Not integer. So no. But the sample output is 'YES' for 15. Hmm, so maybe my initial approach is wrong.\n\nWait, perhaps the process can have multiple layers beyond the second. Like, after layer 2, you can have layer 3, which would involve expanding each leaf again.\n\nWait, the",
    "response": "To solve this problem, we need to determine if a snowflake graph with `n` vertices can exist. The snowflake graph is constructed in a specific way, and we need to check for each test case if such a graph is possible.\n\n### Approach\n1. **Understanding the Snowflake Structure**: The snowflake graph starts with one vertex. Then, it expands by adding layers of vertices. Each leaf node (a node with only one connection) must be expanded by adding `k` new nodes. This expansion step must be done at least once.\n2. **Formulating the Problem**: For a given number of vertices `n`, we need to check if there exists an integer `k > 1` such that `n` can be expressed as `1 + k + k^2 + ... + k^m`, where `m` is the number of expansion steps. The minimal case is when `m = 2`, giving `n = 1 + k + k^2`.\n3. **Check Possible Values**: For each `n`, we check if it can be written in the form `1 + k * (k^m - 1)/(k - 1)` for some integer `m >= 2` and `k > 1`. This involves checking all possible values of `m` up to a reasonable limit (like 60) to cover large values of `n`.\n\n### Solution Code\n```python\nimport math\n\ndef is_snowflake(n):\n    if n < 3:\n        return False\n    max_k = int(math.isqrt(n)) + 1\n    for m in range(2, 60):  # Up to 60 layers to handle n up to 1e18\n        # We have 1 + k*(k^m - 1)/(k-1) = n\n        # Rearranged: k^(m+1) - k + 2 = n*(k-1)\n        # Not sure about that, maybe another approach.\n        # Alternative approach: For each m, find k such that n = 1 + k*(k^m -1)/(k-1)\n        # Let's try to express n-1 as k*(k^m -1)/(k-1)\n        target = n - 1\n        low = 2\n        high = target // 2  # Because k has to be at least 2, so k*(...) <= n-1\n        while low <= high:\n            mid = (low + high) // 2\n            # Compute s = mid * (mid^m -1)/(mid -1)\n            # But computing mid^m for m up to 60 could be big, but for n=1e18, mid can't be larger than 1e9\n            # So mid^60 is 1e540, which is way beyond 64-bit integers. So we need a smarter way.\n            # Let's compute s incrementally and stop early if it exceeds target.\n            s = 0\n            current_power = 1\n            for _ in range(m):\n                s += current_power\n                current_power *= mid\n                if s > target:\n                    break\n            if s == target:\n                return True\n            elif s < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n    return False\n\nt = int(input())\nfor _ in range(t):\n    n = int(input().strip())\n    if is_snowflake(n):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n```\n\n### Explanation\n1. **Function `is_snowflake(n)`**: This function checks if `n` can be represented as the sum of a geometric series starting from 1, with common ratio `k` and at least two terms. It iterates over possible values of `m` (number of terms) and uses binary search to find a suitable `k`.\n2. **Binary Search for `k`**: For each possible number of terms `m`, the function performs a binary search to find a value of `k` such that the sum of the series equals `n`.\n3. **Iterating Over Possible Layers**: The function iterates over possible values of `m` up to a reasonable limit to ensure it covers all possible configurations for very large values of `n`.\n\nThis approach efficiently checks all possible configurations to determine if a snowflake graph with `n` vertices can exist.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef is_snowflake(n):\n    if n < 3:\n        return False\n    max_k = int(math.isqrt(n)) + 1\n    for m in range(2, 60):  # Up to 60 layers to handle n up to 1e18\n        # We have 1 + k*(k^m - 1)/(k-1) = n\n        # Rearranged: k^(m+1) - k + 2 = n*(k-1)\n        # Not sure about that, maybe another approach.\n        # Alternative approach: For each m, find k such that n = 1 + k*(k^m -1)/(k-1)\n        # Let's try to express n-1 as k*(k^m -1)/(k-1)\n        target = n - 1\n        low = 2\n        high = target // 2  # Because k has to be at least 2, so k*(...) <= n-1\n        while low <= high:\n            mid = (low + high) // 2\n            # Compute s = mid * (mid^m -1)/(mid -1)\n            # But computing mid^m for m up to 60 could be big, but for n=1e18, mid can't be larger than 1e9\n            # So mid^60 is 1e540, which is way beyond 64-bit integers. So we need a smarter way.\n            # Let's compute s incrementally and stop early if it exceeds target.\n            s = 0\n            current_power = 1\n            for _ in range(m):\n                s += current_power\n                current_power *= mid\n                if s > target:\n                    break\n            if s == target:\n                return True\n            elif s < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n    return False\n\nt = int(input())\nfor _ in range(t):\n    n = int(input().strip())\n    if is_snowflake(n):\n        print(\"YES\")\n    else:\n        print(\"NO\")",
    "score": 0,
    "metadata": {
        "prompt_token_count": 534,
        "completion_token_count": 929,
        "thoughts_token_count": 1025
    }
}