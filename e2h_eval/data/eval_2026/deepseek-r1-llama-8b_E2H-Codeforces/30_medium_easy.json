{
    "start": 1758288453.412182,
    "end": 1758290842.556348,
    "start-formatted": "2025-09-19 22:27 KST",
    "end-formatted": "2025-09-19 23:07 KST",
    "gpu": 2,
    "pid": 30,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# TV Game\n\nThere is a new TV game on BerTV. In this game two players get a number A consisting of 2n digits. Before each turn players determine who will make the next move. Each player should make exactly n moves. On it's turn i-th player takes the leftmost digit of A and appends it to his or her number Si. After that this leftmost digit is erased from A. Initially the numbers of both players (S1 and S2) are «empty». Leading zeroes in numbers A, S1, S2 are allowed. In the end of the game the first player gets S1 dollars, and the second gets S2 dollars.One day Homer and Marge came to play the game. They managed to know the number A beforehand. They want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize. Help them.\n\n## Input\nThe first line contains integer n (1 ≤ n ≤ 18). The second line contains integer A consisting of exactly 2n digits. This number can have leading zeroes.\n\n## Output\nOutput the line of 2n characters «H» and «M» — the sequence of moves of Homer and Marge, which gives them maximum possible total prize. Each player must make exactly n moves. If there are several solutions, output any of them.\n\n## Example\n### Input\n['2\\n1234', '2\\n9911']\n\n### Output\n['HHMM', 'HMHM']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "Okay, so I have this problem where Homer and Marge are playing a TV game. The goal is to maximize their total prize by choosing the sequence of moves optimally. Let me try to understand the problem.\n\nThe game starts with a number A that has 2n digits. Each player makes exactly n moves. In each move, the current player takes the leftmost digit of A and appends it to their own number (S1 for Homer and S2 for Marge). Then, that digit is removed from A. So after each move, A gets shorter by one digit.\n\nOur task is to determine the order of moves (Homer and Marge) such that when all moves are done, both have exactly n digits, and their combined scores (the sum of their numbers) is as large as possible.\n\nHmm. So the key is to decide for each digit whether it's assigned to Homer or Marge in a way that maximizes the sum of their numbers. But since the order of taking the digits affects how we can assign them, it's a bit tricky.\n\nLet me think about the process. Each turn, a player takes the first digit. So the order of taking digits is fixed based on the initial arrangement of A. Wait, no. Because each time the leftmost digit is taken, but the players alternate turns. So the selection order depends on the choice of which player takes each step.\n\nWait, no. Wait, the players decide who goes first, then they alternate. But the initial setup is that the first player is determined before the game starts. Or do they choose who goes first each turn?\n\nNo, the problem says: \"each turn i-th player takes the leftmost digit\". So perhaps the players take turns, but who is the first player is decided at the beginning. Or wait, perhaps each player must make exactly n moves, so the total steps are 2n, and each player does exactly half. So the process is that in each step, the next player to move is determined—maybe it's a pre-determined order based on who starts first.\n\nWait, the problem statement says: \"Before each turn players determine who will make the next move.\" Oh, right! So before each turn, the two players decide who will take the next move. That's a crucial point.\n\nSo the sequence of moves is determined by the players' choices, not by a fixed order. They can choose to let either player take the next step. But each player must make exactly n moves in total.\n\nSo our goal is to choose the order of H and M such that:\n\n- Each appears exactly n times.\n- The sum of the values of S1 and S2 is maximized.\n\nBut how to model this? Because each choice affects the future options.\n\nThis seems like a dynamic programming problem. We can model the state as the current position in the string A, and the number of moves made by each player so far. For each state, we decide whether to assign the current digit to H or M, ensuring that eventually each has n moves.\n\nWait, yes. So the state can be represented by:\n\n- The current index in the string A (let's say, processed up to position i, so the next digit is at i).\n- The number of moves made by Homer so far (h), and the number made by Marge (m).\n\nSince h + m = i, because each move processes one digit.\n\nThe transition would be: for the next digit (A[i]), assign it to either Homer or Marge, provided that h < n and m < n respectively. Then proceed to the next state.\n\nThe value of the state is the maximum possible sum we can get starting from this state.\n\nBut wait, the sum isn't just the sum of the digits; it's the numerical value of the numbers S1 and S2. So for example, if Homer has '91' and Marge has '20', their sum is 91 + 20 = 111.\n\nBut how do we represent the sum based on the order of digits? Because the order in which digits are added to S1 and S2 affects their numerical values.\n\nWait, no. Because the sum is S1 + S2, which is the sum of the digits in the order they were added to each. So for S1, the digits are added as per their order in the moves assigned to H. Similarly for S2.\n\nSo for example, if the digits assigned to H are [d1, d3, d5], then S1 is d1*10^2 + d3*10^1 + d5*10^0. Similarly for M.\n\nSo the sum is the sum of these two numbers.\n\nCalculating this sum directly for every possible assignment might be computationally expensive, especially since n can be up to 18, making the string length 36. So the state space would be too big if we model it as h, m, and the current index.\n\nWait, but perhaps there's a smarter way. Let me think: the sum S1 + S2 can be represented as the sum of the digits multiplied by their respective place values, depending on whether they were assigned to H or M.\n\nEach digit contributes to either S1 or S2, and the contribution is the digit multiplied by 10^{k}, where k is the position in their own number. For example, if a digit is the first in S1, it's multiplied by 10^{n-1} if it's the first digit, 10^{n-2} if it's the second, etc.\n\nBut this complicates things because the exponent depends on the position within S1 or S2, which varies based on previous assignments.\n\nHmm. So perhaps the optimal approach is to model the state with h, m, and the current index, but also track the positions (exponents) for the next digit.\n\nWait, that sounds complicated. Another thought: for each digit, its contribution to the sum depends on whether it's assigned to H or M, and what position it's in their respective numbers.\n\nWait, but maybe the sum can be represented as the sum of all digits multiplied by some factor, regardless of the order, as long as each digit is assigned to H or M.\n\nWait, no. Because the position in H's or M's number affects the multiplier. For example, a digit assigned to H as the first move gives it a higher weight than if it's assigned later.\n\nThis seems challenging. Maybe another approach: Since each digit can only be assigned to H or M, and each assignment affects their respective multipliers, perhaps we can model the state as the current position in the string, and for H and M, how many digits have been assigned so far.\n\nWait, that's similar to the earlier idea. So, for each state (i, h, m), where i is the current index (digits 0 to 2n-1), h is the number of digits assigned to H so far, and m is the same for M, we can compute the maximum sum possible from this state onwards.\n\nThe base case is when i == 2n, meaning all digits are processed. The sum is then 0.\n\nFor each state (i, h, m), we can choose to assign the current digit (A[i]) to H or M, provided that h < n or m < n, respectively.\n\nWhen assigning to H: the digit is added as the (h+1)-th digit of H's number. So its contribution is digit * 10^{(n - (h+1))}. Similarly for M.\n\nSo for each possible assignment, we calculate the added value and choose the option that gives the maximum sum.\n\nSo the DP recurrence is:\n\ndp[i][h][m] = max(\n    digit * 10^{n - (h+1)} + dp[i+1][h+1][m],\n    digit * 10^{n - (m+1)} + dp[i+1][h][m+1]\n)\n\nWait, but this would require us to compute 10^{k} for various exponents. Since n can be up to 18, the maximum exponent is 17, which is manageable.\n\nBut wait, for n=18, the exponents can be up to 17, so 10^17 is a very large number, but since Python handles big integers, it's okay.\n\nNow, the question is: how to implement this DP efficiently.\n\nThe dimensions of the DP table are (2n+1) x (n+1) x (n+1). For n=18, 2n+1 is 37, and n+1 is 19 each. So the total number of states is 37 * 19 * 19 = around 140,000. Which is acceptable for Python.\n\nBut we need to precompute the powers of 10 up to 10^18, perhaps, since for n=18, the maximum exponent is 17 (since the last digit is the 18th, contributing 10^0).\n\nWait, wait. Let me think again: the first digit assigned to H is multiplied by 10^{n-1}, because it's the first digit in an n-digit number. The second digit is multiplied by 10^{n-2}, and so on until the nth digit, which is 10^0.\n\nSo for each possible state, when assigning to H, the exponent is (n-1 - (h)). Because h is the current count of digits in H, so the new digit is the h+1-th, and the exponent is (n-1 - h).\n\nSimilarly for M.\n\nSo, for the current digit, the contribution is:\n\nif assign to H: digit * (10 ** (n-1 - h))\nif assign to M: digit * (10 ** (n-1 - m))\n\nSo, the DP transitions are:\n\nfor each state (i, h, m):\n   if i >= len(A): return 0\n   current_digit = A[i]\n   option1 = current_digit * (10 ** (n-1 - h)) + dp(i+1, h+1, m)\n   option2 = current_digit * (10 ** (n-1 - m)) + dp(i+1, h, m+1)\n   dp[i][h][m] = max(option1, option2)\n\nYes, that makes sense.\n\nSo the plan is:\n\n1. Read n and the string A.\n2. Precompute the powers of 10 for exponents from 0 to n-1.\n3. Initialize a DP table with dimensions (2n+1) x (n+1) x (n+1). Maybe using memoization with lru_cache, but since the state is small, perhaps a memoization approach is feasible.\n4. The base case is when i == 2n, return 0.\n5. For each state (i, h, m), compute the maximum between assigning to H or M.\n\nWait, but in terms of implementation, since n can be up to 18, the exponents can be up to 10^17, which is manageable in Python.\n\nNow, considering the recursive approach, but for n=18, recursion depth could be up to 36, which is manageable. However, memoization may be more efficient.\n\nAlternatively, we can memoize using a 3D array, but for Python, using functools.lru_cache is easier.\n\nWait, but for n=18, 2n=36, and h and m each up to 18, the memoization cache size is 36*19*19= 36*361= ~13000, which is manageable.\n\nSo, the code structure would be something like this:\n\n- Convert the input string into a list of integers, A_digits.\n- Precompute the powers of 10 for exponents 0 to n-1.\n- Define a recursive function, say, dfs(i, h, m), which returns the maximum sum achievable starting from position i, with h and m digits assigned so far.\n- For each call, if i == 2n, return 0.\n- Else, compute the two options: assign to H or M, and choose the maximum.\n- Use memoization to cache the results.\n\nOnce the maximum sum is computed, we need to reconstruct the path to find the sequence of moves (H or M) that leads to this maximum sum.\n\nBut reconstructing the path is tricky. So perhaps during the DP, we can store not just the maximum sum, but also the choice made at each step (whether to assign to H or M) to reach that maximum. Alternatively, once the DP is computed, we can backtrack from the end.\n\nSo here's the plan:\n\n- Compute the DP table, storing for each state (i, h, m) the best choice (H or M) that led to the maximum sum.\n- Once the DP is filled, start from i=2n, h=n, m=n, and backtrack through the choices, building the sequence of moves.\n\nWait, but wait: when h = n and m = n, that's the end state. So we can build the moves in reverse order, starting from the last digit.\n\nEach step, we look at the state (i, h, m) and see which option (H or M) was chosen to reach this state.\n\nWait, no. Because the DP[i][h][m] stores the best choice for the next digit. So when backtracking, we look at the current state, and see whether the choice was to assign to H or M.\n\nWait, perhaps the way to reconstruct the path is:\n\nWe start from the end state (i=2n, h=n, m=n), and for each step, we look at the previous state.\n\nWait, no, because the DP is built from i=0 to i=2n. So perhaps the path can be reconstructed by working backwards.\n\nBut I'm not sure. Alternatively, during the DP computation, we can store for each state (i, h, m) the decision (H or M) that was taken. Then, when reconstructing, we can follow the decisions in reverse order.\n\nSo, modifying the DP to store not just the maximum sum, but also the choice made (H or M) that led to it.\n\nThis way, when we finish computing the DP, we can start from the end and trace back the choices.\n\nBut that requires storing for each state (i, h, m) the choice, which adds some memory, but for n=18, it's manageable.\n\nSo the code outline would be:\n\nRead n and A.\n\nCompute A_digits as a list of integers.\n\nPrecompute power_10 = [10^0, 10^1, ..., 10^{n-1}].\n\nImplement a memoization function, perhaps using lru_cache, that for given i, h, m, returns the maximum sum and the choice made (H or M) leading to that sum.\n\nWait, but the choice is part of the DP state. So perhaps the function returns a tuple: (max_sum, choice).\n\nAlternatively, during the DP, for each state, we can store both the sum and the choice.\n\nBut in Python, using lru_cache with mutable types can be tricky, but in this case, since the function's output is a tuple, it should be fine.\n\nSo the function would be something like:\n\ndef dfs(i, h, m):\n\n    if i == 2n:\n        return (0, None)\n    if (i, h, m) in memo:\n        return memo[(i, h, m)]\n    digit = A_digits[i]\n    # Option 1: assign to H\n    if h < n:\n        sum_h, choice_h = dfs(i+1, h+1, m)\n        val_h = digit * (power_10[n-1 - h]) + sum_h\n    else:\n        val_h = float('inf')  # not allowed\n        choice_h = None\n    # Option 2: assign to M\n    if m < n:\n        sum_m, choice_m = dfs(i+1, h, m+1)\n        val_m = digit * (power_10[n-1 - m]) + sum_m\n    else:\n        val_m = float('inf')\n        choice_m = None\n\n    # Choose the better option\n    if val_h > val_m:\n        best_val = val_h\n        best_choice = choice_h\n    else:\n        best_val = val_m\n        best_choice = choice_m\n\n    memo[(i, h, m)] = (best_val, best_choice)\n    return (best_val, best_choice)\n\nWait, but the function needs to know which option is better, and then decide which path to take.\n\nBut the problem is that in some cases, one of the options is invalid (e.g., when h == n and trying to assign to H). So in such cases, that option is not considered.\n\nBut how to represent this in code.\n\nWait, perhaps the code should consider both options only if they are allowed (h < n or m < n). Otherwise, the option is skipped.\n\nSo, for each state (i, h, m), we can compute the possible options:\n\noptions = []\nif h < n:\n    option_h = (digit * power_10[...]) + dfs(...)\n    options.append(option_h)\nif m < n:\n    option_m = ... + dfs(...)\n    options.append(option_m)\n\nThen, if options is empty, which shouldn't happen because in the end, h and m must reach n.\n\nWait, but in the initial state, h=0, m=0, so the first digit can be assigned to either.\n\nSo, for each state, we have 0, 1, or 2 options.\n\nSo, the function can be written to collect all possible options and choose the maximum.\n\nBut in code, perhaps it's better to handle each option separately and choose the maximum.\n\nNow, the reconstruction part.\n\nOnce the DP is filled, we can start from the end state (i=2n, h=n, m=n), and for each step, determine whether the last move was H or M.\n\nWait, no. Because the state (i, h, m) represents that up to i, h moves have been made by H, m by M.\n\nSo, when i=2n, h = n, m = n, which is the terminal state.\n\nTo reconstruct the path, we can start from (2n, n, n), and for each step, go to the previous state.\n\nBut wait, the previous state would be (i-1, h-1, m) if the last move was H, or (i-1, h, m-1) if it was M.\n\nBut wait, the last move is the 2n-th digit, but the indices are 0-based. So, the last digit is A[2n-1].\n\nSo, for the last state (i=2n), the previous state could have been (i-1, h-1, m) if the last move was H, or (i-1, h, m-1) if it was M.\n\nSo, the reconstruction starts from i=2n, h=n, m=n.\n\nAt each step, we look at the previous state.\n\nBut in the DP, for each state (i, h, m), we also store the choice that led to it.\n\nSo, during the reconstruction, for each state (i, h, m), we can check which choice was made.\n\nWait, no. Because the DP state (i, h, m) represents the state after processing the i-th digit, so to reconstruct the path, we need to look at how we arrived at this state.\n\nWait, perhaps the function also returns the choice made (H or M) when transitioning to this state.\n\nSo, for example, when we called dfs(i, h, m), the choice made is whether to assign the next digit to H or M.\n\nWait, no. Because the function is called with i, h, m, and the next digit is A[i], which is processed as the (h+1)-th or (m+1)-th digit.\n\nSo, for the state (i, h, m), the next step is to process A[i], and the choice is whether to assign it to H or M.\n\nThus, for the state (i, h, m), the choice is which player took the (i)th digit.\n\nWait, but the digits are taken from left to right. So the first digit is A[0], then A[1], etc.\n\nSo, the reconstruction starts from the last digit, which is A[2n-1], and determines whether it was assigned to H or M.\n\nWait, no. The last digit is processed when i=2n-1, and the state after that is (2n, n, n).\n\nSo, to find out whether the last digit (A[2n-1]) was assigned to H or M, we look at the state (2n-1, h, m) that leads to (2n, n, n).\n\nWait, perhaps it's easier to represent the path as a list, and build it in reverse.\n\nSo, the reconstruction process is:\n\nInitialize the path as an empty list.\n\nStart with the state (i=2n, h=n, m=n).\n\nLoop while i > 0:\n\n   Look at the state (i-1, h_prev, m_prev) that could have led to (i, h, m).\n\n   Depending on whether the last move was H or M, append 'H' or 'M' to the path.\n\n   Update i to i-1, h or m accordingly.\n\nWait, but how to find which choice was made for each state.\n\nAh, right. So in the DP, for each state (i, h, m), we can store not just the maximum sum, but also the choice (H or M) that was made to reach this state.\n\nSo, in the DP memo, we'll store a tuple: (max_sum, choice).\n\nSo, when we're in state (i, h, m), the choice is the one that was made to reach this state.\n\nThus, during reconstruction:\n\ncurrent_i = 2n\ncurrent_h = n\ncurrent_m = n\n\npath = []\n\nwhile current_i > 0:\n    # Get the choice for state (current_i, current_h, current_m)\n    sum_val, choice = dp[current_i][current_h][current_m]\n    if choice == 'H':\n        # The previous state was (current_i-1, current_h-1, current_m)\n        path.insert(0, 'H')\n        current_i -= 1\n        current_h -= 1\n    else:\n        path.insert(0, 'M')\n        current_i -= 1\n        current_m -= 1\n\nWait, but the current_i is 2n, which is beyond the last index of the string (which is 2n-1). So perhaps during the reconstruction, we should process the digits in reverse order.\n\nAlternatively, perhaps the reconstruction starts from the end, and for each step, appends the choice to the path, and moves to the previous state.\n\nWait, perhaps the order is a bit confusing. Let me think: the last digit processed is A[2n-1]. So the state after processing this digit is (2n, n, n). To find out whether this digit was assigned to H or M, we look at the state (2n-1, h, m) that led to (2n, n, n).\n\nBut that state (2n-1, h, m) could have been reached by assigning the digit to H or M.\n\nWait, perhaps the way to reconstruct is to start from the end, and for each step, determine whether the current digit was assigned to H or M.\n\nSo, in the reconstruction loop:\n\ni starts at 2n-1, then 2n-2, etc., down to 0.\n\nAt each step i, we have h and m counts, and the choice made for this digit.\n\nWait, but how to track h and m.\n\nAnother approach: during reconstruction, for each i from 2n-1 downto 0:\n\n   Determine whether the digit A[i] was assigned to H or M.\n\n   Record the choice.\n\n   Update h or m accordingly.\n\nSo, to find this, for each i, h, m, we can query the DP table for (i, h, m), but that's not straightforward.\n\nAlternatively, perhaps during the DP, we can also store for each state (i, h, m) the choice that was made to reach it. So, for the state (i, h, m), the choice is the one that was made when processing the digit A[i].\n\nWait, that makes more sense.\n\nSo, during the DP, for each state (i, h, m), we store the choice that was made when processing A[i], which is whether the digit was assigned to H or M.\n\nThus, the reconstruction can proceed as follows:\n\nstart from i=2n-1, h = n-1, m = n-1 (assuming the last digit is the 2n-th step, but perhaps not). Wait, maybe I'm getting confused.\n\nWait, when i=0, h=0, m=0.\n\nAfter processing A[0], the state becomes (1, 1, 0) if H took it, or (1, 0, 1) if M took it.\n\nSo, for the reconstruction, the initial state is (2n, n, n). We need to find the previous state and the choice made.\n\nSo, during the reconstruction:\n\ncurrent_i = 2n\ncurrent_h = n\ncurrent_m = n\n\npath = []\n\nwhile current_i > 0:\n\n    # Find the previous state based on the choice made to reach current_i, current_h, current_m.\n\n    # The choice is stored in the DP table.\n\n    # So, for state (current_i, current_h, current_m), the choice is known.\n\n    # Wait, but current_i is 2n, which is beyond the string. So perhaps I'm misunderstanding.\n\n    # Maybe the state (current_i, current_h, current_m) is (2n, n, n), and the previous state is (2n-1, h_prev, m_prev), where h_prev = current_h -1 if the last choice was H, else m_prev = current_m -1.\n\n    # But how to get the choice from the DP.\n\n    # Hmm, perhaps I should think differently.\n\n    # When the DP function is called for (i, h, m), it processes A[i], and chooses to assign to H or M.\n\n    # So, for the state (i, h, m), the choice is whether to assign A[i] to H or M.\n\n    # Thus, the choice for the digit A[i] is stored in the DP state.\n\n    # So, for the final state (2n, n, n), the choice is for the digit A[2n-1], which is the last digit processed.\n\n    # So, in the reconstruction, we can start from (2n, n, n), and for each step, get the choice made for the digit A[i], where i is 2n-1, 2n-2, etc.\n\nSo, the reconstruction loop would be:\n\ni = 2n - 1\nh = n\nm = n\npath = []\n\nwhile i >= 0:\n    # Get the choice for the state (i, h, m)\n    # But wait, the state (i, h, m) is for the i-th digit being processed.\n    # So, for i, the state is (i, h, m) and the choice is whether to assign A[i] to H or M.\n\n    # So, the choice is stored in the DP[i][h][m]\n\n    # But wait, in the DP, the state (i, h, m) refers to the current index being i, and the counts being h and m.\n\n    # So, the choice is the action taken for A[i], which affects h or m.\n\n    # So, during reconstruction, for each i from 2n-1 downto 0:\n\n    # 1. Check the state (i, h, m) in the DP.\n\n    # 2. If the choice is 'H', then the digit A[i] was assigned to H. So, the previous state was (i-1, h-1, m).\n\n    # 3. Else, it was assigned to M, so previous state was (i-1, h, m-1).\n\n    # So, the path is built in reverse order.\n\n    # So, in code:\n\n    # Get the choice for (i, h, m)\n    sum_val, choice = dp[i][h][m]\n\n    if choice == 'H':\n        # This digit was assigned to H, so the previous state is (i-1, h-1, m)\n        path.insert(0, 'H')\n        i -= 1\n        h -= 1\n    else:\n        path.insert(0, 'M')\n        i -= 1\n        m -= 1\n\n    # Continue until i reaches 0.\n\nSo, for example, in the sample input:\n\nn=2, A='9911'\n\nSo, 2n=4 digits.\n\nThe optimal path is 'HMHM'.\n\nReconstructing:\n\ni=3, h=2, m=2.\n\nWhat was the choice for state (3, 2, 2)?\n\nIn the DP, for i=3, h=2, m=2, the choice is 'M'?\n\nWait, let's see.\n\nWait, the digits are 9,9,1,1.\n\nThe reconstruction starts at i=3, h=2, m=2.\n\nThe choice is 'M' or 'H' for the digit A[3] (which is 1).\n\nIf the choice is 'M', then the digit is assigned to M, so the previous state is (2, 2, 1).\n\nBut wait, in this case, after assigning to M, m becomes 2, but h remains 2.\n\nWait, but how to proceed.\n\nI think this approach will correctly reconstruct the path.\n\nSo, putting it all together.\n\nNow, coding this.\n\nFirst, read n and A.\n\nn = int(input())\nA = input().strip()\n\nA_digits = [int(c) for c in A]\n\npower_10 = [10**e for e in range(n)]\n\nThen, implement the DP with memoization.\n\nBut in Python, using lru_cache with a 3D function is a bit tricky, but manageable.\n\nWait, but the function needs to be able to handle i up to 36, h and m up to 18.\n\nSo, let's write the function.\n\nWe can use memoization via lru_cache, but since the parameters are i, h, m, which are integers, it's manageable.\n\nBut note that in Python, the lru_cache decorator is applied to functions, not to classes. So, the function must be decorated with @lru_cache(maxsize=None), but since the function is defined inside another function, perhaps it's better to manage it differently.\n\nAlternatively, we can use memoization via a dictionary, but for the purposes of simplicity, let's proceed with lru_cache.\n\nWait, but in Python, the maximum recursion depth is limited. For n=18, the maximum recursion depth would be 36, which is acceptable.\n\nSo, here's the code:\n\nimport sys\nfrom functools import lru_cache\n\nn = int(sys.stdin.readline())\nA = sys.stdin.readline().strip()\n\nA_digits = [int(c) for c in A]\n\n@lru_cache(maxsize=None)\ndef dfs(i, h, m):\n    if i == 2*n:\n        return (0, None)\n    digit = A_digits[i]\n    best = None\n    best_val = -float('inf')\n    \n    # Assign to H\n    if h < n:\n        next_h = h + 1\n        next_m = m\n        next_sum, _ = dfs(i+1, next_h, next_m)\n        val = digit * (10 ** (n-1 - h)) + next_sum\n        if val > best_val:\n            best_val = val\n            best = 'H'\n    # Assign to M\n    if m < n:\n        next_h = h\n        next_m = m + 1\n        next_sum, _ = dfs(i+1, next_h, next_m)\n        val = digit * (10 ** (n-1 - m)) + next_sum\n        if val > best_val:\n            best_val = val\n            best = 'M'\n    # Also, consider the case where neither is possible (but it's impossible because h and m can't exceed n)\n    # So, if both options are invalid, which shouldn't happen.\n    return (best_val, best)\n\n# Now, call dfs(0, 0, 0) to get the max sum and the choice.\n\nmax_sum, path_choices = dfs(0, 0, 0)\n\n# Reconstruct the path\npath = []\ni = 2*n - 1\nh = n\nm = n\n\nwhile i >= 0:\n    sum_val, choice = dfs(i, h, m)\n    if choice == 'H':\n        path.insert(0, 'H')\n        i -= 1\n        h -= 1\n    else:\n        path.insert(0, 'M')\n        i -= 1\n        m -= 1\n\nprint(''.join(path))\n\nWait, but wait. The function dfs returns (best_val, best), but when reconstructing, the function is called again for the same state (i, h, m), which would cause an infinite loop.\n\nBecause during the reconstruction, each call to dfs would add to the cache, but the function is already memoized.\n\nSo, this approach won't work because during reconstruction, the function is called again, which would hit the cache but not actually compute anything, leading to incorrect results.\n\nHmm, that's a problem.\n\nSo, how to avoid this?\n\nAlternative approach: modify the function to not use memoization, but instead use a 3D array for DP.\n\nBut for n=18, 2n=36, h and m up to 18, a 3D array of 36 x 19 x 19 is manageable.\n\nSo, perhaps using memoization is not feasible during reconstruction. Instead, compute the DP table beforehand, and then reconstruct the path.\n\nSo, the plan is:\n\n1. Precompute the DP table without memoization, filling it with the maximum sums.\n\n2. Once the DP table is filled, reconstruct the path by looking up each state (i, h, m) in the table.\n\nBut how to implement this.\n\nSo, the steps are:\n\n- Read n and A.\n\n- Precompute power_10 = [10^e for e in range(n)].\n\n- Initialize a 3D DP array, dp[i][h][m], storing the maximum sum.\n\n- Fill the DP table in a bottom-up manner, starting from i=2n down to 0.\n\nWait, but in what order to fill the DP table.\n\nIt's easier to fill it from i=2n down to 0, and for each i, h, m, compute the maximum between assigning to H or M.\n\nBut for i=2n, all h and m are n.\n\nFor i=2n-1, h can be up to n, but must leave enough moves for both.\n\nWait, perhaps the correct order is to iterate i from 2n downto 0, and for each i, iterate h from min(i, n) downto 0, and similarly for m.\n\nWait, perhaps the order is:\n\nfor i in reversed(range(2n + 1)):\n    for h in range(n, -1, -1):\n        for m in range(n, -1, -1):\n            if i == 2n:\n                dp[i][h][m] = 0\n            else:\n                digit = A_digits[i]\n                option_h = option_m = -infinity\n                if h < n:\n                    next_h = h + 1\n                    next_m = m\n                    if next_h <= n and next_m <=n:\n                        option_h = digit * (power_10[n-1 -h]) + dp[i+1][next_h][next_m]\n                if m < n:\n                    next_h = h\n                    next_m = m + 1\n                    if next_h <=n and next_m <=n:\n                        option_m = digit * (power_10[n-1 -m]) + dp[i+1][next_h][next_m]\n                dp[i][h][m] = max(option_h, option_m)\n\nBut this is a bit tricky.\n\nWait, but for i=2n, all h and m are n, so dp[2n][n][n] = 0.\n\nFor i=2n-1:\n\nh can be up to n, but m can be up to n.\n\nBut for each i, h, m:\n\nif h < n: can assign to H.\n\nif m < n: can assign to M.\n\nSo, for each possible (h, m), compute the maximum of the two options.\n\nBut implementing this in code requires loops that may be a bit complex.\n\nAn alternative approach is to use a top-down DP with memoization, but during the reconstruction phase, to not rely on the memoized function but instead refer directly to the DP table.\n\nBut that would require changing the function to not use memoization, and instead use the DP table directly.\n\nSo, the modified approach:\n\n- Create a 3D DP array, dp[i][h][m], initialized to 0.\n\n- For i from 2n downto 0:\n\n   for h from 0 to n:\n\n      for m from 0 to n:\n\n          if i == 2n:\n\n              dp[i][h][m] = 0\n\n          else:\n\n              digit = A_digits[i]\n\n              option_h = -infinity\n\n              if h < n:\n\n                  next_h = h + 1\n\n                  next_m = m\n\n                  if next_h <=n and next_m <=n:\n\n                      option_h = digit * (10 ** (n-1 - h)) + dp[i+1][next_h][next_m]\n\n              option_m = -infinity\n\n              if m <n:\n\n                  next_h = h\n\n                  next_m = m + 1\n\n                  if next_h <=n and next_m <=n:\n\n                      option_m = digit * (10 ** (n-1 - m)) + dp[i+1][next_h][next_m]\n\n              dp[i][h][m] = max(option_h, option_m)\n\nWait, but this is a bottom-up approach, and for i",
    "response": "To solve this problem, we need to determine the sequence of moves for Homer and Marge in a TV game such that their combined scores are maximized. Each player makes exactly `n` moves, and each move involves taking the leftmost digit of a given number `A`, appending it to their respective numbers, and then removing that digit from `A`.\n\n### Approach\nThe problem can be efficiently solved using dynamic programming (DP). The key idea is to use a DP table where `dp[i][h][m]` represents the maximum score achievable starting from the `i-th` digit of `A`, with `h` moves made by Homer and `m` moves made by Marge.\n\n1. **State Representation**: The state is defined by three parameters:\n   - `i`: The current position in the string `A`.\n   - `h`: The number of moves made by Homer so far.\n   - `m`: The number of moves made by Marge so far.\n\n2. **Transition**: For each state `(i, h, m)`, we have two choices:\n   - Assign the current digit to Homer's number, which contributes to his score based on its position.\n   - Assign the current digit to Marge's number, contributing similarly to her score.\n\n3. **Bottom-Up DP Table**: We fill the DP table starting from the end of the string `A` and moving backwards. This ensures that when we compute the value for a state, all future states (which it depends on) have already been computed.\n\n4. **Reconstruction**: After filling the DP table, we reconstruct the optimal sequence of moves by backtracking from the terminal state where both players have made `n` moves.\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    A = sys.stdin.readline().strip()\n    A_digits = [int(c) for c in A]\n    \n    # Precompute powers of 10\n    power_10 = [10**e for e in range(n)]\n    \n    # Initialize DP table\n    size_i = 2 * n + 1\n    dp = [[[0 for _ in range(n+1)] for __ in range(n+1)] for ___ in range(size_i)]\n    \n    # Fill DP table from i=2n down to 0\n    for i in reversed(range(size_i)):\n        for h in range(n+1):\n            for m in range(n+1):\n                if i == 2 * n:\n                    dp[i][h][m] = 0\n                else:\n                    digit = A_digits[i]\n                    option_h = -float('inf')\n                    if h < n:\n                        next_h = h + 1\n                        next_m = m\n                        if next_h <= n and next_m <= n:\n                            option_h = digit * (power_10[n-1 - h]) + dp[i+1][next_h][next_m]\n                    option_m = -float('inf')\n                    if m < n:\n                        next_h = h\n                        next_m = m + 1\n                        if next_h <= n and next_m <= n:\n                            option_m = digit * (power_10[n-1 - m]) + dp[i+1][next_h][next_m]\n                    dp[i][h][m] = max(option_h, option_m)\n    \n    # Reconstruct the path\n    path = []\n    i = 2 * n - 1\n    h = n\n    m = n\n    \n    while i >= 0:\n        if h < n and m < n:\n            # Check both options\n            digit = A_digits[i]\n            option_h_val = digit * (power_10[n-1 - h]) + dp[i+1][h+1][m]\n            option_m_val = digit * (power_10[n-1 - m]) + dp[i+1][h][m+1]\n            if option_h_val > option_m_val:\n                path.insert(0, 'H')\n                h += 1\n            else:\n                path.insert(0, 'M')\n                m += 1\n            i -= 1\n        else:\n            # Only one option is possible\n            if h < n:\n                path.insert(0, 'H')\n                h += 1\n            else:\n                path.insert(0, 'M')\n                m += 1\n            i -= 1\n    \n    print(''.join(path))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input consists of an integer `n` and a string `A` of `2n` digits.\n2. **Precompute Powers of 10**: These are used to calculate the contribution of each digit based on its position in the resulting numbers.\n3. **DP Table Initialization**: A 3D list `dp` is initialized to store the maximum scores for each state.\n4. **Filling the DP Table**: Starting from the last digit and moving backwards, each state is filled by considering the best possible move (assigning the digit to Homer or Marge).\n5. **Path Reconstruction**: Starting from the end state where both players have made `n` moves, the optimal sequence of moves is reconstructed by checking which choice led to the maximum score at each step.\n\nThis approach ensures that we efficiently compute the optimal sequence of moves using dynamic programming, leveraging memoization and bottom-up computation for correctness and efficiency.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    A = sys.stdin.readline().strip()\n    A_digits = [int(c) for c in A]\n    \n    # Precompute powers of 10\n    power_10 = [10**e for e in range(n)]\n    \n    # Initialize DP table\n    size_i = 2 * n + 1\n    dp = [[[0 for _ in range(n+1)] for __ in range(n+1)] for ___ in range(size_i)]\n    \n    # Fill DP table from i=2n down to 0\n    for i in reversed(range(size_i)):\n        for h in range(n+1):\n            for m in range(n+1):\n                if i == 2 * n:\n                    dp[i][h][m] = 0\n                else:\n                    digit = A_digits[i]\n                    option_h = -float('inf')\n                    if h < n:\n                        next_h = h + 1\n                        next_m = m\n                        if next_h <= n and next_m <= n:\n                            option_h = digit * (power_10[n-1 - h]) + dp[i+1][next_h][next_m]\n                    option_m = -float('inf')\n                    if m < n:\n                        next_h = h\n                        next_m = m + 1\n                        if next_h <= n and next_m <= n:\n                            option_m = digit * (power_10[n-1 - m]) + dp[i+1][next_h][next_m]\n                    dp[i][h][m] = max(option_h, option_m)\n    \n    # Reconstruct the path\n    path = []\n    i = 2 * n - 1\n    h = n\n    m = n\n    \n    while i >= 0:\n        if h < n and m < n:\n            # Check both options\n            digit = A_digits[i]\n            option_h_val = digit * (power_10[n-1 - h]) + dp[i+1][h+1][m]\n            option_m_val = digit * (power_10[n-1 - m]) + dp[i+1][h][m+1]\n            if option_h_val > option_m_val:\n                path.insert(0, 'H')\n                h += 1\n            else:\n                path.insert(0, 'M')\n                m += 1\n            i -= 1\n        else:\n            # Only one option is possible\n            if h < n:\n                path.insert(0, 'H')\n                h += 1\n            else:\n                path.insert(0, 'M')\n                m += 1\n            i -= 1\n    \n    print(''.join(path))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 410,
        "completion_token_count": 1134,
        "thoughts_token_count": 8193
    }
}