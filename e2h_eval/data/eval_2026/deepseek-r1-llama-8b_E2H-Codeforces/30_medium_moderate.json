{
    "start": 1758288290.2323527,
    "end": 1758290565.4379466,
    "start-formatted": "2025-09-19 22:24 KST",
    "end-formatted": "2025-09-19 23:02 KST",
    "gpu": 2,
    "pid": 30,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# TV Game\n\nThere is a new TV game on BerTV. In this game two players get a number A consisting of 2n digits. Before each turn players determine who will make the next move. Each player should make exactly n moves. On it's turn i-th player takes the leftmost digit of A and appends it to his or her number Si. After that this leftmost digit is erased from A. Initially the numbers of both players (S1 and S2) are «empty». Leading zeroes in numbers A, S1, S2 are allowed. In the end of the game the first player gets S1 dollars, and the second gets S2 dollars.One day Homer and Marge came to play the game. They managed to know the number A beforehand. They want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize. Help them.\n\n## Input\nThe first line contains integer n (1 ≤ n ≤ 18). The second line contains integer A consisting of exactly 2n digits. This number can have leading zeroes.\n\n## Output\nOutput the line of 2n characters «H» and «M» — the sequence of moves of Homer and Marge, which gives them maximum possible total prize. Each player must make exactly n moves. If there are several solutions, output any of them.\n\n## Example\n### Input\n['2\\n1234', '2\\n9911']\n\n### Output\n['HHMM', 'HMHM']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "Okay, so I have this problem where Homer and Marge are playing a TV game. The goal is to maximize their total prize by choosing the sequence of moves optimally. Let me try to understand the problem.\n\nThe game starts with a number A that has 2n digits. Each player makes exactly n moves. In each move, the current player takes the leftmost digit of A and appends it to their own number (S1 for Homer and S2 for Marge). Then, that digit is removed from A. So after each move, A gets shorter by one digit.\n\nOur task is to determine the order of moves (Homer and Marge) such that when all moves are done, both have exactly n digits, and their combined scores (the sum of their numbers) is as large as possible.\n\nHmm. So the key is to decide for each digit whether it's assigned to Homer or Marge in a way that maximizes the sum of their numbers. But since the order of taking the digits affects how we can assign them, it's not straightforward.\n\nWait, but perhaps the optimal strategy is to assign each digit to the player who can give the maximum contribution based on its position. Because the leftmost digits are more significant than the ones that follow. So for each pair of positions, we need to decide which player takes which.\n\nWait, but the players alternate turns. So the first move is Homer, then Marge, then Homer, etc. Or wait, no—each turn is determined by whoever is making the next move. They choose who goes first, but in this problem, I think the initial choice is ours to make. Wait no, actually, the problem says before each turn, the players determine who will make the next move. But initially, they are both empty, so perhaps the first move is made by either, but the goal is to choose the sequence that gives maximum sum. Hmm, but the initial choice is up to us, but perhaps the optimal sequence requires that the players alternate turns. Or maybe not necessarily, because sometimes assigning certain digits to a single player could yield a higher sum.\n\nWait, but the initial choice of who goes first might affect the assignment. For example, if the first digit is very high, it's better to be taken by one of the players, but depending on the turn order, it's possible to assign it to the other player as well.\n\nSo, perhaps the optimal approach is to model this as a dynamic programming problem where we track the state of the digits being processed and whose turn it is to pick the next digit.\n\nAlternatively, considering the structure of the problem, since each digit is taken in the order they appear, and each player picks alternately, maybe we can model the problem by pairing the digits in such a way that each pair consists of two consecutive digits, and for each pair, decide whether the first digit goes to the first player and the second to the second player, or vice versa. But I'm not sure if that's the right approach.\n\nWait, let's think about the process. Each time a player takes a digit, it's the leftmost remaining digit. So the order is fixed: digits are taken from left to right. The question is, for each digit, whether it's assigned to S1 or S2, but subject to the constraint that each player must take exactly n digits. Also, the assignment must be such that the players take turns, i.e., the assignment must alternate between H and M.\n\nWait, no. The problem says that each player must make exactly n moves. So the total number of moves is 2n, and the players alternate turns. So the sequence of moves will be something like H, M, H, M, ... for n times each.\n\nSo, the first move is by H, then M, then H, then M, etc. So the turn order is fixed as starting with H, then M, then H, etc. Or wait, wait—no. Because the problem says that before each turn, the players determine who will make the next move. Oh, right, so the initial choice is up to them. So perhaps the first move could be either H or M, depending on what's optimal.\n\nWait, but the initial setup is that both S1 and S2 are empty. So, the first player to take a digit can be either H or M. But to maximize the total prize, perhaps it's better to start with the player who can get the highest possible digits.\n\nBut how do we model this? Because the order of turns can vary, but each player must make exactly n moves. So the total number of moves is 2n, and the number of H and M in the sequence must each be exactly n.\n\nSo the sequence is a string of 2n characters, each being 'H' or 'M', with exactly n of each. We need to find such a string that, when applied to the given A, produces the maximum possible sum of S1 and S2.\n\nThis feels like a problem that can be approached with dynamic programming, but given that n can be up to 18, which means 36 digits, we need an efficient solution.\n\nLet me think about the possible states. One approach is to model the state as:\n\n- The current position in the string A (i.e., which digits have been taken so far).\n- The number of digits taken by H and M so far.\n- Whose turn it is next.\n\nWait, but the turn depends on the previous choices. So for each state, we can choose whether the current player is H or M, but also ensuring that in the end, each has exactly n moves.\n\nAlternatively, perhaps it's better to model the state as the index into the string, the number of H and M moves made so far, and whose turn it is next. But even then, with n=18, 2n=36, the state space could be manageable.\n\nWait, for each step, the current index is up to 36. The number of H and M taken so far can be tracked as h and m, where h + m = current index. And the turn is either H or M.\n\nWait, but the turn depends on the number of moves each has made. So for example, if it's the k-th move overall, if k is even, then M just made a move, and the next is H, unless it's the last move.\n\nWait, perhaps the state can be represented by the current index, the number of H and M moves made so far, and the next player.\n\nBut wait, for each move, the player is determined by the current state. So for example, if the next move is H, then after that, the next player is M, unless it's the last move.\n\nWait, no. Because the players alternate turns. So after H's move, the next is M, and so on.\n\nWait, but the initial choice is who starts. So the first move could be H or M. So perhaps the state needs to include whether the next player is H or M.\n\nSo, the state can be:\n\n- pos: the current position in the string (from 0 to 2n-1)\n- h: number of H moves made so far\n- m: number of M moves made so far\n- next_player: 'H' or 'M' indicating who will take the next digit.\n\nThe initial state is pos=0, h=0, m=0, next_player='H' (if we choose H as the first) or 'M' (if we choose M as the first).\n\nAt each step, we can choose whether to take the current digit for H or M, but only if the current next_player is allowed to do so.\n\nWait, but the next_player is determined by the current state. For example, if next_player is 'H', then the digit is taken by H, and the next player becomes 'M'. Similarly, if next_player is 'M', then the digit is taken by M, and the next player becomes 'H'.\n\nBut we need to ensure that the total H and M moves add up to 2n, with each being exactly n.\n\nSo, the DP state can be defined as follows:\n\ndp[pos][h][m][next] = max_total\n\nWhere:\n\n- pos is the current position in the string A (digits from pos onwards are available).\n- h is the number of H moves made so far.\n- m is the number of M moves made so far.\n- next is the next player to take a digit ('H' or 'M').\n\nThe value stored is the maximum possible sum achievable from this state onward.\n\nThe transitions would be:\n\nFor each state, if the next player is 'H', then:\n\n- Take the current digit (A[pos]) and assign it to H.\n- Then, h increases by 1.\n- pos increments by 1.\n- next player becomes 'M'.\n- The new state is (pos+1, h+1, m, 'M').\n\nSimilarly, if the next player is 'M', then:\n\n- Take the current digit and assign to M.\n- m increases by 1.\n- pos increments by 1.\n- next player becomes 'H'.\n- New state is (pos+1, h, m+1, 'H').\n\nWe need to consider both possibilities at each step and choose the one that leads to the maximum total.\n\nBut wait, what determines the value of the current state? The sum is the sum of all digits assigned to H and M. So for each digit taken, it contributes its value multiplied by 10^position_in_Si.\n\nWait, no. Because each digit is added to the respective player's number as the next digit. So the first digit taken is the most significant digit for that player's number.\n\nSo, for example, the first digit taken by H is the most significant digit in S1. The second digit taken by H is the second most significant, etc.\n\nThus, the value contributed by a digit depends on when it's taken. For instance, the earlier a digit is taken, the higher its place value in the player's number.\n\nThis complicates things because the contribution of a digit isn't just its numerical value but its positional value in the player's number.\n\nSo, for each digit, when it's taken, it's added to either S1 or S2, depending on which player took it, and the position in their number determines its weight.\n\nTherefore, the DP state needs to account for the current digits taken and the positions assigned to each player.\n\nBut that seems difficult because the state space would blow up, especially with n=18.\n\nAlternative approach: Since the order in which digits are taken is fixed (left to right), perhaps we can model the decision for each digit as whether it's taken by H or M, under the constraints of the turn order.\n\nBut how?\n\nEach digit is taken in order, and for each digit, we decide whether to assign it to H or M, subject to the following constraints:\n\n- The assignment must follow the turn order (H, M, H, M, etc., or M, H, M, H, etc., depending on who starts).\n- Each player must take exactly n digits.\n\nSo, the problem reduces to selecting a subset of n digits for H and n digits for M, such that the selection adheres to the turn order, and the sum of the values (with appropriate weights) is maximized.\n\nBut the turn order complicates things because the selection is not arbitrary; it's constrained by the order in which the digits are presented.\n\nHmm. Maybe we can model the problem as follows: for each position, decide whether it's assigned to H or M, but ensuring that in the sequence, the assignment alternates between H and M, starting with either H or M.\n\nWait, but the starting player can be chosen. So perhaps we need to try both possibilities (starting with H or M) and pick the one that gives a higher sum.\n\nSo, the plan is:\n\n1. For each possible starting player (H or M), compute the maximum sum achievable by assigning digits according to the turn order, ensuring that each player makes exactly n moves.\n\n2. Choose the starting player that gives the higher sum. If both give the same sum, choose either.\n\nBut how to compute the maximum sum for a given starting player.\n\nLet me think about the structure of the problem for a fixed starting player.\n\nSuppose the starting player is H. Then, the first move is H, the second is M, third is H, and so on until each has made n moves.\n\nEach digit is taken in the order of the string, and each is assigned to the current player in the turn order.\n\nSo, for each digit, we can assign it to the current player, but we have to make sure that in the end, each has exactly n digits.\n\nWait, but the current player depends on the turn order. So for the first digit, it's H, second M, third H, fourth M, etc.\n\nSo for each digit, it's either assigned to H or M, but only when it's their turn.\n\nSo, the problem for a fixed starting player is to assign each digit to H or M, but only on their respective turns, and ensuring that each ends up with exactly n digits.\n\nWait, but how to model this in code. Maybe using recursion with memoization, tracking the number of digits each has taken so far, and which player's turn it is now.\n\nAlternatively, perhaps we can model this as a dynamic programming problem where for each position, and for the number of H and M digits taken so far, and the current player, we track the maximum possible sum.\n\nYes, that's probably the way to go.\n\nSo, the DP state would be:\n\ndp[pos][h][m][turn] = max_sum\n\nWhere:\n\n- pos is the current position in A (from 0 to 2n-1)\n- h is the number of digits assigned to H so far\n- m is the number of digits assigned to M so far\n- turn is the next player to take a digit ('H' or 'M')\n\nThe transitions would be:\n\nFor each state, if the next player is H:\n\n- Assign the current digit to H.\n- Check if h < n.\n- Then, proceed to the next position (pos+1), with h+1, m remains, and next turn is M.\n\nSimilarly, if the next player is M:\n\n- Assign the current digit to M.\n- Check if m < n.\n- Proceed to pos+1, m+1, h remains, next turn is H.\n\nThe base case is when pos == 2n. At this point, if h == n and m == n, the sum is 0. Otherwise, it's impossible, so we don't consider it.\n\nWait, but we have to compute the sum based on the digits assigned and their positions. So, the sum is built incrementally as we assign digits.\n\nSo, the DP state needs to keep track of the current sum as well as the other parameters.\n\nAlternatively, the DP function can return the maximum sum achievable from the current state.\n\nSo, the recursive function would look something like this:\n\ndef dp(pos, h, m, turn):\n    if pos == len(A):\n        if h == n and m == n:\n            return 0\n        else:\n            return -infinity  # invalid state\n    if (pos, h, m, turn) in cache:\n        return cache[(pos, h, m, turn)]\n    res = -infinity\n    if turn == 'H':\n        # assign current digit to H\n        new_h = h + 1\n        if new_h <= n:\n            current_digit = A[pos]\n            # compute the contribution of current_digit to H's number\n            # H's number is being built digit by digit. The first digit assigned to H is the most significant, next is second, etc.\n            # So for the k-th digit assigned to H, the value is current_digit * 10^(k-1)\n            # Similarly for M.\n            # Wait, but in our DP, we're not keeping track of the exact position of the digits in S1 and S2, so how do we calculate the sum?\n            # Oh, that's a problem. Because the sum depends on the order in which digits are assigned to each player.\n            # So, for example, if H takes the first digit and then the third, his number is formed as d1 followed by d3, making d1*100 + d3*10.\n            # Whereas if H took the second and fourth digits, his number would be d2*100 + d4*10.\n            # So, the contribution of each digit depends on when it's taken relative to other H's digits.\n\n            # This complicates the DP state because the value of a digit depends on the order it's taken in H's or M's number.\n\n            # Therefore, the DP state cannot just track h and m, but also the positions of the digits in each player's number.\n\n            # Which is impossible for n=18, since each player can have up to 18 digits, leading to a state space that's too big.\n\n            # So, this suggests that a different approach is needed.\n\nHmm, this is a problem. Because the sum is dependent on the order in which the digits are taken by each player, which is not captured in the current state.\n\nAlternative idea: Since each player's number is constructed by appending digits in the order they take them, the earlier digits contribute more. So, for each player, the digits are added in the order they are taken. Thus, the first digit taken by H is the most significant, the second next, etc.\n\nSo, the contribution of a digit d at position pos in the original string A is d * 10^{(number of digits taken by the player before this one)}.\n\nBut in the DP, we don't know how many digits each player has already taken before this step.\n\nWait, but in the DP state, we do track h and m, which represent the number of digits each has taken so far. So, for a given digit, if it's assigned to H, it's the (h+1)-th digit for H, contributing d * 10^{h}.\n\nSimilarly, for M, it's the (m+1)-th digit, contributing d * 10^{m}.\n\nSo, the value of the digit depends on when it's taken. So, for each state, when we assign a digit to a player, the current h or m tells us the exponent to multiply by.\n\nThis seems manageable.\n\nSo, the DP transition can be modified to account for this.\n\nLet's formalize this:\n\nWhen processing the i-th digit (pos = i), and considering whether to assign it to H or M:\n\nCase 1: Assigning to H.\n\n- The current state has h digits assigned to H, m to M.\n\n- After assignment, H will have h+1 digits, and M remains at m.\n\n- The value added to the sum is digit * 10^{h}.\n\nBecause this digit is the (h+1)-th digit in H's number, so it's multiplied by 10^h.\n\nSimilarly, if assigned to M, the value is digit * 10^{m}.\n\nThus, in the DP transition, when moving to the next state, we can calculate the added value based on the current h or m.\n\nSo, the state needs to include h and m, and the current turn.\n\nThus, the DP state is:\n\n- pos: current position in the string.\n- h: number of digits assigned to H so far.\n- m: number of digits assigned to M so far.\n- turn: next player to take a digit.\n\nAnd the value stored is the maximum sum achievable from this state onward.\n\nSo, for each state, we can compute the maximum sum by considering both possible assignments (if allowed by the turn) and taking the maximum.\n\nNow, the base case is when pos == len(A). Then, if h == n and m == n, the sum is 0. Else, it's invalid.\n\nSo, the DP function would be something like:\n\ndef dp(pos, h, m, turn):\n    if pos == len(A):\n        return 0 if (h == n and m == n) else -infinity\n    if (pos, h, m, turn) in cache:\n        return cache[(pos, h, m, turn)]\n    res = -infinity\n    if turn == 'H':\n        # Assign to H\n        if h < n:\n            new_h = h + 1\n            val = int(A[pos]) * (10 ** h)\n            next_turn = 'M'\n            new_pos = pos + 1\n            current_sum = dp(new_pos, new_h, m, next_turn)\n            res = max(res, val + current_sum)\n    if turn == 'M':\n        # Assign to M\n        if m < n:\n            new_m = m + 1\n            val = int(A[pos]) * (10 ** m)\n            next_turn = 'H'\n            new_pos = pos + 1\n            current_sum = dp(new_pos, h, new_m, next_turn)\n            res = max(res, val + current_sum)\n    cache[(pos, h, m, turn)] = res\n    return res\n\nWait, but wait—this approach may miss some cases where the initial turn is 'M' instead of 'H'. So, we need to consider both possibilities: starting with H or starting with M.\n\nThus, the solution is to compute the maximum sum for both starting options and choose the one that gives the higher sum.\n\nSo, the algorithm would be:\n\n1. Compute the maximum sum when starting with H.\n\n   Initialize the state as pos=0, h=0, m=0, turn='H'.\n\n   Call dp(0, 0, 0, 'H').\n\n2. Compute the maximum sum when starting with M.\n\n   Initialize the state as pos=0, h=0, m=0, turn='M'.\n\n   Call dp(0, 0, 0, 'M').\n\n3. Choose the option with the higher sum. If both are equal, output any of the sequences.\n\nBut then, how do we reconstruct the sequence of moves (H and M) that led to this maximum sum?\n\nReconstructing the path is necessary because the output requires the sequence of moves.\n\nSo, we need to track not only the maximum sum but also the path taken to achieve it.\n\nThis adds complexity, as the DP state now needs to remember not just the maximum sum but also the sequence of decisions made to reach it.\n\nBut for n=18, this would require a lot of memory, as each state would need to store the entire sequence of decisions. That's impractical.\n\nAlternative approach: Instead of tracking the entire sequence, perhaps during the DP, we can backtrack from the final state to determine the sequence of moves.\n\nSo, once we have the maximum sum for the starting options, we can reconstruct the sequence by backtracking through the DP states.\n\nThus, the steps are:\n\n- Compute the maximum sum for both starting options.\n\n- Choose the one with the higher sum.\n\n- Reconstruct the sequence of moves by backtracking from the end.\n\nSo, how to perform the reconstruction:\n\nStarting from the final state where pos=2n, h=n, m=n, and the last turn was either H or M.\n\nWe can build the sequence in reverse, adding each move to the front of the result.\n\nWait, but the DP function returns the maximum sum, not the path. So, perhaps during the DP computation, we need to track the best path as well.\n\nBut that's complicated and may not be feasible due to memory constraints.\n\nAlternative idea: Use memoization with a tuple that includes the path, but this is also impractical for n=18.\n\nHmm. Another approach is to realize that the decision at each step is deterministic in the sense that for each state, the choice is to assign the current digit to H or M, depending on whose turn it is, provided that h and m are within limits.\n\nWait, no. Because the choice is forced by the turn order. So, for a given state, the next player is determined, and thus the assignment is fixed.\n\nWait, no. Because the next player is determined by the current state, but the choice of whether to assign to H or M is forced by the turn.\n\nWait, no. Let me clarify: the state indicates whose turn it is. So, for example, if the next player is H, then the digit must be assigned to H, and the next player becomes M.\n\nWait, no. Because the player can only take their turn when it's their turn. So, for a given state, the next digit is taken by the next player, and then the next player switches.\n\nSo, the assignment is fixed by the state. So, for a state (pos, h, m, 'H'), the next digit must be assigned to H, provided that h < n.\n\nThus, the sequence of moves is uniquely determined by the starting choice (H or M) and the order of the digits.\n\nWait, but that's not the case. Because the starting choice is H or M, and the rest of the digits are assigned in turn.\n\nWait, no. Because the turn alternates, and the assignment is fixed by the state. So, for the starting choice, the first digit is assigned to H if we start with H, then M, etc.\n\nWait, perhaps the sequence is entirely determined once the starting player is chosen. Because the turn order enforces that each digit is assigned in the order of the string, and the players alternate turns.\n\nSo, for example, if we start with H, the sequence of moves is H, M, H, M, ..., until each has made n moves.\n\nThus, the sequence of H and M is fixed once the starting player is chosen.\n\nIn this case, the sequence of moves is simply a string of 'H's and 'M's, starting with the chosen player, and alternating.\n\nBut wait, that can't be right because the assignment of digits depends on the turn. So, if we choose to start with H, the first digit goes to H, the second to M, third to H, fourth to M, etc.\n\nBut that's not the case. Because the assignment of each digit is determined by the current turn, which alternates.\n\nThus, the sequence of moves is determined by the starting player and the order of the digits.\n\nSo, for example, if the starting player is H, the moves will be H, M, H, M, ..., for 2n steps, making sure each has n moves.\n\nThus, the sequence is fixed once the starting player is decided.\n\nWait, but then how does the choice of starting player affect the sum? Because the way the digits are assigned is fixed based on the starting player.\n\nBut that's not correct. Because the digits are taken in order, but the assignment to H and M is based on the turn order.\n\nSo, for example, the first digit is assigned to H, the second to M, third to H, fourth to M, etc.\n\nThus, the sum is determined by the order of the digits, and the starting player determines which player gets the first, third, fifth, etc., digits.\n\nSo, the problem reduces to choosing whether to start with H or M, and then assign the digits accordingly, computing which starting option gives a higher sum.\n\nOnce the starting option is chosen, the sequence of moves is fixed as per the turn order.\n\nSo, the problem is to choose whether to start with H or M, which results in a specific sequence of H and M, and then compute which option gives a higher sum.\n\nIf both options give the same sum, any can be chosen.\n\nThus, the solution is:\n\n- For both starting options (H and M), simulate the assignment of digits in the order dictated by the turn, and compute the sum for each.\n\n- Choose the option with the higher sum. If equal, choose either.\n\nThen, output the corresponding sequence of moves.\n\nWait, but what if n is 18, and 2n is 36. Simulating this would require iterating through the digits and assigning them to H and M in turn.\n\nBut this seems manageable.\n\nSo, let's outline the steps:\n\n1. Read n and the string A.\n\n2. For each possible starting player (H and M):\n\n   a. Initialize two variables, s1 and s2, as empty strings.\n\n   b. Iterate through each character in A:\n\n      i. For the i-th character (0-based), determine if it's H's turn or M's turn.\n\n         - The first move is the starting player.\n\n         - For the i-th move, if i is even (0-based), it's H's turn if starting is H and i mod 2 is 0.\n\n         Wait, perhaps it's better to precompute the expected player for each position.\n\n   c. For each position in A, determine which player should take it based on the starting player.\n\n      For example, if starting with H, the players take in the order: H, M, H, M, ..., for 2n moves.\n\n      So, for each move index j (0-based), if j is even, it's H's turn; if odd, M's turn.\n\n      But wait, starting with H: j=0 is H, j=1 is M, j=2 is H, j=3 is M, etc.\n\n      So, for j in 0..(2n-1):\n\n         if j is even (0, 2, ...) and starting is H: H's turn.\n\n         if j is odd (1, 3, ...) and starting is H: M's turn.\n\n      Alternatively, for starting player S, the j-th move is assigned to S if j is even, or the other player if j is odd.\n\n      Wait, no. Because the starting player is the first, then the next is the other player, and so on.\n\n      So, for j from 0 to 2n-1:\n\n         if j is even: player is starting player.\n\n         if j is odd: other player.\n\n      So, for example, if starting with H:\n\n         j=0: H\n\n         j=1: M\n\n         j=2: H\n\n         j=3: M\n\n         etc.\n\n      Similarly, if starting with M:\n\n         j=0: M\n\n         j=1: H\n\n         j=2: M\n\n         j=3: H\n\n         etc.\n\n      So, for each j, the player is determined by j % 2 and the starting player.\n\n      So, for j, player = starting_player if j%2 ==0 else (other player).\n\n      Wait, yes. Because for j=0, it's starting player; j=1, the other; j=2, starting again, etc.\n\n      So, for each j, the player is starting_player if j is even, else the other.\n\n      Thus, the sequence of players is fixed once the starting player is chosen.\n\n3. Once the players for each j are known, construct the sum for each starting option.\n\n   a. For each j from 0 to 2n-1:\n\n      i. Get the digit at position j.\n\n      ii. Determine which player takes it.\n\n      iii. Add the digit to that player's number, considering its position.\n\n4. Compute the sum for both starting options and choose the better one.\n\n5. Output the corresponding sequence of moves.\n\nWait, but the sum calculation is not just adding the digits numerically but considering their positional values.\n\nSo, for each player, the digits are added in the order they take them, with the earliest digits being more significant.\n\nFor example, if H takes the first and third digits, his number is d1 d3, which is d1 * 10^2 + d3 * 10^1.\n\nSimilarly, if M takes the second and fourth digits, her number is d2 d4, which is d2 * 10^1 + d4 * 10^0.\n\nSo, the sum is S1 + S2 = (d1 * 10^2 + d3 * 10^1) + (d2 * 10^1 + d4 * 10^0).\n\nThus, for each starting option, we can compute the sum as follows:\n\n- For each player, collect the digits they take, in the order they take them.\n\n- For each digit in the player's list, assign it to the corresponding position (e.g., first digit is 10^{k-1}, where k is the count of digits taken by the player).\n\n- Sum all these contributions.\n\nSo, the plan is:\n\nFor each starting option (H or M):\n\n   a. Create two lists: h_digits and m_digits.\n\n   b. For each j in 0..2n-1:\n\n      i. Determine which player is taking the j-th digit.\n\n      ii. Append the digit to their respective list.\n\n   c. For each player's list, compute their number as an integer, considering the positional values.\n\n   d. Sum the two integers to get the total.\n\nCompute this for both starting options and choose the one with the higher sum.\n\nIf both sums are equal, choose the starting option with the lex order or any.\n\nOnce the optimal starting option is chosen, output the sequence of moves for that starting option.\n\nSo, the code can be structured as follows:\n\nRead n and A.\n\nFor starting in ['H', 'M']:\n\n   assign each digit to a player in the order determined by starting and j's parity.\n\n   compute the sum.\n\nChoose the starting option with higher sum.\n\nIf equal, choose the lex order or any.\n\nThen, output the corresponding sequence of moves.\n\nNow, how to implement this.\n\nFirst, for a given starting player, generate the sequence of moves.\n\nThe sequence is simply 'H' if starting is H, then 'M', 'H', etc., for 2n steps.\n\nSo, for starting 'H':\n\nmoves = []\nfor j in 0 to 2n-1:\n   if j % 2 == 0:\n      moves.append('H')\n   else:\n      moves.append('M')\n\nSimilarly for starting 'M'.\n\nBut wait, no. Because the starting player is H, the first move is H, then M, then H, etc. So for 2n moves, the sequence alternates.\n\nBut wait, 2n is even, so starting with H will have n H's and n M's.\n\nSo, the code can generate the moves list as follows:\n\nif starting is 'H':\n\n   moves = ['H' if i % 2 == 0 else 'M' for i in range(2*n)]\n\nelif starting is 'M':\n\n   moves = ['M' if i % 2 == 0 else 'H' for i in range(2*n)]\n\nWait, no. Because for starting with H, the first move is H (j=0), then M (j=1), etc.\n\nSo, for j from 0 to 2n-1:\n\n   if j % 2 == 0: H's turn.\n\n   else: M's turn.\n\nThus, the moves list is indeed as above.\n\nOnce the moves are generated, we can compute the sum.\n\nTo compute the sum, for each player, we need to process their digits in the order they were taken, and compute the integer value.\n\nSo, for each starting option:\n\nsum_total = 0\n\nh_digits = []\nm_digits = []\n\nfor j in 0 to 2n-1:\n\n   digit = A[j]\n\n   if j % 2 == 0 and starting == 'H':\n\n       h_digits.append(digit)\n\n   elif j % 2 == 1 and starting == 'H':\n\n       m_digits.append(digit)\n\n   elif j % 2 == 0 and starting == 'M':\n\n       m_digits.append(digit)\n\n   else:\n\n       h_digits.append(digit)\n\nThen, for h_digits, the first digit is the most significant, etc.\n\nSo, for h_digits, the value is sum(int(d)*10^(len(h_digits)-1 - idx) for idx, d in enumerate(h_digits)).\n\nSimilarly for m_digits.\n\nSo, compute s1 = sum of h_digits with appropriate exponents.\n\ns2 = sum of m_digits with appropriate exponents.\n\nsum_total = s1 + s2.\n\nCompare sum_total for both starting options.\n\nThus, the code can be implemented.\n\nNow, let's test this logic against the sample input.\n\nSample Input:\n\nn=2, A='1234'\n\nWait, wait, no. Looking back, the problem says that the input is two lines: first line is n, second is A.\n\nWait, in the sample input, the input is:\n\n['2\\n1234', '2\\n9911']\n\nWait, but perhaps the sample is miswritten. Let me see.\n\nWait, the user wrote:\n\n### Input\n['2\\n1234', '2\\n9911']\n\nWhich probably means that n=2, and A is '1234' and '9911' in two separate test cases.\n\nBut perhaps the actual input is two lines: the first line is 2, the second is 1234.\n\nWait, but the sample shows the output as 'HHMM' and 'HMHM'.\n\nLet me compute for n=2 and A='1234'.\n\nCase 1: Starting with H.\n\nDigits are 1,2,3,4.\n\nj=0: H takes 1.\n\nj=1: M takes 2.\n\nj=2: H takes 3.\n\nj=3: M takes 4.\n\nSo, H's digits are [1,3], which form 13.\n\nM's digits are [2,4], which form 24.\n\nSum is 13 + 24 = 37.\n\nCase 2: Starting with M.\n\nj=0: M takes 1.\n\nj=1: H takes 2.\n\nj=2: M takes 3.\n\nj=3: H takes 4.\n\nH's digits are [2,4], forming 24.\n\nM's digits are [1,3], forming 13.\n\nSum is 24 + 13 = 37.\n\nSo, both options give the same sum.\n\nThus, the output can be either HHMM or MHMH.\n\nWait, but in the sample output, it's 'HHMM' and 'HMHM'.\n\nWait, perhaps the sample input is different.\n\nAlternatively, perhaps the sample input is:\n\nn=2, A='9911'.\n\nWait, let's see.\n\nCase 1: starting with H.\n\nDigits:9,9,1,1.\n\nj=0: H takes 9.\n\nj=1: M takes 9.\n\nj=2: H takes 1.\n\nj=3: M takes 1.\n\nH's digits: [9,1] → 91.\n\nM's digits: [9,1] → 91.\n\nSum is 182.\n\nCase 2: starting with M.\n\nj=0: M takes 9.\n\nj=1: H takes 9.\n\nj=2",
    "response": "To solve this problem, we need to determine the sequence of moves for Homer and Marge in a TV game such that their total prize is maximized. Each player makes exactly `n` moves, and the goal is to maximize the sum of their respective numbers formed by appending digits from a given string.\n\n### Approach\n1. **Problem Analysis**: The game involves two players taking turns to append the leftmost digit of a given string to their respective numbers. The challenge is to maximize the sum of these numbers by determining the optimal sequence of moves.\n2. **Turn Order**: Players alternate turns, starting with either Homer ('H') or Marge ('M'). The sequence of moves is determined by the starting player.\n3. **Digit Assignment**: Each digit is taken in the order they appear in the string, with each player taking turns. The contribution of each digit to the player's number depends on its position (i.e., how many digits have been taken before it).\n4. **Sum Calculation**: For each possible starting player, compute the sum of the numbers formed by both players. Choose the starting player that yields the highest sum.\n\n### Solution Code\n```python\nn = int(input())\nA = input().strip()\n\ndef compute_sum(starting):\n    h_digits = []\n    m_digits = []\n    for j in range(2 * n):\n        if j % 2 == 0:\n            current_player = starting\n        else:\n            current_player = 'M' if starting == 'H' else 'H'\n        digit = A[j]\n        if current_player == 'H':\n            h_digits.append(digit)\n        else:\n            m_digits.append(digit)\n    # Calculate s1\n    s1 = 0\n    for idx, d in enumerate(h_digits):\n        s1 += int(d) * (10 ** (len(h_digits) - 1 - idx))\n    # Calculate s2\n    s2 = 0\n    for idx, d in enumerate(m_digits):\n        s2 += int(d) * (10 ** (len(m_digits) - 1 - idx))\n    return s1 + s2\n\n# Compute for both starting options\nsum_h = compute_sum('H')\nsum_m = compute_sum('M')\n\nif sum_h > sum_m:\n    moves = ['H' if i % 2 == 0 else 'M' for i in range(2 * n)]\nelif sum_m > sum_h:\n    moves = ['M' if i % 2 == 0 else 'H' for i in range(2 * n)]\nelse:\n    # Choose either, e.g., H first\n    moves = ['H' if i % 2 == 0 else 'M' for i in range(2 * n)]\n\nprint(''.join(moves))\n```\n\n### Explanation\n1. **Reading Input**: The input consists of an integer `n` and a string `A` of length `2n`.\n2. **Compute Sum Function**: This function calculates the total sum of the numbers formed by the players for a given starting player. It alternates turns based on the starting player and assigns each digit to the respective player's number.\n3. **Determine Optimal Start**: The code computes the sum for both starting players ('H' and 'M') and chooses the one with the higher sum. If both sums are equal, it defaults to starting with 'H'.\n4. **Output Moves**: The sequence of moves is generated based on the optimal starting player and printed as the result.\n\nThis approach ensures that we maximize the total prize by considering both possible starting players and choosing the optimal sequence of moves efficiently.",
    "ground_truth": "N/A",
    "extracted_answer": "n = int(input())\nA = input().strip()\n\ndef compute_sum(starting):\n    h_digits = []\n    m_digits = []\n    for j in range(2 * n):\n        if j % 2 == 0:\n            current_player = starting\n        else:\n            current_player = 'M' if starting == 'H' else 'H'\n        digit = A[j]\n        if current_player == 'H':\n            h_digits.append(digit)\n        else:\n            m_digits.append(digit)\n    # Calculate s1\n    s1 = 0\n    for idx, d in enumerate(h_digits):\n        s1 += int(d) * (10 ** (len(h_digits) - 1 - idx))\n    # Calculate s2\n    s2 = 0\n    for idx, d in enumerate(m_digits):\n        s2 += int(d) * (10 ** (len(m_digits) - 1 - idx))\n    return s1 + s2\n\n# Compute for both starting options\nsum_h = compute_sum('H')\nsum_m = compute_sum('M')\n\nif sum_h > sum_m:\n    moves = ['H' if i % 2 == 0 else 'M' for i in range(2 * n)]\nelif sum_m > sum_h:\n    moves = ['M' if i % 2 == 0 else 'H' for i in range(2 * n)]\nelse:\n    # Choose either, e.g., H first\n    moves = ['H' if i % 2 == 0 else 'M' for i in range(2 * n)]\n\nprint(''.join(moves))",
    "score": 0,
    "metadata": {
        "prompt_token_count": 411,
        "completion_token_count": 750,
        "thoughts_token_count": 8193
    }
}