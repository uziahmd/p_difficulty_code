{
    "start": 1758286202.6584575,
    "end": 1758288521.0529575,
    "start-formatted": "2025-09-19 21:50 KST",
    "end-formatted": "2025-09-19 22:28 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "Okay, so I have this problem where I need to determine if it's possible to assign a number of mushrooms to each lawn such that all the given roads' GCD and LCM constraints are satisfied. And if it's possible, I have to output any valid assignment.\n\nHmm, let's think about the problem. Each edge between two lawns u and v gives us a pair (g, l), which is the GCD and LCM of the mushrooms on u and v. So, for each such edge, the numbers at u and v must satisfy that their GCD is g and their LCM is l.\n\nWait, but how do I model this? Because the GCD and LCM of two numbers a and b are related by the formula: GCD(a,b) * LCM(a,b) = a*b. So for each edge, a * b = g * l, right?\n\nYes. So for each edge, the product of the two mushrooms is fixed as g * l. But since GCD(a,b) is g, that means that a = g * x and b = g * y, where x and y are coprime integers, and LCM(a,b) is g * x * y, which equals l. So l must be equal to g * x * y.\n\nSo for each edge, the pair (u, v) must have a and b such that a = g * x, b = g * y, and x and y are coprime, with x*y = l/g.\n\nWait, but l/g must be equal to x*y because l = g * x * y. So x and y must be factors of l/g, and they must be coprime.\n\nSo, for each edge, the value of l/g must be equal to x*y, and x and y must be coprimes. Also, since a and b are positive integers, x and y must be positive integers as well.\n\nSo, the approach is to model each node's value as a multiple of some base variable, perhaps, and then set up equations based on the edges.\n\nBut how do I model this in a way that can be solved programmatically?\n\nI think this can be modeled as a system of equations where each equation represents an edge's constraints. Each variable is the number of mushrooms on a lawn, and each equation enforces the GCD and LCM condition on two variables.\n\nWait, but the variables are connected through multiple equations, so this might form a graph where each edge imposes certain constraints on the variables.\n\nThis seems similar to a problem where each variable is a node, and each equation is an edge, but it's more like a hypergraph because each equation connects two variables with specific multiplicative constraints.\n\nAlternatively, maybe we can model this using Union-Find (Disjoint Set Union) data structure with some modifications to track the relationships between variables.\n\nWait, but the constraints involve multiplication, so perhaps each node can have a value, and each edge represents a relationship between two nodes' values. So, for example, if an edge has GCD g and LCM l, then for nodes u and v, let’s denote a = x_u, b = x_v. Then, GCD(a, b) = g, LCM(a, b) = l. As before, a = g * x, b = g * y, where x and y are coprime, and x*y = l/g.\n\nSo, for each edge, the ratio of a to b is x : y, with x and y coprimes, and their product is (l/g).\n\nThis suggests that each edge enforces a multiplicative relationship between the variables of the two nodes.\n\nSo, to model this, each node can have a value that's a multiple of some base, and the edges enforce that the ratios are correct.\n\nThis sounds like a problem that can be modeled using a system of equations where each equation relates two variables. However, solving such a system could be complex, especially when dealing with multiple edges and ensuring consistency.\n\nAnother thought: since each edge enforces that the product of the two variables is fixed (g*l), perhaps we can model each variable as a ratio relative to a base variable.\n\nWait, but the variables are linked in a graph, so perhaps it's better to represent each variable as a product of primes raised to certain exponents, but that might get complicated.\n\nAlternatively, perhaps each variable can be represented in terms of a root variable. For example, pick a root node, say node 1, and express all other node's variables as multiples of node 1's variable.\n\nBut how? Let's see. Suppose node 1 has a value a. Then, for each edge connected to node 1, say to node u, we can express node u's value as a multiplied by some factor. Similarly, for each edge between u and v, their values would also be expressed in terms of a, leading to equations that can be checked for consistency.\n\nWait, but this approach could work if the graph is a tree, but when there are cycles, the constraints along different paths might conflict.\n\nFor example, suppose in a cycle, the product of variables leads to a contradiction. In that case, it's impossible to satisfy all the constraints, and the answer is NO.\n\nSo, the plan is:\n\n1. Choose a root node (like node 1) and assign it a value 'a'.\n\n2. For each node, keep track of its value in terms of 'a', i.e., x_i = a * k_i, where k_i is some integer.\n\n3. For each edge, express the GCD and LCM constraints in terms of a, k_u, k_v.\n\n4. Check if all these constraints are satisfied, and if any contradictions arise, output NO.\n\n5. If all constraints are satisfied, assign the values based on the root and the computed k_i's.\n\nBut wait, how do we model the GCD and LCM in terms of a, k_u, and k_v?\n\nLet me think. For an edge between u and v, with given GCD g and LCM l.\n\nWe have x_u = a * k_u, x_v = a * k_v.\n\nThe GCD(x_u, x_v) should be g, and LCM(x_u, x_v) should be l.\n\nBut x_u and x_v are multiples of a, so let's write them as a * m and a * n, where m = k_u, n = k_v.\n\nThen, GCD(a*m, a*n) = a * GCD(m, n). But this is supposed to be equal to g.\n\nSo, a * GCD(m, n) = g.\n\nSimilarly, LCM(a*m, a*n) = a * LCM(m, n) = l.\n\nSo, for the edge (u, v):\n\na * GCD(m, n) = g   ...(1)\n\na * LCM(m, n) = l   ...(2)\n\nAlso, since x_u = a*m and x_v = a*n, we have from (1) and (2):\n\nFrom (1): GCD(m, n) = g/a.\n\nFrom (2): LCM(m, n) = l/a.\n\nBut GCD(m, n) * LCM(m, n) = m * n.\n\nSo, substituting:\n\n(g/a) * (l/a) = m * n.\n\nSo, m * n = (g * l) / a².\n\nAdditionally, since GCD(m, n) = g/a, and m and n are integers, g must divide a. Because GCD(m, n) is g/a, which must be an integer. So, a must be a divisor of g.\n\nWait, no. Because m and n are integers, GCD(m, n) must be an integer. So, g/a must be an integer, meaning that a divides g.\n\nSimilarly, l/a must be an integer, because LCM(m, n) is l/a, which must be an integer.\n\nSo, a must be a common divisor of both g and l.\n\nThus, for each edge (u, v), the a (which is the value of the root node) must be a common divisor of g and l, and a² must divide g*l.\n\nSo, the first step is to find a value 'a' that is a common divisor of all the edge's g and l, and such that for each edge, a² divides g*l.\n\nWait, but a is the same across all edges. Or is it? Because 'a' is the value of the root node, which is a single value. So, 'a' must be chosen such that for every edge, a divides g and a divides l, and a² divides g*l.\n\nWait, no. Because for each edge, a is the same (since it's the root), so for each edge, a must divide both g and l. Because:\n\nFrom the earlier equations:\n\nGCD(m, n) = g/a → must be integer → g must be divisible by a.\n\nLCM(m, n) = l/a → must be integer → l must be divisible by a.\n\nSo, for each edge (u, v), a must be a divisor of g and a divisor of l. Therefore, a must be a common divisor of g and l for every edge.\n\nMoreover, for each edge, (g * l) must be divisible by a squared, because m * n = (g*l)/(a^2).\n\nSo, a must be a common divisor of g and l for each edge, and a² must divide g*l for each edge.\n\nSo, the approach is:\n\n- Find all possible a's that satisfy the above conditions for all edges.\n\n- For each possible a, try to assign the values of the nodes based on the edges and check for consistency.\n\nBut how do I proceed? Because trying all possible a's could be computationally intensive, especially since a can be up to the square root of (g*l) for each edge, which could be up to 1e6 or more.\n\nWait, but the maximum g and l are 106. So, a can't be larger than sqrt(106*106) = 106. So, for each edge, a can be any divisor of g and l, and up to 106.\n\nSo, perhaps the steps are:\n\n1. Collect all edges, each with their g and l.\n\n2. For each possible a (from 1 to 106), check if a divides all g's and l's of the edges.\n\n3. For each such a, proceed to model the variables.\n\nBut wait, a must be a common divisor of all edges' g and l. So, the maximum possible a is the greatest common divisor (gcd) of all the g's and l's across all edges.\n\nWait, no. Because each edge has its own g and l. So, a must be a common divisor of g and l for each individual edge, but not necessarily a common divisor across all edges.\n\nWait, no. Because a must divide g for each edge, and a must divide l for each edge. So, a must be a common divisor of g and l for each edge.\n\nBut it's possible that a is different for each edge, but in our case, a is fixed as the root variable. So, a must be a common divisor for all edges. Hmm, no. Wait, no. Because a is the same for all edges. So, for each edge, a must be a divisor of g and l of that edge. So, a must be a common divisor of all g's and l's across all edges.\n\nWait, for example, suppose one edge has g=4, l=6. Then a must divide 4 and 6. So possible a's are 1, 2, ... but what if another edge has g=6, l=4? Then a must divide 6 and 4 as well. So, a must be a common divisor of all g's and l's across all edges.\n\nWait, no. Because a is the same across all edges. So, for each edge, a must divide g_i and l_i. So, a must be a common divisor of all g_i and all l_i. So, a must be a common divisor of the union of all g_i and l_i.\n\nWait, no. It's possible that a is a common divisor of each edge's g and l, but not necessarily of all of them together.\n\nWait, no. Because a must divide each g_i and each l_i. So, a must be a common divisor of all g_i and all l_i. So, a can be any common divisor of the set of all g's and the set of all l's.\n\nWait, for example, suppose edges have g values 4 and 6, l values 6 and 4. Then, a must be a common divisor of 4 and 6 (for g's) and also a common divisor of 6 and 4 (for l's). So, a can be 1, 2.\n\nSo, a must be a common divisor of all g's and l's across all edges. So, the maximum possible a is the GCD of all g's and l's.\n\nSo, first, compute the GCD of all g's and all l's. Then, a can be any divisor of that overall GCD.\n\nWait, but that's not necessarily true. Because for each edge, a must divide g and l of that edge. So, a must be a common divisor of all g's and all l's, but the overall GCD of all g's and l's may not capture that. For example, suppose we have edges with g's 4,6 and l's 6,4. The overall GCD of g's is 2, and of l's is 2. So a must be a common divisor of 2 and 2, which is 1 or 2.\n\nYes, so the approach is:\n\nCompute the GCD of all g's and all l's across all edges. Let's call this G. Then, a must be a divisor of G. So, a can be any divisor of G.\n\nWait, but G is the GCD of all g's and l's. So, any a that is a divisor of G will automatically divide all g's and l's.\n\nYes. So, a can be any divisor of G, where G is the GCD of all g's and l's.\n\nSo, first, compute G = GCD of all g's and l's.\n\nThen, a can be any divisor of G.\n\nSo, for each possible a (divisor of G), we can check if it satisfies all edges' constraints.\n\nNow, for each a, how do we model the variables?\n\nEach node's value is a * k_i, where k_i is an integer. For each edge, the constraints are:\n\nx_u = a * k_u\n\nx_v = a * k_v\n\nWith GCD(x_u, x_v) = g and LCM(x_u, x_v) = l.\n\nAs before, substituting:\n\nGCD(a*k_u, a*k_v) = a * GCD(k_u, k_v) = g.\n\nSimilarly, LCM(a*k_u, a*k_v) = a * LCM(k_u, k_v) = l.\n\nSo, from these, GCD(k_u, k_v) = g/(a), and LCM(k_u, k_v) = l/(a).\n\nAlso, since k_u and k_v are coprime, because GCD(k_u, k_v) must be 1.\n\nWait, no. Wait, GCD(k_u, k_v) is g/a. So, g/a must be an integer, which it is because a divides g.\n\nBut in order for k_u and k_v to have GCD equal to g/a, they must themselves have that as their GCD. So, after factoring out a, the remaining variables (k_u and k_v) must have a GCD of g/a.\n\nSo, for each edge, we can express k_u and k_v in terms of their GCD and co-prime parts.\n\nSo, for each edge (u, v), let’s denote:\n\ng’ = g / a\n\nl’ = l / a\n\nThen, since x_u = a * k_u and x_v = a * k_v,\n\nwe have:\n\nGCD(k_u, k_v) = g’\n\nand LCM(k_u, k_v) = l’.\n\nBut since LCM(k_u, k_v) = (k_u * k_v) / GCD(k_u, k_v) = (k_u * k_v)/g’.\n\nSo, l’ = (k_u * k_v)/g’.\n\nRearranging, k_u * k_v = g’ * l’.\n\nMoreover, since GCD(k_u, k_v) = g’, we can write k_u = g’ * x, k_v = g’ * y, where x and y are coprimes.\n\nSubstituting into k_u * k_v = g’ * l’:\n\n(g’ x)(g’ y) = g’ * l’ → g’^2 x y = g’ l’ → x y = l’ / g’.\n\nSo, x and y are coprimes, and their product is l’ / g’.\n\nBut since x and y are coprimes, l’ must be divisible by g’ for this to hold. Because x and y are integers.\n\nWait, but l’ is l / a, and g’ is g / a. So, l’ must be a multiple of g’ for this to work.\n\nWhich it is, because LCM(k_u, k_v) is l’ and GCD(k_u, k_v) is g’, so l’ must be a multiple of g’.\n\nTherefore, for each edge, we can write:\n\nk_u = g’ * x\n\nk_v = g’ * y\n\nwhere x and y are coprimes, and x*y = (l’ ) / (g’).\n\nWait, no. Earlier substitution gives x*y = (l’ ) / (g’).\n\nBecause:\n\nx y = (l’ ) / (g’ )\n\nSo, the product x*y must equal (l’ ) / (g’ ), and x and y are coprimes.\n\nThus, for each edge, once a is chosen, we can compute g’ and l’ as g/a and l/a.\n\nThen, for each edge, we can compute the possible pairs (x, y) that satisfy x * y = (l’ ) / (g’ ), with x and y coprimes.\n\nBut wait, x and y are not unique. There could be multiple possibilities for x and y, but each would lead to different assignments of k_u and k_v, possibly conflicting with previous assignments.\n\nSo, the problem reduces to building a system where for each edge, the k_u and k_v variables are constrained according to the above, and ensuring that the constraints don't conflict.\n\nHow can we model this?\n\nPerhaps, for each node, we can track its value relative to the root. Since the root's value is a, the other nodes' values are a multiplied by their respective k_i.\n\nBut how do we handle the edges? For each edge, we have to ensure that the constraints on k_u and k_v are met.\n\nSo, perhaps, for each node, we can represent its k_i as a product of primes, and each edge adds constraints on the prime factors of k_u and k_v.\n\nBut handling this directly might be complicated.\n\nAlternatively, since each edge's constraints are multiplicative, perhaps we can model the k_i's in terms of their prime factors.\n\nWait, but considering that for each edge, the k_i's are built from factors of (l’ )/(g’ ), which is (l/a)/(g/a) = l/g.\n\nWait, because l’ is l/a and g’ is g/a. So, l’/g’ = (l/a)/(g/a) = l/g.\n\nSo, for each edge, x*y = l/g, where x and y are coprimes.\n\nSo, for each edge, the product of x and y is l/g, and x and y are coprimes.\n\nThus, for each edge, the possible pairs (x, y) are the pairs of divisors of (l/g) that are coprimes.\n\nSo, for each edge, we can precompute all possible (x, y) pairs, and then for each a, check if the constraints can be satisfied across all edges without conflicts.\n\nBut the number of possible pairs per edge could be manageable, as l/g is up to (106*106)/1 = around 11236, whose number of divisors is limited.\n\nBut even then, for a graph with m edges, the number of possibilities could explode exponentially.\n\nSo, perhaps a better approach is to model this as a system of equations and constraints, and then use a BFS or DFS approach to assign variables, checking for consistency.\n\nBut I'm not sure how to implement that.\n\nAlternatively, perhaps for each possible a (divisor of G), we can build a bipartite graph where each edge's constraints are enforced, and see if the system is consistent.\n\nWait, perhaps we can model this as a graph where each node has a value, and each edge imposes constraints on those values. This is similar to a constraint satisfaction problem, which can be solved with backtracking or some form of graph-based constraints.\n\nBut with n up to, say, 1e5, that's not feasible.\n\nWait, no, the input constraints are not given, but the sample input shows n=3 and m=4, so perhaps n is small enough that a brute-force approach is possible for each possible a.\n\nWait, but the problem statement says that it's guaranteed that the initial map had numbers no less than 1 and no more than 106. So, the a is at most 106, and for each a, the possible pairs for each edge are limited.\n\nSo, perhaps the steps are:\n\n1. Compute G as the GCD of all g's and l's across all edges.\n\n2. Enumerate all divisors of G. These are the possible a's.\n\n3. For each a in the divisors of G:\n\n   a. For each edge, compute g’ = g/a and l’ = l/a.\n\n   b. For each edge, compute s = l’ / g’. If s is not an integer, this a is invalid. So, skip to next a.\n\n   c. For each edge, find all possible (x, y) pairs where x and y are coprimes and x*y = s.\n\n   d. Now, model the constraints for each edge as a system where k_u = g’ * x and k_v = g’ * y.\n\n   e. Check if this system is consistent across all edges, i.e., no conflicting assignments for k_i's.\n\n   f. If consistent, assign the k_i's and compute the x_i = a * k_i for all nodes. Output this.\n\n4. If any a leads to a consistent assignment, output YES and the assignment. Otherwise, output NO.\n\nBut the problem is, for each a, how to efficiently check if the assignments are consistent.\n\nThis seems tricky because the constraints form a directed graph, and each edge adds constraints between two nodes.\n\nWait, perhaps for each a, we can model the constraints as a graph where each edge (u, v) enforces that k_u = (some multiple of g’ ) and k_v = (another multiple of g’ ). But since k_u and k_v are determined by their edges, it's possible that some edges impose conflicting requirements on the same node's k_i.\n\nSo, perhaps for each a, we can perform a BFS or DFS traversal, assigning k_i's as we go, and checking for consistency.\n\nHere's a more concrete plan:\n\nFor a given a:\n\n- Initialize all k_i as None (unassigned).\n\n- For each edge (u, v), compute s = l’ / g’ = (l/a)/(g/a) = l/g.\n\n- For this edge, we need to find possible x and y such that x*y = s and GCD(x,y) = 1.\n\n- For each possible (x, y) pair:\n\n   - Assign k_u = g’ * x.\n\n   - Assign k_v = g’ * y.\n\n   - Then, for all other edges connected to u or v, check if their constraints are satisfied.\n\nBut this could be time-consuming, as for each edge, there may be multiple (x, y) pairs, and for each pair, we have to explore the implications on other edges.\n\nAn alternative approach is to model each k_i as a product of variables, and represent the constraints in terms of these variables.\n\nWait, perhaps for each node, k_i can be represented as a product of certain primes raised to certain exponents. Each edge's constraints would then translate into constraints on the exponents of these primes in the connected nodes.\n\nBut this might complicate things.\n\nAlternatively, perhaps for each a, we can model the constraints as a system of equations, where each equation is k_u = x * something, and check for consistency.\n\nBut again, this is vague.\n\nWait, perhaps for each a, we can create a graph where each node has a value k_i, and each edge (u, v) imposes that k_u / k_v must be a certain ratio, or that k_u is a multiple of k_v, etc.\n\nBut in our case, for each edge, k_u and k_v are determined up to a multiplicative factor.\n\nWait, no. For each edge, the product of k_u and k_v is fixed as s = l’/g’ = (l/a)/(g/a) = l/g.\n\nWait, no, wait: For edge (u, v), s = (l’ )/(g’ ) = (l/a)/(g/a) = l/g.\n\nAnd, in that edge, x * y = s, where x and y are coprimes.\n\nSo, the product of k_u and k_v is fixed as s.\n\nBut that's not exactly helpful.\n\nWait, perhaps for each a, we can represent the constraints as follows:\n\nFor each edge (u, v), we have:\n\nk_u * k_v = s, where s is l’/g’ = l/g.\n\nBut no, that's not correct. Because k_u = g’ * x, k_v = g’ * y, and x*y = s/(g’^2) ?\n\nWait, no. Let's re-express:\n\nWe have k_u = g’ * x, k_v = g’ * y.\n\nAnd x * y = s = (l’ )/(g’ ) = (l/a)/(g/a) = l/g.\n\nSo, x * y = s.\n\nSo, the product of x and y is s.\n\nBut x and y are coprimes.\n\nSo, for each edge, the product of x and y is s, and x and y are coprimes.\n\nSo, for each edge, the possible (x, y) pairs are the pairs of divisors of s where x and y are coprimes.\n\nSo, for each a, for each edge, we can generate all possible (x, y) pairs and then model the constraints on k_u and k_v.\n\nBut how to combine these constraints across the entire graph.\n\nAn alternative idea: For each a, try to assign the k_i's in such a way that all edges' constraints are satisfied.\n\nWe can model this as a system where each edge (u, v) imposes that k_u / k_v must be equal to x/y, where x and y are coprimes and x*y = s.\n\nBut how to represent this.\n\nWait, perhaps for each edge, we can represent the ratio k_u / k_v as x/y, which is a rational number.\n\nThen, the problem becomes whether all edges can be satisfied with these ratios.\n\nThis is similar to a system of equations where the variables are the k_i's, and each equation is k_u = x/y * k_v.\n\nBut since the k_i's must be integers, these ratios must reduce to fractions where the denominator divides the numerator.\n\nWait, perhaps we can model each k_i as a vector of exponents for each prime factor, and then the constraints can be checked in terms of these exponents.\n\nBut this seems complicated.\n\nAlternatively, perhaps for each a, we can build a graph where each node is assigned a variable, and each edge represents a constraint that the product of the variables for u and v must equal s.\n\nWait, but that's not quite accurate.\n\nAlternatively, perhaps the problem can be modeled using a Union-Find data structure with some additional information, such as the ratio between the variables in the same connected component.\n\nWait, yes! This is a promising approach.\n\nIn the Union-Find structure, each node can have a parent, and the path from the node to the root can be tracked in terms of the product of variables.\n\nWait, but how to represent the product.\n\nWait, for each node, we can track a value that represents the product of variables relative to the root. So, for each node u, we have k_u = k_root * r_u, where r_u is a rational number representing the ratio.\n\nWhen processing an edge (u, v), we have:\n\nk_u * k_v = s.\n\nSubstituting, (k_root * r_u) * (k_root * r_v) = s.\n\nBut k_root is a, which is fixed for this a. So:\n\na² * r_u * r_v = s.\n\nThus, r_u * r_v = s/(a²).\n\nBut s is l/g, so s/(a²) is (l/g)/a² = l/(g a²).\n\nWait, but I'm not sure.\n\nAlternatively, perhaps for each edge (u, v), we have:\n\nk_u = x * t\n\nk_v = y * t\n\nWhere x and y are coprimes, and x*y = s.\n\nWait, but how does this fit into the Union-Find structure.\n\nAlternatively, perhaps for each node u, we can track a variable 'val' which represents k_u.\n\nInitially, val[u] is undefined.\n\nFor each edge (u, v), when processed:\n\n- If both u and v are unassigned: assign val[u] = x, val[v] = y, where x*y = s, and x and y are coprimes.\n\n- If one is assigned and the other is not: check if the existing assignment is consistent with the new constraints.\n\n- If both are assigned: check if their current values are consistent with the new constraints.\n\nBut this requires checking for each edge whether the current assignments are compatible.\n\nSo, here's the approach for a given a:\n\n1. Compute s = l/g for each edge.\n\n2. For each edge (u, v):\n\n   a. Compute s = l/g.\n\n   b. Find all possible (x, y) pairs where x and y are coprimes and x*y = s.\n\n3. Try to assign the variables in such a way that all edges are satisfied.\n\nBut how to manage the possible pairs for each edge.\n\nThis seems computationally expensive, as for each edge, there could be multiple possible (x, y) pairs, and the assignments could conflict.\n\nAn alternative is to represent the constraints as equations and see if they can be satisfied.\n\nWait, perhaps for each a, the system of equations can be represented as a graph where each edge (u, v) imposes that k_u * k_v = s.\n\nThis is a quadratic equation, which complicates matters.\n\nWait, but if we can find a way to represent the ratios of k_u and k_v, perhaps we can use a Union-Find structure with path compression, tracking the ratio between each node and its parent.\n\nThis is known as a \"Union-Find with multiplicative constraints\" approach.\n\nLet me recall: in such a structure, each node has a parent, and a value representing the ratio of the node's value to the parent's value.\n\nWhen merging two sets, we can check if the existing ratios are consistent with the new constraints.\n\nSo, for each a:\n\n- Initialize each node's value as 1 (or perhaps as a variable that will be determined later).\n\n- For each edge (u, v), process it as follows:\n\n   a. Find the roots of u and v.\n\n   b. If the roots are different:\n\n      i. Check if the current ratio between u and v is compatible with the new constraint that k_u * k_v = s.\n\n      ii. If compatible, merge the two sets, updating the ratios accordingly.\n\n   c. If the roots are the same:\n\n      i. Check if the existing ratio between u and v is compatible with k_u * k_v = s.\n\n      ii. If not, this a is invalid.\n\nSo, for each a, we process all edges and check if they can be satisfied using this Union-Find structure.\n\nIf all edges are processed successfully, then this a is valid, and we can compute the k_i's.\n\nWait, this seems promising.\n\nSo, the steps for each a are:\n\n1. Compute s = l/g for each edge.\n\n2. For each edge (u, v):\n\n   a. Compute s = l/g.\n\n   b. Use the Union-Find structure to add the constraint that k_u * k_v = s.\n\nIf all edges are processed without conflicts, then the system is consistent, and we can assign the k_i's.\n\nSo, the key is to implement the Union-Find structure with multiplicative constraints.\n\nHow does this work?\n\nIn the Union-Find structure, each node has a parent and a 'weight' which represents the ratio from the node to its parent.\n\nWhen finding the root of a node, the path is compressed, and the weights are updated to represent the cumulative ratio from the node to the root.\n\nWhen uniting two nodes u and v, we compute the expected ratio between u and v based on their current roots and weights. If this matches the desired ratio (s), we can merge the sets. Otherwise, it's a conflict.\n\nLet's formalize this:\n\nEach node u has:\n\nparent[u] = p(u)\n\nratio[u] = r(u), which is the ratio of u's value to p(u)'s value.\n\nSo, k_u = k_p(u) * r(u).\n\nWhen finding the root of u, we also find the root of p(u), and update u's parent and ratio to point directly to the root, with the ratio being the product of the ratios along the path.\n\nFor example, if u's parent is v, and v's parent is w, then the ratio from u to w is ratio[u] * ratio[v].\n\nSo, when path compressing, we can make u point directly to w, with ratio[u] = ratio[u] * ratio[v].\n\nNow, when we have an edge (u, v) with the constraint that k_u * k_v = s:\n\n- Find the roots of u and v.\n\n- If the roots are different:\n\n   - Compute the expected ratio between u and v.\n\n   - The expected ratio is (k_u / k_v) = (k_u_root * ratio[u]) / (k_v_root * ratio[v]).\n\n   - But we want k_u * k_v = s → k_u / k_v = s / k_v². Wait, no.\n\nWait, perhaps I'm getting confused.\n\nWait, the constraint is k_u * k_v = s.\n\nWe can rewrite this as k_u = s / k_v.\n\nSo, the ratio k_u / k_v is s / (k_v)^2. Not sure.\n\nAlternatively, perhaps the constraint is k_u = s / k_v.\n\nSo, the ratio k_u / k_v = s / (k_v)^2.\n\nHmm, perhaps it's easier to represent the constraint as k_u * k_v = s.\n\nSo, during the Union-Find processing:\n\n1. For the current edge (u, v), compute s = l/g.\n\n2. Find the root of u (root_u) and the root of v (root_v).\n\n3. If root_u != root_v:\n\n   a. The current constraint is k_u * k_v = s.\n\n   b. Express k_u in terms of root_u: k_u = k_root_u * ratio_u.\n\n   c. Express k_v in terms of root_v: k_v = k_root_v * ratio_v.\n\n   d. The constraint becomes (k_root_u * ratio_u) * (k_root_v * ratio_v) = s.\n\n   e. We can express this as k_root_u * k_root_v = s / (ratio_u * ratio_v).\n\n   f. So, when we merge root_u and root_v, we need to set the ratio between them such that this equation holds.\n\n   g. So, when merging, the ratio between root_u and root_v would be s / (ratio_u * ratio_v).\n\n   h. So, during the union, we calculate this ratio and set it as the ratio between root_u and root_v.\n\n4. If root_u == root_v:\n\n   a. We have to ensure that (k_u * k_v) = s.\n\n   b. k_u = k_root * ratio_u.\n\n   c. k_v = k_root * ratio_v.\n\n   d. So, (k_root * ratio_u) * (k_root * ratio_v) = s → k_root² * (ratio_u * ratio_v) = s.\n\n   e. So, k_root² = s / (ratio_u * ratio_v).\n\n   f. Since k_root must be an integer, s must be divisible by (ratio_u * ratio_v), and the square root of (s/(ratio_u * ratio_v)) must be an integer.\n\n   g. So, if this is not the case, the a is invalid.\n\nSo, the steps are:\n\nFor each a:\n\n1. Compute G = GCD of all g's and l's across all edges.\n\n2. Enumerate all divisors of G as possible a's.\n\n3. For each a:\n\n   a. Compute s = l/g for each edge. If any s is not an integer, skip this a.\n\n   b. Initialize the Union-Find structure.\n\n   c. For each edge (u, v):\n\n      i. Compute s = l/g.\n\n      ii. Find the roots of u and v.\n\n      iii. If roots are different:\n\n          - Compute the required ratio between the roots.\n\n          - Unite them, setting the ratio between the roots to s / (ratio_u * ratio_v).\n\n      iv. Else:\n\n          - Compute the required product of the current ratios.\n\n          - Check if s equals the product.\n\n          - If not, this a is invalid.\n\n   d. If all edges are processed without conflicts, then the a is valid.\n\n   e. Once a valid a is found, assign the k_i's as follows:\n\n      - For each node, find its root.\n\n      - The k_i is the product",
    "response": "To solve this problem, we need to determine if it's possible to assign a number of mushrooms to each lawn such that all given roads' GCD and LCM constraints are satisfied. If possible, we must output any valid assignment.\n\n### Approach\n1. **Understanding Constraints**: Each edge between two lawns provides GCD and LCM constraints. For an edge with GCD `g` and LCM `l`, the product of the mushrooms on the two lawns must be `g * l`.\n\n2. **Divisors and Common GCD**: Compute the greatest common divisor (GCD) of all GCDs and LCMs from the edges. This helps in determining possible values for the root node.\n\n3. **Union-Find Structure**: Use a Union-Find data structure with path compression to manage the constraints efficiently. Each node keeps track of its parent and the ratio of its value relative to its parent.\n\n4. **Processing Edges**: For each possible value of the root node (a divisor of the computed GCD), process each edge to check if the constraints can be satisfied without conflicts.\n\n5. **Validation and Assignment**: For each valid root value, validate all edges using the Union-Find structure. If valid, compute the mushroom counts for each lawn and print the result.\n\n### Solution Code\n```python\nimport sys\nfrom math import gcd\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    m = int(input[ptr])\n    ptr += 1\n\n    edges = []\n    all_gcd = []\n    all_lcm = []\n    for _ in range(m):\n        u = int(input[ptr])\n        v = int(input[ptr+1])\n        g = int(input[ptr+2])\n        l = int(input[ptr+3])\n        ptr +=4\n        edges.append( (u, v, g, l) )\n        all_gcd.append(g)\n        all_lcm.append(l)\n\n    # Compute G: GCD of all g and all l\n    def compute_gcd(arr):\n        res = arr[0]\n        for num in arr[1:]:\n            res = gcd(res, num)\n        return res\n    g_all = compute_gcd(all_gcd + all_lcm)\n    # Find all divisors of g_all\n    def get_divisors(num):\n        if num ==0:\n            return []\n        divisors = set()\n        for i in range(1, int(num**0.5)+1):\n            if num % i ==0:\n                divisors.add(i)\n                divisors.add(num//i)\n        return sorted(divisors)\n    possible_a = get_divisors(g_all)\n\n    # Prepare the edges for processing for each a\n    for a in possible_a:\n        s_list = []\n        valid = True\n        for u, v, g, l in edges:\n            s = l // g  # since a is a divisor of g and l, s must be integer\n            s_list.append(s)\n        # Now, process all edges with s = s_list[i]\n        # Initialize UF\n        parent = {}\n        ratio = {}\n        for i in range(n+1):\n            parent[i] = i\n            ratio[i] = 1\n        def find(u):\n            while parent[u] != u:\n                parent[u] = parent[parent[u]]\n                ratio[u] *= ratio[parent[u]]\n                u = parent[u]\n            return u\n        for idx in range(m):\n            u, v, g, l = edges[idx]\n            s = s_list[idx]\n            root_u = find(u)\n            root_v = find(v)\n            if root_u != root_v:\n                # Need to merge them with ratio root_u : root_v as s/(ratio_u * ratio_v)\n                # k_u * k_v = s\n                # k_u = k_root_u * ratio_u\n                # k_v = k_root_v * ratio_v\n                # So, (k_root_u * ratio_u) * (k_root_v * ratio_v) = s\n                # k_root_u * k_root_v = s / (ratio_u * ratio_v)\n                # So, when merging, the ratio from root_u to root_v is s / (ratio_u * ratio_v)\n                # Thus, when we make root_u's parent root_v, the ratio is s/(ratio_u * ratio_v)\n                # But we have to ensure that the new ratio is correct.\n                # Also, the order matters: u's root is root_u, v's root is root_v.\n                # So, k_root_u / k_root_v = (s) / (ratio_u * ratio_v)\n                # So, when making root_u's parent root_v, the ratio is (s) / (ratio_u * ratio_v)\n                # Wait, no: the ratio from root_u to root_v is (k_root_u / k_root_v) = (s) / (ratio_u * ratio_v)\n                # So, when we merge, we set parent[root_u] = root_v, and ratio[root_u] = (s) / (ratio_u * ratio_v)\n                # Because k_root_u * ratio[root_u] = k_root_v * (s/(ratio_u * ratio_v))\n                # So, k_root_u * ratio[root_u] = k_root_v * s/(ratio_u * ratio_v)\n                # But k_root_u * ratio_u = k_u, and k_root_v * ratio_v = k_v\n                # We have k_u * k_v = s → (k_root_u * ratio_u) * (k_root_v * ratio_v) = s\n                # Which is k_root_u * k_root_v * ratio_u * ratio_v = s\n                # So, k_root_u * k_root_v = s/(ratio_u * ratio_v)\n                # So, when we set parent[root_u] = root_v, ratio[root_u] should be (s)/(ratio_u * ratio_v)\n                # So, the new ratio is (s) / (ratio_u * ratio_v)\n                # Compute this value\n                numerator = s\n                denominator = ratio[u] * ratio[v]\n                if denominator == 0:\n                    valid = False\n                    break\n                ratio_uv = numerator / denominator\n                # Now, we can merge root_u into root_v\n                parent[root_u] = root_v\n                ratio[root_u] = ratio_uv\n            else:\n                # Check if (ratio[u] * ratio[v]) == s\n                # Because k_u = k_root * ratio[u], k_v = k_root * ratio[v]\n                # So, k_u * k_v = k_root^2 * ratio[u]*ratio[v] = s\n                # So, ratio[u] * ratio[v] must be s / (k_root)^2\n                # But since k_root is a, which is fixed, but here a is already considered.\n                # Wait, no. For this a, the root is the same for all nodes, so k_root is a.\n                # So, k_u = a * ratio[u], k_v = a * ratio[v]\n                # So, k_u * k_v = a^2 * ratio[u] * ratio[v] = s\n                # Thus, ratio[u] * ratio[v] must equal s / a²\n                required = ratio[u] * ratio[v]\n                if required != s:\n                    valid = False\n                    break\n        if valid:\n            # Now, assign the values\n            node_values = [0] * (n +1)\n            for i in range(1, n+1):\n                root = find(i)\n                node_values[i] = a * ratio[i]\n            # Ensure all node values are positive integers\n            print(\"YES\")\n            print(' '.join(map(str, node_values[1:])))\n            return\n    print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into the number of lawns, roads, and their respective GCD and LCM values.\n\n2. **Compute GCD**: The GCD of all GCDs and LCMs from the edges is computed to determine possible values for the root node.\n\n3. **Divisors**: All divisors of the computed GCD are considered as potential values for the root node.\n\n4. **Union-Find Structure**: For each potential root value, a Union-Find structure is used to manage the constraints imposed by each edge. This structure helps in efficiently checking for consistency across all edges.\n\n5. **Validation**: Each edge is processed to ensure that the constraints are satisfied. If any inconsistency is found, the current root value is discarded.\n\n6. **Output**: If a valid assignment is found, the values are printed. If no valid assignment exists, \"NO\" is printed.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom math import gcd\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    m = int(input[ptr])\n    ptr += 1\n\n    edges = []\n    all_gcd = []\n    all_lcm = []\n    for _ in range(m):\n        u = int(input[ptr])\n        v = int(input[ptr+1])\n        g = int(input[ptr+2])\n        l = int(input[ptr+3])\n        ptr +=4\n        edges.append( (u, v, g, l) )\n        all_gcd.append(g)\n        all_lcm.append(l)\n\n    # Compute G: GCD of all g and all l\n    def compute_gcd(arr):\n        res = arr[0]\n        for num in arr[1:]:\n            res = gcd(res, num)\n        return res\n    g_all = compute_gcd(all_gcd + all_lcm)\n    # Find all divisors of g_all\n    def get_divisors(num):\n        if num ==0:\n            return []\n        divisors = set()\n        for i in range(1, int(num**0.5)+1):\n            if num % i ==0:\n                divisors.add(i)\n                divisors.add(num//i)\n        return sorted(divisors)\n    possible_a = get_divisors(g_all)\n\n    # Prepare the edges for processing for each a\n    for a in possible_a:\n        s_list = []\n        valid = True\n        for u, v, g, l in edges:\n            s = l // g  # since a is a divisor of g and l, s must be integer\n            s_list.append(s)\n        # Now, process all edges with s = s_list[i]\n        # Initialize UF\n        parent = {}\n        ratio = {}\n        for i in range(n+1):\n            parent[i] = i\n            ratio[i] = 1\n        def find(u):\n            while parent[u] != u:\n                parent[u] = parent[parent[u]]\n                ratio[u] *= ratio[parent[u]]\n                u = parent[u]\n            return u\n        for idx in range(m):\n            u, v, g, l = edges[idx]\n            s = s_list[idx]\n            root_u = find(u)\n            root_v = find(v)\n            if root_u != root_v:\n                # Need to merge them with ratio root_u : root_v as s/(ratio_u * ratio_v)\n                # k_u * k_v = s\n                # k_u = k_root_u * ratio_u\n                # k_v = k_root_v * ratio_v\n                # So, (k_root_u * ratio_u) * (k_root_v * ratio_v) = s\n                # k_root_u * k_root_v = s / (ratio_u * ratio_v)\n                # So, when merging, the ratio from root_u to root_v is s / (ratio_u * ratio_v)\n                # Thus, when we make root_u's parent root_v, the ratio is s/(ratio_u * ratio_v)\n                # But we have to ensure that the new ratio is correct.\n                # Also, the order matters: u's root is root_u, v's root is root_v.\n                # So, k_root_u / k_root_v = (s) / (ratio_u * ratio_v)\n                # So, when making root_u's parent root_v, the ratio is (s) / (ratio_u * ratio_v)\n                # Wait, no: the ratio from root_u to root_v is (k_root_u / k_root_v) = (s) / (ratio_u * ratio_v)\n                # So, when we merge, we set parent[root_u] = root_v, and ratio[root_u] = (s) / (ratio_u * ratio_v)\n                # Because k_root_u * ratio[root_u] = k_root_v * (s/(ratio_u * ratio_v))\n                # So, k_root_u * ratio[root_u] = k_root_v * s/(ratio_u * ratio_v)\n                # But k_root_u * ratio_u = k_u, and k_root_v * ratio_v = k_v\n                # We have k_u * k_v = s → (k_root_u * ratio_u) * (k_root_v * ratio_v) = s\n                # Which is k_root_u * k_root_v * ratio_u * ratio_v = s\n                # So, k_root_u * k_root_v = s/(ratio_u * ratio_v)\n                # So, when we set parent[root_u] = root_v, ratio[root_u] should be (s)/(ratio_u * ratio_v)\n                # So, the new ratio is (s) / (ratio_u * ratio_v)\n                # Compute this value\n                numerator = s\n                denominator = ratio[u] * ratio[v]\n                if denominator == 0:\n                    valid = False\n                    break\n                ratio_uv = numerator / denominator\n                # Now, we can merge root_u into root_v\n                parent[root_u] = root_v\n                ratio[root_u] = ratio_uv\n            else:\n                # Check if (ratio[u] * ratio[v]) == s\n                # Because k_u = k_root * ratio[u], k_v = k_root * ratio[v]\n                # So, k_u * k_v = k_root^2 * ratio[u]*ratio[v] = s\n                # So, ratio[u] * ratio[v] must be s / (k_root)^2\n                # But since k_root is a, which is fixed, but here a is already considered.\n                # Wait, no. For this a, the root is the same for all nodes, so k_root is a.\n                # So, k_u = a * ratio[u], k_v = a * ratio[v]\n                # So, k_u * k_v = a^2 * ratio[u] * ratio[v] = s\n                # Thus, ratio[u] * ratio[v] must equal s / a²\n                required = ratio[u] * ratio[v]\n                if required != s:\n                    valid = False\n                    break\n        if valid:\n            # Now, assign the values\n            node_values = [0] * (n +1)\n            for i in range(1, n+1):\n                root = find(i)\n                node_values[i] = a * ratio[i]\n            # Ensure all node values are positive integers\n            print(\"YES\")\n            print(' '.join(map(str, node_values[1:])))\n            return\n    print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 545,
        "completion_token_count": 1864,
        "thoughts_token_count": 8193
    }
}