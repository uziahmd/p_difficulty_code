{
    "start": 1758278908.4743943,
    "end": 1758279576.9003038,
    "start-formatted": "2025-09-19 19:48 KST",
    "end-formatted": "2025-09-19 19:59 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "Okay, so I have this problem where I need to determine if it's possible to assign a number of mushrooms to each lawn such that all the given roads' GCD and LCM constraints are satisfied. And if it's possible, I have to output any valid assignment.\n\nHmm, let's think about the problem. Each edge between two lawns u and v gives us a pair (g, l), which is the GCD and LCM of the mushrooms on u and v. So, for each such edge, the numbers mu and mv must satisfy g = gcd(mu, mv) and l = lcm(mu, mv).\n\nWait, but wait a minute—what's the relationship between GCD and LCM? Oh right, for any two numbers a and b, the product of their GCD and LCM is equal to the product of the numbers themselves. So, g * l = mu * mv. That's an important equation.\n\nSo for each edge, we have:\n\nmu * mv = g * l\n\nBut also, since g is the GCD, mu and mv must both be multiples of g. Let me express mu as g * x and mv as g * y, where x and y are integers such that gcd(x, y) = 1. Because if x and y had a common divisor, then the GCD of mu and mv would be higher than g.\n\nThen, substituting into the LCM condition: l = lcm(gx, gy) = g * lcm(x, y). But since x and y are coprime, lcm(x, y) is x*y. So l = g * x * y.\n\nBut from the earlier equation, mu * mv = gx * gy = g^2 * x y. And from the product of GCD and LCM, it's g*l = g*(gxy) = g²xy. So yeah, that checks out.\n\nSo the key is that for each edge, mu and mv can be expressed as gx and gy, where x and y are coprime, and l = gxy.\n\nWait, but how do we model this as a graph? It seems like each node needs to have a value, and each edge imposes a constraint on those values.\n\nThis feels like a system of equations where each edge contributes an equation based on the GCD and LCM. So perhaps we can model this as a graph with variables (the mushrooms on each node) and constraints between them.\n\nBut solving such a system might be tricky. How can we represent the constraints and find a solution?\n\nMaybe we can model this as a bipartite graph or use some kind of union-find structure with constraints. Alternatively, perhaps we can model this as a system of equations and solve for the variables using some method like Gaussian elimination, but considering the multiplicative relationships.\n\nWait, but each edge's equation is multiplicative. For example, mu * mv = g * l, which is a product of two variables. So the system is nonlinear, which complicates things.\n\nHmm. So perhaps we can represent the variables in terms of their prime factors. Since the maximum value for g and l is 106, the primes involved won't be too big. The maximum possible value for a variable could be up to g*l, but I'm not sure.\n\nAlternatively, maybe we can model the variables in terms of their exponents for each prime. Then, each equation can be broken down into linear constraints on the exponents.\n\nLet me think about that. Suppose we factorize g and l into their prime factors. Then, for each prime p, the exponent of p in g is e_g(p), and similarly for l, e_l(p). Then, mu and mv must satisfy that for each p, the sum of exponents in mu and mv is equal to e_g(p) + e_l(p) divided by something? Wait, maybe not.\n\nWait, no. Let's consider that mu = g * x and mv = g * y. Then, l = g * x * y. So, for each prime p, the exponent in l is the exponent in g plus the exponents in x and y.\n\nWait, more precisely, let's say g has a prime factorization of product p_i^a_i. Similarly, x is product p_i^b_i, and y is product p_i^c_i. Then, l is product p_i^(a_i + b_i + c_i), because g*x*y is the product.\n\nBut from the equation mu * mv = g * l, which is (g x)(g y) = g l → g² x y = g l → l = g x y. So that's consistent.\n\nSo, the exponents in l are a_i + b_i + c_i. But since l is known, its exponents are known.\n\nSo for each prime p, the exponents in x and y must satisfy certain conditions.\n\nWait, but for each edge, we have a pair (g,",
    "response": "To solve this problem, we need to determine if it's possible to assign a number of mushrooms to each lawn such that all given road constraints (GCD and LCM) are satisfied. If possible, we should output any valid assignment; otherwise, we should output \"NO\".\n\n### Approach\n1. **Understanding the Constraints**: Each edge between two lawns provides a pair (GCD, LCM). For two numbers \\( u \\) and \\( v \\), their GCD is \\( g \\) and their LCM is \\( l \\). The key relationship here is \\( g \\times l = u \\times v \\).\n\n2. **Graph Representation**: We can model this problem as a graph where each node represents a lawn, and each edge represents a constraint between two nodes. The challenge is to assign values to each node such that all edge constraints are satisfied.\n\n3. **Prime Factorization**: To handle the multiplicative nature of the problem, we factorize each GCD and LCM into their prime factors. This allows us to express the constraints in terms of linear equations on the exponents of these primes.\n\n4. **Union-Find with Constraints**: We use a union-find data structure with constraints to manage the relationships between nodes. Each node's value can be expressed relative to its parent in the union-find structure.\n\n5. **Solving the System**: We solve the system of linear equations derived from the prime factorization constraints using BFS to ensure consistency across all constraints.\n\n### Solution Code\n```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef input():\n    return sys.stdin.read()\n\ndef main():\n    data = input().split()\n    idx = 0\n    n = int(data[idx])\n    m = int(data[idx+1])\n    idx +=2\n    edges = []\n    for _ in range(m):\n        u = int(data[idx])-1\n        v = int(data[idx+1])-1\n        g = int(data[idx+2])\n        l = int(data[idx+3])\n        idx +=4\n        edges.append( (u, v, g, l) )\n    \n    # Check for self loops or multiple edges\n    for u, v, g, l in edges:\n        if u == v:\n            print(\"NO\")\n            return\n        found = False\n        for other in edges:\n            if (other[0], other[1]) == (u, v) or (other[0], other[1]) == (v, u):\n                found = True\n                break\n        if found:\n            print(\"NO\")\n            return\n    \n    # Now, build the constraints\n    # For each edge, we have mu * mv = g * l\n    # Express mu and mv in terms of their prime factors.\n    # Let's represent variables in terms of their prime exponents.\n    \n    # First, factorize all g and l into primes up to 106\n    max_num = 106\n    primes = []\n    for i in range(2, max_num +1):\n        if i*i > max_num:\n            break\n        if max_num %i ==0:\n            primes.append(i)\n    for i in range(max_num, 1, -1):\n        if i not in primes:\n            primes.append(i)\n    primes = list(set(primes))\n    primes.sort()\n    \n    # Precompute factorization for all numbers up to 106\n    factor = {}\n    for p in primes:\n        if p*p > max_num:\n            continue\n        for multiple in range(p, max_num+1, p):\n            if multiple not in factor:\n                factor[multiple] = {}\n            if p not in factor[multiple]:\n                factor[multiple][p] = 0\n            factor[multiple][p] +=1\n    \n    # Now, for each edge, get the prime factors of g and l\n    # For each edge, we need to create constraints between u and v\n    # Let's model the problem using Union-Find with constraints\n    # Each node has a value, which can be represented as a product of primes\n    # The idea is similar to the union-find with weighted edges\n    \n    # Each node will have a value, stored as a dictionary mapping primes to exponents\n    # We can represent the value as a list of primes and their exponents\n    \n    # However, since the problem involves multiple primes, it's better to model the constraints as linear equations in the exponents of each prime.\n    \n    # So for each prime p, the exponent in u and v must satisfy certain equations based on g and l.\n    \n    # So for each edge, and for each prime p:\n    # Let's denote e_u(p) as the exponent of p in u's value, e_v(p) as the exponent of p in v's value.\n    # Then, for each prime p:\n    # The exponent in g is a_g, in l is a_l.\n    # From the equation: u * v = g * l\n    # So, for each p, e_u(p) + e_v(p) = a_g + a_l\n    # But also, since u = g * x and v = g * y, where x and y are coprime:\n    # So, for each p, e_u(p) = a_g + b_p and e_v(p) = a_g + c_p, where b_p and c_p are 0 or 1 depending on whether p divides x or y.\n    # Wait, no. Because x and y are coprime, so for each p, either x has p^0 or p^1, same for y. So, for each p, the sum of exponents in x and y is either 0,1, or 2.\n    # Wait, perhaps I'm complicating things. Let me think differently.\n    # Since u = g * x and v = g * y, then for each prime p:\n    # e_u(p) = a_g(p) + e_x(p)\n    # e_v(p) = a_g(p) + e_y(p)\n    # And since x and y are coprime, e_x(p) and e_y(p) cannot both be positive for the same p.\n    # So, for each edge, for each prime p:\n    # e_u(p) + e_v(p) = a_g(p) + a_l(p)\n    # Which comes from the fact that u*v = g*l → e_u + e_v = a_g + a_l for each p.\n    # But also, since u = g*x, e_u = a_g + e_x. Similarly for v.\n    # So, for each p, e_x(p) + e_y(p) = a_l(p) - a_g(p)\n    # Wait, because u*v = (g x)(g y) = g² x y. And g*l = g*(g x y) = g² x y. So yes, u*v = g*l.\n    # So, e_u(p) + e_v(p) = a_g(p) + a_l(p)\n    # But since u = g x and v = g y, e_u(p) = a_g(p) + e_x(p), e_v(p) = a_g(p) + e_y(p)\n    # So substituting, we get a_g(p) + e_x(p) + a_g(p) + e_y(p) = a_g(p) + a_l(p)\n    # Simplifying: 2a_g(p) + e_x(p) + e_y(p) = a_g(p) + a_l(p)\n    # Which simplifies to: a_g(p) + e_x(p) + e_y(p) = a_l(p)\n    # So, e_x(p) + e_y(p) = a_l(p) - a_g(p)\n    \n    # So for each prime p, for each edge, we have an equation e_x(p) + e_y(p) = delta_p, where delta_p = a_l(p) - a_g(p)\n    \n    # The goal is to assign 0 or 1 to e_x(p) and e_y(p) for each p, such that their sum equals delta_p for each edge.\n    \n    # Now, how do we model this? For each prime p, we can model the possible assignments as binary variables (0 or 1).\n    \n    # Let's model this as a bipartite graph where each edge represents a constraint between two variables.\n    \n    # For each prime p, create a variable for each node representing whether x has p^e (e=0 or 1).\n    \n    # But this seems complex. Alternatively, we can model each node's value as a product of primes raised to some exponents, but the exponents must satisfy the constraints from the edges.\n    \n    # Another approach is to model each node's value as a product, and use a union-find structure to track the relationships between the nodes and the constraints.\n    \n    # Here's an alternative plan:\n    # For each edge (u, v, g, l), we know that u and v must satisfy the constraints based on their values.\n    # We can represent each node's value as a product of primes, and the constraints as equations involving the exponents of these primes.\n    # We can then model this as a system of equations and solve using BFS-based techniques.\n    \n    # To handle this, we'll use a Union-Find data structure with additional information about the relationships between nodes, similar to the approach used in solving systems of equations with variables and constraints.\n    \n    # Each node will have a value, which is a list of primes and their exponents. However, since the primes are limited, we can model each node's value as a product of primes raised to specific exponents.\n    \n    # For each edge, we'll derive constraints on the exponents of the primes in the values of the connected nodes.\n    \n    # We'll process each edge and check if the constraints can be satisfied. If any edge leads to a contradiction, we output \"NO\".\n    \n    # If all edges can be satisfied, we assign the smallest possible values to the nodes, ensuring that the constraints are met.\n    \n    # Now, let's outline the steps:\n    # 1. Precompute the prime factors for all possible g and l values.\n    # 2. For each edge, compute the required constraints on the exponents of each prime in the values of the connected nodes.\n    # 3. Use a Union-Find structure to manage these constraints and detect contradictions.\n    # 4. If no contradictions are found, assign values to the nodes and output them.\n    \n    # The detailed steps involve:\n    # - Factorizing g and l for each edge.\n    # - Deriving constraints on the exponents of each prime.\n    # - Using BFS to propagate constraints and detect contradictions.\n    # - Assigning default values and adjusting based on constraints.\n    \n    # Given the complexity, we'll proceed with implementing the Union-Find structure and handle each edge's constraints step by step.\n\n    # Implementing the Union-Find with constraints:\n    # Each node has a parent and a value relative to the parent.\n    # When merging two sets, we check for contradictions in the existing constraints.\n    \n    # For each edge, we'll check if the current constraints are consistent with the existing ones.\n    \n    # If any inconsistency is found, output \"NO\".\n    \n    # Otherwise, after processing all edges, we'll assign the values to the nodes.\n    \n    # Assigning values:\n    # Start with all nodes having a value of 1.\n    # For each node, if it's a root in the Union-Find structure, assign it a value based on the accumulated constraints.\n    \n    # Finally, output the values or \"NO\" if any inconsistency was found.\n\n    # Now, let's implement this step by step.\n\n    # First, precompute the prime factors for each number up to 106.\n\n    # Then, for each edge, factorize g and l into their prime factors.\n\n    # For each prime p in the factors of g or l:\n        # Compute the required exponent difference for p in the edge.\n\n    # Then, for each edge, we need to ensure that the exponents of p in u and v satisfy the derived constraints.\n\n    # Using BFS to propagate constraints:\n\n    # Initialize each node's value to 1.\n\n    # For each edge, process the constraints and update the values accordingly.\n\n    # If any contradiction is found during this process, output \"NO\".\n\n    # If all edges are processed without contradictions, output the values.\n\n    # Now, let's proceed to code.\n\n    # Implementing the Union-Find with constraints:\n\n    # Each node has a parent and a value relative to the parent.\n\n    # When merging two nodes, we check if their current values are compatible with the new constraints.\n\n    # If they are not, we output \"NO\".\n\n    # Otherwise, we merge them and update the constraints.\n\n    # Now, let's write the code.\n\n    # Structure:\n    # We'll represent each node as a tuple (parent, rank, value).\n    # The 'value' is a dictionary mapping primes to their exponents relative to the parent.\n\n    # Initialize each node's parent as itself, rank as 1, and value as empty.\n\n    # For each edge, we'll find the roots of u and v, and check if their values are compatible with the current edge's constraints.\n\n    # If they are, we'll merge them, updating the values.\n\n    # Otherwise, output \"NO\".\n\n    # Once all edges are processed, assign the values to the nodes.\n\n    # Now, let's write the code.\n\n    # Precompute primes up to 106.\n\n    primes = []\n    max_num = 106\n    for i in range(2, max_num + 1):\n        if max_num % i == 0:\n            primes.append(i)\n    primes = list(set(primes))\n    primes.sort()\n\n    # Precompute the factorization for each number up to 106.\n\n    factor = {}\n    for num in range(1, max_num + 1):\n        factor[num] = {}\n        for p in primes:\n            if p > num:\n                break\n            cnt = 0\n            while num % p == 0:\n                cnt += 1\n                num //= p\n            if cnt > 0:\n                factor[num][p] = cnt\n\n    # Now, for each edge, process the constraints.\n\n    parent = list(range(n))\n    rank = [1] * n\n    value = [defaultdict(int) for _ in range(n)]\n\n    def find(u):\n        while parent[u] != u:\n            parent[u] = parent[parent[u]]\n            u = parent[u]\n        return u\n\n    def union(u, v, constraints):\n        u_root = find(u)\n        v_root = find(v)\n\n        if u_root == v_root:\n            # Check if the existing constraints match the new ones.\n            # For each prime p in constraints, check if the exponents in u and v match.\n            # Also, check if any new constraints introduce a contradiction.\n            for p, diff in constraints.items():\n                vu = value[u_root].get(p, 0)\n                vv = value[v_root].get(p, 0)\n                if (vu + value[u][p]) + (vv + value[v][p]) != diff:\n                    return False\n            return True\n\n        if rank[u_root] < rank[v_root]:\n            u_root, v_root = v_root, u_root\n\n        for p, diff in constraints.items():\n            vu = value[u_root].get(p, 0)\n            vv = value[v_root].get(p, 0)\n            if (vu + value[u][p]) + (vv + value[v][p]) != diff:\n                return False\n\n        if rank[u_root] == rank[v_root]:\n            rank[u_root] += 1\n\n        parent[v_root] = u_root\n        for p, diff in constraints.items():\n            value[u_root][p] = diff - value[v_root].get(p, 0) - value[u][p]\n\n        return True\n\n    # Now, process each edge.\n\n    possible = True\n    for u, v, g, l in edges:\n        if u == v:\n            print(\"NO\")\n            return\n        # Compute the required exponents for each prime.\n        # u * v = g * l\n        # So for each prime p, e_u(p) + e_v(p) = e_g(p) + e_l(p)\n        # We'll represent this as a dictionary of primes and their required exponent differences.\n\n        constraints = {}\n        # Factorize g and l into their primes.\n        # For each prime in g or l, compute the required exponents.\n        for p in primes:\n            eg = factor[g].get(p, 0)\n            el = factor[l].get(p, 0)\n            total = eg + el\n            constraints[p] = total\n\n        # Now, process the constraints between u and v.\n        # The exponents for u and v must satisfy e_u(p) + e_v(p) = constraints[p] for each p.\n\n        # So, for each prime p, the difference between the exponents in u and v is constraints[p] - 2*min(eg, el)?\n        # No, wait: e_u(p) + e_v(p) = eg + el.\n\n        # So, for each p, the sum of exponents in u and v is eg + el.\n\n        # Now, we need to model this as a constraint between u and v.\n\n        # We'll pass the constraints to the union function.\n\n        # Also, note that the initial value for each node is 1, which is the product of primes^0.\n\n        # So, when we first process an edge, the constraints may conflict with the existing values.\n\n        if not union(u, v, constraints):\n            possible = False\n            break\n\n    if not possible:\n        print(\"NO\")\n        return\n\n    # Now, assign the values.\n\n    # For each node, if it's a root, assign the value based on the accumulated constraints.\n\n    assignment = [1] * n\n\n    for i in range(n):\n        if parent[i] == i:\n            # The value is the product of primes^exponents.\n            # We need to calculate the value based on the exponents stored in the root.\n\n            # For each prime p in the value of i, multiply p^exponent.\n            val = 1\n            for p in primes:\n                if p in value[i]:\n                    val *= p ** value[i][p]\n            assignment[i] = val\n\n    # Now, verify the assignment.\n\n    # For each edge, check if the GCD and LCM are correct.\n\n    # Output the result.\n\n    print(\"YES\")\n    print(' '.join(map(str, assignment)))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\nThe solution involves modeling the problem using a union-find data structure with constraints derived from the prime factorization of the GCD and LCM values on each edge. By breaking down the problem into prime factors and managing constraints through a union-find structure, we can efficiently determine if a valid assignment of mushrooms exists and construct such an assignment if possible.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import defaultdict, deque\n\ndef input():\n    return sys.stdin.read()\n\ndef main():\n    data = input().split()\n    idx = 0\n    n = int(data[idx])\n    m = int(data[idx+1])\n    idx +=2\n    edges = []\n    for _ in range(m):\n        u = int(data[idx])-1\n        v = int(data[idx+1])-1\n        g = int(data[idx+2])\n        l = int(data[idx+3])\n        idx +=4\n        edges.append( (u, v, g, l) )\n    \n    # Check for self loops or multiple edges\n    for u, v, g, l in edges:\n        if u == v:\n            print(\"NO\")\n            return\n        found = False\n        for other in edges:\n            if (other[0], other[1]) == (u, v) or (other[0], other[1]) == (v, u):\n                found = True\n                break\n        if found:\n            print(\"NO\")\n            return\n    \n    # Now, build the constraints\n    # For each edge, we have mu * mv = g * l\n    # Express mu and mv in terms of their prime factors.\n    # Let's represent variables in terms of their prime exponents.\n    \n    # First, factorize all g and l into primes up to 106\n    max_num = 106\n    primes = []\n    for i in range(2, max_num +1):\n        if i*i > max_num:\n            break\n        if max_num %i ==0:\n            primes.append(i)\n    for i in range(max_num, 1, -1):\n        if i not in primes:\n            primes.append(i)\n    primes = list(set(primes))\n    primes.sort()\n    \n    # Precompute factorization for all numbers up to 106\n    factor = {}\n    for p in primes:\n        if p*p > max_num:\n            continue\n        for multiple in range(p, max_num+1, p):\n            if multiple not in factor:\n                factor[multiple] = {}\n            if p not in factor[multiple]:\n                factor[multiple][p] = 0\n            factor[multiple][p] +=1\n    \n    # Now, for each edge, get the prime factors of g and l\n    # For each edge, we need to create constraints between u and v\n    # Let's model the problem using Union-Find with constraints\n    # Each node has a value, which can be represented as a product of primes\n    # The idea is similar to the union-find with weighted edges\n    \n    # Each node will have a value, stored as a dictionary mapping primes to exponents\n    # We can represent the value as a list of primes and their exponents\n    \n    # However, since the problem involves multiple primes, it's better to model the constraints as linear equations in the exponents of each prime.\n    \n    # So for each prime p, the exponent in u and v must satisfy certain equations based on g and l.\n    \n    # So for each edge, and for each prime p:\n    # Let's denote e_u(p) as the exponent of p in u's value, e_v(p) as the exponent of p in v's value.\n    # Then, for each prime p:\n    # The exponent in g is a_g, in l is a_l.\n    # From the equation: u * v = g * l\n    # So, for each p, e_u(p) + e_v(p) = a_g + a_l\n    # But also, since u = g * x and v = g * y, where x and y are coprime:\n    # So, for each p, e_u(p) = a_g + b_p and e_v(p) = a_g + c_p, where b_p and c_p are 0 or 1 depending on whether p divides x or y.\n    # Wait, no. Because x and y are coprime, so for each p, either x has p^0 or p^1, same for y. So, for each p, the sum of exponents in x and y is either 0,1, or 2.\n    # Wait, perhaps I'm complicating things. Let me think differently.\n    # Since u = g * x and v = g * y, then for each prime p:\n    # e_u(p) = a_g(p) + e_x(p)\n    # e_v(p) = a_g(p) + e_y(p)\n    # And since x and y are coprime, e_x(p) and e_y(p) cannot both be positive for the same p.\n    # So, for each edge, for each prime p:\n    # e_u(p) + e_v(p) = a_g(p) + a_l(p)\n    # Which comes from the fact that u*v = g*l → e_u + e_v = a_g + a_l for each p.\n    # But also, since u = g*x, e_u = a_g + e_x. Similarly for v.\n    # So, for each p, e_x(p) + e_y(p) = a_l(p) - a_g(p)\n    # Wait, because u*v = (g x)(g y) = g² x y. And g*l = g*(g x y) = g² x y. So yes, u*v = g*l.\n    # So, e_u(p) + e_v(p) = a_g(p) + a_l(p)\n    # But since u = g x and v = g y, e_u(p) = a_g(p) + e_x(p), e_v(p) = a_g(p) + e_y(p)\n    # So substituting, we get a_g(p) + e_x(p) + a_g(p) + e_y(p) = a_g(p) + a_l(p)\n    # Simplifying: 2a_g(p) + e_x(p) + e_y(p) = a_g(p) + a_l(p)\n    # Which simplifies to: a_g(p) + e_x(p) + e_y(p) = a_l(p)\n    # So, e_x(p) + e_y(p) = a_l(p) - a_g(p)\n    \n    # So for each prime p, for each edge, we have an equation e_x(p) + e_y(p) = delta_p, where delta_p = a_l(p) - a_g(p)\n    \n    # The goal is to assign 0 or 1 to e_x(p) and e_y(p) for each p, such that their sum equals delta_p for each edge.\n    \n    # Now, how do we model this? For each prime p, we can model the possible assignments as binary variables (0 or 1).\n    \n    # Let's model this as a bipartite graph where each edge represents a constraint between two variables.\n    \n    # For each prime p, create a variable for each node representing whether x has p^e (e=0 or 1).\n    \n    # But this seems complex. Alternatively, we can model each node's value as a product of primes raised to some exponents, but the exponents must satisfy the constraints from the edges.\n    \n    # Another approach is to model each node's value as a product, and use a union-find structure to track the relationships between the nodes and the constraints.\n    \n    # Here's an alternative plan:\n    # For each edge (u, v, g, l), we know that u and v must satisfy the constraints based on their values.\n    # We can represent each node's value as a product of primes, and the constraints as equations involving the exponents of these primes.\n    # We can then model this as a system of equations and solve using BFS-based techniques.\n    \n    # To handle this, we'll use a Union-Find data structure with additional information about the relationships between nodes, similar to the approach used in solving systems of equations with variables and constraints.\n    \n    # Each node will have a value, which is a list of primes and their exponents. However, since the primes are limited, we can model each node's value as a product of primes raised to specific exponents.\n    \n    # For each edge, we'll derive constraints on the exponents of the primes in the values of the connected nodes.\n    \n    # We'll process each edge and check if the constraints can be satisfied. If any edge leads to a contradiction, we output \"NO\".\n    \n    # If all edges can be satisfied, we assign the smallest possible values to the nodes, ensuring that the constraints are met.\n    \n    # Now, let's outline the steps:\n    # 1. Precompute the prime factors for all possible g and l values.\n    # 2. For each edge, compute the required constraints on the exponents of each prime in the values of the connected nodes.\n    # 3. Use a Union-Find structure to manage these constraints and detect contradictions.\n    # 4. If no contradictions are found, assign values to the nodes and output them.\n    \n    # The detailed steps involve:\n    # - Factorizing g and l for each edge.\n    # - Deriving constraints on the exponents of each prime.\n    # - Using BFS to propagate constraints and detect contradictions.\n    # - Assigning default values and adjusting based on constraints.\n    \n    # Given the complexity, we'll proceed with implementing the Union-Find structure and handle each edge's constraints step by step.\n\n    # Implementing the Union-Find with constraints:\n    # Each node has a parent and a value relative to the parent.\n    # When merging two sets, we check for contradictions in the existing constraints.\n    \n    # For each edge, we'll check if the current constraints are consistent with the existing ones.\n    \n    # If any inconsistency is found, output \"NO\".\n    \n    # Otherwise, after processing all edges, we'll assign the values to the nodes.\n    \n    # Assigning values:\n    # Start with all nodes having a value of 1.\n    # For each node, if it's a root in the Union-Find structure, assign it a value based on the accumulated constraints.\n    \n    # Finally, output the values or \"NO\" if any inconsistency was found.\n\n    # Now, let's implement this step by step.\n\n    # First, precompute the prime factors for each number up to 106.\n\n    # Then, for each edge, factorize g and l into their prime factors.\n\n    # For each prime p in the factors of g or l:\n        # Compute the required exponent difference for p in the edge.\n\n    # Then, for each edge, we need to ensure that the exponents of p in u and v satisfy the derived constraints.\n\n    # Using BFS to propagate constraints:\n\n    # Initialize each node's value to 1.\n\n    # For each edge, process the constraints and update the values accordingly.\n\n    # If any contradiction is found during this process, output \"NO\".\n\n    # If all edges are processed without contradictions, output the values.\n\n    # Now, let's proceed to code.\n\n    # Implementing the Union-Find with constraints:\n\n    # Each node has a parent and a value relative to the parent.\n\n    # When merging two nodes, we check if their current values are compatible with the new constraints.\n\n    # If they are not, we output \"NO\".\n\n    # Otherwise, we merge them and update the constraints.\n\n    # Now, let's write the code.\n\n    # Structure:\n    # We'll represent each node as a tuple (parent, rank, value).\n    # The 'value' is a dictionary mapping primes to their exponents relative to the parent.\n\n    # Initialize each node's parent as itself, rank as 1, and value as empty.\n\n    # For each edge, we'll find the roots of u and v, and check if their values are compatible with the current edge's constraints.\n\n    # If they are, we'll merge them, updating the values.\n\n    # Otherwise, output \"NO\".\n\n    # Once all edges are processed, assign the values to the nodes.\n\n    # Now, let's write the code.\n\n    # Precompute primes up to 106.\n\n    primes = []\n    max_num = 106\n    for i in range(2, max_num + 1):\n        if max_num % i == 0:\n            primes.append(i)\n    primes = list(set(primes))\n    primes.sort()\n\n    # Precompute the factorization for each number up to 106.\n\n    factor = {}\n    for num in range(1, max_num + 1):\n        factor[num] = {}\n        for p in primes:\n            if p > num:\n                break\n            cnt = 0\n            while num % p == 0:\n                cnt += 1\n                num //= p\n            if cnt > 0:\n                factor[num][p] = cnt\n\n    # Now, for each edge, process the constraints.\n\n    parent = list(range(n))\n    rank = [1] * n\n    value = [defaultdict(int) for _ in range(n)]\n\n    def find(u):\n        while parent[u] != u:\n            parent[u] = parent[parent[u]]\n            u = parent[u]\n        return u\n\n    def union(u, v, constraints):\n        u_root = find(u)\n        v_root = find(v)\n\n        if u_root == v_root:\n            # Check if the existing constraints match the new ones.\n            # For each prime p in constraints, check if the exponents in u and v match.\n            # Also, check if any new constraints introduce a contradiction.\n            for p, diff in constraints.items():\n                vu = value[u_root].get(p, 0)\n                vv = value[v_root].get(p, 0)\n                if (vu + value[u][p]) + (vv + value[v][p]) != diff:\n                    return False\n            return True\n\n        if rank[u_root] < rank[v_root]:\n            u_root, v_root = v_root, u_root\n\n        for p, diff in constraints.items():\n            vu = value[u_root].get(p, 0)\n            vv = value[v_root].get(p, 0)\n            if (vu + value[u][p]) + (vv + value[v][p]) != diff:\n                return False\n\n        if rank[u_root] == rank[v_root]:\n            rank[u_root] += 1\n\n        parent[v_root] = u_root\n        for p, diff in constraints.items():\n            value[u_root][p] = diff - value[v_root].get(p, 0) - value[u][p]\n\n        return True\n\n    # Now, process each edge.\n\n    possible = True\n    for u, v, g, l in edges:\n        if u == v:\n            print(\"NO\")\n            return\n        # Compute the required exponents for each prime.\n        # u * v = g * l\n        # So for each prime p, e_u(p) + e_v(p) = e_g(p) + e_l(p)\n        # We'll represent this as a dictionary of primes and their required exponent differences.\n\n        constraints = {}\n        # Factorize g and l into their primes.\n        # For each prime in g or l, compute the required exponents.\n        for p in primes:\n            eg = factor[g].get(p, 0)\n            el = factor[l].get(p, 0)\n            total = eg + el\n            constraints[p] = total\n\n        # Now, process the constraints between u and v.\n        # The exponents for u and v must satisfy e_u(p) + e_v(p) = constraints[p] for each p.\n\n        # So, for each prime p, the difference between the exponents in u and v is constraints[p] - 2*min(eg, el)?\n        # No, wait: e_u(p) + e_v(p) = eg + el.\n\n        # So, for each p, the sum of exponents in u and v is eg + el.\n\n        # Now, we need to model this as a constraint between u and v.\n\n        # We'll pass the constraints to the union function.\n\n        # Also, note that the initial value for each node is 1, which is the product of primes^0.\n\n        # So, when we first process an edge, the constraints may conflict with the existing values.\n\n        if not union(u, v, constraints):\n            possible = False\n            break\n\n    if not possible:\n        print(\"NO\")\n        return\n\n    # Now, assign the values.\n\n    # For each node, if it's a root, assign the value based on the accumulated constraints.\n\n    assignment = [1] * n\n\n    for i in range(n):\n        if parent[i] == i:\n            # The value is the product of primes^exponents.\n            # We need to calculate the value based on the exponents stored in the root.\n\n            # For each prime p in the value of i, multiply p^exponent.\n            val = 1\n            for p in primes:\n                if p in value[i]:\n                    val *= p ** value[i][p]\n            assignment[i] = val\n\n    # Now, verify the assignment.\n\n    # For each edge, check if the GCD and LCM are correct.\n\n    # Output the result.\n\n    print(\"YES\")\n    print(' '.join(map(str, assignment)))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 545,
        "completion_token_count": 4062,
        "thoughts_token_count": 1025
    }
}