{
    "start": 1758103525.6004248,
    "end": 1758103652.4667804,
    "start-formatted": "2025-09-17 19:05 KST",
    "end-formatted": "2025-09-17 19:07 KST",
    "gpu": 2,
    "pid": 6,
    "use_openrouter": false,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let me read it carefully.\n\nThe problem is about Leha who wants to split his vacation into two parts using two vouchers. The goal is to find the minimal total cost of such two vouchers that don't overlap and their durations add up exactly to x.\n\nHmm, let's break down the problem.\n\nSo, each voucher has a start day li, end day ri, and cost. The duration is ri - li + 1. We need to choose two different vouchers i and j such that:\n\n1. Their durations sum to exactly x.\n2. They don't intersect. That means either the end of one is before the start of the other, or vice versa.\n3. The total cost is as small as possible.\n\nIf no such pair exists, we output -1.\n\nFirst, I need to think about how to approach this efficiently because n can be up to 2005, which is manageable but needs an O(n^2) approach maybe, but perhaps with some optimizations.\n\nWait, wait. Wait, n is up to 2e5? No, wait the input says 2 ≤ n, x ≤ 2·1e5. So n can be up to 200,000. Oh right, that's a larger number. So any O(n^2) approach would be too slow for 2e5. So I need a way to process this more efficiently.\n\nSo, what's the plan?\n\nLet me think about the steps:\n\nFor each voucher, I can compute its duration. Then, for each voucher i, I can look for vouchers j such that duration[i] + duration[j] = x.\n\nBut since I need to select two vouchers, I can precompute for each duration d, what's the minimal cost of a voucher with duration x - d. But that might not directly help with the non-overlapping condition.\n\nAlternatively, perhaps group the vouchers by their duration. For each voucher i, I can look for all vouchers j where duration[j] = x - duration[i], and then check if they are compatible (non-overlapping) and track the minimal cost.\n\nBut even within that, checking all possible j for each i could be O(n^2) in the worst case, which is 4e10 operations—way too slow.\n\nSo that approach isn't feasible.\n\nI need a smarter way.\n\nLet me think: for each voucher i, perhaps I can find all possible vouchers j that have duration x - duration[i], and are either completely before i or completely after i.\n\nWait, but how?\n\nAnother thought: the non-overlapping condition can be expressed as either j ends before i starts, or i ends before j starts.\n\nSo for each voucher i, I can consider two cases:\n\nCase 1: j comes before i. So j's end is <= i's start minus 1. And the duration of j is x - duration[i].\n\nCase 2: i comes before j. So i's end is <= j's start minus 1. And the duration of i is x - duration[j].\n\nWait, but for each i, I'm looking for j's that fit into either case.\n\nBut again, how to do this efficiently.\n\nPerhaps pre-processing the vouchers in a sorted order can help.\n\nLet me think: if I sort all vouchers by their end times, then for a given voucher i, I can quickly find all j's that end before i starts.\n\nSimilarly, if I sort them by their start times, I can find j's that start after i ends.\n\nSo, here's a plan:\n\n1. Precompute for each voucher i, its duration and cost.\n\n2. For each possible duration d, keep a list of vouchers with duration d, along with their start and end times and costs. Then, for each voucher i, with duration di, we need to find vouchers j with duration x-di, and j must be non-overlapping with i.\n\n3. So for each voucher i, we can:\n\n   a. Look for vouchers j with duration x - di. Among these, find those that end before i's start.\n\n   b. Find among those j's the one with the minimal cost.\n\n   c. Similarly, look for vouchers j with duration x - di that start after i's end. Find the minimal cost.\n\n   Then, the minimal between a and b is the candidate for this i, and we track the global minimum.\n\nBut how to efficiently perform steps a and b for each i.\n\nTo do step a: j's end <= i.start -1.\n\nSo for j's with duration x-di, their end should be <= i's start -1.\n\nSo if I have the j's sorted by their end times, I can perform a binary search to find all j's with end <= i.start-1. Among those, find the minimal cost.\n\nSimilarly, for step b: j's start >= i.end +1.\n\nSo j's sorted by their start times, binary search for j's",
    "response": "To solve this problem, we need to find two non-overlapping vouchers whose combined duration equals exactly `x` days and whose total cost is minimized. If no such pair exists, we should return `-1`.\n\n### Approach\n1. **Precompute Durations and Costs**: For each voucher, compute its duration and store its start, end, and cost.\n2. **Group Vouchers by Duration**: Group vouchers based on their durations to efficiently look up potential pairs.\n3. **Sort Vouchers**: Sort vouchers by their end times and start times to facilitate efficient searching.\n4. **Binary Search for Non-Overlapping Vouchers**: For each voucher, use binary search to find the best possible non-overlapping vouchers that complement its duration to sum up to `x`.\n\n### Solution Code\n```python\nimport bisect\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    x = int(input[idx + 1])\n    idx += 2\n    vouchers = []\n    for _ in range(n):\n        li = int(input[idx])\n        ri = int(input[idx + 1])\n        cost = int(input[idx + 2])\n        idx += 3\n        duration = ri - li + 1\n        vouchers.append((li, ri, cost, duration))\n    \n    # Preprocess: group by duration and sort\n    from collections import defaultdict\n    duration_map = defaultdict(list)\n    for v in vouchers:\n        d = v[3]\n        duration_map[d].append(v)\n    \n    # For each duration, sort vouchers by end time and start time\n    sorted_by_end = {}\n    sorted_by_start = {}\n    for d in duration_map:\n        lst_end = sorted(duration_map[d], key=lambda x: x[1])\n        lst_start = sorted(lst_end, key=lambda x: x[0])\n        sorted_by_end[d] = lst_end\n        sorted_by_start[d] = lst_start\n    \n    min_total = float('inf')\n    \n    for i in range(n):\n        li, ri, cost_i, d_i = vouchers[i]\n        required_d = x - d_i\n        if required_d < 0:\n            continue\n        if required_d not in duration_map:\n            continue\n        \n        # Case 1: j ends before i starts (j comes before i)\n        j_list = duration_map[required_d]\n        # Find j where j's end <= li - 1\n        left = 0\n        right = len(j_list) - 1\n        best_cost = float('inf')\n        while left <= right:\n            mid = (left + right) // 2\n            j = j_list[mid]\n            if j[1] <= li - 1:\n                if j[2] < best_cost:\n                    best_cost = j[2]\n                left = mid + 1\n            else:\n                right = mid - 1\n        if best_cost != float('inf'):\n            min_total = min(min_total, best_cost)\n        \n        # Case 2: i ends before j starts (i comes before j)\n        # We need j's start >= ri + 1\n        j_list = duration_map[required_d]\n        left = 0\n        right = len(j_list) - 1\n        best_cost = float('inf')\n        while left <= right:\n            mid = (left + right) // 2\n            j = j_list[mid]\n            if j[0] >= ri + 1:\n                if j[2] < best_cost:\n                    best_cost = j[2]\n                right = mid - 1\n            else:\n                left = mid + 1\n        if best_cost != float('inf'):\n            min_total = min(min_total, best_cost)\n    \n    if min_total != float('inf'):\n        print(min_total)\n    else:\n        print(-1)\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Reading Input and Preprocessing**: The input is read and parsed into a list of vouchers. Each voucher's duration is computed and stored along with its start, end, and cost.\n2. **Grouping by Duration**: Vouchers are grouped by their duration to facilitate quick lookup of complementary vouchers.\n3. **Sorting**: Vouchers within each duration group are sorted by their end times and start times to enable efficient binary search operations.\n4. **Binary Search for Non-Overlapping Vouchers**: For each voucher, binary searches are performed to find the minimal cost non-overlapping voucher that complements its duration to exactly `x`. The minimal total cost is tracked and updated throughout the process.\n\nThis approach ensures that we efficiently find the optimal pair of vouchers without overlapping and with the exact required duration, minimizing the total cost.",
    "ground_truth": "N/A",
    "extracted_answer": "import bisect\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    x = int(input[idx + 1])\n    idx += 2\n    vouchers = []\n    for _ in range(n):\n        li = int(input[idx])\n        ri = int(input[idx + 1])\n        cost = int(input[idx + 2])\n        idx += 3\n        duration = ri - li + 1\n        vouchers.append((li, ri, cost, duration))\n    \n    # Preprocess: group by duration and sort\n    from collections import defaultdict\n    duration_map = defaultdict(list)\n    for v in vouchers:\n        d = v[3]\n        duration_map[d].append(v)\n    \n    # For each duration, sort vouchers by end time and start time\n    sorted_by_end = {}\n    sorted_by_start = {}\n    for d in duration_map:\n        lst_end = sorted(duration_map[d], key=lambda x: x[1])\n        lst_start = sorted(lst_end, key=lambda x: x[0])\n        sorted_by_end[d] = lst_end\n        sorted_by_start[d] = lst_start\n    \n    min_total = float('inf')\n    \n    for i in range(n):\n        li, ri, cost_i, d_i = vouchers[i]\n        required_d = x - d_i\n        if required_d < 0:\n            continue\n        if required_d not in duration_map:\n            continue\n        \n        # Case 1: j ends before i starts (j comes before i)\n        j_list = duration_map[required_d]\n        # Find j where j's end <= li - 1\n        left = 0\n        right = len(j_list) - 1\n        best_cost = float('inf')\n        while left <= right:\n            mid = (left + right) // 2\n            j = j_list[mid]\n            if j[1] <= li - 1:\n                if j[2] < best_cost:\n                    best_cost = j[2]\n                left = mid + 1\n            else:\n                right = mid - 1\n        if best_cost != float('inf'):\n            min_total = min(min_total, best_cost)\n        \n        # Case 2: i ends before j starts (i comes before j)\n        # We need j's start >= ri + 1\n        j_list = duration_map[required_d]\n        left = 0\n        right = len(j_list) - 1\n        best_cost = float('inf')\n        while left <= right:\n            mid = (left + right) // 2\n            j = j_list[mid]\n            if j[0] >= ri + 1:\n                if j[2] < best_cost:\n                    best_cost = j[2]\n                right = mid - 1\n            else:\n                left = mid + 1\n        if best_cost != float('inf'):\n            min_total = min(min_total, best_cost)\n    \n    if min_total != float('inf'):\n        print(min_total)\n    else:\n        print(-1)\n\nif __name__ == '__main__':\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 678,
        "completion_token_count": 999,
        "thoughts_token_count": 1025
    }
}