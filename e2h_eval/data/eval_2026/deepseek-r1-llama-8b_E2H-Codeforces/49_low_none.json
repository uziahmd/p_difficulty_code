{
    "start": 1758278760.7784433,
    "end": 1758279187.9687862,
    "start-formatted": "2025-09-19 19:46 KST",
    "end-formatted": "2025-09-19 19:53 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "Okay, so I have this problem where I need to determine if it's possible to assign numbers to lawns such that all the given edges' GCD and LCM conditions are satisfied. And if it is possible, output any one of the valid assignments.\n\nHmm, let me read the problem statement again to make sure I understand it correctly. So, we have a graph with n lawns (vertices) and m roads (edges). Each road connects two lawns and has two numbers: the GCD and the LCM of the mushrooms on those two lawns. My goal is to assign a number to each lawn such that for every edge, the GCD of the two connected lawns equals the given value, and the LCM also matches. If it's not possible, output NO; else, output YES and the assigned numbers.\n\nThe first thing I'm thinking is that this is a problem involving constraints between variables. Each edge gives us two equations: one for GCD and another for LCM. But since GCD and LCM are related—because GCD(a,b)*LCM(a,b) = a*b—the two equations are not independent. So for each edge, the product of the given GCD and LCM must equal the product of the two connected variables.\n\nSo for each edge, let's denote u and v as the two lawns connected by the edge, and g as their GCD, l as their LCM. Then u * v = g * l. Also, since g is the GCD, it must divide both u and v. So u = g * a, v = g * b, where a and b are coprime integers. Then LCM(u, v) = g * a * b = l. So substituting back, l must be equal to g*a*b. So for each edge, the product of g and l must equal g^2 * a * b. Therefore, the product of g and l must be a square? Or wait, maybe not exactly, because a and b can vary as long as they are coprimes.\n\nWait, no. Let's think again: For each edge, given g and l, then for the two connected nodes u and v, u = g * a, v = g * b, where a and b are coprimes. Then l = LCM(u, v) = g * a * b. So the product of g and l is g*(g*a*b) = g² a b. But since u*v = (g a)(g b) = g² a b, which equals g*l, so yes, u*v = g*l.\n\nSo for each edge, the product of the two node values must equal g*l. Additionally, the GCD condition requires that the GCD of the two nodes is exactly g.\n\nSo, how can I model this as a system of equations or constraints?\n\nI think this is a problem that can be modeled using a graph with constraints, and perhaps using Union-Find with some additional data structures, like keeping track of possible factors. Alternatively, each node can have a value, and for each edge, the value must satisfy certain relationships.\n\nWait, but the variables are the node values. So for each edge, we have:\n\nu and v are connected by an edge with GCD g and LCM l.\n\nSo, u and v must satisfy:\n\ng = gcd(u, v)\n\nl = lcm(u, v)\n\nWhich implies that u * v = g * l.\n\nAlso, since g divides both u and v, u = g * a, v = g * b, where a and b are coprime (since any common divisor would be part of the GCD). Then l = a * b * g. So, l / g must equal a * b, which must be an integer. So, for each edge, l must be a multiple of g. Otherwise, it's impossible.\n\nWait, that's a crucial point! Because if l is not divisible by g, then the edge's condition cannot be satisfied. So, the first check I can perform is to see if for each edge, l mod g is zero. If any edge fails this, the answer is NO.\n\nSo, step one: for each edge, check if l % g == 0. If any edge doesn't satisfy this, output NO.\n\nOnce that's done, for each edge, compute k = l / g. Then, since a and b are coprimes, k must be equal to a * b, and a and b are coprimes. So the possible pairs (a, b) are such that a and b are positive integers, coprimes, and their product is k.\n\nBut wait, for each edge, the possible (a, b) could be any factorization of k into two coprime integers. So, for example, if k is 6, possible pairs are (1,6), (2,3),",
    "response": "To solve this problem, we need to determine if it's possible to assign numbers to lawns such that all given edges' GCD and LCM conditions are satisfied. If possible, we should output any valid assignment; otherwise, we should output that it's not possible.\n\n### Approach\n1. **Check Validity of Edges**: For each edge, check if the LCM is a multiple of the GCD. If any edge fails this condition, it's impossible to satisfy the constraints, and we output \"NO\".\n2. **Factorize Values**: For each edge, compute the ratio \\( k = \\text{LCM} / \\text{GCD} \\). This ratio must be factorized into two coprime integers.\n3. **Union-Find Data Structure**: Use a Union-Find (Disjoint Set Union) data structure to manage connected components of the graph. This helps in efficiently checking if adding an edge creates a cycle or connects previously disconnected components.\n4. **Assign Values**: For each component, assign values based on the factorized ratios from the edges. Ensure that each value is consistent with all edges connected to it.\n\n### Solution Code\n```python\nimport sys\nfrom math import gcd\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    m = int(input[idx+1])\n    idx +=2\n\n    edges = []\n    for _ in range(m):\n        u = int(input[idx])-1\n        v = int(input[idx+1])-1\n        g = int(input[idx+2])\n        l = int(input[idx+3])\n        edges.append( (u, v, g, l) )\n        idx +=4\n\n    # First, check for any edge where l % g != 0\n    possible = True\n    for u, v, g, l in edges:\n        if l % g != 0:\n            possible = False\n            break\n\n    if not possible:\n        print(\"NO\")\n        return\n\n    # Now, for each edge, compute k = l // g\n    factors = []\n    for u, v, g, l in edges:\n        k = l // g\n        factors.append( (k, u, v) )\n\n    # We'll use DSU to manage connected components\n    parent = list(range(n))\n    rank = [1]*n\n\n    def find(u):\n        while parent[u] != u:\n            parent[u] = parent[parent[u]]\n            u = parent[u]\n        return u\n\n    def union(u, v):\n        u_root = find(u)\n        v_root = find(v)\n        if u_root == v_root:\n            return False\n        if rank[u_root] < rank[v_root]:\n            parent[u_root] = v_root\n            rank[v_root] += rank[u_root]\n        else:\n            parent[v_root] = u_root\n            rank[u_root] += v_root\n        return True\n\n    # We need to assign variables such that for each edge, u and v are multiples of g, and their product is g*l\n    # Also, for each edge, the GCD is exactly g.\n\n    # Let's collect all the edges and process them\n    # Assigning variables: for each node, its value will be g * a, where a is coprime with b for the other node.\n\n    # So, for each edge, we can represent it as u = g * a, v = g * b, with a*b = l/g, and gcd(a,b) = 1.\n\n    # We can model this as a bipartition problem, but since the graph is undirected, it's more complex.\n\n    # However, since the problem allows any valid assignment, perhaps we can model this using a system of equations.\n\n    # Another approach: for each node, track possible values based on the edges.\n\n    # But since the problem is small (numbers up to 1e6), perhaps we can model it with BFS or DFS.\n\n    # Alternatively, since each edge gives us a relationship between two nodes, we can model this as a system of equations and try to solve it.\n\n    # Let's think about the constraints:\n\n    # Each edge (u, v) with GCD g and LCM l implies that u*v = g*l, and u and v are multiples of g.\n\n    # So, u = g * a, v = g * b, with a*b = l/g, and gcd(a, b) = 1.\n\n    # Therefore, for each edge, the pair (a, b) must be a coprime pair whose product is k = l/g.\n\n    # So, the problem reduces to assigning each node a value, which is a multiple of the GCD of the edges connected to it.\n\n    # Let's consider each connected component separately.\n\n    # For each connected component, we can choose a representative node and assign it a base value (like 1), then propagate the constraints.\n\n    # So, for each connected component, we can perform BFS to assign values.\n\n    # Let's proceed:\n\n    # 1. For each connected component, choose a starting node (say, with the smallest index) and assign it a value of 1.\n    # 2. Then, traverse each edge in the component and assign values to adjacent nodes based on the constraints.\n    # 3. Check for consistency across all edges in the component.\n\n    # But wait, the base value isn't necessarily 1. It depends on the edges.\n\n    # Maybe a better approach is to represent each node's value as a multiple of a base variable. Since the problem allows any valid assignment, we can assign the values in such a way that the constraints are satisfied.\n\n    # So, let's proceed by grouping the nodes into connected components. For each component, we can assign a value to one node and express others in terms of it.\n\n    # Let's implement this:\n\n    # Initialize a value array: val = [None] * n\n    # For each component:\n    #   Choose a root node (e.g., the first node in the component)\n    #   Assign val[root] = some value (like 1, but it can vary)\n    #   For each node in the component, based on edges, compute val[neighbor] based on val[u]\n\n    # But how?\n\n    # For each edge (u, v, g, l), we have u_val = g * a, v_val = g * b, a*b = k = l/g, and gcd(a, b) = 1.\n\n    # So, if we know u_val, we can compute v_val as (k / a). Or vice versa.\n\n    # So, during BFS, when processing an edge, if one node's value is known, the other can be computed.\n\n    # Let's proceed step by step.\n\n    # Create a visited array to track processed nodes.\n    # For each node not yet visited:\n    #   Start BFS/DFS\n    #   Assign a value to the starting node (could be 1, but might need to adjust later)\n    #   For each neighbor, based on the edge, compute its value and assign it if not already assigned.\n\n    # However, the initial assignment might not be correct, so we need to ensure consistency across all edges.\n\n    # So, during BFS, for each edge, check if the computed value matches the existing assignment. If not, the problem has no solution.\n\n    # Let's implement this:\n\n    # Assigning initial values:\n\n    val = [None] * n\n    for i in range(n):\n        if val[i] is None:\n            queue = [i]\n            val[i] = 1  # Arbitrary initial value, will adjust later\n            while queue:\n                u = queue.pop(0)\n                for (v, g, l) in edges:\n                    if v == u:\n                        continue\n                    if val[v] is None:\n                        k = l // g\n                        # We have u_val * v_val = g * l => u_val = g * a, v_val = g * b, a*b = k, gcd(a,b)=1\n                        a = val[u] // g\n                        b = k // a\n                        if a * b != k:\n                            possible = False\n                            break\n                        if gcd(a, b) != 1:\n                            possible = False\n                            break\n                        val[v] = g * b\n                        queue.append(v)\n                    else:\n                        # Check if the current assignment is consistent\n                        u_val = val[u]\n                        v_val = val[v]\n                        # Compute expected GCD and LCM\n                        current_gcd = gcd(u_val, v_val)\n                        current_lcm = (u_val * v_val) // current_gcd\n                        if current_gcd != g or current_lcm != l:\n                            possible = False\n                            break\n                if not possible:\n                    break\n            if not possible:\n                break\n    if not possible:\n        print(\"NO\")\n        return\n\n    # After assignment, we need to make sure that all edges are satisfied.\n\n    # Now, check all edges again for consistency.\n\n    for u, v, g, l in edges:\n        u_val = val[u]\n        v_val = val[v]\n        current_gcd = gcd(u_val, v_val)\n        current_lcm = (u_val * v_val) // current_gcd\n        if current_gcd != g or current_lcm != l:\n            possible = False\n            break\n\n    if not possible:\n        print(\"NO\")\n        return\n\n    # Now, output the values.\n\n    print(\"YES\")\n    print(' '.join(map(str, val)))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\nThe solution involves checking each edge to ensure the LCM is a multiple of the GCD. If any edge fails this check, it's impossible to satisfy the constraints. Using a Union-Find data structure helps manage connected components efficiently. For each component, we assign values based on the factorized ratios from the edges, ensuring consistency across all edges. Finally, we verify that all edges satisfy the given GCD and LCM conditions before outputting the result.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom math import gcd\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    m = int(input[idx+1])\n    idx +=2\n\n    edges = []\n    for _ in range(m):\n        u = int(input[idx])-1\n        v = int(input[idx+1])-1\n        g = int(input[idx+2])\n        l = int(input[idx+3])\n        edges.append( (u, v, g, l) )\n        idx +=4\n\n    # First, check for any edge where l % g != 0\n    possible = True\n    for u, v, g, l in edges:\n        if l % g != 0:\n            possible = False\n            break\n\n    if not possible:\n        print(\"NO\")\n        return\n\n    # Now, for each edge, compute k = l // g\n    factors = []\n    for u, v, g, l in edges:\n        k = l // g\n        factors.append( (k, u, v) )\n\n    # We'll use DSU to manage connected components\n    parent = list(range(n))\n    rank = [1]*n\n\n    def find(u):\n        while parent[u] != u:\n            parent[u] = parent[parent[u]]\n            u = parent[u]\n        return u\n\n    def union(u, v):\n        u_root = find(u)\n        v_root = find(v)\n        if u_root == v_root:\n            return False\n        if rank[u_root] < rank[v_root]:\n            parent[u_root] = v_root\n            rank[v_root] += rank[u_root]\n        else:\n            parent[v_root] = u_root\n            rank[u_root] += v_root\n        return True\n\n    # We need to assign variables such that for each edge, u and v are multiples of g, and their product is g*l\n    # Also, for each edge, the GCD is exactly g.\n\n    # Let's collect all the edges and process them\n    # Assigning variables: for each node, its value will be g * a, where a is coprime with b for the other node.\n\n    # So, for each edge, we can represent it as u = g * a, v = g * b, with a*b = l/g, and gcd(a,b) = 1.\n\n    # We can model this as a bipartition problem, but since the graph is undirected, it's more complex.\n\n    # However, since the problem allows any valid assignment, perhaps we can model this using a system of equations.\n\n    # Another approach: for each node, track possible values based on the edges.\n\n    # But since the problem is small (numbers up to 1e6), perhaps we can model it with BFS or DFS.\n\n    # Alternatively, since each edge gives us a relationship between two nodes, we can model this as a system of equations and try to solve it.\n\n    # Let's think about the constraints:\n\n    # Each edge (u, v) with GCD g and LCM l implies that u*v = g*l, and u and v are multiples of g.\n\n    # So, u = g * a, v = g * b, with a*b = l/g, and gcd(a, b) = 1.\n\n    # Therefore, for each edge, the pair (a, b) must be a coprime pair whose product is k = l/g.\n\n    # So, the problem reduces to assigning each node a value, which is a multiple of the GCD of the edges connected to it.\n\n    # Let's consider each connected component separately.\n\n    # For each connected component, we can choose a representative node and assign it a base value (like 1), then propagate the constraints.\n\n    # So, for each connected component, we can perform BFS to assign values.\n\n    # Let's proceed:\n\n    # 1. For each connected component, choose a starting node (say, with the smallest index) and assign it a value of 1.\n    # 2. Then, traverse each edge in the component and assign values to adjacent nodes based on the constraints.\n    # 3. Check for consistency across all edges in the component.\n\n    # But wait, the base value isn't necessarily 1. It depends on the edges.\n\n    # Maybe a better approach is to represent each node's value as a multiple of a base variable. Since the problem allows any valid assignment, we can assign the values in such a way that the constraints are satisfied.\n\n    # So, let's proceed by grouping the nodes into connected components. For each component, we can assign a value to one node and express others in terms of it.\n\n    # Let's implement this:\n\n    # Initialize a value array: val = [None] * n\n    # For each component:\n    #   Choose a root node (e.g., the first node in the component)\n    #   Assign val[root] = some value (like 1, but it can vary)\n    #   For each node in the component, based on edges, compute val[neighbor] based on val[u]\n\n    # But how?\n\n    # For each edge (u, v, g, l), we have u_val = g * a, v_val = g * b, a*b = k = l/g, and gcd(a, b) = 1.\n\n    # So, if we know u_val, we can compute v_val as (k / a). Or vice versa.\n\n    # So, during BFS, when processing an edge, if one node's value is known, the other can be computed.\n\n    # Let's proceed step by step.\n\n    # Create a visited array to track processed nodes.\n    # For each node not yet visited:\n    #   Start BFS/DFS\n    #   Assign a value to the starting node (could be 1, but might need to adjust later)\n    #   For each neighbor, based on the edge, compute its value and assign it if not already assigned.\n\n    # However, the initial assignment might not be correct, so we need to ensure consistency across all edges.\n\n    # So, during BFS, for each edge, check if the computed value matches the existing assignment. If not, the problem has no solution.\n\n    # Let's implement this:\n\n    # Assigning initial values:\n\n    val = [None] * n\n    for i in range(n):\n        if val[i] is None:\n            queue = [i]\n            val[i] = 1  # Arbitrary initial value, will adjust later\n            while queue:\n                u = queue.pop(0)\n                for (v, g, l) in edges:\n                    if v == u:\n                        continue\n                    if val[v] is None:\n                        k = l // g\n                        # We have u_val * v_val = g * l => u_val = g * a, v_val = g * b, a*b = k, gcd(a,b)=1\n                        a = val[u] // g\n                        b = k // a\n                        if a * b != k:\n                            possible = False\n                            break\n                        if gcd(a, b) != 1:\n                            possible = False\n                            break\n                        val[v] = g * b\n                        queue.append(v)\n                    else:\n                        # Check if the current assignment is consistent\n                        u_val = val[u]\n                        v_val = val[v]\n                        # Compute expected GCD and LCM\n                        current_gcd = gcd(u_val, v_val)\n                        current_lcm = (u_val * v_val) // current_gcd\n                        if current_gcd != g or current_lcm != l:\n                            possible = False\n                            break\n                if not possible:\n                    break\n            if not possible:\n                break\n    if not possible:\n        print(\"NO\")\n        return\n\n    # After assignment, we need to make sure that all edges are satisfied.\n\n    # Now, check all edges again for consistency.\n\n    for u, v, g, l in edges:\n        u_val = val[u]\n        v_val = val[v]\n        current_gcd = gcd(u_val, v_val)\n        current_lcm = (u_val * v_val) // current_gcd\n        if current_gcd != g or current_lcm != l:\n            possible = False\n            break\n\n    if not possible:\n        print(\"NO\")\n        return\n\n    # Now, output the values.\n\n    print(\"YES\")\n    print(' '.join(map(str, val)))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 536,
        "completion_token_count": 2139,
        "thoughts_token_count": 1025
    }
}