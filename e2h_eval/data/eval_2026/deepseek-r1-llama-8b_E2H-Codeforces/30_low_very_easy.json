{
    "start": 1758279498.4392843,
    "end": 1758279627.7577465,
    "start-formatted": "2025-09-19 19:58 KST",
    "end-formatted": "2025-09-19 20:00 KST",
    "gpu": 2,
    "pid": 30,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# TV Game\n\nThere is a new TV game on BerTV. In this game two players get a number A consisting of 2n digits. Before each turn players determine who will make the next move. Each player should make exactly n moves. On it's turn i-th player takes the leftmost digit of A and appends it to his or her number Si. After that this leftmost digit is erased from A. Initially the numbers of both players (S1 and S2) are «empty». Leading zeroes in numbers A, S1, S2 are allowed. In the end of the game the first player gets S1 dollars, and the second gets S2 dollars.One day Homer and Marge came to play the game. They managed to know the number A beforehand. They want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize. Help them.\n\n## Input\nThe first line contains integer n (1 ≤ n ≤ 18). The second line contains integer A consisting of exactly 2n digits. This number can have leading zeroes.\n\n## Output\nOutput the line of 2n characters «H» and «M» — the sequence of moves of Homer and Marge, which gives them maximum possible total prize. Each player must make exactly n moves. If there are several solutions, output any of them.\n\n## Example\n### Input\n['2\\n1234', '2\\n9911']\n\n### Output\n['HHMM', 'HMHM']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "Okay, so I have this problem where Homer and Marge are playing a TV game. The goal is to maximize their total prize by choosing the sequence of moves optimally. Let me try to understand the problem.\n\nThe game starts with a number A that has 2n digits. Each player takes turns taking the leftmost digit of A, appending it to their own number (S1 for Homer, S2 for Marge). This digit is then removed from A. They each make exactly n moves. So the total number of moves is 2n, which makes sense since A has 2n digits.\n\nThe output should be a string of H's and M's indicating who took which digit in order. The goal is to maximize the sum of S1 and S2. But wait, what's the maximum? Oh right, because each digit contributes to either S1 or S2, we want to assign higher digits to the players whose turn comes when those digits are taken.\n\nSo the key idea is to decide for each digit whether it should be taken by Homer or Marge such that the sum of all digits assigned to each is maximized. But how do we model this?\n\nLet me think about dynamic programming. Because at each step, the choice affects future options, we need a way to track the state after each digit is taken.\n\nHmm. Let's model the state as (i, j), where i is the number of digits taken by Homer so far, and j is the number taken by Marge. Since each must take exactly n digits, the state can range from (0,0) to (n,n), but also considering the order in which they take the digits.\n\nWait, no. Wait, the order is important because the digits are taken from the left each time. So the digits are processed in the order they appear in A. So the first digit is taken first, then the second, etc., but the assignment depends on whether it's Homer's turn or Marge's.\n\nWait, but the turns alternate, starting with whoever goes first. But in the problem statement, it says that before each turn, they determine who will make the next move. Hmm, that complicates things because it adds another variable: whose turn it is. So the initial state isn't fixed; it's possible to choose whether Homer starts first or not, but wait, no— the problem says that each player makes exactly n moves. So perhaps the starting player is fixed. Or maybe not— wait, the problem says that they determine who makes the next move each time. So the sequence of H's and M's is something they can choose, as long as each appears exactly n times. So the challenge is to select the sequence of H and M (with n each) such that the sum of S1 and S2 is maximized.\n\nWait, but S1 is the concatenation of the digits taken by Homer, and similarly S2 for Marge. So the value of S1 is the integer formed by the digits assigned to Homer, and same for S2. So to maximize the sum, we need to maximize the sum of these two numbers.\n\nSo the problem reduces to selecting for each digit whether it's assigned to Homer or Marge, ensuring that each gets exactly n digits, and the sum is as large as possible.\n\nBut the order matters because the digits are processed from left to right. So for example, if the first digit is high, assigning it to the first player (Homer if he starts first) would contribute more to S1 than assigning it later.\n\nSo the decision for each digit depends on its position and the current state of how many digits each player has taken so far.\n\nThis sounds like a dynamic programming problem where the state is (h, m, pos), representing that up to position 'pos', Homer has taken 'h' digits, Marge has taken 'm' digits, and the next digit is at position 'pos'.\n\nAt each step, we can decide whether to assign the current digit to Homer or Marge, provided that neither exceeds n digits.\n\nSo the DP state needs to keep track of h, m, and pos. The value stored could be the maximum possible sum achievable from that state onwards.\n\nBut wait, how do we compute the value contributed by the current digit? It's the digit itself multiplied by 10^k, where k is the position in their respective numbers.\n\nWait, but the position in their number depends on when the digit is added. For example, the first digit of S1 is the first digit taken by Homer, the second is the next, etc. So each digit's contribution to S1 is digit * 10^(number_of_digits_taken_after - 1), similar for S2.\n\nHmm, this seems tricky because the value of a digit depends on the order in which it's added. So the earlier digits contribute more to the sum.\n\nTherefore, the DP approach needs to account for the order in which digits are taken, and the position within S1 and",
    "response": "To solve this problem, we need to determine the sequence of moves for Homer and Marge in a TV game such that their total prize is maximized. Each player takes exactly n moves, and the goal is to maximize the sum of the numbers they form by taking digits from the given string.\n\n### Approach\nThe problem can be efficiently solved using dynamic programming (DP). The key idea is to track the state of the game as we process each digit from left to right. The state is defined by the number of digits taken by Homer (h) and Marge (m), and the current position in the digit string being processed (pos).\n\n1. **State Representation**: The DP state is represented as `dp[h][m][pos]`, where:\n   - `h` is the number of digits taken by Homer so far.\n   - `m` is the number of digits taken by Marge so far.\n   - `pos` is the current position in the digit string.\n\n2. **Transition**: For each state, we have two choices: assign the current digit to Homer or to Marge, provided neither exceeds their maximum allowed moves (n). The value of the current digit contributes to either Homer's or Marge's number based on the position and the number of digits they have already taken.\n\n3. **Maximization**: We use memoization to store the maximum possible sum achievable from each state onwards. This ensures that we do not recompute values for the same state, leading to efficient computation.\n\n4. **Base Case**: When all digits are processed, the sum is simply the sum of the numbers formed by Homer and Marge.\n\n5. **Backtracking**: After computing the optimal moves using DP, we backtrack from the final state to determine the sequence of moves that led to the maximum sum.\n\n### Solution Code\n```python\nimport sys\nfrom functools import lru_cache\n\ndef main():\n    n = int(sys.stdin.readline())\n    A = sys.stdin.readline().strip()\n    \n    # Convert A into a list of integers for easier handling\n    digits = [int(c) for c in A]\n    \n    # DP function with memoization\n    @lru_cache(maxsize=None)\n    def dp(h, m, pos):\n        if pos == len(digits):\n            return 0\n        res = 0\n        # Assign current digit to Homer\n        if h < n:\n            res += (digits[pos] * (10 ** (n - h - 1))) \n            res += dp(h + 1, m, pos + 1)\n        # Assign current digit to Marge\n        if m < n:\n            res += (digits[pos] * (10 ** (n - m - 1)))\n            res += dp(h, m + 1, pos + 1)\n        return res\n    \n    max_sum = dp(0, 0, 0)\n    \n    # Now reconstruct the path to get the sequence of H and M\n    path = []\n    h, m, pos = 0, 0, 0\n    while pos < len(digits):\n        current_digit = digits[pos]\n        if h < n:\n            contribution_h = current_digit * (10 ** (n - h - 1))\n            new_sum = dp(h+1, m, pos+1)\n            if new_sum >= dp(h, m, pos+1):\n                path.append('H')\n                h += 1\n            else:\n                path.append('M')\n        else:\n            contribution_m = current_digit * (10 ** (n - m - 1))\n            new_sum = dp(h, m+1, pos+1)\n            if new_sum >= dp(h, m, pos+1):\n                path.append('M')\n                m += 1\n            else:\n                path.append('H')\n        pos += 1\n    \n    print(''.join(path))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input consists of an integer `n` and a string `A` of 2n digits. We convert this string into a list of integers for easier processing.\n\n2. **Dynamic Programming Function**: The `dp` function uses memoization to store the maximum sum achievable from a given state `(h, m, pos)`. It considers both possible assignments of the current digit to either Homer or Marge and recursively computes the maximum sum.\n\n3. **Reconstructing the Path**: After computing the maximum sum, we backtrack from the final state to determine the sequence of moves that led to this maximum sum. This involves checking at each step whether assigning the current digit to Homer or Marge yields a higher sum and recording the choice.\n\nThis approach ensures that we efficiently compute the optimal sequence of moves using dynamic programming and memoization, resulting in an optimal solution.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom functools import lru_cache\n\ndef main():\n    n = int(sys.stdin.readline())\n    A = sys.stdin.readline().strip()\n    \n    # Convert A into a list of integers for easier handling\n    digits = [int(c) for c in A]\n    \n    # DP function with memoization\n    @lru_cache(maxsize=None)\n    def dp(h, m, pos):\n        if pos == len(digits):\n            return 0\n        res = 0\n        # Assign current digit to Homer\n        if h < n:\n            res += (digits[pos] * (10 ** (n - h - 1))) \n            res += dp(h + 1, m, pos + 1)\n        # Assign current digit to Marge\n        if m < n:\n            res += (digits[pos] * (10 ** (n - m - 1)))\n            res += dp(h, m + 1, pos + 1)\n        return res\n    \n    max_sum = dp(0, 0, 0)\n    \n    # Now reconstruct the path to get the sequence of H and M\n    path = []\n    h, m, pos = 0, 0, 0\n    while pos < len(digits):\n        current_digit = digits[pos]\n        if h < n:\n            contribution_h = current_digit * (10 ** (n - h - 1))\n            new_sum = dp(h+1, m, pos+1)\n            if new_sum >= dp(h, m, pos+1):\n                path.append('H')\n                h += 1\n            else:\n                path.append('M')\n        else:\n            contribution_m = current_digit * (10 ** (n - m - 1))\n            new_sum = dp(h, m+1, pos+1)\n            if new_sum >= dp(h, m, pos+1):\n                path.append('M')\n                m += 1\n            else:\n                path.append('H')\n        pos += 1\n    \n    print(''.join(path))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 411,
        "completion_token_count": 995,
        "thoughts_token_count": 1025
    }
}