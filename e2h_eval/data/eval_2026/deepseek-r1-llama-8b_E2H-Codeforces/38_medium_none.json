{
    "start": 1758284307.2764282,
    "end": 1758286697.5504375,
    "start-formatted": "2025-09-19 21:18 KST",
    "end-formatted": "2025-09-19 21:58 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "Okay, so I have this problem to solve, and I'm a bit stuck but let's try to think through it step by step.\n\nThe problem is about directed graphs and certain properties. Let me read the problem again to make sure I understand it.\n\nWe need to find two things for a given p:\n1. The minimum number of nodes required to create a p-reachable directed graph.\n2. Among all such graphs with this minimum number of nodes, find the maximum number of unidirectional pairs possible.\n\nHmm. So, what's a p-reachable directed graph? Oh right, it's one that has exactly p ordered pairs (u, v) where u < v, and u and v are reachable from each other. So these are the edges that form a bidirectional connection between two nodes where u is less than v. Each such edge contributes to the count p.\n\nWait, but wait: the problem says an ordered pair (u, v) is unidirectional if u != v, there's a path from u to v, and no path from v to u. So in the graph, for each such pair, it's only one way.\n\nBut the p-reachable condition is about the number of such ordered pairs (u, v) where u < v and they can reach each other, meaning that u and v form a strongly connected component (SCC) and u < v. Wait no, because in a directed graph, even if u can reach v and v can reach u, it's a single strongly connected component. But in that case, for any u < v in the component, (u, v) is part of the p count.\n\nSo the p is the count of such edges in the graph.\n\nSo, the first task is to find the minimal number of nodes needed so that the number of such edges is exactly p.\n\nOnce we have that minimal n, then we need to arrange the graph in a way that maximizes the number of unidirectional pairs. Unidirectional pairs are those where (u, v) is present as a path, but not the reverse.\n\nSo, how do I approach this?\n\nLet's break it down into parts.\n\nFirst, finding the minimal number of nodes.\n\nI think the minimal n is determined by the structure of the graph that allows us to get p edges in the way described. Since each such edge corresponds to a pair (u, v) where u < v and they are mutually reachable, perhaps the optimal way is to have each such edge be in a separate component or arranged in a way that doesn't require adding extra nodes.\n\nWait, perhaps the minimal n is achieved when the graph consists of a collection of edges where each edge is part of its own SCC, which is a pair (u, v). Because each such edge contributes exactly 1 to p, and requires 2 nodes. But that's only if the edge is a direct edge, but the problem allows for paths. Hmm, maybe not. Because if you have a path from u to v and not vice versa, but u < v, then (u, v) is counted once, contributing 1 to p. So, if you have a chain like u → w → v, then u and v are in the same SCC, so (u, v) is counted as a reachable pair, but so are (w, u), (w, v), etc., depending on the structure.\n\nWait, no. Wait, the p count is the number of ordered pairs (u, v) where u < v and u and v are mutually reachable. So, if u and v are in the same SCC and u < v, then (u, v) is counted as one pair. But if the SCC has more than two nodes, say k nodes, then the number of such pairs is C(k, 2) = k*(k-1)/2. Because every pair u < v in the same SCC contributes one.\n\nWait, no, because in a strongly connected component, any two nodes can reach each other. So for a component with size m, the number of such (u, v) pairs is m choose 2, since for every u < v in the component, (u, v) is counted once.\n\nSo, the total p is the sum of m choose 2 for each component in the graph, where m is the size of the component.\n\nSo, our goal is to find a set of components where the sum of m choose 2 equals p, and the total number of nodes is minimized.\n\nWait, but the minimal number of nodes would be achieved by having the largest possible components. Because for a given p, if you have a component of size m, it contributes m*(m-1)/2 to p. So to minimize the total number of nodes, we should maximize the components' sizes.\n\nSo, the problem reduces to partitioning p into a sum of terms of the form k*(k-1)/2, where each term is the contribution from a component of size k, and we want to minimize the sum of k's.\n\nAh! So this is similar to the problem where we represent p as a sum of triangular numbers, and find the minimal number of terms.\n\nWait, because each component contributes t_k = k*(k-1)/2, and the sum of t_k's must equal p. We need to find the minimal number of components (and thus, the minimal total nodes) by choosing the largest possible t_k each time.\n\nSo, the approach is to greedily take the largest possible t_k less than or equal to the remaining p, subtract it from p, and repeat until p is zero.\n\nFor example, let's see:\n\nIf p=3, then the largest t_k <=3 is t_3=3, which contributes exactly p=3. So the minimal nodes is 3.\n\nIf p=4, t_4=6 is larger than 4. So next is t_3=3. Subtract 3, remaining p is 1. Then t_1=0, but that's not helpful. Wait, no. Because t_k is for components of size k >=2? Or can k be 1?\n\nWait, wait. Because a component of size 1 contributes zero to p, because there are no pairs (u, v) with u < v in the same component. So including a component of size 1 doesn't affect p but adds 1 node. So to minimize the number of nodes, we shouldn't include any such components unless necessary.\n\nWait, no. Because if you have a component of size 1, it contributes nothing to p. So for p=0, you just have one node.\n\nBut in cases where the sum of t_k's can't reach p exactly without including some t_1's (but that's only if p is not achievable with components of size >=2).\n\nWait, but for example, p=1. What's the minimal nodes?\n\nWe can't have a component of size 2, because t_2=1. So yes, one component of size 2, so nodes=2.\n\nAnother example: p=2. Can we have a component of size 3? No, because t_3=3>2. So the next is t_2=1. Then remaining p is 1. Now, can we add another component of size 2? That would give t_2=1, adding to p=1+1=2. So total nodes 4.\n\nWait, but is there a better way? Alternatively, could we have a component of size 2 (contributes 1) and then a component of size 3 (contributes 3)? But 1 +3=4>2, which is more than needed. So no. So the minimal nodes would be 4 for p=2.\n\nWait, but wait: perhaps another approach. Maybe have a component of size 3 and a component of size 1. Then, t_3=3 and t_1=0, but 3>2, so that's not allowed. So no.\n\nHmm, so for p=2, the minimal nodes are 4.\n\nWait, but wait. Another thought: perhaps a component of size 2 (t=1) and a component of size 3 (t=3). But 1+3=4>2, which is over.\n\nSo, perhaps it's impossible to get p=2 with components of size >=2 except with multiple smaller components. Like two components of size 2: each contributes 1, total 2. So 2+2=4 nodes.\n\nYes, that's correct.\n\nSo the approach is to partition p into a sum of t_k's, each being the triangular number for k, and the sum of k's is as small as possible.\n\nSo the process is:\n\n1. Find the largest k where t_k <= current p.\n2. Subtract t_k from p.\n3. Add k to the total nodes.\n4. Repeat until p becomes zero.\n\nWait, but sometimes, after selecting a certain k, the remaining p may not be a triangular number. For example, suppose p=5.\n\nLargest t_k <=5 is t_3=3. Subtract 3, remaining 2. Next, t_2=1. Subtract 1, remaining 1. Next, can't take t_2=1 again, because that would add 2 nodes for 1 p. But wait, 1 is t_2=1. So total nodes would be 3+2+2=7. But perhaps there's a better way.\n\nWait, maybe instead of taking t_3=3, t_2=1, and t_2=1, we can take t_4=6, which is larger than 5, so no. Or maybe take t_3=3 and then t_2=1 and then t_1=0, but that's not useful.\n\nAlternatively, perhaps another combination: t_3=3, then t_2=1, then t_2=1, which gives 3+1+1=5 p, but that requires 3+2+2=7 nodes.\n\nWait, but perhaps another approach: t_4=6 is too big. So maybe t_3=3, then t_2=1, then t_2=1. So 3+1+1=5. Total nodes 3+2+2=7.\n\nAlternatively, could we take t_4=6? No, because 6>5. So no.\n\nHmm. So for p=5, the minimal nodes are 7.\n\nWait, but another approach: perhaps have a component of size 4 (t_4=6) but that's larger than 5, so no.\n\nSo yeah, seems that the approach is correct.\n\nSo the first part of the problem is to compute the minimal number of nodes by breaking p into a sum of t_k's, each as large as possible.\n\nNow, the second part: among all such graphs with minimal nodes, find the maximum number of unidirectional pairs.\n\nWait, unidirectional pairs are the ones where (u, v) is in the graph (i.e., u can reach v) but (v, u) is not. So for each ordered pair (u, v), u != v, if u can reach v and v cannot reach u, then it's an unidirectional pair.\n\nBut the problem says that in the p-reachable graph, the p is the count of pairs where u < v and they are mutually reachable. So, for each such pair, (u, v) is counted once in p, regardless of whether (v, u) exists or not.\n\nWait, no. Wait, in the p count, we're only considering pairs where u < v and u and v are reachable from each other. So (u, v) is counted if u and v are in the same SCC and u < v. It doesn't matter if u can reach v via a longer path or directly.\n\nSo, in the context of unidirectional pairs, we need to consider all ordered pairs (u, v) where u can reach v but v cannot reach u. These can include pairs where u and v are in different components or in the same component but u reaches v without v reaching u, which is impossible in a strongly connected component.\n\nWait, no. Because in a strongly connected component, every node can reach every other node. So if u and v are in the same component, u can reach v and v can reach u. So for such a pair, (u, v) cannot be an unidirectional pair because both directions exist.\n\nBut wait, wait. The definition says that a unidirectional pair is an ordered pair (u, v) where u != v, there's a path from u to v, and no path from v to u. So, in the same component, (u, v) cannot be unidirectional because v can reach u.\n\nSo, unidirectional pairs can only occur between nodes in different components. Because if u and v are in different components, then u can reach v only if u is in a component that can reach v's component, but v can't reach u.\n\nWait, no. Suppose u is in component A, v is in component B. If there's a path from A to B but not from B to A, then any u in A can reach v, but v cannot reach u. So for any u in A and v in B, if u can reach v, then (u, v) is a unidirectional pair.\n\nBut wait, in that case, the number of unidirectional pairs could be very large.\n\nBut the problem is, in the minimal node graph, how can we arrange the components to maximize the number of such unidirectional pairs.\n\nSo, in the minimal node setup, which is a collection of components whose t_k's sum up to p, each component is a strongly connected component. So, the graph is made up of several strongly connected components, each of size k_i, where t_{k_i} is added to p.\n\nNow, the question is to arrange these components in a way that the number of unidirectional pairs is maximized.\n\nBecause each component can't contribute any unidirectional pairs within itself, all unidirectional pairs must be between nodes from different components.\n\nSo, suppose we have components C_1, C_2, ..., C_m, with sizes k_1, k_2, ..., k_m. The total number of unidirectional pairs is the sum over i < j of (number of edges from C_i to C_j) * k_i * k_j.\n\nWait, but wait: if there's a directed edge from C_i to C_j, but not the reverse, then every u in C_i and v in C_j contributes a unidirectional pair (u, v). So the number of such pairs is k_i * k_j.\n\nBut the problem is, how many directed edges are between components?\n\nIn a DAG of components (since no cycles between components), each component can have edges pointing to other components, but no cycles.\n\nSo, the maximum number of unidirectional pairs is achieved when between every pair of components (i, j), there is a directed edge from i to j, but none from j to i.\n\nBut wait, no. Because if i has an edge to j, then all pairs (u, v) where u is in i and v is in j contribute a unidirectional pair. So for each pair of components i and j, if i points to j, the number of unidirectional pairs is k_i * k_j.\n\nSo, the total is the sum over all i < j of (if i points to j, add k_i * k_j, else 0).\n\nSo, the maximum possible is achieved when all components point to each other in a way that forms a complete DAG, i.e., for any i and j, if i != j, then i points to j.\n\nBut wait, that's not possible because that would create a cycle. For example, if i points to j and j points to i, that creates a cycle between components, which isn't allowed because components are strongly connected. So, the components must form a DAG.\n\nSo, the best way is to arrange the components in a linear order, where each component points to all components that come after it. That way, each component i has edges to all j > i, contributing k_i * k_j to the unidirectional pairs.\n\nIn this arrangement, the total number of unidirectional pairs is the sum for i from 1 to m-1 of (sum_{j=i+1 to m} k_i * k_j).\n\nWhich is equivalent to summing k_i * (sum_{j=i+1 to m} k_j).\n\nThis sum can be computed as the sum over i < j of k_i * k_j.\n\nTo maximize this sum, the components should be arranged in such a way that larger components are placed earlier in the ordering. Because when a larger k_i is multiplied by the sum of all k_j for j > i, it contributes more.\n\nSo, the optimal arrangement is to sort the component sizes in non-increasing order and then connect them in a linear fashion, with edges from each component to all components that come after it.\n\nSo, the steps are:\n\n1. Compute the minimal number of nodes by breaking p into a sum of t_k's, each as large as possible.\n2. Once the component sizes are determined, sort them in non-increasing order.\n3. Compute the number of unidirectional pairs as the sum of k_i * k_j for all i < j.\n\nWait, but in the initial step, when we break p into t_k's, each component is a strongly connected component, and their sizes are determined by the k's used.\n\nBut wait, no. For example, when p=3, the components are of size 3. So the sum is 3 choose 2 =3. So the component is a single component of size 3.\n\nIn that case, there are no unidirectional pairs, because all pairs are within the same component.\n\nSo, the maximum number of unidirectional pairs is zero.\n\nBut for p=4, the minimal nodes are 5. Let's see: t_3 is 3, which leaves 1. But t_2 is 1, so total p=4. So components are 3 and 2.\n\nSort them as [3, 2]. Then the number of unidirectional pairs is 3*2=6.\n\nWait, because 3 points to 2, so all pairs (u, v) where u is in 3 and v is in 2 contribute 6 unidirectional pairs.\n\nSo the maximum number is 6.\n\nWhich matches the sample input where for p=4, the output is 5 6.\n\nSo, the approach is:\n\nCompute the minimal number of nodes by breaking p into the sum of t_k's, each as large as possible.\n\nThen, the number of unidirectional pairs is the sum of k_i * k_j for all i < j, assuming the components are sorted in non-increasing order.\n\nSo, the next step is to figure out how to compute the minimal number of nodes and the component sizes.\n\nSo, the algorithm for the first part is:\n\nInitialize p as the given input.\n\nCompute the minimal nodes by:\n\nWhile p > 0:\n\n   Find the largest k where t_k <= p.\n\n   Subtract t_k from p.\n\n   Add k to the list of component sizes.\n\nOnce all components are found, the total nodes is the sum of k's.\n\nWait, no. Wait, each component contributes t_k to p, and uses k nodes.\n\nSo, for example, for p=3, k=3, t_k=3, sum is 3.\n\nFor p=4, k=3 (t=3), p becomes 1. Then, k=2 (t=1), p becomes 0. Sum is 3+2=5.\n\nYes.\n\nSo, the code for this part would be:\n\ndef find_min_nodes(p):\n\n    nodes = 0\n\n    components = []\n\n    while p > 0:\n\n        # find the largest k where k*(k-1)/2 <= p\n\n        k = 0\n\n        low = 0\n\n        high = 2*10^5\n\n        while low <= high:\n\n            mid = (low + high) // 2\n\n            t = mid * (mid -1) //2\n\n            if t <= p:\n\n                k = mid\n\n                low = mid +1\n\n            else:\n\n                high = mid -1\n\n        if k ==0:\n\n            # can't take a component, so add 1 node.\n\n            p -=0\n\n            nodes +=1\n\n        else:\n\n            # subtract t from p\n\n            t = k*(k-1)//2\n\n            p -= t\n\n            nodes +=k\n\n            components.append(k)\n\n    return nodes, components\n\nWait, but wait: what if after subtracting t, the remaining p is 0 or not?\n\nWait, but in the loop, we subtract t from p, but what if t is larger than p? Because in binary search, we find the largest k where t_k <=p. So, t is always <=p.\n\nSo, the code above is correct.\n\nNow, for the second part: compute the maximum number of unidirectional pairs.\n\nAs discussed, this is achieved when the components are sorted in non-increasing order, and each component points to all components after it.\n\nThus, the number of unidirectional pairs is the sum of k_i * k_j for all i < j.\n\nSo, the steps are:\n\n1. Sort the component sizes in non-increasing order.\n\n2. Compute the sum of k_i * k_j for i < j.\n\nThis can be done efficiently.\n\nNow, let's think about how to compute this sum.\n\nLet's denote S = sum_{i=1 to m} k_i.\n\nSum_{i<j} k_i k_j = (S^2 - sum_{i} k_i^2)/2.\n\nBecause S^2 = sum k_i^2 + 2*sum_{i<j} k_i k_j.\n\nSo, sum_{i<j} k_i k_j = (S^2 - sum_k_sq)/2.\n\nWhere sum_k_sq is the sum of squares of the component sizes.\n\nSo, this is efficient to compute.\n\nThus, the plan is:\n\nOnce we have the components, sorted in non-increasing order, compute the sum S and sum_k_sq.\n\nThen, the number of unidirectional pairs is (S^2 - sum_k_sq) // 2.\n\nWait, but wait: in the earlier example of components [3, 2], S=5, sum_k_sq=9+4=13.\n\nSo, 5²=25. 25-13=12. Divided by 2 is 6, which is correct.\n\nYes.\n\nSo, the code steps are:\n\nAfter obtaining the list of components:\n\n- Sort the list in descending order.\n\n- Compute S = sum(components).\n\n- Compute sum_k_sq = sum(k^2 for k in components).\n\n- The unidirectional pairs count is (S^2 - sum_k_sq) // 2.\n\nSo, putting it all together.\n\nNow, let's handle some edge cases.\n\nCase 1: p=0.\n\nThen, the minimal nodes is 0? Or 1?\n\nWait, according to the problem statement, the graph can have zero nodes? Or is it at least one node?\n\nLooking back at the sample input, when p=0, the output is '0 0'.\n\nSo, if p=0, the graph has zero nodes.\n\nSo, for p=0, min_nodes=0, unidirectional_pairs=0.\n\nAnother case: p=1.\n\nWhat's the minimal nodes? 2.\n\nComponents: [2], t_2=1.\n\nunidirectional_pairs: since all nodes are in the same component, no unidirectional pairs. So 0.\n\nWait, but wait: the component is size 2. So, any pair (u, v) in the same component is considered in p. So, the unidirectional pairs are zero.\n\nSo, the code would correctly output 2 0.\n\nAnother test case: p=2.\n\nAs discussed earlier, the minimal nodes is 4, components [2,2].\n\nSo, sorted as [2,2].\n\nS=4, sum_k_sq=8.\n\n(16-8)/2=4.\n\nSo, the maximum unidirectional pairs is 4.\n\nSo, the output would be 4 4.\n\nWait, but wait: in this case, the two components each of size 2 are arranged in a way that each points to the other. Wait, no. Because in a DAG, you can't have a cycle. So, the two components can't both point to each other. So, the maximum unidirectional pairs is achieved when one component points to the other. So, in this case, the number of unidirectional pairs is 2*2=4.\n\nWhich is correct.\n\nSo, the formula works.\n\nAnother example: p=5.\n\nComponents are [3,2], because t_3=3, t_2=1, sum is 4, which is less than 5. Wait, no, wait.\n\nWait, wait, p=5.\n\nLooking for largest k where t_k <=5.\n\nt_3=3, t_4=6>5.\n\nSo, subtract 3, p becomes 2.\n\nNext, find largest k where t_k <=2. t_2=1, subtract 1, p=1.\n\nWait, but then p=1, but t_2=1 again. So subtract 1, p=0.\n\nSo components are [3,2,2]. Because t_3=3, t_2=1, t_2=1. Sum is 3+2+2=7 nodes.\n\nWait, but wait: 3*(3-1)/2 =3, 2*(2-1)/2=1, 2*(2-1)/2=1. Sum is 3+1+1=5.\n\nYes.\n\nSo, the components are [3,2,2], sorted as [3,2,2].\n\nCompute S=3+2+2=7.\n\nsum_k_sq=9+4+4=17.\n\n(49 -17)/2=32/2=16.\n\nSo the maximum unidirectional pairs is 16.\n\nIs that correct?\n\nLet's see: the components are 3, 2, 2.\n\nEach component points to all components after it.\n\nSo, component 3 points to 2 and 2: 3*2 +3*2=12.\n\nComponent 2 (first) points to the other 2: 2*2=4.\n\nComponent 2 (second) does not point to anything after.\n\nTotal unidirectional pairs: 12+4=16. Yes.\n\nSo, the formula is correct.\n\nSo, the code needs to implement this.\n\nNow, handling the case when p=0: returns 0 0.\n\nAnother case: p=1, which is t_2=1. So components [2], no unidirectional pairs.\n\nNow, let's think about the code.\n\nImplementing the function to find the minimal nodes and the components.\n\nBut wait, for p=0, the loop doesn't run, so the components list is empty. So sum is 0, which is correct.\n\nBut in the code, when p=0, the function returns nodes=0, which is correct.\n\nSo, now the code can be written.\n\nNow, the problem is to write a Python function that reads p from stdin, computes the minimal nodes and the maximum unidirectional pairs.\n\nNow, the code outline is:\n\nRead p.\n\nIf p is 0:\n\n   min_nodes = 0\n\n   unidirectional =0\n\nElse:\n\n   compute the minimal nodes and the components.\n\n   sort the components in descending order.\n\n   compute S = sum(components)\n\n   compute sum_k_sq = sum(k^2 for k in components)\n\n   unidirectional = (S*S - sum_k_sq) // 2\n\nOutput min_nodes and unidirectional.\n\nBut wait, what about when p is zero? The minimal nodes is zero.\n\nSo, the code can be structured as:\n\np = int(input())\n\nif p ==0:\n\n    print(\"0 0\")\n\nelse:\n\n    # compute components\n\n    # compute min_nodes and components.\n\n    # process components.\n\nBut wait, perhaps p can be zero, which is handled correctly.\n\nNow, the binary search part: for each iteration, find the largest k where k*(k-1)/2 <= p_remaining.\n\nImplementing this with binary search.\n\nNow, let's think about the binary search.\n\nThe maximum possible k can be up to sqrt(2p) +1.\n\nBut in code, for each step, we can perform a binary search between low=1 and high=2e5, since p can be up to 2e5.\n\nWait, but p can be up to 2e5, so the maximum k is around sqrt(2*2e5) ~ 894.\n\nSo, binary search is feasible.\n\nNow, in code:\n\ncomponents = []\n\nwhile p >0:\n\n   left =1\n\n   right = 200000  # since (2e5)*(2e5-1)/2 is about 2e10, which is larger than 2e5.\n\n   best_k =0\n\n   while left <= right:\n\n       mid = (left + right) //2\n\n       t = mid * (mid -1) //2\n\n       if t <= p:\n\n           best_k = mid\n\n           left = mid +1\n\n       else:\n\n           right = mid -1\n\n   if best_k ==0:\n\n       # can't find a component, so add 1 node.\n\n       nodes +=1\n\n       p -=0\n\n   else:\n\n       t = best_k * (best_k -1) //2\n\n       p -= t\n\n       nodes += best_k\n\n       components.append(best_k)\n\nSo, in code, for each iteration, we find the largest k where t_k <= p.\n\nNow, let's test this.\n\nFor p=3:\n\nLoop runs once.\n\nmid will be 3, t=3<=3.\n\nSubtract 3, p=0.\n\nnodes=3.\n\ncomponents=[3].\n\nNo more iterations.\n\nThen, for unidirectional, since len(components)=1, the sum is zero.\n\nThus, output 3 0.\n\nSample Input 1.\n\nFor p=4:\n\nLoop:\n\np=4.\n\nbinary search finds k=3, t=3.\n\np=1.\n\nAdd 3 to components.\n\nLoop again: p=1.\n\nbinary search: find k=2, t=1.\n\np=0.\n\nAdd 2.\n\ncomponents are [3,2].\n\nsort as [3,2].\n\nS=5.\n\nsum_k_sq=9+4=13.\n\n(25-13)/2=6.\n\nSo output 5 6.\n\nWhich matches the sample.\n\nAnother test case: p=0.\n\nOutput 0 0.\n\nAnother test case: p=2.\n\nLoop:\n\np=2.\n\nfind k=2, t=1.\n\np=1.\n\nAdd 2.\n\ncomponents [2].\n\nLoop again: p=1.\n\nfind k=2, t=1.\n\np=0.\n\nAdd 2.\n\ncomponents [2,2].\n\nsort as [2,2].\n\nS=4.\n\nsum_k_sq=4+4=8.\n\n(16-8)/2=4.\n\nSo output 4 4.\n\nWhich is correct.\n\nSo, the code seems correct.\n\nNow, let's write the code.\n\nBut also, handle the case when p=0.\n\nSo, the code:\n\nRead p.\n\nif p ==0:\n\n   print(\"0 0\")\n\nelse:\n\n   compute components.\n\n   sort them.\n\n   compute s and sum_k_sq.\n\n   unidir = (s*s - sum_k_sq)//2.\n\n   print(nodes, unidir)\n\nBut wait, what if the components list is empty? Only when p=0.\n\nThus, the code should handle that.\n\nNow, the code in Python:\n\nimport sys\n\ndef find_min_components(p):\n\n    components = []\n\n    nodes =0\n\n    while p >0:\n\n        # Binary search for the largest k where k*(k-1)/2 <= p\n\n        left = 1\n\n        right = 2 * 10**5\n\n        best_k =0\n\n        while left <= right:\n\n            mid = (left + right) // 2\n\n            t = mid * (mid -1) //2\n\n            if t <= p:\n\n                best_k = mid\n\n                left = mid +1\n\n            else:\n\n                right = mid -1\n\n        if best_k ==0:\n\n            # cannot add any component, add 1 node.\n\n            nodes +=1\n\n            p -=0\n\n        else:\n\n            t = best_k * (best_k -1) //2\n\n            p -= t\n\n            nodes += best_k\n\n            components.append(best_k)\n\n    return nodes, components\n\ndef main():\n\n    p = int(sys.stdin.readline().strip())\n\n    if p ==0:\n\n        print(\"0 0\")\n\n        return\n\n    min_nodes, components = find_min_components(p)\n\n    components.sort(reverse=True)\n\n    s = sum(components)\n\n    sum_k_sq = sum( x*x for x in components )\n\n    unidir = (s * s - sum_k_sq) //2\n\n    print(f\"{min_nodes} {unidir}\")\n\nmain()\n\nTesting the sample inputs.\n\nSample Input: 3.\n\nSample Output: 3 0.\n\nAs expected.\n\nSample Input:4.\n\nOutput:5 6.\n\nSample Input:0.\n\nOutput:0 0.\n\nAnother test case: p=2.\n\ncomponents [2,2], sorted as [2,2].\n\ns=4, sum_k_sq=8.\n\n(16-8)/2=4.\n\nSo, output 4 4.\n\nAnother test case: p=5.\n\nComponents are [3,2,2], sorted as [3,2,2].\n\ns=7, sum_k_sq=9+4+4=17.\n\n7^2=49. 49-17=32. 32/2=16.\n\nSo, output 7 16.\n\nYes.\n\nSo, the code seems correct.\n",
    "response": "To solve this problem, we need to determine the minimum number of nodes required to create a p-reachable directed graph and maximize the number of unidirectional pairs among all such graphs with the minimum number of nodes.\n\n### Approach\n1. **Understanding p-reachable Graphs**: A p-reachable graph has exactly p ordered pairs (u, v) where u < v and both nodes are reachable from each other. This means that for any two nodes u and v in a strongly connected component (SCC), the pair (u, v) is counted once if u < v.\n\n2. **Finding Minimum Nodes**: To minimize the number of nodes, we need to partition the value p into sums of triangular numbers (k*(k-1)/2) where each term represents an SCC of size k. This is done by greedily selecting the largest possible SCC size each time until p is reduced to zero.\n\n3. **Maximizing Unidirectional Pairs**: Once the minimum number of nodes is determined, we need to arrange these SCCs in a way that maximizes the number of unidirectional pairs. This is achieved by sorting the SCC sizes in non-increasing order and summing the products of all pairs of different SCC sizes.\n\n### Solution Code\n```python\nimport sys\n\ndef find_min_components(p):\n    components = []\n    nodes = 0\n    while p > 0:\n        left = 1\n        right = 2 * 10**5\n        best_k = 0\n        while left <= right:\n            mid = (left + right) // 2\n            t = mid * (mid - 1) // 2\n            if t <= p:\n                best_k = mid\n                left = mid + 1\n            else:\n                right = mid - 1\n        if best_k == 0:\n            nodes += 1\n            p -= 0\n        else:\n            t = best_k * (best_k - 1) // 2\n            p -= t\n            nodes += best_k\n            components.append(best_k)\n    return nodes, components\n\ndef main():\n    p = int(sys.stdin.readline().strip())\n    if p == 0:\n        print(\"0 0\")\n        return\n    min_nodes, components = find_min_components(p)\n    components.sort(reverse=True)\n    s = sum(components)\n    sum_k_sq = sum(x * x for x in components)\n    unidir = (s * s - sum_k_sq) // 2\n    print(f\"{min_nodes} {unidir}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read as an integer p which represents the number of ordered pairs.\n2. **Handling Special Case for p=0**: If p is zero, the output is directly \"0 0\" since no edges exist.\n3. **Finding Minimum Nodes**: Using a binary search approach, the function `find_min_components` determines the optimal sizes of SCCs that sum up to p. This ensures the minimum number of nodes.\n4. **Calculating Unidirectional Pairs**: After determining the SCC sizes, these sizes are sorted in descending order. The maximum number of unidirectional pairs is calculated using the formula derived from summing the products of all pairs of different SCC sizes.\n\nThis approach efficiently computes the required values using mathematical insights and binary search, ensuring optimal performance even for large values of p.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef find_min_components(p):\n    components = []\n    nodes = 0\n    while p > 0:\n        left = 1\n        right = 2 * 10**5\n        best_k = 0\n        while left <= right:\n            mid = (left + right) // 2\n            t = mid * (mid - 1) // 2\n            if t <= p:\n                best_k = mid\n                left = mid + 1\n            else:\n                right = mid - 1\n        if best_k == 0:\n            nodes += 1\n            p -= 0\n        else:\n            t = best_k * (best_k - 1) // 2\n            p -= t\n            nodes += best_k\n            components.append(best_k)\n    return nodes, components\n\ndef main():\n    p = int(sys.stdin.readline().strip())\n    if p == 0:\n        print(\"0 0\")\n        return\n    min_nodes, components = find_min_components(p)\n    components.sort(reverse=True)\n    s = sum(components)\n    sum_k_sq = sum(x * x for x in components)\n    unidir = (s * s - sum_k_sq) // 2\n    print(f\"{min_nodes} {unidir}\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 467,
        "completion_token_count": 721,
        "thoughts_token_count": 7245
    }
}