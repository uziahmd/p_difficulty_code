{
    "start": 1758278104.8722918,
    "end": 1758278318.6132383,
    "start-formatted": "2025-09-19 19:35 KST",
    "end-formatted": "2025-09-19 19:38 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "Okay, so I have this problem to solve. Let's read it carefully.\n\nThe problem is about assigning Rebel spaceships to guard B bases. Each base must have exactly one spaceship, and each spaceship must be assigned to exactly one base. So it's a perfect matching problem between R ships and B bases.\n\nBut there's an additional condition: the paths from each base to its assigned spaceship shouldn't intersect in 2D space. Wait, what does that mean? Oh right, the paths are straight lines from the base to the spaceship. So no two such lines can cross each other.\n\nHmm. So how do I model this?\n\nFirst, let's think about the input. We have R points (spaceships) and B points (bases). They're all distinct, and no three are colinear. So any two points form a line, but since no three are on the same line, each pair of lines is either non-intersecting or crosses once.\n\nWait, but the problem says that no three points are on the same line, so for any two points, the line between them doesn't contain any others. That might help with checking intersections.\n\nSo, the task is to find a perfect matching between the R and B points such that when we connect each ship to its base, none of these connecting lines cross each other.\n\nHow can I approach this?\n\nI remember that this kind of problem is related to bipartite matching, but with geometric constraints. So perhaps a backtracking approach where we try all possible permutations of matching ships to bases and check if any permutation satisfies the non-crossing condition.\n\nBut wait, R and B can be up to 10 each, so the maximum number of possibilities is 10! which is about 3.6 million. Hmm, that's manageable for a brute-force approach, especially since for each permutation we need to perform O(R log R) time for sorting or something similar.\n\nWait, no. Because for each permutation, we need to check all pairs of edges to see if they cross. For each pair of edges (ship A to base X, ship B to base Y), we need to determine if the line from A to X intersects with the line from B to Y, and also whether it's an improper intersection (i.e., not at the endpoints).\n\nBut considering that for each permutation, which is a matching of size B (since B could be less than R?), wait no: the problem says it's a perfect matching. So R equals B because the assignment is a perfect matching. Because each base has exactly one ship and each ship has exactly one base. So R must equal B. Oh wait, looking back, the first line says \"R Rebel spaceships to guard B bases\". So R and B can be different, but the output is possible only if R equals B, because otherwise a perfect matching isn't possible.\n\nWait, the problem statement says: \"the assignment is a perfect matching.\" So yes, R must equal B. Because a perfect matching requires that the two sets have the same size. So if R != B, then it's impossible. So the first thing to check is whether R == B. If not, output 'No'.\n\nWait, but looking at the sample input, the first case has R=3, B=3, so it's possible. The second case has R=2, B=2 as well, but the output is 'No' because of the crossing lines.\n\nWait, no. Looking at the sample input:\n\nIn the second example, the input is:\n\n2 1\n\nThen two ships:\n\n0 0\n\n1 0\n\nAnd two bases:\n\n2 2\n\n3 1\n\nWait, no. Wait the sample input is given as:\n\nFirst line: '3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2'\n\nWait, no, maybe I misread. Let me look again.\n\nWait the sample input is given as:\n\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\nWait, perhaps the first part is the Rebel data, then the bases. So R=3, B=3.\n\nWait, the initial line says the first line contains R and B. Then R lines of ship positions, then B lines of base positions.\n\nSo in the first sample, R=3, B=3.\n\nIn the second sample, the first line is '2 2', so R=2, B=2. So the output is 'Yes' or 'No' depending on whether a non-crossing matching exists.\n\nSo in the first sample, the output is 'Yes'; in the second, 'No'.\n\nSo the first step is to check if R == B. Otherwise, output 'No'.\n\nWait, but according to the problem statement, it's guaranteed",
    "response": "To solve this problem, we need to determine if it's possible to assign Rebel spaceships to guard B bases such that each base has exactly one guardian and each spaceship has exactly one assigned base. Additionally, the paths from each base to its assigned spaceship must not intersect in 2D space.\n\n### Approach\n1. **Check for Perfect Matching**: First, check if the number of Rebel spaceships (R) is equal to the number of bases (B). If R ≠ B, a perfect matching is impossible, and we immediately return \"No\".\n2. **Generate All Permutations**: Since R and B can be up to 10, generating all permutations of ships to bases is feasible. Each permutation represents a potential assignment.\n3. **Check for Non-Intersecting Paths**: For each permutation, convert the ship and base coordinates into segments. Check if any two segments intersect improperly (i.e., they cross each other except at their endpoints). If any permutation satisfies the non-intersecting condition, return \"Yes\". If none do, return \"No\".\n\n### Solution Code\n```python\nimport sys\nfrom itertools import permutations\n\ndef readints():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef main():\n    # Read R and B\n    R_B = sys.stdin.readline().strip().split()\n    R = int(R_B[0])\n    B = int(R_B[1])\n    \n    if R != B:\n        print(\"No\")\n        return\n    \n    # Read R ship coordinates\n    ships = []\n    for _ in range(R):\n        x, y = map(int, sys.stdin.readline().split())\n        ships.append((x, y))\n    \n    # Read B base coordinates\n    bases = []\n    for _ in range(B):\n        x, y = map(int, sys.stdin.readline().split())\n        bases.append((x, y))\n    \n    # Generate all possible permutations of assignments\n    for perm in permutations(range(R)):\n        # Assign each ship to a base based on the permutation\n        assignment = {}\n        for i in range(len(perm)):\n            assignment[ships[i]] = bases[perm[i]]\n        \n        # Check for any pair of lines that cross\n        valid = True\n        for i in range(R):\n            s_i = ships[i]\n            b_i = assignment[s_i]\n            for j in range(i+1, R):\n                s_j = ships[j]\n                b_j = assignment[s_j]\n                \n                # Function to check if two line segments intersect\n                def ccw(a, b, c):\n                    return (b[0]-a[0])*(c[1]-a[1]) - (b[1]-a[1])*(c[0]-a[0])\n                \n                # Compute orientation\n                o1 = ccw(s_i, b_i, s_j)\n                o2 = ccw(s_i, b_i, b_j)\n                o3 = ccw(s_j, b_j, s_i)\n                o4 = ccw(s_j, b_j, b_i)\n                \n                if ((o1 > 0 and o2 < 0) or (o1 < 0 and o2 > 0)) and \\\n                   ((o3 > 0 and o4 < 0) or (o3 < 0 and o4 > 0)):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            print(\"Yes\")\n            return\n    \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into ship and base coordinates.\n2. **Permutations Check**: We generate all possible permutations of assigning ships to bases.\n3. **Segment Intersection Check**: For each permutation, we convert ships and their assigned bases into line segments and check if any two segments intersect improperly using the CCW (Counter-Clockwise) function to determine orientation.\n4. **Output Result**: If a valid permutation is found where no segments intersect, we print \"Yes\". If no valid permutation exists after checking all possibilities, we print \"No\".\n\nThis approach ensures that we efficiently check all possible assignments and validate the geometric constraints, providing a correct solution to the problem.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom itertools import permutations\n\ndef readints():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef main():\n    # Read R and B\n    R_B = sys.stdin.readline().strip().split()\n    R = int(R_B[0])\n    B = int(R_B[1])\n    \n    if R != B:\n        print(\"No\")\n        return\n    \n    # Read R ship coordinates\n    ships = []\n    for _ in range(R):\n        x, y = map(int, sys.stdin.readline().split())\n        ships.append((x, y))\n    \n    # Read B base coordinates\n    bases = []\n    for _ in range(B):\n        x, y = map(int, sys.stdin.readline().split())\n        bases.append((x, y))\n    \n    # Generate all possible permutations of assignments\n    for perm in permutations(range(R)):\n        # Assign each ship to a base based on the permutation\n        assignment = {}\n        for i in range(len(perm)):\n            assignment[ships[i]] = bases[perm[i]]\n        \n        # Check for any pair of lines that cross\n        valid = True\n        for i in range(R):\n            s_i = ships[i]\n            b_i = assignment[s_i]\n            for j in range(i+1, R):\n                s_j = ships[j]\n                b_j = assignment[s_j]\n                \n                # Function to check if two line segments intersect\n                def ccw(a, b, c):\n                    return (b[0]-a[0])*(c[1]-a[1]) - (b[1]-a[1])*(c[0]-a[0])\n                \n                # Compute orientation\n                o1 = ccw(s_i, b_i, s_j)\n                o2 = ccw(s_i, b_i, b_j)\n                o3 = ccw(s_j, b_j, s_i)\n                o4 = ccw(s_j, b_j, b_i)\n                \n                if ((o1 > 0 and o2 < 0) or (o1 < 0 and o2 > 0)) and \\\n                   ((o3 > 0 and o4 < 0) or (o3 < 0 and o4 > 0)):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            print(\"Yes\")\n            return\n    \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 454,
        "completion_token_count": 880,
        "thoughts_token_count": 1025
    }
}