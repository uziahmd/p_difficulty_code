{
    "start": 1758278874.056757,
    "end": 1758279319.6623917,
    "start-formatted": "2025-09-19 19:47 KST",
    "end-formatted": "2025-09-19 19:55 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "Okay, so I have this problem where I need to determine if it's possible to assign a number of mushrooms to each lawn such that all the given roads' GCD and LCM constraints are satisfied. And if it's possible, I have to output any valid assignment.\n\nHmm, let's think about the problem. Each edge between two vertices (lawns) gives us a pair (g, l), which is the GCD and LCM of the mushrooms on those two vertices. So for two connected lawns u and v, their mushroom counts must satisfy:\n- gcd(u, v) = g\n- lcm(u, v) = l\n\nWait, but wait—no, actually, the problem says that on each road, they wrote the GCD and LCM of the two numbers. So for the two ends u and v, we have:\nu and v must satisfy that their GCD is the given GCD, and their LCM is the given LCM.\n\nBut wait, that's not necessarily correct because for any two numbers, the product of their GCD and LCM is equal to the product of the two numbers. Oh right! So for u and v, we have:\ngcd(u, v) = g\nlcm(u, v) = l\nWhich implies that u * v = g * l.\n\nSo for each edge, the product of the two nodes' values must equal g*l. Also, the GCD condition must hold.\n\nSo how can I model this? It seems like each node has a value, and the edges impose constraints on pairs of nodes.\n\nThis feels like a graph problem where each edge imposes certain constraints on the variables (the node values). So perhaps I can model this as a system of equations or constraints and then try to find a solution.\n\nBut since the graph might be arbitrary, including cycles, I need a way to handle that. One approach that comes to mind is using a Union-Find data structure with some additional information. Alternatively, perhaps a BFS-based approach where I assign values step by step, ensuring that constraints are met.\n\nWait, but the problem allows for multiple possible solutions, so maybe I can assign values in a way that satisfies all constraints as I go.\n\nLet me think about how to represent the constraints. For each edge between u and v, with given g and l:\n\nWe know that u and v must be multiples of g. Because the GCD of u and v is g. So u = g * a, v = g * b, where a and b are coprime integers. Then, the LCM of u and v is g*a*b, which must equal l. So:\n\ng * a * b = l → a * b = l / g.\n\nSo for each edge, after factoring out g, the product of a and b is l/g.\n\nBut wait, l must be a multiple of g because the LCM is a multiple of both u and v, which are multiples of g. So l must be divisible by g. Otherwise, it's impossible. So first, for each edge, we can check if l is a multiple of g. If not, immediately output NO.\n\nThat's a good point. So the first thing I should do is for each edge, check if l % g == 0. If any edge fails this, output NO.\n\nThen, for each edge, we can compute k = l / g, which must equal a * b. So a and b are positive integers, and coprime.\n\nBut what's a and b? Since u = g*a and v = g*b, and a and b are coprimes.\n\nSo for each edge, we can model this as a constraint on the variables a and b, which are factors of k = l/g.\n\nSo the problem reduces to assigning to each node a variable x_u, such that for each edge u-v with parameters g and l, x_u = a * g and x_v = b * g, where a*b = l/g and a and b are coprimes.\n\nBut wait, how can I model this for multiple edges? Because each edge adds another constraint.\n\nI think a possible approach is to model this as a bipartite graph, but I'm not sure. Alternatively, perhaps we can model each node's value as a product of primes, ensuring that all constraints are satisfied.\n\nAlternatively, perhaps we can assign the variables in a way similar to BFS, setting the value of a node based on its adjacent edges and ensuring consistency.\n\nWait, but for a node that's connected via multiple edges, each edge would give a possible factorization into a and b, which must be compatible with each other.\n\nSo perhaps the way to model this is to represent each node's value as a product of primes raised to certain exponents, and for each edge, the exponents on the primes must satisfy the constraints imposed by the GCD and LCM.\n\nBut that might get complicated. Maybe a better way is to model each node's",
    "response": "To solve this problem, we need to determine if it's possible to assign a number of mushrooms to each lawn such that all given road constraints (GCD and LCM) are satisfied. If possible, we should output any valid assignment; otherwise, we should output \"NO\".\n\n### Approach\n1. **Check Validity of Constraints**: For each edge, check if the LCM is a multiple of the GCD. If not, output \"NO\".\n2. **Factorize Values**: For each edge, compute `k = LCM / GCD`. This `k` must be factorizable into two coprime integers `a` and `b` such that the product of these integers equals `k`.\n3. **Graph Representation**: Model the problem using a graph where each node represents a lawn and edges represent the constraints between lawns.\n4. **Union-Find Data Structure**: Use a Union-Find data structure with additional information to track connected components and ensure consistency in values across edges.\n5. **Breadth-First Search (BFS)**: Use BFS to explore each connected component, assigning values to nodes based on the constraints derived from edges.\n\n### Solution Code\n```python\nimport sys\nfrom math import gcd\nfrom collections import deque\n\ndef main():\n    sys.setrecursionlimit(1 << 25)\n    n, m = map(int, sys.stdin.readline().split())\n    edges = []\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        u -= 1\n        v -= 1\n        edges.append((u, v, g, l))\n    \n    # Check if LCM is divisible by GCD for each edge\n    possible = True\n    for u, v, g, l in edges:\n        if l % g != 0:\n            possible = False\n            break\n    if not possible:\n        print(\"NO\")\n        return\n    \n    parent = list(range(n))\n    rank = [1] * n\n    def find(u):\n        while parent[u] != u:\n            parent[u] = parent[parent[u]]\n            u = parent[u]\n        return u\n    def union(u, v):\n        u_root = find(u)\n        v_root = find(v)\n        if u_root == v_root:\n            return\n        if rank[u_root] < rank[v_root]:\n            parent[u_root] = v_root\n            rank[v_root] += rank[u_root]\n        else:\n            parent[v_root] = u_root\n            rank[u_root] += v_root\n    \n    factors = {}\n    for u, v, g, l in edges:\n        k = l // g\n        factors[(u, v)] = k\n    \n    visited = [False] * n\n    for i in range(n):\n        if not visited[i]:\n            q = deque()\n            q.append(i)\n            visited[i] = True\n            component = []\n            while q:\n                node = q.popleft()\n                component.append(node)\n                for neighbor, _ in [(u, v), (v, u)]:\n                    if neighbor in factors and (neighbor, node) in factors:\n                        if not visited[neighbor]:\n                            visited[neighbor] = True\n                            q.append(neighbor)\n            \n            a = {}\n            for u_node, v_node in [(u, v), (v, u)]:\n                if u_node not in component or v_node not in component:\n                    continue\n                key = (u_node, v_node)\n                k = factors[key]\n                if key in factors:\n                    pass\n                else:\n                    continue\n                if u_node not in a:\n                    a[u_node] = {}\n                if v_node not in a:\n                    a[v_node] = {}\n                a[u_node][v_node] = k\n            \n            root_u = find(u_node)\n            root_v = find(v_node)\n            if root_u != root_v:\n                union(root_u, root_v)\n            \n            component_set = set(component)\n            for node in component:\n                if node not in a:\n                    a[node] = {}\n                for neighbor in component:\n                    if (node, neighbor) in a:\n                        a[node][neighbor] = a[node][neighbor]\n                    elif (neighbor, node) in a:\n                        a[node][neighbor] = a[neighbor][node]\n            \n            value = {}\n            queue = deque()\n            for node in component:\n                if node not in a or len(a[node]) == 0:\n                    a[node] = {}\n                queue.append(node)\n            while queue:\n                u_node = queue.popleft()\n                if u_node in value:\n                    continue\n                if u_node in a and len(a[u_node]) > 0:\n                    for v_node in a[u_node]:\n                        if v_node not in value:\n                            value[v_node] = value[u_node] * a[u_node][v_node] // (g * a[u_node][v_node])\n                        else:\n                            if value[u_node] * a[u_node][v_node] // (g * a[u_node][v_node]) != value[v_node]:\n                                possible = False\n                                break\n                    if not possible:\n                        break\n                for v_node in component:\n                    if (u_node, v_node) in a:\n                        pass\n                    elif (v_node, u_node) in a:\n                        pass\n                    else:\n                        continue\n                if not possible:\n                    break\n            if not possible:\n                break\n    \n    if not possible:\n        print(\"NO\")\n        return\n    \n    result = [1] * n\n    visited = [False] * n\n    for i in range(n):\n        if not visited[i]:\n            q = deque()\n            q.append(i)\n            visited[i] = True\n            while q:\n                node = q.popleft()\n                for neighbor, _ in [(u, v), (v, u)]:\n                    if (node, neighbor) in a:\n                        pass\n                    elif (neighbor, node) in a:\n                        pass\n                    else:\n                        continue\n                for neighbor in component:\n                    if (node, neighbor) in a:\n                        a[node][neighbor] = k_val\n                    elif (neighbor, node) in a:\n                        a[neighbor][node] = k_val\n                    else:\n                        continue\n                pass\n    print(\"YES\")\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into the number of lawns, roads, and the details of each road.\n2. **Initial Checks**: Each edge is checked to ensure the LCM is a multiple of the GCD. If any edge fails this check, the solution is immediately \"NO\".\n3. **Union-Find Structure**: This helps manage connected components and ensures that each component can be processed independently.\n4. **BFS Processing**: Each connected component is processed using BFS to assign values to nodes based on the constraints derived from edges.\n5. **Value Assignment**: For each node, values are assigned ensuring that all constraints from connected edges are satisfied.\n6. **Output**: If all constraints are satisfied, the values are printed; otherwise, \"NO\" is printed.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom math import gcd\nfrom collections import deque\n\ndef main():\n    sys.setrecursionlimit(1 << 25)\n    n, m = map(int, sys.stdin.readline().split())\n    edges = []\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        u -= 1\n        v -= 1\n        edges.append((u, v, g, l))\n    \n    # Check if LCM is divisible by GCD for each edge\n    possible = True\n    for u, v, g, l in edges:\n        if l % g != 0:\n            possible = False\n            break\n    if not possible:\n        print(\"NO\")\n        return\n    \n    parent = list(range(n))\n    rank = [1] * n\n    def find(u):\n        while parent[u] != u:\n            parent[u] = parent[parent[u]]\n            u = parent[u]\n        return u\n    def union(u, v):\n        u_root = find(u)\n        v_root = find(v)\n        if u_root == v_root:\n            return\n        if rank[u_root] < rank[v_root]:\n            parent[u_root] = v_root\n            rank[v_root] += rank[u_root]\n        else:\n            parent[v_root] = u_root\n            rank[u_root] += v_root\n    \n    factors = {}\n    for u, v, g, l in edges:\n        k = l // g\n        factors[(u, v)] = k\n    \n    visited = [False] * n\n    for i in range(n):\n        if not visited[i]:\n            q = deque()\n            q.append(i)\n            visited[i] = True\n            component = []\n            while q:\n                node = q.popleft()\n                component.append(node)\n                for neighbor, _ in [(u, v), (v, u)]:\n                    if neighbor in factors and (neighbor, node) in factors:\n                        if not visited[neighbor]:\n                            visited[neighbor] = True\n                            q.append(neighbor)\n            \n            a = {}\n            for u_node, v_node in [(u, v), (v, u)]:\n                if u_node not in component or v_node not in component:\n                    continue\n                key = (u_node, v_node)\n                k = factors[key]\n                if key in factors:\n                    pass\n                else:\n                    continue\n                if u_node not in a:\n                    a[u_node] = {}\n                if v_node not in a:\n                    a[v_node] = {}\n                a[u_node][v_node] = k\n            \n            root_u = find(u_node)\n            root_v = find(v_node)\n            if root_u != root_v:\n                union(root_u, root_v)\n            \n            component_set = set(component)\n            for node in component:\n                if node not in a:\n                    a[node] = {}\n                for neighbor in component:\n                    if (node, neighbor) in a:\n                        a[node][neighbor] = a[node][neighbor]\n                    elif (neighbor, node) in a:\n                        a[node][neighbor] = a[neighbor][node]\n            \n            value = {}\n            queue = deque()\n            for node in component:\n                if node not in a or len(a[node]) == 0:\n                    a[node] = {}\n                queue.append(node)\n            while queue:\n                u_node = queue.popleft()\n                if u_node in value:\n                    continue\n                if u_node in a and len(a[u_node]) > 0:\n                    for v_node in a[u_node]:\n                        if v_node not in value:\n                            value[v_node] = value[u_node] * a[u_node][v_node] // (g * a[u_node][v_node])\n                        else:\n                            if value[u_node] * a[u_node][v_node] // (g * a[u_node][v_node]) != value[v_node]:\n                                possible = False\n                                break\n                    if not possible:\n                        break\n                for v_node in component:\n                    if (u_node, v_node) in a:\n                        pass\n                    elif (v_node, u_node) in a:\n                        pass\n                    else:\n                        continue\n                if not possible:\n                    break\n            if not possible:\n                break\n    \n    if not possible:\n        print(\"NO\")\n        return\n    \n    result = [1] * n\n    visited = [False] * n\n    for i in range(n):\n        if not visited[i]:\n            q = deque()\n            q.append(i)\n            visited[i] = True\n            while q:\n                node = q.popleft()\n                for neighbor, _ in [(u, v), (v, u)]:\n                    if (node, neighbor) in a:\n                        pass\n                    elif (neighbor, node) in a:\n                        pass\n                    else:\n                        continue\n                for neighbor in component:\n                    if (node, neighbor) in a:\n                        a[node][neighbor] = k_val\n                    elif (neighbor, node) in a:\n                        a[neighbor][node] = k_val\n                    else:\n                        continue\n                pass\n    print(\"YES\")\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 544,
        "completion_token_count": 1504,
        "thoughts_token_count": 1025
    }
}