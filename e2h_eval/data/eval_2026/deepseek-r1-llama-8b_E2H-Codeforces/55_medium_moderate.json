{
    "start": 1758287864.3989778,
    "end": 1758290201.2846122,
    "start-formatted": "2025-09-19 22:17 KST",
    "end-formatted": "2025-09-19 22:56 KST",
    "gpu": 2,
    "pid": 55,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Minimum Ternary String\n\nYou are given a ternary string (it is a string which consists only of characters '0', '1' and '2').You can swap any two adjacent (consecutive) characters '0' and '1' (i.e. replace \"01\" with \"10\" or vice versa) or any two adjacent (consecutive) characters '1' and '2' (i.e. replace \"12\" with \"21\" or vice versa).For example, for string \"010210\" we can perform the following moves:   \"010210\" $$$\\rightarrow$$$ \"100210\";  \"010210\" $$$\\rightarrow$$$ \"001210\";  \"010210\" $$$\\rightarrow$$$ \"010120\";  \"010210\" $$$\\rightarrow$$$ \"010201\". Note than you cannot swap \"02\" $$$\\rightarrow$$$ \"20\" and vice versa. You cannot perform any other operations with the given string excluding described above.You task is to obtain the minimum possible (lexicographically) string by using these swaps arbitrary number of times (possibly, zero).String $$$a$$$ is lexicographically less than string $$$b$$$ (if strings $$$a$$$ and $$$b$$$ have the same length) if there exists some position $$$i$$$ ($$$1 \\le i \\le |a|$$$, where $$$|s|$$$ is the length of the string $$$s$$$) such that for every $$$j < i$$$ holds $$$a_j = b_j$$$, and $$$a_i < b_i$$$.\n\n## Input\nThe first line of the input contains the string $$$s$$$ consisting only of characters '0', '1' and '2', its length is between $$$1$$$ and $$$10^5$$$ (inclusive).\n\n## Output\nPrint a single string — the minimum possible (lexicographically) string you can obtain by using the swaps described above arbitrary number of times (possibly, zero).\n\n## Example\n### Input\n['100210', '11222121', '20']\n\n### Output\n['001120', '11112222', '20']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "Okay, so I have this problem where I need to find the lexicographically smallest possible string after performing a series of allowed swaps. The allowed swaps are only between adjacent '0's and '1's, or adjacent '1's and '2's. Hmm, right, so for example, I can swap '0' and '1' if they're next to each other, but not '0' and '2'. Similarly, '1' and '2' can be swapped, but '0' and '2' cannot.\n\nLet me think about what this means for the arrangement of characters. So, the key is that certain characters can be reordered relative to each other. For instance, all '0's can be moved past '1's by swapping them one by one. But '0's cannot move past '2's because we can't swap '0' and '2' directly. Similarly, '1's can be moved past '2's, but not past '0's unless there's a way through another character.\n\nWait, maybe it's better to model this as the ability to reorder within certain groups. Let's see: the '0's can only be swapped with '1's, which implies that in the final string, the order of '0's relative to '1's can be changed. But '0's and '2's can't be swapped, so their relative order must stay the same. Similarly, '1's can be swapped with '2's, so their order can be adjusted, but '1's can't cross over '0's without a '1' in between.\n\nWait, no. Let's clarify: since '0's can be swapped with '1's, any '0' can be moved past any number of '1's, but not past '2's. Similarly, '2's can be moved past '1's, but not past '0's. So, the relative order of '0's and '2's is fixed because you can't swap them directly. So, for example, if the original string has a '0' before a '2', you can't change that order because there's no way to swap them.\n\nSo, the idea is that all '0's can be rearranged among themselves and with '1's, but they can't cross over '2's. Similarly, '2's can be rearranged among themselves and with '1's, but can't cross over '0's.\n\nThis suggests that the minimal lex string would have all '0's as far left as possible, followed by '1's, then '2's. But wait, no, because the relative positions of '0's and '2's are fixed. So if in the original string, a '0' comes before a '2', that's how it must remain. Similarly, if a '2' comes before a '0', it can't be changed.\n\nWait, but perhaps I can arrange the '0's and '1's in such a way that the '0's are as left as possible, but without disturbing the '2's that are before them. Or vice versa.\n\nHmm, maybe the correct approach is to process the string in such a way that for each position, we determine the earliest possible character that can appear there given the constraints.\n\nAlternatively, perhaps we can partition the string into three parts: the 0s, the 1s, and the 2s, but considering their initial order relative to each other.\n\nWait, perhaps the correct approach is to consider that the '0's can be reordered among themselves and with '1's, but cannot cross '2's. Similarly, '1's can be reordered with '2's but cannot cross '0's. So, the relative order between '0's and '2's is fixed, but within the '0's and '1's, and within the '1's and '2's, they can be rearranged.\n\nSo the minimal string would have the '0's as early as possible, followed by '1's arranged as early as possible, and then '2's as early as possible, but considering that some '0's may come before some '2's, which can't be changed.\n\nWait, but how? Let's think of an example. Suppose the string is \"210\". Then, the '2' is first, followed by '1' and '0'. Since '0' can't pass '2', the '0' must stay after the '2'. But between '2' and '1', since '1's can be swapped with '2's, the '1' can be moved to the front, resulting in \"120\" or \"210\" → \"120\". Wait, no. Because the '1' can be swapped with '2' to get '21' → '12'. So the string becomes '120' → '210' can be transformed into '120', which is lex smaller than '210'.\n\nWait, but in that case, the '0' is still after the '2'. So, the '2' comes before the '0' because in the original string, that's the case.\n\nAnother example: suppose the string is \"01\". We can swap them to get '10', which is larger. So the minimal is '01'? No, wait, no. Because the allowed swaps are only between '0' and '1', so yes, '01' can become '10', which is larger. So the minimal is '01'.\n\nWait, wait, no. Wait, '01' is already lex smaller than '10'. So why would we want to swap them? Oh, because perhaps it's possible to get a lex smaller string by rearranging other parts. But in this case, '01' is already the smallest possible.\n\nWait, perhaps I'm getting confused. Let me think again. The problem is to find the lex smallest possible string by performing any number of allowed swaps. So, for each pair of '0' and '1', we can swap them as many times as needed to get them in any order relative to each other, as long as we can swap adjacent pairs.\n\nWait, no. Because swapping two adjacent '0's and '1's can allow us to permute the '0's and '1's in any order. Because, for example, '01' can be swapped to '10', and then if there's another '0' or '1' next to it, further swaps can bring it around.\n\nWait, actually, when you have a sequence of '0's and '1's, you can perform swaps to sort them in any order. Because you can perform a bubble-sort-like process to bring each '0' or '1' to its desired position, as long as they can be swapped.\n\nSo, for the '0's and '1's, their relative order can be completely rearranged. So, within the '0's and '1's, you can arrange them in any order. So, for example, the substring consisting of '0's and '1's can be sorted into all '0's followed by all '1's, regardless of their initial order.\n\nSimilarly, the '1's and '2's can be rearranged into any order because you can swap them. So, the substring of '1's and '2's can be sorted into all '1's followed by all '2's.\n\nBut the issue arises when a '0' appears after a '2' in the string. Because you can't swap '0' and '2', you can't change their relative order. So, any '0' that comes before a '2' in the original string must also come before that '2' in the final string. Similarly, any '2' that comes before a '0' in the original string must also come before that '0' in the final string.\n\nSo, the plan is:\n\n1. Split the string into three regions: the part before any '2's, the '2's, and the part after the '2's. Wait, no. Alternatively, the string can be divided into segments where the order of '0's and '2's is fixed. So, for the entire string, the relative order of '0's and '2's is preserved. However, within the '0's and '1's, and within the '1's and '2's, we can rearrange them.\n\nWait, perhaps the correct approach is to process the string and for each '0' and '2', their relative order must remain as in the original string. So, the '0's that are before a '2' in the original string cannot be moved after that '2' in the final string.\n\nSo, the minimal lex string will have the '0's arranged as early as possible, but respecting the relative order of '0's and '2's.\n\nBut how? Let's think differently.\n\nWe can model the string as being composed of three independent groups:\n\n- Group A: consists of all '0's and '1's that come before any '2's in the string.\n- Group B: consists of all '2's.\n- Group C: consists of all '1's and '0's that come after the last '2' in the string.\n\nWait, no, perhaps that's not accurate. Because, for example, a '2' may be somewhere in the middle, and after it, there are '1's and '0's. Those '1's and '0's can be rearranged among themselves, but cannot cross over the '2's that precede them.\n\nWait, maybe the string can be divided into segments separated by '2's, and within each segment (which contains only '0's and '1's), we can sort the characters to minimize the lex order.\n\nAdditionally, the '2's themselves can be rearranged among themselves, but wait, no, because '2's can't be swapped with '0's or '1's except '1's. So, can '2's be reordered relative to each other?\n\nYes. Because two adjacent '2's can't be swapped, but if there's a '1' in between, then each '2' can be moved past '1's. So, for example, \"221\" can be transformed into \"212\", then into \"122\". So, the two '2's can be reordered, but only by moving them through '1's.\n\nWait, but in the first step, \"221\" → \"212\" (swap second and third characters?), no, because '2's can't be swapped. Wait, no, because '2's can only be swapped with '1's. So, in \"221\", the first two '2's are adjacent and can't be swapped. So, the order of '2's relative to each other can't be changed unless they're separated by '1's.\n\nWait, this complicates things. So, if the string is \"2221\", can the '2's be reordered? Yes, because each '2' can be swapped with the '1's to the right. So, the '1' can be moved to the end, and the '2's can be arranged in any order.\n\nBut if the string is \"212\", can the '2's be reordered? Let's see:\n\nOriginal string: 2 1 2.\n\nWe can swap the '1' and the second '2' to get 2 2 1.\n\nThen, the first two '2's can't be swapped, so the first '2' stays in the first position, the second '2' is in the second, and the '1' is last.\n\nSo, the relative order of the two '2's is preserved. Wait, but in this case, the two '2's were already in order, so their order didn't change.\n\nWhat if the string is \"21\"? They can be swapped to \"12\".\n\nWait, so in general, '2's can be reordered with '1's, but not among themselves unless via '1's. So, the relative order of '2's can be changed if they are separated by '1's.\n\nThis complicates things further. So perhaps it's better to think of the entire string as consisting of three separate sequences:\n\n- All '0's, which can be reordered with '1's.\n- All '1's, which can be reordered with '0's and '2's.\n- All '2's, which can be reordered with '1's.\n\nBut this seems too vague.\n\nAlternatively, perhaps the minimal lex string is achieved by greedily placing the smallest possible character at each position, while respecting the constraints on the order of '0's and '2's.\n\nSo, let's think about building the result character by character, from left to right.\n\nAt each step, choose the smallest possible character available, given the constraints.\n\nBut what's the constraint? The constraint is that once a '0' is placed, all subsequent '2's cannot come before it. Wait, no. Because '0's can't cross '2's.\n\nWait, suppose I have a '0' in the current position. Then, any '2's that were originally before this '0' must also be before it in the final string. So, if in the original string, a '2' comes before a '0', that '2' must be placed before that '0' in the final string.\n\nSimilarly, any '0's that are after '2's in the original string can't be moved before those '2's.\n\nSo, the idea is to process the string and determine for each position, the earliest possible character that can be placed there, considering the constraints of '0's and '2's.\n\nBut how?\n\nPerhaps, we can model the problem by keeping track of the earliest possible position for each type of character.\n\nWait, here's an alternative approach inspired by the problem's constraints.\n\nThe minimal string is constructed by first placing all '0's as early as possible, followed by '1's, and then '2's. However, the placement of '0's is limited by any '2's that were before them in the original string.\n\nSo, for example, suppose the original string has a '0' at position i and a '2' at position j, where j < i. Then, in the final string, the '2' must appear before the '0'. So, during processing, once a '2' is placed, any '0's that come after it in the original string can't be placed before any '2's that were before them.\n\nSo, perhaps the steps are:\n\n1. Separate the string into three parts: the '0's, the '1's, and the '2's, along with their original order relative to each other.\n\nWait, but it's more complicated than that because the '0's and '1's can be interleaved with '2's.\n\nAnother approach: process the string from left to right, and whenever a '0' is encountered, note that all '2's before it must come before it in the final string. Similarly, any '2's encountered can be moved as far right as possible, but subject to the constraints.\n\nAlternatively, think of the string as a sequence where '0's can be moved past '1's, but '0's cannot be moved past '2's, and '2's can be moved past '1's, but not past '0's.\n\nSo, the minimal string is built by arranging the '0's first, followed by '1's, then '2's, but any '0's that are after '2's in the original string can't be moved before the '2's.\n\nWait, perhaps the minimal string is obtained by grouping the string into sections where all '0's are placed before '2's, and within each section, the '0's and '1's are arranged in the minimal order.\n\nWait, maybe not. Let's think of the string as being made up of three segments:\n\n- The prefix of '0's and '1's before the first '2'.\n- The '2's that follow.\n- The suffix of '1's and '0's after the last '2'.\n\nWait, but that might not capture all cases, especially when '2's are interspersed with '0's and '1's.\n\nAn alternative idea is to split the string into blocks where each block is either entirely '0's and '1's, or entirely '2's. Between these blocks, you can't have '0's and '2's mixed.\n\nWait, perhaps that's not the case. For example, the string \"010210\" is given as an example, and after some swaps, it becomes \"001120\".\n\nIn this case, the '0's and '1's are being reordered, and the '2's are being moved around.\n\nSo, perhaps the minimal string can be built by processing each run of '0's and '1's, and '2's, and within each run, sorting the characters to be as small as possible.\n\nWait, but '2's can be reordered among themselves if there are '1's separating them.\n\nThis is getting a bit complicated. Maybe I should look for a pattern or a way to model the problem.\n\nAnother approach: since '0's can only be swapped with '1's, and '1's can be swapped with '2's, the relative order of '0's and '2's is fixed, but within the '0's and '1's, and within the '1's and '2's, they can be rearranged.\n\nSo, the minimal lex string would have all '0's as early as possible, but any '0's that are after a '2' in the original string can't be moved before that '2'.\n\nSimilarly, the '2's can be moved past '1's, but not past '0's.\n\nWait, perhaps the correct approach is to:\n\n1. Split the string into runs of '0's, '1's, and '2's. But also track the relative positions of '0's and '2's.\n\n2. For each '0' in the string, if it comes before any '2's, it can be moved to the left as much as possible, but not past any '2's that were originally before it.\n\n3. For each '2' in the string, it can be moved past any '1's to the right, but not past any '0's that were originally before it.\n\nWait, but how do we manage that?\n\nAlternatively, let's model the string as a list where the relative order of '0's and '2's is fixed. But within the '0's and '1's, and within the '1's and '2's, the characters can be rearranged in any order.\n\nSo, the minimal string would consist of all '0's that can be moved to the front (before any '2's), followed by all '1's and '2's that can be arranged in a way that '1's come before '2's, but also considering the relative order of '0's and '2's.\n\nWait, perhaps it's better to think in terms of the following steps:\n\n1. Identify all the positions of '0's, '1's, and '2's in the string.\n\n2. For the '0's, collect all their indices and sort them in the order they can be arranged, which is that they can be moved past '1's but not '2's. So, the '0's can be moved to the earliest possible positions, but any '0's that are after '2's in the original string can't be moved before those '2's.\n\n3. Similarly, for the '2's, they can be moved past '1's but not '0's. So, '2's can be moved to the latest possible positions, but any '2's that are before '0's in the original string can't be moved after those '0's.\n\nHmm, perhaps that's the way to go.\n\nSo, the minimal string would have:\n\n- All '0's that can be moved to the left, before any '2's, arranged in the earliest possible positions, possibly interleaved with '1's which can be arranged as well.\n\nWait, perhaps it's better to create a new string by greedily choosing the smallest possible character at each step, ensuring that the choice doesn't violate the constraints.\n\nLet's try to model this.\n\nInitialize a pointer for each character group ('0's, '1's, '2's).\n\nAs we iterate through the original string, for each character:\n\n- If it's a '0', we can include it in the output, but also note that any '2's that came before it in the original string must come before this '0' in the output.\n\nWait, but how to track that.\n\nAlternatively, perhaps the process can be broken down into the following:\n\n- All '0's that are before any '2's can be arranged to come before any '2's.\n\n- Within the '0's and '1's before the first '2', arrange them in the minimal order (all '0's first, then '1's).\n\n- The '2's can be arranged among themselves, but any '0's after them in the original string can't be moved before them.\n\nWait, perhaps not. Another approach is to realize that the relative order of '0's and '2's is fixed. So, if in the original string, a '0' comes before a '2', then in the final string, that '0' must appear before the '2'. Similarly, if a '2' comes before a '0' in the original, it must remain before in the final string.\n\nSo, the minimal string is constructed by:\n\n1. For each position, the earliest possible character is chosen, considering that any '0's that are before '2's must stay in their relative order.\n\nWait, perhaps the correct approach is to process the string and for each character, decide whether to take it immediately or wait for a smaller character that can be brought forward.\n\nBut how to model that.\n\nAnother idea: the minimal string can be formed by first taking all '0's that can be moved to the front, then '1's, then '2's, but ensuring that '0's that were after '2's in the original string are placed after the '2's.\n\nWait, but that's not correct. Because '0's that are after '2's can't be moved before the '2's, but the '1's can be moved past the '2's, which allows the '0's to be moved earlier.\n\nWait, perhaps the minimal string is achieved by:\n\n- Arrange all '0's as early as possible, but any '0's that are after '2's in the original string can't be moved before the '2's.\n\n- Arrange all '1's as early as possible, moving them past '2's.\n\n- Arrange the '2's as late as possible, but moving them past '1's.\n\nWait, perhaps the minimal string is obtained by:\n\nFor each '0' in the original string, if all '2's that are before it in the original string are placed before it in the final string, then this '0' can be placed as early as possible. Otherwise, it can't be moved before the '2's.\n\nBut this is getting a bit abstract.\n\nMaybe the correct way is to model the problem as follows:\n\nWe can represent the string as a list of events, where each event is a character and its position. Then, for each '0', we note the positions of '2's that come before it. These '2's must be placed before the '0' in the final string.\n\nSimilarly, for each '2', any '0's that come after it in the original string cannot be moved before it in the final string.\n\nSo, the minimal string would have all '0's that can be moved to the front, followed by '1's, followed by '2's, but ensuring that any '0's that were after '2's in the original string are placed after the '2's.\n\nWait, but that's not necessarily the case because '1's can be moved past '2's, allowing '0's to be moved earlier.\n\nAlternatively, perhaps the minimal string is the minimal possible by treating '0's and '1's as a single group that can be reordered, and '2's as another group that can be reordered among themselves and with '1's, but '0's and '2's cannot be reordered.\n\nSo, the process could be:\n\n- Collect all '0's and '1's, in the order they appear, but considering that '0's can be moved past '1's.\n\n- Collect all '2's, in the order they appear, but considering that '2's can be moved past '1's.\n\nBut how does that affect the overall order.\n\nAlternatively, here's a concrete plan:\n\nWe can process the string from left to right, and for each character, decide whether it can be moved to the earliest possible position, considering the constraints.\n\nLet me think of the string as consisting of three separate lists:\n\n- zeros: a list of indices of '0's in the original string.\n- ones: a list of indices of '1's in the original string.\n- twos: a list of indices of '2's in the original string.\n\nNow, the goal is to arrange the characters in the output such that:\n\n- All '0's that are before any '2's in the original string are placed before the '2's in the output.\n\n- All '1's can be reordered among themselves and with '0's and '2's, but '0's cannot be reordered with '2's.\n\nWait, perhaps the minimal string can be built by:\n\n- First, collect all '0's that are before any '2's in the original string. These can be placed as early as possible.\n\n- Then, collect all '1's and '2's, but the '1's can be arranged in any order relative to '2's, as long as '1's can be moved past '2's.\n\nWait, no. Because '1's can be moved past '2's, but '0's can't be moved past '2's.\n\nWait, perhaps the correct approach is to construct the minimal string by:\n\n1. Place all '0's that are before any '2's in the original string, in their original order, but as early as possible.\n\n2. Then, place all '1's and '2's, but arrange them in a way that '1's come before '2's, considering that '1's can be moved past '2's.\n\nBut again, this is not precise.\n\nAlternative idea inspired by the problem's constraints:\n\nThe allowed swaps permit '0's and '1's to be reordered among themselves, and '1's and '2's to be reordered among themselves. '0's and '2's cannot be reordered.\n\nThus, the minimal string is achieved by:\n\n- For all '0's and '1's, arrange them in a way that '0's come before '1's.\n\n- For all '1's and '2's, arrange them in a way that '1's come before '2's.\n\nBut, the relative order of '0's and '2's is fixed.\n\nSo, the minimal string is built by:\n\n- All '0's that are before any '2's in the original string are placed first, followed by the '1's that are before any '2's, then the '2's.\n\nBut wait, that's not correct because '1's can be moved past '2's.\n\nWait, perhaps the correct approach is:\n\nThe minimal string is the concatenation of:\n\na) All '0's that are before any '2's in the original string, arranged in the earliest possible order (all '0's first, then '1's that can be moved past '0's).\n\nb) All '1's and '2's, arranged such that '1's come before '2's, but also considering that '1's can be moved past '2's.\n\nNo, perhaps not.\n\nAlternatively, perhaps the minimal string is the minimal possible arrangement of the '0's and '1's, followed by the '2's arranged in their minimal way.\n\nWait, perhaps the correct way is to consider that the '0's can be reordered among themselves and with '1's, so they can be arranged in any order among themselves and '1's. Similarly, the '2's can be reordered with '1's.\n\nSo, perhaps the minimal string is:\n\n- All '0's arranged first, followed by all '1's, followed by all '2's.\n\nBut, any '0's that are after '2's in the original string cannot be moved before the '2's.\n\nWait, this is getting confusing.\n\nLet me think about the sample input.\n\nSample Input 1: '100210'\n\nThe sample output is '001120'.\n\nLooking at the original string: '1','0','0','2','1','0'.\n\nThe output is '0','0','1','1','2','0'.\n\nWait, but the '2' is after the '1's, which can be moved past '2's.\n\nWait, perhaps the process is:\n\n- The '0's can be moved to the front, but any '0's after '2's can't be moved before the '2's.\n\nBut in the original string, the first '0' is at position 2, then another at 3, then '2' at 4, etc.\n\nSo, the '0's at positions 2 and 3 can be moved to the front, but the '0' at position 6 (original index 5?) can't be moved before the '2' at position 4.\n\nWait, perhaps the output is arranged as:\n\nFirst, all '0's that can be moved before any '2's, followed by '1's and '2's arranged in minimal order.\n\nBut I'm not sure.\n\nAlternative Idea:\n\nThe problem can be approached by considering the following:\n\nThe allowed swaps mean that:\n\n- Any '0' can be moved past any number of '1's to the left.\n\n- Any '1' can be moved past any number of '2's to the left.\n\nBut '0's cannot be moved past '2's, and '2's cannot be moved past '0's.\n\nThus, the relative order of '0's and '2's is fixed. So, for example, if a '0' appears before a '2' in the original string, it must appear before that '2' in the final string. Conversely, if a '2' appears before a '0', it must remain before in the final string.\n\nWithin the '0's and '1's, the '0's can be arranged in any order relative to '1's.\n\nWithin the '1's and '2's, the '1's can be arranged in any order relative to '2's.\n\nSo, the minimal string is constructed as follows:\n\n1. All '0's that are before any '2's in the original string are placed as early as possible.\n\n2. Then, all '1's that are before any '2's in the original string are placed, followed by '2's.\n\nWait, but that's not considering that '1's can be moved past '2's.\n\nAlternatively, the minimal string is built by:\n\n- Arrange all '0's that are before any '2's, followed by all '1's that are before any '2's, then arrange the '2's and '1's in such a way that '1's come before '2's.\n\nBut I'm not sure.\n\nAnother Idea:\n\nLet me process the string and for each character, decide whether to include it or wait for a smaller character that can be moved into place.\n\nWe can model this using pointers for each character type.\n\nLet's have three pointers: zero_ptr, one_ptr, two_ptr.\n\nInitially, all are at 0.\n\nWe iterate through the original string from left to right.\n\nFor each character c in s:\n\n- If c is '0':\n\n   - If it's a '0' that comes before any '2's in the original string, add it to the result.\n\n   - Else, add it to a buffer for later.\n\nBut how to track whether a '0' comes before any '2's.\n\nAlternatively, perhaps we can precompute for each '0' whether there is any '2' to its right in the original string. If so, then this '0' can't be moved before any '2's that are to its left.\n\nWait, that's not exactly correct.\n\nWait, the presence of a '2' to the left of a '0' in the original string means that the '0' can't be moved before that '2' in the final string.\n\nSo, for each '0' in the string, we need to check if any '2's are to the left of it. If yes, then in the final string, this '0' must appear after those '2's.\n\nSo, perhaps for each '0', if there exists a '2' with index less than the current '0's index, then in the final string, the '0' can't be placed before any such '2's.\n\nThis complicates the decision of when to place a '0' in the result.\n\nSo, the approach would be:\n\n- As we process each character in the original string, we can decide whether to include it in the result or not.\n\n- For a '0', if adding it to the result doesn't violate any constraints (i.e., no '2's that are supposed to come before it in the result have been added yet), then include it.\n\n- Similarly, for a '1', it can be included if it's the smallest possible character available.\n\nWait, perhaps the correct way is to maintain a priority queue of available characters, considering that '0's can be placed before '1's and '2's, but '2's can't be placed before '0's.\n\nWait, perhaps a greedy algorithm where at each step, we select the smallest possible character available, ensuring that any '0's selected don't have a '2' that was earlier in the original string and hasn't been placed yet.\n\nBut how to model this.\n\nAlternative Plan:\n\nThe minimal string can be constructed by:\n\n1. All '0's that are before any '2's in the original string are placed first, in the order they appear, but arranged to be as early as possible.\n\n2. Then, all '1's that are before any '2's in the original string, arranged to be as early as possible.\n\n3. Then, all '2's, arranged as late as possible, but with '1's moved past them.\n\nWait, perhaps not.\n\nAnother Idea:\n\nWe can model the problem as follows:\n\n- The relative order of '0's and '2's is fixed.\n\n- The relative order of '1's among themselves can be changed.\n\n- The relative order of '2's among themselves can be changed.\n\nWait, no. Because '2's can be swapped with '1's, but not with '0's. So, two '2's can be reordered as long as there's a '1' between them.\n\nSo, the relative order of '2's can be changed, but not if they are adjacent without '1's in between.\n\nThis makes it difficult to model.\n\nPerhaps a better approach is to represent the string as a list and simulate the swaps, but that's not feasible for large strings (up to 1e5 in length).\n\nThus, an efficient algorithm is needed.\n\nAlternative Idea Inspired by Two-Pointer Approach:\n\nWe can split the string into three parts:\n\n- Part A: '0's that are before any '2's in the original string.\n\n- Part B: '1's and '2's, with '1's able to be reordered among themselves and with '2's.\n\n- Part C: '0's that are after any '2's in the original string.\n\nWait, but Part C's '0's can't be moved before any '2's in the original string.\n\nSo, the minimal string will be:\n\nPart A (all '0's before any '2's, arranged to be as early as possible) + minimal arrangement of Part B (all '1's and '2's arranged to be as small as possible) + Part C (the '0's after '2's, which can't be moved before '2's).\n\nBut how to arrange Part B.\n\nIn Part B, the '1's can be reordered with '2's to form a minimal string.\n\nSo, within Part B, the minimal arrangement is all '1's followed by '2's.\n\nWait, because '1's can be moved past '2's to the left, making them appear before '2's.\n\nBut wait, in the sample input, the '2' is moved after the '1's.\n\nWait, perhaps within Part B, the '1's can be moved to the left of the '2's, thus forming a substring of '1's followed by '2's.\n\nSo, putting it all together:\n\nThe minimal string is:\n\n- All '0's from Part A (those before any '2's in the original string), arranged in their original order, but as early as possible.\n\n- Then, all '1's from Part B (including those before any '2's in the original string), followed by all '2's from Part B, arranged so that '1's come before '2's.\n\n- Then, all '0's from Part C (after any '2's in the original string), in their original order.\n\nBut how to determine which '0's belong to Part A and Part C.\n\nWait, perhaps:\n\nPart A includes all '0's that appear before the first '2' in the string.\n\nPart C includes all '0's that appear after the last '2' in the string.\n\nThe '1's in the string are all considered in Part B.\n\nSo, the minimal string is:\n\nA_part + [rearranged B_part] + C_part.\n\nWhere:\n\nA_part is all '0's before the first '2', in their original order.\n\nC_part is all '0's after the last '2', in their original order.\n\nB_part is the '1's and '2's between the first and last '2's, inclusive.\n\nIn B_part, the '1's can be reordered to come before '2's, and the '2's can be reordered among themselves.\n\nWait, but how to handle the '2's in B_part.\n\nBecause in B_part, '2's can be reordered among themselves via '1's.\n\nSo, the minimal arrangement for B_part is all '1's followed by all '2's.\n\nThus, the final string is:\n\nA_part + (B_part's '1's followed by B_part's '2's) + C_part.\n\nBut wait, the '2's in B_part are not just the ones after the first '2'; they include all '2's in the string.\n\nWait, no. Let's re-ex",
    "response": "To solve this problem, we need to find the lexicographically smallest string possible by performing allowed adjacent swaps. The allowed swaps are between '0' and '1', and between '1' and '2'. However, '0's and '2's cannot be directly swapped, so their relative order must remain as in the original string.\n\n### Approach\nThe approach involves breaking down the string into three parts:\n1. **Part A**: All '0's that appear before the first '2' in the original string.\n2. **Part B**: The substring from the first '2' (inclusive) to the last '2' (inclusive). Within this part, '1's can be reordered to come before '2's, and '2's can be reordered among themselves.\n3. **Part C**: All '0's that appear after the last '2' in the original string.\n\nThe minimal string is constructed by concatenating:\n- Part A, which consists of all '0's before the first '2'.\n- The rearranged Part B, which is all '1's followed by all '2's.\n- Part C, which consists of all '0's after the last '2'.\n\n### Solution Code\n```python\ns = input().strip()\n\n# Split the string into Part A, B, and C\nfirst_two = s.find('2')\nif first_two == -1:\n    # No '2's in the string; just sort the string\n    if all(c in {'0', '1'} for c in s):\n        print(''.join(sorted(s)))\n    else:\n        # If there are '2's, but none found, which shouldn't happen\n        pass\nelse:\n    last_two = s.rfind('2')\n    part_a = s[:first_two]\n    part_b = s[first_two:last_two+1]\n    part_c = s[last_two+1:]\n\n    # Process Part A: collect all '0's, then '1's\n    a_zeros = []\n    a_ones = []\n    for c in part_a:\n        if c == '0':\n            a_zeros.append(c)\n        elif c == '1':\n            a_ones.append(c)\n    a_result = a_zeros + a_ones\n\n    # Process Part B: collect all '1's and '2's, then arrange '1's first, '2's next\n    b_chars = list(part_b)\n    b_ones = []\n    b_twos = []\n    for c in b_chars:\n        if c == '1':\n            b_ones.append(c)\n        elif c == '2':\n            b_twos.append(c)\n    b_result = b_ones + b_twos\n\n    # Process Part C: same as Part A, collect '0's in order\n    c_zeros = []\n    c_ones = []\n    for c in part_c:\n        if c == '0':\n            c_zeros.append(c)\n        elif c == '1':\n            c_ones.append(c)\n    c_result = c_zeros + c_ones  # though these '0's can't be moved before '2's, so their order is fixed\n\n    # Concatenate all parts\n    result = a_result + b_result + c_result\n\n    # Now, handle the case where there are no '2's at all\n    if first_two == -1:\n        # Then, all '0's and '1's can be sorted\n        # But also, need to ensure that any '0's after '2's are not considered (but since first_two is -1, there are no '2's)\n        # So, treat the entire string as Part B\n        result = ''.join(sorted(s))\n    \n    print(''.join(result))\n```\n\n### Explanation\n1. **Identify Parts**: The string is split into three parts based on the positions of '2's.\n2. **Process Part A**: Collect all '0's followed by '1's before the first '2'.\n3. **Process Part B**: Rearrange '1's to come before '2's and collect them in the minimal order.\n4. **Process Part C**: Collect all '0's after the last '2' in their original order.\n5. **Concatenate Results**: Combine the processed parts to form the minimal lexicographical string.\n\nThis approach ensures that the relative order of '0's and '2's is preserved while allowing '1's to be reordered to achieve the smallest possible string.",
    "ground_truth": "N/A",
    "extracted_answer": "s = input().strip()\n\n# Split the string into Part A, B, and C\nfirst_two = s.find('2')\nif first_two == -1:\n    # No '2's in the string; just sort the string\n    if all(c in {'0', '1'} for c in s):\n        print(''.join(sorted(s)))\n    else:\n        # If there are '2's, but none found, which shouldn't happen\n        pass\nelse:\n    last_two = s.rfind('2')\n    part_a = s[:first_two]\n    part_b = s[first_two:last_two+1]\n    part_c = s[last_two+1:]\n\n    # Process Part A: collect all '0's, then '1's\n    a_zeros = []\n    a_ones = []\n    for c in part_a:\n        if c == '0':\n            a_zeros.append(c)\n        elif c == '1':\n            a_ones.append(c)\n    a_result = a_zeros + a_ones\n\n    # Process Part B: collect all '1's and '2's, then arrange '1's first, '2's next\n    b_chars = list(part_b)\n    b_ones = []\n    b_twos = []\n    for c in b_chars:\n        if c == '1':\n            b_ones.append(c)\n        elif c == '2':\n            b_twos.append(c)\n    b_result = b_ones + b_twos\n\n    # Process Part C: same as Part A, collect '0's in order\n    c_zeros = []\n    c_ones = []\n    for c in part_c:\n        if c == '0':\n            c_zeros.append(c)\n        elif c == '1':\n            c_ones.append(c)\n    c_result = c_zeros + c_ones  # though these '0's can't be moved before '2's, so their order is fixed\n\n    # Concatenate all parts\n    result = a_result + b_result + c_result\n\n    # Now, handle the case where there are no '2's at all\n    if first_two == -1:\n        # Then, all '0's and '1's can be sorted\n        # But also, need to ensure that any '0's after '2's are not considered (but since first_two is -1, there are no '2's)\n        # So, treat the entire string as Part B\n        result = ''.join(sorted(s))\n    \n    print(''.join(result))",
    "score": 0,
    "metadata": {
        "prompt_token_count": 528,
        "completion_token_count": 931,
        "thoughts_token_count": 8193
    }
}