{
    "start": 1758278106.005902,
    "end": 1758278310.4442537,
    "start-formatted": "2025-09-19 19:35 KST",
    "end-formatted": "2025-09-19 19:38 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "Okay, so I have this problem to solve where I need to determine if it's possible to assign Rebel spaceships to bases in such a way that no two paths between them intersect. Hmm, the paths are straight lines from each base to their assigned spaceship. And the condition is that any two of these paths shouldn't cross each other in the galaxy plane.\n\nLet me think about what this means. Oh right, it's similar to matching in a bipartite graph but with some geometric constraints. So first, the problem is to find a perfect matching between R spaceships and B bases. But not just any matching—each pair's connecting line must not intersect with any others.\n\nWait, so how can I model this? Maybe as a bipartite graph where edges represent possible assignments, and then I have to check for a perfect matching without any crossing edges.\n\nBut wait, the problem isn't just about finding any perfect matching. The main constraint is that the lines don't cross. So I need a way to represent which pairs of points would result in crossing lines.\n\nHmm, perhaps for each possible assignment (each possible permutation of spaceships to bases), I can check whether the corresponding lines don't intersect each other. But since R and B can be up to 10 each, the total number of permutations could be 10! which is 3.6 million. That's manageable, I think.\n\nSo the approach could be:\n\n1. Generate all possible perfect matchings between the R spaceships and B bases.\n2. For each matching, check if any two lines (from base to spaceship) intersect.\n3. If there's at least one matching where none of the lines cross, output \"Yes\". Otherwise, \"No\".\n\nBut wait, how do I generate all possible perfect matchings? Well, for R equal to B, because the problem statement says R and B can be up to 10. Wait, no, the input may have R and B different? Wait, the problem statement says R is the number of spaceships, B the number of bases. But in order to have a perfect matching, R must equal B, right? Because each base needs exactly one spaceship, and each spaceship one base.\n\nWait, looking back at the problem statement: It says \"assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (a perfect matching)\". So for that to happen, R must equal B. Because a perfect matching requires that each node on both sides has exactly one edge.\n\nSo the first thing I should check is whether R equals B. If not, then it's impossible, output \"No\".\n\nWait, but looking at the example input, in the second case, R is 2 and B is 2 as well. So the sample input's second case is R=2, B=2, but the answer is \"No\" because no perfect matching exists without crossings. So yes, the initial step is to check if R == B. If not, output \"No\".\n\nWait no, wait the input format says that the first line contains R and B, and for each of the next R lines, it's the coordinates of the spaceships. Then the next B lines are the bases. So R can be different from B. For example, if R is 3 and B is 2, then it's impossible to have a perfect matching. So in that case, the output is immediately \"No\".\n\nSo the first step is to check if R != B. If so, output \"No\". Otherwise, proceed.\n\nSo assuming R = B, now the task is to find a permutation of the spaceships to the bases such that when you draw lines from each base to its assigned spaceship, none of these lines cross each other.\n\nSo how do I represent this?\n\nEach base is a point, each spaceship is another point. For each base i and spaceship j, we can compute whether the line from base i to spaceship j crosses any other line.\n\nWait, but for a given permutation, the lines are from base 0 to ship 0, base 1 to ship 1, etc., assuming the permutation is [0,1,2,...]. Or wait, no. The permutation is a mapping from each spaceship to a base. So for each spaceship, it's assigned to a specific base.\n\nWait, maybe the permutation is a list where for each spaceship index, we say which base it is assigned to. Or perhaps it's the other way around. Let me think.\n\nSuppose we have a list called 'matching' where matching[i] = j means spaceship i is assigned to base j. So for a perfect matching, each j must be unique, and all are covered.\n\nOnce I have such a matching, I need to check all the lines between each base j and its assigned spaceship i. Then, check if any two lines intersect.\n\nSo for the matching, for all pairs of lines, check if they cross.\n\nHow to check if two",
    "response": "To solve this problem, we need to determine if it's possible to assign Rebel spaceships to bases such that no two paths from a base to its assigned spaceship intersect. This problem can be approached by checking all possible perfect matchings between the spaceships and bases for the intersection constraint.\n\n### Approach\n1. **Check for Perfect Matching Feasibility**: First, check if the number of spaceships (R) is equal to the number of bases (B). If not, output \"No\" immediately as a perfect matching is impossible.\n2. **Generate All Perfect Matchings**: For each possible permutation of spaceships to bases, check if the resulting assignment forms a valid perfect matching where no two paths intersect.\n3. **Check for Intersection**: For each permutation, draw lines from each base to its assigned spaceship and ensure no two lines intersect. This involves checking each pair of lines using the cross product to determine if they intersect.\n\n### Solution Code\n```python\nimport itertools\n\ndef readints():\n    return list(map(int, input().split()))\n\ndef ccw(A, B, C):\n    return (B[0] - A[0]) * (C[1] - A[1]) - (B[1] - A[1]) * (C[0] - A[0])\n\ndef segments_intersect(s1, s2):\n    a, b = s1\n    c, d = s2\n    return ccw(a, b, c) * ccw(a, b, d) < 0 and ccw(c, d, a) * ccw(c, d, b) < 0\n\ndef main():\n    R_B = readints()\n    R = R_B[0]\n    B = R_B[1]\n\n    if R != B:\n        print(\"No\")\n        return\n\n    ships = []\n    for _ in range(R):\n        x, y = map(int, input().split())\n        ships.append((x, y))\n\n    bases = []\n    for _ in range(B):\n        x, y = map(int, input().split())\n        bases.append((x, y))\n\n    # Generate all possible permutations of assigning ships to bases\n    for perm in itertools.permutations(range(R)):\n        # Check if this permutation is a valid bijection\n        if len(set(perm)) != R:\n            continue\n        # Assign each ship to a base based on the permutation\n        assignment = {i: perm[i] for i in range(R)}\n        # Collect the pairs as lines\n        lines = [(bases[perm[i]], ships[i]) for i in range(R)]\n        # Check all pairs of lines for intersection\n        valid = True\n        for i in range(R):\n            for j in range(i+1, R):\n                if segments_intersect(lines[i], lines[j]):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into coordinates for spaceships and bases.\n2. **Checking Feasibility**: If the number of spaceships does not match the number of bases, output \"No\".\n3. **Generating Permutations**: Using permutations, generate all possible ways to assign spaceships to bases.\n4. **Checking Validity**: For each permutation, check if the lines formed by the assignments intersect. If any permutation is valid (no intersections), print \"Yes\". If all permutations are invalid, print \"No\".\n\nThis approach ensures that we efficiently check all possible configurations to find a valid assignment, leveraging geometric properties to avoid intersections.",
    "ground_truth": "N/A",
    "extracted_answer": "import itertools\n\ndef readints():\n    return list(map(int, input().split()))\n\ndef ccw(A, B, C):\n    return (B[0] - A[0]) * (C[1] - A[1]) - (B[1] - A[1]) * (C[0] - A[0])\n\ndef segments_intersect(s1, s2):\n    a, b = s1\n    c, d = s2\n    return ccw(a, b, c) * ccw(a, b, d) < 0 and ccw(c, d, a) * ccw(c, d, b) < 0\n\ndef main():\n    R_B = readints()\n    R = R_B[0]\n    B = R_B[1]\n\n    if R != B:\n        print(\"No\")\n        return\n\n    ships = []\n    for _ in range(R):\n        x, y = map(int, input().split())\n        ships.append((x, y))\n\n    bases = []\n    for _ in range(B):\n        x, y = map(int, input().split())\n        bases.append((x, y))\n\n    # Generate all possible permutations of assigning ships to bases\n    for perm in itertools.permutations(range(R)):\n        # Check if this permutation is a valid bijection\n        if len(set(perm)) != R:\n            continue\n        # Assign each ship to a base based on the permutation\n        assignment = {i: perm[i] for i in range(R)}\n        # Collect the pairs as lines\n        lines = [(bases[perm[i]], ships[i]) for i in range(R)]\n        # Check all pairs of lines for intersection\n        valid = True\n        for i in range(R):\n            for j in range(i+1, R):\n                if segments_intersect(lines[i], lines[j]):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 463,
        "completion_token_count": 763,
        "thoughts_token_count": 1025
    }
}