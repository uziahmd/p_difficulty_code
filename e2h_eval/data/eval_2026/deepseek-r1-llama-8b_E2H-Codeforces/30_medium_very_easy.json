{
    "start": 1758288463.5638394,
    "end": 1758290844.7093592,
    "start-formatted": "2025-09-19 22:27 KST",
    "end-formatted": "2025-09-19 23:07 KST",
    "gpu": 2,
    "pid": 30,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# TV Game\n\nThere is a new TV game on BerTV. In this game two players get a number A consisting of 2n digits. Before each turn players determine who will make the next move. Each player should make exactly n moves. On it's turn i-th player takes the leftmost digit of A and appends it to his or her number Si. After that this leftmost digit is erased from A. Initially the numbers of both players (S1 and S2) are «empty». Leading zeroes in numbers A, S1, S2 are allowed. In the end of the game the first player gets S1 dollars, and the second gets S2 dollars.One day Homer and Marge came to play the game. They managed to know the number A beforehand. They want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize. Help them.\n\n## Input\nThe first line contains integer n (1 ≤ n ≤ 18). The second line contains integer A consisting of exactly 2n digits. This number can have leading zeroes.\n\n## Output\nOutput the line of 2n characters «H» and «M» — the sequence of moves of Homer and Marge, which gives them maximum possible total prize. Each player must make exactly n moves. If there are several solutions, output any of them.\n\n## Example\n### Input\n['2\\n1234', '2\\n9911']\n\n### Output\n['HHMM', 'HMHM']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "Okay, so I have this problem where Homer and Marge are playing a TV game. The goal is to maximize their total prize by choosing the sequence of moves optimally. Let me try to understand the problem.\n\nThe game starts with a number A that has 2n digits. Each player makes exactly n moves. In each move, the current player takes the leftmost digit of A and appends it to their own number (S1 for Homer and S2 for Marge). Then, that digit is removed from A. So after each move, A gets shorter by one digit.\n\nOur task is to determine the order of moves (Homer and Marge) such that when all moves are done, both have exactly n digits, and their combined scores (the sum of their numbers) is as large as possible.\n\nHmm. So the key is to decide for each digit whether it's assigned to Homer or Marge in a way that maximizes the sum of their numbers. But since the order of taking the digits affects how we can assign them, it's a bit tricky.\n\nLet me think about what the maximum sum would look like. Since each digit contributes to either S1 or S2, the sum is maximized when the digits are assigned in such a way that the higher digits go to the players who can get more value from them.\n\nWait, but the positions matter. Because each digit's contribution depends on its position in the number. For example, a '9' in the first position of S1 is worth 900...0, while in S2 it's also 900...0. So perhaps the optimal strategy is to assign the largest possible digits to the earliest possible positions in either S1 or S2, but considering that each digit can only be assigned once.\n\nAlternatively, maybe the problem can be approached by determining which digits go to which player in a way that the sum of the digits multiplied by their respective place values is maximized.\n\nWait, let's model this. Each digit will contribute to either S1 or S2. The place value for each digit depends on when it's taken. For example, the first digit taken is the most significant digit in S1 or S2. So the first move's digit is the first digit of S1 or S2.\n\nSo the idea is to arrange the digits in such a way that the highest digits are placed in the earliest possible positions, regardless of whether they go to S1 or S2.\n\nBut since each digit can only be used once, the problem reduces to selecting, for each position in the combined list of 2n digits, whether it goes to S1 or S2, such that the overall sum is maximized.\n\nWait, but the assignment isn't independent because the order in which the digits are taken matters for their position. For example, the first digit is the first digit of either S1 or S2, depending on who takes it first.\n\nSo the problem is similar to partitioning the 2n digits into two sequences, each of length n, such that the sum of the values of these two sequences is maximized. But each sequence is built by taking the leftmost digit at each step, with the assignment determined by the players' turn.\n\nWait, no. Because the assignment of each digit is not arbitrary. The players take turns picking the leftmost digit. So the order in which the digits are picked is fixed as the leftmost remaining digit, but the decision of which player picks it next is part of the strategy.\n\nAh, right! So the sequence of digits being taken is determined by the initial string. For example, if A is \"1234\", then the first move will take '1', then '2', then '3', then '4'. So the order of digits is fixed; the only decision is which player picks each digit in turn.\n\nSo our task is to decide for each position in the 2n-length sequence whether it's taken by Homer or Marge, such that the sum of the resulting S1 and S2 is maximized.\n\nBecause the order of digits is fixed, each digit's position in S1 or S2 is determined by when it was taken. For example, the first digit is the first digit of either S1 (if Homer took it) or S2 (if Marge took it). The second digit is the second digit of whichever player took the first, or if the other player took the first, then the second digit is the first of the other player.\n\nWait, no. Wait, each move alternates between the players. So the first move is made by one of them, the second by the other, etc. But wait, the initial choice is made by the players: who goes first? Or is that part of the solution?\n\nWait, the problem says that before each turn, the players determine who will make the next move. So the initial state is that both S1 and S2 are empty. The players can choose who starts. But each player must make exactly n moves. So the total number of moves is 2n, each player making n moves.\n\nSo the sequence of moves is a permutation of H and M, each appearing exactly n times, such that the sum of the resulting S1 and S2 is maximized.\n\nHmm, okay. So the problem is to choose the starting player, and then for each step, decide which player takes the next available digit (from the left), in a way that the total is maximized.\n\nBut wait, the order of the digits is fixed. For example, suppose A is '1234'. Then the digits are taken in the order 1, 2, 3, 4. So the first digit is 1, then 2, then 3, then 4. So the order is fixed, and the players alternate taking these digits in the order they appear.\n\nBut the assignment of which player takes which digit is part of the strategy. So for each position in the 2n digits, we decide whether it's taken by Homer or Marge, with the constraint that exactly n are taken by each, and that the sequence alternates starting from some point (could be H or M).\n\nWait, but the sequence of moves must be such that the players alternate, starting with either H or M. So the entire sequence is a series of H and M, with exactly n H's and n M's, and the first move could be H or M.\n\nSo our task is to find the best possible sequence of H and M assignments, given the fixed order of the digits, such that:\n\n- The sequence has exactly n H's and n M's.\n\n- The sequence starts with either H or M.\n\n- The assignment of H and M to the digits in the order they appear is such that the sum of the resulting S1 and S2 is maximized.\n\nSo the approach is to generate all possible valid sequences of H and M (with n each, and starting with H or M) and for each, compute the sum, then select the one with the maximum sum.\n\nBut wait, n can be up to 18, meaning 2n is 36. So the number of possible sequences is C(36, 18) if starting with H, or same for starting with M. That's way too big—about 9e10, which is impossible to compute directly.\n\nSo a brute-force approach is out of the question. We need a smarter way.\n\nHmm. Let's think about dynamic programming. Maybe we can model the problem by keeping track of how many digits have been assigned to each player, and the current position in the digit sequence.\n\nWait, perhaps. Let's model the state as (i, h, m), where i is the current position in the digit string (digits are taken in order), h is the number of digits assigned to Homer so far, m to Marge. The value of the state is the maximum sum achievable from this point onward.\n\nAt each step, we can choose to assign the current digit to Homer or Marge, provided that we don't exceed their maximum (n each). The base case is when i == 2n, and then the sum is computed based on the digits assigned to each.\n\nWait, but computing the sum as we go might be computationally expensive because the sum can be very large. However, since we're trying to maximize the sum, perhaps we can find a way to represent the state without tracking the actual sum.\n\nAlternatively, perhaps we can find a way to precompute the contribution of each digit based on its position in S1 or S2.\n\nWait, for a digit d at position k (0-based) in the digit sequence, if it's assigned to S1, its value is d * 10^{n - k - 1}, because each digit added to S1 is at the next higher position. Similarly, if it's assigned to S2, it's d * 10^{n - k - 1}.\n\nWait, no. Let's see: the first digit taken is the first digit of S1 or S2, depending on who takes it. The next digit is the second digit of the previous player's S, or the first of the other. So for each digit in the sequence, its position in S1 or S2 is equal to the number of digits already assigned to that player.\n\nFor example:\n\nDigits are taken in order: d1, d2, d3, ..., d_{2n}.\n\nSuppose the first move is H: then d1 is the first digit of S1. Second move is M: d2 is first of S2. Third move H: d3 is second of S1. Fourth move M: d4 is second of S2. And so on.\n\nSo for each digit di, the position in S1 is (number of times H has taken before this di plus 1), and similarly for S2.\n\nWait, yes. So for each di in the sequence, if it's assigned to S1, its place value is 10^{k}, where k is the number of digits already assigned to S1 before this di. Similarly for S2.\n\nSo the contribution of di to the total sum is di * 10^a, where a is the number of digits already in S1 before di is added.\n\nSimilarly, if it's assigned to S2, a is the number of digits already in S2 before di is added.\n\nThis seems complicated, but perhaps we can model the state as (i, h, m), where i is the current position in the digit string, h is the number of digits assigned to S1 so far, m is the number assigned to S2 so far.\n\nWait, but h and m must satisfy h + m = i, since up to position i, we've assigned i digits. Also, h cannot exceed n, m cannot exceed n.\n\nWait, but when assigning a digit, h can be up to n, and m can be up to n.\n\nSo for each state (i, h, m), we can consider assigning the current digit (i-th) to S1 or S2, but only if h < n or m < n respectively.\n\nThen, for each possible transition, we can compute the gain in the sum.\n\nWait, but the gain depends on how many digits have already been assigned to S1 or S2. Because the place value is determined by the count of digits before it in that player's sequence.\n\nSo for example, if we are at position i, and the current digit is d_i, and we assign it to S1, the place value is 10^{h}, since h is the number of digits already in S1 before this. Similarly, if assigned to S2, it's 10^{m}.\n\nWait, no. Because when we assign the i-th digit, the number of digits in S1 is h, so adding this digit as the (h+1)-th digit in S1. So its place value is 10^{h}.\n\nSimilarly for S2: if we add it as the (m+1)-th digit, place value is 10^m.\n\nSo, the gain for assigning d_i to S1 is d_i * 10^h, and to S2 is d_i * 10^m.\n\nSo, the state can be modeled as (i, h, m), and for each state, we can compute the maximum possible sum by choosing whether to assign the current digit to S1 or S2, if allowed.\n\nThe base case is when i = 2n, and the sum is 0.\n\nWait, but we also need to track the current sum. Hmm, but that's not feasible because the sum can be up to 2n digits, each up to 9, so 9*1e18 is way too big to store.\n\nAlternative approach: realize that the total sum is the sum over all digits of d_i * 10^{position_in_S1_or_S2}. The position in S1 is h, position in S2 is m, depending on where we assign.\n\nWait, but how can we model this without tracking the sum? Because the sum depends on the order of assignments.\n\nAnother idea: For each state (i, h, m), track the maximum possible sum up to that state. Then, for each transition, calculate the new sum based on the current digit and its position in S1 or S2.\n\nBut again, the sum can be very large, so storing it is not feasible. However, since we are maximizing the sum, perhaps we can find a way to represent the state transitions without explicitly storing the sum.\n\nWait, perhaps we can represent the state as (i, h, m) and the maximum sum achievable up to that point. Then, for each state, we can explore both possibilities (assign to S1 or S2) and keep track of the maximum sum.\n\nYes, this seems manageable. The state space is i (up to 36), h (up to 18), m (up to 18). So the total number of states is 36 * 19 * 19 = around 13,684, which is manageable.\n\nSo the plan is:\n\n1. Preprocess the digit string into a list of integers, say digits = [int(c) for c in A].\n\n2. Initialize a DP table, where dp[i][h][m] represents the maximum sum achievable up to the i-th digit, having assigned h digits to S1 and m digits to S2.\n\n3. For each state (i, h, m), we can assign the i-th digit to S1 or S2, provided that h < n or m < n, respectively.\n\n4. The transition is:\n\n   a. Assign to S1: new_h = h + 1, new_m = m. The contribution is digits[i] * 10^h.\n\n   b. Assign to S2: new_m = m + 1, new_h = h. Contribution is digits[i] * 10^m.\n\n5. Take the maximum of the two options and update the DP table accordingly.\n\n6. After processing all digits, the final answer is the maximum of dp[2n][n][n], but wait, no—since the sum is fixed once all digits are assigned, the maximum sum is achieved by the last state.\n\nWait, but the DP[i][h][m] holds the maximum sum achievable when we have processed i digits, with h assigned to S1 and m to S2.\n\nSo the maximum sum is found in dp[2n][n][n], but wait, h and m must each be n, because each player makes exactly n moves.\n\nSo the initial state is dp[0][0][0] = 0. Then, for each digit i (starting from 0?), we process it, updating the states.\n\nWait, perhaps the indices are off. Let me think: for i=0, it's before any digits are processed. When we process the first digit (i=0), we have i=1, h=1, m=0 or h=0, m=1.\n\nWait, no. Let me reindex: perhaps i runs from 0 to 2n-1. So for each i in 0..2n-1:\n\n   For each possible h and m such that h + m = i.\n\nWait, no. Because h + m can't be more than i, since each digit is assigned to either S1 or S2. So for i-th digit (0-based), h can be from 0 to min(i, n), and m = i - h.\n\nBut since h cannot exceed n, and m cannot exceed n, the constraints are:\n\nh <= n\n\nm = i - h >= 0\n\nand m <= n.\n\nSo for each i, h can range from max(0, i - n) to min(i, n). Because m = i - h must be >=0 and <=n.\n\nSo in the DP, for each i, h can vary within those limits.\n\nSo the steps:\n\n- Read n and A.\n\n- Convert A into a list of integers, digits.\n\n- Initialize a 3D DP array of size (2n+1) x (n+1) x (n+1), filled with -infinity, except dp[0][0][0] = 0.\n\n- For each i from 0 to 2n-1:\n\n   For each possible h from max(0, i - n) to min(i, n):\n\n      m = i - h.\n\n      if m > n or m <0: continue.\n\n      current_sum = dp[i][h][m]\n\n      if current_sum is -infinity: continue.\n\n      // Assign to S1\n\n      if h < n:\n\n          new_h = h + 1\n\n          new_m = m\n\n          contribution = digits[i] * (10 ** h)\n\n          new_sum = current_sum + contribution\n\n          if new_sum > dp[i+1][new_h][new_m]:\n\n              dp[i+1][new_h][new_m] = new_sum\n\n      // Assign to S2\n\n      if m < n:\n\n          new_m = m + 1\n\n          new_h = h\n\n          contribution = digits[i] * (10 ** m)\n\n          new_sum = current_sum + contribution\n\n          if new_sum > dp[i+1][new_h][new_m]:\n\n              dp[i+1][new_h][new_m] = new_sum\n\n- After filling the DP table, the answer is the maximum sum, which is dp[2n][n][n]. But wait, that's the sum, but we need the sequence of H and M.\n\nSo, once we have the maximum sum, we need to reconstruct the sequence of choices (H or M for each digit).\n\nTo do that, we can backtrack from dp[2n][n][n] to dp[0][0][0], deciding for each digit whether it was assigned to S1 or S2.\n\nSo, how to reconstruct the path:\n\nWe'll create an array of choices, initially empty.\n\nWe start at i=2n, h=n, m=n.\n\nFor each i from 2n down to 0:\n\n   if h == n and m == n: break.\n\n   if i == 0:\n\n       // but h and m must be 0.\n\n       // so no action.\n\n   else:\n\n       if h < n and dp[i][h][m] == dp[i+1][h+1][m]:\n\n           // the current digit was assigned to S1.\n\n           append 'H' to choices.\n\n       elif m < n and dp[i][h][m] == dp[i+1][h][m+1]:\n\n           // assigned to S2.\n\n           append 'M' to choices.\n\nSo the choices are built in reverse, so we'll need to reverse them at the end.\n\nWait, but the order in which we process i is from 2n down to 0. So for each step, we look at the current state (h, m) and see which transition led to it.\n\nWait, perhaps another approach is to start from i=0, h=0, m=0, and build the choices forward, but that's more complicated for backtracking.\n\nAlternatively, during the DP, we can also track the path by storing for each state (i, h, m) the parent state and the choice made.\n\nBut that would require more memory, but it's manageable.\n\nAlternatively, perhaps the backtracking approach is feasible.\n\nNow, let's think about the implementation.\n\nFirst, the DP needs to handle up to 36 digits, and for each digit, for each possible (h, m), track the maximum sum.\n\nBut the exponents can be large. For example, for a digit assigned to S1 as the 18th digit, 10^18 is a big number, but in Python, it can handle big integers.\n\nSo the steps for code:\n\nRead n.\n\nRead A as a string.\n\nConvert to a list of integers, digits = [int(c) for c in A]\n\nInitialize dp as a 3D array. Since 2n can be up to 36, and h and m up to 18, the dimensions are 37 x 19 x 19.\n\nWe can represent this as a dictionary or a 3D list. Using a 3D list is better for speed.\n\nIn Python, initializing a 3D list:\n\ndp = [[[-inf for _ in range(n+1)] for __ in range(n+1)] for ___ in range(2*n +1)]\n\nBut wait, for each i, the h and m are constrained by h + m = i, h <=n, m<=n.\n\nBut in code, perhaps it's easier to loop through all possible h and m for each i.\n\nWait, but for each i, h can range from max(0, i-n) to min(i, n), and m = i - h.\n\nSo in the code:\n\nfor i in range(2*n):\n\n    for h in range(max(0, i - n), min(i, n)+1):\n\n        m = i - h\n\n        if m < 0 or m >n:\n\n            continue\n\n        # process state (i, h, m)\n\nBut wait, for each i, h can be from 0 to i, but subject to m = i - h <=n and >=0.\n\nSo in code:\n\nfor i in range(2*n):\n\n    for h in range(0, i+1):\n\n        m = i - h\n\n        if m >n or m <0:\n\n            continue\n\n        # process (i, h, m)\n\nBut for i=0, h=0, m=0.\n\nWait, but in the code, for each i in 0..2n-1, and for each h in 0..i, compute m = i -h. If m is within 0..n, proceed.\n\nSo, in code, for each i from 0 to 2n-1:\n\n   for h in 0 to i:\n\n       m = i - h\n\n       if m >n or m <0: continue\n\n       current_sum = dp[i][h][m]\n\n       if current_sum is -inf: continue\n\n       // assign to S1\n\n       if h < n:\n\n           new_h = h +1\n\n           new_m = m\n\n           contribution = digits[i] * (10 ** h)\n\n           new_sum = current_sum + contribution\n\n           if new_sum > dp[i+1][new_h][new_m]:\n\n               dp[i+1][new_h][new_m] = new_sum\n\n       // assign to S2\n\n       if m < n:\n\n           new_m = m +1\n\n           new_h = h\n\n           contribution = digits[i] * (10 ** m)\n\n           new_sum = current_sum + contribution\n\n           if new_sum > dp[i+1][new_h][new_m]:\n\n               dp[i+1][new_h][new_m] = new_sum\n\nBut wait, for i=0, h=0, m=0:\n\ndigits[0] is the first digit.\n\nIf assigned to S1: new_h=1, new_m=0.\n\ncontribution is digits[0] * 10^0 = digits[0].\n\nSimilarly for S2.\n\nSo the code should correctly compute the transitions.\n\nOnce the DP is filled, the maximum sum is dp[2n][n][n].\n\nBut wait, what if there are multiple ways to reach (2n, n, n)? We need to pick the one with the maximum sum.\n\nOnce the maximum sum is known, we need to reconstruct the sequence of choices.\n\nReconstructing the sequence:\n\nWe can create a list of choices, then reverse it.\n\nWe start from i=2n, h=n, m=n.\n\nFor each step back, from i=2n-1 down to 0.\n\nWait, no. Wait, to reconstruct, we start at i=2n, and for each step, find the previous state that led to it.\n\nWait, perhaps it's easier to start from (i=2n, h=n, m=n) and go back to (i=0, h=0, m=0), and for each step, determine whether the current digit was assigned to S1 or S2.\n\nSo, for i from 2n-1 downto 0:\n\n   current state is (i+1, h, m)\n\n   check whether the next state was reached by assigning to S1 or S2.\n\nWait, maybe I'm getting confused.\n\nWait, for each step i, which is the current digit index (0-based), the next state is i+1.\n\nSo to reconstruct the path, we can start at i=2n, with h=n, m=n.\n\nThen, for each i from 2n-1 downto 0:\n\n   check if the current state (i, h, m) was reached by assigning the i-th digit to S1 or S2.\n\nSo, for i-th digit, the next state is i+1, h', m'.\n\nIf the current state (i, h, m) was reached by assigning to S1, then:\n\n   h' = h+1\n\n   m' = m\n\nAnd the contribution is digits[i] * 10^h.\n\nSo, to check whether the transition from (i, h, m) to (i+1, h+1, m) was via S1, we can compare the sum in (i+1, h+1, m) to (i, h, m) + digits[i]*10^h.\n\nSimilarly for S2.\n\nSo, in code:\n\npath = []\n\ncurrent_i = 2n\n\ncurrent_h = n\n\ncurrent_m = n\n\nwhile current_i > 0:\n\n    i = current_i -1\n\n    h = current_h\n\n    m = current_m\n\n    if h < n and dp[current_i][h][m] + digits[i] * (10 ** h) == dp[current_i][h+1][m]:\n\n        # the current digit was assigned to S1\n\n        path.append('H')\n\n        current_h +=1\n\n    else:\n\n        # assigned to S2\n\n        path.append('M')\n\n        current_m +=1\n\n    current_i -=1\n\nBut wait, let's see:\n\nWe're at (current_i, current_h, current_m), which is the result after processing the current_i-th digit (0-based). To find the previous state, we look at the (current_i-1)th digit.\n\nSo for each step, the current_i is decremented by 1, and h and m are updated accordingly.\n\nWait, perhaps I should write the code differently.\n\nAlternatively, perhaps during the reconstruction, for each i from 2n-1 downto 0:\n\n   if the current state (i+1, h, m) was reached by assigning the i-th digit to S1:\n\n       add 'H' to path.\n\n       h increases by 1.\n\n   else:\n\n       add 'M' to path.\n\n       m increases by 1.\n\nBut the initial state after all digits are processed is (2n, n, n). So the first step is to process the 2n-1 th digit.\n\nSo the code:\n\nsequence = []\n\ni = 2n\n\nh = n\n\nm = n\n\nwhile i >0:\n\n    # look at i-1 digit\n\n    digit = digits[i-1]\n\n    # check if previous state was (i-1, h-1, m) with assignment to S1.\n\n    # if dp[i][h][m] equals dp[i-1][h-1][m] + digit * 10^(h-1)\n\n    # then assignment is H\n\n    if h >0 and (dp[i][h][m] == dp[i-1][h-1][m] + digit * (10 ** (h-1))):\n\n        sequence.append('H')\n\n        h -=1\n\n    else:\n\n        # assignment is M\n\n        sequence.append('M')\n\n        m -=1\n\n    i -=1\n\nThen, the sequence is built in reverse order. So after collecting the sequence, we need to reverse it.\n\nWait, no. Because for each step, the digit is i-1, and the choice is added to the sequence. So the first digit processed is the last in the sequence.\n\nSo after the loop, the sequence is in reverse order. So we need to reverse it to get the correct order.\n\nWait, let me think: when i is 2n, we look at the (2n-1)th digit. So the first choice is for the (2n-1)th digit. Then i becomes 2n-1, and we look at (2n-2)th digit, etc., until i=0.\n\nSo the sequence is built from the last digit to the first. So the first element in the sequence is the choice for the last digit, the next is the choice for the second last, etc. So to get the correct order, we need to reverse the sequence.\n\nSo the code:\n\nsequence = []\n\ni = 2n\n\nh = n\n\nm = n\n\nwhile i >0:\n\n    # process digit i-1\n\n    digit = digits[i-1]\n\n    if h>0 and dp[i][h][m] == dp[i-1][h-1][m] + digit * (10 ** (h-1)):\n\n        sequence.append('H')\n\n        h -=1\n\n    else:\n\n        sequence.append('M')\n\n        m -=1\n\n    i -=1\n\nsequence = sequence[::-1]\n\nSo the final sequence is the correct order.\n\nPutting it all together:\n\nRead n.\n\nRead A as a string.\n\ndigits = list(map(int, A))\n\nCompute the DP table.\n\nReconstruct the sequence.\n\nPrint the sequence.\n\nBut wait, the sample input:\n\nSample Input:\n\n2\n\n9911\n\nWhich gives output HHMM.\n\nWait, let's see:\n\nWait, the input is '9911', which is four digits, n=2.\n\nDigits are 9,9,1,1.\n\nThe sample output is 'HHMM'.\n\nSo the sequence is H H M M.\n\nSo the first two digits (9 and 9) are assigned to S1, the next two to S2.\n\nSo S1 is 99, S2 is 11. Sum is 99+11=110.\n\nAnother possible sequence is H M H M, but let's compute the sum.\n\nIn that case, the first digit is H: 9 → S1 (first digit). Second is M: 9 → S2 (first digit). Third is H: 1 → S1 (second digit). Fourth is M: 1 → S2 (second digit). So S1 is 91, S2 is 91. Sum is 182, which is larger.\n\nWait, but the sample output is 'HHMM' with sum 110. So why is that the correct output?\n\nWait, perhaps I'm misunderstanding the sample.\n\nWait, perhaps the sample input is different. Let me recheck.\n\nWait, in the problem statement, the sample input is given as:\n\n['2\\n1234', '2\\n9911']\n\nWait, so the first line is n=2, and the second line is A='9911'.\n\nSo the digits are 9,9,1,1.\n\nSo the optimal sequence is 'HHMM' which leads to S1=99, S2=11. Sum 110.\n\nBut why is that the maximum? Because 99 +11 = 110.\n\nBut another possible sequence is H M H M.\n\nWhich gives S1=91, S2=91. Sum is 182, which is larger.\n\nSo the sample output must be incorrect, but that's unlikely. So perhaps I made a mistake in understanding the problem.\n\nWait, perhaps the sample is not matching the input given.\n\nWait, perhaps the sample's output is for a different A. Or perhaps the problem requires that the sum is maximized, but when there are multiple options, any can be chosen.\n\nWait, perhaps my reasoning is wrong.\n\nWait, in the sample input, A is '9911'.\n\nIf we assign the first two digits to S1 and the next two to S2, then S1 is 99, S2 is 11. Sum is 110.\n\nIf we assign the first digit to S1, second to S2, third to S1, fourth to S2:\n\nS1 is 91, S2 is 91. Sum is 182.\n\nSo that's better. So why does the sample output say 'HHMM'?\n\nWait, perhaps I'm misinterpreting the sample. Let me look again.\n\nWait, the sample output is ['HHMM', 'HMHM'].\n\nWait, perhaps the first output is for the first test case, which is A=1234, but the second line of input is 9911.\n\nWait, perhaps the sample input is:\n\nThe first line is n=2, the second line is 1234, and the output is HHMM.\n\nWait, no, the sample shows the input as ['2\\n1234', '2\\n9911'], which may be a typo in the problem statement.\n\nAlternatively, perhaps the sample is correct, and my reasoning is wrong.\n\nWait, perhaps I'm missing something in how the digits are assigned.\n\nWait, when the first player takes a digit, it's the first digit of his number, then the second, etc. So the order in which the digits are taken determines their place value.\n\nWait, for the sample where A is '9911' (n=2):\n\nOption 1: HHMM → H takes first two digits, M takes last two.\n\nSo S1 is 99, S2 is 11. Sum is 110.\n\nOption 2: H M H M → H takes 9, M takes 9, H takes 1, M takes 1.\n\nSo S1 is 91, S2 is 91. Sum is 182.\n\nSo option 2 is better. So why is the sample output 'HHMM'?\n\nHmm, perhaps I'm misunderstanding the problem statement.\n\nWait, perhaps the problem requires that the sum of the numerical values of S1 and S2 is maximized. But in the sample, 'HHMM' gives S1=99, S2=11, sum=110. While 'HMHM' would give S1=91, S2=91, sum 182.\n\nBut the sample output is given as 'HHMM' with a certain output.\n\nWait, perhaps I'm misreading the sample.\n\nWait, looking back: the sample input is:\n\n['2\\n1234', '2\\n9911']\n\nThe output is ['HHMM', 'HMHM'].\n\nSo perhaps the first line is n=2, A=1234, the second line is n=2, A=9911.\n\nWait, that makes sense. So for the first test case, n=2, A=1234, the output is 'HHMM', which gives S1=12, S2=34. Sum 46.\n\nBut perhaps that's not the maximum.\n\nWait, let's compute for A=1234.\n\nPossible sequences:\n\nOption 1: H H M M → S1=12, S2=34. Sum 12+34=46.\n\nOption 2: H M H M → S1=13, S2=24. Sum 37.\n\nOption 3: H M M H → S1=14, S2=23. Sum 37.\n\nOption 4: M M H H → S1=12, S2=34. Sum 46.\n\nSo the maximum sum is 46.\n\nSo the sample output is correct.\n\nSo for the second test case, A=9911, the maximum sum is 182, but perhaps the sample expects 'H M H M' as the sequence. But the sample output is 'HMHM'.\n\nWait, in the sample output, the first line is 'HHMM' and the second is 'HMHM'.\n\nSo perhaps the sample is correct, and the problem is to find any optimal sequence.\n\nSo back to the problem: the code will correctly find the maximum sum and the corresponding sequence.\n\nThus, the approach using DP is correct.\n\nNow, implementing this in Python.\n\nPotential issues:\n\n- The exponentiation 10^h can be large, but in Python, it's manageable.\n\n- For h=18, 10^18 is 1e18, which fits in a Python integer.\n\nImplementing the DP:\n\nWe can represent the DP as a list of lists of lists.\n\nInitialize all to -infinity, except dp[0][0][0] =0.\n\nThen, for each i in 0 to 2n-1:\n\n   for h in 0 to i:\n\n       m = i - h\n\n       if m <0 or m >n: continue\n\n       current_sum = dp[i][h][m]\n\n       if current_sum == -inf: continue\n\n       // assign to S1\n\n       if h <n:\n\n           new_h = h+1\n\n           new_m = m\n\n           contribution = digits[i] * (10 ** h)\n\n           new_sum = current_sum + contribution\n\n           if new_sum > dp[i+1][new_h][new_m]:\n\n               dp[i+1][new_h][new_m] = new_sum\n\n       // assign to S2\n\n       if m <n:\n\n           new_m = m+1\n\n           new_h = h\n\n           contribution = digits[i] * (10 ** m)\n\n           new_sum = current_sum + contribution\n\n           if new_sum > dp[i+1][new_h][new_m]:\n\n               dp[i+1][new_h][new_m] = new_sum\n\nOnce the DP is filled, find the maximum sum, which is dp[2n][n][n].\n\nThen, reconstruct the path.\n\nTesting with sample input:\n\nSample input 1:\n\nn=2, A=1234.\n\nDigits: [1,2,3,4].\n\nDP after processing:\n\nThe maximum sum is 46, achieved by HHMM.\n\nSo the code should produce 'HHMM'",
    "response": "To solve this problem, we need to determine the sequence of moves for Homer and Marge in a TV game such that their total prize is maximized. The game involves two players taking turns to pick the leftmost digit from a given number, with each player making exactly `n` moves. The goal is to maximize the sum of the numbers formed by both players.\n\n### Approach\n1. **Problem Analysis**: Each player takes turns picking digits from a string, forming two numbers. The sum of these numbers should be maximized. The challenge is to decide the order of moves (Homer or Marge) to achieve this maximum sum.\n\n2. **Dynamic Programming (DP) Approach**: We use a 3D DP table where `dp[i][h][m]` represents the maximum sum achievable after processing the first `i` digits, with `h` digits assigned to Homer and `m` digits assigned to Marge.\n\n3. **State Transitions**: For each digit, we decide whether to assign it to Homer or Marge. The contribution of each digit depends on its position in the respective player's number. The state transitions are based on whether the current digit is added to Homer's or Marge's number.\n\n4. **Reconstruction of Moves**: After filling the DP table, we backtrack from the final state to reconstruct the sequence of moves that led to the maximum sum.\n\n### Solution Code\n```python\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    n = int(input[0])\n    A = input[1].strip()\n    \n    digits = [int(c) for c in A]\n    length = 2 * n\n    \n    # Initialize DP table\n    INF = -float('inf')\n    dp = [[[-INF]*(n+1) for _ in range(n+1)] for __ in range(length + 1)]\n    dp[0][0][0] = 0  # Base case\n    \n    for i in range(length):\n        for h in range(i + 1):\n            m = i - h\n            if m < 0 or m > n:\n                continue\n            current_sum = dp[i][h][m]\n            if current_sum == INF:\n                continue\n            \n            # Assign to S1\n            if h < n:\n                new_h = h + 1\n                new_m = m\n                contribution = digits[i] * (10 ** h)\n                new_sum = current_sum + contribution\n                if new_sum > dp[i+1][new_h][new_m]:\n                    dp[i+1][new_h][new_m] = new_sum\n            \n            # Assign to S2\n            if m < n:\n                new_m = m + 1\n                new_h = h\n                contribution = digits[i] * (10 ** m)\n                new_sum = current_sum + contribution\n                if new_sum > dp[i+1][new_h][new_m]:\n                    dp[i+1][new_h][new_m] = new_sum\n    \n    # Now reconstruct the path\n    max_sum = dp[length][n][n]\n    sequence = []\n    i = length\n    h = n\n    m = n\n    \n    while i > 0:\n        i -= 1\n        digit = digits[i]\n        if h > 0 and dp[i + 1][h - 1][m] == dp[i + 1][h][m] - digit * (10 ** (h - 1)):\n            sequence.append('H')\n            h -= 1\n        else:\n            sequence.append('M')\n            m -= 1\n    \n    # Reverse to get the correct order\n    sequence = sequence[::-1]\n    \n    print(''.join(sequence))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input consists of an integer `n` and a string `A` of length `2n`.\n2. **DP Initialization**: A 3D list `dp` is initialized to keep track of the maximum sum achievable at each state.\n3. **Filling DP Table**: For each digit, we consider assigning it to either Homer or Marge, updating the DP table accordingly.\n4. **Reconstructing Path**: After determining the maximum sum, we backtrack from the final state to construct the sequence of moves that led to this sum.\n5. **Output**: The sequence of moves is printed as a string of 'H' and 'M'.\n\nThis approach ensures that we efficiently compute the optimal sequence of moves using dynamic programming, considering all possible assignments of digits to maximize the total sum.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n    input = sys.stdin.read().split()\n    n = int(input[0])\n    A = input[1].strip()\n    \n    digits = [int(c) for c in A]\n    length = 2 * n\n    \n    # Initialize DP table\n    INF = -float('inf')\n    dp = [[[-INF]*(n+1) for _ in range(n+1)] for __ in range(length + 1)]\n    dp[0][0][0] = 0  # Base case\n    \n    for i in range(length):\n        for h in range(i + 1):\n            m = i - h\n            if m < 0 or m > n:\n                continue\n            current_sum = dp[i][h][m]\n            if current_sum == INF:\n                continue\n            \n            # Assign to S1\n            if h < n:\n                new_h = h + 1\n                new_m = m\n                contribution = digits[i] * (10 ** h)\n                new_sum = current_sum + contribution\n                if new_sum > dp[i+1][new_h][new_m]:\n                    dp[i+1][new_h][new_m] = new_sum\n            \n            # Assign to S2\n            if m < n:\n                new_m = m + 1\n                new_h = h\n                contribution = digits[i] * (10 ** m)\n                new_sum = current_sum + contribution\n                if new_sum > dp[i+1][new_h][new_m]:\n                    dp[i+1][new_h][new_m] = new_sum\n    \n    # Now reconstruct the path\n    max_sum = dp[length][n][n]\n    sequence = []\n    i = length\n    h = n\n    m = n\n    \n    while i > 0:\n        i -= 1\n        digit = digits[i]\n        if h > 0 and dp[i + 1][h - 1][m] == dp[i + 1][h][m] - digit * (10 ** (h - 1)):\n            sequence.append('H')\n            h -= 1\n        else:\n            sequence.append('M')\n            m -= 1\n    \n    # Reverse to get the correct order\n    sequence = sequence[::-1]\n    \n    print(''.join(sequence))\n\nif __name__ == \"__main__\":\n    main()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 411,
        "completion_token_count": 955,
        "thoughts_token_count": 8193
    }
}