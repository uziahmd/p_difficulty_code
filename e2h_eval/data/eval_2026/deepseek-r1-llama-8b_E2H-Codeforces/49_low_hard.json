{
    "start": 1758278800.717153,
    "end": 1758279495.812226,
    "start-formatted": "2025-09-19 19:46 KST",
    "end-formatted": "2025-09-19 19:58 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "Okay, so I have this problem where I need to determine if it's possible to assign a number of mushrooms to each lawn such that all the given roads' GCD and LCM constraints are satisfied. And if it's possible, I have to output any valid assignment.\n\nHmm, let's think about the problem. Each edge between two vertices (lawns) gives us a pair (g, l), which is the GCD and LCM of the mushrooms on those two vertices. So for two connected lawns u and v, their mushroom counts must satisfy:\n- gcd(u, v) = g\n- lcm(u, v) = l\n\nWait, but we also know that for any two numbers a and b, the product of their gcd and lcm is equal to the product of the numbers themselves. So, a * b = g * l. That's a key relationship here.\n\nSo for each edge, u and v must be such that their values a and b satisfy a * b = g * l, and their gcd is g, and their lcm is l.\n\nThis suggests that the possible pairs (a, b) are divisors of g * l, and they must satisfy these two conditions. Also, since g is the gcd, both a and b must be multiples of g. Let me think: if a and b are both divisible by g, then their gcd is at least g. But since the given g is the exact gcd, a and b can't have a higher common divisor than g. So, the maximum possible is when a = g * x and b = g * y, where x and y are coprime, because their gcd would then be 1, ensuring that the overall gcd is g.\n\nAlso, since the lcm of a and b is l, which is equal to (a*b)/gcd(a,b). Substituting a = g*x and b = g*y, the lcm would be (g^2 x y) / (gcd(gx, gy)) ). Since x and y are coprime, the gcd(gx, gy) is g * gcd(x, y). But since x and y are coprimes, that's just g*1 = g. So the lcm becomes (g^2 x y) / g = g x y.\n\nBut wait, in the problem, the given lcm is l, so g x y = l. But since x and y are coprimes, that means that l must be divisible by g, right? Because x and y are integers, their product multiplied by g is l. So if the given l is not divisible by g, then it's impossible, and we should return 'NO'.\n\nSo for each edge, first check if l mod g is zero. If not, it's impossible.\n\nThen, for each edge, after ensuring that l is divisible by g, we can factor out g from l. So l = g * k, which implies that x*y = k, with x and y being coprimes.\n\nWait, no. Wait, l = g x y. So k would be x*y, and since x and y are coprimes, the factors of k are split into x and y, which must be coprimes.\n\nSo for each edge, the possible pairs (a, b) can be written as (g * x, g * y), where x and y are positive integers with x * y = (l/g), and gcd(x, y) = 1.\n\nSo, for each edge, we can precompute all possible pairs (x, y) such that x * y = (l/g), and x and y are coprimes. Then, for each such pair, we can assign a and b as g*x and g*y, or g*y and g*x.\n\nWait, but the order matters because a is assigned to u and b to v, or vice versa. So for each edge, there might be multiple possible assignments.\n\nThis seems like a graph problem where each node has a value that can take certain possible values based on the edges connected to it.\n\nBut how do we model this? It feels like a constraint satisfaction problem, where each variable (the number of mushrooms on a lawn) must satisfy all the constraints from its connected edges.\n\nThis seems similar to problems where variables are connected via equations, and we need to find a consistent assignment.\n\nAn approach that comes to mind is to model this using a graph where each node represents a lawn, and the edges represent the constraints between them. We can perform a kind of BFS or DFS, assigning values to each node based on the constraints.\n\nBut the main challenge is handling the multiplicative relationships and ensuring that all constraints are satisfied across the entire graph.\n\nLet me think about the structure. Each edge imposes that for the two nodes it connects, their values must be multiples of g, and their product divided by g must be equal to l. But since a and b are linked by a * b = g * l",
    "response": "To solve this problem, we need to determine if it's possible to assign a number of mushrooms to each lawn such that all given road constraints (GCD and LCM) are satisfied. If possible, we should output any valid assignment; otherwise, we should return \"NO\".\n\n### Approach\n1. **Understanding Constraints**: Each road connects two lawns with a GCD (g) and an LCM (l). The values on these lawns must satisfy:\n   - `gcd(a, b) = g`\n   - `lcm(a, b) = l`\n   - Additionally, `a * b = g * l` where `a` and `b` are the mushroom counts.\n\n2. **Check Divisibility**: For each edge, check if `l % g == 0`. If not, it's impossible to satisfy the constraints, so return \"NO\".\n\n3. **Factorize Values**: For each edge, after ensuring `l % g == 0`, compute `k = l / g`. We need to find pairs `(x, y)` such that `x * y = k` and `gcd(x, y) = 1`.\n\n4. **Graph Representation**: Represent the problem as a graph where each node is a lawn, and edges represent constraints. Use BFS or DFS to explore possible assignments.\n\n5. **Breadth-First Search (BFS)**: Start from an unassigned node, use backtracking to assign values based on constraints. If a contradiction is found during assignment, backtrack.\n\n6. **Handling Assignments**: For each node, keep track of its value. If a node is already assigned, ensure it matches the current assignment; otherwise, assign values based on constraints and continue.\n\n### Solution Code\n```python\nimport sys\nfrom math import gcd\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    m = int(input[ptr])\n    ptr += 1\n\n    edges = []\n    for _ in range(m):\n        u = int(input[ptr])-1  # converting to 0-based\n        v = int(input[ptr+1])-1\n        g = int(input[ptr+2])\n        l = int(input[ptr+3])\n        ptr +=4\n        edges.append( (u, v, g, l) )\n\n    # Now, we need to assign values to each node.\n    # We'll represent the value of each node as a list, initializing to None.\n    values = [None] * n\n\n    # To avoid redundant processing, we'll process nodes in order, but since the graph could be disconnected,\n    # we need to handle each connected component separately.\n\n    # Let's collect all nodes and their edges, grouped by node.\n    node_edges = [[] for _ in range(n)]\n    for u, v, g, l in edges:\n        node_edges[u].append( (v, g, l) )\n        node_edges[v].append( (u, g, l) )\n\n    # Now, perform BFS for each node that hasn't been assigned yet.\n    # We'll also track which nodes have been processed to avoid revisiting.\n    processed = [False] * n\n    result = []\n\n    for i in range(n):\n        if processed[i]:\n            continue\n        if values[i] is not None:\n            # This node has been assigned elsewhere; proceed.\n            continue\n        queue = deque()\n        queue.append( (i, []) )  # (current node, path)\n        while queue:\n            u, path = queue.popleft()\n            if values[u] is not None:\n                # Check if the current path assigns a different value than existing.\n                if values[u] != path[0]:\n                    continue\n                # Continue with the rest of the path.\n                for (v, g, l) in node_edges[u]:\n                    if values[v] is None:\n                        # Try assigning v's value based on u's value.\n                        # From the equation a * b = g * l\n                        # Since u's value is path[0], let's compute possible values for v.\n                        # Also, the other way around.\n                        # Wait, for each edge, both nodes can be assigned in either way.\n                        # So for each edge, we need to consider possible assignments.\n                        # So for each edge, the two nodes' values must satisfy the constraints.\n                        # So for the current edge, we can model the possible values for v based on u's value.\n                        # Let me think: Suppose u's value is x, then v's value must be such that:\n                        # gcd(x, y) = g and lcm(x, y) = l.\n                        # So y must be a multiple of g, and x must be a multiple of g.\n                        # But wait, no: the edge's g is the gcd of the two nodes, so both must be multiples of g.\n                        # So x and y are both multiples of g. Let me set x = g * a, y = g * b.\n                        # Then, gcd(a, b) = 1, and lcm(a, b) = l/g.\n                        # So a and b are coprimes, and a*b = (l/g)/g = l/(g^2)? Wait, no:\n                        # Wait, the edge's l is the lcm of x and y, which is g*a*b, since x = g*a, y = g*b, and gcd(a, b)=1.\n                        # So, l = g*a*b => a*b = l/(g).\n                        # So, for the edge, a*b = k, where k = l/(g), and a and b are coprimes.\n\n                        # So, when trying to assign v's value, given u's value is x, which is a multiple of g, we can compute possible values for v.\n                        # Similarly, if v's value is known, we can compute u's value.\n\n                        # But in this case, we're processing the edge from u to v, and u's value is already known (from path).\n                        # So, we can compute what v's value must be.\n\n                        # So, given u's value is x = a*g, then v's value must be y = b*g, where a*b = k and gcd(a,b)=1.\n\n                        # So, for each possible pair (a, b) where a*b = k and gcd(a, b)=1, we can assign y = b*g.\n\n                        # Wait, but how do we know which one to choose? Because it's possible that v has already been assigned another value, which may conflict.\n\n                        # So, perhaps the approach is to try all possible assignments, but since it's a lot, we need a smarter way.\n\n                        # Alternative approach: for each edge, once we have u's value, we can compute possible v's values.\n\n                        # So, suppose u's value is x, which is a multiple of g. Let's compute the required y.\n\n                        # Since x and y must have gcd g, let x = g * a, y = g * b, with a and b coprimes.\n                        # Then, lcm(x, y) = g * a * b = l => a*b = l / g.\n\n                        # So, given x = a*g, y must be such that a*b = (l / g), and b must be coprime with a.\n\n                        # So, given x, we can compute possible y's.\n\n                        # But for this problem, it's easier to model as a graph where each node's value is determined by its constraints.\n\n                        # Hmm, perhaps the best approach is to model this as a system of equations where each node's value is determined by its edges, and use BFS with backtracking.\n\n                        # So, for the current node u, we have a value x. Then, for each edge (u, v, g, l), we can compute possible y for v.\n\n                        # So, for each possible (a, b) pair where a*b = k (k = l/g) and gcd(a,b) = 1, we can set y = a*g or b*g.\n\n                        # Wait, but this leads to multiple possibilities, which can explode the state space.\n\n                        # Maybe we can represent the possible values of a node as a dictionary, and during BFS, only proceed when the current assignment doesn't conflict with existing ones.\n\n                        # So, perhaps the way to proceed is to represent the possible values for each node and their dependencies.\n\n                        # This is getting complicated. Maybe a better approach is to model the constraints as a graph and use BFS to assign values step by step.\n\n                        # Let me think differently. For each node, the value must be a multiple of g for each edge connected to it. Wait, no: the GCD for each edge is g, so each node connected to it must be a multiple of g.\n\n                        # Wait, no. The GCD of the two nodes is g, meaning that both nodes must be multiples of g. So for each node, all edges connected to it must have a GCD that divides the node's value.\n\n                        # So, for each node, its value must be a multiple of all GCDs from its edges. Therefore, the node's value must be a multiple of the least common multiple of all GCDs from its edges.\n\n                        # Wait, but that might not be the case because the GCD for each edge is specific to that edge. So the node's value must be a multiple of each GCD from its edges, but the overall node's value must be a common multiple of all those GCDs.\n\n                        # Alternatively, perhaps the node's value must be a multiple of the GCD of all the individual edge GCDs.\n\n                        # This seems too vague. Maybe it's better to model the problem using the constraints between pairs of nodes.\n\n                        # So, for each edge (u, v, g, l), u and v must satisfy:\n\n                        # 1. a = g * a'\n                        # 2. b = g * b'\n                        # 3. gcd(a', b') = 1\n                        # 4. a' * b' = l / g\n\n                        # So, for each edge, the possible pairs (a', b') are factors of k = l/g, with a' and b' coprimes.\n\n                        # So, for each edge, we can precompute all possible (a', b') pairs and thus the possible (a, b) pairs.\n\n                        # Then, during BFS, when we have the value of one node, we can determine possible values for the connected nodes.\n\n                        # So, perhaps the way to proceed is to assign values in a BFS manner, starting from nodes with the fewest constraints.\n\n                        # However, due to the complexity, I think a backtracking approach might be necessary.\n\n                        # Let's try implementing a BFS-based solution where each time we assign a value to a node, we propagate this assignment to its neighbors, checking for consistency.\n\n                        # So, the steps are:\n\n                        # 1. For each node, if not assigned, start a BFS.\n                        # 2. In the BFS, track the current assignment and possible values for connected nodes.\n                        # 3. For each edge, based on the current assignment of one node, compute possible values for the other node.\n                        # 4. If the other node is unassigned, add it to the queue with the computed value.\n                        # 5. If the other node is already assigned, check for consistency. If inconsistent, backtrack.\n\n                        # Implementing this requires careful handling of the constraints and backtracking when a contradiction is found.\n\n                        # Given the complexity, I think the problem can be modeled using a Union-Find structure, but I'm not sure. Alternatively, a constraint satisfaction problem approach might be needed.\n\n                        # For the purpose of this solution, I'll implement a BFS-based approach with backtracking to handle the constraints.\n\n                        # Let's outline the code:\n\n                        # - Read input and build the graph.\n                        # - For each node, if not processed, attempt to assign a value.\n                        # - Use a queue to manage the BFS, tracking the current assignment.\n                        # - For each edge, compute possible values based on the current assignment and constraints.\n                        # - If a node is already assigned, check for consistency; if not, backtrack.\n\n                        # Now, considering the code structure:\n\n                        # We'll represent the values as a list. For each node, if it's not assigned, we'll try to assign it a value and propagate.\n\n                        # The main loop will process each node, and for each edge, compute possible values for connected nodes.\n\n                        # Due to the potential for multiple valid solutions, we'll need to efficiently manage the assignments and backtracking.\n\n                        # So, let's proceed to implement this logic.\n\n    # The above approach is quite involved. Instead, perhaps a better way is to model the problem as a system of equations and use a BFS approach to assign values step by step.\n\n    # After much consideration, I think the correct approach is to represent each node's value as a variable and use BFS with backtracking to assign values based on the constraints.\n\n    # Now, let's write the code.\n\n    # We'll use a dictionary to keep track of the current value of each node. Initially, all are None.\n\n    # For each node, if it's not yet assigned, we'll start a BFS to assign its value.\n\n    # For each edge, we'll compute possible values for the connected nodes based on the current assignment.\n\n    # We'll use a queue to manage the BFS, and a visited set to track which nodes have been processed.\n\n    # Now, let's proceed to write the code.\n\n    # Initialize the values as None.\n    values = [None] * n\n\n    # For each node, if it's not assigned, attempt to assign it.\n    for i in range(n):\n        if values[i] is None:\n            # Try to assign a value to node i.\n            # To do this, we need to consider all edges connected to i and see if they impose any constraints.\n            # But since the edges are bidirectional, we need to process them accordingly.\n            # We'll use a BFS approach to assign values.\n\n            # We'll create a queue that holds tuples of (node, current_value).\n            queue = deque()\n            queue.append( (i, None) )\n\n            while queue:\n                u, current_val = queue.popleft()\n\n                if current_val is not None:\n                    # We've been called back to a node that's already been assigned.\n                    # Check if the current_val matches the stored value.\n                    if values[u] is not None and values[u] != current_val:\n                        # Contradiction found; backtrack.\n                        continue\n                    else:\n                        # Continue processing.\n                        for (v, g, l) in node_edges[u]:\n                            if values[v] is None:\n                                # Compute possible values for v based on u's current_val.\n                                # So, for the edge (u, v, g, l), we have:\n                                # a = current_val\n                                # b must satisfy: gcd(a, b) = g and lcm(a, b) = l\n                                # So, a and b must be multiples of g.\n                                # Let a = g * a', b = g * b'\n                                # Then, gcd(a', b') = 1 and lcm(a', b') = l/g\n                                # So, a' * b' = l/g, and gcd(a', b') = 1.\n\n                                # Compute k = l // g\n                                k = l // g\n                                # Now, find all pairs (a', b') such that a' * b' = k and gcd(a', b') = 1.\n                                # For each such pair, b = g * b' is a possible value for v.\n\n                                # Find all divisors of k.\n                                factors = set()\n                                for i in range(1, int(k**0.5) + 1):\n                                    if k % i == 0:\n                                        factors.add(i)\n                                        factors.add(k // i)\n\n                                possible_pairs = []\n                                for a in factors:\n                                    if k % a == 0:\n                                        b = k // a\n                                        if gcd(a, b) == 1:\n                                            possible_pairs.append( (a, b) )\n\n                                # Now, for each possible (a', b'), compute b = g * b'\n                                # So, possible_values = [g * b for (a, b) in possible_pairs]\n                                possible_values = []\n                                for (a, b) in possible_pairs:\n                                    possible_values.append(g * b)\n\n                                # Also, the reverse is possible: v's value could be a, and u's could be b.\n                                # So, we need to consider both directions.\n\n                                # Wait, no: because the edge is from u to v, and u's value is already known.\n                                # So, we need to compute v's possible values based on u's current_val.\n\n                                # But in the code above, possible_values contains all possible b's.\n\n                                # Now, for each possible value in possible_values, if it's consistent with v's existing value, add it to the queue.\n\n                                for val in possible_values:\n                                    if values[v] is None:\n                                        # Assign val to v and add to queue.\n                                        values[v] = val\n                                        queue.append( (v, val) )\n                                    else:\n                                        if val != values[v]:\n                                            # Inconsistent; skip this possibility.\n                                            pass\n                                        else:\n                                            # Add to queue.\n                                            queue.append( (v, val) )\n                            else:\n                                # The value of v is already assigned. Check if it's compatible with current_val.\n                                if values[v] is not None:\n                                    # Check if the current_val and values[v] are compatible.\n                                    # That is, their product must equal g * l, and their GCD must be g.\n                                    a = current_val\n                                    b = values[v]\n                                    if a * b != g * l:\n                                        continue\n                                    if gcd(a, b) != g:\n                                        continue\n                                    if l == (a * b) // g:\n                                        # It's compatible. Add to queue.\n                                        queue.append( (v, b) )\n                                else:\n                                    # v is not assigned yet. Compute possible values for v based on current_val.\n                                    # Same as before.\n                                    k = l // g\n                                    factors = set()\n                                    for i in range(1, int(k**0.5) + 1):\n                                        if k % i == 0:\n                                            factors.add(i)\n                                            factors.add(k // i)\n\n                                    possible_pairs = []\n                                    for a in factors:\n                                        if k % a == 0:\n                                            b = k // a\n                                            if gcd(a, b) == 1:\n                                                possible_pairs.append( (a, b) )\n\n                                    possible_values = [g * b for (a, b) in possible_pairs]\n\n                                    for val in possible_values:\n                                        if values[v] is None:\n                                            values[v] = val\n                                            queue.append( (v, val) )\n                                        else:\n                                            if val != values[v]:\n                                                pass\n                                            else:\n                                                queue.append( (v, val) )\n    # After processing all nodes, check if all values are assigned.\n    if None in values:\n        print(\"NO\")\n    else:\n        # Verify all edges satisfy the constraints.\n        # This is crucial because some assignments might have been done incorrectly.\n        # So, for each edge, check if the GCD and LCM match.\n        valid = True\n        for u, v, g, l in edges:\n            a = values[u]\n            b = values[v]\n            if a * b != g * l:\n                valid = False\n                break\n            if gcd(a, b) != g:\n                valid = False\n                break\n            if l != (a * b) // g:\n                valid = False\n                break\n        if valid:\n            print(\"YES\")\n            print(' '.join(map(str, values)))\n        else:\n            print(\"NO\")\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\nThe code reads the input, constructs the graph, and attempts to assign values to each node using BFS with backtracking. For each node, it explores possible values based on the constraints imposed by its edges. If a valid assignment is found that satisfies all constraints, it prints \"YES\" followed by the values. If any inconsistency is found during the process, it prints \"NO\".",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom math import gcd\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    m = int(input[ptr])\n    ptr += 1\n\n    edges = []\n    for _ in range(m):\n        u = int(input[ptr])-1  # converting to 0-based\n        v = int(input[ptr+1])-1\n        g = int(input[ptr+2])\n        l = int(input[ptr+3])\n        ptr +=4\n        edges.append( (u, v, g, l) )\n\n    # Now, we need to assign values to each node.\n    # We'll represent the value of each node as a list, initializing to None.\n    values = [None] * n\n\n    # To avoid redundant processing, we'll process nodes in order, but since the graph could be disconnected,\n    # we need to handle each connected component separately.\n\n    # Let's collect all nodes and their edges, grouped by node.\n    node_edges = [[] for _ in range(n)]\n    for u, v, g, l in edges:\n        node_edges[u].append( (v, g, l) )\n        node_edges[v].append( (u, g, l) )\n\n    # Now, perform BFS for each node that hasn't been assigned yet.\n    # We'll also track which nodes have been processed to avoid revisiting.\n    processed = [False] * n\n    result = []\n\n    for i in range(n):\n        if processed[i]:\n            continue\n        if values[i] is not None:\n            # This node has been assigned elsewhere; proceed.\n            continue\n        queue = deque()\n        queue.append( (i, []) )  # (current node, path)\n        while queue:\n            u, path = queue.popleft()\n            if values[u] is not None:\n                # Check if the current path assigns a different value than existing.\n                if values[u] != path[0]:\n                    continue\n                # Continue with the rest of the path.\n                for (v, g, l) in node_edges[u]:\n                    if values[v] is None:\n                        # Try assigning v's value based on u's value.\n                        # From the equation a * b = g * l\n                        # Since u's value is path[0], let's compute possible values for v.\n                        # Also, the other way around.\n                        # Wait, for each edge, both nodes can be assigned in either way.\n                        # So for each edge, we need to consider possible assignments.\n                        # So for each edge, the two nodes' values must satisfy the constraints.\n                        # So for the current edge, we can model the possible values for v based on u's value.\n                        # Let me think: Suppose u's value is x, then v's value must be such that:\n                        # gcd(x, y) = g and lcm(x, y) = l.\n                        # So y must be a multiple of g, and x must be a multiple of g.\n                        # But wait, no: the edge's g is the gcd of the two nodes, so both must be multiples of g.\n                        # So x and y are both multiples of g. Let me set x = g * a, y = g * b.\n                        # Then, gcd(a, b) = 1, and lcm(a, b) = l/g.\n                        # So a and b are coprimes, and a*b = (l/g)/g = l/(g^2)? Wait, no:\n                        # Wait, the edge's l is the lcm of x and y, which is g*a*b, since x = g*a, y = g*b, and gcd(a, b)=1.\n                        # So, l = g*a*b => a*b = l/(g).\n                        # So, for the edge, a*b = k, where k = l/(g), and a and b are coprimes.\n\n                        # So, when trying to assign v's value, given u's value is x, which is a multiple of g, we can compute possible values for v.\n                        # Similarly, if v's value is known, we can compute u's value.\n\n                        # But in this case, we're processing the edge from u to v, and u's value is already known (from path).\n                        # So, we can compute what v's value must be.\n\n                        # So, given u's value is x = a*g, then v's value must be y = b*g, where a*b = k and gcd(a,b)=1.\n\n                        # So, for each possible pair (a, b) where a*b = k and gcd(a, b)=1, we can assign y = b*g.\n\n                        # Wait, but how do we know which one to choose? Because it's possible that v has already been assigned another value, which may conflict.\n\n                        # So, perhaps the approach is to try all possible assignments, but since it's a lot, we need a smarter way.\n\n                        # Alternative approach: for each edge, once we have u's value, we can compute possible v's values.\n\n                        # So, suppose u's value is x, which is a multiple of g. Let's compute the required y.\n\n                        # Since x and y must have gcd g, let x = g * a, y = g * b, with a and b coprimes.\n                        # Then, lcm(x, y) = g * a * b = l => a*b = l / g.\n\n                        # So, given x = a*g, y must be such that a*b = (l / g), and b must be coprime with a.\n\n                        # So, given x, we can compute possible y's.\n\n                        # But for this problem, it's easier to model as a graph where each node's value is determined by its constraints.\n\n                        # Hmm, perhaps the best approach is to model this as a system of equations where each node's value is determined by its edges, and use BFS with backtracking.\n\n                        # So, for the current node u, we have a value x. Then, for each edge (u, v, g, l), we can compute possible y for v.\n\n                        # So, for each possible (a, b) pair where a*b = k (k = l/g) and gcd(a,b) = 1, we can set y = a*g or b*g.\n\n                        # Wait, but this leads to multiple possibilities, which can explode the state space.\n\n                        # Maybe we can represent the possible values of a node as a dictionary, and during BFS, only proceed when the current assignment doesn't conflict with existing ones.\n\n                        # So, perhaps the way to proceed is to represent the possible values for each node and their dependencies.\n\n                        # This is getting complicated. Maybe a better approach is to model the constraints as a graph and use BFS to assign values step by step.\n\n                        # Let me think differently. For each node, the value must be a multiple of g for each edge connected to it. Wait, no: the GCD for each edge is g, so each node connected to it must be a multiple of g.\n\n                        # Wait, no. The GCD of the two nodes is g, meaning that both nodes must be multiples of g. So for each node, all edges connected to it must have a GCD that divides the node's value.\n\n                        # So, for each node, its value must be a multiple of all GCDs from its edges. Therefore, the node's value must be a multiple of the least common multiple of all GCDs from its edges.\n\n                        # Wait, but that might not be the case because the GCD for each edge is specific to that edge. So the node's value must be a multiple of each GCD from its edges, but the overall node's value must be a common multiple of all those GCDs.\n\n                        # Alternatively, perhaps the node's value must be a multiple of the GCD of all the individual edge GCDs.\n\n                        # This seems too vague. Maybe it's better to model the problem using the constraints between pairs of nodes.\n\n                        # So, for each edge (u, v, g, l), u and v must satisfy:\n\n                        # 1. a = g * a'\n                        # 2. b = g * b'\n                        # 3. gcd(a', b') = 1\n                        # 4. a' * b' = l / g\n\n                        # So, for each edge, the possible pairs (a', b') are factors of k = l/g, with a' and b' coprimes.\n\n                        # So, for each edge, we can precompute all possible (a', b') pairs and thus the possible (a, b) pairs.\n\n                        # Then, during BFS, when we have the value of one node, we can determine possible values for the connected nodes.\n\n                        # So, perhaps the way to proceed is to assign values in a BFS manner, starting from nodes with the fewest constraints.\n\n                        # However, due to the complexity, I think a backtracking approach might be necessary.\n\n                        # Let's try implementing a BFS-based solution where each time we assign a value to a node, we propagate this assignment to its neighbors, checking for consistency.\n\n                        # So, the steps are:\n\n                        # 1. For each node, if not assigned, start a BFS.\n                        # 2. In the BFS, track the current assignment and possible values for connected nodes.\n                        # 3. For each edge, based on the current assignment of one node, compute possible values for the other node.\n                        # 4. If the other node is unassigned, add it to the queue with the computed value.\n                        # 5. If the other node is already assigned, check for consistency. If inconsistent, backtrack.\n\n                        # Implementing this requires careful handling of the constraints and backtracking when a contradiction is found.\n\n                        # Given the complexity, I think the problem can be modeled using a Union-Find structure, but I'm not sure. Alternatively, a constraint satisfaction problem approach might be needed.\n\n                        # For the purpose of this solution, I'll implement a BFS-based approach with backtracking to handle the constraints.\n\n                        # Let's outline the code:\n\n                        # - Read input and build the graph.\n                        # - For each node, if not processed, attempt to assign a value.\n                        # - Use a queue to manage the BFS, tracking the current assignment.\n                        # - For each edge, compute possible values based on the current assignment and constraints.\n                        # - If a node is already assigned, check for consistency; if not, backtrack.\n\n                        # Now, considering the code structure:\n\n                        # We'll represent the values as a list. For each node, if it's not assigned, we'll try to assign it a value and propagate.\n\n                        # The main loop will process each node, and for each edge, compute possible values for connected nodes.\n\n                        # Due to the potential for multiple valid solutions, we'll need to efficiently manage the assignments and backtracking.\n\n                        # So, let's proceed to implement this logic.\n\n    # The above approach is quite involved. Instead, perhaps a better way is to model the problem as a system of equations and use a BFS approach to assign values step by step.\n\n    # After much consideration, I think the correct approach is to represent each node's value as a variable and use BFS with backtracking to assign values based on the constraints.\n\n    # Now, let's write the code.\n\n    # We'll use a dictionary to keep track of the current value of each node. Initially, all are None.\n\n    # For each node, if it's not yet assigned, we'll start a BFS to assign its value.\n\n    # For each edge, we'll compute possible values for the connected nodes based on the current assignment.\n\n    # We'll use a queue to manage the BFS, and a visited set to track which nodes have been processed.\n\n    # Now, let's proceed to write the code.\n\n    # Initialize the values as None.\n    values = [None] * n\n\n    # For each node, if it's not assigned, attempt to assign it.\n    for i in range(n):\n        if values[i] is None:\n            # Try to assign a value to node i.\n            # To do this, we need to consider all edges connected to i and see if they impose any constraints.\n            # But since the edges are bidirectional, we need to process them accordingly.\n            # We'll use a BFS approach to assign values.\n\n            # We'll create a queue that holds tuples of (node, current_value).\n            queue = deque()\n            queue.append( (i, None) )\n\n            while queue:\n                u, current_val = queue.popleft()\n\n                if current_val is not None:\n                    # We've been called back to a node that's already been assigned.\n                    # Check if the current_val matches the stored value.\n                    if values[u] is not None and values[u] != current_val:\n                        # Contradiction found; backtrack.\n                        continue\n                    else:\n                        # Continue processing.\n                        for (v, g, l) in node_edges[u]:\n                            if values[v] is None:\n                                # Compute possible values for v based on u's current_val.\n                                # So, for the edge (u, v, g, l), we have:\n                                # a = current_val\n                                # b must satisfy: gcd(a, b) = g and lcm(a, b) = l\n                                # So, a and b must be multiples of g.\n                                # Let a = g * a', b = g * b'\n                                # Then, gcd(a', b') = 1 and lcm(a', b') = l/g\n                                # So, a' * b' = l/g, and gcd(a', b') = 1.\n\n                                # Compute k = l // g\n                                k = l // g\n                                # Now, find all pairs (a', b') such that a' * b' = k and gcd(a', b') = 1.\n                                # For each such pair, b = g * b' is a possible value for v.\n\n                                # Find all divisors of k.\n                                factors = set()\n                                for i in range(1, int(k**0.5) + 1):\n                                    if k % i == 0:\n                                        factors.add(i)\n                                        factors.add(k // i)\n\n                                possible_pairs = []\n                                for a in factors:\n                                    if k % a == 0:\n                                        b = k // a\n                                        if gcd(a, b) == 1:\n                                            possible_pairs.append( (a, b) )\n\n                                # Now, for each possible (a', b'), compute b = g * b'\n                                # So, possible_values = [g * b for (a, b) in possible_pairs]\n                                possible_values = []\n                                for (a, b) in possible_pairs:\n                                    possible_values.append(g * b)\n\n                                # Also, the reverse is possible: v's value could be a, and u's could be b.\n                                # So, we need to consider both directions.\n\n                                # Wait, no: because the edge is from u to v, and u's value is already known.\n                                # So, we need to compute v's possible values based on u's current_val.\n\n                                # But in the code above, possible_values contains all possible b's.\n\n                                # Now, for each possible value in possible_values, if it's consistent with v's existing value, add it to the queue.\n\n                                for val in possible_values:\n                                    if values[v] is None:\n                                        # Assign val to v and add to queue.\n                                        values[v] = val\n                                        queue.append( (v, val) )\n                                    else:\n                                        if val != values[v]:\n                                            # Inconsistent; skip this possibility.\n                                            pass\n                                        else:\n                                            # Add to queue.\n                                            queue.append( (v, val) )\n                            else:\n                                # The value of v is already assigned. Check if it's compatible with current_val.\n                                if values[v] is not None:\n                                    # Check if the current_val and values[v] are compatible.\n                                    # That is, their product must equal g * l, and their GCD must be g.\n                                    a = current_val\n                                    b = values[v]\n                                    if a * b != g * l:\n                                        continue\n                                    if gcd(a, b) != g:\n                                        continue\n                                    if l == (a * b) // g:\n                                        # It's compatible. Add to queue.\n                                        queue.append( (v, b) )\n                                else:\n                                    # v is not assigned yet. Compute possible values for v based on current_val.\n                                    # Same as before.\n                                    k = l // g\n                                    factors = set()\n                                    for i in range(1, int(k**0.5) + 1):\n                                        if k % i == 0:\n                                            factors.add(i)\n                                            factors.add(k // i)\n\n                                    possible_pairs = []\n                                    for a in factors:\n                                        if k % a == 0:\n                                            b = k // a\n                                            if gcd(a, b) == 1:\n                                                possible_pairs.append( (a, b) )\n\n                                    possible_values = [g * b for (a, b) in possible_pairs]\n\n                                    for val in possible_values:\n                                        if values[v] is None:\n                                            values[v] = val\n                                            queue.append( (v, val) )\n                                        else:\n                                            if val != values[v]:\n                                                pass\n                                            else:\n                                                queue.append( (v, val) )\n    # After processing all nodes, check if all values are assigned.\n    if None in values:\n        print(\"NO\")\n    else:\n        # Verify all edges satisfy the constraints.\n        # This is crucial because some assignments might have been done incorrectly.\n        # So, for each edge, check if the GCD and LCM match.\n        valid = True\n        for u, v, g, l in edges:\n            a = values[u]\n            b = values[v]\n            if a * b != g * l:\n                valid = False\n                break\n            if gcd(a, b) != g:\n                valid = False\n                break\n            if l != (a * b) // g:\n                valid = False\n                break\n        if valid:\n            print(\"YES\")\n            print(' '.join(map(str, values)))\n        else:\n            print(\"NO\")\n\nif __name__ == '__main__':\n    main()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 544,
        "completion_token_count": 4332,
        "thoughts_token_count": 1025
    }
}