{
    "start": 1758338783.5275426,
    "end": 1758339277.7893934,
    "start-formatted": "2025-09-20 12:26 KST",
    "end-formatted": "2025-09-20 12:34 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\nOkay, let's see. The problem is to find the smallest non-negative integer k such that the LCM of (a +k) and (b +k) is minimized. And if there are multiple k's with the same minimal LCM, pick the smallest one.\n\nHmm. So first, I need to understand how the LCM of two numbers behaves when we add the same k to both. Let me think about the LCM formula. The LCM of two numbers x and y is (x * y) / gcd(x, y). So, if I have x = a +k and y = b +k. Let's denote d = |a - b|. Because adding k to both a and b makes their difference remain the same. Wait, because (a +k) - (b +k) = a -b. So the difference between the two numbers is fixed as d = |a -b|. Let me assume that a ≤ b, so that d = b -a. Then, the two numbers are (a +k) and (a +k +d). So their difference is d. \n\nSo the problem reduces to finding k such that the LCM of (x) and (x +d) is minimized, where x = a +k. And since k is non-negative, x must be ≥ a (if a ≤ b). But maybe I should consider the case where a and b are swapped. So perhaps first, I can swap a and b if necessary to make sure that a ≤ b, so that d = b -a.\n\nSo the key here is that for the two numbers x and x +d, their LCM is (x*(x+d))/gcd(x, x+d). But since x and x +d have a gcd equal to gcd(x, d). Because gcd(x, x +d) = gcd(x, d). So the LCM becomes (x*(x +d)) / gcd(x, d). \n\nSo the problem becomes: find x ≥ a (since x = a +k, and k ≥ 0) such that (x*(x +d))/g is minimized, where g is gcd(x, d). And then find the minimal k corresponding to that x. \n\nWait, but x can be any number ≥ a, but since d is fixed (as b -a), perhaps we can find x such that x is a multiple of some divisor of d, or something like that. Because the gcd(x, d) depends on the divisors of d.\n\nBut how do I minimize the LCM? Let's think. For fixed d, the LCM of x and x +d depends on x and the gcd(x, d). Let me think of x as varying, and trying to find the minimum value of LCM(x, x+d).\n\nAlternatively, since x and x +d have a difference of d, perhaps the minimal LCM occurs when x is chosen such that x and x +d are as small as possible and share a large common divisor. Because the LCM is (x(x +d))/g, and larger g would reduce the LCM.\n\nSo, perhaps the optimal x is such that x is a multiple of some divisor of d. Let me think. For example, suppose d is fixed. Let's take the example from the problem. In the first sample input, a=6, b=10. So d is 4. Then, x is a +k = 6 +k, and x +d is 6 +k +4 = 10 +k. So the two numbers are x and x+4. The LCM is (x(x+4))/g, where g is gcd(x,4). \n\nIn the sample, when k=2, x is 8. Then x+4 is 12. Their gcd is 4. So LCM is (8*12)/4 = 24. Which is the minimal. \n\nWhat if we look for x such that x is a divisor of d? Or maybe x is chosen such that x is a divisor of d, but not sure. Alternatively, perhaps the minimal LCM occurs when x is chosen as a divisor of d, or something similar.\n\nWait, but x can be anything. However, the minimal LCM would be achieved when x and x +d have as high as possible gcd. Because the LCM is (x(x +d))/g. So higher g reduces the LCM. So for a given d, the optimal x is one that maximizes g = gcd(x, d). \n\nBut how can we find such x?\n\nLet me think. Let's suppose that d is fixed. Let me denote g as the gcd(x, d). Then, since g divides d, we can write d = g * m. Also, since x is divisible by g, let x = g * t. Then, the gcd(x, d) is g * gcd(t, m). Wait, no. Since d = g * m, and x = g * t. Then, the gcd(g t, g m) is g * gcd(t, m). But since we have that g is the gcd(x, d), which implies that gcd(t, m) = 1. Because otherwise, the gcd would be larger than g. So in this case, for x = g * t, where t and m are coprime. \n\nBut then, the LCM of x and x +d is (x (x +d )) / g. Substituting x = g t and d = g m:\n\nx +d = g t + g m = g (t + m). So the LCM is (g t * g (t + m)) / (g) ) = g t (t + m) = g t (t + m). \n\nBut since m = d/g, and since m and t are coprime (because earlier step). So the LCM is g * t * (t + m). \n\nBut since m = d/g, this becomes g * t * (t + d/g). \n\nNow, since t and m are coprime, and m is d/g. \n\nBut how can I find the minimal value of this expression? Well, since t can be any positive integer such that x = g t ≥ a. \n\nBut wait, x = a +k, so x must be ≥ a. So for each possible divisor g of d, I can try to find the minimal t such that x = g t ≥ a, and then compute the LCM as g t (t + m), where m = d/g. Then, among all these possibilities, find the minimal LCM.\n\nBut how to find the possible g's? Well, since g is a divisor of d. Because in the previous analysis, g is the gcd(x, d), which divides d. So for each possible divisor g of d, we can consider it as a candidate. \n\nSo the approach could be:\n\n- Compute d = |a - b|. If d is zero, then a = b. Then, the LCM of a +k and a +k is a +k. So the minimal is achieved when k is 0, since a +k is minimized. So output 0 in that case.\n\nOtherwise, for d > 0:\n\n- Find all divisors of d. For each divisor g of d, compute m = d/g. Then, find the minimal t such that x = g*t >= a (since x = a +k, k must be >= 0 => x >= a). Then, compute the LCM value for that t, which is g * t * (t + m). \n\nBut since m is d/g, and t can be any positive integer. However, for each g, the minimal t would be ceil(a / (g)), but since x must be >= a, and x = g * t. So t_min = max(ceil(a/(g)), 1). Wait, but if a is already divisible by g, then t_min is a/g. Otherwise, it's floor(a/g) + 1. \n\nOnce we find t_min for each g, compute the corresponding LCM value. Then, among all possible divisors g of d, and their corresponding t_min, find the one that gives the minimal LCM. Then, among those, select the minimal k (which would correspond to x = g*t_min, and k = x -a).\n\nBut also, there's another possibility. What if the minimal LCM is achieved when x is not a multiple of any divisor of d? Or is it guaranteed that the optimal x is such that x is a multiple of some divisor of d?\n\nWell, according to the previous analysis, the LCM is minimized when the gcd(x, d) is as large as possible. Therefore, for each possible divisor of d, we can check the minimal t that gives x >= a. Then, among all these possibilities, choose the one with minimal LCM. \n\nBut why is that? Because for each possible g (divisor of d), the maximum possible gcd(x, d) is g. So by considering all possible divisors of d, we can find the maximum possible g, and thus minimize the LCM. \n\nSo the plan is:\n\n1. Compute d = |a - b|. If d is zero, return 0.\n\n2. Else, find all divisors of d. For each divisor g of d:\n\n   a. Compute m = d/g.\n\n   b. Find the minimal t such that g * t >= a. Let's call this t_min. Since x = g * t must be >= a. So t_min is ceil(a / g). However, since t must be a positive integer (since x is at least a, which is >=1).\n\n   c. Then, compute the LCM value for this t_min: LCM = g * t_min * (t_min + m). \n\n   d. Also, note that for this t_min, the corresponding x is g * t_min, and k is x -a. \n\n3. Among all these possibilities, find the one with the minimal LCM. If multiple options have the same LCM, choose the one with the smallest k. \n\nBut wait, there's another case. What if there are other values of x (not multiples of any divisor of d) that could give a better LCM? For example, suppose that for some x, the gcd(x, d) is not a divisor of d. But that's impossible, because the gcd(x, d) must divide d. So the maximum possible gcd(x, d) is a divisor of d. Therefore, considering all divisors of d is sufficient. \n\nThus, the approach of checking all divisors of d is correct.\n\nSo now, the steps are:\n\nFirst, compute d = |a - b|.\n\nIf d is zero, then output 0.\n\nElse, generate all the divisors of d. For each divisor g of d, compute the minimal t_min such that x = g * t_min >= a, then compute the LCM value. Then choose the minimal LCM and the corresponding k.\n\nBut how to generate all divisors of d? Well, for a number up to 1e9, generating all divisors can be done by factoring into primes and generating all combinations. However, for d up to 1e9, this is manageable. \n\nWait, but how to generate the divisors of d? Let's think. For example, for d, we can find all its divisors by checking up to sqrt(d). For each i that divides d, add i and d/i to the list of divisors. Then, after collecting all, we can sort them. \n\nBut since d can be up to 1e9, the number of divisors is manageable (for example, even the worst case for 1e9 is 100 divisors or so).\n\nOnce we have all the divisors, we can process each of them.\n\nBut wait, what about the divisors of d, but also the divisors of d's factors. For example, if d is 4, the divisors are 1, 2, 4. So for each of those, we process.\n\nOnce we have all the divisors, we process each one as a possible g.\n\nBut there's also another thing: for each divisor g of d, there's a corresponding m = d/g. But in the previous example, for each g, we can compute the minimal t_min. However, perhaps there are multiple t's for each g, but the minimal t is the best choice, since increasing t would increase the LCM.\n\nFor example, for a fixed g, the LCM is g * t * (t + m). As t increases, this value increases. Therefore, for each g, the minimal possible t (the minimal t that makes x >=a) will give the minimal LCM for that particular g.\n\nSo for each g, we only need to consider the minimal t for that g.\n\nOnce we have all possible candidates from all divisors of d, we can compare them and find the best one.\n\nBut also, there's another case: when x is such that x +d is smaller than x. Wait, no, since x is a +k, and d is positive. So x +d is larger than x. So the LCM is between x and x +d, which is larger than x. \n\nBut how about the case where x is such that x and x +d are multiples of some number. For example, if x is chosen as (some number) such that x is a multiple of a higher g, which is a divisor of d.\n\nSo, the approach is to generate all the possible candidates for each divisor of d, and then select the best one.\n\nNow, let's think about the sample input.\n\nSample Input 1: 6 10 → d = 4. Divisors of 4 are 1, 2, 4.\n\nFor each divisor:\n\nCase g=1: m = 4/1 = 4. t_min is ceil(6 / 1) = 6. So x = 6*1 = 6. Then LCM is 1 * 6 * (6 +4) = 6 *10 = 60.\n\nCase g=2: m =4/2=2. t_min is ceil(6/2) = 3. x = 2*3=6. LCM is 2 *3*(3 + 2) = 2*3*5=30.\n\nCase g=4: m =4/4=1. t_min is ceil(6/4)=2. x=4*2=8. LCM is 4*2*(2+1) = 4*2*3=24. Which is the sample answer. \n\nSo among the three options, 24 is the minimal. So the best is when g=4, t=2. Then k is x -a =8-6=2. Which matches the sample.\n\nAnother sample input: 5 and 10. d is 5. Divisors are 1,5.\n\nCase g=1: m=5. t_min is 5. x=5. LCM is 1*5*(5+5) = 50.\n\nCase g=5: m=1. t_min is ceil(5/5) =1. x=5*1=5. LCM is 5 *1*(1 +1) = 5*2=10. Which is better. So k is 5-5=0. Which matches the third sample.\n\nAnother sample input: 21 and 31. d=10. Divisors of 10 are 1,2,5,10.\n\nFor each:\n\ng=1: m=10. t_min is ceil(21/1) =21. LCM is 1*21*(21+10) = 21*31= 651.\n\ng=2: m=5. t_min is ceil(21/2) = 11. x=2*11=22. LCM is 2 *11*(11+5) = 2*11*16 = 352.\n\ng=5: m=2. t_min is ceil(21/5) =5 (since 5*4=20 <21, 5*5=25 >=21). So x=25. LCM is 5*5*(5+2) =5*5*7=175.\n\ng=10: m=1. t_min is ceil(21/10) =3. x=10*3=30. LCM is 10 *3*(3+1) =10*3*4=120. \n\nBut the sample output is 9. Wait, what's happening here? Let's see. The sample input is 21 and 31. So a=21, b=31. So d=10. So the code's approach would suggest that the minimal LCM is 120, achieved when k=30-21=9. Which matches the sample output. So yes. So the code's approach works here.\n\nSo the code seems to work for the samples.\n\nSo the plan is:\n\n- Compute d = absolute difference between a and b.\n\n- If d is zero, output 0.\n\n- Else, generate all the divisors of d.\n\n- For each divisor g, compute m = d/g.\n\n- Compute t_min as the minimal t such that g * t >= a. Which is t_min = ceil(a / g). But since a and g are integers, how to compute that? Well, in Python, it can be done as (a + g -1) // g.\n\n- Then compute the LCM value as g * t_min * (t_min + m).\n\n- Also, compute the corresponding k for this case, which is x -a = g*t_min -a.\n\n- Then, among all these possibilities, find the one with the minimal LCM. If there are multiple, choose the one with the smallest k.\n\nBut wait, there's another possibility. What if there are multiple divisors that lead to the same LCM? For example, two different divisors leading to same LCM. Then, we need to choose the one with the smallest k.\n\nSo, the steps are:\n\nCollect all possible candidates (each with their LCM value and k), then select the candidate with the smallest LCM. If there are multiple, select the one with the smallest k.\n\nBut how to generate all the divisors of d?\n\nNow, the code steps:\n\nImplement a function to generate all divisors of a number.\n\nBut first, handle the case where a and b are equal. Then, the minimal k is 0.\n\nElse, compute d = abs(a - b). Generate all divisors of d.\n\nOnce we have all divisors, for each divisor g, compute the candidate.\n\nBut also, note that for each divisor g, the same g can be considered once. However, for example, for d=4, divisors are 1, 2, 4. So we process each once.\n\nOnce all candidates are generated, select the best one.\n\nNow, the code:\n\nBut how to generate all the divisors of d?\n\nLet me think. For example, for d, we can loop from 1 to sqrt(d), and for each i that divides d, add i and d//i to the list. Then, after collecting all, we can deduplicate and sort.\n\nBut in Python, for a given d, here's how to generate the divisors:\n\ndef get_divisors(d):\n    divisors = set()\n    for i in range(1, int(math.sqrt(d)) + 1):\n        if d % i == 0:\n            divisors.add(i)\n            divisors.add(d // i)\n    return sorted(divisors)\n\nBut for d=0? No, in our case, d is non-zero, since we handled the case when a = b.\n\nOnce we have all the divisors, process each.\n\nNow, for each candidate, compute the LCM value and k.\n\nOnce all candidates are generated, select the one with the minimal LCM. If tie, the minimal k.\n\nBut what about the case where there's a better k that is not covered by the divisors? For example, perhaps when choosing x such that x is not a multiple of any divisor of d, but gives a better LCM. But according to earlier reasoning, that's not possible. Because the maximum possible gcd(x, d) is a divisor of d. So for each x, the corresponding g is a divisor of d. So considering all divisors is sufficient.\n\nBut let me think of a counterexample. Suppose d=6. Let's say a=3, so x must be >=3. Let's say we take x=4. Then, d=6. So x=4, x +d = 10. gcd(4,6) is 2. Which is a divisor of 6. So for this case, the code would have considered g=2. So the code would process all possibilities. Thus, the code is correct.\n\nSo, the code approach is correct.\n\nNow, implement this in Python.\n\nNow, code steps:\n\nRead a and b from input. For example, the input is a line with two integers. So:\n\nimport math\n\ndef get_divisors(d):\n    divisors = set()\n    for i in range(1, int(math.isqrt(d)) +1):\n        if d % i == 0:\n            divisors.add(i)\n            divisors.add(d//i)\n    return list(divisors)\n\nThen, for the main code:\n\na, b = map(int, input().split())\n\nif a == b:\n    print(0)\nelse:\n    d = abs(a - b)\n    divisors = get_divisors(d)\n    min_lcm = float('inf')\n    best_k = float('inf')\n    for g in divisors:\n        m = d // g\n        # compute t_min: minimal t where g*t >= a\n        # t_min = ceil(a / g)\n        t_min = (a + g -1) // g\n        x = g * t_min\n        current_lcm = g * t_min * (t_min + m)\n        current_k = x - a\n        # compare with current min\n        if current_lcm < min_lcm or (current_lcm == min_lcm and current_k < best_k):\n            min_lcm = current_lcm\n            best_k = current_k\n    print(best_k)\n\nWait, but what about when a is larger than b? For example, if a is larger than b, then d is a -b. But in the code, the code uses a and b as given. But when a is larger than b, then the code would compute d as a -b. Then, the code proceeds. However, in the code, the variable 'a' is used in the calculation of t_min. But when a is larger than b, then in the original problem, the x is a +k, and the other number is b +k. But since d is a -b, then x is a +k, and the other number is (b +k) = x -d. So the difference between x and (x -d) is d. But then, the code is still correct because the code uses d as the difference between the two numbers. \n\nBut in the code above, the code uses a as the lower bound for x. But if a was originally larger than b, then in the code, when we compute x = a +k, but the original problem is that x is a +k and y is b +k. But since d is |a -b|, and in that case, if a is larger than b, then the difference between x and y is a -b =d. So, in that case, x is a +k, and y = x -d. So for x to be >= a, but since a is larger than b, but in the code, the code uses a as the lower bound. However, in this scenario, when a is larger than b, then the code would compute d as a -b. Then, for the code, the x is a +k, which is >= a. But in that case, the code's logic is correct because the other number is x -d = (a +k) - (a -b) = b +k, which is correct. \n\nBut the code uses a as the lower bound for x. But if a is larger than b, then the code may not capture the optimal k. Wait, no. Because for example, if a is larger than b, then the code uses d = a -b. Then, when we compute the divisors of d, and for each divisor g, compute t_min such that x = g * t_min >= a. But the x is a +k. So, in that case, the code is correct.\n\nBut what if the optimal k is such that x is less than a? For example, if a is larger than b, and k is negative. But the problem states that k must be non-negative. So x can't be less than a. Because k is non-negative. So, the code is correct in using x >= a.\n\nWait, but if a is larger than b, then the code uses x = a +k, but the other number is b +k. Since k is non-negative, then the other number is b +k. But since a is larger than b, and k is non-negative, then x is larger than the other number. However, the code's approach of considering x as the larger number (since x is a +k) is correct. \n\nBut regardless of whether a is larger or smaller than b, the code uses d = |a -b|, and then considers x as the larger of the two numbers (since x is a +k, and if a is larger than b, then x is larger than the other number, but if a is smaller than b, then x is a +k, and the other number is larger. But the code treats x as the variable, and the difference between the two numbers is d. So the code is correct.\n\nSo the code seems correct. But let's test the sample inputs.\n\nSample 1: input 6 10 → a=6, b=10. d=4. divisors are 1, 2, 4. The code processes them as before. The best is k=2. Correct.\n\nSample 2: input 21 31 → a=21, b=31. d=10. Divisors 1, 2, 5, 10. For each:\n\ng=1: t_min = 21 → x=21, LCM is 1*21*(21 +10) = 21*31=651. k=0.\n\nWait, no. Wait, for g=1, m =d/g=10/1=10. So LCM is 1 * t_min * (t_min +10). t_min is (21 +1 -1)/1 = 21. So 21 * (21 +10) = 21 *31 = 651. current_k is 21 -21 =0. But in the sample, the correct k is 9. So why is this candidate not being selected?\n\nAh, because in the code, the code is considering all divisors. For example, for g=10, m=1. t_min is (21 +10 -1)//10 = (30) //10 =3. x=10*3=30. So current_k is 30 -21 =9. Which is the sample's correct answer. The code would compare all possibilities, including the g=1 case. The code would select the minimal LCM. For the g=10 case, the LCM is 10 *3*(3 +1) = 10*3*4=120. Which is better than 651. So the code would select that. So the code works.\n\nAnother sample: input 5 10. a=5, b=10. d=5. divisors are 1,5. For g=5, t_min is (5 +5-1)//5 = (9)//5=1. x=5*1=5. current_k=5-5=0. Which is correct.\n\nSo the code seems correct.\n\nBut what about when a is larger than b?\n\nLet's take an example where a=10, b=6. Then d=4. The code would process the same divisors as before. For each g, the code computes t_min as (a +g -1)//g. a is 10. So for g=4, t_min is (10 +4-1)//4 =13//4=3. x=4*3=12. So k is 12 -10 =2. Which is the same as the first sample. The LCM is (12, 6 +2=8). LCM(12, 8) is 24. Which is correct. So the code works regardless of whether a is larger or smaller than b.\n\nAnother test case: when a=3, b=5. d=2. divisors are 1,2.\n\nFor g=1: t_min =3 → x=3. LCM(3, 5) is 15. k=0.\n\nFor g=2: m=1. t_min is (3 +2-1)//2 = (4)//2=2 → x=4. LCM(4, 4+2=6) → LCM(4,6)=12. Which is better. So k is 4-3=1. So the best is k=1. Which is correct.\n\nSo the code would output 1. Which is correct.\n\nAnother test case: a=4, b=6. d=2. divisors 1, 2.\n\ng=1: t_min=4 → x=4. LCM(4,6)=12. k=0.\n\ng=2: t_min is (4 +2-1)//2 = (5)//2=2 → x=4. k=0. LCM is 4 and 6 again. So same as before. So the code would select the same k=0. Which is correct.\n\nSo the code would compare the two options. For g=1, current_lcm is 1 *4*(4 + 2/1) = 4 *6=24? Wait, no. Let me re-calculate.\n\nWait, for g=1, m is d/g =2/1=2. So current_lcm is g * t_min * (t_min + m) = 1 *4 * (4 +2) =4*6=24. For g=2, m is 2/2=1. current_lcm is 2 * 2 * (2 +1) = 2*2*3=12. So the code would select the latter, which gives k=0. Which is correct.\n\nSo the code works.\n\nNow, what about when there are multiple divisors that result in the same LCM?\n\nFor example, a=2 and b=4. d=2. Divisors are 1, 2.\n\nFor g=1: t_min is 2. LCM is 1 * 2 * (2 +2) = 8.\n\nFor g=2: t_min is 1. LCM is 2 *1 * (1 +1) =4. So the code selects the latter. So k is 2*1 -2=0. Which is correct.\n\nBut suppose another case where two divisors produce same LCM. For example, a=3 and d=6. Let's say a=3, d=6. So divisors are 1, 2, 3, 6.\n\nFor example, let's say for g=2 and g=3, they produce same LCM.\n\nBut let's take an example. Let me think of a scenario where two different g's produce same LCM and different k's.\n\nBut regardless, the code would select the one with the smallest k.\n\nSo the code is correct.\n\nNow, code implementation.\n\nBut in the code, the divisors are generated as a list. However, in the code, when generating the divisors, the code uses math.isqrt (which is available in Python 3.8+). Alternatively, math.sqrt can be used, but math.isqrt is better for integer square roots.\n\nBut for the code to run in Python, perhaps using math.sqrt and cast to int.\n\nBut in Python, math.isqrt is available in Python 3.8+. However, for older versions, perhaps using int(math.sqrt(d)).\n\nBut assuming that the code is run in a modern environment, using math.isqrt is better.\n\nNow, code:\n\nimport math\n\ndef get_divisors(d):\n    divisors = set()\n    for i in range(1, int(math.isqrt(d)) + 1):\n        if d % i == 0:\n            divisors.add(i)\n            divisors.add(d // i)\n    return list(divisors)\n\nBut then, in the code, for the main part:\n\na, b = map(int, input().split())\n\nif a == b:\n    print(0)\nelse:\n    d = abs(a - b)\n    divisors = get_divisors(d)\n    min_lcm = float('inf')\n    best_k = float('inf')\n    for g in divisors:\n        m = d // g\n        t_min = (a + g - 1) // g\n        x = g * t_min\n        current_lcm = g * t_min * (t_min + m)\n        current_k = x - a\n        if current_lcm < min_lcm or (current_lcm == min_lcm and current_k < best_k):\n            min_lcm = current_lcm\n            best_k = current_k\n    print(best_k)\n\nWait, but what about the case when there are multiple divisors that produce the same LCM? For example, two different divisors leading to same LCM but different k. The code checks for current_lcm < min_lcm or (equal and smaller k). So that's handled.\n\nBut there's a problem here. What if the minimal LCM is achieved for a divisor g, but there is another divisor g' that leads to the same LCM but with a smaller k? The code would handle that.\n\nBut what about when there are multiple candidates with the same LCM? The code will track the best_k as the minimal one.\n\nBut what about when the same LCM can be achieved with different k's for the same g? For example, if there are multiple t's for the same g. But according to the code, for each g, only the minimal t is considered. Which gives the minimal possible LCM for that g. So, for example, if there are other t's for the same g, they would give larger LCMs, so they are not considered.\n\nSo the code is correct.\n\nBut wait, what about when there's a case where choosing a larger t for a certain g gives a better LCM? For example, perhaps not. Because for fixed g and m, the LCM is g * t * (t + m). Which is a quadratic function in t. So as t increases, the LCM increases. Hence, the minimal t for each g gives the minimal LCM for that g.\n\nTherefore, the code is correct.\n\nBut what about the case when the optimal k is not covered by the divisors? For example, when the optimal x is not a multiple of any divisor of d. But according to earlier reasoning, this is not possible.\n\nBut let's think of an example. Suppose d=6, a=4. So d=6. The divisors are 1, 2, 3, 6.\n\nFor each g:\n\ng=1: m=6. t_min = (4 +1 -1)/1 =4. LCM is 1 *4*(4 +6) =4*10=40. k=0.\n\ng=2: m=3. t_min=(4 +2-1)//2 =5//2=2. x=4. LCM is 2 *2*(2+3) = 2*2*5=20. k=0.\n\ng=3: m=2. t_min = (4 +3-1)/3 =6//3=2. x=6. LCM is 3*2*(2+2)= 3*2*4=24. k=6-4=2.\n\ng=6: m=1. t_min = (4 +6-1)//6 =9//6=1. x=6. LCM is 6*1*(1 +1) =6*2=12. k=6-4=2. \n\nSo the best is 12, with k=2. \n\nBut suppose there is another x, say x=3. But x must be >= a=4. So x=3 is invalid. So no. \n\nAnother example: a=5, d=6. Then, the divisors are 1, 2, 3, 6. \n\nFor g=3, t_min is (5 +3-1)/3 =7//3=2. x=6. LCM is 3*2*(2+2) =24. \n\nBut what if x=5? Then, the two numbers are 5 and 5 +6 =11. Their LCM is 5*11=55. Which is worse than 24. \n\nSo the code's approach is correct.\n\nAnother example: a=3, d=6. So divisors are same. For x=3, which is allowed (since a=3, k=0). Then, the two numbers are 3 and 9. LCM is 9. Which is better than the code's approach. Wait, but",
    "response": "To solve this problem, we need to find the smallest non-negative integer $ k $ such that the least common multiple (LCM) of $ a + k $ and $ b + k $ is minimized. If there are multiple values of $ k $ that yield the same minimal LCM, we should choose the smallest $ k $.\n\n### Approach\n1. **Understanding the Problem**: The key insight is that the difference between $ a $ and $ b $ remains constant when adding the same $ k $ to both. Let $ d = |a - b| $. The problem reduces to finding the optimal $ k $ such that the LCM of $ x $ and $ x + d $ is minimized, where $ x = a + k $.\n\n2. **Divisors of Difference**: The optimal value of $ x $ will be influenced by the divisors of $ d $. For each divisor $ g $ of $ d $, we compute the minimum $ t $ such that $ x = g \\cdot t $ is at least $ a $, ensuring $ k $ is non-negative.\n\n3. **LCM Calculation**: For each divisor $ g $, calculate the corresponding LCM of $ x $ and $ x + d $, and track the minimum LCM and the corresponding $ k $.\n\n4. **Edge Cases**: If $ a $ equals $ b $, the optimal $ k $ is 0 because the LCM of $ a + k $ and $ b + k $ is simply $ a + k $, which is minimized when $ k = 0 $.\n\n### Solution Code\n```python\nimport math\n\ndef get_divisors(d):\n    divisors = set()\n    for i in range(1, int(math.isqrt(d)) + 1):\n        if d % i == 0:\n            divisors.add(i)\n            divisors.add(d // i)\n    return list(divisors)\n\ndef main():\n    a, b = map(int, input().split())\n    if a == b:\n        print(0)\n        return\n    d = abs(a - b)\n    divisors = get_divisors(d)\n    min_lcm = float('inf')\n    best_k = float('inf')\n    for g in divisors:\n        m = d // g\n        t_min = (a + g - 1) // g\n        x = g * t_min\n        current_lcm = g * t_min * (t_min + m)\n        current_k = x - a\n        if current_lcm < min_lcm or (current_lcm == min_lcm and current_k < best_k):\n            min_lcm = current_lcm\n            best_k = current_k\n    print(best_k)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Divisors Calculation**: The function `get_divisors` computes all divisors of $ d $, which helps in evaluating potential values of $ x $ that might minimize the LCM.\n\n2. **Optimal $ k $ Calculation**: For each divisor $ g $ of $ d $, we calculate the minimum $ t $ such that $ x = g \\cdot t $ is at least $ a $. This ensures $ k $ is non-negative. The corresponding LCM is computed and compared to find the minimum.\n\n3. **Efficiency**: By focusing on divisors of $ d $, we efficiently explore potential candidates for $ x $, ensuring the solution is both optimal and efficient, even for large values of $ a $ and $ b $ up to $ 10^9 $.\n\nThis approach ensures that we consider all potential candidates for minimizing the LCM efficiently, leveraging mathematical properties of divisors and LCM calculations.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef get_divisors(d):\n    divisors = set()\n    for i in range(1, int(math.isqrt(d)) + 1):\n        if d % i == 0:\n            divisors.add(i)\n            divisors.add(d // i)\n    return list(divisors)\n\ndef main():\n    a, b = map(int, input().split())\n    if a == b:\n        print(0)\n        return\n    d = abs(a - b)\n    divisors = get_divisors(d)\n    min_lcm = float('inf')\n    best_k = float('inf')\n    for g in divisors:\n        m = d // g\n        t_min = (a + g - 1) // g\n        x = g * t_min\n        current_lcm = g * t_min * (t_min + m)\n        current_k = x - a\n        if current_lcm < min_lcm or (current_lcm == min_lcm and current_k < best_k):\n            min_lcm = current_lcm\n            best_k = current_k\n    print(best_k)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 403,
        "completion_token_count": 768,
        "thoughts_token_count": 8192
    }
}