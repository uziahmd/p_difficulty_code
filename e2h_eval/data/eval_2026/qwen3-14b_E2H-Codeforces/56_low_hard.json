{
    "start": 1758309280.9698105,
    "end": 1758309342.4749522,
    "start-formatted": "2025-09-20 04:14 KST",
    "end-formatted": "2025-09-20 04:15 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\nOkay, let's see. The problem is about determining whether there's a perfect matching between Rebel spaceships and bases such that none of the connecting lines intersect. So, each spaceship is assigned to exactly one base, and all those lines don't cross each other.\n\nFirst, I need to understand what conditions make two line segments intersect. Oh right, but since no three points are colinear, maybe that simplifies things. Because if two lines cross, they must form a crossing in the plane.\n\nSo the main idea is: check all possible perfect matchings between R and B (assuming R equals B, since the problem says \"every base has exactly one guardian\" and \"each spaceship has exactly one assigned base\", so R must equal B. Wait, the input says R and B can be up to 10. Wait, but the first line says R and B. Oh, but the problem says that the assignment is a perfect matching. So for that to be possible, R must equal B. But the input might have R != B? Wait, the problem says that the input is given with R and B, but the output is \"Yes\" or \"No\" based on whether there exists a perfect matching. So if R != B, then the answer is automatically No. Oh right! So first thing, check if R != B. If they are not equal, output No.\n\nBut the problem says that in the input, R and B are given. For example, in the sample input, the first case is 3 3, which is okay. The second is 2 1, which would automatically output No. But the sample output for the second input is 'No', which matches that.\n\nSo first step: check if R != B. If so, output No. Otherwise, proceed.\n\nNow, when R = B, we need to check if there exists a perfect matching between the R spaceships and B bases such that no two edges (connecting a spaceship to a base) cross each other.\n\nThe challenge is to find such a matching. How can we check this?\n\nThe problem is similar to checking if there's a non-crossing matching between two sets of points. For example, in computational geometry, there's a concept of non-crossing matchings, often related to convex hulls or sorting points.\n\nOne approach is to consider that if we can sort the points in some way and match them in order. For example, if we sort both the spaceships and bases in a certain order (like by x-coordinate, then y-coordinate), and then match them in order, perhaps that would avoid crossings. But how to verify this?\n\nAlternatively, since the number of possible matchings is small (since R and B are up to 10, then for R=10, the number of possible perfect matchings is 10! = 3.6 million, which is manageable for small N. So for R=B=10, 10! is about 3.6 million. Wait, but 10! is 3,628,800. For each possible permutation, we can check if the matching is non-crossing. If any of them is non-crossing, output Yes.\n\nBut how do we check if a given matching has any crossing lines?\n\nSo the plan is:\n\n- If R != B, return No.\n\n- Else, generate all possible permutations of the B bases (since each spaceship is matched to a unique base). For each permutation, check if the lines between spaceship i and base permutation[i] (for each i) have any crossings. If any permutation is found where no crossings exist, return Yes. Otherwise, return No.\n\nBut wait, the problem says that the assignment is a perfect matching. So for R=B=n, the number of possible perfect matchings is n! (since each spaceship is matched to exactly one base). So generating all permutations of the bases (assuming that the spaceships are ordered in some way) would cover all possibilities.\n\nBut how to represent the matchings? For example, suppose the spaceships are S_1, S_2, ..., S_n, and the bases are B_1, B_2, ..., B_n. Then a permutation p of the bases would correspond to matching S_i with B_p[i], for each i. But since the problem allows any assignment, perhaps we need to consider all possible bijections between the two sets. However, since the spaceships are given as a list, and the bases as another list, the permutations approach would work if we consider that for each permutation of the bases, we can assign the i-th spaceship to the permuted base.\n\nBut generating all permutations of the bases and checking for each if the matching is non-crossing is feasible for n up to 10. Let's think about the computational complexity.\n\nFor n=10, 10! is around 3.6 million. For each permutation, we need to check all pairs of lines to",
    "response": "To solve this problem, we need to determine if there exists a perfect matching between Rebel spaceships and bases such that no two connecting lines intersect. The solution involves checking all possible permutations of the bases and verifying if any permutation results in a non-crossing matching.\n\n### Approach\n1. **Check for Equal Numbers**: First, check if the number of spaceships (R) is equal to the number of bases (B). If they are not equal, it's impossible to have a perfect matching, so the answer is immediately \"No\".\n2. **Generate Permutations**: For the case where R equals B, generate all permutations of the bases. Each permutation represents a potential assignment of bases to spaceships.\n3. **Check for Non-Crossing Lines**: For each permutation, check if any pair of lines connecting spaceships to their assigned bases intersect. If a permutation is found where no lines intersect, output \"Yes\". If no such permutation exists, output \"No\".\n\n### Solution Code\n```python\nimport sys\nimport itertools\n\ndef read_input():\n    data = sys.stdin.read().split('\\n')\n    return data\n\ndef is_intersect(p1, p2, p3, p4):\n    # Check if line segments (p1,p2) and (p3,p4) intersect\n    # Using orientation method\n    def orientation(p, q, r):\n        val = (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0])\n        if val == 0:\n            return 0  # colinear\n        return 1 if val > 0 else 2  # clock or counterclock wise\n\n    o1 = orientation(p1, p2, p3)\n    o2 = orientation(p1, p2, p4)\n    o3 = orientation(p3, p4, p1)\n    o4 = orientation(p3, p4, p2)\n\n    if o1 != o2 and o3 != o4:\n        return True\n\n    # Special Cases\n    if o1 == 0 and on_segment(p1, p3, p2):\n        return True\n    if o2 == 0 and on_segment(p1, p4, p2):\n        return True\n    if o3 == 0 and on_segment(p3, p1, p4):\n        return True\n    if o4 == 0 and on_segment(p3, p2, p4):\n        return True\n\n    return False\n\ndef on_segment(p, q, r):\n    # Check if point q lies on line segment pr\n    return (min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and\n            min(p[1], r[1]) <= q[1] <= max(p[1], r[1]))\n\ndef main():\n    data = read_input()\n    input_lines = [line.strip() for line in data if line.strip()]\n    idx = 0\n    R, B = map(int, input_lines[idx].split())\n    idx += 1\n    rebels = []\n    for _ in range(R):\n        x, y = map(int, input_lines[idx].split())\n        rebels.append((x, y))\n        idx += 1\n    bases = []\n    for _ in range(B):\n        x, y = map(int, input_lines[idx].split())\n        bases.append((x, y))\n        idx += 1\n\n    if R != B:\n        print(\"No\")\n        return\n\n    # Generate all permutations of bases\n    from itertools import permutations\n    for perm in permutations(bases):\n        # Check all pairs of lines\n        valid = True\n        for i in range(R):\n            for j in range(i+1, R):\n                # Check if line between rebels[i] and perm[i] intersects with rebels[j] and perm[j]\n                if is_intersect(rebels[i], perm[i], rebels[j], perm[j]):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Reading Input**: The input is read and parsed into coordinates for spaceships and bases.\n- **Intersection Check**: The `is_intersect` function uses the orientation method to determine if two line segments intersect. This method checks the orientation of points to determine if segments cross.\n- **Permutations Check**: All permutations of the bases are generated, and each permutation is checked for non-crossing lines. If any permutation is found to be valid, \"Yes\" is printed; otherwise, \"No\" is printed after all permutations are checked.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport itertools\n\ndef read_input():\n    data = sys.stdin.read().split('\\n')\n    return data\n\ndef is_intersect(p1, p2, p3, p4):\n    # Check if line segments (p1,p2) and (p3,p4) intersect\n    # Using orientation method\n    def orientation(p, q, r):\n        val = (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0])\n        if val == 0:\n            return 0  # colinear\n        return 1 if val > 0 else 2  # clock or counterclock wise\n\n    o1 = orientation(p1, p2, p3)\n    o2 = orientation(p1, p2, p4)\n    o3 = orientation(p3, p4, p1)\n    o4 = orientation(p3, p4, p2)\n\n    if o1 != o2 and o3 != o4:\n        return True\n\n    # Special Cases\n    if o1 == 0 and on_segment(p1, p3, p2):\n        return True\n    if o2 == 0 and on_segment(p1, p4, p2):\n        return True\n    if o3 == 0 and on_segment(p3, p1, p4):\n        return True\n    if o4 == 0 and on_segment(p3, p2, p4):\n        return True\n\n    return False\n\ndef on_segment(p, q, r):\n    # Check if point q lies on line segment pr\n    return (min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and\n            min(p[1], r[1]) <= q[1] <= max(p[1], r[1]))\n\ndef main():\n    data = read_input()\n    input_lines = [line.strip() for line in data if line.strip()]\n    idx = 0\n    R, B = map(int, input_lines[idx].split())\n    idx += 1\n    rebels = []\n    for _ in range(R):\n        x, y = map(int, input_lines[idx].split())\n        rebels.append((x, y))\n        idx += 1\n    bases = []\n    for _ in range(B):\n        x, y = map(int, input_lines[idx].split())\n        bases.append((x, y))\n        idx += 1\n\n    if R != B:\n        print(\"No\")\n        return\n\n    # Generate all permutations of bases\n    from itertools import permutations\n    for perm in permutations(bases):\n        # Check all pairs of lines\n        valid = True\n        for i in range(R):\n            for j in range(i+1, R):\n                # Check if line between rebels[i] and perm[i] intersects with rebels[j] and perm[j]\n                if is_intersect(rebels[i], perm[i], rebels[j], perm[j]):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 485,
        "completion_token_count": 1006,
        "thoughts_token_count": 1024
    }
}