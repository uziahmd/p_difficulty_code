{
    "start": 1758313599.5236988,
    "end": 1758313804.5835183,
    "start-formatted": "2025-09-20 05:26 KST",
    "end-formatted": "2025-09-20 05:30 KST",
    "gpu": 2,
    "pid": 7,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\nOkay, let's try to figure out how to solve this problem. The task is to determine for a given number n whether there exists a snowflake graph as defined. Let's break down the problem.\n\nFirst, understanding the structure of the snowflake. The snowflake is built in a certain way. Let me rephrase the construction steps:\n\n- Start with one vertex.\n- Then, connect it to k new vertices (k>1). So after this step, there are 1 + k vertices.\n- Then, each vertex that has only one connection (so those added in the previous step) must be connected to k new vertices. This step must be done at least once. \n\nWait, so the process is like a tree where each node is expanded in a certain way. Let me think about the structure.\n\nLet me model the growth. Let's think recursively. The initial step is level 0: one node. Then, level 1 adds k nodes connected to the root. Then, each of those level 1 nodes must have k children. So each node in level 1 adds k children. Then, perhaps, the same applies for subsequent levels. But the process must be done at least once. Wait, the second step says that the step (adding k new vertices to each leaf) should be done at least once. So the minimal snowflake would be when we do this once. For example, with k=4: initial node (level 0), then level 1 has 4 nodes. Then each of these is connected to 4 new nodes (so level 2 has 4*4=16 nodes). So total nodes is 1 + 4 + 16 = 21? But the example says for k=4, the smallest is shown. However, in the sample input, when n=13, the answer is YES. Let's check that.\n\nWait, the sample input includes n=13 as a YES. Let's see. How can 13 be formed?\n\nLet me think. Let's think of possible structures. For example, maybe the snowflake has two layers. Let's consider:\n\nCase 1: Only one expansion step. So the initial step is level 0 (1 node), then level 1 (k nodes), then each of those is expanded once. So the total is 1 + k + k*k. For example, if k=3, that's 1+3+9=13. Which matches the sample input's n=13. So that's a valid case. Hence, the answer is YES for n=13.\n\nSo the problem is to find whether n can be written as 1 + k + k^2 + ... + k^m, where m ≥ 1 (since the expansion step must be done at least once). Wait, no. Wait, the initial step is adding k nodes. Then, the expansion step is done at least once. Let me re-express the construction steps.\n\nThe initial step: start with 1 node. Then, add k nodes connected to it. So that's step 1. Then, for each node that is a leaf (i.e., has only one connection), add k new nodes connected to them. This step must be done at least once. So the minimal case is that after adding the initial k nodes, we perform this expansion once. So the expansion step is done once. Let me think of the structure as a tree. Each node in the tree has exactly k children except for the leaves. Wait, no. Because the initial node is connected to k nodes. Then, each of those nodes is connected to k new nodes. So the initial node has degree k. Each of the first-level nodes has degree 1 + k (connected to their parent and their k children). But the second-level nodes have degree 1 (since they are leaves). So the expansion step is applied once. So the total number of nodes is 1 + k + k*k. For example, if k=2, then 1 + 2 + 4 = 7. But what if the expansion is done more than once?\n\nFor example, suppose after the initial step (adding k nodes), we perform the expansion step twice. That is, first, each first-level node gets k children (second level). Then, each second-level node gets k children (third level). Then, the total is 1 + k + k^2 + k^3. But the expansion step must be done at least once. So the general formula for the total number of nodes is 1 + k*(1 + k + k^2 + ... + k^{m}) ), where m is the number of expansion steps. Wait, perhaps not. Let me think again.\n\nLet me model the structure. The initial node is level 0. Then, level 1 has k nodes. Then, each node in level 1 has k children (level 2",
    "response": "To solve the problem of determining whether a snowflake with `n` vertices can be constructed, we must understand the structure of such a graph. The construction rules imply that the total number of vertices in a snowflake is a sum of geometric series:\n\n$$\nn = 1 + k + k^2 + \\dots + k^m\n$$\n\nWhere:\n- `k > 1`\n- `m ≥ 1` (since the expansion step must be done at least once)\n\nThis simplifies to:\n\n$$\nn = \\frac{k^{m+1} - 1}{k - 1}\n$$\n\nThe challenge is to determine for a given `n` if there exists any integer `k > 1` and integer `m ≥ 1` such that this equation holds.\n\n---\n\n### Key Observations:\n\n1. **The formula is symmetric in `k` and `m`**, so for each `n`, we can try different values of `m` and check if the corresponding `k` is an integer greater than 1.\n2. **For large `n` (up to $10^{18}$)**, we need an efficient approach. We can iterate over possible values of `m` up to a small limit (like `60`) because $k^m$ grows extremely fast.\n3. For each `m`, we solve the equation:\n\n$$\nn = \\frac{k^{m+1} - 1}{k - 1}\n$$\n\nWe rearrange it to:\n\n$$\nk^{m+1} - n(k - 1) - 1 = 0\n$$\n\nBut solving this directly is not easy. Instead, we can use binary search to find a value of `k` for a given `m` that satisfies the formula.\n\n---\n\n### Algorithm:\n\nFor each test case with a value `n`:\n- If `n == 1`, output `NO` (not enough nodes to form a snowflake).\n- Iterate over `m` from `1` to `60` (because $k^m$ becomes too large for `k > 2`).\n- For each `m`, perform binary search on `k` from `2` to a reasonable upper bound (e.g., `n^(1/(m+1)) + 1`).\n- Check if the formula yields `n` exactly. If yes, return `YES`.\n\n---\n\n### Python Code:\n\n```python\nimport sys\nimport math\n\ndef is_snowflake(n):\n    if n == 1:\n        return False\n    # Try m from 1 to 60 (sufficient since k^m grows very fast)\n    for m in range(1, 61):\n        # Find k such that (k^(m+1) - 1) / (k - 1) == n\n        low = 2\n        high = int(n ** (1.0 / (m + 1))) + 2\n        while low <= high:\n            mid = (low + high) // 2\n            # Compute the sum: 1 + mid + mid^2 + ... + mid^m\n            total = 0\n            power = 1\n            for _ in range(m + 1):\n                total += power\n                power *= mid\n                if total > n:\n                    break\n            if total == n:\n                return True\n            elif total < n:\n                low = mid + 1\n            else:\n                high = mid - 1\n    return False\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    results = []\n    for i in range(1, t + 1):\n        n = int(data[i])\n        if is_snowflake(n):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n---\n\n### Explanation:\n\n- The function `is_snowflake` tries all possible values of `m` (up to 60), and for each, performs a binary search on `k` to see if the geometric series matches `n`.\n- This approach ensures that we do not check more than necessary, and avoids brute-forcing through all possible combinations.\n- The binary search keeps the complexity manageable even for large values of `n` up to $10^{18}$.\n\nThis solution is efficient and handles the constraints effectively.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\n\ndef is_snowflake(n):\n    if n == 1:\n        return False\n    # Try m from 1 to 60 (sufficient since k^m grows very fast)\n    for m in range(1, 61):\n        # Find k such that (k^(m+1) - 1) / (k - 1) == n\n        low = 2\n        high = int(n ** (1.0 / (m + 1))) + 2\n        while low <= high:\n            mid = (low + high) // 2\n            # Compute the sum: 1 + mid + mid^2 + ... + mid^m\n            total = 0\n            power = 1\n            for _ in range(m + 1):\n                total += power\n                power *= mid\n                if total > n:\n                    break\n            if total == n:\n                return True\n            elif total < n:\n                low = mid + 1\n            else:\n                high = mid - 1\n    return False\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    results = []\n    for i in range(1, t + 1):\n        n = int(data[i])\n        if is_snowflake(n):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 562,
        "completion_token_count": 943,
        "thoughts_token_count": 1024
    }
}