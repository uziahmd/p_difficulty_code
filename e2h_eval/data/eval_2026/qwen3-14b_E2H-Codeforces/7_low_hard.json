{
    "start": 1758008505.7956595,
    "end": 1758008752.4010718,
    "start-formatted": "2025-09-16 16:41 KST",
    "end-formatted": "2025-09-16 16:45 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\nOkay, let's tackle this problem. So, the task is to determine for a given n whether there exists a snowflake graph as defined. The snowflake is built in a certain way, and we need to check if such a graph can have exactly n vertices.\n\nFirst, I need to understand the structure of the snowflake. Let me re-read the description.\n\nThe snowflake starts with one vertex. Then, this initial vertex is connected to k new vertices (k>1). Then, each vertex that is connected to only one other (so those leaves) are connected to k new vertices. This step must be done at least once. So, the process is like building layers. \n\nLet me think about how the number of vertices grows with each step. Let's model this.\n\nLet's consider the construction steps. Let's say the initial step is level 0. Then:\n\n- Level 0: 1 node (the root).\n- Level 1: Add k nodes connected to the root. Now total is 1 + k.\n- Then, each node in level 1 (which are leaves) gets k new children. So level 2 adds k * k nodes. Total is 1 + k + k².\n- Then, each node in level 2 (which are leaves) gets k children. So level 3 adds k^3. Total is 1 + k + k² + k³.\n\nBut wait, the problem says that the step of adding new vertices to leaves must be done at least once. So, the minimal snowflake would be when after the initial step (adding k children to root), we do at least one more step. For example, for k=4, the minimal snowflake would be 1 + 4 + 4² = 21? But according to the example, when n=6, the answer is NO. Wait, looking at the sample input:\n\nSample Input includes 6, and the output is NO. Let me check. For example, let's see possible values.\n\nLet me think of possible n values. For example, for k=2, the possible numbers are:\n\n- If we stop after level 1: 1+2=3. But according to the problem statement, the step of adding to leaves must be done at least once. So, the initial step is adding the first k children. Then, the second step is adding to the leaves. So the minimal is 1 + k + k². So for k=2, the minimal is 1+2+4=7. But then, if you add another step, it becomes 1 + 2 + 4 + 8 = 15, etc. \n\nWait, but maybe there are other possibilities. For example, maybe the process can be stopped after some steps. Let me re-examine the problem description.\n\nThe rules are:\n\nInitially, the graph has one vertex. Then, more vertices are added. The initial vertex is connected by edges to k new vertices (k>1). Then, each vertex that is connected to only one other is connected to k new vertices. This step should be done at least once.\n\nSo the process is:\n\nStart with 1 node. Then, add k nodes (level 1). Then, perform the step (adding k children to each leaf) at least once. So after the initial step (adding level 1), we must do the step once. So that would be adding level 2. So the total number of nodes is 1 + k + k^2. But perhaps you can do more steps. For example, after adding level 2, you can add level 3, etc. So the total number of nodes is 1 + k + k^2 + ... + k^m, where m >= 2? Or m >= 1?\n\nWait, the step is done at least once. Let me parse the description again.\n\nThe initial step is adding k new vertices. Then, the step (each leaf connected to only one other is connected to k new vertices) is done at least once. So the initial step is adding the first k nodes. Then, the step (adding more nodes) is done once or more. So for example, the minimal case would be after adding level 1 and then doing the step once (adding level 2). So the total is 1 + k + k^2.\n\nBut what if the step is done once, but not more? So the snowflake can have any number of layers, but at least two layers (the initial step plus one more step). Wait, the initial step is adding the first layer (level 1). Then the step (adding to leaves) is done once, which adds level 2. So the total is 1 + k + k^2. But if you do the step again, you add level 3, so 1 + k + k^2 + k^3, etc.\n\n",
    "response": "\n\nTo solve this problem, we need to determine if a given number of vertices `n` can form a \"snowflake\" graph as defined. The snowflake graph is constructed in a specific hierarchical manner, starting with one vertex and expanding in layers.\n\n### Approach\n1. **Understanding the Structure**: The snowflake graph starts with one vertex (root), then adds `k` children to this root. Each subsequent layer adds `k` children to every leaf node from the previous layer. This process must be done at least once after the initial step.\n2. **Formulating the Problem**: The total number of vertices after `m` layers (including the root) can be represented as a geometric series. For `m` layers, the total number of vertices is `1 + k + k^2 + ... + k^m`, where `m >= 2`.\n3. **Geometric Series Check**: For a given `n`, we need to check if there exists an integer `k > 1` such that `n` can be expressed as the sum of a geometric series starting from `k^0` (i.e., 1) up to some term `k^m`, with `m >= 2`.\n\n### Solution Code\n```python\nimport sys\nimport math\n\ndef is_snowflake(n):\n    if n < 3:\n        return False\n    # Try all possible m >= 2\n    # For each possible m, check if there exists k > 1 such that sum_{i=0}^m k^i = n\n    # The sum is (k^(m+1) - 1) / (k - 1)\n    # So for each m, we need to find k such that (k^(m+1) - 1) / (k - 1) == n\n    # But since m can be large, we need to limit the range of m.\n    # Since k >= 2, the minimal sum for m is 1 + 2 + 4 + ... + 2^m = 2^{m+1} - 1\n    # So for n up to 1e18, m can't be more than about 60 (since 2^60 is ~1e18)\n    max_m = 60\n    for m in range(2, max_m + 1):\n        # Now find k such that sum_{i=0}^m k^i = n\n        # Which is (k^(m+1) - 1) / (k - 1) = n\n        # We can binary search k in [2, ...]\n        low = 2\n        high = 2\n        # Find upper bound for k\n        while (high ** (m + 1) - 1) // (high - 1) <= n:\n            high *= 2\n        # Now binary search between low and high\n        while low <= high:\n            mid = (low + high) // 2\n            try:\n                # Compute the sum s = (mid^(m+1) - 1) // (mid - 1)\n                # To avoid overflow, use logarithms or iterative calculation\n                # However, since n can be up to 1e18, mid^(m+1) can be very big\n                # So we need to compute it carefully\n                # Let's compute the sum iteratively\n                s = 0\n                power = 1\n                for _ in range(m + 1):\n                    s += power\n                    if s > n:\n                        break\n                    power *= mid\n                if s == n:\n                    return True\n                elif s < n:\n                    low = mid + 1\n                else:\n                    high = mid - 1\n            except:\n                # Overflow case, move high down\n                high = mid - 1\n    # Also check cases where the snowflake is formed by adding layers beyond the first m steps\n    # Another possibility: the snowflake is built with exactly two layers, but with some k\n    # Wait, we already checked all m from 2 to 60. But maybe there's another way?\n    # For example, when the snowflake is built with more than m layers, but we might have missed some k\n    # Alternatively, check for cases where the snowflake has exactly two layers (m=2) and the sum is 1 + k + k^2 = n\n    # Which is equivalent to k^2 + k + 1 = n\n    # So solving for k, check if k is integer >1\n    # Similarly for other m values\n    # But the above loop already covers that.\n    # Additionally, there's another case: the snowflake could have been built with more than one step, but not all layers completed\n    # Wait no, according to the problem statement, the construction must be done until the step is done at least once. So the minimal is 1 +k +k^2, and any further steps are allowed.\n    # Therefore, our approach is correct.\n\n    # Also check the case where the snowflake is built with only one additional step (so m=2), but the sum is 1 + k + k^2 = n\n    # But that's already covered in the loop.\n\n    # Also check for cases where the snowflake is built with more than one step, but not all layers are completed.\n    # Wait, no. The construction is such that after the initial step (adding k children to the root), you perform the step (adding children to leaves) at least once. So the minimal is m=2 (sum 1 + k + k^2). If you do more steps, it's m=3, etc.\n\n    # Another possibility: the snowflake can be built with different numbers of layers for different k's. So our code checks all possible m up to 60, which should be sufficient for n up to 1e18.\n\n    # Also, check for the case where the snowflake is built with exactly one layer (but according to the problem, that's not allowed). So n=1 +k is invalid unless the step is done at least once.\n\n    # So, the code above should cover all possibilities.\n\n    return False\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    t = int(input[0])\n    cases = list(map(int, input[1:t+1]))\n    for n in cases:\n        if is_snowflake(n):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **is_snowflake Function**: This function checks if a given number `n` can be expressed as the sum of a geometric series with at least two layers (i.e., `m >= 2`). It uses binary search to efficiently check possible values of `k` for each possible number of layers `m`.\n- **Main Function**: Reads input, processes each test case, and prints \"YES\" or \"NO\" based on whether the number of vertices can form a valid snowflake graph.\n\nThis approach ensures that we efficiently check all possible configurations within the constraints, leveraging geometric series properties and binary search for performance.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\n\ndef is_snowflake(n):\n    if n < 3:\n        return False\n    # Try all possible m >= 2\n    # For each possible m, check if there exists k > 1 such that sum_{i=0}^m k^i = n\n    # The sum is (k^(m+1) - 1) / (k - 1)\n    # So for each m, we need to find k such that (k^(m+1) - 1) / (k - 1) == n\n    # But since m can be large, we need to limit the range of m.\n    # Since k >= 2, the minimal sum for m is 1 + 2 + 4 + ... + 2^m = 2^{m+1} - 1\n    # So for n up to 1e18, m can't be more than about 60 (since 2^60 is ~1e18)\n    max_m = 60\n    for m in range(2, max_m + 1):\n        # Now find k such that sum_{i=0}^m k^i = n\n        # Which is (k^(m+1) - 1) / (k - 1) = n\n        # We can binary search k in [2, ...]\n        low = 2\n        high = 2\n        # Find upper bound for k\n        while (high ** (m + 1) - 1) // (high - 1) <= n:\n            high *= 2\n        # Now binary search between low and high\n        while low <= high:\n            mid = (low + high) // 2\n            try:\n                # Compute the sum s = (mid^(m+1) - 1) // (mid - 1)\n                # To avoid overflow, use logarithms or iterative calculation\n                # However, since n can be up to 1e18, mid^(m+1) can be very big\n                # So we need to compute it carefully\n                # Let's compute the sum iteratively\n                s = 0\n                power = 1\n                for _ in range(m + 1):\n                    s += power\n                    if s > n:\n                        break\n                    power *= mid\n                if s == n:\n                    return True\n                elif s < n:\n                    low = mid + 1\n                else:\n                    high = mid - 1\n            except:\n                # Overflow case, move high down\n                high = mid - 1\n    # Also check cases where the snowflake is formed by adding layers beyond the first m steps\n    # Another possibility: the snowflake is built with exactly two layers, but with some k\n    # Wait, we already checked all m from 2 to 60. But maybe there's another way?\n    # For example, when the snowflake is built with more than m layers, but we might have missed some k\n    # Alternatively, check for cases where the snowflake has exactly two layers (m=2) and the sum is 1 + k + k^2 = n\n    # Which is equivalent to k^2 + k + 1 = n\n    # So solving for k, check if k is integer >1\n    # Similarly for other m values\n    # But the above loop already covers that.\n    # Additionally, there's another case: the snowflake could have been built with more than one step, but not all layers completed\n    # Wait no, according to the problem statement, the construction must be done until the step is done at least once. So the minimal is 1 +k +k^2, and any further steps are allowed.\n    # Therefore, our approach is correct.\n\n    # Also check the case where the snowflake is built with only one additional step (so m=2), but the sum is 1 + k + k^2 = n\n    # But that's already covered in the loop.\n\n    # Also check for cases where the snowflake is built with more than one step, but not all layers are completed.\n    # Wait, no. The construction is such that after the initial step (adding k children to the root), you perform the step (adding children to leaves) at least once. So the minimal is m=2 (sum 1 + k + k^2). If you do more steps, it's m=3, etc.\n\n    # Another possibility: the snowflake can be built with different numbers of layers for different k's. So our code checks all possible m up to 60, which should be sufficient for n up to 1e18.\n\n    # Also, check for the case where the snowflake is built with exactly one layer (but according to the problem, that's not allowed). So n=1 +k is invalid unless the step is done at least once.\n\n    # So, the code above should cover all possibilities.\n\n    return False\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    t = int(input[0])\n    cases = list(map(int, input[1:t+1]))\n    for n in cases:\n        if is_snowflake(n):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 561,
        "completion_token_count": 1540,
        "thoughts_token_count": 1023
    }
}