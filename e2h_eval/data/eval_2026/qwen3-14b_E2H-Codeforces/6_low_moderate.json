{
    "start": 1758313506.9753473,
    "end": 1758313720.6406481,
    "start-formatted": "2025-09-20 05:25 KST",
    "end-formatted": "2025-09-20 05:28 KST",
    "gpu": 2,
    "pid": 6,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\nOkay, I need to solve this programming problem. Let's read the problem carefully.\n\nSo, the problem is about finding two non-overlapping vouchers such that their total duration equals exactly x days. And we need to find the minimal total cost of such a pair. If it's not possible, return -1.\n\nFirst, let's understand what the duration is. For each voucher i, duration is ri - li + 1. So, for two vouchers i and j, their durations must add up to x. Also, they must not overlap. That means either the first ends before the second starts, or vice versa.\n\nConstraints: n can be up to 2e5, which is 200,000. So any O(n^2) approach is definitely out of the question. Need something efficient, like O(n log n) or O(n).\n\nLet me think about how to approach this.\n\nThe key points are:\n\n1. For each voucher, check if there exists another voucher that doesn't overlap with it and has a duration of (x - duration_i). Then find the minimum cost for such pairs.\n\nBut how do I efficiently find for each voucher, the best possible other voucher?\n\nLet me think about pre-processing. For each possible duration d, we can keep track of the minimum cost of vouchers with that duration, and also track their start and end times. But since x can be up to 2e5, and each voucher's duration can be up to 2e5 as well, maybe we can group vouchers by their duration.\n\nSo here's an idea: for each voucher with duration d, we need to find a voucher with duration (x - d), which does not overlap with it. Then, for each such pair, compute the sum of costs and track the minimum.\n\nBut how to efficiently find the minimum cost voucher of duration (x - d) that doesn't overlap with the current voucher.\n\nLet me think about the steps:\n\nFirst, for all vouchers, compute their duration. Then group them by their duration. For example, a dictionary where the key is the duration, and the value is a list of vouchers (each with li, ri, costi). But perhaps we can pre-process for each duration, the vouchers sorted in some way.\n\nBut for each voucher i with duration d, we need to find vouchers of duration (x - d) that end before li (so that they don't overlap), or start after ri (so that they don't overlap). So for each voucher i, we need to find the minimum cost among vouchers of duration (x - d) that are either completely before i's voucher, or completely after.\n\nBut how to find that quickly?\n\nFor example, suppose we have vouchers of duration t = x - d. For a given voucher i with duration d, we need to find the minimum cost of vouchers of duration t that end before li. Also, the minimum cost of vouchers of duration t that start after ri. Then take the minimum between those two possibilities.\n\nSo, for each duration t, we can pre-process two structures:\n\n- A sorted list of the end times of vouchers of duration t, along with their costs. Then, for a given li, we can find all vouchers of duration t that end before li. The minimal cost among those.\n\nSimilarly, for the start times. For vouchers of duration t, sorted by their start times. For a given ri, find all vouchers of duration t that start after ri. The minimal cost among those.\n\nBut how to do that efficiently?\n\nLet me think about for each duration t, we can have two arrays:\n\n- For the first part: vouchers sorted by their end time. Then, for a given li, we can find all vouchers with end <= li-1. The minimal cost in that subset.\n\nBut how to query that? Well, if the vouchers are sorted by end time, and for each, we have a prefix minimum array. So for example, for vouchers of duration t, sorted by end time in ascending order, and for each position in the sorted list, we have the minimum cost up to that index. Then, when we want to find the minimal cost of vouchers ending before a certain value, we can binary search to find the largest end time <= li-1, and then take the corresponding prefix min.\n\nSimilarly for the start times: vouchers of duration t sorted by start time. For a given ri, we want vouchers that start after ri. So we can binary search for the first start time > ri, and then take the suffix minima from that index onwards.\n\nSo, the plan is:\n\n- Preprocess for each duration t, two sorted lists:\n\n   a. Sorted by end time, with prefix minima.\n\n   b. Sorted by start time, with suffix minima.\n\nThen, for each voucher i with duration d, compute t = x - d. If t is not present in the duration groups, skip. Otherwise, check for the two possibilities (voucher j ends before voucher",
    "response": "To solve this problem, we need to find two non-overlapping vouchers such that their combined duration equals exactly x days, while minimizing the total cost. If no such pair exists, we should return -1.\n\n### Approach\n1. **Group Vouchers by Duration**: First, we group all vouchers by their duration. This helps in efficiently checking for pairs of vouchers whose combined duration equals x.\n2. **Preprocess for Efficient Querying**: For each duration, we maintain two sorted lists:\n   - One sorted by the end time of vouchers, with prefix minimum costs.\n   - Another sorted by the start time of vouchers, with suffix minimum costs.\n3. **Check for Valid Pairs**: For each voucher, check if there exists another voucher of the required duration (x - current duration) that does not overlap. Use the preprocessed lists to efficiently find the minimum cost of valid non-overlapping vouchers.\n\n### Solution Code\n```python\nimport sys\nimport bisect\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n\n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n\n    # Group vouchers by duration\n    duration_dict = defaultdict(list)\n    for l, r, cost, d in vouchers:\n        duration_dict[d].append((l, r, cost))\n\n    # Preprocess for each duration: sorted by end, and sorted by start\n    # Also, for each, create prefix min for end-sorted and suffix min for start-sorted\n    preprocessed = dict()\n    for d in duration_dict:\n        lst = duration_dict[d]\n        # Sort by end time\n        sorted_by_end = sorted(lst, key=lambda x: x[1])\n        prefix_min = []\n        min_so_far = float('inf')\n        for l, r, cost in sorted_by_end:\n            min_so_far = min(min_so_far, cost)\n            prefix_min.append(min_so_far)\n        # Sort by start time\n        sorted_by_start = sorted(lst, key=lambda x: x[0])\n        suffix_min = [0] * len(sorted_by_start)\n        min_so_far = float('inf')\n        for i in range(len(sorted_by_start)-1, -1, -1):\n            l, r, cost = sorted_by_start[i]\n            min_so_far = min(min_so_far, cost)\n            suffix_min[i] = min_so_far\n        preprocessed[d] = (sorted_by_end, prefix_min, sorted_by_start, suffix_min)\n\n    min_total = float('inf')\n\n    for l1, r1, cost1, d1 in vouchers:\n        d2 = x - d1\n        if d2 < 1:\n            continue\n        if d2 not in preprocessed:\n            continue\n        # Check for vouchers of duration d2 that end before l1\n        sorted_by_end, prefix_min_end, _, _ = preprocessed[d2]\n        # Find the largest end <= l1 - 1\n        # Binary search on sorted_by_end's end times\n        ends = [r for (l, r, c) in sorted_by_end]\n        pos = bisect.bisect_right(ends, l1 - 1)\n        if pos > 0:\n            min_cost = prefix_min_end[pos - 1]\n            min_total = min(min_total, cost1 + min_cost)\n        # Check for vouchers of duration d2 that start after r1\n        _, _, sorted_by_start, suffix_min_start = preprocessed[d2]\n        starts = [l for (l, r, c) in sorted_by_start]\n        pos = bisect.bisect_right(starts, r1)\n        if pos < len(starts):\n            min_cost = suffix_min_start[pos]\n            min_total = min(min_total, cost1 + min_cost)\n\n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into a list of vouchers, each with their start time, end time, cost, and duration.\n2. **Grouping by Duration**: Vouchers are grouped by their duration to facilitate quick lookups when checking for valid pairs.\n3. **Preprocessing**: For each duration, vouchers are sorted by end time and start time. Prefix minimum arrays are created for end-sorted lists, and suffix minimum arrays for start-sorted lists to enable efficient range minimum queries.\n4. **Finding Valid Pairs**: For each voucher, we check if there exists another voucher of the required duration that ends before the current voucher starts or starts after the current voucher ends. The minimum cost of such valid pairs is tracked and updated.\n\nThis approach ensures that we efficiently check for valid pairs using preprocessing and binary search, leading to an optimal solution.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport bisect\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n\n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n\n    # Group vouchers by duration\n    duration_dict = defaultdict(list)\n    for l, r, cost, d in vouchers:\n        duration_dict[d].append((l, r, cost))\n\n    # Preprocess for each duration: sorted by end, and sorted by start\n    # Also, for each, create prefix min for end-sorted and suffix min for start-sorted\n    preprocessed = dict()\n    for d in duration_dict:\n        lst = duration_dict[d]\n        # Sort by end time\n        sorted_by_end = sorted(lst, key=lambda x: x[1])\n        prefix_min = []\n        min_so_far = float('inf')\n        for l, r, cost in sorted_by_end:\n            min_so_far = min(min_so_far, cost)\n            prefix_min.append(min_so_far)\n        # Sort by start time\n        sorted_by_start = sorted(lst, key=lambda x: x[0])\n        suffix_min = [0] * len(sorted_by_start)\n        min_so_far = float('inf')\n        for i in range(len(sorted_by_start)-1, -1, -1):\n            l, r, cost = sorted_by_start[i]\n            min_so_far = min(min_so_far, cost)\n            suffix_min[i] = min_so_far\n        preprocessed[d] = (sorted_by_end, prefix_min, sorted_by_start, suffix_min)\n\n    min_total = float('inf')\n\n    for l1, r1, cost1, d1 in vouchers:\n        d2 = x - d1\n        if d2 < 1:\n            continue\n        if d2 not in preprocessed:\n            continue\n        # Check for vouchers of duration d2 that end before l1\n        sorted_by_end, prefix_min_end, _, _ = preprocessed[d2]\n        # Find the largest end <= l1 - 1\n        # Binary search on sorted_by_end's end times\n        ends = [r for (l, r, c) in sorted_by_end]\n        pos = bisect.bisect_right(ends, l1 - 1)\n        if pos > 0:\n            min_cost = prefix_min_end[pos - 1]\n            min_total = min(min_total, cost1 + min_cost)\n        # Check for vouchers of duration d2 that start after r1\n        _, _, sorted_by_start, suffix_min_start = preprocessed[d2]\n        starts = [l for (l, r, c) in sorted_by_start]\n        pos = bisect.bisect_right(starts, r1)\n        if pos < len(starts):\n            min_cost = suffix_min_start[pos]\n            min_total = min(min_total, cost1 + min_cost)\n\n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 741,
        "completion_token_count": 1096,
        "thoughts_token_count": 1024
    }
}