{
    "start": 1758008328.6669326,
    "end": 1758008509.0287619,
    "start-formatted": "2025-09-16 16:38 KST",
    "end-formatted": "2025-09-16 16:41 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\nOkay, let's tackle this problem. So, the task is to find two non-overlapping vouchers whose total duration equals exactly x, and their combined cost is minimized. If there's no such pair, return -1.\n\nFirst, I need to understand the problem thoroughly. Let's rephrase the requirements. Each voucher has a duration of ri - li + 1. We need two vouchers i and j such that:\n\n1. The sum of their durations is exactly x.\n2. They don't overlap. Which means either the first ends before the second starts (ri < lj) or the second ends before the first starts (rj < li).\n3. Find the minimum cost of such pairs.\n\nConstraints: n can be up to 2e5, which is 200,000. So any O(n^2) approach is definitely out of the question. Need something efficient, like O(n log n) or O(n).\n\nSo the challenge is to find for each voucher, another voucher that meets the duration requirement and doesn't overlap, and find the minimal cost.\n\nLet me think about how to approach this. Let's consider that for each voucher, we can check if there exists another voucher that has a duration of (x - duration of current voucher), and that they don't overlap.\n\nBut how do I efficiently find those?\n\nFirst, let's precompute the duration for each voucher. For each voucher i, duration_i = ri - li + 1.\n\nWe need pairs (i,j) where duration_i + duration_j = x. So for each voucher, we can look for vouchers with duration equal to (x - duration_i). But even that, how to find them?\n\nMoreover, the vouchers must not overlap. So for each voucher i, we need to find vouchers j with duration d = x - duration_i, and either j's end is before i's start, or i's end is before j's start.\n\nBut how to efficiently find the minimal cost for such j's?\n\nAn idea: group vouchers by their duration. Then, for each voucher i with duration d, look into the group of vouchers with duration x - d, and find those that are non-overlapping with i.\n\nBut how to find the minimal cost in that group?\n\nBut even that, for each voucher, checking all vouchers in the other group might be O(n^2) in worst case. For example, if all vouchers have duration x/2, then for each voucher, we have to check all others.\n\nSo we need a way to quickly find, for a given voucher i, the minimal cost of vouchers in the other group that don't overlap with i.\n\nLet me think about the non-overlapping condition. Suppose we have voucher i with [li, ri], and we want to find vouchers j with duration d = x - duration_i. These vouchers j must satisfy either rj < li or lj > ri.\n\nSo for each voucher i, we can split into two cases:\n\nCase 1: find vouchers j with duration d, which end before li. So rj < li.\n\nCase 2: find vouchers j with duration d, which start after ri. So lj > ri.\n\nFor each of these two cases, find the minimal cost of such j's.\n\nIf we can find the minimal cost for both cases, then take the minimum between them, and then compare across all vouchers.\n\nSo the plan is:\n\n- Preprocess vouchers grouped by their duration. So a dictionary, say duration_map, where key is duration, and value is a list of vouchers with that duration. Also, perhaps for each duration, we can have some sorted data structures to allow efficient querying.\n\nFor each voucher i:\n\n- Compute d_i = ri - li + 1.\n\n- target_duration = x - d_i.\n\n- If target_duration is not present in duration_map, skip this voucher.\n\n- Else, for all vouchers j in duration_map[target_duration], check if they don't overlap with i. But checking each one would be O(k) where k is the number of vouchers in target_duration. Which could be O(n) again.\n\nThis is not efficient enough.\n\nAlternative approach: For each duration, pre-process the vouchers in such a way that for a given [li, ri], we can quickly find the minimal cost of vouchers that end before li (case 1) and the minimal cost of vouchers that start after ri (case 2).\n\nHow to do that?\n\nFor case 1: vouchers j with duration = target_d, and rj < li.\n\nTo find the minimal cost among these, perhaps for each duration, we can have a sorted list of rj's, and for each li, find all vouchers j with rj < li, and get the minimal cost among them.\n\nSimilarly, for case 2: vouchers j with lj > ri. For that, maybe have a sorted list of lj's, and find the minimal cost among those lj's > ri.\n\nBut how to store this data?\n\nLet me",
    "response": "\n\nTo solve this problem, we need to find two non-overlapping vouchers whose combined duration exactly matches a given value `x` and whose total cost is minimized. If no such pair exists, we should return -1.\n\n### Approach\n1. **Group Vouchers by Duration**: First, we group all vouchers by their duration. This helps in efficiently finding potential pairs that meet the required total duration.\n2. **Preprocess for Efficient Querying**: For each duration, we maintain two sorted lists:\n   - One sorted by the end date (`ri`) to efficiently find vouchers ending before a given start date.\n   - Another sorted by the start date (`li`) to efficiently find vouchers starting after a given end date.\n3. **Binary Search for Efficient Lookup**: Using binary search on the sorted lists, we can quickly determine the minimum cost of vouchers that meet the non-overlapping conditions for each voucher.\n\n### Solution Code\n```python\nimport bisect\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n\n    vouchers = []\n    duration_map = defaultdict(list)\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n        duration_map[duration].append((l, r, cost))\n\n    # Preprocess for each duration: sort by r and by l\n    # Also, for each duration, keep a list sorted by r and a list sorted by l\n    # And for each sorted list, keep a prefix min and suffix min array\n    preprocessed = dict()\n    for d in duration_map:\n        lst = duration_map[d]\n        # Sort by r\n        sorted_by_r = sorted(lst, key=lambda x: x[1])\n        # Sort by l\n        sorted_by_l = sorted(lst, key=lambda x: x[0])\n        # For sorted_by_r, create a prefix min array (min cost up to index i)\n        prefix_min_r = []\n        min_so_far = float('inf')\n        for item in sorted_by_r:\n            min_so_far = min(min_so_far, item[2])\n            prefix_min_r.append(min_so_far)\n        # For sorted_by_l, create a suffix min array (min cost from index i onwards)\n        suffix_min_l = []\n        min_so_far = float('inf')\n        for item in reversed(sorted_by_l):\n            min_so_far = min(min_so_far, item[2])\n            suffix_min_l.append(min_so_far)\n        suffix_min_l = suffix_min_l[::-1]\n        preprocessed[d] = (sorted_by_r, prefix_min_r, sorted_by_l, suffix_min_l)\n\n    min_total = float('inf')\n\n    for l_i, r_i, cost_i, duration_i in vouchers:\n        target_d = x - duration_i\n        if target_d not in preprocessed:\n            continue\n        # Now check for vouchers with target_d\n        sorted_by_r, prefix_min_r, sorted_by_l, suffix_min_l = preprocessed[target_d]\n        # Case 1: find vouchers j where r_j < l_i\n        # Find the largest r_j < l_i in sorted_by_r\n        # Using bisect\n        pos = bisect.bisect_left([item[1] for item in sorted_by_r], l_i)\n        if pos > 0:\n            min_cost = prefix_min_r[pos-1]\n            min_total = min(min_total, min_cost + cost_i)\n        # Case 2: find vouchers j where l_j > r_i\n        # Find the first l_j > r_i in sorted_by_l\n        l_list = [item[0] for item in sorted_by_l]\n        pos = bisect.bisect_right(l_list, r_i)\n        if pos < len(l_list):\n            min_cost = suffix_min_l[pos]\n            min_total = min(min_total, min_cost + cost_i)\n\n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into a list of vouchers, each represented by their start date, end date, cost, and duration.\n2. **Grouping by Duration**: Vouchers are grouped by their duration using a dictionary. This allows efficient lookup when checking for compatible vouchers.\n3. **Preprocessing**: For each duration, vouchers are sorted by their end date and start date. Additionally, prefix and suffix minimum cost arrays are created to quickly determine the minimum cost for ranges of vouchers.\n4. **Binary Search for Non-overlapping Vouchers**: For each voucher, we use binary search to efficiently find the minimum cost of non-overlapping vouchers that meet the required duration condition. This ensures the solution runs efficiently even for large inputs.",
    "ground_truth": "N/A",
    "extracted_answer": "import bisect\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n\n    vouchers = []\n    duration_map = defaultdict(list)\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n        duration_map[duration].append((l, r, cost))\n\n    # Preprocess for each duration: sort by r and by l\n    # Also, for each duration, keep a list sorted by r and a list sorted by l\n    # And for each sorted list, keep a prefix min and suffix min array\n    preprocessed = dict()\n    for d in duration_map:\n        lst = duration_map[d]\n        # Sort by r\n        sorted_by_r = sorted(lst, key=lambda x: x[1])\n        # Sort by l\n        sorted_by_l = sorted(lst, key=lambda x: x[0])\n        # For sorted_by_r, create a prefix min array (min cost up to index i)\n        prefix_min_r = []\n        min_so_far = float('inf')\n        for item in sorted_by_r:\n            min_so_far = min(min_so_far, item[2])\n            prefix_min_r.append(min_so_far)\n        # For sorted_by_l, create a suffix min array (min cost from index i onwards)\n        suffix_min_l = []\n        min_so_far = float('inf')\n        for item in reversed(sorted_by_l):\n            min_so_far = min(min_so_far, item[2])\n            suffix_min_l.append(min_so_far)\n        suffix_min_l = suffix_min_l[::-1]\n        preprocessed[d] = (sorted_by_r, prefix_min_r, sorted_by_l, suffix_min_l)\n\n    min_total = float('inf')\n\n    for l_i, r_i, cost_i, duration_i in vouchers:\n        target_d = x - duration_i\n        if target_d not in preprocessed:\n            continue\n        # Now check for vouchers with target_d\n        sorted_by_r, prefix_min_r, sorted_by_l, suffix_min_l = preprocessed[target_d]\n        # Case 1: find vouchers j where r_j < l_i\n        # Find the largest r_j < l_i in sorted_by_r\n        # Using bisect\n        pos = bisect.bisect_left([item[1] for item in sorted_by_r], l_i)\n        if pos > 0:\n            min_cost = prefix_min_r[pos-1]\n            min_total = min(min_total, min_cost + cost_i)\n        # Case 2: find vouchers j where l_j > r_i\n        # Find the first l_j > r_i in sorted_by_l\n        l_list = [item[0] for item in sorted_by_l]\n        pos = bisect.bisect_right(l_list, r_i)\n        if pos < len(l_list):\n            min_cost = suffix_min_l[pos]\n            min_total = min(min_total, min_cost + cost_i)\n\n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 740,
        "completion_token_count": 1078,
        "thoughts_token_count": 1023
    }
}