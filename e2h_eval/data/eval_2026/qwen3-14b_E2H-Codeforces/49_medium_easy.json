{
    "start": 1758308729.1206822,
    "end": 1758308894.1255417,
    "start-formatted": "2025-09-20 04:05 KST",
    "end-formatted": "2025-09-20 04:08 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\nOkay, let's see. I need to solve this problem where I have to determine if there's a way to assign numbers to each lawn such that for every given edge (road), the GCD and LCM of the two connected lawns match the given values. If possible, output the numbers; else, output NO.\n\nHmm. Let's think about the constraints. For each edge between u and v, we have that GCD(a_u, a_v) = g and LCM(a_u, a_v) = l. Also, since GCD * LCM = a_u * a_v, we can use that relation. So for each edge, the product of the two numbers must be equal to g * l. But also, since the GCD is g, both a_u and a_v must be multiples of g. Let me think: Let's say a_u = g * x, a_v = g * y. Then GCD(x, y) must be 1, because any common divisor would multiply with g to give a higher GCD. And the LCM of a_u and a_v is g * x * y, since x and y are coprime. Therefore, the LCM given must be equal to g * x * y. Which implies that l must be equal to g * x * y. So, l must be divisible by g. Wait, but in the input, the problem says that the given GCD and LCM are valid for the original map. So maybe the input is such that for each edge, the given GCD divides the LCM? Because otherwise, it's impossible. For example, if the GCD is 2 and LCM is 3, then that's impossible. Because GCD * LCM = product of the two numbers. But if GCD is 2 and LCM is 3, then product is 6. So the two numbers would be 2 and 3. Their GCD is 1, not 2. So that's invalid. So for each edge, we must check that the given GCD divides the LCM. Otherwise, it's impossible. So first thing: for each edge, check if l % g != 0. If yes, then output NO.\n\nSo that's one check. But even if that's true, how do we proceed?\n\nNow, considering that for each edge, the two nodes must have their values as multiples of g, and their product is g*l. So, for each edge, the two values must be g * x and g * y, where x and y are coprime, and x*y = l/g. Because l = g * x * y. So l/g must be equal to x*y, and since x and y are coprime, then x and y must be divisors of l/g, and coprime. So for example, if l/g is 6, then x and y could be 1 and 6, 2 and 3, etc. But since they are coprime, their product is 6.\n\nBut how to model this for the entire graph? It seems like a graph problem where each node has some value, and edges impose constraints on pairs of nodes.\n\nThis feels like a graph problem where we need to assign values to nodes such that for each edge, the two nodes satisfy the GCD and LCM conditions. How can we model this?\n\nLet me think about building a graph where each edge enforces that the two nodes have certain relationships. Since the values are determined up to multiplication by factors, perhaps we can model this as a graph where each node's value is determined relative to others.\n\nAlternatively, since for each edge, the two nodes' values are multiples of the GCD, perhaps we can model this as a graph where each node's value is a multiple of some base value, and we need to assign these multiples in a way that satisfies all edges.\n\nWait, but how can we assign the values? Let's think of each node's value as being a multiple of the GCD of the edge. But since a node can be part of multiple edges, each with different GCDs, perhaps the node's value must be a multiple of the GCDs of all edges connected to it. Wait, no. Because for example, if a node is connected to two edges with different GCDs. Suppose node A is connected to B with GCD g1, and to C with GCD g2. Then the value of A must be a multiple of g1 and also a multiple of g2. Therefore, the value of A must be a multiple of LCM(g1, g2). But that's only if those edges are connected. So, perhaps the values of the nodes must be multiples of some value that depends on the GCDs of the edges connected to them.\n\nBut how can we model this? Maybe we can model the problem as a graph where each node's value is determined based on its connected edges, and we can perform some kind of BFS or DFS to assign values.\n\nAnother approach: Let's consider that for each edge (u, v), we have that a_u = g * x, a_v = g * y, where x and y are coprime, and x * y = l/g. So, for each edge, the product of x and y is fixed. Also, since x and y are coprime, x must divide l/g, and y must divide l/g. Also, since x and y are coprime, once we fix x, y is determined as (l/g)/x.\n\nBut how to assign x and y for each edge, and ensure consistency across the entire graph?\n\nAlternatively, think of the problem as building a graph where each node's value is determined relative to another node. For example, suppose we have a connected component. Let's pick a root node and assign a value to it, then propagate the values through the edges. However, this might not work directly because the same node can be connected to multiple edges, which might impose conflicting constraints.\n\nLet me think of an example. Suppose we have a chain: A connected to B with GCD g and LCM l, and B connected to C with GCD g' and LCM l'. Then, the value of B is determined by A and C, but how?\n\nAlternatively, for each edge, we can model the relationship between the two nodes. Let's take the first edge between u and v. Let's say that a_u = g * x and a_v = g * y. Since x and y are coprime, and x * y = l/g. So, for this edge, the possible pairs (x, y) are (d, (l/g)/d), where d is a divisor of (l/g) and gcd(d, (l/g)/d) = 1. But how do we choose which pair to take?\n\nBut perhaps, for the purposes of building the graph, we can model the relationships between nodes as a graph where each node's value is a multiple of some base value. For instance, if we have a connected component, we can assign a value to one node, and then determine the values of other nodes based on the edges.\n\nBut how?\n\nLet me think again. Suppose we have two nodes u and v connected by an edge with GCD g and LCM l. Then, we know that a_u and a_v must be multiples of g, and their product is g*l. So, a_u * a_v = g*l. Also, since GCD(a_u, a_v) is g, then a_u = g * x, a_v = g * y, where x and y are coprime. Then, x * y = (g*l)/(g^2) ) = l/g. So, l must be divisible by g. So, first check that for each edge, l is divisible by g. Otherwise, answer is NO.\n\nSo first step: For each edge, check if l % g != 0. If any edge fails this, output NO.\n\nOnce that's done, for each edge, compute k = l / g. Then, the product of x and y (coprimes) is k. So, x and y must be coprime divisors of k, such that x*y =k.\n\nBut how to assign x and y for each edge? Well, since x and y are coprime, then x must be a divisor of k, and y = k/x, and gcd(x, y) = 1.\n\nBut how to assign this for the entire graph?\n\nLet me think of the problem as building a graph where each node's value is determined by the product of g and some variable, but the variables must be coprime with their neighbors.\n\nAlternatively, think of the problem as building a graph where each node's value is a multiple of some base value, and the relations between nodes are determined by the edges.\n\nWait, here's an idea: For each connected component in the graph, we can assign a base value to one node, and then derive the values of other nodes based on the edges. However, the problem is that the values are interdependent. For example, if we have a cycle, the assignments must be consistent around the cycle.\n\nLet me think of an example. Suppose there's a triangle of nodes A-B, B-C, C-A. Each edge has their own GCD and LCM. How can we assign values?\n\nBut perhaps the key is to model the problem as a graph where each node's value is determined by the product of some factors, and the relations between nodes are multiplicative.\n\nAnother approach: Let's model the problem as a graph where each node's value is determined by the product of g and some variable, and for each edge, the variables must be coprime. For example, for each edge (u, v) with GCD g and LCM l, we have a_u = g * x_u, a_v = g * x_v. Then, x_u and x_v must be coprime, and x_u * x_v = l/g. So, for each edge, x_u and x_v are coprime, and their product is k = l/g.\n\nBut how can we assign x_u and x_v for all nodes in the graph?\n\nThis seems like a problem where the variables x_i must satisfy for each edge (u, v) that x_u * x_v = k_uv (where k_uv is l/g for that edge), and gcd(x_u, x_v) = 1.\n\nBut how can we find such x_i's?\n\nLet me think about this. Suppose we have a connected component. Let's pick a root node and assign x_root as some value, then derive the rest based on the edges. But how?\n\nFor example, consider a tree structure. Let's say we have a tree where each node is connected to its parent. For each edge from parent u to child v, we have that x_u * x_v = k_uv. Also, since x_u and x_v are coprime, then x_v must be a divisor of k_uv, and x_u must be k_uv / x_v. But since they are coprime, x_v must be a divisor of k_uv, and x_u must be k_uv divided by x_v, and they must be coprime.\n\nBut how to choose x_v? Well, for the tree, once you assign x_root, you can traverse the tree and assign x's accordingly.\n\nWait, but for each edge, the product x_u * x_v is fixed. So, for example, if we have a tree, and we assign x_root as 1, then for each edge from root to child, x_child must be k_uv, since x_root * x_child = k_uv. But then, for the next edge, say from child to grandchild, the product of x_child and x_grandchild must be k_new. Since x_child is known, x_grandchild is k_new / x_child. But then, we must check that x_grandchild and x_child are coprime. But how?\n\nWait, this seems like a problem. Because if we assign x_root as 1, and then assign x_child as k_uv, then when we process the next edge, we have x_child * x_grandchild = k_new. So x_grandchild = k_new / x_child. But then, since x_child and x_grandchild must be coprime, we have to check that gcd(x_child, k_new / x_child) is 1. But how can we ensure that?\n\nBut this depends on the choice of x_root. For example, maybe choosing x_root as a particular value allows this to be satisfied. However, how do we know what value to choose for x_root?\n\nAlternatively, perhaps for the entire connected component, the product of all the k_uv along the edges must be a square? Or something similar. Wait, but that's not necessarily the case. Let me think of an example.\n\nTake a simple case: a single edge between u and v. The product x_u * x_v = k. Since x_u and x_v are coprime, then x_u and x_v must be divisors of k that are coprime. So, for example, if k is 6, then possible pairs are (1,6), (2,3), (3,2), (6,1). But in this case, the assignment can be done in any of these ways. However, if the graph is connected, and there are multiple edges, then the assignments must be consistent.\n\nBut how to model this. Let's think of the problem as building a graph where each node's x_i is determined by the product of the k_uv along the path from the root to that node. But since for each edge, the product of x_u and x_v is k_uv, then perhaps the product of x's along a path must be determined in a way that is consistent.\n\nAlternatively, think of the x_i's as being variables that must satisfy for each edge (u, v) that x_u * x_v = k_uv and gcd(x_u, x_v) = 1.\n\nLet me consider that if I have a connected component, and for each edge (u, v), the product x_u * x_v is fixed. Then, for any two nodes u and v in the same connected component, the product of x_u and x_v must be equal to the product of all k's along any path between u and v, divided by something... Wait, perhaps not. Let me think of a cycle. Suppose we have a cycle of three nodes u-v-w-u. Each edge has product k1, k2, k3 respectively. Then, for the product:\n\nx_u * x_v = k1\n\nx_v * x_w = k2\n\nx_w * x_u = k3\n\nMultiply all three equations: (x_u x_v x_w)^2 = k1 k2 k3 → x_u x_v x_w = sqrt(k1 k2 k3). So, for this to be possible, k1*k2*k3 must be a perfect square. Otherwise, no solution exists.\n\nBut in this case, the product of the three k's must be a square. Otherwise, no solution. But how can this be checked?\n\nThis suggests that for any cycle in the graph, the product of the k's along the cycle must be a square. Because when you multiply the equations along the cycle, you get that the product of the x's squared equals the product of the k's. Therefore, the product of the k's must be a square. Otherwise, no solution.\n\nSo, this gives us another condition. For each connected component, the product of the k's along any cycle must be a square. But how to check this efficiently?\n\nAlternatively, during a BFS or DFS traversal of the graph, whenever we encounter a back edge (i.e., an edge that connects to an already visited node), we can check if the product of the k's along the path from the current node to the already visited node multiplied by the k of the current edge is a square. If not, then there's no solution.\n\nBut how to track this?\n\nLet me think again. Suppose we have a connected component. We can model the x_i as follows: for each node, we can assign x_i = (product of k's along the path from the root to i) divided by x_root. Wait, but how?\n\nAlternatively, during BFS, for each node, we can assign a value that is the product of the k's along the path from the root to this node, divided by the product of the k's along the path from the root to the parent node. Wait, that's not helpful. Maybe another approach.\n\nLet me think of the variables x_i as follows. For any two nodes u and v in the same connected component, the product x_u * x_v must be equal to the product of the k's along any path between u and v. Because, for example, if the path is u - a - b - ... - v, then each step contributes a product of x's. For example, x_u * x_a = k_ua, x_a * x_b = k_ab, ..., x_prev * x_v = k_prevv. Multiply all these equations: x_u * x_a * x_a * x_b * ... * x_prev * x_v = product of k's. But since x_a appears twice, etc., except for x_u and x_v, which appear once. So the product is (x_u * x_v) * (product of x's squared) = product of k's. Therefore, unless all the x's except x_u and x_v are squares, which they may not be, this seems complicated.\n\nBut perhaps, for any two nodes u and v in the same connected component, the product x_u * x_v is equal to the product of the k's along any path between u and v divided by the product of the squares of the x's along that path. This seems too vague.\n\nAlternatively, considering that for any two nodes u and v, the product x_u * x_v is equal to the product of the k's along any path between them divided by the product of the x's squared along that path. Not sure.\n\nThis seems complicated. Let's go back to the earlier idea. For a connected component, during BFS traversal, assign x values based on the edges. For example, pick a root node, assign x_root as 1. Then, for each neighbor, we can set x_neighbor = k_uv / x_root. Since x_root is 1, x_neighbor = k_uv. Then, for the next level, for each neighbor of the neighbor, we have that x_current * x_next = k_current_next. So x_next = k_current_next / x_current. But then, this x_next must be coprime with x_current. But how do we ensure that?\n\nWait, but the x_current is determined by previous steps. For example, if the root is assigned 1, and then a neighbor is assigned k_uv, then when processing that neighbor's children, we have to check whether x_neighbor and x_child are coprime. But how can that be ensured?\n\nThis suggests that the way we assign x values depends on the choices made during the traversal. For example, in a tree, if we assign the root's x as 1, then for each child, we assign x as k_uv. But then, when processing the next level, the product of x_child and x_grandchild must be k_new. So x_grandchild = k_new / x_child. Now, since x_child is k_uv, and k_new is l/g for that edge, we need to check that k_uv divides k_new, and that the result is coprime with k_uv.\n\nBut how can we ensure that? It seems that this depends on the actual values of the k's. For example, if the k_uv is 6 and k_new is 12, then x_grandchild would be 12/6 = 2, which is coprime with 6? No, because gcd(6, 2) is 2. Which violates the requirement that x_child and x_grandchild are coprime. Therefore, this assignment would be invalid.\n\nSo, this suggests that the initial assignment of x_root as 1 might not work. Therefore, how to choose the x values for the nodes so that all the coprimality conditions are satisfied?\n\nThis seems like a problem that requires building a system where the variables are constrained to be coprime in pairs for each edge. But how?\n\nAnother thought: since x_u and x_v are coprime, and their product is k_uv, then x_u must be a divisor of k_uv, and x_v = k_uv / x_u. Also, since they are coprime, x_u must be a divisor of k_uv that is coprime with k_uv / x_u. Which means that x_u must be a divisor of k_uv and that x_u and k_uv/x_u are coprime. Which implies that x_u must be a divisor of k_uv such that x_u is square-free and divides k_uv. Wait, not sure.\n\nAlternatively, since x_u and x_v are coprime and their product is k_uv, then x_u must be a divisor of k_uv and x_v must be the complementary divisor. Moreover, since they are coprime, x_u must be square-free? Not necessarily. For example, if k_uv is 4, then x_u could be 1 and x_v 4 (coprime), or x_u=2 and x_v=2 (but then their GCD is 2, which is not allowed). So only the first option is valid. So for k_uv=4, the only valid pairs are (1,4) and (4,1). Thus, the x's must be chosen as coprime factors of k_uv.\n\nSo for each edge, there are two possibilities for the assignment of x's. But how to choose between them in a way that is consistent across the entire graph?\n\nThis seems like a problem that can be modeled as a bipartition. For example, if we have a tree structure, and we assign x values based on the edges, but ensuring that the coprimality conditions are met. However, for cycles, the product of the k's must be a square, as discussed before.\n\nBut how to implement this?\n\nPerhaps, for each connected component, we can perform a BFS or DFS traversal, assigning x values as follows: when visiting a node u, for each neighbor v, if v hasn't been visited yet, assign x_v = k_uv / x_u. But then, we need to ensure that x_v and x_u are coprime. However, since x_u * x_v = k_uv, and x_v = k_uv / x_u, then x_u and x_v are coprime if and only if x_u divides k_uv and gcd(x_u, k_uv/x_u) = 1. Which is always true, because x_u and x_v are factors of k_uv whose product is k_uv and their gcd is 1. Wait, no. Because x_u and x_v are factors of k_uv, and their product is k_uv, and their gcd is 1. So, if x_u and x_v are coprime and multiply to k_uv, then x_u must be a divisor of k_uv, and x_v = k_uv / x_u. But how do we choose x_u such that this holds?\n\nAh! Because the product x_u * x_v is k_uv, and their GCD is 1, then x_u must be a divisor of k_uv, and x_v is k_uv / x_u. However, the choice of x_u is arbitrary as long as it divides k_uv and that x_u and x_v are coprime. But how to choose x_u in a way that is consistent with the rest of the graph?\n\nBut perhaps, during the BFS traversal, once we assign x_u for a node, then for the neighboring nodes, we have to assign x_v = k_uv / x_u. But then, we need to ensure that x_v and x_u are coprime. Which is guaranteed by the fact that x_u * x_v = k_uv, and that their GCD is 1. Wait, but how?\n\nBecause, suppose x_u and x_v are such that their product is k_uv and their GCD is 1. Then, x_u must be a divisor of k_uv and x_v is k_uv/x_u. However, the GCD(x_u, x_v) is 1. So, if we can ensure that during the assignment, x_u is chosen such that this is true, then everything is okay.\n\nBut how to choose x_u for the first node?\n\nLet me think. Suppose I start with node u, assign x_u as 1. Then, for each neighbor v, x_v = k_uv / x_u = k_uv. Then, since x_u is 1 and x_v is k_uv, their GCD is 1. But wait, that's only true if k_uv is such that 1 and k_uv are coprime, which they are. Because GCD(1, anything) is 1. So that's okay.\n\nThen, for the next step, when visiting node v, and looking at its neighbor w, which hasn't been visited yet. Then, x_w = k_vw / x_v. But x_v is k_uv. So x_w = k_vw / k_uv. Now, we need to check that x_w and x_v are coprime. Which is equivalent to checking that GCD(k_uv, k_vw / k_uv) = 1. But how can we ensure that?\n\nWait, but this depends on the values of k_uv and k_vw. For example, if k_uv is 6 and k_vw is 12, then x_w = 12 / 6 = 2. Now, x_v is 6, and x_w is 2. Their GCD is 2, which is not 1. So this would violate the condition. Hence, the assignment would be invalid.\n\nSo this suggests that the initial choice of x_u as 1 may not work, and that the way we assign x values during traversal must be adjusted.\n\nBut how?\n\nThis seems to be a problem. How can we choose x_u's such that for every edge, the two x's are coprime?\n\nAnother approach: For each edge (u, v), since x_u and x_v are coprime, and their product is k_uv, then x_u must be a divisor of k_uv, and x_v is k_uv divided by x_u. Also, since x_u and x_v are coprime, then x_u must be square-free? No, that's not necessarily true. For example, k_uv = 4, x_u = 1, x_v = 4. Then, x_v is not square-free, but their GCD is 1.\n\nBut in this case, x_u is a divisor of k_uv and x_v is the complementary divisor. However, the problem is that during the traversal, when we assign x_v as k_uv / x_u, we need to ensure that this x_v is compatible with the rest of the graph.\n\nBut how?\n\nMaybe the key is that for the entire connected component, the product of all k_uv along any path between two nodes must be a square. Because earlier, in the cycle example, the product of the k's must be a square. So, for any two paths between u and v, the product of the k's along the paths must be equal. Otherwise, there's no solution.\n\nThis suggests that for each connected component, we need to check that for any two paths between u and v, the product of the k's is the same. Because otherwise, when trying to assign x values, there will be a contradiction.\n\nBut how to check this efficiently?\n\nThis sounds like a problem that can be solved using Union-Find (Disjoint Set Union) with some additional information. However, I'm not sure how to track the product of the k's along the path.\n\nAlternatively, during BFS traversal, for each node, we can store the product of the k's along the path from the root to that node. Let's call this value 'prod'. Then, for any edge between u and v, if both u and v are already visited, then the product of the k's along the path from u to v via the root must be equal to the product of the k's along the path from u to v via the edge. Let me think.\n\nSuppose u and v are connected by an edge with k_uv. The product of the k's along the path from root to u is prod_u, and from root to v is prod_v. Then, the product of the k's along the path from u to v through the root is (prod_u * prod_v) / (prod_root^2) ? Not sure.\n\nAlternatively, considering that for any two nodes u and v, the product of the k's along any path between them must be equal to (prod_u * prod_v) / (prod_root^2) ?\n\nNo, perhaps not. Let me think of a simple example. Suppose the root is r, and there is a path r -> u -> v. The product of the k's along this path is k_ru * k_uv. Also, the product of the k's along the path from r to v is k_ru * k_uv. So, for any node v, prod_v = product of the k's along the path from root to v.\n\nNow, if there is an edge between u and v with k_uv, and during traversal, we have already processed u, and now we're processing v. Then, the product of the k's along the path from root to v should be equal to the product of the k's along the path from root to u multiplied by k_uv. But if v was already visited, then we have a cycle. In that case, the existing product of the k's along the path from root to v (prod_v) must be equal to the product of the k's along the path from root to u multiplied by k_uv. If not, then it's impossible.\n\nSo during traversal, whenever we encounter an edge between u and v where both are already visited, we check whether prod_u * k_uv == prod_v. If not, then it's impossible.\n\nThis seems promising. Because if this condition holds for all edges, then the product of the k's along any path between two nodes is the same, and thus the assignment is possible.\n\nBut how does this relate to the x values?\n\nWell, assuming that this condition holds, then we can assign x values as follows: For each node, x_i = prod_i / x_root. Because, for example, for the root, x_root = x_root. For node u connected to root via edge with k_ru, we have x_root * x_u = k_ru. So x_u = k_ru / x_root. Similarly, for node v connected to u via edge with k_uv, x_u * x_v = k_uv → x_v = k_uv / x_u = k_uv * x_root / k_ru. Which equals (k_ru * k_uv) / (x_root * k_ru) ) ? No. Wait, x_u is k_ru / x_root. So x_v = k_uv / (k_ru / x_root) ) = (k_uv * x_root) / k_ru. But the product of the k's along the path from root to v is k_ru * k_uv. So, x_v = (prod_v) / x_root. Because prod_v = k_ru * k_uv. So x_v = (prod_v) / x_root.\n\nSo in general, x_i = prod_i / x_root. Then, for any edge between u and v, x_u * x_v = (prod_u / x_root) * (prod_v / x_root) ) = (prod_u * prod_v) / (x_root^2). But according to the earlier condition, for any edge between u and v, the product of the k's along the path from u to v is prod_u * k_uv = prod_v. So, prod_v = prod_u * k_uv. Therefore, substituting into the equation:\n\nx_u * x_v = (prod_u * (prod_u * k_uv)) ) / (x_root^2) ) = (prod_u² * k_uv) / x_root². \n\nBut we need this to be equal to k_uv. Because for the edge between u and v, x_u * x_v must equal k_uv. So:\n\n(prod_u² * k_uv) / x_root² = k_uv → prod_u² / x_root² = 1 → prod_u = ±x_root. But since all k's are positive integers, prod_u is positive, so prod_u = x_root. Which implies that x_root is equal to prod_u. But this seems to suggest that x_root is equal to all the prod_i's for nodes in the connected component. Which is impossible unless all prod_i's are equal to x_root. Which would imply that x_i = 1 for all nodes, which is only possible if all k's along the path are 1. Which isn't generally the case.\n\nSo there's a contradiction here. This suggests that my earlier reasoning is flawed.\n\nLet me re-examine. For any edge between u and v, x_u * x_v = k_uv. And according to the assignment x_i = prod_i / x_root, this becomes:\n\n(prod_u / x_root) * (prod_v / x_root) ) = k_uv → (prod_u * prod_v) / x_root² = k_uv.\n\nBut from the condition that for any edge between u and v, prod_v = prod_u * k_uv. Substituting this into the equation:\n\nprod_u * (prod_u * k_uv) / x_root² = k_uv → (prod_u² * k_uv) / x_root² = k_uv → prod_u² = x_root² → prod_u = x_root (since all values are positive).\n\nThis implies that for any node u in the connected component, prod_u = x_root. Which would mean that x_i = (x_root) / x_root = 1 for all nodes. Which implies that x_i = 1 for all nodes. Which would imply that for every edge, k_uv = x_u * x_v = 1 * 1 = 1. Which is only possible if all k_uv are 1. Which is not generally the case.\n\nThis suggests that the earlier assumption that x_i = prod_i / x_root is incorrect, or that the condition derived from the cycle is not sufficient.\n\nHmm. This indicates that there's a flaw in my reasoning. Let's think again.\n\nLet me try to think of a simple example. Suppose there is a single edge between u and v, with k_uv = 6. Then, during BFS traversal, assign x_root (say, u) as 1. Then, x_v = k_uv / x_root = 6. So x_u = 1, x_v = 6. Now, x_u * x_v = 6 = k_uv, which is correct. The product of the k's along the path from root to u is 1 (assuming the root is u?), but I think I need to clarify the definitions.\n\nWait, the prod_i is the product of the k's along the path from the root to node i. For example, in this case, if the root is u, then prod_u = 1 (no edges), and prod_v = k_uv = 6. Then, according to the formula x_i = prod_i / x_root, x_root is x_u = 1. So x_u = 1 / 1 = 1, x_v = 6 / 1 = 6. Which matches our earlier assignment. Now, for the edge between u and v, x_u * x_v = 1*6 = 6 = k_uv. So that works.\n\nNow, if there's another edge between v and w with k_vw = 12. Then, during traversal, we assign x_w = k_vw / x_v = 12/6 = 2. So x_w = 2. Now, x_v = 6, x_w = 2. Their product is 12, which is k_vw. And their GCD is 2, which is not 1. So this violates the condition that x_v and x_w must be coprime. Hence, this assignment is invalid. But according to the earlier condition, during BFS traversal, when we process the edge between v and w, since w is unvisited, we assign x_w = k_vw / x_v = 12/6 = 2. However, this leads to a violation of the coprimality condition.\n\nThis suggests that the earlier approach of assigning x_i = prod_i / x_root is insufficient to ensure that the coprimality condition is satisfied.\n\nSo, what's wrong here?\n\nThe problem is that the assignment of x_i = prod_i / x_root ensures that x_u * x_v = k_uv, but not that x_u and x_v are coprime. Hence, this approach misses checking that the coprimality condition is satisfied.\n\nTherefore, the earlier approach is incomplete. It ensures that the product condition is satisfied, but not the coprimality.\n\nSo, how to handle the coprimality condition?\n\nThis seems challenging. Perhaps the key is to realize that for the coprimality condition to hold, the x_i's must be pairwise coprime for every edge. Which means that for each edge, the x_i and x_j must be coprime. But how to ensure this during the assignment.\n\nLet me think about the example again. In the case where x_v = 6 and x_w = 2, they are not coprime. So this assignment is invalid. But why did this happen?\n\nBecause during the traversal, I chose x_v = 6, and then assigned x_w as 12 / 6 = 2. However, this leads to a violation of the coprimality condition. So, the error is in the assignment of x_w. But how can I avoid this?\n\nPerhaps, during the assignment, after calculating x_w = k_vw / x_v, I must check that gcd(x_v, x_w) == 1. If not, then there is no solution.\n\nBut how can this be done? In the example, when processing the edge between v and w, after assigning x_w = 2, we check gcd(6, 2) = 2 != 1. Hence, this assignment is invalid. So, the algorithm would return NO.\n\nBut what if there was another way to assign x_v and x_w such that their product is ",
    "response": "To solve this problem, we need to determine if we can assign numbers to each lawn such that for every given road, the greatest common divisor (GCD) and least common multiple (LCM) of the numbers on the connected lawns match the given values. If possible, we should output the numbers; otherwise, we should indicate that it's not possible.\n\n### Approach\n1. **Check Validity of Input**: For each road, ensure that the LCM is divisible by the GCD. If not, it's impossible to satisfy the conditions.\n2. **Graph Traversal**: Use a BFS (Breadth-First Search) approach to traverse the graph starting from each unvisited node. During traversal, assign values to nodes ensuring that the product of values on connected nodes matches the given LCM and their GCD is correct.\n3. **Consistency Check**: During traversal, ensure that the values assigned to nodes are consistent with the constraints provided by the edges. If any inconsistency is found, return \"NO\".\n\n### Solution Code\n```python\nimport sys\nimport math\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n    \n    edges = []\n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        u = int(input[idx]) - 1\n        idx += 1\n        v = int(input[idx]) - 1\n        idx += 1\n        g = int(input[idx])\n        idx += 1\n        l = int(input[idx])\n        idx += 1\n        if l % g != 0:\n            print(\"NO\")\n            return\n        k = l // g\n        edges.append((u, v, g, l, k))\n        adj[u].append((v, g, l, k))\n        adj[v].append((u, g, l, k))\n    \n    result = [0] * n\n    visited = [False] * n\n    \n    for start in range(n):\n        if not visited[start]:\n            queue = deque()\n            queue.append(start)\n            visited[start] = True\n            result[start] = 1  # arbitrary initial value\n            valid = True\n            while queue:\n                u = queue.popleft()\n                for v, g, l, k in adj[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        # x_u * x_v = k\n                        # x_v = k / x_u\n                        x_u = result[u]\n                        if x_u == 0:\n                            valid = False\n                            break\n                        if k % x_u != 0:\n                            valid = False\n                            break\n                        x_v = k // x_u\n                        if math.gcd(x_u, x_v) != 1:\n                            valid = False\n                            break\n                        result[v] = x_v\n                        queue.append(v)\n                    else:\n                        x_u = result[u]\n                        x_v = result[v]\n                        if x_u * x_v != k or math.gcd(x_u, x_v) != 1:\n                            valid = False\n                            break\n                if not valid:\n                    break\n            if not valid:\n                print(\"NO\")\n                return\n    \n    # Now, check that all edges satisfy the original GCD and LCM\n    for u, v, g, l, k in edges:\n        a = result[u]\n        b = result[v]\n        if math.gcd(a, b) != g or (a * b) // math.gcd(a, b) != l:\n            print(\"NO\")\n            return\n    \n    print(\"YES\")\n    print(' '.join(map(str, [g * result[i] for i in range(n)])))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Input Reading and Initial Checks**: The input is read and each edge is checked for validity (LCM must be divisible by GCD).\n2. **Graph Traversal with BFS**: Starting from each unvisited node, we use BFS to traverse the graph. During traversal, we assign values to nodes ensuring that the product of values on connected nodes matches the given LCM and their GCD is correct.\n3. **Validation**: After assigning values, we validate that all edges meet the original GCD and LCM constraints. If any edge fails this check, we print \"NO\". Otherwise, we print \"YES\" followed by the computed values for each lawn.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n    \n    edges = []\n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        u = int(input[idx]) - 1\n        idx += 1\n        v = int(input[idx]) - 1\n        idx += 1\n        g = int(input[idx])\n        idx += 1\n        l = int(input[idx])\n        idx += 1\n        if l % g != 0:\n            print(\"NO\")\n            return\n        k = l // g\n        edges.append((u, v, g, l, k))\n        adj[u].append((v, g, l, k))\n        adj[v].append((u, g, l, k))\n    \n    result = [0] * n\n    visited = [False] * n\n    \n    for start in range(n):\n        if not visited[start]:\n            queue = deque()\n            queue.append(start)\n            visited[start] = True\n            result[start] = 1  # arbitrary initial value\n            valid = True\n            while queue:\n                u = queue.popleft()\n                for v, g, l, k in adj[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        # x_u * x_v = k\n                        # x_v = k / x_u\n                        x_u = result[u]\n                        if x_u == 0:\n                            valid = False\n                            break\n                        if k % x_u != 0:\n                            valid = False\n                            break\n                        x_v = k // x_u\n                        if math.gcd(x_u, x_v) != 1:\n                            valid = False\n                            break\n                        result[v] = x_v\n                        queue.append(v)\n                    else:\n                        x_u = result[u]\n                        x_v = result[v]\n                        if x_u * x_v != k or math.gcd(x_u, x_v) != 1:\n                            valid = False\n                            break\n                if not valid:\n                    break\n            if not valid:\n                print(\"NO\")\n                return\n    \n    # Now, check that all edges satisfy the original GCD and LCM\n    for u, v, g, l, k in edges:\n        a = result[u]\n        b = result[v]\n        if math.gcd(a, b) != g or (a * b) // math.gcd(a, b) != l:\n            print(\"NO\")\n            return\n    \n    print(\"YES\")\n    print(' '.join(map(str, [g * result[i] for i in range(n)])))\n\nif __name__ == \"__main__\":\n    main()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 558,
        "completion_token_count": 952,
        "thoughts_token_count": 8192
    }
}