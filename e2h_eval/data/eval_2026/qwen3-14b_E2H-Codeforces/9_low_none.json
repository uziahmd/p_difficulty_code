{
    "start": 1758313696.7600236,
    "end": 1758313737.828752,
    "start-formatted": "2025-09-20 05:28 KST",
    "end-formatted": "2025-09-20 05:28 KST",
    "gpu": 2,
    "pid": 9,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Selling Souvenirs\n\nAfter several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.This morning, as usual, Petya will come to the market. Petya has n different souvenirs to sell; ith souvenir is characterised by its weight wi and cost ci. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than m, and total cost is maximum possible.Help Petya to determine maximum possible total cost.\n\n## Input\nThe first line contains two integers n and m (1 ≤ n ≤ 100000, 1 ≤ m ≤ 300000) — the number of Petya's souvenirs and total weight that he can carry to the market.Then n lines follow. ith line contains two integers wi and ci (1 ≤ wi ≤ 3, 1 ≤ ci ≤ 109) — the weight and the cost of ith souvenir.\n\n## Output\nPrint one number — maximum possible total cost of souvenirs that Petya can carry to the market.\n\n## Example\n### Input\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\n### Output\n['0', '3', '10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\nOkay, let's see. I need to solve this problem where Petya wants to select souvenirs with maximum total cost without exceeding a weight limit m. The constraints are that n can be up to 1e5 and m up to 3e5. Also, each souvenir's weight is between 1 and 3. Hmm.\n\nSo the classic knapsack problem, but with weights limited to 1, 2, or 3. Since the standard dynamic programming approach for knapsack is O(nm), which for n=1e5 and m=3e5 would be 3e10 operations, that's way too slow. So I need a smarter approach here.\n\nLet me think. Since the weights are small (only 1, 2, 3), maybe we can group items by their weight and then find an optimal way to take them.\n\nFor example, for each weight category (1, 2, 3), sort the items in descending order of cost. Then, for each weight category, precompute the prefix sums so that for any number of items taken from that category, we can quickly compute the total cost.\n\nThen, the problem becomes how to combine these three groups optimally. Let's think about it.\n\nLet me denote:\n\n- For weight 1: we have a list sorted in descending order of cost. Let's say there are a_1 items. The prefix sum array for weight 1 is s1, where s1[k] is the sum of the first k items.\n\nSimilarly for weight 2: sorted, prefix sum s2. And weight 3: s3.\n\nNow, the challenge is to choose x items of weight 1, y items of weight 2, z items of weight 3 such that x*1 + y*2 + z*3 ≤ m. And maximize the total cost s1[x] + s2[y] + s3[z].\n\nBut how do I efficiently compute this? Because trying all possible x, y, z combinations would be O(a1 * a2 * a3), which could be big if each group has many items. But since the total weight is up to 3e5, perhaps there's a way to loop through possible numbers of items for two groups and compute the third.\n\nAlternatively, considering that for each possible number of weight 1 and 2 items, we can calculate the maximum possible for weight 3.\n\nBut even that might be too slow. Let's think of the possible ranges.\n\nLet me think about the maximum number of items for each weight:\n\nFor weight 1: the maximum possible is min( (m) , number of items with weight 1). Similarly for others.\n\nBut perhaps the key is to iterate over the number of weight 3 items, then for the remaining weight, do something similar with weight 1 and 2.\n\nAlternatively, here's an idea:\n\nLet me precompute for each weight group the prefix sums. Then, for each possible number of weight 3 items (z), I can calculate the remaining weight capacity as rem = m - 3*z. Then, for this rem, I need to choose x items of weight 1 and y items of weight 2 such that x + 2y ≤ rem. How can I compute the maximum for x and y?\n\nBut even that, for each z, how do I compute the best x and y?\n\nAlternatively, for each possible z (number of weight 3 items), the problem reduces to solving a similar problem with weight 1 and 2, and a capacity of rem = m - 3*z. But how to compute that quickly.\n\nLet me think about solving the subproblem of choosing x and y (for weight 1 and 2) given a capacity W. How to maximize s1[x] + s2[y], with x + 2y ≤ W.\n\nBut how to compute this quickly?\n\nFor this subproblem, perhaps we can iterate over the number of y (weight 2 items) and compute the maximum x possible.\n\nBut again, for each possible y, the maximum x is W - 2y. So for each possible y, take min(possible number of items in weight 2, y_max) and then take x as min(possible items in weight 1, W - 2y).\n\nBut how to find the optimal y?\n\nLet me think. Let's say for the weight 1 and 2 items, we have sorted lists. For each possible y (number of weight 2 items), the maximum x is (W - 2*y), but we can't take more than the available items in weight 1.\n\nBut if we precompute the prefix sums for weight 1 and 2, then for each possible y, we can compute the maximum x as min( (W - 2y), len1 ), where len1 is the number of weight 1 items. Then, the total cost is s2[y]",
    "response": "To solve this problem efficiently, we need to maximize the total cost of souvenirs Petya can carry, given a weight limit. The key insight is that each souvenir has a weight of 1, 2, or 3, allowing us to use optimized strategies for each weight category.\n\n### Approach\n1. **Grouping by Weight**: Separate the souvenirs into three groups based on their weights (1, 2, and 3).\n2. **Sorting and Prefix Sums**: Sort each group in descending order of cost and compute prefix sums for each group. This helps in quickly determining the maximum cost for any number of items taken from each group.\n3. **Iterate Over Possible Choices**: For each possible number of weight 3 items, calculate the remaining capacity and then determine the optimal combination of weight 1 and weight 2 items that fit within this remaining capacity.\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n    \n    w1 = []\n    w2 = []\n    w3 = []\n    \n    for _ in range(n):\n        wi = int(input[idx])\n        idx += 1\n        ci = int(input[idx])\n        idx += 1\n        if wi == 1:\n            w1.append(ci)\n        elif wi == 2:\n            w2.append(ci)\n        else:\n            w3.append(ci)\n    \n    # Sort and compute prefix sums\n    w1.sort(reverse=True)\n    w2.sort(reverse=True)\n    w3.sort(reverse=True)\n    \n    # Compute prefix sums\n    s1 = [0]\n    for c in w1:\n        s1.append(s1[-1] + c)\n    \n    s2 = [0]\n    for c in w2:\n        s2.append(s2[-1] + c)\n    \n    s3 = [0]\n    for c in w3:\n        s3.append(s3[-1] + c)\n    \n    max_total = 0\n    \n    # Iterate over possible number of weight 3 items\n    max_z = min(len(w3), m // 3)\n    for z in range(0, max_z + 1):\n        rem = m - 3 * z\n        # Now solve for weight 1 and 2 with capacity rem\n        # Try all possible y (number of weight 2 items)\n        max_y = min(len(w2), rem // 2)\n        best = 0\n        # For each possible y, compute x = min(rem - 2y, len(w1))\n        for y in range(0, max_y + 1):\n            x = min(rem - 2 * y, len(w1))\n            current = s1[x] + s2[y]\n            if current > best:\n                best = current\n        total = best + s3[z]\n        if total > max_total:\n            max_total = total\n    \n    print(max_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Input Handling**: The input is read and parsed into three separate lists based on the weight of the souvenirs.\n2. **Sorting and Prefix Sums**: Each list of souvenirs is sorted in descending order of cost, and prefix sums are computed to quickly determine the maximum cost for any number of items taken from each group.\n3. **Iterating Over Combinations**: For each possible number of weight 3 items, the remaining capacity is calculated. For this remaining capacity, the optimal combination of weight 1 and weight 2 items is determined by iterating over possible counts of weight 2 items and calculating the corresponding maximum count of weight 1 items that fit within the remaining capacity.\n\nThis approach efficiently narrows down the problem space using the constraints on weights, leading to an optimal solution without the need for a full dynamic programming table.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n    \n    w1 = []\n    w2 = []\n    w3 = []\n    \n    for _ in range(n):\n        wi = int(input[idx])\n        idx += 1\n        ci = int(input[idx])\n        idx += 1\n        if wi == 1:\n            w1.append(ci)\n        elif wi == 2:\n            w2.append(ci)\n        else:\n            w3.append(ci)\n    \n    # Sort and compute prefix sums\n    w1.sort(reverse=True)\n    w2.sort(reverse=True)\n    w3.sort(reverse=True)\n    \n    # Compute prefix sums\n    s1 = [0]\n    for c in w1:\n        s1.append(s1[-1] + c)\n    \n    s2 = [0]\n    for c in w2:\n        s2.append(s2[-1] + c)\n    \n    s3 = [0]\n    for c in w3:\n        s3.append(s3[-1] + c)\n    \n    max_total = 0\n    \n    # Iterate over possible number of weight 3 items\n    max_z = min(len(w3), m // 3)\n    for z in range(0, max_z + 1):\n        rem = m - 3 * z\n        # Now solve for weight 1 and 2 with capacity rem\n        # Try all possible y (number of weight 2 items)\n        max_y = min(len(w2), rem // 2)\n        best = 0\n        # For each possible y, compute x = min(rem - 2y, len(w1))\n        for y in range(0, max_y + 1):\n            x = min(rem - 2 * y, len(w1))\n            current = s1[x] + s2[y]\n            if current > best:\n                best = current\n        total = best + s3[z]\n        if total > max_total:\n            max_total = total\n    \n    print(max_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 474,
        "completion_token_count": 838,
        "thoughts_token_count": 1024
    }
}