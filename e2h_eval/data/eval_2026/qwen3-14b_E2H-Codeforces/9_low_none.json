{
    "start": 1758008984.4381068,
    "end": 1758009449.5009515,
    "start-formatted": "2025-09-16 16:49 KST",
    "end-formatted": "2025-09-16 16:57 KST",
    "gpu": 2,
    "pid": 9,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Selling Souvenirs\n\nAfter several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.This morning, as usual, Petya will come to the market. Petya has n different souvenirs to sell; ith souvenir is characterised by its weight wi and cost ci. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than m, and total cost is maximum possible.Help Petya to determine maximum possible total cost.\n\n## Input\nThe first line contains two integers n and m (1 ≤ n ≤ 100000, 1 ≤ m ≤ 300000) — the number of Petya's souvenirs and total weight that he can carry to the market.Then n lines follow. ith line contains two integers wi and ci (1 ≤ wi ≤ 3, 1 ≤ ci ≤ 109) — the weight and the cost of ith souvenir.\n\n## Output\nPrint one number — maximum possible total cost of souvenirs that Petya can carry to the market.\n\n## Example\n### Input\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\n### Output\n['0', '3', '10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\nOkay, let's tackle this problem. So, the task is to find the maximum possible total cost of souvenirs that Petya can carry, given that each souvenir has a weight (1, 2, or 3) and a cost. The constraints are n up to 1e5 and m up to 3e5. Hmm, so a standard knapsack approach would be too slow here because for n=1e5 and m=3e5, the O(nm) solution would be 3e10 operations, which is impossible.\n\nSo, we need a smarter approach. Let's think about the weights. Since each item's weight is either 1, 2, or 3, maybe we can process each group separately and then combine them optimally.\n\nLet me think. For each weight category (1, 2, 3), we can sort the items in descending order of cost. Then, for each weight group, we can precompute the prefix sums. That way, for any number of items taken from that group, we can quickly calculate the total cost.\n\nFor example, for weight 1 items, after sorting, taking k items gives us the sum of the first k items. Similarly for weight 2 and 3.\n\nOnce we have these prefix sums, the problem becomes selecting how many items to take from each group such that the total weight is <= m, and the sum of their costs is maximized.\n\nBut how do we combine these groups efficiently?\n\nLet me think of the approach. Suppose we have three arrays: for weight 1, weight 2, weight 3. Each sorted in descending order of cost, with prefix sums.\n\nThen, for each possible number of weight 3 items taken (let's say x), and for each possible number of weight 2 items taken (y), we can compute how many weight 1 items can be taken (z), such that 3x + 2y + z <= m. But even that might be too slow if done naively.\n\nAlternatively, since the weights are small (1, 2, 3), maybe we can iterate through one of the groups and use two pointers or binary search for the others.\n\nAnother idea: Let's consider all possible numbers of weight 3 items. For each possible x (number of weight 3 items taken), we can compute the remaining weight capacity, then solve the problem for weight 1 and 2 items with that remaining capacity.\n\nBut how do we handle the weight 1 and 2 items? Well, for that, perhaps we can precompute for all possible capacities up to m, the maximum value achievable with weight 1 and 2 items.\n\nWait, but for weight 1 and 2 items, we can model it as a knapsack problem with items of weight 1 and 2. However, since the items are sorted, maybe there's a way to compute for each possible capacity, the optimal selection.\n\nAlternatively, for the combination of weight 1 and 2 items, given a certain capacity, we can use a greedy approach. Wait, but that's not always possible. However, since the items are sorted by cost, perhaps taking as many as possible of the highest cost items is optimal.\n\nWait, for example, for weight 1 and 2 items. Suppose we have a certain capacity left. Let's say we can take some number of weight 1 and 2 items. How do we maximize the cost?\n\nThis seems like a classic unbounded knapsack problem, but since we can only take each item once (since each item is unique), it's 0-1 knapsack. However, with the items sorted, perhaps we can find an optimal way to choose between taking weight 1 and 2 items.\n\nBut again, with large n, doing this for each possible x (number of weight 3 items) may not be feasible.\n\nAlternative plan:\n\nSince the weight of each item is small (1, 2, 3), we can pre-process each group. For example, for weight 1 items, we sort them in descending order of cost and compute prefix sums. Similarly for weight 2 and 3.\n\nThen, for the problem, the maximum total cost can be found by considering all possible combinations of taking x items of weight 3, y items of weight 2, and z items of weight 1, such that 3x + 2y + z ≤ m.\n\nBut trying all possible x, y, z would be O(m^2) which is too slow.\n\nSo, perhaps we can fix x and y, and compute z. But even that would be O(m^2) in worst case.\n\nAnother approach: since the weight 3 items can be processed first, and for each possible x (number of weight 3 items taken), we can compute the remaining capacity, then solve for weight 1 and 2 items with that capacity.\n\nBut how to solve the",
    "response": "\n\nTo solve this problem, we need to determine the maximum possible total cost of souvenirs that Petya can carry given a weight constraint. Each souvenir has a weight of either 1, 2, or 3 and a corresponding cost. The challenge is to maximize the total cost while ensuring the total weight does not exceed the given capacity.\n\n### Approach\n1. **Group Items by Weight**: Separate the souvenirs into three groups based on their weights (1, 2, 3).\n2. **Sort and Compute Prefix Sums**: For each group, sort the items in descending order of cost and compute prefix sums to quickly determine the total cost for any number of items taken from that group.\n3. **Iterate Over Possible Counts**: For each possible count of weight 3 items, compute the remaining capacity and then determine the optimal combination of weight 1 and 2 items that can fit within the remaining capacity using a two-pointer technique.\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n    \n    w1 = []\n    w2 = []\n    w3 = []\n    \n    for _ in range(n):\n        wi = int(input[idx])\n        idx += 1\n        ci = int(input[idx])\n        idx += 1\n        if wi == 1:\n            w1.append(ci)\n        elif wi == 2:\n            w2.append(ci)\n        else:\n            w3.append(ci)\n    \n    # Sort each list in descending order\n    w1.sort(reverse=True)\n    w2.sort(reverse=True)\n    w3.sort(reverse=True)\n    \n    # Compute prefix sums\n    prefix1 = [0]\n    for c in w1:\n        prefix1.append(prefix1[-1] + c)\n    \n    prefix2 = [0]\n    for c in w2:\n        prefix2.append(prefix2[-1] + c)\n    \n    prefix3 = [0]\n    for c in w3:\n        prefix3.append(prefix3[-1] + c)\n    \n    max_total = 0\n    \n    # Iterate over possible number of weight 3 items\n    max_w3 = min(len(w3), m // 3)\n    for x in range(0, max_w3 + 1):\n        weight_used = x * 3\n        remaining = m - weight_used\n        # Now solve for weight 1 and 2 with remaining capacity\n        # Use two pointers approach\n        i = len(prefix2) - 1  # number of weight 2 items\n        j = len(prefix1) - 1  # number of weight 1 items\n        best = 0\n        while i >= 0 and j >= 0:\n            weight = 2 * i + j\n            if weight <= remaining:\n                best = max(best, prefix2[i] + prefix1[j])\n                j -= 1\n            else:\n                i -= 1\n        # Also check all possibilities where i is fixed and j is maxed\n        # Check for i from 0 to len(prefix2)-1\n        # Alternatively, after the above loop, check for all possible i and compute j\n        # But the two-pointer approach should already find the best\n        current_total = prefix3[x] + best\n        if current_total > max_total:\n            max_total = current_total\n    \n    print(max_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Grouping and Sorting**: The souvenirs are grouped by their weights and sorted in descending order of cost to prioritize higher-value items.\n2. **Prefix Sums**: Prefix sums for each group allow quick calculation of the total cost for taking the first `k` items from any group.\n3. **Iterating Over Weight 3 Items**: For each possible number of weight 3 items, the remaining capacity is calculated, and a two-pointer technique is used to find the optimal combination of weight 1 and 2 items that fit within the remaining capacity. This ensures an efficient solution without resorting to a full dynamic programming approach, which would be computationally infeasible given the constraints.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n    \n    w1 = []\n    w2 = []\n    w3 = []\n    \n    for _ in range(n):\n        wi = int(input[idx])\n        idx += 1\n        ci = int(input[idx])\n        idx += 1\n        if wi == 1:\n            w1.append(ci)\n        elif wi == 2:\n            w2.append(ci)\n        else:\n            w3.append(ci)\n    \n    # Sort each list in descending order\n    w1.sort(reverse=True)\n    w2.sort(reverse=True)\n    w3.sort(reverse=True)\n    \n    # Compute prefix sums\n    prefix1 = [0]\n    for c in w1:\n        prefix1.append(prefix1[-1] + c)\n    \n    prefix2 = [0]\n    for c in w2:\n        prefix2.append(prefix2[-1] + c)\n    \n    prefix3 = [0]\n    for c in w3:\n        prefix3.append(prefix3[-1] + c)\n    \n    max_total = 0\n    \n    # Iterate over possible number of weight 3 items\n    max_w3 = min(len(w3), m // 3)\n    for x in range(0, max_w3 + 1):\n        weight_used = x * 3\n        remaining = m - weight_used\n        # Now solve for weight 1 and 2 with remaining capacity\n        # Use two pointers approach\n        i = len(prefix2) - 1  # number of weight 2 items\n        j = len(prefix1) - 1  # number of weight 1 items\n        best = 0\n        while i >= 0 and j >= 0:\n            weight = 2 * i + j\n            if weight <= remaining:\n                best = max(best, prefix2[i] + prefix1[j])\n                j -= 1\n            else:\n                i -= 1\n        # Also check all possibilities where i is fixed and j is maxed\n        # Check for i from 0 to len(prefix2)-1\n        # Alternatively, after the above loop, check for all possible i and compute j\n        # But the two-pointer approach should already find the best\n        current_total = prefix3[x] + best\n        if current_total > max_total:\n            max_total = current_total\n    \n    print(max_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 473,
        "completion_token_count": 899,
        "thoughts_token_count": 1023
    }
}