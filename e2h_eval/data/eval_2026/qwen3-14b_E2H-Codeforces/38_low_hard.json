{
    "start": 1758309600.7821395,
    "end": 1758309775.210773,
    "start-formatted": "2025-09-20 04:20 KST",
    "end-formatted": "2025-09-20 04:22 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\nOkay, let's try to tackle this problem. Hmm. The problem is about finding the minimum number of nodes required to create a p-reachable directed graph and then determining the maximum number of unidirectional pairs in such graphs. Let's break it down.\n\nFirst, I need to understand what a p-reachable graph is. Oh right, it's a directed graph that has exactly p ordered pairs (u, v) where u < v and both are reachable from each other. Wait, so for each pair u < v, if they can reach each other, that contributes 1 to p. So the total count of such pairs is exactly p.\n\nThe first part of the problem is to find the minimal number of nodes needed. Then, among all such graphs with that minimal number of nodes, find the maximum number of unidirectional pairs. Unidirectional pairs are those where u != v, there's a path from u to v, but not vice versa.\n\nLet me think about how to model this. For the minimal number of nodes, perhaps we need to maximize the number of mutual reachable pairs (the ones contributing to p) with as few nodes as possible. But since p is given, we need to arrange the graph in a way that the number of mutual pairs is exactly p.\n\nWait, but how do we calculate the number of mutual pairs for a certain graph structure?\n\nLet me think about the structure of the graph. For example, if the graph is a DAG with a certain structure. But since reachability is involved, maybe considering strongly connected components (SCCs). Because in an SCC, all nodes are mutually reachable. So any two distinct nodes in the same SCC contribute 1 to p if u < v. But if two nodes are in different SCCs, their reachability depends on the direction between the components.\n\nBut perhaps the optimal way to maximize the number of mutual pairs (for a given number of nodes) is to have a single strongly connected component. Because in that case, all pairs u < v contribute to p. For example, with n nodes in a single SCC, the number of mutual pairs is C(n, 2) = n*(n-1)/2. However, if the graph is not strongly connected, then some pairs might not be mutual.\n\nBut for the first part of the problem, we need to find the minimal n such that there exists a graph with exactly p mutual pairs. So the minimal n would be determined by finding the smallest n where C(n, 2) >= p. Wait, but maybe there's a way to have a graph with fewer nodes by combining components. Wait, no. Because if you have multiple components, then the mutual pairs are only within each component. For example, if you have two components, one with k nodes and another with m nodes, then the total mutual pairs would be C(k, 2) + C(m, 2). Which is less than C(k + m, 2). So if we want to reach exactly p, the minimal n is achieved when the graph is a single strongly connected component. Because that way, the number of mutual pairs is maximized for a given n. So if we can find the minimal n such that C(n, 2) >= p, then that's the minimal number of nodes required. Wait, but what if p is not exactly C(n, 2)? For example, suppose p is 3. Then C(3,2)=3, which is exactly p. So the minimal n is 3. If p is 4, then C(3,2)=3 <4, so n=4, since C(4,2)=6. But wait, maybe there's a way to have a graph with n=4 nodes but with exactly 4 mutual pairs. Like, maybe having a single component with 4 nodes, but some edges missing. But that would reduce the number of mutual pairs. However, the problem requires that the graph has exactly p mutual pairs. So if p is 4, then perhaps the minimal n is 4. Because with n=4, you can have a graph where exactly 4 pairs are mutual. But how?\n\nWait, but if you have a graph that's not a complete strongly connected component. For example, maybe a DAG with some components. But then the mutual pairs would be within each component. So perhaps to get exactly p, the minimal n is determined by the minimal n where C(n, 2) >= p, and then adjust the graph to have exactly p mutual pairs. But how?\n\nAlternatively, maybe the minimal number of nodes is determined by the minimal n such that C(n, 2) >= p. Because if you have a single component, you can have exactly C(n, 2) mutual pairs. But if p is less than that, then perhaps you can't have a smaller n. Because for example, if p is 4, then n=4 gives C(4, 2)=6.",
    "response": "To solve this problem, we need to determine the minimum number of nodes required to create a p-reachable directed graph and then find the maximum number of unidirectional pairs in such graphs. \n\n### Approach\n\n1. **Understanding p-Reachable Graphs**: A p-reachable graph has exactly `p` ordered pairs (u, v) such that `u < v` and both are mutually reachable. The goal is to find the minimal number of nodes required to achieve this.\n\n2. **Minimum Number of Nodes**: The number of mutual reachable pairs in a complete strongly connected component of `n` nodes is given by the combination formula `C(n, 2) = n * (n - 1) / 2`. We need to find the smallest `n` such that `C(n, 2) >= p`.\n\n3. **Maximum Unidirectional Pairs**: Once the minimum number of nodes `n` is determined, we calculate the maximum number of unidirectional pairs. This is derived from the total possible ordered pairs minus the mutual pairs and the self-pairs (where u = v).\n\n### Solution Code\n\n```python\nimport sys\nimport math\n\ndef main():\n    p = int(sys.stdin.readline())\n    if p == 0:\n        print(\"0 0\")\n        return\n    \n    # Find the minimal number of nodes n such that C(n, 2) >= p\n    n = 1\n    while n * (n - 1) // 2 < p:\n        n += 1\n    \n    # Now, compute the maximum number of unidirectional pairs\n    total_pairs = n * (n - 1)\n    mutual_pairs = n * (n - 1) // 2\n    # The number of unidirectional pairs is total_pairs - 2 * mutual_pairs\n    # Because each mutual pair contributes two ordered pairs (u,v) and (v,u), but we only count (u,v) where u < v\n    # Wait, the problem defines unidirectional pairs as (u, v) where u != v, there's a path from u to v, but not vice versa.\n    # So for all ordered pairs (u, v) with u != v, subtract those that are mutual.\n    # Total ordered pairs (u != v) is n*(n-1). From this, subtract the mutual pairs (each mutual pair is counted once in the p).\n    # But wait, in the p-reachable graph, we have exactly p mutual pairs (u < v). For each such pair, there's also (v, u) which is not considered in p but is a mutual pair.\n    # However, the problem says that for the p-reachable graph, exactly p ordered pairs (u, v) with u < v are mutual. So for the total number of mutual ordered pairs (both directions), it's 2*p.\n    # Therefore, the number of unidirectional pairs is total_ordered_pairs - 2*p.\n    \n    total_ordered = n * (n - 1)\n    unidirectional = total_ordered - 2 * p\n    \n    print(f\"{n} {unidirectional}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n\n1. **Finding Minimum Nodes**: We start with `n = 1` and incrementally check the combination value `C(n, 2)` until it is at least `p`. This gives us the minimum number of nodes required.\n\n2. **Calculating Unidirectional Pairs**: The total number of ordered pairs (u, v) where `u != v` is `n * (n - 1)`. From this, we subtract twice the number of mutual pairs (since each mutual pair contributes two ordered pairs: (u, v) and (v, u)). The result is the maximum number of unidirectional pairs possible in the graph.\n\nThis approach efficiently determines the required values using mathematical properties of combinations and ordered pairs, ensuring optimal performance even for large values of `p`.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\n\ndef main():\n    p = int(sys.stdin.readline())\n    if p == 0:\n        print(\"0 0\")\n        return\n    \n    # Find the minimal number of nodes n such that C(n, 2) >= p\n    n = 1\n    while n * (n - 1) // 2 < p:\n        n += 1\n    \n    # Now, compute the maximum number of unidirectional pairs\n    total_pairs = n * (n - 1)\n    mutual_pairs = n * (n - 1) // 2\n    # The number of unidirectional pairs is total_pairs - 2 * mutual_pairs\n    # Because each mutual pair contributes two ordered pairs (u,v) and (v,u), but we only count (u,v) where u < v\n    # Wait, the problem defines unidirectional pairs as (u, v) where u != v, there's a path from u to v, but not vice versa.\n    # So for all ordered pairs (u, v) with u != v, subtract those that are mutual.\n    # Total ordered pairs (u != v) is n*(n-1). From this, subtract the mutual pairs (each mutual pair is counted once in the p).\n    # But wait, in the p-reachable graph, we have exactly p mutual pairs (u < v). For each such pair, there's also (v, u) which is not considered in p but is a mutual pair.\n    # However, the problem says that for the p-reachable graph, exactly p ordered pairs (u, v) with u < v are mutual. So for the total number of mutual ordered pairs (both directions), it's 2*p.\n    # Therefore, the number of unidirectional pairs is total_ordered_pairs - 2*p.\n    \n    total_ordered = n * (n - 1)\n    unidirectional = total_ordered - 2 * p\n    \n    print(f\"{n} {unidirectional}\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 480,
        "completion_token_count": 837,
        "thoughts_token_count": 1024
    }
}