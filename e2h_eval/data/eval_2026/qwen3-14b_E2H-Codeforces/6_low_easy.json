{
    "start": 1758008325.8747206,
    "end": 1758008507.0828931,
    "start-formatted": "2025-09-16 16:38 KST",
    "end-formatted": "2025-09-16 16:41 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\nOkay, let's tackle this problem. So, the task is to find two non-overlapping vouchers whose total duration equals exactly x, and their combined cost is minimized. If there's no such pair, return -1.\n\nFirst, I need to understand the problem thoroughly. Let's break down the requirements:\n\nEach voucher has a departure day (li), return day (ri), and cost. The duration is ri - li + 1. We need two vouchers i and j (i≠j) such that their durations add up to x. Also, they must not overlap. Non-overlapping means either the first ends before the second starts (ri < lj) or the second ends before the first starts (rj < li).\n\nThe challenge is to find such pairs efficiently given the constraints of n up to 2e5. A brute-force approach checking all pairs would be O(n²), which is definitely not feasible for n=2e5. So we need an efficient way.\n\nLet me think about how to approach this. For each voucher, we can check if there exists another voucher that doesn't overlap with it and has a duration of (x - duration of current voucher). But how do we find that efficiently?\n\nLet me think about pre-processing. Suppose for each possible duration d, we have a list of vouchers with that duration. Then, for each voucher with duration d, we need to find a voucher with duration (x - d) that does not overlap with it.\n\nBut even that might be tricky. Because for each voucher, we need to check for vouchers of a certain duration that are either before it or after it.\n\nAnother idea: For each voucher, we can consider two cases:\n\nCase 1: The first voucher ends before the second starts. So, for voucher i, we look for vouchers j where duration_j = x - duration_i, and lj > ri. Similarly, Case 2: voucher j ends before voucher i starts. So, for voucher i, look for vouchers j with duration_j = x - duration_i, and rj < li.\n\nBut how to find these efficiently?\n\nMaybe we can preprocess for each duration d, the minimum cost of vouchers that end before a certain day, and the minimum cost of vouchers that start after a certain day.\n\nWait, here's a plan:\n\nFor each voucher i:\n\n- Compute d_i = ri - li + 1.\n\n- Check if there exists a voucher j with duration (x - d_i). Let's call this target_duration = x - d_i.\n\nIf target_duration is negative, skip. Also, if x - d_i is not possible (like if x is less than 2, but according to input constraints, x is at least 2?), no. Wait, the input says x can be as low as 2? Well, in the problem statement, x is given as the duration of the vacation, and Leha wants to split into two parts. So the sum of durations of the two vouchers must be exactly x. So for each voucher i, the target duration is x - d_i. So if x - d_i is less than 1, then it's impossible. So for each voucher, we first check if x - d_i >= 1. Otherwise, skip.\n\nSo for each voucher, we need to check for vouchers with duration equal to target_duration, and that don't overlap with it.\n\nNow, how to find the minimal cost for vouchers with target_duration that end before li (so that they can be before voucher i) or start after ri (so that they can be after voucher i).\n\nSo for each possible duration, we can pre-process two structures:\n\n- For duration d, a sorted list of the starting days (or ending days) of vouchers, along with their costs. But maybe we can track for each duration d, the minimum cost of vouchers that end before a certain day, and the minimum cost of vouchers that start after a certain day.\n\nAlternatively, for each duration d, we can have two arrays:\n\n- One sorted by end time (ri) and for each end time, track the minimum cost up to that point. This way, for a given voucher i, if we want to find a voucher with duration d that ends before li, we can binary search in the sorted list of end times for duration d to find the earliest end time <= li-1, and get the minimum cost up to that point.\n\nSimilarly, for vouchers with duration d, sorted by start time (li), and for each start time, track the minimum cost from that point onward. So for a voucher i, if we want a voucher that starts after ri, we can find the earliest start time >= ri+1 and get the minimum cost from that point.\n\nWait, but how to pre-process this? Let's think:\n\nFor each duration d, we can collect all vouchers of that duration. Then, for those vouchers, we can sort them by their end time (ri), and compute a prefix minimum array. So for any",
    "response": "\n\nTo solve this problem, we need to find two non-overlapping vouchers whose combined duration exactly matches a given value `x` and whose total cost is minimized. If no such pair exists, we should return -1.\n\n### Approach\n1. **Preprocessing by Duration**: Group vouchers by their duration. This allows us to efficiently check for possible pairs of vouchers that can sum up to the required duration `x`.\n2. **Binary Search for Efficient Lookup**: For each voucher, determine if there exists another voucher with the complementary duration (i.e., `x - duration`) that does not overlap with it. Use binary search to efficiently find the minimum cost of such vouchers.\n3. **Prefix and Suffix Minimum Arrays**: For each duration, maintain sorted lists of start and end times along with prefix and suffix minimum cost arrays to quickly determine the minimum cost of non-overlapping vouchers.\n\n### Solution Code\n```python\nimport sys\nimport bisect\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n    \n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        vouchers.append((l, r, cost))\n    \n    from collections import defaultdict\n\n    # Preprocess: group vouchers by their duration\n    duration_dict = defaultdict(list)\n    for l, r, cost in vouchers:\n        d = r - l + 1\n        duration_dict[d].append((l, r, cost))\n    \n    # For each duration, sort by end time and create prefix min cost array\n    # Also sort by start time and create suffix min cost array\n    duration_info = dict()\n    for d in duration_dict:\n        lst = duration_dict[d]\n        # Sort by end time\n        sorted_by_end = sorted(lst, key=lambda x: x[1])\n        # Create prefix min cost array\n        prefix_min = []\n        min_cost = float('inf')\n        for l, r, cost in sorted_by_end:\n            if cost < min_cost:\n                min_cost = cost\n            prefix_min.append(min_cost)\n        # Sort by start time\n        sorted_by_start = sorted(lst, key=lambda x: x[0])\n        # Create suffix min cost array\n        suffix_min = [0] * len(sorted_by_start)\n        min_cost = float('inf')\n        for i in reversed(range(len(sorted_by_start))):\n            l, r, cost = sorted_by_start[i]\n            if cost < min_cost:\n                min_cost = cost\n            suffix_min[i] = min_cost\n        duration_info[d] = (sorted_by_end, prefix_min, sorted_by_start, suffix_min)\n    \n    min_total = float('inf')\n    \n    for l1, r1, cost1 in vouchers:\n        d1 = r1 - l1 + 1\n        target_d = x - d1\n        if target_d < 1:\n            continue\n        if target_d not in duration_info:\n            continue\n        \n        # Check for vouchers with target_d that end before l1\n        sorted_by_end, prefix_min, _, _ = duration_info[target_d]\n        # Find the largest end <= l1 - 1\n        ends = [item[1] for item in sorted_by_end]\n        pos = bisect.bisect_right(ends, l1 - 1) - 1\n        if pos >= 0:\n            current_min = prefix_min[pos]\n            min_total = min(min_total, cost1 + current_min)\n        \n        # Check for vouchers with target_d that start after r1\n        _, _, sorted_by_start, suffix_min = duration_info[target_d]\n        starts = [item[0] for item in sorted_by_start]\n        pos = bisect.bisect_left(starts, r1 + 1)\n        if pos < len(starts):\n            current_min = suffix_min[pos]\n            min_total = min(min_total, cost1 + current_min)\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into a list of vouchers.\n2. **Grouping by Duration**: Vouchers are grouped by their duration to facilitate efficient lookups.\n3. **Prefix and Suffix Arrays**: For each duration, we maintain sorted lists of vouchers by their end and start times, along with prefix and suffix minimum cost arrays to quickly determine the minimum cost of non-overlapping vouchers.\n4. **Binary Search**: For each voucher, we use binary search to find the minimum cost of vouchers with the complementary duration that either end before the current voucher starts or start after the current voucher ends.\n5. **Result Calculation**: The minimum total cost from all valid pairs is computed and printed, or -1 if no valid pairs exist.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport bisect\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n    \n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        vouchers.append((l, r, cost))\n    \n    from collections import defaultdict\n\n    # Preprocess: group vouchers by their duration\n    duration_dict = defaultdict(list)\n    for l, r, cost in vouchers:\n        d = r - l + 1\n        duration_dict[d].append((l, r, cost))\n    \n    # For each duration, sort by end time and create prefix min cost array\n    # Also sort by start time and create suffix min cost array\n    duration_info = dict()\n    for d in duration_dict:\n        lst = duration_dict[d]\n        # Sort by end time\n        sorted_by_end = sorted(lst, key=lambda x: x[1])\n        # Create prefix min cost array\n        prefix_min = []\n        min_cost = float('inf')\n        for l, r, cost in sorted_by_end:\n            if cost < min_cost:\n                min_cost = cost\n            prefix_min.append(min_cost)\n        # Sort by start time\n        sorted_by_start = sorted(lst, key=lambda x: x[0])\n        # Create suffix min cost array\n        suffix_min = [0] * len(sorted_by_start)\n        min_cost = float('inf')\n        for i in reversed(range(len(sorted_by_start))):\n            l, r, cost = sorted_by_start[i]\n            if cost < min_cost:\n                min_cost = cost\n            suffix_min[i] = min_cost\n        duration_info[d] = (sorted_by_end, prefix_min, sorted_by_start, suffix_min)\n    \n    min_total = float('inf')\n    \n    for l1, r1, cost1 in vouchers:\n        d1 = r1 - l1 + 1\n        target_d = x - d1\n        if target_d < 1:\n            continue\n        if target_d not in duration_info:\n            continue\n        \n        # Check for vouchers with target_d that end before l1\n        sorted_by_end, prefix_min, _, _ = duration_info[target_d]\n        # Find the largest end <= l1 - 1\n        ends = [item[1] for item in sorted_by_end]\n        pos = bisect.bisect_right(ends, l1 - 1) - 1\n        if pos >= 0:\n            current_min = prefix_min[pos]\n            min_total = min(min_total, cost1 + current_min)\n        \n        # Check for vouchers with target_d that start after r1\n        _, _, sorted_by_start, suffix_min = duration_info[target_d]\n        starts = [item[0] for item in sorted_by_start]\n        pos = bisect.bisect_left(starts, r1 + 1)\n        if pos < len(starts):\n            current_min = suffix_min[pos]\n            min_total = min(min_total, cost1 + current_min)\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 739,
        "completion_token_count": 1065,
        "thoughts_token_count": 1023
    }
}