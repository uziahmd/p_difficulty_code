{
    "start": 1758313549.0083861,
    "end": 1758313599.2385657,
    "start-formatted": "2025-09-20 05:25 KST",
    "end-formatted": "2025-09-20 05:26 KST",
    "gpu": 2,
    "pid": 6,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\nOkay, let's see. I need to solve this programming problem. Let me read the problem carefully again.\n\nSo, the problem is about Leha wanting to choose two vouchers such that their durations add up exactly to x days, and they don't overlap. And we need to find the minimal total cost of such a pair. If it's not possible, output -1.\n\nFirst, let's understand the input. Each voucher has li (departure day), ri (return day), and cost. The duration is ri - li + 1. The two vouchers must not intersect. That means either the first ends before the second starts, or the second ends before the first starts.\n\nThe approach here is to find pairs of vouchers where the sum of their durations is exactly x, and they are non-overlapping. Then among all such pairs, find the one with the minimum total cost.\n\nBut how do I do this efficiently? Because n can be up to 2e5, which is 200,000. A brute force approach of checking all pairs would be O(n²), which is way too slow for n=2e5. So we need a smarter way.\n\nLet me think. For each voucher, let's say its duration is d. Then we need another voucher with duration x - d. So for each voucher, we can look for vouchers of duration (x - d) that end before the current voucher starts, or start after the current voucher ends.\n\nBut how to efficiently find the minimum cost for those vouchers?\n\nMaybe we can pre-process vouchers by their duration. For example, group vouchers by their duration. Then, for each voucher with duration d, we check if there exists vouchers with duration (x - d). For each such voucher, we need to find the minimum cost of vouchers that are non-overlapping with it.\n\nBut even that, how do we find the min cost for vouchers of a certain duration that are non-overlapping?\n\nLet me think. Suppose I have a voucher A with duration d. I need to find vouchers B with duration (x - d) such that B ends before A starts, or starts after A ends.\n\nSo for each voucher A, we can:\n\n- Check if there exists vouchers of duration (x - d). Let's call this target duration t = x - d.\n\nIf t is negative, then skip. Also, if t is zero, but since duration is ri - li +1, which is at least 1, so x must be at least 2? Well, the problem says x can be as low as 2 (since n >=2 and x is given as per input). Wait, the input constraints say x can be between 2 and 2e5. Wait, no. The input says x can be as low as 2? Let me check the input description. The first line has n and x, with 2 ≤ n, x ≤ 2e5. So x can be 2, but for example, if x is 2, then each voucher must have duration 1 and 1. So for each voucher of duration 1, we need to find another voucher of duration 1 that doesn't overlap.\n\nSo back to the plan. For each voucher A, with duration d, check if x - d is a valid duration (i.e., t ≥ 1). Then, for all vouchers B with duration t, check if they are non-overlapping with A. Then, find the minimum cost among those B's.\n\nBut how to find the minimum cost of B's that are non-overlapping with A?\n\nThis seems challenging. Let's think about the two cases for non-overlapping:\n\nCase 1: B ends before A starts. So B's ri < A's li.\n\nCase 2: B starts after A ends. So B's li > A's ri.\n\nSo for each voucher A, we need to find the minimum cost in vouchers of duration t that satisfy either case 1 or case 2.\n\nBut how to query that quickly?\n\nLet me think about preprocessing. Suppose for each duration t, we have sorted lists of vouchers with that duration, sorted by their ri (for case 1) and sorted by li (for case 2). Or maybe for each duration t, we can have two structures:\n\n- A sorted list of vouchers' ri (so that we can find the earliest ones that end before a certain li).\n\n- A sorted list of vouchers' li (so that we can find the earliest ones that start after a certain ri).\n\nWait, but for case 1, we need vouchers B where B.ri < A.li. So for vouchers of duration t, we can find the minimum cost among those with ri < A.li. Similarly for case 2, find the minimum cost among those with li > A.ri.\n\nBut how to do that efficiently?\n\nFor each duration t, if we have all vouchers with that duration sorted by their ri, and also have a prefix minimum array",
    "response": "To solve this problem, we need to find two non-overlapping vouchers whose combined duration exactly matches a given number of days, `x`, while minimizing the total cost. The solution involves efficiently checking for valid voucher pairs using preprocessing and binary search.\n\n### Approach\n1. **Group Vouchers by Duration**: First, we group all vouchers by their duration. This allows us to quickly access vouchers of a specific duration when needed.\n2. **Sort and Preprocess**: For each duration, we maintain two sorted lists:\n   - One sorted by the end date (`ri`) to help find vouchers that end before another voucher starts.\n   - Another sorted by the start date (`li`) to help find vouchers that start after another voucher ends.\n3. **Binary Search for Efficient Lookup**: For each voucher, we check if there exists another voucher with a complementary duration such that their combined duration equals `x`. Using binary search, we efficiently find the minimum cost of valid non-overlapping vouchers.\n\n### Solution Code\n```python\nimport bisect\nimport sys\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n    \n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n    \n    from collections import defaultdict\n    duration_map = defaultdict(list)\n    for l, r, cost, d in vouchers:\n        duration_map[d].append((l, r, cost))\n    \n    # For each duration, sort by ri and li, and also create prefix min arrays\n    # Also, for each duration, we'll have two sorted lists:\n    # one sorted by ri (for case where B ends before A starts)\n    # and one sorted by li (for case where B starts after A ends)\n    # Also, for each list, we'll have a prefix min cost array\n    # So for each duration t, we'll have:\n    # sorted_ri: list of (ri, cost) sorted by ri\n    # sorted_li: list of (li, cost) sorted by li\n    # and corresponding prefix min arrays for each\n    \n    duration_info = dict()\n    for d in duration_map:\n        lst = duration_map[d]\n        # Sort by ri\n        sorted_ri = sorted(lst, key=lambda x: x[1])\n        # Sort by li\n        sorted_li = sorted(lst, key=lambda x: x[0])\n        # Prepare prefix min for sorted_ri (based on ri)\n        prefix_min_ri = []\n        min_cost = float('inf')\n        for item in sorted_ri:\n            min_cost = min(min_cost, item[2])\n            prefix_min_ri.append(min_cost)\n        # Prepare prefix min for sorted_li (based on li)\n        prefix_min_li = []\n        min_cost = float('inf')\n        for item in sorted_li:\n            min_cost = min(min_cost, item[2])\n            prefix_min_li.append(min_cost)\n        duration_info[d] = (sorted_ri, prefix_min_ri, sorted_li, prefix_min_li)\n    \n    min_total = float('inf')\n    \n    for l_a, r_a, cost_a, d_a in vouchers:\n        t = x - d_a\n        if t < 1:\n            continue\n        if t not in duration_info:\n            continue\n        \n        # Get the info for duration t\n        sorted_ri, prefix_min_ri, sorted_li, prefix_min_li = duration_info[t]\n        \n        # Case 1: B ends before A starts (B.ri < l_a)\n        # Find the largest ri in sorted_ri that is < l_a\n        # Use bisect to find the insertion point\n        idx_ri = bisect.bisect_left(sorted_ri, (0, l_a, 0)) - 1\n        if idx_ri >= 0:\n            current_min = prefix_min_ri[idx_ri]\n            min_total = min(min_total, current_min + cost_a)\n        \n        # Case 2: B starts after A ends (B.li > r_a)\n        # Find the first li in sorted_li that is > r_a\n        # Use bisect to find the insertion point\n        idx_li = bisect.bisect_right(sorted_li, (r_a, float('inf'), 0))\n        if idx_li < len(prefix_min_li):\n            current_min = prefix_min_li[idx_li]\n            min_total = min(min_total, current_min + cost_a)\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Grouping by Duration**: Vouchers are grouped by their duration to quickly access those with specific durations.\n- **Sorting and Prefix Minimum Arrays**: For each duration, vouchers are sorted by their end date and start date. Prefix minimum arrays are used to quickly find the minimum cost up to any point in these sorted lists.\n- **Binary Search**: For each voucher, we use binary search to efficiently determine valid non-overlapping vouchers with the required complementary duration, ensuring the solution runs efficiently even for large inputs.",
    "ground_truth": "N/A",
    "extracted_answer": "import bisect\nimport sys\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n    \n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n    \n    from collections import defaultdict\n    duration_map = defaultdict(list)\n    for l, r, cost, d in vouchers:\n        duration_map[d].append((l, r, cost))\n    \n    # For each duration, sort by ri and li, and also create prefix min arrays\n    # Also, for each duration, we'll have two sorted lists:\n    # one sorted by ri (for case where B ends before A starts)\n    # and one sorted by li (for case where B starts after A ends)\n    # Also, for each list, we'll have a prefix min cost array\n    # So for each duration t, we'll have:\n    # sorted_ri: list of (ri, cost) sorted by ri\n    # sorted_li: list of (li, cost) sorted by li\n    # and corresponding prefix min arrays for each\n    \n    duration_info = dict()\n    for d in duration_map:\n        lst = duration_map[d]\n        # Sort by ri\n        sorted_ri = sorted(lst, key=lambda x: x[1])\n        # Sort by li\n        sorted_li = sorted(lst, key=lambda x: x[0])\n        # Prepare prefix min for sorted_ri (based on ri)\n        prefix_min_ri = []\n        min_cost = float('inf')\n        for item in sorted_ri:\n            min_cost = min(min_cost, item[2])\n            prefix_min_ri.append(min_cost)\n        # Prepare prefix min for sorted_li (based on li)\n        prefix_min_li = []\n        min_cost = float('inf')\n        for item in sorted_li:\n            min_cost = min(min_cost, item[2])\n            prefix_min_li.append(min_cost)\n        duration_info[d] = (sorted_ri, prefix_min_ri, sorted_li, prefix_min_li)\n    \n    min_total = float('inf')\n    \n    for l_a, r_a, cost_a, d_a in vouchers:\n        t = x - d_a\n        if t < 1:\n            continue\n        if t not in duration_info:\n            continue\n        \n        # Get the info for duration t\n        sorted_ri, prefix_min_ri, sorted_li, prefix_min_li = duration_info[t]\n        \n        # Case 1: B ends before A starts (B.ri < l_a)\n        # Find the largest ri in sorted_ri that is < l_a\n        # Use bisect to find the insertion point\n        idx_ri = bisect.bisect_left(sorted_ri, (0, l_a, 0)) - 1\n        if idx_ri >= 0:\n            current_min = prefix_min_ri[idx_ri]\n            min_total = min(min_total, current_min + cost_a)\n        \n        # Case 2: B starts after A ends (B.li > r_a)\n        # Find the first li in sorted_li that is > r_a\n        # Use bisect to find the insertion point\n        idx_li = bisect.bisect_right(sorted_li, (r_a, float('inf'), 0))\n        if idx_li < len(prefix_min_li):\n            current_min = prefix_min_li[idx_li]\n            min_total = min(min_total, current_min + cost_a)\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 740,
        "completion_token_count": 1144,
        "thoughts_token_count": 1024
    }
}