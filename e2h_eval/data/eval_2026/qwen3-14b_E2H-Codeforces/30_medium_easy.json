{
    "start": 1758309097.4082253,
    "end": 1758309279.488608,
    "start-formatted": "2025-09-20 04:11 KST",
    "end-formatted": "2025-09-20 04:14 KST",
    "gpu": 2,
    "pid": 30,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# TV Game\n\nThere is a new TV game on BerTV. In this game two players get a number A consisting of 2n digits. Before each turn players determine who will make the next move. Each player should make exactly n moves. On it's turn i-th player takes the leftmost digit of A and appends it to his or her number Si. After that this leftmost digit is erased from A. Initially the numbers of both players (S1 and S2) are «empty». Leading zeroes in numbers A, S1, S2 are allowed. In the end of the game the first player gets S1 dollars, and the second gets S2 dollars.One day Homer and Marge came to play the game. They managed to know the number A beforehand. They want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize. Help them.\n\n## Input\nThe first line contains integer n (1 ≤ n ≤ 18). The second line contains integer A consisting of exactly 2n digits. This number can have leading zeroes.\n\n## Output\nOutput the line of 2n characters «H» and «M» — the sequence of moves of Homer and Marge, which gives them maximum possible total prize. Each player must make exactly n moves. If there are several solutions, output any of them.\n\n## Example\n### Input\n['2\\n1234', '2\\n9911']\n\n### Output\n['HHMM', 'HMHM']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\nOkay, let's see. The problem is about Homer and Marge playing a game where they take digits from a number A. Each takes turns, and each makes exactly n moves. The goal is to maximize the total sum of their numbers S1 and S2. We need to find the sequence of H and M moves that gives this maximum total.\n\nHmm. So the key here is to choose, at each step, whether Homer or Marge takes the next digit, such that the total sum is maximized. But since both players are taking digits, and each has to take exactly n digits, we need to make sure that in the end, each has exactly n digits.\n\nWait, but how do we model this? Because the choice at each step depends on future choices. For example, if we have a choice between taking a digit now for Homer or Marge, which one leads to a better total sum?\n\nBut since n can be up to 18, the total number of steps is 2n = 36. So for a recursive approach with memoization, maybe it's feasible? Let's think about the state space. The state would be the current position in the string A (how many digits have been taken so far), and how many moves Homer has made so far (since Marge's moves are determined as (current step) - Homer's moves). Wait, because each move is either H or M. So for a given step k (from 0 to 2n-1), the number of H's chosen so far is some value, and the number of M's is also determined. So the state can be represented by the number of H's taken so far and the current position in the string.\n\nWait, for example, suppose we have taken k digits already. Then, the number of H's taken so far could be h. Then, the number of M's is k - h. But since each player must take exactly n moves, the total number of H's in the entire sequence must be n, and same for M's. So during the selection process, we need to ensure that at any step, the number of H's chosen so far doesn't exceed n, and similarly for M's.\n\nSo the state can be represented by two parameters: the current position in the string (i.e., how many digits have been taken so far), and the number of H's chosen so far. Because once we know those two, the number of M's is known (equal to the current position minus the number of H's). Also, the remaining digits are known based on the current position. For example, if we have taken i digits so far, then there are 2n - i digits left.\n\nSo for dynamic programming, the state is (i, h), where i is the number of digits taken so far (ranging from 0 to 2n), and h is the number of H's chosen so far (ranging from 0 to n). The maximum possible value of i is 2n, but since each step increases i by 1, we can model this.\n\nAt each state (i, h), we can decide whether to take an H or an M. But we have to ensure that after taking, the counts don't exceed n. For example, if we are at state (i, h), then:\n\n- If we choose H, then the next state is (i+1, h+1). But h+1 must be <=n.\n- If we choose M, then the next state is (i+1, h). But since the total number of M's is (i+1) - h, and since M's total must be n, then (i+1) - h <=n. Which implies that h >= (i+1) -n. But perhaps that's handled automatically during the transitions.\n\nThe DP function would return the maximum total sum possible from this state onwards. Then, for each state, we can compute the best choice between H and M.\n\nBut how do we calculate the contribution of each choice? When choosing H or M, the digit taken is the current leftmost digit of A. Wait, the digits are taken in order. So the first digit taken is the first digit of A, then the second, etc. So the current position in the string is i digits taken, so the next digit to take is the (i)th index (assuming zero-based or one-based? Well, let's think. For example, when i=0, no digits have been taken. So the next digit is the first one (index 0 in the string). So the digit to take is A[i], and after taking it, the next state is i+1.\n\nSo for the DP, the state (i, h) represents that we have taken i digits so far, and h of them are H's. Then, the next digit to take is the i-th digit (assuming the string is zero-based).\n\nNow, when choosing to take H, the digit is added to Homer's number. Similarly for M. But how do we compute the value of this choice? Well, the value is the digit multiplied by 10^{remaining digits} (since the digits are added to the front, but wait, no. Wait, when you take a digit, it's added to the front of the player's number. Wait, no. Let me re-read the problem statement.\n\nOn each turn, the i-th player takes the leftmost digit of A and appends it to his or her number S_i. Then this digit is erased from A. So the digits are taken in order. For example, if the original number is 1234, then the first move takes 1, then the next move takes 2, etc. But each time, the player adds the digit to their number. So the first digit taken becomes the first digit of their number, and subsequent digits are added to the end. So for example, if Homer takes first digit 1, then takes the third digit 3, his number would be 13.\n\nSo the value of S1 is the digits taken in the order of their selection, concatenated. So the first digit taken is the most significant digit, and the last taken is the least. So the value of S1 is sum_{k=0}^{n-1} (digit_k * 10^{n-1 -k} ), where digit_k is the k-th digit taken by Homer. Similarly for S2.\n\nBut calculating the actual value for each possible choice might be computationally expensive. However, since the problem requires us to maximize the total sum of S1 and S2, perhaps we can model the DP not just with the maximum total sum, but also track how much each choice contributes to the total.\n\nBut for the DP approach, when considering choosing H or M at a certain step, the contribution of that digit is determined by its position in the player's number. For example, if Homer takes a digit now, then that digit will be the first digit of his number (if he hasn't taken any before), or the second, etc. So the position of the digit in the player's number depends on how many times the player has taken digits before.\n\nWait, but in the DP state, we know how many H's have been taken so far (h). So if we choose H now, then the current digit will be the (h+1)-th digit in Homer's number. Since the length of Homer's number is n, the place value of this digit is 10^{n - (h+1)}.\n\nSimilarly, for Marge. If the current state is (i, h), and we choose M, then the number of M's taken so far is (i - h). Choosing M now would make this digit the (i - h + 1)-th digit in Marge's number. So the place value is 10^{n - (i - h + 1)}.\n\nSo for each decision, the contribution to the total sum is the digit multiplied by the appropriate power of 10 for the respective player.\n\nBut how do we compute this in the DP? Let's think. The DP function for state (i, h) returns the maximum total sum possible from this state onwards. So, when making a choice (H or M), we can compute the immediate contribution of that choice plus the best possible contribution from the remaining steps.\n\nSo for example, if we are at state (i, h), and the current digit is d = A[i], then:\n\nIf we choose H, then the contribution is d * 10^{n - (h + 1)} (since after taking this, Homer has h+1 digits, and this is the (h+1)-th digit, which is the most significant digit for his number. Wait, no. Wait, for example, if Homer takes his first digit (h=0), then this is the first digit of his number, which is multiplied by 10^{n-1} (since the number has n digits). Then, when he takes his second digit, it's multiplied by 10^{n-2}, etc. So for the (k)-th digit taken by Homer, the multiplier is 10^{n - k}.\n\nSo if the current choice is H, then the number of digits Homer has already taken is h. After taking this digit, it's h+1. So the multiplier is 10^{n - (h+1)}. Similarly for Marge.\n\nSo, for the current choice of H, the contribution is d * 10^{n - (h+1)} plus the result of the DP for the next state (i+1, h+1). Similarly for choosing M, the contribution is d * 10^{n - (m + 1)}, where m is the number of digits Marge has taken before this step. Since m is equal to (i - h) (because i is the total digits taken so far, and h is the count for Homer). So m = i - h. After choosing M, m becomes (i - h) + 1. So the multiplier is 10^{n - ((i - h) + 1)}.\n\nTherefore, the DP transition can be written as follows:\n\ndp(i, h) = max(\n    (d * 10^{n - (h+1)} ) + dp(i+1, h+1),\n    (d * 10^{n - ( (i - h) + 1 ) }) + dp(i+1, h)\n)\n\nBut we need to check if the choices are valid. For example, choosing H is only allowed if h+1 <=n. Similarly, choosing M is allowed only if (i - h) + 1 <=n. Because Marge must take exactly n digits.\n\nSo for the state (i, h), the number of M's taken so far is (i - h). So when choosing M, the new count is (i - h) + 1, which must be <=n. So (i - h) + 1 <=n => i - h <= n -1. Which is equivalent to h >= i - (n-1). But how do we check that in the transitions?\n\nBut during the DP transitions, for each state (i, h), when considering choosing H or M, we need to check if that choice is possible.\n\nSo for the initial state, i=0, h=0. The first choice can be H or M, provided that after choosing, the counts don't exceed n. For example, choosing H would make h=1, which is allowed as long as n >=1 (which it is, since n>=1). Similarly for M.\n\nSo the base case for the DP is when i=2n. Then, there are no more digits to take. So the total contribution is 0.\n\nNow, the problem is that for n up to 18, the number of states is (2n +1) * (n+1). For n=18, 2n is 36, so 37 * 19 = 703 states. That's manageable. And for each state, we have to compute two possibilities (H and M), so the total number of operations is manageable.\n\nBut what about the powers of 10? For n=18, the maximum exponent is 18-1=17, so 10^17. But when multiplied by a digit (up to 9), that's 9e17. However, for Python, integers can handle that. However, precomputing all the powers of 10 for each possible position would be helpful.\n\nBut how do we compute 10^{n - k} for various k?\n\nLet me think. For Homer's case, when he takes the (h+1)th digit, the exponent is n - (h+1). So for example, if he has taken h digits before, then this is the (h+1)th digit. Similarly for Marge's case.\n\nSo, for each possible h and m (number of digits taken by Homer and Marge respectively), we can precompute the exponents. However, during the DP transitions, we can compute these exponents on the fly.\n\nBut for efficiency, perhaps precompute a list of powers of 10 up to 18 digits (since n can be up to 18). Let's think: the maximum exponent needed is n (for when a player takes their first digit). For example, if n=18, then the first digit taken by a player contributes 10^17, since the number has 18 digits. So the exponents needed are 10^0 to 10^17.\n\nSo precomputing pow10 = [10**i for i in range(0, 18)] would be sufficient. Wait, but for n=18, the exponent for the first digit is 18 - 1 = 17. So yes, pow10[17] is 10^17.\n\nSo precompute pow10 as a list where pow10[k] = 10^k. Then, for a given h, the exponent is n - (h + 1) = (n - h -1). So for Homer's contribution, it's d * pow10[n - h -1].\n\nSimilarly for Marge's contribution: when she takes her (m + 1)th digit, the exponent is n - (m + 1). Here, m is the number of digits she has taken before this step. Since m = (i - h) (because i is the current number of digits taken, and h is the number of H's taken so far), then m + 1 = i - h + 1. So the exponent is n - (i - h + 1) = (n - i + h - 1). So the contribution is d * pow10[ n - i + h - 1 ].\n\nWait, let's check that. For example, if Marge takes her first digit (m=0 before), then the exponent is n - (0 + 1) = n -1. Which is correct, since the first digit is multiplied by 10^(n-1). So yes.\n\nSo during the DP transitions, for each state (i, h), and for the current digit d = A[i], we can compute the contribution for choosing H or M.\n\nSo, the plan is:\n\n- Precompute the pow10 array up to 18 digits (since n can be up to 18, and the maximum exponent is 18-1=17).\n\n- Implement a memoized recursive DP function that for each (i, h) returns the maximum total sum possible from that state, and also tracks the path (the choices made) to reconstruct the solution.\n\nBut since Python's recursion stack may not be deep enough for 36 steps, perhaps it's better to implement memoization with a memo table (like a dictionary or a 2D array) and use iterative DP.\n\nAlternatively, since the number of states is small, even a memoization approach with recursion would work.\n\nBut for the purposes of code, perhaps memoization with lru_cache would be easier. However, since n can be up to 18, and 2n is 36, and the state is (i, h), which can be up to (36, 18), it's manageable.\n\nBut wait, in Python, for memoization with lru_cache, the parameters must be hashable. So if we pass i and h as integers, that's fine.\n\nBut for the problem, we need to not only compute the maximum sum, but also the path (the sequence of H and M choices). So the DP needs to track both the maximum value and the path.\n\nBut how to do that? One approach is to compute the maximum value using memoization, and then reconstruct the path by, for each state, checking which choice (H or M) was taken to reach the maximum value.\n\nSo first, compute the DP table for maximum values, then backtrack through the states to find the path.\n\nSo the steps are:\n\n1. Parse the input: n and A (as a string).\n\n2. Precompute pow10 array.\n\n3. Compute the DP table for (i, h) states, storing the maximum total sum.\n\n4. Once the DP is filled, backtrack from the initial state (i=0, h=0) to determine the sequence of choices (H or M) that leads to the maximum sum.\n\nBut how to compute the DP table. Let's think about the transitions again.\n\nThe DP can be implemented with memoization. Let's define a function max_sum(i, h) which returns the maximum total sum possible from state (i, h).\n\nThe base case is when i == 2n: return 0.\n\nFor other cases:\n\ncurrent_digit = A[i]\n\nWe can try choosing H (if possible) and M (if possible).\n\nFor choosing H:\n\nif h < n:\n\n   new_h = h + 1\n\n   contribution_H = current_digit * pow10[ n - new_h ]\n\n   then, the total is contribution_H + max_sum(i+1, new_h)\n\nFor choosing M:\n\nif (i - h) < n:\n\n   new_m = (i - h) + 1\n\n   contribution_M = current_digit * pow10[ n - new_m ]\n\n   then, total is contribution_M + max_sum(i+1, h)\n\nWe take the maximum between the two options (if both are allowed).\n\nBut wait, for M's case, the new_m is (i - h) + 1. But since (i - h) is the number of M's taken before this step, and after choosing M, it becomes (i - h) + 1. This must be <=n. So the condition is (i - h) + 1 <=n → i - h <=n-1 → h >= i - (n-1). But in the DP function, when considering whether to choose M, we need to check if (i - h) < n. Because (i - h) is the current number of M's taken. Adding 1 would make it (i - h +1) which must be ≤n. So the condition is (i - h) <n.\n\nSo during the transitions, when considering choosing M, the condition is (i - h) <n.\n\nSo in code, for each state (i, h):\n\nmax_val = -infinity\n\nif h <n:\n\n   compute contribution_H and add to max_sum(i+1, h+1)\n\nif (i - h) <n:\n\n   compute contribution_M and add to max_sum(i+1, h)\n\nthen, take the maximum between the two options.\n\nBut how to handle cases where only one option is possible. For example, when i=2n-1, and h =n-1. Then, the next step must be H (since h can be increased to n, and M can't take anymore, since (i -h) = (2n-1 - (n-1)) =n. So (i-h) is n, which is not less than n. So M can't be chosen here.\n\nSo the code for the DP transitions would need to check for the validity of each choice.\n\nOnce the DP is computed, the next step is to reconstruct the path. To do that, during the DP computation, we can track for each state (i, h) which choice (H or M) was taken to reach the maximum value.\n\nBut for that, perhaps during the DP computation, we can store not only the maximum value but also the choice made. However, with memoization, this can be done by, during the computation, for each state, checking which option (H or M) gives the maximum value, and recording that choice.\n\nBut since the DP is memoized, perhaps we can compute the max_sum values first, and then backtrack through the states to find the path.\n\nSo the plan is:\n\nCompute the max_sum for all states, then backtrack from (0, 0) to (2n, n) (since after 2n steps, h must be n, since each player took exactly n steps).\n\nSo for backtracking:\n\nInitialize i=0, h=0. The path is empty.\n\nWhile i < 2n:\n\n   current_digit = A[i]\n\n   check if choosing H is possible and if it leads to the maximum value.\n\n   For that, compare the value of choosing H (contribution_H + max_sum(i+1, h+1)) versus choosing M (contribution_M + max_sum(i+1, h)).\n\n   Whichever is larger, choose that option, append 'H' or 'M' to the path, and update i and h accordingly.\n\nBut how do we know which choice was taken during the DP calculation? Because during the DP, for each state, we can compute which choice gives the maximum value.\n\nSo during backtracking, for each state (i, h), we can compute both options and see which one gives the maximum value.\n\nBut for that, we need to compute for each (i, h) the max_sum value, which we have already stored. So during backtracking, for each step, we can check whether the maximum value for (i, h) is achieved by choosing H or M.\n\nThis seems feasible.\n\nNow, the problem is to implement this in Python.\n\nBut first, handling the pow10 array. Let's think: n can be up to 18, so the maximum exponent is 18-1=17. So pow10 should be precomputed for exponents 0 to 17.\n\nBut for the contribution, when choosing H, the exponent is n - (h + 1). For example, when h is the current count of H's, and we add one more. So the exponent is (n - (h + 1)).\n\nBut if n is 18, and h is 17, then n - (h +1) = 18 - 18 = 0. Which is correct, since that's the last digit taken by Homer, contributing digit * 10^0.\n\nSo pow10 needs to be precomputed for exponents from 0 to 17 (since n can be up to 18, and the exponent can be 0 to 18-1=17).\n\nSo in code, we can precompute pow10 as follows:\n\npow10 = [10**i for i in range(0, 18)]\n\nBut in Python, 10**i for i up to 17 is manageable.\n\nNow, for the DP function. Let's implement it with memoization. However, for Python, recursion with memoization may be acceptable here, but for n=18, the maximum depth is 36 steps. So recursion depth is acceptable.\n\nBut for memoization, perhaps using memoization via lru_cache with a helper function.\n\nBut the problem is that the A string is needed for the current digit. However, since the DP is dependent on the current i (the index into A), which is passed as a parameter, the helper function can access A as a global variable, or pass it as a parameter. However, since the helper function is memoized, passing A as a parameter would not be efficient. Therefore, it's better to process the A string as a global variable or as a parameter to the DP function, but that would complicate memoization.\n\nWait, but the A string is fixed for each test case. So during the processing of a single test case, the DP function can refer to the A string as a global variable. So for each input, we read A, and then process it.\n\nSo the code structure would be:\n\nRead n and A.\n\nprecompute pow10.\n\ncompute the DP for max_sum(i, h) for all (i, h).\n\nthen backtrack to find the path.\n\nNow, implementing the DP with memoization.\n\nBut in Python, for memoization, we can use functools.lru_cache. However, since the parameters i and h are integers, and the A is fixed, the function can be written as follows.\n\nBut the problem is that for each call to the DP function, the A is fixed. So the DP function can be inside a function that has access to A and pow10.\n\nSo perhaps the code can be structured as follows:\n\ndef solve():\n\n    n = ... \n\n    A = ... \n\n    pow10 = ... \n\n    @lru_cache(maxsize=None)\n\n    def max_sum(i, h):\n\n        if i == 2*n:\n\n            return 0\n\n        current_digit = int(A[i])\n\n        best = -infinity\n\n        # try H\n\n        if h < n:\n\n            new_h = h + 1\n\n            exponent = n - new_h \n\n            contribution = current_digit * pow10[exponent]\n\n            res = contribution + max_sum(i+1, new_h)\n\n            if res > best:\n\n                best = res\n\n        # try M\n\n        current_m = i - h \n\n        if current_m < n:\n\n            new_m = current_m + 1 \n\n            exponent = n - new_m \n\n            contribution = current_digit * pow10[exponent]\n\n            res = contribution + max_sum(i+1, h)\n\n            if res > best:\n\n                best = res\n\n        return best \n\n    # then backtrack to find the path\n\nBut wait, this code is not correct. Because when trying both options, the code must compare which option gives the higher value. However, the code above is written as if trying H and M, and choosing the maximum between them. But the code as written would not capture that.\n\nWait, the code for max_sum is written as follows: for each possible option (H and M), compute the value, and take the maximum. So the code is correct.\n\nBut in the code above, the 'best' variable is initialized to -infinity, and then for each possible option, we compute the res and compare to best. So the code is correct.\n\nBut in the code, for the H case, the code checks if h <n, then computes the contribution and adds the recursive call. Similarly for M.\n\nOnce the max_sum function is computed, then backtracking is needed.\n\nNow, the backtracking part:\n\nWe need to generate the sequence of 'H' and 'M' choices. Starting from (i=0, h=0), and for each step, decide whether to choose H or M, based on which option gives the maximum value.\n\nBut how to do that? For each state (i, h), we can check what choice (H or M) gives the maximum value.\n\nSo during backtracking, for each (i, h), we check:\n\ncurrent_digit = int(A[i])\n\noption_H is possible if h <n.\n\noption_M is possible if (i -h) <n.\n\nThen, compute the value of choosing H (contribution_H + max_sum(i+1, h+1)) and the value of choosing M (contribution_M + max_sum(i+1, h)), and pick the one with higher value.\n\nBut since we have already computed the max_sum values, we can do this comparison.\n\nSo, the backtracking code would be something like:\n\npath = []\n\ni = 0\n\nh = 0\n\nwhile i < 2*n:\n\n    current_digit = int(A[i])\n\n    # check possible options\n\n    option_H_possible = h <n \n\n    option_M_possible = (i - h) <n \n\n    # evaluate which option gives higher value\n\n    best_choice = None \n\n    best_value = -infinity \n\n    if option_H_possible:\n\n        new_h = h +1 \n\n        exponent = n - new_h \n\n        contribution_H = current_digit * pow10[exponent]\n\n        value_H = contribution_H + max_sum(i+1, new_h)\n\n        if value_H > best_value:\n\n            best_value = value_H \n\n            best_choice = 'H'\n\n    if option_M_possible:\n\n        current_m = i -h \n\n        new_m = current_m +1 \n\n        exponent = n - new_m \n\n        contribution_M = current_digit * pow10[exponent]\n\n        value_M = contribution_M + max_sum(i+1, h)\n\n        if value_M > best_value:\n\n            best_value = value_M \n\n            best_choice = 'M'\n\n    # append the best_choice to the path \n\n    path.append(best_choice)\n\n    # update i and h \n\n    if best_choice == 'H':\n\n        h +=1 \n\n    i +=1 \n\nreturn ''.join(path)\n\nBut this code assumes that for each state, the best choice can be determined by comparing the value of choosing H and M. However, since the max_sum function returns the maximum value for that state, the value_H and value_M should be compared to see which one equals the max_sum(i, h) value. But how?\n\nWait, the max_sum(i, h) is equal to the maximum between value_H and value_M. So for the current state (i, h), the value of max_sum(i, h) is the maximum of the two options. So during backtracking, when evaluating the options, the code can check which option gives the value equal to max_sum(i, h).\n\nBut how to compute that?\n\nAlternatively, during backtracking, for each state, the code can compute both options and see which one matches the max_sum value. However, this could be computationally expensive, but given that the number of steps is small (36 steps), it's manageable.\n\nBut in the code above, the code computes value_H and value_M, and chooses the one with higher value. However, in the case where both options are possible and give the same value, the code would choose the first one (H or M?), depending on which is evaluated first. But according to the problem statement, any correct path is acceptable.\n\nBut how do we know that the code correctly captures the choice that was made during the DP calculation?\n\nWell, the code for the backtracking is based on the same logic as the DP function. So, during backtracking, for each state, the code checks which option (H or M) gives the maximum value, which is exactly what the DP function did. Therefore, the code should correctly reconstruct the path.\n\nBut there's a problem: when the code calls max_sum(i+1, new_h) during backtracking, it's possible that the max_sum function is already memoized. So during backtracking, the code can use the memoized values.\n\nBut in the code above, during backtracking, the code recomputes value_H and value_M by adding the contribution and the max_sum of the next state. However, this is redundant, because the max_sum(i, h) is already the maximum of these two options. So, during backtracking, the code can compare the value of choosing H (contribution_H + max_sum(i+1, h+1)) and choosing M (contribution_M + max_sum(i+1, h)), and select the one that equals the max_sum(i, h) value.\n\nBut since the max_sum(i, h) is already known, perhaps we can compare which of the options gives the same value.\n\nBut how?\n\nAlternatively, during the backtracking, for each state (i, h), we can check whether choosing H gives the same value as the current max_sum(i, h). If yes, then choose H. Else, choose M.\n\nBut how to do that?\n\nFor example, during backtracking:\n\ncurrent_value = max_sum(i, h)\n\nif option_H is possible:\n\n   value_H = contribution_H + max_sum(i+1, h+1)\n\n   if value_H == current_value:\n\n       choose H\n\nelse:\n\n   choose M\n\nBut this approach would work. However, since the max_sum function is already computed, this would be accurate.\n\nBut how to implement this?\n\nIn code:\n\ncurrent_value = max_sum(i, h)\n\nif option_H_possible:\n\n    contribution_H = ... \n\n    value_H = contribution_H + max_sum(i+1, h+1)\n\n    if value_H == current_value:\n\n        choose H\n\nSimilarly for M.\n\nBut this would require checking both options, which may be time-consuming, but for small n, acceptable.\n\nBut during backtracking, the code can proceed as follows:\n\nfor each step:\n\n   check if H is possible and if choosing H gives the same value as max_sum(i, h). If yes, choose H.\n\n   else, choose M.\n\nBut how to handle cases where both options are possible and both give the same value? For example, when value_H and value_M are equal to current_value. In that case, the code can choose either H or M, as per the problem statement.\n\nBut how to implement this? For example, in the code, during backtracking, for each state (i, h), we can first check whether choosing H is possible and if the value_H equals current_value. If yes, choose H. Else, check if choosing M is possible and value_M equals current_value. Choose that.\n\nBut how to compute value_H and value_M?\n\nIn code:\n\ncurrent_value = max_sum(i, h)\n\noption_H_possible = h <n \n\noption_M_possible = (i - h) <n \n\nif option_H_possible:\n\n    new_h = h +1 \n\n    exponent = n - new_h \n\n    contribution_H = current_digit * pow10[exponent]\n\n    value_H = contribution_H + max_sum(i+1, new_h)\n\nelse:\n\n    value_H = -infinity \n\nif option_M_possible:\n\n    current_m = i - h \n\n    new_m = current_m +1 \n\n    exponent = n - new_m \n\n    contribution_M = current_digit * pow10[exponent]\n\n    value_M = contribution_M + max_sum(i+1, h)\n\nelse:\n\n    value_M = -infinity \n\nif value_H == current_value:\n\n    choose H \n\nelif value_M == current_value:\n\n    choose M \n\nelse:\n\n    # error, since current_value is supposed to be the max of these two \n\nBut this approach is more accurate, but requires computing value_H and value_M again. However, since the max_sum function is already memoized, this is acceptable.\n\nBut during backtracking, this may be computationally feasible.\n\nBut in practice, for the code, during backtracking, the code can compute both options and check which one matches the current_value.\n\nHowever, for the code, this would require that during backtracking, we have access to the max_sum function's values.\n\nSo integrating this into the code.\n\nBut how to handle the pow10 array? It's already precomputed.\n\nNow, putting all this together.\n\nBut there's another problem: the pow10 array. For exponents, when n is 18, and the exponent is n - new_h, which can be 18 - new_h. For example, if new_h is 0, then exponent is 18, but our pow10 array is up to 17. Wait, no! Wait, earlier analysis said that the maximum exponent is n-1. Let me recheck.\n\nWhen a player takes their first digit, the exponent is n - 1 (since the digit is multiplied by 10^{n-1}).\n\nBut in the code, when new_h is h+1, which is the number of digits taken by Homer so far. For example, when new_h is 1, the exponent is n - new_h = n -1. Which is correct.\n\nBut if n is 18, then n - new_h can be up to 18 - 1 = 17, which is covered by the pow10 array (which is up to 10^17). So pow10 needs to be of size 18, indexes 0 to 17. So pow10 = [10**i for i in range(18)].\n\nYes. So for exponents up to 17, which is 10^17.\n\nSo the code for pow10 is correct.\n\nNow, let's test with the sample input.\n\nSample Input 1:\n\n2\n\n1234\n\nSample Output: HHMM.\n\nLet's see.\n\nn=2, A is '1234'.\n\nThe digits are 1,2,3,4.\n\nThe optimal sequence is HHMM.\n\nLet's compute the total sum.\n\nHomer takes 1 and 2 (digits 1 and 2). His number is 12 → 12 dollars.\n\nMarge takes 3 and 4 → 34 → 34. Total is 46.\n\nAnother option: HMHM.\n\nH takes 1, M takes 2, H takes 3, M takes 4.\n\nHomer's number is 13 → 13, Marge's is 24 → 24. Total 37 <46.\n\nSo the first option is better.\n\nNow, during the DP steps.\n\nLet's see how the code would compute this.\n\nBut perhaps the code works.\n\nNow, code-wise, the main challenge is to implement the DP and backtracking correctly.\n\nBut in Python, memoization with lru_cache can be used for the max_sum function. However, since the function is inside the solve() function, and the parameters are i and h, which are integers, it should work.\n\nBut for the pow10 array, the code must be accessible inside the max_sum function.\n\nBut in code, the pow10 array is a local variable inside solve(), so the max_sum function (defined inside solve()) can access it.\n\nSo the code outline is:\n\nimport sys\n\nfrom functools import lru_cache\n\ndef solve():\n\n    n = int(sys.stdin.readline())\n\n    A = sys.stdin.readline().strip()\n\n    pow10 = [10**i",
    "response": "To solve this problem, we need to determine the optimal sequence of moves for Homer and Marge such that their total prize money is maximized. The game involves taking digits from a given number, with each player taking exactly `n` turns. The goal is to maximize the sum of the numbers formed by each player's digits.\n\n### Approach\n1. **Dynamic Programming (DP) with Memoization**: We use a DP approach to explore all possible sequences of moves, ensuring we maximize the total prize money. The state of our DP function is defined by the current position in the number string and the number of moves Homer has made so far.\n2. **Precompute Powers of 10**: Since the value of each digit depends on its position in the number formed by a player, we precompute powers of 10 up to the maximum required exponent (18).\n3. **Backtracking to Reconstruct Path**: After computing the maximum possible total prize using DP, we backtrack from the initial state to determine the exact sequence of moves that leads to this maximum value.\n\n### Solution Code\n```python\nimport sys\nfrom functools import lru_cache\n\ndef solve():\n    n = int(sys.stdin.readline())\n    A = sys.stdin.readline().strip()\n    pow10 = [10**i for i in range(18)]  # since max n is 18, exponents up to 17\n\n    @lru_cache(maxsize=None)\n    def max_sum(i, h):\n        if i == 2 * n:\n            return 0\n        current_digit = int(A[i])\n        best = -float('inf')\n        # Try H\n        if h < n:\n            new_h = h + 1\n            exponent = n - new_h\n            contribution = current_digit * pow10[exponent]\n            res = contribution + max_sum(i + 1, new_h)\n            if res > best:\n                best = res\n        # Try M\n        current_m = i - h\n        if current_m < n:\n            new_m = current_m + 1\n            exponent = n - new_m\n            contribution = current_digit * pow10[exponent]\n            res = contribution + max_sum(i + 1, h)\n            if res > best:\n                best = res\n        return best\n\n    # Backtrack to find the path\n    path = []\n    i = 0\n    h = 0\n    while i < 2 * n:\n        current_digit = int(A[i])\n        current_value = max_sum(i, h)\n        option_H_possible = h < n\n        option_M_possible = (i - h) < n\n\n        value_H = -float('inf')\n        value_M = -float('inf')\n\n        if option_H_possible:\n            new_h = h + 1\n            exponent = n - new_h\n            contribution_H = current_digit * pow10[exponent]\n            value_H = contribution_H + max_sum(i + 1, new_h)\n        if option_M_possible:\n            current_m = i - h\n            new_m = current_m + 1\n            exponent = n - new_m\n            contribution_M = current_digit * pow10[exponent]\n            value_M = contribution_M + max_sum(i + 1, h)\n\n        if value_H == current_value:\n            path.append('H')\n            h += 1\n        elif value_M == current_value:\n            path.append('M')\n        else:\n            # This should not happen as per the DP calculation\n            pass\n        i += 1\n\n    print(''.join(path))\n\nif __name__ == \"__main__\":\n    solve()\n```\n\n### Explanation\n1. **Reading Input**: The input consists of an integer `n` and a string `A` of length `2n`.\n2. **Precompute Powers of 10**: This helps in efficiently calculating the contribution of each digit based on its position in the number formed by a player.\n3. **Dynamic Programming Function**: The `max_sum` function uses memoization to store results of subproblems, ensuring efficient computation. It evaluates both possible moves (Homer or Marge) at each step and returns the maximum possible total prize.\n4. **Backtracking**: After computing the DP table, we backtrack from the initial state to reconstruct the sequence of moves that leads to the maximum total prize. This involves checking which move (H or M) at each step contributes to the maximum value stored in the DP table.\n\nThis approach ensures that we efficiently explore all possible move sequences and determine the optimal one using dynamic programming and backtracking.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom functools import lru_cache\n\ndef solve():\n    n = int(sys.stdin.readline())\n    A = sys.stdin.readline().strip()\n    pow10 = [10**i for i in range(18)]  # since max n is 18, exponents up to 17\n\n    @lru_cache(maxsize=None)\n    def max_sum(i, h):\n        if i == 2 * n:\n            return 0\n        current_digit = int(A[i])\n        best = -float('inf')\n        # Try H\n        if h < n:\n            new_h = h + 1\n            exponent = n - new_h\n            contribution = current_digit * pow10[exponent]\n            res = contribution + max_sum(i + 1, new_h)\n            if res > best:\n                best = res\n        # Try M\n        current_m = i - h\n        if current_m < n:\n            new_m = current_m + 1\n            exponent = n - new_m\n            contribution = current_digit * pow10[exponent]\n            res = contribution + max_sum(i + 1, h)\n            if res > best:\n                best = res\n        return best\n\n    # Backtrack to find the path\n    path = []\n    i = 0\n    h = 0\n    while i < 2 * n:\n        current_digit = int(A[i])\n        current_value = max_sum(i, h)\n        option_H_possible = h < n\n        option_M_possible = (i - h) < n\n\n        value_H = -float('inf')\n        value_M = -float('inf')\n\n        if option_H_possible:\n            new_h = h + 1\n            exponent = n - new_h\n            contribution_H = current_digit * pow10[exponent]\n            value_H = contribution_H + max_sum(i + 1, new_h)\n        if option_M_possible:\n            current_m = i - h\n            new_m = current_m + 1\n            exponent = n - new_m\n            contribution_M = current_digit * pow10[exponent]\n            value_M = contribution_M + max_sum(i + 1, h)\n\n        if value_H == current_value:\n            path.append('H')\n            h += 1\n        elif value_M == current_value:\n            path.append('M')\n        else:\n            # This should not happen as per the DP calculation\n            pass\n        i += 1\n\n    print(''.join(path))\n\nif __name__ == \"__main__\":\n    solve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 425,
        "completion_token_count": 962,
        "thoughts_token_count": 8192
    }
}