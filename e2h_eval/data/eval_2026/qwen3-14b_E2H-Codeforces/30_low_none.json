{
    "start": 1758310145.1325333,
    "end": 1758310183.7230558,
    "start-formatted": "2025-09-20 04:29 KST",
    "end-formatted": "2025-09-20 04:29 KST",
    "gpu": 2,
    "pid": 30,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# TV Game\n\nThere is a new TV game on BerTV. In this game two players get a number A consisting of 2n digits. Before each turn players determine who will make the next move. Each player should make exactly n moves. On it's turn i-th player takes the leftmost digit of A and appends it to his or her number Si. After that this leftmost digit is erased from A. Initially the numbers of both players (S1 and S2) are «empty». Leading zeroes in numbers A, S1, S2 are allowed. In the end of the game the first player gets S1 dollars, and the second gets S2 dollars.One day Homer and Marge came to play the game. They managed to know the number A beforehand. They want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize. Help them.\n\n## Input\nThe first line contains integer n (1 ≤ n ≤ 18). The second line contains integer A consisting of exactly 2n digits. This number can have leading zeroes.\n\n## Output\nOutput the line of 2n characters «H» and «M» — the sequence of moves of Homer and Marge, which gives them maximum possible total prize. Each player must make exactly n moves. If there are several solutions, output any of them.\n\n## Example\n### Input\n['2\\n1234', '2\\n9911']\n\n### Output\n['HHMM', 'HMHM']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\nOkay, let's see. I need to solve this problem where Homer and Marge are playing a game with a number A of 2n digits. They take turns picking digits from the front of A, and each makes exactly n moves. The goal is to maximize the sum of their numbers S1 and S2. The output should be the sequence of moves (H or M) that achieves this maximum sum. And if there are multiple solutions, any is acceptable.\n\nHmm. The challenge here is to find the optimal sequence of choices for Homer and Marge. Since each choice affects the remaining digits and the future possibilities, this seems like a dynamic programming problem. But considering that n can be up to 18, the total number of digits is 36. So the state space might be manageable with memoization.\n\nLet me think about the state. At any point in the game, the number of digits left is 2n - k, where k is the number of digits already taken. But since each player takes exactly n moves, the state can be represented by how many moves Homer and Marge have made so far. Wait, but since the total moves are fixed (each has exactly n), maybe the state can be represented by the current position in the string and the count of how many times Homer and Marge have picked so far.\n\nWait, for example, suppose we have a string A of length 2n. Let's say that after some steps, Homer has made h moves and Marge has made m moves. Since each move takes one digit, the number of digits taken so far is h + m. So the current position in the string is at index (h + m). So the state can be represented as (h, m), which tells us how many moves each has made. Then, for each state, we can decide whether the next move is H or M, provided that h < n and m < n respectively.\n\nBut the problem is that for each state (h, m), there are two possible choices (if both players still have moves left). However, since the total number of moves is 2n, and h + m can range from 0 to 2n-1. For n=18, h and m can each be up to 18. So the total number of states is (18+1)*(18+1) = 361. That's manageable. But for each state, we need to track the maximum sum possible from that state onwards, and also the choice (H or M) that leads to that maximum.\n\nSo the DP approach would be:\n\nDefine dp[h][m] as the maximum total sum that can be achieved from the current state (h, m). The current state implies that Homer has already taken h digits and Marge has taken m digits. The current position in the string is at index (h + m). So, the next digit to take is A[h + m].\n\nAt each state (h, m), the next move can be either H or M, but only if h < n (for H) and m < n (for M). \n\nFor example, if h < n, then Homer can take the next digit. Then, the next state would be (h+1, m). Similarly for Marge.\n\nThe value of the DP state would be the maximum between taking H or M (if possible) plus the current contribution of the digit chosen. Wait, but when Homer takes the digit, it adds to his number S1, which contributes to the total sum. Similarly for Marge. So the current digit added to the sum depends on which player takes it.\n\nWait, the total prize is S1 + S2. Each digit that Homer takes is added to S1, and each digit that Marge takes is added to S2. So, for each choice of H or M, the current digit is multiplied by 10^{n - (current number of moves for that player)}? Wait, no. Because the digits are collected in the order they are taken. For example, if Homer takes digits in the order d1, d2, ..., dn, then his number S1 is d1 * 10^{n-1} + d2 * 10^{n-2} + ... + dn * 10^0. Similarly for Marge.\n\nBut the problem is that the value of the digits depends on their position in the sequence. So, the first digit taken by a player contributes more to the total than the later ones. Therefore, when making a decision, we need to consider the position of the digit in the player's number.\n\nThis complicates things because the DP state not only needs to track the counts of moves but also the current value of S1 and S2. However, since the digits are taken in order, the position of each digit in the player's number is determined by how many digits they have already taken. For example,",
    "response": "To solve this problem, we need to determine the optimal sequence of moves for Homer and Marge such that their total prize money is maximized. The game involves taking digits from a number A of length 2n, with each player making exactly n moves.\n\n### Approach\n1. **Dynamic Programming (DP) with Memoization**: We use a DP approach where the state is defined by the number of moves made by Homer (h) and Marge (m). This helps in efficiently exploring all possible move sequences while keeping track of the maximum possible total prize.\n2. **Recursive Decision Making**: At each state (h, m), we decide whether Homer or Marge should take the next digit based on which choice leads to a higher total prize. The decision considers the current digit's contribution to the total prize, factoring in its position in the respective player's number.\n3. **Memoization**: To avoid redundant calculations, we memoize the results of subproblems using a cache. This ensures that each state is computed only once, leading to efficient computation even for larger values of n.\n\n### Solution Code\n```python\nimport sys\nimport functools\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    n = int(input[0])\n    A = input[1]\n    \n    length = 2 * n\n    # Precompute the powers of 10 for each position\n    power = [1] * (n + 1)\n    for i in range(1, n + 1):\n        power[i] = power[i - 1] * 10\n\n    @functools.lru_cache(maxsize=None)\n    def dp(h, m):\n        if h + m == length:\n            return (0, \"\")\n        pos = h + m\n        digit = int(A[pos])\n        max_val = -1\n        best_move = \"\"\n        \n        # Homer's turn if he hasn't taken n digits yet\n        if h < n:\n            new_h = h + 1\n            val = digit * power[n - new_h]\n            next_val, next_move = dp(new_h, m)\n            total = val + next_val\n            if total > max_val:\n                max_val = total\n                best_move = \"H\" + next_move\n        # Marge's turn if she hasn't taken n digits yet\n        if m < n:\n            new_m = m + 1\n            val = digit * power[n - new_m]\n            next_val, next_move = dp(h, new_m)\n            total = val + next_val\n            if total > max_val:\n                max_val = total\n                best_move = \"M\" + next_move\n        return (max_val, best_move)\n    \n    _, result = dp(0, 0)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Dynamic Programming State**: The function `dp(h, m)` computes the maximum total prize starting from the state where Homer has made `h` moves and Marge has made `m` moves.\n- **Digit Contribution Calculation**: For each digit taken, its contribution to the total prize depends on its position in the player's number. This is calculated using precomputed powers of 10.\n- **Recursive Exploration**: The function recursively explores both possible moves (Homer or Marge taking the next digit) and selects the one that maximizes the total prize, using memoization to store results of previously computed states for efficiency.\n\nThis approach ensures that we efficiently explore all possible move sequences while keeping track of the optimal choices, leading to the maximum total prize for Homer and Marge.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport functools\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    n = int(input[0])\n    A = input[1]\n    \n    length = 2 * n\n    # Precompute the powers of 10 for each position\n    power = [1] * (n + 1)\n    for i in range(1, n + 1):\n        power[i] = power[i - 1] * 10\n\n    @functools.lru_cache(maxsize=None)\n    def dp(h, m):\n        if h + m == length:\n            return (0, \"\")\n        pos = h + m\n        digit = int(A[pos])\n        max_val = -1\n        best_move = \"\"\n        \n        # Homer's turn if he hasn't taken n digits yet\n        if h < n:\n            new_h = h + 1\n            val = digit * power[n - new_h]\n            next_val, next_move = dp(new_h, m)\n            total = val + next_val\n            if total > max_val:\n                max_val = total\n                best_move = \"H\" + next_move\n        # Marge's turn if she hasn't taken n digits yet\n        if m < n:\n            new_m = m + 1\n            val = digit * power[n - new_m]\n            next_val, next_move = dp(h, new_m)\n            total = val + next_val\n            if total > max_val:\n                max_val = total\n                best_move = \"M\" + next_move\n        return (max_val, best_move)\n    \n    _, result = dp(0, 0)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 417,
        "completion_token_count": 760,
        "thoughts_token_count": 1024
    }
}