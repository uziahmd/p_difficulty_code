{
    "start": 1758308534.774915,
    "end": 1758308690.178957,
    "start-formatted": "2025-09-20 04:02 KST",
    "end-formatted": "2025-09-20 04:04 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\nOkay, let's try to figure out how to solve this problem. The problem is about finding the minimum number of edges to add to a graph to create an odd-length cycle, and also count the number of ways to do that. \n\nFirst, I need to understand what's required. The key here is that the graph already might have some structures. If the graph already contains an odd-length cycle, then the answer is t=0 and w=1? Or maybe not. Wait, the problem says that the existing graph may not have such a cycle, and we need to find the minimum edges to add to create one. But if the graph already has such a cycle, then t is zero and w is the number of ways to add zero edges (which would be 1, since there's only one way to do nothing). But how do I check if the graph already has an odd-length cycle?\n\nWait, but the problem says that the graph is undirected. So for an undirected graph, any cycle that is of odd length would make the graph non-bipartite. Because bipartite graphs can't have odd-length cycles. So if the graph is bipartite, then it doesn't have any odd-length cycles. So the first thing to check is whether the graph is bipartite. If it's not bipartite, then there's already an odd-length cycle. So in that case, t is 0 and w is 1. But wait, the note says that the output for the second example is 0 1. Let me check that example.\n\nIn the second example input, the graph is a triangle (3 nodes connected in a cycle). That's a cycle of length 3, which is odd. So the answer is t=0 and w=1. Which matches the sample output. So that makes sense.\n\nSo the first step is to check if the graph is bipartite. If it's not bipartite, then the answer is t=0 and w=1. But wait, maybe there are multiple existing odd-length cycles. However, the problem says that we need to find the minimum number of edges to add. Since the graph already has an odd cycle, no edges need to be added. So regardless of how many existing odd cycles there are, the answer is t=0 and w=1? Because the question says that the ways to add edges must form a cycle of odd length. But if the graph already has such a cycle, then adding zero edges is one way. But perhaps there are multiple existing cycles. However, the problem says that the ways are considered equal if they have the same set of added edges. Since adding zero edges is only one way, regardless of how many existing cycles there are, the answer for w would be 1. Because the problem requires that the added edges form a cycle. But the existing cycles are already present, so the way to add zero edges is just one way. So in that case, the output is t=0 and w=1. \n\nSo the first thing to check is: is the graph bipartitionable? If not, then output t=0, w=1.\n\nIf the graph is bipartite, then we need to find the minimum number of edges to add to create an odd-length cycle. How can we do that?\n\nIn a bipartite graph, all cycles are even-length. So to create an odd-length cycle, we need to add edges in such a way that creates a cycle with an odd length. \n\nWhat's the minimal number of edges needed? Well, think about the structure of a bipartite graph. A bipartite graph is divided into two parts, say A and B. All edges go between A and B. So if there's a connected component that is bipartite, then adding an edge within the same partition would create an odd-length cycle. For example, suppose you have a connected bipartite component. Let's say that component has partitions A and B. If you add an edge between two nodes in A, then there's a cycle. Let's see: suppose there's a path from u to v in the original graph. Since it's bipartite, the path has even length. Adding an edge between u and v would create a cycle of length (even +1) = odd. So that's an odd-length cycle.\n\nSo, for each connected component in the graph, if it's bipartite, then the minimal number of edges to add to create an odd cycle is 1. But how?\n\nBut wait, if a connected component is bipartite, then adding any edge between two nodes in the same partition will create an odd cycle. So the minimal number of edges to add is 1. But how to compute the number of ways to do that?\n\nSo, the problem reduces to:\n\nIf the graph is already non-bipartite (i.e., has an odd cycle), then answer is t=0, w=1.\n\nElse, for each connected component, compute the number of possible edges that can be added within the same partition. Then, the minimal t is 1 (since adding one edge is enough), and the number of ways is the sum over all connected components of (number of possible edges in the component's partitions).\n\nWait, but why?\n\nBecause, adding any such edge would create an odd cycle. So the minimal t is 1, and the number of ways is the total number of such possible edges across all connected components.\n\nWait, but the problem says that the added edges must form a cycle of odd length. So adding one edge in a bipartitioned component would create exactly one such cycle. So, for each connected component, the number of possible edges that can be added to create an odd cycle is (number of possible edges within the same partition). For example, if the component is bipartitioned into A and B, then the number of possible edges is C(|A|,2) + C(|B|,2). Because adding any edge between two nodes in A or two in B would create an odd cycle.\n\nBut wait, the original graph may already have some edges. So the number of possible edges to add is (size_A choose 2 + size_B choose 2) minus the existing edges in the component. Wait, no. Because the original graph is bipartite, so all existing edges are between A and B. So the edges that can be added to create an odd cycle are those that connect two nodes in A or two nodes in B. But the original graph does not have those edges. So for each connected component, the number of possible edges that can be added is (a * (a-1)/2 + b * (b-1)/2 ), where a is the size of partition A, and b is the size of partition B.\n\nBut how do we find a and b for each connected component?\n\nSo, the steps for the solution would be:\n\n1. Check if the graph is bipartite. If not, then output t=0 and w=1.\n\nBut how to check if the graph is bipartite? Well, the graph may consist of multiple connected components. Each connected component needs to be checked for bipartition. If any component is not bipartite, then the entire graph is not bipartite. So, if the graph is bipartitionable (all components are bipartite), then we need to proceed to calculate the required t and w.\n\nSo, first, check for bipartition. If any component is not bipartite, then answer is t=0, w=1.\n\nElse, the graph is bipartitioned into multiple components. For each connected component, we can compute the number of possible edges that can be added to create an odd cycle (i.e., the number of possible edges within the same partition). The minimal t is 1, because adding one such edge would suffice. The number of ways w is the total number of such edges across all components.\n\nWait, but why? Because adding any such edge would create an odd cycle. So the minimal number of edges to add is 1, and the number of ways is the sum over all possible edges that can be added in each component (i.e., for each component, the number of possible edges that can be added to create an odd cycle).\n\nBut in this case, the answer would be t=1 and w=sum of (a*(a-1)/2 + b*(b-1)/2) for all components.\n\nWait, let's look at the sample input.\n\nFirst sample input is:\n\n4 4\n\nEdges: 1-2, 1-3, 2-4, 3-4.\n\nLet me draw this graph. Let's see:\n\nNodes 1 connected to 2 and 3. Nodes 2 and 3 are connected to 4. So the graph is connected. Let's check if it's bipartite.\n\nLet me try to color it. Suppose node 1 is color 0. Then 2 and 3 are color 1. Node 4 is connected to 2 and 3, so it must be color 0. Now, check if there are any conflicts. The edges are between 0 and 1. So yes, it's bipartitioned. So the component is bipartitioned into {1,4} and {2,3}.\n\nSo for this component, a=2, b=2. The number of possible edges is (2 choose 2) + (2 choose 2) = 1+1=2. Which matches the first sample's output of 1 2. So the answer is t=1, w=2. Which matches the sample.\n\nAnother sample is the third input: 3 0. So the graph is three nodes with no edges. So each node is a connected component. But since each component is trivially bipartite (as a single node can be in one partition). So for each component, the size of partitions is a=1, b=0. So for each component, the number of possible edges is (1*0/2) + (0* -1)/2? Wait no. For a single node, the bipartition is (1,0). So the number of possible edges within the same partition is (1 choose 2) + (0 choose 2) = 0 + 0 = 0. So for each of the three components, the count is zero. So the sum is zero. But according to the sample, the output is 3 1. Wait, that's conflicting. What's wrong here?\n\nWait the third input is 3 0. So the graph is three nodes, no edges. So the graph is bipartitioned. So for each connected component (each node is its own component), the bipartition is (1,0). So for each component, the possible edges that can be added to create an odd cycle is (C(1,2) + C(0,2)) = 0 + 0 = 0. So the total sum is zero. But according to the sample, the output is 3 1. Which suggests that t=3 and w=1.\n\nHmm. That indicates that my previous reasoning is incorrect. So what's wrong here?\n\nWait, the problem says that we need to form a simple cycle of an odd length. So, for the case where the graph is three nodes with no edges, how can we create such a cycle?\n\nWe need to add edges. Since the graph is bipartite (each component is a single node, which is trivially bipartite). So in order to create an odd-length cycle, we need to add edges. \n\nBut how? For example, adding three edges to form a triangle. But that requires adding three edges. But the minimal number of edges to add is 3? Because with two edges, you can't form a cycle. For example, adding two edges between 1-2 and 1-3. Then, you have a tree, no cycles. To form a cycle, you need to add three edges. So for a graph with three isolated nodes, the minimal number of edges to add is 3. But according to the sample, the output is 3 1. Which matches this scenario.\n\nSo my earlier reasoning was incorrect. So where is the mistake?\n\nAh! My mistake was assuming that adding one edge in a bipartitioned component would create an odd-length cycle. But that's only possible if the component has at least two nodes in one of the partitions. For example, if a component is a single node (so partitions are (1,0)), adding an edge between two nodes in the same partition is impossible (since there's only one node in that partition). So for such a component, adding any edge would require adding edges between different partitions (but that's allowed in bipartitioned graphs). So in that case, adding an edge between two nodes in different partitions (but that's part of the bipartition). Wait, but that would not create an odd cycle.\n\nSo the previous approach is wrong. So what's the correct way to approach this?\n\nLet me re-express the problem. The minimal number of edges to add to create an odd cycle. \n\nFor a bipartitioned graph (i.e., all connected components are bipartite), adding an edge between two nodes in the same partition of a connected component creates an odd-length cycle. But for that, the connected component must have at least two nodes in that partition. \n\nSo, for each connected component, if the component has a bipartition (A, B), then the number of possible edges that can be added to create an odd cycle is the number of possible edges between nodes in A plus the number between nodes in B. \n\nBut in the case where the component is a single node (A has 1, B has 0), then the number of possible edges is zero. \n\nSo for the third sample input, which has three isolated nodes, each component is a single node. So for each component, the number of possible edges is zero. Therefore, the total sum is zero. But according to the sample, the answer is t=3, w=1. Which implies that in this case, we need to add three edges, and there's exactly one way to do that. So how to reconcile this?\n\nThis suggests that my approach is missing something. Let's think again.\n\nThe problem is to find the minimal number of edges to add to form an odd-length cycle. \n\nIn the case of three isolated nodes, how can we form an odd-length cycle? Well, the minimal way is to add three edges to form a triangle. So that's three edges. \n\nBut according to the previous logic, since each component is bipartitioned, but adding an edge between two nodes in the same partition is not possible (since each component has only one node in their partitions). So the previous approach of adding one edge per component is not sufficient. So what's the correct way to compute t and w?\n\nSo perhaps the minimal t depends on the number of connected components. \n\nLet me think. For a graph that is bipartite, the minimal number of edges to add to create an odd-length cycle can be determined as follows:\n\nIf there is at least one connected component with at least two nodes, then adding one edge between two nodes in the same partition of that component will create an odd cycle. So t is 1. \n\nBut if all connected components are single-node (like the third sample input), then adding one edge is not enough. Because adding one edge would create a component with two nodes connected by an edge. That component is bipartite (two nodes, one edge). Adding another edge would create a cycle. But adding two edges would form a cycle of length 2? No, because the graph is undirected and can't have loops. So two edges between two nodes is not allowed. So for three isolated nodes, to form a cycle, we need to add three edges. \n\nSo in this case, the minimal t is 3. \n\nSo the problem is more complex than previously thought. How can I model this?\n\nSo, the minimal number of edges to add depends on the structure of the graph. Let's break it down into cases.\n\nCase 1: The graph is not bipartite. Then, answer is t=0, w=1.\n\nCase 2: The graph is bipartite. Then, we need to find the minimal number of edges to add to create an odd cycle.\n\nSubcases:\n\nSubcase A: There exists a connected component with at least two nodes. Then, adding one edge within the same partition of that component would create an odd cycle. Hence, t=1.\n\nSubcase B: All connected components are single-node (n nodes, all isolated). Then, to create a cycle, you need to add enough edges to form a cycle. The minimal number of edges is 3 (for a triangle), which requires adding three edges. And the number of ways is 1 (only one way to choose three edges that form a triangle, but wait, the number of ways depends on the number of possible combinations of three edges that form a cycle. However, since the graph is empty, the number of ways to add three edges that form a cycle is exactly 1: the only possible way is to select all three possible edges between the three nodes. So for three nodes, the number of ways is 1. Which matches the third sample input.\n\nSo how do we determine which subcase we are in?\n\nSo, when the graph is bipartite, we need to check if there's a connected component with at least two nodes. If yes, then t=1 and w is the sum of (a choose 2 + b choose 2) for each component. If not (i.e., all components are single nodes), then t = 3 and w is 1 (if n >=3, else impossible? But the problem states that the graph has n vertices. So if n is 1, then no cycle can be formed. But according to the problem statement, the cycle must consist of more than one vertex. So for n=1, the answer is impossible. But according to the input constraints, the input may have n=1. However, the problem says that the given graph may not have any loops or parallel edges. But in that case, for n=1 and m=0, the answer would be impossible. However, the problem says that the input is such that the answer exists. Wait, the problem says that the output must be printed. So perhaps the input ensures that the answer exists. But I need to handle that.\n\nBut for the current problem, the third sample input is n=3, m=0. So the answer is t=3, w=1.\n\nSo, the plan is:\n\nCheck if the graph is bipartite. If not, output t=0, w=1.\n\nElse:\n\nCheck if there exists at least one connected component with size >= 2. If yes:\n\nThen, t=1, and w is the sum over all connected components of (a choose 2 + b choose 2), where a and b are the sizes of the two partitions of the component.\n\nIf all components are of size 1 (n= number of components, each component has 1 node):\n\nThen, if n < 3: impossible? But according to the problem statement, the output must exist. Wait, but in the problem statement, the sample input includes n=3, m=0. For n=2, m=0, the minimal number of edges to add is 2 (adding two edges between the two nodes, which is not allowed since it's a loop or parallel edge. Wait, no. Wait for two nodes, you can't form a cycle. Because a cycle must have at least three nodes. So for n=2 and m=0, it's impossible to form a cycle. But according to the problem statement, the input is such that the answer exists. However, the problem says that the graph may not be connected. So perhaps the input ensures that n >=3 in this case. But how to handle that?\n\nBut according to the problem statement, the sample input for 3 0 outputs t=3, w=1. So for n=3, the answer is possible.\n\nSo for the case where all components are single nodes (so n is the number of components, and each component has one node), then:\n\nIf n >=3, then the minimal t is 3 (add edges to form a triangle), and the number of ways is 1 (only one way to choose three edges between three nodes). But if n is larger than 3, then how?\n\nFor example, if n=4 and all nodes are isolated. Then, the minimal number of edges to add is 3 (to form a triangle). But there are C(4,3) ways to choose the three nodes, and for each such group, there is exactly one way to add the three edges. So the total number of ways is C(4,3) * 1 = 4.\n\nBut according to the problem's sample input, when n=3 and m=0, the answer is 3 1. So in that case, the number of ways is 1. So for the general case where all components are single nodes (i.e., the graph is empty), the answer is t=3 and w= C(n,3) if n >=3, else impossible.\n\nBut how to handle this in code?\n\nSo the overall steps are:\n\n- Check if the graph is bipartite. If not, output 0 1.\n\nElse:\n\n   Check if there exists at least one connected component with size >=2.\n\n   If yes:\n\n      Compute the sum over all components of (a*(a-1)/2 + b*(b-1)/2), which is the number of possible edges to add to create an odd cycle. Then, t is 1, and w is this sum.\n\n   Else:\n\n      If n < 3: impossible? But according to the problem statement, the input is valid. So perhaps n is at least 3.\n\n      Else: t is 3, and w is C(n, 3). Because we need to choose three nodes and connect them into a triangle. Since the original graph has no edges, the number of ways is the number of possible triplets of nodes. Each triplet contributes exactly one way (adding the three edges between them).\n\nBut wait, the problem says that the added edges must form a cycle of odd length. For three nodes, adding three edges forms a triangle (cycle of length 3, which is odd). So yes.\n\nSo, for the third sample input, n=3, so C(3,3)=1. So output is 3 1. Which matches the sample.\n\nSo now, the problem becomes how to implement this logic.\n\nNow, the steps for code:\n\nFirst, check if the graph is bipartite. How to do that?\n\nWe can perform BFS for each connected component and check if it's bipartite. For each component, assign colors (0 and 1) to nodes. If during BFS, we find a conflict (neighbor has same color as current node), then the graph is not bipartite.\n\nOnce we know the graph is bipartite, then:\n\nFor each connected component, we need to find the sizes of the two partitions (a and b). For example, for a connected component, during BFS, we can track the color of each node, and count the number of nodes in each color group. So for each component, a is the count of color 0, b is count of color 1.\n\nOnce we have these, for each component, the number of possible edges to add is a*(a-1)//2 + b*(b-1)//2.\n\nThen, sum all these numbers across all components. That gives the w when t is 1.\n\nBut, before that, we need to check if there exists at least one component with size >=2. For example, if all components are single nodes (so each component's a and b are 1 and 0), then the sum would be zero. So in that case, we need to handle the special case.\n\nSo, in code:\n\nOnce the graph is determined to be bipartite, we check for each component whether its size (a + b) is >= 2. If any component has size >=2, then proceed with t=1 and w=sum.\n\nElse (all components are size 1), then:\n\nif n >=3: t=3, w = C(n,3)\n\nelse: ?\n\nBut according to the problem statement, the input is such that the answer exists. So for example, for n=1, m=0, there is no way to form a cycle. But according to the problem statement, the input may not have such cases. But how to handle that?\n\nWell, the problem says that the output must be printed. So perhaps in such cases, the code can assume that n >=3. But perhaps the problem guarantees that the input allows for a solution.\n\nBut the problem says that the input is given, and the output must be computed. So for example, in the case where n=2 and m=0, the answer would be impossible. However, according to the problem statement, the input may not have such cases. However, the code must handle all possible inputs.\n\nBut according to the problem statement, the sample input includes n=3, m=0. So the code must handle that.\n\nSo, in code, after checking that the graph is bipartite, and that all components are single nodes (i.e., n_components = n, and each component has size 1), then:\n\nif n < 3: then, it's impossible to create a cycle. But according to the problem statement, the output must be printed. However, the problem says that the cycle must consist of more than one vertex. So for n=1 or 2, it's impossible. But the problem says that the input is such that the answer exists. So perhaps the code can assume that n >=3 in this case.\n\nBut how to handle this? For example, if n=2, and the graph is bipartite (which it is, since it's two nodes with no edges). Then, the code would reach the case where all components are size 1. Then, n=2 <3. But the answer is impossible. However, according to the problem statement, the input is such that the answer exists. So perhaps the code can assume that in such cases, the input is not given. But how to proceed?\n\nBut the code must handle all possible inputs. So for example, if the input is n=2, m=0, then the answer would be impossible. However, the problem says that the graph is given, but perhaps the problem's input is such that the answer exists. However, the code must output something.\n\nBut according to the problem statement, the sample input includes n=3, m=0. So for that case, the code returns 3 1.\n\nSo for the code, the logic is:\n\nIf the graph is bipartite:\n\n   check if any component has size >=2.\n\n   if yes:\n\n      t = 1, w = sum of (a choose 2 + b choose 2) for all components.\n\n   else:\n\n      if n >=3:\n\n         t = 3, w = C(n,3)\n\n      else:\n\n         ??? (but perhaps the problem ensures that this case does not happen)\n\nSo, the code can proceed with that.\n\nNow, the problem is how to implement this in Python.\n\nNow, the code steps:\n\nRead n and m.\n\nBuild adjacency list.\n\nCheck if the graph is bipartite. For that, perform BFS for each component. Also, during this process, track the size of each component and the counts of the two partitions.\n\nSo, for each component:\n\n   during BFS, assign color 0 or 1 to each node.\n\n   if any conflict, the graph is not bipartite.\n\nOnce all components are processed, if the graph is not bipartite, output 0 1.\n\nElse:\n\n   check if any component has size >=2.\n\n   if yes:\n\n      compute sum_w = sum for each component (a*(a-1)//2 + b*(b-1)//2)\n\n      output t=1 and w=sum_w.\n\n   else:\n\n      if n >=3:\n\n         t=3, w= n*(n-1)*(n-2)//6\n\n      else:\n\n         # impossible, but according to problem statement, input is valid. So perhaps assume n >=3?\n\nBut how to handle that?\n\nBut according to the problem statement, the sample input includes n=3, m=0, and the output is 3 1. Which is handled by this case.\n\nNow, let's test this logic against the samples.\n\nSample 1:\n\nInput:\n\n4 4\n\nEdges: 1-2, 1-3, 2-4, 3-4.\n\nThe graph is connected. It is bipartite. The partitions are {1,4} and {2,3} (a=2, b=2). So sum_w is 2C2 + 2C2 = 1 + 1 = 2. So output is 1 2. Which matches the first sample.\n\nSample 2:\n\nInput is 3 3, edges forming a triangle. This graph is not bipartite. So output 0 1. Which matches the sample.\n\nSample 3:\n\nInput is 3 0. The graph is bipartite. All components are single nodes (each component is a single node). So n=3 >=3. So t=3, w= C(3,3)=1. Which matches the sample.\n\nAnother test case: n=2, m=0. The graph is bipartite. All components are single nodes. n=2 <3. But according to the problem statement, perhaps the input does not have such cases. So the code would output t=3, w= C(2,3) = 0. Which is invalid. But perhaps the code can assume that n >=3 in this case.\n\nSo, the code needs to handle that. But the problem says that the input is given, and the output must be generated. However, the problem statement says that the graph may not be connected, but the input is valid. So perhaps the code can assume that when this case occurs, n >=3.\n\nNow, the code.\n\nImplementing the BFS for bipartition check.\n\nWe can represent the graph as an adjacency list. For each node, if not visited, perform BFS and check bipartition.\n\nAlso, for each component, track the count of color 0 and color 1.\n\nNow, code steps:\n\nRead n and m.\n\nadj = [[] for _ in range(n+1)]\n\nfor _ in range(m):\n\n   u, v = map(int, input().split())\n\n   adj[u].append(v)\n\n   adj[v].append(u)\n\nvisited = [False] * (n+1)\n\ncolor = [-1] * (n+1)\n\nis_bipartite = True\n\ncomponents = []  # list of tuples (a, b) for each component.\n\nfor each node from 1 to n:\n\n   if not visited:\n\n      queue = deque()\n\n      queue.append(node)\n\n      visited[node] = True\n\n      color[node] = 0\n\n      a_count = 0\n\n      b_count = 0\n\n      a_count += 1\n\n      while queue not empty:\n\n          current = queue.popleft()\n\n          for neighbor in adj[current]:\n\n              if not visited[neighbor]:\n\n                  visited[neighbor] = True\n\n                  color[neighbor] = color[current] ^ 1\n\n                  if color[neighbor] == 0:\n\n                      a_count +=1\n\n                  else:\n\n                      b_count +=1\n\n                  queue.append(neighbor)\n\n              else:\n\n                  if color[neighbor] == color[current]:\n\n                      is_bipartite = False\n\n      # after processing component:\n\n      components.append( (a_count, b_count) )\n\nWait, but the initial code for counting a_count and b_count is not correct. Because the initial node is colored 0, so a_count starts as 1. Then, for each neighbor, when added, their color is toggled. But during BFS, the initial node is processed, and for each neighbor, we check if they are visited. But the code above has a bug in the way a_count and b_count are tracked. Because the initial node's color is 0, and a_count starts as 1, but when the neighbors are processed, their color is set and added to a_count or b_count. However, the code as written may not capture the counts correctly.\n\nWait, the code for the component processing is:\n\nInitially, node is added to the queue. Marked as visited. color is 0. a_count is incremented by 1 (since color is 0). Then, during BFS, for each neighbor, when added, their color is set to 1 (if current is 0). Then, if neighbor is not visited, we add to the queue and increment a_count or b_count based on their color. However, the initial code for a_count and b_count is:\n\nInitially, a_count is 0, then after setting color of node to 0, a_count +=1?\n\nWait, perhaps better to track during BFS:\n\nInitialize a_count and b_count as 0.\n\nWhen processing a node, check its color. For example:\n\ncurrent = queue.popleft()\n\nif color[current] is 0:\n\n   a_count +=1\n\nelse:\n\n   b_count +=1\n\nBut no, that's not correct. Because when you add a node to the queue, you have already set its color. So during BFS, for each node, when you process it, you can check its color and add to a_count or b_count.\n\nSo the code should be:\n\nfor each node from 1 to n:\n\n   if not visited:\n\n      queue = deque()\n\n      queue.append(node)\n\n      visited[node] = True\n\n      color[node] = 0\n\n      a_count = 0\n\n      b_count = 0\n\n      # initial node is color 0\n\n      a_count +=1\n\n      while queue not empty:\n\n          current = queue.popleft()\n\n          for neighbor in adj[current]:\n\n              if not visited[neighbor]:\n\n                  visited[neighbor] = True\n\n                  color[neighbor] = color[current] ^ 1\n\n                  if color[neighbor] == 0:\n\n                      a_count +=1\n\n                  else:\n\n                      b_count +=1\n\n                  queue.append(neighbor)\n\n              else:\n\n                  if color[neighbor] == color[current]:\n\n                      is_bipartite = False\n\n      components.append( (a_count, b_count) )\n\nBut this code may not capture the counts correctly. For example, the initial node is added to the queue. When popped, its neighbors are processed. But the initial a_count is 1 (the initial node's color is 0). However, during the processing of the current node, the code doesn't check its color again. So the a_count and b_count may not be accurate. Because the initial node's color is 0, but the code adds it to a_count once, but during the processing of the current node, the code doesn't check again.\n\nWait, no. The code adds the initial node to a_count once. Then, when the current node is popped from the queue, the code does not check its color again. So the a_count and b_count are not updated for the current node. So the code is wrong.\n\nSo the correct way is to track the a_count and b_count by checking the color of the current node when it is popped from the queue. For example:\n\nInitially, a_count and b_count are 0.\n\nWhen we add the node to the queue, we set its color to 0. Then, when it is popped from the queue, we check its color and increment a_count or b_count accordingly.\n\nBut how to do that?\n\nAlternative approach:\n\nWhen a node is added to the queue, we have already assigned its color. So, during the BFS, whenever we process a node (popping it from the queue), we can check its color and add to a_count or b_count.\n\nSo:\n\nfor each node from 1 to n:\n\n   if not visited:\n\n      queue = deque()\n\n      queue.append(node)\n\n      visited[node] = True\n\n      color[node] = 0\n\n      a_count = 0\n\n      b_count = 0\n\n      while queue not empty:\n\n          current = queue.popleft()\n\n          if color[current] == 0:\n\n              a_count +=1\n\n          else:\n\n              b_count +=1\n\n          for neighbor in adj[current]:\n\n              if not visited[neighbor]:\n\n                  visited[neighbor] = True\n\n                  color[neighbor] = color[current] ^ 1\n\n                  queue.append(neighbor)\n\n              else:\n\n                  if color[neighbor] == color[current]:\n\n                      is_bipartite = False\n\n      components.append( (a_count, b_count) )\n\nYes, this seems better. Because when the node is popped from the queue, we check its color and add to the count.\n\nBut what about the initial node? For example, the initial node is added to the queue. When popped, it's processed, and its color is checked, and added to a_count or b_count. Then, the neighbors are added. So this should correctly count all nodes in the component.\n\nBut during the processing of the current node, when we check its color, we add to a_count or b_count. So for the initial node, which is added to the queue, and then popped, processed, and counted.\n\nThis would correctly count the number of nodes in each color group.\n\nSo that's the correct way to compute a_count and b_count.\n\nOnce we have that, then for each component, the a_count and b_count are known.\n\nOnce the graph is determined to be bipartite, we check if any component has a_count + b_count >= 2. Because a_count + b_count is the size of the component.\n\nSo, for each component, if size (a + b) >= 2, then it's a component with at least two nodes.\n\nSo, in code:\n\nhas_large_component = False\n\nfor a, b in components:\n\n    if a + b >= 2:\n\n        has_large_component = True\n\n        break\n\nif has_large_component:\n\n    sum_w = 0\n\n    for a, b in components:\n\n        sum_w += a*(a-1)//2 + b*(b-1)//2\n\n    print(1, sum_w)\n\nelse:\n\n    # all components are single nodes\n\n    if n >=3:\n\n        print(3, n*(n-1)*(n-2)//6)\n\n    else:\n\n        # impossible, but according to the problem statement, this case is not present\n\n        # but what to output?\n\n        # For example, n=2, m=0. How to form a cycle? Impossible.\n\n       ",
    "response": "To solve this problem, we need to determine the minimum number of edges to add to an undirected graph to form a simple cycle of odd length, and also count the number of ways to achieve this. The solution involves checking if the graph is bipartite and then determining the necessary edges based on the structure of the graph.\n\n### Approach\n1. **Check Bipartiteness**: Use BFS to check if the graph is bipartite. If it is not bipartite, the graph already contains an odd-length cycle, so the answer is `0 1`.\n2. **Component Analysis**: If the graph is bipartite, analyze each connected component to determine the number of nodes in each partition.\n3. **Determine Minimum Edges**:\n   - If there exists at least one component with more than one node, the minimum edges required is `1`, and the number of ways is calculated based on possible edges within the same partition of each component.\n   - If all components are isolated nodes (each with only one node), then forming a triangle (cycle of length 3) requires adding 3 edges, and the number of ways is determined by combinations of nodes.\n\n### Solution Code\n```python\nimport sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n    \n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u = int(input[idx])\n        idx += 1\n        v = int(input[idx])\n        idx += 1\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    visited = [False] * (n + 1)\n    color = [-1] * (n + 1)\n    is_bipartite = True\n    components = []\n    \n    for node in range(1, n + 1):\n        if not visited[node]:\n            queue = deque()\n            queue.append(node)\n            visited[node] = True\n            color[node] = 0\n            a_count = 0\n            b_count = 0\n            while queue:\n                current = queue.popleft()\n                if color[current] == 0:\n                    a_count += 1\n                else:\n                    b_count += 1\n                for neighbor in adj[current]:\n                    if not visited[neighbor]:\n                        visited[neighbor] = True\n                        color[neighbor] = color[current] ^ 1\n                        queue.append(neighbor)\n                    else:\n                        if color[neighbor] == color[current]:\n                            is_bipartite = False\n            components.append((a_count, b_count))\n    \n    if not is_bipartite:\n        print(\"0 1\")\n        return\n    \n    has_large_component = False\n    for a, b in components:\n        if a + b >= 2:\n            has_large_component = True\n            break\n    \n    if has_large_component:\n        sum_w = 0\n        for a, b in components:\n            sum_w += a * (a - 1) // 2 + b * (b - 1) // 2\n        print(f\"1 {sum_w}\")\n    else:\n        if n >= 3:\n            ways = n * (n - 1) * (n - 2) // 6\n            print(f\"3 {ways}\")\n        else:\n            print(\"0 0\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Bipartiteness Check**: Using BFS, we check if the graph can be colored using two colors such that no two adjacent nodes share the same color. If any conflict is found during this check, the graph is not bipartite.\n- **Component Analysis**: For each connected component, we count the number of nodes in each partition (color group).\n- **Edge Calculation**: If there's at least one component with more than one node, we calculate the number of ways to add edges within the same partition to form an odd-length cycle. If all components are single nodes, we compute the number of ways to form a triangle (cycle of length 3) using combinations of nodes.\n\nThis approach efficiently determines the minimum edges required and the number of ways to achieve the desired cycle, leveraging graph properties and combinatorial calculations.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n    \n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u = int(input[idx])\n        idx += 1\n        v = int(input[idx])\n        idx += 1\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    visited = [False] * (n + 1)\n    color = [-1] * (n + 1)\n    is_bipartite = True\n    components = []\n    \n    for node in range(1, n + 1):\n        if not visited[node]:\n            queue = deque()\n            queue.append(node)\n            visited[node] = True\n            color[node] = 0\n            a_count = 0\n            b_count = 0\n            while queue:\n                current = queue.popleft()\n                if color[current] == 0:\n                    a_count += 1\n                else:\n                    b_count += 1\n                for neighbor in adj[current]:\n                    if not visited[neighbor]:\n                        visited[neighbor] = True\n                        color[neighbor] = color[current] ^ 1\n                        queue.append(neighbor)\n                    else:\n                        if color[neighbor] == color[current]:\n                            is_bipartite = False\n            components.append((a_count, b_count))\n    \n    if not is_bipartite:\n        print(\"0 1\")\n        return\n    \n    has_large_component = False\n    for a, b in components:\n        if a + b >= 2:\n            has_large_component = True\n            break\n    \n    if has_large_component:\n        sum_w = 0\n        for a, b in components:\n            sum_w += a * (a - 1) // 2 + b * (b - 1) // 2\n        print(f\"1 {sum_w}\")\n    else:\n        if n >= 3:\n            ways = n * (n - 1) * (n - 2) // 6\n            print(f\"3 {ways}\")\n        else:\n            print(\"0 0\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 578,
        "completion_token_count": 916,
        "thoughts_token_count": 8192
    }
}