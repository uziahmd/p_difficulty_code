{
    "start": 1758313550.2185357,
    "end": 1758313599.5233467,
    "start-formatted": "2025-09-20 05:25 KST",
    "end-formatted": "2025-09-20 05:26 KST",
    "gpu": 2,
    "pid": 6,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\nOkay, I need to solve this programming problem. Let's read the problem statement carefully.\n\nSo, the task is to find two vouchers such that their durations add up exactly to x, and they don't overlap. And we need the minimal total cost of such a pair. If there's no such pair, output -1.\n\nFirst, let's understand the problem. Each voucher has a duration of ri - li + 1. So for each voucher, we can calculate its duration. Then, we need two vouchers where the sum of their durations is x, and they don't overlap. Also, the two vouchers must be different (i≠j).\n\nThe challenge is to find such pairs efficiently given the constraints on n (up to 2e5). A brute-force approach checking all pairs would be O(n²), which is way too slow for n=2e5. So we need an efficient method.\n\nLet me think about how to approach this. Let's break it down into steps:\n\nStep 1: For each voucher, compute its duration. Then, for each voucher with duration d, we need another voucher with duration x - d. So, for each voucher i with duration d, look for vouchers j with duration (x - d), and check if they don't overlap.\n\nBut how do we efficiently find those j's?\n\nMoreover, for each possible d, we need to have vouchers of that duration. So maybe we can group vouchers by their duration. Then, for each voucher with duration d, check if there exists vouchers with duration (x - d) that don't overlap with it.\n\nBut even then, for each voucher, how do we find the minimum cost voucher in the other group that doesn't overlap?\n\nHmm. Let's think about the structure. For example, suppose we have a voucher A with duration d, and we need to find a voucher B with duration x-d. The vouchers B can be either before A (r_B < l_A) or after A (r_A < l_B). So for each voucher A, we need to find the minimal cost voucher B in the x-d group that starts after A ends, or ends before A starts.\n\nBut how do we do that quickly?\n\nAn idea: For each possible duration, pre-process the vouchers in a way that allows us to query the minimum cost for vouchers that end before a certain day, or start after a certain day.\n\nFor example, for vouchers of duration t, we can sort them by their end day, and for each possible l, find the earliest end day that is less than l. Similarly, sort them by start day and find the earliest start day that is greater than r.\n\nWait, but for a given voucher A (with duration d, say), we need to find vouchers of duration (x-d) that are completely before A (so their end day is <= A's start day - 1) or completely after A (their start day >= A's end day + 1).\n\nSo for each voucher A, we can check two possibilities:\n\n1. Find a voucher B of duration (x - d) that ends before A starts. So B's end day < A's start day.\n\n2. Find a voucher B of duration (x - d) that starts after A ends. So B's start day > A's end day.\n\nIf we can find the minimal cost in each of these two scenarios for B, then we can take the minimum between them and update our overall answer.\n\nSo the plan is:\n\n- Preprocess for each duration t, a sorted list of vouchers by their end day, and also a sorted list by their start day. Then, for each voucher A with duration d, we look for vouchers of duration (x-d) and check these two cases.\n\nBut how to efficiently find the minimal cost in those two cases?\n\nFor example, for case 1: vouchers of duration t = x -d, and end day < l_A.\n\nWe can sort all vouchers of duration t by their end day. Then, for a given l_A, find the maximum end day that is less than l_A. Then, among all such vouchers, find the one with minimal cost.\n\nWait, but how do we find the minimal cost for vouchers ending before l_A?\n\nIf we have a sorted list of vouchers for duration t, sorted by end day. Then, for each voucher in this list, we can have a prefix minimum array. So for each position in the sorted list, we know the minimal cost up to that point. Then, for a given l_A, we can perform a binary search to find the largest end day that is less than l_A, and then get the corresponding prefix minimum.\n\nSimilarly, for case 2: vouchers of duration t = x -d, and start day > r_A. We can sort the vouchers of duration t by their start day, and for each voucher, have a suffix minimum array. Then, for a given r_A, find the first start day that is larger than r_A",
    "response": "To solve this problem, we need to find two non-overlapping vouchers whose combined duration exactly matches a given value `x` and whose total cost is minimized. The solution involves efficiently checking for valid voucher pairs using preprocessing and binary search.\n\n### Approach\n1. **Preprocessing by Duration**: Group vouchers by their duration. This allows us to quickly access all vouchers of a specific duration when needed.\n2. **Sorting and Prefix/Suffix Minimum Arrays**: For each group of vouchers with the same duration, sort them by their end day and start day respectively. Additionally, maintain prefix minimum arrays for end-sorted lists and suffix minimum arrays for start-sorted lists to quickly find the minimum cost vouchers that meet specific criteria.\n3. **Binary Search for Efficient Lookup**: For each voucher, determine if there exists another voucher of the required duration that starts after or ends before the current voucher. Use binary search to efficiently find these vouchers and check their costs.\n\n### Solution Code\n```python\nimport sys\nimport bisect\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n\n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n\n    from collections import defaultdict\n\n    # Group vouchers by their duration\n    duration_dict = defaultdict(list)\n    for l, r, cost, d in vouchers:\n        duration_dict[d].append((l, r, cost))\n\n    # Preprocess each duration group: sorted by end, and sorted by start\n    # Also, for each sorted by end, create a prefix min array\n    # For each sorted by start, create a suffix min array\n    processed = dict()\n    for d in duration_dict:\n        lst = duration_dict[d]\n        # Sort by end\n        sorted_by_end = sorted(lst, key=lambda x: x[1])\n        prefix_min = []\n        min_cost = float('inf')\n        for l, r, cost in sorted_by_end:\n            if cost < min_cost:\n                min_cost = cost\n            prefix_min.append(min_cost)\n        # Sort by start\n        sorted_by_start = sorted(lst, key=lambda x: x[0])\n        suffix_min = [0] * len(sorted_by_start)\n        min_cost = float('inf')\n        for i in range(len(sorted_by_start)-1, -1, -1):\n            l, r, cost = sorted_by_start[i]\n            if cost < min_cost:\n                min_cost = cost\n            suffix_min[i] = min_cost\n        processed[d] = (sorted_by_end, prefix_min, sorted_by_start, suffix_min)\n\n    min_total = float('inf')\n\n    for l1, r1, cost1, d1 in vouchers:\n        target_d = x - d1\n        if target_d not in processed:\n            continue\n        # Check for vouchers with duration target_d\n        sorted_by_end, prefix_min, sorted_by_start, suffix_min = processed[target_d]\n\n        # Case 1: voucher ends before l1\n        # Find the largest end <= l1 - 1\n        # Binary search in sorted_by_end's end\n        ends = [r for (l, r, c) in sorted_by_end]\n        pos = bisect.bisect_right(ends, l1 - 1) - 1\n        if pos >= 0:\n            current_min = prefix_min[pos]\n            min_total = min(min_total, cost1 + current_min)\n\n        # Case 2: voucher starts after r1\n        # Find the first start > r1\n        starts = [l for (l, r, c) in sorted_by_start]\n        pos = bisect.bisect_right(starts, r1)\n        if pos < len(starts):\n            current_min = suffix_min[pos]\n            min_total = min(min_total, cost1 + current_min)\n\n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Grouping by Duration**: Vouchers are grouped by their duration to facilitate quick lookups when checking for pairs.\n- **Sorting and Min Arrays**: Each group of vouchers is sorted by end day and start day. Prefix and suffix minimum arrays are built to quickly retrieve the minimum cost for vouchers ending before or starting after a given day.\n- **Binary Search**: For each voucher, binary search is used to efficiently find valid non-overlapping vouchers of the required duration, ensuring the solution handles large inputs efficiently.\n\nThis approach ensures that we efficiently check all possible valid pairs while maintaining a time complexity that is feasible for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport bisect\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n\n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n\n    from collections import defaultdict\n\n    # Group vouchers by their duration\n    duration_dict = defaultdict(list)\n    for l, r, cost, d in vouchers:\n        duration_dict[d].append((l, r, cost))\n\n    # Preprocess each duration group: sorted by end, and sorted by start\n    # Also, for each sorted by end, create a prefix min array\n    # For each sorted by start, create a suffix min array\n    processed = dict()\n    for d in duration_dict:\n        lst = duration_dict[d]\n        # Sort by end\n        sorted_by_end = sorted(lst, key=lambda x: x[1])\n        prefix_min = []\n        min_cost = float('inf')\n        for l, r, cost in sorted_by_end:\n            if cost < min_cost:\n                min_cost = cost\n            prefix_min.append(min_cost)\n        # Sort by start\n        sorted_by_start = sorted(lst, key=lambda x: x[0])\n        suffix_min = [0] * len(sorted_by_start)\n        min_cost = float('inf')\n        for i in range(len(sorted_by_start)-1, -1, -1):\n            l, r, cost = sorted_by_start[i]\n            if cost < min_cost:\n                min_cost = cost\n            suffix_min[i] = min_cost\n        processed[d] = (sorted_by_end, prefix_min, sorted_by_start, suffix_min)\n\n    min_total = float('inf')\n\n    for l1, r1, cost1, d1 in vouchers:\n        target_d = x - d1\n        if target_d not in processed:\n            continue\n        # Check for vouchers with duration target_d\n        sorted_by_end, prefix_min, sorted_by_start, suffix_min = processed[target_d]\n\n        # Case 1: voucher ends before l1\n        # Find the largest end <= l1 - 1\n        # Binary search in sorted_by_end's end\n        ends = [r for (l, r, c) in sorted_by_end]\n        pos = bisect.bisect_right(ends, l1 - 1) - 1\n        if pos >= 0:\n            current_min = prefix_min[pos]\n            min_total = min(min_total, cost1 + current_min)\n\n        # Case 2: voucher starts after r1\n        # Find the first start > r1\n        starts = [l for (l, r, c) in sorted_by_start]\n        pos = bisect.bisect_right(starts, r1)\n        if pos < len(starts):\n            current_min = suffix_min[pos]\n            min_total = min(min_total, cost1 + current_min)\n\n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 740,
        "completion_token_count": 1041,
        "thoughts_token_count": 1024
    }
}