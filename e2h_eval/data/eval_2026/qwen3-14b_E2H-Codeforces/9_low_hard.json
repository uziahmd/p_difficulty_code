{
    "start": 1758009108.2307806,
    "end": 1758009493.512592,
    "start-formatted": "2025-09-16 16:51 KST",
    "end-formatted": "2025-09-16 16:58 KST",
    "gpu": 2,
    "pid": 9,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Selling Souvenirs\n\nAfter several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.This morning, as usual, Petya will come to the market. Petya has n different souvenirs to sell; ith souvenir is characterised by its weight wi and cost ci. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than m, and total cost is maximum possible.Help Petya to determine maximum possible total cost.\n\n## Input\nThe first line contains two integers n and m (1 ≤ n ≤ 100000, 1 ≤ m ≤ 300000) — the number of Petya's souvenirs and total weight that he can carry to the market.Then n lines follow. ith line contains two integers wi and ci (1 ≤ wi ≤ 3, 1 ≤ ci ≤ 109) — the weight and the cost of ith souvenir.\n\n## Output\nPrint one number — maximum possible total cost of souvenirs that Petya can carry to the market.\n\n## Example\n### Input\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\n### Output\n['0', '3', '10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\nOkay, let's tackle this problem. So, the task is to find the maximum possible total cost of souvenirs that Petya can carry, given that each souvenir has a weight (1, 2, or 3) and a cost. The constraints are n up to 1e5 and m up to 3e5. Hmm, so a standard knapsack approach would be too slow here because for n=1e5 and m=3e5, the O(nm) solution would be way too slow. So we need a smarter approach.\n\nLet me think. Since the weights are limited to 1, 2, or 3, maybe we can handle each weight category separately. For example, for items of weight 1, we can take as many as possible (sorted by cost descending), same for weight 2 and 3. But how do we combine them optimally?\n\nWait, but there's a possibility that taking some combination of items with different weights gives a better total than just taking the highest value items in each category. For example, maybe a weight 3 item with high cost is better than two weight 2 items. But how to balance this?\n\nSo here's an idea: group all items by their weight. Then for each group, sort them in descending order of cost. Then, for each weight group, compute a prefix sum array. For example, for weight 1 items, we can have an array where prefix_sum[i] is the maximum cost when taking i items of weight 1. Similarly for weight 2 and 3.\n\nOnce we have these prefix sums, the problem reduces to choosing how many items of each weight to take such that the total weight is <= m, and the sum of their costs is maximized.\n\nBut how do we combine these choices efficiently?\n\nLet me think about the possible combinations. Let's say we have:\n\n- a items of weight 1 (total weight a * 1)\n- b items of weight 2 (total weight b * 2)\n- c items of weight 3 (total weight c * 3)\n\nThe total weight is a + 2b + 3c ≤ m. And we want to maximize the sum of their prefix sums.\n\nBut trying all possible combinations of a, b, c would be too slow. However, since the weights are small (only 1, 2, 3), perhaps we can find a way to iterate through possible values of one variable and compute the others optimally.\n\nFor example, let's consider that for each possible number of weight 3 items (c), we can calculate the remaining weight and then decide how to best use the weight 1 and 2 items. But even that might be too slow if c is up to m/3, which could be 1e5. But maybe with m up to 3e5, that's manageable?\n\nAlternatively, since the weight is small, perhaps we can precompute the best possible for weight 1 and 2 items given a certain total weight. Let's think about it.\n\nAnother approach: for each possible number of weight 3 items, we can compute the maximum possible sum for the remaining weight using weight 1 and 2 items. Let's see.\n\nLet me outline the steps:\n\n1. Separate the items into three groups: w=1, w=2, w=3. Sort each group in descending order of cost. Compute prefix sums for each group. For example, for weight 1, prefix_1[i] = sum of first i items. Similarly for prefix_2 and prefix_3.\n\n2. Now, for each possible number of weight 3 items (let's say c), which can range from 0 to min(k3, m//3), where k3 is the number of weight 3 items available. For each c, the total weight taken by these items is 3*c. Then, the remaining weight is rem = m - 3*c. We need to find the best combination of weight 1 and 2 items that fit into rem.\n\nBut how to compute the best combination of weight 1 and 2 items for a given rem?\n\nThis seems like a classic unbounded knapsack problem, but with only two types of items. Wait, but the items are sorted, and we can take any number of them (but up to the available count). However, since the items are sorted, taking as many as possible of the highest value items is optimal. But since we can take any combination, perhaps for the weight 1 and 2 items, we can precompute for each possible weight limit, the maximum value.\n\nBut how to compute this efficiently?\n\nLet me think. Suppose we have the prefix sums for weight 1 and 2. Let's denote:\n\nmax_12(w) = maximum value achievable with weight w using weight 1 and 2 items.\n\nWe can compute this for all possible w up to m.\n\nBut how",
    "response": "\n\nTo solve this problem, we need to determine the maximum possible total cost of souvenirs that Petya can carry given a weight limit. Each souvenir has a weight (1, 2, or 3) and a cost. The challenge is to efficiently combine these items to maximize the total cost without exceeding the weight limit.\n\n### Approach\n1. **Group Items by Weight**: Separate the souvenirs into three groups based on their weights (1, 2, and 3).\n2. **Sort and Compute Prefix Sums**: For each group, sort the items by cost in descending order and compute prefix sums to quickly determine the maximum value for taking the first `k` items.\n3. **Iterate Over Possible Counts of Weight 3 Items**: For each possible count of weight 3 items, calculate the remaining weight capacity and then determine the optimal combination of weight 1 and 2 items that fit within this remaining capacity.\n4. **Use Two-Pointer Technique for Weight 1 and 2 Items**: For each remaining capacity after accounting for weight 3 items, use a two-pointer approach to find the optimal combination of weight 1 and 2 items that maximizes the total value.\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n    \n    w1 = []\n    w2 = []\n    w3 = []\n    \n    for _ in range(n):\n        wi = int(input[idx])\n        idx += 1\n        ci = int(input[idx])\n        idx += 1\n        if wi == 1:\n            w1.append(ci)\n        elif wi == 2:\n            w2.append(ci)\n        else:\n            w3.append(ci)\n    \n    # Sort and compute prefix sums\n    w1.sort(reverse=True)\n    w2.sort(reverse=True)\n    w3.sort(reverse=True)\n    \n    # Compute prefix sums for each group\n    prefix1 = [0]\n    for c in w1:\n        prefix1.append(prefix1[-1] + c)\n    \n    prefix2 = [0]\n    for c in w2:\n        prefix2.append(prefix2[-1] + c)\n    \n    prefix3 = [0]\n    for c in w3:\n        prefix3.append(prefix3[-1] + c)\n    \n    max_total = 0\n    \n    # Try all possible number of weight 3 items\n    max_c = min(len(w3), m // 3)\n    for c in range(0, max_c + 1):\n        weight_used = 3 * c\n        if weight_used > m:\n            continue\n        remaining = m - weight_used\n        # Now find best combination of w1 and w2 with total weight <= remaining\n        # Using two pointers\n        i = len(prefix1) - 1\n        j = len(prefix2) - 1\n        best = 0\n        while i >= 0 and j >= 0:\n            weight = i + 2 * j\n            if weight <= remaining:\n                best = max(best, prefix1[i] + prefix2[j])\n                i -= 1\n            else:\n                j -= 1\n        # Also check cases where i=0 or j=0\n        # Check all possible i for j=0\n        temp = 0\n        for i in range(len(prefix1)):\n            if i <= remaining:\n                temp = max(temp, prefix1[i])\n        best = max(best, temp)\n        # Check all possible j for i=0\n        temp = 0\n        for j in range(len(prefix2)):\n            if 2 * j <= remaining:\n                temp = max(temp, prefix2[j])\n        best = max(best, temp)\n        # Also check combinations where i and j are not both at extremes\n        # But the two pointers should have covered it\n        max_total = max(max_total, best + prefix3[c])\n    \n    print(max_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Grouping and Sorting**: The souvenirs are grouped by their weights and sorted by cost in descending order to prioritize higher-value items.\n2. **Prefix Sums**: Prefix sums for each group allow quick calculation of the total value for taking the first `k` items of each weight.\n3. **Iterating Over Weight 3 Items**: For each possible count of weight 3 items, the remaining weight capacity is calculated, and the optimal combination of weight 1 and 2 items is determined using a two-pointer technique to ensure efficiency.\n4. **Two-Pointer Technique**: This technique efficiently explores combinations of weight 1 and 2 items to maximize the value within the remaining weight capacity, ensuring an optimal solution without excessive computation.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n    \n    w1 = []\n    w2 = []\n    w3 = []\n    \n    for _ in range(n):\n        wi = int(input[idx])\n        idx += 1\n        ci = int(input[idx])\n        idx += 1\n        if wi == 1:\n            w1.append(ci)\n        elif wi == 2:\n            w2.append(ci)\n        else:\n            w3.append(ci)\n    \n    # Sort and compute prefix sums\n    w1.sort(reverse=True)\n    w2.sort(reverse=True)\n    w3.sort(reverse=True)\n    \n    # Compute prefix sums for each group\n    prefix1 = [0]\n    for c in w1:\n        prefix1.append(prefix1[-1] + c)\n    \n    prefix2 = [0]\n    for c in w2:\n        prefix2.append(prefix2[-1] + c)\n    \n    prefix3 = [0]\n    for c in w3:\n        prefix3.append(prefix3[-1] + c)\n    \n    max_total = 0\n    \n    # Try all possible number of weight 3 items\n    max_c = min(len(w3), m // 3)\n    for c in range(0, max_c + 1):\n        weight_used = 3 * c\n        if weight_used > m:\n            continue\n        remaining = m - weight_used\n        # Now find best combination of w1 and w2 with total weight <= remaining\n        # Using two pointers\n        i = len(prefix1) - 1\n        j = len(prefix2) - 1\n        best = 0\n        while i >= 0 and j >= 0:\n            weight = i + 2 * j\n            if weight <= remaining:\n                best = max(best, prefix1[i] + prefix2[j])\n                i -= 1\n            else:\n                j -= 1\n        # Also check cases where i=0 or j=0\n        # Check all possible i for j=0\n        temp = 0\n        for i in range(len(prefix1)):\n            if i <= remaining:\n                temp = max(temp, prefix1[i])\n        best = max(best, temp)\n        # Check all possible j for i=0\n        temp = 0\n        for j in range(len(prefix2)):\n            if 2 * j <= remaining:\n                temp = max(temp, prefix2[j])\n        best = max(best, temp)\n        # Also check combinations where i and j are not both at extremes\n        # But the two pointers should have covered it\n        max_total = max(max_total, best + prefix3[c])\n    \n    print(max_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 481,
        "completion_token_count": 1025,
        "thoughts_token_count": 1023
    }
}