{
    "start": 1758309451.2237818,
    "end": 1758309501.2792501,
    "start-formatted": "2025-09-20 04:17 KST",
    "end-formatted": "2025-09-20 04:18 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\nOkay, let's tackle this problem. Hmm, the task is to find the minimum number of edges to add to form an odd-length cycle, and the number of ways to do that. Let me think.\n\nFirst, I remember that a graph is bipartite if and only if it doesn't contain any odd-length cycles. So, if the original graph already has an odd-length cycle, then t is 0 and w is 1? Wait, no. Because the problem says we need to form a cycle of odd length. So if the graph already has such a cycle, then t is zero, and the number of ways is the number of existing such cycles? Wait, no. Because the problem says that the answer requires adding edges to form such a cycle. But if there's already one, then we don't need to add any edges. However, the question says \"the minimum number of edges that must be added to form a simple cycle of an odd length\". So if the graph already contains such a cycle, then t is 0. And for w, how many ways can you add zero edges to get such a cycle? Well, it's the number of existing odd-length cycles? But that's not feasible because counting all possible cycles is computationally expensive, especially for large graphs. Wait, but maybe the problem is not about existing cycles. Let me re-read the problem statement.\n\nThe problem says that we need to find the minimum number of edges to add so that the graph contains at least one simple odd-length cycle. Oh right! So if the graph already contains such a cycle, then t is zero. And the number of ways is 1? Or maybe the number of ways to add zero edges (i.e., the number of existing such cycles?), but that's not clear. Wait, the problem says: \"the number of ways to add t edges in order to form a cycle of an odd length...\". So when t is zero, the way is to not add any edges, but how many such ways are there? Well, since the problem says that two ways are considered equal if they have the same set of added edges. So if there's already an odd cycle, then adding zero edges is one way. But if there are multiple existing odd cycles, does that count as multiple ways? No, because the way is determined by the set of added edges. Since adding zero edges is a single way. So regardless of how many existing cycles there are, if the graph already contains at least one, then w is 1. Because the way is to add no edges. Wait, but the problem says \"the number of ways to add t edges in order to form a cycle of an odd length\". So if the graph already has such a cycle, then the answer is t=0 and w=1? Because there's exactly one way to add zero edges. But that's not correct. For example, suppose the graph has two different odd cycles. Then, the way to add zero edges would still be one way. Because the way is about the edges added, not about which cycle is formed. So the answer for w in this case is 1. So the first thing is to check whether the graph already contains an odd cycle. If yes, then t is 0, w is 1. Otherwise, we need to find the minimal t and the number of ways.\n\nSo the first step is to check if the graph is bipartite. If it's not bipartite, then there's already an odd cycle. So t=0 and w=1. But if it is bipartite, then we need to add edges to make it non-bipartite, i.e., introduce an odd cycle.\n\nNow, for a bipartite graph, how can we add edges to create an odd cycle? Well, adding an edge between two nodes in the same partition of a bipartition would create an odd cycle. Because in a bipartite graph, all cycles are even-length. Adding an edge between two nodes in the same partition would create a cycle of length (path length from u to v in the bipartition) + 1. Since the path from u to v in a bipartition is even length (since bipartitions are split into two sets, and each edge goes between them). So adding an edge between two nodes in the same partition would create a cycle of odd length.\n\nBut wait, the graph might be disconnected, and each connected component is bipartite. So for each connected component, we can perform a bipartition. Now, the problem reduces to: find the minimal number of edges to add to create an odd cycle. Which is equivalent to adding an edge within a single bipartition of a connected component. Because adding such an edge would create an odd-length cycle.\n\nSo, for each connected component, we can compute the size of the two partitions. Let's say the component has partitions A and B with sizes a and b. Then,",
    "response": "To solve this problem, we need to determine the minimum number of edges to add to a given undirected graph to form an odd-length cycle and the number of ways to achieve this. The solution involves checking if the graph is bipartite and then determining the necessary edges to introduce an odd-length cycle if it isn't.\n\n### Approach\n1. **Check Bipartiteness**: Use BFS to check if each connected component of the graph is bipartite. If any component is not bipartite, the graph already contains an odd-length cycle, so the answer is `0 1`.\n2. **Bipartition Sizes**: For each bipartite component, calculate the sizes of the two partitions.\n3. **Determine Minimum Edges**: For each bipartite component, the minimum number of edges needed to create an odd-length cycle is 1. This is done by adding an edge between two nodes in the same partition.\n4. **Count Ways**: The number of ways to add such edges is calculated by considering all possible pairs within each partition and summing the combinations.\n\n### Solution Code\n```python\nimport sys\nfrom collections import deque, defaultdict\n\ndef main():\n    input = sys.stdin.read().split('\\n')\n    idx = 0\n    n, m = map(int, input[idx].split())\n    idx += 1\n    edges = []\n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b = map(int, input[idx].split())\n        idx += 1\n        edges.append((a-1, b-1))\n        adj[a-1].append(b-1)\n        adj[b-1].append(a-1)\n    \n    color = [-1] * n\n    is_bipartite = True\n    components = []\n    \n    for i in range(n):\n        if color[i] == -1:\n            q = deque()\n            q.append(i)\n            color[i] = 0\n            count = [0, 0]\n            count[0] += 1\n            while q:\n                u = q.popleft()\n                for v in adj[u]:\n                    if color[v] == -1:\n                        color[v] = color[u] ^ 1\n                        count[color[v]] += 1\n                        q.append(v)\n                    else:\n                        if color[v] == color[u]:\n                            is_bipartite = False\n            components.append(count)\n    \n    if not is_bipartite:\n        print(\"0 1\")\n        return\n    \n    min_t = 1\n    total_ways = 0\n    \n    for a, b in components:\n        ways = (a * (a - 1) // 2) + (b * (b - 1) // 2)\n        total_ways += ways\n    \n    print(f\"{min_t} {total_ways}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into the number of vertices `n`, edges `m`, and the adjacency list `adj`.\n2. **Bipartite Check**: Using BFS, each connected component is checked for bipartiteness. If any component is not bipartite, it means there's already an odd-length cycle, so the result is `0 1`.\n3. **Component Analysis**: For each bipartite component, the sizes of the two partitions are stored.\n4. **Calculate Ways**: For each bipartite component, the number of ways to add an edge within the same partition is calculated using combinations. The total number of ways across all components is summed up.\n5. **Output Result**: The minimum number of edges needed is always 1 for a bipartite graph, and the total number of ways is printed.\n\nThis approach ensures that we efficiently determine the minimum edges required and the number of ways to achieve the desired cycle, leveraging the properties of bipartite graphs.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque, defaultdict\n\ndef main():\n    input = sys.stdin.read().split('\\n')\n    idx = 0\n    n, m = map(int, input[idx].split())\n    idx += 1\n    edges = []\n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b = map(int, input[idx].split())\n        idx += 1\n        edges.append((a-1, b-1))\n        adj[a-1].append(b-1)\n        adj[b-1].append(a-1)\n    \n    color = [-1] * n\n    is_bipartite = True\n    components = []\n    \n    for i in range(n):\n        if color[i] == -1:\n            q = deque()\n            q.append(i)\n            color[i] = 0\n            count = [0, 0]\n            count[0] += 1\n            while q:\n                u = q.popleft()\n                for v in adj[u]:\n                    if color[v] == -1:\n                        color[v] = color[u] ^ 1\n                        count[color[v]] += 1\n                        q.append(v)\n                    else:\n                        if color[v] == color[u]:\n                            is_bipartite = False\n            components.append(count)\n    \n    if not is_bipartite:\n        print(\"0 1\")\n        return\n    \n    min_t = 1\n    total_ways = 0\n    \n    for a, b in components:\n        ways = (a * (a - 1) // 2) + (b * (b - 1) // 2)\n        total_ways += ways\n    \n    print(f\"{min_t} {total_ways}\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 578,
        "completion_token_count": 824,
        "thoughts_token_count": 1024
    }
}