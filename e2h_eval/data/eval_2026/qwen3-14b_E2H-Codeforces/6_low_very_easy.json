{
    "start": 1758008325.8805645,
    "end": 1758008512.284393,
    "start-formatted": "2025-09-16 16:38 KST",
    "end-formatted": "2025-09-16 16:41 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\nOkay, let's tackle this problem. So, the task is to find two non-overlapping vouchers whose total duration equals exactly x, and their combined cost is minimized. If there's no such pair, return -1.\n\nFirst, I need to understand the problem thoroughly. Let's break down the requirements:\n\nEach voucher has a departure day (li), return day (ri), and cost. The duration is ri - li + 1. We need two vouchers i and j (i≠j) such that their durations add up to x. Also, they must not overlap. Non-overlapping means either the first ends before the second starts (ri < lj) or the second ends before the first starts (rj < li).\n\nThe challenge is to find such pairs efficiently given the constraints of n up to 2e5. A brute-force approach checking all pairs would be O(n²), which is way too slow for n=2e5. So we need an efficient approach.\n\nLet me think about how to approach this. For each voucher, we can check if there exists another voucher that doesn't overlap with it and has a duration of (x - duration of current voucher). But how do we find that efficiently?\n\nLet me think about the steps:\n\n1. Preprocess all vouchers by their duration. For each possible duration d, store the minimum cost of vouchers with that duration. Also, maybe store the earliest ending day or latest starting day for each duration to help with non-overlapping checks?\n\nWait, but for each voucher with duration d, we need to find a voucher with duration (x - d) that starts after the first ends, or ends before the first starts.\n\nBut how to find that?\n\nAlternative idea: For each voucher, check for vouchers of duration (x - d) that end before li (so that they don't overlap), and also check for those that start after ri (so that they don't overlap). Then take the minimum cost in those cases.\n\nBut how to find those quickly?\n\nMaybe we can precompute for each possible duration, the minimum cost of vouchers that end before a certain day, and the minimum cost of vouchers that start after a certain day.\n\nBut how to structure that.\n\nLet me think about the following approach:\n\n- For each voucher, compute its duration d = ri - li + 1.\n\n- For each voucher, we need to find another voucher with duration (x - d), and that does not overlap with it.\n\nSo for each voucher i with duration d, we need to find vouchers j with duration (x - d) where either rj < li or lj > ri.\n\nSo for each voucher i, we can look for vouchers j with duration (x - d) that end before li (so they are completely before i) or start after ri (completely after i).\n\nIf we can find the minimum cost among these vouchers, then for each voucher i, we can compute the sum of its cost and the min cost found, and track the overall minimum.\n\nThe key is to find for each voucher i, the minimal cost of vouchers with duration (x - d_i) that are either before i or after i.\n\nBut how to query that efficiently.\n\nLet me think about data structures. Let's say we have for each duration k, two structures:\n\n- A sorted list of end days (ri) for vouchers with duration k, along with their costs. Then, for a given li, we can find the minimal cost among vouchers with duration k that end before li. Similarly, for start days (lj), find the minimal cost of vouchers with duration k that start after ri.\n\nBut how to do that.\n\nAlternatively, for each duration k, we can pre-process two arrays:\n\n- One sorted by end time, and for each end time, keep track of the minimum cost up to that point. So that for a given li, we can find the earliest end time <= li-1, and get the minimum cost up to that point.\n\nSimilarly, for the start times: sorted by start time, and for each start time, keep track of the minimum cost from that point onward. So for a given ri, we can find the earliest start time >= ri+1, and get the minimum cost from that point.\n\nWait, but how to handle that.\n\nFor example, for vouchers of duration k, sorted by their end time. For a given li, we need to find all vouchers with end time < li. Among those, the minimal cost. Similarly, for vouchers with start time > ri, minimal cost.\n\nSo for each duration k, we can have two structures:\n\n- A list of vouchers sorted by end time. Then, for a given li, we can perform a binary search to find the largest end time less than li. Then, for all vouchers up to that point, we can have a prefix minimum array. So that we can quickly find the minimum cost for vouchers with end time < li.\n\nSimilarly, for the other case: vouchers sorted by start time, with a suffix",
    "response": "\n\nTo solve this problem, we need to find two non-overlapping vouchers whose combined duration exactly matches a given value `x` and whose total cost is minimized. If no such pair exists, we should return -1.\n\n### Approach\n1. **Preprocessing by Duration**: We first categorize all vouchers by their duration. This helps in efficiently checking for pairs of vouchers that sum up to the required duration `x`.\n2. **Binary Search for Efficient Lookup**: For each voucher, we check if there exists another voucher with the complementary duration (i.e., `x - duration`). To ensure these vouchers do not overlap, we use binary search on sorted lists of start and end times.\n3. **Prefix and Suffix Minimum Arrays**: For each duration, we maintain sorted lists of end times and start times along with prefix and suffix minimum cost arrays. This allows us to quickly find the minimum cost of vouchers that end before a certain day or start after a certain day.\n\n### Solution Code\n```python\nimport sys\nimport bisect\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n    \n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n    \n    from collections import defaultdict\n\n    # Preprocess: group vouchers by duration\n    duration_dict = defaultdict(list)\n    for l, r, cost, d in vouchers:\n        duration_dict[d].append((l, r, cost))\n    \n    # For each duration, sort the vouchers by end time and start time\n    # Also, create prefix min for end sorted list and suffix min for start sorted list\n    preprocessed = dict()\n    for d in duration_dict:\n        lst = duration_dict[d]\n        # Sort by end time\n        sorted_by_end = sorted(lst, key=lambda x: x[1])\n        # Create prefix min array\n        prefix_min_end = []\n        min_cost = float('inf')\n        for l, r, cost in sorted_by_end:\n            if cost < min_cost:\n                min_cost = cost\n            prefix_min_end.append(min_cost)\n        # Sort by start time\n        sorted_by_start = sorted(lst, key=lambda x: x[0])\n        # Create suffix min array\n        suffix_min_start = [0] * len(sorted_by_start)\n        min_cost = float('inf')\n        for i in range(len(sorted_by_start)-1, -1, -1):\n            l, r, cost = sorted_by_start[i]\n            if cost < min_cost:\n                min_cost = cost\n            suffix_min_start[i] = min_cost\n        preprocessed[d] = (sorted_by_end, prefix_min_end, sorted_by_start, suffix_min_start)\n    \n    min_total = float('inf')\n    \n    for l1, r1, cost1, d1 in vouchers:\n        target_d = x - d1\n        if target_d < 1:\n            continue\n        if target_d not in preprocessed:\n            continue\n        # Check for vouchers with duration target_d that end before l1\n        sorted_by_end, prefix_min_end, sorted_by_start, suffix_min_start = preprocessed[target_d]\n        # Find the largest end <= l1 - 1\n        end_list = [r for (l, r, c) in sorted_by_end]\n        idx_end = bisect.bisect_right(end_list, l1 - 1) - 1\n        if idx_end >= 0:\n            min_cost_end = prefix_min_end[idx_end]\n            total = cost1 + min_cost_end\n            if total < min_total:\n                min_total = total\n        # Check for vouchers with duration target_d that start after r1\n        start_list = [l for (l, r, c) in sorted_by_start]\n        idx_start = bisect.bisect_right(start_list, r1)\n        if idx_start < len(start_list):\n            min_cost_start = suffix_min_start[idx_start]\n            total = cost1 + min_cost_start\n            if total < min_total:\n                min_total = total\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into a list of vouchers, each characterized by its start day, end day, cost, and duration.\n2. **Categorizing Vouchers**: Vouchers are grouped by their duration using a dictionary for efficient lookup.\n3. **Sorting and Preprocessing**: For each duration, vouchers are sorted by end time and start time. Prefix and suffix minimum cost arrays are created to facilitate quick minimum cost queries.\n4. **Checking Valid Pairs**: For each voucher, we check if there exists another voucher with the complementary duration that either ends before the current voucher starts or starts after the current voucher ends. Binary search is used to efficiently find valid vouchers and their minimum costs.\n5. **Result Calculation**: The minimum total cost from all valid pairs is computed and printed, or -1 if no valid pairs are found.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport bisect\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n    \n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n    \n    from collections import defaultdict\n\n    # Preprocess: group vouchers by duration\n    duration_dict = defaultdict(list)\n    for l, r, cost, d in vouchers:\n        duration_dict[d].append((l, r, cost))\n    \n    # For each duration, sort the vouchers by end time and start time\n    # Also, create prefix min for end sorted list and suffix min for start sorted list\n    preprocessed = dict()\n    for d in duration_dict:\n        lst = duration_dict[d]\n        # Sort by end time\n        sorted_by_end = sorted(lst, key=lambda x: x[1])\n        # Create prefix min array\n        prefix_min_end = []\n        min_cost = float('inf')\n        for l, r, cost in sorted_by_end:\n            if cost < min_cost:\n                min_cost = cost\n            prefix_min_end.append(min_cost)\n        # Sort by start time\n        sorted_by_start = sorted(lst, key=lambda x: x[0])\n        # Create suffix min array\n        suffix_min_start = [0] * len(sorted_by_start)\n        min_cost = float('inf')\n        for i in range(len(sorted_by_start)-1, -1, -1):\n            l, r, cost = sorted_by_start[i]\n            if cost < min_cost:\n                min_cost = cost\n            suffix_min_start[i] = min_cost\n        preprocessed[d] = (sorted_by_end, prefix_min_end, sorted_by_start, suffix_min_start)\n    \n    min_total = float('inf')\n    \n    for l1, r1, cost1, d1 in vouchers:\n        target_d = x - d1\n        if target_d < 1:\n            continue\n        if target_d not in preprocessed:\n            continue\n        # Check for vouchers with duration target_d that end before l1\n        sorted_by_end, prefix_min_end, sorted_by_start, suffix_min_start = preprocessed[target_d]\n        # Find the largest end <= l1 - 1\n        end_list = [r for (l, r, c) in sorted_by_end]\n        idx_end = bisect.bisect_right(end_list, l1 - 1) - 1\n        if idx_end >= 0:\n            min_cost_end = prefix_min_end[idx_end]\n            total = cost1 + min_cost_end\n            if total < min_total:\n                min_total = total\n        # Check for vouchers with duration target_d that start after r1\n        start_list = [l for (l, r, c) in sorted_by_start]\n        idx_start = bisect.bisect_right(start_list, r1)\n        if idx_start < len(start_list):\n            min_cost_start = suffix_min_start[idx_start]\n            total = cost1 + min_cost_start\n            if total < min_total:\n                min_total = total\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 740,
        "completion_token_count": 1136,
        "thoughts_token_count": 1023
    }
}