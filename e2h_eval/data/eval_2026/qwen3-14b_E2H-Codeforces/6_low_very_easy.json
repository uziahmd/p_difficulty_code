{
    "start": 1758313551.8225207,
    "end": 1758313959.8522964,
    "start-formatted": "2025-09-20 05:25 KST",
    "end-formatted": "2025-09-20 05:32 KST",
    "gpu": 2,
    "pid": 6,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\nOkay, let's see. I need to solve this programming problem. Let me read the problem carefully again.\n\nSo, the problem is about Leha wanting to choose two vouchers such that their durations add up exactly to x days, and they don't overlap. And we have to find the minimal total cost of such a pair. If it's not possible, output -1.\n\nThe input gives n vouchers, each with li (departure day), ri (return day), and cost. The duration of a voucher is ri - li + 1. The two vouchers must not overlap, meaning one ends before the other starts. So for two vouchers i and j, either ri < lj or rj < li.\n\nThe approach here is to find pairs of vouchers where the sum of their durations is exactly x, and they are non-overlapping, then find the minimum cost among all such pairs.\n\nFirst, I need to process all vouchers and find for each voucher, another voucher that can pair with it. But checking all possible pairs would be O(n²), which is not feasible since n can be up to 2e5. That would be way too slow. So we need an efficient approach.\n\nLet me think about how to optimize this.\n\nLet me think about the duration. For each voucher, let's compute its duration. Let's say duration_i = ri - li + 1. Then, for each voucher i, we need to find a voucher j such that duration_i + duration_j = x. Also, they must not overlap.\n\nSo for each voucher, we can check if there exists another voucher with duration equal to (x - duration_i). But how do we efficiently find those vouchers that have the required duration and also don't overlap with the current voucher?\n\nBut even that seems challenging. Because for each voucher i, we need to look for vouchers j with duration d = x - duration_i, and then check if they are non-overlapping.\n\nBut how can we efficiently find the minimal cost for such j's?\n\nMaybe pre-process vouchers by their duration. Like, create a dictionary where for each duration, we have a list of vouchers with that duration. Then, for each voucher i with duration d, we can check if there's a duration (x - d) in the dictionary. If yes, then for all vouchers in that duration group, check if they are non-overlapping with voucher i, and track the minimal cost.\n\nBut even that could be O(n * k), where k is the number of vouchers in the other duration group. Which could be O(n²) in worst case. Not feasible.\n\nSo we need a smarter way.\n\nAlternative idea: For each possible duration d, we can precompute the minimal cost of vouchers that end before a certain day, or start after a certain day. Because when looking for a voucher j with duration (x - d), which can be paired with voucher i, we need to find vouchers j that either end before li (so that voucher j ends before voucher i starts) or start after ri (so that voucher j starts after voucher i ends).\n\nWait, but voucher i has duration d. Let's say voucher i has li and ri. For a voucher j with duration (x - d), we need either:\n\nCase 1: j ends before i starts. So rj < li.\n\nOR\n\nCase 2: j starts after i ends. So lj > ri.\n\nSo for each voucher i, we need to find the minimal cost of vouchers j with duration (x - d_i) that satisfy either of these two conditions.\n\nSo, how can we find the minimal cost for vouchers j with duration (target_d) that end before a certain day (li) or start after a certain day (ri)?\n\nIf we can pre-process for each duration, the minimal cost for vouchers that end before a certain day, and the minimal cost for vouchers that start after a certain day, then for each voucher i, we can query these structures.\n\nBut how to do that?\n\nLet me think. Let's consider that for each duration d, we have a list of vouchers with that duration. For each such list, we can sort them by their end day (ri) and also by their start day (li). Then, for a given target day (say, li), we can find the minimal cost among vouchers in that duration group that end before li. Similarly, for vouchers that start after ri.\n\nSo here's the plan:\n\n- Preprocess for each duration d, two sorted lists:\n\n   a) sorted by end day (ri), and for each entry, keep track of the minimal cost up to that end day. So that for any query of \"find the minimal cost of vouchers with duration d that end before day t\", we can perform a binary search on the sorted list of end days and find the earliest entries, and take the minimal cost.\n\n   b) sorted by start day (li), and for each entry, keep track of the minimal cost from that start day onwards. So that for",
    "response": "To solve this problem, we need to find two non-overlapping vouchers such that their combined duration equals exactly `x` days, and their total cost is minimized. If no such pair exists, we should return `-1`.\n\n### Approach\n1. **Preprocessing by Duration**: Group vouchers by their duration. This helps in efficiently checking for pairs of vouchers whose durations sum to `x`.\n2. **Sorting and Binary Search**: For each duration, maintain two sorted lists:\n   - One sorted by the end day (`ri`) to efficiently find vouchers ending before a given day.\n   - Another sorted by the start day (`li`) to efficiently find vouchers starting after a given day.\n3. **Prefix Minimum Arrays**: For each sorted list, maintain a prefix minimum array to quickly determine the minimum cost of vouchers up to a certain index.\n\n### Solution Code\n```python\nimport bisect\nimport sys\nimport math\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n    \n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n    \n    from collections import defaultdict\n\n    # Preprocess: group vouchers by their duration\n    duration_map = defaultdict(list)\n    for l, r, cost, d in vouchers:\n        duration_map[d].append((l, r, cost))\n    \n    # For each duration d, we will have:\n    # - sorted by end time (r), and prefix min cost\n    # - sorted by start time (l), and suffix min cost\n    # So we pre-process these structures\n    processed = dict()\n    for d in duration_map:\n        lst = duration_map[d]\n        # Sort by end time\n        sorted_by_end = sorted(lst, key=lambda x: x[1])\n        # Create prefix min array\n        prefix_min = []\n        min_cost = math.inf\n        for item in sorted_by_end:\n            min_cost = min(min_cost, item[2])\n            prefix_min.append(min_cost)\n        # Sort by start time\n        sorted_by_start = sorted(lst, key=lambda x: x[0])\n        # Create suffix min array\n        suffix_min = [0] * len(sorted_by_start)\n        min_cost = math.inf\n        for i in range(len(sorted_by_start)-1, -1, -1):\n            min_cost = min(min_cost, sorted_by_start[i][2])\n            suffix_min[i] = min_cost\n        processed[d] = (sorted_by_end, prefix_min, sorted_by_start, suffix_min)\n    \n    min_total = math.inf\n    for l1, r1, cost1, d1 in vouchers:\n        target_d = x - d1\n        if target_d not in duration_map:\n            continue\n        # Now look for vouchers with duration target_d that do not overlap with (l1, r1)\n        # Case 1: voucher ends before l1\n        # Case 2: voucher starts after r1\n        # For case 1, find the minimal cost among vouchers with duration target_d where r <= l1 -1\n        # For case 2, find the minimal cost among vouchers with duration target_d where l >= r1 + 1\n        \n        # Process case 1\n        sorted_by_end, prefix_min, _, _ = processed[target_d]\n        # Find the largest r in sorted_by_end that is <= l1 - 1\n        end_days = [item[1] for item in sorted_by_end]\n        pos = bisect.bisect_right(end_days, l1 - 1)\n        if pos > 0:\n            current_min = prefix_min[pos - 1]\n            min_total = min(min_total, current_min + cost1)\n        \n        # Process case 2\n        _, _, sorted_by_start, suffix_min = processed[target_d]\n        # Find the smallest l in sorted_by_start that is >= r1 + 1\n        start_days = [item[0] for item in sorted_by_start]\n        pos = bisect.bisect_left(start_days, r1 + 1)\n        if pos < len(start_days):\n            current_min = suffix_min[pos]\n            min_total = min(min_total, current_min + cost1)\n    \n    if min_total == math.inf:\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into a list of vouchers, each represented by its start day, end day, cost, and duration.\n2. **Grouping by Duration**: Vouchers are grouped by their duration using a dictionary. This allows efficient lookup when checking for pairs of vouchers whose durations sum to `x`.\n3. **Sorting and Prefix/Suffix Min Arrays**: For each duration group, vouchers are sorted by end time and start time. Prefix minimum arrays are used for end-sorted lists to quickly find the minimum cost up to a certain end day. Similarly, suffix minimum arrays are used for start-sorted lists to quickly find the minimum cost from a certain start day onwards.\n4. **Checking Valid Pairs**: For each voucher, we check if there exists another voucher with the required duration that does not overlap. This is done using binary search on the sorted lists and leveraging the prefix/suffix minimum arrays for quick minimum cost queries.\n\nThis approach ensures that we efficiently find the optimal pairs without checking all possible pairs, leading to an overall time complexity of O(n log n).",
    "ground_truth": "N/A",
    "extracted_answer": "import bisect\nimport sys\nimport math\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n    \n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n    \n    from collections import defaultdict\n\n    # Preprocess: group vouchers by their duration\n    duration_map = defaultdict(list)\n    for l, r, cost, d in vouchers:\n        duration_map[d].append((l, r, cost))\n    \n    # For each duration d, we will have:\n    # - sorted by end time (r), and prefix min cost\n    # - sorted by start time (l), and suffix min cost\n    # So we pre-process these structures\n    processed = dict()\n    for d in duration_map:\n        lst = duration_map[d]\n        # Sort by end time\n        sorted_by_end = sorted(lst, key=lambda x: x[1])\n        # Create prefix min array\n        prefix_min = []\n        min_cost = math.inf\n        for item in sorted_by_end:\n            min_cost = min(min_cost, item[2])\n            prefix_min.append(min_cost)\n        # Sort by start time\n        sorted_by_start = sorted(lst, key=lambda x: x[0])\n        # Create suffix min array\n        suffix_min = [0] * len(sorted_by_start)\n        min_cost = math.inf\n        for i in range(len(sorted_by_start)-1, -1, -1):\n            min_cost = min(min_cost, sorted_by_start[i][2])\n            suffix_min[i] = min_cost\n        processed[d] = (sorted_by_end, prefix_min, sorted_by_start, suffix_min)\n    \n    min_total = math.inf\n    for l1, r1, cost1, d1 in vouchers:\n        target_d = x - d1\n        if target_d not in duration_map:\n            continue\n        # Now look for vouchers with duration target_d that do not overlap with (l1, r1)\n        # Case 1: voucher ends before l1\n        # Case 2: voucher starts after r1\n        # For case 1, find the minimal cost among vouchers with duration target_d where r <= l1 -1\n        # For case 2, find the minimal cost among vouchers with duration target_d where l >= r1 + 1\n        \n        # Process case 1\n        sorted_by_end, prefix_min, _, _ = processed[target_d]\n        # Find the largest r in sorted_by_end that is <= l1 - 1\n        end_days = [item[1] for item in sorted_by_end]\n        pos = bisect.bisect_right(end_days, l1 - 1)\n        if pos > 0:\n            current_min = prefix_min[pos - 1]\n            min_total = min(min_total, current_min + cost1)\n        \n        # Process case 2\n        _, _, sorted_by_start, suffix_min = processed[target_d]\n        # Find the smallest l in sorted_by_start that is >= r1 + 1\n        start_days = [item[0] for item in sorted_by_start]\n        pos = bisect.bisect_left(start_days, r1 + 1)\n        if pos < len(start_days):\n            current_min = suffix_min[pos]\n            min_total = min(min_total, current_min + cost1)\n    \n    if min_total == math.inf:\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 741,
        "completion_token_count": 1218,
        "thoughts_token_count": 1024
    }
}