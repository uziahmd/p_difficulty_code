{
    "start": 1758008509.0291119,
    "end": 1758008718.5649886,
    "start-formatted": "2025-09-16 16:41 KST",
    "end-formatted": "2025-09-16 16:45 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\nOkay, let's tackle this problem. So the task is to determine for a given n whether there exists a snowflake graph with exactly n vertices. The snowflake is built in a certain way, and I need to find out the conditions under which such a graph can exist.\n\nLet me try to understand the structure of the snowflake graph. According to the description:\n\nThe snowflake starts with one vertex. Then, this initial vertex is connected to k new vertices (k>1). Then, each vertex that is connected to only one other (so those leaves) are connected to k new vertices. This step must be done at least once. \n\nSo the construction process seems to involve multiple layers. Let's think about how the number of vertices grows with each step.\n\nLet me model this. Let's think of the snowflake as a tree. Because each step adds new nodes connected to existing leaves. So the structure is a tree with certain branching factors.\n\nLet me think of the steps:\n\nInitial step: 1 node (level 0).\n\nFirst expansion: connect the root to k nodes. Now total nodes is 1 + k. These k nodes are leaves. But according to the problem statement, the step where adding new nodes to leaves must be done at least once. So the first expansion is required. Wait, the initial step is just one node. Then the first expansion is adding k nodes connected to the root. Then, the next step is to take each leaf (which are those k nodes) and add k new nodes to each. So after that, the total number of nodes would be 1 + k + k * k = 1 + k + k².\n\nBut wait, the problem says that the step of connecting leaves to k new nodes must be done at least once. So the first expansion (adding k nodes to the root) is part of the construction, but then we have to do the second step (adding k new nodes to each leaf) at least once. So the minimal snowflake would be when we do the first expansion (adding k nodes) and then do the second step once. So the minimal number of nodes would be 1 + k + k*k. For example, when k=4, the minimal is 1 +4+16=21? But the example given in the problem says that for n=6, the answer is NO. Let's check the sample input.\n\nLooking at the sample input:\n\nSample Input includes 6 as one of the test cases, and the output is NO. Let me think why. Let's see what possible values of n can be achieved.\n\nSo the snowflake construction requires that after the initial step, there are some expansions. Let me model the possible numbers of nodes.\n\nLet me think of the snowflake as being built in m layers. Let me think about how the number of nodes is calculated.\n\nLet me think of the process as follows:\n\nThe snowflake is constructed by starting with a root node. Then, each time, all the current leaves are expanded by adding k children each. But this expansion has to happen at least once. So the initial expansion (the first step) is adding k children to the root. Then, the second step is adding k children to each of those leaves. And so on. However, the problem states that the step of adding k new vertices to each leaf must be done at least once. So the minimal number of steps is two: the first step (adding k children to the root), and then the second step (adding k children to each of those leaves). But perhaps the process can be done more than once. For example, after the second step, you could do another expansion step, adding k children to each of the leaves from the second step.\n\nSo the number of nodes depends on how many times we perform this expansion step. Let me formalize this.\n\nLet me think of the process as follows:\n\nLet's say that the snowflake is built with m layers. The first layer is the root. Then, the first expansion (step 1) adds k nodes. Then, each expansion step adds k children to each of the current leaves. Let me think in terms of levels.\n\nLet me consider the number of nodes after each expansion step. Let's assume that the expansion steps are done t times. Wait, perhaps the number of expansion steps is t, where t ≥ 1. Because the initial step (connecting the root to k nodes) is the first expansion. Then, the second expansion is adding k children to each of those leaves, etc.\n\nWait, maybe the process is:\n\nThe snowflake is constructed in stages. The first stage is creating the root and adding k children. Then, each subsequent stage adds k children to each leaf from the previous stage. However, the problem says that the step of adding k children to each leaf must be done at least once. So the first expansion (the initial step) is required, and then at least one more expansion step.\n\nWait, no. Let",
    "response": "\n\nTo solve this problem, we need to determine if a snowflake graph with exactly `n` vertices can be constructed based on specific rules. The snowflake graph starts with one vertex and expands by connecting each leaf node to `k` new vertices, where `k > 1`. This expansion must be done at least once after the initial setup.\n\n### Approach\n1. **Understanding the Structure**: The snowflake graph is built in layers. Starting with one vertex, each subsequent layer adds `k` new vertices to every leaf node from the previous layer. The total number of vertices after `t` expansions can be modeled using geometric series.\n2. **Geometric Series Insight**: The number of vertices after `t` expansions can be represented as a sum of a geometric series. For example, if we start with 1 vertex and expand `t` times, the total number of vertices is given by:\n   $$\n   n = 1 + k + k^2 + \\ldots + k^t\n   $$\n   This sum can be simplified to:\n   $$\n   n = \\frac{k^{t+1} - 1}{k - 1}\n   $$\n3. **Iterative Check**: For each test case, we need to check if there exists a valid `k > 1` such that the given `n` can be expressed in the form of the above geometric series for some integer `t >= 1`.\n\n### Solution Code\n```python\nimport sys\nimport math\n\ndef is_snowflake(n):\n    if n == 1:\n        return False\n    # We need to check if there exists k > 1 and t >= 1 such that (k^(t+1) - 1) / (k - 1) == n\n    # Also, since t >= 1, then the minimal number of nodes is when t=1: 1 + k + k^2 = (k^3 - 1)/(k - 1)\n    # So for t=1, the formula is (k^2 + k + 1) = n\n    # For t=2, it's (k^3 + k^2 + k + 1) = n, etc.\n    # We can iterate over possible k values, but since n can be up to 1e18, we need an efficient way\n    # Let's consider possible t values starting from 1 upwards until the sum would exceed n.\n    max_t = 60  # since 2^60 is about 1e18\n    for t in range(1, max_t + 1):\n        # For each t, find if there exists a k > 1 such that sum_{i=0}^t k^i = n\n        # sum_{i=0}^t k^i = (k^(t+1) - 1)/(k - 1) = n\n        # So we need to solve for k in this equation\n        # Since k > 1, we can binary search k in [2, ...]\n        low = 2\n        high = 2\n        # Find upper bound for k\n        while (high ** (t + 1)) // (high - 1) <= n:\n            high *= 2\n        # Now binary search between low and high\n        while low <= high:\n            mid = (low + high) // 2\n            # Compute (mid^(t+1) - 1) // (mid - 1)\n            # But since mid can be large, we need to compute it carefully\n            try:\n                total = (pow(mid, t + 1) - 1) // (mid - 1)\n            except:\n                total = float('inf')\n            if total == n:\n                return True\n            elif total < n:\n                low = mid + 1\n            else:\n                high = mid - 1\n    return False\n\ndef main():\n    input = sys.stdin.read().split()\n    t = int(input[0])\n    cases = list(map(int, input[1:t+1]))\n    for n in cases:\n        if is_snowflake(n):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **is_snowflake Function**: This function checks if a given number `n` can be expressed as a sum of a geometric series with base `k > 1` and at least one expansion step. It iterates over possible values of `t` (number of expansions) and uses binary search to find valid `k` values.\n- **Binary Search**: For each `t`, the function performs a binary search on `k` to efficiently check if the sum of the geometric series equals `n`.\n- **Efficiency**: The approach ensures that we handle very large values of `n` (up to $10^{18}$) efficiently by leveraging mathematical properties and binary search, making the solution feasible within the problem constraints.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\n\ndef is_snowflake(n):\n    if n == 1:\n        return False\n    # We need to check if there exists k > 1 and t >= 1 such that (k^(t+1) - 1) / (k - 1) == n\n    # Also, since t >= 1, then the minimal number of nodes is when t=1: 1 + k + k^2 = (k^3 - 1)/(k - 1)\n    # So for t=1, the formula is (k^2 + k + 1) = n\n    # For t=2, it's (k^3 + k^2 + k + 1) = n, etc.\n    # We can iterate over possible k values, but since n can be up to 1e18, we need an efficient way\n    # Let's consider possible t values starting from 1 upwards until the sum would exceed n.\n    max_t = 60  # since 2^60 is about 1e18\n    for t in range(1, max_t + 1):\n        # For each t, find if there exists a k > 1 such that sum_{i=0}^t k^i = n\n        # sum_{i=0}^t k^i = (k^(t+1) - 1)/(k - 1) = n\n        # So we need to solve for k in this equation\n        # Since k > 1, we can binary search k in [2, ...]\n        low = 2\n        high = 2\n        # Find upper bound for k\n        while (high ** (t + 1)) // (high - 1) <= n:\n            high *= 2\n        # Now binary search between low and high\n        while low <= high:\n            mid = (low + high) // 2\n            # Compute (mid^(t+1) - 1) // (mid - 1)\n            # But since mid can be large, we need to compute it carefully\n            try:\n                total = (pow(mid, t + 1) - 1) // (mid - 1)\n            except:\n                total = float('inf')\n            if total == n:\n                return True\n            elif total < n:\n                low = mid + 1\n            else:\n                high = mid - 1\n    return False\n\ndef main():\n    input = sys.stdin.read().split()\n    t = int(input[0])\n    cases = list(map(int, input[1:t+1]))\n    for n in cases:\n        if is_snowflake(n):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 562,
        "completion_token_count": 1065,
        "thoughts_token_count": 1023
    }
}