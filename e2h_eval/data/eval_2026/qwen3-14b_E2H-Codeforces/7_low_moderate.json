{
    "start": 1758313720.6409862,
    "end": 1758313767.1924942,
    "start-formatted": "2025-09-20 05:28 KST",
    "end-formatted": "2025-09-20 05:29 KST",
    "gpu": 2,
    "pid": 7,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\nOkay, let's try to figure out how to solve this problem. The task is to determine for a given number n whether there exists a snowflake graph as defined. Let's break down the problem.\n\nFirst, understanding the structure of the snowflake. The snowflake is built in a certain way. Let me rephrase the construction steps:\n\n- Start with one vertex.\n- Then, connect it to k new vertices (k>1). So after this step, there are 1 + k vertices.\n- Then, each vertex that has only one connection (so those added in the previous step) must be connected to k new vertices. This step must be done at least once. \n\nWait, so the process is like a tree where each node is expanded in a certain way. Let me think about the structure.\n\nLet me model the growth. Let's think recursively. The initial step is level 0: one node. Then, level 1 adds k nodes connected to the root. Then, each of those level 1 nodes must have k children. So each node in level 1 adds k children. Then, perhaps, the same applies again for the next levels.\n\nBut the process says that the step of adding k new vertices to each leaf must be done at least once. So the minimal snowflake would be when we do this once. For example, if k=4:\n\nStart with 1 node. Add 4 children (total 5). Then, each of those 4 nodes must get 4 new children. So adding 4*4 = 16 nodes. Total is 1 + 4 + 16 = 21? Wait, but the example says that for k=4, the minimal is shown, but in the sample input, when n=13, the output is YES. Hmm, maybe I'm misunderstanding the structure.\n\nWait, looking at the sample input. For example, the sample input includes n=13 and output is YES. Let's think about that.\n\nLet me think of possible values of n. Let's see:\n\nThe snowflake's construction can be thought of as a tree where each node has exactly k children except for the root, which has k children, and then each node added in the first step (the immediate children of the root) must have their own k children. However, the process of expanding each leaf (those with only one connection) must be done at least once. So the minimal case is when we do that expansion once.\n\nSo for example, the minimal snowflake would be:\n\n- Level 0: 1 node (root)\n- Level 1: k nodes connected to root. Now, each of these is a leaf. So we need to expand them once. So each of them gets k new children. So level 2: k * k nodes. Total nodes is 1 + k + k².\n\nBut according to the sample input, n=13 is a YES. Let's check for k=3. Then 1+3+9=13. So yes. So that's a valid case. So for n=13, it's possible. That's why the sample output says YES.\n\nAnother example: n=6. Let's see. Let's check if there's any k such that 1 +k +k² =6? Let's compute for k=2: 1+2+4=7. No. k=1 is not allowed. So no. What about other possibilities?\n\nWait, maybe the process can be done more than once. Like, after expanding once, you can expand again. For example, suppose after the first expansion (level 1), you expand again. But how?\n\nWait, the rules say that each vertex that is connected to only one other vertex (i.e., leaves) must be connected to k new vertices. This step should be done at least once. So the process is:\n\nInitially, the root has k children. Then, each of those children is a leaf. So the step is done once: each of those leaves gets k new children. So that's the first expansion. But maybe you can do more expansions. For example, after that, the leaves are the nodes added in the second expansion. So you can expand them again. \n\nSo the total number of nodes depends on how many times the expansion is done. Let's model this.\n\nLet me think of the snowflake as a tree where each node is expanded m times. Wait, maybe not. Let's think of the process as follows:\n\nThe construction starts with the root. Then, we perform some number of expansion steps. Each expansion step applies to all current leaves (those with degree 1). Each such leaf is replaced by a node connected to k new nodes. So, each expansion step increases the number of nodes.\n\nBut the problem says that the step of adding k new vertices to each leaf must be done at least once. So the minimal number of expansions is 1",
    "response": "To solve this problem, we need to determine if a given number of vertices `n` can form a valid \"snowflake\" graph as defined by the rules provided. The snowflake graph is constructed in a specific hierarchical manner, starting with one node and expanding recursively.\n\n### Approach\n1. **Understanding the Structure**: The snowflake graph starts with a root node. Each node that is a leaf (connected to only one other node) must be expanded by connecting it to `k` new nodes. This expansion process must be done at least once.\n2. **Mathematical Model**: The total number of nodes in a snowflake graph can be represented by a geometric series. For a given number of expansions, the total number of nodes can be calculated using the formula:\n   $$\n   n = 1 + k + k^2 + k^3 + \\ldots + k^m\n   $$\n   where `m` is the number of expansion steps (at least 1).\n3. **Efficient Check**: For each test case, we check if there exists an integer `k > 1` such that the sum of the geometric series equals the given number of vertices `n`. We iterate over possible values of `k` and check if the sum matches `n`.\n\n### Solution Code\n```python\nimport sys\nimport math\n\ndef is_snowflake(n):\n    if n == 1:\n        return False\n    # Try all possible k > 1\n    # For each k, check if there exists m >= 1 such that sum_{i=0}^m (k^i) = n\n    # But since sum_{i=0}^m k^i = (k^(m+1) - 1) / (k - 1)\n    # So for each k, we can compute whether (k^(m+1) - 1) / (k - 1) == n\n    # But since n can be up to 1e18, we need to limit the k's we try.\n    # Let's try k from 2 up to some limit.\n    # For k^m <= n, so m can be up to log_2(n)\n    # However, trying all k up to sqrt(n) may be feasible.\n    # Another approach: for each possible m (number of expansion steps), find if there's a k such that sum_{i=0}^m k^i = n\n    # For m >= 1\n    # Let's try m from 1 to up to 60 (since 2^60 is around 1e18)\n    for m in range(1, 61):\n        # We need to find k such that (k^(m+1) - 1) / (k - 1) == n\n        # Let's solve for k in this equation\n        # We can perform binary search on k for each m\n        low = 2\n        high = 2\n        # Find upper bound for k\n        while (high ** (m + 1) - 1) // (high - 1) <= n:\n            high *= 2\n        # Now binary search between low and high\n        while low <= high:\n            mid = (low + high) // 2\n            # Compute sum = (mid^(m+1) - 1) // (mid - 1)\n            # But calculating mid^(m+1) could be large, so use exponentiation by squaring\n            # However, for m up to 60, mid^60 is manageable for Python's big integers\n            try:\n                total = (mid ** (m + 1) - 1) // (mid - 1)\n            except:\n                total = float('inf')\n            if total == n:\n                return True\n            elif total < n:\n                low = mid + 1\n            else:\n                high = mid - 1\n    return False\n\ndef main():\n    input = sys.stdin.read().split()\n    t = int(input[0])\n    cases = list(map(int, input[1:t+1]))\n    for n in cases:\n        if is_snowflake(n):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **is_snowflake Function**: This function checks if a given number `n` can be expressed as the sum of a geometric series starting from 1 with a common ratio `k > 1`, for some integer `k` and at least one expansion step.\n- **Binary Search**: For each possible number of expansion steps `m`, the function performs a binary search on possible values of `k` to determine if the sum of the geometric series matches `n`.\n- **Efficiency**: The solution efficiently handles large values of `n` (up to $10^{18}$) by leveraging binary search and mathematical properties of geometric series, ensuring the algorithm runs in a reasonable time even for large inputs.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\n\ndef is_snowflake(n):\n    if n == 1:\n        return False\n    # Try all possible k > 1\n    # For each k, check if there exists m >= 1 such that sum_{i=0}^m (k^i) = n\n    # But since sum_{i=0}^m k^i = (k^(m+1) - 1) / (k - 1)\n    # So for each k, we can compute whether (k^(m+1) - 1) / (k - 1) == n\n    # But since n can be up to 1e18, we need to limit the k's we try.\n    # Let's try k from 2 up to some limit.\n    # For k^m <= n, so m can be up to log_2(n)\n    # However, trying all k up to sqrt(n) may be feasible.\n    # Another approach: for each possible m (number of expansion steps), find if there's a k such that sum_{i=0}^m k^i = n\n    # For m >= 1\n    # Let's try m from 1 to up to 60 (since 2^60 is around 1e18)\n    for m in range(1, 61):\n        # We need to find k such that (k^(m+1) - 1) / (k - 1) == n\n        # Let's solve for k in this equation\n        # We can perform binary search on k for each m\n        low = 2\n        high = 2\n        # Find upper bound for k\n        while (high ** (m + 1) - 1) // (high - 1) <= n:\n            high *= 2\n        # Now binary search between low and high\n        while low <= high:\n            mid = (low + high) // 2\n            # Compute sum = (mid^(m+1) - 1) // (mid - 1)\n            # But calculating mid^(m+1) could be large, so use exponentiation by squaring\n            # However, for m up to 60, mid^60 is manageable for Python's big integers\n            try:\n                total = (mid ** (m + 1) - 1) // (mid - 1)\n            except:\n                total = float('inf')\n            if total == n:\n                return True\n            elif total < n:\n                low = mid + 1\n            else:\n                high = mid - 1\n    return False\n\ndef main():\n    input = sys.stdin.read().split()\n    t = int(input[0])\n    cases = list(map(int, input[1:t+1]))\n    for n in cases:\n        if is_snowflake(n):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 563,
        "completion_token_count": 1065,
        "thoughts_token_count": 1024
    }
}