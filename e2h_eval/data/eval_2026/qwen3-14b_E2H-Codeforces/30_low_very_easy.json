{
    "start": 1758309803.4462512,
    "end": 1758309848.0417845,
    "start-formatted": "2025-09-20 04:23 KST",
    "end-formatted": "2025-09-20 04:24 KST",
    "gpu": 2,
    "pid": 30,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# TV Game\n\nThere is a new TV game on BerTV. In this game two players get a number A consisting of 2n digits. Before each turn players determine who will make the next move. Each player should make exactly n moves. On it's turn i-th player takes the leftmost digit of A and appends it to his or her number Si. After that this leftmost digit is erased from A. Initially the numbers of both players (S1 and S2) are «empty». Leading zeroes in numbers A, S1, S2 are allowed. In the end of the game the first player gets S1 dollars, and the second gets S2 dollars.One day Homer and Marge came to play the game. They managed to know the number A beforehand. They want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize. Help them.\n\n## Input\nThe first line contains integer n (1 ≤ n ≤ 18). The second line contains integer A consisting of exactly 2n digits. This number can have leading zeroes.\n\n## Output\nOutput the line of 2n characters «H» and «M» — the sequence of moves of Homer and Marge, which gives them maximum possible total prize. Each player must make exactly n moves. If there are several solutions, output any of them.\n\n## Example\n### Input\n['2\\n1234', '2\\n9911']\n\n### Output\n['HHMM', 'HMHM']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\nOkay, let's see. The problem is about Homer and Marge playing a game where they take digits from a number A. Each takes turns, and each makes exactly n moves. The goal is to maximize the total sum of their numbers S1 and S2. We need to find the sequence of H and M moves that gives this maximum total.\n\nHmm. So the key here is to choose, at each step, whether Homer or Marge takes the next digit, such that the total sum is maximized. But since both players are taking digits, and each has to take exactly n digits, we need to make sure that in the end, each has exactly n digits.\n\nWait, but how do we model this? Because the choice at each step depends on future choices. For example, if we have a choice between taking a digit now for Homer or Marge, which one leads to a better total sum?\n\nBut since n can be up to 18, the total number of steps is 2n = 36. So for a recursive approach with memoization, maybe it's feasible? Let's think about the state space. The state would be the current position in the string A (how many digits have been taken so far), and how many moves Homer has made so far (since Marge's moves are determined as (current step) - Homer's moves). Wait, because each move is either H or M. So for a given step k (from 0 to 2n-1), the number of H's so far is h, and M's is m = k - h. But since each player must take exactly n moves, we can't have h > n or m > n. So during the process, when choosing between H and M, we have to make sure that after choosing, the counts don't exceed n.\n\nSo the state can be represented by two variables: the current position (how many digits have been taken so far, say i), and the number of H's taken so far (h). Then, the number of M's is i - h. Since the total steps is 2n, and each step increases i by 1. So for each state (i, h), we can decide whether to take H or M, provided that h < n and (i - h) < n (so that M can take more steps if needed).\n\nThe problem is to find the sequence of choices (H or M) that maximizes the sum of the digits collected by each player. But how do we calculate the sum? Well, each time a player takes a digit, that digit contributes to their number. But since the numbers are S1 and S2, which are numbers, the total sum is S1 + S2. However, since each digit is added to the end of the player's number, the value of the digit depends on its position. For example, the first digit taken by Homer is the most significant digit (like the thousands place if there are four digits), then the next is less significant, etc. Wait, no! Wait, when you take the leftmost digit, and append it to your number. So for example, if the initial A is 1234, and Homer takes the first digit (1), then his number is '1'. Then, if he takes another digit, say 2, his number becomes '12', which is 1*10^1 + 2*10^0. So the order in which digits are taken affects the value of the number. Therefore, the value of each digit depends on the position in which it is added to the player's number.\n\nBut calculating the total sum S1 + S2 requires considering the value of each digit multiplied by 10^power, where power depends on when the digit was taken. For example, the first digit a player takes is the highest place (like 10^{n-1} if they take n digits), then the next is 10^{n-2}, etc. Wait, because each player takes exactly n digits. So for a player's first digit, it's the first in their number, so it's multiplied by 10^{n-1}, then the next by 10^{n-2}, and so on until the last digit, which is multiplied by 10^0.\n\nSo for each digit that a player takes, the contribution to the total sum is digit * 10^{k}, where k is the number of digits remaining to be taken by that player after this step. For example, if a player has already taken m digits, then the next digit will be the (m+1)th digit in their number, so the exponent is (n - m - 1). Wait, let's think: for a player who takes n digits, the first digit is multiplied by 10^{n-1}, the second by 10^{n-2}, ...,",
    "response": "To solve this problem, we need to determine the optimal sequence of moves for Homer and Marge such that their total prize money is maximized. The game involves taking digits from a number A, where each player takes exactly n digits, and the goal is to maximize the sum of their respective numbers formed by these digits.\n\n### Approach\n1. **Dynamic Programming with Memoization**: We use a recursive approach with memoization to explore all possible sequences of moves efficiently. This helps avoid redundant calculations and ensures we consider all possible paths to maximize the total prize.\n2. **State Representation**: The state is represented by two parameters: the current position in the string (indicating how many digits have been taken so far) and the number of digits Homer has taken so far. This allows us to track the remaining moves for both players.\n3. **Greedy Choice with Backtracking**: At each step, we decide whether Homer or Marge should take the next digit based on which choice leads to a higher total prize. This decision is made recursively, considering future moves and their contributions to the total prize.\n\n### Solution Code\n```python\nimport sys\nimport functools\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    n = int(input[0])\n    A = input[1]\n    length = 2 * n\n\n    @functools.lru_cache(maxsize=None)\n    def dp(pos, h_count):\n        if pos == length:\n            return 0, \"\"\n        # Current digit\n        current_digit = int(A[pos])\n        # Possible moves\n        max_total = -1\n        best_move = ''\n        # Try H move if possible\n        if h_count < n:\n            remaining_h = n - h_count - 1\n            contribution = current_digit * (10 ** remaining_h)\n            total, rest = dp(pos + 1, h_count + 1)\n            total += contribution\n            if total > max_total:\n                max_total = total\n                best_move = 'H' + rest\n        # Try M move if possible\n        m_count = pos - h_count\n        if m_count < n:\n            remaining_m = n - m_count - 1\n            contribution = current_digit * (10 ** remaining_m)\n            total, rest = dp(pos + 1, h_count)\n            total += contribution\n            if total > max_total:\n                max_total = total\n                best_move = 'M' + rest\n        return max_total, best_move\n\n    _, result = dp(0, 0)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Dynamic Programming Function (`dp`)**: This function recursively calculates the maximum total prize from the current position `pos` with `h_count` digits taken by Homer. It uses memoization to store results of subproblems to avoid redundant computations.\n- **Contribution Calculation**: For each digit taken by Homer or Marge, the contribution to their respective numbers is calculated based on the position of the digit in their number. This is determined using powers of 10, considering how many digits each player will still take after the current move.\n- **Recursive Decision Making**: At each step, the function evaluates both possible moves (Homer or Marge taking the next digit) and selects the one that maximizes the total prize, ensuring both players end up with exactly `n` digits each.\n\nThis approach efficiently explores all valid sequences of moves while ensuring optimal decisions at each step, leading to the maximum total prize for Homer and Marge.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport functools\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    n = int(input[0])\n    A = input[1]\n    length = 2 * n\n\n    @functools.lru_cache(maxsize=None)\n    def dp(pos, h_count):\n        if pos == length:\n            return 0, \"\"\n        # Current digit\n        current_digit = int(A[pos])\n        # Possible moves\n        max_total = -1\n        best_move = ''\n        # Try H move if possible\n        if h_count < n:\n            remaining_h = n - h_count - 1\n            contribution = current_digit * (10 ** remaining_h)\n            total, rest = dp(pos + 1, h_count + 1)\n            total += contribution\n            if total > max_total:\n                max_total = total\n                best_move = 'H' + rest\n        # Try M move if possible\n        m_count = pos - h_count\n        if m_count < n:\n            remaining_m = n - m_count - 1\n            contribution = current_digit * (10 ** remaining_m)\n            total, rest = dp(pos + 1, h_count)\n            total += contribution\n            if total > max_total:\n                max_total = total\n                best_move = 'M' + rest\n        return max_total, best_move\n\n    _, result = dp(0, 0)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 426,
        "completion_token_count": 739,
        "thoughts_token_count": 1024
    }
}