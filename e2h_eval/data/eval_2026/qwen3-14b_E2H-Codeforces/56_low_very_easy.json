{
    "start": 1758309271.201303,
    "end": 1758309327.723747,
    "start-formatted": "2025-09-20 04:14 KST",
    "end-formatted": "2025-09-20 04:15 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\nOkay, let's see. The problem is about determining if there's a perfect matching between Rebel spaceships and bases such that the line segments connecting each pair don't intersect. And since R and B are up to 10, maybe we can check all possible permutations?\n\nFirst, I need to understand the constraints. The key is that any two line segments (from a spaceship to its assigned base) must not cross each other. So for a given permutation (matching), we have to check all pairs of line segments to ensure they don't intersect.\n\nSo the steps I need to take:\n\n1. Check if R equals B. Because if they are not equal, there's no perfect matching. Wait, the problem says that the assignment is a perfect matching, which requires R = B. So the first thing to check is whether R and B are equal. If not, output No immediately.\n\nWait, the input says R and B are given. For example, in the first sample input, it's 3 3. In the second example, it's 2 1. So the second example's output is No because R != B. So that's an initial check.\n\nSo first, if R != B, output No.\n\nOtherwise, when R = B, we need to check all possible matchings (permutations) between the R spaceships and B bases. For each possible permutation, check if all the line segments between the matched pairs are non-intersecting. If any permutation satisfies this, output Yes. Otherwise, No.\n\nBut how do I generate all possible permutations? Well, since R and B are up to 10, the number of permutations is 10! which is 3.6 million. Wait, 10! is 3,628,800. For each permutation, we need to check all pairs of line segments for intersections. For each permutation, checking O(n²) pairs. For n=10, that's 100 checks per permutation. So total operations would be around 3.6e8. Hmm, but that's 360 million operations. That might be tight for Python, but considering that for each check, the code is simple, maybe it's manageable. Or maybe there's a smarter way.\n\nBut given that the constraints are small (R and B up to 10), perhaps this brute-force approach is feasible.\n\nSo the plan is:\n\n- Check if R != B: output No.\n- Else, generate all possible permutations of assigning spaceships to bases.\n- For each permutation, check if all line segments between the pairs are non-intersecting.\n- If any permutation passes, output Yes. Otherwise, No.\n\nNow, the problem reduces to two parts: generating permutations and checking for segment intersections.\n\nFirst, generating permutations. Let's say we have R spaceships and R bases. For each permutation, we assign spaceship i to base permutation[i].\n\nWait, the permutation is for the bases. Let me think: suppose the spaceships are in a list called rebels, and the bases are in a list called bases. For a permutation p, where p is a list of indices (or elements?), then for each i in 0..R-1, we connect rebels[i] to bases[p[i]]. But for permutations, we need to generate all possible orderings of the bases. For example, if R=3, then the permutations are all the possible orderings of the 3 bases, so that each spaceship is matched to exactly one base.\n\nBut in Python, itertools.permutations can generate all possible orderings of the bases. So for the bases list, each permutation is a possible assignment. So for each permutation, we can check if the set of line segments between rebels[i] and bases_perm[i] for each i have no intersections.\n\nNow, the next part is checking if two line segments intersect. How to do that?\n\nWe need a function that takes two line segments (each defined by two points) and returns True if they intersect, False otherwise.\n\nBut note that the problem states that no three points are colinear. So, any two line segments can't have overlapping lines, but they can cross each other. Also, the problem says that the line segments are straight paths from a spaceship to a base. So, the line segments are between two points.\n\nThe standard way to check if two line segments AB and CD intersect is to use the orientation method. The steps are:\n\n- Check if the segments AB and CD intersect properly (i.e., they cross each other) or if one of the endpoints lies on the other segment.\n\nBut given the problem's note that no three points are colinear, that simplifies things. Because if two segments share an endpoint, then they are connected, but since the problem says that no three points are colinear, that implies that if two segments share an endpoint, then they can't have another point in the same line. But wait, the problem says that no three points are",
    "response": "To solve this problem, we need to determine if there exists a perfect matching between Rebel spaceships and bases such that the line segments connecting each pair of matched points do not intersect. The solution involves checking all possible permutations of assignments between spaceships and bases, and verifying for each permutation if any line segments intersect.\n\n### Approach\n1. **Check for Equal Numbers**: First, check if the number of spaceships (R) is equal to the number of bases (B). If they are not equal, output \"No\" immediately since a perfect matching is impossible.\n2. **Generate Permutations**: For each permutation of the bases, generate a potential assignment of spaceships to bases.\n3. **Check Line Segment Intersections**: For each permutation, check if any pair of line segments formed by the assigned spaceships and bases intersect. This is done using a helper function that determines if two line segments intersect using orientation checks.\n\n### Solution Code\n```python\nimport sys\nimport itertools\n\ndef read_input():\n    data = sys.stdin.read().split('\\n')\n    lines = [line.strip() for line in data if line.strip()]\n    return lines\n\ndef orientation(p, q, r):\n    val = (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0])\n    if val == 0:\n        return 0  # colinear\n    return 1 if val > 0 else 2  # clock or counterclock wise\n\ndef on_segment(p, q, r):\n    return (min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and\n            min(p[1], r[1]) <= q[1] <= max(p[1], r[1]))\n\ndef segments_intersect(seg1, seg2):\n    p1, q1 = seg1\n    p2, q2 = seg2\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    if o1 != o2 and o3 != o4:\n        return True\n\n    if o1 == 0 and on_segment(p1, p2, q1):\n        return True\n    if o2 == 0 and on_segment(p1, q2, q1):\n        return True\n    if o3 == 0 and on_segment(p2, p1, q2):\n        return True\n    if o4 == 0 and on_segment(p2, q1, q2):\n        return True\n\n    return False\n\ndef main():\n    lines = read_input()\n    idx = 0\n    R, B = map(int, lines[idx].split())\n    idx += 1\n    rebels = []\n    for _ in range(R):\n        x, y = map(int, lines[idx].split())\n        rebels.append((x, y))\n        idx += 1\n    bases = []\n    for _ in range(B):\n        x, y = map(int, lines[idx].split())\n        bases.append((x, y))\n        idx += 1\n\n    if R != B:\n        print(\"No\")\n        return\n\n    for perm in itertools.permutations(bases):\n        segments = []\n        for i in range(R):\n            seg = (rebels[i], perm[i])\n            segments.append(seg)\n        valid = True\n        for i in range(R):\n            for j in range(i + 1, R):\n                if segments_intersect(segments[i], segments[j]):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Reading Input**: The input is read and parsed into lists of coordinates for spaceships and bases.\n- **Orientation Check**: The `orientation` function determines the orientation of three points, which helps in checking if line segments intersect.\n- **Segment Intersection Check**: The `segments_intersect` function uses orientation checks to determine if two line segments intersect.\n- **Permutations Check**: For each permutation of base positions, the code checks if all line segments between spaceships and bases in that permutation intersect. If any permutation is found where no intersections occur, \"Yes\" is printed; otherwise, \"No\" is printed after all permutations are checked.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport itertools\n\ndef read_input():\n    data = sys.stdin.read().split('\\n')\n    lines = [line.strip() for line in data if line.strip()]\n    return lines\n\ndef orientation(p, q, r):\n    val = (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0])\n    if val == 0:\n        return 0  # colinear\n    return 1 if val > 0 else 2  # clock or counterclock wise\n\ndef on_segment(p, q, r):\n    return (min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and\n            min(p[1], r[1]) <= q[1] <= max(p[1], r[1]))\n\ndef segments_intersect(seg1, seg2):\n    p1, q1 = seg1\n    p2, q2 = seg2\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    if o1 != o2 and o3 != o4:\n        return True\n\n    if o1 == 0 and on_segment(p1, p2, q1):\n        return True\n    if o2 == 0 and on_segment(p1, q2, q1):\n        return True\n    if o3 == 0 and on_segment(p2, p1, q2):\n        return True\n    if o4 == 0 and on_segment(p2, q1, q2):\n        return True\n\n    return False\n\ndef main():\n    lines = read_input()\n    idx = 0\n    R, B = map(int, lines[idx].split())\n    idx += 1\n    rebels = []\n    for _ in range(R):\n        x, y = map(int, lines[idx].split())\n        rebels.append((x, y))\n        idx += 1\n    bases = []\n    for _ in range(B):\n        x, y = map(int, lines[idx].split())\n        bases.append((x, y))\n        idx += 1\n\n    if R != B:\n        print(\"No\")\n        return\n\n    for perm in itertools.permutations(bases):\n        segments = []\n        for i in range(R):\n            seg = (rebels[i], perm[i])\n            segments.append(seg)\n        valid = True\n        for i in range(R):\n            for j in range(i + 1, R):\n                if segments_intersect(segments[i], segments[j]):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 486,
        "completion_token_count": 960,
        "thoughts_token_count": 1024
    }
}