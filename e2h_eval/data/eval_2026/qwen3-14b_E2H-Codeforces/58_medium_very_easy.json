{
    "start": 1758307579.2460206,
    "end": 1758307866.4817524,
    "start-formatted": "2025-09-20 03:46 KST",
    "end-formatted": "2025-09-20 03:51 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\nOkay, I need to solve this programming problem. Let's read the problem carefully.\n\nThe problem is about finding the minimum number of edges to add to a given undirected graph so that it contains a simple cycle of odd length (with more than one vertex). Also, find the number of ways to do this with exactly that minimum number of edges.\n\nHmm. So first, what's a simple cycle of odd length? It's a cycle where each vertex appears once, and the total number of vertices in the cycle is odd. Like, for example, a triangle (3 nodes) is an odd cycle.\n\nThe task is to find t and w. Where t is the minimum number of edges needed to add to form such a cycle, and w is the number of ways to add exactly t edges to achieve that.\n\nLet me think about the approach.\n\nFirst, let's consider the properties of the graph. If the original graph already contains an odd-length cycle, then t is 0 and w is 1? Or maybe there are multiple ways? Wait, no. Because if there's already an odd cycle, then the answer is t=0 and w=1? But the problem says that the output for the second example is 0 1. Looking at the example:\n\nIn the second input, it's a triangle (3 nodes connected in a cycle). The output is 0 1. So yes, if the graph already has an odd cycle, then t is 0 and w is 1. But wait, maybe there are multiple existing odd cycles. But the problem says that w is the number of ways to add t edges. Since t is zero, adding zero edges. So the number of ways would be 1 if there's at least one existing odd cycle. But how to count that?\n\nWait, but the problem says that the answer requires the number of ways to add exactly t edges. So if the original graph already has an odd cycle, then there's no need to add any edges. So the number of ways is 1? Or maybe the number of existing odd cycles? No, because the question isn't about counting the number of existing cycles. It's about the number of ways to add edges. Since adding zero edges, the way is just one way (since you don't add any edges). But the problem says that the answer for the second input is 0 1. Which suggests that when there's already an odd cycle, the answer is t=0 and w=1. So regardless of how many existing odd cycles there are, the answer is 1? That seems odd. But maybe the problem counts the number of possible ways to add edges. Since adding zero edges, there's only one way (doing nothing). So even if there are multiple existing odd cycles, the number of ways is 1. So the answer is 0 1.\n\nSo the first thing to check is whether the graph already contains an odd-length cycle. If yes, then output t=0 and w=1.\n\nIf not, then we need to find the minimal number of edges to add to create such a cycle.\n\nNow, how can we create an odd-length cycle?\n\nLet me think about the properties of bipartite graphs. A graph is bipartite if and only if it contains no odd-length cycles. So if the graph is bipartite, then adding edges to create an odd-length cycle would require certain steps.\n\nSo the problem reduces to: if the graph is bipartite, then we need to add edges to make it non-bipartite. The minimal number of edges to add to make a graph non-bipartite.\n\nBut how?\n\nFor a bipartite graph, adding any edge between two nodes in the same partition will create an odd-length cycle. Because in a bipartite graph, all cycles are even-length. Adding an edge between two nodes in the same partition creates a cycle of length (distance between them + 1). Since the distance between two nodes in the same partition is even (since the bipartition splits into two sets, and any path between nodes in the same set has even length), adding an edge between them creates a cycle of odd length.\n\nSo the minimal number of edges to add is 1. But only if there exists at least two nodes in the same partition (i.e., in the same bipartition set) that are not connected by an edge. Wait, but the graph may have multiple connected components. Each connected component is bipartite.\n\nSo for each connected component, we can check if it's bipartite. If the entire graph is bipartite, then we need to add edges to make it non-bipartite.\n\nSo the minimal number of edges required is 1. But how to compute the number of ways?\n\nWait, if the graph is bipartite, then to create an odd-length cycle, we need to add an edge between two nodes in the same partition. So the minimal t is 1. And the number of ways is the number of possible pairs of nodes in the same partition (for all connected components) that are not already connected by an edge.\n\nWait, but the graph can have multiple connected components. For example, if the graph is split into multiple bipartite components. So adding an edge between two nodes in the same partition of any component will create an odd-length cycle. So the minimal t is 1, and the number of ways is the sum over all connected components of (number of possible pairs in same partition in that component) minus existing edges.\n\nWait, no. Because each connected component is bipartitioned into two sets, say A and B. For each component, the number of possible edges that can be added between two nodes in A (or two nodes in B) is C(|A|,2) + C(|B|,2) minus the existing edges that are between nodes in A or B. Wait, no. Because existing edges are between A and B. Because the graph is bipartite. So in a bipartition, all edges are between A and B. So existing edges between two nodes in the same partition (A or B) are zero. So for each connected component, the number of possible edges that can be added between two nodes in the same partition is (C(|A|,2) + C(|B|,2)).\n\nBut since adding any such edge would create an odd-length cycle. So the total number of ways is the sum for each connected component of (C(a,2) + C(b,2)), where a and b are the sizes of the two partitions of that component.\n\nBut wait, if the graph is bipartite, then each connected component is bipartite. So for each connected component, the bipartition is (A, B). Then, adding any edge between two nodes in A or two nodes in B will create an odd-length cycle. So the number of possible edges that can be added to create an odd cycle is (C(a,2) + C(b,2)) for each component. But since the original graph has no such edges (because it's bipartite), the number of possible edges is exactly that sum.\n\nBut the problem says that the minimal number of edges to add is 1. So the answer for t is 1, and the number of ways is the sum over all connected components of (C(a,2) + C(b,2))).\n\nBut wait, in the first example input:\n\nInput is:\n\n4 4\n\nEdges: 1-2, 1-3, 4-2, 4-3.\n\nLet's see the graph. Let's draw it. Nodes 1 connected to 2 and 3. Node 4 connected to 2 and 3. So the graph has two connected components? No, all nodes are connected. Let's check:\n\n1 is connected to 2 and 3. 2 is connected to 1 and 4. 4 is connected to 2 and 3. 3 is connected to 1 and 4. So the graph is connected. Now, is it bipartite?\n\nLet me try to color it. Let's assign color 0 to node 1. Then neighbors 2 and 3 must be color 1. Then node 4 is connected to 2 and 3, which are color 1. So node 4 must be color 0. Now, node 4 is connected to 3 (color 1) and 2 (color 1). So that's okay. So the bipartition is {1,4} and {2,3}. So a=2, b=2. Then C(2,2) + C(2,2) = 1 + 1 = 2. So the answer would be t=1, w=2. Which matches the first sample input's output of 1 2. Yes! So that seems correct.\n\nAnother example: the third input is 3 nodes and 0 edges. So the graph is three isolated nodes. Each connected component is a single node. For each component, the bipartition is (1, 0) (since a single node can be considered as a bipartition with one set having 1 node and the other 0). Then for each component, C(1,2) + C(0,2) is 0 + 0 = 0. But wait, that's for each component. So the sum across all components is zero. But that would imply that the answer is t=1 and w=0? But the sample input for that case is output 3 1. Wait, that's conflicting.\n\nWait, the third input is 3 0. The output is 3 1. Let me think.\n\nWait, the original graph is three isolated nodes. So the graph is bipartite (since all components are bipartite). So to create an odd-length cycle, we need to add edges. What is the minimal t here?\n\nWell, to create a cycle of odd length, say 3. To create a triangle, we need to add three edges. Because each node is isolated. So adding edges between 1-2, 2-3, 3-1. That's three edges. So t=3. But according to the previous approach, the minimal t would be 1. But that's not the case. So my previous reasoning was wrong.\n\nAh, here's the mistake. Because the approach of adding one edge between two nodes in the same partition only works when the component is connected. But in this case, the component is disconnected. Let me think again.\n\nThe graph is bipartite. So adding an edge between two nodes in the same partition of a connected component would create an odd-length cycle. However, in the case where the component is a single node (like in the third example), the bipartition is (a=1, b=0). So the number of possible edges between same partitions is C(1,2) + C(0,2) = 0. So the sum is zero. Which would imply that there are no edges that can be added to create an odd-length cycle. But that's not true. Because adding any edge between two nodes in the same component (but they are in different components). Wait, no. The original graph is three separate nodes. Each is a connected component. Each component is bipartitioned into a single node and empty set. So adding an edge between two nodes in the same component (but they are in the same partition?) Well, each component is a single node. So if you add an edge between two different components, like between node 1 and node 2. Then, since the original components are bipartitioned, but adding an edge between two different components. How does that affect the bipartition?\n\nWait, the original graph is bipartitioned. But when adding edges between different components, the bipartition might not be possible. Let me think. Suppose we have two separate bipartite graphs. Adding an edge between two nodes from the same partition (say, both in the A set of their respective components) would make the combined graph not bipartite. But in this case, the original graph is three separate components. So adding an edge between any two nodes (say, node 1 and node 2) would create a new connected component. Let's check if that creates an odd-length cycle. Adding a single edge between node 1 and node 2: the new component has two nodes connected by an edge. The cycle is not present. So there's no cycle. So adding one edge doesn't create a cycle. So to create a cycle, you need at least two edges. For example, adding edges between 1-2 and 2-3. Now, the component is a chain of three nodes. No cycle. Adding another edge between 1 and 3 would form a triangle (cycle of length 3). So that's three edges. So t is 3, which is the sample's output.\n\nSo why did my previous approach fail? Because the approach assumed that adding one edge between two nodes in the same partition of a connected component would create an odd-length cycle. But in this case, the connected components are single nodes. So adding an edge between two nodes (from different components) would not create a cycle. Therefore, the previous approach only applies when the graph is connected. Or perhaps I need to re-examine the logic.\n\nSo the key is that for the graph to have an odd-length cycle, it must not be bipartite. So the problem reduces to:\n\nIf the graph is already not bipartite (i.e., contains an odd-length cycle), then t=0 and w=1.\n\nElse, the graph is bipartite. So we need to find the minimal number of edges to add to make it non-bipartite. What is that minimal number?\n\nFor a bipartite graph, the minimal number of edges to add to make it non-bipartite is 1 if there exists at least two nodes in the same partition of some connected component. Because adding an edge between two nodes in the same partition of a connected component would create an odd-length cycle.\n\nBut if all connected components are bipartite and consist of only one node (so each component is a single node), then adding any edge between two nodes (from different components) would not create an odd-length cycle. Because that would form a connected component of two nodes connected by an edge. Which is bipartite. So to create an odd-length cycle, you need to add enough edges to form a cycle. For example, in the case of three nodes, you need to add three edges to form a triangle.\n\nSo the minimal number of edges depends on the structure of the graph.\n\nSo perhaps the problem can be broken down into two cases:\n\nCase 1: The graph already contains an odd-length cycle. Then t=0, w=1.\n\nCase 2: The graph is bipartite. Then, we need to find the minimal t and the number of ways.\n\nBut how to compute this.\n\nLet me think again. For a bipartite graph, the minimal number of edges to add to make it non-bipartite is either 1 or 2 or more.\n\nWait, if the graph is bipartite, then:\n\nIf there exists a connected component that has at least two nodes, then in that component, there are two nodes in the same partition. So adding an edge between them would create an odd-length cycle. So the minimal t is 1.\n\nBut if all connected components are single-node (i.e., n nodes, m=0), then adding any edge would not create a cycle. So to create a cycle, you need to add enough edges to form a cycle. For example, in the case of three nodes, you need to add three edges. So for this case, the minimal t is (k), where k is the number of nodes in the cycle. But since the cycle needs to be of odd length, the minimal t is 3 (for three nodes) if there are no edges.\n\nSo the problem is more complex than I thought. So how to handle this?\n\nLet me think about the general approach:\n\nFirst, check if the graph is bipartite. If not, output t=0 and w=1.\n\nIf it is bipartite, then we have two possibilities:\n\nEither there exists a connected component with at least two nodes. In that case, adding one edge between two nodes in the same partition of that component would create an odd-length cycle. So t=1, and the number of ways is the sum over all connected components of (C(a_i,2) + C(b_i, 2)), where a_i and b_i are the sizes of the two partitions of component i.\n\nBut if all connected components are single-node (n nodes, m=0), then the minimal t is 3 (adding three edges to form a triangle), and the number of ways is C(n,3) (choosing three nodes and connecting them in a triangle). But wait, the problem says that the added edges must form a cycle of odd length. So for three nodes, adding three edges (the triangle) is the only way. But the number of ways is the number of possible triangles. Which is C(n,3) if n >=3.\n\nBut in the third example, input is 3 0. So n=3. The output is 3 1. Which matches C(3,3) =1. So that's correct.\n\nSo the overall approach is:\n\nCheck if the graph is bipartite. If not, output 0 1.\n\nElse:\n\nCheck if there exists at least one connected component with size >=2. If yes, then t=1 and the number of ways is the sum for each connected component of (C(a_i, 2) + C(b_i, 2)).\n\nIf all components are size 1 (i.e., n nodes and m=0), then t=3 and the number of ways is C(n,3).\n\nBut how to check if the graph is bipartite?\n\nWe can perform BFS-based bipartition checking for each connected component.\n\nSo the steps:\n\n1. Check if the graph is bipartite. If not, then output 0 1.\n\n   How to check if the graph is bipartite? For each connected component, perform BFS and assign colors. If during BFS, we find an edge that connects two nodes of the same color, the graph is not bipartite.\n\n   So during the BFS, if any conflict is found, the graph is not bipartite.\n\n2. If the graph is bipartite:\n\n   a. Check if there is at least one connected component with size >=2.\n\n      - If yes: then t=1, and the number of ways is the sum for each component of (C(a_i,2) + C(b_i,2)).\n\n      - Else (all components are size 1, i.e., n >=1, m=0):\n\n         - If n < 3: then it's impossible to form a cycle. But according to the problem statement, the cycle must consist of more than one vertex. For example, if n=1, then no cycle can be formed. But according to the input constraints, the input can have n=1 and m=0. But the problem says that the output must have a cycle of more than one vertex. So for such cases, what is the answer?\n\nWait, the problem says that the graph is given, and you need to find the minimal number of edges to add to form a simple cycle of odd length consisting of more than one vertex.\n\nSo for example, if n=1 and m=0, then it's impossible to form such a cycle. Because a cycle must have at least two vertices. But according to the problem's sample input, the third input is n=3, m=0. The output is 3 1. So for n=1, the answer would be impossible. But the problem says that the graph is given. So perhaps in such cases, the answer is t= something?\n\nBut according to the problem statement, the input can have n=1, m=0. How to handle that?\n\nBut the problem says that the output should have t and w. So for n=1, the minimal number of edges to add is ... Well, you can't form a cycle. Because you need at least two nodes. So for n=1, you can't form a cycle. But the problem says that the graph is given with n vertices. So in that case, the answer is impossible. However, the problem says that the input is such that the answer exists. Or perhaps the problem allows for such cases, but how?\n\nBut according to the problem statement, the input is such that the graph may not have any cycles. But the problem requires that after adding edges, there is a cycle of odd length with more than one vertex.\n\nSo for n=1, it's impossible. But the problem says that the input is given, but perhaps the code must handle such cases. However, according to the sample input, the third case is n=3 and m=0. Let's think about the code.\n\nSo, for the case when the graph is bipartite, and all connected components are of size 1 (i.e., n nodes, m=0):\n\nIf n < 3: then the minimal number of edges is impossible. But since the problem says that the answer must exist, perhaps the problem ensures that n is at least 3? Or perhaps the code must handle it.\n\nBut looking back at the problem statement's sample input, the third input is n=3, m=0. Output is 3 1. Which implies that when n=3, you need to add 3 edges to form a triangle.\n\nSo for n=1, the answer would be impossible. But the problem says that the input may have such a case. However, the problem statement says that the graph is not necessarily connected. So the code must handle all possible cases.\n\nBut the problem says that the output must be printed. So how to proceed?\n\nLet me think. For the case when the graph is bipartite, and all components are size 1 (i.e., n nodes and m=0):\n\nIf n < 2: then no possible cycle (needs at least two nodes). But since the problem says that the cycle must consist of more than one vertex. So for n=1, the answer is impossible. But according to the problem's constraints, the input may have n=1. But according to the problem's note, the first sample input has n=4, etc. But the code must handle all possible n and m.\n\nBut in such cases, how to compute t and w?\n\nBut let's proceed under the assumption that the problem will not have such cases. But perhaps the code must handle them.\n\nBut according to the problem's sample input, the third case is n=3, m=0. So in that case, the code returns t=3 and w=1.\n\nSo for the case when the graph is bipartite, and all components are size 1, then:\n\nif n < 3: then it's impossible to form a cycle. But since the problem says that the output must be printed, but how? Well, the problem says that the graph may not have any cycles, but the code must find the minimal edges to add. However, for n=1, you can't form any cycle. So in that case, the answer is t=infinity, but since the problem says that the answer must exist, perhaps the input is guaranteed to have n >= 2.\n\nBut according to the problem's input constraints, n can be 1. For example, if n=1 and m=0, then the output would be something. But since the problem says that the output must have a cycle with more than one vertex, perhaps the code must assume that n >= 2. However, the problem's third sample input has n=3, which is allowed.\n\nSo, perhaps in the code, we need to handle the case where all components are single nodes. Let's proceed with that.\n\nSo, for the case where the graph is bipartite, and all components are single nodes (so n nodes and m=0):\n\nThen, the minimal number of edges to add to create an odd-length cycle is:\n\nWe need to form a cycle. The minimal cycle is of length 3 (odd). So, to form a cycle of length 3, you need to add 3 edges. For example, connecting three nodes in a triangle.\n\nThe number of ways is the number of possible triplets of nodes, since each triplet can be connected in exactly one way (adding three edges to form a triangle). So the number of ways is C(n, 3).\n\nBut in this case, the code would return t=3 and w=C(n,3).\n\nBut for n=2, m=0, the code would have to add edges. But forming a cycle requires at least 2 nodes, but a cycle must have at least 3 edges. Wait, no. A cycle with two nodes would require two edges (a loop), but the problem states that loops are prohibited. So for n=2, the minimal number of edges to add to create a cycle of odd length is impossible. Because any cycle must have at least three nodes. So for n=2, even if you add edges between the two nodes, you can't form a cycle. Because a cycle must have at least three edges. So for n=2, the answer is impossible. But according to the problem's input constraints, the code must handle this.\n\nBut how to handle this in code?\n\nThis complicates things. Let me think again.\n\nSo, for the case where the graph is bipartite and all components are single nodes (i.e., n nodes, m=0):\n\nIf n < 3: then no possible way to form a cycle. So the answer is impossible. But the problem says that the input is valid. However, according to the problem statement, the output must be printed. So perhaps the problem guarantees that n >= 3 in such cases. But the problem says that the input can be anything. So the code must handle all cases.\n\nBut how?\n\nLet me think. For the problem's constraints, the input can have n=1. But the code must output t and w. However, the problem says that the answer must be to form a cycle of more than one vertex. So for n=1, it's impossible. But the code must output something. However, according to the problem statement, the input may not have such cases. For example, the problem says that the input is given, but it's not specified whether it's possible to form such a cycle. So perhaps the code can assume that the answer exists.\n\nBut perhaps the problem ensures that n >= 2. Or perhaps the code can handle all cases, including when it's impossible. However, the problem's sample inputs include n=3, which is possible.\n\nBut given that the problem's third sample input is n=3, m=0, which outputs t=3 and w=1. So in that case, the code returns 3 and 1. So for n=2, m=0, the code would have to return t=3, but it's impossible. Because with two nodes, you can't form a cycle of length 3. So the code would have to return t=3, but that's not possible. Therefore, perhaps the code must check for that.\n\nBut this is getting complicated. Let me think again about the problem.\n\nThe problem says that the given graph may not have any cycles. But the code must add edges to form a cycle of odd length. So the minimal number of edges to add depends on the graph's structure.\n\nSo for the case where the graph is bipartite, and all connected components are size 1 (i.e., n nodes and m=0):\n\nIf n < 3: then no possible cycle. So the answer is impossible. However, the problem may not have such test cases.\n\nBut according to the problem's sample input, the third case is n=3, m=0. So the code must handle that.\n\nSo, the code can proceed as follows:\n\nAfter checking that the graph is bipartite:\n\nCheck if there exists at least one connected component with size >=2.\n\nIf yes:\n\nt = 1\n\nw is the sum for each connected component of (C(a_i, 2) + C(b_i, 2)).\n\nElse:\n\nif n < 3:\n\nthen it's impossible to form a cycle. But according to the problem's statement, the output must be printed. However, the problem says that the answer exists. So perhaps the problem guarantees that in this case, n >=3.\n\nAssuming that, then:\n\nt = 3\n\nw = C(n,3)\n\nBut for n=2, the code would return t=3, but that's impossible. However, the problem may not have such cases.\n\nBut how to handle this in code?\n\nWell, let's proceed with the code under the assumption that the problem will not have such cases. So, for the case when all components are size 1, and n >=3, then t=3 and w=C(n,3).\n\nSo now, the code plan is:\n\nImplement the following steps:\n\n1. Check if the graph is bipartite. If not, output 0 1.\n\n   How to check bipartition:\n\n   For each connected component, perform BFS and assign colors. If any conflict, then the graph is not bipartite.\n\n2. If the graph is bipartite:\n\n   a. Check if there exists at least one connected component with size >=2.\n\n      For this, during the BFS, track the size of each component.\n\n   b. If such component exists:\n\n      Compute the sum over all components of (a_i choose 2 + b_i choose 2), which is the number of possible edges that can be added between two nodes in the same partition of that component. This is the number of ways w. t=1.\n\n   c. Else (all components are size 1, i.e., n nodes and m=0):\n\n      if n < 3: then no solution. But according to the problem's sample input, the third case is n=3, m=0, which outputs 3 1.\n\n      else:\n\n         t=3, w = C(n,3)\n\nSo, how to compute this.\n\nNow, the code:\n\nImplementing the Bipartition check.\n\nWe can represent the graph as an adjacency list. For each node, we can perform BFS to check if it's bipartite.\n\nWe also need to track for each connected component, the sizes of the two partitions (a_i and b_i). For example, for each component, during BFS, we can count the number of nodes in each color (0 and 1). So for each component, a_i and b_i are the counts of each color.\n\nNow, code steps:\n\nRead n and m.\n\nBuild adjacency list.\n\nInitialize color array (say, -1 for uncolored).\n\nFor each node from 1 to n:\n\n   if not colored:\n\n      perform BFS/DFS to check bipartition.\n\n      during this process, track the color counts (a and b) for this component.\n\n      if during BFS, a conflict is found, mark the graph as not bipartite.\n\nOnce the bipartition check is done, if the graph is not bipartite, output 0 1.\n\nElse:\n\nCheck if there is at least one component with size >=2.\n\nHow? For each component, during BFS, track the size of the component. For example, for each component, the size is a_i + b_i. So if any component has size >=2, then the answer is t=1 and compute the sum.\n\nElse:\n\nAll components are of size 1. So n is the number of components. Which implies that m=0.\n\nIn that case:\n\nif n < 3: then impossible. But according to the problem's sample input, for n=3, the answer is 3 1.\n\nBut what if n=2? Then, the answer would require adding edges to form a cycle of odd length. But with two nodes, you can't form a cycle. So the minimal t is impossible. However, the problem says that the answer must exist. So perhaps the input ensures that n >=3 in this case.\n\nAssuming that, then proceed.\n\nSo code:\n\nNow, code for the case when all components are size 1:\n\nif n >=3:\n\n   t = 3\n\n   w = comb(n,3)\n\nelse:\n\n   ?\n\nBut according to the problem's sample input, the third case is n=3, m=0. So output is 3 1, which is comb(3,3) =1.\n\nThus, code for that part.\n\nNow, implement this logic.\n\nNow, code in Python:\n\nBut how to compute combinations?\n\nFor example, C(n,3) can be computed as n*(n-1)*(n-2)//6.\n\nSo, in code:\n\nBut for the case where all components are size 1, and n >=3, then:\n\nt = 3\n\nw = n * (n-1) * (n-2) // 6\n\nNow, code steps:\n\nImplement Bipartition check.\n\nLet's proceed.\n\nNow, code:\n\nRead n, m.\n\nadj = [[] for _ in range(n+1)]\n\nfor _ in range(m):\n\n   u, v = map(int, input().split())\n\n   adj[u].append(v)\n\n   adj[v].append(u)\n\ncolor = [-1] * (n+1)\n\nis_bipartite = True\n\ncomponents = []  # list of tuples (a, b) for each component\n\nfor u in range(1, n+1):\n\n   if color[u] == -1:\n\n       # new component\n\n       queue = deque()\n\n       queue.append(u)\n\n       color[u] = 0\n\n       a = 0\n\n       b = 0\n\n       a += 1\n\n       while queue:\n\n           current = queue.popleft()\n\n           for neighbor in adj[current]:\n\n               if color[neighbor] == -1:\n\n                   color[neighbor] = color[current] ^ 1\n\n                   if color[neighbor] == 0:\n\n                       a +=1\n\n                   else:\n\n                       b +=1\n\n                   queue.append(neighbor)\n\n               else:\n\n                   if color[neighbor] == color[current]:\n\n                       is_bipartite = False\n\n       # Wait, the initial code for counting a and b is incorrect.\n\nWait, the initial code for counting a and b is wrong. Because in the code above, when we start with u, color[u] is set to 0. Then, the initial a and b counts are a=1, b=0. Then, for each neighbor, when we assign color, we increment a or b accordingly. But the code above is not correct. Let me think again.\n\nActually, during BFS, for each component, we can track the count of nodes with color 0 and color 1. So for the component starting at u:\n\nInitially, color[u] is 0. So count_0 = 1, count_1 = 0.\n\nThen, for each neighbor processed, we check their color. For example, when we process a node, we check its neighbors. For each neighbor, if not colored, assign the opposite color, and increment the count accordingly.\n\nSo the correct way is:\n\nfor each component:\n\ncount_0 = 0\n\ncount_1 = 0\n\nwhen we color a node, increment count_0 or count_1 accordingly.\n\nSo, during BFS:\n\nWhen processing a node, for example, when we add a node to the queue, we assign its color and increment the count.\n\nSo, let me rewrite the code:\n\nfor u in 1..n:\n\n   if color[u] is -1:\n\n       queue = deque([u])\n\n       color[u] = 0\n\n       count_0 = 1\n\n       count_1 = 0\n\n       while queue not empty:\n\n           current = queue.popleft()\n\n           for neighbor in adj[current]:\n\n               if color[neighbor] == -1:\n\n                   color[neighbor] = color[current] ^ 1\n\n                   if color[neighbor] == 0:\n\n                       count_0 +=1\n\n                   else:\n\n                       count_1 +=1\n\n                   queue.append(neighbor)\n\n               else:\n\n                   if color[neighbor] == color[current]:\n\n                       is_bipartite = False\n\n       components.append( (count_0, count_1) )\n\nBut wait, this code may miss some nodes. Because when we process a node, we check its neighbors. However, the code for the initial node u is added to the queue. Then, during processing, for each neighbor, if not colored, we assign color and add to queue. So this should process all nodes in the component.\n\nBut in this code, during BFS, for each node in the component, we count how many are in color 0 and color 1.\n\nOnce the BFS is done, the component's counts are (count_0, count_1).\n\nBut during BFS, the code may not check all edges. For example, when a neighbor is already colored, but the code checks if it's same color as current. However, this is done during BFS.\n\nSo the code for checking bipartition is correct.\n\nBut in the code above, during the BFS, the code may not check all edges. For example, suppose there is an edge between two nodes that are already processed. But the code checks that when the neighbor is processed. However, the code only checks for conflicts when the neighbor is being colored. For example, if the current node is being processed, and the neighbor is already colored, then if the neighbor has the same color as current, it's a conflict. However, this may not catch all conflicts. For example, in a cycle of odd length, during BFS, the conflict is detected when processing the last edge. But in a bipartition check, this is correct.\n\nSo the code for checking bipartition is correct.\n\nOnce this is done, the components list contains (count_0, count_1) for each component.\n\nOnce that is done, if the graph is not bipartite, output 0 1.\n\nElse:\n\nCheck if there is at least one component with count_0 + count_1 >= 2.\n\nWhich is equivalent to checking if any component has size >= 2.\n\nIf yes:\n\nsum_ways = sum( (a * (a-1) // 2) + (b * (b-1) // 2) for a, b in components )\n\nt = 1\n\nw = sum_ways\n\nElse:\n\n   if n >=3:\n\n      t = 3\n\n      w = n * (n-1) * (n-2) // 6\n\n   else:\n\n      ?\n\nBut for the case where n <3, but all components are size 1, then:\n\nif n == 1: can",
    "response": "To solve this problem, we need to determine the minimum number of edges required to transform a given undirected graph into one that contains a simple cycle of odd length. Additionally, we need to find the number of ways to achieve this transformation.\n\n### Approach\n1. **Check Bipartiteness**: A graph is bipartite if it can be colored using two colors such that no two adjacent nodes share the same color. If the graph is not bipartite, it already contains an odd-length cycle, so the answer is `0 1`.\n2. **Component Analysis**: If the graph is bipartite, analyze each connected component to determine the minimum edges needed to create an odd-length cycle:\n   - **Existing Components with Size ≥ 2**: For each component, calculate the number of ways to add edges between nodes in the same partition (which would create an odd-length cycle). The minimum number of edges required here is 1.\n   - **All Components are Single Nodes**: If all components are single nodes (i.e., the graph has no edges), then forming a cycle requires creating a triangle (3 nodes), which needs 3 edges. The number of ways to choose 3 nodes from `n` nodes is given by the combination formula $ C(n, 3) $.\n\n### Solution Code\n```python\nimport sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n    \n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u = int(input[idx])\n        idx += 1\n        v = int(input[idx])\n        idx += 1\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    color = [-1] * (n + 1)\n    is_bipartite = True\n    components = []\n    \n    for u in range(1, n + 1):\n        if color[u] == -1:\n            queue = deque()\n            queue.append(u)\n            color[u] = 0\n            count_0 = 1\n            count_1 = 0\n            while queue:\n                current = queue.popleft()\n                for neighbor in adj[current]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = color[current] ^ 1\n                        if color[neighbor] == 0:\n                            count_0 += 1\n                        else:\n                            count_1 += 1\n                        queue.append(neighbor)\n                    else:\n                        if color[neighbor] == color[current]:\n                            is_bipartite = False\n            components.append((count_0, count_1))\n    \n    if not is_bipartite:\n        print(\"0 1\")\n        return\n    \n    has_large_component = False\n    for a, b in components:\n        if a + b >= 2:\n            has_large_component = True\n            break\n    \n    if has_large_component:\n        sum_ways = 0\n        for a, b in components:\n            sum_ways += (a * (a - 1)) // 2 + (b * (b - 1)) // 2\n        print(f\"1 {sum_ways}\")\n    else:\n        # All components are single nodes\n        if n < 3:\n            print(\"0 1\")\n        else:\n            ways = n * (n - 1) * (n - 2) // 6\n            print(f\"3 {ways}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Bipartite Check**: Using BFS, we check if the graph can be colored with two colors without conflicts. If any conflict is found, the graph is not bipartite and contains an odd-length cycle.\n- **Component Analysis**: For each connected component, we count the nodes in each partition. If any component has at least two nodes, we calculate the number of ways to add edges within the same partition.\n- **Handling All Single-Node Components**: If all nodes are isolated, forming a cycle requires creating a triangle (3 nodes), which is handled by computing combinations of nodes taken three at a time.\n\nThis approach ensures we efficiently determine the minimum edges and ways to form an odd-length cycle based on the graph's structure.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n    \n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u = int(input[idx])\n        idx += 1\n        v = int(input[idx])\n        idx += 1\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    color = [-1] * (n + 1)\n    is_bipartite = True\n    components = []\n    \n    for u in range(1, n + 1):\n        if color[u] == -1:\n            queue = deque()\n            queue.append(u)\n            color[u] = 0\n            count_0 = 1\n            count_1 = 0\n            while queue:\n                current = queue.popleft()\n                for neighbor in adj[current]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = color[current] ^ 1\n                        if color[neighbor] == 0:\n                            count_0 += 1\n                        else:\n                            count_1 += 1\n                        queue.append(neighbor)\n                    else:\n                        if color[neighbor] == color[current]:\n                            is_bipartite = False\n            components.append((count_0, count_1))\n    \n    if not is_bipartite:\n        print(\"0 1\")\n        return\n    \n    has_large_component = False\n    for a, b in components:\n        if a + b >= 2:\n            has_large_component = True\n            break\n    \n    if has_large_component:\n        sum_ways = 0\n        for a, b in components:\n            sum_ways += (a * (a - 1)) // 2 + (b * (b - 1)) // 2\n        print(f\"1 {sum_ways}\")\n    else:\n        # All components are single nodes\n        if n < 3:\n            print(\"0 1\")\n        else:\n            ways = n * (n - 1) * (n - 2) // 6\n            print(f\"3 {ways}\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 579,
        "completion_token_count": 918,
        "thoughts_token_count": 8192
    }
}