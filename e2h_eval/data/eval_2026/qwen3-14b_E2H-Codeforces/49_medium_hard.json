{
    "start": 1758338782.5755625,
    "end": 1758338989.4660826,
    "start-formatted": "2025-09-20 12:26 KST",
    "end-formatted": "2025-09-20 12:29 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\nOkay, let's tackle this problem. Hmm, the problem is about restoring the number of mushrooms on each lawn based on the GCD and LCM values given for each road. So each road connects two lawns, and for that pair, we know their GCD and LCM. Our job is to assign numbers to each lawn such that all these conditions are satisfied.\n\nFirst, I need to think about the constraints. For any two nodes connected by an edge, say u and v, their GCD is g and LCM is l. Now, there's a mathematical relationship here. Remember that for two numbers a and b, GCD(a,b) * LCM(a,b) = a*b. So, if we have g and l, then a*b = g*l. Also, since the GCD is g, both a and b must be multiples of g. Let me think: Let's say a = g * x, b = g * y. Then GCD(a,b) is g * GCD(x,y). But since the given GCD is g, this implies that GCD(x,y) must be 1. Also, the LCM of a and b would be g * LCM(x,y). But since LCM(a,b) is given as l, then LCM(x,y) = l/g. But since x and y are coprime, LCM(x,y) is x*y. Therefore, x*y = l/g. \n\nSo putting it all together, for each edge between u and v with given g and l, we can say that a_u and a_v must be multiples of g, and their product must be g*l. Also, since x and y are coprime, the values of a_u/g and a_v/g must be coprime. \n\nSo, the problem reduces to assigning values to each node such that for every edge (u, v), the values assigned to u and v are multiples of g, and when divided by g, they are coprime, and their product is l/g. \n\nBut how do we model this? It seems like a graph problem where each edge imposes constraints on the values of the nodes. \n\nThis feels similar to a bipartition problem or a graph coloring problem, but with numerical constraints. However, since the constraints involve multiplicative relationships, maybe we can model this as a graph where each node's value is determined relative to others. \n\nLet me think about building equations. Suppose we have a connected component. If we can assign a value to one node, perhaps we can derive the values of others based on the edges. However, there might be contradictions if the constraints are conflicting. \n\nFor example, consider a chain of edges. Let's say node A is connected to B with GCD g1 and LCM l1. Then B is connected to C with GCD g2 and LCM l2. The value of B must satisfy both edges. How can we ensure consistency?\n\nAnother approach: For each edge (u, v, g, l), we can represent that a_u = g * x, a_v = g * y, where x and y are coprime, and x*y = l/g. So for each edge, x and y are factors of l/g, and coprime. Therefore, x must be a divisor of l/g, and y must be l/g divided by x. Also, since x and y are coprime, this uniquely defines x and y once we choose one. However, for the edge, there are two possibilities: x and y could be swapped. So for example, if the edge is between u and v, then a_u could be g*x and a_v could be g*y, or vice versa. \n\nBut how do we model this in a graph? Maybe we can model this as a graph where each node's value is determined up to a factor, and we need to assign these factors such that all constraints are satisfied. \n\nThis seems like a problem that can be modeled using Union-Find (Disjoint Set Union) with some additional constraints, but I'm not sure. Alternatively, maybe we can model it as a system of equations and use BFS or DFS to assign values. \n\nLet me think of a way to model this. Let's take a connected component. Suppose we pick a starting node and assign a value to it. Then, for each adjacent node, we can determine possible values based on the edge constraints. However, the problem is that there might be multiple possibilities for the values, and we need to make sure that all constraints are consistent. \n\nFor example, suppose we have a cycle in the graph. The constraints around the cycle must be consistent. Otherwise, there's no solution. \n\nLet me take an example. Suppose there's a triangle of nodes A-B, B-C, C-A. Each edge has some GCD and LCM. When we assign a value to A, then B's value is determined based on the A-B edge. Then, C's value is determined based on B-C edge. Then, when checking the C-A edge, we need to see if the values of C and A meet the required GCD and LCM. If not, then it's impossible. \n\nSo the approach would be:\n\n1. For each connected component in the graph, assign values to the nodes. \n2. For each component, perform a BFS or DFS, assigning values based on the edges. \n3. During traversal, check for consistency. \n4. If any inconsistency is found, return \"NO\". Otherwise, collect the values.\n\nBut how exactly to assign the values during traversal?\n\nLet's think about the process. Suppose we start with a node u. We can assign it a value. Then, for each neighbor v connected by an edge with GCD g and LCM l, we can compute the possible values for v based on u's value. \n\nWait, but how? Let's say u has a value a. The edge between u and v has GCD g and LCM l. So, the GCD of a and b (where b is v's value) is g, and LCM is l. \n\nWe know that a and b must be multiples of g. Let's denote a = g * x, b = g * y. Then, x and y are coprime, and x*y = l/g. \n\nSo, given a, we can compute x = a/g. Then, y must be (l/g)/x. But since x*y = l/g, and x is known, y is determined. However, since x and y must be coprime, we need to check that this holds. \n\nBut wait, since a is already determined, and given the edge's g and l, we can compute what y should be. However, for that, we need to check if x divides (l/g), and that x and y are coprime. \n\nBut here's the problem: if we start with a value for u, then for each edge from u to v, we can compute what the value of v must be. But how do we choose the initial value for u?\n\nWait, perhaps the initial value isn't arbitrary. Because for the edge between u and v, given that a and b are multiples of g, and that a and b must satisfy a*b = g*l. So, if we know a, then b is (g*l)/a. However, since a must be a multiple of g, and (g*l)/a must also be a multiple of g. Let's check that:\n\nLet me see: Let's say a is a multiple of g. Then, (g*l)/a must be a multiple of g? No, that's not necessarily true. Wait, but the GCD of a and b is g, so both a and b must be multiples of g. Therefore, for the edge between u and v, once a is determined, then b must be (g*l)/a. But since b must be a multiple of g, then (g*l)/a must be divisible by g. Which implies that a must divide l. Because (g*l)/a must be divisible by g → (g*l)/a = k * g → l/a = k → a divides l. \n\nSo, for a to be valid, a must divide l. Also, since a is a multiple of g, then a is equal to g * x, where x divides (l/g). \n\nBut how do we choose the value of a for the starting node?\n\nAh, here's a problem. The value of a is not fixed. So, perhaps the initial assignment is not arbitrary. But how can we proceed?\n\nAlternatively, perhaps the value of a node can be represented in terms of the product of the GCDs and LCMs along the path from the root. \n\nWait, here's an idea. Let's model the problem as a graph where each node's value is determined by the product of certain factors along the path from the root. \n\nBut how?\n\nLet me think again. For each edge between u and v, the GCD and LCM are given. Let's say that the value of u is a and v is b. Then, as before, a = g * x, b = g * y, x and y coprime, x*y = l/g. \n\nNow, if we have a path from u to v, the values of the nodes along the path must be consistent with all edges. \n\nBut perhaps the key is that for each connected component, the values are determined up to a multiplicative factor. For example, if we have a tree structure, once we assign a value to the root, the rest of the values are determined. However, in a cycle, we need to check for consistency.\n\nWait, but how?\n\nLet me think of the problem as building a graph where each node's value is determined by the product of some factors. Let's consider building a graph where each node's value is determined by the product of the GCDs and the LCMs along the edges. \n\nAlternatively, here's a different approach. For each node, we can represent its value as a product of a base value multiplied by some factors. But I'm not sure.\n\nAnother angle: For each edge (u, v, g, l), since a_u and a_v must be multiples of g, and their product is g*l. So, a_u * a_v = g*l. Also, GCD(a_u, a_v) = g. \n\nLet me think of the ratio between a_u and a_v. Let's say that a_u / g = x, a_v / g = y. Then, x and y are coprime, and x*y = l/g. \n\nSo, for each edge, the pair (x, y) must be such that x*y = l/g and GCD(x, y) = 1. \n\nBut since x and y are coprime, their product is l/g, which implies that x and y are divisors of l/g and are coprime. \n\nTherefore, for each edge, we can find the pair (x, y) as a pair of coprime integers whose product is l/g. However, since the order matters (as x corresponds to u and y to v), but the problem allows for either possibility (since the edge can be traversed in either direction), we need to assign x and y accordingly. \n\nBut how do we model this in the graph? \n\nThis seems like a problem that can be modeled as a graph where each node's value is determined relative to another node. For example, if we have a tree structure, we can assign a value to the root, and then propagate the values through the tree. However, for cycles, we need to ensure that the constraints are consistent.\n\nLet me think of the following approach:\n\n- Treat the graph as a collection of connected components. For each connected component, perform a BFS or DFS to assign values to the nodes. \n\n- Start with an arbitrary node and assign it a value. Then, for each adjacent node, determine its value based on the edge's constraints. \n\nBut how to choose the initial value?\n\nWait, the initial value can be arbitrary? No, because the value must satisfy the constraints of the edges. For example, suppose the first node is u, and it's connected to v. Then, for the edge between u and v, the product of their values must be g*l. So, if I assign a value to u, then v's value is determined as (g*l)/a_u. However, this value must also be a multiple of g, and when divided by g, must be coprime with a_u/g. \n\nBut how do I choose a_u? Well, for the first node, perhaps we can assign it as g multiplied by x, where x is a divisor of l/g. But since the problem allows for any possible assignment, perhaps we can choose x as 1, and then see if that leads to a contradiction. However, this might not work in all cases. \n\nAlternatively, perhaps the value of the first node is determined by the constraints of the edges. For example, if the node is connected to multiple edges, the initial value must satisfy all those constraints. But how?\n\nWait, this seems complicated. Let's take an example. Suppose we have a single edge between u and v, with GCD g and LCM l. Then, the possible pairs for (a_u, a_v) are (g*x, g*y) where x*y = l/g and x and y are coprime. So, there are multiple possibilities. For example, if l/g is 6, then possible (x,y) pairs are (1,6), (2,3), (3,2), (6,1). But since x and y are coprime. \n\nIn this case, we can choose any of these pairs. For example, assign a_u = g*1, a_v = g*6. Or assign a_u = g*2, a_v = g*3. \n\nBut how to choose between them? Since the problem allows any valid assignment, perhaps we can choose one arbitrarily. However, when there are multiple edges, this choice might affect the rest of the assignments. \n\nBut how can we model this? It seems that the problem requires us to assign values in such a way that for each edge, the constraints are met. This sounds like a system of equations, but with variables being the node values. \n\nBut solving such a system directly is not straightforward. \n\nAlternative idea: For each edge, the product of the two nodes' values is fixed. So, for the entire graph, the product of all nodes' values in a connected component is fixed up to some factors. However, this might not help directly. \n\nLet me think again about the relations. For any connected component, the values are interdependent. Let's imagine that we have a spanning tree for the component. If we assign a value to the root, then we can compute the values of all other nodes based on the edges. However, when there are cycles, we need to ensure that the computed values are consistent with the edges in the cycle. \n\nSo, here's a plan:\n\nFor each connected component:\n\n1. Choose a root node and assign it an initial value. However, what value? Well, perhaps the initial value can be determined based on the constraints of the edges. But how?\n\nWait, maybe the initial value can be chosen as g * x, where x is a divisor of l/g for the first edge. But this seems arbitrary. \n\nAlternatively, maybe the initial value can be chosen as any possible value that satisfies the constraints of the edges connected to the root. But since the root may have multiple edges, this might not be straightforward. \n\nAlternatively, perhaps we can model the problem as a system of equations where for each edge (u, v), a_u * a_v = g * l. Then, for a connected component, the product of all a_i's is determined up to a square root? Not sure. \n\nAlternatively, considering that for any connected component, the product of all a_i's is fixed. For example, if we have a tree structure, the product of all a_i's can be derived from the product of the edges. But I'm not sure. \n\nLet me think of a simple example. Suppose we have two nodes connected by an edge. Their product is g*l. So, the product of the two nodes is fixed. \n\nIf there are three nodes connected in a line (A-B-C), then the product of A*B*C would be (A*B) * (B*C) / B. Which is (g1*l1) * (g2*l2) / B. But since B is part of both products, this might not help. \n\nHmm. This approach might not be helpful. \n\nBack to the previous idea of using BFS/DFS. Let's think of the following steps:\n\n- For each connected component, perform BFS/DFS starting from a node. Assign a value to the starting node, then propagate the values to adjacent nodes based on the edges. However, the problem is choosing the initial value. \n\nBut how can we choose the initial value? Let's think. Suppose the starting node is u, and it's connected to v via an edge with GCD g and LCM l. Then, a_u * a_v = g*l. Also, a_u must be a multiple of g, and a_v must be a multiple of g. \n\nSo, a_u can be any multiple of g such that (g*l) / a_u is also a multiple of g. Which implies that a_u must divide (g*l) and a_u must be a multiple of g. \n\nBut how can we choose a_u? Well, perhaps we can set a_u as g multiplied by x, where x is a divisor of (l/g). But since x and y (which is (l/g)/x) must be coprime, x must be a divisor of l/g and coprime with (l/g)/x. \n\nWait, but x and y are coprime, so x must be a divisor of l/g and coprime with (l/g)/x. Which is equivalent to x and (l/g)/x being coprime. Which is always true if x is a divisor of l/g and x and (l/g)/x are coprime. But how can we find such x?\n\nActually, since x and y are coprime and x*y = l/g, then x must be a divisor of l/g, and y is l/g divided by x. And since they are coprime, x must be such that all prime factors of x are not present in y. Which implies that x must be a divisor of l/g, and x must be square-free? Not necessarily. Wait, for example, if l/g is 6, then x could be 2 and y would be 3. They are coprime. But 2 is not square-free. Wait, 2 is square-free. Hmm. \n\nIn any case, for each edge, the possible pairs (x, y) are coprime divisors of l/g. But how to choose which one to take during BFS/DFS?\n\nThis seems tricky. However, perhaps for each edge, once we have one node's value, the other node's value is uniquely determined. For example, if we have a_u, then a_v must be (g*l) / a_u. \n\nBut then, how to choose the initial value of a_u? \n\nWait, here's an idea. For the first node in the BFS, we can assign it a value that is a multiple of the GCD of all edges connected to it. But I'm not sure. \n\nAlternatively, perhaps during the BFS, when we process an edge, we can assign the value of the adjacent node based on the current node's value. But since the current node's value is determined earlier, this would fix the adjacent node's value. However, this approach would require that the initial value of the starting node is chosen such that all constraints are satisfied. \n\nBut how to choose that initial value? \n\nLet me think of an example. Suppose we have a single edge between u and v with GCD g=2 and LCM l=6. Then, a_u * a_v = 2*6 = 12. Also, a_u and a_v must be multiples of 2. So possible pairs are (2,6), (6,2), (4, 3) — but wait, 3 is not a multiple of 2. So that's invalid. So only (2,6) and (6,2). \n\nSo, in this case, the possible values for a_u are 2 or 6. \n\nBut if I choose a_u as 2, then a_v is 6. If I choose a_u as 6, then a_v is 2. \n\nSo, during BFS, if I start with u, I can choose either 2 or 6. However, if there are other edges connected to u, this choice may affect the validity of the rest of the assignments. \n\nBut how can I choose between them? \n\nThis suggests that the initial value can't be arbitrary. It must be chosen in such a way that all constraints are satisfied. However, without knowing the rest of the graph, how can I choose this value?\n\nThis seems like a problem. Maybe there's a way to represent the values in terms of the GCD and LCM of the edges. \n\nWait, another thought: For any node u, its value must be a multiple of all the GCDs of the edges connected to it. Because for each edge, the value of u must be a multiple of the GCD of that edge. \n\nBut if a node is connected to multiple edges with different GCDs, then the value of u must be a multiple of the LCM of all those GCDs. \n\nFor example, if u is connected to two edges with GCDs 2 and 3, then the value of u must be a multiple of LCM(2,3) = 6. \n\nThis seems like a crucial point. \n\nSo, for each node, the value must be a multiple of the LCM of all the GCDs of the edges connected to it. \n\nLet me verify this. Suppose a node u is connected to two edges. Edge1 has GCD g1, Edge2 has GCD g2. Then, the value of u must be a multiple of g1 and also a multiple of g2. Hence, it must be a multiple of LCM(g1, g2). \n\nYes. \n\nSo, this gives us a constraint on the possible values of each node. \n\nTherefore, for the starting node, the initial value must be a multiple of the LCM of all the GCDs of the edges connected to it. \n\nBut how do we find that initial value? \n\nWell, perhaps the minimal possible value is the LCM of the GCDs of the edges connected to it. But even that may not be sufficient, because the value must also satisfy the constraints of the edges. \n\nBut this gives us a starting point. \n\nLet me try to formalize the approach:\n\nFor each connected component:\n\n1. For each node in the component, compute the LCM of all the GCDs of its incident edges. Let's call this value 'base'. The node's value must be a multiple of 'base'.\n\n2. Assign a value to the starting node. Let's say we choose 'base' as the initial value. \n\n3. Then, for each adjacent node, compute their value based on the edge's constraints. \n\nBut how to compute the adjacent node's value?\n\nLet me take an example. Suppose we have a node u with value a, connected to node v via an edge with GCD g and LCM l. Then, the product of a and b (the value of v) must be g*l. \n\nSo, b = (g*l) / a. \n\nBut since a is a multiple of g (because it's a multiple of the base, which is the LCM of the GCDs of its edges, including this one), then (g*l) must be divisible by a. \n\nWait, but why? Because a is a multiple of g, and l is given. \n\nWait, let's see: \n\nWe have a = k * g. \n\nThen, b = (g*l) / (k * g) ) = l/(k). \n\nBut since b must be a multiple of g (as per the edge's GCD), then l/k must be divisible by g. \n\nSo, l/k must be divisible by g → l must be divisible by k * g → k must divide l/g. \n\nBut since a is k*g, and a must be a multiple of the base (which is LCM of the GCDs of edges connected to u), this may impose constraints on k. \n\nBut how can we ensure that this is possible? \n\nThis seems very complex. \n\nPerhaps the correct approach is to model the problem as a graph where each node's value is determined relative to others, and during traversal, we check for consistency. \n\nLet me think of the following steps:\n\nFor each connected component:\n\n- Select a starting node. \n\n- Assign to it a value that is the LCM of all the GCDs of its incident edges. Let's call this value 'val'.\n\n- Then, for each neighbor, compute the value based on the edge's constraints. \n\n- For each edge (u, v, g, l), once u's value is known, v's value is determined as (g*l) / u_val. \n\n- Check if this value is a multiple of the GCD of that edge (g). \n\n- Also, check that the GCD of u_val and v_val is equal to g, and their LCM is equal to l. \n\nBut why would that be necessary? Because when you compute v_val as (g*l)/u_val, then the product of u_val and v_val is g*l. However, the GCD and LCM of u_val and v_val must match the given ones. \n\nBut how can we ensure that?\n\nLet me take an example. Suppose u_val is 2, and the edge has g=2, l=6. Then v_val is (2*6)/2 = 6. GCD(2,6)=2, LCM(2,6)=6. Correct. \n\nAnother example: suppose u_val is 6, same edge. Then v_val is (2*6)/6 = 2. Same result. \n\nBut what if the edge has g=2, l=6. Suppose u_val is 4. Then v_val is 3. But 3 is not a multiple of 2. Which is invalid. So, this would be rejected. \n\nBut how do we ensure that the computed v_val is a multiple of g? \n\nBecause during the traversal, when we compute v_val as (g*l)/u_val, we must check that this value is indeed a multiple of g. \n\nBut why would that be the case? Because u_val is a multiple of the LCM of the GCDs of its edges, which includes this edge's GCD. Therefore, u_val is a multiple of g. Let me see:\n\nLet me denote u_val as a multiple of g. Let's say u_val = k * g. Then, v_val = (g*l) / (k * g) ) = l/(k). \n\nBut for v_val to be a multiple of g, l/k must be divisible by g → l must be divisible by k * g → k must divide l/g. \n\nBut how can we ensure that? \n\nBecause when we choose the initial value for the starting node, we need to make sure that for all edges connected to it, the computed values for neighbors are multiples of the respective GCDs. \n\nBut how can we choose the initial value to ensure that? \n\nThis seems like a problem. Because the initial value may not be chosen correctly, leading to invalid values for neighbors. \n\nSo, perhaps the initial value must be chosen such that for all edges connected to the starting node, the value computed for the neighbor is a multiple of the GCD of that edge. \n\nBut how to find such a value? \n\nLet me think again. For the initial node u, its value must be a multiple of the LCM of the GCDs of its incident edges. Let's call this base_val. \n\nSuppose u is connected to an edge with GCD g and LCM l. Then, the value of u is base_val, which is a multiple of g. So, when computing v_val = (g*l)/base_val, we need to ensure that this is a multiple of g. \n\nWhich implies that (g*l) / base_val must be divisible by g → l / base_val must be divisible by 1 → l must be divisible by base_val. \n\nBut that's not necessarily true. \n\nWait, no. Let me re-calculate:\n\nv_val = (g*l) / u_val. \n\nWe need v_val to be divisible by g. \n\nSo:\n\n(g*l) / u_val must be divisible by g → (g*l) / u_val = k * g → l / u_val = k → u_val divides l. \n\nSo, for this to be true, u_val must divide l. \n\nBut u_val is the base_val, which is the LCM of the GCDs of the edges connected to u. \n\nSo, for each edge connected to u, the base_val must divide l. \n\nBut why would that be the case? \n\nNot necessarily. For example, suppose u is connected to an edge with GCD=2 and LCM=6. Then, l=6. The base_val for u is LCM of the GCDs of its edges. If u has only this edge, then base_val is 2. Then, u_val is 2, which divides l=6. So, yes. \n\nBut if u is connected to another edge with GCD=3 and LCM=15, then base_val is LCM(2,3) = 6. For the first edge (GCD=2, LCM=6), l=6. So u_val is 6, which divides l=6. So yes. \n\nBut for the second edge (GCD=3, LCM=15), l=15. u_val is 6, which does not divide 15. So, when calculating v_val for that edge, we get (3*15)/6 = 7.5, which is not an integer. So this would be invalid. \n\nBut how can that be? How can the initial value be chosen in such a way that it divides all l's of the edges connected to u?\n\nThis suggests that the initial approach of setting the initial value as the base_val may not work. \n\nHmm. So this seems like a problem. How can we choose the initial value for the starting node such that for all edges connected to it, u_val divides l (the LCM of that edge)?\n\nBut how can we find such a value?\n\nPerhaps the base_val must be a divisor of l for each edge connected to u. \n\nBut this is not guaranteed. \n\nFor example, take u with two edges. One has GCD=2, LCM=6. Another has GCD=3, LCM=15. The base_val is LCM(2,3)=6. For the first edge, 6 divides 6 → yes. For the second edge, 6 divides 15? No. So this would fail. \n\nBut that would mean that there's no solution for this scenario. \n\nBut wait, let's think: Is there a possible assignment of values to u and its neighbors?\n\nFor the first edge, u and v1 must have values such that their product is 2*6=12. Both are multiples of 2. Possible pairs: (2,6), (6,2), etc.\n\nFor the second edge, u and v2 must have product 3*15=45. Both are multiples of 3. Possible pairs: (3,15), (15,3), (9, 5), etc. But 9 and 5 are coprime. \n\nBut u's value must satisfy both edges. So, u's value must be a multiple of 2 and 3, i.e., 6. So possible values for u are 6, 12, 18, etc. \n\nLet's take u=6. For the first edge, v1 = 12 / 6 = 2. Which is a multiple of 2. For the second edge, v2 = 45 / 6 = 7.5 → not integer. Invalid. \n\nWhat about u= 3* something? No, because u must be a multiple of 6. \n\nSo there's no solution. Hence, the answer would be NO. \n\nSo, in this case, the problem is unsolvable. \n\nBut how can we detect this during the BFS?\n\nThe problem is that the initial value (base_val) doesn't divide the l of the edge. So, during the BFS, when we compute v_val, it's not an integer, which is invalid. \n\nTherefore, the algorithm would detect this and return NO. \n\nSo, the steps would be:\n\nFor each connected component:\n\n1. Compute for each node the base_val (LCM of the GCDs of its incident edges).\n\n2. For the starting node, assign it base_val. \n\n3. For each edge from this node, compute the neighbor's value as (g*l) / current_val. \n\n   - Check if this value is an integer. If not, return NO.\n\n   - Check if it's a multiple of the edge's GCD. \n\n   - Also, check if the GCD of current_val and neighbor_val equals the edge's GCD, and LCM equals the edge's LCM. \n\n   - If any of these checks fail, return NO. \n\n4. Proceed with BFS/DFS, propagating values to other nodes. \n\nBut how to handle the case where the initial value may not divide the l of the edge, leading to invalid values? \n\nIn this case, the algorithm would detect that and return NO. \n\nBut what if there exists a valid value for the starting node that is not the base_val? For example, if the base_val doesn't divide l, but another multiple of base_val does?\n\nLet me think. Suppose base_val is 6, but for an edge with l=15, we need u_val to divide 15. But 6 doesn't divide 15. However, what if u_val is 3* something? No, because base_val is 6, which is LCM of the GCDs of its edges. So, u_val must be a multiple of 6. \n\nThus, there's no possible value for u_val that is a multiple of 6 and divides 15. Because 6 and 15 have a GCD of 3. So, the multiples of 6 are 6, 12, 18, etc. None of these divide 15. \n\nHence, in this case, there's no solution. \n\nSo, the algorithm is correct in returning NO. \n\nTherefore, the approach is:\n\nFor each connected component:\n\n   - Compute base_val for each node (LCM of GCDs of its incident edges).\n\n   - Perform BFS/DFS, starting with a node. Assign it base_val.\n\n   - For each neighbor, compute the value based on the edge's g and l. Check if the computed value is valid (integer, multiple of g, and GCD and LCM match).\n\n   - Proceed recursively. \n\nBut during BFS/DFS, if a node is already visited, check if the computed value matches the existing one. If not, return NO. \n\nSo, the steps are:\n\nInitialize a list of values for each node, initially set to None. \n\nFor each connected component:\n\n   Pick a starting node. \n\n   Assign its value as base_val. \n\n   Proceed with BFS/DFS:\n\n      For each current node u, iterate over its edges:\n\n         For each edge (u, v, g, l):\n\n            if v is not visited:\n\n               compute v_val = (g*l) // u_val \n\n               check if u_val * v_val == g*l \n\n               check if v_val is a multiple of g \n\n               check if GCD(u_val, v_val) == g \n\n               check if LCM(u_val, v_val) == l \n\n               if all pass, assign v_val to v and proceed. \n\n            else:\n\n               check if v's current value is equal to (g*l) // u_val. \n\n               if not, return NO. \n\nSo, this approach should work. \n\nNow, the question is, how to compute the base_val for each node. \n\nFor each node, base_val is LCM of all the GCDs of its incident edges. \n\nSo, for each node, we can iterate through its edges, collect the GCDs, and compute their LCM. \n\nBut what if a node has no edges? Like in the first sample input, where n=1 and m=0. Then, the base_val for that node is undefined. However, since there are no edges, the value can be any positive integer. But since the problem says that the original map had numbers >=1 and <=1e6, but the problem allows any valid assignment. However, in this case, since there are no constraints, the value can be any number. But the problem says that the answer is any valid arrangement. So, for a node with no edges, we can assign it 1. \n\nSo, during the base_val computation, for a node with no edges, its base_val is 1. \n\nWait, but how to handle that? \n\nLet me think. For a node with no edges, there are no constraints. So, its value can be any positive integer. However, the problem requires us to output any valid arrangement. So, for such nodes, we can assign them any value, like 1. \n\nThus, during the base_val calculation, for nodes with no edges, base_val is 1. \n\nNow, let's think about the steps to implement this:\n\nFirst, read the input. \n\nWe have n and m. Then, m lines of edges. \n\nFor each node, collect its edges. \n\nThen, for each node, compute base_val as LCM of all the GCDs of its edges. For nodes with no edges, base_val is 1. \n\nOnce that is done, for each connected component, perform BFS/DFS:\n\n   Assign the starting node's value as base_val. \n\n   For each edge in the component, propagate the values. \n\n   During propagation, check for consistency.",
    "response": "To solve this problem, we need to determine the number of mushrooms on each lawn based on given GCD and LCM values for each road connecting two lawns. The solution involves checking for consistency in the constraints provided by these values and using a graph traversal approach to propagate values through the connected components of the graph.\n\n### Approach\n1. **Graph Representation**: Represent the lawns and roads as an undirected graph where each node (lawn) is connected to other nodes via edges with associated GCD and LCM values.\n2. **Base Value Calculation**: For each node, compute a base value which is the Least Common Multiple (LCM) of the GCDs of all incident edges. This ensures that the node's value is a multiple of all necessary GCDs.\n3. **Breadth-First Search (BFS)**: Use BFS to traverse each connected component of the graph. Starting from an arbitrary node, assign the base value and propagate values to adjacent nodes based on the given GCD and LCM constraints.\n4. **Consistency Check**: During BFS traversal, ensure that the computed values for adjacent nodes are consistent with the given constraints. If any inconsistency is found, the configuration is invalid.\n\n### Solution Code\n```python\nimport sys\nimport math\nfrom collections import defaultdict, deque\n\ndef input():\n    return sys.stdin.read()\n\ndef main():\n    data = input().split()\n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    m = int(data[idx])\n    idx += 1\n    \n    edges = []\n    graph = defaultdict(list)\n    for _ in range(m):\n        u = int(data[idx]) - 1\n        idx += 1\n        v = int(data[idx]) - 1\n        idx += 1\n        g = int(data[idx])\n        idx += 1\n        l = int(data[idx])\n        idx += 1\n        edges.append((u, v, g, l))\n        graph[u].append((v, g, l))\n        graph[v].append((u, g, l))\n    \n    # Compute base_val for each node\n    base_val = [1] * n\n    for u in range(n):\n        g_list = []\n        for (v, g, l) in graph[u]:\n            g_list.append(g)\n        if len(g_list) == 0:\n            continue\n        current_lcm = g_list[0]\n        for g_val in g_list[1:]:\n            current_lcm = current_lcm * g_val // math.gcd(current_lcm, g_val)\n        base_val[u] = current_lcm\n    \n    # Prepare visited array and values array\n    visited = [False] * n\n    values = [0] * n\n    result = True\n    \n    def bfs(start):\n        nonlocal result\n        queue = deque()\n        queue.append(start)\n        visited[start] = True\n        values[start] = base_val[start]\n        while queue:\n            u = queue.popleft()\n            for (v, g, l) in graph[u]:\n                if not visited[v]:\n                    # Compute v_val\n                    u_val = values[u]\n                    product = g * l\n                    if u_val == 0:\n                        # Should not happen since base_val is at least 1\n                        result = False\n                        return\n                    if product % u_val != 0:\n                        result = False\n                        return\n                    v_val = product // u_val\n                    # Check if v_val is multiple of g\n                    if v_val % g != 0:\n                        result = False\n                        return\n                    # Check GCD and LCM\n                    gcd_uv = math.gcd(u_val, v_val)\n                    lcm_uv = u_val * v_val // gcd_uv\n                    if gcd_uv != g or lcm_uv != l:\n                        result = False\n                        return\n                    values[v] = v_val\n                    visited[v] = True\n                    queue.append(v)\n                else:\n                    # Check consistency\n                    u_val = values[u]\n                    v_val = values[v]\n                    product = g * l\n                    if u_val * v_val != product:\n                        result = False\n                        return\n                    gcd_uv = math.gcd(u_val, v_val)\n                    lcm_uv = u_val * v_val // gcd_uv\n                    if gcd_uv != g or lcm_uv != l:\n                        result = False\n                        return\n    \n    for i in range(n):\n        if not visited[i]:\n            if base_val[i] == 0:\n                # This should not happen\n                result = False\n                break\n            bfs(i)\n            if not result:\n                break\n    \n    if result:\n        print(\"YES\")\n        print(' '.join(map(str, values)))\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Graph Representation**: The graph is represented using an adjacency list where each node points to its neighbors along with the GCD and LCM values of the connecting road.\n2. **Base Value Calculation**: For each node, compute the LCM of all GCDs of its incident edges to ensure initial values are valid multiples of all necessary constraints.\n3. **BFS Traversal**: Starting from each unvisited node, use BFS to propagate values through the graph. For each edge, compute the neighbor's value based on the current node's value and check consistency with given GCD and LCM constraints.\n4. **Consistency Checks**: During BFS, ensure that computed values for nodes are consistent with the given constraints. Any inconsistency results in an immediate \"NO\" response. If all checks pass, the computed values are printed as the solution.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\nfrom collections import defaultdict, deque\n\ndef input():\n    return sys.stdin.read()\n\ndef main():\n    data = input().split()\n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    m = int(data[idx])\n    idx += 1\n    \n    edges = []\n    graph = defaultdict(list)\n    for _ in range(m):\n        u = int(data[idx]) - 1\n        idx += 1\n        v = int(data[idx]) - 1\n        idx += 1\n        g = int(data[idx])\n        idx += 1\n        l = int(data[idx])\n        idx += 1\n        edges.append((u, v, g, l))\n        graph[u].append((v, g, l))\n        graph[v].append((u, g, l))\n    \n    # Compute base_val for each node\n    base_val = [1] * n\n    for u in range(n):\n        g_list = []\n        for (v, g, l) in graph[u]:\n            g_list.append(g)\n        if len(g_list) == 0:\n            continue\n        current_lcm = g_list[0]\n        for g_val in g_list[1:]:\n            current_lcm = current_lcm * g_val // math.gcd(current_lcm, g_val)\n        base_val[u] = current_lcm\n    \n    # Prepare visited array and values array\n    visited = [False] * n\n    values = [0] * n\n    result = True\n    \n    def bfs(start):\n        nonlocal result\n        queue = deque()\n        queue.append(start)\n        visited[start] = True\n        values[start] = base_val[start]\n        while queue:\n            u = queue.popleft()\n            for (v, g, l) in graph[u]:\n                if not visited[v]:\n                    # Compute v_val\n                    u_val = values[u]\n                    product = g * l\n                    if u_val == 0:\n                        # Should not happen since base_val is at least 1\n                        result = False\n                        return\n                    if product % u_val != 0:\n                        result = False\n                        return\n                    v_val = product // u_val\n                    # Check if v_val is multiple of g\n                    if v_val % g != 0:\n                        result = False\n                        return\n                    # Check GCD and LCM\n                    gcd_uv = math.gcd(u_val, v_val)\n                    lcm_uv = u_val * v_val // gcd_uv\n                    if gcd_uv != g or lcm_uv != l:\n                        result = False\n                        return\n                    values[v] = v_val\n                    visited[v] = True\n                    queue.append(v)\n                else:\n                    # Check consistency\n                    u_val = values[u]\n                    v_val = values[v]\n                    product = g * l\n                    if u_val * v_val != product:\n                        result = False\n                        return\n                    gcd_uv = math.gcd(u_val, v_val)\n                    lcm_uv = u_val * v_val // gcd_uv\n                    if gcd_uv != g or lcm_uv != l:\n                        result = False\n                        return\n    \n    for i in range(n):\n        if not visited[i]:\n            if base_val[i] == 0:\n                # This should not happen\n                result = False\n                break\n            bfs(i)\n            if not result:\n                break\n    \n    if result:\n        print(\"YES\")\n        print(' '.join(map(str, values)))\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 558,
        "completion_token_count": 1184,
        "thoughts_token_count": 8192
    }
}