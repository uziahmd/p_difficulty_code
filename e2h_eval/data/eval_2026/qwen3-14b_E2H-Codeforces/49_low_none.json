{
    "start": 1758309845.5753706,
    "end": 1758309886.6199229,
    "start-formatted": "2025-09-20 04:24 KST",
    "end-formatted": "2025-09-20 04:24 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\nOkay, let's see. I need to solve this problem where I have to determine the number of mushrooms on each lawn based on the GCD and LCM given for each road. The input is a graph with nodes (lawns) and edges (roads) that have GCD and LCM values. My job is to assign numbers to each node such that for every edge, the GCD and LCM of the two nodes match the given values. If it's possible, output YES and the numbers; else, NO.\n\nFirst, I need to think about the constraints. For each edge between u and v, let's say the GCD is g and LCM is l. Then, we know that the numbers on u and v must satisfy:\n\ngcd(a_u, a_v) = g\nlcm(a_u, a_v) = l\n\nBut there's a relationship between GCD and LCM. Remember that for any two numbers a and b, gcd(a,b) * lcm(a,b) = a*b. So, here, if the given GCD is g and LCM is l, then a_u * a_v = g*l. But also, since the GCD is g, both a_u and a_v must be multiples of g. Let me think: Let a_u = g * x, a_v = g * y. Then, the GCD of a_u and a_v is g * gcd(x,y). But since the given GCD is g, that implies that gcd(x,y) must be 1. Also, the LCM of a_u and a_v is g * lcm(x,y). But the given LCM is l, so g * lcm(x,y) = l. Therefore, lcm(x,y) = l/g. But since x and y are coprime, their LCM is x*y. So, x*y = l/g. And since x and y are coprime, that gives us that x and y are divisors of l/g and coprime.\n\nSo, for each edge, the product of the two numbers (a_u and a_v) must be equal to g*l. Also, since a_u and a_v are multiples of g, we can represent them as g * x and g * y, with x and y coprime and x*y = l/g. So for each edge, we can find x and y such that x*y = l/g and gcd(x,y)=1. However, there could be multiple possibilities for x and y. For example, if l/g is 6, then x=2 and y=3, or x=1 and y=6, etc. But since x and y are coprime, the pair (x,y) must be such that they are coprime and multiply to l/g.\n\nWait, but for the problem, we need to assign values to all nodes such that all edges are satisfied. So this seems like a graph problem where each edge imposes a relation between two nodes. How can I model this?\n\nThis feels like a problem where each node's value is determined by some constraints. For example, if two nodes are connected by an edge, their values must be multiples of the GCD and satisfy the product condition.\n\nBut how do I model this? Maybe using a Union-Find structure isn't enough here because the constraints are multiplicative and require specific relationships between variables.\n\nAlternatively, perhaps I can model this as a graph where each node has a value, and for each edge, the values of u and v must be in a certain ratio. But since there are multiple possibilities, maybe I need to assign variables and check for consistency.\n\nAnother approach: For each connected component of the graph, we can assign values based on the constraints. Let's think of the graph as a collection of connected components. For each component, we can assign a base value (like a root node's value), and then derive other nodes' values based on the edges.\n\nBut how?\n\nLet me think again about the edge constraints. For each edge between u and v, we have that a_u and a_v are multiples of g (the GCD), and their product is g*l. So, if I can represent a_u and a_v as g * x and g * y, with x and y coprime and x*y = l/g. So, for each edge, we can find that x and y must be such that x*y = k, where k = l/g. Also, since x and y are coprime, the only possible pairs are factors of k that are coprime. However, for the problem, the actual x and y could be either way. For example, if the edge is between u and v, then a_u could be g*x and a_v g*y, or vice versa. But that depends on the direction of the edge. However, since the problem allows any valid assignment, perhaps we can choose one direction during traversal.\n\nSo, perhaps this",
    "response": "```python\nimport sys\nimport math\nfrom collections import defaultdict, deque\n\ndef input():\n    return sys.stdin.read()\n\ndef main():\n    data = input().split()\n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    m = int(data[idx])\n    idx += 1\n    \n    edges = []\n    graph = defaultdict(list)\n    for _ in range(m):\n        u = int(data[idx]) - 1\n        idx += 1\n        v = int(data[idx]) - 1\n        idx += 1\n        g = int(data[idx])\n        idx += 1\n        l = int(data[idx])\n        idx += 1\n        edges.append((u, v, g, l))\n        graph[u].append((v, g, l))\n        graph[v].append((u, g, l))\n    \n    # Check if GCD divides LCM\n    valid = True\n    for u, v, g, l in edges:\n        if l % g != 0:\n            valid = False\n            break\n    if not valid:\n        print(\"NO\")\n        return\n    \n    # Assign values to nodes\n    values = [-1] * n\n    visited = [False] * n\n    \n    for start in range(n):\n        if visited[start]:\n            continue\n        # BFS to assign values\n        queue = deque()\n        queue.append(start)\n        visited[start] = True\n        values[start] = 1  # Placeholder, will be adjusted later\n        valid_component = True\n        \n        while queue:\n            u = queue.popleft()\n            for v, g, l in graph[u]:\n                if visited[v]:\n                    # Check if current values are consistent\n                    a_u = values[u]\n                    a_v = values[v]\n                    if math.gcd(a_u, a_v) != g or (a_u * a_v) // math.gcd(a_u, a_v) != l:\n                        valid_component = False\n                        break\n                    continue\n                # Compute possible a_v based on a_u\n                k = l // g\n                # Since a_u * a_v = g*l and gcd(a_u, a_v) = g\n                # So a_u = g * x, a_v = g * y where x*y = k and gcd(x,y) = 1\n                # We have a_u is known, so compute x = a_u / g\n                x = values[u] // g\n                # Then y = k / x\n                # But since x * y = k and gcd(x, y) = 1, we need to check if k is divisible by x\n                if values[u] % g != 0:\n                    valid_component = False\n                    break\n                x = values[u] // g\n                if k % x != 0:\n                    valid_component = False\n                    break\n                y = k // x\n                # Now, a_v = g * y\n                values[v] = g * y\n                visited[v] = True\n                queue.append(v)\n            if not valid_component:\n                break\n        if not valid_component:\n            print(\"NO\")\n            return\n    \n    # Final check for all edges\n    for u, v, g, l in edges:\n        a_u = values[u]\n        a_v = values[v]\n        if math.gcd(a_u, a_v) != g or (a_u * a_v) // math.gcd(a_u, a_v) != l:\n            print(\"NO\")\n            return\n    \n    print(\"YES\")\n    print(' '.join(map(str, values)))\n\nif __name__ == \"__main__\":\n    main()\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\nfrom collections import defaultdict, deque\n\ndef input():\n    return sys.stdin.read()\n\ndef main():\n    data = input().split()\n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    m = int(data[idx])\n    idx += 1\n    \n    edges = []\n    graph = defaultdict(list)\n    for _ in range(m):\n        u = int(data[idx]) - 1\n        idx += 1\n        v = int(data[idx]) - 1\n        idx += 1\n        g = int(data[idx])\n        idx += 1\n        l = int(data[idx])\n        idx += 1\n        edges.append((u, v, g, l))\n        graph[u].append((v, g, l))\n        graph[v].append((u, g, l))\n    \n    # Check if GCD divides LCM\n    valid = True\n    for u, v, g, l in edges:\n        if l % g != 0:\n            valid = False\n            break\n    if not valid:\n        print(\"NO\")\n        return\n    \n    # Assign values to nodes\n    values = [-1] * n\n    visited = [False] * n\n    \n    for start in range(n):\n        if visited[start]:\n            continue\n        # BFS to assign values\n        queue = deque()\n        queue.append(start)\n        visited[start] = True\n        values[start] = 1  # Placeholder, will be adjusted later\n        valid_component = True\n        \n        while queue:\n            u = queue.popleft()\n            for v, g, l in graph[u]:\n                if visited[v]:\n                    # Check if current values are consistent\n                    a_u = values[u]\n                    a_v = values[v]\n                    if math.gcd(a_u, a_v) != g or (a_u * a_v) // math.gcd(a_u, a_v) != l:\n                        valid_component = False\n                        break\n                    continue\n                # Compute possible a_v based on a_u\n                k = l // g\n                # Since a_u * a_v = g*l and gcd(a_u, a_v) = g\n                # So a_u = g * x, a_v = g * y where x*y = k and gcd(x,y) = 1\n                # We have a_u is known, so compute x = a_u / g\n                x = values[u] // g\n                # Then y = k / x\n                # But since x * y = k and gcd(x, y) = 1, we need to check if k is divisible by x\n                if values[u] % g != 0:\n                    valid_component = False\n                    break\n                x = values[u] // g\n                if k % x != 0:\n                    valid_component = False\n                    break\n                y = k // x\n                # Now, a_v = g * y\n                values[v] = g * y\n                visited[v] = True\n                queue.append(v)\n            if not valid_component:\n                break\n        if not valid_component:\n            print(\"NO\")\n            return\n    \n    # Final check for all edges\n    for u, v, g, l in edges:\n        a_u = values[u]\n        a_v = values[v]\n        if math.gcd(a_u, a_v) != g or (a_u * a_v) // math.gcd(a_u, a_v) != l:\n            print(\"NO\")\n            return\n    \n    print(\"YES\")\n    print(' '.join(map(str, values)))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 550,
        "completion_token_count": 769,
        "thoughts_token_count": 1024
    }
}