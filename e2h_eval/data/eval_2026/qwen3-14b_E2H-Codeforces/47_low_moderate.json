{
    "start": 1758309504.2372704,
    "end": 1758309724.3889418,
    "start-formatted": "2025-09-20 04:18 KST",
    "end-formatted": "2025-09-20 04:22 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\nOkay, let's see. I need to find the smallest non-negative integer k such that the LCM of (a +k) and (b +k) is as small as possible. And if there are multiple k's with the same minimal LCM, pick the smallest one.\n\nHmm. Let me think about how to approach this. The problem is to minimize LCM(a+k, b+k). Let me note that a and b are given, and k is non-negative. \n\nFirst, let's think about what happens when we add k to both a and b. Let me denote x = a +k and y = b +k. Then, since k is the same for both, the difference between x and y is (a - b). Let's say a < b. Then, x = a +k, y = b +k = x + (b -a). So the difference between y and x is fixed as (b -a). \n\nWait, but the LCM of two numbers depends on their difference and their GCD. Since LCM(x,y) = x*y / GCD(x,y). So to minimize LCM, we need to maximize the GCD of x and y. Because for fixed product x*y, higher GCD would lead to lower LCM. But how do we find that?\n\nAlternatively, since x and y differ by a fixed value. Let's assume without loss of generality that a â‰¤ b. Then, the difference between the two numbers is d = b - a. So, when we add k, the two numbers are x = a +k and y = x + d. So, their difference is d. So the GCD of x and y must divide d. Because GCD(x, x +d) = GCD(x, d). \n\nSo, the GCD of x and y is the same as GCD(x, d). Therefore, to maximize the GCD of x and y, we need to find x such that x is a multiple of some divisor of d. Wait, but since d is fixed, perhaps we can find the maximum possible GCD by looking for divisors of d. \n\nLet me think. Let's suppose that d is the difference between a and b. Let me take the example from the first input: a=6, b=10. So d=4. Then, the optimal k was 2. So x = 6+2=8, y=10+2=12. Their GCD is 4, which is the maximum possible. Because the LCM is 24, which is 8*12 /4 = 24. \n\nSo, for the case where d is fixed, the maximum possible GCD of x and y is the maximum divisor of d that can be achieved by choosing x such that x is a multiple of that divisor. \n\nWait, but how do we find x? Because x is a +k. So, for each divisor g of d, we can try to find the minimal k such that x is a multiple of g. Then, the GCD of x and y will be at least g. But since x and y differ by d, and g divides d, then GCD(x, y) = GCD(x, d) = g. So, if x is a multiple of g, then GCD(x, d) would be g, provided that g is a divisor of d. \n\nSo, the idea is: for all possible divisors g of d, find the minimal k such that a +k is a multiple of g, and then compute the LCM for that case. Then, among all these possibilities, choose the one with the minimal LCM. If there are multiple, choose the smallest k. \n\nBut what if d is zero? Well, if a = b, then adding any k gives x and y equal to a +k and b +k = same value. So their LCM is x (since LCM(x,x) is x). So in this case, the minimal k is 0. Because any k would give same LCM. So the answer is 0. \n\nSo, the first step is to handle the case where a == b. Then, return 0. Otherwise, compute d = |a - b|. Let's assume a < b, so d = b -a. \n\nSo, for the general case where a != b, we need to find all divisors of d, then for each divisor g, find the minimal k such that (a +k) is divisible by g. Then, compute the LCM of (a +k) and (b +k), which would be (a +k) * (b +k) / g. But since (b +k) = (a +k) + d, and since g divides d, then (a +k) is a multiple of g. Let me see",
    "response": "To solve this problem, we need to find the smallest non-negative integer $ k $ such that the least common multiple (LCM) of $ a + k $ and $ b + k $ is minimized. If there are multiple values of $ k $ that yield the same minimal LCM, we choose the smallest $ k $.\n\n### Approach\n1. **Special Case Handling**: If $ a $ and $ b $ are equal, the LCM of $ a + k $ and $ b + k $ will always be $ a + k $. Hence, the optimal $ k $ is 0.\n2. **Difference Calculation**: Compute the absolute difference $ d $ between $ a $ and $ b $.\n3. **Divisors of Difference**: Find all divisors of $ d $, as these divisors help in determining potential values of $ k $ that could maximize the GCD of $ a + k $ and $ b + k $, thereby minimizing the LCM.\n4. **Optimal $ k $ Calculation**: For each divisor $ g $ of $ d $, compute the smallest non-negative $ k $ such that $ a + k $ is a multiple of $ g $. Calculate the corresponding LCM for this $ k $ and track the minimum LCM and the smallest $ k $.\n\n### Solution Code\n```python\nimport sys\nimport math\n\ndef get_divisors(n):\n    divisors = set()\n    for i in range(1, int(math.isqrt(n)) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return divisors\n\ndef compute_min_k(a, b):\n    if a == b:\n        return 0\n    d = abs(a - b)\n    divisors = get_divisors(d)\n    min_lcm = float('inf')\n    best_k = float('inf')\n    \n    for g in divisors:\n        # Find the smallest k >= 0 such that (a + k) % g == 0\n        remainder = a % g\n        if remainder == 0:\n            k = 0\n        else:\n            k = g - remainder\n        x = a + k\n        y = b + k\n        current_lcm = x * y // math.gcd(x, y)\n        if current_lcm < min_lcm or (current_lcm == min_lcm and k < best_k):\n            min_lcm = current_lcm\n            best_k = k\n    return best_k\n\ndef main():\n    input = sys.stdin.read().split()\n    for i in range(0, len(input), 2):\n        a = int(input[i])\n        b = int(input[i+1])\n        print(compute_min_k(a, b))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read from standard input and processed in pairs of integers $ a $ and $ b $.\n2. **Special Case Handling**: If $ a $ equals $ b $, the result is immediately 0.\n3. **Divisors Calculation**: The function `get_divisors` computes all divisors of the difference $ d $ between $ a $ and $ b $.\n4. **Finding Optimal $ k $**: For each divisor $ g $ of $ d $, compute the smallest $ k $ such that $ a + k $ is a multiple of $ g $. This ensures that the GCD of $ a + k $ and $ b + k $ is maximized, which helps minimize the LCM.\n5. **LCM Calculation**: For each candidate $ k $, compute the LCM of $ a + k $ and $ b + k $, and track the minimum LCM and corresponding smallest $ k $.\n\nThis approach efficiently narrows down potential values of $ k $ by leveraging properties of divisors and GCD, ensuring an optimal solution with minimal computational overhead.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\n\ndef get_divisors(n):\n    divisors = set()\n    for i in range(1, int(math.isqrt(n)) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return divisors\n\ndef compute_min_k(a, b):\n    if a == b:\n        return 0\n    d = abs(a - b)\n    divisors = get_divisors(d)\n    min_lcm = float('inf')\n    best_k = float('inf')\n    \n    for g in divisors:\n        # Find the smallest k >= 0 such that (a + k) % g == 0\n        remainder = a % g\n        if remainder == 0:\n            k = 0\n        else:\n            k = g - remainder\n        x = a + k\n        y = b + k\n        current_lcm = x * y // math.gcd(x, y)\n        if current_lcm < min_lcm or (current_lcm == min_lcm and k < best_k):\n            min_lcm = current_lcm\n            best_k = k\n    return best_k\n\ndef main():\n    input = sys.stdin.read().split()\n    for i in range(0, len(input), 2):\n        a = int(input[i])\n        b = int(input[i+1])\n        print(compute_min_k(a, b))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 403,
        "completion_token_count": 820,
        "thoughts_token_count": 1024
    }
}