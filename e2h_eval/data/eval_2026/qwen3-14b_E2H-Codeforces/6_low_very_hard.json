{
    "start": 1758313552.394404,
    "end": 1758313600.441482,
    "start-formatted": "2025-09-20 05:25 KST",
    "end-formatted": "2025-09-20 05:26 KST",
    "gpu": 2,
    "pid": 6,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\nOkay, I need to solve this programming problem. Let me read the problem statement carefully again.\n\nSo, Leha wants to choose exactly two vouchers that don't overlap. The sum of their durations must be exactly x, and the total cost should be as minimal as possible. If it's not possible, output -1.\n\nFirst, let's understand the duration. For each voucher i, duration is ri - li + 1. So for two vouchers, their durations must add up to x. Also, they must not overlap. That means either the first ends before the second starts, or vice versa.\n\nThe input is n vouchers, each with li, ri, costi. We need to find two distinct vouchers that meet the criteria.\n\nConstraints are n up to 2e5, which suggests that O(n^2) approaches are not feasible. So we need an efficient way, probably O(n log n) or similar.\n\nLet me think about how to approach this.\n\nThe key points are:\n\n- Find pairs of vouchers where the sum of their durations is x.\n- These vouchers must not overlap.\n- Find the minimum total cost among all such pairs.\n\nFirst, for each voucher, compute its duration. Let's call duration d. Then, for each voucher with duration d, we need to find another voucher with duration (x - d), and check if they don't overlap.\n\nBut how do we efficiently find those pairs?\n\nAn idea: group vouchers by their duration. For example, create a dictionary where the key is the duration, and the value is a list of vouchers with that duration. Then, for each voucher in duration d, look for vouchers in duration (x - d), and check if they can be paired without overlapping.\n\nBut even then, for each voucher, checking all vouchers of the complementary duration would be O(n^2) in the worst case. For example, if all vouchers have duration x/2, then for each voucher, we have to check all others, leading to O(n^2) time.\n\nThat's not feasible. So we need a smarter way.\n\nAnother thought: For each possible duration d, pre-process the vouchers so that for any voucher of duration d, we can quickly find the minimum cost voucher of duration (x - d) that doesn't overlap with it.\n\nBut how?\n\nLet me think. For example, suppose we have a voucher A with duration d, and we need to find vouchers B with duration (x - d) that end before A starts, or start after A ends.\n\nSo for each voucher A, we need to find the minimum cost voucher B in the (x - d) group that ends before A's li, or starts after A's ri.\n\nBut how to find that quickly?\n\nMaybe for each duration, we can sort the vouchers by their start and end times, and for each voucher, perform binary search to find the earliest possible or latest possible.\n\nWait, let's think about this. Suppose we have all vouchers of duration k. For a given voucher A (duration d), we need to find vouchers of duration (x-d) that end before A's start (so their ri < li of A). Or start after A's end (so their li > ri of A).\n\nFor the first case (B ends before A starts), we can find the minimum cost voucher in the (x-d) group where ri < li_A. Similarly for the second case (B starts after A ends), find the minimum cost voucher in the (x-d) group where li > ri_A.\n\nIf we can find these minima quickly, then for each voucher A, we can check both possibilities and take the minimum between them.\n\nSo the plan is:\n\n- Preprocess vouchers grouped by their duration. For each duration, we have two sorted structures:\n\n   - Sorted by end time (ri), and for each entry, we can have the minimum cost up to that point. So for a given li_A, we can find all vouchers in the (x-d) group that end before li_A, and find the minimum cost among them.\n\n   - Similarly, sorted by start time (li), and for each entry, the minimum cost from that point onwards. So for a given ri_A, we can find all vouchers in the (x-d) group that start after ri_A, and find the minimum cost among them.\n\nBut how to implement this?\n\nFor example, for each duration k, we can have two sorted lists:\n\n- One list sorted by ri (end time), and for each position in this list, we can have a prefix minimum array. So when we want to find the minimum cost of vouchers with ri < X, we can binary search for X in the sorted ri list, find the largest index where ri < X, and then take the prefix minimum up to that index.\n\nSimilarly, for the other case, we can have a list sorted by li (start time), and for each position, a suffix minimum array. So when we want to find the minimum cost of vouchers with li",
    "response": "To solve this problem, we need to find two non-overlapping vouchers whose combined duration exactly matches a given value `x` and whose total cost is minimized. The solution involves efficiently grouping and querying vouchers based on their durations and start/end times.\n\n### Approach\n1. **Group Vouchers by Duration**: First, we group all vouchers by their duration. This allows us to quickly access vouchers of specific durations when checking for valid pairs.\n2. **Preprocess Sorted Lists**: For each duration, we maintain two sorted lists:\n   - One sorted by the end time (`ri`) with a prefix minimum cost array.\n   - Another sorted by the start time (`li`) with a suffix minimum cost array.\n3. **Check Valid Pairs**: For each voucher, we check if there exists another voucher of the complementary duration (i.e., `x - duration`) that does not overlap. This is done using binary search on the preprocessed sorted lists to quickly find the minimum cost of valid non-overlapping vouchers.\n\n### Solution Code\n```python\nimport sys\nimport bisect\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n    \n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n    \n    # Group vouchers by their duration\n    duration_dict = defaultdict(list)\n    for l, r, cost, d in vouchers:\n        duration_dict[d].append((l, r, cost))\n    \n    # Preprocess for each duration: sorted by end time and start time, with prefix/suffix min cost\n    processed = dict()\n    for d in duration_dict:\n        lst = duration_dict[d]\n        # Sort by end time (r)\n        sorted_by_end = sorted(lst, key=lambda x: x[1])\n        prefix_min = []\n        min_so_far = float('inf')\n        for item in sorted_by_end:\n            min_so_far = min(min_so_far, item[2])\n            prefix_min.append(min_so_far)\n        # Sort by start time (l)\n        sorted_by_start = sorted(lst, key=lambda x: x[0])\n        suffix_min = [0] * len(sorted_by_start)\n        min_so_far = float('inf')\n        for i in range(len(sorted_by_start)-1, -1, -1):\n            min_so_far = min(min_so_far, sorted_by_start[i][2])\n            suffix_min[i] = min_so_far\n        processed[d] = (sorted_by_end, prefix_min, sorted_by_start, suffix_min)\n    \n    min_total = float('inf')\n    \n    for l1, r1, cost1, d1 in vouchers:\n        target_d = x - d1\n        if target_d < 1:\n            continue\n        if target_d not in processed:\n            continue\n        # Check for vouchers with duration target_d that end before l1 or start after r1\n        # Case 1: vouchers end before l1\n        sorted_by_end, prefix_min, sorted_by_start, suffix_min = processed[target_d]\n        # Find the largest r in sorted_by_end that is < l1\n        end_list = [item[1] for item in sorted_by_end]\n        pos = bisect.bisect_left(end_list, l1) - 1\n        if pos >= 0:\n            min_cost = prefix_min[pos]\n            min_total = min(min_total, cost1 + min_cost)\n        # Case 2: vouchers start after r1\n        start_list = [item[0] for item in sorted_by_start]\n        pos = bisect.bisect_right(start_list, r1)\n        if pos < len(start_list):\n            min_cost = suffix_min[pos]\n            min_total = min(min_total, cost1 + min_cost)\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into a list of vouchers, each represented by its start time, end time, cost, and duration.\n2. **Grouping by Duration**: Vouchers are grouped by their duration to facilitate quick lookups.\n3. **Preprocessing**: For each duration, vouchers are sorted by end time and start time. Prefix and suffix minimum cost arrays are created to allow efficient range minimum queries.\n4. **Checking Valid Pairs**: For each voucher, we check if there exists a valid non-overlapping voucher of the complementary duration using binary search on the preprocessed sorted lists. The minimum cost for valid pairs is tracked and updated accordingly.\n\nThis approach ensures efficient querying and minimizes the total cost by leveraging sorted structures and binary search, leading to an optimal solution.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport bisect\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n    \n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n    \n    # Group vouchers by their duration\n    duration_dict = defaultdict(list)\n    for l, r, cost, d in vouchers:\n        duration_dict[d].append((l, r, cost))\n    \n    # Preprocess for each duration: sorted by end time and start time, with prefix/suffix min cost\n    processed = dict()\n    for d in duration_dict:\n        lst = duration_dict[d]\n        # Sort by end time (r)\n        sorted_by_end = sorted(lst, key=lambda x: x[1])\n        prefix_min = []\n        min_so_far = float('inf')\n        for item in sorted_by_end:\n            min_so_far = min(min_so_far, item[2])\n            prefix_min.append(min_so_far)\n        # Sort by start time (l)\n        sorted_by_start = sorted(lst, key=lambda x: x[0])\n        suffix_min = [0] * len(sorted_by_start)\n        min_so_far = float('inf')\n        for i in range(len(sorted_by_start)-1, -1, -1):\n            min_so_far = min(min_so_far, sorted_by_start[i][2])\n            suffix_min[i] = min_so_far\n        processed[d] = (sorted_by_end, prefix_min, sorted_by_start, suffix_min)\n    \n    min_total = float('inf')\n    \n    for l1, r1, cost1, d1 in vouchers:\n        target_d = x - d1\n        if target_d < 1:\n            continue\n        if target_d not in processed:\n            continue\n        # Check for vouchers with duration target_d that end before l1 or start after r1\n        # Case 1: vouchers end before l1\n        sorted_by_end, prefix_min, sorted_by_start, suffix_min = processed[target_d]\n        # Find the largest r in sorted_by_end that is < l1\n        end_list = [item[1] for item in sorted_by_end]\n        pos = bisect.bisect_left(end_list, l1) - 1\n        if pos >= 0:\n            min_cost = prefix_min[pos]\n            min_total = min(min_total, cost1 + min_cost)\n        # Case 2: vouchers start after r1\n        start_list = [item[0] for item in sorted_by_start]\n        pos = bisect.bisect_right(start_list, r1)\n        if pos < len(start_list):\n            min_cost = suffix_min[pos]\n            min_total = min(min_total, cost1 + min_cost)\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 741,
        "completion_token_count": 1067,
        "thoughts_token_count": 1024
    }
}