{
    "start": 1758008331.556397,
    "end": 1758008530.706061,
    "start-formatted": "2025-09-16 16:38 KST",
    "end-formatted": "2025-09-16 16:42 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\nOkay, let's tackle this problem. So the task is to find two non-overlapping vouchers whose total duration is exactly x, and their combined cost is minimal. If there's no such pair, return -1.\n\nFirst, I need to understand the problem thoroughly. Let's rephrase: each voucher has a start day li, end day ri, and cost. The duration is ri - li + 1. We need two vouchers i and j (i≠j) such that their durations add up to x, and they don't overlap. And we have to find the minimum total cost of such pairs.\n\nThe constraints are n up to 2e5, which suggests that any O(n^2) approach is impossible. So we need an efficient method, probably O(n log n) or similar.\n\nLet me think about how to approach this. For each voucher, we can check if there's another voucher that has a duration of (x - duration_i), and that doesn't overlap with it. But how do we efficiently find those?\n\nFirst, for each voucher, compute its duration. Then, for each voucher with duration d, we need to find vouchers with duration (x - d), and check if they don't overlap.\n\nBut how do we efficiently find the minimal cost vouchers for each possible duration?\n\nMaybe pre-process all vouchers by their duration. For example, create a dictionary where the key is the duration, and the value is a list of (start, end, cost) for vouchers with that duration. Then, for each voucher with duration d, look up in the dictionary for duration (x - d), and check for vouchers in that list that don't overlap with the current voucher.\n\nBut even then, for each voucher, checking all vouchers in the other duration group could be O(n^2) in worst case. For example, if all vouchers have duration d = x/2, then for each voucher, we have to check all others. Which would be O(n^2).\n\nThat's not feasible. So we need a smarter way.\n\nLet me think about the non-overlapping condition. Suppose we have two vouchers, A and B. They don't overlap if A ends before B starts, or B ends before A starts.\n\nSo for a given voucher A (with duration d), we want to find vouchers B with duration (x - d) that end before A starts (so B's end < A's start), or start after A ends (so B's start > A's end).\n\nSo for each voucher A, we can look for vouchers B in the (x - d) group that are either entirely before A or entirely after A.\n\nBut how to find the minimal cost for those cases?\n\nFor example, suppose we have all vouchers with duration k (where k is x - d). For a given voucher A (duration d), we need to find the minimal cost of vouchers B in the k group that end before A's start. Also, find the minimal cost of vouchers B in the k group that start after A's end. Then take the minimum between these two possibilities (if any exist).\n\nIf we can pre-process for each duration, the vouchers sorted by their end time, and also sorted by their start time, then for a given A, we can perform binary searches to find the minimal cost for vouchers B that end before A's start, or start after A's end.\n\nWait, but how to get the minimal cost for vouchers that end before a certain value?\n\nLet me think. Suppose for each duration k, we have a list of vouchers sorted by their end time. Also, for each such list, we can have a prefix minimum array. So for any query of \"find the minimal cost among vouchers with end <= some value\", we can binary search on the end time to find the latest voucher that ends before the target, and then use the prefix min array to get the minimal cost up to that point.\n\nSimilarly, for vouchers that start after a certain value. If we have a list sorted by start time, and a suffix min array, then for a given start value, we can find the first voucher that starts after the target and take the suffix min from that index onwards.\n\nSo here's the plan:\n\n- Preprocess all vouchers into a dictionary, where each key is a duration, and the value is two sorted lists:\n   - One sorted by end time (for finding vouchers that end before a certain time)\n   - Another sorted by start time (for finding vouchers that start after a certain time)\n   - Additionally, for each of these sorted lists, have a prefix min array (for end-sorted list) and a suffix min array (for start-sorted list).\n\nBut how to handle this? Let's think step by step.\n\nFirst, for each duration k, we need to store:\n\n- A list of vouchers sorted by their end time. For each such list, we can build a prefix minimum array. So, for each position i in the sorted list, prefix_min[i] is",
    "response": "\n\nTo solve this problem, we need to find two non-overlapping vouchers whose combined duration exactly matches a given value `x` and whose total cost is minimized. If no such pair exists, we should return -1.\n\n### Approach\n1. **Preprocessing Vouchers by Duration**: First, we categorize all vouchers by their duration. This helps in quickly finding vouchers that can potentially form the required total duration when paired with another voucher.\n2. **Sorting and Minimization Arrays**: For each duration, we maintain two sorted lists:\n   - One sorted by end time, along with a prefix minimum array to quickly find the minimum cost of vouchers ending before a specific date.\n   - Another sorted by start time, along with a suffix minimum array to quickly find the minimum cost of vouchers starting after a specific date.\n3. **Binary Search for Efficient Lookup**: For each voucher, we check if there exists another voucher with the complementary duration (i.e., `x - duration`) that does not overlap. Using binary search on the preprocessed lists, we efficiently determine the minimum cost of valid non-overlapping vouchers.\n\n### Solution Code\n```python\nimport sys\nimport bisect\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n\n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n\n    from collections import defaultdict\n\n    # Preprocess: group vouchers by duration\n    duration_dict = defaultdict(lambda: {'end_sorted': [], 'start_sorted': []})\n\n    for l, r, cost, d in vouchers:\n        duration_dict[d]['end_sorted'].append((r, l, cost))\n        duration_dict[d]['start_sorted'].append((l, r, cost))\n\n    # For each duration, sort the end_sorted list by end (r), and create prefix min\n    # Also sort start_sorted by start (l), and create suffix min\n    processed = dict()\n    for d in duration_dict:\n        end_list = duration_dict[d]['end_sorted']\n        # sort by end (r)\n        end_list.sort()\n        # create prefix min array\n        prefix_min = []\n        min_so_far = float('inf')\n        for r, l, cost in end_list:\n            if cost < min_so_far:\n                min_so_far = cost\n            prefix_min.append(min_so_far)\n        # store end_sorted and prefix_min\n        processed[d] = {\n            'end_sorted': end_list,\n            'prefix_min': prefix_min,\n            'start_sorted': [],\n            'suffix_min': []\n        }\n\n        start_list = duration_dict[d]['start_sorted']\n        # sort by start (l)\n        start_list.sort()\n        # create suffix min array\n        suffix_min = [0] * len(start_list)\n        min_so_far = float('inf')\n        for i in reversed(range(len(start_list))):\n            l, r, cost = start_list[i]\n            if cost < min_so_far:\n                min_so_far = cost\n            suffix_min[i] = min_so_far\n        processed[d]['start_sorted'] = start_list\n        processed[d]['suffix_min'] = suffix_min\n\n    min_total = float('inf')\n\n    for l, r, cost, d in vouchers:\n        target_d = x - d\n        if target_d < 1:\n            continue\n        if target_d not in processed:\n            continue\n        # Now check for vouchers with duration target_d that do not overlap with (l, r)\n        # Case 1: voucher ends before l\n        # Find in target_d's end_sorted list where end <= l-1\n        end_list = processed[target_d]['end_sorted']\n        prefix_min = processed[target_d]['prefix_min']\n        # Binary search for the largest end <= l-1\n        left, right = 0, len(end_list) - 1\n        best_idx = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if end_list[mid][0] <= l - 1:\n                best_idx = mid\n                left = mid + 1\n            else:\n                right = mid - 1\n        if best_idx != -1:\n            min_cost = prefix_min[best_idx]\n            min_total = min(min_total, min_cost + cost)\n\n        # Case 2: voucher starts after r\n        start_list = processed[target_d]['start_sorted']\n        suffix_min = processed[target_d]['suffix_min']\n        # Binary search for the first start >= r + 1\n        left, right = 0, len(start_list) - 1\n        best_idx = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if start_list[mid][0] >= r + 1:\n                best_idx = mid\n                right = mid - 1\n            else:\n                left = mid + 1\n        if best_idx != -1:\n            min_cost = suffix_min[best_idx]\n            min_total = min(min_total, min_cost + cost)\n\n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into a list of vouchers, each characterized by start day, end day, cost, and duration.\n2. **Categorization by Duration**: Vouchers are grouped by their duration using a dictionary. Each duration entry contains sorted lists of vouchers by their end and start times, along with prefix and suffix minimum cost arrays.\n3. **Binary Search for Non-overlapping Vouchers**: For each voucher, we check if there exists a voucher of complementary duration that either ends before the current voucher starts or starts after the current voucher ends. Binary search is used to efficiently find these non-overlapping vouchers and determine the minimum cost.\n4. **Result Calculation**: The minimum total cost from all valid pairs is computed and printed, or -1 if no valid pairs exist.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport bisect\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n\n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n\n    from collections import defaultdict\n\n    # Preprocess: group vouchers by duration\n    duration_dict = defaultdict(lambda: {'end_sorted': [], 'start_sorted': []})\n\n    for l, r, cost, d in vouchers:\n        duration_dict[d]['end_sorted'].append((r, l, cost))\n        duration_dict[d]['start_sorted'].append((l, r, cost))\n\n    # For each duration, sort the end_sorted list by end (r), and create prefix min\n    # Also sort start_sorted by start (l), and create suffix min\n    processed = dict()\n    for d in duration_dict:\n        end_list = duration_dict[d]['end_sorted']\n        # sort by end (r)\n        end_list.sort()\n        # create prefix min array\n        prefix_min = []\n        min_so_far = float('inf')\n        for r, l, cost in end_list:\n            if cost < min_so_far:\n                min_so_far = cost\n            prefix_min.append(min_so_far)\n        # store end_sorted and prefix_min\n        processed[d] = {\n            'end_sorted': end_list,\n            'prefix_min': prefix_min,\n            'start_sorted': [],\n            'suffix_min': []\n        }\n\n        start_list = duration_dict[d]['start_sorted']\n        # sort by start (l)\n        start_list.sort()\n        # create suffix min array\n        suffix_min = [0] * len(start_list)\n        min_so_far = float('inf')\n        for i in reversed(range(len(start_list))):\n            l, r, cost = start_list[i]\n            if cost < min_so_far:\n                min_so_far = cost\n            suffix_min[i] = min_so_far\n        processed[d]['start_sorted'] = start_list\n        processed[d]['suffix_min'] = suffix_min\n\n    min_total = float('inf')\n\n    for l, r, cost, d in vouchers:\n        target_d = x - d\n        if target_d < 1:\n            continue\n        if target_d not in processed:\n            continue\n        # Now check for vouchers with duration target_d that do not overlap with (l, r)\n        # Case 1: voucher ends before l\n        # Find in target_d's end_sorted list where end <= l-1\n        end_list = processed[target_d]['end_sorted']\n        prefix_min = processed[target_d]['prefix_min']\n        # Binary search for the largest end <= l-1\n        left, right = 0, len(end_list) - 1\n        best_idx = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if end_list[mid][0] <= l - 1:\n                best_idx = mid\n                left = mid + 1\n            else:\n                right = mid - 1\n        if best_idx != -1:\n            min_cost = prefix_min[best_idx]\n            min_total = min(min_total, min_cost + cost)\n\n        # Case 2: voucher starts after r\n        start_list = processed[target_d]['start_sorted']\n        suffix_min = processed[target_d]['suffix_min']\n        # Binary search for the first start >= r + 1\n        left, right = 0, len(start_list) - 1\n        best_idx = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if start_list[mid][0] >= r + 1:\n                best_idx = mid\n                right = mid - 1\n            else:\n                left = mid + 1\n        if best_idx != -1:\n            min_cost = suffix_min[best_idx]\n            min_total = min(min_total, min_cost + cost)\n\n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 740,
        "completion_token_count": 1331,
        "thoughts_token_count": 1023
    }
}