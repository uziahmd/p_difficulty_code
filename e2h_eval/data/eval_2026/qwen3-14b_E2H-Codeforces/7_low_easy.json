{
    "start": 1758313599.239705,
    "end": 1758313646.0282426,
    "start-formatted": "2025-09-20 05:26 KST",
    "end-formatted": "2025-09-20 05:27 KST",
    "gpu": 2,
    "pid": 7,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\nOkay, let's try to figure out how to solve this problem. The task is to determine for a given number n whether there exists a snowflake graph as defined. Let's break down the problem.\n\nFirst, understanding the structure of the snowflake. The snowflake is built in a certain way. Let me rephrase the construction steps:\n\n- Start with one vertex.\n- Then, connect it to k new vertices (k>1). So after this step, there are 1 + k vertices.\n- Then, each vertex that has only one connection (so those added in the previous step) must be connected to k new vertices. This step must be done at least once. \n\nWait, so the process is like a tree where each node added in a certain level has exactly k children. But the construction requires that after the initial step, each \"leaf\" (node with degree 1) is expanded by adding k new nodes. And this expansion step must happen at least once. \n\nLet me think about how the total number of nodes would look. Let's model the growth.\n\nLet me consider the structure as a tree. The root is the initial node. Then, each level adds nodes. For example:\n\nInitial step: level 0 has 1 node (root).\nFirst expansion: level 1 has k nodes. Now, each of these nodes is a leaf. Then, we have to expand them. So each of these k nodes gets k children. So level 2 has k * k nodes. But wait, the problem says that each leaf (nodes connected to only one other) must be connected to k new vertices. So after the first expansion, all the nodes in level 1 are leaves. So expanding them once would add k new nodes per node. So the total number of nodes would be 1 + k + k^2. \n\nBut then, perhaps the expansion can be done multiple times. Like, after expanding level 1 nodes once, the next expansion would take the new leaves (level 2 nodes) and add k children each. So the total nodes would be 1 + k + k^2 + k^3, etc. But the problem says that the expansion step must be done at least once. So the minimal case is when we do the expansion once. \n\nWait, the initial step is adding k nodes to the root. Then, the expansion step must be done at least once. So the minimal snowflake would have 1 + k + k^2 nodes. \n\nSo for example, the sample input says that n=6 is not possible. Let's check. Let's see for k=2: 1 + 2 + 4 =7, which is more than 6. For k=3: 1+3+9=13. So for n=6, there's no possible k. Hence the sample output says NO for 6.\n\nBut the sample input includes n=13, which is 1+3+9=13. So that's a YES. Also, n=15: maybe 1 + 2 + 4 + 8 = 15? Wait 1+2+4+8=15. But how many expansion steps? Let's think:\n\nOriginal step (level 0): 1 node.\n\nFirst expansion (level 1): add k nodes. Then, expansion step 1: expand level 1 nodes once. So each of the k nodes in level 1 gets k children. So level 2 has k*k nodes. Total is 1 +k +k². But if we do another expansion step, then each node in level 2 (which are leaves) get k children. So level 3 has k³ nodes. Total becomes 1 +k +k² +k³. So for k=2, 1+2+4+8=15. So n=15 is possible. Hence sample input says YES for 15.\n\nSo the problem reduces to checking whether n can be written as 1 + k + k^2 + ... + k^m, where m ≥ 1 (since the expansion step must be done at least once). Wait, no. Let me think again.\n\nThe initial step is adding k nodes. Then, the expansion step is done at least once. So the expansion steps are applied to the leaves. So the initial step is level 0 (root), then level 1 (k nodes). Then, expanding once would add level 2 (k^2 nodes). So total is 1 +k +k^2. That's when m=2 levels. But if we expand again, then level 3 is added, which is k^3 nodes. So the total is 1 +k +k² +k³. So the formula is sum_{i=0}^m k^i, but with m ≥ 2? No. Because the initial step is adding",
    "response": "To solve this problem, we need to determine if a given number of vertices `n` can form a valid \"snowflake\" graph as defined by the rules provided. The snowflake graph is constructed in such a way that it starts with one node and each subsequent level adds nodes in a specific pattern.\n\n### Approach\n1. **Understanding the Structure**: The snowflake graph is built in levels. Starting with one node (level 0), each subsequent level adds `k` new nodes for each node from the previous level. This expansion must happen at least once after the initial step.\n2. **Mathematical Representation**: The total number of nodes `n` can be represented as a geometric series: `1 + k + k^2 + ... + k^m` where `m ≥ 1`. This series must be checked for any valid integer `k > 1`.\n3. **Efficient Check**: For each test case, we need to check if there exists an integer `k > 1` such that `n` can be expressed as the sum of the geometric series described above. This involves iterating over possible values of `k` and checking if the sum of the series equals `n`.\n\n### Solution Code\n```python\nimport sys\nimport math\n\ndef is_snowflake(n):\n    if n == 1:\n        return False\n    # Try all possible k > 1\n    # We need to check if there exists a k > 1 and m >= 1 such that sum_{i=0}^m k^i = n\n    # The sum is (k^(m+1) - 1) / (k - 1)\n    # So for each possible k, we can try to find m such that this holds\n    # However, since n can be up to 1e18, we need an efficient way\n    # Let's iterate possible m and check for possible k\n    # For m >= 1, the minimal sum for m is 1 + k + k^2 (when m=2)\n    # So for each possible m, we can try to find if there exists a k such that sum_{i=0}^m k^i = n\n    # The maximum m can be log_2(n) since for k=2, sum increases exponentially\n    max_m = 60  # since 2^60 is about 1e18\n    for m in range(1, max_m + 1):\n        # For each m, we want to find k such that sum_{i=0}^m k^i = n\n        # The sum is S = (k^(m+1) - 1) / (k - 1)\n        # We can binary search k here\n        low = 2\n        high = 2\n        # Find upper bound for k\n        while True:\n            s = (high ** (m + 1) - 1) // (high - 1)\n            if s >= n:\n                break\n            high *= 2\n        # Now binary search between low and high\n        left = 2\n        right = high\n        while left <= right:\n            mid = (left + right) // 2\n            try:\n                s = (mid ** (m + 1) - 1) // (mid - 1)\n            except:\n                s = float('inf')\n            if s == n:\n                return True\n            elif s < n:\n                left = mid + 1\n            else:\n                right = mid - 1\n    return False\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    cases = list(map(int, data[1:t+1]))\n    for n in cases:\n        if is_snowflake(n):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **is_snowflake Function**: This function checks if a given number `n` can be expressed as the sum of a geometric series starting from 1 with a common ratio `k > 1` for some integer `k` and at least one expansion step.\n- **Binary Search for k**: For each possible number of levels `m`, we use binary search to efficiently determine if there exists a valid `k` such that the sum of the geometric series equals `n`.\n- **Efficiency**: The approach leverages logarithmic bounds and binary search to handle very large values of `n` up to $10^{18}$ efficiently, ensuring the solution is feasible within the problem constraints.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\n\ndef is_snowflake(n):\n    if n == 1:\n        return False\n    # Try all possible k > 1\n    # We need to check if there exists a k > 1 and m >= 1 such that sum_{i=0}^m k^i = n\n    # The sum is (k^(m+1) - 1) / (k - 1)\n    # So for each possible k, we can try to find m such that this holds\n    # However, since n can be up to 1e18, we need an efficient way\n    # Let's iterate possible m and check for possible k\n    # For m >= 1, the minimal sum for m is 1 + k + k^2 (when m=2)\n    # So for each possible m, we can try to find if there exists a k such that sum_{i=0}^m k^i = n\n    # The maximum m can be log_2(n) since for k=2, sum increases exponentially\n    max_m = 60  # since 2^60 is about 1e18\n    for m in range(1, max_m + 1):\n        # For each m, we want to find k such that sum_{i=0}^m k^i = n\n        # The sum is S = (k^(m+1) - 1) / (k - 1)\n        # We can binary search k here\n        low = 2\n        high = 2\n        # Find upper bound for k\n        while True:\n            s = (high ** (m + 1) - 1) // (high - 1)\n            if s >= n:\n                break\n            high *= 2\n        # Now binary search between low and high\n        left = 2\n        right = high\n        while left <= right:\n            mid = (left + right) // 2\n            try:\n                s = (mid ** (m + 1) - 1) // (mid - 1)\n            except:\n                s = float('inf')\n            if s == n:\n                return True\n            elif s < n:\n                left = mid + 1\n            else:\n                right = mid - 1\n    return False\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    cases = list(map(int, data[1:t+1]))\n    for n in cases:\n        if is_snowflake(n):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 562,
        "completion_token_count": 983,
        "thoughts_token_count": 1024
    }
}