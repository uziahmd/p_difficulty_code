{
    "start": 1758008507.08324,
    "end": 1758008679.6035647,
    "start-formatted": "2025-09-16 16:41 KST",
    "end-formatted": "2025-09-16 16:44 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\nOkay, let's tackle this problem. So, the task is to determine for a given n whether there exists a snowflake graph as defined. The snowflake is built in a certain way, and we need to check if such a graph can have exactly n vertices.\n\nFirst, I need to understand the structure of the snowflake. Let me re-read the description.\n\nThe snowflake starts with one vertex. Then, this initial vertex is connected to k new vertices (k>1). Then, each vertex that is connected to only one other (so those leaves) are connected to k new vertices. This step must be done at least once. So, the process is like building layers. \n\nLet me think about how the number of vertices grows. Let's model the construction steps.\n\nLet me consider the example given for k=4. The smallest snowflake would be:\n\nStart with 1 node. Then connect to 4 nodes. Now total is 5. But then, each of those 4 nodes (which are leaves) must be connected to k new nodes. So each of them adds 4 new nodes. So after that step, the total is 1 + 4 + 4*4 = 1 +4 +16 = 21? Or maybe I'm misunderstanding the steps.\n\nWait, the initial step is adding the first layer. Then, each leaf (the ones connected to only one other) must be connected to k new vertices. And this step has to be done at least once. So the minimal case is when we do this step once. So for example:\n\nOriginal structure: 1 node. Then add k nodes connected to it. Now, the leaves are those k nodes. Then, each of them must be connected to k new nodes. So each of those k nodes adds k new nodes. So the total number of nodes is 1 + k + k * k = 1 +k +k². \n\nBut for k=4, that would be 1+4+16=21. However, the example input says that for n=13, the answer is YES. Let's see. Wait, maybe there are multiple steps. Like, perhaps the process can be repeated multiple times. For example, after the first expansion, you could do another expansion step. \n\nSo, the snowflake is built in layers. The first layer is the initial node. Then, the first expansion adds k children to it. Then, each expansion step adds k children to each leaf node. But each expansion step must be done at least once. So the structure is such that the number of vertices depends on the number of expansion steps and the value of k.\n\nLet me think about the general formula. Suppose that the snowflake is built with m expansion steps. Let's see:\n\n- The initial node is level 0.\n- After the first expansion (step 1), there are k nodes added. So total is 1 + k.\n- Then, during each expansion step, every leaf node (those from the previous step) gets k new children. So each expansion step adds (number of leaves) * k nodes. \n\nBut how does the number of leaves change?\n\nLet me think step by step. Let's say that during each expansion step, all the leaves (nodes with degree 1) are expanded. \n\nLet me define the number of nodes and leaves after each step.\n\nInitial step (before any expansion): 1 node. Leaves: 0 (since it's the only node, but it's connected to nothing). Wait, no. Wait the initial step is just the single node. Then the first expansion step is adding k nodes connected to it. So after that, the initial node has degree k, and each of the k nodes has degree 1. So leaves are k nodes. \n\nThen, in the next expansion step, each of these k leaves is connected to k new nodes. So each of these k nodes adds k new nodes. So the number of new nodes added is k * k. Now, the leaves are those new nodes. The number of leaves is k * k. \n\nThen, in the next expansion step, each of those k^2 leaves is connected to k new nodes. So adding k^3 nodes. Leaves now are k^3. \n\nSo the total number of nodes after m expansion steps (m ≥ 1) is:\n\nTotal = 1 + k + k^2 + ... + k^m ?\n\nWait, no. Because the first expansion step adds k nodes. Then the second adds k^2, third adds k^3, etc. So the total number of nodes is:\n\n1 (initial) + k (after first expansion) + k^2 (after second expansion) + ... + k^m (after m-th expansion). \n\nWait, but the expansion steps are done after the initial step. So the first expansion step is required (since the problem says that the step should be done at least once",
    "response": "\n\nTo solve this problem, we need to determine if a snowflake graph with exactly `n` vertices can be constructed based on specific rules. The snowflake graph starts with one vertex and expands by connecting each leaf node to `k` new vertices in each expansion step (with at least one such step).\n\n### Approach\n1. **Understanding the Structure**: The snowflake graph starts with one vertex. Each expansion step adds more vertices by connecting each leaf node to `k` new vertices. The total number of vertices after `m` expansion steps is given by the formula:\n   $$\n   n = 1 + k + k^2 + k^3 + \\ldots + k^m\n   $$\n   This forms a geometric series.\n\n2. **Geometric Series Check**: For a given `n`, we need to check if there exists an integer `k > 1` and an integer `m ≥ 1` such that the sum of the geometric series equals `n`.\n\n3. **Iterative Check**: For each test case, iterate over possible values of `k` and check if the sum of the geometric series for some `m` equals `n`. Since `n` can be very large (up to $10^{18}$), we need an efficient approach to avoid excessive computations.\n\n### Solution Code\n```python\nimport sys\n\ndef is_snowflake(n):\n    if n == 1:\n        return False\n    # Try different values of k\n    for k in range(2, 60):  # since k^60 is way larger than 1e18\n        total = 1  # initial node\n        current = 1  # current term is k^m\n        m = 0\n        while True:\n            next_term = current * k\n            if next_term > 1e18:\n                break\n            total += next_term\n            m += 1\n            if total == n:\n                return True\n            elif total > n:\n                break\n            current = next_term\n    return False\n\ndef main():\n    input = sys.stdin.read().split()\n    t = int(input[0])\n    cases = list(map(int, input[1:t+1]))\n    for n in cases:\n        if is_snowflake(n):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Geometric Series Check**: For each possible value of `k` starting from 2 up to 60 (since $k^{60}$ exceeds $10^{18}$), we compute the cumulative sum of the geometric series until it either matches `n` or exceeds it.\n- **Efficiency**: By limiting `k` to a reasonable upper bound (60) and breaking early when the sum exceeds `n`, we ensure the solution is efficient even for very large values of `n`.\n\nThis approach efficiently checks all possible values of `k` and expansion steps to determine if a valid snowflake graph can be constructed with exactly `n` vertices.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef is_snowflake(n):\n    if n == 1:\n        return False\n    # Try different values of k\n    for k in range(2, 60):  # since k^60 is way larger than 1e18\n        total = 1  # initial node\n        current = 1  # current term is k^m\n        m = 0\n        while True:\n            next_term = current * k\n            if next_term > 1e18:\n                break\n            total += next_term\n            m += 1\n            if total == n:\n                return True\n            elif total > n:\n                break\n            current = next_term\n    return False\n\ndef main():\n    input = sys.stdin.read().split()\n    t = int(input[0])\n    cases = list(map(int, input[1:t+1]))\n    for n in cases:\n        if is_snowflake(n):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 561,
        "completion_token_count": 648,
        "thoughts_token_count": 1023
    }
}