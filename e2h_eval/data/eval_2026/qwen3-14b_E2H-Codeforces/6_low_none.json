{
    "start": 1758008324.5932825,
    "end": 1758008530.5130627,
    "start-formatted": "2025-09-16 16:38 KST",
    "end-formatted": "2025-09-16 16:42 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\nOkay, let's tackle this problem. So, the task is to find two non-overlapping vouchers whose total duration equals exactly x, and their combined cost is minimized. If there's no such pair, return -1.\n\nFirst, I need to understand the problem thoroughly. Let's break down the requirements:\n\nEach voucher has a departure day (li), return day (ri), and cost. The duration is ri - li + 1. We need two vouchers i and j (i≠j) such that their durations add up to x. Also, they must not overlap. Non-overlapping means either the first ends before the second starts (ri < lj) or the second ends before the first starts (rj < li).\n\nThe challenge is to find such pairs efficiently given the constraints of n up to 2e5. A brute-force approach checking all pairs would be O(n²), which is way too slow for n=2e5. So we need an efficient approach.\n\nLet me think about how to approach this. For each voucher, we can check if there exists another voucher that doesn't overlap with it and has a duration of (x - duration of current voucher). But how do we find that efficiently?\n\nLet me think about the steps:\n\n1. Preprocess all vouchers by their duration. For each possible duration d, store the minimum cost of vouchers with that duration. Also, maybe store the earliest ending day or latest starting day for each duration to help with non-overlapping checks?\n\nWait, but for each voucher with duration d, we need to find another voucher with duration (x - d) that does not overlap with it. So for each voucher, we can check if there's a voucher with duration (x - d) that ends before li (so that the other voucher is before this one), or starts after ri (so that the other voucher is after this one).\n\nBut how to quickly find the minimal cost for those cases?\n\nLet me think. Suppose I have a voucher A with duration d. Then, I need to find vouchers B with duration (x - d) such that B ends before A starts (B's ri < A's li) or B starts after A ends (B's li > A's ri). For each such B, the minimal cost would be helpful.\n\nSo perhaps for each possible duration, we can keep track of the minimum cost for vouchers that end on or before a certain day, and also the minimum cost for vouchers that start on or after a certain day.\n\nAlternatively, for each duration d, we can have two structures:\n\n- For vouchers of duration d, sorted by their end time. Then, for a given start time (say, the start of voucher A), we can find the minimum cost among vouchers of duration (x - d) that end before this start time.\n\nSimilarly, for vouchers of duration d, sorted by their start time. For a given end time (the end of voucher A), find the minimum cost among vouchers of duration (x - d) that start after this end time.\n\nBut how to precompute these?\n\nAnother idea: Preprocess for each possible duration, the list of vouchers sorted by their end time, and also for each duration, the list of vouchers sorted by their start time. Then, for each voucher, when considering possible pairs, we can query the min cost in those sorted lists.\n\nBut even then, for each voucher, we need to perform two queries:\n\nFor the first part (voucher B ends before voucher A starts):\n\nWe need to find vouchers with duration (x - d) where ri < li_A. So, if we have all vouchers of duration (x - d) sorted by their ri, we can find the ones with ri < li_A. Among those, what is the minimal cost?\n\nSimilarly, for vouchers with duration (x - d) where li > ri_A. So, sorted by li, find the ones with li > ri_A, and get the minimal cost.\n\nIf we can find these minima efficiently, then for each voucher, we can compute the possible candidates.\n\nSo the plan is:\n\n- Preprocess for each duration, the list of vouchers sorted by end time (ri) and also sorted by start time (li).\n\nThen, for each voucher i with duration d_i:\n\n- Check if (x - d_i) is a valid duration (i.e., there exists some vouchers with that duration). If not, skip.\n\n- For the case where we need a voucher j with duration (x - d_i) that ends before li (so that voucher j is before voucher i):\n\n   - Find the minimum cost among all vouchers of duration (x - d_i) with ri < li_i.\n\n- For the case where we need a voucher j with duration (x - d_i) that starts after ri_i (so that voucher j is after voucher i):\n\n   - Find the minimum cost among all vouchers of duration (x - d_i) with li > ri_i.\n\nIf either of these two cases has a valid",
    "response": "\n\nTo solve this problem, we need to find two non-overlapping vouchers whose combined duration exactly matches a given value `x` and whose total cost is minimized. If no such pair exists, we should return -1.\n\n### Approach\n1. **Preprocessing by Duration**: We first categorize all vouchers by their duration. This helps in quickly checking if there are vouchers of a specific duration that can be paired with another voucher.\n2. **Sorting and Binary Search**: For each duration, we maintain two sorted lists:\n   - One sorted by the end date (`ri`) to efficiently find vouchers ending before a certain date.\n   - Another sorted by the start date (`li`) to efficiently find vouchers starting after a certain date.\n3. **Efficient Querying**: Using binary search on these sorted lists, we can quickly determine the minimum cost of vouchers that end before or start after a given date, ensuring non-overlapping conditions.\n\n### Solution Code\n```python\nimport sys\nimport bisect\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n\n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n\n    # Preprocess: for each duration, store sorted lists of (end, cost) and (start, cost)\n    duration_data = defaultdict(lambda: {'end': [], 'start': []})\n    for l, r, cost, d in vouchers:\n        duration_data[d]['end'].append((r, cost))\n        duration_data[d]['start'].append((l, cost))\n\n    # Sort the lists for each duration\n    for d in duration_data:\n        duration_data[d]['end'].sort()\n        duration_data[d]['start'].sort()\n\n    min_total = float('inf')\n\n    for l_i, r_i, cost_i, d_i in vouchers:\n        target_d = x - d_i\n        if target_d < 1:\n            continue\n        if target_d not in duration_data:\n            continue\n\n        # Case 1: find a voucher with duration target_d that ends before l_i\n        end_list = duration_data[target_d]['end']\n        # Find the largest r_j < l_i\n        # Use bisect to find the insertion point\n        pos = bisect.bisect_left(end_list, (l_i, 0))  # 0 is dummy cost\n        if pos > 0:\n            # The first pos elements have r_j < l_i\n            # We need the minimal cost among these\n            # Since end_list is sorted by r_j, but costs may vary\n            # So we need to precompute prefix minima\n            # Wait, but how? We need to process this during preprocessing\n            # So let's precompute for each duration's end list, the prefix minima\n            # Let's adjust the code to precompute minima\n\n    # Re-initialize duration_data with prefix minima\n    duration_data = defaultdict(lambda: {'end': [], 'start': []})\n    for l, r, cost, d in vouchers:\n        duration_data[d]['end'].append((r, cost))\n        duration_data[d]['start'].append((l, cost))\n\n    for d in duration_data:\n        # Sort end list by r\n        duration_data[d]['end'].sort()\n        # Create prefix minima for end list\n        prefix_min_end = []\n        min_cost = float('inf')\n        for r_j, cost_j in duration_data[d]['end']:\n            if cost_j < min_cost:\n                min_cost = cost_j\n            prefix_min_end.append(min_cost)\n        duration_data[d]['prefix_min_end'] = prefix_min_end\n\n        # Sort start list by l\n        duration_data[d]['start'].sort()\n        # Create suffix minima for start list\n        suffix_min_start = [0] * len(duration_data[d]['start'])\n        min_cost = float('inf')\n        for i in reversed(range(len(duration_data[d]['start']))):\n            l_j, cost_j = duration_data[d]['start'][i]\n            if cost_j < min_cost:\n                min_cost = cost_j\n            suffix_min_start[i] = min_cost\n        duration_data[d]['suffix_min_start'] = suffix_min_start\n\n    for l_i, r_i, cost_i, d_i in vouchers:\n        target_d = x - d_i\n        if target_d < 1:\n            continue\n        if target_d not in duration_data:\n            continue\n\n        # Case 1: find a voucher with duration target_d that ends before l_i\n        end_list = duration_data[target_d]['end']\n        prefix_min_end = duration_data[target_d]['prefix_min_end']\n        pos = bisect.bisect_left(end_list, (l_i, 0))\n        if pos > 0:\n            min_cost_j = prefix_min_end[pos - 1]\n            total = cost_i + min_cost_j\n            if total < min_total:\n                min_total = total\n\n        # Case 2: find a voucher with duration target_d that starts after r_i\n        start_list = duration_data[target_d]['start']\n        suffix_min_start = duration_data[target_d]['suffix_min_start']\n        pos = bisect.bisect_right(start_list, (r_i, float('inf')))\n        if pos < len(start_list):\n            min_cost_j = suffix_min_start[pos]\n            total = cost_i + min_cost_j\n            if total < min_total:\n                min_total = total\n\n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Preprocessing**: Vouchers are categorized by their duration. For each duration, we maintain lists of vouchers sorted by their end and start times.\n2. **Prefix and Suffix Minima**: For efficient querying, we precompute prefix minima for end-sorted lists and suffix minima for start-sorted lists. This allows quick lookup of the minimum cost for vouchers ending before a certain date or starting after a certain date.\n3. **Binary Search**: For each voucher, we use binary search to determine valid ranges of other vouchers that can be paired without overlapping, leveraging the precomputed minima to quickly find the minimum cost.\n\nThis approach ensures that we efficiently check all possible valid pairs while maintaining a time complexity that is feasible for large inputs.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport bisect\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n\n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n\n    # Preprocess: for each duration, store sorted lists of (end, cost) and (start, cost)\n    duration_data = defaultdict(lambda: {'end': [], 'start': []})\n    for l, r, cost, d in vouchers:\n        duration_data[d]['end'].append((r, cost))\n        duration_data[d]['start'].append((l, cost))\n\n    # Sort the lists for each duration\n    for d in duration_data:\n        duration_data[d]['end'].sort()\n        duration_data[d]['start'].sort()\n\n    min_total = float('inf')\n\n    for l_i, r_i, cost_i, d_i in vouchers:\n        target_d = x - d_i\n        if target_d < 1:\n            continue\n        if target_d not in duration_data:\n            continue\n\n        # Case 1: find a voucher with duration target_d that ends before l_i\n        end_list = duration_data[target_d]['end']\n        # Find the largest r_j < l_i\n        # Use bisect to find the insertion point\n        pos = bisect.bisect_left(end_list, (l_i, 0))  # 0 is dummy cost\n        if pos > 0:\n            # The first pos elements have r_j < l_i\n            # We need the minimal cost among these\n            # Since end_list is sorted by r_j, but costs may vary\n            # So we need to precompute prefix minima\n            # Wait, but how? We need to process this during preprocessing\n            # So let's precompute for each duration's end list, the prefix minima\n            # Let's adjust the code to precompute minima\n\n    # Re-initialize duration_data with prefix minima\n    duration_data = defaultdict(lambda: {'end': [], 'start': []})\n    for l, r, cost, d in vouchers:\n        duration_data[d]['end'].append((r, cost))\n        duration_data[d]['start'].append((l, cost))\n\n    for d in duration_data:\n        # Sort end list by r\n        duration_data[d]['end'].sort()\n        # Create prefix minima for end list\n        prefix_min_end = []\n        min_cost = float('inf')\n        for r_j, cost_j in duration_data[d]['end']:\n            if cost_j < min_cost:\n                min_cost = cost_j\n            prefix_min_end.append(min_cost)\n        duration_data[d]['prefix_min_end'] = prefix_min_end\n\n        # Sort start list by l\n        duration_data[d]['start'].sort()\n        # Create suffix minima for start list\n        suffix_min_start = [0] * len(duration_data[d]['start'])\n        min_cost = float('inf')\n        for i in reversed(range(len(duration_data[d]['start']))):\n            l_j, cost_j = duration_data[d]['start'][i]\n            if cost_j < min_cost:\n                min_cost = cost_j\n            suffix_min_start[i] = min_cost\n        duration_data[d]['suffix_min_start'] = suffix_min_start\n\n    for l_i, r_i, cost_i, d_i in vouchers:\n        target_d = x - d_i\n        if target_d < 1:\n            continue\n        if target_d not in duration_data:\n            continue\n\n        # Case 1: find a voucher with duration target_d that ends before l_i\n        end_list = duration_data[target_d]['end']\n        prefix_min_end = duration_data[target_d]['prefix_min_end']\n        pos = bisect.bisect_left(end_list, (l_i, 0))\n        if pos > 0:\n            min_cost_j = prefix_min_end[pos - 1]\n            total = cost_i + min_cost_j\n            if total < min_total:\n                min_total = total\n\n        # Case 2: find a voucher with duration target_d that starts after r_i\n        start_list = duration_data[target_d]['start']\n        suffix_min_start = duration_data[target_d]['suffix_min_start']\n        pos = bisect.bisect_right(start_list, (r_i, float('inf')))\n        if pos < len(start_list):\n            min_cost_j = suffix_min_start[pos]\n            total = cost_i + min_cost_j\n            if total < min_total:\n                min_total = total\n\n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 731,
        "completion_token_count": 1410,
        "thoughts_token_count": 1023
    }
}