{
    "start": 1758313551.081405,
    "end": 1758313606.8007607,
    "start-formatted": "2025-09-20 05:25 KST",
    "end-formatted": "2025-09-20 05:26 KST",
    "gpu": 2,
    "pid": 6,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\nOkay, let's see. I need to solve this programming problem. Let me read the problem carefully again.\n\nSo, the problem is about finding two vouchers that don't overlap, their durations add up exactly to x, and their total cost is minimized. If there's no such pair, output -1.\n\nFirst, let's understand the input. Each voucher has li (departure day), ri (return day), and cost. The duration is ri - li + 1. We need two vouchers i and j such that their durations sum to x, and they don't overlap. Also, they have to be different vouchers.\n\nThe key points here are:\n\n- Check for all pairs of vouchers where the sum of durations is x.\n- Ensure that the vouchers do not overlap. Which means either the first ends before the second starts, or vice versa.\n- Find the minimum total cost among all such valid pairs.\n\nBut with n up to 2e5, checking all possible pairs is O(n²), which is way too slow. So we need a smarter approach.\n\nHmm. How can we optimize this?\n\nLet me think: For each voucher, we can compute its duration. Let's say for a voucher with duration d, we need another voucher with duration x - d. So for each voucher, we look for vouchers with duration (x - d) that do not overlap with it.\n\nBut how to efficiently find those vouchers?\n\nMaybe we can pre-process vouchers by their duration. Like, for each possible duration, store a list of vouchers with that duration, sorted by their start and end times.\n\nBut even then, for each voucher, we need to find vouchers of duration (x - d) that don't overlap with it. How to do that quickly?\n\nLet's think about the steps:\n\n1. Precompute for each voucher its duration. Let's call it d_i = ri - li + 1.\n\n2. For each voucher i, check if there exists a voucher j with duration (x - d_i). If x - d_i is not a valid duration (like negative, or zero?), then skip. But since x is at least 2 (since n and x are ≥2?), wait no. Wait, x can be 2. For example, in the sample input, the second example has x=2, and each voucher has duration 3. So sum would be 6, which is larger than x=2. Hence, no solution.\n\nSo for each voucher i, we need to check if there's a voucher j with duration (x - d_i), and that j does not overlap with i. Then, find the minimum cost for such pairs.\n\nBut how to find the minimum cost for j's that meet the criteria?\n\nLet me think about grouping vouchers by their duration. For example, create a dictionary where the key is the duration, and the value is a list of vouchers with that duration. Then, for each voucher i with duration d, we look into the group for duration (x - d). Then, within that group, we need to find vouchers that don't overlap with i.\n\nBut how to find those vouchers efficiently?\n\nFor each voucher in the group (x - d), we need to check if they are non-overlapping with voucher i. Let's think about voucher i's [li, ri]. For a voucher j in the group (x - d), it must satisfy either rj < li or lj > ri.\n\nSo for each voucher i, when looking for j's in the group (x - d), we need to find the minimal cost of vouchers j that are entirely before i (rj < li) or entirely after i (lj > ri).\n\nBut how to find these minimal costs quickly?\n\nFor each duration, perhaps we can pre-process the vouchers in that duration group by their end time and start time. For example, for a given duration D, we can have two sorted lists:\n\n- Sorted by end time (so we can find the earliest end time that is less than li)\n- Sorted by start time (so we can find the earliest start time that is greater than ri)\n\nWait, but for each voucher in the D group, we want to find the ones that end before li (so they are before i) or start after ri (so they are after i). For each of these two categories, we can find the minimum cost.\n\nSo for each duration D, we can pre-process two structures:\n\n- A list of vouchers sorted by their end time, and for each position, keep track of the minimum cost up to that point. This way, when we need to find the minimal cost of vouchers that end before a certain value (li), we can perform a binary search on the end times and get the min cost from all vouchers up to that point.\n\nSimilarly, a list of vouchers sorted by their start time, with prefix minima. So for vouchers that start after a certain value (ri), we can binary search to find the first start time that is > ri, and",
    "response": "To solve this problem, we need to find two non-overlapping vouchers whose combined duration exactly matches a given value `x` and whose total cost is minimized. If no such pair exists, we should return `-1`.\n\n### Approach\n1. **Group Vouchers by Duration**: First, we group all vouchers by their duration. This helps in efficiently checking for pairs of vouchers that sum up to the required duration `x`.\n2. **Preprocess for Efficient Querying**: For each duration, we maintain two sorted lists:\n   - One sorted by the end time of vouchers, along with prefix minimum costs.\n   - Another sorted by the start time of vouchers, along with prefix minimum costs.\n3. **Binary Search for Non-overlapping Vouchers**: For each voucher, we check if there exists another voucher with the complementary duration (i.e., `x - duration`). Using binary search, we efficiently find the minimum cost of non-overlapping vouchers.\n\n### Solution Code\n```python\nimport bisect\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n    \n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n    \n    # Group vouchers by duration\n    duration_map = defaultdict(list)\n    for l, r, cost, d in vouchers:\n        duration_map[d].append((l, r, cost))\n    \n    # Preprocess each duration group\n    # For each duration D, we have:\n    # - sorted_end: list of (end, min_cost_so_far)\n    # - sorted_start: list of (start, min_cost_so_far)\n    # Also, for sorted_end, we sort by end, and for sorted_start, sort by start\n    processed = dict()\n    for d in duration_map:\n        lst = duration_map[d]\n        # Sort by end time\n        sorted_end = sorted(lst, key=lambda x: x[1])\n        # Create prefix min for end\n        prefix_min_end = []\n        min_cost = float('inf')\n        for item in sorted_end:\n            min_cost = min(min_cost, item[2])\n            prefix_min_end.append((item[1], min_cost))\n        # Sort by start time\n        sorted_start = sorted(lst, key=lambda x: x[0])\n        # Create prefix min for start\n        prefix_min_start = []\n        min_cost = float('inf')\n        for item in sorted_start:\n            min_cost = min(min_cost, item[2])\n            prefix_min_start.append((item[0], min_cost))\n        processed[d] = (sorted_end, prefix_min_end, sorted_start, prefix_min_start)\n    \n    min_total = float('inf')\n    \n    for l1, r1, cost1, d1 in vouchers:\n        target_d = x - d1\n        if target_d < 1:\n            continue\n        if target_d not in processed:\n            continue\n        # Now check for vouchers with duration target_d\n        # Get the processed data\n        sorted_end, prefix_min_end, sorted_start, prefix_min_start = processed[target_d]\n        \n        # Check for vouchers ending before l1\n        # Find the largest end <= l1 - 1\n        ends = [e for e, _ in prefix_min_end]\n        pos = bisect.bisect_right(ends, l1 - 1)\n        if pos > 0:\n            min_cost_before = prefix_min_end[pos - 1][1]\n            min_total = min(min_total, cost1 + min_cost_before)\n        \n        # Check for vouchers starting after r1\n        starts = [s for s, _ in prefix_min_start]\n        pos = bisect.bisect_right(starts, r1)\n        if pos < len(starts):\n            min_cost_after = prefix_min_start[pos][1]\n            min_total = min(min_total, cost1 + min_cost_after)\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Grouping by Duration**: Vouchers are grouped by their duration to quickly access potential pairs that sum to `x`.\n- **Preprocessing**: For each duration, we maintain sorted lists of start and end times along with prefix minimum costs. This allows efficient querying of minimum costs using binary search.\n- **Binary Search for Non-overlapping Vouchers**: For each voucher, we use binary search to find the minimum cost of non-overlapping vouchers with the complementary duration, ensuring efficient lookups and minimizing the total cost.\n\nThis approach ensures that we efficiently check all possible valid pairs without resorting to an O(n²) brute-force method, making the solution feasible even for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import bisect\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n    \n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n    \n    # Group vouchers by duration\n    duration_map = defaultdict(list)\n    for l, r, cost, d in vouchers:\n        duration_map[d].append((l, r, cost))\n    \n    # Preprocess each duration group\n    # For each duration D, we have:\n    # - sorted_end: list of (end, min_cost_so_far)\n    # - sorted_start: list of (start, min_cost_so_far)\n    # Also, for sorted_end, we sort by end, and for sorted_start, sort by start\n    processed = dict()\n    for d in duration_map:\n        lst = duration_map[d]\n        # Sort by end time\n        sorted_end = sorted(lst, key=lambda x: x[1])\n        # Create prefix min for end\n        prefix_min_end = []\n        min_cost = float('inf')\n        for item in sorted_end:\n            min_cost = min(min_cost, item[2])\n            prefix_min_end.append((item[1], min_cost))\n        # Sort by start time\n        sorted_start = sorted(lst, key=lambda x: x[0])\n        # Create prefix min for start\n        prefix_min_start = []\n        min_cost = float('inf')\n        for item in sorted_start:\n            min_cost = min(min_cost, item[2])\n            prefix_min_start.append((item[0], min_cost))\n        processed[d] = (sorted_end, prefix_min_end, sorted_start, prefix_min_start)\n    \n    min_total = float('inf')\n    \n    for l1, r1, cost1, d1 in vouchers:\n        target_d = x - d1\n        if target_d < 1:\n            continue\n        if target_d not in processed:\n            continue\n        # Now check for vouchers with duration target_d\n        # Get the processed data\n        sorted_end, prefix_min_end, sorted_start, prefix_min_start = processed[target_d]\n        \n        # Check for vouchers ending before l1\n        # Find the largest end <= l1 - 1\n        ends = [e for e, _ in prefix_min_end]\n        pos = bisect.bisect_right(ends, l1 - 1)\n        if pos > 0:\n            min_cost_before = prefix_min_end[pos - 1][1]\n            min_total = min(min_total, cost1 + min_cost_before)\n        \n        # Check for vouchers starting after r1\n        starts = [s for s, _ in prefix_min_start]\n        pos = bisect.bisect_right(starts, r1)\n        if pos < len(starts):\n            min_cost_after = prefix_min_start[pos][1]\n            min_total = min(min_total, cost1 + min_cost_after)\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 732,
        "completion_token_count": 1070,
        "thoughts_token_count": 1024
    }
}