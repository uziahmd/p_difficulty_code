{
    "start": 1758344528.9498324,
    "end": 1758344704.943339,
    "start-formatted": "2025-09-20 14:02 KST",
    "end-formatted": "2025-09-20 14:05 KST",
    "gpu": 2,
    "pid": 13,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Chord\n\nVasya studies music. He has learned lots of interesting stuff. For example, he knows that there are 12 notes: C, C#, D, D#, E, F, F#, G, G#, A, B, H. He also knows that the notes are repeated cyclically: after H goes C again, and before C stands H. We will consider the C note in the row's beginning and the C note after the H similar and we will identify them with each other. The distance between the notes along the musical scale is measured in tones: between two consecutive notes there's exactly one semitone, that is, 0.5 tone. The distance is taken from the lowest tone to the uppest one, that is, the distance between C and E is 4 semitones and between E and C is 8 semitonesVasya also knows what a chord is. A chord is an unordered set of no less than three notes. However, for now Vasya only works with triads, that is with the chords that consist of exactly three notes. He can already distinguish between two types of triads — major and minor.Let's define a major triad. Let the triad consist of notes X, Y and Z. If we can order the notes so as the distance along the musical scale between X and Y equals 4 semitones and the distance between Y and Z is 3 semitones, then the triad is major. The distance between X and Z, accordingly, equals 7 semitones.A minor triad is different in that the distance between X and Y should be 3 semitones and between Y and Z — 4 semitones.For example, the triad \"C E G\" is major: between C and E are 4 semitones, and between E and G are 3 semitones. And the triplet \"C# B F\" is minor, because if we order the notes as \"B C# F\", than between B and C# will be 3 semitones, and between C# and F — 4 semitones.Help Vasya classify the triad the teacher has given to him.\n\n## Input\nThe only line contains 3 space-separated notes in the above-given notation.\n\n## Output\nPrint \"major\" if the chord is major, \"minor\" if it is minor, and \"strange\" if the teacher gave Vasya some weird chord which is neither major nor minor. Vasya promises you that the answer will always be unambiguous. That is, there are no chords that are both major and minor simultaneously.\n\n## Example\n### Input\n['C E G', 'C# B F', 'A B H']\n\n### Output\n['major', 'minor', 'strange']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\nOkay, let's see. I need to solve this problem where I have to determine if a given triad of notes is major, minor, or strange. The input is three notes, and I have to check all possible orderings to see if any of them fit the major or minor criteria.\n\nFirst, I need to figure out how to represent the notes and calculate the distances between them. The notes are in a cyclic order. Let me think about the order. The problem lists them as C, C#, D, D#, E, F, F#, G, G#, A, B, H. Wait, wait, in the problem statement, it says that after H comes C again. Oh right, and the distance between consecutive notes is one semitone. So each note is 1 semitone apart from the next. So for example, C to C# is 1 semitone, C to D is 2, etc. But since it's cyclic, the distance between H and C is 1 semitone as well.\n\nSo, the first thing I need is a way to map each note to its position in this sequence. Then, when given two notes, I can compute the distance between them by taking the difference in their positions, modulo 12, but considering the direction. Wait, but the problem says that the distance is measured from the lower note to the upper one. For example, between C and E, the distance is 4 semitones. Let me check: C is position 0, E is position 4 (since C is 0, C# 1, D 2, D#3, E4). So the distance from C to E is 4 semitones. But if you have E to C, the distance would be 8 semitones? Because the problem says that the distance is taken from the lower to the upper. So when calculating the distance between X and Y, we need to find the number of semitones when moving upwards from X to Y. So if X is before Y in the list, then it's Y's index minus X's index. If X is after Y, then it's (12 - (X's index - Y's index))? Or maybe (Y's index + 12 - X's index) mod 12? Wait, no. Let me think: for example, if X is H (which is position 11?), and Y is C (position 0). The distance from X to Y is 1 semitone. So how do I compute that?\n\nSo, the distance between X and Y is (Y's position - X's position) mod 12? No, because if Y is after X, then it's positive. But if Y is before X, then (Y - X) would be negative. But the distance is supposed to be the number of semitones when moving upwards. So for example, if X is E (position 4), Y is C (position 0). The distance from X to Y is 8 semitones. Because moving up from E to C would require going through F, F#, G, G#, A, B, H, C. That's 8 steps. So how to calculate that?\n\nThe correct formula for the distance from X to Y is (Y_pos - X_pos) if Y is higher than X, else (Y_pos + 12 - X_pos). Alternatively, it can be calculated as (Y_pos - X_pos) mod 12, but since the distance is always positive. Wait, no. Because if Y is lower than X, then (Y_pos - X_pos) is negative. But mod 12 would give a positive value. Let me see:\n\nFor example, X is E (4), Y is C (0). Y_pos - X_pos = 0 -4 = -4. Mod 12 gives 8. Which is correct. Similarly, X is C (0), Y is E (4): 4-0=4 mod12 is 4. Correct. And if X is H (11), Y is C (0): 0-11 = -11 mod12 is 1. Which is correct. So the distance from X to Y is (Y_pos - X_pos) mod 12. But since the problem says that the distance is measured from the lower note to the upper one. Wait, but how do I know which note is lower? Because the distance is defined as the number of semitones between the two notes when moving upwards. So the distance between X and Y is the number of semitones you need to move up from X to reach Y. So if X is lower than Y, then it's Y - X. If X is higher than Y, then it's 12 - (X - Y). Which is the same as (Y - X) mod 12. So yes, the distance between X and Y is (Y_pos - X_pos) mod 12. But since the problem says that the distance between X and Y is measured from the lower to the upper. So for example, the distance between E and C is 8 semitones, which is (0 -4) mod12 = 8. So that's correct.\n\nSo the key is to calculate the distance between two notes as (Y_pos - X_pos) mod 12. But since the problem says that the distance is from the lower to the upper, but when you compute that mod 12, it gives the correct value. So for any two notes X and Y, the distance from X to Y is (Y - X) mod 12. But in the problem's definition, the distance between X and Y is the number of semitones between them along the scale, moving upwards. So this formula works.\n\nNow, for the triad. For a major triad, there must be an ordering X, Y, Z such that distance between X and Y is 4 semitones, and between Y and Z is 3 semitones. So the total distance between X and Z would be 7 semitones. But since the triad is unordered, we need to check all permutations of the three notes to see if any permutation satisfies this condition.\n\nSimilarly for minor: distance between X and Y is 3, between Y and Z is 4.\n\nSo the approach is:\n\n- For the three given notes, generate all possible permutations (since the order matters for checking the distances).\n\n- For each permutation (X, Y, Z), check:\n\n   - distance between X and Y is 4, and between Y and Z is 3 → major.\n\n   - or distance between X and Y is 3, and between Y and Z is 4 → minor.\n\nIf any permutation meets the major condition, then output 'major'. Similarly for minor. If none, output 'strange'.\n\nBut since the problem says that the answer is unambiguous, we don't have to worry about overlapping cases.\n\nSo first, I need to create a mapping from note names to their positions. Let's create a list of the notes in order. Let's see:\n\nThe problem lists them as:\n\nC, C#, D, D#, E, F, F#, G, G#, A, B, H.\n\nWait, but in the example, the third input is 'A B H'. Let's check the notes. H is the last note. So the order is:\n\nindexes 0 to 11:\n\n0: C\n\n1: C#\n\n2: D\n\n3: D#\n\n4: E\n\n5: F\n\n6: F#\n\n7: G\n\n8: G#\n\n9: A\n\n10: B\n\n11: H\n\nWait, but in the example, the third input is A, B, H. Let's see:\n\nA is index 9, B is 10, H is 11. So for example, the distance between B and H is (11 -10) = 1. Between H and A is (9 - 11) mod 12 = ( -2 ) mod 12 = 10? So that's 10 semitones. But perhaps the example's third input is 'A B H' which is supposed to be strange. Let's see why.\n\nLet me think about all permutations of A, B, H. Let's take each possible order and check for major or minor.\n\nFor example, let's take X=A, Y=B, Z=H.\n\nDistance between A and B is 1 (B is index 10, A is 9. 10-9=1). Then between B and H is 11-10=1. So 1 and 1. Not 4 and 3 or 3 and 4. So not.\n\nAnother permutation: X=A, Y=H, Z=B. Distance from A to H is (11 -9) = 2. Then from H to B is (10 -11) mod 12 = ( -1 ) mod 12 = 11. So 2 and 11. Not matching.\n\nAnother permutation: X=B, Y=A, Z=H. Distance from B to A is (9 -10) mod 12 = 11. Which is 11 semitones. Then from A to H is 11-9=2. So 11 and 2. Not matching.\n\nAnother permutation: X=B, Y=H, Z=A. Distance from B to H is 11-10=1. Then H to A is 9 -11 mod 12 = ( -2 ) mod 12 = 10. 1 and 10. Not matching.\n\nAnother permutation: X=H, Y=A, Z=B. Distance from H to A is (9 - 11) mod 12 = ( -2 ) mod 12 = 10. Then from A to B is 1. 10 and 1. Not matching.\n\nAnother permutation: X=H, Y=B, Z=A. Distance from H to B is (10 - 11) mod 12 = ( -1 ) mod 12 = 11. Then from B to A is (9-10) mod 12 = 11. So 11 and 11. Not matching.\n\nSo none of the permutations meet the criteria. Hence, the output is strange. Which matches the example.\n\nSo the plan is:\n\n1. Create a dictionary that maps each note to its index (position) in the list.\n\n2. For the input notes, generate all possible permutations (since the order matters for checking the conditions).\n\n3. For each permutation (X, Y, Z):\n\n   a. Compute distance between X and Y (d1).\n\n   b. Compute distance between Y and Z (d2).\n\n   c. Check if d1 is 4 and d2 is 3 → major.\n\n   d. Check if d1 is 3 and d2 is 4 → minor.\n\n4. If any permutation meets the major condition, return 'major'. Similarly for minor. If neither, return 'strange'.\n\nNow, how to generate permutations of the three notes. Since there are 3! = 6 permutations. For example, for notes [A, B, H], the permutations are all possible orderings.\n\nBut since the input is three distinct notes (assuming that they are distinct?), but the problem says that the input is three space-separated notes. But the problem says that the answer is unambiguous, so perhaps the input can have duplicates? Well, the problem says that the chord is an unordered set of no less than three notes. However, the input is three notes. But the problem says that the answer is unambiguous. So perhaps the input will have three distinct notes. But the code should handle cases where there are duplicates? Well, the problem says that the answer is always unambiguous. So even if there are duplicates, the code can process them, but in practice, the input will have three distinct notes.\n\nBut regardless, the code can process all permutations, even if some are same notes.\n\nSo, for the code:\n\nFirst, create a list of the notes in order. Let's create a list called note_order, where note_order[0] is 'C', note_order[1] is 'C#', etc. Then, create a dictionary note_to_index that maps each note to its index.\n\nThen, read the input. The input is three notes. For example, the first example input is ['C E G', 'C# B F', 'A B H'] — but the actual input is a single line with three notes. Wait, looking back at the problem statement:\n\nInput: The only line contains 3 space-separated notes in the above-given notation.\n\nSo the input is a single line, like \"C E G\" or \"C# B F\", etc. So the code needs to read three notes. So for example, the sample input is three different test cases? Wait, the example shows:\n\nSample Input:\n\n['C E G', 'C# B F', 'A B H']\n\nSample Output:\n\n['major', 'minor', 'strange']\n\nBut that's probably an example of three different test cases. However, the actual input is a single line. So perhaps the user is supposed to read a single line of three notes. For example, in the sample input, the first case is \"C E G\" which outputs 'major'.\n\nSo the code should read a single line, split into three notes.\n\nSo, in Python, the code would read input().split().\n\nOnce we have the three notes, we can generate all permutations of them. For each permutation, check for major or minor.\n\nNow, in Python, permutations can be generated using itertools.permutations. For example, for the three notes, permutations would generate all 6 possible orderings.\n\nSo, steps in code:\n\n- Read the three notes.\n\n- For each permutation of the three notes:\n\n   - compute d1 between first and second note.\n\n   - compute d2 between second and third note.\n\n   - check if d1 ==4 and d2 ==3 → major.\n\n   - check if d1 ==3 and d2 ==4 → minor.\n\nIf any permutation meets the major condition, then output 'major'. Similarly for minor. If none, output 'strange'.\n\nNow, how to compute the distance between two notes. For example, note1 and note2.\n\nWe can get their indices from the note_to_index dictionary. Let's call them idx1 and idx2. Then, distance is (idx2 - idx1) % 12. Because that gives the number of semitones from note1 to note2.\n\nWait, for example, note1 is C (0), note2 is E (4). (4-0) mod 12 is 4 → correct. For note1 is E (4), note2 is C (0): (0-4) mod 12 is 8 → correct. For note1 is H (11), note2 is C (0): (0-11) mod 12 = 1 → correct. So yes.\n\nSo, code for distance between X and Y is (idx_y - idx_x) % 12.\n\nSo, the code:\n\nFirst, define the note_order list. Let's make sure the order is correct.\n\nThe problem lists the notes as:\n\nC, C#, D, D#, E, F, F#, G, G#, A, B, H.\n\nWait, in the problem statement, the list is written as:\n\nC, C#, D, D#, E, F, F#, G, G#, A, B, H. So the order is:\n\n0: C\n\n1: C#\n\n2: D\n\n3: D#\n\n4: E\n\n5: F\n\n6: F#\n\n7: G\n\n8: G#\n\n9: A\n\n10: B\n\n11: H\n\nYes. So the note_order list would be:\n\nnote_order = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B', 'H']\n\nWait, but the problem says that after H comes C again. So the order is correct.\n\nNow, the note_to_index can be built as a dictionary:\n\nnote_to_index = {note: idx for idx, note in enumerate(note_order)}\n\nSo, for example, note_to_index['C'] is 0, note_to_index['H'] is 11.\n\nOnce that is set up, the code can proceed.\n\nSo, the code steps:\n\nRead the three notes as a list, say, notes = input().split()\n\nThen, generate all permutations of the three notes. For each permutation (x, y, z):\n\nCompute d1 = distance between x and y.\n\nCompute d2 = distance between y and z.\n\nCheck if d1 == 4 and d2 ==3 → if yes, then it's a major chord.\n\nCheck if d1 ==3 and d2 ==4 → if yes, then it's a minor chord.\n\nIf any permutation meets the major condition, then output 'major'. Similarly for minor. Else, 'strange'.\n\nNow, the code can loop through all permutations. Once any permutation meets the major or minor condition, we can return the result.\n\nBut since there are 6 permutations, it's manageable.\n\nNow, code:\n\nimport itertools\n\nnote_order = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B', 'H']\nnote_to_index = {note: idx for idx, note in enumerate(note_order)}\n\nnotes = input().split()\n\nfound_major = False\nfound_minor = False\n\nfor perm in itertools.permutations(notes):\n    x, y, z = perm\n    idx_x = note_to_index[x]\n    idx_y = note_to_index[y]\n    idx_z = note_to_index[z]\n    d1 = (idx_y - idx_x) % 12\n    d2 = (idx_z - idx_y) % 12\n    if d1 ==4 and d2 ==3:\n        found_major = True\n    if d1 ==3 and d2 ==4:\n        found_minor = True\n\nif found_major:\n    print(\"major\")\nelif found_minor:\n    print(\"minor\")\nelse:\n    print(\"strange\")\n\nWait, but what if multiple permutations trigger the same condition? For example, if two permutations satisfy major. But since the problem says that the answer is unambiguous, there's no case where both major and minor are possible. So the code can check for any occurrence of major or minor.\n\nBut in the code, found_major and found_minor are flags. So, if any permutation triggers major, found_major becomes True. Similarly for minor. Then, after checking all permutations, if found_major is True, output 'major'; else if found_minor is True, output 'minor'; else 'strange'.\n\nBut what if, for example, one permutation triggers major and another permutation triggers minor? According to the problem statement, this is impossible. So the code can safely check for either.\n\nBut the problem says that the answer is always unambiguous, so there are no such cases. Therefore, the code is correct.\n\nTesting the sample input:\n\nSample Input 1: 'C E G'\n\nPermutations:\n\nC, E, G → d1 = (E - C) = 4-0=4 → mod12 4. d2 = G - E = 7-4=3 → 3. So major → found_major is True.\n\nOther permutations may not matter. So the code returns 'major'.\n\nSample Input 2: 'C# B F'\n\nLooking at the permutation B, C#, F.\n\nCheck:\n\nB is note index 10. C# is index 1. F is index 5.\n\nd1 between B and C#: (1 -10) mod12 → ( -9 ) mod12 → 3? Let me compute:\n\n(1 -10) = -9. -9 mod 12 is 3 (since 12* (-1) is -12, -9 - (-12) = 3). So d1 is 3. Then between C# (index 1) and F (index5): 5-1 =4. So d2 is 4. So this permutation satisfies minor. So found_minor is True.\n\nSample Input 3: 'A B H' → as discussed earlier, no permutations meet the criteria. So output 'strange'.\n\nThus, the code seems to handle the sample correctly.\n\nNow, what about some other cases?\n\nTest case: 'C# E G' → Let's see. Let's check permutations.\n\nFor example, C#, E, G. d1 between C# (1) and E (4) is 3. Then between E (4) and G (7) is 3. So 3 and 3. Not matching. Another permutation: E, G, C#. d1 is G - E = 7-4=3. d2 is C# - G → (1 -7) mod12 = -6 mod12 = 6. So 3 and 6. Not. Another permutation: E, C#, G. d1 between E and C#: (1 -4) mod12 = -3 mod12 = 9. Not helpful. What about C#, G, E? d1 between C# and G is 7-1=6. d2 between G and E: (4-7) mod12 = -3 mod12 =9. No. So this triad would be strange.\n\nAnother test case: 'C E G#' → Let's see. Let's check permutations. For example, C, E, G#. Distance between C and E is 4. Between E and G#: G# is index 8. E is 4. 8-4=4. So d1=4, d2=4. Not. Another permutation: C, G#, E. d1 between C and G# is 8-0=8 mod12 is 8. Then between G# and E: (4-8) mod12 = -4 mod12 = 8. No. Another permutation: E, C, G#. d1 is (C - E) → (0 -4) mod12 = 8. Then between C and G# is 8. No. So perhaps this is strange.\n\nBut what about a minor chord? Let's take B, C#, F. As in the example. Let's see permutations. One permutation is B, C#, F. d1 between B (10) and C# (1) is (1-10) mod12 = ( -9 ) mod12 = 3. Then between C# (1) and F (5) is 5-1=4. So that's 3 and 4 → minor.\n\nSo the code works.\n\nNow, code-wise, the code uses itertools.permutations, which is acceptable. But perhaps for the purposes of code submission, it's better to generate all permutations manually, but for three elements, it's manageable. But itertools is allowed.\n\nNow, possible edge cases:\n\nWhat if the three notes are H, C, E. Let's see. Let's check permutations. For example, H, C, E. The distance between H and C is 1. Between C and E is 4. So 1 and 4. Not. Another permutation: C, H, E. Distance between C and H is 11-0=11 mod12 is 11. Then between H and E is 4-11 mod12 = ( -7 ) mod12 =5. Not. Another permutation: H, E, C. Distance between H and E is 4-11 mod12 → (4-11) is -7 mod12 → 5. Then between E and C is (0 -4) mod12 → 8. Not. Another permutation: E, H, C. Distance between E and H is 11-4=7. Then between H and C is 1. 7 and 1. Not. Another permutation: E, C, H. Distance between E and C is 8. Between C and H is 11. No. Another permutation: C, E, H. Distance between C and E is 4. Between E and H is 11-4=7. So 4 and 7. Not 3 and 4. So this is strange.\n\nAnother case: 'C# E G#'. Let's see. Let's check permutations. For example, C#, E, G#. Distance between C# and E is 4-1=3. Then between E and G# is 8-4=4. So 3 and 4 → minor. So this is a minor chord. So code would detect it.\n\nSo the code seems correct.\n\nNow, code-wise, the code reads the input, splits into three notes, and processes them.\n\nNow, the code needs to be written. Also, note that in Python, the permutations function returns tuples of the elements. So the code is correct.\n\nNow, the code must be written as a Python script that reads from stdin and writes to stdout.\n\nSo the code would be:\n\nimport itertools\n\nnote_order = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B', 'H']\nnote_to_index = {note: idx for idx, note in enumerate(note_order)}\n\nnotes = input().split()\n\nfound_major = False\nfound_minor = False\n\nfor perm in itertools.permutations(notes):\n    x, y, z = perm\n    idx_x = note_to_index[x]\n    idx_y = note_to_index[y]\n    idx_z = note_to_index[z]\n    d1 = (idx_y - idx_x) % 12\n    d2 = (idx_z - idx_y) % 12\n    if d1 == 4 and d2 == 3:\n        found_major = True\n    if d1 == 3 and d2 == 4:\n        found_minor = True\n\nif found_major:\n    print(\"major\")\nelif found_minor:\n    print(\"minor\")\nelse:\n    print(\"strange\")\n\nBut wait, the problem says that the input is three space-separated notes. For example, in the sample input, the input is something like 'C E G'.\n\nThis code should work. Now, testing for the sample input:\n\nSample Input: C E G → code returns 'major'.\n\nSample Input: C# B F → permutations include B, C#, F. Which gives d1 = (1 - 10) mod12 → ( -9 ) mod12 is 3. d2 is (5 - 1) mod12 is 4. So found_minor is True. So output 'minor'.\n\nSample Input: A B H → no permutations meet the criteria. Output 'strange'.\n\nSo the code is correct.\n\nI think that's the solution.\n",
    "response": "To solve this problem, we need to determine if a given triad of musical notes forms a major chord, a minor chord, or neither. The solution involves checking all permutations of the three notes to see if they meet the criteria for either a major or minor chord.\n\n### Approach\n1. **Mapping Notes to Indices**: First, we map each musical note to its corresponding position in the cyclic sequence of 12 notes. This helps in calculating the distances between notes efficiently.\n2. **Distance Calculation**: The distance between two notes is calculated using their positions in the sequence. The distance from note X to note Y is determined as `(Y's index - X's index) % 12`.\n3. **Permutations Check**: For each permutation of the three given notes, we check if the distances between the first and second note, and the second and third note, match the criteria for a major or minor chord.\n4. **Determine Chord Type**: Based on the permutations checked, we determine if the chord is major, minor, or strange (neither).\n\n### Solution Code\n```python\nimport itertools\n\nnote_order = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B', 'H']\nnote_to_index = {note: idx for idx, note in enumerate(note_order)}\n\nnotes = input().split()\n\nfound_major = False\nfound_minor = False\n\nfor perm in itertools.permutations(notes):\n    x, y, z = perm\n    idx_x = note_to_index[x]\n    idx_y = note_to_index[y]\n    idx_z = note_to_index[z]\n    d1 = (idx_y - idx_x) % 12\n    d2 = (idx_z - idx_y) % 12\n    if d1 == 4 and d2 == 3:\n        found_major = True\n    if d1 == 3 and d2 == 4:\n        found_minor = True\n\nif found_major:\n    print(\"major\")\nelif found_minor:\n    print(\"minor\")\nelse:\n    print(\"strange\")\n```\n\n### Explanation\n- **Mapping Notes**: The `note_order` list defines the sequence of musical notes, and `note_to_index` maps each note to its respective index for quick lookup.\n- **Distance Calculation**: Using modular arithmetic, the distance between any two notes is computed to ensure it wraps around the cyclic sequence correctly.\n- **Permutations Check**: By generating all permutations of the three notes, we check each possible ordering to see if it meets the criteria for a major or minor chord.\n- **Result Determination**: If any permutation meets the criteria for a major chord, we print \"major\". Similarly, if any permutation meets the minor criteria, we print \"minor\". If neither is found, we print \"strange\".\n\nThis approach ensures that all possible configurations of the given notes are checked efficiently, leveraging permutations and modular arithmetic to handle the cyclic nature of musical notes.",
    "ground_truth": "N/A",
    "extracted_answer": "import itertools\n\nnote_order = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B', 'H']\nnote_to_index = {note: idx for idx, note in enumerate(note_order)}\n\nnotes = input().split()\n\nfound_major = False\nfound_minor = False\n\nfor perm in itertools.permutations(notes):\n    x, y, z = perm\n    idx_x = note_to_index[x]\n    idx_y = note_to_index[y]\n    idx_z = note_to_index[z]\n    d1 = (idx_y - idx_x) % 12\n    d2 = (idx_z - idx_y) % 12\n    if d1 == 4 and d2 == 3:\n        found_major = True\n    if d1 == 3 and d2 == 4:\n        found_minor = True\n\nif found_major:\n    print(\"major\")\nelif found_minor:\n    print(\"minor\")\nelse:\n    print(\"strange\")",
    "score": 1,
    "metadata": {
        "prompt_token_count": 684,
        "completion_token_count": 626,
        "thoughts_token_count": 5784
    }
}