{
    "start": 1758309414.1312191,
    "end": 1758309646.0674357,
    "start-formatted": "2025-09-20 04:16 KST",
    "end-formatted": "2025-09-20 04:20 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\nOkay, let's tackle this problem. Hmm, the problem is about restoring the number of mushrooms on each lawn based on the GCD and LCM values provided for each edge. The input gives us a graph where each edge has a GCD and LCM of the two nodes it connects. We need to assign numbers to each node such that all edges satisfy their respective GCD and LCM constraints. If it's not possible, we output NO.\n\nFirst, I need to think about the constraints. For any two nodes u and v connected by an edge with GCD g and LCM l, the numbers on u and v must satisfy:\n\n- gcd(a_u, a_v) = g\n- lcm(a_u, a_v) = l\n\nBut there's a relationship between GCD and LCM. Remember that for two numbers a and b, gcd(a, b) * lcm(a, b) = a * b. So, given that, if we have a GCD and LCM, then the product of the two numbers must be equal to GCD * LCM. However, there's another condition here: the LCM must be a multiple of the GCD. Because LCM(a, b) is the smallest number divisible by both a and b, so it must be a multiple of their GCD. Wait, but the problem says that the input's GCD and LCM are valid. So maybe the input ensures that for each edge, the given GCD divides the LCM? But perhaps not. Wait, the problem statement says that the original map had numbers that were no less than 1 and no more than 1e6. So maybe in the input, for each edge, the given GCD and LCM must satisfy that GCD divides LCM. Otherwise, the answer would be impossible. So during processing, we need to check that for each edge, the given GCD divides the LCM. Otherwise, it's impossible.\n\nWait, but the problem says that the input is such that the original numbers were valid. However, when Pasha tore the map, he has some roads left. So the input may have invalid edges? Or is it guaranteed that the input edges are valid? Wait, the problem says that \"it is guaranteed that the numbers on the roads on the initial map were no less than 1 and did not exceed 1e6.\" But the current input (the m roads that Pasha has) could have edges where the GCD and LCM don't satisfy that GCD divides LCM. So in that case, the answer is impossible. For example, if an edge has GCD=2 and LCM=3, then since 2 doesn't divide 3, there's no pair of numbers that can satisfy that. So in this case, the answer is NO.\n\nSo first step: for each edge, check that GCD divides LCM. If not, immediately return NO.\n\nBut how do I proceed from there?\n\nNext, considering that for each edge (u, v) with GCD g and LCM l, the numbers a_u and a_v must be multiples of g. Also, since their LCM is l, which is the least common multiple. Let me think. Let me denote a_u = g * x, a_v = g * y. Then, since the GCD of a_u and a_v is g, the GCD of x and y must be 1. Also, the LCM of a_u and a_v is g * x * y (since LCM(a_u, a_v) = (a_u * a_v)/GCD(a_u, a_v) = (g x * g y)/g = g x y). Therefore, the LCM is g x y. According to the problem, this must equal l. So:\n\ng * x * y = l → x * y = l / g.\n\nBut since l must be divisible by g, otherwise, this is impossible. Which brings us back to checking that l % g == 0. So for each edge, first check that l is divisible by g. If not, output NO.\n\nOnce that's done, for each edge, x and y are coprime integers, and their product is (l/g). So for each edge, the possible pairs (x, y) are coprime pairs whose product is (l/g). However, since we can choose either (x, y) or (y, x), but the problem allows any valid assignment.\n\nNow, the problem becomes assigning values to each node such that for each edge, the values of the nodes are multiples of g, and their product divided by g is l/g. But how to model this?\n\nThis seems like a graph problem where each node has some constraints based on the edges. So perhaps we can model this as a graph where each edge imposes a relationship between the nodes.\n\nLet me think of this as a graph where each node's value is determined by",
    "response": "To solve this problem, we need to restore the number of mushrooms on each lawn based on the given GCD and LCM values for each edge in a graph. The solution involves checking constraints and using a graph traversal technique to assign values to nodes that satisfy these constraints.\n\n### Approach\n1. **Check Validity of Input**: For each edge, verify if the LCM is divisible by the GCD. If not, the configuration is impossible.\n2. **Graph Representation**: Use an adjacency list to represent the graph where each node points to its connected nodes along with the GCD and LCM values.\n3. **Breadth-First Search (BFS)**: Traverse the graph using BFS starting from an arbitrary node. Assign values to nodes based on the constraints derived from the GCD and LCM values of the edges.\n4. **Consistency Check**: During BFS traversal, ensure that the assigned values are consistent with the constraints imposed by the edges. If any inconsistency is found, output \"NO\".\n\n### Solution Code\n```python\nimport sys\nimport math\nfrom collections import deque, defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n    \n    edges = []\n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        u = int(input[idx]) - 1\n        idx += 1\n        v = int(input[idx]) - 1\n        idx += 1\n        g = int(input[idx])\n        idx += 1\n        l = int(input[idx])\n        idx += 1\n        if l % g != 0:\n            print(\"NO\")\n            return\n        edges.append((u, v, g, l))\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l))\n    \n    value = [-1] * n\n    visited = [False] * n\n    \n    for start in range(n):\n        if visited[start]:\n            continue\n        queue = deque()\n        queue.append(start)\n        visited[start] = True\n        value[start] = 1  # can be any value as long as constraints are met, but we'll adjust later\n        \n        while queue:\n            u = queue.popleft()\n            for (v, g, l) in adj[u]:\n                if value[u] == -1:\n                    continue\n                if value[v] == -1:\n                    # compute x and y such that value[u] = g*x, value[v] = g*y, x*y = l/g\n                    product = l // g\n                    # since value[u] = g * x, so x = value[u]/g\n                    x = value[u] // g\n                    if value[u] % g != 0:\n                        print(\"NO\")\n                        return\n                    y = product // x\n                    if math.gcd(x, y) != 1:\n                        print(\"NO\")\n                        return\n                    value[v] = g * y\n                    visited[v] = True\n                    queue.append(v)\n                else:\n                    # check if current value is consistent\n                    if math.gcd(value[u], value[v]) != g or (value[u] * value[v]) // math.gcd(value[u], value[v]) != l:\n                        print(\"NO\")\n                        return\n    \n    # Now check all edges again to ensure consistency\n    for u, v, g, l in edges:\n        if math.gcd(value[u], value[v]) != g or (value[u] * value[v]) // math.gcd(value[u], value[v]) != l:\n            print(\"NO\")\n            return\n    \n    print(\"YES\")\n    print(' '.join(map(str, value)))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Input Handling**: The input is read and parsed into the number of nodes, edges, and their respective GCD and LCM values.\n2. **Validity Check**: Each edge's LCM is checked for divisibility by the GCD. If any edge fails this check, the answer is immediately \"NO\".\n3. **Graph Traversal**: Using BFS, starting from an arbitrary node, values are assigned to nodes ensuring they meet the constraints derived from the GCD and LCM of the edges.\n4. **Consistency Check**: After assigning values, all edges are rechecked to ensure the GCD and LCM constraints are satisfied. If any inconsistency is found, the answer is \"NO\"; otherwise, it is \"YES\" with the computed values.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\nfrom collections import deque, defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n    \n    edges = []\n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        u = int(input[idx]) - 1\n        idx += 1\n        v = int(input[idx]) - 1\n        idx += 1\n        g = int(input[idx])\n        idx += 1\n        l = int(input[idx])\n        idx += 1\n        if l % g != 0:\n            print(\"NO\")\n            return\n        edges.append((u, v, g, l))\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l))\n    \n    value = [-1] * n\n    visited = [False] * n\n    \n    for start in range(n):\n        if visited[start]:\n            continue\n        queue = deque()\n        queue.append(start)\n        visited[start] = True\n        value[start] = 1  # can be any value as long as constraints are met, but we'll adjust later\n        \n        while queue:\n            u = queue.popleft()\n            for (v, g, l) in adj[u]:\n                if value[u] == -1:\n                    continue\n                if value[v] == -1:\n                    # compute x and y such that value[u] = g*x, value[v] = g*y, x*y = l/g\n                    product = l // g\n                    # since value[u] = g * x, so x = value[u]/g\n                    x = value[u] // g\n                    if value[u] % g != 0:\n                        print(\"NO\")\n                        return\n                    y = product // x\n                    if math.gcd(x, y) != 1:\n                        print(\"NO\")\n                        return\n                    value[v] = g * y\n                    visited[v] = True\n                    queue.append(v)\n                else:\n                    # check if current value is consistent\n                    if math.gcd(value[u], value[v]) != g or (value[u] * value[v]) // math.gcd(value[u], value[v]) != l:\n                        print(\"NO\")\n                        return\n    \n    # Now check all edges again to ensure consistency\n    for u, v, g, l in edges:\n        if math.gcd(value[u], value[v]) != g or (value[u] * value[v]) // math.gcd(value[u], value[v]) != l:\n            print(\"NO\")\n            return\n    \n    print(\"YES\")\n    print(' '.join(map(str, value)))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 558,
        "completion_token_count": 963,
        "thoughts_token_count": 1024
    }
}