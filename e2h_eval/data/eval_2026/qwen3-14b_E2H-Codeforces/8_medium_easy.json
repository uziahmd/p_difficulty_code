{
    "start": 1758019745.3449082,
    "end": 1758022299.8383777,
    "start-formatted": "2025-09-16 19:49 KST",
    "end-formatted": "2025-09-16 20:31 KST",
    "gpu": 2,
    "pid": 8,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\nOkay, let's tackle this problem. So, the task is to assign directions to each edge in an undirected graph such that the resulting flow is a valid maximum flow. The conditions are that for every vertex except the source (1) and sink (n), the incoming flow equals the outgoing flow. Also, the source has no incoming edges, and the directed graph must be acyclic.\n\nHmm. Let me think about how to approach this. Since the flow is already given as the capacities (ci values), we need to direct the edges so that the flow conservation holds and there are no cycles.\n\nWait, the problem says that the given ci values are the flow volumes. So the sum of flows into a vertex (except source and sink) must equal the sum of flows out. And the source's incoming flow is zero. Also, the directed graph must be acyclic.\n\nSo how do I model this? Maybe think of it as building a directed acyclic graph where the flow conservation holds. But how?\n\nLet me think about the structure. Since the graph is connected and we need to have a DAG with no cycles, perhaps we can arrange the vertices in a topological order. Then, all edges go from earlier vertices to later ones in the order. But how to ensure flow conservation?\n\nAlternatively, maybe we can model this as a directed graph where each edge is directed in such a way that the flow conservation holds. But how to compute that?\n\nAnother thought: since the flow is maximum, the residual graph should have no augmenting paths. But I'm not sure how that helps here.\n\nWait, the problem says that the flow is already given. We just need to assign directions. So the flow is fixed. For each edge, the direction is determined such that the flow is properly routed.\n\nBut how to ensure that the flow conservation holds. Let's think about the flow conservation for each vertex v (not source or sink). The sum of flows entering v must equal the sum of flows leaving. Which implies that the net flow at v is zero.\n\nBut how to assign directions to edges to satisfy this?\n\nMaybe we can model this as a directed graph where for each vertex, the total flow going out minus the total flow coming in equals zero (for non-source/sink nodes). The source has all its edges directed away (since no incoming), and the sink has all edges directed towards it.\n\nBut how to assign directions?\n\nLet me think of the problem as a flow network. Suppose that each edge has a flow value ci. We need to assign directions such that for each node except source and sink, the inflow equals outflow. Also, the directed graph must be acyclic.\n\nAn idea: construct a directed graph where the edges are directed in a way that forms a DAG. One way to do this is to arrange the nodes in a topological order and direct edges accordingly. However, how to ensure that the flow conservation holds?\n\nAlternatively, maybe think of the flow as a directed graph where the flow is a valid circulation, except for the source and sink. But the source has all flow going out, and the sink has all flow coming in.\n\nWait, in a standard max-flow problem, the source has outflow equal to the total flow, and the sink has inflow equal to that. All other nodes have inflow equal to outflow.\n\nSo the problem reduces to assigning directions to the edges such that the flow values (ci) form a valid flow in the directed graph. Additionally, the directed graph must be acyclic.\n\nSo the challenge is to find such a direction assignment.\n\nNow, how can we model this? Let's consider the following approach:\n\nFor each edge between u and v, we need to decide whether to direct it as u→v or v→u. Let's think of this as choosing a direction such that when we look at the flow, the flow conservation holds.\n\nBut how to do this efficiently for large n and m?\n\nAnother idea: Since the directed graph must be acyclic, we can assign directions based on a topological order. So if we can find a topological order of the nodes such that all edges are directed from earlier nodes to later ones. Then, the graph is acyclic. Now, how to choose this order such that the flow conservation holds?\n\nWait, but how to ensure that the flow conservation holds for all intermediate nodes?\n\nLet me think about the flow conservation. For a node v (not source or sink), the sum of the flows on edges directed into v must equal the sum of flows on edges directed out of v.\n\nThis can be rewritten as the sum of flows on edges incident to v, where each edge contributes +ci if directed away from v and -ci if directed towards v. The sum must be zero.\n\nBut how to model this? It's similar to finding an orientation of edges such that the net flow at each node (except source and sink) is zero.\n\nWait, this is equivalent to finding an Eulerian orientation for the graph. Because in an Eulerian orientation, the in-degree and out-degree for each node are balanced. But here, it's about the sum of the flows, which is similar to the concept of an Eulerian trail, but with weights.\n\nWait, but for each node, the sum of flows going out minus the sum of flows coming in equals zero. Which is the same as the sum of flows going out equals the sum coming in. Which is exactly the flow conservation condition.\n\nSo, the problem is equivalent to finding an orientation of the edges such that for each node (except source and sink), the sum of flows on edges directed away from the node equals the sum of flows on edges directed towards the node.\n\nBut how to find such an orientation?\n\nThis seems similar to the problem of orienting edges to make the graph have a flow with certain properties.\n\nAnother thought: For each node v (excluding source and sink), the sum of all ci for edges incident to v must be even? No, because the sum of flows going out and in must be equal. So the sum of all flows for edges incident to v is twice the outflow (since each edge contributes once to outflow and once to inflow, but depending on direction). Wait, no. For example, for each edge, if it's directed away from v, then it contributes +ci to the outflow. If it's directed towards v, then it contributes +ci to the inflow. The sum of outflow and inflow is the sum of all ci for edges adjacent to v. But flow conservation requires that outflow equals inflow. Therefore, the sum of all ci for edges adjacent to v must be even? No. Because outflow equals inflow implies that sum of outflow = sum of inflow. Therefore, the total sum of all flows for edges adjacent to v is 2 * outflow (since outflow = inflow). Therefore, the sum must be even. But the problem states that a solution exists, so this must be satisfied for all nodes except the source and sink.\n\nWait, but the source and sink can have any sum. For example, the source has no incoming edges, so all edges adjacent to it are outgoing. Therefore, the sum of flows for edges adjacent to the source is the total outflow, which is the maximum flow value. Similarly for the sink.\n\nBut in the problem statement, the given ci values are the flow volume for each edge. So the sum of all flows on edges adjacent to the source must equal the maximum flow. But since the problem says that the solution exists, we don't have to worry about that.\n\nBut back to the problem of orienting edges. How to find orientations that satisfy flow conservation?\n\nLet me think of this as a system of equations. For each node v (not source or sink), the sum of flows on edges directed away from v minus the sum of flows directed towards v equals zero. Which can be rewritten as the sum over edges adjacent to v of (direction choice) * ci = 0. But how to solve this?\n\nAlternatively, for each node v (not source or sink), the sum of ci for edges adjacent to v must be even. Because the sum of outflow and inflow is twice the outflow. But since the problem says that a solution exists, this must be true. But how to use that?\n\nBut how does this help in assigning directions?\n\nAnother idea: For each node v (excluding source and sink), the sum of flows of edges adjacent to v must be even. So, for each such node, we can split the edges into two parts, such that the sum of flows in one part equals the sum of the other. Then, we can direct edges in such a way that the outflow equals inflow.\n\nBut how to compute this?\n\nThis seems like a problem that can be modeled as a directed graph with certain constraints, but I'm not sure.\n\nWait, perhaps we can model this as a directed graph where we perform a DFS or BFS and assign directions based on the traversal. For example, during a traversal, whenever we visit a node, we direct the edge from the parent to the child. Then, the graph becomes a DAG (as long as we don't have cycles in the traversal tree). However, how to ensure that flow conservation holds?\n\nAlternatively, think of the problem as building a directed graph where the flow conservation holds. Let's imagine that the flow is a valid flow, so for each node except source and sink, the inflow equals outflow. So, the flow can be viewed as a directed graph where the edges are directed in such a way that for each node, the net flow is zero.\n\nBut how to find such a direction?\n\nAnother approach: Let's think of the problem as a directed graph where each edge has a direction, and the flow is determined by the direction. The problem requires that for each node except source and sink, the net flow is zero. So, the sum of flows directed away from the node equals the sum directed towards it.\n\nThis is similar to finding an Eulerian circuit, but for a general graph. However, in an Eulerian circuit, each node has equal in-degree and out-degree. But here, the flows are weighted.\n\nWait, but for each node, the sum of flows on edges directed away from the node must equal the sum of flows directed towards it. So, for each node, the sum of flows on edges directed away from it is equal to half of the total sum of flows on edges adjacent to it. Because total sum is (outflow + inflow) = 2 * outflow.\n\nSo, for each node v (not source or sink), the sum of flows on edges adjacent to v must be even. Which is guaranteed by the problem's existence of a solution.\n\nBut how to find such directions?\n\nLet me think of this as a problem where we need to assign directions to edges such that for each node (except source and sink), the sum of flows on edges directed away from it is exactly half of the total sum of flows on edges adjacent to it.\n\nSo, the question becomes: How can we assign directions to edges to achieve this?\n\nThis seems like a problem that can be solved using a spanning tree approach. For example, we can build a spanning tree and assign directions based on the tree structure, and then handle the remaining edges.\n\nAlternatively, think of the problem as a directed graph where we can perform a DFS traversal, and for each edge, assign the direction based on the traversal order.\n\nBut how to ensure that the flow conservation holds?\n\nLet me think of the following approach. Let's pick a root (maybe the source) and perform a BFS or DFS. For each edge, if it's part of the tree, direct it away from the root. For non-tree edges, direct them in some way. However, this might not ensure flow conservation.\n\nAlternatively, think of the problem as building a directed graph where each node has a certain balance. For example, for each node, the sum of flows on edges directed away from it must be equal to some value. How can we model this?\n\nAnother idea: For each node, compute the required outflow. For the source, the outflow is equal to the total flow. For the sink, the inflow is equal to the total flow. For other nodes, the outflow equals the inflow.\n\nBut how to compute the required outflow for each node?\n\nWait, the outflow from the source is the total flow. Let's denote the total flow as F. Then, for each node v (other than source and sink), the outflow equals inflow. For the sink, the inflow is F.\n\nBut how to find F? Well, the sum of all flows on edges adjacent to the source must be F, since all edges from the source are directed away. But since the problem states that the input is a valid maximum flow, perhaps we can assume that the sum of flows on edges adjacent to the source is F, and similarly for the sink.\n\nBut how to proceed?\n\nAlternatively, think of this as a flow problem where the edges are undirected, but we need to assign directions. Let me think of the following approach:\n\nWe can model this as a directed graph, and for each node, except the source and sink, the net flow must be zero. So, the problem is to find an orientation of edges that satisfies this.\n\nThis seems like a problem that can be modeled as a flow network. Wait, but how?\n\nAnother idea: For each node v, compute the total sum of ci for edges adjacent to it. Let's call this S_v. For the source, S_1 = F (the total flow). For the sink, S_n = F. For other nodes, S_v must be even, as discussed before. Because S_v = 2 * outflow (since outflow = inflow).\n\nBut how to use this?\n\nLet me think of this as a problem of assigning directions so that for each node v (not source or sink), the sum of flows directed away from v is exactly S_v / 2.\n\nSo, for each node, we need to select a subset of edges adjacent to it such that their total flow is exactly S_v / 2. Then, those edges are directed away from the node, and the others are directed towards it.\n\nBut how to find such subsets for all nodes?\n\nThis seems like a problem that could be modeled as a system of equations, but solving it directly would be computationally intensive for large n and m.\n\nBut perhaps there's a way to model this as a directed graph and perform some traversal to assign directions.\n\nLet me think of the following approach. We can model this as a directed graph where each node has a certain \"balance\" that needs to be achieved. For example, for each node v, we need to have a balance of S_v / 2. The balance for the source is S_1, since all edges are directed away. The balance for the sink is zero, since all edges are directed towards it.\n\nBut how to model this?\n\nAlternatively, think of the problem as a directed graph where we can assign directions such that for each node, the sum of flows on outgoing edges equals the required value.\n\nThis seems similar to the problem of finding an Eulerian trail, but again, I'm not sure.\n\nAnother idea: Since the directed graph must be acyclic, we can assign directions based on a topological order. Suppose we arrange the nodes in a topological order, and for each edge, direct it from the node that comes earlier in the order to the one that comes later. Then, the graph is acyclic. Now, the question is: can we find a topological order such that for each node (except source and sink), the sum of flows on edges directed away from it is equal to the sum directed towards it?\n\nBut how to find such an order?\n\nAlternatively, think of the problem as building a DAG where for each node, the sum of flows on edges going out is equal to the sum going in. This seems challenging.\n\nLet me think of the example given. In the first sample input:\n\n3 3\n\nEdges:\n\n3-2 with 10\n\n1-2 with 10\n\n3-1 with 5\n\nThe output is directions 1, 0, 1. Which means:\n\nEdge 3-2 is directed as 2→3 (since di=1, which means original ai=3, bi=2, so direction is bi→ai, which is 2→3).\n\nEdge 1-2 is directed as 1→2 (di=0).\n\nEdge 3-1 is directed as 1→3 (di=1, original ai=3, bi=1, so direction is bi→ai: 1→3).\n\nSo the directed edges are 1→2, 2→3, 1→3. The flow conservation for node 2: incoming is 10 (from 1→2), outgoing is 10 (to 3). So it's balanced.\n\nNow, the topological order here could be 1, 2, 3. All edges go from earlier to later. Which makes the graph acyclic.\n\nSo, in this case, the topological order is such that the source is first, the sink last, and the other nodes are ordered in between.\n\nSo, maybe the approach is to arrange the nodes in a topological order (source first, sink last), and direct all edges from earlier to later. Then, the graph is acyclic, and we need to ensure that flow conservation holds.\n\nBut how to ensure that flow conservation holds?\n\nIn this scenario, for each node v (not source or sink), the sum of flows on edges directed into v (from earlier nodes) must equal the sum of flows on edges directed out of v (to later nodes). Because all edges are directed from earlier to later, the incoming edges are from earlier nodes, and outgoing edges are to later nodes.\n\nSo, for each such node v, the sum of flows on edges going into v (from earlier nodes) must equal the sum of flows on edges going out of v (to later nodes).\n\nBut how to arrange the nodes in such an order?\n\nThis seems like a problem where we can perform a greedy approach. Let's think of the nodes as being processed in a certain order, and for each node, we need to ensure that the sum of flows on edges to nodes that come after it is equal to the sum of flows on edges from nodes that come before it.\n\nBut how?\n\nAlternatively, think of the problem as follows: For each node, the total sum of flows on edges adjacent to it is S_v. For the source, S_1 = F (total flow), for the sink S_n = F. For other nodes, S_v must be even, and for each such node, the sum of flows on edges directed out of it is S_v / 2.\n\nIf we can arrange the nodes in a topological order such that for each node v (not source or sink), the sum of flows on edges directed out of v (i.e., to nodes that come after it in the order) is exactly S_v / 2, then we have our solution.\n\nHow to find such an order?\n\nThis sounds like a problem that can be solved with a modified BFS or DFS approach. For example, we can start with the source, and then process nodes in an order where we ensure that for each node, the sum of flows on edges to unprocessed nodes is exactly S_v / 2.\n\nLet me think of this step by step. Let's say we have a node v that has been processed. For all edges from v to unprocessed nodes, we can direct them from v to the unprocessed node. The sum of these flows must be exactly S_v / 2 minus the sum of flows directed into v from previously processed nodes.\n\nWait, this seems complex. Let me think of a possible algorithm:\n\n1. Compute S_v for each node (sum of flows on edges adjacent to v).\n\n2. For the source (node 1), S_1 is the total flow. Since all edges from the source must be directed away, we need to direct all edges from source to other nodes. The sum of these flows is S_1.\n\n3. For the sink (node n), all edges must be directed towards it. So, any edge connected to the sink must be directed towards it.\n\n4. For other nodes, we need to arrange them in an order such that when they are processed, the sum of flows on edges directed out (to nodes processed after) is S_v / 2.\n\nBut how to find this order?\n\nLet me think recursively. Suppose we start with the source. Then, for each node connected to the source, we can process them next. But how to determine which nodes to process next?\n\nAlternatively, think of the nodes as being arranged in a DAG, and for each node, the sum of flows on edges directed out is S_v / 2. This implies that the sum of flows on edges directed into the node (from previously processed nodes) plus the sum of flows on edges directed out (to unprocessed nodes) equals S_v. So, the sum of flows directed into the node is S_v - sum_out, which must equal the sum_out (since sum_out = S_v / 2). Therefore, sum_in = S_v / 2. Which implies that sum_in = sum_out. Hence, the flow conservation holds.\n\nBut how to compute this?\n\nMaybe we can model this as a graph where we greedily select nodes that have their required outflow satisfied by the edges that are directed to unprocessed nodes.\n\nLet me think of the following steps:\n\n- Start with the source. All edges from the source are directed away. The sum of these flows is S_1, which is the total flow.\n\n- For each other node, we need to process them in an order such that when processed, the sum of flows on edges directed to unprocessed nodes is exactly S_v / 2 minus the sum of flows directed into the node from already processed nodes.\n\nBut how?\n\nAlternatively, think of the problem as building a directed tree where each node is processed once, and during processing, we direct edges from the current node to unprocessed nodes. The key is to choose the order of processing such that for each node, the sum of flows on edges to unprocessed nodes is exactly S_v / 2 minus the sum of flows from processed nodes to this node.\n\nThis seems complicated, but perhaps we can model it as follows:\n\nFor each node v (not source or sink), we can calculate the required outflow as (S_v - inflow) / 2, where inflow is the sum of flows from already processed nodes. Wait, but how to track that?\n\nAlternatively, during processing, for each node v, we can keep track of how much outflow we need to assign. Initially, the required outflow is S_v / 2. As we process the node, we direct edges to unprocessed nodes, and subtract their flows from the required outflow.\n\nSo, the algorithm would be:\n\nInitialize a queue with the source.\n\nWhile the queue is not empty:\n\n    Take a node u from the queue.\n\n    For each neighbor v of u:\n\n        If v is not processed yet:\n\n            Direct the edge from u to v.\n\n            Subtract the flow of this edge from the required outflow of u.\n\n            Add the flow of this edge to the inflow of v.\n\n    Once u is processed, add it to the processed set.\n\nBut how to choose which nodes to process next?\n\nWait, this seems like a BFS approach. But how to ensure that when processing a node, the required outflow is satisfied.\n\nWait, but what if the required outflow for a node is not yet met by directing edges to unprocessed nodes?\n\nThis suggests that we need to process nodes only when their required outflow can be satisfied by directing edges to unprocessed nodes.\n\nBut how to manage this?\n\nLet me think of the required outflow for a node v as the amount of flow that needs to be directed out of v. Initially, this is S_v / 2 for nodes that are not source or sink. For the source, it is S_1. For the sink, it is zero (since all edges must be directed into it).\n\nBut how to compute this?\n\nLet me think of the following:\n\nFor each node v, we maintain a variable called 'required_out', which is the amount of flow that must be directed out of v through edges to unprocessed nodes.\n\nInitially:\n\n- For the source, required_out is S_1.\n\n- For the sink, required_out is zero.\n\n- For other nodes, required_out is S_v / 2.\n\nWhen processing a node u, we look at its adjacent edges. For each such edge, if the other end v is not processed yet, we can direct the edge from u to v. This contributes ci to u's outflow, and thus reduces u's required_out by ci. At the same time, this adds ci to v's inflow (which will be used to determine when v can be processed).\n\nOnce u's required_out reaches zero, we can add it to the queue (or process it further).\n\nWait, but how to handle the inflow for v. For example, when we direct an edge from u to v, this contributes ci to v's inflow. But v's required_out is S_v / 2. So, the inflow to v from processed nodes is the sum of flows directed into v from processed nodes. The required_out for v is S_v / 2. However, once the inflow to v from processed nodes equals S_v / 2, then the required_out for v is zero, and we can process v.\n\nWait, no. Because the required_out for v is S_v / 2, which is the amount of flow that must be directed out of v. However, the inflow into v from processed nodes is the sum of flows directed into v. The outflow from v is the sum of flows directed out of v. For flow conservation, inflow into v must equal outflow from v. Therefore, the sum of flows directed into v (from processed nodes) plus the sum of flows directed into v (from unprocessed nodes) must equal the sum of flows directed out of v (to unprocessed nodes) plus the sum of flows directed out of v (to processed nodes). But since the graph is processed in a way that edges are directed from processed to unprocessed, the only inflow to v is from processed nodes, and the outflow from v is to unprocessed nodes. Therefore, for flow conservation, the inflow (from processed) must equal the outflow (to unprocessed). Thus, the required_out for v is the sum of flows directed out of v to unprocessed nodes, which must equal the inflow from processed nodes.\n\nTherefore, when the inflow to v from processed nodes equals the required_out for v, then we can process v.\n\nSo, the algorithm could be:\n\n- Initialize a priority queue (or a queue) with the source node.\n\n- For each node, maintain:\n\n   - required_out: the amount of outflow needed.\n\n   - inflow: the sum of flows directed into the node from processed nodes.\n\n- Initially, the source's required_out is S_1. For other nodes, required_out is S_v / 2. The inflow for all nodes starts at zero.\n\n- When a node is processed, we look at all its edges. For each edge to an unprocessed node, we can direct it from the current node to the unprocessed node. This adds ci to the inflow of the unprocessed node, and subtracts ci from the current node's required_out.\n\n- Once the current node's required_out becomes zero, it can be added to the queue (but only once?), and then processed.\n\nWait, but how to manage this. For example, the source node's required_out is S_1. For each edge from the source to an unprocessed node, we direct it from source to that node. This reduces the source's required_out by the ci of that edge. Once the source's required_out is zero, it's done. Then, the nodes that received inflow from the source may now have their inflow increased. For example, suppose a node v has inflow of x, and required_out of y. When the inflow increases by ci, if this new inflow equals y, then we can process this node.\n\nSo, the algorithm could be:\n\n- For each node, keep track of the inflow and required_out.\n\n- Use a queue (like BFS) to process nodes. Initially, the source is in the queue.\n\n- While the queue is not empty:\n\n   - Dequeue a node u.\n\n   - For each neighbor v of u:\n\n      - If v is not processed:\n\n         - Direct the edge from u to v (so di is 0 if the original edge is u-v, or 1 if the original is v-u).\n\n         - Add ci to v's inflow.\n\n         - Subtract ci from u's required_out.\n\n         - If v's inflow == required_out of v, then enqueue v.\n\n   - Mark u as processed.\n\nBut wait, what about nodes that are not processed yet but have their inflow equal to their required_out? For example, suppose a node v has inflow from multiple sources. Once the inflow reaches the required_out, it can be enqueued.\n\nThis seems promising. Let's test this idea on the first example.\n\nFirst example:\n\nNodes: 1, 2, 3.\n\nEdges:\n\n3-2 (ci=10)\n\n1-2 (ci=10)\n\n3-1 (ci=5)\n\nCompute S_v:\n\nS_1 = 10 (edge 1-2) + 5 (edge 3-1) = 15.\n\nS_2 = 10 (edge 1-2) + 10 (edge 3-2) = 20.\n\nS_3 = 10 (edge 3-2) + 5 (edge 3-1) = 15.\n\nFor the source (node 1), required_out is S_1 = 15.\n\nFor node 2, required_out is 20/2 = 10.\n\nFor node 3, required_out is 15/2 = 7.5? Wait, but that's not possible. Wait, but according to the problem statement, a solution exists, so S_v must be even for all nodes except source and sink.\n\nWait in this example, node 3 is the sink (n=3). So for the sink, required_out is zero, since all edges must be directed into it. So S_3 is 15, but since it's the sink, required_out is zero. So the previous calculation was wrong.\n\nAh! Right, for the sink (node n), all edges must be directed into it. So the required_out for the sink is zero. For other nodes, required_out is S_v / 2.\n\nSo let's re-calculate:\n\nFor node 1 (source), required_out is S_1 = 15.\n\nFor node 2 (non-source/sink), required_out is S_2 / 2 = 20/2 = 10.\n\nFor node 3 (sink), required_out is 0.\n\nInitially, the queue contains node 1.\n\nProcessing node 1:\n\nCheck its neighbors: 2 and 3.\n\nFor neighbor 2 (unprocessed):\n\nDirect edge from 1 to 2. Add 10 to node 2's inflow (now 10). Subtract 10 from node 1's required_out (now 15-10=5).\n\nFor neighbor 3 (unprocessed):\n\nDirect edge from 1 to 3. Add 5 to node 3's inflow (now 5). Subtract 5 from node 1's required_out (now 5-5=0).\n\nNow, node 1's required_out is zero. So it's done.\n\nNow, check if any of the neighbors (2 and 3) have inflow equal to their required_out.\n\nFor node 2: inflow is 10, required_out is 10. So yes. Enqueue node 2.\n\nFor node 3: inflow is 5, required_out is 0. 5 != 0. So not enqueued.\n\nNow, the queue has node 2.\n\nProcess node 2:\n\nCheck its neighbors: 1 (processed), 3 (unprocessed), and possibly others.\n\nFor neighbor 3 (unprocessed):\n\nDirect edge from 2 to 3. Add 10 to node 3's inflow (now 5+10=15). Subtract 10 from node 2's required_out (which was 10, now 0).\n\nNow, node 2's required_out is 0. Enqueue node 2's neighbors if applicable.\n\nCheck for node 3's inflow (15) against required_out (0). 15 != 0, so not enqueued.\n\nNow, the queue is empty. But what about node 3?\n\nThe required_out for node 3 is 0. Its inflow is 15. But since it's the sink, all edges must be directed into it. Let's see the edges connected to node 3:\n\nEdge 3-2 is directed from 2 to 3 (processed). Edge 3-1 is directed from 1 to 3. Are there any other edges? No. So all edges to node 3 are directed into it. Which is correct.\n\nSo the algorithm works here.\n\nAnother example: the second input given in the problem.\n\nSample input 2:\n\n4 5\n\nEdges:\n\n1-2 (10)\n\n1-3 (10)\n\n2-3 (5)\n\n4-2 (15)\n\n3-4 (5)\n\nOutput is 0 0 1 1 0.\n\nLet me compute S_v for each node:\n\nnode 1: edges 1-2 (10) and 1-3 (10) → S_1 = 20.\n\nnode 2: edges 1-2 (10), 2-3 (5), 4-2 (15) → S_2 = 30.\n\nnode 3: edges 1-3 (10), 2-3 (5), 3-4 (5) → S_3 = 20.\n\nnode 4: edges 4-2 (15), 3-4 (5) → S_4 = 20. Since node 4 is the sink (n=4), required_out is zero.\n\nSo:\n\nrequired_out for node 1 (source) is S_1 = 20.\n\nrequired_out for node 2 (non-sink/source): S_2 / 2 = 15.\n\nrequired_out for node 3 (non-sink/source): S_3 / 2 = 10.\n\nrequired_out for node 4 (sink): 0.\n\nInitially, the queue has node 1.\n\nProcessing node 1:\n\nNeighbors are 2 and 3.\n\nFor neighbor 2: direct edge 1→2. Add 10 to node 2's inflow (now 10). Subtract 10 from node 1's required_out (20-10=10).\n\nFor neighbor 3: direct edge 1→3. Add 10 to node 3's inflow (now 10). Subtract 10 from node 1's required_out (now 10-10=0).\n\nNow, node 1's required_out is zero. Check node 2 and 3:\n\nnode 2's inflow is 10, required_out is 15. Not enough.\n\nnode 3's inflow is 10, required_out is 10. So enqueue node 3.\n\nQueue now has node 3.\n\nProcess node 3:\n\nNeighbors are 1 (processed), 2 (unprocessed), and 4 (unprocessed).\n\nFor neighbor 2: direct edge from 3 to 2. Add 5 to node 2's inflow (now 10+5=15). Subtract 5 from node 3's required_out (10-5=5).\n\nFor neighbor 4: direct edge from 3 to 4. Add 5 to node 4's inflow (now 5). Subtract 5 from node 3's required_out (5-5=0).\n\nNow, node 3's required_out is 0. Check node 2 and 4.\n\nnode 2's inflow is 15, required_out is 15. So enqueue node 2.\n\nnode 4's inflow is 5, required_out is 0. Not equal.\n\nNow, queue has node 2.\n\nProcess node 2:\n\nNeighbors are 1 (processed), 3 (processed), 4 (unprocessed).\n\nFor neighbor 4: direct edge from 2 to 4. Add 15 to node 4's inflow (5+15=20). Subtract 15 from node 2's required_out (15-15=0).\n\nNow, node 2's required_out is 0. Check node 4's inflow (20) vs required_out (0). 20 != 0, so not enqueued.\n\nNow, queue is empty. But node 4 is the sink, and all edges connected to it are directed into it. Let's check:\n\nEdges connected to node 4:\n\nEdge 3-4 is directed from 3→4 (processed).\n\nEdge 4-2 is directed from 2→4 (processed).\n\nYes. All edges to node 4 are directed into it. So the algorithm works.\n\nThis seems promising. So the algorithm is:\n\n- For each node, compute S_v = sum of ci of edges adjacent to it.\n\n- For the source (node 1), required_out is S_1.\n\n- For the sink (node n), required_out is 0.\n\n- For other nodes, required_out is S_v / 2.\n\n- For all nodes, inflow starts at 0.\n\n- Use a queue to process nodes. Initially, the source is in the queue.\n\n- For each node u dequeued, iterate over all its edges. For each edge to a node v that hasn't been processed yet:\n\n   - Direct the edge from u to v.\n\n   - Add ci to v's inflow.\n\n   - Subtract ci from u's required_out.\n\n   - If v's inflow equals its required_out, enqueue v.\n\n- Once all nodes are processed, the directions are assigned.\n\nNow, how to implement this?\n\nWe need to track:\n\n- For each node, whether it's processed.\n\n- For each node, the required_out.\n\n- For each node, the inflow.\n\nAlso, for each edge, we need to determine the direction (ai→bi or bi→ai). So during the processing of edges, when we decide to direct from u to v, we need to check if the original edge is (u, v) or (v, u), and assign di accordingly.\n\nBut how to track this? For",
    "response": "\n\nTo solve this problem, we need to determine the direction of each edge in an undirected graph such that the resulting directed graph forms a valid maximum flow from the source (vertex 1) to the sink (vertex n). The solution must ensure that the flow conservation holds for all intermediate vertices and that the directed graph is acyclic.\n\n### Approach\n1. **Graph Representation**: Use adjacency lists to represent the graph and store the edges along with their capacities.\n2. **Flow Calculation**: For each vertex, compute the total flow (sum of capacities of incident edges).\n3. **Required Outflow Calculation**: For the source vertex, the required outflow is the sum of its incident edges. For the sink vertex, the required outflow is zero. For intermediate vertices, the required outflow is half of the total flow of incident edges.\n4. **BFS Traversal**: Use a BFS-like approach to traverse the graph starting from the source. During traversal, direct edges from processed nodes to unprocessed nodes, adjusting the required outflow and inflow values accordingly.\n5. **Direction Assignment**: Track the direction of each edge based on the traversal order, ensuring that the flow conservation and acyclic properties are maintained.\n\n### Solution Code\n```python\nimport sys\nimport threading\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n\n    edges = []\n    adj = [[] for _ in range(n + 1)]\n    for i in range(m):\n        a = int(input[idx])\n        idx += 1\n        b = int(input[idx])\n        idx += 1\n        c = int(input[idx])\n        idx += 1\n        edges.append((a, b, c))\n        adj[a].append((b, i))\n        adj[b].append((a, i))\n\n    # Compute S_v for each node\n    S = [0] * (n + 1)\n    for a, b, c in edges:\n        S[a] += c\n        S[b] += c\n\n    required_out = [0] * (n + 1)\n    required_out[1] = S[1]\n    required_out[n] = 0\n    for v in range(2, n):\n        required_out[v] = S[v] // 2\n\n    inflow = [0] * (n + 1)\n    processed = [False] * (n + 1)\n    q = deque()\n    q.append(1)\n    processed[1] = True\n\n    # To store the direction of each edge\n    direction = [0] * m\n\n    while q:\n        u = q.popleft()\n        for (v, edge_idx) in adj[u]:\n            if not processed[v]:\n                # Determine the original edge\n                a, b, c = edges[edge_idx]\n                if a == u and b == v:\n                    direction[edge_idx] = 0\n                else:\n                    direction[edge_idx] = 1\n                # Update inflow of v\n                inflow[v] += c\n                # Subtract from required_out of u\n                required_out[u] -= c\n                # Check if v's inflow meets required_out\n                if inflow[v] == required_out[v]:\n                    q.append(v)\n                    processed[v] = True\n\n    for d in direction:\n        print(d)\n\nthreading.Thread(target=main).start()\n```\n\n### Explanation\n- **Graph Representation**: The graph is represented using adjacency lists where each entry stores the connected vertex and the index of the edge in the input list.\n- **Flow Calculation**: For each vertex, the total flow (sum of capacities of incident edges) is computed to determine the required outflow for each vertex.\n- **BFS Traversal**: Starting from the source, we use a BFS approach to process each node. As we traverse, edges are directed from the current node to unprocessed nodes, updating the required outflow and inflow values.\n- **Direction Assignment**: The direction of each edge is determined based on the traversal order, ensuring that the flow conservation and acyclic properties are maintained.\n\nThis approach efficiently ensures that the resulting directed graph meets all the specified conditions for a valid maximum flow.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport threading\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n\n    edges = []\n    adj = [[] for _ in range(n + 1)]\n    for i in range(m):\n        a = int(input[idx])\n        idx += 1\n        b = int(input[idx])\n        idx += 1\n        c = int(input[idx])\n        idx += 1\n        edges.append((a, b, c))\n        adj[a].append((b, i))\n        adj[b].append((a, i))\n\n    # Compute S_v for each node\n    S = [0] * (n + 1)\n    for a, b, c in edges:\n        S[a] += c\n        S[b] += c\n\n    required_out = [0] * (n + 1)\n    required_out[1] = S[1]\n    required_out[n] = 0\n    for v in range(2, n):\n        required_out[v] = S[v] // 2\n\n    inflow = [0] * (n + 1)\n    processed = [False] * (n + 1)\n    q = deque()\n    q.append(1)\n    processed[1] = True\n\n    # To store the direction of each edge\n    direction = [0] * m\n\n    while q:\n        u = q.popleft()\n        for (v, edge_idx) in adj[u]:\n            if not processed[v]:\n                # Determine the original edge\n                a, b, c = edges[edge_idx]\n                if a == u and b == v:\n                    direction[edge_idx] = 0\n                else:\n                    direction[edge_idx] = 1\n                # Update inflow of v\n                inflow[v] += c\n                # Subtract from required_out of u\n                required_out[u] -= c\n                # Check if v's inflow meets required_out\n                if inflow[v] == required_out[v]:\n                    q.append(v)\n                    processed[v] = True\n\n    for d in direction:\n        print(d)\n\nthreading.Thread(target=main).start()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 700,
        "completion_token_count": 901,
        "thoughts_token_count": 8191
    }
}