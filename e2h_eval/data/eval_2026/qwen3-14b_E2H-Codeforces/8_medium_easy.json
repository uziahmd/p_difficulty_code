{
    "start": 1758352916.8208416,
    "end": 1758353094.6128066,
    "start-formatted": "2025-09-20 16:21 KST",
    "end-formatted": "2025-09-20 16:24 KST",
    "gpu": 2,
    "pid": 8,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\nOkay, let's see. I need to solve this problem where I have to assign directions to the edges of an undirected graph such that the flow conditions are satisfied. The main points are that the flow must be a maximum flow, and the directed graph must not have cycles. Also, the source (vertex 1) has no incoming edges, and all other vertices except the sink (vertex n) have equal incoming and outgoing flow sums.\n\nHmm. So the problem is about directing edges in a way that satisfies flow conservation for all intermediate nodes, and also ensuring the directed graph is acyclic. Oh right, and the flow values are already given for each edge. So the direction is what we need to determine.\n\nLet me think. How can I model this? Well, the flow conservation condition for each node except source and sink requires that the sum of flows entering equals the sum leaving. Which implies that for each such node, the total flow through its edges must be even? No, wait. Because for each edge connected to the node, the flow is either going into or out of the node. So for each node v (not source or sink), the sum of flows on edges directed towards it must equal the sum of flows on edges directed away from it. Which means that the sum of all flows on edges connected to v must be even? Because if you take the total sum of flows on edges connected to v, then when you split them into incoming and outgoing, the sum of incoming equals sum of outgoing, so total sum is twice the sum of incoming (or outgoing). So the total sum of flows on edges connected to v must be even. Wait, but the problem says that the input is such that a solution exists, so maybe that's already taken care of.\n\nBut how do I assign the directions?\n\nAnother thought: since the directed graph must be acyclic, perhaps we can arrange the directions in a way that forms a DAG with a topological order. For example, if we can find a topological order where the source is first and the sink is last, then all edges go from earlier nodes to later ones. But how does that help with the flow conservation?\n\nWait, the problem says that the flow is a maximum flow. But perhaps the actual maximum flow isn't needed here. The given ci values are the flow values, and we just need to direct them properly. So the key is to find a direction for each edge such that the flow conservation holds and the graph is acyclic.\n\nSo maybe the approach is to construct a directed acyclic graph (DAG) where the flow conservation holds. How can we do that?\n\nLet me think about the flow conservation. For each node v (not source or sink), the sum of flows on edges directed into v must equal the sum of flows on edges directed out of v. Let me denote for each edge, the direction as either from u to v or v to u. For each node v, the net flow (sum of flows on edges directed out minus sum of flows directed in) must be zero. Except for source and sink.\n\nBut the source has no incoming edges. So all edges connected to the source must be directed away from it. Similarly, the sink has no outgoing edges. So all edges connected to the sink must be directed towards it.\n\nBut how to model this for all nodes?\n\nAn alternative approach: think of the problem as building a directed graph where the flow conservation holds, and the graph is acyclic. Since the graph is acyclic, there's a topological order. Let's imagine that we have a topological order where the source is first, the sink is last, and all edges go from earlier nodes to later nodes. Then, for each node v (except source and sink), the sum of flows on edges coming into v (from earlier nodes) must equal the sum of flows on edges going out of v (to later nodes). How can we ensure that?\n\nBut how to compute this? Maybe we can model this as a directed graph where each node's outflow is determined based on the inflow.\n\nWait, but how do we find such a direction? Let's think of the problem as a directed graph where the edges are directed in such a way that for each node (except source and sink), the sum of flows on incoming edges equals the sum on outgoing edges.\n\nAnother idea: The problem is similar to finding an Euler tour, but not exactly. Or maybe it's similar to building a flow network where each node has zero excess except the source and sink. But since the flow is already given, perhaps we need to assign directions such that the flow conservation is met.\n\nLet me think of the problem as follows: For each node v (not source or sink), the total flow on edges connected to it must be even. Because the sum of incoming and outgoing flows is equal. Wait, no. For example, if the total flow is S, then the incoming is S/2 and outgoing is S/2. So S must be even. But the problem says that a solution exists, so perhaps that's guaranteed.\n\nBut how to assign directions?\n\nMaybe we can model this as a directed graph where each node's in-degree (in terms of flow) balances out. But how?\n\nAlternative approach: Since the graph must be acyclic, perhaps we can perform a topological sort. Let's imagine that we arrange the nodes in a certain order. For each edge between two nodes, we direct it from the earlier node in the order to the later one. Then, the graph is acyclic. However, this may not satisfy the flow conservation. So how can we choose the order such that the flow conservation is satisfied?\n\nAlternatively, perhaps the direction of the edges can be determined by considering the flow as a directed graph, and building a DAG that respects the flow conservation.\n\nWait, here's another thought: The flow conservation for each node v (not source or sink) implies that the sum of flows on edges connected to v is even. But that's not necessarily true. Wait, suppose for a node v, the sum of flows on edges connected to it is S. Then, the sum of incoming flows is x, and outgoing is x (since they are equal). Then S = x + x = 2x. So S must be even. Therefore, for each node v (other than source and sink), the sum of flows on edges connected to it must be even. But the problem says that a solution exists, so this must be the case. So that's something that's guaranteed.\n\nBut how to proceed?\n\nAnother idea: Let's model this as a directed graph where the flow conservation is satisfied. For that, we can model the problem as a directed graph where the flow is a valid flow. Then, the problem reduces to assigning directions to edges such that the flow is valid and the graph is acyclic.\n\nBut how to do that?\n\nLet me think of the problem as a directed graph where each edge's direction is chosen such that the flow is valid. Since the graph must be acyclic, perhaps we can construct a directed tree structure or something similar.\n\nWait, but the graph can have cycles as long as the directions are assigned in a way that makes it acyclic. So perhaps the way to proceed is to build a DAG that satisfies the flow conservation constraints.\n\nAn alternative approach is to model this as a directed graph where the edges are directed in a way that forms a DAG and satisfies flow conservation. Let's consider that the DAG must have a topological order. Let's say the topological order is from the source to the sink. Then, for each node in the order (excluding the source and sink), the sum of flows from previous nodes (incoming) must equal the sum of flows to next nodes (outgoing). How can we ensure this?\n\nPerhaps we can process the nodes in a topological order. For each node, we can decide the direction of edges connected to it. But how?\n\nAlternatively, think of the problem as building a directed graph where for each node, except the source and sink, the net outflow is zero. The source has net outflow equal to the total flow (since it's the source), and the sink has net inflow equal to the total flow.\n\nBut how to assign the directions of the edges to meet this?\n\nLet me think of the following approach:\n\n- First, compute for each node the total flow that must pass through it. Wait, but the flow is already given. For example, for the source, all edges connected to it must be directed away from it. Because the source cannot have incoming edges. Similarly, for the sink, all edges connected to it must be directed towards it.\n\nSo, for example, if there is an edge between the source and some other node, that edge must be directed from the source to that node. Similarly for edges connected to the sink.\n\nBut what about edges between other nodes?\n\nLet me consider the example given in the problem. For instance, the first sample input:\n\n3 3\n\nEdges:\n\n3-2 with 10\n\n1-2 with 10\n\n3-1 with 5.\n\nThe output directions are 1,0,1. Which means:\n\nEdge 1 (3-2) is directed as 2→3 (since output is 1?), wait the output says for each edge, 0 means ai → bi, 1 means bi → ai. So for the first edge, which is between 3 and 2, the output is 1, meaning direction is bi → ai. So 2 → 3. The second edge is between 1 and 2, output is 0, so 1 → 2. Third edge is between 3 and 1, output is 1, meaning direction is 1 → 3. Wait no, original edge is ai=3, bi=1, so output 1 would mean direction is bi → ai, which is 1 → 3. So the edges are directed as 2→3, 1→2, 1→3. Then the flow conservation for node 2: incoming is 10 (from 1→2) and outgoing is 10 (to 3). So balanced. For node 1: no incoming edges, and outgoing 10+5=15. For node 3: incoming is 10+5=15, no outgoing. So it's the sink.\n\nBut the graph is directed as 1→2, 2→3, 1→3. Which is a DAG with topological order 1, 2, 3. So this seems to work.\n\nSo the approach here was to arrange the nodes in a topological order, and direct edges accordingly. But how to find such an order?\n\nAnother idea: We can model this as a directed graph where each node has a certain \"potential\" and the direction of the edge depends on the potentials. For example, if the potential of u is higher than that of v, then the edge is directed from u to v. This would ensure that the graph is acyclic if the potentials are assigned in a way that forms a DAG.\n\nBut how to assign these potentials so that the flow conservation is satisfied?\n\nAlternatively, think of the problem as building a directed graph where for each node (except source and sink), the sum of flows on edges directed into the node equals the sum of flows directed out. Let me consider that for each node, the net flow (outflow - inflow) is zero. Except for the source (net outflow is the total flow) and the sink (net inflow is the total flow).\n\nBut how to model this?\n\nWait, the net outflow for the source is the total flow value. Because all edges from the source contribute to the outflow. Similarly, for the sink, the net inflow is the same as the total flow.\n\nBut for all other nodes, net outflow is zero.\n\nSo, the problem is equivalent to finding a directed graph where the net outflow for each node is as described, and the graph is acyclic.\n\nBut how to find such a directed graph?\n\nThis seems like a problem that can be modeled using a directed graph where each node's net outflow is fixed, and the edges are directed in a way that satisfies this. However, I'm not sure how to proceed with that.\n\nAnother idea: Since the graph must be acyclic, we can arrange the nodes in a topological order. Let's imagine that we have such an order, say, v_1, v_2, ..., v_n, where v_1 is the source and v_n is the sink. Then, for each node v_i (i not 1 or n), the sum of flows on edges directed into it (from earlier nodes) must equal the sum of flows directed out of it (to later nodes). How can we ensure this?\n\nLet me think of it as follows: For each node v_i (except source and sink), the sum of flows on edges that are directed into it (from earlier nodes) plus the sum of flows on edges directed out of it (to later nodes) must be equal. Wait, no. Because the sum of flows directed into it equals the sum directed out of it. So, the sum of flows directed into it is equal to the sum directed out. But the sum of flows directed into it is the sum of flows on edges from earlier nodes to it. The sum directed out is the sum of flows on edges from it to later nodes. So for each node v_i, the sum of flows on edges from earlier nodes to it (incoming) must equal the sum of flows on edges from it to later nodes (outgoing). \n\nBut how can we calculate that? For example, suppose we have a node v_i. Let's say that all edges connected to v_i are either from earlier nodes or to later nodes. Then, the sum of flows on edges from earlier nodes to v_i (incoming) must equal the sum of flows on edges from v_i to later nodes (outgoing). \n\nBut how to choose which edges are directed into or out of v_i?\n\nThis seems like a problem that could be solved with some kind of greedy approach. Let's think about the following steps:\n\n1. Choose a topological order of the nodes. The first node is the source, the last is the sink.\n\n2. For each node in the topological order (after the source and before the sink), we need to ensure that the sum of flows on edges directed into it equals the sum of flows directed out of it.\n\nBut how?\n\nLet me think about the following: For each node v in the topological order (after the source and before the sink), the sum of flows on edges from earlier nodes to v (which are directed into v) is some value, and the sum of flows on edges from v to later nodes (directed out of v) is another value. These two must be equal.\n\nSo, the difference between the sum of flows on edges connected to v (from earlier nodes and later nodes) must be such that the sum of flows from earlier nodes to v plus the sum of flows from v to later nodes equals the total flow connected to v. Wait, no. For example, the total flow connected to v is the sum of all flows on edges connected to v. Let me denote this as T_v.\n\nThen, the sum of flows directed into v is X, and the sum directed out of v is Y. Since X = Y, then T_v = X + Y = 2X. So T_v must be even, which is guaranteed by the problem.\n\nBut how to find X and Y?\n\nIf we can find for each node v (not source or sink) the value X, then we can direct the edges accordingly.\n\nBut how to compute X?\n\nLet me think recursively. Suppose we have processed all nodes before v in the topological order. Then, for the current node v, the sum of flows on edges from earlier nodes to v is fixed (since those edges have already been directed). The sum of flows on edges from v to later nodes can be adjusted by directing the edges between v and the later nodes.\n\nWait, but the edges between v and later nodes are not yet processed. So, for each such edge, we can decide the direction. For example, if we have an edge between v and u (where u comes after v in the topological order), then we can choose to direct it from v to u (so contributing to Y) or from u to v (but that would be impossible because u comes after v, so in the topological order, edges can only go from earlier to later, so that direction would be invalid. Wait, no. If we have a topological order, then edges can only go from earlier to later. Because otherwise, there would be a cycle. So in this approach, all edges are directed from earlier nodes to later nodes in the topological order. So, for any edge between v and u, if u is after v in the topological order, the edge is directed from v to u. If u is before v, then the edge is directed from u to v. But in the topological order, u comes before v, so the edge would be directed from u to v.\n\nWait, but in this case, the edges between v and nodes that come after it in the topological order are directed from v to them. Those between v and nodes that come before are directed from those nodes to v.\n\nSo for a given topological order, the direction of each edge is determined by which node comes first in the order.\n\nSo, given that, the sum of flows directed into v is the sum of flows of edges from earlier nodes (processed before v) to v. And the sum of flows directed out of v is the sum of flows of edges from v to later nodes (processed after v).\n\nSo for the node v, we need that sum_in = sum_out. Which implies that sum_in = sum_out = (sum_total)/2.\n\nBut how can we ensure that?\n\nLet me think of the following approach. We can choose the topological order in such a way that for each node v (except source and sink), the sum of flows on edges from earlier nodes to v is equal to (sum_total_v)/2. Then, the sum_out will automatically be equal to sum_in.\n\nBut how to find such a topological order?\n\nAlternatively, perhaps we can process the nodes in a certain order and adjust the directions of edges between them. For example, we can build the topological order incrementally, ensuring that for each node added to the order, the sum of flows directed into it equals the sum of flows directed out.\n\nLet me think of this as a dynamic process. Let's start with the source node. Then, for each step, we add a new node to the topological order. When adding a node v, we can look at all edges between v and the already added nodes. Those edges are directed from the already added nodes to v. And edges between v and not-yet-added nodes will be directed from v to those nodes once they are added.\n\nSo, when adding v to the topological order, the sum_in for v is the sum of flows on edges from already added nodes to v. The sum_out is the sum of flows on edges from v to not-yet-added nodes. But since those not-yet-added nodes haven't been processed yet, their edges to v are not yet directed. However, the sum_in must be equal to sum_out. But how?\n\nWait, this seems tricky. Because when adding v to the order, the sum_in is known (sum of edges from already added nodes to v). The sum_out is the sum of edges from v to nodes that are not yet added. But those nodes are not yet in the topological order, so their edges to v are not yet directed. However, once they are added, the edges between v and them will be directed from v to them (since they are added later). So the sum_out for v is the sum of flows of edges between v and nodes not yet added. But when those nodes are added, their edges to v are directed from v to them. Thus, for the current node v, the sum_out is the sum of flows on edges from v to nodes not yet added. However, since those nodes are not yet added, the sum_out is unknown.\n\nBut how can we ensure that sum_in equals sum_out?\n\nLet me think of the following: For the node v being added to the topological order, the sum_in is fixed (sum of flows on edges from already added nodes to v). The sum_out is the sum of flows on edges from v to nodes not yet added. Let me call this S. For the flow conservation, we need sum_in = sum_out. Therefore, sum_in must equal S. But S is the sum of flows on edges between v and nodes not yet added. How can we ensure that?\n\nBut S is equal to the sum of flows on edges between v and nodes not yet added. Let me denote that as T_v - sum_in, where T_v is the total flow on edges connected to v. Because sum_in is the sum of flows from already added nodes to v. The edges between v and nodes not yet added are part of T_v. So S = T_v - sum_in. But according to the flow conservation, sum_in must equal S. Therefore:\n\nsum_in = T_v - sum_in => 2 * sum_in = T_v => sum_in = T_v / 2.\n\nTherefore, when adding a node v to the topological order, the sum of flows on edges from already added nodes to v must be exactly half of T_v. Only then will the flow conservation be satisfied.\n\nSo the problem reduces to choosing a topological order where, for each node v (not source or sink), when it is added to the order, the sum of flows on edges from previously added nodes to v is exactly T_v / 2.\n\nHow can we achieve this?\n\nLet me think of this as a graph traversal where we select nodes to add to the topological order in such a way that this condition holds. For example, we can start with the source node. Then, for each subsequent node, we select a node that has the property that the sum of flows from already added nodes to it is exactly T_v / 2.\n\nBut how can we find such a node? It seems challenging. However, perhaps we can model this as a graph where each node has a certain \"balance\" that needs to be achieved.\n\nLet me think of the following approach:\n\nFor each node v, let's compute T_v, the total flow on edges connected to v. For the source and sink, we don't need to worry about this. For other nodes, T_v must be even.\n\nWe can process nodes in a way that ensures that when a node is added to the topological order, the sum of flows from already added nodes to it is exactly T_v / 2.\n\nLet me think of this as follows: Initially, the source is added to the topological order. Then, for each node adjacent to the source, we can check if the sum of flows from the source to it is equal to T_v / 2. But this seems unlikely unless the node is connected only to the source and has T_v = 2 * c (the flow from the source to it).\n\nAlternatively, perhaps we can model this as a directed graph where for each node, we track the current balance of flows. When adding a node to the topological order, we can compute how much of its T_v is already accounted for by the already added nodes. If that's exactly half, then we can add it to the order.\n\nBut how to find such a node to add next?\n\nThis seems like a problem that can be addressed with a priority queue or some other data structure. However, I'm not sure.\n\nAnother idea: Think of the nodes as needing to have their T_v / 2 of flow from already added nodes. For each node, the current sum of flows from already added nodes is called 'current_in'. Initially, current_in is zero for all nodes. When a node is added to the topological order, for each of its neighbors, if the neighbor hasn't been added yet, we add the flow of the edge between them to the neighbor's current_in. For example, if node u is added to the order, and there is an edge between u and v (not yet added), then v's current_in increases by the flow of that edge.\n\nOnce current_in for a node reaches T_v / 2, we can add it to the topological order.\n\nThis seems promising. Because when a node is added to the topological order, all edges from already added nodes to it are accounted for in current_in. And since current_in equals T_v / 2, the sum_out (edges from this node to unadded nodes) is also T_v / 2, satisfying the flow conservation condition.\n\nSo the algorithm would be:\n\n- Compute T_v for each node.\n\n- Initialize a priority queue (or some structure) of nodes whose current_in is equal to T_v / 2.\n\n- Start with the source node. Add it to the topological order.\n\n- For each node added to the topological order, iterate over its edges. For each edge to a node not yet added, add the flow of that edge to the neighbor's current_in. If this makes the neighbor's current_in equal to T_v / 2, add it to the priority queue.\n\n- Repeat until all nodes are processed.\n\nBut how to manage the priority queue? Well, since the source is added first, and then for each node added, we process its edges and update the current_in of its neighbors. Once a neighbor's current_in reaches T_v / 2, it can be added to the topological order.\n\nThis sounds similar to BFS or DFS, but with the condition that a node can only be added when its current_in reaches T_v / 2.\n\nLet's test this idea with the sample input.\n\nSample 1:\n\nNodes: 1, 2, 3. Source is 1, sink is 3.\n\nEdges:\n\n3-2 (10)\n\n1-2 (10)\n\n3-1 (5)\n\nT_v for each node:\n\nT_1: edges to 2 (10) and to 3 (5) → total 15.\n\nT_2: edges to 1 (10), 3 (10) → total 20.\n\nT_3: edges to 2 (10) and 1 (5) → total 15.\n\nFor nodes 1 and 3, we don't need to check T_v / 2. For node 2, T_v is 20, so T_v / 2 is 10.\n\nInitially, the topological order starts with node 1.\n\nNow, for each neighbor of node 1 (nodes 2 and 3):\n\nFor node 2: current_in is 0. Adding the flow from 1 to 2 (10) → current_in becomes 10, which equals T_2 / 2 (10). So node 2 is added to the queue.\n\nFor node 3: current_in is 0. Adding the flow from 1 to 3 (5) → current_in becomes 5. T_3 is 15, so T_3 / 2 is 7.5. But since the problem states that a solution exists, perhaps T_v is even for non-source/sink nodes. Wait, node 3 is the sink. So T_3 can be anything. So for node 3, since it's the sink, we don't need to check current_in. So node 3's current_in is 5, but we don't have to process it.\n\nNow, the queue has node 2. We add node 2 to the topological order. Now, we look at its edges. Node 2 is connected to 1 (already added), 3 (not added yet). For the edge between 2 and 3 (flow 10), we add this to node 3's current_in. So node 3's current_in is 5 + 10 = 15. T_3 is 15. Since node 3 is the sink, we don't need to check. However, since node 3 is the sink, we can add it to the topological order now. But why? Because once all edges from previously added nodes are processed, node 3's current_in is 15. But since it's the sink, there's no need to check. So we add node 3 to the topological order.\n\nThus, the topological order is [1, 2, 3].\n\nNow, for each edge, we direct it from the earlier node in the topological order to the later one. So:\n\nEdge between 3 and 2: in the topological order, 2 is before 3. So direction is 2 → 3. Which matches the sample output (for the first edge, which is 3-2, output is 1, meaning direction is 2→3).\n\nEdge between 1 and 2: 1 is before 2 → direction 1→2 (output 0).\n\nEdge between 3 and 1: 1 is before 3 → direction 1→3 (output 1, since original edge is 3-1, so direction is 1→3 is bi → ai, so output 1).\n\nWhich matches the sample output. So this approach works.\n\nAnother example: the second sample input.\n\nInput:\n\n4 5\n\nEdges:\n\n1-2 (10)\n\n1-3 (10)\n\n2-3 (5)\n\n4-2 (15)\n\n3-4 (5)\n\nOutput is 0 0 1 1 0.\n\nLet me compute T_v for each node.\n\nNode 1: edges to 2 (10), 3 (10). Total 20.\n\nNode 2: edges to 1 (10), 3 (5), 4 (15). Total 30.\n\nNode 3: edges to 1 (10), 2 (5), 4 (5). Total 20.\n\nNode 4: edges to 2 (15), 3 (5). Total 20.\n\nSink is node 4.\n\nFor nodes 2 and 3, T_v is 30 and 20 respectively. So T_v/2 is 15 and 10.\n\nProcessing steps:\n\nStart with node 1 (source). Its edges are to 2 and 3.\n\nFor node 2: current_in += 10 → 10. T_2 is 30, so T_2/2 is 15. Not enough.\n\nFor node 3: current_in += 10 → 10. T_3 is 20, so T_3/2 is 10. So node 3 is added to the queue.\n\nSo the queue has node 3. Add it to the topological order.\n\nNow, look at node 3's edges. Its edges are to 1 (already added), 2 (not added), and 4 (not added).\n\nFor edge to 2 (flow 5): add 5 to node 2's current_in. Now node 2's current_in is 10 + 5 = 15. Which equals T_2/2 (15). So node 2 is added to the queue.\n\nFor edge to 4 (flow 5): add 5 to node 4's current_in. Node 4's current_in is 5. But since it's the sink, no need to check.\n\nNow, the queue has node 2. Add it to the topological order.\n\nNow, process node 2's edges. Its edges are to 1 (added), 3 (added), and 4 (not added). Edge to 4 (flow 15): add 15 to node 4's current_in. Now node 4's current_in is 5 + 15 = 20. T_4 is 20. Since it's the sink, we can add it to the topological order.\n\nSo the topological order is [1, 3, 2, 4].\n\nNow, the edges are directed based on the topological order.\n\nEdge 1-2: 1 is before 2 → direction 1→2 (output 0).\n\nEdge 1-3: 1 before 3 → direction 1→3 (output 0).\n\nEdge 2-3: 3 is before 2 in the topological order? No, node 3 is added before node 2. So in the topological order, 3 comes before 2. So the edge between 2 and 3 is directed from 3 to 2. Original edge is 2-3. So direction is 3→2, which is output 1 (since original is ai=2, bi=3. Output 1 means direction is bi→ai, which is 3→2. Correct.)\n\nEdge 4-2: in the topological order, 2 is before 4. So direction is 2→4. Original edge is 4-2. Output is 1 if direction is bi→ai (2→4). Wait original edge is ai=4, bi=2. So direction 4→2 is ai→bi (output 0), and 2→4 is bi→ai (output 1). But in our topological order, node 2 comes before 4, so direction is 2→4. So output is 1 for this edge. Which matches the sample output's fourth line (output is 1).\n\nEdge 3-4: in the topological order, 3 is before 4. So direction is 3→4. Original edge is 3-4. Output is 0 if direction is ai→bi (3→4). Which is correct, and the sample output for this edge is 0.\n\nSo the outputs for the edges would be:\n\nOriginal edges:\n\nEdge 1: 1-2 → 0.\n\nEdge 2: 1-3 → 0.\n\nEdge 3: 2-3 → 1.\n\nEdge 4: 4-2 → 1.\n\nEdge 5: 3-4 → 0.\n\nWhich matches the sample output of 0 0 1 1 0. Correct.\n\nSo this approach seems to work. Therefore, the plan is:\n\n- For each node, compute T_v (sum of flows on edges connected to it).\n\n- For non-sink and non-source nodes, we need to add them to the topological order when their current_in (sum of flows from already added nodes) equals T_v / 2.\n\n- The source is added first.\n\n- For each node added, iterate through its edges. For each neighbor not yet added, add the flow of the edge to the neighbor's current_in. If that makes the neighbor's current_in equal to T_v / 2 (and it's not the sink), add it to the queue.\n\n- Once all nodes are added, the topological order is determined, and the direction of each edge is determined by which node comes first in the order.\n\nNow, the question is: how to implement this efficiently.\n\nImplementation Steps:\n\n1. Read the input.\n\n2. For each node, compute T_v.\n\n3. Build the adjacency list. For each edge, store both ends and the flow. Also, keep track of the original edges' indices for output.\n\nBut for processing, we need to know the neighbors of each node and the flow between them.\n\n4. Initialize a data structure (like a queue) for nodes that can be added to the topological order. Initially, the source (node 1) is added.\n\n5. For each node, track whether it's been added to the topological order. Also, track current_in for each node.\n\n6. For each node added to the topological order, iterate through all its edges. For each edge, if the other end hasn't been added yet, add the flow to the other end's current_in. Then, check if that other end's current_in equals T_v / 2 (if it's not the sink), and if so, add it to the queue.\n\n7. Once the topological order is built, for each edge, determine the direction based on which node comes first in the order.\n\nBut how to handle the edges? For each edge (u, v), during the processing, we need to know which of u or v comes first in the topological order. So during the topological order building, we can record the order of nodes, and for each edge, compare the positions of u and v in the order.\n\nBut storing the order as a list, and for each node, storing its position in the list (like an array pos where pos[v] is the index in the order), then for an edge between u and v, if pos[u] < pos[v], then direction is u→v (original edge is ai, bi. So if the original edge is (ai, bi), then if ai is u and bi is v, and u comes before v, then direction is ai→bi (output 0). Else, if the original edge is (ai, bi) and the direction is bi→ai, then output 1.\n\nBut how to handle this for each edge?\n\nImplementation Steps:\n\n- After building the topological order, create a dictionary or array that maps each node to its position in the order.\n\n- For each edge in the input, compare the positions of ai and bi. If pos[ai] < pos[bi], then direction is ai→bi (output 0). Else, output 1.\n\nBut this assumes that the topological order is such that for any edge between u and v, the direction is from the one that comes first in the order to the one that comes later. Which is correct, since the order is a topological order of the directed graph.\n\nNow, the code:\n\nImplementing this in Python.\n\nBut for large n (up to 2e5), we need an efficient way. Using BFS-like approach with a queue.\n\nLet's outline the code:\n\nRead n and m.\n\nThen read m edges. For each edge, store ai, bi, ci, and also keep track of the original order.\n\nBuild adjacency list: for each node, list of (neighbor, flow).\n\nCompute T_v for each node: for each node v, sum of ci for all edges connected to it.\n\nInitialize:\n\n- added = array of booleans, size n+1 (since nodes are numbered 1-based).\n\n- current_in = array of integers, size n+1.\n\n- queue: initially contains node 1.\n\n- topological_order = list.\n\n- pos = array of integers, size n+1, to store the position in the topological order.\n\nThen, while the queue is not empty:\n\n   u = dequeue.\n\n   add u to topological_order.\n\n   pos[u] = len(topological_order) - 1 (or whatever index).\n\n   for each neighbor v in adjacency",
    "response": "To solve this problem, we need to determine the direction of each edge in an undirected graph such that the resulting directed graph satisfies the conditions of a valid maximum flow. Specifically, the graph must be acyclic, and each vertex (except the source and sink) must have equal incoming and outgoing flow sums.\n\n### Approach\n1. **Graph Representation**: Use an adjacency list to represent the graph, storing each edge along with its flow value.\n2. **Flow Calculation**: For each vertex, calculate the total flow of all edges connected to it.\n3. **Topological Order Construction**: Construct a topological order starting from the source vertex (vertex 1). This ensures that the graph remains acyclic.\n4. **Current Inflow Tracking**: Track the inflow for each vertex as we build the topological order. When a vertex's inflow reaches half of its total flow (ensuring balance), it is added to the topological order.\n5. **Direction Determination**: After constructing the topological order, determine the direction of each edge based on the positions of its endpoints in the topological order.\n\n### Solution Code\n```python\nimport sys\nimport threading\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n\n    edges = []\n    adj = [[] for _ in range(n + 1)]\n    for i in range(m):\n        a = int(input[idx])\n        idx += 1\n        b = int(input[idx])\n        idx += 1\n        c = int(input[idx])\n        idx += 1\n        edges.append((a, b, c))\n        adj[a].append((b, c, i))\n        adj[b].append((a, c, i))\n\n    T = [0] * (n + 1)\n    for a, b, c in edges:\n        T[a] += c\n        T[b] += c\n\n    added = [False] * (n + 1)\n    current_in = [0] * (n + 1)\n    q = deque()\n    q.append(1)\n    added[1] = True\n    topological_order = []\n    pos = [0] * (n + 1)\n\n    while q:\n        u = q.popleft()\n        topological_order.append(u)\n        pos[u] = len(topological_order) - 1\n        for v, c, i in adj[u]:\n            if not added[v]:\n                current_in[v] += c\n                if v != n:\n                    if current_in[v] == T[v] // 2:\n                        q.append(v)\n                        added[v] = True\n\n    result = [0] * m\n    for i in range(m):\n        a, b, c = edges[i]\n        if pos[a] < pos[b]:\n            result[i] = 0\n        else:\n            result[i] = 1\n\n    for d in result:\n        print(d)\n\nthreading.Thread(target=main).start()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into edges and an adjacency list.\n2. **Total Flow Calculation**: For each vertex, the total flow of connected edges is calculated.\n3. **Topological Order Construction**: Using a BFS-like approach, nodes are added to the topological order once their inflow reaches half of their total flow, ensuring flow conservation.\n4. **Edge Direction Determination**: After constructing the topological order, each edge's direction is determined by comparing the positions of its endpoints in the topological order. If the source node of the edge comes before the destination node in the topological order, the edge is directed from the source to the destination; otherwise, it is directed in the opposite direction.\n\nThis approach ensures that the resulting directed graph is acyclic and satisfies the flow conservation constraints for all intermediate vertices.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport threading\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n\n    edges = []\n    adj = [[] for _ in range(n + 1)]\n    for i in range(m):\n        a = int(input[idx])\n        idx += 1\n        b = int(input[idx])\n        idx += 1\n        c = int(input[idx])\n        idx += 1\n        edges.append((a, b, c))\n        adj[a].append((b, c, i))\n        adj[b].append((a, c, i))\n\n    T = [0] * (n + 1)\n    for a, b, c in edges:\n        T[a] += c\n        T[b] += c\n\n    added = [False] * (n + 1)\n    current_in = [0] * (n + 1)\n    q = deque()\n    q.append(1)\n    added[1] = True\n    topological_order = []\n    pos = [0] * (n + 1)\n\n    while q:\n        u = q.popleft()\n        topological_order.append(u)\n        pos[u] = len(topological_order) - 1\n        for v, c, i in adj[u]:\n            if not added[v]:\n                current_in[v] += c\n                if v != n:\n                    if current_in[v] == T[v] // 2:\n                        q.append(v)\n                        added[v] = True\n\n    result = [0] * m\n    for i in range(m):\n        a, b, c = edges[i]\n        if pos[a] < pos[b]:\n            result[i] = 0\n        else:\n            result[i] = 1\n\n    for d in result:\n        print(d)\n\nthreading.Thread(target=main).start()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 701,
        "completion_token_count": 824,
        "thoughts_token_count": 8192
    }
}