{
    "start": 1758308176.6325932,
    "end": 1758308359.520508,
    "start-formatted": "2025-09-20 03:56 KST",
    "end-formatted": "2025-09-20 03:59 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\nOkay, let's see. The problem is to find the smallest non-negative integer k such that the LCM of (a +k) and (b +k) is minimized. And if there are multiple k's with the same minimal LCM, choose the smallest one.\n\nHmm. Let's think about how to approach this. Let me first understand what the LCM depends on here. Let's denote x = a + k and y = b +k. Then, since both x and y are increased by the same k, the difference between them remains the same as the original difference between a and b. Wait, because (b +k) - (a +k) = b -a. So the difference between x and y is fixed as d = |a - b|. Let me assume that a and b are such that a ≤ b. Let me think: suppose a is smaller than b. Then, the difference is d = b -a. So, when we add k to both, x = a +k, y = b +k. Then, y -x = d. So, the problem reduces to finding x and y where y -x = d, and their LCM is minimized. But since x and y differ by d, perhaps there's a way to find x and y such that they share as many factors as possible.\n\nWait, the LCM of two numbers x and y is (x*y)/gcd(x,y). Since y = x +d, then the LCM is (x*(x +d))/gcd(x, x+d). But since gcd(x, x+d) = gcd(x, d), because gcd(x, x+d) = gcd(x, d). So, the LCM becomes (x*(x +d))/gcd(x, d). So, for fixed d, we need to find x such that this value is minimized.\n\nBut how do we find x? Well, since x can be any number greater than or equal to a (since k is non-negative, so x = a +k ≥ a). But since a and b can be in any order, perhaps we should first compute d as the absolute difference between a and b. Let me assume that d is the absolute difference. Let me say that a is the smaller one, but perhaps it's better to take d = |a -b|.\n\nSo, the problem becomes: find x such that x ≥ min(a, b), and y = x +d, and the LCM of x and y is minimized. Then, the minimal k would be x - a (since x = a +k, so k = x -a). But since x can be any value ≥ min(a, b), how do we find the optimal x?\n\nAlternatively, since y = x +d, and d is fixed, perhaps the optimal x is such that x and y have the maximum possible gcd. Because the LCM is (x*y)/g, where g is the gcd. So, maximizing the gcd would minimize the LCM. So, the problem reduces to finding x such that x and x +d have the maximum possible gcd. Then, among those x's, we need to find the smallest k.\n\nBut how to find such x?\n\nLet me think. Let's say that d is fixed. Let me denote that x and x +d have a common divisor g. Then, since x and x +d are multiples of g, then x = g * m, and x +d = g * n. Therefore, the difference between them is d = g*(n - m). So, g must be a divisor of d. Therefore, the maximum possible gcd of x and x +d is a divisor of d. So, to maximize the gcd, we need to find the largest possible divisor of d, say g, such that there exists an x where x is a multiple of g, and x ≥ min(a, b). Then, once we find the largest such g, the optimal x would be such that x is a multiple of g, and x is as small as possible (to minimize the LCM? Or maybe not, but perhaps the minimal x that allows for maximum g).\n\nWait, but for each divisor g of d, the maximum possible gcd is g. So, the idea is to find the maximum possible g that divides d, and then find x such that x is a multiple of g, and x is as small as possible (so that x and x +d have LCM as small as possible). Then, once we find that, the minimal LCM would be (x*(x +d))/g.\n\nBut how to find the best g?\n\nLet me think. For example, in the first sample input: a=6, b=10. So, d = 4. The divisors of 4 are 1,2,4. Let's check for each possible divisor:\n\nIf we take g=4. Then, x must be a multiple of 4. Also, since x must be ≥ min(a,b) =6. So, the smallest x is 8 (since 4*2=8, but 4*1=4 <6). Then, x=8, y=12. Their LCM is (8*12)/4 = 24. Which matches the sample.\n\nIf we take g=2. Then, x must be a multiple of 2. The minimal x is 6 (since 6 is >=6). Then, x=6, y=10. LCM is (6*10)/2=30. Which is higher than 24. So, worse than the previous case.\n\nFor g=1, the LCM would be x*(x+4)/1. The minimal x is 6, which gives 6*10=60. Which is worse than 24.\n\nThus, the best is to take the maximum possible g, which is 4, and find x as the minimal possible multiple of g that is ≥ min(a,b).\n\nBut wait, in this case, the maximum possible g is 4, but what if there's a larger g? Well, since d is 4, the maximum possible is 4. So, the approach is to find the maximum possible divisor of d, and then find x as the minimal multiple of that divisor that is ≥ min(a, b). But how to find that divisor?\n\nSo, the steps would be:\n\n1. Compute d = |a - b|. If d is zero, then a = b. Then, adding k to both gives a +k and a +k. Their LCM is a +k. To minimize this, we take k=0, since that gives the minimal possible value (a). So in this case, the answer is 0.\n\nElse, for d > 0:\n\n2. Find all divisors of d, then find the maximum divisor g such that there exists x ≥ min(a, b) where x is a multiple of g. Then, once we have that g, the minimal x is the smallest multiple of g that is ≥ min(a, b). Then, the corresponding k is x - a (assuming a is the smaller one, but need to check which is which).\n\nWait, but how do we find the maximum possible g? Well, since d is fixed, the maximum possible g is d itself. But then, we need to check whether there exists an x such that x is a multiple of g (d), and x ≥ min(a, b). For example, if min(a, b) is m. Then, the minimal x is the smallest multiple of d that is ≥m. Let's call this x_min. Then, the corresponding k is x_min - a (if a is the smaller one, otherwise x_min - b? No, because if a is smaller than b, then m =a. So, x is a +k, so k = x -a. So, for example, in the first case, m=6, d=4. x_min is 8, which is 6 + 2. So k is 2.\n\nBut what if the minimal x is not possible? Well, since d is fixed, and for g=d, the minimal x is ceil(m /d) *d. But since m can be any value. For example, suppose m is 5, d is 4. Then, the minimal x is 8. So, yes, possible.\n\nSo, the plan is:\n\n- Compute d = |a -b|. If d is zero, return 0.\n\n- Else, find the maximum divisor of d (call it g) such that there exists x ≥ m (where m is min(a, b)) which is a multiple of g. Then, the minimal x is the smallest multiple of g that is ≥ m. Then, compute k as x - m (since m is min(a, b), and x = m +k).\n\nWait, but why is the maximum divisor of d the best? Because the higher the g, the higher the gcd(x, x+d) will be. Which would lead to lower LCM.\n\nBut how to find the maximum possible g?\n\nWell, the maximum possible is d itself. So, first check if there's an x that is a multiple of d, and x ≥ m. Then, if yes, then that's the best possible. Otherwise, we need to look for the next largest divisor of d.\n\nBut how do we know if there's an x that is a multiple of d and ≥ m? Well, the minimal x is the ceiling of m divided by d multiplied by d. For example, if m is 6 and d is 4, then 6 /4 is 1.5, ceiling is 2, so 2*4=8. Which is ≥6. So, yes. So, for any m, there exists such x. So, the maximum possible g is d. So, in that case, the optimal x is the minimal multiple of d that is ≥ m.\n\nWait, but then why in the first example, the answer is 2. Let's see. For d=4, m=6. The minimal x is 8. So, k is 8 -6 = 2. Which matches the sample. So that works.\n\nAnother example: the third sample input is 5 and 10. So d is 5. m is 5. So the minimal x is 5. Then, k is 0. Which is correct. Because adding 0 gives 5 and 10. Their LCM is 10. If we tried other options, like k=5, x=10, y=15, LCM is 30. Which is worse. So yes, the answer is 0.\n\nAnother example: input 21 and 31. d is 10. m is 21. So, the maximum possible g is 10. The minimal x is 21 rounded up to the next multiple of 10. 21 divided by 10 is 2.1, ceiling is 3, so 3*10=30. So x is 30, which is 21 +k => k=9. Which matches the sample output.\n\nSo, this seems to work. So the approach is:\n\nIf a == b, return 0.\n\nElse, compute d = abs(a -b). Then, compute m = min(a, b). Then, find the minimal x that is a multiple of d and ≥ m. Then, k = x - m.\n\nBut wait, why is this the case? Because taking the maximum possible g (d) gives the maximum possible gcd, which leads to the minimal LCM. So, this approach would find the optimal k.\n\nBut is there any case where taking a smaller divisor of d could result in a smaller LCM?\n\nLet me think of a counterexample. Suppose d=6. Let's say m is 4. So, the maximum possible g is 6. The minimal x is 6 (since 4 is less than 6). Then x is 6, y is 6 +6=12. LCM(6,12) is 12.\n\nAlternatively, if we take a divisor of 6, say 3. Then, the minimal x is 4 (since 4 is ≥ m=4 and is a multiple of 3? No. 4 is not a multiple of 3. The next multiple is 6. So x=6 again. Which gives same as before. Hmm. So, same result.\n\nAnother example. Let's say d=6, m=5. Then, for maximum g=6, x is 6. LCM(6, 12) = 12. If we take g=3, then the minimal x is 6 (since 5/3 is ~1.66, ceiling is 2, 2*3=6). Then x=6, same as before. So LCM is same. What if there's another divisor?\n\nWhat if d=6 and m is 3. Then, for maximum g=6, x is 3? No, because 3 is a multiple of 6? No, 3 is not. So the minimal x is 6. So x=6, y=12. LCM is 12. Alternatively, take g=3. Then x can be 3, which is ≥ m=3. Then x=3, y=9. LCM is 9. Which is better than 12. Oh! So this contradicts our previous approach. So in this case, choosing a smaller divisor gives a better LCM.\n\nWait, that's a problem. So our initial approach was wrong. So why?\n\nBecause the maximum divisor of d is 6, but choosing a smaller divisor (like 3) allows for a smaller x (3) which gives a smaller LCM.\n\nSo, our initial reasoning was incorrect. Therefore, we need to think again.\n\nThis shows that the approach of taking the maximum divisor of d may not always be the best. So, how to proceed?\n\nIn this example, d=6, m=3. The two possibilities are:\n\nOption 1: Take g=6. Then x must be a multiple of 6, and ≥3. The minimal x is 6. Then, x=6, y=12. LCM is 12.\n\nOption 2: Take g=3. Then x can be 3 (≥3). Then, x=3, y=9. LCM is 9, which is better.\n\nSo, the maximum divisor of d is 6, but the optimal choice is to take a smaller divisor. Hence, our initial approach is wrong.\n\nSo, this suggests that the problem requires considering all possible divisors of d, not just the maximum one, and for each possible divisor, compute the minimal possible LCM, then choose the one with the minimal LCM. If there are multiple divisors leading to the same minimal LCM, pick the one with the smallest k.\n\nBut how can we do that efficiently?\n\nThe key insight is that for each divisor g of d, we can find the minimal x (as the smallest multiple of g that is ≥m). Then compute the LCM of x and x +d. Then, find the minimal LCM over all possible divisors of d. Once we find the minimal LCM, we select the smallest k that achieves it.\n\nSo, the steps would be:\n\n- Compute d = |a -b|. If d=0, return 0.\n\n- Else, find all divisors of d.\n\n- For each divisor g of d:\n\n   - compute the minimal x that is a multiple of g and ≥m (where m = min(a, b)).\n\n   - compute y = x +d.\n\n   - compute LCM(x, y) = (x*y) // gcd(x, y). But since x and y differ by d, and since g divides d, and x is a multiple of g, then x = g * p, and d = g * q. So y = x +d = g(p + q). Thus, gcd(x, y) = g * gcd(p, p + q) = g * gcd(p, q). But since d = g * q, and q = d/g. So, q is an integer. However, since x is a multiple of g, and d is also a multiple of g, then the gcd(x, y) = g * gcd(p, p + q) = g * gcd(p, q). But since q = d/g, and p is x/g.\n\nBut perhaps there's a simpler way to compute the LCM. Since x and y are x and x +d. And since g divides d, and x is a multiple of g, then x and y are multiples of g. So, the LCM of x and y is (x * y) / (gcd(x, y)). But since x and y are multiples of g, their gcd is at least g. But how to compute it?\n\nAlternatively, since x and y = x +d, and since d = g * q, then y = x + g * q. Since x is a multiple of g, let's say x = g * p. Then y = g*(p + q). Thus, the gcd(x, y) = g * gcd(p, p + q) = g * gcd(p, q). Therefore, the LCM is (g*p * g*(p + q)) / (g * gcd(p, q)) ) = g * p * (p + q) / gcd(p, q). \n\nBut since q = d/g, and p is x/g, which is some integer. However, since x is chosen as the minimal multiple of g ≥ m, then p is minimal possible. But how does this help us?\n\nAlternatively, perhaps the LCM can be simplified as (x * y) / g', where g' is the gcd(x, y). But since x and y are multiples of g, and their difference is d, which is also a multiple of g, then the gcd(x, y) is at least g. However, it might be higher. For example, in the case where x = 3, y =9, d=6. Here, x=3, y=9, d=6. The gcd(x, y) is 3, which is equal to g (since d=6, and g=3 is a divisor of d). So in that case, the LCM is (3*9)/3 = 9.\n\nBut in the case where x=6 and y=12, the gcd is 6, and the LCM is 12.\n\nSo, for each divisor g of d, the LCM is (x * y) / (gcd(x, y)), which depends on x and y. However, for the same g, different x's (i.e., different p's) could yield different LCMs. But since we are choosing the minimal x for each g, perhaps that's the optimal for that particular g.\n\nBut how to find which g gives the minimal LCM?\n\nSo, the plan is:\n\nFor each divisor g of d:\n\n   compute x as the smallest multiple of g that is ≥ m.\n\n   compute y = x +d.\n\n   compute the LCM of x and y.\n\nThen, select the g that gives the minimal LCM. If multiple g's give the same minimal LCM, then choose the one with the smallest k (which is x - m).\n\nBut how to generate all the divisors of d efficiently?\n\nGiven that d can be up to 1e9, but the number of divisors is manageable (for 1e9, the maximum number of divisors is 100 or so).\n\nSo, the steps would be:\n\n1. Compute d = |a -b|.\n\n   if d ==0, return 0.\n\n2. else, compute all divisors of d.\n\n3. for each divisor g of d:\n\n   compute x = ((m + g -1) // g) * g. Where m is min(a, b).\n\n   compute y = x +d.\n\n   compute the LCM of x and y.\n\n   keep track of the minimal LCM, and the corresponding k (x - m).\n\n4. choose the k with the minimal LCM. If tie, choose the smallest k.\n\nBut then, how to generate all divisors of d?\n\nYes. Now, how to generate all divisors of d. Let's think of a function that returns all the divisors of a given number.\n\nBut for this, we can factorize d into primes, then generate all possible products. However, for d up to 1e9, trial division is feasible.\n\nAlternatively, for generating all divisors, we can iterate from 1 to sqrt(d), check if i divides d, and collect i and d//i.\n\nBut for the problem, since we need to process all divisors, including the ones that are not the maximum, perhaps this is manageable.\n\nOnce all divisors are generated, we can process each of them.\n\nBut in the example I mentioned earlier, where d=6, m=3, the divisors are 1,2,3,6.\n\nProcessing each:\n\nFor g=1:\n\nx = ((3 +1-1)//1)*1 = 3. So x=3, y=3+6=9. LCM(3,9)=9.\n\nFor g=2:\n\nx = ((3 +2-1)//2)*2 → (4//2)*2= 2*2=4. x=4, y=10. LCM(4,10) = 20.\n\nFor g=3:\n\nx = ((3 +3-1)//3)*3 → (5//3) is 1, so 1*3=3. x=3, y=9. LCM is 9.\n\nFor g=6:\n\nx = ((3 +6-1)//6)*6 → (8//6) is 1 → 6. x=6, y=12. LCM is 12.\n\nSo the minimal LCM is 9, achieved by g=1 and g=3. So, between these, we need to select the smallest k. For g=1, x is 3, which is m=3. So k = 3 - m = 0. For g=3, same k=0. So the answer is 0. Which is correct.\n\nBut according to the previous approach, which only considered the maximum divisor (g=6), we would have chosen k=3, which gives LCM 12, which is worse than 9. Hence, the need to consider all divisors.\n\nSo the correct approach is to generate all divisors of d, compute for each the corresponding x, then compute the LCM, and find the minimal LCM and the corresponding k.\n\nSo, the algorithm is:\n\nCompute d = |a -b|.\n\nif d ==0: return 0.\n\nelse:\n\n   generate all divisors of d.\n\n   for each divisor g in the list of divisors:\n\n      compute x as the smallest multiple of g that is >= m (m = min(a, b)).\n\n      compute y = x +d.\n\n      compute LCM(x, y).\n\n   find the divisor g that gives the minimal LCM. If multiple, pick the one with the smallest k.\n\nBut how to generate all divisors of d?\n\nLet me code a function to generate all divisors of a number.\n\nFor example, for d, we can find all divisors by checking up to sqrt(d). For each i that divides d, add i and d//i to the list. Then, deduplicate and sort.\n\nBut for the problem, perhaps we can generate all the divisors, then process them.\n\nOnce all divisors are generated, we can loop through each, compute x, compute LCM, track the minimal.\n\nBut how to compute LCM(x, y)? Well, LCM(x, y) = x * y // gcd(x, y). So, for that, we need to compute the GCD of x and y.\n\nBut since x and y are x and x +d, and since d is fixed. Also, since x is a multiple of g (a divisor of d), then x and y = x +d will be multiples of g, so their GCD is at least g. However, it can be higher.\n\nBut for the code, using math.gcd is straightforward.\n\nBut in Python, the math.gcd returns the absolute value, but since x and y are positive, it's fine.\n\nSo, the code steps:\n\nRead a and b.\n\nif a == b: print 0.\n\nelse:\n\n   m = min(a, b)\n\n   d = abs(a -b)\n\n   generate all divisors of d.\n\n   for each divisor g in the list of divisors:\n\n      x = ((m + g -1) // g) * g\n\n      y = x + d\n\n      current_lcm = (x * y) // gcd(x, y)\n\n      keep track of the minimal current_lcm and the corresponding k (x - m)\n\n   after processing all divisors, select the k with minimal current_lcm, and if tie, the smallest k.\n\nBut wait, in the example where d=6 and m=3, the divisors are [1, 2, 3, 6]. For each, we compute x and LCM. For g=1, x=3, LCM 9. For g=3, x=3, LCM 9. So, both give same LCM. Then, the k is 0 in both cases. So, the answer is 0.\n\nBut what if there are multiple divisors that give same LCM? For example, in that case, we need to choose the smallest k. But since x is the minimal possible for each g, the k is x - m. For the same LCM, which is possible for different g's, we need to choose the smallest k.\n\nBut in the example above, both g=1 and g=3 give same LCM and same k. So no problem.\n\nAnother example: suppose for two different divisors, the LCM is same, but k differs. For example, let's imagine:\n\nd=4, m=2. Divisors are 1,2,4.\n\nFor g=1: x=2, y=6. LCM(2,6)=6.\n\nFor g=2: x=2, y=6. LCM is same. So same LCM. k is 0.\n\nFor g=4: x=4, y=8. LCM is 8. So, better to choose the first two options. So, the minimal k is 0.\n\nSo, the code needs to track for each candidate (divisor) the LCM and k, and then select the one with minimal LCM, and minimal k in case of ties.\n\nSo, the code can collect all possible candidates (each divisor's x and k) and then select the best one.\n\nNow, the question is: how to generate all the divisors of d.\n\nImplementing that in Python.\n\nLet me write a helper function to get all divisors of a number.\n\ndef get_divisors(n):\n\n    divisors = set()\n\n    for i in range(1, int(n**0.5) + 1):\n\n        if n % i == 0:\n\n            divisors.add(i)\n\n            divisors.add(n//i)\n\n    return sorted(divisors)\n\nBut for n=0? Well, in our case, d is |a -b|, which is non-zero, since we handled the case where a==b.\n\nOnce we have the list of divisors, we can process them.\n\nBut in the example where d=6, the divisors are 1, 2, 3, 6. So the code would generate them.\n\nNow, for each of those divisors, compute x, then compute the LCM.\n\nOnce all candidates are generated, select the best one.\n\nNow, considering that for each divisor, the x is computed as the minimal multiple of g >= m.\n\nNow, the code.\n\nBut what about when d is large? For example, 1e9. The number of divisors is manageable. For example, even for 1e9, which factors into 2^9 * 5^9, the number of divisors is (9+1)*(9+1) = 100. So generating them is feasible.\n\nNow, the code:\n\nimport math\n\ndef get_divisors(n):\n\n    divisors = set()\n\n    for i in range(1, int(n**0.5) + 1):\n\n        if n % i == 0:\n\n            divisors.add(i)\n\n            divisors.add(n//i)\n\n    return list(divisors)\n\ndef main():\n\n    a, b = map(int, input().split())\n\n    if a == b:\n\n        print(0)\n\n        return\n\n    m = min(a, b)\n\n    d = abs(a - b)\n\n    divisors = get_divisors(d)\n\n    min_lcm = float('inf')\n\n    best_k = float('inf')\n\n    for g in divisors:\n\n        # compute x as the smallest multiple of g >= m\n\n        quotient = (m + g -1) // g\n\n        x = quotient * g\n\n        y = x + d\n\n        current_gcd = math.gcd(x, y)\n\n        current_lcm = x * y // current_gcd\n\n        # compare with min_lcm\n\n        if current_lcm < min_lcm or (current_lcm == min_lcm and (x - m) < best_k):\n\n            min_lcm = current_lcm\n\n            best_k = x - m\n\n        elif current_lcm == min_lcm and (x - m) < best_k:\n\n            best_k = x - m\n\n    print(best_k)\n\nBut wait, in the code above, for each divisor, we compute x and then compare. However, there's a possibility that two different divisors may generate the same LCM. For example, in the case where d=6, m=3, and for g=1 and g=3, the LCM is same. So, the code needs to track the minimal k.\n\nBut in the code, for each divisor, it checks if current_lcm is less than min_lcm, or equal but k is smaller. So that should handle it.\n\nTesting the sample inputs:\n\nFirst sample input: 6 10. d=4. divisors are 1,2,4.\n\nFor each g:\n\ng=1: x = (6 +1-1)//1 *1 = 6. y=6+4=10. LCM(6,10) is 30. current_lcm=30. best_k is 0.\n\ng=2: x = (6 +2-1)//2 *2 = (7//2)=3 *2=6. y=10. LCM is 30. same as before. k=0. So, same as before. So best_k remains 0.\n\ng=4: x is (6+4-1)//4 *4 → (9//4)=2 *4=8. y=12. LCM(8, 12) is 24. which is less than 30. So min_lcm becomes 24, best_k is 8-6=2. So the code returns 2. Which matches the sample.\n\nSecond sample input: 21 31. d=10. divisors are 1,2,5,10.\n\nm is 21.\n\nFor each g:\n\ng=1: x=21, y=31. LCM(21,31)= 21*31=651.\n\ng=2: x is ((21 +2-1)/2)*2 → (22//2) =11 → 22. y=22+10=32. LCM(22,32) is (22*32)/2 = 352.\n\ng=5: x is ((21+5-1)/5)*5 → (25//5) =5 → 25. y=35. LCM(25,35) = 175.\n\ng=10: x is ((21+10-1)/10)*10 → (30//10)=3 → 30. y=40. LCM(30,40) is 120. So the minimal is 120, which is achieved with k=9. Which matches the sample.\n\nThird sample: 5 and 10. d=5. divisors are 1,5.\n\nm is 5.\n\ng=1: x=5, y=10. LCM is 10.\n\ng=5: x=5, y=10. LCM is 10. So both have same LCM. So best_k is 0. Which is correct.\n\nAnother test case where d=6, m=3. divisors are 1,2,3,6.\n\nFor g=1: x=3, y=9. LCM=9.\n\nFor g=2: x=4, y=10. LCM=20.\n\nFor g=3: x=3, y=9. LCM=9.\n\nFor g=6: x=6, y=12. LCM=12.\n\nSo the best is 9, achieved with k=0.\n\nSo the code would choose the first occurrence of the minimal LCM. But since for both g=1 and g=3, the k is 0, which is same. So the code would select 0.\n\nBut in the code, for each divisor, it checks if current_lcm is less than min_lcm, or equal and k is smaller. So in the first iteration, when g=1, min_lcm is set to 9 and best_k to 0. Then, for g=3, current_lcm is 9, same as min_lcm, and (x -m) is 0, which is same as best_k. So no change. So the code returns 0.\n\nWhich is correct.\n\nAnother test case where two divisors give same LCM but different k. Let's imagine m=4, d=6. divisors are 1,2,3,6.\n\nFor g=1: x=4, y=10. LCM(4, 10) is 20.\n\nFor g=2: x=4, y=10. LCM same. k=0.\n\nFor g=3: x=6, y=12. LCM is 12. So better.\n\nSo code would find the best is 12, with k=6-4=2.\n\nBut for g=3, the code would process it and find that LCM is 12, which is better than 20. So it would set min_lcm to 12 and best_k to 2.\n\nThus, the code works.\n\nNow, edge cases.\n\nCase where a=1, b=1. Output is 0.\n\nCase where a=1, b=2. d=1. divisors are 1. x is 1. y=2. LCM is 2. k=0.\n\nAnother case: a=2, b=5. d=3. divisors are 1,3.\n\nFor g=1: x=2, y=5. LCM is 10.\n\nFor g=3: x is ((2+3-1)//3)*3 → (4//3)=1 → 3. y=6. LCM(3,6)=6. So best is 6, k=1.\n\nWhich is better than 10.\n\nSo code returns 1.\n\nAnother case: a=3, b=5. d=2. divisors are 1,2.\n\ng=1: x=3, y=5. LCM is 15.\n\ng=2: x=4, y=6. LCM is 12. So code returns k=1.\n\nWhich is correct.\n\nThus, the code seems to handle all cases correctly.\n\nNow, the code needs to be written in Python, handling the input correctly.\n\nBut note that in the code above, the divisors are generated as a list, but the order is not sorted. However, the code loops through all divisors regardless of order. Since for each divisor, the code checks whether it's better than the current best, the order doesn't matter.\n\nBut in the code, the get_divisors function returns a list, which is generated as a set. So the order is arbitrary. However, the code is correct regardless.\n\nNow, testing the sample input:\n\nSample Input 1:\n\n6 10 → Output 2.\n\nSample Input 2:\n\n21 31 → Output 9.\n\nSample Input 3:\n\n5 10 → Output 0.\n\nWhich the code handles.\n\nAnother sample: input 3 and 5 → output 1.\n\nNow, what about when m is not a multiple of g?\n\nLike, m=7, d=4. divisors are 1,2,4.\n\nFor g=4: x = ((7 +4-1)/4)*4 → (10//4)=2 → 8. So k=8-7=1. y=12. LCM(8,12)=24.\n\nFor g=2: x= ((7+2-1)/2)*2 → (8//2)=4 → 8. y=12. Same LCM. k=1.\n\nFor g=1: x=7, y=11. LCM=77. So best is 24, with k=1.\n\nSo code returns 1.\n\nBut what if there are multiple divisors leading to same LCM and different k? For example, if two divisors generate same LCM but different k, the code will choose the smallest k.\n\nSo, the code seems correct.\n\nThus, the code should work.\n",
    "response": "To solve this problem, we need to find the smallest non-negative integer $ k $ such that the least common multiple (LCM) of $ a + k $ and $ b + k $ is minimized. If there are multiple values of $ k $ that yield the same minimal LCM, we choose the smallest $ k $.\n\n### Approach\n1. **Understanding the Problem**: The key insight is that the difference between $ a $ and $ b $ remains constant when adding $ k $ to both. This difference, denoted as $ d $, helps in determining potential values of $ k $.\n2. **Divisors of Difference**: The optimal $ k $ can be derived by considering all divisors of $ d $. For each divisor $ g $, we compute the smallest multiple of $ g $ that is greater than or equal to the smaller of $ a $ and $ b $.\n3. **LCM Calculation**: For each divisor $ g $, we compute the corresponding values $ x $ and $ y $ (where $ x = a + k $ and $ y = b + k $), then calculate their LCM. The smallest LCM across all divisors gives us the optimal $ k $.\n\n### Solution Code\n```python\nimport math\n\ndef get_divisors(n):\n    divisors = set()\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return list(divisors)\n\ndef main():\n    a, b = map(int, input().split())\n    if a == b:\n        print(0)\n        return\n    m = min(a, b)\n    d = abs(a - b)\n    divisors = get_divisors(d)\n    min_lcm = float('inf')\n    best_k = float('inf')\n    for g in divisors:\n        quotient = (m + g - 1) // g\n        x = quotient * g\n        y = x + d\n        current_gcd = math.gcd(x, y)\n        current_lcm = x * y // current_gcd\n        if current_lcm < min_lcm or (current_lcm == min_lcm and (x - m) < best_k):\n            min_lcm = current_lcm\n            best_k = x - m\n    print(best_k)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input consists of two integers $ a $ and $ b $.\n2. **Special Case Handling**: If $ a $ and $ b $ are equal, the optimal $ k $ is 0 because adding 0 to both results in the same number, whose LCM is itself.\n3. **Divisors Calculation**: The function `get_divisors` computes all divisors of the absolute difference $ d $ between $ a $ and $ b $.\n4. **Finding Optimal $ k $**: For each divisor $ g $, we determine the smallest multiple of $ g $ that is at least the smaller of $ a $ and $ b $. Using this value, we compute the corresponding $ x $ and $ y $, then their LCM. We track the minimum LCM and the corresponding $ k $, ensuring to handle ties by selecting the smallest $ k $.\n\nThis approach efficiently narrows down potential values of $ k $ by leveraging properties of divisors and LCM, ensuring optimal performance even for large input values.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef get_divisors(n):\n    divisors = set()\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return list(divisors)\n\ndef main():\n    a, b = map(int, input().split())\n    if a == b:\n        print(0)\n        return\n    m = min(a, b)\n    d = abs(a - b)\n    divisors = get_divisors(d)\n    min_lcm = float('inf')\n    best_k = float('inf')\n    for g in divisors:\n        quotient = (m + g - 1) // g\n        x = quotient * g\n        y = x + d\n        current_gcd = math.gcd(x, y)\n        current_lcm = x * y // current_gcd\n        if current_lcm < min_lcm or (current_lcm == min_lcm and (x - m) < best_k):\n            min_lcm = current_lcm\n            best_k = x - m\n    print(best_k)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 402,
        "completion_token_count": 731,
        "thoughts_token_count": 8138
    }
}