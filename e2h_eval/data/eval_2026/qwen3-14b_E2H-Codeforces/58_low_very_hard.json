{
    "start": 1758309804.0769253,
    "end": 1758309969.538296,
    "start-formatted": "2025-09-20 04:23 KST",
    "end-formatted": "2025-09-20 04:26 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\nOkay, let's tackle this problem. Hmm. The task is to find the minimum number of edges to add to form an odd-length cycle, and the number of ways to do that. \n\nFirst, I need to understand what's required here. A simple cycle of odd length. So, a cycle where each vertex occurs once except the starting and ending one, and the total number of edges (which equals the number of vertices in the cycle) is odd. \n\nWait, but the problem says \"more than one vertex\", so the cycle must have at least 3 vertices. \n\nNow, the key thing here is that if the graph already contains an odd-length cycle, then t is zero. Because we don't need to add any edges. But how do I check that?\n\nBut if there's no such cycle, then we need to find the minimal number of edges to add. Let's think about the conditions for the graph. \n\nI remember that a graph is bipartite if and only if it contains no odd-length cycles. So, if the graph is bipartite, then adding edges to create an odd-length cycle would require some steps. \n\nSo the approach might involve checking whether the graph is bipartite. If it's not bipartite, then there's already an odd-length cycle, so t=0 and w is the number of ways to choose such cycles? Wait, no. Wait, the problem says that we need to find the minimum number of edges to add to form such a cycle. If the graph already contains such a cycle, then the answer is t=0 and w is the number of such cycles? Or wait, no. Because the question is about adding edges to form a cycle. If there's already an existing cycle, then you can just take that cycle. But the problem says that we need to find the minimum number of edges to add. So if the graph already has an odd-length cycle, then t is zero. And the number of ways w is the number of possible such cycles that exist in the original graph? But that seems complicated. However, the example given includes the case where the input is a triangle (3 nodes connected in a cycle). The output is 0 1. Which makes sense because there's already one cycle of length 3, which is odd. So in that case, the answer is t=0, w=1.\n\nBut how do we compute that? Well, maybe the problem is not about counting existing cycles but about the minimal steps to create one. So if the graph is not bipartite, then t is zero. But if it's bipartite, then we need to add edges to create an odd-length cycle. \n\nSo first, the problem reduces to checking if the graph is bipartite. If not, then t is zero and w is the number of existing odd-length cycles. Wait, but that's not feasible. Because counting the number of odd-length cycles is computationally expensive. However, the problem says that the answer for the case where the graph already has an odd cycle is t=0 and w is the number of ways to add zero edges (i.e., the number of existing odd cycles). But how do we compute that?\n\nWait, but the problem statement says that the answer is the number of ways to add t edges. For t=0, that would be the number of existing odd-length cycles. However, in the sample input, when the graph is a triangle (which is an odd cycle), the output is 0 1. Which implies that the answer counts the number of such cycles. But how can we compute that efficiently?\n\nBut perhaps the problem is not about existing cycles. Let me re-read the problem statement. \n\nThe problem says that Vitaly wants to find the minimum number of edges to add to form a simple cycle of odd length. So, if the graph already contains such a cycle, then t is zero. But the question is, how many ways are there to add zero edges (i.e., select an existing odd cycle). However, the problem says that two ways are considered equal if they have the same set of added edges. So for t=0, the number of ways is the number of existing odd cycles. But that's impossible to compute for large graphs. However, looking at the sample input where the graph is a triangle, the output is 0 1. Which suggests that the answer for that case is 1. But how can we compute that?\n\nAlternatively, perhaps the problem is not about existing cycles. Maybe the answer for t=0 is 1 if the graph is not bipartite. But that's not correct. Because the graph could have multiple odd cycles. However, perhaps the problem requires that the minimal t is zero if the graph is not bipartite, and the number of ways is the number of possible ways to choose a cycle. But that's not feasible for large n. So maybe the problem is not considering existing cycles. \n\nAlternatively, perhaps",
    "response": "To solve this problem, we need to determine the minimum number of edges to add to a given undirected graph to form a simple cycle of odd length, and also count the number of ways to achieve this. The solution involves checking if the graph is bipartite and using this information to determine the required values.\n\n### Approach\n1. **Check Bipartiteness**: A graph is bipartite if it can be colored using two colors such that no two adjacent nodes share the same color. If a graph is not bipartite, it contains an odd-length cycle, so no edges need to be added (t = 0).\n2. **Count Ways for Non-Bipartite Graphs**: If the graph is not bipartite, the number of ways (w) is 1 because we can use any existing odd-length cycle.\n3. **Bipartite Graph Handling**: If the graph is bipartite, we need to find the minimum number of edges to add to create an odd-length cycle. This involves:\n   - Finding the smallest component in terms of the number of nodes in each bipartition.\n   - The minimum number of edges to add is determined by the smallest component size.\n   - The number of ways to add these edges is calculated based on combinations of nodes from the smallest component.\n\n### Solution Code\n```python\nimport sys\nfrom collections import deque\n\ndef main():\n    sys.setrecursionlimit(1000000)\n    input = sys.stdin.read\n    data = input().split('\\n')\n    \n    n = int(data[0].split()[0])\n    m = int(data[0].split()[1])\n    edges = []\n    for i in range(1, len(data)):\n        if data[i] == '':\n            continue\n        u, v = map(int, data[i].split())\n        edges.append((u-1, v-1))\n    \n    # Check if the graph is bipartite\n    color = [-1] * n\n    is_bipartite = True\n    components = []\n    for start in range(n):\n        if color[start] == -1:\n            queue = deque()\n            queue.append(start)\n            color[start] = 0\n            cnt = [0, 0]\n            cnt[0] += 1\n            comp = []\n            while queue:\n                u = queue.popleft()\n                comp.append(u)\n                for v in [x for x in range(n) if (u, x) in edges or (x, u) in edges]:\n                    if color[v] == -1:\n                        color[v] = color[u] ^ 1\n                        cnt[color[v]] += 1\n                        queue.append(v)\n                    else:\n                        if color[v] == color[u]:\n                            is_bipartite = False\n            components.append(cnt)\n    \n    if not is_bipartite:\n        print(\"0 1\")\n        return\n    \n    # Now, the graph is bipartite. Need to find the minimal t and w\n    min_t = float('inf')\n    total_ways = 0\n    for cnt in components:\n        a, b = cnt\n        min_size = min(a, b)\n        if min_size == 0:\n            continue\n        t = min_size\n        if t < min_t:\n            min_t = t\n            total_ways = 0\n        if t == min_t:\n            # Compute the number of ways for this component\n            ways = 0\n            if min_size == 1:\n                # Choose 1 node from the smaller part (size 1), but need to form a cycle\n                # Wait, to form a cycle, you need at least 3 nodes. So for min_size = 1, you can't form a cycle?\n                # Because the other part has 1 node, but to form a cycle, you need to connect them with at least 2 edges\n                # Wait, no. For example, if a component is split into two parts with sizes 1 and k. To form a cycle of odd length,\n                # you need to connect nodes from the same partition? No, since the graph is bipartite. Adding an edge between two nodes in the same partition creates an odd-length cycle.\n                # So, in the case where one partition has size 1, the other has size k. To form a cycle, you need to connect two nodes from the same partition. But since the partition with size 1 has only one node, you can't connect two nodes there. So you need to connect two nodes in the larger partition. But that would require adding at least one edge. But wait, the minimal t is 1. How?\n                # Wait, if the component is bipartite, then all cycles are even-length. To create an odd-length cycle, we need to add an edge between two nodes in the same partition. The minimal number of edges to add is 1, and the number of ways is C(s, 2), where s is the size of the larger partition.\n                # So in this case, for the component with sizes 1 and k, the minimal t is 1, and the number of ways is C(k, 2)\n                # Wait, but how? Let's think: the component is bipartite with partitions A and B. Suppose |A| = 1, |B| = k. To form an odd-length cycle, we need to connect two nodes in the same partition. Since A has only one node, we cannot connect two in A. So we need to connect two nodes in B. Adding such an edge would create a cycle of length (path from u to v via A's single node) + 1. Which is (length of path from u to v through A) + 1. Since the original path from u to v is even (since the graph is bipartite), adding an edge between u and v gives an odd-length cycle.\n                # So the number of ways is C(k, 2) for this component.\n                # So for the current component, if the min_size is 1, then the larger size is max(a, b), and the number of ways is C(max_size, 2)\n                # So in this case, for the component with a=1, b=k, the number of ways is C(k, 2)\n                # So in this code, for each component, we compute the number of ways as C(s, 2), where s is the size of the larger partition\n                s = max(a, b)\n                ways = s * (s - 1) // 2\n            else:\n                # min_size is the size of the smaller partition. We need to choose two nodes from it to connect.\n                # Because connecting two nodes in the same partition will create an odd-length cycle.\n                # The minimal t is 1, and the number of ways is C(min_size, 2)\n                ways = min_size * (min_size - 1) // 2\n            total_ways += ways\n    \n    print(f\"{min_t} {total_ways}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Bipartite Check**: The graph is checked for bipartiteness using BFS. If it is not bipartite, it contains an odd-length cycle, so the answer is `0 1`.\n- **Component Analysis**: For each connected component in the bipartite graph, we determine the sizes of the two partitions. The minimum number of edges to add is derived from the smaller partition size.\n- **Ways Calculation**: The number of ways to add edges is computed using combinations of nodes from the smaller partition to form an odd-length cycle. This ensures we efficiently determine the minimum edges and valid configurations.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef main():\n    sys.setrecursionlimit(1000000)\n    input = sys.stdin.read\n    data = input().split('\\n')\n    \n    n = int(data[0].split()[0])\n    m = int(data[0].split()[1])\n    edges = []\n    for i in range(1, len(data)):\n        if data[i] == '':\n            continue\n        u, v = map(int, data[i].split())\n        edges.append((u-1, v-1))\n    \n    # Check if the graph is bipartite\n    color = [-1] * n\n    is_bipartite = True\n    components = []\n    for start in range(n):\n        if color[start] == -1:\n            queue = deque()\n            queue.append(start)\n            color[start] = 0\n            cnt = [0, 0]\n            cnt[0] += 1\n            comp = []\n            while queue:\n                u = queue.popleft()\n                comp.append(u)\n                for v in [x for x in range(n) if (u, x) in edges or (x, u) in edges]:\n                    if color[v] == -1:\n                        color[v] = color[u] ^ 1\n                        cnt[color[v]] += 1\n                        queue.append(v)\n                    else:\n                        if color[v] == color[u]:\n                            is_bipartite = False\n            components.append(cnt)\n    \n    if not is_bipartite:\n        print(\"0 1\")\n        return\n    \n    # Now, the graph is bipartite. Need to find the minimal t and w\n    min_t = float('inf')\n    total_ways = 0\n    for cnt in components:\n        a, b = cnt\n        min_size = min(a, b)\n        if min_size == 0:\n            continue\n        t = min_size\n        if t < min_t:\n            min_t = t\n            total_ways = 0\n        if t == min_t:\n            # Compute the number of ways for this component\n            ways = 0\n            if min_size == 1:\n                # Choose 1 node from the smaller part (size 1), but need to form a cycle\n                # Wait, to form a cycle, you need at least 3 nodes. So for min_size = 1, you can't form a cycle?\n                # Because the other part has 1 node, but to form a cycle, you need to connect them with at least 2 edges\n                # Wait, no. For example, if a component is split into two parts with sizes 1 and k. To form a cycle of odd length,\n                # you need to connect nodes from the same partition? No, since the graph is bipartite. Adding an edge between two nodes in the same partition creates an odd-length cycle.\n                # So, in the case where one partition has size 1, the other has size k. To form a cycle, you need to connect two nodes from the same partition. But since the partition with size 1 has only one node, you can't connect two nodes there. So you need to connect two nodes in the larger partition. But that would require adding at least one edge. But wait, the minimal t is 1. How?\n                # Wait, if the component is bipartite, then all cycles are even-length. To create an odd-length cycle, we need to add an edge between two nodes in the same partition. The minimal number of edges to add is 1, and the number of ways is C(s, 2), where s is the size of the larger partition.\n                # So in this case, for the component with sizes 1 and k, the minimal t is 1, and the number of ways is C(k, 2)\n                # Wait, but how? Let's think: the component is bipartite with partitions A and B. Suppose |A| = 1, |B| = k. To form an odd-length cycle, we need to connect two nodes in the same partition. Since A has only one node, we cannot connect two in A. So we need to connect two nodes in B. Adding such an edge would create a cycle of length (path from u to v via A's single node) + 1. Which is (length of path from u to v through A) + 1. Since the original path from u to v is even (since the graph is bipartite), adding an edge between u and v gives an odd-length cycle.\n                # So the number of ways is C(k, 2) for this component.\n                # So for the current component, if the min_size is 1, then the larger size is max(a, b), and the number of ways is C(max_size, 2)\n                # So in this case, for the component with a=1, b=k, the number of ways is C(k, 2)\n                # So in this code, for each component, we compute the number of ways as C(s, 2), where s is the size of the larger partition\n                s = max(a, b)\n                ways = s * (s - 1) // 2\n            else:\n                # min_size is the size of the smaller partition. We need to choose two nodes from it to connect.\n                # Because connecting two nodes in the same partition will create an odd-length cycle.\n                # The minimal t is 1, and the number of ways is C(min_size, 2)\n                ways = min_size * (min_size - 1) // 2\n            total_ways += ways\n    \n    print(f\"{min_t} {total_ways}\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 579,
        "completion_token_count": 1632,
        "thoughts_token_count": 1024
    }
}