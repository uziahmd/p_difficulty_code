{
    "start": 1758309278.6633656,
    "end": 1758309661.3948176,
    "start-formatted": "2025-09-20 04:14 KST",
    "end-formatted": "2025-09-20 04:21 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\nOkay, I need to solve this programming problem. Let's read the problem carefully.\n\nThe problem is about determining if there's a perfect matching between R Rebel spaceships and B bases such that no two connecting lines (from a spaceship to its assigned base) intersect. The input gives the coordinates of the spaceships and bases. The output is \"Yes\" or \"No\" based on whether such a matching exists.\n\nFirst, since R and B are up to 10, the numbers are small. So maybe trying all possible permutations is feasible. Because for R=B=10, the number of permutations is 10! which is around 3.6 million. That's manageable for a brute-force approach.\n\nBut how do I check if two line segments intersect? Oh right, the problem says that any two paths (lines) must not intersect. So for a given permutation (matching), I need to check that all pairs of line segments (spaceship to base) don't cross each other.\n\nSo the plan is:\n\n1. Check if R equals B. If not, output No immediately. Because a perfect matching requires R=B. Wait, the problem says \"every base has exactly one guardian and each spaceship has exactly one assigned base\". So yes, R must equal B. So first step: if R != B, output No.\n\nBut the input may have R and B not equal. For example, in the second sample input, it's 2 1. So output No. So the first check is to see if R and B are equal. If not, output No.\n\nSo that's the first condition. Then, for R = B, proceed.\n\nThen, generate all possible perfect matchings (permutations of the bases assigned to the spaceships). For each permutation, check if all the line segments between the spaceships and their assigned bases are non-intersecting.\n\nIf any permutation satisfies this condition, output Yes. Otherwise, No.\n\nNow, the key steps are:\n\n- Generate all permutations of the bases (since each spaceship must be matched to exactly one base, and each base to exactly one spaceship).\n\n- For each permutation, check all pairs of line segments to ensure they don't intersect.\n\nBut how to check if two line segments intersect?\n\nI need a function that takes two line segments (each defined by two points) and returns True if they intersect, False otherwise.\n\nBut how to implement that?\n\nThe standard approach is to use computational geometry. The steps to check if two line segments AB and CD intersect are:\n\n1. Check if the bounding boxes of AB and CD overlap. If not, they can't intersect. This is a quick rejection test.\n\n2. Use the orientation method. Compute the orientation of A, B, C; A, B, D; C, D, A; C, D, B. The segments AB and CD intersect if:\n\n   a. The orientations of (A,B,C) and (A,B,D) are different, and the orientations of (C,D,A) and (C,D,B) are different. (This is the case when the segments cross each other.)\n\n   b. Or, one of the endpoints lies on the other segment. For example, if C is colinear with AB and lies on AB, then they intersect.\n\nBut since the problem states that no three points are colinear. Wait, the note says that it is guaranteed that no two points coincide and no three points are on the same line. So, that simplifies things. Because, in this problem, any two line segments can't have endpoints lying on the same line. So, for two line segments AB and CD, if they are colinear, then they can't have overlapping points because all points are unique. But since no three points are colinear, the segments can't be colinear. So, the only possibility is that they cross each other, or not.\n\nWait, but the problem says that no three points are on the same line. So, for example, if AB is a segment and CD is another segment, then none of the four endpoints are colinear. So, the line segments can't be colinear. So the only way they can intersect is if they cross each other. Therefore, the intersection check can be done using the orientation-based method.\n\nSo, the function to check if two segments AB and CD intersect would be:\n\nCheck if the orientations of (A,B,C) and (A,B,D) are different, and the orientations of (C,D,A) and (C,D,B) are different. If so, then they intersect.\n\nBut how to compute the orientation? The orientation of three points p, q, r is determined by the cross product of vectors (q-p) and (r-p). The sign of the cross product tells us the orientation.\n\nThe orientation can be:\n\n- 0: colinear\n\n- 1: clockwise\n\n- 2: counterclockwise\n\nBut since the problem says that no three points are colinear, we can ignore",
    "response": "To solve this problem, we need to determine if there exists a perfect matching between Rebel spaceships and bases such that no two connecting line segments intersect. The solution involves checking all permutations of possible assignments and verifying the non-intersection condition using computational geometry.\n\n### Approach\n1. **Check Equality of Spaceships and Bases**: First, ensure the number of spaceships (R) equals the number of bases (B). If not, output \"No\".\n2. **Generate Permutations**: For each permutation of bases, consider it as a potential assignment of bases to spaceships.\n3. **Check Line Segment Intersections**: For each permutation, check if any pair of line segments (from spaceship to base) intersect. This is done using orientation checks based on cross products to determine if segments intersect.\n\n### Solution Code\n```python\nimport sys\nimport itertools\n\ndef read_input():\n    data = sys.stdin.read().split('\\n')\n    lines = [line.strip() for line in data if line.strip()]\n    return lines\n\ndef orientation(p, q, r):\n    val = (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0])\n    if val == 0:\n        return 0  # colinear\n    return 1 if val > 0 else 2  # clock or counterclock wise\n\ndef segments_intersect(a1, a2, b1, b2):\n    o1 = orientation(a1, a2, b1)\n    o2 = orientation(a1, a2, b2)\n    o3 = orientation(b1, b2, a1)\n    o4 = orientation(b1, b2, a2)\n\n    if o1 != o2 and o3 != o4:\n        return True\n    return False\n\ndef main():\n    lines = read_input()\n    idx = 0\n    R = int(lines[idx].split()[0])\n    B = int(lines[idx].split()[1])\n    idx += 1\n    rebels = []\n    for _ in range(R):\n        x, y = map(int, lines[idx].split())\n        rebels.append((x, y))\n        idx += 1\n    bases = []\n    for _ in range(B):\n        x, y = map(int, lines[idx].split())\n        bases.append((x, y))\n        idx += 1\n\n    if R != B:\n        print(\"No\")\n        return\n\n    from itertools import permutations\n\n    for perm in permutations(bases):\n        # Check all pairs of segments\n        intersect = False\n        for i in range(R):\n            for j in range(i+1, R):\n                a1 = rebels[i]\n                a2 = perm[i]\n                b1 = rebels[j]\n                b2 = perm[j]\n                if segments_intersect(a1, a2, b1, b2):\n                    intersect = True\n                    break\n            if intersect:\n                break\n        if not intersect:\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into coordinates for spaceships and bases.\n2. **Orientation Check**: The `orientation` function determines the orientation of three points using the cross product, which helps in checking if segments intersect.\n3. **Segment Intersection Check**: The `segments_intersect` function uses orientation checks to determine if two line segments intersect.\n4. **Permutations Check**: All permutations of bases are checked against spaceships. For each permutation, we ensure no two line segments intersect. If a valid permutation is found, \"Yes\" is printed; otherwise, \"No\" is printed after all permutations are checked.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport itertools\n\ndef read_input():\n    data = sys.stdin.read().split('\\n')\n    lines = [line.strip() for line in data if line.strip()]\n    return lines\n\ndef orientation(p, q, r):\n    val = (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0])\n    if val == 0:\n        return 0  # colinear\n    return 1 if val > 0 else 2  # clock or counterclock wise\n\ndef segments_intersect(a1, a2, b1, b2):\n    o1 = orientation(a1, a2, b1)\n    o2 = orientation(a1, a2, b2)\n    o3 = orientation(b1, b2, a1)\n    o4 = orientation(b1, b2, a2)\n\n    if o1 != o2 and o3 != o4:\n        return True\n    return False\n\ndef main():\n    lines = read_input()\n    idx = 0\n    R = int(lines[idx].split()[0])\n    B = int(lines[idx].split()[1])\n    idx += 1\n    rebels = []\n    for _ in range(R):\n        x, y = map(int, lines[idx].split())\n        rebels.append((x, y))\n        idx += 1\n    bases = []\n    for _ in range(B):\n        x, y = map(int, lines[idx].split())\n        bases.append((x, y))\n        idx += 1\n\n    if R != B:\n        print(\"No\")\n        return\n\n    from itertools import permutations\n\n    for perm in permutations(bases):\n        # Check all pairs of segments\n        intersect = False\n        for i in range(R):\n            for j in range(i+1, R):\n                a1 = rebels[i]\n                a2 = perm[i]\n                b1 = rebels[j]\n                b2 = perm[j]\n                if segments_intersect(a1, a2, b1, b2):\n                    intersect = True\n                    break\n            if intersect:\n                break\n        if not intersect:\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 485,
        "completion_token_count": 792,
        "thoughts_token_count": 1024
    }
}