{
    "start": 1758309271.9811227,
    "end": 1758309310.2379506,
    "start-formatted": "2025-09-20 04:14 KST",
    "end-formatted": "2025-09-20 04:15 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\nOkay, let's see. The problem is about determining if there's a perfect matching between Rebel spaceships and bases such that no two connecting lines intersect. Hmm. So the key here is to check for each possible perfect matching whether all the line segments between matched pairs are non-intersecting.\n\nFirst, I need to understand the constraints. Since R and B are up to 10, the total number of possible perfect matchings would be R! (since it's a bijection between R and B). For R=10, that's 3.6 million possibilities. Wait, but 10! is 3,628,800. For each of these possibilities, I need to check if all the line segments are non-intersecting. But how?\n\nSo the plan is:\n\n1. Generate all possible perfect matchings between the R spaceships and B bases. But wait, since R and B are equal (since the problem says \"every base has exactly one guardian and each spaceship has exactly one assigned base\"), so R must equal B. Wait, the input says R and B can be up to 10, but the problem says that it's possible only when R equals B? Because the first line says R and B, but the problem says that the assignment is a perfect matching. Oh right, the problem says that the input has R and B, but for a perfect matching to exist, R must equal B. Wait, but the input could have R != B. But according to the problem statement, the output is to check if there exists a perfect matching. So if R != B, the answer is automatically No. Wait, but the input constraints say that R and B are between 1 and 10. But the problem says that the assignment is a perfect matching. So in the code, first check if R != B. If they are not equal, output No. Otherwise, proceed.\n\nSo first step: check if R != B. If so, output No.\n\nOtherwise, generate all permutations of the B bases (since each spaceship is assigned to exactly one base). For each permutation, check if all the line segments between the i-th spaceship and the i-th base in the permutation do not intersect with each other.\n\nBut how to check if two line segments intersect?\n\nAh right, the problem says that any two paths (straight lines) should not intersect. So for a given matching, all the line segments between matched pairs must be non-intersecting. So for each pair of line segments in the matching, we need to check that they don't cross each other.\n\nSo the steps for the code:\n\n- Read R and B. If R != B, output No.\n- Else, read R spaceship coordinates, then B base coordinates.\n- Generate all possible permutations of the B bases (since each permutation represents a possible assignment of bases to spaceships).\n- For each permutation, check if all the line segments between spaceship i and base permutation[i] are non-intersecting.\n- If any permutation satisfies this condition, output Yes. Otherwise, No.\n\nNow, the challenge is to implement the line segment intersection check.\n\nBut how to check if two line segments AB and CD intersect?\n\nI remember that there's a standard computational geometry approach for this. The steps are:\n\n1. Check if the two segments AB and CD intersect by checking if the orientations of the points are such that they cross each other.\n\nBut I need to remember the exact conditions. Let me think.\n\nThe standard method involves checking the orientation of four points. The segments AB and CD intersect if:\n\na) The orientations of (A, B, C) and (A, B, D) are different, and the orientations of (C, D, A) and (C, D, B) are different. This is the case where the segments cross each other.\n\nOR\n\nb) One of the endpoints of a segment lies on the other segment. For example, if C is on AB, or D is on AB, etc. However, since the problem says that no three points are colinear, this case can't happen. Because if three points are colinear, then the problem states that it's not allowed. Wait, the problem says that no three points are on the same line. So in the input, all points are such that no three are colinear. Therefore, the case where a point lies on another segment is impossible. Because if, say, C is on AB, then A, B, and C are colinear, which is not allowed. Therefore, in our problem, the only way two segments can intersect is if they cross each other in the interior. Therefore, we can ignore the cases where endpoints are on the other segment.\n\nThus, for our problem, the check for two segments AB and CD is whether they cross each other, which can be determined by checking if the orientations of (A,B,C) and (A,B,D) are different, and the orientations of (C,D,A)",
    "response": "To solve this problem, we need to determine if there exists a perfect matching between Rebel spaceships and bases such that no two connecting line segments intersect. The solution involves checking all possible permutations of assignments and verifying the non-intersection condition using computational geometry principles.\n\n### Approach\n1. **Input Validation**: Check if the number of spaceships (R) and bases (B) are equal. If not, output \"No\" immediately.\n2. **Generate Permutations**: For each permutation of bases, consider it as a potential assignment to spaceships.\n3. **Check Line Segment Intersections**: For each permutation, check if all line segments between matched spaceships and bases intersect. This is done using orientation checks to determine if two line segments cross each other.\n\n### Solution Code\n```python\nimport sys\nimport itertools\n\ndef read_input():\n    input = sys.stdin.read().split('\\n')\n    lines = [line.strip() for line in input if line.strip()]\n    idx = 0\n    R, B = map(int, lines[idx].split())\n    idx += 1\n    rebels = []\n    for _ in range(R):\n        x, y = map(int, lines[idx].split())\n        rebels.append((x, y))\n        idx += 1\n    bases = []\n    for _ in range(B):\n        x, y = map(int, lines[idx].split())\n        bases.append((x, y))\n        idx += 1\n    return R, B, rebels, bases\n\ndef orientation(p, q, r):\n    val = (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0])\n    if val == 0:\n        return 0  # colinear\n    return 1 if val > 0 else 2  # clock or counterclock wise\n\ndef segments_intersect(a1, a2, b1, b2):\n    o1 = orientation(a1, a2, b1)\n    o2 = orientation(a1, a2, b2)\n    o3 = orientation(b1, b2, a1)\n    o4 = orientation(b1, b2, a2)\n\n    if o1 != o2 and o3 != o4:\n        return True\n    return False\n\ndef solve():\n    R, B, rebels, bases = read_input()\n    if R != B:\n        print(\"No\")\n        return\n    from itertools import permutations\n    for perm in permutations(bases):\n        intersect = False\n        for i in range(R):\n            for j in range(i+1, R):\n                a1 = rebels[i]\n                a2 = perm[i]\n                b1 = rebels[j]\n                b2 = perm[j]\n                if segments_intersect(a1, a2, b1, b2):\n                    intersect = True\n                    break\n            if intersect:\n                break\n        if not intersect:\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    solve()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into the number of spaceships (R), bases (B), their respective coordinates.\n2. **Orientation Check**: The `orientation` function determines the relative orientation of three points, which helps in checking if two line segments intersect.\n3. **Segment Intersection Check**: The `segments_intersect` function uses the orientation check to determine if two line segments intersect.\n4. **Permutation Check**: For each permutation of bases, we check all pairs of line segments to ensure no intersections. If a valid permutation is found, \"Yes\" is printed; otherwise, \"No\" is printed after all permutations are checked.\n\nThis approach ensures that we explore all possible assignments and efficiently check for intersections using geometric properties, ensuring correctness and handling all edge cases as specified.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport itertools\n\ndef read_input():\n    input = sys.stdin.read().split('\\n')\n    lines = [line.strip() for line in input if line.strip()]\n    idx = 0\n    R, B = map(int, lines[idx].split())\n    idx += 1\n    rebels = []\n    for _ in range(R):\n        x, y = map(int, lines[idx].split())\n        rebels.append((x, y))\n        idx += 1\n    bases = []\n    for _ in range(B):\n        x, y = map(int, lines[idx].split())\n        bases.append((x, y))\n        idx += 1\n    return R, B, rebels, bases\n\ndef orientation(p, q, r):\n    val = (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0])\n    if val == 0:\n        return 0  # colinear\n    return 1 if val > 0 else 2  # clock or counterclock wise\n\ndef segments_intersect(a1, a2, b1, b2):\n    o1 = orientation(a1, a2, b1)\n    o2 = orientation(a1, a2, b2)\n    o3 = orientation(b1, b2, a1)\n    o4 = orientation(b1, b2, a2)\n\n    if o1 != o2 and o3 != o4:\n        return True\n    return False\n\ndef solve():\n    R, B, rebels, bases = read_input()\n    if R != B:\n        print(\"No\")\n        return\n    from itertools import permutations\n    for perm in permutations(bases):\n        intersect = False\n        for i in range(R):\n            for j in range(i+1, R):\n                a1 = rebels[i]\n                a2 = perm[i]\n                b1 = rebels[j]\n                b2 = perm[j]\n                if segments_intersect(a1, a2, b1, b2):\n                    intersect = True\n                    break\n            if intersect:\n                break\n        if not intersect:\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    solve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 477,
        "completion_token_count": 812,
        "thoughts_token_count": 1024
    }
}