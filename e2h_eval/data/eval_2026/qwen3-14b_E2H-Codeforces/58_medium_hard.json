{
    "start": 1758313410.6353698,
    "end": 1758314703.112913,
    "start-formatted": "2025-09-20 05:23 KST",
    "end-formatted": "2025-09-20 05:45 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\nOkay, let's try to understand this problem. So, the task is to find the minimum number of edges to add to a given undirected graph so that there's a simple cycle of odd length (more than one vertex). Also, we need to count how many ways there are to do this with exactly that minimum number of edges.\n\nHmm. First, I remember that a graph is bipartite if and only if it doesn't contain any odd-length cycles. So if the graph already has an odd-length cycle, then t is 0, and w is 1? Wait, no. Because the problem says to find the minimum number of edges to add to form such a cycle. If the graph already contains such a cycle, then t is 0. But how many ways are there? Well, the answer would be 1 if there's at least one existing odd cycle. Wait, but maybe there are multiple existing odd cycles. But the problem says that when t is 0, the number of ways is the number of possible ways to choose edges that form an odd cycle. But no, wait. The problem says that the existing graph may have multiple odd cycles. But the question is about adding edges to form a cycle. So if the graph already has an odd cycle, then the answer is t=0 and w=1? Or maybe w is the number of existing odd cycles? Wait, no. Because the problem says that the way to add edges must form a cycle. But if the graph already contains such a cycle, then you don't need to add any edges. However, the question says that the answer w is the number of ways to add t edges. Since t is zero, that would mean the number of existing such cycles? But that's not correct. Because the problem says that the way to add edges is considered the same if they have the same set of added edges. But in this case, you're not adding any edges. So, the answer would be 1 if there exists at least one such cycle. Wait, but the problem says that the answer for the second example input is '0 1' when the input is a triangle (which is an odd cycle). So in that case, the output is 0 and 1. So that suggests that when the graph already contains an odd cycle, the answer is t=0 and w=1. But why 1? Because there's only one way to do nothing? Or perhaps the problem counts the number of possible ways to add edges (which is zero edges) such that the resulting graph has an odd cycle. But since the existing graph already has an odd cycle, the number of such ways is 1 (since you can choose to add zero edges). But why isn't it the number of existing odd cycles? Because the problem's note says that two ways are considered equal if they have the same set of added edges. So, if the original graph already has an odd cycle, then adding zero edges is the way. But how many such ways are there? Well, only one way, which is adding no edges. But regardless of how many existing cycles there are, the answer is 1? That seems to be the case based on the sample input.\n\nSo, the first thing to check is whether the graph already contains an odd-length cycle. If yes, then t=0 and w=1. Otherwise, we need to find the minimum number of edges to add.\n\nSo, the problem reduces to checking if the graph is bipartite. If it's not bipartite, then t is 0 and w is 1. Wait, no. Because if the graph is not bipartite, then it already contains an odd cycle. So that's the case where t=0 and w=1. So the first step is to check if the graph is bipartite. If it's not bipartite, then the answer is t=0, w=1.\n\nIf the graph is bipartite, then we need to find the minimum number of edges to add to create an odd cycle. How can that be done?\n\nWell, in a bipartite graph, all cycles are even-length. So adding edges to create an odd cycle. How?\n\nLet me think. For a bipartite graph, each connected component is bipartite. So each component can be divided into two parts, say A and B. Any edge connects a node in A to B.\n\nTo create an odd-length cycle, we need to connect two nodes in the same partition. Because if you have a path from u to v that goes through an even number of edges (so same partition), adding an edge between u and v would create a cycle of odd length (even + 1 = odd).\n\nSo, for each connected component, if we can find two nodes in the same partition (say, in the same part of the bipartition), adding an edge between them would create an odd cycle.\n\nBut what's the minimal number of edges needed? Let's see.\n\nSuppose the graph is bipartite. Then, the minimal number of edges to add is 1. Because if there's a connected component with at least two nodes in one of the partitions, then adding an edge between two nodes in the same partition would create an odd cycle.\n\nWait, but for that, the component must have at least two nodes in one partition. For example, if a component is a single node, then there's no way to add an edge. But if the component is a tree (like a single edge between two nodes), then the bipartition is {A, B} with A having one node and B having one node. Adding an edge between the two nodes would create a cycle of length 1? No, but that's not allowed. Wait, but in that case, the component is a single edge. Adding another edge between the same two nodes would create a parallel edge, which is prohibited. But the original graph doesn't have loops or parallel edges. So, for a connected component that's a tree (so bipartitioned into two sets), adding an edge between two nodes in the same partition would create a cycle. For example, if the component is two nodes connected by an edge. Then, the bipartition is {u} and {v}. Adding an edge between u and v would create a cycle of length 2 (but that's even). Wait, that's not helpful. Oh, but that's not possible. Because adding an edge between u and v would create a cycle of length 2 (the original edge and the new edge). But that's not a simple cycle. Wait, the problem says that the cycle must be simple. So, the cycle must have distinct vertices except for the starting and ending. So, a cycle of length 2 is not allowed because it would require two edges between the same pair of nodes, which is not allowed. So, in that case, adding an edge between u and v would not create a cycle. Wait, but the original graph has an edge between them. So adding another edge is prohibited. Therefore, for a component that is a tree with two nodes (connected by one edge), you can't add any edges that would create a cycle. So, how to form an odd cycle here?\n\nWait, but in that case, the component is bipartitioned into two parts, each of size 1. To create an odd cycle, you need to add an edge between two nodes in the same partition. But there are no two nodes in the same partition. So, you can't. Hence, you need to add edges between different components.\n\nWait, perhaps the minimal number of edges depends on the structure of the connected components. For example, if there are multiple connected components, each being bipartite.\n\nSo, the problem is: if the graph is bipartite, then the minimal number of edges to add is 1 if there exists a connected component with at least two nodes in one partition. Otherwise, if all connected components are single-node (n=1?), but that's impossible because n is the number of vertices. Wait, for example, if n is 3 and the graph is three separate nodes (no edges). Then, each component is a single node. Then, adding edges between two nodes would create a cycle of length 2 (if adding one edge, no cycle). Wait, adding one edge creates a tree, no cycle. To create a cycle, you need to add at least two edges. For example, adding edges between 1-2 and 1-3 would create a tree. But adding 1-2, 2-3, 1-3 would create a cycle of length 3 (odd). So, in that case, the minimal number of edges to add is 2 edges. But how?\n\nSo, the problem is more complex than I thought.\n\nLet me think again. The key is that the graph is bipartite. So, for each connected component, we can assign a bipartition (A and B). Now, to create an odd cycle, we need to add an edge between two nodes in the same partition. However, if a component has only one node (so A has one node, B has zero), then adding an edge between two nodes in the same partition is not possible. So, for a component with only one node, it's impossible. So, for the entire graph to be bipartite, but not have any odd cycles, we need to find a way to add edges that create an odd cycle.\n\nSo, the minimal number of edges to add depends on the number of connected components that have at least two nodes in their bipartition.\n\nWait, for example:\n\nCase 1: There is at least one connected component where the bipartition has at least two nodes in one of the partitions. Then, adding a single edge between two nodes in the same partition would create an odd cycle. So t=1.\n\nCase 2: All connected components have bipartitions of size 1 and 0 (i.e., single-node components). So, for example, if the graph is completely disconnected, and n >= 2. Then, how to create an odd cycle?\n\nIn that case, for example, if there are two components, each with one node. To create an odd cycle, you need to connect them in a way that forms a cycle. But with two nodes, you can't form a cycle. So you need to add three edges. Wait, but how?\n\nAlternatively, if there are three components, each with one node. Then, adding edges between them to form a triangle (three edges) creates a cycle of length 3. So, in this case, t=3.\n\nBut how to find the minimal t for this scenario?\n\nSo, the problem splits into two possibilities:\n\nIf the graph is bipartite, then:\n\n- Check if there exists a connected component that has at least two nodes. In that case, we can add one edge between two nodes in the same partition. So t=1.\n\n- Else, all components are single-node. Then, the minimal number of edges is 3 (to form a triangle). Because adding three edges between three nodes (each pair) forms a cycle of length 3. But how to compute this?\n\nWait, but if there are k components (each with one node), then the minimal number of edges to add is (k + 1) / 2? No, perhaps not. Let's think: for example, if there are k components, each being a single node. Then, to form a cycle of length 3, you need 3 nodes. So, if k >= 3, then you can take three nodes and add edges between them (three edges) to form a triangle. So t=3. But if k=2, then you can't form a cycle. So, you need to add two edges between the two nodes (but that's not possible as it would create a parallel edge). So, in that case, you need to add a third node. But if there are only two nodes, you can't form a cycle. So, in this case, the minimal number of edges is 3, but only if there are at least three nodes. Wait, but the problem says that the graph can have n vertices. So, for example, when n is 2, and the graph is empty (no edges), then you can't form a cycle. So, adding edges would require adding two edges between the two nodes, but that's not allowed. So, in this case, the problem says that the cycle must consist of more than one vertex. So, for n=2, the minimal number of edges to add is 2 (but that would form a cycle of length 2, which is even). But that's not acceptable. So, in this case, the answer is impossible? But according to the problem statement, the input is such that the graph is possible. Wait, but the problem says that the input can be any graph. So, for example, if the input is n=2, m=0, then the answer would be t=3? But that's impossible. Wait, but the problem requires that after adding edges, the graph has an odd-length cycle. So, for n=2, the minimal number of edges to add would be 3? But how?\n\nWait, no. For n=2, adding three edges is impossible. So, perhaps this case is handled in the following way: if the graph is bipartite and all components are single-node (so, n >= 1). Then, the minimal number of edges to add is 3 if n >= 3. Otherwise, if n=1, then it's impossible. But according to the problem statement, the graph has n vertices, and the output must be possible. However, the problem says that the graph is not necessarily connected. So, for example, when n=2 and m=0, the graph is bipartite. So, how can we form an odd-length cycle? We can't. Because adding any edges would create a cycle of length 2 (even) or not. Wait, adding one edge between the two nodes gives a tree (no cycle). Adding two edges between the two nodes is not allowed. So, for n=2 and m=0, the answer would be t=3? Which is impossible. But according to the problem statement, the input is such that the answer exists. But perhaps the problem allows that? Wait, the problem says that the graph may not be connected. So, for n=2, the answer is impossible? But the problem says that the output must be computed. So, perhaps there's a mistake in my reasoning.\n\nWait, let's re-examine the problem statement. It says that the graph is not necessarily connected, and that the answer must be found. So, the problem must have a solution for all inputs. For example, in the case where n=2 and m=0, the answer would be t=3? But that's impossible. However, perhaps the problem requires that the cycle is formed by adding edges. Let me think again.\n\nIn the case of n=2 and m=0, the graph is bipartite. So, to form an odd-length cycle, the minimal number of edges to add. Let's think: the cycle must have at least three vertices. But there are only two vertices. So, it's impossible. Therefore, the answer would be impossible. But the problem statement says that the input is given and the output must be computed. So, perhaps there's something wrong in my approach.\n\nWait, but the problem says that the cycle must consist of more than one vertex. So, the minimal cycle is of length 3 (triangle). So, for n=2, it's impossible to form such a cycle. But according to the problem's third example input, when n=3 and m=0, the output is '3 1'. Which makes sense: adding three edges to form a triangle. So, for that case, t=3.\n\nSo, in general, for a bipartite graph, if the graph is bipartite and has no existing odd cycles, then:\n\nCase 1: There exists a connected component with at least two nodes. Then, the minimal t is 1. Because adding an edge between two nodes in the same partition would create an odd cycle.\n\nCase 2: All connected components are single-node. Then, we need to add edges to form a cycle of length 3. So, the minimal t is 3 if n >=3, else impossible. But since the problem requires an answer, perhaps this case is handled by checking if n >= 3. If n >=3, then t=3 and w is the number of ways to choose three nodes and connect them into a triangle. But since the graph is empty (all components are single nodes), the number of ways is C(n, 3), but since adding three edges (each pair) would form a triangle. However, the problem says that the number of ways is the number of ways to add exactly t edges to form such a cycle.\n\nBut in this case, t=3. The number of ways is the number of possible triangles that can be formed by adding three edges. Each triangle is a set of three nodes, and adding all three edges between them. However, the problem states that adding edges must not create loops or parallel edges. So, for each possible triangle (set of three nodes), the number of ways is 1 (adding all three edges). So the total number of such ways is C(n, 3). But in the third example input, when n=3 and m=0, the output is '3 1', which matches this. So, in that case, there is exactly one way (the only possible triangle).\n\nSo, the steps for solving the problem are:\n\n1. Check if the graph already contains an odd-length cycle. If yes, then output t=0 and w=1.\n\n   How to check this? By checking if the graph is bipartite. If it is not bipartite, then there exists an odd-length cycle. So, t=0 and w=1.\n\n   But if the graph is bipartite, then proceed.\n\n2. If the graph is bipartite, then:\n\n   a. Check if there exists a connected component with at least two nodes. If yes, then t=1. Then, the number of ways w is the number of possible edges that can be added between two nodes in the same partition of any connected component.\n\n   Wait, but how to compute this?\n\n   For each connected component, during the bipartitioning, we can count the number of nodes in each partition. Let's say for a component, the partitions are A and B. Then, the number of possible edges that can be added between two nodes in A is C(|A|, 2), and similarly for B. Summing over all components gives the total number of possible edges to add. But since adding any of these edges would create an odd cycle, the minimal t is 1, and the number of ways is the sum of C(a_i, 2) + C(b_i, 2) for all components, where a_i and b_i are the sizes of the two partitions in component i.\n\n   Wait, but the problem says that the minimal number of edges is 1. So, the answer for t is 1, and w is the total number of possible edges that can be added between two nodes in the same partition across all components.\n\n   So, for example, in the first sample input:\n\nSample Input 1:\n\n4 4\n\nEdges: 1-2, 1-3, 2-4, 3-4.\n\nThe graph is bipartitioned? Let's see.\n\nLet me try to check if it's bipartite. Let's see:\n\nAssume the graph is connected. Let's check for bipartition.\n\nLet me consider the nodes. Let's take node 1. Assign color 0. Then its neighbors 2 and 3 must be color 1. Node 2 is connected to 4, so 4 is color 0. Node 3 is connected to 4, which is color 0. So node 3's color is 1, which is okay. So the bipartition is {1,4} and {2,3}. So for this component, |A|=2, |B|=2. So the number of possible edges to add is C(2,2) + C(2,2) = 1 + 1 = 2. Which matches the sample output of 1 2. So, that's correct.\n\nSo, in this case, the answer is t=1 and w=2.\n\nSo, this seems to fit.\n\nSo, the algorithm steps are:\n\n- Check if the graph is bipartite. If not, output 0 1.\n\n- Else:\n\n   - Check if there is at least one connected component with at least two nodes. If yes, then t=1 and w is the sum of (C(a_i, 2) + C(b_i, 2)) for all components, where a_i and b_i are the sizes of the two partitions of component i.\n\n   - Else, all components are single-node. Then:\n\n      - If n < 3, then it's impossible to form a cycle. But according to the problem's third example, when n=3 and m=0, the answer is 3 1. So, for n >=3, t=3 and w is C(n,3).\n\n      - But for n=1, it's impossible. However, the problem's input constraints say that n is the number of vertices. But the problem says that the graph can have m=0. So, for example, if n=1 and m=0, then the answer is impossible. But according to the problem statement, the input may have such cases. But according to the problem's note, the output must be computed. How to handle this?\n\nWait, the problem says that the cycle must consist of more than one vertex. So, for n=1, it's impossible. However, the input constraints for n are not given. Let's check the problem's input description: the first line has n and m. The constraints for n are not specified here, but in the sample input, the third case is 3 0, which outputs 3 1.\n\nSo, for the case when all components are single-node (so the graph has no edges, and n is the number of nodes):\n\nIf n == 1: then there's no way to form a cycle. But according to the problem's statement, the answer must exist. However, the problem says that the graph is allowed to have n=1. But in this case, the answer is impossible. However, the problem's third sample input is n=3 and m=0, which outputs t=3 and w=1. So, perhaps in the case when n=1, the answer is t=3 (but it's impossible). So, perhaps there's a mistake here. But according to the problem statement, the input is such that the answer exists. So, perhaps the problem ensures that n >= 2?\n\nBut the problem's input constraints do not specify that. So, perhaps the code needs to handle this case. However, the problem's sample input includes n=3, which works. Let's think about the case when n=1. Then, the answer is impossible. But according to the problem's output, we have to print t and w. How to handle this?\n\nBut according to the problem statement, the graph is allowed to have any n. However, the problem says that the answer must be found. So, perhaps the code should assume that n >= 2. But I'm not sure. However, given that the problem's third sample input is n=3, m=0, which outputs 3 1, which is correct. So, for the case where all components are single-node, and n >= 3, then t=3 and w is C(n,3). For n=2, the answer is impossible, but how to handle it?\n\nBut in the case of n=2 and all components are single-node (i.e., m=0), then the minimal number of edges to add is 3, but you can't form a cycle of length 3. Because you need three nodes. So, in this case, the answer is impossible. But the problem says that the output must be printed. So, perhaps the problem guarantees that the answer is possible. However, the problem's input may not have such cases. But how?\n\nAlternatively, perhaps the case when all components are single-node and n >= 3, then t=3 and w=C(n,3). For n=1, it's impossible, but perhaps the problem's input will not have such cases. Let's proceed under that assumption.\n\nSo, putting it all together:\n\nThe steps are:\n\nCheck if the graph is bipartite. If not, output 0 1.\n\nElse:\n\n   Check if there exists at least one connected component with size >=2.\n\n   If yes:\n\n      t = 1.\n\n      Compute the sum over all connected components of (number of pairs in partition A) + (number of pairs in partition B) for each component.\n\n      w = that sum.\n\n   Else:\n\n      if n >= 3:\n\n         t = 3\n\n         w = C(n, 3)\n\n      else:\n\n         ... ?\n\nBut for n=1, there's no way to form a cycle. However, the problem's input may not have such cases. Let's proceed with this logic.\n\nNow, how to implement this.\n\nFirst, we need to check if the graph is bipartite. For that, we can perform BFS or DFS for each connected component, trying to color the graph with two colors. If during this process, we find a conflict (a node that is already colored with the opposite color), then the graph is not bipartite.\n\nOnce we know the graph is bipartite, we need to process each connected component to find the sizes of the two partitions.\n\nFor each connected component, during the BFS/DFS, we can track the color of each node, and count the number of nodes in each color (partition).\n\nOnce we have that, for each component, we can calculate the number of possible edges that can be added between nodes in the same partition.\n\nSo, for each component, the contribution is (a * (a-1) // 2) + (b * (b-1) // 2), where a and b are the sizes of the two partitions.\n\nThen, sum all those contributions across all components. That gives the value of w when t=1.\n\nNow, for the case when all components are single-node. So, for each component, a=1 and b=0. So, their contribution is 0. So, the sum is zero. Thus, the code will check if there exists any component with size >=2. If not, then proceed to the else clause.\n\nSo, the code steps are:\n\nImplement a function to check if the graph is bipartite, and during that process, for each connected component, record the sizes of the two partitions.\n\nNow, let's think about the code structure.\n\nRead n and m.\n\nBuild adjacency list.\n\nInitialize color array (for bipartitioning). For each node, color[i] can be -1 (unvisited), 0, or 1.\n\nFor each unvisited node, perform BFS/DFS to check bipartition.\n\nIf during this process, any conflict is found, then the graph is not bipartite.\n\nElse, proceed.\n\nOnce we know the graph is bipartite, then:\n\nCheck if there exists any component with size >= 2.\n\nIf yes:\n\n   t = 1.\n\n   For each component, compute the number of pairs in each partition, sum all, that's w.\n\nElse:\n\n   if n >= 3:\n\n      t = 3\n\n      w = n * (n-1) * (n-2) // 6\n\n   else:\n\n      ... ?\n\nBut what if n=2 and all components are single-node (i.e., m=0). Then, the code would go into the else clause, and since n <3, but how to handle it? But according to the problem's third sample input, for n=3 and m=0, the answer is 3 1. So, for n=2 and m=0, the code would have to return t=3 and w=0 (since C(2,3)=0). But that's not possible. However, in this case, the code would output t=3 and w=0, which is incorrect. But perhaps the problem's input ensures that n >=3 when all components are single-node.\n\nBut how can that be? For example, if n=2 and m=0, then the code would proceed to the else clause, and since n <3, but there's no way to form a cycle. So, the code would output t=3 and w=0, but that's invalid. However, the problem's sample input for n=3 and m=0 outputs t=3 and w=1, which is correct. So, perhaps the code should assume that in the else clause, n >=3.\n\nBut how to handle that? Let's proceed under the assumption that the problem's input will not have such cases. Or perhaps, when n <3, the code returns t=3 and w=0, but that's not correct. However, given that the problem's third sample input has n=3, and the output is correct, perhaps that's the intended approach.\n\nBut for the problem's third sample input, which is n=3, m=0, the code would enter the else clause (all components are single-node), and compute t=3 and w= C(3,3) =1, which is correct.\n\nSo, the code can proceed as follows.\n\nNow, coding this in Python.\n\nFirst, read the input. Then build the adjacency list.\n\nThen, perform BFS/DFS to check bipartition and collect the sizes of the two partitions for each component.\n\nLet's code the bipartition check.\n\nInitialize color array as -1.\n\nFor each node from 1 to n:\n\n   if not visited (color is -1):\n\n      perform BFS.\n\n      assign color 0 to the node.\n\n      for each node in the queue, check its neighbors. For each neighbor, if not colored, assign the opposite color and add to queue. If already colored, check if it's the opposite color. If not, then the graph is not bipartite.\n\n      During this process, track the count of color 0 and color 1 for each component.\n\nOnce the bipartition is determined, check if the graph is bipartite.\n\nIf not bipartite, output 0 1.\n\nElse:\n\n   check if any component has size >= 2. How? For each component, the sum of a and b is the size of the component. So, for each component, if a + b >=2, then yes.\n\n   For example, a component with a=1 and b=1 has size 2. So, yes.\n\n   So, if any component has a + b >= 2, then yes.\n\n   So, during processing, collect all components' a and b counts.\n\n   So, during the BFS, for each component, store (a, b) as the counts of the two partitions.\n\n   Then, check if any component has a + b >= 2. If yes, then proceed to compute t=1 and w.\n\n   Else, all components are single-node. So, n must be the number of components (each with a=1, b=0).\n\n   Then, if n >=3, then t=3, w = C(n,3). Else, what?\n\nBut for n=1, the answer is impossible, but the problem's input may not include such cases.\n\nBut according to the problem's third sample input, when n=3 and m=0, the output is 3 1. Which is correct.\n\nSo, code:\n\nOnce the graph is bipartite:\n\ncomponents = list of (a, b) for each component.\n\nhas_large_component = any (a + b >= 2 for (a, b) in components)\n\nif has_large_component:\n\n   t = 1\n\n   w = sum( (a * (a-1) // 2) + (b * (b-1) // 2) for (a, b) in components )\n\nelse:\n\n   if n >=3:\n\n      t =3\n\n      w = n * (n-1) * (n-2) // 6\n\n   else:\n\n      # impossible? but what to output?\n\n      # but for n=1, the answer is impossible. However, according to the problem statement, the output must be given. But perhaps the input will not have such cases.\n\n      # For example, if n=1, then the answer is t=3, but it's impossible. However, the code will output t=3 and w=0. But this is incorrect.\n\n      # However, given the problem's sample input, perhaps the code can proceed with this logic.\n\n      # For the code, perhaps assume that n >=3 in this case.\n\nBut how to handle it?\n\nBut for the problem's test cases, perhaps the code will pass. Let's proceed.\n\nNow, code:\n\nImplement the BFS.\n\nNow, code:\n\nRead n and m.\n\nadj = [[] for _ in range(n+1)]\n\nfor _ in range(m):\n\n   u, v = map(int, input().split())\n\n   adj[u].append(v)\n\n   adj[v].append(u)\n\ncolor = [-1] * (n+1)\n\ncomponents = []\n\nis_bipartite = True\n\nfor u in range(1, n+1):\n\n   if color[u] == -1:\n\n      # start BFS\n\n      queue = deque()\n\n      queue.append(u)\n\n      color[u] = 0\n\n      a = 0\n\n      b = 0\n\n      if color[u] == 0:\n\n          a +=1\n\n      else:\n\n          b +=1\n\n      while queue:\n\n          current = queue.popleft()\n\n          for neighbor in adj[current]:\n\n              if color[neighbor] == -1:\n\n                  color[neighbor] = 1 - color[current]\n\n                  if color[neighbor] == 0:\n\n                      a +=1\n\n                  else:\n\n                      b +=1\n\n                  queue.append(neighbor)\n\n              else:\n\n                  if color[neighbor] == color[current]:\n\n                      is_bipartite = False\n\n      components.append( (a, b) )\n\nWait, no. Because during BFS, the initial code for counting a and b is incorrect. Because when u is added to the queue, we set its color to 0, and increment a. But the code above is inside the loop. Wait, the code is written as:\n\nInitially, for u, color[u] is set to 0, and then a is incremented by 1. Then, during BFS processing, when a neighbor is added, we check its color and increment a or b accordingly.\n\nBut this code is not correct. Because the initial code for a and b is initialized to 0. Then, when u is processed, we check color[u] and increment a or b. But in the code above, after setting color[u] to 0, the code checks if color[u] is 0 and increments a by 1. However, the initial code for a and b is set to 0. Then, after setting color[u] to 0, the code does:\n\nif color[u] == 0:\n\n   a +=1 ?\n\nBut that's not correct. Because the code initializes a and b as 0, then for u, which is color 0, adds 1 to a. Then, during BFS, when processing neighbors, for each neighbor that is colored, we check their color and increment a or b accordingly. But this code is not correct. Because the initial code for a and b is set to 0, then for u, which is colored 0, a is incremented by 1. But during the BFS processing, the code adds the neighbors and increments a or b based on their color. However, this code is not tracking the counts correctly. Because the initial a and b counts are for the current component.\n\nWait, the code should track the count of nodes in each color for the current component. So, during BFS, for each node processed, we can count how many are in color 0 and color 1.\n\nSo, the correct approach is:\n\nWhen starting a new component, initialize a and b to 0.\n\nSet color[u] = 0, increment a by 1.\n\nThen, for each node in the queue, process their neighbors. For each neighbor, if not colored, assign color, and increment a or b accordingly.\n\nBut the code above is missing this. Let me rework that.\n\nLet me rewrite the code for the BFS part:\n\nfor u in 1..n:\n\n   if color[u] == -1:\n\n      queue = deque()\n\n      queue.append(u)\n\n      color[u] = 0\n\n      a = 1\n\n      b = 0\n\n      while queue not empty:\n\n          current = queue.popleft()\n\n          for neighbor in adj[current]:\n\n              if color[neighbor] == -1:\n\n                  color[neighbor] = 1 - color[current]\n\n                  if color[neighbor] == 0:\n\n                      a += 1\n\n                  else:\n\n                      b += 1\n\n                  queue.append(neighbor)\n\n              else:\n\n                  if color[neighbor] == color[current]:\n\n                      is_bipartite = False\n\n      components.append( (a, b) )\n\nWait, but this code would miss the case where the neighbor is already colored, but that's handled in the else clause. However, during the BFS, the code may not check all the edges. For example, if the neighbor is already colored, but the color is different, then it's okay. But if it's same, then the graph is not bipartite.\n\nBut in the code above, the check for color[neighbor] == color[current] is done, but the code may not check all edges. Because during BFS, for each neighbor, we check if it's colored. If not, we color it. But if it is colored, we check if the color is same as current. However, this may not catch all conflicts, because during BFS, the same edge may be checked multiple times. For example, when processing a node, we check its neighbor, and if that neighbor is already processed, but the color is same as current, then the graph is not bipartite. However, this check may be done multiple times. However, once is_bipartite is set to False, the code can continue processing, but the result is already known.\n\nBut for the purpose of checking bipartition, the code is correct.\n\nBut the code for counting a and b is not correct. Because in the code above,",
    "response": "To solve this problem, we need to determine the minimum number of edges required to form an odd-length cycle in an undirected graph and count the number of ways to achieve this. The solution involves checking if the graph is bipartite and then determining the necessary steps based on that check.\n\n### Approach\n1. **Check Bipartiteness**: A graph is bipartite if it can be colored using two colors such that no two adjacent nodes share the same color. If a graph is not bipartite, it already contains an odd-length cycle, so the answer is 0 edges and 1 way.\n2. **Component Analysis**: If the graph is bipartite, analyze each connected component to determine the number of nodes in each partition (color group).\n3. **Determine Minimum Edges**:\n   - If there exists at least one component with more than one node, the minimum number of edges needed to form an odd-length cycle is 1. The number of ways to add such edges is calculated by considering all possible edges within each partition.\n   - If all components are single-node components and there are at least three nodes, the minimum number of edges needed is 3 (to form a triangle), and the number of ways is the combination of choosing three nodes from the total.\n\n### Solution Code\n```python\nimport sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    m = int(input[ptr])\n    ptr += 1\n\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u = int(input[ptr])\n        ptr += 1\n        v = int(input[ptr])\n        ptr += 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    color = [-1] * (n + 1)\n    components = []\n    is_bipartite = True\n\n    for u in range(1, n + 1):\n        if color[u] == -1:\n            queue = deque()\n            queue.append(u)\n            color[u] = 0\n            a = 1\n            b = 0\n            while queue:\n                current = queue.popleft()\n                for neighbor in adj[current]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - color[current]\n                        if color[neighbor] == 0:\n                            a += 1\n                        else:\n                            b += 1\n                        queue.append(neighbor)\n                    else:\n                        if color[neighbor] == color[current]:\n                            is_bipartite = False\n            components.append((a, b))\n\n    if not is_bipartite:\n        print(\"0 1\")\n        return\n\n    has_large = False\n    for (a, b) in components:\n        if a + b >= 2:\n            has_large = True\n            break\n\n    if has_large:\n        total_ways = 0\n        for (a, b) in components:\n            total_ways += (a * (a - 1)) // 2 + (b * (b - 1)) // 2\n        print(f\"1 {total_ways}\")\n    else:\n        if n >= 3:\n            w = n * (n - 1) * (n - 2) // 6\n            print(f\"3 {w}\")\n        else:\n            print(\"3 0\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and stored in an adjacency list representation of the graph.\n2. **Bipartite Check**: Using BFS, each connected component is checked for bipartiteness. If any conflict is found during coloring, the graph is not bipartite.\n3. **Component Analysis**: For each connected component, the sizes of the two partitions (color groups) are recorded.\n4. **Result Calculation**:\n   - If the graph is not bipartite, it already contains an odd-length cycle, so the result is `0 1`.\n   - If the graph is bipartite and has at least one component with more than one node, the result is calculated based on possible intra-partition edges.\n   - If all components are single-node and there are at least three nodes, the result is based on forming a triangle with three edges.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    m = int(input[ptr])\n    ptr += 1\n\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u = int(input[ptr])\n        ptr += 1\n        v = int(input[ptr])\n        ptr += 1\n        adj[u].append(v)\n        adj[v].append(u)\n\n    color = [-1] * (n + 1)\n    components = []\n    is_bipartite = True\n\n    for u in range(1, n + 1):\n        if color[u] == -1:\n            queue = deque()\n            queue.append(u)\n            color[u] = 0\n            a = 1\n            b = 0\n            while queue:\n                current = queue.popleft()\n                for neighbor in adj[current]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - color[current]\n                        if color[neighbor] == 0:\n                            a += 1\n                        else:\n                            b += 1\n                        queue.append(neighbor)\n                    else:\n                        if color[neighbor] == color[current]:\n                            is_bipartite = False\n            components.append((a, b))\n\n    if not is_bipartite:\n        print(\"0 1\")\n        return\n\n    has_large = False\n    for (a, b) in components:\n        if a + b >= 2:\n            has_large = True\n            break\n\n    if has_large:\n        total_ways = 0\n        for (a, b) in components:\n            total_ways += (a * (a - 1)) // 2 + (b * (b - 1)) // 2\n        print(f\"1 {total_ways}\")\n    else:\n        if n >= 3:\n            w = n * (n - 1) * (n - 2) // 6\n            print(f\"3 {w}\")\n        else:\n            print(\"3 0\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 578,
        "completion_token_count": 929,
        "thoughts_token_count": 8192
    }
}