{
    "start": 1758309280.9881768,
    "end": 1758309523.820171,
    "start-formatted": "2025-09-20 04:14 KST",
    "end-formatted": "2025-09-20 04:18 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\nOkay, let's tackle this problem. So the task is to determine if there's a perfect matching between R rebel spaceships and B bases such that no two connecting lines (from a spaceship to its assigned base) intersect. And since R and B are up to 10, maybe we can check all possible matchings?\n\nFirst, I need to understand the constraints. The problem says that any two paths (lines) shouldn't intersect. So for any two pairs (ship1 → base1) and (ship2 → base2), the line segments between them must not cross each other.\n\nBut how do I check that? Well, for a given matching, I need to check all pairs of line segments and ensure none intersect.\n\nSo the plan is:\n\n1. Generate all possible perfect matchings between the R ships and B bases. Since R and B are up to 10, but for a perfect matching, R must equal B. Wait, the input says R and B can be up to 10. But the first line says R and B. Oh, but the problem says that every base has exactly one guardian and each spaceship has exactly one assigned base. So that implies that R must equal B. Otherwise, there's no perfect matching. So first check if R != B, then output No. Otherwise, proceed.\n\nWait, the input says that for the first example, R and B are both 3. So the first thing in the code is to check if R equals B. If not, immediately output No.\n\nSo step 0: Check if R != B. If so, output No.\n\nOtherwise, proceed.\n\nNow, for R = B, we need to generate all possible permutations of the bases (since each spaceship is assigned to a unique base). For example, if there are R ships and R bases, then each permutation represents a possible assignment. For each permutation, check if all the line segments between ship i and base permutation[i] (or whatever the index mapping is) do not intersect with each other.\n\nBut how to check if two line segments intersect?\n\nI remember that there's a computational geometry algorithm to check if two line segments intersect. Let me recall.\n\nThe standard approach is to check if the two segments intersect by checking:\n\n- The orientation of the four points (the endpoints of the two segments) to see if they form a proper intersection.\n\nBut since the problem states that no three points are colinear, that might simplify things. Because if two segments are colinear, then they would have overlapping points, but since all points are unique and no three are colinear, perhaps that's not a case here. Wait, but the problem says that no three points are on the same line. So any two line segments that are part of the same line would have their endpoints on that line. But since no three points are colinear, that would mean that any two line segments that are colinear would have to be between two pairs of points. However, since all points are distinct, but the line segments could be overlapping. For example, if two segments share a common point, but that's allowed as long as they don't cross. Wait, but the problem says that the paths (segments) should not intersect. So even if two segments share an endpoint (like if two different pairs have a common point), that's allowed? Or does the problem consider that as intersecting?\n\nWait, the problem says \"any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D)\". So, if two paths share an endpoint, that's allowed. Because the endpoints are the actual points (spaceship or base). But if two segments cross each other (even at a point that's not an endpoint), that's not allowed.\n\nSo, for two line segments AB and CD, they are considered to intersect if they cross each other (i.e., their interiors intersect) or if they share an endpoint. Wait, no. Because if two segments share an endpoint, like AB and AC, then they meet at A, but that's not considered as crossing. However, the problem says that the paths shouldn't intersect. So maybe the problem considers that even touching at a point (other than the endpoints) is forbidden? Or perhaps the problem considers that the segments must be non-crossing, but can share endpoints.\n\nBut according to the note in the problem statement, in the first example, connecting in order is acceptable. So perhaps the problem allows the segments to share endpoints. But how to check for intersection.\n\nIn computational geometry, the standard line segment intersection check includes whether the segments cross each other (properly intersect) or whether they share an endpoint. However, the problem says that the paths shouldn't intersect. So, if two paths share an endpoint (like if two different assignments have a spaceship connected to two different bases, but that's impossible because each spaceship is assigned to exactly one base. Wait, no. Each spaceship is assigned to exactly one",
    "response": "To solve this problem, we need to determine if there exists a perfect matching between Rebel spaceships and bases such that no two connecting line segments intersect. The approach involves checking all possible permutations of assignments and verifying the non-intersecting condition for each permutation.\n\n### Approach\n1. **Check for Equal Numbers**: First, ensure the number of spaceships (R) is equal to the number of bases (B). If not, output \"No\".\n2. **Generate Permutations**: For each permutation of bases, check if it can be matched with the spaceships such that no two line segments intersect.\n3. **Line Segment Intersection Check**: For each permutation, verify that no two line segments formed by the spaceship and base pairs intersect using computational geometry principles.\n\n### Solution Code\n```python\nimport sys\nimport itertools\n\ndef read_input():\n    input_str = sys.stdin.read().strip()\n    inputs = input_str.split('\\n')\n    R, B = map(int, inputs[0].split())\n    ships = []\n    for i in range(1, R+1):\n        x, y = map(int, inputs[i].split())\n        ships.append((x, y))\n    bases = []\n    for i in range(R+1, R+B+1):\n        x, y = map(int, inputs[i].split())\n        bases.append((x, y))\n    return R, B, ships, bases\n\ndef orientation(p, q, r):\n    val = (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0])\n    if val == 0:\n        return 0  # colinear\n    return 1 if val > 0 else 2  # clock or counterclock wise\n\ndef on_segment(p, q, r):\n    if min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and min(p[1], r[1]) <= q[1] <= max(p[1], r[1]):\n        return True\n    return False\n\ndef segments_intersect(seg1, seg2):\n    p1, q1 = seg1\n    p2, q2 = seg2\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    if o1 != o2 and o3 != o4:\n        return True\n\n    if o1 == 0 and on_segment(p1, p2, q1):\n        return True\n    if o2 == 0 and on_segment(p1, q2, q1):\n        return True\n    if o3 == 0 and on_segment(p2, p1, q2):\n        return True\n    if o4 == 0 and on_segment(p2, q1, q2):\n        return True\n\n    return False\n\ndef main():\n    R, B, ships, bases = read_input()\n    if R != B:\n        print(\"No\")\n        return\n\n    from itertools import permutations\n\n    for perm in permutations(bases):\n        all_segments = []\n        for i in range(R):\n            ship = ships[i]\n            base = perm[i]\n            all_segments.append((ship, base))\n        valid = True\n        for i in range(len(all_segments)):\n            for j in range(i+1, len(all_segments)):\n                seg1 = all_segments[i]\n                seg2 = all_segments[j]\n                if segments_intersect(seg1, seg2):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into spaceships and bases coordinates.\n2. **Orientation Check**: This helper function determines the orientation of three points to check if they are collinear or form a clockwise/counterclockwise turn.\n3. **Segment Intersection Check**: This function checks if two line segments intersect using orientation checks and segment containment.\n4. **Permutations Check**: All permutations of bases are generated, and for each permutation, we check if the corresponding line segments between spaceships and bases intersect. If any permutation is found without intersections, \"Yes\" is printed; otherwise, \"No\" is printed after checking all permutations.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport itertools\n\ndef read_input():\n    input_str = sys.stdin.read().strip()\n    inputs = input_str.split('\\n')\n    R, B = map(int, inputs[0].split())\n    ships = []\n    for i in range(1, R+1):\n        x, y = map(int, inputs[i].split())\n        ships.append((x, y))\n    bases = []\n    for i in range(R+1, R+B+1):\n        x, y = map(int, inputs[i].split())\n        bases.append((x, y))\n    return R, B, ships, bases\n\ndef orientation(p, q, r):\n    val = (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0])\n    if val == 0:\n        return 0  # colinear\n    return 1 if val > 0 else 2  # clock or counterclock wise\n\ndef on_segment(p, q, r):\n    if min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and min(p[1], r[1]) <= q[1] <= max(p[1], r[1]):\n        return True\n    return False\n\ndef segments_intersect(seg1, seg2):\n    p1, q1 = seg1\n    p2, q2 = seg2\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    if o1 != o2 and o3 != o4:\n        return True\n\n    if o1 == 0 and on_segment(p1, p2, q1):\n        return True\n    if o2 == 0 and on_segment(p1, q2, q1):\n        return True\n    if o3 == 0 and on_segment(p2, p1, q2):\n        return True\n    if o4 == 0 and on_segment(p2, q1, q2):\n        return True\n\n    return False\n\ndef main():\n    R, B, ships, bases = read_input()\n    if R != B:\n        print(\"No\")\n        return\n\n    from itertools import permutations\n\n    for perm in permutations(bases):\n        all_segments = []\n        for i in range(R):\n            ship = ships[i]\n            base = perm[i]\n            all_segments.append((ship, base))\n        valid = True\n        for i in range(len(all_segments)):\n            for j in range(i+1, len(all_segments)):\n                seg1 = all_segments[i]\n                seg2 = all_segments[j]\n                if segments_intersect(seg1, seg2):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 486,
        "completion_token_count": 957,
        "thoughts_token_count": 1024
    }
}