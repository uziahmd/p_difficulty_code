{
    "start": 1758313518.7635624,
    "end": 1758314772.3419535,
    "start-formatted": "2025-09-20 05:25 KST",
    "end-formatted": "2025-09-20 05:46 KST",
    "gpu": 2,
    "pid": 44,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Polycarp's Practice\n\nPolycarp is practicing his problem solving skill. He has a list of $$$n$$$ problems with difficulties $$$a_1, a_2, \\dots, a_n$$$, respectively. His plan is to practice for exactly $$$k$$$ days. Each day he has to solve at least one problem from his list. Polycarp solves the problems in the order they are given in his list, he cannot skip any problem from his list. He has to solve all $$$n$$$ problems in exactly $$$k$$$ days.Thus, each day Polycarp solves a contiguous sequence of (consecutive) problems from the start of the list. He can't skip problems or solve them multiple times. As a result, in $$$k$$$ days he will solve all the $$$n$$$ problems.The profit of the $$$j$$$-th day of Polycarp's practice is the maximum among all the difficulties of problems Polycarp solves during the $$$j$$$-th day (i.e. if he solves problems with indices from $$$l$$$ to $$$r$$$ during a day, then the profit of the day is $$$\\max\\limits_{l \\le i \\le r}a_i$$$). The total profit of his practice is the sum of the profits over all $$$k$$$ days of his practice.You want to help Polycarp to get the maximum possible total profit over all valid ways to solve problems. Your task is to distribute all $$$n$$$ problems between $$$k$$$ days satisfying the conditions above in such a way, that the total profit is maximum.For example, if $$$n = 8, k = 3$$$ and $$$a = [5, 4, 2, 6, 5, 1, 9, 2]$$$, one of the possible distributions with maximum total profit is: $$$[5, 4, 2], [6, 5], [1, 9, 2]$$$. Here the total profit equals $$$5 + 6 + 9 = 20$$$.\n\n## Input\nThe first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\le k \\le n \\le 2000$$$) — the number of problems and the number of days, respectively.The second line of the input contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le 2000$$$) — difficulties of problems in Polycarp's list, in the order they are placed in the list (i.e. in the order Polycarp will solve them).\n\n## Output\nIn the first line of the output print the maximum possible total profit.In the second line print exactly $$$k$$$ positive integers $$$t_1, t_2, \\dots, t_k$$$ ($$$t_1 + t_2 + \\dots + t_k$$$ must equal $$$n$$$), where $$$t_j$$$ means the number of problems Polycarp will solve during the $$$j$$$-th day in order to achieve the maximum possible total profit of his practice.If there are many possible answers, you may print any of them.\n\n## Example\n### Input\n['8 3\\n5 4 2 6 5 1 9 2', '5 1\\n1 1 1 1 1', '4 2\\n1 2000 2000 2']\n\n### Output\n['20\\n3 2 3', '1\\n5', '4000\\n2 2']\n\n## Note\nThe first example is described in the problem statement.In the second example there is only one possible distribution.In the third example the best answer is to distribute problems in the following way: $$$[1, 2000], [2000, 2]$$$. The total profit of this distribution is $$$2000 + 2000 = 4000$$$.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\nOkay, I need to solve this programming problem. Let's read the problem statement carefully.\n\nSo, Polycarp has a list of n problems with difficulties a_1 to a_n. He wants to practice for exactly k days. Each day he solves at least one problem, and he must solve all problems in exactly k days. The way he does it is by splitting the list into k contiguous parts. For each day, the profit is the maximum difficulty of the problems solved that day. The total profit is the sum of these daily profits. Our task is to maximize this total profit and output the maximum value along with the distribution of the number of problems per day.\n\nHmm. So the challenge is to find the optimal way to split the array into k contiguous segments such that the sum of the maxima of each segment is maximized.\n\nLet me think about the approach. Since n can be up to 2000 and k up to 2000, we need an efficient solution. A brute-force approach would be too slow.\n\nDynamic programming seems like a possible approach here. Let's consider DP[i][j], which represents the maximum total profit for the first i problems split into j days.\n\nThe base case would be DP[0][0] = 0, but maybe we need to adjust indices. Let's think: For DP[i][j], how do we compute it?\n\nTo compute DP[i][j], we need to consider all possible positions m where the j-th day starts. For example, the j-th day could consist of the problems from m+1 to i. Then, the maximum for that day is max(a[m+1..i]), and we add that to DP[m][j-1].\n\nSo the recurrence would be:\n\nDP[i][j] = max(DP[m][j-1] + max(a[m+1..i])) for all m from j-1 to i-1.\n\nBut calculating the max for each possible m and i would take O(n^3) time if done naively. Because for each i and j, and for each m, we have to calculate the max of a subarray. For n=2000, that's way too slow.\n\nWait, but n is 2000, and k is up to 2000. So O(n^2 *k) would be 2000^3 = 8e10 operations. That's way too big. So this approach isn't feasible unless optimized.\n\nWe need to find a way to compute the max values efficiently. Let's think about precomputing max values for ranges. For example, precompute a 2D array max_range[i][j], which is the maximum value from a[i] to a[j]. But even that would take O(n^2) space, which for 2000 is 4 million entries. That's manageable.\n\nBut even then, the DP step would be O(n^2 *k) time. For n=2000 and k=2000, that's 8e10 again. Which is not feasible.\n\nWait, but maybe k can't be larger than n. Since k is between 1 and n. For example, when k is equal to n, each day has exactly one problem. Then the total profit is sum of all elements. But for other cases, perhaps there's a way to optimize the DP.\n\nAlternatively, maybe we can find that for some constraints on k, the problem can be optimized. For example, when k is small, but for the worst case, it's still O(n^2 *k).\n\nWait, but n is 2000. Let's see: for n=2000 and k=2000, the DP approach would be O(n^2 *k) = 2000^3 = 8e10 operations. That's way too slow. So this approach isn't feasible. Therefore, I need to think of another way.\n\nAlternatively, perhaps there's a way to optimize the DP transition. For example, for each i and j, when computing DP[i][j], can we find the best m quickly?\n\nAnother idea: For each j, when building DP[i][j], we can iterate over m from (j-1) to i-1. However, for each m, we need the max of a[m+1 ... i]. How can we compute this efficiently?\n\nWe can precompute the range maxima using a sparse table or some other structure. However, during the DP transitions, for each i and m, we can compute the max in O(1) time if we have a precomputed max_range array.\n\nSo let's precompute max_range[i][j], which is the maximum value between index i and j (assuming 0-based or 1-based). How to compute that? Well, for each i, we can compute the max for j >=i as follows. For each i, we can keep track of the current max as we expand j from i to n-1. This would take O(n^2) time and space, which is acceptable for n=2000 (since 2000^2 is 4 million).\n\nOnce we have this, then during the DP step, for each i and j, and for each possible m, we can get the max in O(1) time.\n\nBut even with that, the DP approach would be O(k * n^2) time. For n=2000 and k=2000, that's 8e10 operations. Which is way too slow.\n\nWait, but what is the maximum possible value of k? It's n. So for k=2000 and n=2000, the DP approach is O(2000 * 2000^2) = O(8e10), which is way beyond acceptable for Python. So this approach is not feasible.\n\nHmm. So perhaps there's a smarter way. Let me think again.\n\nWhat's the structure of the problem? We need to split the array into k contiguous parts, each part contributing their maximum. The sum of these maxima should be as large as possible.\n\nLet me think about the case when k is 1. Then the answer is simply the maximum of the entire array.\n\nWhen k is n, the answer is the sum of all elements.\n\nFor other values of k, perhaps the optimal way is to split the array such that each split takes the maximum elements as much as possible.\n\nBut how?\n\nAnother observation: Each time you split into more days, you can potentially capture more maxima. For example, if you have a very high value in the array, you want to split so that it is in its own day, so that it contributes once. But if you have multiple high values, you can split them into separate days.\n\nBut how to model this.\n\nWait, but for the maximum total profit, we need to maximize the sum of maxima. So, for example, if there are multiple high values, it's better to have each of them in their own day, because that way they each contribute once. However, if you have overlapping ranges, you might have to make trade-offs.\n\nBut how to model that in code.\n\nAlternative approach: For each day, the maximum of that day's segment is added. So, the problem is similar to partitioning the array into k segments, where each segment contributes its maximum. The goal is to maximize the sum of these maxima.\n\nThis feels similar to some classic dynamic programming problems. Let me think again about the DP approach.\n\nLet me think about the DP[i][j] as the maximum total profit for the first i elements divided into j days.\n\nThe recurrence is DP[i][j] = max(DP[m][j-1] + max(a[m+1..i])) for m from j-1 to i-1.\n\nBut with n=2000 and k=2000, this is not feasible.\n\nBut maybe the constraints are not that bad. Let's think: For n=2000 and k=2000, the DP[i][j] would only be valid when i >= j. For example, for j=2000, i must be 2000, and the only possible split is m=1999, etc. So perhaps in practice, the number of operations is O(n^2) when k is small, but when k approaches n, the DP becomes manageable.\n\nBut even so, for n=2000 and k=2000, the DP would have O(n^2) steps. Wait, no. For each j from 1 to k, and for each i from j to n, we have to compute DP[i][j]. For j=1, i can be 1 to n. For j=2, i can be 2 to n. For j=k, i can be k to n. So the total number of DP states is O(nk). For each state, the transition requires O(i) steps (for m from j-1 to i-1). So the total time complexity is O(n^2k). Which for n=2000 and k=2000 is 8e10 operations. Which is way too slow for Python.\n\nThus, this approach is not feasible. Need to find a better way.\n\nAlternative idea: Maybe for each position i and j, the optimal m is somewhere specific. For example, when adding the j-th day, the optimal split is to take the last day as a segment ending at i, and the maximum of that segment is a[i], but that's not necessarily true.\n\nAlternatively, considering that the maximum of a segment [m+1..i] is the maximum between the previous maximum and a[i]. So perhaps we can find a way to compute DP[i][j] efficiently by keeping track of the maximum as we increase m.\n\nWait, for a fixed j and i, when considering m from (j-1) to i-1, the max of a[m+1..i] can be computed incrementally. For example, for m from i-1 down to j-1, the max for [m+1..i] can be tracked as we move m leftwards.\n\nLet me think. Suppose I'm trying to compute DP[i][j]. For each possible m (split point), the segment for day j is from m+1 to i. The max of this segment is max(a[m+1..i]).\n\nIf I iterate m from i-1 down to j-1, then for each m, the segment [m+1..i] is [m+1..i-1] plus a[i]. So the max is max(prev_max, a[i]).\n\nSo for each i and j, we can compute the max in O(1) time per m, by keeping track of the current maximum as we move m from i-1 down to j-1.\n\nThis would reduce the time for each DP[i][j] from O(i) to O(i), but with a better constant factor.\n\nBut even with that, the overall time complexity remains O(n^2k), which is still too slow for n=2000 and k=2000.\n\nBut maybe in practice, the constraints for the problem are not so tight. Let's see:\n\nFor n=2000, and k=2000, the total number of DP states is O(nk) = 2000*2000=4e6. For each state, the computation is O(i - (j-1)) steps. For j=2000, i must be 2000. Then m ranges from 1999 to 1999, which is one step. For j=1999, i can be 1999 to 2000. For i=1999, m ranges from 1998 to 1998 (one step). For i=2000, m ranges from 1998 to 1999 (two steps). So for higher j's, the number of steps per state is small.\n\nBut for j=1, i can be up to 2000. For each i, we need to process m from 0 to i-1. For i=2000, that's 2000 steps. So for j=1, the total steps are O(n^2). For j=2, the same. So for k=2, the total steps would be O(2n^2). So for k=2000, the worst case is O(n^2) steps for j=1, but for higher j's, it's less.\n\nBut for the worst case, when k is small, say k=2, then the total steps would be O(n^2 *k) = O(2*2000^2) = 8 million steps. Which is manageable. However, for k=1000, the steps would be O(1000 * 2000^2) = 4e9 steps. Which is way too slow for Python.\n\nHmm. So perhaps there's a different approach.\n\nAlternative idea: Since each day's segment is a prefix of the array. Wait, no. Because the splits are contiguous, but each day's segment must start after the previous day's. So the first day's segment is from 1 to x, the second from x+1 to y, etc. So the splits are prefixes in the sense that each day's segment is a consecutive block starting from the previous end.\n\nBut how can that help?\n\nAnother thought: For each possible split into k days, the maximums are determined by the positions where the maximums are taken. To maximize the sum, perhaps we need to select the k-1 largest elements and assign each to their own day, and then split the rest accordingly. But this may not work because the positions of the elements matter.\n\nFor example, if there are two large elements, but they are adjacent. Splitting between them would allow both to be in their own days. But if they are not adjacent, perhaps we need to split in a way that includes them in separate days.\n\nBut how to formalize this.\n\nAlternatively, think of it as choosing k-1 split points. Each split point divides the array into segments. The maximum of each segment contributes to the total. The problem is to choose split points so that the sum of the maxima is maximized.\n\nBut how to model that.\n\nAnother observation: The maximum sum is achieved when each split captures as many high elements as possible. For example, if there's a very high element, it's better to have it as a single segment. However, if there are multiple high elements, we need to split them into separate segments.\n\nBut how to model this in code.\n\nAnother approach: Let's think of the problem as selecting k-1 positions to split the array into k parts. The total profit is the sum of the maxima of each part. How to choose those splits.\n\nBut even with that, the problem is how to find the splits.\n\nLet me think about the case where k=2. Then the problem is to split the array into two parts, and the sum is max of first part plus max of second part. How to find the split that maximizes this sum.\n\nFor this case, we can iterate all possible split points (from 1 to n-1) and compute the max of the first part and the max of the second part. Then take the maximum sum.\n\nBut for general k, this approach is not feasible.\n\nBut perhaps for the DP approach, we can optimize it further. Let's think again about the DP[i][j] approach, but with the optimization for the max calculation.\n\nSo, for each DP[i][j], we can compute the max as we go through possible m.\n\nLet me try to code this approach and see if it's feasible.\n\nLet's think about the sample input:\n\nSample 1:\nn=8, k=3\na = [5,4,2,6,5,1,9,2]\n\nThe DP for this case would be:\n\nDP[i][j] represents the maximum total profit for the first i elements split into j days.\n\nBase case: DP[0][0] = 0. But for j=1, DP[i][1] is the max of a[0..i-1].\n\nThen for j=2, DP[i][2] = max(DP[m][1] + max(a[m..i-1]) for m from 1 to i-1).\n\nBut in code, indexes can be tricky. Let's use 0-based or 1-based arrays.\n\nAssuming 1-based for the DP. So DP[i][j] is for the first i elements (a[1..i]) split into j days.\n\nThen for DP[i][j], we look for m in [j-1 ... i-1], since for j-1 days, you need at least j-1 elements. So m can be from j-1 to i-1.\n\nFor each m, the j-th day is the segment from m+1 to i. The max of this segment is needed.\n\nNow, for each i and j, we can compute the max for m+1 to i as follows:\n\nAs we iterate m from i-1 down to j-1, we can track the current maximum. For example, for the current i, when m decreases, the segment [m+1 ... i] expands to the left. So, for m = i-1, the segment is [i], so max is a[i]. For m = i-2, the segment is [i-1, i], max is max(a[i-1], a[i]). And so on.\n\nSo for each i and j, we can loop m from i-1 downto j-1, and keep track of current_max. For each m, current_max = max(current_max, a[m+1]).\n\nThis way, for each i and j, the inner loop is O(i) steps, but with O(1) per step.\n\nSo the total time complexity is O(n^2k), but with a better constant factor.\n\nBut for n=2000 and k=2000, this is still O(8e10) steps. Which is impossible.\n\nBut perhaps in practice, for the given constraints, the code can be optimized. Wait, what's the maximum possible value of k? It's n. But for k=n, each day is exactly one problem, so the answer is sum of all a[i]. So for that case, the code can handle it quickly.\n\nBut for other cases, when k is small, like k=2, the code would run in O(n^2 * 2) steps, which is acceptable for n=2000 (about 8 million steps).\n\nBut for k=1000, it's O(2000^2 * 1000) = 4e9 * 1000 = 4e12 steps. That's way too slow.\n\nSo this approach is not feasible for the worst case. Therefore, we need to find another way.\n\nAlternative Idea: Let's think about the problem differently. Since each day's segment contributes the maximum of that segment, and the sum is to be maximized, perhaps the optimal strategy is to split the array into k segments such that each segment contains exactly one of the k largest elements. But how to arrange that.\n\nFor example, suppose the array has elements sorted in decreasing order. Then the best way is to split into k segments, each containing one of the top k elements. Because each of these will contribute their maximum, and the rest of the elements can be grouped with them.\n\nBut how to generalize this.\n\nAlternatively, think of the problem as choosing k-1 split points. The sum of the maxima is the sum of the maxima of the segments. So, for each split, the maxima are the maxima of each segment.\n\nAnother observation: For any segment, the maximum is at least as large as any element within it. Therefore, if we can ensure that the k segments include the k largest elements in the array, each in their own segment, that would maximize the sum.\n\nBut how to do that.\n\nFor example, suppose the array has elements [a_1, a_2, ..., a_n], and the top k elements are x_1 >= x_2 >= ... >= x_k. Then, we can split the array so that each x_i is in its own segment. However, the positions of these elements may require that some segments include other elements as well.\n\nBut this suggests that the optimal solution is to split the array so that the k largest elements are each in their own segments. However, this may not always be possible if the elements are not spread out enough. For example, if the top k elements are all in the first part of the array. Then, we have to split the array in a way that each of these elements is in a separate segment.\n\nBut how to implement this.\n\nAlternatively, think of the problem as follows: The maximum sum is the sum of the k largest elements, plus the sum of the maxima of the remaining segments. But this is not necessarily correct, because some of the k largest elements may be in the same segment, thus only contributing once.\n\nWait, but if we can split the array such that each of the top k elements is in a separate segment, then the sum would be the sum of these top k elements. If we cannot do that, then some of the top elements would be grouped together, and their contribution would be the maximum of them, which is the same as if they were in separate segments. For example, if two of the top elements are in the same segment, their contribution is the maximum of them, which is the same as if they were split into separate segments. Thus, the sum would be the same. Therefore, the optimal sum is the sum of the k largest elements.\n\nWait, this seems like a possible breakthrough. Let me think again.\n\nSuppose that the optimal sum is the sum of the k largest elements. Because, regardless of how you split the array, each segment contributes its maximum. The sum of the maxima is at least the sum of the k largest elements, but can it be higher?\n\nNo. Because, each segment's maximum is one of the elements in the array. So, the sum of the maxima is the sum of k elements (each being the maximum of a segment). However, these elements can be any elements in the array, but each segment's maximum must be at least as large as any element in that segment. However, since there are exactly k segments, and we have to choose k elements (each being the maximum of their segment), the sum of these k elements can't exceed the sum of the k largest elements in the array.\n\nWait, this is a key insight. The sum of the maxima of the segments is equal to the sum of k elements, each of which is the maximum of their respective segment. Therefore, the maximum possible sum is the sum of the k largest elements in the array. Because if you can arrange that each of the k largest elements is the maximum of a segment, then the sum would be exactly the sum of the k largest elements. Otherwise, if some of them are grouped together, their contribution would be the maximum of them (which is one of the k largest elements), but then another segment would have to have a maximum that is smaller than some of the k largest elements. Hence, the sum would be less than or equal to the sum of the k largest elements.\n\nTherefore, the optimal total profit is the sum of the k largest elements in the array. But how to split the array into segments such that each of the k largest elements is in its own segment.\n\nBut wait, this seems to contradict the sample input. Let me check the sample input.\n\nSample Input 1:\n\nn=8, k=3\n\na = [5,4,2,6,5,1,9,2]\n\nThe k=3 largest elements are 9, 6, 5. Sum is 9+6+5 = 20. Which matches the sample output. So that's correct.\n\nAnother sample input is:\n\nThird example:\n\nInput is 4 2, array [1, 2000, 2000, 2]. The k=2 largest elements are 2000, 2000. Sum is 4000, which matches the sample output.\n\nSecond example: input is 5 1, array [1,1,1,1,1]. The sum of the 1 largest element is 1, which is correct.\n\nAnother test case: suppose n=3, k=2, array [3,1,2]. The two largest elements are 3 and 2. Sum is 5. How to split? The possible splits are [3][1,2] → sum 3+2=5, or [3,1][2] → sum 3+2=5. Either way, it's correct.\n\nAnother case: n=3, k=2, array [3, 2, 1]. The two largest are 3 and 2. Sum is 5. Split into [3][2,1], sum 3+2=5. Correct.\n\nAnother case: n=3, k=2, array [3, 2, 4]. The two largest are 4 and 3. Sum 7. How to split? The array must be split into two segments. The segments could be [3,2][4], sum 3+4=7. Or [3][2,4], sum 3+4=7. Both ways, correct.\n\nBut what if the array is [4, 3, 2, 1], and k=2. The two largest elements are 4 and 3. Sum is 7. Split into [4][3,2,1], sum 4+3=7. Correct.\n\nBut what if the array is [4, 3, 5, 1], k=2. The two largest elements are 5 and 4. Sum 9. How to split? The segments must be [4,3,5] and [1], sum 5 + 1 = 6? No. Wait, but the maximum of the first segment is 5, and the second is 1. Sum is 6. But the two largest elements are 5 and 4. But the sum is 5+1=6, which is less than 5+4=9. Wait, what's wrong here?\n\nAh, this shows that my earlier reasoning was incorrect. In this case, the two largest elements are 5 and 4. But how can we split the array into two segments to have each of them as a maximum?\n\nThe array is [4,3,5,1]. For k=2, possible splits:\n\nOption 1: [4,3,5] and [1]. Maxima are 5 and 1. Sum 6.\n\nOption 2: [4,3] and [5,1]. Maxima are 4 and 5. Sum 9. Which is the sum of the two largest elements.\n\nSo the correct split is option 2. So the sum is indeed the sum of the two largest elements. So in this case, it's possible to split the array such that each of the two largest elements is in their own segment.\n\nSo the key is to find a way to split the array such that each of the k largest elements is in its own segment. How?\n\nSo the problem reduces to selecting the k largest elements, and ensuring that each is in a separate segment. Once that is done, the sum is the sum of the k largest elements.\n\nSo the question is, how to split the array into k segments such that each of the k largest elements is in a separate segment. How can we do that?\n\nLet's think about the positions of the k largest elements. For example, if the k largest elements are located at positions p_1, p_2, ..., p_k (sorted in increasing order), then we can split the array into segments as follows:\n\nFirst segment is from the beginning up to p_1.\n\nSecond segment is from p_1 + 1 up to p_2.\n\n...\n\nk-th segment is from p_{k-1}+1 up to end.\n\nBut this would ensure that each of the k largest elements is in its own segment.\n\nBut how to find these positions.\n\nSo the algorithm could be:\n\n1. Find the k largest elements in the array. Let's call them the 'top' elements.\n\n2. Ensure that each of these elements is in its own segment. To do this, we can split the array so that each of these elements is the last element of a segment. For example, the first segment ends at the first occurrence of the first top element, the next segment ends at the next occurrence, etc.\n\nBut how to handle duplicates. For example, if there are multiple elements with the same value as the k-th largest.\n\nBut this approach seems promising.\n\nSo the plan is:\n\n- Sort the array's elements and find the k-th largest value. All elements greater than or equal to this value are part of the top elements.\n\nWait, but if there are multiple elements with the same value as the k-th largest, we need to select exactly k elements. For example, if the array is [5,5,5,5], and k=2, then the sum is 5+5=10.\n\nSo the steps could be:\n\n- Select the k largest elements. For example, sort the array in non-decreasing order, take the last k elements.\n\n- Then, find the positions of these elements in the original array, and split the array into k segments such that each of these elements is in its own segment.\n\nBut how to find the split points.\n\nFor example, consider the array [4,3,5,1], k=2. The two largest elements are 5 and 4. Their positions are 2 and 0 (assuming 0-based). To split the array into two segments, one containing 5 and one containing 4. But since 4 comes before 5, we can split after the 4 (so first segment is [4], second is [3,5,1], but that gives maxima 4 and 5. Sum is 9. Which is correct.\n\nSo the approach is to split the array into segments such that each of the k largest elements is in a separate segment. The way to do this is to find the positions of these elements, and split between them.\n\nBut how to find the split points. One approach is to collect all the positions of the top k elements, sort them in increasing order, and then split the array so that each segment ends at each of these positions.\n\nFor example, suppose the positions are p_1 < p_2 < ... < p_k.\n\nThen the split points would be after p_1, after p_2, etc. So the segments would be [0..p_1], [p_1+1..p_2], ..., [p_{k-1}+1..p_k], and the rest (if any) would be part of the last segment.\n\nBut how to handle when there are multiple elements with the same value. For example, if the array is [5,5,5,5], and k=2. The positions are 0,1,2,3. We need to select two of them. For example, select the first two positions (0 and 1). Then split into [0..0], [1..3], giving maxima 5 and 5. Sum is 10.\n\nBut how to choose which elements to select. The problem is that there may be more than k elements with the same value as the k-th largest element. For example, if the array is [5,5,5,5], and k=2. The k-th largest is 5. So all elements are part of the top k elements. We need to select exactly k of them. But how to choose which ones.\n\nIn this case, the optimal split would be to split the array into two segments, each containing at least one 5. So any split that separates the array into two parts, each containing at least one 5. For example, [5], [5,5,5], sum is 5+5=10.\n\nSo the approach is:\n\n- Find the k-th largest element. Let's call it 'threshold'.\n\n- Collect all indices where the element is greater than threshold. Let's say there are m such elements. If m >=k, then we need to select k of them. But how? Well, the way to maximize the sum is to select the k largest elements. But if there are multiple elements with the same value as the threshold, we need to choose exactly k elements. For example, if there are more than k elements with value equal to the threshold, then we need to select k of them. However, the selection of which ones to take depends on their positions.\n\nBut this seems complicated. However, the main idea is that the optimal sum is the sum of the k largest elements. Once we know that, the problem reduces to finding a way to split the array into k segments such that each of the k largest elements is in its own segment. Once that is done, the sum is the sum of the k largest elements.\n\nSo the steps are:\n\n1. Compute the sum of the k largest elements.\n\n2. Find the positions of these elements in the array.\n\n3. Split the array into k segments such that each of these elements is in its own segment.\n\nThe question now is how to perform step 3.\n\nLet's think about how to find the split points. For example, the k largest elements may be in various positions. To split the array into k segments, each containing one of these elements, we can greedily split after each of these elements.\n\nFor example, suppose we have the k largest elements sorted in increasing order of their positions. Let's say their positions are p_1 < p_2 < ... < p_k. Then, the first segment is from the start to p_1. The second segment is from p_1 +1 to p_2. The third is from p_2 +1 to p_3, etc. The last segment is from p_{k-1}+1 to end.\n\nThis way, each of the k largest elements is in its own segment.\n\nBut how to collect the positions of the k largest elements.\n\nLet me think about how to collect them. For example, we can create a list of the elements with their indices, sort them in descending order of value, and take the first k elements. Then, collect their indices and sort them in increasing order.\n\nOnce we have the sorted list of indices, we can split the array as described.\n\nLet me test this with the earlier example where the array is [4,3,5,1], k=2. The two largest elements are 5 and 4. Their indices are 2 and 0. When sorted in increasing order, they are 0 and 2. So the first segment is from 0 to 0 (length 1), the second segment is from 1 to 2 (indices 1 and 2), which is [3,5]. The maxima are 4 and 5. Sum is 9. Which is correct.\n\nAnother example: array [5,4,2,6,5,1,9,2], k=3. The three largest elements are 9, 6, 5 (assuming the array is [5,4,2,6,5,1,9,2], the elements sorted descendingly are 9,6,5,5,4,2,2,1. The top three are 9,6,5. Their positions are 6, 3, 0 (assuming 0-based). When sorted in increasing order, the indices are 0,3,6. So the split would be:\n\nFirst segment: 0 to 0 (length 1) → [5], max 5.\n\nSecond segment: 1 to 3 → [4,2,6], max 6.\n\nThird segment: 4 to 6 → [5,1,9], max 9. Sum is 5+6+9=20. Which matches the sample.\n\nAnother example: array [1,2000,2000,2], k=2. The two largest elements are 2000 and 2000. Their positions are 1 and 2. Sorted in increasing order, indices 1 and 2. Split into [0..1], [2..3]. The segments are [1,2000], [2000,2]. Maxima are 2000 and 2000. Sum is 4000. Which is correct.\n\nAnother example: array [5,5,5,5], k=2. The two largest elements are 5 and 5. Their positions are 0,1,2,3. Take the first two, positions 0 and 1. Split into [0..0], [1..3]. Maxima 5 and 5. Sum 10.\n\nBut what if the k largest elements are not all unique, and their positions are not spread out?\n\nFor example, array [5,5,5,5], k=3. The three largest are 5,5,5. Positions 0,1,2. Split into [0..0], [1..1], [2..3]. Maxima 5,5,5. Sum 15.\n\nYes.\n\nSo this approach seems to work.\n\nSo the plan is:\n\n1. Find the k largest elements in the array. Let's say they are stored in a list called 'top_elements'.\n\n2. Collect their indices, sort them in increasing order.\n\n3. Split the array into k segments as follows:\n\n   The first segment is from 0 to the first index.\n\n   The second segment is from the first index +1 to the second index.\n\n   ...\n\n   The k-th segment is from the (k-1)th index +1 to the end.\n\nThis ensures that each of the top k elements is in its own segment, and hence their maxima are added to the sum.\n\nNow, the problem is to find these top elements and their indices.\n\nSo, how to implement this.\n\nImplementation Steps:\n\n- Read n and k.\n\n- Read the array a.\n\n",
    "response": "To solve this problem, we need to maximize the total profit Polycarp can achieve by solving problems over exactly `k` days. Each day's profit is determined by the maximum difficulty of the problems solved that day. The goal is to split the list of problems into `k` contiguous segments such that the sum of the maximum difficulties of each segment is maximized.\n\n### Approach\n1. **Identify Top k Elements**: The optimal strategy involves ensuring that each of the top `k` elements in the array is in its own segment. This is because each segment's profit is determined by its maximum element, and the sum of the top `k` elements will be the maximum possible sum.\n2. **Determine Segment Boundaries**: Once the top `k` elements are identified, their positions in the array are used to determine the boundaries of each segment. This ensures that each of these top elements is in a separate segment, maximizing their contribution to the total profit.\n\n### Solution Code\n```python\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    k = int(input[idx])\n    idx += 1\n    a = list(map(int, input[idx:idx + n]))\n    \n    # Create a list of (value, index) pairs\n    val_indices = [(a[i], i) for i in range(n)]\n    # Sort descending by value, then ascending by index to break ties\n    val_indices.sort(reverse=True, key=lambda x: (x[0], -x[1]))\n    \n    # Take the first k elements\n    top_k = val_indices[:k]\n    # Extract their indices and sort them in increasing order\n    top_indices = sorted([idx for (val, idx) in top_k])\n    \n    # Now, create the segments\n    result = []\n    prev = -1\n    for idx in top_indices:\n        result.append(idx - prev)\n        prev = idx\n    # The last segment is from prev+1 to end\n    result[-1] += (n - 1 - prev)\n    \n    # Output the sum of the top k values\n    total = sum(val for (val, idx) in top_k)\n    print(total)\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into the number of problems `n`, the number of days `k`, and the list of problem difficulties.\n2. **Identifying Top k Elements**: The list of problem difficulties is converted into a list of tuples containing each value and its index. This list is sorted in descending order by value, and in case of ties, by ascending index to ensure consistent selection.\n3. **Extracting Indices**: The indices of the top `k` elements are extracted and sorted in increasing order to determine the segment boundaries.\n4. **Creating Segments**: Using the sorted indices of the top `k` elements, the array is split into segments such that each segment ends at one of these indices, ensuring each top element is in its own segment.\n5. **Output**: The sum of the top `k` values is printed, followed by the lengths of each segment.\n\nThis approach ensures that the maximum possible profit is achieved by leveraging the top `k` elements and efficiently splitting the array into segments that include these elements individually.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    k = int(input[idx])\n    idx += 1\n    a = list(map(int, input[idx:idx + n]))\n    \n    # Create a list of (value, index) pairs\n    val_indices = [(a[i], i) for i in range(n)]\n    # Sort descending by value, then ascending by index to break ties\n    val_indices.sort(reverse=True, key=lambda x: (x[0], -x[1]))\n    \n    # Take the first k elements\n    top_k = val_indices[:k]\n    # Extract their indices and sort them in increasing order\n    top_indices = sorted([idx for (val, idx) in top_k])\n    \n    # Now, create the segments\n    result = []\n    prev = -1\n    for idx in top_indices:\n        result.append(idx - prev)\n        prev = idx\n    # The last segment is from prev+1 to end\n    result[-1] += (n - 1 - prev)\n    \n    # Output the sum of the top k values\n    total = sum(val for (val, idx) in top_k)\n    print(total)\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 936,
        "completion_token_count": 718,
        "thoughts_token_count": 8192
    }
}