{
    "start": 1758309868.0479944,
    "end": 1758309915.0970423,
    "start-formatted": "2025-09-20 04:24 KST",
    "end-formatted": "2025-09-20 04:25 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\nOkay, let's see. The problem is about finding the minimum number of edges to add to a graph to create an odd-length cycle, and also count the number of ways to do that. Hmm.\n\nFirst, I need to understand what's required here. A simple cycle of odd length. Oh right, and each vertex occurs once. So, the cycle must be a simple cycle with an odd number of edges (since the number of edges equals the number of vertices in a cycle). Wait, no, for a cycle, the number of edges equals the number of vertices. So, the cycle has to have an odd number of vertices. Because the length of the cycle (in terms of edges) is equal to the number of vertices in it. So, for example, a triangle is a cycle of length 3 (odd).\n\nSo the problem is to find the minimal t such that adding t edges creates such a cycle. Also, count the number of ways to add those t edges.\n\nBut how to approach this? Let me think about the properties of bipartite graphs. Because a graph is bipartite if and only if it contains no odd-length cycles. So, if the original graph is bipartite, then adding edges to create an odd cycle would require some changes. But if the graph already has an odd cycle, then t is zero, and w is the number of ways to add zero edges (which is 1, but maybe not? Wait, the problem says that the existing graph may already have such a cycle. In that case, t is zero and w is 1? Or maybe the problem requires that the added edges form a cycle, but if there's already such a cycle, then adding zero edges would be the way. So in that case, the answer is t=0 and w=1. But wait, the problem says \"the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length...\". So if the graph already has such a cycle, then t is 0, and w is 1 (since there's exactly one way: adding zero edges). But maybe there are multiple existing cycles. However, the problem says that the answer is the number of ways to add t edges to form such a cycle. So if the graph already has at least one such cycle, then the answer is t=0, and w=1? Or is it the number of possible ways to add edges (but since adding zero edges is the only way, but maybe there are multiple existing cycles, but the problem counts the number of ways to add edges, which is just one way (adding nothing) regardless of how many existing cycles there are. Because the question is about the number of ways to add edges to form such a cycle. So even if there are multiple existing cycles, the way to add edges is zero edges, which is one way. So in that case, the answer would be t=0 and w=1.\n\nSo the first thing is to check whether the graph already contains an odd-length cycle. If yes, then t is 0 and w is 1.\n\nIf not, then we need to find the minimal t. Since the graph is bipartite (as it has no odd cycles), then adding edges to create an odd cycle.\n\nNow, how to create an odd cycle. Let's think about the bipartition. Suppose the graph is bipartite, so each connected component is bipartite. For a bipartite graph, any cycle is of even length. So adding an edge between two nodes in the same partition of a connected component would create an odd-length cycle. Because in a bipartite graph, all paths between two nodes have the same parity. So if two nodes are in the same partition, then any path between them has even length. Adding an edge between them creates a cycle of odd length (path length + 1). So, for example, if two nodes u and v are in the same partition of their connected component, then adding an edge between u and v would create an odd-length cycle.\n\nTherefore, the minimal t is 1 if there exists at least one connected component that has at least two nodes in the same partition. Wait, but how?\n\nWait, the minimal t is 1. Because adding one edge between two nodes in the same bipartition of a connected component would create an odd-length cycle. So if the graph is bipartite, then the minimal t is 1. But how to compute the number of ways to do that?\n\nSo the problem reduces to:\n\n- Check if the graph already has an odd cycle. If yes, output t=0, w=1.\n- Else, the graph is bipartite. Then, t is 1, and w is the number of possible pairs of nodes in the same partition of their connected component, minus the existing edges. Because adding an edge between two nodes in the same partition would create an odd cycle. But",
    "response": "To solve this problem, we need to determine the minimum number of edges to add to a given undirected graph to form a simple cycle of odd length, and also count the number of ways to achieve this.\n\n### Approach\n1. **Check for Existing Odd Cycles**: If the graph already contains an odd-length cycle, the answer is `t = 0` and `w = 1` because no edges need to be added.\n2. **Bipartite Graph Analysis**: If the graph is bipartite (i.e., it does not contain any odd-length cycles), we need to determine the minimum number of edges to add to create such a cycle. In a bipartite graph, adding an edge between two nodes in the same partition will create an odd-length cycle.\n3. **Count Valid Edge Additions**: For each connected component of the graph, calculate the number of valid edges that can be added between nodes in the same partition. This count gives the number of ways to add the required edges.\n\n### Solution Code\n```python\nimport sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n    \n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        u = int(input[idx]) - 1\n        idx += 1\n        v = int(input[idx]) - 1\n        idx += 1\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    # Check if the graph has an odd-length cycle\n    color = [-1] * n\n    is_bipartite = True\n    has_odd_cycle = False\n    \n    for start in range(n):\n        if color[start] == -1:\n            queue = deque()\n            queue.append(start)\n            color[start] = 0\n            while queue:\n                u = queue.popleft()\n                for v in adj[u]:\n                    if color[v] == -1:\n                        color[v] = color[u] ^ 1\n                        queue.append(v)\n                    else:\n                        if color[v] == color[u]:\n                            has_odd_cycle = True\n                            is_bipartite = False\n    if has_odd_cycle:\n        print(\"0 1\")\n        return\n    \n    # If the graph is bipartite, compute the number of ways to add one edge\n    # For each connected component, count the number of nodes in each partition\n    # Then the number of possible edges is (a * (a - 1) / 2 + b * (b - 1) / 2) - existing_edges_in_same_partition\n    # But since the graph is bipartite, existing edges are between different partitions\n    # So the existing edges in same partition is zero. Wait, no. The existing edges are between different partitions.\n    # So the number of possible edges to add is the sum over all components of (count0 * (count0 - 1) // 2 + count1 * (count1 - 1) // 2)\n    # But we have to subtract the existing edges between same partitions? No, because in bipartition, existing edges are between different partitions.\n    # So all existing edges are between different partitions. Therefore, the number of possible new edges that can be added between same partitions is sum for each component (count0 choose 2 + count1 choose 2)\n    \n    color = [-1] * n\n    total_ways = 0\n    for start in range(n):\n        if color[start] == -1:\n            queue = deque()\n            queue.append(start)\n            color[start] = 0\n            count0 = 1\n            count1 = 0\n            while queue:\n                u = queue.popleft()\n                for v in adj[u]:\n                    if color[v] == -1:\n                        color[v] = color[u] ^ 1\n                        if color[v] == 0:\n                            count0 += 1\n                        else:\n                            count1 += 1\n                        queue.append(v)\n            # Now, count0 and count1 are the sizes of the two partitions\n            # The number of possible edges within same partition is (count0 * (count0 - 1) // 2) + (count1 * (count1 - 1) // 2)\n            total_ways += (count0 * (count0 - 1) // 2) + (count1 * (count1 - 1) // 2)\n    \n    print(f\"1 {total_ways}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Check for Odd Cycles**: Using BFS, we check if the graph contains any odd-length cycles. If found, we immediately return `0 1`.\n2. **Bipartite Graph Analysis**: If the graph is bipartite, we analyze each connected component to count the number of nodes in each partition.\n3. **Calculate Ways**: For each connected component, compute the number of ways to add an edge between nodes in the same partition. Summing these values gives the total number of ways to add one edge to create an odd-length cycle.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n    \n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        u = int(input[idx]) - 1\n        idx += 1\n        v = int(input[idx]) - 1\n        idx += 1\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    # Check if the graph has an odd-length cycle\n    color = [-1] * n\n    is_bipartite = True\n    has_odd_cycle = False\n    \n    for start in range(n):\n        if color[start] == -1:\n            queue = deque()\n            queue.append(start)\n            color[start] = 0\n            while queue:\n                u = queue.popleft()\n                for v in adj[u]:\n                    if color[v] == -1:\n                        color[v] = color[u] ^ 1\n                        queue.append(v)\n                    else:\n                        if color[v] == color[u]:\n                            has_odd_cycle = True\n                            is_bipartite = False\n    if has_odd_cycle:\n        print(\"0 1\")\n        return\n    \n    # If the graph is bipartite, compute the number of ways to add one edge\n    # For each connected component, count the number of nodes in each partition\n    # Then the number of possible edges is (a * (a - 1) / 2 + b * (b - 1) / 2) - existing_edges_in_same_partition\n    # But since the graph is bipartite, existing edges are between different partitions\n    # So the existing edges in same partition is zero. Wait, no. The existing edges are between different partitions.\n    # So the number of possible edges to add is the sum over all components of (count0 * (count0 - 1) // 2 + count1 * (count1 - 1) // 2)\n    # But we have to subtract the existing edges between same partitions? No, because in bipartition, existing edges are between different partitions.\n    # So all existing edges are between different partitions. Therefore, the number of possible new edges that can be added between same partitions is sum for each component (count0 choose 2 + count1 choose 2)\n    \n    color = [-1] * n\n    total_ways = 0\n    for start in range(n):\n        if color[start] == -1:\n            queue = deque()\n            queue.append(start)\n            color[start] = 0\n            count0 = 1\n            count1 = 0\n            while queue:\n                u = queue.popleft()\n                for v in adj[u]:\n                    if color[v] == -1:\n                        color[v] = color[u] ^ 1\n                        if color[v] == 0:\n                            count0 += 1\n                        else:\n                            count1 += 1\n                        queue.append(v)\n            # Now, count0 and count1 are the sizes of the two partitions\n            # The number of possible edges within same partition is (count0 * (count0 - 1) // 2) + (count1 * (count1 - 1) // 2)\n            total_ways += (count0 * (count0 - 1) // 2) + (count1 * (count1 - 1) // 2)\n    \n    print(f\"1 {total_ways}\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 578,
        "completion_token_count": 1103,
        "thoughts_token_count": 1024
    }
}