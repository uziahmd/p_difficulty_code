{
    "start": 1758309685.371554,
    "end": 1758310238.9428055,
    "start-formatted": "2025-09-20 04:21 KST",
    "end-formatted": "2025-09-20 04:30 KST",
    "gpu": 2,
    "pid": 54,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mister B and Angle in Polygon\n\nOn one quiet day all of sudden Mister B decided to draw angle a on his field. Aliens have already visited his field and left many different geometric figures on it. One of the figures is regular convex n-gon (regular convex polygon with n sides).That's why Mister B decided to use this polygon. Now Mister B must find three distinct vertices v1, v2, v3 such that the angle  (where v2 is the vertex of the angle, and v1 and v3 lie on its sides) is as close as possible to a. In other words, the value  should be minimum possible.If there are many optimal solutions, Mister B should be satisfied with any of them.\n\n## Input\nFirst and only line contains two space-separated integers n and a (3 ≤ n ≤ 105, 1 ≤ a ≤ 180) — the number of vertices in the polygon and the needed angle, in degrees.\n\n## Output\nPrint three space-separated integers: the vertices v1, v2, v3, which form . If there are multiple optimal solutions, print any of them. The vertices are numbered from 1 to n in clockwise order.\n\n## Example\n### Input\n['3 15', '4 67', '4 68']\n\n### Output\n['1 2 3', '2 1 3', '4 1 2']\n\n## Note\nIn first sample test vertices of regular triangle can create only angle of 60 degrees, that's why every possible angle is correct.Vertices of square can create 45 or 90 degrees angles only. That's why in second sample test the angle of 45 degrees was chosen, since |45 - 67| < |90 - 67|. Other correct answers are: \"3 1 2\", \"3 2 4\", \"4 2 3\", \"4 3 1\", \"1 3 4\", \"1 4 2\", \"2 4 1\", \"4 1 3\", \"3 1 4\", \"3 4 2\", \"2 4 3\", \"2 3 1\", \"1 3 2\", \"1 2 4\", \"4 2 1\".In third sample test, on the contrary, the angle of 90 degrees was chosen, since |90 - 68| < |45 - 68|. Other correct answers are: \"2 1 4\", \"3 2 1\", \"1 2 3\", \"4 3 2\", \"2 3 4\", \"1 4 3\", \"3 4 1\".\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\nOkay, I need to solve this programming problem. Let's read the problem carefully.\n\nThe problem is about finding three distinct vertices in a regular convex n-gon such that the angle at v2 is as close as possible to a given angle a. The goal is to minimize the absolute difference between the angle formed and a. If there are multiple solutions, any is acceptable.\n\nFirst, I need to figure out how to calculate the possible angles that can be formed in a regular polygon. Let's think about the properties of regular polygons.\n\nIn a regular n-gon, each interior angle is given by ((n-2)*180)/n degrees. But that's the angle of the polygon itself. However, the problem here is about angles formed by three vertices, where the middle vertex is the vertex of the angle. So, for example, if we pick three consecutive vertices, the angle at the middle one would be the interior angle of the polygon. But if we pick vertices further apart, the angle changes.\n\nWait, but how do we compute the angle formed by three vertices in a regular polygon?\n\nLet me think. Let's imagine a regular polygon inscribed in a circle. All vertices lie on a circle. So, when you select three points v1, v2, v3, with v2 being the vertex of the angle, then the angle at v2 depends on the number of sides between v1 and v2, and between v3 and v2.\n\nIn a regular polygon, the central angles (angles from the center of the polygon to two adjacent vertices) are equal. For an n-gon, each central angle is 360/n degrees.\n\nBut how does that relate to the angle at v2? Let's think of the triangle formed by v1, v2, v3. Since the polygon is regular, all the vertices are on a circle, so the triangle is inscribed in that circle. The angle at v2 is an inscribed angle. \n\nThe measure of an inscribed angle depends on the arc it subtends. For example, if we have two points v1 and v3 on the circle, and v2 is another point, then the angle at v2 depends on the arc between v1 and v3 that does not contain v2. Wait, no. Wait, the inscribed angle theorem says that the angle is half the measure of the arc that it subtends. \n\nSo, suppose that between v1 and v3, there are k steps around the polygon (i.e., k edges). Then the arc between them is k*(360/n) degrees. But the angle at v2 depends on which arc we take. If v2 is on the circumference, then the angle at v2 would be half the measure of the arc that's opposite to it. \n\nWait, perhaps I should think of the case where v1 and v3 are separated by m steps. Let's say that between v1 and v3 along the perimeter, there are m steps. Then the arc between v1 and v3 is m*(360/n) degrees. But since the polygon is regular, the angle at v2 depends on how many steps are between v1 and v2, and between v2 and v3.\n\nAlternatively, let's consider that in a regular polygon, if we have three vertices v1, v2, v3, arranged such that when moving clockwise from v1 to v2 to v3, then the angle at v2 can be determined based on the number of edges between v1 and v2, and between v2 and v3. However, since the polygon is regular, the angle depends on the number of vertices between v1 and v3 when moving around the polygon.\n\nWait, maybe there's a formula here. Let me try some examples.\n\nTake a square (n=4). For three consecutive vertices, like 1,2,3. The angle at 2 is 90 degrees. But if I take vertices 1,2,4. Then the angle at 2 would be 45 degrees. Because in that case, the arc from 1 to 4 is 3 steps (since moving clockwise from 1 to 2 to 3 to 4 is 3 steps), but the arc that's opposite to the angle at 2 would be the arc from 1 to 4 not passing through 2. Wait, but how?\n\nAlternatively, for any triangle formed by three vertices of a regular polygon, the angle at v2 can be calculated as follows:\n\nLet’s say that when you fix v2 as the vertex, the number of vertices between v1 and v2 is k steps in one direction, and between v3 and v2 is l steps in the other direction. But since the polygon is regular and convex, the angle at v2 depends on the total number of steps between v1 and v3 when going around the polygon in one direction. For example, if there are",
    "response": "To solve this problem, we need to find three distinct vertices in a regular convex n-gon such that the angle formed at one of the vertices is as close as possible to a given angle `a`. The solution involves understanding the geometric properties of regular polygons and efficiently calculating the closest possible angle.\n\n### Approach\n1. **Understanding Angles in Regular Polygons**: In a regular n-gon, the central angle between two adjacent vertices is $ \\frac{360^\\circ}{n} $. For any three vertices $ v1, v2, v3 $, the angle at $ v2 $ depends on the number of steps (edges) between $ v1 $ and $ v3 $ when moving around the polygon.\n2. **Inscribed Angle Calculation**: The angle at vertex $ v2 $ can be calculated using the formula derived from the inscribed angle theorem. If there are $ k $ steps between $ v1 $ and $ v3 $, the angle at $ v2 $ is $ \\frac{(k-1) \\times 180^\\circ}{n} $.\n3. **Iterative Search**: We iterate through possible values of $ k $ (number of steps between $ v1 $ and $ v3 $) to find the angle closest to the given angle `a`.\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    n = int(input[0])\n    a = int(input[1])\n    \n    # Calculate the angle for each possible k\n    min_diff = float('inf')\n    best_k = 1\n    for k in range(1, n):\n        angle = (k - 1) * 180.0 / n\n        diff = abs(angle - a)\n        if diff < min_diff:\n            min_diff = diff\n            best_k = k\n        elif diff == min_diff:\n            # Prefer smaller k to get earlier positions\n            if k < best_k:\n                best_k = k\n    \n    # Now, find a triplet of vertices with k steps between v1 and v3\n    # We can choose v2 as 1, then v1 as 2, v3 as 2 + best_k\n    # But need to ensure that the vertices are distinct and within the range\n    # Let's pick v2 as 1, then v1 = 2, v3 = 2 + best_k\n    # However, need to handle wrap-around\n    # Since the polygon is regular, we can choose any starting point\n    # For simplicity, let's pick v2 = 1, v1 = 2, v3 = 2 + best_k\n    # But need to make sure that v3 does not exceed n\n    # Wait, the number of steps between v1 and v3 is best_k, so the actual positions\n    # Let me think: if we fix v2 as 1, then v1 can be 2, and v3 is 2 + best_k\n    # But if best_k is larger than n - 2, then it wraps around. Wait no, since k ranges from 1 to n-1\n    # Because for k steps between v1 and v3, the maximum k is n-1 (since you can't have more steps than the total vertices minus 2)\n    # So, for example, if n=4 and best_k=3, then v1=2, v3=2+3=5, but since n=4, it wraps around to 1.\n    # Wait, but how to compute the correct v3?\n    # Actually, the number of steps between v1 and v3 is best_k, which is the number of edges between them.\n    # So for example, if v1 is 2, and best_k is 3, then v3 would be (2 + best_k - 1) % n + 1\n    # Wait, perhaps I should choose v2 as 1, then v1 as 2, and v3 as 2 + best_k - 1? Or maybe another approach.\n    # Alternatively, for a given best_k, the angle is determined by the arc between v1 and v3 which is (k-1)*180/n\n    # So, for example, if best_k is 2, then the arc is 1 step, leading to angle 180/n * 1\n    # To construct the triplet, we can choose v2 as 1, v1 as 2, and v3 as 2 + best_k\n    # But since the polygon is cyclic, we need to ensure that the indices are within 1 to n\n    # So, for example, if best_k is 3 and n=4, then v3 would be 2+3 = 5, which is 1 (mod 4)\n    # So, v3 = (2 + best_k - 1) % n + 1\n    # Wait, let's think: if v1 is at position i, and v3 is k steps away in the clockwise direction (excluding v2), then v3 = (i + k) % n or something like that.\n    # Maybe a better way is to choose v2 as 1, v1 as 2, and v3 as (2 + best_k) if <=n else (2 + best_k - n)\n    # But perhaps the simplest way is to select v2 as 1, v1 as 2, and v3 as (2 + best_k - 1) mod n + 1\n    # Wait, let's take an example. For n=4, best_k=3. Then, v1=2, v3 should be 2 + 3 - 1 = 4? No, because the number of steps between v1 and v3 is best_k, which is 3 steps. So between 2 and 4, there are 2 steps (2->3->4), but that's only 2 steps. Wait, I'm getting confused here.\n\n    # Let me think again. For a regular polygon, the number of steps between v1 and v3 along the perimeter (in one direction) is m. Then, the arc length is m*(360/n) degrees. The angle at v2 is half of the arc that's opposite to the angle. Wait, but in this case, the angle at v2 is half of the arc between v1 and v3 that does not contain v2. So if the arc between v1 and v3 that doesn't contain v2 is m*(360/n), then the angle at v2 is (m*(360/n))/2 = m*180/n. But wait, in the square example, if v1 is 1, v2 is 2, v3 is 4. The arc between v1 and v3 not containing v2 is 3 steps (from 1 to 2 to 3 to 4?), no. Wait, the arc that does not contain v2 would be the other side. For example, if the polygon is a square with vertices 1,2,3,4. If v1 is 1, v2 is 2, v3 is 4, then the arc between v1 and v3 that does not contain v2 is 1 -> 4, which is one edge (since the other way around is 1->2->3->4 which is three steps). So the arc length is 1*(360/4) = 90 degrees, and the angle at v2 is 90/2 = 45 degrees. Which matches the sample input.\n\n    # So the number of steps m is the number of edges in the arc between v1 and v3 that does not contain v2. Therefore, m = (n - k), where k is the number of steps between v1 and v3 that contains v2. Wait, but how do we determine m?\n\n    # Alternatively, for the angle at v2, the formula is (m * 180)/n, where m is the number of steps between v1 and v3 that does not include v2. And m can be from 1 to n-2. Because if m is 1, then the angle is 180/n. For example, in the square, m=1 gives 45 degrees. For m=2, 2*180/4 = 90 degrees, which is the interior angle.\n\n    # Therefore, for each possible m (from 1 to n-2), the angle is (m * 180)/n. And our goal is to find m such that this angle is as close as possible to a.\n\n    # Wait, but earlier calculations said that the angle is (k-1)*180/n. How does that fit?\n\n    # Let me re-express. For a given m (steps in the arc that does not contain v2), the angle is (m * 180)/n. So, for each m in 1..n-2, we can calculate this angle.\n\n    # So in the code above, the loop was over k from 1 to n-1, and angle was (k-1)*180/n. That seems to be equivalent to m = k-1. So m ranges from 0 to n-2. But m must be at least 1. Wait, maybe there's confusion here.\n\n    # Let me correct this. The correct approach is to consider m from 1 to n-2. For each m, the angle is (m * 180)/n. Then, we find the m that makes this angle closest to a.\n\n    # So the code should be adjusted to loop m from 1 to n-2.\n\n    # Let's redo the code with this in mind.\n\n    # So, the code:\n\n    # Read n and a\n    # For m in 1 to n-2:\n    #   angle = m * 180.0 / n\n    #   compute difference with a\n    # Find the m with minimal difference\n\n    # Then, once m is found, construct the triplet.\n\n    # How to construct the triplet? For example, if m is the number of steps in the arc between v1 and v3 not containing v2. So, for example, if m=1, then v1 and v3 are adjacent, and v2 is between them. So, for example, in a square, m=1 would be v1=1, v2=2, v3=3. But that's the interior angle. Wait, no. Wait, for m=1, the arc not containing v2 is 1 step. So the angle at v2 is 1*180/4 = 45 degrees. Which is the case where v1=1, v2=2, v3=4. The arc between 1 and 4 not containing v2 is 1 step (from 1 to 4 directly, but in a square, that's actually two edges? No, in a square, the arc between 1 and 4 not containing v2 (which is 2) would be going through 3 and 4, which is two steps. Wait, I'm confused again.\n\n    # This suggests that my earlier analysis is incorrect. Let me refer back to the sample input.\n\n    # In the sample input 4 67, the output is \"2 1 3\". Let's see what angle that forms. The vertices are 2,1,3. The angle is at vertex 1. So v1 is 2, v2 is 1, v3 is 3. The arc between v1 and v3 (2 and 3) that does not contain v2 (1) is the arc going through 2, 3. That's one step. So m=1. The angle is 1 * 180 /4 = 45 degrees. Which matches the sample explanation.\n\n    # So in this case, the angle is m * 180 /n, where m is the number of steps in the arc between v1 and v3 not containing v2. So how to find m? For each possible m from 1 to n-2, we can calculate the angle.\n\n    # So the code needs to find the m (from 1 to n-2) that gives the closest angle to a.\n\n    # So let's adjust the code accordingly.\n\n    # Now, the code:\n\n    # Read n and a\n    n = int(input[0])\n    a = int(input[1])\n\n    min_diff = float('inf')\n    best_m = 1\n    for m in range(1, n-1):\n        angle = m * 180.0 / n\n        diff = abs(angle - a)\n        if diff < min_diff:\n            min_diff = diff\n            best_m = m\n        elif diff == min_diff:\n            if m < best_m:\n                best_m = m\n\n    # Now, construct the triplet. How?\n    # We need to find three vertices v1, v2, v3 such that the arc between v1 and v3 not containing v2 has m steps.\n    # One simple way is to choose v2 as 1, v1 as 2, and v3 as 2 + m. But since the polygon is cyclic, we need to ensure that v3 is within the range [1, n].\n\n    # Wait, for example, if m=1 and n=4: v1=2, v2=1, v3=2 + m = 3. But the arc between v1 and v3 (2 and 3) not containing v2 (1) is 1 step. That's correct. The angle is 45 degrees.\n\n    # Another example: m=2, n=4. Then angle is 2*180/4 = 90 degrees. Which is the interior angle. For triplet 1,2,3: v2=2, v1=1, v3=3. Arc between v1 and v3 not containing v2 is 2 steps (through 1-4-3?), no. Wait, the arc between v1 and v3 not containing v2 (which is 2) would be 1-4-3, which is 2 steps. So m=2. So yes, the angle is 90 degrees.\n\n    # So, to create such a triplet, we can choose v2 as 1, v1 as 2, and v3 as 2 + m. However, if 2 + m exceeds n, we need to wrap around. But since m is at most n-2, 2 + m can be up to n-2 + 2 = n. So for example, if n=4 and m=2, then 2 + m = 4, which is valid.\n\n    # So the triplet can be constructed as follows:\n    # v2 = 1\n    # v1 = 2\n    # v3 = 2 + m\n    # But if 2 + m > n, then v3 = 2 + m - n? No, because m can be up to n-2, so 2 + m is up to 2 + n-2 = n, which is valid.\n\n    # So, for example, if n=4, m=2, then v3 is 4. So the triplet is 2,1,4. Which is one of the correct answers in the sample.\n\n    # Therefore, the triplet is v1=2, v2=1, v3=2 + m.\n\n    # But wait, in the sample input 4 67, the best m is 1 (angle 45), and the output is \"2 1 3\", which is exactly 2,1,3 (since 2 + 1 = 3).\n\n    # So this approach works.\n\n    # However, what if m is such that 2 + m exceeds n? Let's say n=5 and m=3. Then 2 + 3 = 5, which is valid. For m=4, n=5, but m can be up to n-2=3. So no problem.\n\n    # So the code can proceed with:\n\n    v2 = 1\n    v1 = 2\n    v3 = 2 + best_m\n\n    # But wait, what if the best_m is such that v3 is beyond n? For example, n=5, m=3. 2 + 3 = 5, which is valid. For m=4, which is not allowed since m can be up to n-2=3.\n\n    # So the triplet is v1=2, v2=1, v3=2 + best_m.\n\n    # But what if the best_m is 0? No, because m ranges from 1 to n-2.\n\n    # So the final answer is the triplet 2, 1, 2+best_m.\n\n    # However, what if there are multiple best_m with the same difference? The code chooses the smallest m, which gives the earliest possible triplet.\n\n    # Now, output the triplet. But need to ensure that the vertices are distinct and within the range.\n\n    # So, print v1, v2, v3. But in the sample input 3 15, n=3, a=15. The best_m is 1 (angle 1*180/3=60). The triplet would be 2,1,3. Which is one of the correct answers.\n\n    # So the code seems correct.\n\n    # Edge Cases:\n    # - n=3: m can be 1. The angle is 60 degrees. Any triplet is acceptable.\n    # - a is exactly equal to some angle: e.g., a=90 for n=4, m=2.\n\n    # Now, implement this logic.\n\n    # But wait, what if the best_m is 0? No, because m starts from 1.\n\n    # So the code becomes:\n\n    # After finding best_m:\n\n    v2 = 1\n    v1 = 2\n    v3 = 2 + best_m\n\n    # But in cases where best_m is such that v3 exceeds n? For example, n=4, best_m=2: 2+2=4, which is valid.\n\n    # So, output v1, v2, v3.\n\n    # However, the problem allows any valid triplet. So other triplets are also acceptable. But the code picks one specific triplet.\n\n    # Thus, the code can be written as follows:\n\n    print(f\"{v1} {v2} {v3}\")\n\n    # Wait, but in the first sample input, the output is \"1 2 3\". According to our code, for n=3, best_m is 1. So v1=2, v2=1, v3=2+1=3. The output would be \"2 1 3\", which is one of the correct answers. But the sample output is \"1 2 3\".\n\n    # Oh, right. The problem states that any correct triplet is acceptable. So why the sample output is different?\n\n    # Because there are multiple correct triplets. For example, in the first sample input, all triplets are valid. So the code's output may differ from the sample, but it's still correct.\n\n    # However, the sample output for the first input is \"1 2 3\", which corresponds to the angle at vertex 2. Let's check what m would be for that case.\n\n    # For triplet 1,2,3: the arc between v1=1 and v3=3 not containing v2=2 is 1 step (1->3 directly, which is not possible in a triangle. Wait, in a triangle, the arc between 1 and 3 not containing 2 would be zero steps? No, because the polygon is a triangle, and the arc between 1 and 3 not containing 2 is the direct line, which is one step (since there are two edges between 1 and 3: 1-2-3 and 1-3 (if it were a digon, but it's a triangle). Wait, in a triangle, the arc between 1 and 3 not containing 2 is one step (the edge between 1 and 3), but since it's a triangle, the arc between 1 and 3 that doesn't contain 2 is just one edge. So m=1. The angle at v2=2 is 1*180/3 = 60 degrees. Which is correct. So the triplet 1 2 3 is valid, and the code's output would be 2 1 3. Both are correct.\n\n    # So the code is correct even though it outputs a different triplet than the sample. The problem allows any correct triplet.\n\n    # However, the sample outputs may vary, but the code's output is valid.\n\n    # So the code is correct.\n\n    # Now, let's write the code with the corrected approach.\n\n    # Also, note that for n=3, the loop for m runs from 1 to 1 (n-2 = 1). So m=1.\n\n    # Now, the code:\n\n    import sys\n\n    def main():\n        import sys\n        input = sys.stdin.read().split()\n        n = int(input[0])\n        a = int(input[1])\n\n        if n == 3:\n            # Only possible angle is 60 degrees. Any triplet is acceptable.\n            print(\"1 2 3\")\n            return\n\n        min_diff = float('inf')\n        best_m = 1\n        for m in range(1, n-1):\n            angle = m * 180.0 / n\n            diff = abs(angle - a)\n            if diff < min_diff:\n                min_diff = diff\n                best_m = m\n            elif diff == min_diff:\n                if m < best_m:\n                    best_m = m\n\n        v2 = 1\n        v1 = 2\n        v3 = 2 + best_m\n\n        print(f\"{v1} {v2} {v3}\")\n\n    if __name__ == \"__main__\":\n        main()\n\n```\n\n### Explanation\n1. **Reading Input**: The input consists of two integers, `n` (number of vertices) and `a` (target angle).\n2. **Finding Best m**: We iterate through possible values of `m` (number of steps in the arc between vertices not containing the middle vertex) to find the angle closest to `a`.\n3. **Constructing Triplet**: Once the optimal `m` is found, we construct a valid triplet of vertices based on `m`, ensuring the vertices are distinct and within bounds.\n\nThis approach efficiently computes the closest possible angle and constructs a valid triplet, ensuring correctness and adherence to the problem constraints.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    n = int(input[0])\n    a = int(input[1])\n    \n    # Calculate the angle for each possible k\n    min_diff = float('inf')\n    best_k = 1\n    for k in range(1, n):\n        angle = (k - 1) * 180.0 / n\n        diff = abs(angle - a)\n        if diff < min_diff:\n            min_diff = diff\n            best_k = k\n        elif diff == min_diff:\n            # Prefer smaller k to get earlier positions\n            if k < best_k:\n                best_k = k\n    \n    # Now, find a triplet of vertices with k steps between v1 and v3\n    # We can choose v2 as 1, then v1 as 2, v3 as 2 + best_k\n    # But need to ensure that the vertices are distinct and within the range\n    # Let's pick v2 as 1, then v1 = 2, v3 = 2 + best_k\n    # However, need to handle wrap-around\n    # Since the polygon is regular, we can choose any starting point\n    # For simplicity, let's pick v2 = 1, v1 = 2, v3 = 2 + best_k\n    # But need to make sure that v3 does not exceed n\n    # Wait, the number of steps between v1 and v3 is best_k, so the actual positions\n    # Let me think: if we fix v2 as 1, then v1 can be 2, and v3 is 2 + best_k\n    # But if best_k is larger than n - 2, then it wraps around. Wait no, since k ranges from 1 to n-1\n    # Because for k steps between v1 and v3, the maximum k is n-1 (since you can't have more steps than the total vertices minus 2)\n    # So, for example, if n=4 and best_k=3, then v1=2, v3=2+3=5, but since n=4, it wraps around to 1.\n    # Wait, but how to compute the correct v3?\n    # Actually, the number of steps between v1 and v3 is best_k, which is the number of edges between them.\n    # So for example, if v1 is 2, and best_k is 3, then v3 would be (2 + best_k - 1) % n + 1\n    # Wait, perhaps I should choose v2 as 1, then v1 as 2, and v3 as 2 + best_k - 1? Or maybe another approach.\n    # Alternatively, for a given best_k, the angle is determined by the arc between v1 and v3 which is (k-1)*180/n\n    # So, for example, if best_k is 2, then the arc is 1 step, leading to angle 180/n * 1\n    # To construct the triplet, we can choose v2 as 1, v1 as 2, and v3 as 2 + best_k\n    # But since the polygon is cyclic, we need to ensure that the indices are within 1 to n\n    # So, for example, if best_k is 3 and n=4, then v3 would be 2+3 = 5, which is 1 (mod 4)\n    # So, v3 = (2 + best_k - 1) % n + 1\n    # Wait, let's think: if v1 is at position i, and v3 is k steps away in the clockwise direction (excluding v2), then v3 = (i + k) % n or something like that.\n    # Maybe a better way is to choose v2 as 1, v1 as 2, and v3 as (2 + best_k) if <=n else (2 + best_k - n)\n    # But perhaps the simplest way is to select v2 as 1, v1 as 2, and v3 as (2 + best_k - 1) mod n + 1\n    # Wait, let's take an example. For n=4, best_k=3. Then, v1=2, v3 should be 2 + 3 - 1 = 4? No, because the number of steps between v1 and v3 is best_k, which is 3 steps. So between 2 and 4, there are 2 steps (2->3->4), but that's only 2 steps. Wait, I'm getting confused here.\n\n    # Let me think again. For a regular polygon, the number of steps between v1 and v3 along the perimeter (in one direction) is m. Then, the arc length is m*(360/n) degrees. The angle at v2 is half of the arc that's opposite to the angle. Wait, but in this case, the angle at v2 is half of the arc between v1 and v3 that does not contain v2. So if the arc between v1 and v3 that doesn't contain v2 is m*(360/n), then the angle at v2 is (m*(360/n))/2 = m*180/n. But wait, in the square example, if v1 is 1, v2 is 2, v3 is 4. The arc between v1 and v3 not containing v2 is 3 steps (from 1 to 2 to 3 to 4?), no. Wait, the arc that does not contain v2 would be the other side. For example, if the polygon is a square with vertices 1,2,3,4. If v1 is 1, v2 is 2, v3 is 4, then the arc between v1 and v3 that does not contain v2 is 1 -> 4, which is one edge (since the other way around is 1->2->3->4 which is three steps). So the arc length is 1*(360/4) = 90 degrees, and the angle at v2 is 90/2 = 45 degrees. Which matches the sample input.\n\n    # So the number of steps m is the number of edges in the arc between v1 and v3 that does not contain v2. Therefore, m = (n - k), where k is the number of steps between v1 and v3 that contains v2. Wait, but how do we determine m?\n\n    # Alternatively, for the angle at v2, the formula is (m * 180)/n, where m is the number of steps between v1 and v3 that does not include v2. And m can be from 1 to n-2. Because if m is 1, then the angle is 180/n. For example, in the square, m=1 gives 45 degrees. For m=2, 2*180/4 = 90 degrees, which is the interior angle.\n\n    # Therefore, for each possible m (from 1 to n-2), the angle is (m * 180)/n. And our goal is to find m such that this angle is as close as possible to a.\n\n    # Wait, but earlier calculations said that the angle is (k-1)*180/n. How does that fit?\n\n    # Let me re-express. For a given m (steps in the arc that does not contain v2), the angle is (m * 180)/n. So, for each m in 1..n-2, we can calculate this angle.\n\n    # So in the code above, the loop was over k from 1 to n-1, and angle was (k-1)*180/n. That seems to be equivalent to m = k-1. So m ranges from 0 to n-2. But m must be at least 1. Wait, maybe there's confusion here.\n\n    # Let me correct this. The correct approach is to consider m from 1 to n-2. For each m, the angle is (m * 180)/n. Then, we find the m that makes this angle closest to a.\n\n    # So the code should be adjusted to loop m from 1 to n-2.\n\n    # Let's redo the code with this in mind.\n\n    # So, the code:\n\n    # Read n and a\n    # For m in 1 to n-2:\n    #   angle = m * 180.0 / n\n    #   compute difference with a\n    # Find the m with minimal difference\n\n    # Then, once m is found, construct the triplet.\n\n    # How to construct the triplet? For example, if m is the number of steps in the arc between v1 and v3 not containing v2. So, for example, if m=1, then v1 and v3 are adjacent, and v2 is between them. So, for example, in a square, m=1 would be v1=1, v2=2, v3=3. But that's the interior angle. Wait, no. Wait, for m=1, the arc not containing v2 is 1 step. So the angle at v2 is 1*180/4 = 45 degrees. Which is the case where v1=1, v2=2, v3=4. The arc between 1 and 4 not containing v2 is 1 step (from 1 to 4 directly, but in a square, that's actually two edges? No, in a square, the arc between 1 and 4 not containing v2 (which is 2) would be going through 3 and 4, which is two steps. Wait, I'm confused again.\n\n    # This suggests that my earlier analysis is incorrect. Let me refer back to the sample input.\n\n    # In the sample input 4 67, the output is \"2 1 3\". Let's see what angle that forms. The vertices are 2,1,3. The angle is at vertex 1. So v1 is 2, v2 is 1, v3 is 3. The arc between v1 and v3 (2 and 3) that does not contain v2 (1) is the arc going through 2, 3. That's one step. So m=1. The angle is 1 * 180 /4 = 45 degrees. Which matches the sample explanation.\n\n    # So in this case, the angle is m * 180 /n, where m is the number of steps in the arc between v1 and v3 not containing v2. So how to find m? For each possible m from 1 to n-2, we can calculate the angle.\n\n    # So the code needs to find the m (from 1 to n-2) that gives the closest angle to a.\n\n    # So let's adjust the code accordingly.\n\n    # Now, the code:\n\n    # Read n and a\n    n = int(input[0])\n    a = int(input[1])\n\n    min_diff = float('inf')\n    best_m = 1\n    for m in range(1, n-1):\n        angle = m * 180.0 / n\n        diff = abs(angle - a)\n        if diff < min_diff:\n            min_diff = diff\n            best_m = m\n        elif diff == min_diff:\n            if m < best_m:\n                best_m = m\n\n    # Now, construct the triplet. How?\n    # We need to find three vertices v1, v2, v3 such that the arc between v1 and v3 not containing v2 has m steps.\n    # One simple way is to choose v2 as 1, v1 as 2, and v3 as 2 + m. But since the polygon is cyclic, we need to ensure that v3 is within the range [1, n].\n\n    # Wait, for example, if m=1 and n=4: v1=2, v2=1, v3=2 + m = 3. But the arc between v1 and v3 (2 and 3) not containing v2 (1) is 1 step. That's correct. The angle is 45 degrees.\n\n    # Another example: m=2, n=4. Then angle is 2*180/4 = 90 degrees. Which is the interior angle. For triplet 1,2,3: v2=2, v1=1, v3=3. Arc between v1 and v3 not containing v2 is 2 steps (through 1-4-3?), no. Wait, the arc between v1 and v3 not containing v2 (which is 2) would be 1-4-3, which is 2 steps. So m=2. So yes, the angle is 90 degrees.\n\n    # So, to create such a triplet, we can choose v2 as 1, v1 as 2, and v3 as 2 + m. However, if 2 + m exceeds n, we need to wrap around. But since m is at most n-2, 2 + m can be up to n-2 + 2 = n. So for example, if n=4 and m=2, then 2 + m = 4, which is valid.\n\n    # So the triplet can be constructed as follows:\n    # v2 = 1\n    # v1 = 2\n    # v3 = 2 + m\n    # But if 2 + m > n, then v3 = 2 + m - n? No, because m can be up to n-2, so 2 + m is up to 2 + n-2 = n, which is valid.\n\n    # So, for example, if n=4, m=2, then v3 is 4. So the triplet is 2,1,4. Which is one of the correct answers in the sample.\n\n    # Therefore, the triplet is v1=2, v2=1, v3=2 + m.\n\n    # But wait, in the sample input 4 67, the best m is 1 (angle 45), and the output is \"2 1 3\", which is exactly 2,1,3 (since 2 + 1 = 3).\n\n    # So this approach works.\n\n    # However, what if m is such that 2 + m exceeds n? Let's say n=5 and m=3. Then 2 + 3 = 5, which is valid. For m=4, n=5, but m can be up to n-2=3. So no problem.\n\n    # So the code can proceed with:\n\n    v2 = 1\n    v1 = 2\n    v3 = 2 + best_m\n\n    # But wait, what if the best_m is such that v3 is beyond n? For example, n=5, m=3. 2 + 3 = 5, which is valid. For m=4, which is not allowed since m can be up to n-2=3.\n\n    # So the triplet is v1=2, v2=1, v3=2 + best_m.\n\n    # But what if the best_m is 0? No, because m ranges from 1 to n-2.\n\n    # So the final answer is the triplet 2, 1, 2+best_m.\n\n    # However, what if there are multiple best_m with the same difference? The code chooses the smallest m, which gives the earliest possible triplet.\n\n    # Now, output the triplet. But need to ensure that the vertices are distinct and within the range.\n\n    # So, print v1, v2, v3. But in the sample input 3 15, n=3, a=15. The best_m is 1 (angle 1*180/3=60). The triplet would be 2,1,3. Which is one of the correct answers.\n\n    # So the code seems correct.\n\n    # Edge Cases:\n    # - n=3: m can be 1. The angle is 60 degrees. Any triplet is acceptable.\n    # - a is exactly equal to some angle: e.g., a=90 for n=4, m=2.\n\n    # Now, implement this logic.\n\n    # But wait, what if the best_m is 0? No, because m starts from 1.\n\n    # So the code becomes:\n\n    # After finding best_m:\n\n    v2 = 1\n    v1 = 2\n    v3 = 2 + best_m\n\n    # But in cases where best_m is such that v3 exceeds n? For example, n=4, best_m=2: 2+2=4, which is valid.\n\n    # So, output v1, v2, v3.\n\n    # However, the problem allows any valid triplet. So other triplets are also acceptable. But the code picks one specific triplet.\n\n    # Thus, the code can be written as follows:\n\n    print(f\"{v1} {v2} {v3}\")\n\n    # Wait, but in the first sample input, the output is \"1 2 3\". According to our code, for n=3, best_m is 1. So v1=2, v2=1, v3=2+1=3. The output would be \"2 1 3\", which is one of the correct answers. But the sample output is \"1 2 3\".\n\n    # Oh, right. The problem states that any correct triplet is acceptable. So why the sample output is different?\n\n    # Because there are multiple correct triplets. For example, in the first sample input, all triplets are valid. So the code's output may differ from the sample, but it's still correct.\n\n    # However, the sample output for the first input is \"1 2 3\", which corresponds to the angle at vertex 2. Let's check what m would be for that case.\n\n    # For triplet 1,2,3: the arc between v1=1 and v3=3 not containing v2=2 is 1 step (1->3 directly, which is not possible in a triangle. Wait, in a triangle, the arc between 1 and 3 not containing 2 would be zero steps? No, because the polygon is a triangle, and the arc between 1 and 3 not containing 2 is the direct line, which is one step (since there are two edges between 1 and 3: 1-2-3 and 1-3 (if it were a digon, but it's a triangle). Wait, in a triangle, the arc between 1 and 3 not containing 2 is one step (the edge between 1 and 3), but since it's a triangle, the arc between 1 and 3 that doesn't contain 2 is just one edge. So m=1. The angle at v2=2 is 1*180/3 = 60 degrees. Which is correct. So the triplet 1 2 3 is valid, and the code's output would be 2 1 3. Both are correct.\n\n    # So the code is correct even though it outputs a different triplet than the sample. The problem allows any correct triplet.\n\n    # However, the sample outputs may vary, but the code's output is valid.\n\n    # So the code is correct.\n\n    # Now, let's write the code with the corrected approach.\n\n    # Also, note that for n=3, the loop for m runs from 1 to 1 (n-2 = 1). So m=1.\n\n    # Now, the code:\n\n    import sys\n\n    def main():\n        import sys\n        input = sys.stdin.read().split()\n        n = int(input[0])\n        a = int(input[1])\n\n        if n == 3:\n            # Only possible angle is 60 degrees. Any triplet is acceptable.\n            print(\"1 2 3\")\n            return\n\n        min_diff = float('inf')\n        best_m = 1\n        for m in range(1, n-1):\n            angle = m * 180.0 / n\n            diff = abs(angle - a)\n            if diff < min_diff:\n                min_diff = diff\n                best_m = m\n            elif diff == min_diff:\n                if m < best_m:\n                    best_m = m\n\n        v2 = 1\n        v1 = 2\n        v3 = 2 + best_m\n\n        print(f\"{v1} {v2} {v3}\")\n\n    if __name__ == \"__main__\":\n        main()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 712,
        "completion_token_count": 4933,
        "thoughts_token_count": 1024
    }
}