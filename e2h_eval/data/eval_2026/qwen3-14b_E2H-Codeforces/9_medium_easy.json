{
    "start": 1758022299.8400726,
    "end": 1758025343.8496673,
    "start-formatted": "2025-09-16 20:31 KST",
    "end-formatted": "2025-09-16 21:22 KST",
    "gpu": 2,
    "pid": 9,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Selling Souvenirs\n\nAfter several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.This morning, as usual, Petya will come to the market. Petya has n different souvenirs to sell; ith souvenir is characterised by its weight wi and cost ci. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than m, and total cost is maximum possible.Help Petya to determine maximum possible total cost.\n\n## Input\nThe first line contains two integers n and m (1 ≤ n ≤ 100000, 1 ≤ m ≤ 300000) — the number of Petya's souvenirs and total weight that he can carry to the market.Then n lines follow. ith line contains two integers wi and ci (1 ≤ wi ≤ 3, 1 ≤ ci ≤ 109) — the weight and the cost of ith souvenir.\n\n## Output\nPrint one number — maximum possible total cost of souvenirs that Petya can carry to the market.\n\n## Example\n### Input\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\n### Output\n['0', '3', '10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\nOkay, let's tackle this problem. So, the task is to find the maximum possible total cost of souvenirs that Petya can carry, given that each souvenir has a weight (1, 2, or 3) and a cost. The constraints are n up to 1e5 and m up to 3e5. Hmm, so a standard knapsack approach might not work here because with n=1e5 and m=3e5, the O(nm) solution would be way too slow. So I need a smarter approach.\n\nLet me think. Since the weights are only 1, 2, or 3, maybe we can handle each weight category separately. For example, for all items of weight 1, we can take as many as possible (sorted by cost descending), same for weight 2 and 3. But how do we combine them optimally?\n\nWait, but there's a catch. Because taking some items of weight 2 might be better than taking two items of weight 1. So the problem becomes how to optimally choose between different combinations of items of different weights.\n\nSo maybe the approach is:\n\n- Sort all items of each weight group in descending order of cost.\n- For each weight group, precompute a prefix sum array so that for any number of items taken, we can get the total cost quickly.\n\nOnce we have these prefix sums, the problem reduces to choosing how many items from each weight group to take, such that the total weight is <= m, and the total cost is maximized.\n\nBut how to efficiently compute this combination?\n\nLet me think. Let's say we have:\n\nFor weight 1: sorted list, prefix sum array s1, where s1[k] is the sum of first k items.\n\nSimilarly for weight 2: s2, and weight 3: s3.\n\nThen, the problem becomes selecting a, b, c such that 1*a + 2*b + 3*c <= m, and maximize s1[a] + s2[b] + s3[c].\n\nBut considering that a can be up to the number of weight 1 items, same for b and c.\n\nBut trying all possible combinations of a, b, c is going to be O(n^3), which is impossible. So we need a smarter way.\n\nAlternative idea: Iterate over the number of weight 3 items, then for each possible c, compute the best combination of a and b for the remaining weight.\n\nBut even that might be expensive. Let's think about the maximum possible c. Since each item is weight 3, the maximum c is min( (m//3), number of weight 3 items). So if m is 3e5, then c can be up to 1e5. So for each c, we need to process the remaining weight m - 3c, and then find the best a and b for that.\n\nBut for each c, how to find the best a and b? Let's think: For the remaining weight W = m - 3c, we need to select a and b such that a + 2b <= W. How to maximize s1[a] + s2[b].\n\nNow, for this part, perhaps we can precompute for each possible weight W, the maximum sum for a and b. But how?\n\nAlternatively, for each possible b (number of weight 2 items taken), the maximum a is (W - 2b). So for each possible b, we can take up to (W - 2b) items of weight 1. But again, trying all possible b for each c could be expensive. However, since the weight 2 items are sorted, perhaps we can precompute their prefix sums, and for each possible W, find the optimal combination of a and b.\n\nWait, but for each W, how to find the best combination of a and b?\n\nLet me think: For a given W, we can try all possible numbers of weight 2 items (b) up to min(k2, W//2), where k2 is the number of weight 2 items. Then for each b, the maximum a is min(k1, (W - 2*b)), where k1 is the number of weight 1 items. Then the total cost is s1[a] + s2[b]. But even for W up to 3e5, and for each c, this could be O(W) time, which would be too slow.\n\nBut maybe we can optimize this. Let's consider that for each possible W, we can iterate through all possible b values up to min(k2, W//2), but that's still O(W) per c. Which would be O(m) per c, and with c up to m/3, that would be O(m^2), which is 9e10 operations. That's way too slow.\n\nHmm, so this approach isn't feasible. Need a better way.\n\nAlternative idea: For each possible number of weight 2 items, we can precompute the best possible number of weight 1 items. Let me think.\n\nSuppose we have for weight 2 items, their prefix sum s2. For each possible b, the maximum number of weight 1 items we can take is (W - 2*b). So for a given W, the maximum value of s2[b] + s1[min(k1, W - 2*b)].\n\nBut how to find this maximum quickly?\n\nLet me think: For each possible W, the optimal choice of b is such that 2b is as large as possible, but not exceeding W, but also considering that s2[b] is high. However, since the weight 2 items are sorted in descending order, the prefix sum s2 is non-decreasing. So for a given W, if we take more weight 2 items, it's possible that the s2 increases, but the available space for weight 1 items decreases.\n\nBut perhaps for a given W, the optimal b can be found by checking all possible b up to min(k2, W//2), but that's again O(W) time. Not helpful.\n\nWait, but maybe for a given W, the optimal b is either floor(W/2) or something like that. But I'm not sure.\n\nAlternative approach: Let's precompute for all possible weight 2 items and weight 1 items. For example, for each possible total weight W, what's the maximum value of s1[a] + s2[b], where a + 2b <= W.\n\nBut how to compute this efficiently.\n\nAnother idea: For each possible b, the maximum a is (W - 2b). So for each possible W, the maximum value is max over b (s2[b] + s1[ min(k1, W - 2b) ] )\n\nBut how to compute this max quickly. Let's think about for each possible W, what is the best b.\n\nBut since the weight 2 items are sorted, the s2 array is non-decreasing. So for a given W, the maximum b can be up to min( (W//2), len(s2)-1 ). For each possible b in 0 to that maximum, we can compute the corresponding a. But again, this seems O(W) for each W.\n\nBut perhaps we can precompute for all possible W, the best combination. However, with m up to 3e5, and for each W, that would be O(m) time. But that would be O(m^2) time, which is not feasible.\n\nAlternative Idea: Since the weight 1 items are sorted, for any given available weight (say, x), the maximum value from weight 1 is the sum of the first min(x, k1) items. Similarly, for weight 2 items, for a given available weight y, the maximum value is the sum of the first min(y//2, k2) items. But how to combine these.\n\nWait, but when combining weight 1 and 2, the problem is to choose how much to take from each. But perhaps we can precompute for all possible x (the total weight allocated to weight 1 and 2), the best combination of weight 1 and 2 items.\n\nBut how?\n\nLet me think of this as a separate problem. Suppose I have two groups: items of weight 1 and items of weight 2. What is the maximum total value I can get with total weight up to X.\n\nHow to compute this quickly?\n\nLet me denote that for the weight 1 items, the prefix sum is s1, and for the weight 2 items, the prefix sum is s2.\n\nFor a given X, the maximum value is max over all possible b (number of weight 2 items taken) of s2[b] + s1[ min( (X - 2*b), len(s1) ) ].\n\nBut how to compute this maximum quickly.\n\nBut since the weight 2 items are sorted, and their prefix sum is increasing, perhaps for each possible X, we can find the optimal b in O(1) or O(log n) time.\n\nAlternatively, for each possible X, the optimal b is up to min( X//2, len(s2) ), and we can find the best among those.\n\nBut even this, if done naively, would be O(X) for each X, which is not feasible.\n\nWait, but for the case where we have only weight 1 and 2 items, perhaps we can precompute for all possible numbers of weight 2 items, and for each possible number of weight 2 items, compute the maximum possible weight 1 items that can be added. Then, for each possible X, find the best combination.\n\nAlternatively, for each possible number of weight 2 items (say, up to the maximum possible for the entire problem), we can compute the total weight used (2*b), and then the remaining weight is X - 2*b, which can be filled with weight 1 items. So for each possible b, the total value is s2[b] + s1[ min( (X - 2*b), len(s1) ) ].\n\nBut again, for each X, how to find the best b.\n\nBut perhaps we can precompute for all possible b, and for each possible X, find the best b such that 2*b <= X. However, this seems challenging.\n\nAnother Idea: For the weight 1 and 2 items, for each possible number of weight 2 items taken (up to the maximum possible), we can precompute the best possible number of weight 1 items that can be taken. Then, for each X, the maximum value is the maximum over all possible b where 2*b <= X.\n\nBut how to do that.\n\nLet me think: Let's precompute the prefix sums for weight 1 and 2. Let's say we have s1 and s2.\n\nFor each possible b (number of weight 2 items taken), the maximum number of weight 1 items that can be taken is (X - 2*b). However, since X can vary, perhaps for each b, we can consider that for any X >= 2*b, the contribution is s2[b] + s1[ min( (X - 2*b), k1 ) ].\n\nBut how to find, for a given X, the maximum of this expression across all possible b.\n\nAlternatively, for each possible X, the optimal b can be found by checking the possible b values that are up to X//2, but that's again O(X) per X.\n\nThis seems stuck. Let's think back to the original problem.\n\nThe original problem allows for three different weights, but perhaps the key is that the weights are small (1, 2, 3). So, perhaps we can handle the problem by considering for each possible number of weight 3 items, and then solving the subproblem of weight 1 and 2 items with the remaining capacity.\n\nBut even then, solving the weight 1 and 2 subproblem efficiently is crucial.\n\nAlternative Idea: For the weight 1 and 2 items, for each possible total weight (let's call it W), the maximum value can be computed by considering that for each possible number of weight 2 items (b), the maximum a is (W - 2*b). So, for each possible W, the maximum is the maximum of s2[b] + s1[ min( (W - 2*b), k1 ) ] for all b from 0 to min( W//2, len(s2) ). \n\nBut if we can precompute for all possible W up to m, then during the processing of weight 3 items, we can just query this precomputed array.\n\nBut how to precompute this array for all W up to m.\n\nLet me think. Let's suppose that the maximum possible W is up to m, which is 3e5. So for each W from 0 to m, we need to compute the maximum value for weight 1 and 2 items.\n\nHow can we compute this efficiently?\n\nLet me think of the following approach for the weight 1 and 2 items:\n\nWe can iterate through all possible b (number of weight 2 items taken) and for each b, we can add the corresponding value to all W >= 2*b. But this seems complicated.\n\nAlternatively, for each possible W, the maximum value can be found by considering two possibilities:\n\n1. Take as many weight 2 items as possible, and fill the rest with weight 1 items.\n\nOR\n\n2. Take one less weight 2 item, and fill the rest with weight 1 items.\n\nBut this might not capture the optimal choice.\n\nAnother Idea: Since the weight 1 items are sorted, for a given W, the maximum number of weight 1 items is min(W, k1), and their sum is s1[min(W, k1)]. Similarly, if we take no weight 2 items, then the maximum is s1[W].\n\nBut if we take some weight 2 items, then perhaps the optimal is to take as many weight 2 items as possible, but maybe not all. However, since the weight 2 items are sorted in descending order, taking more of them gives higher value, but leaves less room for weight 1 items.\n\nSo for a given W, the optimal b can be in the range of 0 to min( W//2, len(s2) ), and we can find the best b in this range.\n\nBut how to find this quickly.\n\nLet me think of the following approach: For each possible W, we can try all possible b in the range [max(0, b_opt - K), min( W//2, len(s2) ) ] where K is a small number, like 300. Because if the optimal b is within this range, then we can check all of them and find the maximum. This is called the \"convex hull trick\" or some kind of approximation. However, I'm not sure if this would work.\n\nBut why would this work? Well, for example, if the weight 2 items are very valuable, then taking as many as possible would be better. But if the weight 1 items are very valuable, then taking fewer weight 2 items and more weight 1 items would be better. However, the optimal point is somewhere in between. But since the weight 2 items are sorted, the s2 array is non-decreasing, and the s1 array is also non-decreasing. So the function f(b) = s2[b] + s1[ min( W - 2b, k1 ) ] is not necessarily unimodal. But maybe for a given W, the maximum occurs near the point where 2b is approximately W - something. \n\nAlternatively, for a given W, the optimal b is around floor(W / 2), or floor((W - x)/2), where x is the weight of the weight 1 items. But I'm not sure.\n\nAlternatively, since the weight 2 items are sorted in descending order, their prefix sum is strictly increasing. Similarly for weight 1 items. So for a given W, the function f(b) is s2[b] + s1[ min( W - 2b, k1 ) ].\n\nIf W is fixed, then as b increases, 2b increases, so W - 2b decreases, so the s1 term decreases. However, the s2 term increases. So the function f(b) may have a single peak. If this is true, then we can perform ternary search on b to find the maximum value.\n\nBut is the function unimodal? Let's see. For example, when you increase b by 1, the s2 increases by the next item's cost, while the s1 decreases by the cost of the weight 1 items that are no longer taken. Depending on which is larger, the function can increase or decrease. However, it's possible that the function is not strictly unimodal. But perhaps for practical purposes, assuming that it is, and using ternary search, we can find the maximum.\n\nBut how to verify this. Let's take an example.\n\nSuppose W is 5. The weight 2 items have costs [5, 4, 3]. So s2 is [0,5,9,12]. The weight 1 items have costs [6,5,4,3,2,1]. So s1 is [0,6,11,15,18,19,20]. Now, for each possible b:\n\nb=0: s2[0] + s1[5] = 0+19=19\n\nb=1: 5 + s1[5-2=3] =5+15=20\n\nb=2:9 + s1[5-4=1] =9+6=15\n\nb=3: 12 + s1[5-6= negative, so min(5-6, ...)=0 → 12+0=12.\n\nSo maximum is 20 at b=1. So the function increases then decreases. So unimodal.\n\nAnother example: suppose W=6, weight 2 items [3,3], weight 1 items [5,5,5]. So s2 is [0,3,6], s1 is [0,5,10,15].\n\nFor b=0: 0 + s1[6] = 15.\n\nb=1: 3 + s1[6-2=4 → min(3,4) is 3 → 3+10=13.\n\nb=2: 6 + s1[6-4=2 → 6+5=11.\n\nSo maximum is at b=0. But here, the function decreases as b increases. So it's unimodal.\n\nAnother example where the function increases and then decreases. So perhaps the function is unimodal. If that's the case, then ternary search can be applied.\n\nAssuming that, then for each W, we can perform a ternary search on b (number of weight 2 items taken) in the range [0, min( W//2, len(s2) -1 )], and find the maximum value of f(b).\n\nBut how to implement this. Well, for each W, the possible b ranges from 0 to max_b = min( W//2, len(s2)-1 ). For each W, we can compute this max_b, and then perform ternary search in that range.\n\nBut since W can be up to 3e5, and for each W we perform a ternary search (log(max_b) steps), then for the weight 1 and 2 subproblem, this would be O(m log n) time. Then, for the original problem, we need to loop through all possible c (number of weight 3 items taken), which is up to m//3 steps, and for each, compute the remaining weight W = m - 3*c, and then compute the maximum value for the weight 1 and 2 items for W. So overall time would be O(m log n) for the weight 1 and 2 part, plus O(m) for the loop over c.\n\nBut what's the total time?\n\nLet me calculate:\n\nFor the weight 1 and 2 subproblem, the ternary search per W is O(log (k2)), where k2 is the number of weight 2 items. For m up to 3e5, and per W, this is acceptable.\n\nBut for the original problem, the loop over c can be up to m//3 steps. So for m=3e5, that's 1e5 steps. Each step involves computing the max for weight 1 and 2 for W = m - 3c. So the total time would be O( (m/3) * log (k2) ) steps.\n\nBut then, how to handle the weight 1 and 2 subproblem for all possible W?\n\nWait, but for each c, the W is m - 3c, which varies. So during the main loop, for each c, we need to compute the maximum value of the weight 1 and 2 items for that particular W. So for each W, we perform a ternary search. Thus, the total time for this part would be O( (m/3) * log (k2) ), which is acceptable.\n\nBut how to implement this.\n\nSo, the plan is:\n\n1. Separate the items into three groups based on their weight (1, 2, 3).\n\n2. Sort each group in descending order of cost.\n\n3. Compute prefix sums for each group.\n\n   For example, for weight 1 items, prefix_s1[i] is the sum of the first i items. Similarly for prefix_s2 and prefix_s3.\n\n4. For the weight 3 items, loop through all possible c (number of items taken) from 0 to min( len(weight3), m//3 ). For each c:\n\n   a. Compute the remaining weight: rem_weight = m - 3*c.\n\n   b. Compute the maximum value from weight 1 and 2 items for rem_weight.\n\n   c. Add this value to prefix_s3[c], and keep track of the maximum total.\n\n5. The maximum total across all possible c is the answer.\n\nNow, the key is step 4b: how to compute the maximum value for weight 1 and 2 items given a rem_weight.\n\nImplementing that via ternary search.\n\nBut how to implement the ternary search for a given W.\n\nLet me outline the code for that function.\n\nFunction get_max_1_2(W):\n\n   low = 0\n\n   high = min( len(s2) -1, W // 2 )\n\n   best = 0\n\n   while low <= high:\n\n       mid1 = low + (high - low) // 3\n\n       mid2 = high - (high - low) // 3\n\n       val1 = s2[mid1] + s1[ min( W - 2*mid1, len(s1)-1 ) ]\n\n       val2 = s2[mid2] + s1[ min( W - 2*mid2, len(s1)-1 ) ]\n\n       if val1 < val2:\n\n           best = max(best, val2)\n\n           low = mid1 + 1\n\n       else:\n\n           best = max(best, val1)\n\n           high = mid2 - 1\n\n   # Also check the endpoints\n\n   for b in [low, high, 0, ... ] ?\n\n   return best\n\nBut this is a rough sketch. Alternatively, perform a binary search for the optimal b. But I'm not sure. Another approach is to iterate through all possible b in the range [max(0, max_b - 200), max_b], since the optimal b is likely to be in that vicinity. For example, if we check all possible b in the range of 0 to max_b, but for large max_b, that would be too slow. However, since the weight 2 items are sorted, and for each W, the max_b is up to W//2, which could be up to 3e5/2 = 1.5e5. For each W, checking all possible b up to that would be O(1.5e5) per W, which multiplied by 1e5 steps would be O(1.5e10) operations. Which is way too slow.\n\nThus, the ternary search approach is needed. But how to make sure it works.\n\nAnother Idea: For the function f(b) = s2[b] + s1[ min(W - 2b, len(s1)) ], the maximum is achieved when the derivative (change) is zero. But since this is a discrete function, it's hard to model. However, if the function is unimodal, then ternary search can find the maximum.\n\nBut how to confirm that the function is indeed unimodal.\n\nIn the first example, it was unimodal. Let's think of another example where it's not.\n\nSuppose W=4, weight 2 items [5, 5], weight 1 items [6, 6].\n\ns2 = [0,5,10]\n\ns1 = [0,6, 12]\n\nFor b=0: 0 + s1[4] = 12 (since len(s1) is 2, min(4, 2) is 2 → 12.\n\nb=1: 5 + s1[4-2=2 → 12 → 5+12=17.\n\nb=2: 10 + s1[4-4=0 → 0 → 10.\n\nSo the function increases from b=0 to 1, then decreases. So unimodal.\n\nAnother example: W=5, weight 2 items [4,3,3], weight 1 items [5,5,5,5].\n\ns2 is [0,4,7,10], s1 is [0,5,10,15,20].\n\nPossible b:\n\nb=0 → 0 + 20 (since 5-0=5, but len(s1) is 4 → 20.\n\nb=1 → 4 + s1[5-2=3 → 15 → 4+15=19.\n\nb=2 → 7 + s1[5-4=1 → 5 → 12.\n\nb=3 → 10 + s1[5-6=negative → 0 → 10.\n\nSo maximum is at b=0. So again, unimodal.\n\nAnother test case where there are multiple peaks. Let's imagine:\n\nW=6.\n\nweight 2 items: [5, 5, 5], s2 is [0,5,10,15]\n\nweight 1 items: [5,5,5,5,5,5], s1 is [0,5,10,15,20,25,30].\n\nFor b=0 → 0 + 30 (since 6-0=6, len(s1)=6 → 30.\n\nb=1 → 5 + s1[6-2=4 → 20 → total 25.\n\nb=2 → 10 + s1[6-4=2 → 10 → total 20.\n\nb=3 → 15 + s1[6-6=0 → 0 → 15.\n\nSo function is decreasing. Still unimodal.\n\nAnother case where there's a dip but then rise again? Let's see:\n\nW=5.\n\nweight 2 items: [3, 4, 3], sorted as [4,3,3]. So s2 is [0,4,7,10].\n\nweight 1 items: [5,5,5,5,5]. s1 is [0,5,10,15,20,25].\n\nFor b=0 → 0 + 25 (since 5-0=5 → 5 items → 25.\n\nb=1 → 4 + s1[5-2=3 → 15 → total 19.\n\nb=2 → 7 + s1[5-4=1 → 5 → total 12.\n\nb=3 → 10 + s1[5-6= -1 → 0 → total 10.\n\nSo again, unimodal.\n\nHmm. It seems that the function is unimodal. So ternary search can be used.\n\nThus, the plan is:\n\nImplement a function that, given a weight W, returns the maximum value obtainable from weight 1 and 2 items with total weight <= W.\n\nThis function uses ternary search on the number of weight 2 items (b) that can be taken, and for each b, computes the maximum possible a (number of weight 1 items) as min( (W - 2*b), len(s1) ), and returns the sum.\n\nBut how to implement this in code.\n\nNow, in Python, for each W, the code would be something like:\n\ndef max_1_2(W):\n\n    max_b = min( len(s2) -1, W // 2 )\n\n    low = 0\n\n    high = max_b\n\n    best = 0\n\n    while low <= high:\n\n        mid = (low + high) // 2\n\n        # compute value for mid and mid + 1 ?\n\n        # Or compare mid and mid + 1 ?\n\n        # Alternative approach for ternary search:\n\n        # Compare mid and mid + 1 to decide which direction to go.\n\n        # But this is more for finding the maximum in a unimodal function.\n\n        # Let me think.\n\n        # Since the function is unimodal, we can use ternary search.\n\n        # However, in practice, sometimes people use binary search for this.\n\n        # Alternatively, for each W, we can iterate through all possible b in a small range around the optimal point.\n\n        # But for now, let's proceed with the ternary search approach.\n\n        # Let me think of the function as being increasing up to a certain point and then decreasing.\n\n        # So, for a given mid, if f(mid) < f(mid + 1), then the maximum is to the right.\n\n        # Else, it's to the left.\n\n        # So, this is similar to finding the peak in a mountain array.\n\n        # So, here's the code:\n\n        # Let me compute the value at mid and mid + 1.\n\n        # But in the case where mid is the last possible value, mid +1 is out of range.\n\n        # So:\n\n        if mid == max_b:\n\n            val_mid = get_val(mid)\n\n            val_mid_plus_1 = -infinity\n\n        else:\n\n            val_mid = get_val(mid)\n\n            val_mid_plus_1 = get_val(mid + 1)\n\n        if val_mid < val_mid_plus_1:\n\n            # move to the right\n\n            low = mid + 1\n\n        else:\n\n            # move to the left\n\n            high = mid - 1\n\n    # After the loop, check the best value around low, high, etc.\n\n    # But during the loop, we can keep track of the best value.\n\n    # However, this approach may not cover all possibilities. So after finding the approximate peak, we can check all possible values in the vicinity.\n\n    # Alternatively, after the loop, check all values from max(0, low - 2) to min(max_b, low + 2) and pick the maximum.\n\n    # But for the sake of time, perhaps during the loop, we can track the best value.\n\n    # However, implementing this requires modifying the code.\n\n    # So perhaps, during the binary search, we can keep track of the maximum value found so far.\n\n    # Alternatively, after finding the approximate peak, check all possible values in the range [low, high], but that may not be efficient.\n\n    # This is getting complicated. Maybe for the purpose of passing the problem, we can try a different approach.\n\nAlternative Idea: Since the weight 2 items are sorted, and for each possible b, the maximum a is determined, perhaps for each W, we can try all possible b in the range [max(0, max_b - 200), max_b], and take the maximum. Since the optimal b is likely to be close to the maximum possible (since taking more weight 2 items gives higher value), and the number of items is up to 1e5, but for each W, checking 200 possibilities would be manageable.\n\nFor example, for each W, we can check all possible b in the range [max(0, max_b - 200), max_b], and take the maximum. This would be O(200) per W, which is acceptable.\n\nBut why would this work? Well, the weight 2 items are sorted in descending order, so the prefix sum s2 increases as b increases. However, the s1 part decreases as b increases. The optimal point is where the gain from adding a weight 2 item outweighs the loss from having less weight for weight 1 items.\n\nBut if the weight 2 items are very valuable, then taking as many as possible is better. However, if the weight 1 items are very valuable, taking fewer weight 2 items and more weight 1 items is better.\n\nBut in practice, the optimal b is either near the maximum possible (when weight 2 items are more valuable), or near the minimum (when weight 1 items are more valuable). So checking a small range around the maximum possible b would capture the optimal value.\n\nBut how to determine the size of this range. For example, in the worst case, the optimal b could be anywhere, but for the problem's constraints, checking 300 possibilities would be manageable.\n\nLet me think about the example where taking exactly one less weight 2 item gives a better total. For example, if the weight 2 items are [100, 1], and the weight 1 items are [100, 100, ...]. For W=3. Then:\n\nmax_b is 1 (since 3//2 = 1). So checking b=0 and 1:\n\nb=0: s1[3] = 100 + 100 = 200.\n\nb=1: s2[1] = 100 + s1[3-2=1] = 100 + 100 = 200. Same value.\n\nBut if the weight 1 items are [100, 100], and W=3. Then:\n\nb=0: s1[3] is 200 (since len(s1) is 2, so min(3, 2) is 2 → 200.\n\nb=1: 100 + s1[1] → 100 + 100 = 200. Same.\n\nSo checking the range around max_b (which is 1) includes the optimal.\n\nAnother example where the optimal is not at max_b:\n\nW=4, weight 2 items [3, 3], weight 1 items [5,5,5,5]. So:\n\nmax_b = 2 (4//2=2).\n\nb=0: s1[4] = 20 (sum of 4 items).\n\nb=1: 3 + s1[4-2=2 → 10 → total 13.\n\nb=2: 6 + s1[0 → 0 → 6.\n\nSo the maximum is at b=0, which is far from max_b. So checking a small range around max_b (like 200) would not find it. Hence, this approach would fail.\n\nSo this suggests that checking a fixed number of values around max_b is not reliable.\n\nSo back to the ternary search approach. Let's try to implement that.\n\nLet me think again of the function f(b) = s2[b] + s1[ min( W - 2*b, len_s1 ) ].\n\nFor a given W, the maximum of this function can be found with ternary search if it is unimodal. As discussed earlier, examples suggest that it is unimodal.\n\nThus, the ternary search approach is worth trying.\n\nImplementing ternary search:\n\nInitialize low = 0, high = max_b.\n\nWhile low <= high:\n\n   mid = (low + high) // 2\n\n   compare f(mid) with f(mid + 1)\n\n   if f(mid) < f(mid + 1): move to the right (low = mid + 1)\n\n   else: move to the left (high = mid - 1)\n\nOnce the loop ends, the maximum is in the vicinity of low and high. So after the loop, we can check all values in the range [max(0, low - 2), min(max_b, low + 2)] and take the maximum.\n\nBut how to implement this.\n\nLet me write a sample code for this:\n\ndef get_max_1_2(W):\n\n    max_b = min(len(s2)-1, W // 2)\n\n    low = 0\n\n    high = max_b\n\n    while low < high:\n\n        mid = (low + high) // 2\n\n        if get_val(mid) < get_val(mid + 1):\n\n            low = mid + 1\n\n        else:\n\n            high = mid\n\n    # Now, low == high, and it's the peak?\n\n    # But need to check around it.\n\n    # So check from max(0, low - 2) to min(max_b, low + 2)\n\n    best = 0\n\n    for b in range(max(0, low - 2), min(max_b, low + 2) + 1):\n\n        current = get_val(b)\n\n        if current > best:\n\n            best = current\n\n    return best\n\nWhere get_val(b) is:\n\ndef get_val(b):\n\n    w_left = W - 2*b\n\n    a = min(w_left, len_s1)\n\n    return s2[b] + s1[a]\n\nBut what about cases where the optimal is not in this range? Well, the ternary search should have converged to the peak, and checking a few values around it would capture it.\n\nBut how to verify.\n\nIn the earlier example where W=4, the max_b is 2. The loop would proceed as follows:\n\nInitially, low=0, high=2.\n\nmid = 1. Compare get_val(1) vs",
    "response": "\n\nTo solve this problem, we need to determine the maximum possible total cost of souvenirs that Petya can carry given a weight constraint. The souvenirs have weights of 1, 2, or 3, and we need an efficient approach to handle the constraints effectively.\n\n### Approach\n1. **Grouping by Weight**: Separate the souvenirs into three groups based on their weights (1, 2, 3).\n2. **Sorting and Prefix Sums**: Sort each group in descending order of cost and compute prefix sums for each group to quickly calculate the total cost for any number of items taken from each group.\n3. **Iterative Optimization**: For each possible number of weight 3 items that can be taken, compute the remaining weight capacity and use a ternary search approach to determine the optimal combination of weight 1 and weight 2 items that can be carried within the remaining capacity.\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n\n    w1 = []\n    w2 = []\n    w3 = []\n\n    for _ in range(n):\n        wi = int(input[idx])\n        idx += 1\n        ci = int(input[idx])\n        idx += 1\n        if wi == 1:\n            w1.append(ci)\n        elif wi == 2:\n            w2.append(ci)\n        else:\n            w3.append(ci)\n\n    # Sort each list in descending order\n    w1.sort(reverse=True)\n    w2.sort(reverse=True)\n    w3.sort(reverse=True)\n\n    # Compute prefix sums\n    len1 = len(w1)\n    len2 = len(w2)\n    len3 = len(w3)\n\n    prefix1 = [0] * (len1 + 1)\n    for i in range(len1):\n        prefix1[i+1] = prefix1[i] + w1[i]\n\n    prefix2 = [0] * (len2 + 1)\n    for i in range(len2):\n        prefix2[i+1] = prefix2[i] + w2[i]\n\n    prefix3 = [0] * (len3 + 1)\n    for i in range(len3):\n        prefix3[i+1] = prefix3[i] + w3[i]\n\n    max_total = 0\n\n    # Iterate over possible number of weight 3 items\n    max_c = min(len3, m // 3)\n    for c in range(0, max_c + 1):\n        rem_weight = m - 3 * c\n        if rem_weight < 0:\n            continue\n\n        # Now compute max value from weight 1 and 2 with rem_weight\n        def get_val(b):\n            w_left = rem_weight - 2 * b\n            a = min(w_left, len1)\n            return prefix2[b] + prefix1[a]\n\n        max_b = min(len2, rem_weight // 2)\n        low = 0\n        high = max_b\n        while low < high:\n            mid = (low + high) // 2\n            if get_val(mid) < get_val(mid + 1):\n                low = mid + 1\n            else:\n                high = mid\n\n        # Check around low\n        best = 0\n        start = max(0, low - 2)\n        end = min(max_b, low + 2)\n        for b in range(start, end + 1):\n            current = get_val(b)\n            if current > best:\n                best = current\n\n        total = prefix3[c] + best\n        if total > max_total:\n            max_total = total\n\n    print(max_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Grouping and Sorting**: The souvenirs are grouped by their weights and sorted in descending order of cost to prioritize higher value items.\n2. **Prefix Sums**: Prefix sums are computed for each group to allow quick calculation of the total cost for any number of items taken from each group.\n3. **Iterative Optimization**: For each possible count of weight 3 items, the remaining weight capacity is calculated. A ternary search is used to find the optimal combination of weight 1 and weight 2 items that maximizes the total cost within the remaining capacity. This approach ensures we efficiently explore possible combinations without excessive computation.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n\n    w1 = []\n    w2 = []\n    w3 = []\n\n    for _ in range(n):\n        wi = int(input[idx])\n        idx += 1\n        ci = int(input[idx])\n        idx += 1\n        if wi == 1:\n            w1.append(ci)\n        elif wi == 2:\n            w2.append(ci)\n        else:\n            w3.append(ci)\n\n    # Sort each list in descending order\n    w1.sort(reverse=True)\n    w2.sort(reverse=True)\n    w3.sort(reverse=True)\n\n    # Compute prefix sums\n    len1 = len(w1)\n    len2 = len(w2)\n    len3 = len(w3)\n\n    prefix1 = [0] * (len1 + 1)\n    for i in range(len1):\n        prefix1[i+1] = prefix1[i] + w1[i]\n\n    prefix2 = [0] * (len2 + 1)\n    for i in range(len2):\n        prefix2[i+1] = prefix2[i] + w2[i]\n\n    prefix3 = [0] * (len3 + 1)\n    for i in range(len3):\n        prefix3[i+1] = prefix3[i] + w3[i]\n\n    max_total = 0\n\n    # Iterate over possible number of weight 3 items\n    max_c = min(len3, m // 3)\n    for c in range(0, max_c + 1):\n        rem_weight = m - 3 * c\n        if rem_weight < 0:\n            continue\n\n        # Now compute max value from weight 1 and 2 with rem_weight\n        def get_val(b):\n            w_left = rem_weight - 2 * b\n            a = min(w_left, len1)\n            return prefix2[b] + prefix1[a]\n\n        max_b = min(len2, rem_weight // 2)\n        low = 0\n        high = max_b\n        while low < high:\n            mid = (low + high) // 2\n            if get_val(mid) < get_val(mid + 1):\n                low = mid + 1\n            else:\n                high = mid\n\n        # Check around low\n        best = 0\n        start = max(0, low - 2)\n        end = min(max_b, low + 2)\n        for b in range(start, end + 1):\n            current = get_val(b)\n            if current > best:\n                best = current\n\n        total = prefix3[c] + best\n        if total > max_total:\n            max_total = total\n\n    print(max_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 481,
        "completion_token_count": 947,
        "thoughts_token_count": 8191
    }
}