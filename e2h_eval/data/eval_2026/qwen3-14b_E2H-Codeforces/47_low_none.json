{
    "start": 1758309322.3483555,
    "end": 1758309659.854862,
    "start-formatted": "2025-09-20 04:15 KST",
    "end-formatted": "2025-09-20 04:20 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\nOkay, let's see. I need to find the smallest non-negative integer k such that the LCM of (a +k) and (b +k) is minimized. And if there are multiple k's with the same minimal LCM, pick the smallest one.\n\nHmm. Let's think about the problem. Let me first note that a and b are given, and we add the same k to both. So, let me denote x = a +k and y = b +k. Then, since k is non-negative, x and y are at least a and b respectively. But since k is the same for both, the difference between x and y is (b - a). Wait, because x - y = (a +k) - (b +k) = a - b. So the difference between x and y is fixed as (a - b), but since x and y are in the same order as a and b. So, without loss of generality, let's assume that a ≤ b. Wait, but maybe not. Let me think: suppose a is 6 and b is 10. Then, when k is 2, x is 8 and y is 12. Their difference is 4, which is same as original difference (10-6=4). So the difference between x and y is always (b -a) if a < b. So perhaps we can assume that a and b are ordered. So maybe first, we can sort them. Let me think: if a is bigger than b, then swapping them would not change the problem. Because adding k to both would make x and y with difference (a - b) in either case. So, perhaps I can first swap a and b so that a ≤ b. That might help in reasoning.\n\nSo, let me assume that a ≤ b. Then, the difference between the two numbers is d = b - a. So, when we add k to both, the new numbers are x = a +k and y = b +k = x + d. So, the problem reduces to finding x such that x ≥ a (since k ≥ 0) and the LCM of x and x +d is minimized.\n\nSo the problem becomes: find x ≥ a (since k is non-negative, x = a +k ≥ a) such that LCM(x, x +d) is minimized. Then, the minimal k is x -a.\n\nBut how do we find this x?\n\nLet me recall that LCM(x, y) = (x*y)/GCD(x, y). So for x and x +d, their GCD is GCD(x, x +d) = GCD(x, d). Because GCD(x, x +d) = GCD(x, d). So, the LCM of x and x +d is (x*(x +d))/GCD(x, d).\n\nSo, the problem becomes minimizing (x*(x +d)) / GCD(x, d), where x ≥ a, and d is fixed as (b -a).\n\nBut how do we find the x that minimizes this expression?\n\nLet me think. For a given d, what x would minimize this value?\n\nWell, since x and x +d differ by d, their GCD is GCD(x, d). Let me denote g = GCD(x, d). Then, x can be written as g * m, where m is an integer. Also, since d = g * n, where n is some integer. Because GCD(x, d) is g, so d must be divisible by g. So, d = g * n, and x = g * m, where GCD(m, n) = 1. Because x and d share a GCD of g, so after dividing by g, m and n are coprime.\n\nThen, x +d = g*m + g*n = g*(m +n). So the LCM of x and x +d is (g*m * g*(m +n)) / (g) ) = g*m*(m +n). Which simplifies to g*m*(m +n).\n\nBut since d = g*n, then n = d/g. So substituting back, the LCM is g*m*(m + (d/g)).\n\nBut since x = g*m, and x must be ≥ a. So, we have to find m such that g*m ≥ a, and then find the minimal LCM.\n\nBut how to find this? It seems complicated. Maybe there's another approach.\n\nAlternatively, since the LCM is (x*(x +d))/g, where g is GCD(x, d). So, to minimize this, perhaps we want to maximize the GCD(x, d), because the denominator is larger. So, for a given x, higher GCD(x, d) would lead to lower LCM.\n\nBut how to",
    "response": "To solve this problem, we need to find the smallest non-negative integer $ k $ such that the least common multiple (LCM) of $ a + k $ and $ b + k $ is minimized. If there are multiple values of $ k $ that yield the same minimal LCM, we choose the smallest $ k $.\n\n### Approach\n1. **Understanding the Problem**: The key insight is that adding the same value $ k $ to both $ a $ and $ b $ results in two numbers $ x = a + k $ and $ y = b + k $. The difference between these two numbers remains constant as $ d = |b - a| $.\n\n2. **Mathematical Insight**: The LCM of two numbers $ x $ and $ y $ can be expressed as $ \\text{LCM}(x, y) = \\frac{x \\cdot y}{\\text{GCD}(x, y)} $. For $ x $ and $ y $, since their difference is fixed as $ d $, we can express $ y $ as $ x + d $. Thus, the problem reduces to minimizing $ \\text{LCM}(x, x + d) $.\n\n3. **Optimization Insight**: To minimize the LCM, we should maximize the GCD of $ x $ and $ d $. This leads us to consider values of $ x $ that are divisors of $ d $, adjusted to ensure $ x \\geq a $.\n\n4. **Algorithm**: \n   - Compute the absolute difference $ d $ between $ a $ and $ b $.\n   - Iterate over possible values of $ k $ starting from 0, checking for the optimal $ k $ by leveraging the properties of GCD and LCM.\n   - For each candidate $ k $, compute the LCM of $ a + k $ and $ b + k $, and track the minimum LCM and corresponding $ k $.\n\n### Solution Code\n```python\nimport sys\nimport math\n\ndef compute_lcm(x, y):\n    return x * y // math.gcd(x, y)\n\ndef find_min_k(a, b):\n    if a == b:\n        return 0\n    # Ensure a <= b\n    if a > b:\n        a, b = b, a\n    d = b - a\n    min_lcm = float('inf')\n    best_k = 0\n    # We need to check possible k values where (a + k) divides d or similar\n    # However, checking all k up to d might not be efficient, but given constraints, it's manageable\n    # Let's try to find the optimal k\n    # The optimal k is such that (a + k) and (b + k) have maximum GCD\n    # Let's iterate over possible candidates for gcd\n    # Try all possible divisors of d\n    for g in range(1, int(math.isqrt(d)) + 1):\n        if d % g == 0:\n            # Check for g and d/g\n            for candidate_gcd in [g, d // g]:\n                # We want x = a + k to be a multiple of candidate_gcd\n                # Also, x + d = b + k must be a multiple of candidate_gcd\n                # Since x + d = x + (b - a), and x = a + k, so x + d = b + k\n                # So, GCD(x, d) = candidate_gcd\n                # Let's find the minimal x >= a such that GCD(x, d) = candidate_gcd\n                # x must be of the form m * candidate_gcd\n                # Also, since GCD(m, d / candidate_gcd) must be 1\n                # Let's find the minimal m such that m * candidate_gcd >= a\n                m_min = (a + candidate_gcd - 1) // candidate_gcd\n                # Now, check if GCD(m_min, d // candidate_gcd) == 1\n                # Because GCD(x, d) = candidate_gcd * GCD(m, d//candidate_gcd)\n                # So we need GCD(m, d//candidate_gcd) = 1\n                # So, for each m_min, check this\n                # Then x = m_min * candidate_gcd\n                # Then compute k = x - a\n                # But how to find the minimal x?\n                # Let's compute the candidate x\n                x_candidate = m_min * candidate_gcd\n                k_candidate = x_candidate - a\n                # Now, check if this k_candidate gives a valid LCM\n                x = a + k_candidate\n                y = b + k_candidate\n                current_lcm = compute_lcm(x, y)\n                if current_lcm < min_lcm or (current_lcm == min_lcm and k_candidate < best_k):\n                    min_lcm = current_lcm\n                    best_k = k_candidate\n                # Also check m_min - 1, but only if it's >= 1\n                # Wait, m_min is the smallest integer m where m * candidate_gcd >= a\n                # So m_min - 1 would give x_candidate - candidate_gcd which may be less than a\n                # So no need\n    # Also check k=0\n    k_candidate = 0\n    x = a + k_candidate\n    y = b + k_candidate\n    current_lcm = compute_lcm(x, y)\n    if current_lcm < min_lcm or (current_lcm == min_lcm and k_candidate < best_k):\n        min_lcm = current_lcm\n        best_k = k_candidate\n    # Also check for k = d - (a % d) if a % d != 0 else 0\n    # But perhaps the above loop already covers it\n    # However, there might be cases where the optimal k is not covered by the above\n    # So let's also check some other candidates\n    # Try k = (d - (a % d)) % d\n    k_candidate = (d - (a % d)) % d\n    x = a + k_candidate\n    y = b + k_candidate\n    current_lcm = compute_lcm(x, y)\n    if current_lcm < min_lcm or (current_lcm == min_lcm and k_candidate < best_k):\n        min_lcm = current_lcm\n        best_k = k_candidate\n    return best_k\n\ndef main():\n    input = sys.stdin.read().split()\n    for i in range(0, len(input), 2):\n        a = int(input[i])\n        b = int(input[i+1])\n        print(find_min_k(a, b))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Reading Input**: The input is read from standard input and processed in pairs of integers.\n- **Finding Optimal $ k $**: The function `find_min_k` computes the optimal $ k $ by iterating over possible values derived from the divisors of the difference $ d $ between $ a $ and $ b $. This ensures that we consider values of $ k $ that maximize the GCD of the resulting numbers, thus minimizing their LCM.\n- **Efficiency**: By focusing on divisors of $ d $, the solution efficiently narrows down potential candidates for $ k $, ensuring the solution is both optimal and efficient.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\n\ndef compute_lcm(x, y):\n    return x * y // math.gcd(x, y)\n\ndef find_min_k(a, b):\n    if a == b:\n        return 0\n    # Ensure a <= b\n    if a > b:\n        a, b = b, a\n    d = b - a\n    min_lcm = float('inf')\n    best_k = 0\n    # We need to check possible k values where (a + k) divides d or similar\n    # However, checking all k up to d might not be efficient, but given constraints, it's manageable\n    # Let's try to find the optimal k\n    # The optimal k is such that (a + k) and (b + k) have maximum GCD\n    # Let's iterate over possible candidates for gcd\n    # Try all possible divisors of d\n    for g in range(1, int(math.isqrt(d)) + 1):\n        if d % g == 0:\n            # Check for g and d/g\n            for candidate_gcd in [g, d // g]:\n                # We want x = a + k to be a multiple of candidate_gcd\n                # Also, x + d = b + k must be a multiple of candidate_gcd\n                # Since x + d = x + (b - a), and x = a + k, so x + d = b + k\n                # So, GCD(x, d) = candidate_gcd\n                # Let's find the minimal x >= a such that GCD(x, d) = candidate_gcd\n                # x must be of the form m * candidate_gcd\n                # Also, since GCD(m, d / candidate_gcd) must be 1\n                # Let's find the minimal m such that m * candidate_gcd >= a\n                m_min = (a + candidate_gcd - 1) // candidate_gcd\n                # Now, check if GCD(m_min, d // candidate_gcd) == 1\n                # Because GCD(x, d) = candidate_gcd * GCD(m, d//candidate_gcd)\n                # So we need GCD(m, d//candidate_gcd) = 1\n                # So, for each m_min, check this\n                # Then x = m_min * candidate_gcd\n                # Then compute k = x - a\n                # But how to find the minimal x?\n                # Let's compute the candidate x\n                x_candidate = m_min * candidate_gcd\n                k_candidate = x_candidate - a\n                # Now, check if this k_candidate gives a valid LCM\n                x = a + k_candidate\n                y = b + k_candidate\n                current_lcm = compute_lcm(x, y)\n                if current_lcm < min_lcm or (current_lcm == min_lcm and k_candidate < best_k):\n                    min_lcm = current_lcm\n                    best_k = k_candidate\n                # Also check m_min - 1, but only if it's >= 1\n                # Wait, m_min is the smallest integer m where m * candidate_gcd >= a\n                # So m_min - 1 would give x_candidate - candidate_gcd which may be less than a\n                # So no need\n    # Also check k=0\n    k_candidate = 0\n    x = a + k_candidate\n    y = b + k_candidate\n    current_lcm = compute_lcm(x, y)\n    if current_lcm < min_lcm or (current_lcm == min_lcm and k_candidate < best_k):\n        min_lcm = current_lcm\n        best_k = k_candidate\n    # Also check for k = d - (a % d) if a % d != 0 else 0\n    # But perhaps the above loop already covers it\n    # However, there might be cases where the optimal k is not covered by the above\n    # So let's also check some other candidates\n    # Try k = (d - (a % d)) % d\n    k_candidate = (d - (a % d)) % d\n    x = a + k_candidate\n    y = b + k_candidate\n    current_lcm = compute_lcm(x, y)\n    if current_lcm < min_lcm or (current_lcm == min_lcm and k_candidate < best_k):\n        min_lcm = current_lcm\n        best_k = k_candidate\n    return best_k\n\ndef main():\n    input = sys.stdin.read().split()\n    for i in range(0, len(input), 2):\n        a = int(input[i])\n        b = int(input[i+1])\n        print(find_min_k(a, b))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 394,
        "completion_token_count": 1559,
        "thoughts_token_count": 1024
    }
}