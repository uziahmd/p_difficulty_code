{
    "start": 1758309526.054576,
    "end": 1758309580.716546,
    "start-formatted": "2025-09-20 04:18 KST",
    "end-formatted": "2025-09-20 04:19 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\nOkay, let's see. I need to solve this problem where I have to determine the number of mushrooms on each lawn based on the GCD and LCM values given for each road. Hmm. Let's think about the approach here.\n\nSo, each road connects two lawns (nodes) and has a GCD and LCM of their mushroom counts. Let me recall that for two numbers a and b, GCD(a,b) * LCM(a,b) = a*b. So for each edge, if we have GCD g and LCM l, then the product of the two numbers must be g*l. Also, since GCD divides both numbers, each number must be a multiple of g. Let me think: Let's say the two numbers are x and y. Then x = g * a, y = g * b, where a and b are coprime (since GCD(x,y) is g). Then LCM(x,y) would be g*a*b. So the LCM given must equal g*a*b. Which means that l must be divisible by g. Otherwise, it's impossible. Wait, because l is the LCM, so l must be a multiple of g. So first check for each edge: if l % g != 0, then it's impossible. Because otherwise, the LCM would not be a multiple of the GCD. So that's a necessary condition. So for each edge, we can check if l % g is not zero, then output NO.\n\nSo first step: For each edge, check if LCM is divisible by GCD. If any isn't, return NO.\n\nThen, for each edge, the product of the two nodes' values is g*l. But since x and y are g*a and g*b, and LCM is g*a*b. So, the LCM is g*a*b. Which implies that l = g*a*b. Therefore, a*b = l/g. And since a and b are coprime, the product a*b must be equal to l/g, and a and b must be coprime. So, for each edge, the l/g must be a product of two coprime numbers. But since a and b are coprime, that's already handled by the way we split them. But how does that help us?\n\nBut perhaps for the problem, the main idea is to model this as a graph where each node has a value, and each edge gives constraints between two nodes. The problem is similar to building a system of equations where for each edge between u and v, the values of u and v must satisfy that their GCD is g and LCM is l. However, since the values are connected through multiple edges, we need to find a consistent assignment of values to nodes.\n\nBut how to model this? Maybe using a Union-Find (Disjoint Set Union) structure? Or maybe building a graph where each node's value is determined relative to others. For example, if two nodes are connected by an edge, their values must be multiples of g, and their product is g*l. But how to assign these values?\n\nAnother approach: For each connected component in the graph, we can assign values to nodes such that the constraints are satisfied. Let's think of each node's value as being a multiple of some base value. For example, if two nodes u and v are connected with GCD g and LCM l, then their values must be g*a and g*b, where a and b are coprime, and a*b = l/g. So, for each edge, we can represent the relationship between u and v as a ratio or some relation. But how to model this across the entire graph?\n\nWait, but since a and b are coprime, and their product is l/g, then the possible pairs (a,b) are such that a divides l/g and b divides l/g, and they are coprime. However, since the problem allows any valid assignment, maybe we can choose a particular way to assign the values. For example, for each edge, we can assign one of the nodes a value of g * a and the other as g * b, where a*b = l/g and gcd(a,b)=1.\n\nBut how do we ensure that all constraints are satisfied across the entire graph?\n\nThis seems like a problem that can be modeled as a graph where each node's value is determined relative to others. For example, if we have a tree structure, we can assign values starting from a root node. But if there are cycles, we need to check for consistency.\n\nLet me think. Suppose we model the problem as building a graph where each edge enforces that the two nodes have values that are multiples of g, and their product is g*l. Let me consider that for each node, its value must be a multiple of some base. But how?\n\nAlternatively, considering that for each edge between u and v, the value of u and v must be",
    "response": "To solve this problem, we need to determine the number of mushrooms on each lawn based on the given GCD and LCM values for each road connecting two lawns. The key insight is that the product of the mushroom counts on two connected lawns must be equal to the product of their GCD and LCM. Additionally, each value must be a multiple of the GCD.\n\n### Approach\n1. **Check Validity**: For each edge, check if the LCM is divisible by the GCD. If not, it's impossible to restore the values, so we immediately return \"NO\".\n2. **Graph Construction**: Construct a graph where each node represents a lawn and each edge represents the constraints given by the GCD and LCM.\n3. **Breadth-First Search (BFS)**: Use BFS to traverse the graph starting from an arbitrary node, assigning values to nodes while ensuring all constraints are satisfied. If a contradiction is found during traversal, return \"NO\".\n\n### Solution Code\n```python\nimport sys\nimport math\nfrom collections import deque, defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n    \n    edges = []\n    graph = defaultdict(list)\n    for _ in range(m):\n        u = int(input[idx]) - 1\n        idx += 1\n        v = int(input[idx]) - 1\n        idx += 1\n        g = int(input[idx])\n        idx += 1\n        l = int(input[idx])\n        idx += 1\n        edges.append((u, v, g, l))\n        graph[u].append((v, g, l))\n        graph[v].append((u, g, l))\n    \n    # Check if any LCM is not divisible by GCD\n    for u, v, g, l in edges:\n        if l % g != 0:\n            print(\"NO\")\n            return\n    \n    # Assign values using BFS\n    values = [-1] * n\n    visited = [False] * n\n    \n    for start in range(n):\n        if visited[start]:\n            continue\n        queue = deque()\n        queue.append(start)\n        visited[start] = True\n        values[start] = 1  # arbitrary value, but will be adjusted\n        valid = True\n        \n        while queue:\n            u = queue.popleft()\n            for v, g, l in graph[u]:\n                if values[u] == -1:\n                    # This shouldn't happen as we start with start node\n                    continue\n                if values[v] == -1:\n                    # Compute possible value for v\n                    # We know that values[u] * values[v] = g * l\n                    # Also, GCD(values[u], values[v]) = g\n                    # So values[u] must be a multiple of g, same for values[v]\n                    # Let's assume values[u] is fixed, then values[v] = (g * l) / values[u]\n                    # But need to check if GCD is correct\n                    product = g * l\n                    if values[u] == 0:\n                        valid = False\n                        break\n                    if product % values[u] != 0:\n                        valid = False\n                        break\n                    val_v = product // values[u]\n                    # Now check that GCD(values[u], val_v) == g\n                    if math.gcd(values[u], val_v) != g:\n                        valid = False\n                        break\n                    values[v] = val_v\n                    visited[v] = True\n                    queue.append(v)\n                else:\n                    # Check if current values are consistent\n                    if values[u] * values[v] != g * l or math.gcd(values[u], values[v]) != g:\n                        valid = False\n                        break\n            if not valid:\n                break\n        if not valid:\n            print(\"NO\")\n            return\n    \n    # After processing all components\n    print(\"YES\")\n    print(' '.join(map(str, values)))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Validity Check**: Each edge's LCM must be divisible by its GCD. If not, the configuration is impossible.\n2. **Graph Traversal**: Using BFS, we start from an arbitrary node and assign values based on the constraints. For each node, we ensure that the product of its value and its neighbor's value matches the product of the GCD and LCM of the edge connecting them.\n3. **Consistency Check**: During BFS traversal, we check if the assigned values maintain the required GCD and LCM constraints. If any inconsistency is found, we print \"NO\".\n\nThis approach ensures that we efficiently check all constraints and determine a valid configuration if possible.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\nfrom collections import deque, defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n    \n    edges = []\n    graph = defaultdict(list)\n    for _ in range(m):\n        u = int(input[idx]) - 1\n        idx += 1\n        v = int(input[idx]) - 1\n        idx += 1\n        g = int(input[idx])\n        idx += 1\n        l = int(input[idx])\n        idx += 1\n        edges.append((u, v, g, l))\n        graph[u].append((v, g, l))\n        graph[v].append((u, g, l))\n    \n    # Check if any LCM is not divisible by GCD\n    for u, v, g, l in edges:\n        if l % g != 0:\n            print(\"NO\")\n            return\n    \n    # Assign values using BFS\n    values = [-1] * n\n    visited = [False] * n\n    \n    for start in range(n):\n        if visited[start]:\n            continue\n        queue = deque()\n        queue.append(start)\n        visited[start] = True\n        values[start] = 1  # arbitrary value, but will be adjusted\n        valid = True\n        \n        while queue:\n            u = queue.popleft()\n            for v, g, l in graph[u]:\n                if values[u] == -1:\n                    # This shouldn't happen as we start with start node\n                    continue\n                if values[v] == -1:\n                    # Compute possible value for v\n                    # We know that values[u] * values[v] = g * l\n                    # Also, GCD(values[u], values[v]) = g\n                    # So values[u] must be a multiple of g, same for values[v]\n                    # Let's assume values[u] is fixed, then values[v] = (g * l) / values[u]\n                    # But need to check if GCD is correct\n                    product = g * l\n                    if values[u] == 0:\n                        valid = False\n                        break\n                    if product % values[u] != 0:\n                        valid = False\n                        break\n                    val_v = product // values[u]\n                    # Now check that GCD(values[u], val_v) == g\n                    if math.gcd(values[u], val_v) != g:\n                        valid = False\n                        break\n                    values[v] = val_v\n                    visited[v] = True\n                    queue.append(v)\n                else:\n                    # Check if current values are consistent\n                    if values[u] * values[v] != g * l or math.gcd(values[u], values[v]) != g:\n                        valid = False\n                        break\n            if not valid:\n                break\n        if not valid:\n            print(\"NO\")\n            return\n    \n    # After processing all components\n    print(\"YES\")\n    print(' '.join(map(str, values)))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 558,
        "completion_token_count": 1006,
        "thoughts_token_count": 1024
    }
}