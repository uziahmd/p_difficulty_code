{
    "start": 1758343714.7824008,
    "end": 1758343906.0922332,
    "start-formatted": "2025-09-20 13:48 KST",
    "end-formatted": "2025-09-20 13:51 KST",
    "gpu": 2,
    "pid": 6,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\nOkay, let's see. I need to solve this programming problem. Let me read the problem carefully again.\n\nSo, the problem is about finding two non-overlapping vouchers such that their durations add up exactly to x, and their total cost is minimized. If there's no such pair, output -1.\n\nFirst, let's understand the voucher details. Each voucher has a departure day li, return day ri, and cost. The duration is ri - li + 1. So for two vouchers i and j, their durations must sum to x. Also, they must not overlap. Which means either the first ends before the second starts (ri < lj) or the second ends before the first starts (rj < li).\n\nThe challenge is to find such pairs efficiently given the constraints of n up to 2e5. Brute-forcing all pairs would be O(n^2), which is way too slow for n=2e5. So we need an efficient approach.\n\nLet me think about how to approach this. For each voucher, we can check if there exists another voucher that starts after the first ends, or vice versa, such that the sum of durations is x.\n\nBut how do we find these pairs efficiently?\n\nLet me think about the durations. Let's say for a voucher with duration d, we need another voucher with duration x - d. So for each voucher, if we can find another voucher with duration (x - d) that doesn't overlap with it, then we can consider their sum.\n\nSo maybe the plan is:\n\n1. Preprocess all vouchers by their duration. For each possible duration, keep track of the minimum cost for vouchers of that duration, and also their start and end times. Wait, but for each duration, we need to find vouchers that can be paired with others. However, since we need non-overlapping, perhaps for each voucher, we can look for vouchers of duration (x - d) that end before li, or start after ri.\n\nBut how to find those quickly?\n\nAnother thought: For each voucher, let's say it's the first part of the pair. Then, we need a voucher of duration (x - d) that starts after this voucher ends. Or, alternatively, a voucher of duration (x - d) that ends before this voucher starts. But since the order can be either way, maybe we can process the vouchers in a way that allows us to query the minimal cost for certain conditions.\n\nLet me think about splitting into two cases:\n\nCase 1: voucher A ends before voucher B starts. So, A's ri < B's lj. Then, the duration of A is d1, B is d2, and d1 + d2 = x.\n\nCase 2: voucher B ends before voucher A starts. Which is symmetric to case 1.\n\nSo for each voucher, we can look for vouchers of duration (x - d) that are completely after it, or completely before it.\n\nBut how to find the minimal cost for those?\n\nLet me think about processing vouchers sorted by their start or end time.\n\nFor example, suppose we have all vouchers sorted by their end time. For each voucher, if we want to find vouchers of duration (x - d) that start after this voucher ends. Then, for each voucher, we can check if there are any vouchers with duration (x - d) that start after ri. And among those, find the one with minimal cost.\n\nSimilarly, for vouchers that end before the current voucher starts. So, for each voucher, we can check if there are vouchers with duration (x - d) that end before li. And find the minimal cost among them.\n\nBut how to efficiently find those?\n\nAn idea is to pre-process for each possible duration, the list of vouchers sorted by their end time, and also their start time. Then, for a given duration, we can perform binary search to find the earliest start time that is after some value.\n\nAlternatively, for each possible duration, we can keep track of the minimum cost of vouchers that end before a certain time, or start after a certain time.\n\nLet me outline steps:\n\nFirst, for each voucher, compute its duration. Then, group all vouchers by their duration. For example, a dictionary where the key is the duration, and the value is a list of vouchers with that duration. Then, for each voucher, we can check if (x - duration) exists in the dictionary. If so, then we need to find in that group of vouchers, those that don't overlap with the current voucher.\n\nBut how to find the minimal cost in that group?\n\nLet's take an example. Suppose current voucher has duration d, and we need to find vouchers of duration (x -d). Let's call this target duration t = x -d. So for each voucher of duration d, we check if there are vouchers of duration t that do not overlap with it.\n\nNow, for the current voucher (say, voucher A), we need to find vouchers of duration t that either end before A's start (so their ri < A's li) or start after A's end (their lj > A's ri). So, for each voucher A, we can check both possibilities.\n\nBut how to find the minimal cost in these scenarios?\n\nFor the first possibility (vouchers of duration t that end before A's li): We can have a structure that for each duration t, stores the vouchers sorted by their end time. Then, for a given li, we can find all vouchers of duration t that end before li, and find the minimum cost among them. Similarly, for the second possibility (vouchers of duration t that start after A's ri), we can have the vouchers of duration t sorted by their start time, and find the minimal cost of those that start after ri.\n\nBut how to do this efficiently?\n\nLet me think. For each duration t, we can have two sorted lists:\n\n- One sorted by end time (for checking if a voucher ends before a certain value)\n- One sorted by start time (for checking if a voucher starts after a certain value)\n\nBut even better, for each duration t, we can pre-process the vouchers of that duration by their end time, and for each end time, keep track of the minimum cost up to that point. Similarly, for start times.\n\nWait, here's an idea. For each duration t, we can create two arrays:\n\n- sorted by end time, and for each position, have the minimum cost up to that position. Then, when we want to find the minimum cost of vouchers of duration t that end before a certain value (like li), we can binary search the end time in the sorted list, and take the min cost up to that index.\n\nSimilarly, for the start time: sorted by start time, and for each position, have the minimum cost from that position onwards. Then, when we want to find the minimum cost of vouchers of duration t that start after a certain value (like ri), we can binary search for the first start time that is greater than ri, and then take the min cost from that index onwards.\n\nThis seems promising.\n\nSo the steps would be:\n\n1. Preprocess all vouchers into groups by their duration. For each duration t, store:\n\n   a. A list of vouchers sorted by end time. Along with a prefix minimum array (for the minimum cost up to each index).\n\n   b. A list of vouchers sorted by start time. Along with a suffix minimum array (for the minimum cost from each index to the end).\n\nBut how to build these structures?\n\nFor example, for each duration t, collect all vouchers of that duration. Then sort them by end time. Then, create a prefix_min array where prefix_min[i] is the minimum cost among the first i+1 vouchers. Similarly, sort the same vouchers by start time, then create a suffix_min array where suffix_min[i] is the minimum cost from i to end.\n\nOnce these structures are built, for any given voucher A with duration d, and target duration t = x -d, we can check:\n\n- If t is a valid duration (i.e., exists in our groups), then:\n\n   a. Find the minimal cost of vouchers in t that end before A's li. How? In the sorted end time list for t, find the largest end time that is less than A's li. Then the prefix_min up to that index gives the minimum cost.\n\n   b. Find the minimal cost of vouchers in t that start after A's ri. How? In the sorted start time list for t, find the first start time that is greater than A's ri. Then the suffix_min from that index gives the minimum cost.\n\nThen, the overall minimum between these two possibilities (a and b) is considered for this voucher A.\n\nWe can do this for all vouchers, and keep track of the global minimum.\n\nBut how to handle the case where the same voucher is considered twice? Because the problem says i != j. However, since we are considering for each voucher A, looking for vouchers in the group t (which may include other vouchers), and as long as the voucher A is not in the group t (but wait, if t is equal to d, then the group t is the same as the group of d. So, in that case, when looking for vouchers of duration t, which is same as d, we need to ensure that the voucher A is not considered as itself. But perhaps during the preprocessing, for each group, we can have multiple vouchers, and when checking for vouchers in the same group, we need to make sure that the voucher A is not included in the min calculation. However, this could complicate things.\n\nWait, but the problem requires that two different vouchers are selected. So, for example, if a voucher A has duration d, and t = x -d is also d, then we need to find another voucher in the same group with duration d that does not overlap with A. However, when we process voucher A, we check for vouchers in the group t (same as d) that end before A's li or start after A's ri. However, if there's another voucher B in the same group that meets this condition, then it's okay. But when we check for the min in the group, it's possible that the voucher A is included in the group. But since we need to find another voucher, we need to make sure that when we look for vouchers in the same group, we exclude voucher A itself.\n\nBut that seems complicated. How can we handle this?\n\nAlternative approach: For each voucher, when considering the group t (could be same as d), we can check if there are other vouchers in the group that meet the criteria. However, this might require more complex handling.\n\nBut perhaps in practice, during the processing, when we look for vouchers in the group t, the min cost for the group may include the current voucher. However, if the current voucher is in the group t, then during the check for vouchers that end before li or start after ri, the current voucher may not satisfy that condition. For example, if we are looking for vouchers that end before A's li, and the current voucher is A itself, then its end time is ri, which is >= li (since li is the start of A, and ri >= li). So, the voucher A cannot be in the list of vouchers that end before li. Therefore, even if the group includes voucher A, when we process the group, the voucher A will not be considered in the case of looking for vouchers that end before li. Similarly for the other case.\n\nWait, for example, let's say we are looking for vouchers of duration t that end before A's li. The voucher A has duration d, and t = x -d. If t = d, then the group includes voucher A. But voucher A's end time is ri, which is >= li (since li is the start of A). So when we check for vouchers that end before li, voucher A's end time is ri >= li, which is not less than li. Therefore, even if the group includes voucher A, it's not included in the result of the query. Thus, the min cost found in the group will not include voucher A. Therefore, even if the group contains voucher A, during the query, it's not considered. So, we don't need to worry about excluding it. Because the queries are designed to find vouchers that are non-overlapping with A.\n\nTherefore, the approach can proceed without worrying about overlapping with itself, because the queries are designed to find vouchers that don't overlap with A.\n\nThat's a relief. So, the steps are:\n\nFor each voucher A:\n\nCompute d = duration of A.\n\nt = x - d.\n\nIf t is not present in the groups, skip.\n\nElse:\n\nCheck in the group t for two possibilities:\n\n1. Vouchers in group t that end before A's li. The minimal cost for such vouchers.\n\n2. Vouchers in group t that start after A's ri. The minimal cost for such vouchers.\n\nTake the minimum of these two possibilities (if any), and add it to the cost of A. Keep track of the global minimum.\n\nSo, the problem reduces to, for each voucher, checking these two possibilities for the corresponding t group.\n\nNow, the question is how to implement the two checks efficiently.\n\nLet me think about how to build the data structures for each group.\n\nFor each group (duration t):\n\nSort all vouchers in the group by their end time. Then, for each position in this sorted list, compute a prefix minimum array. So, for example, if the sorted list is [v1, v2, v3, ...], then prefix_min[i] = min(prefix_min[i-1], v_i.cost). This way, when we want to find the minimal cost of vouchers that end before a certain value, we can binary search the maximum end time that is <= target (A's li). Then, the prefix_min up to that index gives the minimal cost.\n\nSimilarly, for the start time: sort the vouchers in the group by their start time. Then, compute a suffix minimum array. For each index i, suffix_min[i] = min(voucher[i].cost, suffix_min[i+1]). Then, when we want to find vouchers that start after a certain value (A's ri), we can binary search the first start time that is > ri. All vouchers from that index onwards in the sorted list have start time > ri. The suffix_min[i] gives the minimal cost in that range.\n\nSo, for each group, we need to precompute these sorted lists and their respective prefix/suffix min arrays.\n\nNow, the code steps:\n\nFirst, process all vouchers, group them by their duration. For each duration, collect all vouchers, then sort them by end time and create prefix_min array. Also sort them by start time and create suffix_min array.\n\nOnce that is done, for each voucher A in the original list, compute d = duration, t = x -d. Check if t is in the groups. If not, continue. Else:\n\nCheck for the two possibilities:\n\nPossibility 1: find vouchers in group t that end before A's li.\n\nTo do this:\n\nIn the group t's sorted end time list, perform a binary search for the largest end time <= (A.li - 1). Because the condition is ri < lj (voucher in group t ends before A's li). So, the end time of the voucher in group t must be < A's li. So, we can search for the largest end time <= (A.li - 1).\n\nIf such a voucher exists, get the min cost from the prefix_min array.\n\nPossibility 2: find vouchers in group t that start after A's ri.\n\nIn the group t's sorted start time list, perform a binary search for the first start time > A.ri. All vouchers from that index onwards have start time > A.ri. Then, get the min cost from the suffix_min array starting at that index.\n\nSo, for each of these possibilities, if there is a valid voucher, we can take the min cost and add to A's cost. Then, compare with the global minimum.\n\nNow, how to implement the binary search steps.\n\nFor possibility 1: sorted_end_times is a list sorted in ascending order. We need to find the rightmost element <= (A.li - 1). For example, using bisect_right.\n\nFor example, in Python, using the bisect module:\n\nindex = bisect.bisect_right(sorted_end_times, target) - 1.\n\nIf index >=0, then the prefix_min[index] is the min cost.\n\nBut wait, the sorted_end_times is a list of end times. But in the group, the vouchers are sorted by end time. So, the sorted_end_times list can be generated by taking the end time of each voucher in the sorted list. But perhaps we can have a separate list for end times. Alternatively, during the group setup, we can have a list of vouchers sorted by end time, and then for binary search, extract the end times.\n\nBut perhaps for efficiency, during the group setup, we can create a list of end times, sorted, and then use that for binary search.\n\nBut in Python, perhaps it's easier to use the bisect module on a list of end times.\n\nSimilarly for the start times.\n\nSo, for each group, for the sorted_end list, we have a list of vouchers sorted by end time. Then, the end_times list is [v.end for v in sorted_end_vouchers].\n\nSimilarly for the sorted_start list, start_times is [v.start for v in sorted_start_vouchers].\n\nSo, for possibility 1:\n\ntarget = A.li - 1.\n\nWe perform a bisect_right on the end_times list for target. The index is the insertion point. So, the number of elements <= target is index. If index is 0, then no such elements. Otherwise, the prefix_min array up to index-1 gives the minimal cost.\n\nWait, the prefix_min array is built for the sorted_end_vouchers. So, the prefix_min array is of the same length as the sorted_end_vouchers. For example, prefix_min[i] is the minimum cost among the first i+1 vouchers in the sorted_end_vouchers list.\n\nSo, if the index from bisect_right is k, then the largest element <= target is at position k-1. So, if k-1 >=0, then the min cost is prefix_min[k-1].\n\nFor possibility 2:\n\ntarget = A.ri.\n\nWe need to find the first voucher in the sorted_start_vouchers list whose start time is > target. So, in the start_times list, we can use bisect_right to find the insertion point for target. All elements from that index onwards have start time > target. So, if the index is i, then the suffix_min[i] is the minimal cost in that range.\n\nSo, the suffix_min array is built for the sorted_start_vouchers list. For example, suffix_min[i] = min of sorted_start_vouchers[i...end]. So, if the start index is i, then the minimal cost is suffix_min[i].\n\nThus, for each group, during preprocessing, we need to have:\n\n- sorted_end_vouchers: list of vouchers sorted by end time.\n\n- end_times: list of end times of these vouchers.\n\n- prefix_min: list where prefix_min[i] is the minimum cost up to index i (inclusive).\n\nSimilarly, sorted_start_vouchers: list of vouchers sorted by start time.\n\n- start_times: list of start times of these vouchers.\n\n- suffix_min: list where suffix_min[i] is the minimum cost from index i to end.\n\nOnce these are built, for each voucher, we can perform the two checks.\n\nNow, the next step is to implement this in Python.\n\nBut first, let's think about edge cases.\n\nFor example, when x is 0? Well, according to the input constraints, x is at least 2. Wait, no. Looking back:\n\nInput constraints: n and x are between 2 and 2e5. So x is at least 2. So no problem.\n\nAnother case: when a voucher's duration is zero? No, because li <= ri, so duration is ri - li + 1 >= 1. So each voucher has duration >=1.\n\nSo, for each voucher, d is >=1. So, t = x -d can be anything. But if t is less than 1, then no possible. So during processing, for each voucher, we check if t is positive and exists in the groups.\n\nSo, during the processing of each voucher:\n\nd = ri - li + 1.\n\nt = x -d.\n\nif t < 1, then skip (since we can't have a voucher with duration t).\n\nElse, check if t exists in the groups. If not, skip.\n\nElse, proceed with the two checks.\n\nNow, let's think about the sample input.\n\nSample Input 1:\n\n4 5\n\n1 3 4 → duration is 3-1+1=3\n\n1 2 5 → duration 2\n\n5 6 1 → duration 2\n\n1 2 4 → duration 2\n\nSo, for the first voucher (duration 3), t = 5-3=2. So we check group 2. The group has three vouchers: the second, third, fourth. Let's see.\n\nFor the first voucher (li=1, ri=3). For possibility 1: looking for vouchers in group 2 that end before li=1. The end time of such vouchers must be <1. But the vouchers in group 2 have durations 2. Their end times are 2, 6, 2. So none of them have end time <1. So possibility 1 gives nothing.\n\nPossibility 2: looking for vouchers in group 2 that start after 3. The start times of group 2 are 1,5,1. So sorted_start_vouchers would be sorted by start time. So sorted_start_vouchers would be vouchers with start times 1,1,5. The start_times list is [1,1,5]. The target is 3. We need to find the first start time >3. Using bisect_right on [1,1,5], target 3. bisect_right returns 2. So the index is 2. The suffix_min[2] is the cost of the voucher at index 2, which is 1 (the third voucher, which starts at 5). So the min cost is 1. Adding to the current voucher's cost (4) gives 5. Which is the correct answer.\n\nSo this is found.\n\nOther vouchers may contribute as well, but in the sample, this is the minimal.\n\nNow, the code steps.\n\nFirst, group the vouchers by duration.\n\nWe can create a dictionary, say, duration_dict, where keys are durations, and values are the data structures for that duration.\n\nEach entry in duration_dict would have:\n\n- sorted_end_vouchers (sorted by end time)\n\n- end_times (list of end times)\n\n- prefix_min (list of min costs up to each index)\n\n- sorted_start_vouchers (sorted by start time)\n\n- start_times (list of start times)\n\n- suffix_min (list of min costs from each index to end)\n\nSo, for each duration t, we can precompute these.\n\nNow, how to build these structures.\n\nFor each duration in duration_dict:\n\nsorted_end_vouchers = sorted(vouchers, key=lambda v: v.end)\n\nend_times = [v.end for v in sorted_end_vouchers]\n\nprefix_min is computed as follows:\n\nprefix_min = [0]*len(sorted_end_vouchers)\n\nprefix_min[0] = sorted_end_vouchers[0].cost\n\nfor i in 1 to len-1:\n\nprefix_min[i] = min(prefix_min[i-1], sorted_end_vouchers[i].cost)\n\nSimilarly for sorted_start_vouchers:\n\nsorted_start_vouchers = sorted(vouchers, key=lambda v: v.start)\n\nstart_times = [v.start for v in sorted_start_vouchers]\n\nsuffix_min is computed as:\n\nsuffix_min = [0]*len(sorted_start_vouchers)\n\nsuffix_min[-1] = sorted_start_vouchers[-1].cost\n\nfor i in len-2 downto 0:\n\nsuffix_min[i] = min( sorted_start_vouchers[i].cost, suffix_min[i+1] )\n\nOnce these are precomputed, for each voucher, we can check the possibilities.\n\nNow, in Python, for each voucher, we can process as follows.\n\nNow, let's think about how to represent the vouchers. Perhaps as a list of tuples (li, ri, cost), and for each, compute duration.\n\nBut during grouping, we need to collect all vouchers of the same duration.\n\nNow, code steps in Python:\n\nRead n and x.\n\nThen read n lines, each with li, ri, cost. Store them as a list of tuples.\n\nThen, group them by duration. For each voucher, compute duration as (ri - li + 1).\n\nCreate a dictionary, say, from collections import defaultdict.\n\nduration_dict = defaultdict(list)\n\nfor each voucher in the list:\n\n    d = ri - li + 1\n\n    duration_dict[d].append( (li, ri, cost) )\n\nOnce grouped, for each duration in duration_dict, process the sorted_end and sorted_start lists, along with their prefix and suffix min arrays.\n\nBut in Python, perhaps we can create for each duration, a tuple containing:\n\n(end_sorted_list, end_times, prefix_min), (start_sorted_list, start_times, suffix_min)\n\nBut how to structure this.\n\nAlternatively, for each duration t, we can precompute:\n\nsorted_end_list: list of vouchers sorted by end time.\n\nend_times: list of end times.\n\nprefix_min: list of min cost up to each index.\n\nSimilarly for start_sorted_list, start_times, suffix_min.\n\nOnce that is done, for each voucher in the original list, process as follows:\n\ncurrent_li, current_ri, current_cost = voucher\n\nd = current_ri - current_li + 1\n\nt = x -d\n\nif t < 1:\n\n    continue\n\nif t not in duration_dict:\n\n    continue\n\nelse:\n\n    process the group t.\n\nSo, for group t:\n\nCheck possibility 1: vouchers in t that end before current_li.\n\nCheck possibility 2: vouchers in t that start after current_ri.\n\nNow, for possibility 1:\n\nIn the group t's sorted_end_list, end_times is the list of end times. So:\n\ntarget = current_li - 1\n\nusing bisect.bisect_right(end_times, target) gives the insertion point. Let's call this pos.\n\nif pos > 0:\n\n    min_cost1 = prefix_min[pos-1]\n\nelse:\n\n    min_cost1 = infinity\n\nSimilarly for possibility 2:\n\nIn the group t's start_times list, target = current_ri.\n\npos = bisect.bisect_right(start_times, target)\n\nif pos < len(start_times):\n\n    min_cost2 = suffix_min[pos]\n\nelse:\n\n    min_cost2 = infinity\n\nThen, the total cost for this pair is current_cost + min(min_cost1, min_cost2). We compare this with the global minimum.\n\nBut we need to check if min_cost1 or min_cost2 is valid (i.e., not infinity). So, for each possibility, if there is a valid voucher, then we can take the min between them.\n\nBut what if both possibilities are valid? We take the minimum of the two.\n\nSo, for each voucher, we check both possibilities, and if any of them is possible, we add the current cost plus the min of the possible options.\n\nBut how to handle the case where both possibilities are possible? For example, there are vouchers in group t that end before current_li, and also vouchers that start after current_ri. Then, the minimal between those two possibilities is considered.\n\nNow, the code for this.\n\nBut how to handle the group t's data structures. For example, for each duration t, we have:\n\nsorted_end_list, end_times, prefix_min.\n\nsorted_start_list, start_times, suffix_min.\n\nSo, during preprocessing, for each duration t in duration_dict, we need to generate these.\n\nLet me code that part.\n\nIn Python:\n\nfrom bisect import bisect_right\n\nimport sys\nfrom collections import defaultdict\n\nn, x = map(int, sys.stdin.readline().split())\nvouchers = []\nfor _ in range(n):\n    li, ri, cost = map(int, sys.stdin.readline().split())\n    vouchers.append( (li, ri, cost) )\n\nduration_dict = defaultdict(list)\nfor li, ri, cost in vouchers:\n    d = ri - li + 1\n    duration_dict[d].append( (li, ri, cost) )\n\n# Now preprocess each duration in duration_dict\n# For each duration t, create the necessary structures\nprocessed = dict()  # key: duration, value: (end_sorted, end_times, prefix_min, start_sorted, start_times, suffix_min)\n\nfor t in duration_dict:\n    # Process end sorted\n    end_sorted = sorted( duration_dict[t], key=lambda x: x[1] )  # sorted by end time (x[1] is ri)\n    end_times = [v[1] for v in end_sorted]\n    # compute prefix_min\n    prefix_min = []\n    min_so_far = float('inf')\n    for v in end_sorted:\n        min_so_far = min( min_so_far, v[2] )\n        prefix_min.append( min_so_far )\n    # Process start sorted\n    start_sorted = sorted( duration_dict[t], key=lambda x: x[0] )  # sorted by start time (x[0] is li)\n    start_times = [v[0] for v in start_sorted]\n    # compute suffix_min\n    suffix_min = [0]*len(start_sorted)\n    min_so_far = float('inf')\n    for i in range(len(start_sorted)-1, -1, -1):\n        min_so_far = min( min_so_far, start_sorted[i][2] )\n        suffix_min[i] = min_so_far\n    # store in processed\n    processed[t] = (end_sorted, end_times, prefix_min, start_sorted, start_times, suffix_min )\n\n# Now, for each voucher, check possibilities\nmin_total = float('inf')\n\nfor li, ri, cost in vouchers:\n    d = ri - li + 1\n    t = x - d\n    if t < 1:\n        continue\n    if t not in processed:\n        continue\n    # get the processed data for t\n    end_sorted, end_times, prefix_min, start_sorted, start_times, suffix_min = processed[t]\n    # possibility 1: vouchers in t that end before li\n    target_p1 = li - 1\n    # find the largest end time <= target_p1\n    pos_p1 = bisect_right(end_times, target_p1)\n    if pos_p1 > 0:\n        min_cost_p1 = prefix_min[pos_p1 - 1]\n    else:\n        min_cost_p1 = float('inf')\n    # possibility 2: vouchers in t that start after ri\n    target_p2 = ri\n    pos_p2 = bisect_right(start_times, target_p2)\n    if pos_p2 < len(start_times):\n        min_cost_p2 = suffix_min[pos_p2]\n    else:\n        min_cost_p2 = float('inf')\n    # take the min between p1 and p2\n    current_min = min( min_cost_p1, min_cost_p2 )\n    if current_min != float('inf'):\n        total = cost + current_min\n        if total < min_total:\n            min_total = total\n\nif min_total == float('inf'):\n    print(-1)\nelse:\n    print(min_total)\n\nWait, but in the sample input, the first voucher is (1,3,4). For t=2, the processed data for t=2 would be:\n\nThe vouchers in duration 2 are:\n\nvoucher 2: (1,2,5) → duration 2.\n\nvoucher 3: (5,6,1) → duration 2.\n\nvoucher 4: (1,2,4) → duration 2.\n\nSo, when sorted by end time (end_sorted):\n\nvoucher 2 (end=2), voucher 4 (end=2), voucher 3 (end=6). So end_times is [2,2,6].\n\nprefix_min would be [5, min(5,4)=4, min(4,1)=1]. So prefix_min is [5,4,1].\n\nFor possibility 1, target_p1 is li-1 = 1-1=0. bisect_right([2,2,6], 0) returns 0. So pos_p1 is 0, which is not >0. So min_cost_p1 is inf.\n\npossibility 2: target_p2 is ri=3. start_times for start_sorted: sorted by start time. The vouchers are:\n\nvoucher 2 (start=1), voucher4 (start=1), voucher3 (start=5). start_times is [1,1,5]. bisect_right([1,1,5], 3) → returns 2. pos_p2=2. len(start_times) is 3. 2 < 3 → suffix_min[2] is 1. So min_cost_p2 is 1. So total is 4 + 1 =5. Which is correct.\n\nSo the code would find that.\n\nBut what about when there are multiple vouchers in the same group and overlapping?\n\nAnother test case: the second sample input.\n\nSample Input 2:\n\n3 2\n\n4 6 3 → duration 3\n\n2 4 1 → duration 3\n\n3 5 4 → duration 3\n\nSo x is 2. For each voucher, duration is 3, so t = 2-3 = -1. So all are skipped. Hence output is -1. Which matches the sample.\n\nAnother test case: if two vouchers have durations adding to x and non-overlapping.\n\nSo the code should work.\n\nNow, what about the case where a voucher is in the same group as t?\n\nLike, say x=4, and a voucher has duration 2, and another voucher has duration 2. So t=2.\n\nFor example, voucher A (1-2, cost 1), voucher B (3-4, cost 1). Then, for voucher A, t=2, and looking for vouchers in group 2 that start after 2 (voucher B starts at 3). So min cost is 1. So total cost is 1+1=2. Which is correct.\n\nNow, the code would handle this.\n\nNow, possible issues:\n\nWhat if the same voucher is considered in both possibilities? Like, if a voucher is in group t, and during processing, it's possible that the voucher is in both possibilities. But no, since for voucher A, when processing group t, the possibilities are for vouchers that end before A's li (so not overlapping) or start after A's ri (so not overlapping). So even if the voucher is in group t, it's not considered in the possibilities because it would not meet the end before li or start after ri conditions.\n\nAnother possible issue is when the group t is the same as the current voucher's duration. For example, voucher A is in group t. But during the processing, when checking for vouchers in group t, the code would find other vouchers in that group that are non-overlapping.\n\nNow, what about when there are multiple vouchers in the same group and overlapping? The code would find those that are non-overlapping.\n\nNow, the code seems correct.\n\nBut what about when there are multiple vouchers in group t, and some of them are non-overlapping with the current voucher. The code finds the minimal cost.\n\nNow, the code uses the processed dictionary, which for each duration t, stores the preprocessed data.\n\nBut in Python, the defaultdict is used for duration_dict, but when we process the durations, we have to loop through all keys in duration_dict. However, in the code above, the 'processed' is built for all durations in duration_dict. But during the processing of vouchers, for each voucher, we check if t is in processed (which is same as duration_dict, since processed is built for all durations in duration_dict).\n\nBut in the code, the 'processed' is built for all durations in duration_dict. So yes.\n\nNow, what about when the same voucher is considered multiple times? For example, if two vouchers are in group t and non-overlapping. But since for each voucher, we check for all possible pairs, including when the other voucher is processed in the group t. However, since the code considers all vouchers, including those that could be paired with others, it should find the minimal pair.\n\nBut since we are checking for each voucher, and for each possible pair (i,j) where i is the current voucher and j is in the group t, the code would find the minimal possible sum.\n\nBut since the code checks for all vouchers, and for each voucher, checks both possibilities, the minimal sum would be found.\n\nNow, what about the time complexity?\n\nFor each voucher, the processing is O(log m), where m is the number of vouchers in group t. Since for each voucher, we perform two binary searches.\n\nThe preprocessing for each duration t takes O(m log m) time for sorting, and O(m) for building the prefix and suffix arrays.\n\nThe overall time complexity is O(n log n) for the preprocessing, and O(n log m) for processing all vouchers. Since m is up to n, the total time is acceptable for n up to 2e5.\n\nNow, let's test the code against the sample inputs.\n\nSample Input 1:\n\n4 5\n\n1 3 4 → duration 3\n\n1 2 5 → duration 2\n\n5 6 1 → duration 2\n\n1 2 4 → duration 2\n\nThe duration_dict will have keys 3 and 2.\n\nFor duration 3, the group has one voucher (1,3,4). For duration 2, the group has three vouchers.\n\nThe processed for duration 2:\n\nend_sorted is sorted by end time. The three vouchers have end times 2, 2, 6. So end_sorted is [(1,2,5), (1,2,4), (5,6,1)] ?\n\nWait, no. The vouchers in duration_dict[2] are (1,2,5), (5,6,1), (1,2,4). When sorted by end time (ri), which is 2, 6, 2? No. Wait, no. The original vouchers in duration_dict[2] are:\n\nvoucher 2: (1, 2, 5) → ri=2.\n\nvoucher 3: (5,6,1) → ri=6.\n\nvoucher 4: (1,2,4) → ri=2.\n\nSo when sorted by end time (ri), the sorted_end would be [(1,2,5), (1,2,4), (5,6,1)]? Or",
    "response": "To solve this problem, we need to find two non-overlapping vouchers such that their total duration equals a given value `x` and their combined cost is minimized. If no such pair exists, we should return -1.\n\n### Approach\n1. **Group Vouchers by Duration**: First, we group all vouchers by their duration. This helps in efficiently finding pairs of vouchers whose durations sum up to `x`.\n2. **Preprocess Data Structures**: For each duration, we preprocess the vouchers to create sorted lists of start and end times along with prefix and suffix minimum cost arrays. This allows efficient querying of minimum costs for non-overlapping intervals.\n3. **Binary Search for Efficient Querying**: For each voucher, we check if there exists another voucher with a duration that complements it to sum up to `x`. Using binary search, we quickly determine the minimum cost of valid non-overlapping vouchers.\n\n### Solution Code\n```python\nimport sys\nfrom bisect import bisect_right\nfrom collections import defaultdict\n\ndef main():\n    n, x = map(int, sys.stdin.readline().split())\n    vouchers = []\n    for _ in range(n):\n        li, ri, cost = map(int, sys.stdin.readline().split())\n        vouchers.append((li, ri, cost))\n    \n    duration_dict = defaultdict(list)\n    for li, ri, cost in vouchers:\n        d = ri - li + 1\n        duration_dict[d].append((li, ri, cost))\n    \n    processed = dict()\n    for t in duration_dict:\n        # Process end_sorted and prefix_min\n        end_sorted = sorted(duration_dict[t], key=lambda v: v[1])\n        end_times = [v[1] for v in end_sorted]\n        prefix_min = []\n        min_so_far = float('inf')\n        for v in end_sorted:\n            min_so_far = min(min_so_far, v[2])\n            prefix_min.append(min_so_far)\n        \n        # Process start_sorted and suffix_min\n        start_sorted = sorted(duration_dict[t], key=lambda v: v[0])\n        start_times = [v[0] for v in start_sorted]\n        suffix_min = [0] * len(start_sorted)\n        min_so_far = float('inf')\n        for i in range(len(start_sorted)-1, -1, -1):\n            min_so_far = min(min_so_far, start_sorted[i][2])\n            suffix_min[i] = min_so_far\n        \n        processed[t] = (end_sorted, end_times, prefix_min, start_sorted, start_times, suffix_min)\n    \n    min_total = float('inf')\n    for li, ri, cost in vouchers:\n        d = ri - li + 1\n        t = x - d\n        if t < 1:\n            continue\n        if t not in processed:\n            continue\n        end_sorted, end_times, prefix_min, start_sorted, start_times, suffix_min = processed[t]\n        \n        # Possibility 1: vouchers in t that end before li\n        target_p1 = li - 1\n        pos_p1 = bisect_right(end_times, target_p1)\n        min_cost_p1 = float('inf')\n        if pos_p1 > 0:\n            min_cost_p1 = prefix_min[pos_p1 - 1]\n        \n        # Possibility 2: vouchers in t that start after ri\n        target_p2 = ri\n        pos_p2 = bisect_right(start_times, target_p2)\n        min_cost_p2 = float('inf')\n        if pos_p2 < len(start_times):\n            min_cost_p2 = suffix_min[pos_p2]\n        \n        current_min = min(min_cost_p1, min_cost_p2)\n        if current_min != float('inf'):\n            total = cost + current_min\n            if total < min_total:\n                min_total = total\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Grouping by Duration**: Vouchers are grouped by their duration to facilitate quick lookups when checking for complementary durations.\n2. **Preprocessing**: For each duration group, vouchers are sorted by their end and start times. Prefix and suffix minimum cost arrays are created to quickly find the minimum cost of non-overlapping intervals.\n3. **Binary Search**: For each voucher, we use binary search to efficiently determine if there exists another voucher with the required duration that does not overlap, ensuring the solution is both optimal and efficient.\n\nThis approach ensures that we efficiently check all possible pairs of vouchers while maintaining an overall time complexity of O(n log n), making it suitable for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom bisect import bisect_right\nfrom collections import defaultdict\n\ndef main():\n    n, x = map(int, sys.stdin.readline().split())\n    vouchers = []\n    for _ in range(n):\n        li, ri, cost = map(int, sys.stdin.readline().split())\n        vouchers.append((li, ri, cost))\n    \n    duration_dict = defaultdict(list)\n    for li, ri, cost in vouchers:\n        d = ri - li + 1\n        duration_dict[d].append((li, ri, cost))\n    \n    processed = dict()\n    for t in duration_dict:\n        # Process end_sorted and prefix_min\n        end_sorted = sorted(duration_dict[t], key=lambda v: v[1])\n        end_times = [v[1] for v in end_sorted]\n        prefix_min = []\n        min_so_far = float('inf')\n        for v in end_sorted:\n            min_so_far = min(min_so_far, v[2])\n            prefix_min.append(min_so_far)\n        \n        # Process start_sorted and suffix_min\n        start_sorted = sorted(duration_dict[t], key=lambda v: v[0])\n        start_times = [v[0] for v in start_sorted]\n        suffix_min = [0] * len(start_sorted)\n        min_so_far = float('inf')\n        for i in range(len(start_sorted)-1, -1, -1):\n            min_so_far = min(min_so_far, start_sorted[i][2])\n            suffix_min[i] = min_so_far\n        \n        processed[t] = (end_sorted, end_times, prefix_min, start_sorted, start_times, suffix_min)\n    \n    min_total = float('inf')\n    for li, ri, cost in vouchers:\n        d = ri - li + 1\n        t = x - d\n        if t < 1:\n            continue\n        if t not in processed:\n            continue\n        end_sorted, end_times, prefix_min, start_sorted, start_times, suffix_min = processed[t]\n        \n        # Possibility 1: vouchers in t that end before li\n        target_p1 = li - 1\n        pos_p1 = bisect_right(end_times, target_p1)\n        min_cost_p1 = float('inf')\n        if pos_p1 > 0:\n            min_cost_p1 = prefix_min[pos_p1 - 1]\n        \n        # Possibility 2: vouchers in t that start after ri\n        target_p2 = ri\n        pos_p2 = bisect_right(start_times, target_p2)\n        min_cost_p2 = float('inf')\n        if pos_p2 < len(start_times):\n            min_cost_p2 = suffix_min[pos_p2]\n        \n        current_min = min(min_cost_p1, min_cost_p2)\n        if current_min != float('inf'):\n            total = cost + current_min\n            if total < min_total:\n                min_total = total\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 741,
        "completion_token_count": 974,
        "thoughts_token_count": 8192
    }
}