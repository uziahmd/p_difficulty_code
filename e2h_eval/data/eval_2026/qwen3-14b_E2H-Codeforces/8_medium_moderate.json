{
    "start": 1758344038.7200706,
    "end": 1758344169.586561,
    "start-formatted": "2025-09-20 13:53 KST",
    "end-formatted": "2025-09-20 13:56 KST",
    "gpu": 2,
    "pid": 8,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\nOkay, let's try to figure out how to solve this problem. So the problem is about assigning directions to edges in an undirected graph such that the flow conditions are satisfied. The main points are:\n\n- The flow must be a maximum flow, which implies that the flow conservation holds for all vertices except the source (vertex 1) and sink (vertex n).\n- The directed graph should not have cycles.\n- The source has no incoming edges, and the sink has no outgoing edges (I think? Well, the problem says for vertex 1, no incoming edges. For the sink, maybe it's implied that outgoing edges are allowed, but the flow conservation only applies to intermediate nodes.)\n\nSo the key is to assign directions to edges such that for each node except source and sink, the sum of incoming flows equals the sum of outgoing flows. Also, the directed graph must be acyclic.\n\nHmm. How can we model this?\n\nFirst, let's think about the flow conservation. For each node v (not source or sink), the total flow into v must equal the total flow out of v. Since each edge has a fixed capacity ci, which is the flow through it, the direction determines whether it contributes to incoming or outgoing flow for each node.\n\nBut how do we find the directions that satisfy this?\n\nAnother thing to note is that the graph must be acyclic once directed. So perhaps we need to assign directions in a way that forms a DAG. Maybe we can arrange the nodes in a topological order and assign directions accordingly.\n\nWait, but how does that help with flow conservation?\n\nAlternatively, think of this as building a directed graph where the flow is conserved at each intermediate node, and the graph is acyclic. Also, the source has all edges directed away from it, and the sink has all edges directed towards it. But how to ensure that?\n\nLet me think about the flow conservation. For each node v (not source or sink), the sum of flows going into v must equal the sum going out. Let me denote for each edge, if it's directed from u to v, then it contributes +ci to u's outflow and +ci to v's inflow. So for each node, the total inflow equals outflow.\n\nThis seems similar to the concept of an Eulerian trail, but for each node, the in-degree and out-degree must balance. However, since the flow is given, perhaps we can model this as a directed graph where each node's inflow equals outflow, except source and sink.\n\nBut how to assign directions to edges so that this is true?\n\nWait, the sum of all flows into a node must equal the sum of all flows out of it. For each node v (not source or sink), the sum of flows on edges incident to v, where the direction is into v, must equal the sum of those directed out of v. So for each node, the total flow of edges incident to it must be even? No, because for example, if a node has edges with flows 10 and 5, then the inflow and outflow would need to balance. So for each node, the sum of all flows on edges connected to it must be even? Because the inflow equals the outflow, so sum_in = sum_out, and sum_in + sum_out = total_flow * 2. Therefore, total_flow must be even. Wait, but the problem states that the given flow values are already part of a maximum flow. So maybe the sum of flows for each node (except source and sink) is even?\n\nBut perhaps that's not directly relevant here. Let's think differently.\n\nWe can model this problem as finding an orientation of the edges such that for each node (other than source and sink), the net flow (sum of outflow minus inflow) is zero. But since the flow is fixed per edge, the direction determines the contribution.\n\nAlternatively, for each node v (not source or sink), the sum of flows on edges directed away from v must equal the sum of flows on edges directed towards v. Which is equivalent to saying that the sum of flows on edges incident to v is even? No, because sum_in = sum_out => sum_in + sum_out = 2*sum_in = total_flow. So the total_flow is twice the sum_in. Therefore, the total_flow for each node (sum of all edges' ci connected to it) must be even. However, since the problem says that a solution exists, this must be the case.\n\nBut how to find the directions?\n\nAn approach could be to model this as a graph where each edge's direction is chosen such that the flow conservation holds. However, how to compute that?\n\nAnother idea: think of this as a problem of finding a directed graph with the given flow values, such that for each node (except source and sink), the inflow equals outflow. This is equivalent to having a flow that is a circulation plus the source and sink. But I'm not sure.\n\nWait, the original flow is a maximum flow from source to sink. The problem says that the flow volumes are given, but the directions are unknown. So the problem is to assign directions to edges such that the flow is valid.\n\nBut since the flow is already a maximum flow, the sum of flows leaving the source equals the sum of flows entering the sink. And for other nodes, the inflow equals outflow.\n\nBut how to assign directions to edges to satisfy this?\n\nMaybe we can model this as a directed graph where the flow is a valid flow. But how?\n\nAnother thought: the problem requires that the directed graph has no cycles. So perhaps the graph should be a DAG, and we can arrange the nodes in a topological order. Then, for each edge, we direct it from the node that comes earlier in the topological order to the one that comes later. But how to ensure flow conservation?\n\nWait, but how do we choose the topological order? Maybe we can perform some kind of traversal, like BFS or DFS, and assign directions based on the traversal.\n\nAlternatively, think of the problem as building a directed acyclic graph where each node (except source and sink) has balanced inflow and outflow. How can we do that?\n\nLet me consider the example given. In the first input:\n\n3 3\n3 2 10\n1 2 10\n3 1 5\n\nThe output directions are 1, 0, 1. Which corresponds to:\n\nEdge 1: 3→2 (original was 3-2, direction is reversed)\nEdge 2: 1→2 (original is 1-2, direction is same)\nEdge 3: 3→1 (original is 3-1, direction is reversed)\n\nSo the directed edges are 2→3 (wait, no. Wait the first edge is 3-2, direction is 1 meaning the original is ai=3, bi=2. So direction is reversed, so 2→3? Or wait, the output is di: 0 means ai→bi, 1 means bi→ai. So for the first edge (ai=3, bi=2, ci=10), di=1 means the direction is bi→ai, i.e., 2→3. So the edges are:\n\nEdge 1: 2→3 (flow 10)\nEdge 2: 1→2 (flow 10)\nEdge 3: 1→3 (flow 5? No, original is 3-1, direction is 1, so bi is 1, so direction is 1→3? Wait, the original edge is ai=3, bi=1. So di=1 means the direction is from bi to ai, i.e., 1→3. So yes.\n\nThen, the flow into node 2 is 10 (from edge 2) and the outflow is 10 (edge 1). So flow conservation holds for node 2. The source (node 1) has outflow 10+5=15, and the sink (node 3) has inflow 10+5=15. So that's correct.\n\nNow, the directed graph has edges 1→2, 2→3, 1→3. Which is a DAG with topological order 1, 2, 3. So the DAG is acyclic.\n\nSo perhaps the approach is to build a DAG where nodes are ordered in a way that allows flow conservation.\n\nAnother idea: construct a directed tree structure, perhaps a DAG where each node (except the source) has a parent, and directions are from parent to child. But how to handle the flow conservation?\n\nAlternatively, think of the problem as building a directed graph with the source as the root, and each node's flow is directed towards the sink. But again, how to handle the flow conservation.\n\nWait, the flow conservation condition implies that for each node (except source and sink), the net flow is zero. So the total flow into the node equals the total flow out of it. Which suggests that the directed graph has an Eulerian trail? No, because in an Eulerian trail, the in-degree and out-degree differ by at most one. But here, for each node, the in-degree and out-degree (weighted by flow) are equal. So perhaps the problem can be modeled as finding an Eulerian circuit, but I'm not sure.\n\nAlternatively, think of the problem as a directed graph where each node (except source and sink) has equal in-flow and out-flow. So, for each node, the sum of flows on edges directed into it equals the sum of flows on edges directed out of it.\n\nBut how to find such a direction?\n\nLet me think of this as a system of equations. For each node v, the sum over edges (if directed into v) ci minus sum over edges directed out of v ci equals zero. Which is equivalent to sum (for each edge incident to v) (direction) * ci = 0. But direction is +1 if directed away, -1 if directed towards.\n\nBut solving this system for each node is challenging, especially with the constraints of acyclicity.\n\nAnother approach: since the graph is connected and the solution exists, perhaps we can model this as a directed tree where each node (except source) has exactly one parent, and the flow is directed towards the parent. But again, not sure.\n\nWait, but the graph must be acyclic. So perhaps we can arrange the nodes in a topological order, such that all edges go from earlier nodes to later nodes. Then, for each node, we can adjust the directions of edges to satisfy flow conservation.\n\nBut how?\n\nLet's think of the following steps:\n\n1. Assign directions to edges such that the graph is a DAG. For example, arrange the nodes in a topological order and direct edges from lower to higher indices in the order.\n\n2. Then, for each node (except source and sink), check if the flow conservation holds. If not, adjust directions of edges connected to it. But how?\n\nBut how to find such a topological order?\n\nAlternatively, think of the problem as building a directed graph where the nodes are arranged in a certain order, and the directions are determined based on that order. Then, for each node, we can compute the required flow.\n\nWait, here's an idea inspired by the example. Suppose we arrange the nodes in a topological order where the source is first, the sink is last, and all other nodes are in between. Then, for each node, we can direct edges towards the sink. But how to manage the flow conservation?\n\nAlternatively, think of the graph as a DAG with the source as the root, and each node's edges are directed towards the sink. But again, not sure.\n\nAnother idea: Let's model this as a directed graph where the edges are directed in such a way that the flow conservation holds. To do this, we can use a greedy approach. For example, process the nodes in a certain order and adjust the directions of edges to balance the flow.\n\nLet me think of the following algorithm:\n\n- Start with the source node (1). All edges connected to the source must be directed away from it. Because the source cannot have incoming edges.\n\n- Then, for each other node, we can track the difference between the inflow and outflow. For example, for node v, let's say that the current net flow (inflow - outflow) is some value. We need this to be zero. So, for each node, we can look at the edges that are not yet directed and adjust their direction to balance this difference.\n\nBut how to manage that? Let's think of it as a flow problem. For example, when processing node v, we can direct edges connected to it in a way that reduces the imbalance.\n\nWait, here's a possible approach:\n\nWe can model the problem as a directed graph where each node (except source and sink) must have a net flow of zero. Let's imagine that we can perform a traversal of the graph, starting from the source, and for each node, we direct edges in a way that balances the flow.\n\nFor example, suppose we have a BFS or DFS traversal. When we visit a node, we can direct the edges to unvisited nodes (so that they are directed away from the current node), and adjust the flow accordingly.\n\nBut how to ensure that the flow conservation is met?\n\nAlternatively, think of the problem as a directed graph where each node (except source and sink) has a balance of zero. Let's imagine that for each node, we can compute the required flow. For example, for node v, the sum of all flows on edges connected to it is S. Then, the sum of inflows must be S/2, and the sum of outflows must be S/2. So, for each node, we need exactly half of its edges' flows to be directed into it, and half out of it.\n\nBut how to find such a direction?\n\nThis seems like a problem of finding an orientation of the edges such that for each node, the sum of flows on edges directed out of it equals S/2. But how?\n\nAnother approach: Let's model this as a graph where each node (except source and sink) has a balance of zero. We can model this as a directed graph and use a modified DFS or BFS to assign directions.\n\nLet me think of the following algorithm:\n\n1. Start with the source node (1). All edges connected to the source must be directed away from it. For each edge from the source to another node, we direct it away. Then, for each neighbor of the source, we can track their inflow.\n\n2. For each node, once we have processed its incoming edges, we can process its outgoing edges. For example, when visiting a node, we can direct edges to unvisited nodes, and adjust the flow accordingly.\n\nBut how to handle the balance?\n\nAlternatively, think of this as a problem where each node (except source and sink) must have an equal amount of flow going in and out. So, for each node, we can calculate the total flow of its edges, and then decide how much of that should be directed in and out. But how?\n\nLet's consider the following approach:\n\nWe can model the problem as a directed graph where we perform a BFS or DFS traversal, and for each edge, we direct it from the node that was visited earlier to the one that is being visited now. This ensures that the graph is acyclic (since we process nodes in a way that edges are only directed from earlier to later in the traversal). Then, during this traversal, we can adjust the flow conservation by keeping track of the excess flow at each node.\n\nWait, here's an idea inspired by the problem of finding an Eulerian trail. Suppose we have a directed graph where each node (except source and sink) has equal in-flow and out-flow. To achieve this, we can model the problem as a directed graph and perform a traversal that adjusts the directions as needed.\n\nBut I'm not sure. Let's think of the following steps:\n\n- Treat the graph as undirected. Choose a root (source node 1). Perform a traversal (like BFS or DFS), and for each edge, when you encounter it during traversal, direct it away from the parent node. This creates a tree structure, and the rest of the edges are back edges. However, this may not account for all the flow conservation.\n\nAlternatively, think of the graph as a directed tree with additional edges. But again, not sure.\n\nWait, another idea. Since the directed graph must be acyclic, we can arrange the nodes in a topological order. Let's say the order is v1, v2, ..., vn, where v1 is the source and vn is the sink. For each edge between vi and vj, if i < j, direct it from vi to vj; otherwise, from vj to vi. But how to choose the topological order such that flow conservation is satisfied?\n\nBut how to find such an order? It's unclear.\n\nAlternatively, think of the problem as a directed acyclic graph (DAG) with a topological order. For each node in the topological order (except source and sink), the sum of flows on edges directed into it must equal the sum on edges directed out of it. How to enforce this?\n\nLet me think of the following steps:\n\n- Assign the source to be first in the topological order. The sink is last.\n\n- For each node in the topological order (starting from the second node), we can direct edges from previous nodes to this node, and edges from this node to later nodes. But how to manage the flow conservation?\n\nBut this seems too vague.\n\nAnother approach: Let's think of the problem as a directed graph where each node (except source and sink) has in-flow equal to out-flow. This implies that the total flow into the node from the edges must be equal to the flow out of it. So, for each node, the sum of flows on edges directed into it is equal to the sum on edges directed out of it.\n\nThis can be rephrased as: for each node v, the sum of flows on edges incident to v is even (as discussed earlier), and the sum of flows directed into v is exactly half of that sum.\n\nBut how to determine which edges are directed into v and which are directed out?\n\nThis feels like a problem of finding an orientation of edges that satisfies certain constraints. Perhaps we can model this as a flow problem.\n\nWait, here's a different idea. Since the flow is already a maximum flow, the residual network may have certain properties. But I'm not sure.\n\nAlternatively, think of the problem as follows: the flow on each edge is fixed. We need to assign directions to edges such that for each node (except source and sink), the net flow is zero. This is equivalent to the sum of flows directed out of the node minus the sum directed into the node equals zero. Which is the same as the sum of flows directed out of the node equals the sum directed into the node.\n\nSo, for each node v (not source or sink), the sum of flows on edges directed out of v must be equal to the sum of flows on edges directed into v. Which is the same as saying that the sum of flows on edges incident to v is twice the sum of flows directed out of v.\n\nLet me denote for each node v, total_flow[v] = sum of ci for all edges incident to v.\n\nThen, for each node v (not source or sink), the sum of flows directed out of v must be total_flow[v]/2.\n\nSo the problem reduces to selecting for each edge a direction such that for every node v (not source or sink), the sum of flows on edges directed out of v equals total_flow[v]/2.\n\nBut how to find such a direction?\n\nThis seems like a problem of finding an orientation of the edges such that for each node, the sum of flows on outgoing edges is total_flow[v]/2.\n\nBut how?\n\nThis looks like a problem of finding a directed graph where each node has a specified outflow. This is similar to the problem of finding a directed graph with given out-degrees, but here it's weighted.\n\nBut how to find such a direction?\n\nLet me think of this as a system of equations. Each edge can contribute to the outflow of one of its two endpoints. For example, if an edge between u and v is directed from u to v, then it contributes ci to the outflow of u and ci to the inflow of v. So, for each node v, the sum of ci for edges directed out of v must be equal to total_flow[v]/2.\n\nThis is a linear system, but since the variables are binary (the direction of each edge), it's not straightforward to solve.\n\nHowever, since the problem states that a solution exists, there must be a way to find such directions.\n\nAnother idea: since the graph is connected and the solution exists, we can model this as a directed graph where each node's outflow is known. We can perform a BFS or DFS traversal, and for each node, direct edges in a way that satisfies the outflow requirement.\n\nLet me think of the following algorithm:\n\n1. Compute for each node v (excluding source and sink) the required outflow: req_out[v] = total_flow[v]/2.\n\n   For the source, req_out is the total flow leaving it (which is the max flow value). Similarly for the sink, req_in is the total flow entering it. But since we don't have to worry about the sink's outflow, perhaps we can ignore it.\n\n2. We can model this as a directed graph where we need to assign directions to edges such that for each node, the sum of flows directed out of it is req_out[v].\n\n3. To do this, we can perform a traversal of the graph, and for each node, direct edges to other nodes in a way that satisfies the req_out.\n\nBut how?\n\nLet's think of the following approach:\n\nWe can perform a BFS starting from the source. For each node we visit, we will direct edges to unvisited nodes, and adjust the required outflow accordingly.\n\nFor example:\n\n- Start with the source node. Its required outflow is the total_flow[1]/2? Wait, no. For the source, the inflow is zero, and the outflow is the total_flow[1]/2? Or no. Wait, the source is allowed to have any outflow, but the other nodes must have their outflow equal to req_out.\n\nBut the source's outflow is the total flow of the maximum flow. Let's think:\n\nThe total_flow for the source is the sum of all flows on edges connected to it. Since the source has no incoming edges, all flows on edges connected to it must be directed away from it. So, the outflow of the source is the sum of all flows on edges connected to it. Which is also equal to the total_flow[1], and since the source's inflow is zero, the outflow must be equal to the total_flow[1].\n\nBut according to the earlier formula, req_out[v] for the source would be total_flow[1]/2. But that doesn't make sense. So perhaps the formula for req_out[v] is only applicable to the intermediate nodes.\n\nAh right! For the source and sink, the flow conservation does not apply. For the source, the outflow is equal to the total_flow[1], and for the sink, the inflow is equal to total_flow[n]. For other nodes, the outflow must be equal to total_flow[v]/2.\n\nSo the algorithm can be:\n\nFor each node v (not source or sink), we need to direct edges so that the sum of flows directed out of v is equal to total_flow[v]/2.\n\nNow, how to do that.\n\nLet me think of the following approach:\n\nWe can model this as a directed graph, and for each node, we keep track of how much more outflow is needed. Initially, for each node v (not source or sink), the needed_out is total_flow[v]/2.\n\nFor the source, all edges must be directed away from it. For each edge connected to the source, we add its flow to the outflow of the source, and subtract it from the needed_out of the destination node.\n\nWait, here's an idea inspired by the Ford-Fulkerson method. We can model this as a directed graph and perform a traversal, ensuring that each node's needed_out is satisfied.\n\nHere's a step-by-step plan:\n\n1. Compute for each node v, the total_flow[v] = sum of ci for all edges incident to v.\n\n2. For the source (v=1), all edges must be directed away from it. So for each edge (u, v) where u is the source, we direct it from u to v. Then, for each such edge, we add ci to the outflow of the source. For the destination node (say, w), we subtract ci from its needed_out. Because the edge is directed away from the source, so the destination node now has an inflow of ci. So the needed_out for the destination is total_flow[w]/2 minus the inflow from this edge? Or wait, needed_out is the amount of outflow that the node needs to have. Since the edge is directed into the node, it contributes to the inflow, which must be balanced by outflow. So for the destination node, the outflow must be total_flow[w]/2. The inflow from this edge is ci, so the outflow from this node must be total_flow[w]/2. So if the edge is directed into the node, then the outflow of the node must account for that.\n\nThis is getting complicated. Let's think of it in terms of the needed_out for each node. Initially, needed_out for each node (not source or sink) is total_flow[v]/2.\n\nWhen we direct an edge from u to v, this contributes ci to the outflow of u and ci to the inflow of v. Therefore, the outflow of u increases by ci, and the inflow of v increases by ci. For the node v, since the inflow is part of its total flow, the outflow of v must be equal to total_flow[v]/2. So the inflow of v is (total_flow[v] - outflow of v). But the inflow of v is the sum of flows on edges directed into it. So, for each node v, the sum of inflow + outflow = total_flow[v]. And since outflow must be equal to total_flow[v]/2, inflow is also total_flow[v]/2.\n\nTherefore, for each node v, the sum of flows directed into it must be equal to total_flow[v]/2.\n\nBut how to track this?\n\nLet me think of it as follows: for each node v (not source or sink), the sum of flows directed into it is equal to the sum of flows directed out of it. So, when we direct an edge into v, it contributes to the inflow of v. To ensure that the inflow is equal to total_flow[v]/2, we need to track how much more inflow v needs.\n\nWait, maybe we can think of it as for each node v (not source or sink), the inflow must be exactly total_flow[v]/2. So, we can track for each node the remaining inflow needed.\n\nInitially, for each node v (not source or sink), the required inflow is total_flow[v]/2.\n\nWhen we direct an edge into v, we subtract the flow from the required inflow. When we direct an edge out of v, we do nothing for the required inflow, since it's contributing to the outflow.\n\nBut how to decide which direction to take for each edge.\n\nHere's an idea inspired by the BFS traversal:\n\n- We start with the source. For each edge connected to the source, we direct it away from the source. This adds ci to the outflow of the source. For the other end of the edge (say, node w), we subtract ci from its required inflow (because this edge is directed into w, contributing ci to its inflow).\n\n- Then, we process node w. For each edge connected to w, if it hasn't been directed yet, we check whether directing it away from w would help in satisfying the required inflow of other nodes.\n\nWait, this might not work. Let me think of an example.\n\nTake the first sample input:\n\nNodes 1, 2, 3.\n\nEdges:\n\n3-2 (ci=10)\n\n1-2 (ci=10)\n\n3-1 (ci=5)\n\ntotal_flow for each node:\n\nnode 1: 10 (from 1-2) +5 (from 3-1) = 15.\n\nnode 2: 10 (from 1-2) +10 (from 3-2) = 20.\n\nnode 3: 10 (from 3-2) +5 (from 3-1) = 15.\n\nFor node 2, required inflow is 20/2 = 10.\n\nProcessing the source (node 1). The edges connected to it are 1-2 (ci=10) and 3-1 (ci=5). We direct both away from node 1. So for edge 1-2, directed from 1 to 2. This contributes 10 to the inflow of node 2. Required inflow for node 2 is 10, so after this, it's 10-10=0. For the edge 3-1, directed from 1 to 3. Wait, no. The original edge is between 3 and 1, and we are directing it away from source (node 1), so direction is 1→3. So this contributes 5 to the inflow of node 3. Node 3's required inflow is 15/2 = 7.5? Wait, but the problem says that the solution always exists, so the total_flow must be even for all intermediate nodes. But node 3 is the sink, so it's allowed to have odd total_flow? Or wait, node 3 is the sink. The problem says that for nodes 1 < v < n, the flow conservation holds. So node 3 is the sink (n=3), so no flow conservation. Thus, for node 3, we don't care about the inflow/outflow. So for the edge directed from 1 to 3, it contributes to the outflow of node 1 and inflow of node 3. But since node 3 is the sink, we don't need to track anything for it.\n\nSo after processing the source's edges, node 2 has required inflow 0. Now, we can process node 2. What edges are connected to it? The edge to node 1 (already directed away), and the edge to node 3 (ci=10). This edge is undirected. We need to direct it in a way that helps other nodes. Since node 2's required inflow is already satisfied (it's 0), we need to direct this edge away from node 2. Why? Because node 2's outflow must be equal to total_flow[2]/2 = 20/2 = 10. The current outflow of node 2 is the edge from 1→2 (no, that's inflow for node 2). Wait, the outflow of node 2 is the sum of flows on edges directed away from it. Currently, there are no edges directed away from node 2. So, the outflow is zero. The required outflow is 10. So we need to direct the edge from node 2 to node 3. That would contribute 10 to the outflow of node 2, satisfying the required outflow. Thus, this edge is directed from 2→3.\n\nNow, for node 3, this contributes 10 to its inflow. But since it's the sink, we don't care. So all edges are directed, and the flow conservation holds.\n\nThis matches the sample solution.\n\nSo the algorithm seems to work for this case.\n\nLet's try to generalize this approach:\n\n- For each node, track the required inflow (for non-source/sink nodes).\n\n- Process nodes in BFS order, starting from the source.\n\n- For each node u, when processing it, for each adjacent edge that hasn't been directed yet:\n\n   - If the other end of the edge is the sink, direct it away from u (since the sink's inflow is not tracked).\n\n   - Else, check whether the other node v has required inflow > 0. If so, direct the edge from u to v. This contributes ci to the inflow of v, reducing its required inflow by ci. Otherwise, direct the edge from v to u, which contributes ci to the inflow of u (but since u is being processed, we need to check if that's allowed).\n\nWait, but how to decide which direction to take for the edge.\n\nLet me think again. For the current node u, we have already processed all edges that are directed away from u. Wait, no. The idea is that during the traversal, we are ensuring that the required inflow for the nodes is satisfied.\n\nBut how to ensure that.\n\nLet me think of the following steps:\n\nInitialize a queue with the source node.\n\nFor each node u dequeued from the queue:\n\n   For each edge connected to u that hasn't been directed yet:\n\n      Let v be the other end of the edge.\n\n      If v is the sink, direct the edge from u to v. Add this to the output.\n\n      Else:\n\n         If the required inflow of v is greater than 0:\n\n             Direct the edge from u to v. Subtract ci from the required inflow of v.\n\n             Add v to the queue.\n\n         Else:\n\n             Direct the edge from v to u. This contributes to the inflow of u. But since u is being processed, we need to check if this is allowed. However, since u's required inflow is already handled (since u is being processed, perhaps it's not needed?), or maybe not. \n\nWait, this is getting complicated. Let's think again.\n\nThe required inflow for a node v (non-sink) is initially total_flow[v]/2. When we direct an edge into v, we subtract ci from required_inflow[v]. Once required_inflow[v] reaches zero, we can process v.\n\nSo, during the traversal:\n\nWhen processing node u, we look at all edges connected to u that are not yet directed. For each such edge between u and v:\n\n- If v is the sink, direct it from u to v.\n\n- Else, if required_inflow[v] > 0: direct the edge from u to v. Subtract ci from required_inflow[v]. Add v to the queue.\n\n- Else: direct the edge from v to u. This contributes to the inflow of u. But since u is being processed, perhaps this is not needed. However, since u's required_inflow may not have been handled yet.\n\nBut how can we handle this case?\n\nFor example, suppose u is being processed, and v has required_inflow[v] == 0. Then directing the edge from v to u would contribute ci to the inflow of u. However, since u's required_inflow may not be zero yet, this is allowed. But how to ensure that u's required_inflow is eventually satisfied.\n\nThis seems like a problem. Because if we direct the edge from v to u, then u's inflow increases by ci. But u's required_inflow is the amount of inflow it needs to have. So, for u, required_inflow[u] is initially total_flow[u]/2. So, if we direct an edge into u, we subtract from required_inflow[u].\n\nBut in this case, when we process u, we have to consider all edges connected to u. So, during processing of u, for each edge between u and v:\n\nIf the edge hasn't been directed yet, we decide its direction based on whether v's required_inflow is positive.\n\nBut what if v's required_inflow is zero? Then, we can't direct the edge into v (since that would require adding to its inflow, but it's already satisfied). So we have to direct it from v to u, which contributes to u's inflow.\n\nBut then, for u, we need to track how much inflow it has received so far. Because u's required_inflow is total_flow[u]/2. So, if we direct an edge into u, we need to subtract from required_inflow[u].\n\nSo, during processing of u:\n\nFor each edge between u and v:\n\n   if edge not directed yet:\n\n      if v is the sink:\n\n          direct from u to v.\n\n      else:\n\n          if required_inflow[v] > 0:\n\n              direct from u to v.\n\n              required_inflow[v] -= ci.\n\n              add v to the queue.\n\n          else:\n\n              direct from v to u.\n\n              required_inflow[u] -= ci.\n\nBut wait, why would we subtract from required_inflow[u]? Because the edge is directed into u, contributing to its inflow.\n\nYes! Because for node u, the required_inflow is the amount of inflow it needs. So when an edge is directed into u, we subtract ci from required_inflow[u].\n\nBut how do we know that required_inflow[u] is not already zero?\n\nThis suggests that during processing of u, we may have to direct edges into u, which would reduce required_inflow[u]. However, since u is being processed, perhaps required_inflow[u] is not zero yet. So this is allowed.\n\nBut how to ensure that required_inflow[u] eventually reaches zero.\n\nThis seems like a viable approach. Let's test this with the sample input.\n\nSample input:\n\nn=3, m=3.\n\nEdges:\n\n3-2 (ci=10)\n\n1-2 (ci=10)\n\n3-1 (ci=5)\n\ntotal_flow:\n\nnode 1: 10 +5 =15 (source)\n\nnode 2: 10+10=20 (required inflow 10)\n\nnode 3: 10+5=15 (sink)\n\nProcessing starts with node 1 in the queue.\n\nrequired_inflow for node 2 is 10, node 3 is not considered.\n\nFor each edge connected to node 1:\n\nEdge between 1 and 2:\n\nv is 2, not sink. required_inflow[v] is 10>0. So direct from 1 to 2. Subtract 10 from required_inflow[2], which becomes 0. Add 2 to the queue.\n\nEdge between 1 and 3: v is 3 (sink). Direct from 1 to 3. No change to required_inflow.\n\nNow, queue has node 2.\n\nProcess node 2:\n\nCheck edges connected to 2. These are:\n\n- Edge between 1 and ",
    "response": "To solve this problem, we need to direct the edges of an undirected graph such that the resulting directed graph satisfies the flow conservation conditions for all intermediate vertices (excluding the source and sink), has no cycles, and ensures the source has no incoming edges.\n\n### Approach\n1. **Flow Conservation**: For each intermediate vertex (not the source or sink), the sum of incoming flows must equal the sum of outgoing flows.\n2. **Acyclic Graph**: The directed graph must be acyclic. This can be achieved by processing nodes in a topological order using BFS traversal.\n3. **Direction Assignment**: Using BFS starting from the source, we direct edges away from the source and ensure that intermediate nodes meet their required inflow by adjusting edge directions dynamically during traversal.\n\n### Solution Code\n```python\nimport sys\nimport threading\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n\n    edges = []\n    adj = [[] for _ in range(n + 1)]\n    for i in range(m):\n        a = int(input[idx])\n        idx += 1\n        b = int(input[idx])\n        idx += 1\n        c = int(input[idx])\n        idx += 1\n        edges.append((a, b, c))\n        adj[a].append((b, i))\n        adj[b].append((a, i))\n\n    total_flow = [0] * (n + 1)\n    for a, b, c in edges:\n        total_flow[a] += c\n        total_flow[b] += c\n\n    required_inflow = [0] * (n + 1)\n    for v in range(1, n + 1):\n        if v == 1 or v == n:\n            continue\n        required_inflow[v] = total_flow[v] // 2\n\n    directed = [0] * m  # 0 means original direction, 1 means reversed\n\n    visited_edge = [False] * m\n\n    q = deque()\n    q.append(1)\n    visited_node = [False] * (n + 1)\n    visited_node[1] = True\n\n    while q:\n        u = q.popleft()\n        for (v, edge_idx) in adj[u]:\n            if visited_edge[edge_idx]:\n                continue\n            if u == 1:\n                # source, direct away\n                directed[edge_idx] = 0\n                visited_edge[edge_idx] = True\n                if v != n:\n                    required_inflow[v] -= edges[edge_idx][2]\n                    if required_inflow[v] == 0:\n                        q.append(v)\n                        visited_node[v] = True\n                continue\n            if v == n:\n                # direct from u to v\n                directed[edge_idx] = 0\n                visited_edge[edge_idx] = True\n                continue\n            if required_inflow[v] > 0:\n                # direct from u to v\n                directed[edge_idx] = 0\n                visited_edge[edge_idx] = True\n                required_inflow[v] -= edges[edge_idx][2]\n                if required_inflow[v] == 0:\n                    q.append(v)\n                    visited_node[v] = True\n            else:\n                # direct from v to u\n                directed[edge_idx] = 1\n                visited_edge[edge_idx] = True\n                required_inflow[u] -= edges[edge_idx][2]\n                if required_inflow[u] == 0 and not visited_node[u]:\n                    q.append(u)\n                    visited_node[u] = True\n\n    for d in directed:\n        print(d)\n\nthreading.Thread(target=main).start()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into edges and adjacency lists.\n2. **Total Flow Calculation**: For each node, calculate the total flow of all incident edges.\n3. **Required Inflow**: For each intermediate node, compute the required inflow as half of the total flow.\n4. **BFS Traversal**: Starting from the source, use BFS to traverse the graph. Direct edges away from the source and adjust directions based on the required inflow of neighboring nodes.\n5. **Edge Direction Adjustment**: During BFS traversal, dynamically adjust edge directions to ensure intermediate nodes meet their required inflow while maintaining an acyclic structure.\n\nThis approach ensures that the resulting directed graph meets the flow conservation constraints and remains acyclic, efficiently solving the problem within the given constraints.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport threading\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n\n    edges = []\n    adj = [[] for _ in range(n + 1)]\n    for i in range(m):\n        a = int(input[idx])\n        idx += 1\n        b = int(input[idx])\n        idx += 1\n        c = int(input[idx])\n        idx += 1\n        edges.append((a, b, c))\n        adj[a].append((b, i))\n        adj[b].append((a, i))\n\n    total_flow = [0] * (n + 1)\n    for a, b, c in edges:\n        total_flow[a] += c\n        total_flow[b] += c\n\n    required_inflow = [0] * (n + 1)\n    for v in range(1, n + 1):\n        if v == 1 or v == n:\n            continue\n        required_inflow[v] = total_flow[v] // 2\n\n    directed = [0] * m  # 0 means original direction, 1 means reversed\n\n    visited_edge = [False] * m\n\n    q = deque()\n    q.append(1)\n    visited_node = [False] * (n + 1)\n    visited_node[1] = True\n\n    while q:\n        u = q.popleft()\n        for (v, edge_idx) in adj[u]:\n            if visited_edge[edge_idx]:\n                continue\n            if u == 1:\n                # source, direct away\n                directed[edge_idx] = 0\n                visited_edge[edge_idx] = True\n                if v != n:\n                    required_inflow[v] -= edges[edge_idx][2]\n                    if required_inflow[v] == 0:\n                        q.append(v)\n                        visited_node[v] = True\n                continue\n            if v == n:\n                # direct from u to v\n                directed[edge_idx] = 0\n                visited_edge[edge_idx] = True\n                continue\n            if required_inflow[v] > 0:\n                # direct from u to v\n                directed[edge_idx] = 0\n                visited_edge[edge_idx] = True\n                required_inflow[v] -= edges[edge_idx][2]\n                if required_inflow[v] == 0:\n                    q.append(v)\n                    visited_node[v] = True\n            else:\n                # direct from v to u\n                directed[edge_idx] = 1\n                visited_edge[edge_idx] = True\n                required_inflow[u] -= edges[edge_idx][2]\n                if required_inflow[u] == 0 and not visited_node[u]:\n                    q.append(u)\n                    visited_node[u] = True\n\n    for d in directed:\n        print(d)\n\nthreading.Thread(target=main).start()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 702,
        "completion_token_count": 945,
        "thoughts_token_count": 8192
    }
}