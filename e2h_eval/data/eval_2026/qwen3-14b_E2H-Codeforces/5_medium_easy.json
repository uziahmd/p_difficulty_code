{
    "start": 1758023567.0896692,
    "end": 1758026619.5915096,
    "start-formatted": "2025-09-16 20:52 KST",
    "end-formatted": "2025-09-16 21:43 KST",
    "gpu": 2,
    "pid": 5,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Colored Boots\n\nThere are $$$n$$$ left boots and $$$n$$$ right boots. Each boot has a color which is denoted as a lowercase Latin letter or a question mark ('?'). Thus, you are given two strings $$$l$$$ and $$$r$$$, both of length $$$n$$$. The character $$$l_i$$$ stands for the color of the $$$i$$$-th left boot and the character $$$r_i$$$ stands for the color of the $$$i$$$-th right boot.A lowercase Latin letter denotes a specific color, but the question mark ('?') denotes an indefinite color. Two specific colors are compatible if they are exactly the same. An indefinite color is compatible with any (specific or indefinite) color.For example, the following pairs of colors are compatible: ('f', 'f'), ('?', 'z'), ('a', '?') and ('?', '?'). The following pairs of colors are not compatible: ('f', 'g') and ('a', 'z').Compute the maximum number of pairs of boots such that there is one left and one right boot in a pair and their colors are compatible.Print the maximum number of such pairs and the pairs themselves. A boot can be part of at most one pair.\n\n## Input\nThe first line contains $$$n$$$ ($$$1 \\le n \\le 150000$$$), denoting the number of boots for each leg (i.e. the number of left boots and the number of right boots).The second line contains the string $$$l$$$ of length $$$n$$$. It contains only lowercase Latin letters or question marks. The $$$i$$$-th character stands for the color of the $$$i$$$-th left boot.The third line contains the string $$$r$$$ of length $$$n$$$. It contains only lowercase Latin letters or question marks. The $$$i$$$-th character stands for the color of the $$$i$$$-th right boot.\n\n## Output\nPrint $$$k$$$ — the maximum number of compatible left-right pairs of boots, i.e. pairs consisting of one left and one right boot which have compatible colors.The following $$$k$$$ lines should contain pairs $$$a_j, b_j$$$ ($$$1 \\le a_j, b_j \\le n$$$). The $$$j$$$-th of these lines should contain the index $$$a_j$$$ of the left boot in the $$$j$$$-th pair and index $$$b_j$$$ of the right boot in the $$$j$$$-th pair. All the numbers $$$a_j$$$ should be distinct (unique), all the numbers $$$b_j$$$ should be distinct (unique).If there are many optimal answers, print any of them.\n\n## Example\n### Input\n['10\\ncodeforces\\ndodivthree', '7\\nabaca?b\\nzabbbcc', '9\\nbambarbia\\nhellocode', '10\\ncode??????\\n??????test']\n\n### Output\n['5\\n7 8\\n4 9\\n2 2\\n9 10\\n3 1', '5\\n6 5\\n2 3\\n4 6\\n7 4\\n1 2', '0', '10\\n6 2\\n1 6\\n7 3\\n3 5\\n4 8\\n9 7\\n5 1\\n2 4\\n10 9\\n8 10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\nOkay, let's tackle this problem. So, the task is to find the maximum number of compatible left-right boot pairs. Each pair must consist of one left and one right boot, and their colors must be compatible. The compatibility rules are that two specific colors (letters) must be the same, and a question mark can match any color, including another question mark.\n\nHmm. The challenge is to maximize the number of pairs. Let's think about how to approach this.\n\nFirst, I need to process the two strings l and r. For each position, we have a left boot and a right boot. But we can't just pair them directly unless their colors are compatible. Also, since each boot can be in at most one pair, we need to find an optimal way to match them.\n\nLet me think of possible strategies. One idea is to first pair up the left boots with specific colors and right boots with matching colors. Then handle the question marks.\n\nBut how to do that efficiently?\n\nLet me break it down into steps:\n\n1. Pair as many specific color matches as possible. For example, if a left boot has color 'a', find a right boot with color 'a' that hasn't been paired yet. But how to do this optimally?\n\n2. Then, use the question marks. For example, left question marks can pair with any right boots (specific or question), and vice versa. However, we need to make sure that we don't pair them in a way that uses up resources unnecessarily.\n\nWait, but the question marks can be used in two ways: either they can pair with specific colors (which would be better than using them for other question marks?), or maybe not. Hmm.\n\nAlternatively, here's an approach:\n\n- First, count all the specific colors in the left and right boots. For each color c (excluding '?'), we can pair left c's with right c's. The maximum possible pairs here would be the minimum of the counts of c in left and right. But we also need to track which positions are used.\n\nBut since the problem allows us to choose any pairing as long as it's optimal, perhaps we can process the specific colors first, then handle the question marks.\n\nBut how to track which positions have been used?\n\nAnother thought: for each color (excluding '?'), we can pair left and right boots of that color. Let's say for color 'a', we have some left boots and some right boots. We can pair them as much as possible. Once those are paired, the remaining left and right boots with '?' can be paired among themselves or with the remaining ones.\n\nBut how to manage that?\n\nAlternatively, perhaps the following steps:\n\n1. Create a list of left boots that are not '?', and a list of right boots that are not '?'. For each color, we can pair left and right boots of that color. For example, for color 'a', we can pair as many left 'a's with right 'a's as possible. Once that's done, the remaining left and right boots (those with '?') can be paired with each other or with the remaining ones.\n\nBut how to track which positions are used?\n\nWait, but the problem requires that we output the actual indices of the pairs. So we need to track which left and right boots have been used.\n\nSo maybe the approach is:\n\n- For each color c (not '?'), collect the indices of left boots with color c and the indices of right boots with color c. Then, pair them up. For example, if there are 3 left 'a's and 5 right 'a's, we can pair all 3 left with 3 right. Then, the remaining right 'a's can't be used for this color anymore, but maybe they can be used with question marks.\n\nBut how to pair them? For example, after pairing all specific colors, the remaining left and right boots are those with '?'. Then, we can pair them with each other. But how?\n\nWait, but the question marks can be matched with any. So perhaps the optimal way is to first pair as many specific color pairs as possible, then pair the remaining question marks with the remaining question marks, and also any leftover specific color boots that couldn't be paired.\n\nWait, but maybe there's a better way. For example, if there are left question marks and right specific colors, we can pair them. Similarly, if there are left specific colors and right question marks.\n\nBut how to balance that? Because if we pair a left question with a right specific, that may prevent a right question from being paired with another left specific. But perhaps that's better than not pairing them.\n\nBut how to model this optimally?\n\nThis feels like a bipartite graph matching problem, but with n up to 150,000, that's not feasible for standard algorithms like Hungarian, which are O(n^3).\n\nThus, we need a greedy approach.\n\nLet me think again. Let's separate the left and right boots into three categories:\n\nLeft Specific (LS): left boots with color != '?'\n\nLeft Question (LQ): left boots with color '?'\n\nRight Specific (RS): right boots with color != '?'\n\nRight Question (RQ): right boots with color '?'\n\nThe plan is to:\n\n1. Pair LS with RS of same color. For each color c, pair as many as possible between LS[c] and RS[c].\n\n2. Then, pair LS with RQ (if any). For example, any remaining LS that couldn't be paired with RS can be paired with RQ.\n\n3. Then, pair LQ with RS (if any). Any remaining RS that couldn't be paired with LS can be paired with LQ.\n\n4. Finally, pair LQ with RQ.\n\nBut how to implement this?\n\nBut perhaps the order matters. For example, pairing LS with RS first is better than using LS with RQ. Because otherwise, you could have more pairs.\n\nBut how to handle this optimally?\n\nLet me think about the first step: pairing same-color LS and RS. For example, for each color c, take min( count of LS[c], count of RS[c] ), and pair them. That's straightforward.\n\nOnce that's done, the remaining LS and RS are those that couldn't be paired. For example, suppose there are 5 LS 'a's and 3 RS 'a's. After pairing, 2 LS 'a's remain. These can be paired with RQ's.\n\nSimilarly, the RS 'a's that were paired are already used, so the remaining RS are those that couldn't be matched with their same color LS.\n\nThen, for the remaining LS (those that are not paired yet), we can pair them with RQ's. Similarly, for the remaining RS (those not paired yet), we can pair them with LQ's.\n\nBut how to do this?\n\nLet me think of data structures. For example, after step 1, collect all the remaining LS (those that are not paired) and all the remaining RS (those not paired). Then, for each LS, we can pair it with any RQ (since RQ can match any color). Similarly, for each RS, pair with any LQ.\n\nBut how to do this in code?\n\nLet me think of the following steps:\n\n- Initialize two arrays: left_used and right_used, to track whether a boot is already used.\n\n- For each color c in a-z:\n\n   - collect all left indices where l[i] == c and not used.\n\n   - collect all right indices where r[j] == c and not used.\n\n   - pair them as much as possible, and mark them as used.\n\nThis is step 1.\n\nThen, for step 2: pair remaining left specific (LS) with right question (RQ). For each left index i (LS) not used, we can pair with any RQ not used. Similarly, for step 3: pair remaining right specific (RS) with LQ.\n\nBut how to pair them efficiently?\n\nFor example, for step 2, collect all the remaining LS (those that are not used) and all the RQ (not used). Then, pair as many as possible. Since each LS can be paired with any RQ. So the number of such pairs is min( number of remaining LS, number of remaining RQ ). How to pair them? For example, take the first available LS and pair with the first available RQ.\n\nSimilarly for step 3.\n\nThen, step 4: pair remaining LQ and RQ. The number of pairs here is min( number of LQ not used, number of RQ not used )\n\nBut how to implement this?\n\nBut how to collect the remaining LS, RQ, etc.?\n\nPerhaps, during the initial steps, we can track which left and right boots are used. Then, for each step, collect the available ones.\n\nBut for large n (up to 1.5e5), we need to process this efficiently.\n\nLet me outline the code structure:\n\nRead n, l, r.\n\nInitialize left_used = [False] * n\n\nright_used = [False] * n\n\npairs = []\n\nThen, for each color c in 'a' to 'z':\n\n   collect all left indices where l[i] == c and not used.\n\n   collect all right indices where r[j] == c and not used.\n\n   for each pair (left, right) in zip(left_list, right_list):\n\n       add to pairs, mark left and right as used.\n\nBut how to collect these lists. For example, for each color c, we can precompute the list of left and right indices. But for each step, we have to check if they are already used.\n\nAlternatively, for each color c, we can have a list of left indices with that color, and a list of right indices with that color. Then, during step 1, for each color, we pair as many as possible between left and right.\n\nBut how to do this? For example, for color 'a', we have left_a = list of indices where l[i] is 'a', and right_a = list of indices where r[j] is 'a'. Then, for each i in left_a and j in right_a, pair them up until one of the lists is exhausted.\n\nBut since the order in which we pair them can affect the overall result, but since the problem allows any valid maximum pairing, perhaps we can pair them in the order they appear.\n\nBut to avoid reprocessing, perhaps during step 1, we can process each color once, and pair the left and right indices for that color.\n\nSo, for example, for color 'a', we take the left indices and right indices, and pair them in order. For example, for the first m elements, where m is min(len(left_a), len(right_a)).\n\nOnce that's done, those indices are marked as used.\n\nThen, after processing all colors, we proceed to step 2: pair remaining left specific (those not used) with right question marks (not used).\n\nSimilarly for step 3: pair remaining right specific (those not used) with left question marks (not used).\n\nThen, step 4: pair remaining left question and right question.\n\nBut how to collect the remaining left specific and right question?\n\nFor step 2:\n\nWe can iterate through all left indices, check if they are not used and their color is not '?'. Then collect them into a list. Similarly, collect all right indices not used and their color is '?'.\n\nThen, pair as many as possible between these two lists. For example, for each left in the left_specific_remaining list, pair with a right from the right_question_remaining list.\n\nSimilarly for step 3: collect right_specific_remaining (those not used, color not '?') and pair with left_question_remaining (not used, color '?').\n\nThen, for step 4, collect left_question_remaining (not used) and right_question_remaining (not used), pair them as much as possible.\n\nBut how to implement this efficiently?\n\nLet me think of code steps:\n\nAfter step 1:\n\nCollect all left indices that are not used and have color != '?'. Let's call this list left_spec_remaining.\n\nCollect all right indices that are not used and have color == '?'. Call this right_q_remaining.\n\nNow, for each left in left_spec_remaining, we can pair them with a right in right_q_remaining. The number of such pairs is min(len(left_spec_remaining), len(right_q_remaining)).\n\nSo we can pair them in order. For example, take the first k elements of left_spec_remaining and first k elements of right_q_remaining, where k is the min.\n\nSimilarly for step 3.\n\nThen, collect left_q_remaining (left indices not used and color is '?'), and right_spec_remaining (right indices not used and color != '?'). Pair them as per min(len(...)).\n\nFinally, pair the remaining left_q_remaining with right_q_remaining.\n\nBut how to collect these lists?\n\nIn Python, for large n, it's important to process this efficiently. Let's see:\n\nFor step 2:\n\nleft_spec_remaining = [i for i in range(n) if not left_used[i] and l[i] != '?']\nright_q_remaining = [j for j in range(n) if not right_used[j] and r[j] == '?']\n\nThen, the number of pairs is min(len(left_spec_remaining), len(right_q_remaining)).\n\nWe can pair them by taking the first k elements from each list.\n\nSimilarly for the other steps.\n\nBut for large n, creating these lists could take O(n) time each time, which is acceptable since n is up to 1.5e5 and the steps are O(n) each.\n\nOnce these are processed, then step 4.\n\nBut what about the order of processing steps?\n\nFor example, after step 2 and step 3, the remaining left_q_remaining and right_q_remaining can be paired.\n\nBut perhaps the order of steps 2 and 3 can be adjusted. For example, pairing left_spec_remaining with right_q_remaining first, then right_spec_remaining with left_q_remaining, then the remaining q's.\n\nBut that seems correct.\n\nNow, let's think about the example given.\n\nTake the first sample input:\n\nSample Input 1:\n\nn=10\n\nl = \"codeforces\"\n\nr = \"dodivthree\"\n\nSample Output is 5 pairs.\n\nBut how does the algorithm process this?\n\nLet's think:\n\nStep 1: for each color, pair same color left and right.\n\nFor example, in l = 'c o d e f o r c e s'\n\nr = 'd o d i v t h r e e'\n\nLooking for same colors:\n\nLet's check each color:\n\nFor 'c' in left: positions 0, 7.\n\nIn right: 'd o d i v t h r e e' — no 'c's. So nothing here.\n\nFor 'o': left has positions 1, 5.\n\nRight has o at position 1. So pair 1 and 1? Or maybe others.\n\nBut in any case, step 1 will pair same color.\n\nThen, after that, step 2: pair left specific (unpaired) with right questions.\n\nBut in the sample input, the right string is \"dodivthree\" — which has no '?'. So step 2 would not have any right question. Similarly, step 3 would pair right specific with left questions. But the left string is \"codeforces\" — no '?'. So step 3 would not have any left question. Then step 4 is pairing left and right questions, but there are none. So the total pairs would be the ones from step 1.\n\nBut according to the sample output, the first input gives 5 pairs. So perhaps the step 1 pairing isn't sufficient. Wait, maybe I'm misunderstanding the sample input.\n\nWait, the first sample input is given as:\n\nInput is ['10\\ncodeforces\\ndodivthree', ...]. But the example shows that the first output is 5 pairs. So perhaps the step 1 pairing gives some pairs, and other steps add more.\n\nBut perhaps I need to think of the algorithm again.\n\nWait, maybe the steps I outlined are not sufficient. Because in step 1, I pair same-color left and right. But perhaps there are cases where pairing a left question with a right question is better than pairing some specific colors. But no, because the algorithm first pairs the same-color ones, which are the most restrictive.\n\nAlternatively, perhaps the steps need to be adjusted. For example, after step 1, we have some left and right specific boots that are not paired. Then, we can pair them with question marks.\n\nBut how to implement that.\n\nAnother idea: after step 1, for the left and right specific boots that are not paired, they can be paired with question marks. But the question marks can be on either side.\n\nBut in the code steps above, step 2 is pairing left specific with right question, step 3 is pairing right specific with left question, and step 4 is pairing left and right question.\n\nSo, the algorithm should capture all possibilities.\n\nBut how to implement this in code.\n\nNow, the problem is that the code needs to generate the pairs, and track which indices are used.\n\nSo, the code outline would be:\n\nRead n, l, r.\n\nInitialize left_used and right_used arrays of size n, all False.\n\npairs = empty list.\n\nProcess each color from 'a' to 'z':\n\n   collect all left indices where l[i] == c and not used.\n\n   collect all right indices where r[j] == c and not used.\n\n   for each pair (left, right) in zip(left_list, right_list):\n\n       add (left+1, right+1) to pairs (since indices are 1-based)\n\n       mark left_used[left] = True\n\n       mark right_used[right] = True\n\nOnce all colors are processed, proceed to step 2:\n\nCollect left_spec_remaining (left not used, color != '?')\n\nCollect right_q_remaining (right not used, color == '?')\n\nTake min(len(left_spec_remaining), len(right_q_remaining)) pairs.\n\nFor i in 0 to k-1:\n\n   add (left_spec_remaining[i]+1, right_q_remaining[i]+1) to pairs.\n\n   mark left_used and right_used accordingly.\n\nThen step 3:\n\nCollect right_spec_remaining (right not used, color != '?')\n\nCollect left_q_remaining (left not used, color == '?')\n\nTake min(len(...)) pairs.\n\nAdd to pairs.\n\nThen step 4:\n\nCollect left_q_remaining (not used) and right_q_remaining (not used).\n\nTake min(len(...)) pairs.\n\nAdd to pairs.\n\nBut how to collect the remaining lists.\n\nBut in code, for step 2, after step 1, we can generate the lists as follows:\n\nleft_spec_remaining = [i for i in range(n) if not left_used[i] and l[i] != '?']\n\nright_q_remaining = [j for j in range(n) if not right_used[j] and r[j] == '?']\n\nThen, for each i in range(min(len(left_spec_remaining), len(right_q_remaining))):\n\n   add pair (left_spec_remaining[i], right_q_remaining[i])\n\n   mark them as used.\n\nBut wait, how to mark them as used? Because when we create these lists, they are not used. So during this step, we can loop through the elements of the lists, and mark them as used.\n\nBut in code, for example:\n\nfor i in range(k):\n\n    left_idx = left_spec_remaining[i]\n\n    right_idx = right_q_remaining[i]\n\n    pairs.append( (left_idx+1, right_idx+1) )\n\n    left_used[left_idx] = True\n\n    right_used[right_idx] = True\n\nSimilarly for the other steps.\n\nBut for step 3, collect:\n\nright_spec_remaining = [j for j in range(n) if not right_used[j] and r[j] != '?']\n\nleft_q_remaining = [i for i in range(n) if not left_used[i] and l[i] == '?']\n\nk = min(len(right_spec_remaining), len(left_q_remaining))\n\nfor i in range(k):\n\n    left_idx = left_q_remaining[i]\n\n    right_idx = right_spec_remaining[i]\n\n    pairs.append( ... )\n\n    mark used.\n\nThen step 4:\n\nleft_q_remaining = [i for i in range(n) if not left_used[i] and l[i] == '?']\n\nright_q_remaining = [j for j in range(n) if not right_used[j] and r[j] == '?']\n\nk = min(len(left_q_remaining), len(right_q_remaining))\n\nfor i in range(k):\n\n    pairs.append( ... )\n\nBut this approach may have overlapping steps. For example, in step 2, after pairing, the left_spec_remaining and right_q_remaining are modified. So during step 3, we need to collect the new lists again.\n\nBut in code, the steps are:\n\nAfter step 1, collect the left_spec_remaining and right_q_remaining.\n\nThen, pair them as per step 2.\n\nThen, collect right_spec_remaining and left_q_remaining for step 3.\n\nBut how to collect them again.\n\nBut this approach is feasible.\n\nNow, let's test this logic with the sample input.\n\nSample Input 1:\n\nn=10\n\nl = \"codeforces\" → characters are c o d e f o r c e s\n\nr = \"dodivthree\" → d o d i v t h r e e\n\nLet's process step 1.\n\nFor each color c in a-z:\n\nCheck for left and right.\n\nFor example:\n\nColor 'c':\n\nleft has positions 0 and 7.\n\nright has no 'c's.\n\nSo no pairs.\n\nColor 'o':\n\nleft has positions 1, 5.\n\nright has position 1 (o).\n\nSo pair left 1 with right 1. Then, left 5 remains.\n\nColor 'd':\n\nleft has position 2.\n\nright has positions 0, 2.\n\nPair left 2 with right 0. Now, left 2 is used, right 0 is used.\n\nColor 'e':\n\nleft has positions 3, 8.\n\nright has positions 8, 9.\n\nPair left 3 with right 8, left 8 with right 9? Or depends on order.\n\nWait, in code, for each color, we collect all left and right indices, and pair them in order. For example, for color 'e', left indices are [3, 8], right indices are [8,9]. So pair 3 with 8, and 8 with 9. So both pairs are added.\n\nBut then, after that, the left 3 and 8 are marked as used, right 8 and 9 are marked as used.\n\nSimilarly for other colors.\n\nSo after step 1, the pairs would include:\n\n(1, 1), (2, 0), (3, 8), (8, 9) ?\n\nWait, but let's think again. For each color, we collect the left and right indices. For example, for 'o' in the left, we have indices [1,5], and in the right, indices [1]. So we can pair left 1 with right 1. The left 5 remains.\n\nSo after step 1, the pairs are:\n\n(1,1), (2,0), (3,8), (8,9) ?\n\nWait, but what about other colors?\n\nFor example, 'f' in left: position 4. Right has no 'f's.\n\n'r' in left: position 6. Right has position 7 (r). So pair left 6 with right 7.\n\nSo that adds another pair.\n\nSo step 1 gives several pairs. Let's count how many.\n\nAssuming that:\n\nFor 'o' → 1 pair.\n\n'd' → 1 pair.\n\n'e' → 2 pairs (assuming len(left_e) is 2 and len(right_e) is 2).\n\n'r' → 1 pair.\n\nWhat about other colors?\n\nFor example, 'd' in left (position 2) and right (positions 0 and 2). So pair left 2 with right 0.\n\nThen, right 2 is still available. But for color 'd', the right has another 'd' (position 2). But during step 1, the code would process color 'd' once. So the left list for 'd' is [2], and right list is [0, 2]. So pair left 2 with right 0. The right 2 is not used.\n\nSo after step 1, the pairs are:\n\n(1,1), (2,0), (3,8), (8,9), (6,7), etc.\n\nBut perhaps the total is 5 pairs. Which matches the sample output's first case. So that's why the sample output is 5.\n\nSo the code would generate those pairs.\n\nThen, steps 2, 3, 4 would not add anything else, because there are no question marks in this case.\n\nThus, the code would produce the correct answer.\n\nAnother sample input is the third one, which outputs 0. That would be when there are no compatible pairs. For example, if l and r have no matching colors and no question marks.\n\nNow, considering the code steps, the next thing is to implement this in Python.\n\nBut for large n (1.5e5), creating lists for each step may be time-consuming. However, in practice, the code should be efficient enough.\n\nNow, the code steps in Python:\n\nRead n, then l and r.\n\nInitialize left_used and right_used as lists of booleans.\n\nThen, for each color in 'a' to 'z':\n\n   collect left_indices = [i for i in range(n) if l[i] == c and not left_used[i]]\n\n   collect right_indices = [j for j in range(n) if r[j] == c and not right_used[j]]\n\n   for i in range(min(len(left_indices), len(right_indices))):\n\n       pairs.append( (left_indices[i]+1, right_indices[i]+1) )\n\n       left_used[left_indices[i]] = True\n\n       right_used[right_indices[i]] = True\n\nBut wait, this approach is O(26 * n) time, which is acceptable for n=1.5e5.\n\nBut for each color, collecting the left and right indices would take O(n) time. So for 26 colors, it's O(26n) = acceptable.\n\nBut in practice, for each color, we can precompute the lists once. However, for the first step, we can process each color, and for each, check the current left and right indices not used.\n\nBut in Python, for each color, doing list comprehensions may be slow for n=1.5e5. However, given that 26*1.5e5 is manageable.\n\nBut perhaps there's a better way. For example, for each color, we can precompute the list of left indices and right indices, and then process them in the first step.\n\nBut even that would require O(n) time per color.\n\nAlternatively, during the first step, for each color, we can iterate through all left and right indices once. But that's probably not better.\n\nBut let's proceed with the code.\n\nOnce step 1 is done, proceed to step 2:\n\nCollect left_spec_remaining = [i for i in range(n) if not left_used[i] and l[i] != '?'].\n\nCollect right_q_remaining = [j for j in range(n) if not right_used[j] and r[j] == '?'].\n\nThen, k = min(len(left_spec_remaining), len(right_q_remaining)).\n\nfor i in range(k):\n\n    left_idx = left_spec_remaining[i]\n\n    right_idx = right_q_remaining[i]\n\n    pairs.append( (left_idx+1, right_idx+1) )\n\n    left_used[left_idx] = True\n\n    right_used[right_idx] = True\n\nThen step 3:\n\nCollect right_spec_remaining = [j for j in range(n) if not right_used[j] and r[j] != '?'].\n\nCollect left_q_remaining = [i for i in range(n) if not left_used[i] and l[i] == '?'].\n\nk = min(len(right_spec_remaining), len(left_q_remaining)).\n\nfor i in range(k):\n\n    left_idx = left_q_remaining[i]\n\n    right_idx = right_spec_remaining[i]\n\n    pairs.append( (left_idx+1, right_idx+1) )\n\n    left_used[left_idx] = True\n\n    right_used[right_idx] = True\n\nThen step 4:\n\nCollect left_q_remaining = [i for i in range(n) if not left_used[i] and l[i] == '?'].\n\nCollect right_q_remaining = [j for j in range(n) if not right_used[j] and r[j] == '?'].\n\nk = min(len(left_q_remaining), len(right_q_remaining)).\n\nfor i in range(k):\n\n    left_idx = left_q_remaining[i]\n\n    right_idx = right_q_remaining[i]\n\n    pairs.append( (left_idx+1, right_idx+1) )\n\n    left_used[left_idx] = True\n\n    right_used[right_idx] = True\n\nBut in code, the way to collect these lists is as described.\n\nNow, the code would generate the maximum number of pairs.\n\nNow, testing this approach with the sample input.\n\nAnother sample input is the second one, which outputs 5 pairs. But perhaps the code would handle that.\n\nNow, for the code:\n\nBut how to read the input? The original problem says that the input is given as:\n\nThe first line contains n.\n\nThe second line is l.\n\nThird line is r.\n\nBut the example input given in the problem shows that there are multiple test cases. Wait, looking back at the problem statement:\n\nWait, the user provided a sample input as:\n\n['10\\ncodeforces\\ndodivthree', '7\\nabaca?b\\nzabbbcc', '9\\nbambarbia\\nhellocode', '10\\ncode??????\\n??????test']\n\nBut that seems to be a list of four test cases. However, the problem says that the input is as per the first line being n, then l, then r. So perhaps the sample input is for multiple test cases, but the code is supposed to read one test case at a time.\n\nBut the problem says that the user's code should read input from stdin and print to stdout. So the code should read one test case per run.\n\nWait, the original problem says:\n\nInput:\n\nThe first line contains n.\n\nSecond line contains l.\n\nThird line contains r.\n\nSo the code should read three lines: n, l, r.\n\nBut the sample input provided by the user seems to have multiple test cases, but perhaps that was a mistake. So the code should read one test case.\n\nThus, the code should read n, then l, then r.\n\nNow, the code in Python:\n\nRead n from input.\n\nRead l from input.\n\nRead r from input.\n\nThen process as per the steps.\n\nNow, the code:\n\nImplementing the steps.\n\nBut in Python, for large n (like 1.5e5), using list comprehensions for each step may be acceptable.\n\nBut for the first step, looping through each color from 'a' to 'z' and for each, collect the left and right indices.\n\nBut perhaps for efficiency, we can precompute for each color, the list of left and right indices. But in practice, for each color, during the first step, we can process as follows.\n\nNow, the code:\n\nimport sys\n\nn = int(sys.stdin.readline())\nl = sys.stdin.readline().strip()\nr = sys.stdin.readline().strip()\n\nleft_used = [False] * n\nright_used = [False] * n\npairs = []\n\n# Step 1: Pair same color\nfor c in 'abcdefghijklmnopqrstuvwxyz':\n    left_list = []\n    right_list = []\n    for i in range(n):\n        if not left_used[i] and l[i] == c:\n            left_list.append(i)\n        if not right_used[i] and r[i] == c:\n            right_list.append(i)\n    # Pair as much as possible\n    m = min(len(left_list), len(right_list))\n    for i in range(m):\n        pairs.append( (left_list[i]+1, right_list[i]+1) )\n        left_used[left_list[i]] = True\n        right_used[right_list[i]] = True\n\n# Step 2: Left specific with right question\nleft_spec = []\nright_q = []\nfor i in range(n):\n    if not left_used[i] and l[i] != '?':\n        left_spec.append(i)\nfor j in range(n):\n    if not right_used[j] and r[j] == '?':\n        right_q.append(j)\nm = min(len(left_spec), len(right_q))\nfor i in range(m):\n    pairs.append( (left_spec[i]+1, right_q[i]+1) )\n    left_used[left_spec[i]] = True\n    right_used[right_q[i]] = True\n\n# Step 3: Right specific with left question\nright_spec = []\nleft_q = []\nfor j in range(n):\n    if not right_used[j] and r[j] != '?':\n        right_spec.append(j)\nfor i in range(n):\n    if not left_used[i] and l[i] == '?':\n        left_q.append(i)\nm = min(len(right_spec), len(left_q))\nfor i in range(m):\n    pairs.append( (left_q[i]+1, right_spec[i]+1) )\n    left_used[left_q[i]] = True\n    right_used[right_spec[i]] = True\n\n# Step 4: Left question with right question\nleft_q = []\nright_q = []\nfor i in range(n):\n    if not left_used[i] and l[i] == '?':\n        left_q.append(i)\nfor j in range(n):\n    if not right_used[j] and r[j] == '?':\n        right_q.append(j)\nm = min(len(left_q), len(right_q))\nfor i in range(m):\n    pairs.append( (left_q[i]+1, right_q[i]+1) )\n    left_used[left_q[i]] = True\n    right_used[right_q[i]] = True\n\nprint(len(pairs))\nfor a, b in pairs:\n    print(a, b)\n\nWait, but in step 1, for each color, the code loops through all i in 0..n-1, checking if not used and color is c. That would take O(n) per color. For 26 colors, that's O(26n) time. Which is acceptable for n=1.5e5.\n\nBut for n=1.5e5, 26*1.5e5 is 3.9e6 operations, which is manageable.\n\nHowever, in Python, this might be slow. But given that the problem is for competitive programming, perhaps this is acceptable.\n\nBut let's think of optimizing step 1. For example, precompute for each color, the list of left and right indices. But in code, for each color, the code is checking all indices again. Which is O(n) per color.\n\nBut perhaps for step 1, we can precompute for each color, the list of left and right indices once, and then process them.\n\nBut in the code above, during step 1, for each color, the code loops through all the indices and checks if they are not used and match the color. However, during this process, the left_used and right_used are being updated. So for each color, the code is processing the current state of the used arrays.\n\nBut in this code, during step 1, for each color, we are building left_list and right_list for that color, considering only the indices that are not yet used. Thus, the code is correct.\n\nBut in the code above, during step 1, the loops for left_list and right_list are done for each color. For example, for color 'a', the code loops through all n indices, checking for l[i] == 'a' and not used. Then, for color 'b', same thing.\n\nBut this is O(26n) time. Which is acceptable.\n\nBut perhaps there's a way to optimize this. For example, for each color, we can precompute the list of left and right indices, and then during step 1, process them in order, but that's not necessary.\n\nNow, let's test the code against the sample input.\n\nSample Input 1:\n\nn=10\n\nl = codeforces → 'c o d e f o r c e s'\n\nr = dodivthree → 'd o d i v t h r e e'\n\nThe code would process step 1 for each color.\n\nFor example, for 'c', left_list would be [0,7], right_list would be empty. So no pairs.\n\nFor 'o', left_list is [1,5], right_list is [1]. So pairs (1+1, 1+1) → (2, 2)? Wait, no. The code adds (left_list[i]+1, right_list[i]+1). So for i=0, left_list[0] is 0 (the first index of 'c' in l?), no, for 'o' in the code:\n\nWait, during step 1, for each color, the code loops through all i in range(n) and checks if l[i] == c and not used. So for the first color, say 'a', but in the first sample, the l is codeforces. So for 'o', the left_list would be the indices where l[i] is 'o' and not used. Initially, all are not used. So for 'o', left_list would be [1,5], right_list would be [1] (since r[1] is 'o').\n\nSo pairs (1+1, 1+1) → (2, 2) is added. Then, left_used[1] is marked as True, and right_used[1] is marked as True.\n\nThen, during the next processing of 'o', the code would not add any more pairs.\n\nThus, this code would pair the same colors.\n\nNow, after step 1, the code proceeds to step 2, which in this case would collect left_spec_remaining (those not used and l[i] != '?') and right_q_remaining (those not used and r[j] == '?'). But in this case, the r has no '?', so right_q_remaining is empty. Thus, step 2 adds nothing.\n\nSimilarly, step 3 and 4 add nothing. Thus, the code outputs the pairs collected during step 1, which is 5 pairs. Which matches the sample.\n\nAnother sample input is the third one, which outputs 0. For example, if l and r have no compatible pairs.\n\nNow, let's think of possible edge cases.\n\nEdge Case 1: All left and right are '?'. Then, the maximum pairs is n, and all pairs are (i, i) or something.\n\nEdge Case 2: All left are 'a', right are 'b'. Then, no pairs",
    "response": "\n\nTo solve this problem, we need to determine the maximum number of compatible pairs of boots where each pair consists of one left boot and one right boot. The compatibility rules are such that specific colors must match exactly, while a question mark ('?') can match any color, including another question mark.\n\n### Approach\n1. **Pair Specific Colors**: First, we pair left boots with specific colors (non '?') with right boots of the same specific color.\n2. **Pair Specific Left with Question Marks on Right**: After pairing specific colors, we use remaining left boots with specific colors to pair with right boots that have question marks.\n3. **Pair Specific Right with Question Marks on Left**: Similarly, use remaining right boots with specific colors to pair with left boots that have question marks.\n4. **Pair Remaining Question Marks**: Finally, pair any remaining question marks on both left and right boots.\n\nThis approach ensures that we maximize the number of compatible pairs by first handling the most restrictive cases (specific colors) and then using the flexible question marks to cover any remaining unmatched boots.\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    l = sys.stdin.readline().strip()\n    r = sys.stdin.readline().strip()\n\n    left_used = [False] * n\n    right_used = [False] * n\n    pairs = []\n\n    # Step 1: Pair same color\n    for c in 'abcdefghijklmnopqrstuvwxyz':\n        left_list = []\n        right_list = []\n        for i in range(n):\n            if not left_used[i] and l[i] == c:\n                left_list.append(i)\n            if not right_used[i] and r[i] == c:\n                right_list.append(i)\n        m = min(len(left_list), len(right_list))\n        for i in range(m):\n            pairs.append((left_list[i] + 1, right_list[i] + 1))\n            left_used[left_list[i]] = True\n            right_used[right_list[i]] = True\n\n    # Step 2: Left specific with right question\n    left_spec = []\n    right_q = []\n    for i in range(n):\n        if not left_used[i] and l[i] != '?':\n            left_spec.append(i)\n    for j in range(n):\n        if not right_used[j] and r[j] == '?':\n            right_q.append(j)\n    m = min(len(left_spec), len(right_q))\n    for i in range(m):\n        pairs.append((left_spec[i] + 1, right_q[i] + 1))\n        left_used[left_spec[i]] = True\n        right_used[right_q[i]] = True\n\n    # Step 3: Right specific with left question\n    right_spec = []\n    left_q = []\n    for j in range(n):\n        if not right_used[j] and r[j] != '?':\n            right_spec.append(j)\n    for i in range(n):\n        if not left_used[i] and l[i] == '?':\n            left_q.append(i)\n    m = min(len(right_spec), len(left_q))\n    for i in range(m):\n        pairs.append((left_q[i] + 1, right_spec[i] + 1))\n        left_used[left_q[i]] = True\n        right_used[right_spec[i]] = True\n\n    # Step 4: Left question with right question\n    left_q = []\n    right_q = []\n    for i in range(n):\n        if not left_used[i] and l[i] == '?':\n            left_q.append(i)\n    for j in range(n):\n        if not right_used[j] and r[j] == '?':\n            right_q.append(j)\n    m = min(len(left_q), len(right_q))\n    for i in range(m):\n        pairs.append((left_q[i] + 1, right_q[i] + 1))\n        left_used[left_q[i]] = True\n        right_used[right_q[i]] = True\n\n    print(len(pairs))\n    for a, b in pairs:\n        print(a, b)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read from standard input, which includes the number of boots and their respective color strings.\n2. **Tracking Usage**: Arrays `left_used` and `right_used` keep track of which boots have been paired.\n3. **Step-by-Step Pairing**:\n   - **Same Color Pairs**: Iterate through each letter of the alphabet and pair left and right boots of the same color.\n   - **Left Specific with Right Question Marks**: Use remaining specific color left boots to pair with right boots that have question marks.\n   - **Right Specific with Left Question Marks**: Use remaining specific color right boots to pair with left boots that have question marks.\n   - **Question Mark Pairs**: Pair any remaining question marks on both left and right boots.\n4. **Output**: Print the number of pairs followed by the indices of each pair.\n\nThis approach ensures that we maximize the number of compatible pairs efficiently, considering all possible combinations of specific colors and question marks.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    l = sys.stdin.readline().strip()\n    r = sys.stdin.readline().strip()\n\n    left_used = [False] * n\n    right_used = [False] * n\n    pairs = []\n\n    # Step 1: Pair same color\n    for c in 'abcdefghijklmnopqrstuvwxyz':\n        left_list = []\n        right_list = []\n        for i in range(n):\n            if not left_used[i] and l[i] == c:\n                left_list.append(i)\n            if not right_used[i] and r[i] == c:\n                right_list.append(i)\n        m = min(len(left_list), len(right_list))\n        for i in range(m):\n            pairs.append((left_list[i] + 1, right_list[i] + 1))\n            left_used[left_list[i]] = True\n            right_used[right_list[i]] = True\n\n    # Step 2: Left specific with right question\n    left_spec = []\n    right_q = []\n    for i in range(n):\n        if not left_used[i] and l[i] != '?':\n            left_spec.append(i)\n    for j in range(n):\n        if not right_used[j] and r[j] == '?':\n            right_q.append(j)\n    m = min(len(left_spec), len(right_q))\n    for i in range(m):\n        pairs.append((left_spec[i] + 1, right_q[i] + 1))\n        left_used[left_spec[i]] = True\n        right_used[right_q[i]] = True\n\n    # Step 3: Right specific with left question\n    right_spec = []\n    left_q = []\n    for j in range(n):\n        if not right_used[j] and r[j] != '?':\n            right_spec.append(j)\n    for i in range(n):\n        if not left_used[i] and l[i] == '?':\n            left_q.append(i)\n    m = min(len(right_spec), len(left_q))\n    for i in range(m):\n        pairs.append((left_q[i] + 1, right_spec[i] + 1))\n        left_used[left_q[i]] = True\n        right_used[right_spec[i]] = True\n\n    # Step 4: Left question with right question\n    left_q = []\n    right_q = []\n    for i in range(n):\n        if not left_used[i] and l[i] == '?':\n            left_q.append(i)\n    for j in range(n):\n        if not right_used[j] and r[j] == '?':\n            right_q.append(j)\n    m = min(len(left_q), len(right_q))\n    for i in range(m):\n        pairs.append((left_q[i] + 1, right_q[i] + 1))\n        left_used[left_q[i]] = True\n        right_used[right_q[i]] = True\n\n    print(len(pairs))\n    for a, b in pairs:\n        print(a, b)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 798,
        "completion_token_count": 1057,
        "thoughts_token_count": 8191
    }
}