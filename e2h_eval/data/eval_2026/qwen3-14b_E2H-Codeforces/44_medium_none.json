{
    "start": 1758310002.445556,
    "end": 1758310607.3186512,
    "start-formatted": "2025-09-20 04:26 KST",
    "end-formatted": "2025-09-20 04:36 KST",
    "gpu": 2,
    "pid": 44,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Polycarp's Practice\n\nPolycarp is practicing his problem solving skill. He has a list of $$$n$$$ problems with difficulties $$$a_1, a_2, \\dots, a_n$$$, respectively. His plan is to practice for exactly $$$k$$$ days. Each day he has to solve at least one problem from his list. Polycarp solves the problems in the order they are given in his list, he cannot skip any problem from his list. He has to solve all $$$n$$$ problems in exactly $$$k$$$ days.Thus, each day Polycarp solves a contiguous sequence of (consecutive) problems from the start of the list. He can't skip problems or solve them multiple times. As a result, in $$$k$$$ days he will solve all the $$$n$$$ problems.The profit of the $$$j$$$-th day of Polycarp's practice is the maximum among all the difficulties of problems Polycarp solves during the $$$j$$$-th day (i.e. if he solves problems with indices from $$$l$$$ to $$$r$$$ during a day, then the profit of the day is $$$\\max\\limits_{l \\le i \\le r}a_i$$$). The total profit of his practice is the sum of the profits over all $$$k$$$ days of his practice.You want to help Polycarp to get the maximum possible total profit over all valid ways to solve problems. Your task is to distribute all $$$n$$$ problems between $$$k$$$ days satisfying the conditions above in such a way, that the total profit is maximum.For example, if $$$n = 8, k = 3$$$ and $$$a = [5, 4, 2, 6, 5, 1, 9, 2]$$$, one of the possible distributions with maximum total profit is: $$$[5, 4, 2], [6, 5], [1, 9, 2]$$$. Here the total profit equals $$$5 + 6 + 9 = 20$$$.\n\n## Input\nThe first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\le k \\le n \\le 2000$$$) — the number of problems and the number of days, respectively.The second line of the input contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le 2000$$$) — difficulties of problems in Polycarp's list, in the order they are placed in the list (i.e. in the order Polycarp will solve them).\n\n## Output\nIn the first line of the output print the maximum possible total profit.In the second line print exactly $$$k$$$ positive integers $$$t_1, t_2, \\dots, t_k$$$ ($$$t_1 + t_2 + \\dots + t_k$$$ must equal $$$n$$$), where $$$t_j$$$ means the number of problems Polycarp will solve during the $$$j$$$-th day in order to achieve the maximum possible total profit of his practice.If there are many possible answers, you may print any of them.\n\n## Example\n### Input\n['8 3\\n5 4 2 6 5 1 9 2', '5 1\\n1 1 1 1 1', '4 2\\n1 2000 2000 2']\n\n### Output\n['20\\n3 2 3', '1\\n5', '4000\\n2 2']\n\n## Note\nThe first example is described in the problem statement.In the second example there is only one possible distribution.In the third example the best answer is to distribute problems in the following way: $$$[1, 2000], [2000, 2]$$$. The total profit of this distribution is $$$2000 + 2000 = 4000$$$.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\nOkay, I need to solve this programming problem. Let's read the problem carefully.\n\nSo, Polycarp has n problems arranged in order, and he needs to split them into exactly k days. Each day he solves a contiguous block of problems starting from the first. So, the first day's problems are from the start up to some index, then the next day starts where the previous left off, etc. The total profit is the sum of the maximum difficulty of each day's problems. My goal is to maximize this total profit.\n\nHmm. The challenge is to find the optimal way to split the array into k parts such that the sum of the maxima of each part is maximized.\n\nLet me think about dynamic programming here. Because for each position and number of days, we can track the maximum profit.\n\nLet's consider the DP approach. Let's define dp[i][j] as the maximum profit for the first i problems split into j days.\n\nThe base case would be dp[0][0] = 0, but maybe I need to adjust indices. Let's think:\n\nFor the first i problems and j days, how do we compute dp[i][j]?\n\nTo compute dp[i][j], we can consider that the j-th day could have some number of problems. Let's say the j-th day starts at position m+1 and ends at position i. Then, the previous j-1 days would have covered the first m problems. So for each possible m < i, we can take dp[m][j-1] + max(a[m+1..i]).\n\nBut since the constraints are n up to 2000, and k up to 2000, this might be O(n^2 *k) time. For n=2000 and k=2000, that would be 2000^3 which is 8e10 operations. That's way too slow.\n\nWait, but maybe there's a way to optimize this. Let's think about the constraints again. For example, if k is up to 2000, and n is up to 2000, then for each dp[i][j], we need to find the best m. However, for each j, the number of days is fixed, and perhaps we can find a way to compute the max efficiently.\n\nAlternatively, maybe we can find that for each j, the number of days is limited. For example, for j days, the minimum number of problems per day is 1, so the maximum i for j days is j. Wait, no. For example, when j=3, the first 3 days must have at least 1 problem each. So for i >= j. So for each j, the i must be >= j. So for j from 1 to k, and i from j to n.\n\nBut even with that, the DP approach would be O(n^2 *k) time. For n=2000, that's 2000^2 * 2000 = 8e10 operations. Which is way too big.\n\nBut wait, maybe there's a way to optimize the calculation of the max for ranges. For example, precompute the maximums for all possible ranges. But that would take O(n^2) space. For n=2000, that's 4 million entries. Which is manageable.\n\nBut even with that, the DP step would still be O(n^2 *k) time. Which is not feasible.\n\nWait, but maybe there's a smarter way. Let's think about the problem again. Since each day must consist of consecutive problems, and the splits are in order. So for the first i problems and j days, the last day must consist of some number of problems, say l, where l ranges from 1 to i - (j-1)*1 (since the previous j-1 days need to have at least one problem each). So for each i and j, we can look back to m = i - l, and find the max between m+1 and i.\n\nBut again, for each i and j, trying all possible l would be O(n^2 *k) time. Which is too slow.\n\nBut maybe there's a way to optimize this. Let's think about the transitions for the DP.\n\nLet me think about the recurrence relation again:\n\ndp[i][j] = max( dp[m][j-1] + max(a[m+1..i]) ) for all m from j-1 to i-1.\n\nBut how to compute this efficiently?\n\nIf we can compute the max for a[m+1..i] quickly, then for each i and j, we can iterate m from j-1 to i-1 and compute the max. However, even with precomputed ranges, this would take O(n^2 *k) time.\n\nBut maybe for each i and j, we can find the optimal m in a smarter way. Let's think about the structure of the problem.\n\nAnother thought: since each day must have at least one problem, the first day can be split into 1 to something, but the maximum for that day is the maximum of that range. For example, if we have to split into k days, then the first k-1 days must take at least one problem each, leaving the last day to take the rest.\n\nBut how does this help?\n\nAlternatively, considering that the maximum for a range is determined by the maximum element in that range. So when splitting into days, each day contributes its maximum. To maximize the sum, we want to have as many high elements as possible as maxima of their days.\n\nBut how to arrange that? For example, if there's a very high element, it's better to have it as a maximum of its own day. But if it's in a group with other elements, it will contribute once. So maybe the optimal strategy is to split the array into segments where each segment contains exactly one of the highest elements, but that's not necessarily true.\n\nBut perhaps the DP approach is the way to go. Let's try to find a way to optimize it.\n\nLet me think about the constraints again. n is up to 2000, and k is up to 2000. For the DP approach, if we can find a way to compute the transitions in O(1) or O(n) time, maybe we can make it work.\n\nAnother idea: for each j, the number of days, and for each i, the number of problems, we can compute the DP[i][j] based on the previous DP values.\n\nBut for the max part, perhaps we can compute it as we iterate m. Let's see. For a fixed i and j, when considering m from (j-1) to i-1, then for each m, the max from m+1 to i can be computed incrementally. For example, for m from i-1 down to j-1, the max from m+1 to i is the max between a[m+1] and the max from m+2 to i. Wait, but that's not helpful unless we can precompute the ranges.\n\nAlternatively, for each i, we can precompute the maximums for all ranges ending at i. For example, for each i, and for each m from 1 to i, we can have max[m][i]. But that's O(n^2) space, which is acceptable for n=2000 (since 2000*2000 is 4 million).\n\nYes. So let's precompute a 2D array max_range, where max_range[m][i] is the maximum value of a[m..i]. Then, for any m and i, the maximum of a[m..i] can be retrieved in O(1) time.\n\nOnce we have that, the DP transition can be done as follows:\n\ndp[i][j] = max( dp[m][j-1] + max_range[m+1][i] ), for m from j-1 to i-1.\n\nBut even with this, for each dp[i][j], we need to check O(i) possibilities for m. So the total time complexity would be O(n^2 *k). For n=2000 and k=2000, this would be O(2000^3) = 8e10 operations. Which is way too slow for Python, which can handle roughly 1e8 operations per second.\n\nSo this approach is not feasible. Therefore, we need to find a better way.\n\nWait, but perhaps the constraints are not that tight. Let's think: For example, if k is small. But the problem says that k can be up to n. So in the worst case, it's O(n^3) time.\n\nHmm. So perhaps there's a way to optimize the DP further.\n\nLet me think about the problem again. Let's think about the case where k=1. Then, the answer is the maximum of the entire array. For k=n, each day has exactly one problem, so the sum is the sum of all elements.\n\nWhat about when k is small? For example, when k=2. We need to split into two parts. The first part is from 1 to m, and the second part is from m+1 to n. The maximum for the first part is max(a[1..m]), and the second part is max(a[m+1..n]). So the total is sum of these two. To find the maximum, we can iterate m from 1 to n-1 and find the best split.\n\nBut how to generalize this for larger k?\n\nAnother thought: For the DP approach, perhaps the transitions can be optimized using certain properties. For example, when considering the j-th day, the optimal split for dp[i][j] may have some monotonicity or other properties that can be exploited.\n\nAlternatively, perhaps we can use a different approach. Let's think about the problem as selecting k-1 split points in the array. The split points must divide the array into exactly k parts. Each split point is between two elements. The sum is the sum of the maxima of each part.\n\nBut how to choose the split points to maximize the sum.\n\nBut even with that, it's unclear how to proceed.\n\nAnother idea: the maximum sum can be achieved by ensuring that each split includes the largest possible elements as maxima. For example, the largest element must be in a segment by itself, or in a segment where it's the maximum. But if you have multiple large elements, perhaps you want to split them into separate days.\n\nBut how to model that.\n\nAlternatively, think of it as the problem is similar to the problem of partitioning the array into k segments, and for each segment, take its maximum, and maximize the sum.\n\nThis seems similar to the problem of partitioning an array into k parts to maximize the sum of some function of each part. For such problems, dynamic programming is a standard approach, but the key is to find a way to compute the transitions efficiently.\n\nSo going back to the DP approach. Let's think of the DP[i][j] as before. But for each i and j, perhaps we can find a way to compute it faster than O(n) per state.\n\nLet me think about the recurrence again. For dp[i][j], we have:\n\ndp[i][j] = max_{m} ( dp[m][j-1] + max(a[m+1..i]) )\n\nNow, the question is, for a given i and j, how to compute this maximum efficiently.\n\nLet me consider that when building the DP table for j-th day, we can process i in order. For each i, and for each possible m (from j-1 to i-1), we need to compute the max from m+1 to i.\n\nBut if we can compute this max efficiently as we increase i, perhaps we can find a way.\n\nSuppose for each j, and for each i, we can keep track of the current maximum as we iterate m from i-1 down to j-1. Wait, for example, for a fixed i and j, when considering m from i-1 down to j-1, then for each m, the range [m+1, i] is [m+1, i]. As m decreases, the range [m+1, i] becomes longer. So the maximum for [m+1, i] can be maintained by keeping track of the current maximum as we move m from right to left.\n\nSo for each i and j, when computing dp[i][j], we can iterate m from i-1 down to j-1, and for each step, track the current maximum of a[m+1..i].\n\nLet me think:\n\nInitialize current_max = a[i], and for m = i-1 down to j-1:\n\ncurrent_max = max(current_max, a[m+1])\n\nthen dp[i][j] = max( dp[m][j-1] + current_max )\n\nWait, but m is varying. Let's see:\n\nFor example, when i is fixed, and m is varying from (i-1) down to (j-1), then for each m, the range is from m+1 to i. So when m decreases by 1, the range starts at m+1, which is one position earlier. So for m = i-1, the range is [i], which is just a[i]. For m = i-2, the range is [i-1, i], etc.\n\nSo as m decreases, the range expands to the left. So the current_max can be updated as the maximum between the previous current_max and a[m+1].\n\nSo for each i and j, we can compute the max_range on the fly while iterating m from i-1 down to j-1.\n\nThis way, for each i and j, the computation of the max_range is O(i) steps, but the cost is amortized.\n\nSo the overall time complexity would be O(n^2 *k), but with a lower constant factor.\n\nBut with n=2000 and k=2000, this is still O(2000^3) = 8e10 operations. Which is way too slow for Python.\n\nBut maybe there's a way to optimize further. Let's think about the constraints again. For example, when j is larger than i, it's impossible. So for each j, the possible i starts from j (since each day has at least one problem). So for j from 1 to k, and i from j to n.\n\nBut even with that, for k=2000, and n=2000, the total number of states is O(kn) = 2000*2000 = 4e6. And for each state, the inner loop is O(n) steps. So 4e6 * 2000 = 8e9 steps. Which is way too slow.\n\nSo this suggests that the DP approach is not feasible for the given constraints.\n\nHmm. So what's another approach?\n\nLet me think about the problem differently. What if we note that for the optimal solution, each split must include the maximum elements in their respective segments. For example, if there's a peak in the array, it's better to split before and after that peak. But I'm not sure how to formalize this.\n\nAnother observation: the maximum total profit is the sum of the maximum elements of each segment. Since each segment must contain at least one element, and the segments are contiguous and cover the entire array.\n\nNow, the maximum sum would be achieved by having as many high elements as possible as the maximums of their segments. For example, if there are multiple high elements, we can split them into separate segments.\n\nBut how to do this optimally?\n\nLet me think of the problem as choosing k-1 split points. The splits must be such that each segment has at least one element. The sum is the sum of maxima of each segment.\n\nBut how to choose the splits to maximize this sum.\n\nAnother idea: The problem resembles the problem of finding the maximum sum when splitting the array into k parts, where each part contributes its maximum. This is similar to the problem of splitting into k parts to maximize the sum of minima, but here it's maxima.\n\nIn the problem of splitting into k parts to maximize the sum of minima, a greedy approach might be possible, but for maxima, perhaps not.\n\nAlternatively, perhaps for the maximum sum, the optimal way is to split the array into segments such that each segment contains exactly one of the top k elements. For example, if the array has elements sorted in decreasing order, then the best way is to split the array into the first k elements as individual segments (each being the maximum of their segment), and the rest as one segment. But this is just a hypothesis.\n\nBut how to formalize this?\n\nLet me take the example from the problem statement. The array is [5,4,2,6,5,1,9,2], and k=3. The top 3 elements are 9, 6, 5. The optimal split is [5,4,2], [6,5], [1,9,2], which gives maxima 5, 6, 9. So the three maxima are 5, 6, 9. However, the top three elements are 9,6,5. So that matches. Another example: if the array is [1,2000,2000,2], and k=2. The top two elements are 2000 and 2000. The optimal split is [1,2000], [2000,2], giving sum 2000 + 2000 = 4000. Which is indeed the sum of the two top elements.\n\nSo perhaps the optimal strategy is to select the k largest elements in the array and ensure that each is the maximum of its own segment. However, this may not always be possible if the elements are not in order.\n\nFor example, suppose the array is [3, 1, 2, 4], and k=2. The top two elements are 4 and 3. How to split? If we split into [3,1,2], [4], sum is 3 +4 =7. Alternatively, [3,1], [2,4] gives 3 +4=7. Or [3], [1,2,4] gives 3 +4=7. All options give same sum. So the sum is indeed the sum of the top two elements.\n\nAnother example: array [5, 3, 4], k=2. The top two elements are 5 and 4. Splitting into [5], [3,4] gives sum 5 +4=9. Splitting into [5,3], [4] gives 5+4=9. So again, the sum is the sum of the top two elements.\n\nBut what if the array is [5, 4, 3, 2, 1], and k=3. The top three elements are 5,4,3. How to split? The best way is to split into [5], [4], [3,2,1], sum is 5+4+3=12. Alternatively, any split that puts each of the top three elements in their own segments.\n\nSo this suggests that the maximum possible total profit is the sum of the k largest elements in the array. However, this is only possible if those k elements can be separated into their own segments. But how?\n\nBut this isn't always possible. For example, consider the array [2, 1, 3], and k=2. The two largest elements are 3 and 2. To split into two segments, the first segment must be [2,1], and the second [3], which gives sum 2+3=5. Or [2], [1,3], which gives 2+3=5. But if the array were [3, 1, 2], and k=2. Then the two largest elements are 3 and 2. Splitting into [3], [1,2] gives sum 3+2=5. Which is indeed the sum of the two largest elements.\n\nBut what if the array is [5, 3, 4], and k=2. The two largest elements are 5 and 4. Splitting into [5], [3,4] gives sum 5+4=9. Which is correct. But if the array is [5, 4, 3, 2, 1], and k=3. The three largest are 5,4,3. Split into [5], [4], [3,2,1], sum is 5+4+3=12. Which is correct.\n\nBut here's a case where this might not hold. Suppose the array is [1, 3, 2, 4], and k=2. The two largest elements are 4 and 3. How to split? One option is [1,3,2], [4] sum is 3+4=7. Another option is [1,3], [2,4] sum is 3+4=7. Or [1], [3,2,4] sum 1+4=5. So the maximum is 7, which is indeed the sum of the two largest elements (3 and 4). So it holds.\n\nAnother test case: array [1, 2, 3, 4, 5], k=3. The three largest elements are 5,4,3. Split into [1,2,3], [4], [5] sum 3+4+5=12. Or [1,2], [3,4], [5] sum 2+4+5=11. So the first split is better. So the maximum is indeed sum of the three largest elements.\n\nBut what about when there are duplicates? Like array [5,5,5], k=2. The sum of the two largest elements is 5+5=10. Which is achieved by splitting into [5], [5,5], sum 5+5=10. Or [5,5], [5], sum 5+5=10. So yes.\n\nSo perhaps the maximum possible total profit is the sum of the k largest elements in the array. But how to verify this?\n\nBut wait, what if there's a case where splitting in a way that includes more than one of the top elements in a segment would allow for higher sum? For example, suppose the array is [5, 1, 5], and k=2. The two largest elements are 5 and 5. The optimal split is [5,1], [5], sum 5+5=10. Or [5], [1,5], sum 5+5=10. Which is the sum of the two largest elements. But if we had to split into [5,1,5], which is not allowed since k=2. So it works.\n\nAnother example: array [5, 3, 5, 2], k=2. The two largest elements are 5 and 5. Splitting into [5,3,5], [2], sum is 5 +2=7. But that's worse than splitting into [5], [3,5,2], sum is 5 +5=10. Which is the sum of the two largest elements.\n\nSo in all these examples, the maximum total profit is the sum of the k largest elements. But why?\n\nBecause each segment contributes its maximum. So, if we can arrange that each of the k largest elements is the maximum of its own segment, then the total sum would be the sum of those k elements. And since those are the largest possible elements, this is the maximum possible sum.\n\nBut how to arrange that?\n\nWell, the segments must be chosen such that each of the k largest elements is in a separate segment. However, the arrangement of the array may not allow that. For example, if the array is [5, 6, 5], and k=2. The two largest elements are 6 and 5. To split into two segments, we can have [5,6], [5], which gives maxima 6 and 5. Sum is 11. Or [5], [6,5], sum 5+6=11. Which is the sum of the two largest elements. So it works.\n\nBut if the array is [5, 4, 6, 5], and k=2. The two largest elements are 6 and 5. But splitting into [5,4,6], [5] gives sum 6+5=11. Or [5,4], [6,5], sum 5+6=11. Which is the sum of the two largest elements.\n\nAnother example: array [5, 6, 5, 6], k=2. The two largest are 6 and 6. Split into [5,6], [5,6], sum 6+6=12. Which is the sum of the two largest elements.\n\nSo in all these cases, the maximum sum is the sum of the k largest elements. So this suggests that the problem reduces to selecting the k largest elements and ensuring that each is the maximum of its segment. But how to do that?\n\nBut how to split the array into k segments such that each segment contains exactly one of the k largest elements. Because if that is possible, then the sum will be the sum of the k largest elements.\n\nBut how to ensure that? Well, the k largest elements must be in distinct segments. However, if they are not already in distinct segments, then we need to split the array in such a way.\n\nBut the problem allows us to split the array into any segments as long as they are contiguous and cover the entire array.\n\nSo the question now becomes: can we always split the array into k segments such that each segment contains exactly one of the k largest elements? If yes, then the answer is to sum the k largest elements.\n\nBut how to prove that?\n\nLet me think. Suppose that the array has elements with values sorted in non-decreasing order. Let's say the k largest elements are the last k elements. Then, we can split the array into the first (n-k) elements as one segment, and then each of the remaining k elements as individual segments. But since the first segment's maximum is the maximum of the first n-k elements, which is less than or equal to the k-th largest element. However, this would not include the k largest elements in their own segments. Wait, no. If the k largest elements are the last k elements, then splitting into the first n-k elements as one segment and then k segments of 1 element each (the last k elements) would ensure that each of the last k elements is in its own segment. Thus, the sum would be the sum of the k largest elements.\n\nBut if the array is not sorted, then the k largest elements may be scattered. But as long as we can split the array so that each of the k largest elements is in a separate segment, then the sum would be their sum.\n\nBut how to ensure that? Well, since the array is processed in order, the segments are contiguous. So for example, if the k largest elements are in positions p_1, p_2, ..., p_k, where p_1 < p_2 < ... < p_k, then we can split the array into segments as follows: first segment up to p_1, then from p_1+1 to p_2, then from p_2+1 to p_3, etc. But wait, this would require that each segment contains exactly one of the k largest elements, but also that the other elements in the segment do not have a larger value than that element. However, since the elements are the k largest, any other element in the array is less than or equal to them. So if we split the array such that each of the k largest elements is in a segment by itself, then the maximum of each segment is that element. However, if they are not in order, then this may not be possible.\n\nWait, but how can we split the array into k segments such that each segment contains exactly one of the k largest elements?\n\nLet me think of an example. Suppose the array is [6, 5, 7, 4, 8], and k=3. The three largest elements are 8,7,6. Their positions are 5, 3, 1. Now, how to split into three segments. The first segment must contain 6 (position 1), then the second segment must contain 7 (position 3), and the third segment must contain 8 (position 5). However, since the segments are contiguous, the first segment can be [6], then the second segment must start at position 2. But the second segment would need to include position 3 (the 7) and end before position 5. So the second segment could be [5,7], then the third segment is [4,8]. The maxima would be 6,7,8. Sum is 21. Which is the sum of the three largest elements.\n\nBut in this case, the segments are [6], [5,7], [4,8]. So the segments are contiguous and cover the entire array.\n\nAnother example: array [7, 6, 5, 8, 4], k=3. The three largest elements are 8,7,6. Their positions are 4, 1, 2. How to split into three segments. One possible split is [7], [6,5,8], [4]. Maxima are 7, 8, 4. Sum is 19. But the sum of the three largest elements is 8+7+6=21. But in this split, the third segment's maximum is 4, which is not one of the three largest. So this is not good.\n\nAh, but there must be a better way. How?\n\nWe need to split into three segments such that each of the three largest elements is in its own segment. Let's see:\n\nThe first segment must include 7 (position 1), the second segment must include 6 (position 2), and the third must include 8 (position 4). But since the segments are contiguous, the first segment can be [7], the second segment [6,5], and the third [8,4]. Then the maxima are 7,6,8. Sum is 21. Which is correct.\n\nYes! So the split is [7], [6,5], [8,4]. So even though the 6 is in the second segment, which has a maximum of 6, which is one of the three largest elements. Thus, the sum is correct.\n\nSo the idea is that for each of the k largest elements, we need to have them in their own segments. But how to ensure that during the splitting.\n\nBut how to find this split programmatically?\n\nPerhaps the approach is to select the k largest elements, and then split the array such that each of them is in its own segment. However, the problem is to find the split that allows this.\n\nBut how to implement this?\n\nLet me think. Suppose we sort the array's elements in descending order, take the first k elements. Then, find their positions in the original array. Then, we need to split the array into k segments such that each segment contains exactly one of these elements, and they are ordered according to their positions.\n\nFor example, the positions of the k largest elements are p_1 < p_2 < ... < p_k. Then, the first segment is from 1 to p_1, the second segment from p_1+1 to p_2, ..., the k-th segment from p_{k-1}+1 to p_k. Wait, but that would only work if the elements are in increasing order of positions. For example, if the k largest elements are at positions p_1, p_2, ..., p_k in increasing order, then splitting between them would ensure that each segment contains exactly one of the largest elements.\n\nBut in this case, the first segment would be from 1 to p_1, which contains the first largest element. The second segment from p_1+1 to p_2, which contains the second largest element, etc. However, the problem is that between p_1 and p_2, there may be elements that are not among the k largest. But since each segment's maximum is the element at p_i, which is one of the k largest, and all other elements in the segment are smaller than or equal to it.\n\nBut wait, what if there is an element larger than the p_i in the segment? For example, suppose the array is [5, 3, 6, 2, 7], and k=2. The two largest elements are 7 and 6. Their positions are 5 and 3. So p_1 is 3 (6), p_2 is 5 (7). So the first segment would be from 1 to 3, which is [5,3,6]. The maximum is 6. The second segment is from 4 to 5, which is [2,7]. The maximum is 7. Sum is 6+7=13. Which is the sum of the two largest elements. Correct.\n\nAnother example: array [6, 5, 7, 4, 8], k=3. The three largest are 8,7,6. Positions are 5,3,1. So sorted in increasing order, the positions are 1,3,5. So the first segment is 1 to 1 (just [6]), the second segment from 2 to 3 ([5,7]), the third segment from 4 to 5 ([4,8]). Sum is 6+7+8=21.\n\nYes. So the approach seems to work.\n\nThus, the plan is:\n\n- Find the k largest elements in the array. Let's call them the 'top k' elements.\n- Find their positions in the array. Sort these positions in increasing order.\n- Split the array into k segments, where the i-th segment starts at the end of the (i-1)-th segment plus one, and ends at the position of the i-th top element. Then, the rest of the array after the last top element can be added to the last segment.\n\nWait, but what if there are duplicate elements? For example, if the array is [5,5,5], and k=2. The two largest elements are both 5. Their positions are 0,1,2. Choosing any two of them. For example, positions 0 and 2. Then the segments are [5], [5,5]. Which gives sum 5+5=10. Which is correct.\n\nSo the algorithm would be:\n\n1. Find the k largest elements in the array. Let's collect their positions. However, if there are duplicates, we need to choose exactly k positions. For example, if the array has multiple elements with the same value as the k-th largest, we need to select enough of them to reach k elements.\n\nBut how to do this?\n\nLet me think. First, sort the array in descending order. Take the first k elements. These are the k largest elements. Then, collect all their positions in the original array, making sure that if there are duplicates, we select enough of them.\n\nBut how to collect their positions?\n\nFor example, suppose the array is [5,5,5], and k=2. The two largest elements are 5 and 5. So we need to collect two positions. Any two positions would work.\n\nBut how to choose which ones to take? For the purpose of splitting, we need to select positions that are as early as possible so that we can split the array into segments that include them.\n\nBut perhaps the best way is to collect all the positions of the elements that are in the top k elements, and then select the earliest k positions.\n\nWait, but how to find which elements are in the top k?\n\nAlternatively, we can collect all elements and their positions, sort them in descending order of value, and then pick the first k elements. For example, for the array [5,5,5], the first k elements (k=2) would be the first two 5s. Their positions are 0 and 1. Then, the split would be [5], [5,5], which is correct.\n\nBut for the array [5,4,5], k=2. The top two elements are 5 and 5. Their positions are 0 and 2. So the split would be [5], [4,5], sum 5+5=10.\n\nBut what if there are more than k elements with the same value as the k-th largest?\n\nFor example, array [5,5,5,5], k=2. The top two elements are 5 and 5. Their positions are 0,1,2,3. We need to choose two positions. To split the array into two segments, we can choose positions 0 and 2. So the segments are [5], [5,5,5]. Sum is 5+5=10.\n\nBut how to choose which positions to take?\n\nThe key is that we need to choose exactly k positions, and the positions should be in increasing order. Once we have these positions, we can split the array into segments as described.\n\nSo the steps for the algorithm are:\n\n1. Collect all elements and their indices.\n\n2. Sort them in descending order of value, breaking ties by index (so that in case of equal values, earlier indices come first).\n\n3. Take the first k elements from this sorted list. These are the elements that will be the maxima of each segment.\n\n4. Collect the indices of these elements, sort them in increasing order. Let's call this list pos = [p1, p2, ..., pk], where p1 < p2 < ... < pk.\n\n5. Now, split the array into k segments:\n\n   - The first segment is from 0 to p1 (inclusive).\n\n   - The second segment is from p1+1 to p2 (inclusive).\n\n   - ...\n\n   - The k-th segment is from p_{k-1}+1 to pk (inclusive).\n\nBut wait, the first segment starts at 0 (assuming 0-based indexing), and ends at p",
    "response": "To solve this problem, we need to distribute `n` problems into exactly `k` days such that the total profit, defined as the sum of the maximum difficulties of each day's problems, is maximized. The key insight is to ensure that each of the top `k` difficulties in the array is the maximum of its respective segment.\n\n### Approach\n1. **Identify Top k Elements**: The optimal strategy involves selecting the top `k` elements from the array. These elements will be the maxima of their respective segments.\n2. **Determine Positions**: Collect the positions of these top `k` elements in the original array. If there are duplicate values, prioritize earlier positions to ensure valid segment splits.\n3. **Segment the Array**: Using the sorted positions of the top `k` elements, split the array into `k` segments such that each segment contains exactly one of these top elements, ensuring each segment's maximum is one of these top elements.\n\n### Solution Code\n```python\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    k = int(input[idx])\n    idx += 1\n    a = list(map(int, input[idx:idx + n]))\n    \n    # Create a list of (value, index) pairs\n    elements = []\n    for i in range(n):\n        elements.append((-a[i], i))  # Use negative for descending sort\n    \n    # Sort by value (descending), then by index (ascending)\n    elements.sort()\n    \n    # Take the first k elements (since we used negative, the smallest -a[i] is the largest a[i])\n    selected = []\n    for i in range(k):\n        selected.append(elements[i][1])\n    \n    # Sort the selected indices in increasing order\n    selected.sort()\n    \n    # Now, create the segments\n    result = []\n    prev = -1\n    for pos in selected:\n        if prev == -1:\n            start = 0\n        else:\n            start = prev + 1\n        end = pos\n        length = end - start + 1\n        result.append(length)\n        prev = pos\n    \n    # The last segment might need to include remaining elements\n    if len(result) < k:\n        # This case should not happen since we have exactly k positions\n        pass\n    \n    # Check if the last segment ends at n-1\n    if prev < n - 1:\n        # Add the remaining elements to the last segment\n        last_length = result[-1]\n        result[-1] = (prev + 1) - (selected[-1]) + 1 + (n - 1 - (prev + 1) + 1)\n        # Wait, no. Let's recalculate:\n        # The last segment starts at prev + 1 and ends at n-1\n        start_last = prev + 1\n        end_last = n - 1\n        length_last = end_last - start_last + 1\n        result[-1] += length_last\n    \n    # However, the above logic is incorrect. Let's recompute properly.\n    # Actually, the segments are determined by the selected positions.\n    # The first segment is from 0 to selected[0]\n    # Second from selected[0]+1 to selected[1], etc.\n    # The last segment is from selected[k-2]+1 to selected[k-1]\n    # But after that, there may be elements from selected[k-1]+1 to end?\n    # No, because the selected positions are sorted, and the last position is selected[-1]\n    # So the last segment is from selected[k-2]+1 to selected[k-1]\n    # But what about elements after selected[k-1]?\n    # They must be included in the last segment.\n    # So the correct way is:\n    # The first k-1 segments are between the selected positions\n    # The last segment is from selected[k-2]+1 to the end of the array\n    # Wait, no. Let me think again.\n    # For example, selected = [p1, p2, ..., pk]\n    # Then the segments are:\n    # [0..p1], [p1+1..p2], ..., [p_{k-1}+1..pk], and then any elements after pk?\n    # No, because pk is the last selected position. The array has n elements. So the last segment is from p_{k-1}+1 to pk, but if pk is not the last element, then we need to include the rest?\n    # No, because the selected positions are chosen from the array. For example, if the array is of size n, and the selected positions include the last element, then all elements are covered.\n    # However, if the last selected position is before the end of the array, then the last segment should include from selected[k-1] to the end.\n    # Wait, no. Because the way we split is:\n    # The first segment is from 0 to p1\n    # The second segment is from p1+1 to p2\n    # ...\n    # The k-th segment is from p_{k-1}+1 to p_k\n    # But if p_k is not the last element of the array, then the last segment would end at p_k, and the elements after p_k would be left out. Which is not allowed.\n    # Therefore, the selection of the positions must include the last element of the array if necessary.\n    # Wait, but how can that be ensured? Because the top k elements may not include the last element. However, the problem requires that all n elements are covered.\n\n    # The mistake here is in the initial selection of the top k elements. We need to ensure that the selected positions cover the entire array. However, the approach of selecting the top k elements and splitting them as described ensures that all elements are covered.\n\n    # Let me re-express the correct way to generate the segments:\n    # The selected positions are sorted as p_1 < p_2 < ... < p_k\n    # Then the segments are:\n    # 1st segment: 0 to p_1\n    # 2nd segment: p_1 + 1 to p_2\n    # ...\n    # k-th segment: p_{k-1} + 1 to p_k\n    # But this only covers up to p_k. What about elements after p_k?\n\n    # This is a critical error in the previous approach. To fix this, we must ensure that the last segment includes all elements from p_{k-1}+1 to the end of the array. However, this is not possible if the selected positions do not include the last element. Therefore, the initial approach is flawed.\n\n    # Correct approach: the selected positions must be chosen such that the last selected position is the last element of the array. Otherwise, the last segment will miss some elements. How to ensure this?\n\n    # Actually, the selected positions are the positions of the top k elements. The last element of the array may or may not be among them. However, when generating the segments, the last segment must include all elements from the end of the previous segment to the end of the array.\n\n    # Therefore, the correct way to generate the segments is:\n\n    # The first k-1 segments are between the selected positions, and the last segment includes from the end of the (k-1)-th segment to the end of the array.\n\n    # So let's adjust the code:\n\n    # After sorting selected positions in increasing order, we have p_1, p_2, ..., p_k\n    # The first segment is from 0 to p_1\n    # The second segment is from p_1 + 1 to p_2\n    # ...\n    # The (k-1)-th segment is from p_{k-2} + 1 to p_{k-1}\n    # The k-th segment is from p_{k-1} + 1 to n-1\n\n    # This ensures that all elements are covered.\n\n    # So, let's recompute the result accordingly.\n\n    result = []\n    prev = -1\n    for i in range(k):\n        pos = selected[i]\n        if i == 0:\n            start = 0\n        else:\n            start = prev + 1\n        end = pos\n        length = end - start + 1\n        result.append(length)\n        prev = pos\n\n    # Now handle the last segment\n    if prev < n - 1:\n        start_last = prev + 1\n        end_last = n - 1\n        length_last = end_last - start_last + 1\n        result[-1] += length_last\n\n    # Now print the total profit which is sum of the selected elements\n    total_profit = sum(a[pos] for pos in selected)\n    print(total_profit)\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into the number of problems `n`, the number of days `k`, and the list of problem difficulties.\n2. **Selecting Top k Elements**: The elements are sorted in descending order along with their indices. The top `k` elements are selected based on their values.\n3. **Generating Segments**: The selected positions are sorted to ensure contiguous segments. Each segment is formed by starting just after the end of the previous segment and ending at the next selected position. The last segment includes any remaining elements after the last selected position.\n4. **Output**: The total profit is the sum of the top `k` elements, and the segments are printed as required.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    k = int(input[idx])\n    idx += 1\n    a = list(map(int, input[idx:idx + n]))\n    \n    # Create a list of (value, index) pairs\n    elements = []\n    for i in range(n):\n        elements.append((-a[i], i))  # Use negative for descending sort\n    \n    # Sort by value (descending), then by index (ascending)\n    elements.sort()\n    \n    # Take the first k elements (since we used negative, the smallest -a[i] is the largest a[i])\n    selected = []\n    for i in range(k):\n        selected.append(elements[i][1])\n    \n    # Sort the selected indices in increasing order\n    selected.sort()\n    \n    # Now, create the segments\n    result = []\n    prev = -1\n    for pos in selected:\n        if prev == -1:\n            start = 0\n        else:\n            start = prev + 1\n        end = pos\n        length = end - start + 1\n        result.append(length)\n        prev = pos\n    \n    # The last segment might need to include remaining elements\n    if len(result) < k:\n        # This case should not happen since we have exactly k positions\n        pass\n    \n    # Check if the last segment ends at n-1\n    if prev < n - 1:\n        # Add the remaining elements to the last segment\n        last_length = result[-1]\n        result[-1] = (prev + 1) - (selected[-1]) + 1 + (n - 1 - (prev + 1) + 1)\n        # Wait, no. Let's recalculate:\n        # The last segment starts at prev + 1 and ends at n-1\n        start_last = prev + 1\n        end_last = n - 1\n        length_last = end_last - start_last + 1\n        result[-1] += length_last\n    \n    # However, the above logic is incorrect. Let's recompute properly.\n    # Actually, the segments are determined by the selected positions.\n    # The first segment is from 0 to selected[0]\n    # Second from selected[0]+1 to selected[1], etc.\n    # The last segment is from selected[k-2]+1 to selected[k-1]\n    # But after that, there may be elements from selected[k-1]+1 to end?\n    # No, because the selected positions are sorted, and the last position is selected[-1]\n    # So the last segment is from selected[k-2]+1 to selected[k-1]\n    # But what about elements after selected[k-1]?\n    # They must be included in the last segment.\n    # So the correct way is:\n    # The first k-1 segments are between the selected positions\n    # The last segment is from selected[k-2]+1 to the end of the array\n    # Wait, no. Let me think again.\n    # For example, selected = [p1, p2, ..., pk]\n    # Then the segments are:\n    # [0..p1], [p1+1..p2], ..., [p_{k-1}+1..pk], and then any elements after pk?\n    # No, because pk is the last selected position. The array has n elements. So the last segment is from p_{k-1}+1 to pk, but if pk is not the last element, then we need to include the rest?\n    # No, because the selected positions are chosen from the array. For example, if the array is of size n, and the selected positions include the last element, then all elements are covered.\n    # However, if the last selected position is before the end of the array, then the last segment should include from selected[k-1] to the end.\n    # Wait, no. Because the way we split is:\n    # The first segment is from 0 to p1\n    # The second segment is from p1+1 to p2\n    # ...\n    # The k-th segment is from p_{k-1}+1 to p_k\n    # But if p_k is not the last element of the array, then the last segment would end at p_k, and the elements after p_k would be left out. Which is not allowed.\n    # Therefore, the selection of the positions must include the last element of the array if necessary.\n    # Wait, but how can that be ensured? Because the top k elements may not include the last element. However, the problem requires that all n elements are covered.\n\n    # The mistake here is in the initial selection of the top k elements. We need to ensure that the selected positions cover the entire array. However, the approach of selecting the top k elements and splitting them as described ensures that all elements are covered.\n\n    # Let me re-express the correct way to generate the segments:\n    # The selected positions are sorted as p_1 < p_2 < ... < p_k\n    # Then the segments are:\n    # 1st segment: 0 to p_1\n    # 2nd segment: p_1 + 1 to p_2\n    # ...\n    # k-th segment: p_{k-1} + 1 to p_k\n    # But this only covers up to p_k. What about elements after p_k?\n\n    # This is a critical error in the previous approach. To fix this, we must ensure that the last segment includes all elements from p_{k-1}+1 to the end of the array. However, this is not possible if the selected positions do not include the last element. Therefore, the initial approach is flawed.\n\n    # Correct approach: the selected positions must be chosen such that the last selected position is the last element of the array. Otherwise, the last segment will miss some elements. How to ensure this?\n\n    # Actually, the selected positions are the positions of the top k elements. The last element of the array may or may not be among them. However, when generating the segments, the last segment must include all elements from the end of the previous segment to the end of the array.\n\n    # Therefore, the correct way to generate the segments is:\n\n    # The first k-1 segments are between the selected positions, and the last segment includes from the end of the (k-1)-th segment to the end of the array.\n\n    # So let's adjust the code:\n\n    # After sorting selected positions in increasing order, we have p_1, p_2, ..., p_k\n    # The first segment is from 0 to p_1\n    # The second segment is from p_1 + 1 to p_2\n    # ...\n    # The (k-1)-th segment is from p_{k-2} + 1 to p_{k-1}\n    # The k-th segment is from p_{k-1} + 1 to n-1\n\n    # This ensures that all elements are covered.\n\n    # So, let's recompute the result accordingly.\n\n    result = []\n    prev = -1\n    for i in range(k):\n        pos = selected[i]\n        if i == 0:\n            start = 0\n        else:\n            start = prev + 1\n        end = pos\n        length = end - start + 1\n        result.append(length)\n        prev = pos\n\n    # Now handle the last segment\n    if prev < n - 1:\n        start_last = prev + 1\n        end_last = n - 1\n        length_last = end_last - start_last + 1\n        result[-1] += length_last\n\n    # Now print the total profit which is sum of the selected elements\n    total_profit = sum(a[pos] for pos in selected)\n    print(total_profit)\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 927,
        "completion_token_count": 2063,
        "thoughts_token_count": 8192
    }
}