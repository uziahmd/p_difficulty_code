{
    "start": 1758339654.7414606,
    "end": 1758339858.7239401,
    "start-formatted": "2025-09-20 12:40 KST",
    "end-formatted": "2025-09-20 12:44 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\nOkay, let's see. I need to solve this problem where I have to determine if there's a way to assign numbers to each lawn such that for every given edge (road), the GCD and LCM of the two connected lawns match the given values. If possible, output the numbers; else, output NO.\n\nHmm. Let's think about the constraints. For each edge between u and v, we have that GCD(a_u, a_v) = g and LCM(a_u, a_v) = l. Also, since GCD * LCM = a_u * a_v, we can use that relation. So for each edge, the product of the two numbers must be equal to g * l. But also, since the GCD is g, both a_u and a_v must be multiples of g. Let me think: Let's say a_u = g * x, a_v = g * y. Then GCD(x, y) must be 1, because any common divisor would multiply with g to give a higher GCD. And the LCM of a_u and a_v is g * x * y, since x and y are coprime. Therefore, the LCM given must be equal to g * x * y. Which implies that l must be equal to g * x * y. So, l must be divisible by g. Wait, but in the input, the problem says that the given GCD and LCM are valid for the original map. So maybe the input is such that for each edge, the given GCD divides the LCM? Because otherwise, it's impossible. For example, if the GCD is 2 and LCM is 3, then that's impossible. Because GCD * LCM = product of the two numbers. But 2*3=6, which would require that the product of the two numbers is 6. But their GCD is 2, so they must both be multiples of 2. Let's say a and b. Then a=2x, b=2y. Their product is 4xy. But according to GCD*LCM, it's 2*3=6. So 4xy=6 → 2xy=3. But x and y are integers. So no solution. Hence, in such cases, the answer is NO.\n\nSo first, for each edge, we need to check if l is divisible by g. Because if not, then it's impossible. Because the LCM must be a multiple of the GCD. So that's a necessary condition. Also, the product of the two numbers is g*l. So, for each edge, if the given GCD and LCM don't satisfy that l is divisible by g, then we can immediately return NO.\n\nSo that's one check to perform. But how do I model the problem?\n\nEach edge gives us some constraints between two nodes. The idea is that for each pair of nodes connected by an edge, their values must be multiples of the GCD, and their product must be GCD * LCM. Also, the GCD of the two values must be exactly the given GCD. So, perhaps we can model this as a graph where each node has a value, and edges enforce certain relationships between pairs.\n\nBut how to assign the values? Let's think about the approach. Since the GCD of the two nodes is g, and their LCM is l, then the product of the two numbers is g*l. So, for each edge between u and v, the product a_u * a_v = g * l. Also, since GCD(a_u, a_v) = g, then a_u = g * x, a_v = g * y, where GCD(x, y) = 1. And x*y = l/g. Because LCM(a_u, a_v) = g * x * y = l. So x*y = l/g. Therefore, for each edge, l must be divisible by g. Otherwise, it's impossible.\n\nSo first, for all edges, check if l is divisible by g. If any edge fails this, output NO.\n\nOnce that is done, for each edge, the product x*y = (l/g). And since x and y are coprime, this gives us that x and y are divisors of (l/g) and coprime.\n\nBut how do I assign x and y to the nodes? Because for each node, there could be multiple edges connected to it, each imposing different constraints.\n\nThis seems like a problem where each node's value is determined by a set of constraints, and perhaps we can model this as a graph where each edge enforces a ratio between the nodes. However, since the problem involves GCD and LCM, perhaps we need to model the relationships between the nodes as a graph where each node's value is a multiple of some base value, and the edges impose constraints on the ratios between the nodes.\n\nAlternatively, think of the problem as building a graph where each node has a value, and for each edge between u and v, the value of u and v must be such that their GCD is g and LCM is l. Let's think about the possible assignments.\n\nLet me think of the problem as a graph where each node has a value. For each edge, the values of u and v must be such that:\n\na_u = g * x\n\na_v = g * y\n\nwith x and y coprime, and x*y = (l/g).\n\nSo for each edge, the product x*y is fixed. Also, since x and y are coprime, they must be factors of (l/g) that are coprime.\n\nBut how to assign x and y to the nodes. For example, suppose we have a connected component. For each node, we can assign a value based on the product of the factors along the path from some root node. But how?\n\nAlternatively, for each connected component, we can choose a root node and assign a value to it, then propagate the constraints through the edges.\n\nBut how to do that?\n\nLet me consider that for each edge, the product of the two nodes' values is fixed. For example, for edge between u and v, a_u * a_v = g * l. So, if I know a_u, then a_v is determined as (g*l)/a_u. But this is only possible if a_u divides (g*l). However, since a_u must be a multiple of g (from the GCD), then a_u is g * x, and a_v is g * y, where x * y = l/g. Also, since x and y are coprime, once we choose x for u, y is determined as (l/g)/x. But since x and y must be coprime, this imposes that x must divide (l/g) and that the co-divisor (l/g)/x must be coprime with x.\n\nSo, for each edge, the possible pairs (x, y) are such that x*y = k (where k = l/g) and gcd(x,y)=1.\n\nBut how to model this in the graph? Because each edge connects two nodes, and their x and y values must be such that their product is k and they are coprime.\n\nBut how can we assign these values across the entire graph?\n\nPerhaps, for each connected component of the graph, we can assign a value to a starting node and then propagate the constraints through BFS or DFS. However, during propagation, we need to ensure that the constraints are compatible.\n\nLet me think of an example. Suppose we have two nodes connected by an edge with g=1, l=3. Then k = l/g = 3. So x*y =3, and x and y are coprime. Possible pairs (1,3) and (3,1). So, for the first node, we can assign x=1, and the second node x=3. Alternatively, the other way around.\n\nBut when building the graph, if there are multiple edges, how do we ensure that the assignments are consistent.\n\nSo, the approach could be:\n\n- For each connected component in the graph (since the graph may be disconnected), process it separately.\n\n- For each connected component, choose a starting node (say, node u), assign a value to it (like a_u = g * x, but how to choose x?), then propagate the constraints through the edges.\n\nWait, but how to choose the initial value. Let's think again. For each edge, the product of the two nodes' values is fixed. Let me think of the nodes as variables, and for each edge between u and v, a_u * a_v = c (where c is g*l for that edge). But this is a system of equations. However, the variables are constrained to be multiples of the GCDs of their edges. Wait, but how?\n\nAlternatively, considering that for each edge, the product of the two nodes is fixed. So, if the graph is connected, then all nodes' values are determined up to a constant factor. But that's not the case here, because each edge may have different constraints.\n\nWait, for example, suppose we have a chain of nodes u - v - w, with edges (u-v) with product c1 and (v-w) with product c2. Then, a_u * a_v = c1, a_v * a_w = c2. Then, a_u = c1 / a_v, and a_w = c2 / a_v. So, a_u * a_w = (c1 * c2) / a_v^2. But unless there's another constraint, this could vary. However, if there's a cycle in the graph, then the constraints must be compatible.\n\nSo, the problem becomes similar to checking if the graph is bipartite, but with more complex constraints. For example, in a bipartition, each edge enforces that adjacent nodes are in different partitions. Here, each edge enforces that the product of the two nodes is fixed.\n\nBut how to model this. Let me think of each node's value as a variable. For each edge (u, v), we have a_u * a_v = c (which is g*l for that edge). So, for each such edge, a_u = c / a_v. So, if I have a path from u to v, then the product of the variables along the path must be compatible. For example, if there's a path u - a - b - v, then a_u * a_a = c1, a_a * a_b = c2, a_b * a_v = c3. Then, a_u = c1/a_a, a_b = c2/a_a, a_v = c3/a_b = c3 * a_a / c2. Then, substituting into a_u * a_v = (c1/a_a) * (c3 * a_a / c2) ) = (c1 * c3) / c2. But if there's another path from u to v, say directly, then the product a_u * a_v must equal the c of that direct edge. So, if the product computed via the path is different from the direct edge's c, then there's a contradiction, and the answer is NO.\n\nTherefore, the approach is:\n\nFor each connected component, perform a BFS or DFS, assigning values to nodes, ensuring that all constraints are satisfied.\n\nBut how to assign the values. Let's think of the following:\n\nStart with a node u. Assign a value to it. Then, for each neighbor v connected by an edge with parameters g and l, compute the required value of v as (g*l) / a_u. However, this requires that a_u divides (g*l). Also, the GCD of a_u and a_v must be equal to g. Wait, but how can we ensure that?\n\nBecause the product of a_u and a_v is g*l. Also, their GCD is g. Let me check:\n\nIf a_u and a_v have GCD g, then their product is g * LCM(a_u, a_v). Which equals g*l. So that's correct.\n\nBut how to ensure that the GCD is exactly g. Because if I set a_u and a_v as (g * x) and (g * y) with x*y = l/g and x and y coprime, then their GCD is g * GCD(x, y) = g * 1 = g. So that's correct. So the key is to assign x and y such that x and y are coprime and x*y = l/g.\n\nBut how to do that when propagating through the graph. Because for each edge, the product of the two nodes is fixed. But the problem is that when you assign a value to a node, the other node's value is determined, but you have to ensure that their GCD is exactly the given g and that their LCM is exactly the given l. However, if the product is correct, then the LCM and GCD would be determined. Wait, no. Because if a_u and a_v have product g*l, but their GCD is not g, then their LCM would be (a_u*a_v)/GCD(a_u,a_v) = (g*l)/GCD(a_u,a_v). Which would not be equal to l. So, the LCM would be l only if GCD(a_u,a_v) is g.\n\nTherefore, the product being g*l is necessary but not sufficient. We also have to ensure that the GCD is exactly g. How?\n\nBut how can that be ensured? Because when you assign a_u and a_v such that their product is g*l, but their GCD could be higher than g. For example, suppose g is 2, l is 6. Then product is 12. Suppose a_u is 4 and a_v is 3. Their product is 12. GCD(4,3) is 1, which is not equal to g=2. So that's invalid. Hence, even though the product is correct, the GCD is wrong.\n\nSo, how to avoid that? Well, the earlier approach of setting a_u = g * x and a_v = g * y, where x and y are coprime and x*y = l/g. This ensures that the product is g*l and that the GCD is exactly g.\n\nBut during the assignment process, how can we ensure that this is the case?\n\nSo, perhaps the approach is:\n\nFor each edge between u and v, we have that a_u and a_v must be multiples of g. So, for each edge, we can model the relationship between u and v as follows: a_u = g * x, a_v = g * y, with x and y coprime and x*y = l/g.\n\nBut how to assign x and y to the nodes. For example, when processing the graph, for each node, we can assign a value (x) such that for each edge, the product of x and y is (l/g), and they are coprime.\n\nBut how to model this in code. Let's think of the following steps:\n\nFirst, for each edge, check if l is divisible by g. If not, output NO.\n\nThen, for each edge, compute k = l / g. Then, for the edge between u and v, we have that (a_u/g) * (a_v/g) = k, and GCD(a_u/g, a_v/g) = 1.\n\nSo, let's define for each node, a value x_i = a_i / g_uv, but this depends on the edge. Wait, no. Because each node can be part of multiple edges, each with different g and l. So this approach may not work.\n\nAlternatively, perhaps the problem can be modeled as a graph where each node's value is a multiple of some base, but that's unclear.\n\nAnother idea: For each edge between u and v, the ratio between a_u and a_v must be such that a_u / a_v = (x/y), where x*y = k, and x and y are coprime. But since x and y are coprime, the ratio is x/y, which is in reduced terms. However, this seems complicated.\n\nAlternatively, for each edge, the product of the two nodes is fixed. So, for example, a_u * a_v = c (where c is g*l). So, if I can assign a value to a_u, then a_v is determined as c / a_u. However, this requires that a_u divides c. Also, the GCD of a_u and a_v must be exactly g. How can I ensure that?\n\nBut how can I find such a value for a_u? Let's take an example. Suppose I have an edge between u and v with g=2 and l=6. Then c = 2*6 = 12. So a_u * a_v = 12. Also, GCD(a_u, a_v) must be 2. So possible pairs (2,6), (6,2), (4,3) is invalid because GCD is 1, etc. So, the possible values are those where both are multiples of 2, and their product is 12. Let's see:\n\nPossible options:\n\na_u can be 2, then a_v is 6. GCD(2,6) is 2. Good.\n\na_u can be 6, a_v is 2. Same.\n\na_u can be 4, a_v is 3. But 3 is not a multiple of 2. So invalid.\n\na_u can be 12, a_v is 1. Again, invalid.\n\nSo, only possible pairs are (2,6) and (6,2). So, when propagating through the graph, the value of a node must be a multiple of the GCD of the edge. But how to ensure that.\n\nSo, for each edge, when assigning the value to a node, the value must be a multiple of the GCD of that edge.\n\nBut how to handle multiple edges connected to the same node. For example, if a node u is connected to v via edge with g1, and to w via edge with g2, then a_u must be a multiple of both g1 and g2. So, the GCD of all the edges connected to u must divide a_u. Therefore, for each node, the value must be a multiple of the LCM of all the GCDs of the edges connected to it. Or wait, no. Because for each edge connected to u, the value of u must be a multiple of the GCD of that edge. Therefore, the value of u must be a multiple of the LCM of all the GCDs of the edges connected to u. Because LCM of the GCDs is the minimal number that is a multiple of all of them.\n\nBut how to compute that. For example, if a node is connected to edges with GCDs 2 and 3, then a_u must be a multiple of 6. So, the LCM of all the GCDs of edges connected to the node.\n\nTherefore, for each node, we can compute the LCM of all the GCDs of the edges connected to it. Then, the value of the node must be a multiple of this LCM. However, during the assignment, we need to ensure that this is satisfied.\n\nBut how to proceed with this. Let's think again about the approach of BFS/DFS. Let's pick a starting node, assign it a value that is a multiple of the LCM of its edges' GCDs, then propagate through the edges.\n\nBut how to choose the initial value. For example, suppose the starting node has edges with GCDs 2 and 3, so LCM is 6. So the value of the node must be a multiple of 6. Let's say we assign it 6. Then, for each connected edge, we can compute the other node's value.\n\nBut then, for each edge between u and v with GCD g and LCM l, we have a_u * a_v = g * l. So, once a_u is known, a_v is determined as (g*l)/a_u. However, this a_v must be a multiple of the GCD of that edge (g), and also must be compatible with other edges connected to v.\n\nSo, the algorithm could be:\n\nFor each connected component:\n\n   - Compute the LCM of all GCDs of edges connected to each node in the component. Let's call this the 'base' value for the node.\n\n   - Choose a starting node, assign it a value. Let's say, the base value. Then, for each neighbor, compute their value based on the edge's g and l.\n\n   - During traversal, check if the computed value for a node is compatible with its existing value (if already assigned) and also that it is a multiple of the node's base value.\n\nBut how to compute the base value for each node. For example, for a node u, collect all edges connected to it, take their GCDs, compute their LCM, which is the minimum value that u's a_u must be a multiple of.\n\nSo, for each node, precompute this LCM.\n\nOnce that is done, during BFS/DFS:\n\n- Assign the starting node a value equal to its base value. Then, for each edge, compute the neighbor's value as (g*l) / current node's value. Then check if this value is a multiple of the neighbor's base value. If not, then it's impossible. Also, check if the neighbor's value is compatible with the current edge's constraints (i.e., that the GCD of the two values is exactly the given g and the LCM is exactly the given l).\n\nBut how to check that. Because once the product is correct, and the values are multiples of the respective GCDs, then the GCD should be correct. Let me think.\n\nSuppose a_u is assigned as a multiple of the base (which is the LCM of all the GCDs of edges connected to u). For the edge between u and v, a_u is a multiple of g (the GCD of this edge). Similarly, a_v must be a multiple of g. Then, the GCD of a_u and a_v must be at least g. But since their product is g*l, then their GCD must be exactly g. Because:\n\nLet me denote a_u = g * x, a_v = g * y. Then their product is g^2 * x * y = g * l → g * x * y = l. Also, since the GCD of a_u and a_v is g * GCD(x, y). But since the given GCD is g, then GCD(x, y) must be 1. Also, x * y = l/g. Therefore, x and y are coprime and their product is l/g. Therefore, the LCM of a_u and a_v is g * x * y = g * (l/g) = l, which matches the given LCM. So, as long as x and y are coprime, the constraints are satisfied.\n\nSo, during the assignment, if we can ensure that for each edge, the x and y are coprime, then the constraints are satisfied. However, how can we ensure that during the BFS/DFS?\n\nBut how to compute x and y. Since a_u = g * x, a_v = g * y, and x * y = l/g, and x and y are coprime.\n\nBut when we assign a_u and a_v, their values are determined by the product (g*l) = a_u * a_v. So, once a_u is known, a_v is determined. However, x = a_u / g, y = a_v / g. Then x * y = (a_u * a_v) / (g^2) ) = (g*l) / g^2 = l/g. Which is correct. But we also need x and y to be coprime.\n\nSo, how to ensure that x and y are coprime. Because if a_u and a_v are assigned as per the product, but their x and y are not coprime, then the GCD of a_u and a_v would be higher than g. Which would violate the constraints.\n\nSo, for example, suppose the edge has g=2, l=6. Then l/g = 3. So x * y = 3. x and y must be coprime. So possible pairs (1,3) and (3,1). So a_u is 2*1=2, a_v is 2*3=6. GCD(2,6)=2. Correct.\n\nBut if during the assignment, a_u is 4 and a_v is 3 (product 12 = 2*6). But then, a_u is 4, which is 2*2, and a_v is 3. So x=2, y=3/2. No, that's not integer. So that's invalid. Wait, but a_v must be a multiple of g (2), so in this case, a_v must be 6, not 3. So if the assignment process ensures that a_v is a multiple of g, then x and y will be integers.\n\nSo during the BFS/DFS, when we assign a_v as (g*l) / a_u, we need to make sure that a_v is a multiple of g. Because a_v must be a multiple of the GCD of the edge. But since a_u is a multiple of g (as per the base value), and (g*l) is divisible by g (since l is divisible by g), then (g*l) / a_u will be (g*l) divided by a multiple of g. Let me think: a_u is a multiple of g, say a_u = k * g. Then (g*l) / a_u = (g*l)/(k * g) ) = l/(k). So l must be divisible by k. But why?\n\nBecause l is divisible by g (we checked that earlier), but k is the value of a_u / g. However, during the assignment process, how do we ensure that l is divisible by k?\n\nThis seems like a problem. Because if during the assignment, the value of a_u is chosen such that k divides l, then a_v will be an integer. Otherwise, it's not possible.\n\nSo, for example, if during the BFS/DFS, when we assign a_u, we must choose a value such that for each edge connected to u, the l of that edge is divisible by (a_u / g). But how can we ensure that?\n\nThis seems complicated. Perhaps, during the BFS/DFS, when we assign a value to a node, we need to ensure that for each edge connected to it, the l of that edge is divisible by (a_u / g_uv), where g_uv is the GCD of that edge.\n\nBut how to do that. It seems challenging. So maybe the approach is:\n\nFor each connected component:\n\n   - For each node u in the component, compute the base value (LCM of all GCDs of edges connected to u).\n\n   - Start BFS/DFS from a node. Assign it a value. Let's say, the base value.\n\n   - For each edge from u to v with parameters g and l:\n\n      - Check if (g*l) is divisible by a_u. If not, then impossible. Because a_v = (g*l) / a_u must be integer.\n\n      - Compute a_v = (g*l) / a_u.\n\n      - Check if a_v is a multiple of the base value of v. If not, impossible.\n\n      - Also, check if a_v is a multiple of g. Because a_v must be a multiple of the GCD of this edge.\n\n      - Then, proceed to assign a_v and continue BFS/DFS.\n\nBut how to ensure that during the assignment, the a_v is such that for all edges connected to v, the same conditions are met. However, since during BFS/DFS, we are propagating the constraints, we can check for consistency.\n\nBut what if during this process, a_v is not compatible with other edges connected to v?\n\nFor example, suppose node v is connected to two edges. The first edge (u-v) gives a_v as computed, and the second edge (v-w) gives a different value for a_v. Then, there's a contradiction.\n\nSo, the BFS/DFS must check that when visiting a node, the computed value is the same as the previously assigned value. If not, then it's impossible.\n\nSo, the algorithm steps would be:\n\nFor each connected component in the graph:\n\n   - Precompute for each node u in the component, the base value (LCM of all GCDs of edges connected to u).\n\n   - Initialize all nodes in the component with no value.\n\n   - Pick a starting node u. Assign it a value equal to its base value.\n\n   - Perform BFS/DFS:\n\n      - For each current node, iterate through its edges.\n\n      - For each edge (current_node, neighbor) with parameters g and l:\n\n         - If neighbor hasn't been assigned a value yet:\n\n             - Compute required value for neighbor: a_neighbor = (g * l) / a_current.\n\n             - Check if a_neighbor is integer. If not, return NO.\n\n             - Check if a_neighbor is a multiple of the base value of neighbor. If not, return NO.\n\n             - Check if a_neighbor is a multiple of g. Because the GCD of the edge is g. Since a_neighbor is a multiple of base value of neighbor, which is LCM of all GCDs of edges connected to neighbor, including this edge's g. So the base value of neighbor is a multiple of g. Therefore, a_neighbor is a multiple of base value of neighbor, which is a multiple of g. Hence, this check is redundant.\n\n             - Assign a_neighbor and proceed.\n\n         - Else:\n\n             - Check if a_neighbor equals (g*l)/a_current. If not, return NO.\n\n   - After BFS/DFS completes, check all edges in the component to ensure that the GCD and LCM are correct.\n\nBut wait, the above steps may not check all constraints. For example, even if during BFS/DFS the values are assigned correctly, there might be an edge that was not processed during BFS/DFS (but it's part of the component). But since the BFS/DFS processes all edges, perhaps not. Because during BFS/DFS, each edge is processed when the current node is visited. But for example, when the edge u-v is processed from u to v, and later, when v is processed, the edge v-u is also processed. However, during the processing, the check is whether the computed value matches the existing value. So, this should ensure that all edges are consistent.\n\nBut perhaps there's a case where during BFS/DFS, the value is assigned correctly, but the GCD and LCM are not satisfied. For example, if during the assignment, the product is correct, but the GCD is not the required value.\n\nBut earlier analysis suggests that if the product is correct and the a_u and a_v are multiples of the edge's GCD, then the GCD of a_u and a_v is exactly the edge's GCD.\n\nLet me check with an example. Suppose a_u = 2 and a_v = 6. GCD is 2. Product is 12. Edge's g is 2, l is 6. So yes. Now, suppose a_u is 4 and a_v is 3. Product is 12. Edge's g is 2, l is 6. But a_v is 3, which is not a multiple of 2. So this case is not allowed, because during the assignment, the a_v must be a multiple of the edge's GCD. Hence, this case is prevented by the check that a_neighbor is a multiple of the base value, which is a multiple of the edge's GCD.\n\nThus, during the BFS/DFS, all a_neighbor are multiples of the edge's GCD. Therefore, the product is correct, and the GCD of a_u and a_v is exactly the edge's GCD. Hence, the constraints are satisfied.\n\nSo, the algorithm steps are:\n\nCheck for all edges if l is divisible by g. If any is not, output NO.\n\nFor each connected component:\n\n   Compute base value for each node (LCM of all edge GCDs connected to it).\n\n   Do BFS/DFS, assigning values as described.\n\n   During BFS/DFS, check for consistency.\n\nOnce all components are processed, output the values.\n\nNow, let's think about the code structure.\n\nFirst, read n and m. Then read m edges. Each edge has u, v, g, l.\n\nWe need to build the graph. Also, for each node, collect all edges connected to it, to compute the base value.\n\nFor each node u, base[u] = LCM of all GCDs of edges connected to u.\n\nHow to compute LCM of a list of numbers. The LCM of two numbers a and b can be computed as a*b // GCD(a,b). So for multiple numbers, we can compute the LCM incrementally.\n\nOnce base is computed for each node, then proceed.\n\nNow, for the BFS/DFS:\n\nWe need to process each connected component. For each component, assign values.\n\nWe can represent the graph as an adjacency list. For each node, a list of tuples (neighbor, g, l).\n\nNow, for each node, if not visited, start BFS/DFS.\n\nInitialize a list 'values' with None for each node.\n\nFor the starting node, assign it base value. Then, for each neighbor, compute the required value.\n\nBut during this process, we need to check that the required value is integer. For example, (g*l) must be divisible by the current node's value.\n\nBut how to compute that. For example, current node's value is a_current. For the edge (u, v) with parameters g and l, the required a_v is (g*l) / a_current. This must be an integer.\n\nBut how to check that. Because a_current is a multiple of base[u], which is the LCM of all edge GCDs connected to u. For example, the edge's g is part of that LCM. So, base[u] is a multiple of g. Therefore, a_current is a multiple of g. Hence, g divides a_current. Then, (g*l) / a_current is l/(a_current/g). Since a_current/g is an integer (since a_current is a multiple of g). But why is l divisible by (a_current/g)?\n\nNot sure. Because l can be anything. For example, suppose the edge has g=2, l=6. Then, a_current is 2 (base[u] is 2, assuming no other edges connected to u). Then a_v is (2*6)/2 = 6. Which is correct.\n\nBut if the edge has g=2, l=6, and a_current is 4 (base[u] is 2, but a_current is 4). Then, a_v is (2*6)/4 = 3. Which is not a multiple of g (2). But earlier checks during BFS/DFS would have ensured that a_v is a multiple of the base of v. However, in this case, the base of v is LCM of all edge GCDs connected to v. For example, if v is connected to this edge with g=2, then base[v] is at least 2. So, a_v must be a multiple of base[v], which is >= 2. But in this example, a_v is 3, which is not a multiple of 2. Hence, this case would be caught during the check that a_v is a multiple of base[v].\n\nBut how can a_v be 3 in this case? Because during the BFS/DFS, when we compute a_v = (g*l)/a_current, which is 12/4 = 3. Then, check if 3 is a multiple of base[v]. If base[v] is 2, then no. So the code would return NO.\n\nBut why would a_current be 4? Because during the BFS/DFS, the starting node's value is set to its base value. For example, if the starting node's base is 2, then the code would assign it 2, not 4. Unless there's a mistake in the code.\n\nAh! The code assigns the starting node's value as its base value. So, for the starting node, the value is base[u], which is the LCM of all the edge GCDs connected to u. Hence, for the edge (u, v) with GCD g, the value of a_current is base[u], which is a multiple of g. Then, when computing a_v = (g*l)/a_current, this is (g*l) divided by a multiple of g. Let me write this as (g*l) / (k * g) = l /k. So, l must be divisible by k.\n\nBut why would that be the case? Because k is the base value of u, which is the LCM of all the GCDs of edges connected to u. However, the edge (u, v) has GCD g, which is part of that LCM. So, k is a multiple of g. But l is given for that edge, and we have already checked that l is divisible by g. However, there's no guarantee that l is divisible by k.\n\nFor example, suppose u has a base value of 2 (because it's connected to an edge with GCD 2). The edge between u and v has g=2, l=4. Then, l/g is 2. So, for the starting node u, a_current is 2. Then a_v = (2*4)/2 = 4. Which is okay. Now, suppose the edge between u and v has g=2, l=5. Then, since l is not divisible by g (wait, no: 5 is not divisible by 2. But earlier steps would have checked that for all edges, l is divisible by g. So in this case, the code would have already returned NO.)\n\nSo, the initial check for each edge ensures that l is divisible by g. Hence, for each edge, l/g is an integer. Let me denote this as k_edge = l/g.\n\nSo, during BFS/DFS, when we compute a_v = (g*l) / a_current = g * (l/g) * g / a_current? No,",
    "response": "To solve this problem, we need to determine if we can restore the number of mushrooms on each lawn based on given GCD and LCM values for each road connecting two lawns. The solution involves checking constraints and using a graph traversal technique to propagate values consistently across the connected components of the graph.\n\n### Approach\n1. **Input Validation**: For each edge, check if the LCM is divisible by the GCD. If not, it's impossible to restore the values.\n2. **Base Value Calculation**: For each node, compute the base value as the Least Common Multiple (LCM) of all GCDs of edges connected to that node. This ensures that the value assigned to each node is a multiple of all GCDs of its connected edges.\n3. **Graph Traversal**: Use BFS/DFS to traverse each connected component of the graph. Assign values starting from an arbitrary node, ensuring that values are consistent with the given GCD and LCM constraints for each edge.\n4. **Consistency Check**: During traversal, ensure that each computed value for a node is consistent with previously assigned values and meets the required constraints.\n\n### Solution Code\n```python\nimport sys\nimport math\nfrom collections import deque\n\ndef input():\n    return sys.stdin.read()\n\ndef main():\n    data = input().split()\n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    m = int(data[idx])\n    idx += 1\n    \n    edges = []\n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        u = int(data[idx]) - 1\n        idx += 1\n        v = int(data[idx]) - 1\n        idx += 1\n        g = int(data[idx])\n        idx += 1\n        l = int(data[idx])\n        idx += 1\n        edges.append((u, v, g, l))\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l))\n    \n    # Check if any edge has l not divisible by g\n    for u, v, g, l in edges:\n        if l % g != 0:\n            print(\"NO\")\n            return\n    \n    # Compute base for each node\n    base = [1] * n\n    for i in range(n):\n        current_gcds = []\n        for neighbor, g, l in adj[i]:\n            current_gcds.append(g)\n        if not current_gcds:\n            continue\n        lcm_val = current_gcds[0]\n        for g in current_gcds[1:]:\n            lcm_val = lcm_val * g // math.gcd(lcm_val, g)\n        base[i] = lcm_val\n    \n    # Now process each connected component\n    visited = [False] * n\n    values = [None] * n\n    \n    for start in range(n):\n        if not visited[start]:\n            # BFS\n            queue = deque()\n            queue.append(start)\n            visited[start] = True\n            values[start] = base[start]\n            \n            while queue:\n                u = queue.popleft()\n                for (v, g, l) in adj[u]:\n                    if not visited[v]:\n                        # Compute required value for v\n                        a_u = values[u]\n                        product = g * l\n                        if product % a_u != 0:\n                            print(\"NO\")\n                            return\n                        a_v = product // a_u\n                        # Check if a_v is multiple of base[v]\n                        if a_v % base[v] != 0:\n                            print(\"NO\")\n                            return\n                        values[v] = a_v\n                        visited[v] = True\n                        queue.append(v)\n                    else:\n                        # Check consistency\n                        a_u = values[u]\n                        a_v = values[v]\n                        expected_product = g * l\n                        if a_u * a_v != expected_product:\n                            print(\"NO\")\n                            return\n    \n    # After processing all, check all edges again for GCD and LCM\n    for u, v, g, l in edges:\n        a_u = values[u]\n        a_v = values[v]\n        if math.gcd(a_u, a_v) != g or (a_u * a_v) // math.gcd(a_u, a_v) != l:\n            print(\"NO\")\n            return\n    \n    print(\"YES\")\n    print(' '.join(map(str, values)))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Input Handling**: The input is read and parsed into nodes and edges with their respective GCD and LCM values.\n2. **Validation Check**: Each edge's LCM is checked to ensure it is divisible by its GCD.\n3. **Base Value Calculation**: For each node, the base value is calculated as the LCM of all GCDs of its connected edges to ensure compatibility with all constraints.\n4. **Graph Traversal**: Using BFS, values are propagated from an initial node to its neighbors, ensuring consistency with the given constraints. If any inconsistency is found during traversal, the answer is \"NO\".\n5. **Final Consistency Check**: After traversal, all edges are rechecked to ensure that the GCD and LCM values match the given constraints, confirming the solution's validity.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\nfrom collections import deque\n\ndef input():\n    return sys.stdin.read()\n\ndef main():\n    data = input().split()\n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    m = int(data[idx])\n    idx += 1\n    \n    edges = []\n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        u = int(data[idx]) - 1\n        idx += 1\n        v = int(data[idx]) - 1\n        idx += 1\n        g = int(data[idx])\n        idx += 1\n        l = int(data[idx])\n        idx += 1\n        edges.append((u, v, g, l))\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l))\n    \n    # Check if any edge has l not divisible by g\n    for u, v, g, l in edges:\n        if l % g != 0:\n            print(\"NO\")\n            return\n    \n    # Compute base for each node\n    base = [1] * n\n    for i in range(n):\n        current_gcds = []\n        for neighbor, g, l in adj[i]:\n            current_gcds.append(g)\n        if not current_gcds:\n            continue\n        lcm_val = current_gcds[0]\n        for g in current_gcds[1:]:\n            lcm_val = lcm_val * g // math.gcd(lcm_val, g)\n        base[i] = lcm_val\n    \n    # Now process each connected component\n    visited = [False] * n\n    values = [None] * n\n    \n    for start in range(n):\n        if not visited[start]:\n            # BFS\n            queue = deque()\n            queue.append(start)\n            visited[start] = True\n            values[start] = base[start]\n            \n            while queue:\n                u = queue.popleft()\n                for (v, g, l) in adj[u]:\n                    if not visited[v]:\n                        # Compute required value for v\n                        a_u = values[u]\n                        product = g * l\n                        if product % a_u != 0:\n                            print(\"NO\")\n                            return\n                        a_v = product // a_u\n                        # Check if a_v is multiple of base[v]\n                        if a_v % base[v] != 0:\n                            print(\"NO\")\n                            return\n                        values[v] = a_v\n                        visited[v] = True\n                        queue.append(v)\n                    else:\n                        # Check consistency\n                        a_u = values[u]\n                        a_v = values[v]\n                        expected_product = g * l\n                        if a_u * a_v != expected_product:\n                            print(\"NO\")\n                            return\n    \n    # After processing all, check all edges again for GCD and LCM\n    for u, v, g, l in edges:\n        a_u = values[u]\n        a_v = values[v]\n        if math.gcd(a_u, a_v) != g or (a_u * a_v) // math.gcd(a_u, a_v) != l:\n            print(\"NO\")\n            return\n    \n    print(\"YES\")\n    print(' '.join(map(str, values)))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 559,
        "completion_token_count": 1098,
        "thoughts_token_count": 8192
    }
}