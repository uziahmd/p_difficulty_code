{
    "start": 1758309294.4627507,
    "end": 1758309510.6296182,
    "start-formatted": "2025-09-20 04:14 KST",
    "end-formatted": "2025-09-20 04:18 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\nOkay, let's tackle this problem. Hmm, the task is to find the minimum number of edges to add to form an odd-length cycle, and the number of ways to do that. Let me think.\n\nFirst, I remember that a graph is bipartite if and only if it doesn't contain any odd-length cycles. So, if the original graph already has an odd-length cycle, then t is 0 and w is 1? Wait, no. Because the problem says we need to form a simple cycle of odd length. So if the graph already contains such a cycle, then the answer is t=0 and w=number of such cycles? But wait, the problem says that we have to find the minimum number of edges to add. If there's already an existing cycle of odd length, then t is zero. But how do we count w?\n\nWait, the problem says that w is the number of ways to add t edges to form such a cycle. So if the graph already has at least one such cycle, then t is zero, and w is the number of such possible cycles? Or maybe not. Because the question is about adding t edges to form a cycle. If the graph already has such a cycle, then adding zero edges would be the way. But how many such ways are there? Well, for each existing odd-length cycle, but since the problem says that the way is considered equal if they have the same set of added edges. Since in this case, no edges are added, so the number of ways is 1? Or maybe the number of existing odd cycles?\n\nNo, that's not right. Because the problem says that w is the number of ways to add t edges to form a cycle. So if the graph already contains an odd cycle, then t is zero, and the number of ways is 1, because you don't add any edges. But wait, maybe there are multiple existing odd cycles. However, the problem says that the way is considered equal if they have the same set of added edges. Since adding zero edges is one way, regardless of how many existing cycles there are. Because the question is about how many ways to add edges. So if the original graph already has an odd cycle, then the answer is t=0 and w=1? Because you don't add any edges. But why is the sample input 3 3 (a triangle) output 0 1? Let's check the sample input.\n\nIn the second example input, the graph is a triangle (three nodes connected in a cycle). The output is 0 1. Which matches that. So yes, if the graph already contains an odd cycle, then t is 0 and w is 1. Because there's exactly one way to add zero edges (no matter how many existing cycles there are, since adding zero edges is one way).\n\nSo the first thing to check is whether the graph already contains an odd-length cycle. If yes, then the answer is t=0, w=1.\n\nIf not, then we need to find the minimal t and the number of ways.\n\nNow, if the graph is bipartite (so no odd cycles), then how can we add edges to create an odd cycle?\n\nLet me think. For a bipartite graph, any cycle is even-length. To create an odd-length cycle, we need to add edges in such a way that creates a cycle of odd length.\n\nThe minimal number of edges to add would be 1 or 2?\n\nWait, for example, consider a bipartite graph. Suppose there's a connected component which is a tree. Then, adding one edge would create a cycle. But since the graph is bipartite, the cycle would be even-length. So adding one edge is not enough. To get an odd-length cycle, perhaps we need to add two edges. Or maybe find a way to connect two nodes in a way that creates an odd-length cycle.\n\nAlternatively, think about the bipartition of each connected component. Each connected component of a bipartite graph can be divided into two parts, say A and B. If we add an edge between two nodes in the same partition, then that creates an odd-length cycle. Because in the original bipartition, any path between two nodes in the same partition has even length. Adding an edge between them creates a cycle of length (path length + 1), which is odd.\n\nSo, for each connected component, if we can add an edge between two nodes in the same partition, then that creates an odd-length cycle. The minimal number of edges to add is 1. But how?\n\nSo, if the graph is bipartite, then the minimal t is 1, but only if there exists at least one connected component with at least two nodes in one of the partitions. Wait, no. Because if the component is a single node, then it's trivially bipartitioned into one part. But adding an edge between two nodes in the same partition requires that there are at least two nodes in that partition.\n\nSo, for each connected component, if the component has at least two nodes, then the bipartition splits into two parts. Let's say the component has partitions of size a and b. Then, the number of possible edges that can be added between the same partitions is (a choose 2) + (b choose 2). Each such edge would create an odd-length cycle.\n\nBut the minimal t is 1. So, the minimal number of edges to add is 1. However, if there is a connected component where the bipartition has both partitions with at least one node, then adding one edge between same partitions would create an odd cycle.\n\nWait, but if the component is a single node, then adding an edge is impossible (since the graph has no loops). So, for a connected component with only one node, you can't add any edges. So, in that case, you need to add edges between other components.\n\nBut the problem says that the graph is undirected, and we can add edges between any two nodes (as long as they are not already connected by an edge).\n\nSo, for the case when the original graph is bipartite (no odd cycles), then the minimal t is 1 if there exists at least one connected component with at least two nodes. Wait, no. Because if the graph has a connected component with two nodes (say, connected by an edge). Then, the bipartition is {A}, {B}, each of size 1. Adding an edge between A and B is already present. To create an odd-length cycle, you need to add an edge between A and A (but that's a loop, which is prohibited), or between B and B. But that's also a loop. So, no. So, in this case, adding an edge between two nodes in the same partition is not possible. So, how can you create an odd cycle here?\n\nWait, in this case, the component is a single edge between two nodes. The bipartition is {u}, {v}. Adding an edge between u and v again is a parallel edge, which is not allowed. So, adding any edge between u and v is not allowed. But what about adding an edge between u and another node in another component?\n\nWait, suppose there is another component. Let's say there's another component with two nodes. Suppose we add an edge between u and x (from another component). Then, perhaps that creates a cycle?\n\nWait, if the original graph is bipartite, and you add an edge between two nodes in different components. Let's think: suppose component 1 is a single edge (u-v), component 2 is a single edge (x-y). If you add an edge between u and x. Now, the new graph would have a cycle u-v-x-u. Which is of length 3. That's an odd-length cycle. So in this case, adding a single edge between two components would create an odd-length cycle.\n\nSo, the minimal t is 1. But how?\n\nSo, the problem is that in the original graph being bipartite, the way to create an odd cycle is either:\n\n- Add an edge within a component between two nodes in the same partition (so that the cycle formed is odd-length), or\n\n- Add an edge between two nodes from different components (each of which is bipartitioned). But how does that create an odd cycle?\n\nLet me think. Suppose component A is bipartitioned into (A1, A2), and component B is bipartitioned into (B1, B2). If I add an edge between a node in A1 and a node in B1. Then, the combined component would have a cycle that involves paths from A1 to A2 (even length), then through the new edge to B1, then through some path in B to B2 (even length?), and then back via the new edge. Wait, perhaps not. Maybe the parity depends on the combination.\n\nAlternatively, think of the two components as separate. When you add an edge between two nodes from different components, the new graph's bipartition may not be possible. For example, suppose component A is bipartitioned into (A1, A2), component B is bipartitioned into (B1, B2). If you add an edge between a node in A1 and B1. Then, the new component would have a bipartition (A1 ∪ B2, A2 ∪ B1). But if you have a cycle that goes through A1 → B1 → ... → B2 → A2 → ... → A1. The length would depend on the paths. But if the original components were bipartitioned, then any path between A1 and B1 would have length odd or even?\n\nAlternatively, perhaps the minimal t is 1 if the graph has at least two nodes. Wait, but if the graph is a tree (so bipartitioned, no cycles). Adding an edge between two nodes in the same partition would create an odd-length cycle. But for that, the component must have at least two nodes in the same partition. For example, a tree with more than one node. For example, a tree with three nodes arranged in a line (u-v-w). The bipartition is {u, w}, {v}. Adding an edge between u and w would create a cycle u-v-w-u, which is length 3 (odd). So that's possible. So in this case, t is 1, and the number of ways is the number of pairs of nodes in the same partition.\n\nBut if the component is a single edge (two nodes), then the bipartition is {u}, {v}. Adding an edge between u and v is not allowed (already exists). Adding an edge between u and u is a loop. So, no. So in this case, to create an odd cycle, you need to connect two components. For example, if there are two components, each with two nodes. Then, adding an edge between u (from component 1) and x (from component 2). Then, the cycle would be u-v-x-u (if x is in component 2, which has x connected to y). Wait, but that would be a cycle of length 3 (u-v-x-u) if x is connected to y, but that's not part of the cycle. Wait, the cycle is u-v-x-u, which is length 3. Yes. So adding that edge creates a cycle of length 3. So that's possible.\n\nSo, in this case, the minimal t is 1. So, the problem reduces to:\n\nIf the original graph has no odd cycles (i.e., it is bipartite), then:\n\n- If there exists at least one connected component with at least two nodes, then t is 1. But how to compute w?\n\nWait, the number of ways to add t=1 edges to form an odd cycle is the sum over all possible ways to add an edge that creates an odd cycle. Which can be done in two ways:\n\n1. Adding an edge between two nodes in the same bipartition of a connected component. For each connected component, the number of such possible edges is (a * (a - 1) / 2) + (b * (b - 1) / 2), where a and b are the sizes of the two partitions of the component.\n\n2. Adding an edge between two nodes from different connected components. For example, if you have two connected components, each of which is bipartitioned. Adding an edge between a node in partition A1 of component 1 and a node in partition B1 of component 2. But how does that contribute to forming an odd cycle?\n\nWait, when you add such an edge between two components, you can create a cycle that uses the new edge and paths in the two components. Let's see. Suppose component 1 has a bipartition (A1, A2), component 2 has (B1, B2). Adding an edge between a node in A1 and B1. Now, consider the path from A1 to A2 (which is even length) and then the edge to B1, then path from B1 to B2 (even length), then edge back to A1 (the new edge). Wait, that's not a cycle. Hmm, maybe I'm getting confused here.\n\nAlternatively, think of the entire graph after adding the edge. The new graph is no longer bipartite, so there must be an odd-length cycle. But how?\n\nSuppose you have two connected components, each bipartitioned. Adding an edge between u (in component 1) and v (in component 2). Then, the new graph will have a cycle that combines the path from u to some node in component 1, then the new edge, then a path from v to some node in component 2, then back via another path. But perhaps the parity of the total length depends on the way the components are bipartitioned.\n\nAlternatively, think of the bipartition of the entire graph. Suppose component 1 is bipartitioned into A and B. Component 2 is bipartitioned into C and D. If we connect a node in A to a node in C, then the new component can be bipartitioned into (A ∪ D) and (B ∪ C). However, if we connect a node in A to a node in D, then the bipartition would be (A ∪ C) and (B ∪ D). Wait, but if you connect A to D, then the new bipartition would have the node in A and D in the same partition. So, for example, suppose you have a path from u (in A) to v (in D) via the new edge. Then, the parity of the path from u to v is 1 (the new edge). But in the original bipartition, u is in A, and v is in D. In component 2, the bipartition is C and D. So, the path from v to any node in C would be even length. But I'm not sure.\n\nBut regardless, adding an edge between two components that are bipartitioned would create an odd-length cycle. How?\n\nLet me take an example. Suppose component 1 is a single edge (u-v), bipartition {u}, {v}. Component 2 is a single edge (x-y), bipartition {x}, {y}. Adding an edge between u and x. Now, the cycle u-v-x-u has length 3. Which is odd. So this creates an odd-length cycle. Similarly, adding an edge between u and y would create a cycle u-v-y-u (length 3). So, in this case, adding any edge between u and x or u and y would create an odd-length cycle.\n\nBut how many such possibilities are there? For two components, each with two nodes, the number of possible edges that connect them is (number of nodes in component 1) * (number of nodes in component 2). But in this case, component 1 has 2 nodes, component 2 has 2 nodes. So adding any edge between them (there are 2*2 =4 possible edges, but existing edges are not allowed. Wait, but the original graph has no edges between them. So for this case, the number of possible edges between the two components is 4 (since each node in component 1 can be connected to each node in component 2). But in the original graph, there are no such edges. So, the number of possible ways to add an edge between these two components is 4. However, each of these edges would create an odd cycle.\n\nSo, in this case, the number of ways to add an edge between two components is the product of the number of nodes in each component. But wait, for each pair of components, the number of possible edges between them that would create an odd cycle is (number of nodes in component 1) * (number of nodes in component 2) ?\n\nBut how do we know that adding an edge between two components creates an odd cycle?\n\nLet me think. Suppose component 1 has bipartition (A1, A2), component 2 has (B1, B2). Let's say we add an edge between a node in A1 and a node in B1. Then, the new graph's cycle would be: take a path from the node in A1 to another node in A1 (but that's not possible unless there's a cycle). Wait, perhaps the key is that when you connect two bipartite components, the resulting component is not bipartite. Therefore, there must be an odd-length cycle. However, the way to count the number of possible edges that create such a cycle is not straightforward. But perhaps the number of possible edges that can be added between two components is (size of component 1) * (size of component 2) ?\n\nBut how to calculate that for all possible pairs of components?\n\nAlternatively, think of the problem as follows: when the graph is bipartite, the minimal t is 1. The number of ways to add t=1 edges is the sum of:\n\n- All possible edges that can be added within a component between same partitions (for each component, as discussed earlier).\n\nPlus \n\n- All possible edges between different components (each such edge would create an odd cycle).\n\nBut how to calculate that?\n\nWait, but adding any edge between two different components would create an odd cycle. Is that true?\n\nYes. Because if the original graph is bipartite, then each component is bipartitioned. Suppose you have two components. Let's say component X and component Y. Each is bipartitioned into (X1, X2) and (Y1, Y2). Adding an edge between a node in X1 and Y1. Now, the new component is connected. Suppose you have a path from the new edge's node in X1 to any node in X2 (even length), then through the new edge to Y1, then through a path in Y to Y2 (even length), then through another path back to Y1 (but that's not helpful). Alternatively, think of the new edge creating a cycle between the two components. For example, take a node u in X1 and v in Y1. Connect them. Now, take any path from u to another node in X1 (but since X is bipartitioned, any path between u and itself must be even length. Wait, but that's not possible unless there's a cycle. So perhaps this approach isn't working.\n\nAlternatively, think of the two components as trees. Suppose component X is a tree (so bipartitioned), component Y is a tree. Adding an edge between u in X and v in Y. Now, the new graph has a cycle that goes from u to v through the new edge, and then back through the trees. But since the trees are bipartitioned, the path from u to v in the original trees (before adding the edge) would have a certain parity. However, since the two components were separate, there was no path. So perhaps the new edge creates a cycle of length 1 (but that's not possible). Wait, no. The cycle would require a path from u to v through the new edge and then back. But there's no existing path between u and v. So that's not a cycle. Hmm, this is confusing.\n\nWait, earlier example where two components each have two nodes. Adding an edge between them creates a cycle. But how?\n\nIn that example, the two components are each a single edge. Let's take component 1: u-v, component 2: x-y. Adding an edge between u and x. Now, the cycle is u-v-x-u, which is length 3. So that's an odd cycle. So adding an edge between the two components creates a cycle. But how does this fit into the general case?\n\nSo, in general, if you add an edge between two nodes from different components, then you can create a cycle by combining the new edge with paths in each component. But since each component is bipartitioned, the parity of the path length from the nodes to their respective partitions determines the parity of the cycle.\n\nLet me think again. Let's say you have two components. Take any two nodes u and v from different components. Let's say u is in component A, and v is in component B. Suppose component A is bipartitioned into (A1, A2), and component B is bipartitioned into (B1, B2). Now, u is in A1, and v is in B1. Adding the edge u-v. Now, consider the path from u to v through the new edge. But there's no existing path between u and v. However, if you take a path from u to some node in A2 (say, a), then from a to u (length 1?), but that's not helpful. Alternatively, take a path from u to itself (which is zero, but that's not helpful). Wait, perhaps I'm missing something.\n\nWait, the cycle is created by taking the new edge and paths that form a loop. But since the components were disconnected before, the only way to form a cycle is by adding the edge between u and v, and then having a path from v back to u. But that path would require that there's a path in the combined graph. However, since the original components are separate, the only path is the new edge. So that's not a cycle. So what's wrong here?\n\nAh, no. Wait, in the earlier example, adding the edge between u (from component 1) and x (from component 2) allows a cycle of u-v-x-u. But that requires that x is connected to u, and x is connected to y. So the path is u to v (existing edge), then v to x (new edge?), no. Wait, in the example, the new edge is u to x. Then, the cycle is u to x (new edge), then x to y (existing edge), then y to x? No. Wait, the cycle is u connected to x, and x connected to y. But to make a cycle, you need to return to u. How? There's no existing connection between y and u. Oh, but in this example, the component 1 is u connected to v. Component 2 is x connected to y. Adding edge u-x creates a cycle of u-x-y-x-u? No, that's not a cycle. Wait, no, because that would be a cycle of x-y-x, which is not possible. Oh, I'm confused. How did the example earlier create a cycle of length 3?\n\nAh! Oh, no. The cycle is u-v-x-u. So, u to v (existing edge), v to x (no edge), x to u (new edge). Wait, but that's not a path. Oh, right! There's no edge between v and x. So that's not a valid cycle. So my previous reasoning was wrong. What's the correct way?\n\nThis suggests that my earlier assumption was incorrect. So adding an edge between two components may not necessarily create a cycle. So why in the example with two separate edges, adding an edge between u and x creates a cycle?\n\nWait, no. Because if component 1 is u-v, and component 2 is x-y. Adding edge u-x. Then, the cycle would be u-x-y-x-u? No, that's not a cycle. Or u-x and then back to u? No. That's just a single edge. So where is the cycle?\n\nAh! I think I made a mistake here. Adding an edge between u and x does not create a cycle. Because there's no path between u and x before adding the edge. So adding the edge creates a new component, but there's no cycle. So how did I think that there was a cycle earlier?\n\nOh no! So my previous reasoning was completely wrong. Then, how can adding an edge between two components create a cycle?\n\nAh, right! Only when there's already a path between the two nodes. Otherwise, adding an edge between them creates a tree-like structure. So, adding an edge between two components would create a cycle only if there's already a path between the two nodes, but since they are in different components, there is no such path. Therefore, adding an edge between two components would not create a cycle. So my earlier example was wrong. That means that adding an edge between two components does not create a cycle. So the only way to create a cycle is to add an edge within a component.\n\nSo, that changes everything. So, the only way to create a cycle is to add an edge within a component. Thus, in order to create an odd-length cycle, you need to add an edge within a component that connects two nodes in the same bipartition. Because that creates a cycle of odd length.\n\nSo, this brings us back to the original idea: for a bipartite graph, the minimal number of edges to add is 1, provided that there exists at least one connected component with at least two nodes (so that there are two nodes in the same partition). But if all connected components are single nodes (n is the number of nodes, and m is zero), then you need to add edges between them.\n\nWait, but if all connected components are single nodes (so n nodes, each a separate component), then adding an edge between any two nodes would create a cycle? No, because adding an edge between two nodes creates a single edge, which is not a cycle. To create a cycle, you need at least three nodes. So for example, if there are three single-node components, adding three edges between them would form a cycle of length 3. But that would require adding three edges. But the minimal t is 3 in this case?\n\nBut according to the third sample input, which is 3 0 (n=3, m=0). The output is 3 1. So that's correct. Because you need to add three edges to form a cycle. For example, adding edges between 1-2, 2-3, 3-1. So the minimal t is 3.\n\nSo, for the case when the graph is bipartite, the minimal t depends on the structure of the components.\n\nSo, the overall approach is:\n\nCheck if the graph has an odd-length cycle. If yes, then t=0, w=1.\n\nElse:\n\nFor each connected component, determine if it's possible to add an edge within the component to create an odd-length cycle. For that, the component must have at least two nodes. And, the component must have at least two nodes in one of the partitions (since adding an edge between two nodes in the same partition creates an odd-length cycle).\n\nSo, the minimal t is 1 if there exists at least one connected component that has at least two nodes. Otherwise, if all components are single nodes, then the minimal t is 3 (since you need to connect three nodes into a cycle, which requires adding three edges).\n\nWait, but if there are two components (each with one node), then you can't form a cycle. So, you need to add edges to form a cycle. For example, if there are two components (each with one node), then to form a cycle, you need to add two edges. But that would form a multi-edge, which is not allowed. So, no. So, the minimal number of edges needed is 3 when the graph has n ≥3 and all components are single nodes.\n\nSo, for the case when the graph is bipartite, we need to:\n\n- Check if there's at least one connected component with at least two nodes. Let's call this condition C.\n\nIf condition C is true:\n\nThen, the minimal t is 1. The number of ways w is the sum over all connected components of (number of possible edges within the component that connect same partitions) plus the number of possible edges between different components that would create an odd cycle? Or no?\n\nWait, no. Because adding an edge between two components cannot create a cycle. So the only way to create a cycle is to add an edge within a component. Thus, the number of ways is the sum for each component of the number of possible edges that can be added between same partitions.\n\nBut wait, in the sample input where the graph is 4 nodes and 4 edges (the first sample input), the output is 1 2. Let's see.\n\nSample input 1:\n\n4 nodes, 4 edges. Edges are 1-2, 1-3, 4-2, 4-3. Let's see if this graph is bipartite.\n\nLet me try to color the graph. Let's say node 1 is color 0. Its neighbors (2,3) must be color 1. Node 2's neighbors are 1,4. So 4 must be color 0. Node 4's neighbors are 2,3. Node 3 is color 1. So 4 is color 0, which is okay. Then, node 3's neighbors are 1 (color 0) and 4 (color 0). So node 3 is color 1, which is okay. So the graph is bipartitioned into {1,4} and {2,3}. So, the graph is bipartite. So, there's no existing odd cycle. So t is 1. Now, the number of ways is the sum for each component (there is one component here) of (a choose 2 + b choose 2), where a and b are the sizes of the partitions. Here, a is 2 (nodes 1 and 4), b is 2 (nodes 2 and 3). So (2 choose 2) + (2 choose 2) = 1 + 1 = 2. Which matches the sample output of 1 2. So that's correct.\n\nAnother sample input is the third example: 3 0. The graph has three single-node components. So, the graph is bipartite. So, the minimal t is 3. The number of ways is 1 (only one way to add three edges to form a triangle).\n\nSo, the steps for solving the problem are:\n\n1. Check if the graph contains an odd-length cycle. If yes, output t=0 and w=1.\n\n2. Else, the graph is bipartite. We need to compute:\n\n   a. The minimal t and the number of ways.\n\n   b. For this, we need to check if there exists at least one component with at least two nodes. If yes, then t=1. The number of ways is the sum over all components of (a_i choose 2 + b_i choose 2), where a_i and b_i are the sizes of the two partitions of component i.\n\n   c. If there are no components with at least two nodes (i.e., all components are single nodes), then:\n\n      - If n < 3: impossible? But according to the problem statement, the cycle must have more than one vertex. So, for n=1, it's impossible. But the input constraints probably ensure that n is at least 1. However, the problem says that the output must have a valid answer. For example, in the third sample input, n=3, which is possible.\n\n      - So, for n >=3, the minimal t is 3 (adding three edges to form a triangle). The number of ways is 1 (since there's only one way to choose three nodes and connect them into a cycle. However, the problem says that the added edges must form a cycle. So, the number of ways is the number of possible triangles that can be formed by adding edges. But since we can choose any three nodes, and add edges between them to form a triangle. However, the problem says that the way to add edges is considered the same if the set of edges added is the same. So, the number of ways is the number of possible sets of edges that form a cycle of odd length. For the case of three nodes, adding all three edges forms a triangle (which is an odd cycle). So, the number of ways is 1 (since there's only one possible set of edges to add). For example, for n=3, the only way is to add all three edges. Hence, the third sample output is 3 1.\n\nSo, putting this together:\n\nThe algorithm steps are:\n\n- Check if the graph has an odd-length cycle. If yes, output 0 1.\n\n- Else:\n\n   - Check if there are any components with size ≥ 2.\n\n      - If yes:\n\n         - t = 1.\n\n         - Compute w as the sum for each component of (a_i choose 2 + b_i choose 2), where a_i and b_i are the sizes of the two partitions of the component.\n\n      - Else:\n\n         - If n < 3: impossible? But according to the problem statement, the answer must exist. However, the input is guaranteed to be valid. So for example, when n=2, m=0, then the minimal t is 1 (but adding one edge would create a single edge, not a cycle. So this case can't happen. So how to handle this?\n\nWait, for n=2 and m=0. The graph is bipartite. But to form a cycle, you need at least three nodes. So adding any edges won't create a cycle. Thus, in this case, the answer would be t=3 (but n=2, so impossible). So this seems like a contradiction. But according to the problem statement, the graph can be given with any n and m. How to handle this case?\n\nBut according to the problem statement, the answer must exist. So perhaps the input ensures that it's possible to form a cycle. But the problem says nothing about that. So, what's the correct approach here?\n\nLet me think. The problem says that the output must be the minimum number of edges to add to form a simple cycle of odd length. So, for example, if the graph has n=2 and m=0. Then, it's impossible to form a cycle (since a cycle must have at least three nodes). So, what should be the answer?\n\nBut according to the problem statement, the input is such that the answer exists. Because the problem says \"you need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length...\".\n\nBut perhaps the input guarantees that n ≥ 3. Or perhaps not. For example, in the third sample input, n=3. So, for the case when all components are single nodes (n ≥3), then the minimal t is 3. For example, when n=2 and all components are single nodes, then you can't form a cycle. So, what's the answer?\n\nBut according to the problem statement, the input is such that the answer exists. So perhaps the input will have n ≥ 3 when all components are single nodes. But how?\n\nWell, in the code, we need to handle all cases.\n\nSo, for the case when all components are single nodes (i.e., n components, each with 1 node), then:\n\n- If n < 3: then it's impossible to form a cycle. But the problem says that the answer must exist, so perhaps the input will not have this case.\n\n- If n ≥ 3: then, the minimal t is 3. The number of ways is 1. Because you have to choose any three nodes and connect them into a cycle. But how many ways are there?\n\nWait, the number of possible ways to add edges to form a cycle. For example, in the case of n=3, you have to add three edges (each between the three nodes) to form a triangle. There's only one way to do this. So the answer is 3 1.\n\nFor n=4, when all components are single nodes, the minimal t is 3. But there are C(4,3) = 4 ways to choose three nodes, and each way adds three edges. So the number of ways is 4. But according to the problem statement, each way is considered unique if the set of added edges is different.\n\nBut the problem says that the answer for the third sample input (n=3, m=0) is 3 1. Which aligns with this logic.\n\nSo, in the case where all components are single nodes, the minimal t is 3. The number of ways is C(n, 3), since each set of three nodes can be connected into a cycle by adding three edges.\n\nWait, but for each set of three nodes, there is exactly one way to add the three edges (the triangle). So the number of ways is the number of possible triplets of nodes, which is C(n, 3).\n\nBut in the third sample input, n=3, so C(3,3)=1. Which matches the sample output.\n\nSo, for this case, the code needs to compute:\n\nt = 3, w = C(n, 3).\n\nBut how to handle this in code.\n\nSo, putting it all together:\n\nFirst, check if the graph has an odd-length cycle. How to do that?\n\nWe can perform a BFS or DFS for each component, trying to color it as bipartite. If during this process, we find a contradiction (i.e., a node that is already colored with a color conflicting with the expected color), then the graph has an odd-length cycle.\n\nOnce we confirm that the graph is bipartite (no odd cycles), then proceed to check the components.\n\nSo, the steps:\n\nImplement a function to check if the graph is bipartite, and for each component, record the sizes of the two partitions.\n\nIf the graph is not",
    "response": "To solve this problem, we need to determine the minimum number of edges to add to an undirected graph to form a simple cycle of odd length, and the number of ways to achieve this. The solution involves checking if the graph already contains an odd-length cycle and, if not, determining the minimum edges required based on the graph's bipartite properties.\n\n### Approach\n1. **Check for Odd-Length Cycle**: Use BFS to check if the graph contains an odd-length cycle. If it does, the answer is `0 1`.\n2. **Bipartite Graph Handling**: If the graph is bipartite (no odd-length cycles), we need to determine the minimum edges to add:\n   - **Within Components**: For each connected component, calculate the number of ways to add edges between nodes in the same partition of the bipartite component.\n   - **All Single-Node Components**: If all components are single nodes, the minimum edges required to form a cycle is 3, and the number of ways is the combination of choosing 3 nodes from the total nodes.\n\n### Solution Code\n```python\nimport sys\nimport threading\nfrom collections import deque, defaultdict\n\ndef main():\n    sys.setrecursionlimit(1 << 25)\n    n, m = map(int, sys.stdin.readline().split())\n    edges = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        edges[u-1].append(v-1)\n        edges[v-1].append(u-1)\n    \n    color = [-1] * n\n    is_bipartite = True\n    component_partitions = []\n    \n    for start in range(n):\n        if color[start] == -1:\n            queue = deque()\n            queue.append(start)\n            color[start] = 0\n            part0 = 1\n            part1 = 0\n            while queue:\n                u = queue.popleft()\n                for v in edges[u]:\n                    if color[v] == -1:\n                        color[v] = color[u] ^ 1\n                        if color[v] == 0:\n                            part0 += 1\n                        else:\n                            part1 += 1\n                        queue.append(v)\n                    else:\n                        if color[v] == color[u]:\n                            is_bipartite = False\n            component_partitions.append((part0, part1))\n    \n    if not is_bipartite:\n        print(\"0 1\")\n        return\n    \n    has_large_component = False\n    total_ways = 0\n    for a, b in component_partitions:\n        if a + b >= 2:\n            has_large_component = True\n            total_ways += (a * (a - 1)) // 2 + (b * (b - 1)) // 2\n    \n    if has_large_component:\n        print(f\"1 {total_ways}\")\n    else:\n        if n < 3:\n            print(\"0 1\")\n        else:\n            # All components are single nodes\n            # Need to choose 3 nodes to form a triangle\n            # Number of ways is C(n, 3)\n            ways = n * (n - 1) * (n - 2) // 6\n            print(f\"3 {ways}\")\n\nthreading.Thread(target=main).start()\n```\n\n### Explanation\n1. **Odd-Length Cycle Check**: Using BFS, we attempt to color the graph as bipartite. If we find a conflict, it indicates an odd-length cycle.\n2. **Component Analysis**: For each connected component, we track the sizes of the two partitions in its bipartite structure.\n3. **Ways Calculation**: If there's a component with at least two nodes, the number of ways to add edges within the same partition is calculated using combinations. If all components are single nodes, the solution involves forming a triangle using any three nodes, calculated using combinations of nodes.\n\nThis approach efficiently checks for odd cycles and calculates the required edges and ways based on the graph's structure, ensuring optimal performance even for larger inputs.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport threading\nfrom collections import deque, defaultdict\n\ndef main():\n    sys.setrecursionlimit(1 << 25)\n    n, m = map(int, sys.stdin.readline().split())\n    edges = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        edges[u-1].append(v-1)\n        edges[v-1].append(u-1)\n    \n    color = [-1] * n\n    is_bipartite = True\n    component_partitions = []\n    \n    for start in range(n):\n        if color[start] == -1:\n            queue = deque()\n            queue.append(start)\n            color[start] = 0\n            part0 = 1\n            part1 = 0\n            while queue:\n                u = queue.popleft()\n                for v in edges[u]:\n                    if color[v] == -1:\n                        color[v] = color[u] ^ 1\n                        if color[v] == 0:\n                            part0 += 1\n                        else:\n                            part1 += 1\n                        queue.append(v)\n                    else:\n                        if color[v] == color[u]:\n                            is_bipartite = False\n            component_partitions.append((part0, part1))\n    \n    if not is_bipartite:\n        print(\"0 1\")\n        return\n    \n    has_large_component = False\n    total_ways = 0\n    for a, b in component_partitions:\n        if a + b >= 2:\n            has_large_component = True\n            total_ways += (a * (a - 1)) // 2 + (b * (b - 1)) // 2\n    \n    if has_large_component:\n        print(f\"1 {total_ways}\")\n    else:\n        if n < 3:\n            print(\"0 1\")\n        else:\n            # All components are single nodes\n            # Need to choose 3 nodes to form a triangle\n            # Number of ways is C(n, 3)\n            ways = n * (n - 1) * (n - 2) // 6\n            print(f\"3 {ways}\")\n\nthreading.Thread(target=main).start()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 570,
        "completion_token_count": 851,
        "thoughts_token_count": 8192
    }
}