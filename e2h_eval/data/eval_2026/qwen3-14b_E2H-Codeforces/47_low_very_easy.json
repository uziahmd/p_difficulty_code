{
    "start": 1758309416.1082826,
    "end": 1758309667.8394842,
    "start-formatted": "2025-09-20 04:16 KST",
    "end-formatted": "2025-09-20 04:21 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\nOkay, let's see. The problem is to find the smallest non-negative integer k such that the LCM of (a +k) and (b +k) is minimized. And if there are multiple k's with the same minimal LCM, pick the smallest one.\n\nHmm. Let me think about how to approach this. \n\nFirst, let's note that a and b are given, and we need to find k. Let me think about what happens when we add k to both. Let's denote x = a +k and y = b +k. Then, since k is the same for both, the difference between x and y is (a - b). Wait, because x - y = (a +k) - (b +k) = a - b. So, the difference between the two numbers is fixed. Let me call this difference d. Let's say d = a - b. But since a and b can be in any order, maybe I should take absolute value. Let me think: suppose a < b. Then, when we add k, the difference between the two numbers is still (a - b) = -(b - a). But the actual difference between x and y is |a - b|. So, regardless of which is bigger, the difference between the two numbers is fixed as |a - b|.\n\nWait, but for the LCM of two numbers, if they are x and y, then LCM(x,y) = x*y / GCD(x,y). So, to minimize the LCM, we want x and y to be as small as possible, and their GCD as large as possible.\n\nBut since x and y differ by a fixed amount, perhaps the optimal case is when x and y are as small as possible and their GCD is as large as possible. \n\nLet me think. Let me assume that a and b are such that a < b. Then, when we add k, the two numbers are (a +k) and (b +k). Let me call them x and y, where y = x + (b - a). Let's denote d = b - a. So, y = x + d. Then, the LCM of x and x +d is (x*(x+d))/gcd(x, x+d). But since gcd(x, x+d) = gcd(x, d), because gcd(x, x+d) = gcd(x, d). \n\nSo, the LCM becomes x*(x +d)/g, where g is gcd(x, d). \n\nSo, for fixed d, we need to choose x such that this value is minimized. And since x can be any number >= a (since k is non-negative, so x = a +k >=a, and similarly for y). Wait, but if a is larger than b, then d would be negative. So perhaps I should take d as the absolute difference between a and b. Let me rephrase:\n\nLet me define d = |a - b|. Then, the two numbers x and y will differ by d. Let me assume that x is the smaller one. So, if a is smaller than b, then x is a +k, and y is x +d. If a is larger than b, then x is b +k and y is x +d. But regardless, the problem is symmetric. So, without loss of generality, let's assume that a <= b. Then, d = b - a. So, the problem reduces to finding x such that x is >= a (since k >=0 implies x = a +k >=a), and y = x +d, and then find x that minimizes LCM(x, x +d).\n\nBut how do we find such x?\n\nThe LCM is minimized when the numbers are as small as possible, and their GCD is as large as possible. So, for example, if x and x +d are multiples of some number, then their GCD would be larger, leading to a lower LCM.\n\nSo, the minimal LCM occurs when x is such that x and x +d have a large GCD. Let's think about the GCD. Let me denote g = gcd(x, x +d) = gcd(x, d). So, the GCD of x and d. Therefore, if we can choose x such that x is a multiple of a divisor of d, then the GCD would be that divisor. \n\nSo, for example, if d is zero, then x and y are equal. Then, their LCM is x, which is minimized when x is as small as possible. Since d is zero, that means a = b. Then, the minimal k is zero, since adding zero gives a +0 = a, and b +0 = a, so LCM(a,a) =a. Which is the minimal possible. So, in that case, the answer is zero. \n\nBut if d is not",
    "response": "To solve this problem, we need to find the smallest non-negative integer $ k $ such that the least common multiple (LCM) of $ a + k $ and $ b + k $ is minimized. The approach involves leveraging properties of the greatest common divisor (GCD) and the difference between the two input integers.\n\n### Approach\n1. **Difference Calculation**: Calculate the absolute difference $ d $ between the two integers $ a $ and $ b $. This difference remains constant regardless of the value of $ k $.\n2. **Special Case Handling**: If $ a $ and $ b $ are equal, the optimal $ k $ is 0 because both numbers will be the same, resulting in their LCM being the number itself.\n3. **Divisors of Difference**: For non-zero differences, we consider the divisors of $ d $. The optimal $ k $ is found by checking values that make $ a + k $ and $ b + k $ share a large GCD, which reduces the LCM.\n4. **Iterative Check**: By iterating through potential values of $ k $ derived from the divisors of $ d $, we determine the minimum LCM and the corresponding smallest $ k $.\n\n### Solution Code\n```python\nimport math\n\ndef compute_lcm(x, y):\n    return x * y // math.gcd(x, y)\n\ndef find_min_k(a, b):\n    d = abs(a - b)\n    if d == 0:\n        return 0\n    min_lcm = float('inf')\n    best_k = 0\n    # We need to check possible k's that can make (a +k) and (b +k) have a large gcd\n    # Let's consider all divisors of d\n    # The optimal k is such that (a +k) is a multiple of some divisor of d\n    # So, let's generate all divisors of d\n    def get_divisors(n):\n        divisors = set()\n        for i in range(1, int(n**0.5) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                divisors.add(n // i)\n        return divisors\n\n    divisors = get_divisors(d)\n    # For each divisor g of d, we want to find x such that x mod g == 0 and x >= a (assuming a <= b)\n    # Then, x = m * g, and since x = a + k, k = m * g - a\n    # But we need k >= 0 => m * g >= a\n    # Also, since y = x + d, then y = m*g + d, and since x and y differ by d, their gcd is g\n    # So, for each divisor g of d, find the minimal m such that m*g >= a and then compute k\n    # Also, note that for x = m*g, the other number is x + d = m*g + d\n    # But since d = b - a (if a < b), then x + d = a +k + d = b +k\n    # So, the LCM would be (m*g * (m*g + d)) / g = m*(m*g + d)\n    # Which is m*(m*g + d)\n    # But since d = g * (d/g), so m*g + d = m*g + g*(d/g) = g*(m + d/g)\n    # So, LCM is m * g * (m + d/g) = g*m*(m + d/g)\n    # Which is minimized when m is as small as possible\n    # So, for each divisor g of d, compute the minimal m such that m*g >= a\n    # Then compute the corresponding k and LCM\n    # Also, we can do similar for the case when a > b, but since we take absolute difference, it's symmetric\n\n    for g in divisors:\n        # Find minimal m such that m*g >= a (if a < b) or m*g >= b (if a > b)\n        # Since d = |a - b|, and we can assume a <= b without loss of generality\n        # So let's assume a <= b, so the minimal x is a +k >= a\n        # So, m*g >= a => m >= ceil(a / g)\n        m_min = (a + g - 1) // g  # ceil division\n        x = m_min * g\n        k_candidate = x - a\n        y = x + d\n        current_lcm = compute_lcm(x, y)\n        if current_lcm < min_lcm or (current_lcm == min_lcm and k_candidate < best_k):\n            min_lcm = current_lcm\n            best_k = k_candidate\n        # Also check m_min - 1 if it's possible? Wait, no, because m_min is the minimal m where m*g >= a\n        # So m_min -1 would give m*g < a, which would make k negative, which is invalid\n    return best_k\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    for i in range(0, len(input), 2):\n        a = int(input[i])\n        b = int(input[i+1])\n        print(find_min_k(a, b))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Difference Calculation**: The absolute difference $ d $ between $ a $ and $ b $ is calculated to understand how the values change with $ k $.\n- **Divisors of Difference**: By examining the divisors of $ d $, we identify potential values of $ k $ that could maximize the GCD of the modified values $ a + k $ and $ b + k $, thereby minimizing the LCM.\n- **Optimal $ k $**: For each divisor of $ d $, we compute the smallest $ k $ that makes the modified values align with the divisor, ensuring the LCM is minimized. The smallest valid $ k $ is chosen if multiple values yield the same LCM.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef compute_lcm(x, y):\n    return x * y // math.gcd(x, y)\n\ndef find_min_k(a, b):\n    d = abs(a - b)\n    if d == 0:\n        return 0\n    min_lcm = float('inf')\n    best_k = 0\n    # We need to check possible k's that can make (a +k) and (b +k) have a large gcd\n    # Let's consider all divisors of d\n    # The optimal k is such that (a +k) is a multiple of some divisor of d\n    # So, let's generate all divisors of d\n    def get_divisors(n):\n        divisors = set()\n        for i in range(1, int(n**0.5) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                divisors.add(n // i)\n        return divisors\n\n    divisors = get_divisors(d)\n    # For each divisor g of d, we want to find x such that x mod g == 0 and x >= a (assuming a <= b)\n    # Then, x = m * g, and since x = a + k, k = m * g - a\n    # But we need k >= 0 => m * g >= a\n    # Also, since y = x + d, then y = m*g + d, and since x and y differ by d, their gcd is g\n    # So, for each divisor g of d, find the minimal m such that m*g >= a and then compute k\n    # Also, note that for x = m*g, the other number is x + d = m*g + d\n    # But since d = b - a (if a < b), then x + d = a +k + d = b +k\n    # So, the LCM would be (m*g * (m*g + d)) / g = m*(m*g + d)\n    # Which is m*(m*g + d)\n    # But since d = g * (d/g), so m*g + d = m*g + g*(d/g) = g*(m + d/g)\n    # So, LCM is m * g * (m + d/g) = g*m*(m + d/g)\n    # Which is minimized when m is as small as possible\n    # So, for each divisor g of d, compute the minimal m such that m*g >= a\n    # Then compute the corresponding k and LCM\n    # Also, we can do similar for the case when a > b, but since we take absolute difference, it's symmetric\n\n    for g in divisors:\n        # Find minimal m such that m*g >= a (if a < b) or m*g >= b (if a > b)\n        # Since d = |a - b|, and we can assume a <= b without loss of generality\n        # So let's assume a <= b, so the minimal x is a +k >= a\n        # So, m*g >= a => m >= ceil(a / g)\n        m_min = (a + g - 1) // g  # ceil division\n        x = m_min * g\n        k_candidate = x - a\n        y = x + d\n        current_lcm = compute_lcm(x, y)\n        if current_lcm < min_lcm or (current_lcm == min_lcm and k_candidate < best_k):\n            min_lcm = current_lcm\n            best_k = k_candidate\n        # Also check m_min - 1 if it's possible? Wait, no, because m_min is the minimal m where m*g >= a\n        # So m_min -1 would give m*g < a, which would make k negative, which is invalid\n    return best_k\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    for i in range(0, len(input), 2):\n        a = int(input[i])\n        b = int(input[i+1])\n        print(find_min_k(a, b))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 403,
        "completion_token_count": 1290,
        "thoughts_token_count": 1024
    }
}