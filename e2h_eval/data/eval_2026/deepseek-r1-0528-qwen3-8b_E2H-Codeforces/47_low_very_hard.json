{
    "start": 1758296543.4547098,
    "end": 1758299470.8979871,
    "start-formatted": "2025-09-20 00:42 KST",
    "end-formatted": "2025-09-20 01:31 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\n Okay, let's analyze the problem:\n\nWe are given two integers a and b (with 1 <= a, b <= 10^9). We need to find a non-negative integer k such that:\n   LCM(a+k, b+k) is minimized.\n\nNote: If multiple k yield the same minimal LCM, choose the smallest k.\n\nLet d = gcd(a+k, b+k). Then we know:\n   LCM(a+k, b+k) = (a+k)*(b+k) / d.\n\nAlso note that (a+k) - (b+k) = a-b, so the difference between the two numbers is fixed (a-b). Therefore, we can think of the two numbers as two numbers with fixed difference (say D = |a-b|, but actually we can consider without loss of generality by symmetry, but note: if a < b then we have positive difference, etc).\n\nAlternatively, let g = gcd(a+k, b+k). Then g must divide (a-b) because:\n   g divides (a+k) and (b+k), so it divides their difference (a-b).\n\nSo, g must be a divisor of |a-b|.\n\nNow, let d = |a-b|. Then for each divisor g of d, we can set k such that g divides both (a+k) and (b+k). This is equivalent to:\n   k ≡ (-a) mod g   and   k ≡ (-b) mod g.\n\nBut note: since g divides (a-b), then (-a) mod g is the same as (-b) mod g? Actually, because (a-b) is divisible by g, we have a ≡ b (mod g). So the condition for k is just k ≡ (-a) mod g (which is the same as k ≡ (-b) mod g).\n\nHowever, note: if a and b are the same, then d=0, and we have to consider separately. But the problem says a, b >= 1, so we can handle d=0 as a special case.\n\nBut note: when a==b, then the two numbers are the same. Then LCM(a+k, a+k) = a+k. We want to minimize a+k, so k=0.\n\nNow, in general, for each divisor g of d (where d = |a-b|), we can set k to be the smallest non-negative integer such that:\n   k ≡ (-a) mod g   => k = (g - a % g) % g   [but wait, if a % g == 0, then k=0? Actually, we require (a+k) % g == 0, so k = (g - (a % g)) % g, but if a % g ==0 then k=0.\n\nHowever, note that there might be multiple divisors and we are to choose the k that minimizes the LCM. But note: the LCM is (a+k)*(b+k)/g. Since g divides both, we can write:\n\n   Let x = a+k, then b+k = x + (b-a). Then the LCM is |x * (x + (b-a))| / gcd(x, x+(b-a)).\n\nBut note: the gcd(x, x+d) where d = b-a is the same as gcd(x, |d|). And we know that g (the gcd) must divide |d|.\n\nBut also note: the value of k we choose must satisfy that g divides (a+k) and (b+k). The candidate k for a divisor g is the smallest non-negative k satisfying k ≡ (-a) mod g. However, note that the same k might be generated by multiple divisors? And we are to consider all divisors of d.\n\nBut note: the LCM formula: \n   LCM(x, y) = (x*y) / gcd(x,y)\n\nWe can express x = a+k, and y = b+k. Then the product is (a+k)*(b+k). The denominator is g, so we want to minimize (a+k)*(b+k)/g.\n\nBut note: k is determined by g: k = (g - (a % g)) % g. However, we must note that this k might not be the only one for a given g? Actually, for a fixed g, k is uniquely determined modulo g. The minimal nonnegative k is k0 = (g - a % g) % g. But note: if a % g != 0, then k0 = g - (a % g). Otherwise k0=0.\n\nBut wait: what if we take k0 + t*g for any t>=0? Then the LCM would be the same because the two numbers become multiples of g (so the gcd might actually be more than g). However, we are assuming that the gcd is exactly g? Not necessarily:",
    "response": "\nTo solve this problem, we need to find a non-negative integer \\( k \\) such that the least common multiple (LCM) of \\( a+k \\) and \\( b+k \\) is minimized. If multiple values of \\( k \\) yield the same minimal LCM, we should choose the smallest \\( k \\).\n\n### Approach\n1. **Problem Analysis**: The key observation here is that the difference between \\( a+k \\) and \\( b+k \\) is constant (\\( a - b \\)). Therefore, the greatest common divisor (GCD) of \\( a+k \\) and \\( b+k \\) must be a divisor of \\( |a - b| \\). This insight allows us to consider all divisors of \\( |a - b| \\) to determine potential values of \\( k \\).\n\n2. **Special Case Handling**: If \\( a \\) and \\( b \\) are equal, the LCM of \\( a+k \\) and \\( a+k \\) is simply \\( a+k \\). The smallest value occurs when \\( k = 0 \\).\n\n3. **General Case**: For each divisor \\( g \\) of \\( |a - b| \\), compute the smallest non-negative \\( k \\) such that \\( g \\) divides both \\( a+k \\) and \\( b+k \\). This \\( k \\) is given by \\( k = (g - (a \\% g)) \\% g \\). For each such \\( k \\), compute the LCM of \\( a+k \\) and \\( b+k \\) and keep track of the minimal LCM encountered.\n\n4. **Efficiency**: The algorithm efficiently checks all divisors of \\( |a - b| \\), which for numbers up to \\( 10^9 \\) involves checking up to \\( O(\\sqrt{d}) \\) divisors, where \\( d \\) is \\( |a - b| \\). This ensures the solution is feasible within the problem constraints.\n\n### Solution Code\n```python\nimport math\nfrom math import gcd\n\ndef main():\n    data = input().split()\n    a = int(data[0])\n    b = int(data[1])\n    \n    if a == b:\n        print(0)\n        return\n        \n    d = abs(a - b)\n    divisors = set()\n    i = 1\n    while i * i <= d:\n        if d % i == 0:\n            divisors.add(i)\n            divisors.add(d // i)\n        i += 1\n        \n    best_k = 0\n    best_lcm = (a + b + abs(a - b)) // gcd(a + b, abs(a - b))\n    \n    for g in divisors:\n        k = (g - a % g) % g\n        x = a + k\n        y = b + k\n        current_gcd = gcd(x, y)\n        current_lcm = (x * y) // current_gcd\n        \n        if current_lcm < best_lcm:\n            best_lcm = current_lcm\n            best_k = k\n            \n    print(best_k)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Input Handling**: The code reads two integers \\( a \\) and \\( b \\) from standard input.\n2. **Special Case Check**: If \\( a \\) and \\( b \\) are equal, it immediately outputs \\( 0 \\) since the LCM is minimized at \\( k = 0 \\).\n3. **Divisor Calculation**: For the general case, the code calculates all divisors of \\( |a - b| \\) by iterating up to the square root of \\( |a - b| \\). Each divisor and its complement are added to a set to avoid duplicates.\n4. **Finding Minimal LCM**: For each divisor \\( g \\), the code computes the smallest \\( k \\) such that \\( g \\) divides both \\( a+k \\) and \\( b+k \\). It then calculates the LCM for these values and updates the minimal LCM found along with the corresponding \\( k \\).\n5. **Output**: The smallest \\( k \\) that results in the minimal LCM is printed.\n\nThis approach efficiently narrows down the search space to the divisors of \\( |a - b| \\), ensuring optimal performance even for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\nfrom math import gcd\n\ndef main():\n    data = input().split()\n    a = int(data[0])\n    b = int(data[1])\n    \n    if a == b:\n        print(0)\n        return\n        \n    d = abs(a - b)\n    divisors = set()\n    i = 1\n    while i * i <= d:\n        if d % i == 0:\n            divisors.add(i)\n            divisors.add(d // i)\n        i += 1\n        \n    best_k = 0\n    best_lcm = (a + b + abs(a - b)) // gcd(a + b, abs(a - b))\n    \n    for g in divisors:\n        k = (g - a % g) % g\n        x = a + k\n        y = b + k\n        current_gcd = gcd(x, y)\n        current_lcm = (x * y) // current_gcd\n        \n        if current_lcm < best_lcm:\n            best_lcm = current_lcm\n            best_k = k\n            \n    print(best_k)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 397,
        "completion_token_count": 899,
        "thoughts_token_count": 1023
    }
}