{
    "start": 1758300270.2227912,
    "end": 1758304119.2787664,
    "start-formatted": "2025-09-20 01:44 KST",
    "end-formatted": "2025-09-20 02:48 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\n Okay, let's break down the problem.\n\n We are given an integer p (0 <= p <= 200000). We need to find:\n  1. The minimum number of nodes n such that there exists a directed graph with n nodes that is p-reachable.\n     - A graph is p-reachable if it contains exactly p ordered pairs (u, v) with u < v and u and v are mutually reachable.\n\n  2. Among all such graphs with n nodes, we need to maximize the number of unidirectional pairs (u, v) (with u != v, path from u to v but not from v to u).\n\n Observation:\n\n In a directed graph, mutual reachability (i.e., strongly connected components) is important.\n\n Let the graph have k strongly connected components (SCCs). Then, the entire graph is a DAG of these SCCs.\n\n For two distinct nodes u and v, they are mutually reachable only if they lie in the same SCC (and then we consider the condition for being in the same SCC). However, note the problem says: \n   \"exactly p ordered pairs (u, v) such that u < v and u and v are reachable from each other\"\n\n But note: the condition for mutual reachability is symmetric, so if (u,v) is mutual then (v,u) is also mutual. However, the problem counts only the pairs with u < v. So we are counting each mutual pair once (by ordering by node index?).\n\n Actually, the problem does not specify the node indices, but we are free to assign the graph structure arbitrarily. However, note that the definition of unidirectional pairs uses node indices (u != v) and the condition on paths.\n\n How do we relate the number of mutual pairs (p) to the SCCs?\n\n Let the graph have k SCCs. Then, the entire graph has k nodes (each SCC being a supernode) in a DAG. The mutual pairs (u, v) must be within the same SCC. \n\n In fact, the condition for a mutual pair (u, v) is that u and v are in the same SCC. But note: the entire graph might have multiple SCCs. However, the problem does not require that the graph is connected as a whole, but just that the number of mutual pairs (with u < v) is exactly p.\n\n Now, how do we count the mutual pairs? Each SCC of size s contributes C(s,2) = s*(s-1)//2 mutual pairs (since every two distinct nodes in the SCC are mutually reachable). But wait: the problem states that the graph is p-reachable, meaning the total number of pairs (u, v) with u < v and mutually reachable is p.\n\n However, note: the problem does not require that the entire graph is one SCC. It can have multiple SCCs, and the mutual pairs are counted only within an SCC.\n\n Therefore, if we let the graph have SCCs of sizes s1, s2, ..., sk, then the total mutual pairs is:\n   p_total = sum_{i=1}^{k} [ s_i*(s_i-1)//2 ]\n\n We are allowed to choose the graph arbitrarily (so we can arrange the SCCs arbitrarily). We want to minimize the total number of nodes (which is n = s1 + s2 + ... + sk) such that the sum of the combinations (for each SCC) is at least p? Actually, we must have exactly p? \n\n But note: the problem says \"exactly p\".\n\n However, we can choose the sizes arbitrarily (as long as the sum is n). So we are to represent p as a sum of triangular numbers (the triangular numbers being T(s) = s*(s-1)//2) and minimize n (the total nodes) which is the sum of the sides of the triangles.\n\n Actually, we can use as many SCCs as we wish, but the graph must be built with the minimal total nodes.\n\n We are to find the minimal n (total nodes) such that there exists a set of positive integers {s1, s2, ..., sk} (each >=1) with:\n   T(s1) + T(s2) + ... + T(sk) = p   and n = s1+s2+...+sk.\n\n However, note: the triangular numbers for s=1: T(1)=0, s=2: T(2)=1, s=3: T(3)=3, etc.\n\n But wait: we don't necessarily have to use distinct SCCs? Actually, the graph can have as many SCCs as we want. However, the entire graph must have exactly p mutual pairs (counted by the pairs (u,v) with u<v that are mutually reachable). Since the mutual pairs are entirely determined by the SCCs, we can think of decomposing p into a sum of triangular numbers (each T(s) for s>=1).\n\n However, note that the problem does not require that the graph is built from disjoint SCCs (which it is) and that the entire graph has no edges between SCCs (which is the case in a DAG of SCCs). But the mutual pairs are only within an SCC.\n\n Therefore, the problem reduces to: Represent p as a sum of triangular numbers (allowing repetitions) and minimize the total nodes (which is the sum of the sides of the triangles). \n\n But note: we are allowed to have multiple SCCs of the same size? Yes, because we can have multiple copies.\n\n However, the minimal total nodes would be achieved by using as large triangular numbers as possible (since a larger triangular number gives more mutual pairs per node). \n\n Example: p=3. \n   We can use one triangle of size 3: T(3)=3, then n=3.\n   Alternatively, we can use three triangles of size 2: T(2)=1, so 1+1+1=3, then n=2+2+2=6 -> which is worse.\n\n So we want to use as few and as large SCCs as possible.\n\n But note: the triangular numbers are defined for s>=1. The triangular number for s is T(s)=s*(s-1)//2.\n\n Steps for part 1: Find the minimal n (total nodes) such that there exists a decomposition of p into a sum of triangular numbers (each T(s) for some s>=1) and the sum of the s's is n.\n\n Alternatively, we can think: We want to minimize the total nodes n = s1+s2+...+sk, subject to T(s1)+T(s2)+...+T(sk)=p.\n\n However, note: the problem says \"exactly p\", so we must represent p exactly.\n\n We can use dynamic programming? But p can be up to 200000, and the side length s can be up to about sqrt(2*p) (since T(s) ~ s^2/2, so s ~ sqrt(2*p)), which is about sqrt(400000) ~ 632.\n\n But note: we are allowed to use multiple SCCs arbitrarily. We want to minimize the total nodes.\n\n Alternate approach: We can use a greedy-like method. Notice that the efficiency of an SCC of size s is that it provides T(s) mutual pairs and uses s nodes.\n\n We want to minimize the total nodes for a fixed p (mutual pairs). This is similar to the coin change problem but minimizing the total value (nodes) for a fixed amount (p) and coins being triangular numbers.\n\n However, we are allowed to use any triangular number (any s>=1) and we can use unlimited supply.\n\n But note: the triangular numbers are not all distinct and they are increasing with s. The triangular numbers for s=1:0, s=2:1, s=3:3, s=4:6, ... \n\n Since we want to minimize the total nodes (n) for a given p, we should use as many large triangular numbers as possible (like the greedy algorithm for coin change when the coins are canonical). However, triangular numbers are not necessarily a canonical system. But note: the triangular numbers are increasing and the gaps between consecutive triangular numbers are increasing. However, we cannot use fractional coins.\n\n But observe: we can use multiple SCCs of the same size. We can use DP, but note p up to 200000, and the maximum s we need is about floor((1+sqrt(1+8*p))/2) (from solving s(s-1)/2 <= p). For p=200000, s_max is about ceil((1+sqrt(1+1600000))/2) ~ (1+sqrt(1600001))//2 ~ (1+1265)/2 ~ 633.\n\n So we have about 633 different types of coins (triangular numbers). And p up to 200000. We can do a DP with state dp[i] = minimal total nodes to achieve i mutual pairs.\n\n However, 200000 states and 633 coin types: 200000*633 ~ 126.6e6, which is acceptable in C++ but in Python we have to be cautious. But note: the triangular numbers are not too many, but we must generate them.\n\n Alternatively, we can use mathematical insight.\n\n Insight: We know that the graph must have exactly p mutual pairs, and the mutual pairs are the sum of the triangular numbers of the SCCs. We are allowed to break p arbitrarily into triangular numbers.\n\n The minimal total nodes for representing p as a sum of triangular numbers is achieved by using as many large triangular numbers as possible.\n\n But note: we can also use multiple SCCs. However, the triangular numbers are fixed.\n\n We can use a greedy method: Start with the largest triangular number T(s) <= p, then subtract T(s) from p and add s to the total nodes, and repeat.\n\n However, is the greedy method optimal? The greedy method for coin change is optimal for canonical systems. But the system of triangular numbers is not necessarily canonical.\n\n Example: Consider p=2. \n   Triangular numbers: T(1)=0, T(2)=1, T(3)=3 (too big). So we can use two T(2): 1+1=2, then total nodes=2+2=4.\n   But is there a better way? There is no other way. So minimal n=4.\n\n However, consider p=4.\n   Option 1: Use two T(3)? But T(3)=3, so two T(3) would be 6, too big.\n   Option 2: Use four T(2): 4 mutual pairs, then n=8.\n   Option 3: Use one T(3) and two T(2): 3 + 1 + 1 = 5, which is >4 -> invalid.\n   Actually, we need exactly 4. So we cannot use T(3) because then we get at least 3 and then we have 1 left which requires one T(2) but then total mutual pairs becomes 4, and nodes = 3+2=5.\n\n   Alternatively, we can use four T(2): 4 mutual pairs, nodes=8.\n\n   But wait, is there a triangular number for 4? T(4)=6, too big. So the only way is to use four T(2). But that gives n=8.\n\n   However, consider: can we use a single SCC of size 4? Then T(4)=6, which is too big. So we cannot.\n\n   Another idea: use an SCC of size 3 and then an SCC of size 1? Then mutual pairs: T(3)=3 and T(1)=0, total 3, not 4.\n\n   So the minimal n is 8.\n\n   But wait, what about using two SCCs of size 2 and one SCC of size 2? That doesn't help.\n\n   Actually, we can use multiple SCCs arbitrarily. The condition is that the entire graph has exactly p mutual pairs (each mutual pair is within an SCC). \n\n   However, note: the problem does not require that the graph is connected. We can have multiple disconnected SCCs.\n\n   Now, is there another representation? We are allowed to break p arbitrarily.\n\n   But note: the triangular numbers are fixed. The set of triangular numbers is {0,1,3,6,10,...}. We need to represent 4 as a sum of these numbers. Since 4 is not in the set and 3+? -> 3+1=4 (but 1 is T(2)). Then we have two SCCs: one of size 3 and one of size 2, and the mutual pairs are 3 (from the SCC of size 3) and 1 (from the SCC of size 2) so total 4. Then total nodes = 3+2=5.\n\n   Why did I miss that? Because I thought we were using T(3) and T(2) together. So the representation is: 3+1=4.\n\n   So the minimal n for p=4 is 5.\n\n   How did I get 8 earlier? Because I considered only using T(2) four times. But we can mix.\n\n   So we need to use the minimal total nodes (the sum of the s_i) to represent p as the sum of triangular numbers (each T(s_i)).\n\n   We can use dynamic programming to compute the minimal total nodes for each p from 0 to p_max (200000). \n\n   Steps for DP:\n\n   Let dp[i] = minimal total nodes required to represent i mutual pairs (i.e., the sum of the triangular numbers equals i). Then:\n\n   dp[0] = 0   (using no SCC, or using SCCs that are singletons? Actually, we can have SCCs of size 1 which contribute 0, so we can ignore them? But note: we are allowed to use as many as we want.)\n\n   Then for each j from 1 to p (or to the maximum p=200000), we set:\n        dp[j] = min_{s>=2, T(s) <= j} { dp[j - T(s)] + s }\n\n   But note: we can also use an SCC of size 1 (which gives T(1)=0 and uses 1 node) but that doesn't help the mutual pairs. However, if we use an SCC of size 1, then we are adding 0 to the mutual pairs and 1 to the nodes. So we can also consider:\n\n        dp[j] = min( dp[j], dp[j] (if we don't use any new SCC) ) but we are building from 0.\n\n   Actually, we can iterate over the triangular numbers (which are T(s) for s from 2 up to s_max, where T(s) <= 200000). Then for each j from T(s) to p, update dp[j] = min(dp[j], dp[j - T(s)] + s)\n\n   However, we must also consider that we can use multiple SCCs of size 1. But note: an SCC of size 1 does not contribute to mutual pairs. So if we have a representation for j mutual pairs, then we can add as many singleton nodes as we want without affecting j. But wait, the problem requires exactly p mutual pairs. So we cannot arbitrarily add singleton nodes because they don't help and they increase the total nodes. However, the minimal representation does not include any singleton? Actually, we can use a singleton node (size 1) and it adds 0 to the mutual pairs, but increases the total nodes by 1. So if we have a representation for j mutual pairs with total nodes n, then we can add k singleton nodes and the total nodes becomes n+k, and the mutual pairs remains j. Therefore, the minimal representation for j mutual pairs (without considering singletons) is the base, and then we don't need to add singletons because we are free to choose the graph arbitrarily. But note: the problem does not require that the graph is minimal in terms of edges or anything else, only the number of nodes.\n\n   However, the problem is asking for the minimal number of nodes to achieve exactly p mutual pairs. We can break p arbitrarily, and we are allowed to have extra nodes (singletons) but that would only increase the total nodes. So we want the minimal total nodes (ignoring singletons) and then we cannot avoid having the singletons? Actually, we don't need to add singletons because the mutual pairs are already achieved by the non-singleton SCCs. But the graph must have the SCCs and the singletons are separate. However, the minimal representation (without singletons) already gives a total number of nodes (say n0). Then if we use that representation and no singletons, the graph has n0 nodes. If we use the same representation and add k singletons, the graph has n0+k nodes. Since we are looking for minimal nodes, we don't want to add any singleton.\n\n   But wait: the problem does not say that the graph must be connected. We are allowed to have multiple SCCs (including singletons). However, the mutual pairs are only from the non-singleton SCCs. So we can have:\n\n        total_nodes = (sum of sizes of non-singleton SCCs) + (number of singleton SCCs)\n\n   and the mutual pairs = (sum of T(s) for non-singleton SCCs).\n\n   Therefore, the minimal total nodes is the minimal representation of p as a sum of triangular numbers (each T(s) for s>=2) and then we don't add any singleton.\n\n   However, note: we can also use an SCC of size 1 (which is a singleton) but that doesn't help the mutual pairs. So we only use SCCs of size>=2 for the mutual pairs.\n\n   Therefore, we can design our DP for j from 0 to p, and we consider only triangular numbers T(s) for s>=2 (so T(s) >=1). Then:\n\n        dp[0] = 0   (no SCCs, so 0 nodes)\n        For j from 1 to p:\n            dp[j] = a very large number (inf)\n\n        Precompute all triangular numbers T(s) for s from 2 to s_max (where T(s) <= 200000). Let A be the list of T(s) for s from 2 to s_max.\n\n        Then for each t in A (which is T(s)) and for j from t to p:\n            dp[j] = min(dp[j], dp[j-t] + s)   # but wait, we don't have s stored per triangular number? \n\n   Alternatively, we can store the triangular numbers and their corresponding s.\n\n   Steps:\n\n        s_min = 2\n        s_max = 1\n        while T(s_max) <= 200000:\n            s_max += 1\n        Then s_max is about 633.\n\n        Then we have an array A of (t, s) for s from 2 to s_max, where t = s*(s-1)//2.\n\n        Then we do:\n\n        dp = [10**9]*(p+1)\n        dp[0] = 0\n        for t_val, s_val in A:\n            for j in range(t_val, p+1):\n                dp[j] = min(dp[j], dp[j-t_val] + s_val)\n\n        Then the minimal total nodes is dp[p].\n\n   But wait: is this correct? Let's test with p=3 and p=4.\n\n        p=3: \n            We have A: \n                s=2: t=1, s=3: t=3, s=4: t=6 (skip since 6>3)\n            Then:\n                dp[0]=0\n                For t_val=1 (s_val=2): \n                    j from 1 to 3: \n                        dp[1] = min(inf, dp[0]+2) = 2\n                        dp[2] = min(inf, dp[1]+2)= 2+2=4\n                        dp[3] = min(inf, dp[2]+2)= 4+2=6\n                Then for t_val=3 (s_val=3):\n                    j from 3 to 3:\n                        dp[3] = min(6, dp[0]+3)= min(6,3)=3.\n\n            So dp[3]=3 -> which is correct.\n\n        p=4:\n            We have the same A (only s=2 and s=3).\n            After processing t_val=1 (s_val=2): \n                dp[0]=0, dp[1]=2, dp[2]=4, dp[3]=6, dp[4]=8 (from 4: dp[4] = dp[2] (which is 4) + 2 = 6? Wait, no:\n\n            Actually, the inner loop for t_val=1 (s_val=2) goes from 1 to 4:\n                dp[1] = 2\n                dp[2] = dp[0]+2 = 2 (if we start from 0) OR wait, we are iterating in increasing order of j. But the standard way is to use the same triangular number repeatedly. However, we are using a list of triangular numbers and then doing a knapSack style.\n\n            But note: the above DP is unbounded knapSack (we can use unlimited coins). So we are allowed to use multiple of the same triangular number.\n\n            However, the above code does:\n\n                for each triangular number (t_val, s_val) in A:\n                    for j from t_val to p:\n                        dp[j] = min(dp[j], dp[j-t_val] + s_val)\n\n            This is the standard unbounded knapSack for minimal total weight (here weight is s_val, and the value is the triangular number t_val) but we are minimizing the total nodes (weight) for achieving total value p.\n\n            But wait: we are not storing the minimal representation for each j. We are doing:\n\n                dp[j] = minimal total nodes (sum of s) to achieve j mutual pairs, using the triangular numbers.\n\n            Then for p=4:\n\n                First, process t_val=1 (s_val=2):\n                    j=1: dp[1]=min(inf, dp[0]+2)=2\n                    j=2: dp[2]=min(inf, dp[1]+2)=4\n                    j=3: dp[3]=min(inf, dp[2]+2)=6\n                    j=4: dp[4]=min(inf, dp[3]+2)=8\n\n                Then process t_val=3 (s_val=3):\n                    j=3: dp[3]=min(6, dp[0]+3)=min(6,3)=3\n                    j=4: dp[4]=min(8, dp[1]+3)=min(8, 2+3)=5\n\n            So dp[4]=5, which is correct.\n\n        Therefore, the DP works.\n\n   However, note: the triangular numbers are not necessarily distinct in the sense that we can use the same triangular number multiple times. But the above DP does allow multiple uses because we are iterating over all triangular numbers and then for j from t_val to p, so the same triangular number can be used repeatedly.\n\n   But note: the list A contains each triangular number only once. The standard unbounded knapSack style requires that we do a forward iteration for each coin. Alternatively, we can do:\n\n        for j in range(t_val, p+1):\n            dp[j] = min(dp[j], dp[j-t_val] + s_val)\n\n   This allows using the same triangular number multiple times. But note: the above inner loop for a fixed (t_val, s_val) does a complete iteration from t_val to p, and then we move to the next. This is the standard way for unbounded knapSack.\n\n   But note: the problem says we can use any number of SCCs of any size. So yes, we can use multiple SCCs of the same size.\n\n   However, the time complexity: we have about 633 triangular numbers, and for each we iterate from t_val to p (which is 200000). The worst-case t_val is 1 (for s=2) and then we iterate 200000 steps. Then the total operations is about 633 * (average length) but the average length for each triangular number is (p - t_val) / 1, so the total operations is about 633 * (p) = 633 * 200000 = 126.6e6, which is acceptable in C++ but in Python we might need to optimize.\n\n   However, 126.6e6 iterations in Python might be borderline in speed (in PyPy/C++ it's fast, but in Python we might need to use faster loops or use a different approach).\n\n   Alternatively, we can use a bounded knapSack and use the fact that the triangular numbers are increasing. But we are doing unbounded, so we can use the above.\n\n   But note: the problem constraints say p up to 200000, and we have 633 triangular numbers. 633 * 200000 is 126.6e6, which is acceptable in Pyton in many cases (if we use a compiled language, but in Python we hope that the inner loop is in C and fast). Let's code and see.\n\n   However, note that the triangular numbers are increasing and we can break early for large t_val? Actually, we are iterating j from t_val to p, so the inner loop for a given triangular number t_val runs (p - t_val + 1) steps. The total work is the sum_{t_val in A} (p - t_val + 1). The smallest t_val is 1 (for s=2) and the largest t_val is the last triangular number <=200000. The number of triangular numbers is about 633, and the smallest t_val is 1, then 3, then 6, ... so the total work is about 633 * (p) (worst-case) but actually the triangular numbers are increasing, so the first few (small) triangular numbers will have large ranges (from 1 to p) and the last ones (large) will have small ranges (from t_val to p). But the total work is still O(|A| * p) which is 633 * 200000 = 126.6e6, which is acceptable in Pyton if we use efficient loops.\n\n   Let's code the DP and then check for p=0, p=1, p=2, etc.\n\n   Edge: p=0 -> then dp[0]=0, so minimal nodes=0. Then the second part: the maximum number of unidirectional pairs.\n\n   But wait: the problem says \"minimum number of nodes required\" and then \"among all such graphs with the minimum number of nodes, the maximum number of unidirectional pairs\".\n\n   Now, what is the maximum number of unidirectional pairs?\n\n   We are to build a graph with n nodes (the minimal n we found, say n0) and having exactly p mutual pairs (so the SCC decomposition must yield exactly p mutual pairs). Additionally, we can have any graph structure (as long as the mutual pairs are p). We want to maximize the number of unidirectional pairs.\n\n   What are the unidirectional pairs? (u, v) with u != v, there is a path from u to v but not from v to u.\n\n   Note: the entire graph has n nodes. The graph is built from the SCCs and the DAG between them.\n\n   How do we count unidirectional pairs?\n\n   There are two types of pairs (u, v):\n\n     1. Within an SCC: In an SCC, by definition, every node is reachable from every other node. Therefore, there are no unidirectional pairs within an SCC.\n\n     2. Between two different SCCs (say component A and component B, and assume the graph is a DAG of SCCs): \n          - If there is an edge from A to B, then for every u in A and v in B, the path from u to v exists, but the reverse (from v to u) does not (because the graph is a DAG and we don't have cycles between A and B). Similarly, if there is no edge from A to B, then the reverse (from B to A) might exist? Actually, if there is an edge from B to A, then the reverse path exists (from B to A) and then (u in A, v in B) is not unidirectional. But wait, if we have an edge from A to B, then we have paths from A to B, but no path from B to A (unless there is a cycle, but the graph is a DAG of SCCs, so no cycles between different SCCs). Therefore, the direction of the edges between SCCs must form a DAG.\n\n        Therefore, for two SCCs A and B, if there is an edge from A to B (at least one edge) then for every u in A and v in B, (u, v) is unidirectional (because u->v exists and v->u does not). Similarly, if there is an edge from B to A, then (v, u) is unidirectional (but that's a different pair). \n\n        But note: the problem counts (u, v) with u != v. So we consider ordered pairs.\n\n        Therefore, the unidirectional pairs are:\n\n          For every ordered pair of distinct SCCs (A, B) (with A and B being distinct SCCs) and for every u in A and v in B, the pair (u, v) is unidirectional if and only if there is an edge from A to B (in the DAG) and not from B to A (which is given by the DAG property: either no edge from B to A, or if there is then we don't count (u, v) from A to B? Actually, no: the definition of unidirectional is independent of the existence of edges from B to A. The definition says: there is a path from u to v and no path from v to u.\n\n        In our graph, the entire graph is built from the SCCs and the edges between them. The mutual reachability is only within an SCC. Between two SCCs, the reachability is determined by the DAG. Specifically, if there is a path from A to B (via the DAG) then every node in A can reach every node in B. Similarly, if there is a path from B to A, then every node in B can reach every node in A.\n\n        Therefore, for two distinct SCCs A and B:\n\n          - If there is a path from A to B and no path from B to A, then for every u in A and v in B, (u, v) is unidirectional.\n\n          - If there is a path from B to A and no path from A to B, then for every u in A and v in B, (u, v) is not unidirectional (because there is a path from v to u via the DAG? Actually, no: the definition requires no path from v to u. But if there is a path from B to A, then from v (in B) to u (in A) there is a path, so (u, v) is not unidirectional. However, (v, u) would be unidirectional if there is no path from u to v (which is true because there is no path from A to B). But note: the definition counts (u, v) with u != v and requires a path from u to v and no path from v to u.\n\n          - If there are two-way paths (both from A to B and from B to A) then the entire set {A, B} becomes one SCC? No, because if there is a path from A to B and from B to A, then we can merge A and B into one SCC. So in a proper SCC decomposition, there are no two-way paths between distinct SCCs. Therefore, the DAG between SCCs is acyclic and the edges go in one direction.\n\n        Therefore, the DAG between SCCs is oriented: for any two distinct SCCs, there is at most one directed edge (in the condensation graph) between them? Actually, no: there can be multiple edges, but the condensation graph is a DAG and we can have multiple edges. However, the reachability is determined by the existence of a directed path.\n\n        So the key point: in the condensation graph, if there is a path from A to B, then (u, v) (for u in A and v in B) is unidirectional. Similarly, if there is a path from B to A, then (v, u) is unidirectional.\n\n        But note: we cannot have both a path from A to B and from B to A, because then A and B would be in the same SCC.\n\n        Therefore, the condensation graph is a DAG and we can assign a topological order. Then, for two distinct SCCs, either A is before B (then there is a path from A to B) or B is after A (then there is a path from B to A) but not both.\n\n        Actually, in a DAG, for two distinct nodes (SCCs) there is a directed path from one to the other or not? Not necessarily: the DAG might not have a path between two nodes.\n\n        But note: the graph must be built from the SCCs. The problem does not require the condensation graph to be connected. So we can have multiple connected components in the condensation graph? Actually, no: the condensation graph is the DAG of SCCs, and if the original graph is not strongly connected, the condensation graph may have multiple connected components? Actually, the condensation graph is a DAG and it is not necessarily connected (it can have multiple weakly connected components? Actually, no: the condensation graph is the quotient graph of the original graph by its SCCs, and it is a DAG. It is connected as a DAG? Not necessarily: there can be multiple connected components (in the sense of the underlying undirected graph) but the DAG might not have edges between them. So the condensation graph is a DAG and it may be disconnected (i.e., several connected components, each being a DAG).\n\n        However, note: the mutual pairs are fixed by the SCCs. The unidirectional pairs come from the edges in the condensation graph.\n\n        How to maximize the unidirectional pairs?\n\n        We have fixed the SCCs (their sizes and the total nodes n0). We can arrange the edges between the SCCs arbitrarily (as long as the condensation graph is a DAG). \n\n        The total number of ordered pairs (u, v) (with u != v) is n0*(n0-1). \n\n        The graph is divided into k SCCs (with sizes s1, s2, ..., sk). The mutual pairs are fixed (p). The remaining pairs (n0*(n0-1) - 2*p) are not mutual. However, note: the mutual pairs are only the pairs (u, v) with u and v in the same SCC (and u < v). But wait, the problem counts mutual pairs as (u, v) with u < v. However, the total number of mutual pairs (unordered pairs) is p, but the total number of ordered pairs (u, v) with u != v and mutual is 2*p (because each unordered pair {u,v} gives two ordered pairs (u,v) and (v,u) that are mutual). But wait, the problem defines:\n\n          \"exactly p ordered pairs of nodes (u, v) such that u < v and u and v are reachable from each other\"\n\n        So the mutual pairs (as ordered pairs with u<v) is p. Then the total mutual pairs (considering both orders) is 2*p (because if (u,v) is mutual then (v,u) is mutual, and they are distinct if u != v). But wait, the problem does not count (v,u) because the condition u < v. So the total mutual pairs (ordered) is 2*p.\n\n        Then the total number of ordered pairs (u, v) (u != v) is n0*(n0-1). \n\n        Then the number of non-mutual ordered pairs (u, v) is n0*(n0-1) - 2*p.\n\n        Now, the unidirectional pairs are a subset of the non-mutual pairs. Specifically, a non-mutual pair (u, v) is unidirectional if there is a path from u to v and no path from v to u.\n\n        But note: the graph might not have a path for some (u, v). However, we are allowed to add edges arbitrarily (to maximize the unidirectional pairs). But note: the problem does not restrict the edges. We can choose any graph (with the fixed SCC decomposition) to maximize the unidirectional pairs.\n\n        However, the SCC decomposition is fixed by the sizes? Actually, no: we can choose the graph arbitrarily as long as the mutual pairs (within SCCs) are p. But note: the minimal total nodes we found is the minimal n0, and the SCCs are determined by the representation (each SCC is of size s_i). But we can arrange the edges arbitrarily as long as the condensation graph is a DAG and the SCCs are of the given sizes.\n\n        How to maximize the unidirectional pairs?\n\n        We have k SCCs (with sizes s1, s2, ..., sk). The total number of pairs between two distinct SCCs is (s_i * s_j) for each unordered pair (i, j) (i != j). \n\n        For two distinct SCCs i and j, we can choose to put edges from i to j or from j to i or none, but we cannot put both (because that would merge the SCCs).",
    "response": "\nTo solve this problem, we need to determine the minimum number of nodes required to create a directed graph that is exactly p-reachable, and among all such graphs with the minimum number of nodes, find the maximum number of unidirectional node pairs.\n\n### Approach\n1. **Problem Analysis**:\n   - A directed graph is p-reachable if it contains exactly p ordered pairs (u, v) where u < v and u and v are mutually reachable (i.e., there exists a path from u to v and from v to u).\n   - The solution involves decomposing the problem into two parts: finding the minimal number of nodes (n) such that the sum of triangular numbers (each representing mutual pairs within a strongly connected component (SCC)) equals p, and then maximizing the number of unidirectional pairs in such a graph.\n\n2. **Key Insights**:\n   - **Triangular Numbers**: Each SCC of size s contributes \\( T(s) = s*(s-1)/2 \\) mutual pairs. The problem reduces to representing p as a sum of triangular numbers and minimizing the total nodes (sum of s values).\n   - **Dynamic Programming (DP)**: We use a DP approach where `dp[j]` represents the minimal nodes needed to achieve j mutual pairs. The DP is filled by considering each triangular number and updating the DP array accordingly.\n   - **Maximizing Unidirectional Pairs**: For the minimal node graph, the maximum unidirectional pairs are achieved by arranging the condensation graph (DAG of SCCs) such that as many inter-SCC pairs as possible are unidirectional. This involves ensuring that for every pair of distinct SCCs, edges are directed in a way that maximizes the count of paths from one SCC to another but not vice versa.\n\n3. **Algorithm Selection**:\n   - **DP for Minimal Nodes**: Compute the minimal nodes required by iterating through all possible triangular numbers and using an unbounded knapsack approach.\n   - **Combinatorial Counting**: For the maximal unidirectional pairs, calculate the total possible ordered pairs minus the mutual pairs and adjust for the DAG structure.\n\n4. **Complexity Analysis**:\n   - **DP Step**: The DP involves processing each triangular number up to p (200,000), leading to approximately 633 * 200,000 operations, which is feasible given constraints.\n   - **Unidirectional Pairs Calculation**: This involves simple arithmetic operations based on the SCC sizes and their arrangement, which is efficient.\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    p = int(sys.stdin.readline())\n    \n    if p == 0:\n        print(\"0 0\")\n        return\n        \n    max_tri = 0\n    s_val = 1\n    while max_tri <= p:\n        s_val += 1\n        max_tri = s_val * (s_val - 1) // 2\n        \n    A = []\n    s_val = 2\n    while True:\n        t_val = s_val * (s_val - 1) // 2\n        if t_val > p:\n            break\n        A.append((t_val, s_val))\n        s_val += 1\n        \n    dp = [10**9] * (p + 1)\n    dp[0] = 0\n    \n    for t_val, s_val in A:\n        for j in range(t_val, p + 1):\n            if dp[j - t_val] != 10**9:\n                new_nodes = dp[j - t_val] + s_val\n                if new_nodes < dp[j]:\n                    dp[j] = new_nodes\n                    \n    n0 = dp[p]\n    \n    total_ordered_pairs = n0 * (n0 - 1)\n    mutual_ordered_pairs = 2 * p\n    \n    non_mutual_ordered_pairs = total_ordered_pairs - mutual_ordered_pairs\n    \n    max_unidirectional = non_mutual_ordered_pairs\n    \n    print(f\"{n0} {max_unidirectional}\")\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read as an integer p, which represents the required number of mutual pairs.\n2. **Special Case Handling**: If p is 0, the output is \"0 0\" since no nodes or edges are needed.\n3. **Triangular Numbers Calculation**: The loop calculates all triangular numbers up to p and stores them along with their corresponding SCC sizes.\n4. **DP Initialization**: The DP array is initialized with a large value (10^9) to represent infinity, except for `dp[0]` which is 0 (no nodes needed for zero mutual pairs).\n5. **DP Filling**: For each triangular number, the DP array is updated to reflect the minimal nodes required to achieve each possible mutual pair count up to p.\n6. **Result Extraction**: The minimal nodes (n0) is found in `dp[p]`. The maximum unidirectional pairs is calculated by subtracting the mutual pairs (2*p) from the total possible ordered pairs (n0*(n0-1)).\n7. **Output**: The result is printed as the minimal nodes and the maximal unidirectional pairs.\n\nThis approach efficiently solves the problem by leveraging dynamic programming to minimize nodes and combinatorial mathematics to maximize unidirectional pairs.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    p = int(sys.stdin.readline())\n    \n    if p == 0:\n        print(\"0 0\")\n        return\n        \n    max_tri = 0\n    s_val = 1\n    while max_tri <= p:\n        s_val += 1\n        max_tri = s_val * (s_val - 1) // 2\n        \n    A = []\n    s_val = 2\n    while True:\n        t_val = s_val * (s_val - 1) // 2\n        if t_val > p:\n            break\n        A.append((t_val, s_val))\n        s_val += 1\n        \n    dp = [10**9] * (p + 1)\n    dp[0] = 0\n    \n    for t_val, s_val in A:\n        for j in range(t_val, p + 1):\n            if dp[j - t_val] != 10**9:\n                new_nodes = dp[j - t_val] + s_val\n                if new_nodes < dp[j]:\n                    dp[j] = new_nodes\n                    \n    n0 = dp[p]\n    \n    total_ordered_pairs = n0 * (n0 - 1)\n    mutual_ordered_pairs = 2 * p\n    \n    non_mutual_ordered_pairs = total_ordered_pairs - mutual_ordered_pairs\n    \n    max_unidirectional = non_mutual_ordered_pairs\n    \n    print(f\"{n0} {max_unidirectional}\")\n\nif __name__ == '__main__':\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 474,
        "completion_token_count": 1114,
        "thoughts_token_count": 8191
    }
}