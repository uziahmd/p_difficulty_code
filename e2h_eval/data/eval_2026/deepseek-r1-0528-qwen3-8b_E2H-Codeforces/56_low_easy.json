{
    "start": 1758294378.2073138,
    "end": 1758296547.4761493,
    "start-formatted": "2025-09-20 00:06 KST",
    "end-formatted": "2025-09-20 00:42 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\n We are given R and B (number of rebels and bases) with R, B between 1 and 10.\n Then R lines for rebels, then B lines for bases.\n\n We need to assign each base to exactly one rebel (and each rebel to exactly one base) such that the straight line from the base to its assigned rebel does not intersect any other such line.\n\n However, note: the problem says \"any two (straight) paths\" from a base to its assigned spaceship do not intersect. Since we have a perfect matching, we are drawing R+B/2 lines? Actually, we have R bases and R rebels? Wait, no: the input first gives R and B. But note the example: \n Example 1: Input starts with \"3 3\", so R=3, B=3. Then three rebels and three bases.\n\n Condition: Each base has exactly one guardian (rebel) and each rebel has exactly one base. So we are looking for a bijection (matching) between the R rebels and the B bases? But wait: the problem says \"assign R Rebel spaceships to guard B bases\", but then says \"every base has exactly one guardian\", meaning that we must have R == B? \n\n Let's read the problem statement again: \"assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base\". This implies that the number of bases must equal the number of rebels. Otherwise, if R != B, then it's impossible because we cannot assign each base one and each rebel one.\n\n But note the input: the first line contains two integers R, B. Then R lines for rebels, then B lines for bases.\n\n The example input: \n   \"3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2\"\n\n And the second example: \n   \"2 1\\n1 0\\n2 2\\n3 1\"\n\n In the second example, R=2, B=1. So we have two rebels and one base. Then the condition requires that each base has one guardian (so one rebel) and each rebel has one base. But if there is only one base, then we can only assign one rebel, leaving the other without a base. So the condition requires that the assignment is a perfect matching (each base assigned one rebel and each rebel assigned one base). Therefore, we must have R = B.\n\n However, the problem statement says: \"each spaceship has exactly one assigned base\", meaning that the set of bases must be of the same size as the set of rebels. So if R != B, then there is no perfect matching.\n\n Therefore, we can immediately output \"No\" if R != B.\n\n But wait: what if R and B are different? The problem says \"perfect matching\", which requires |R| = |B|. Since the problem states \"1 ≤ R, B ≤ 10\", we can check:\n\n Approach:\n  1. If R != B, output \"No\".\n  2. Else, we have R = B. Now we need to find a perfect matching (bijection) between the rebels and the bases such that the straight lines drawn from each base to its assigned rebel do not intersect.\n\n How to check non-intersection?\n\n Note: The lines are in the plane. Two line segments (from base A to rebel A, and base B to rebel B) will not intersect if they form a non-crossing matching? \n\n However, note: the problem says \"any two (straight) paths\" do not intersect. So we require that the entire set of lines (each base to its assigned rebel) do not cross.\n\n Observation: In computational geometry, a matching of points (with n pairs) such that the edges do not cross is called a non-crossing matching. But note: we are allowed to choose the matching arbitrarily.\n\n How to solve?\n  - We have up to 10 points (since R=B<=10). So we can use brute-force: try all permutations (factorial(R)) which is at most 10! = 3628800, which is acceptable.\n\n Steps for brute-force:\n  Step 1: Read R and B. If R != B, print \"No\" and exit.\n  Step 2: Read the next R lines for rebels, then B lines for bases.\n  Step 3: We have two lists: \n        rebels = [(x1,y1), (x2,y2), ...]\n        bases = [(a1,b1), (a2,b2), ...]\n\n  Step 4: We consider all bijections (permutations) from bases to rebels. For a given permutation p (which assigns base i to rebel p[i]), we draw lines from base i to rebel p[i] for all i.\n\n  Step 5:",
    "response": "\nTo solve this problem, we need to determine if there exists a perfect matching between a set of Rebel spaceships and bases such that the straight lines connecting each base to its assigned spaceship do not intersect. The solution involves checking all possible permutations of assignments between the bases and spaceships to find a valid non-intersecting configuration.\n\n### Approach\n1. **Problem Analysis**: The problem requires a perfect matching (bijection) between R rebels and B bases where R must equal B for a perfect matching to exist. If R ≠ B, the answer is immediately \"No\".\n2. **Brute-Force Matching**: For cases where R = B, we generate all possible permutations of assigning bases to rebels. Each permutation represents a potential matching.\n3. **Non-Intersection Check**: For each permutation, we check if the line segments connecting each base to its assigned rebel intersect with any other line segments. This is done by verifying that no two segments cross each other in the plane.\n4. **Efficiency**: Given the constraints (R, B ≤ 10), the brute-force approach is feasible as the number of permutations (10! = 3,628,800) is manageable for modern computing.\n\n### Solution Code\n```python\nimport itertools\n\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"No\")\n        return\n        \n    r = int(data[0])\n    b = int(data[1])\n    \n    index = 2\n    rebels = []\n    for i in range(r):\n        x = int(data[index])\n        y = int(data[index+1])\n        index += 2\n        rebels.append((x, y))\n        \n    bases = []\n    for i in range(b):\n        a = int(data[index])\n        b_val = int(data[index+1])\n        index += 2\n        bases.append((a, b_val))\n        \n    if r != b:\n        print(\"No\")\n        return\n        \n    from itertools import permutations\n    \n    def segments_intersect(a, b, c, d):\n        # Check if segments (a, b) and (c, d) intersect\n        def orientation(p, q, r):\n            val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n            if val == 0:\n                return 0\n            return 1 if val > 0 else 2\n            \n        o1 = orientation(a, b, c)\n        o2 = orientation(a, b, d)\n        o3 = orientation(c, d, a)\n        o4 = orientation(c, d, b)\n        \n        if o1 != o2 and o3 != o4:\n            return True\n            \n        return False\n        \n    n = r\n    found = False\n    for perm in permutations(range(n)):\n        valid = True\n        for i in range(n):\n            for j in range(i+1, n):\n                base1 = bases[i]\n                base2 = bases[j]\n                rebel1 = rebels[perm[i]]\n                rebel2 = rebels[perm[j]]\n                if segments_intersect(base1, rebel1, base2, rebel2):\n                    valid = False\n                    break\n            if not valid:\n                break\n                \n        if valid:\n            found = True\n            break\n            \n    print(\"Yes\" if found else \"No\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into integers R and B, followed by their respective coordinates for rebels and bases.\n2. **Immediate Check**: If the number of rebels (R) does not equal the number of bases (B), the solution outputs \"No\" since a perfect matching is impossible.\n3. **Permutations Generation**: All possible permutations of base assignments to rebels are generated. Each permutation represents a unique way to match bases to rebels.\n4. **Segment Intersection Check**: For each permutation, the code checks if any two line segments (from base to rebel) intersect. The `segments_intersect` function uses the orientation method to determine if segments cross.\n5. **Result Determination**: If any permutation is found where no segments intersect, the solution outputs \"Yes\". If no such permutation exists after checking all possibilities, it outputs \"No\".\n\nThis approach efficiently checks all possible configurations using brute-force due to the small constraint size, ensuring correctness while maintaining simplicity.",
    "ground_truth": "N/A",
    "extracted_answer": "import itertools\n\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"No\")\n        return\n        \n    r = int(data[0])\n    b = int(data[1])\n    \n    index = 2\n    rebels = []\n    for i in range(r):\n        x = int(data[index])\n        y = int(data[index+1])\n        index += 2\n        rebels.append((x, y))\n        \n    bases = []\n    for i in range(b):\n        a = int(data[index])\n        b_val = int(data[index+1])\n        index += 2\n        bases.append((a, b_val))\n        \n    if r != b:\n        print(\"No\")\n        return\n        \n    from itertools import permutations\n    \n    def segments_intersect(a, b, c, d):\n        # Check if segments (a, b) and (c, d) intersect\n        def orientation(p, q, r):\n            val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n            if val == 0:\n                return 0\n            return 1 if val > 0 else 2\n            \n        o1 = orientation(a, b, c)\n        o2 = orientation(a, b, d)\n        o3 = orientation(c, d, a)\n        o4 = orientation(c, d, b)\n        \n        if o1 != o2 and o3 != o4:\n            return True\n            \n        return False\n        \n    n = r\n    found = False\n    for perm in permutations(range(n)):\n        valid = True\n        for i in range(n):\n            for j in range(i+1, n):\n                base1 = bases[i]\n                base2 = bases[j]\n                rebel1 = rebels[perm[i]]\n                rebel2 = rebels[perm[j]]\n                if segments_intersect(base1, rebel1, base2, rebel2):\n                    valid = False\n                    break\n            if not valid:\n                break\n                \n        if valid:\n            found = True\n            break\n            \n    print(\"Yes\" if found else \"No\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 479,
        "completion_token_count": 938,
        "thoughts_token_count": 1023
    }
}