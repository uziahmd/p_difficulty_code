{
    "start": 1758294366.4584582,
    "end": 1758296008.5313475,
    "start-formatted": "2025-09-20 00:06 KST",
    "end-formatted": "2025-09-20 00:33 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\n Okay, we are given two integers R and B (number of rebels and bases) and then 2R+B points (R lines for rebels, then B lines for bases). We need to check if there exists a perfect matching (one-to-one assignment) between the R rebels and the B bases such that the straight line segments (from each base to its assigned spaceship) do not intersect.\n\n However, note: the problem says \"any two (straight) paths\" (from a base to its assigned spaceship) do not intersect. This means that if we assign each spaceship to a base with a straight line, then no two such lines should cross.\n\n But note: the problem does not require that the entire drawing is non-intersecting in the plane? Actually, the constraint is that the assignment must be such that the segments do not intersect. However, note that the bases and spaceships are distinct points, and we are allowed to assign each base to one spaceship and vice versa (so it's a bijection). The condition is that the straight line segments connecting each base to its assigned spaceship do not intersect.\n\n Important: The problem states that no two points coincide and no three points are collinear.\n\n How to approach?\n\n Since R and B are at most 10, we can consider using a combinatorial method.\n\n Observation:\n 1. The assignment must be a perfect matching (if R != B, then there is no perfect matching? Actually, the problem says \"assign R Rebel spaceships to guard B bases\" with every base having exactly one guardian and each spaceship having exactly one assigned base. So we require R = B. But the input says 1<=R,B<=10, and the example has R=3, B=3. The second example: R=2, B=1 -> output 'No' because 2 rebels cannot be perfectly matched to 1 base (each base must have one guardian and each spaceship must have one base, so we require |R| = |B|). Therefore, first check: if R != B, then output 'No'.\n\n 2. If R == B, then we have to assign each spaceship to a base. We are to check if there exists an assignment such that the straight lines (from each base to its spaceship) do not intersect.\n\n However, note: the problem does not specify which is which, but the input gives first R lines for rebels and then B lines for bases.\n\n Steps:\n\n - Read R and B.\n - Read the next R lines for rebels.\n - Read the next B lines for bases.\n\n Condition 1: if R != B -> output 'No'\n\n Condition 2: if R == B, then we have to find a perfect matching (bijection) from the set of rebels to the set of bases such that the segments connecting each rebel to its base do not intersect.\n\n But note: the problem says \"any two (straight) paths\" (meaning the segments) do not intersect. So the entire set of segments must be non-intersecting.\n\n However, note that the problem does not say that the entire set of segments must be non-intersecting in the usual sense. Actually, the condition is that no two segments (from different pairs) should cross. But note: two segments that share an endpoint (like a base or a spaceship) are allowed to meet at that endpoint? The problem says \"do not intersect\", and typically in such problems, meeting at endpoints is considered non-intersecting (they don't cross in the interior). So we only care about crossings that are not at the endpoints.\n\n But note: the problem says \"any two (straight) paths – from a base to its assigned spaceship – do not intersect\". So if two segments cross at an interior point, that is not allowed.\n\n How to check for non-intersection of segments?\n\n We can use the standard method: for four distinct points A, B, C, D, the segments AB and CD do not intersect (in the interior) if the points are in one of the two configurations (without loss of generality, we can check the orientation of the four points).\n\n However, we have R=B (say n) and we have two sets: \n   Set S (rebels) and Set T (bases)\n\n We want to assign each rebel i to a base j (a bijection) and then check that for every pair of edges (i, j) and (k, l) (with i != k and j != l), the segments (from rebel i to base j) and (from rebel k to base l) do not cross.\n\n But note: we are only drawing the edges from rebels to bases. Also, note that the same point (base or rebel) might be shared by multiple edges? No, because the assignment is a bijection: each base is connected to exactly one rebel and each rebel is connected to exactly one base.\n\n Therefore, we have a complete bipartite graph between S and T (with n nodes on left",
    "response": "\nTo solve this problem, we need to determine if there exists a perfect matching between a set of Rebel spaceships and bases such that the straight-line segments connecting each spaceship to its assigned base do not intersect. The solution involves checking two main conditions: first, whether the number of spaceships equals the number of bases, and second, whether there exists a matching where the connecting segments do not cross.\n\n### Approach\n1. **Initial Check**: If the number of spaceships (R) does not equal the number of bases (B), output \"No\" immediately since a perfect matching is impossible.\n2. **Perfect Matching Check**: If R equals B, we need to verify if there exists a bijection between the spaceships and bases such that no two connecting segments intersect. This involves:\n   - **Reading Input**: Parse the coordinates of spaceships and bases.\n   - **Matching Algorithm**: Use a combinatorial approach to explore all possible permutations of assignments between spaceships and bases. For each permutation, check if any two segments intersect.\n   - **Segment Intersection Check**: For four distinct points (two spaceships and two bases), determine if the segments connecting them intersect by using the cross product method to check the orientation of the points.\n\n### Solution Code\n```python\ndef cross(o, a, b):\n    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n\ndef orientation(a, b, c):\n    return cross(a, b, c)\n\ndef do_segments_intersect(a, b, c, d):\n    o1 = orientation(a, b, c)\n    o2 = orientation(a, b, d)\n    o3 = orientation(c, d, a)\n    o4 = orientation(c, d, b)\n    \n    if (o1 * o2 < 0) and (o3 * o4 < 0):\n        return True\n    if o1 == 0 or o2 == 0 or o3 == 0 or o4 == 0:\n        return False\n    return False\n\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"No\")\n        return\n    \n    r = int(data[0])\n    b = int(data[1])\n    rebels = []\n    index = 2\n    for _ in range(r):\n        x = int(data[index])\n        y = int(data[index + 1])\n        index += 2\n        rebels.append((x, y))\n    \n    bases = []\n    for _ in range(b):\n        x = int(data[index])\n        y = int(data[index + 1])\n        index += 2\n        bases.append((x, y))\n    \n    if r != b:\n        print(\"No\")\n        return\n    \n    from itertools import permutations\n    bases_perm = list(permutations(bases))\n    \n    n = r\n    found = False\n    for perm in bases_perm:\n        valid = True\n        for i in range(n):\n            for j in range(i + 1, n):\n                seg1 = (rebels[i], perm[i])\n                seg2 = (rebels[j], perm[j])\n                if do_segments_intersect(seg1[0], seg1[1], seg2[0], seg2[1]):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            found = True\n            break\n    \n    print(\"Yes\" if found else \"No\")\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Initial Check**: The code first checks if the number of spaceships (R) matches the number of bases (B). If not, it immediately outputs \"No\".\n2. **Reading Input**: The input is read and parsed into two lists: one for spaceship coordinates and another for base coordinates.\n3. **Permutation Check**: For each permutation of base assignments, the code checks if any two connecting segments (from a spaceship to its base) intersect. The intersection is determined using the cross product to check the orientation of the points.\n4. **Output Result**: If a valid permutation is found where no segments intersect, the code outputs \"Yes\"; otherwise, it outputs \"No\".\n\nThis approach efficiently checks all possible assignments between spaceships and bases, ensuring that the solution meets the problem's constraints. The use of combinatorial permutations and geometric intersection checks ensures correctness for the given problem constraints.",
    "ground_truth": "N/A",
    "extracted_answer": "def cross(o, a, b):\n    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n\ndef orientation(a, b, c):\n    return cross(a, b, c)\n\ndef do_segments_intersect(a, b, c, d):\n    o1 = orientation(a, b, c)\n    o2 = orientation(a, b, d)\n    o3 = orientation(c, d, a)\n    o4 = orientation(c, d, b)\n    \n    if (o1 * o2 < 0) and (o3 * o4 < 0):\n        return True\n    if o1 == 0 or o2 == 0 or o3 == 0 or o4 == 0:\n        return False\n    return False\n\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"No\")\n        return\n    \n    r = int(data[0])\n    b = int(data[1])\n    rebels = []\n    index = 2\n    for _ in range(r):\n        x = int(data[index])\n        y = int(data[index + 1])\n        index += 2\n        rebels.append((x, y))\n    \n    bases = []\n    for _ in range(b):\n        x = int(data[index])\n        y = int(data[index + 1])\n        index += 2\n        bases.append((x, y))\n    \n    if r != b:\n        print(\"No\")\n        return\n    \n    from itertools import permutations\n    bases_perm = list(permutations(bases))\n    \n    n = r\n    found = False\n    for perm in bases_perm:\n        valid = True\n        for i in range(n):\n            for j in range(i + 1, n):\n                seg1 = (rebels[i], perm[i])\n                seg2 = (rebels[j], perm[j])\n                if do_segments_intersect(seg1[0], seg1[1], seg2[0], seg2[1]):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            found = True\n            break\n    \n    print(\"Yes\" if found else \"No\")\n\nif __name__ == '__main__':\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 480,
        "completion_token_count": 942,
        "thoughts_token_count": 1023
    }
}