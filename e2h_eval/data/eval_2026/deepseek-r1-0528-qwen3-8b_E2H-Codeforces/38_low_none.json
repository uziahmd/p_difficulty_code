{
    "start": 1758297380.937261,
    "end": 1758300767.383544,
    "start-formatted": "2025-09-20 00:56 KST",
    "end-formatted": "2025-09-20 01:52 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\n Okay, let's break down the problem.\n\n We are given an integer p (0 <= p <= 200000). We need to find:\n  1. The minimum number of nodes required to create a directed graph that is p-reachable.\n  2. Among all such graphs with the minimum number of nodes, the maximum number of unidirectional ordered pairs (u, v) (with u != v, there's a path from u to v but not from v to u).\n\n Note: The graph is p-reachable if it contains exactly p ordered pairs (u, v) such that u < v and u and v are mutually reachable (i.e., they form a strongly connected component, and we count unordered pairs but note the condition u < v). However, note that the problem says \"exactly p ordered pairs of nodes (u, v) such that u < v and u and v are reachable from each other\". But wait: the condition is on the pair (u, v) with u < v, so we are counting unordered pairs? Actually, since u < v, each mutual pair (u, v) is uniquely identified by the ordering. \n\n However, note that in a strongly connected component (SCC), the entire component is a set of nodes where every node is reachable from every other. The condition for being p-reachable is that the graph has exactly p pairs (u, v) with u < v and mutual reachability.\n\n But note: In a graph, the mutual reachability condition is symmetric. So if we have a set S of k nodes that form a strongly connected component, then the number of pairs (u, v) with u < v and u, v in S is C(k,2) = k*(k-1)//2.\n\n Also, the graph may have multiple SCCs. However, note that the problem requires that the graph has exactly p such pairs. Moreover, the graph must be constructed with the minimum number of nodes.\n\n Observation:\n\n Let n be the total number of nodes.\n\n We can think of the graph as having several strongly connected components (SCCs) arranged in a linear order (like a DAG of SCCs). Then, for two nodes in different SCCs, say from SCC A and SCC B, if there is a path from A to B then we don't consider the reverse (unless there's also a path from B to A, which would make them one SCC). So the mutual reachability only happens within an SCC.\n\n Therefore, the total number of pairs (u, v) (with u < v) that are mutually reachable is the sum over all SCCs of size k_i: k_i*(k_i-1)//2.\n\n So we require: sum_{i} [k_i*(k_i-1)//2] = p.\n\n Now, we want the minimum n (the total number of nodes) such that we can partition n into positive integers k_1, k_2, ..., k_m (each at least 1) and the sum of the combinations (k_i choose 2) is p.\n\n However, note: the graph must have exactly p pairs. But wait, we can also have the entire graph being one big SCC? Then n(n-1)/2 = p, so n is the smallest integer such that n(n-1)/2 >= p? But we are allowed to have more than one SCC.\n\n Actually, we are allowed to have any number of SCCs. The minimal n is achieved when we use the representation of p as a sum of triangular numbers (each triangular number T_k = k*(k-1)//2) and we want to minimize the total n (which is the sum of the k_i's). However, note that the same k can be used multiple times? And the triangular numbers are additive.\n\n But note: the triangular numbers are not necessarily distinct and we can use the same k multiple times.\n\n However, we know that the triangular numbers grow as k^2/2. To minimize the total n (the sum of k_i) for a fixed sum of T_{k_i}=p, we should use as few and as large as possible k_i? Actually, no: we want to minimize the total n (which is the sum of k_i) for a fixed p (which is the sum of T_{k_i}). This is a classic coin change-like problem but with coins being triangular numbers and we want to minimize the total value (the sum of k_i) for a given total p.\n\n But note: the problem does not require to represent p as the sum of triangular numbers arbitrarily. We are allowed to use any number of SCCs and each SCC contributes a triangular number. We want to minimize n (the total nodes) and then maximize the number of unidirectional pairs.\n\n However, note: the minimal n is the minimal total number of nodes we can get by decomposing p as a sum of triangular numbers (each T_k = k*(",
    "response": "\nTo solve this problem, we need to determine the minimum number of nodes required to create a directed graph that is p-reachable, and among all such graphs, find the one that maximizes the number of unidirectional node pairs. \n\n### Approach\n1. **Understanding p-Reachability**: A directed graph is p-reachable if it contains exactly p ordered pairs (u, v) where u < v and there exists mutual reachability between u and v. This means the graph must have exactly p strongly connected components (SCCs) when considering each SCC of size k contributes k*(k-1)/2 pairs.\n2. **Minimizing Nodes**: The goal is to partition the integer p into a sum of triangular numbers (each representing an SCC's contribution) such that the sum of the corresponding k values (sizes of SCCs) is minimized. This involves finding the smallest set of triangular numbers that sum up to p.\n3. **Maximizing Unidirectional Pairs**: Once the minimal node configuration is determined, the next step is to maximize the number of unidirectional pairs. This is achieved by structuring the graph such that within each SCC, all possible edges exist, and between SCCs, edges are directed in a way that only allows paths from higher-order to lower-order SCCs, thus maximizing unidirectional pairs.\n\n### Solution Code\n```python\ndef main():\n    import sys\n    p = int(sys.stdin.readline().strip())\n    \n    if p == 0:\n        print(\"0 0\")\n        return\n        \n    n = 1\n    while True:\n        tri = n * (n - 1) // 2\n        if tri > p:\n            break\n        p -= tri\n        n += 1\n        \n    total_nodes = n\n    m = (p * 2 + 1) ** 0.5\n    last_k = int(m)\n    while p >= (last_k + 1) * last_k // 2:\n        last_k += 1\n        \n    num_components = 0\n    remaining = p\n    k = 1\n    while remaining > 0:\n        t = k * (k - 1) // 2\n        if t <= remaining:\n            num_components += 1\n            remaining -= t\n        k += 1\n        \n    total_nodes += num_components\n    \n    if p == 0:\n        print(f\"{total_nodes} 0\")\n    else:\n        max_unidirectional = 0\n        for i in range(1, total_nodes + 1):\n            max_unidirectional += i * (i - 1) // 2\n            \n        for i in range(1, total_nodes + 1):\n            max_unidirectional -= (i * (i - 1)) // 4\n            \n        print(f\"{total_nodes} {int(max_unidirectional)}\")\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input consists of a single integer p, which represents the number of required mutual reachability pairs.\n2. **Handling Zero Case**: If p is zero, the solution immediately returns \"0 0\" since no nodes or edges are needed.\n3. **Finding Minimal Nodes**: The loop calculates the largest triangular number less than or equal to p. It subtracts this triangular number from p and increments the node count until the triangular number exceeds the remaining p. This gives the minimal node configuration.\n4. **Calculating Components**: The remaining value after subtracting triangular numbers is processed to determine additional components needed, adjusting the total node count accordingly.\n5. **Maximizing Unidirectional Pairs**: The solution computes the maximum number of unidirectional pairs by considering all possible edges within the graph and subtracting those that are part of mutual reachability pairs, ensuring the result is optimal for the minimal node configuration.\n\nThis approach efficiently balances the constraints to find the minimal nodes and maximizes unidirectional pairs within the given structure.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n    p = int(sys.stdin.readline().strip())\n    \n    if p == 0:\n        print(\"0 0\")\n        return\n        \n    n = 1\n    while True:\n        tri = n * (n - 1) // 2\n        if tri > p:\n            break\n        p -= tri\n        n += 1\n        \n    total_nodes = n\n    m = (p * 2 + 1) ** 0.5\n    last_k = int(m)\n    while p >= (last_k + 1) * last_k // 2:\n        last_k += 1\n        \n    num_components = 0\n    remaining = p\n    k = 1\n    while remaining > 0:\n        t = k * (k - 1) // 2\n        if t <= remaining:\n            num_components += 1\n            remaining -= t\n        k += 1\n        \n    total_nodes += num_components\n    \n    if p == 0:\n        print(f\"{total_nodes} 0\")\n    else:\n        max_unidirectional = 0\n        for i in range(1, total_nodes + 1):\n            max_unidirectional += i * (i - 1) // 2\n            \n        for i in range(1, total_nodes + 1):\n            max_unidirectional -= (i * (i - 1)) // 4\n            \n        print(f\"{total_nodes} {int(max_unidirectional)}\")\n\nif __name__ == '__main__':\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 466,
        "completion_token_count": 828,
        "thoughts_token_count": 1023
    }
}