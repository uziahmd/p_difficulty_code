{
    "start": 1758089233.9014862,
    "end": 1758090749.1189225,
    "start-formatted": "2025-09-17 15:07 KST",
    "end-formatted": "2025-09-17 15:32 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\n Okay, let's analyze the problem:\n\nWe are constructing a snowflake as follows:\n- Start with 1 vertex (step 0).\n- Then, we do at least one step. In each step, every vertex that has degree 1 (i.e., connected to only one other vertex) will be expanded by connecting it to k new vertices (k>1). \n\nHowever, note that the process is done in layers. The initial vertex (step 0) is connected to k new ones (step 1). Then, the k vertices from step 1 (each connected only to the center) will each connect to k new ones (step 2), and so on.\n\nBut note: the expansion condition says \"Each vertex that is connected to only one other vertex\" (so leaves) is expanded. However, after expanding, the center has degree k (so it won't be expanded again) and the vertices from step i have one connection to the center or parent and then k children? Actually, let's break down:\n\nStep 0: 1 vertex (the center)\nStep 1: Add k vertices -> total = 1 + k\nStep 2: Each of the k vertices from step 1 adds k new ones -> total = 1 + k + k*k\n\nBut wait, the problem says: \"Each vertex that is connected to only one other vertex is connected by edges to k more new vertices.\" And this step should be done at least once.\n\nSo the entire construction has multiple layers. Let the number of steps (or layers) be m (at least 1, but note: the first expansion is step 1, then step 2, etc.). Then:\n\nAfter step 0: 1 node.\nAfter step 1: 1 + k\nAfter step 2: 1 + k + k^2\nAfter step m: 1 + k + k^2 + ... + k^m = (k^(m+1)-1)/(k-1)\n\nBut note: the problem states that the expansion is done at least once (so m>=1). However, the example smallest snowflake for k=4 has 1 + 4 + 4*3? Wait, let me check the example.\n\nWait, actually the example says: \"The smallest possible snowflake for k = 4\". The smallest would be when we do exactly one expansion (step 1): \n  1 (center) + 4 (first ring) = 5 nodes.\n\nBut wait, the example might be showing a different structure? Alternatively, note that in step 1, we start with the center and add k. Then, the rule says: \"Each vertex that is connected to only one other vertex\" (which are the k vertices) must be expanded at least once. So we must do step 2? But then the problem says \"This step should be done at least once\", meaning the entire process (from the beginning) must have at least one expansion (step 1) and then the expansion of the leaves (step 2) is also part of the process? Actually, the problem says:\n\n\"Then, more vertices are added to the graph. The initial vertex is connected by edges to k new vertices (k > 1). Each vertex that is connected to only one other vertex is connected by edges to k more new vertices. This step should be done at least once.\"\n\nWait, there are two steps described. The first step is connecting the center to k. Then, the next step (for each leaf) is connecting each leaf to k new ones. But the problem says \"This step\" (meaning the second step) should be done at least once? Or does the entire process (both steps) count as one?\n\nLet me read again: \"Then, more vertices are added to the graph. The initial vertex is connected by edges to k new vertices (k > 1). Each vertex that is connected to only one other vertex is connected by edges to k more new vertices. This step should be done at least once.\"\n\nIt's ambiguous. However, note the example: \"The smallest possible snowflake for k = 4\" is shown. The figure typically shows the center, then the first ring of 4, and then each of those 4 is connected to 3 more? That would be 1 + 4 + 4*3 = 17? But wait, the problem says: \"Each vertex that is connected to only one other vertex\" (so the leaves) are expanded. However, after step 1, the center has degree 4 (so not a leaf) and the four leaves have degree 1 (so they are expanded). But if we expand a leaf, we remove the leaf and add k new ones? Or we add k new ones and keep the leaf? \n\nActually, the problem does not say to remove the leaf. It says: \"Each vertex that is connected to only one other",
    "response": "\nTo solve this problem, we need to determine whether a given number of vertices \\( n \\) can form a snowflake graph as defined by Rudolf. The snowflake graph is constructed in layers, starting with a single central vertex. Each subsequent layer adds vertices such that every leaf vertex (connected to only one other vertex) is expanded by connecting it to \\( k \\) new vertices, where \\( k > 1 \\). This process must be performed at least once.\n\n### Approach\n1. **Problem Analysis**: The snowflake graph's structure after \\( m \\) layers (steps) is given by the geometric series sum \\( 1 + k + k^2 + \\ldots + k^m = \\frac{k^{m+1} - 1}{k - 1} \\). Here, \\( k \\) is the expansion factor (must be greater than 1), and \\( m \\) is the number of expansions (at least 1).\n2. **Key Insight**: For a given \\( n \\), we need to check if there exists an integer \\( k > 1 \\) and an integer \\( m \\geq 1 \\) such that \\( n = \\frac{k^{m+1} - 1}{k - 1} \\). However, directly checking all possible \\( k \\) and \\( m \\) for very large \\( n \\) (up to \\( 10^{18} \\)) is computationally infeasible.\n3. **Optimization**: Instead, we recognize that for each possible \\( m \\) (number of layers), the equation \\( n = \\frac{k^{m+1} - 1}{k - 1} \\) can be transformed into \\( k^{m+1} = n(k - 1) + 1 \\). We can iterate over possible values of \\( m \\) (from 1 upwards) and solve for \\( k \\) by taking the \\((m+1)\\)-th root of \\( n(k - 1) + 1 \\). However, since \\( n \\) can be very large, we limit the number of iterations by noting that \\( m \\) cannot exceed \\( \\log_k(n) \\). Specifically, \\( m \\) is at most around 60 for \\( n \\leq 10^{18} \\), as \\( 2^{60} \\) exceeds \\( 10^{18} \\).\n\n### Solution Code\n```python\nimport math\n\ndef main():\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        test_cases.append(int(input().strip()))\n    \n    results = []\n    for n in test_cases:\n        if n == 1:\n            results.append(\"NO\")\n            continue\n        found = False\n        m = 1\n        while True:\n            total_layers = m + 1\n            low = 2\n            high = n\n            k_guess = None\n            \n            # Using binary search to find k for fixed m\n            while low <= high:\n                mid = (low + high) // 2\n                s = (mid ** total_layers) - 1\n                denom = mid - 1\n                if denom == 0:\n                    val = float('inf')\n                else:\n                    val = s / denom\n                if val == n:\n                    k_guess = mid\n                    break\n                elif val < n:\n                    low = mid + 1\n                else:\n                    high = mid - 1\n            \n            if k_guess is not None:\n                found = True\n                break\n                \n            m += 1\n            if m > 60:\n                break\n        \n        results.append(\"YES\" if found else \"NO\")\n    \n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Input Handling**: The code reads multiple test cases, each containing a large integer \\( n \\) (up to \\( 10^{18} \\)).\n2. **Special Case Handling**: If \\( n = 1 \\), the answer is immediately \"NO\" because the smallest snowflake requires at least one expansion (step 1) which adds vertices.\n3. **Binary Search for \\( k \\)**: For each test case, the code iterates over possible numbers of layers \\( m \\). For each \\( m \\), it performs a binary search to find an integer \\( k > 1 \\) such that the sum of the geometric series \\( \\frac{k^{m+1} - 1}{k - 1} = n \\).\n4. **Termination Condition**: The loop terminates if a valid \\( k \\) is found or if \\( m \\) exceeds 60, ensuring efficiency even for very large \\( n \\).\n5. **Output**: For each test case, the result is \"YES\" if a valid \\( k \\) is found, otherwise \"NO\".\n\nThis approach efficiently checks the feasibility of constructing a snowflake graph with \\( n \\) vertices by leveraging mathematical insights and binary search, ensuring optimal performance even for the upper constraint limits.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef main():\n    t = int(input().strip())\n    test_cases = []\n    for _ in range(t):\n        test_cases.append(int(input().strip()))\n    \n    results = []\n    for n in test_cases:\n        if n == 1:\n            results.append(\"NO\")\n            continue\n        found = False\n        m = 1\n        while True:\n            total_layers = m + 1\n            low = 2\n            high = n\n            k_guess = None\n            \n            # Using binary search to find k for fixed m\n            while low <= high:\n                mid = (low + high) // 2\n                s = (mid ** total_layers) - 1\n                denom = mid - 1\n                if denom == 0:\n                    val = float('inf')\n                else:\n                    val = s / denom\n                if val == n:\n                    k_guess = mid\n                    break\n                elif val < n:\n                    low = mid + 1\n                else:\n                    high = mid - 1\n            \n            if k_guess is not None:\n                found = True\n                break\n                \n            m += 1\n            if m > 60:\n                break\n        \n        results.append(\"YES\" if found else \"NO\")\n    \n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 556,
        "completion_token_count": 1071,
        "thoughts_token_count": 1023
    }
}