{
    "start": 1758091626.0812614,
    "end": 1758093414.6538332,
    "start-formatted": "2025-09-17 15:47 KST",
    "end-formatted": "2025-09-17 16:16 KST",
    "gpu": 2,
    "pid": 13,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Chord\n\nVasya studies music. He has learned lots of interesting stuff. For example, he knows that there are 12 notes: C, C#, D, D#, E, F, F#, G, G#, A, B, H. He also knows that the notes are repeated cyclically: after H goes C again, and before C stands H. We will consider the C note in the row's beginning and the C note after the H similar and we will identify them with each other. The distance between the notes along the musical scale is measured in tones: between two consecutive notes there's exactly one semitone, that is, 0.5 tone. The distance is taken from the lowest tone to the uppest one, that is, the distance between C and E is 4 semitones and between E and C is 8 semitonesVasya also knows what a chord is. A chord is an unordered set of no less than three notes. However, for now Vasya only works with triads, that is with the chords that consist of exactly three notes. He can already distinguish between two types of triads — major and minor.Let's define a major triad. Let the triad consist of notes X, Y and Z. If we can order the notes so as the distance along the musical scale between X and Y equals 4 semitones and the distance between Y and Z is 3 semitones, then the triad is major. The distance between X and Z, accordingly, equals 7 semitones.A minor triad is different in that the distance between X and Y should be 3 semitones and between Y and Z — 4 semitones.For example, the triad \"C E G\" is major: between C and E are 4 semitones, and between E and G are 3 semitones. And the triplet \"C# B F\" is minor, because if we order the notes as \"B C# F\", than between B and C# will be 3 semitones, and between C# and F — 4 semitones.Help Vasya classify the triad the teacher has given to him.\n\n## Input\nThe only line contains 3 space-separated notes in the above-given notation.\n\n## Output\nPrint \"major\" if the chord is major, \"minor\" if it is minor, and \"strange\" if the teacher gave Vasya some weird chord which is neither major nor minor. Vasya promises you that the answer will always be unambiguous. That is, there are no chords that are both major and minor simultaneously.\n\n## Example\n### Input\n['C E G', 'C# B F', 'A B H']\n\n### Output\n['major', 'minor', 'strange']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\n We are given a string of three notes. The notes are from the set: ['C','C#','D','D#','E','F','F#','G','G#','A','B','H'] (12 notes)\n Steps:\n 1. Map each note to a number (0 to 11) representing the semitone index.\n 2. Since the chord is an unordered set, we will consider all permutations of the three notes.\n 3. For each permutation [a, b, c] (which we can think as X, Y, Z), check two conditions:\n    Condition for major: \n        distance from a to b = 4 semitones, and from b to c = 3 semitones.\n    Condition for minor:\n        distance from a to b = 3 semitones, and from b to c = 4 semitones.\n\n However, note: the problem says the distance is taken from the lowest tone to the highest one. But in our circular system, we need to compute the distance in a circular way.\n\n Important: In music, when we say the distance from note A to note B, we mean the smallest positive distance along the circle? Actually, the problem states: \"the distance between C and E is 4 semitones and between E and C is 8 semitones\". So the distance from E to C is not the same as C to E. \n\n But note: the example says that the chord \"C E G\" is major: ordering as C, E, G -> C to E is 4, E to G is 3.\n\n However, the problem also says: \"If we can order the notes so as the distance along the musical scale from X to Y equals 4 semitones and from Y to Z equals 3 semitones\"\n\n So the ordering must be such that the notes are consecutive in the cyclic order and we don't wrap around? Actually, the problem does not specify wrapping, but note: the example input might have notes that are not in increasing order.\n\n Approach for computing distance between two notes:\n\n Let's assign numbers to the notes:\n   C:0, C#:1, D:2, D#:3, E:4, F:5, F#:6, G:7, G#:8, A:9, B:10, H:11.\n\n Then, the distance from note a to note b is defined as (b - a) mod 12, but if negative we can adjust by adding 12 and then mod 12, but wait the example says from E to C is 8 semitones.\n\n Actually, the problem states: \"the distance between C and E is 4 semitones and between E and C is 8 semitones\".\n\n How to compute the distance from E to C?\n   E is 4, C is 0. \n   If we go forward from E to C: \n        E(4) -> F(5) -> F#(6) -> G(7) -> G#(8) -> A(9) -> B(10) -> H(11) -> C(0): that's 8 steps (from 4 to 0: 0-4 = -4, then add 12 -> 8).\n\n Alternatively, we can define the distance from a to b as (b - a) % 12, but if negative we can do (b - a + 12) % 12, but wait: \n   (0 - 4 + 12) % 12 = 8, which matches.\n\n However, note: the problem says the distance from E to C is 8, but the distance from C to E is 4. So we want the distance from a to b to be the smallest non-negative number of semitones to go from a to b in the upward direction (without going backward). \n\n Actually, we don't want the smallest, we want the upward distance (which might be more than 6 because the circle is 12). \n\n But note: the problem says \"the distance is taken from the lowest tone to the uppest one\", meaning we are going upward. However, the example input \"C E G\": \n   From C to E: we go up 4 semitones (C->C#->D->D#->E) -> 4 semitones.\n   From E to G: E->F->F#->G -> 3 semitones.\n\n But what if we have notes that are not in increasing order? Example: \"C# B F\" is minor. They are ordered as B, C#, F.\n\n Steps for the example \"C# B F\":\n   Notes: C# (1), B (10), F (5)\n\n   We must order them in the cyclic order. However, the problem says: \"if we can order the notes so as ...\".\n\n   How to order? We can map the notes to numbers and then sort, but then we have to consider the circularity.\n\n   Alternate approach: since there are only 12 notes, we can try all 6 permutations and see if any of them satisfies the major/minor condition.\n\n   Conditions for a permutation [a, b, c]:\n        Condition1 (major): (b - a) % 12 == 4 and (c - b) % 12 == 3\n        Condition2 (minor): (b - a) % 12 == 3 and (c - b) % 12 == 4\n\n   But wait: the modulus operation for negative? We can define the distance from a to b as (b - a) % 12, but if negative we add 12 until positive? Actually, we can use:\n\n        dist(a, b) = (b - a) % 12\n        But if (b - a) is negative, then (b - a) % 12 gives a positive value? Not exactly: in Python, negative modulus is handled by giving a result between 0 and 11. However, let me test:\n\n        (10 - 1) % 12 = 9 % 12 = 9 -> but wait, from C# (1) to B (10) is 9 semitones? Actually, from C# to B: \n            C# (1) -> D(2) -> D#(3) -> E(4) -> F(5) -> F#(6) -> G(7) -> G#(8) -> A(9) -> B(10): that's 9 semitones. But the example says the chord is minor with ordering B, C#, F.\n\n        Now, for the minor condition: \n            Ordering: B, C#, F -> [10, 1, 5]\n            Condition: \n                from B to C#: (1 - 10) % 12 = (1 - 10) = -9 % 12 = 3 (because -9 + 12 = 3) -> so 3 semitones. Correct.\n                from C# to F: (5 - 1) % 12 = 4 % 12 = 4 -> but wait, the condition for minor requires 4 semitones. However, the example says it's minor because the distances are 3 and 4. But wait, the example says: \"between B and C# will be 3 semitones, and between C# and F — 4 semitones\".\n\n        However, from C# to F: \n            C# (1) -> D(2) -> D#(3) -> E(4) -> F(5): that's 4 semitones. So the modulus method works.\n\n        But note: the problem says the distance from E to C is 8, which is (0 - 4) % 12 = (-4) % 12 = 8.\n\n        So the formula for the distance from a to b (in semitones, going upward) is: (b - a) % 12, but if negative we get a positive modulo.\n\n        However, we must consider: the entire chord might be considered in a cycle. But the condition requires consecutive notes? \n\n        But note: the example \"C E G\": \n            C to E: (4-0)%12=4 -> correct.\n            E to G: (7-4)%12=3 -> correct.\n\n        But what if the notes are not adjacent in the circle? The problem does not require that the entire set is consecutive, but the ordering must be such that the two intervals (4 and 3 for major) are consecutive in the circle.\n\n        However, the problem says: \"the distance along the musical scale\", meaning we are moving from the lowest to the highest. But in the example \"C# B F\", the ordering they used was B, C#, F. This ordering is not the natural ascending order in the linear sense? But in the circle, we can start at B and then go up to C# and then to F.\n\n        But note: the problem says the chord is unordered. We are allowed to choose any ordering.\n\n        However, the condition requires that the three notes form two consecutive intervals of 4 and 3 (for major) or 3 and 4 (for minor). \n\n        But note: the entire chord must be contained in a span of 7 semitones? Because 4+3=7, and the third note is 7 semitones above the first. \n\n        However, because of the circularity, we might have multiple possibilities.\n\n        Let's break down the steps:\n\n        Step 1: Map the three input notes to their numerical values.\n\n        Step 2: Generate all 6 permutations of the three notes.\n\n        Step 3: For each permutation [a, b, c]:\n                d1 = (b - a) % 12\n                d2 = (c - b) % 12\n\n                But wait, what if the chord wraps around? Actually, the condition does not require that the entire chord is within a span of less than 12 semitones? \n\n                However, note: the problem says the distance is taken from the lowest to the highest. So we are effectively considering the notes in a linearized version of the circle? \n\n                Actually, the problem says: \"the distance between C and E is 4 semitones and between E and C is 8 semitones\". So the distance from a to b is defined as the upward movement (which might be more than 6 if going the long way). But the chord condition requires two consecutive intervals: 4 and 3 (total 7) or 3 and 4 (total 7). \n\n                However, if the chord spans more than 12 semitones, then we might have multiple representations? But the problem states that the notes are repeated cyclically.\n\n        But note: the condition requires that we can order the notes so that the distances are 4 and 3 (or 3 and 4). \n\n        However, the total span from the first to the last note is 7 semitones. But wait: if we have a chord that is major, the three notes are separated by 4 and 3, so the total from the first to the last is 7. Similarly for minor.\n\n        But the circle has 12 semitones, so we can have two possibilities for the same set of notes? \n\n        Example: Consider the chord \"C E G\". \n          One representation: starting at C: [0,4,7] -> distances: 4 and 3.\n          Another representation: starting at E: [4,7,11] (but then 7 to 11 is 4, and 4 to 7 is 3, but wait: the chord is {0,4,7}. If we start at E (4), then we need to go to G (7) and then to the next note? But the next note is C (0). The distance from 7 to 0 is (0-7)%12 = 5, which is not 3 or 4.\n\n        Actually, the condition requires the entire set of three notes to be consecutive in the ordering? \n\n        Let me read again: \"If we can order the notes so as the distance along the musical scale between X and Y equals 4 semitones and the distance between Y and Z equals 3 semitones\"\n\n        This ordering must be three distinct notes and the distances are measured without wrapping? \n\n        But the example \"C E G\": \n          Ordering: [C, E, G] -> distances: 4 and 3. \n          What if we try ordering [E, G, C]? \n            E to G: (7-4)=3 -> ok, then G to C: (0-7)%12 = (0-7+12)%12 = 5 -> not 4.\n\n        And ordering [G, C, E]: \n            G to C: (0-7)%12=5, then C to E: (4-0)=4 -> doesn't match.\n\n        So the condition is very specific: the three notes must be consecutive in the circle with the two intervals being 4 and 3 (for major) or 3 and 4 (for minor). \n\n        However, note: the chord is defined as an unordered set. The condition requires that there exists an ordering (X, Y, Z) such that the distance from X to Y is 4 (or 3) and from Y to Z is 3 (or 4). \n\n        But wait, the entire chord must be contained in a contiguous segment of the circle of length 7? Because 4+3=7. \n\n        However, the circle is 12, so if the chord spans 7 semitones, then the remaining part of the circle is 5 semitones. \n\n        But note: the chord is three distinct notes, and the entire set must be contained in an interval of 7 semitones (so that the two intervals add up to 7). \n\n        Therefore, we can also check: the entire span from the lowest note to the highest note (without wrapping) must be <= 7? Or we can check the condition with the modulus.\n\n        However, the modulus condition we are using already accounts for the circularity.\n\n        But note: the condition for the entire chord: \n            We are only checking two consecutive steps (each step being the distance between two adjacent notes in the chosen ordering). The total from X to Z is (Z-X) mod 12 = (d1+d2) mod 12. But we don't require that the entire chord is without wrapping. \n\n        Actually, the example \"C# B F\": \n            The three notes: [10,1,5]. We are allowed to reorder. The condition is satisfied for [10,1,5] (which is [B, C#, F]): \n                d1 = (1-10)%12 = -9%12=3, d2=(5-1)%12=4 -> minor.\n\n        But note: the entire chord spans from 10 to 5: but 5 is less than 10, so we can also think of it as from 10 to 1 (which is 3) and then from 1 to 5 (which is 4). \n\n        However, the problem does not require that the entire chord is contiguous in the linear sense. It uses the circular definition of distance.\n\n        Therefore, we can use the modulus method.\n\n        Algorithm:\n\n        1. Create a list of note names: ['C','C#','D','D#','E','F','F#','G','G#','A','B','H']\n        2. Map each note to its index.\n\n        3. Read the input string, split into three parts.\n\n        4. Convert each note to its index.\n\n        5. Generate all permutations of these three indices.\n\n        6. For each permutation [a,b,c]:\n                d1 = (b - a) % 12\n                d2 = (c - b) % 12\n                # But wait, is that the entire story? \n\n                However, note: the condition does not require that the entire chord is only these three notes? Actually, no. We are only concerned with the two consecutive distances.\n\n                But there is a catch: the condition requires that the entire set is {a, b, c}. The modulus calculation is correct for the distances.\n\n                However, note: the problem says the chord is unordered, but we are considering a specific ordering. \n\n                But what if the three notes are not consecutive in the circle? Then we might get a different total distance. \n\n                Example: \"C D F\" -> \n                    Permutations: \n                      [0,2,5]: \n                        d1 = (2-0)%12=2, d2=(5-2)%12=3 -> doesn't match.\n                      [0,5,2]: \n                        d1 = (5-0)%12=5, d2=(2-5)%12= (2-5+12)%12=9 -> no.\n                      [2,0,5]: \n                        d1 = (0-2)%12=10, d2=(5-0)%12=5 -> no.\n                      [2,5,0]:\n                        d1 = (5-2)=3, d2=(0-5)%12=7 -> no.\n                      [5,0,2]:\n                        d1 = (0-5)%12=7, d2=(2-0)=2 -> no.\n                      [5,2,0]:\n                        d1 = (2-5)%12= (2-5+12)=9, d2=(0-2)%12=10 -> no.\n\n                So \"C D F\" is strange.\n\n        7. However, we must check the condition: the entire set must be {a, b, c}. But we are generating permutations of the given set, so no duplicates.\n\n        8. We'll check for major: d1==4 and d2==3\n           minor: d1==3 and d2==4\n\n        9. But note: the condition in the problem says the chord is an unordered set. However, the condition requires an ordering. So we must check all orderings.\n\n        10. If at least one ordering satisfies the major condition, output \"major\".\n            Else, if at least one ordering satisfies the minor condition, output \"minor\".\n            Else, output \"strange\".\n\n        However, note: the problem states that the answer is unambiguous, so no chord is both major and minor.\n\n        But wait: is it possible that two different orderings could satisfy both conditions? \n            Example: \n                Major: [a,b,c] with (b-a)%12=4 and (c-b)%12=3.\n                Minor: [a,b,c] with (b-a)%12=3 and (c-b)%12=4.\n\n            These are two different conditions. Also, the total from a to c is 7 in both cases. But the intermediate note is different.\n\n        However, the problem says there are no chords that are both major and minor simultaneously.\n\n        But note: what if we have two different orderings that are both major? That would be two different ways to assign the root? \n\n        Actually, the condition for a major chord is that the intervals are 4 and 3. The root is the first note. \n\n        Example: Let's take a major chord: \"C E G\" (0,4,7). \n            Ordering [0,4,7]: 4 and 3 -> major.\n            Ordering [4,7,0]: \n                d1 = (7-4)=3, d2=(0-7)%12=5 -> not minor (we require 4) and not major (we require 4 then 3, but here we have 3 then 5).\n            Ordering [7,0,4]:\n                d1 = (0-7)%12=5, d2=(4-0)=4 -> no.\n\n        So only one ordering for this chord is major.\n\n        Similarly, for a minor chord: \"C D# G\" (0,3,7) -> \n            Ordering [0,3,7]: d1=3, d2=4 -> minor.\n            Ordering [3,7,0]: d1=(7-3)=4, d2=(0-7)%12=5 -> no.\n            Ordering [7,0,3]: d1=(0-7)%12=5, d2=(3-0)=3 -> no.\n\n        So we can simply check all six permutations and if we find at least one major OR at least one minor, we output accordingly.\n\n        However, note: the problem says the chord has exactly three distinct notes.\n\n        Implementation:\n\n        Let notes = ['C','C#','D','D#','E','F','F#','G','G#','A','B','H']\n\n        mapping = {'C':0, 'C#':1, 'D':2, 'D#':3, 'E':4, 'F':5, 'F#':6, 'G':7, 'G#':8, 'A':9, 'B':10, 'H':11}\n\n        Steps:\n\n        data = input().split()\n        n1, n2, n3 = data\n\n        indices = [mapping[n1], mapping[n2], mapping[n3]]\n\n        from itertools import permutations\n        perms = permutations(indices)\n\n        found_major = False\n        found_minor = False\n\n        for p in perms:\n            a, b, c = p\n            d1 = (b - a) % 12\n            d2 = (c - b) % 12\n            if d1 == 4 and d2 == 3:\n                found_major = True\n            if d1 == 3 and d2 == 4:\n                found_minor = True\n\n        Then:\n            if found_major:\n                print(\"major\")\n            elif found_minor:\n                print(\"minor\")\n            else:\n                print(\"strange\")\n\n        Let's test with the examples:\n\n        Example 1: \"C E G\" -> [0,4,7]\n          Permutation (0,4,7): d1=4, d2=3 -> major -> found_major=True.\n\n        Example 2: \"C# B F\" -> [1,10,5]\n          We need to find the permutation that is [10,1,5] (B, C#, F): \n            a=10, b=1, c=5.\n            d1 = (1-10)%12 = (-9)%12 = 3\n            d2 = (5-1)%12 = 4 -> minor -> found_minor=True.\n\n        Example 3: \"A B H\" -> [9,10,11]\n          Permutations: \n            [9,10,11]: d1=1, d2=1 -> no.\n            [9,11,10]: d1=2, d2= (10-11)%12=11 -> no.\n            [10,9,11]: d1=(9-10)%12=11, d2=2 -> no.\n            [10,11,9]: d1=1, d2=(9-11)%12= (9-11+12)%12=10 -> no.\n            [11,9,10]: d1=(9-11)%12= (9-11+12)%12=10, d2=1 -> no.\n            [11,10,9]: d1=(10-11)%12=11, d2=(9-10)%12=11 -> no.\n\n          Output \"strange\", as expected.\n\n        However, wait: what if we have a chord that is major but the distances are computed differently? \n\n        Example: \"C E G\" is major. But what about the same chord in a different inversion? \n          We saw that only one inversion (root position) gives the major condition.\n\n        But note: the problem says the chord is an unordered set, so we must consider all inversions.\n\n        However, the condition requires the specific ordering (X,Y,Z) with the two consecutive intervals. \n\n        Another example: \"C E G\" in first inversion: E, G, C -> [4,7,0]\n          d1 = (7-4)=3, d2=(0-7)%12=5 -> not matching.\n\n        So our method is correct.\n\n        But wait: what if the chord is \"C E G\" but the input is given in a different order, say \"E G C\"? \n          Then we get [4,7,0]. We still check all permutations, including [4,7,0]. \n\n        However, note: we are generating all permutations of the three indices. So we are covering all orders.\n\n        One more edge: the chord \"C E G\" in second inversion: \"G C E\" -> [7,0,4]\n          d1 = (0-7)%12=5, d2=(4-0)=4 -> not matching.\n\n        So only the root position is major.\n\n        But note: the problem does not specify the inversion. We are just checking the condition on the set.\n\n        Therefore, the code is as below.\n\n        However, note: the problem says the notes are repeated cyclically, so the distance from a to b is the upward movement (which might be more than 6). \n\n        But the condition for the chord requires two consecutive intervals of 4 and 3 (or 3 and 4). \n\n        The modulus operation takes care of the circularity.\n\n        Let me test a chord that is major but the notes are given in a non-root position? \n\n        Example: \"E G C\" (same chord). We already did: [4,7,0] -> not major, but wait: the condition for major is: \n            There exists an ordering [X,Y,Z] such that (Y-X)%12=4 and (Z-Y)%12=3.\n\n        In [4,7,0]: \n            We cannot rearrange to get the root? Actually, the root is C (0). The condition for major is that the root is the first note? \n\n        But the problem does not require that. It just requires that we can order the notes arbitrarily. \n\n        However, the condition for the major chord is defined by the set {X,Y,Z} being such that we can arrange them so that the two consecutive intervals are 4 and 3. \n\n        In the set {0,4,7}, the ordering [0,4,7] is the only one that gives 4 and 3. The other orderings don't.\n\n        But what if we consider a different ordering? \n\n        We must consider all 6. \n\n        However, note: the problem does not specify the root. It's just an unordered set.\n\n        So if the teacher gives \"E G C\", then we are going to check:\n          [4,7,0]: d1=3, d2=5 -> no.\n          [4,0,7]: d1=(0-4)%12=8, d2=(7-0)=7 -> no.\n          [7,4,0]: d1=(4-7)%12=9, d2=(0-4)%12=8 -> no.\n          [7,0,4]: d1=5, d2=4 -> no.\n          [0,7,4]: d1=7, d2=(4-7)%12=9 -> no.\n          [0,4,7]: d1=4, d2=3 -> yes.\n\n        So we are checking all permutations, so we will find [0,4,7] even if the input is given as \"E G C\". \n\n        But wait: the input is given as three space-separated notes. We are converting the given notes to numbers. Then we are generating all permutations of the three numbers.\n\n        Example: input \"E G C\" -> [4,7,0] and then we generate permutations: one of them is (0,4,7). \n\n        So we are safe.\n\n        Code:\n\n        We'll use the above.\n\n        Let me code accordingly.\n\n        Note: We must be cautious of the input format. The input is one line with three space-separated notes.\n\n        Example input: \"C E G\"\n        Example input: \"C# B F\"\n        Example input: \"A B H\"\n\n        We assume the input notes are always valid.\n\n        Let's code accordingly.\n",
    "response": "\nTo solve this problem, we need to determine whether a given set of three musical notes forms a major chord, a minor chord, or neither. The solution involves checking all possible orderings of the three notes to see if any ordering satisfies the conditions for a major or minor chord.\n\n### Approach\n1. **Problem Analysis**: \n   - A major chord is defined by three notes where, in some ordering, the distance between the first and second note is 4 semitones, and the distance between the second and third note is 3 semitones.\n   - A minor chord is defined similarly, but with the distances being 3 and 4 semitones respectively.\n   - The challenge is to check all permutations of the three notes to determine if any permutation meets either of these conditions.\n\n2. **Key Insight**:\n   - Each note can be mapped to a numerical value (0 to 11) representing its position in the 12-note musical scale.\n   - The distance between two notes is calculated using modulo 12 arithmetic to handle the circular nature of the musical scale.\n\n3. **Algorithm Selection**:\n   - Convert each note to its corresponding numerical value.\n   - Generate all permutations of these three values.\n   - For each permutation, compute the distances between consecutive notes. If any permutation matches the major or minor chord conditions, note the result accordingly.\n\n4. **Complexity Analysis**:\n   - The algorithm checks all 6 permutations of three notes, which is a constant time operation (O(1)) since the number of permutations is fixed for three elements.\n\n### Solution Code\n```python\nimport itertools\n\ndef main():\n    notes_list = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B', 'H']\n    mapping = {note: idx for idx, note in enumerate(notes_list)}\n    \n    data = input().split()\n    if len(data) != 3:\n        print(\"strange\")\n        return\n        \n    try:\n        n1, n2, n3 = data\n    except Exception as e:\n        print(\"strange\")\n        return\n        \n    if n1 not in mapping or n2 not in mapping or n3 not in mapping:\n        print(\"strange\")\n        return\n        \n    indices = [mapping[n1], mapping[n2], mapping[n3]]\n    \n    found_major = False\n    found_minor = False\n    \n    for perm in itertools.permutations(indices):\n        a, b, c = perm\n        d1 = (b - a) % 12\n        d2 = (c - b) % 12\n        if d1 == 4 and d2 == 3:\n            found_major = True\n        if d1 == 3 and d2 == 4:\n            found_minor = True\n            \n    if found_major:\n        print(\"major\")\n    elif found_minor:\n        print(\"minor\")\n    else:\n        print(\"strange\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Mapping Notes to Numbers**: The code starts by creating a list of all 12 musical notes and a dictionary to map each note to its corresponding numerical value (0 to 11).\n2. **Input Handling**: The input is read and split into three parts. Each part is checked to ensure it is a valid note from the predefined list.\n3. **Permutation Check**: The code generates all permutations of the three input notes' numerical values. For each permutation, it calculates the distances between consecutive notes using modulo 12 arithmetic.\n4. **Condition Check**: The distances are checked against the conditions for a major chord (4 and 3 semitones) or a minor chord (3 and 4 semitones). If either condition is met, the corresponding result (\"major\" or \"minor\") is printed. If no conditions are met, \"strange\" is printed.\n\nThis approach efficiently checks all possible orderings of the input notes to determine the chord type, leveraging modular arithmetic to handle the circular nature of musical scales.",
    "ground_truth": "N/A",
    "extracted_answer": "import itertools\n\ndef main():\n    notes_list = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B', 'H']\n    mapping = {note: idx for idx, note in enumerate(notes_list)}\n    \n    data = input().split()\n    if len(data) != 3:\n        print(\"strange\")\n        return\n        \n    try:\n        n1, n2, n3 = data\n    except Exception as e:\n        print(\"strange\")\n        return\n        \n    if n1 not in mapping or n2 not in mapping or n3 not in mapping:\n        print(\"strange\")\n        return\n        \n    indices = [mapping[n1], mapping[n2], mapping[n3]]\n    \n    found_major = False\n    found_minor = False\n    \n    for perm in itertools.permutations(indices):\n        a, b, c = perm\n        d1 = (b - a) % 12\n        d2 = (c - b) % 12\n        if d1 == 4 and d2 == 3:\n            found_major = True\n        if d1 == 3 and d2 == 4:\n            found_minor = True\n            \n    if found_major:\n        print(\"major\")\n    elif found_minor:\n        print(\"minor\")\n    else:\n        print(\"strange\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 677,
        "completion_token_count": 859,
        "thoughts_token_count": 6239
    }
}