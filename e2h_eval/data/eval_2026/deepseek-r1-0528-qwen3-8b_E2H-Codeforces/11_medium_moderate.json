{
    "start": 1758088081.929612,
    "end": 1758089519.5992064,
    "start-formatted": "2025-09-17 14:48 KST",
    "end-formatted": "2025-09-17 15:11 KST",
    "gpu": 2,
    "pid": 11,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Soft Drinking\n\nThis winter is so cold in Nvodsk! A group of n friends decided to buy k bottles of a soft drink called \"Take-It-Light\" to warm up a bit. Each bottle has l milliliters of the drink. Also they bought c limes and cut each of them into d slices. After that they found p grams of salt.To make a toast, each friend needs nl milliliters of the drink, a slice of lime and np grams of salt. The friends want to make as many toasts as they can, provided they all drink the same amount. How many toasts can each friend make?\n\n## Input\nThe first and only line contains positive integers n, k, l, c, d, p, nl, np, not exceeding 1000 and no less than 1. The numbers are separated by exactly one space.\n\n## Output\nPrint a single integer — the number of toasts each friend can make.\n\n## Example\n### Input\n['3 4 5 10 8 100 3 1', '5 100 10 1 19 90 4 3', '10 1000 1000 25 23 1 50 1']\n\n### Output\n['2', '3', '0']\n\n## Note\nA comment to the first sample: Overall the friends have 4 * 5 = 20 milliliters of the drink, it is enough to make 20 / 3 = 6 toasts. The limes are enough for 10 * 8 = 80 toasts and the salt is enough for 100 / 1 = 100 toasts. However, there are 3 friends in the group, so the answer is min(6, 80, 100) / 3 = 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\n We are given one line of input with 8 positive integers: n, k, l, c, d, p, nl, np.\n Each bottle has 'l' milliliters. They have k bottles -> total drink = k * l milliliters.\n For a toast, each friend needs nl milliliters. But note: the toasts are for the entire group? Actually, the problem says:\n \"each friend needs nl milliliters of the drink\" for one toast. But they want to make toasts such that each friend gets the same amount.\n\n However, note that the problem says: \"each friend needs nl milliliters of the drink, a slice of lime and np grams of salt\" for one toast.\n\n Steps:\n 1. Calculate the total available drink in milliliters: total_drink = k * l\n 2. Calculate the total available lime slices: from c limes, each cut into d slices -> total_slices = c * d\n\n 3. Now, for one toast, we need:\n    - drink: nl milliliters (per friend per toast) but note: the entire group is making the same number of toasts per friend?\n    Actually, the problem says: \"each friend needs nl milliliters of the drink\" for one toast.\n\n    But wait: if we are making T toasts per friend, then the total drink required is n * T * nl.\n    Similarly, for salt: total salt required is n * T * np.\n    And for lime: total slices required is n * T (since each toast requires one slice per friend).\n\n 4. Alternatively, we can think: \n    - The drink limits the total number of toasts (per friend) as: floor(total_drink / (n * nl))\n    - The lime limits: floor(total_slices / n)   [because each toast per friend requires one slice, and there are n friends, so total slices needed for T toasts is n*T]\n    - The salt limits: floor(p / (n * np))\n\n 5. However, note: the example input: \"3 4 5 10 8 100 3 1\"\n    Here: n=3, k=4, l=5, c=10, d=8, p=100, nl=3, np=1.\n\n    Total drink = 4*5 = 20 ml.\n    Drink requirement per toast for the whole group: 3 * 3 = 9 ml? Actually, wait: the problem says \"each friend needs nl milliliters\", so for one toast, one friend uses nl. Therefore, for T toasts per friend, the total drink used is n * T * nl.\n\n    So, maximum T from drink: floor(20 / (3 * 3)) = 20 / 9 -> 2 (using integer division, but note: we must use floor)\n\n    Lime: total_slices = 10*8 = 80. Then total slices for T toasts: 3 * T. So T <= 80 // 3 -> 26 (but wait, we are going to take the minimum of the constraints, so let's see)\n\n    Salt: p=100, so total salt needed: 3 * T * 1 -> T <= 100 // 3 = 33 (so 33)\n\n    Then the answer would be min( floor(20/(3*3)), floor(80/3), floor(100/(3*1)) ) -> min(2, 26, 33) = 2.\n\n    But wait, in the example explanation: \n        \"Overall the friends have 20 milliliters of the drink, it is enough to make 20 / 3 = 6 toasts.\"\n    Why 6? Because the example is considering that each toast requires 3 ml for the entire group? \n\n    Let me re-read: \"each friend needs nl milliliters of the drink\" for one toast. So for one toast, the entire group (n friends) will consume n * nl milliliters.\n\n    However, the example says: \"it is enough to make 20 / 3 = 6 toasts\". That calculation seems to be using the entire bottle's drink divided by the amount per toast (which is 3 ml) without multiplying by the number of friends. \n\n    This indicates that the example is actually considering that one toast (for the entire group) requires 3 ml? But wait, the problem says: \"each friend needs nl milliliters\" for one toast. So for one toast, one friend uses 3 ml. Then if there are 3 friends, then one toast (if we consider one toast for the entire group) would require 3 * 3 = 9 ml? \n\n    However, the example calculation does not multiply by the number of friends. Let me read the example again:\n\n    \"After that they found p grams of salt.To make a toast, each friend needs nl milliliters of the drink, a slice of lime and np grams of salt.\"\n\n    So for one toast, each friend must have their own drink, lime, and salt. Therefore, for one toast, we need:\n        drink: n * nl\n        lime: n slices (one per friend)\n        salt: n * np\n\n    But wait, the example calculation for drink: 20 / 3 = 6 toasts. This 3 is nl (which is 3). So they are dividing the total drink by 3 (nl) and getting 6 toasts. But note: these 6 toasts are for the entire group? Or per friend?\n\n    The problem says: \"the friends want to make as many toasts as they can, provided they all drink the same amount.\"\n\n    And then: \"How many toasts can each friend make?\"\n\n    So the example: \n        Total drink: 20 ml. \n        Each toast (meaning one toast for one friend) requires 3 ml. But wait, the problem doesn't say \"each toast\" meaning per friend. It says \"each friend needs nl milliliters\" for one toast.\n\n    However, the example then says: \"it is enough to make 20 / 3 = 6 toasts\". Then they divide by 3 (the number of friends) to get 2 toasts per friend.\n\n    This implies that the example considers that one toast is for the entire group? But that contradicts the statement.\n\n    Let me clarify: \n        In the example, they have 3 friends. Each friend needs 3 ml for one toast. So if we want to make T toasts for the entire group (meaning each friend makes T toasts), then the total drink needed is 3 * T * 3 = 9T ml.\n\n    But the example calculation was: total_drink / nl = 20 / 3 ~ 6. Then they divide by 3 (number of friends) to get 2.\n\n    Alternatively, the example might be thinking: \n        How many toasts can we have in total (across all friends) if we consider that each toast (by any friend) requires nl ml? Then total toasts (not per friend) is floor(total_drink / nl) = 6. But then we have to distribute these toasts equally among the 3 friends, so each friend gets 6 // 3 = 2.\n\n    This matches.\n\n    So two interpretations:\n\n    Interpretation 1 (as initially): \n        Let T be the number of toasts per friend.\n        Then total drink needed = n * T * nl.\n        Then T <= total_drink / (n * nl)\n\n    Interpretation 2 (from example explanation):\n        Let T_total be the total number of toasts (across all friends). Then each toast (anywhere) requires nl ml (because each toast must be consumed by one friend, and each toast for one friend requires nl). Also, the lime and salt are similarly global? \n\n    But note: the lime and salt: \n        The example: lime slices = 80. Each toast requires one slice per friend? Actually, the problem says: \"a slice of lime\" per toast (and each toast is for one friend). So if we have T_total toasts, then we need T_total slices? But wait, no: because each toast is for one friend, so if there are n friends, then each friend must have T_toasts slices? \n\n    Actually, the problem states: \n        To make a toast, each friend needs ... \n        So if we are making T_total toasts, then we must have at least T_total drinks (because each toast is one drink for one friend) and T_total lime slices? \n\n    Wait, that doesn't sound right. The problem says: \"each friend needs nl milliliters, a slice of lime and np grams of salt\" for one toast. \n\n    So if we have T_total toasts, then we must have:\n        drink: T_total * nl\n        lime: T_total (since each toast requires one slice, and each toast is for one friend? But note: if we have multiple friends, then the same toast cannot be shared. Actually, the problem is about having each friend make the same number of toasts.\n\n    After reading the problem again: \"provided they all drink the same amount.\" and \"How many toasts can each friend make?\".\n\n    So the total number of toasts is n * T (where T is the number per friend). Then the requirements are:\n        drink: n * T * nl\n        lime: n * T   (because each toast requires one lime slice per friend, and there are n*T toasts in total, but wait: each toast is associated with one friend. So actually, for each friend, we need T slices. Therefore, total slices needed = n * T.\n        salt: n * T * np\n\n    Alternatively, we can also think: the total drink must be at least n * T * nl, so T <= (total_drink) / (n * nl)\n\n    Similarly, T <= (total_slices) / n   [because total_slices must be >= n * T]\n\n    And T <= (p) / (n * np)\n\n    Then the answer is the floor of the minimum of these three values.\n\n    Example: \n        n=3, k=4, l=5, c=10, d=8, p=100, nl=3, np=1.\n\n        total_drink = 20\n        total_slices = 80\n\n        T_drink = 20 / (3*3) = 20/9 -> floor(20/9)=2 (if we use integer division, but note: the problem says \"as many as possible\", so we use floor division, but we have to use integer values)\n\n        T_lime = 80 / 3 -> floor(80/3)=26 (if we do integer floor division) but wait, we are going to take the minimum, and then we have to check salt.\n\n        T_salt = 100 / (3*1) = 100/3 -> floor(100/3)=33.\n\n        Then T = min(2, 26, 33) = 2.\n\n    However, the example explanation did: \n        total_drink / nl = 20/3 = 6 -> then 6/3 = 2.\n\n    This method is different: \n        total_drink / nl gives the total number of toasts (if we consider that each toast uses nl ml) but note: in this interpretation, each toast is one drink for one friend? Actually, no: because one toast requires nl ml per friend? \n\n    Let me break down the example explanation:\n\n        They said: \"it is enough to make 20 / 3 = 6 toasts\"\n\n    This 6 is the total number of toasts (each toast being one drink for one friend) because 20 ml is enough for 20/3 toasts (each toast requiring 3 ml) and then they divide by 3 (the number of friends) to get the number per friend.\n\n    But wait, why divide by 3? Because if there are 3 friends, then the total toasts (which is 6) must be distributed equally. So each friend gets 6/3 = 2 toasts.\n\n    This is equivalent to:\n\n        total_toasts = min( total_drink // nl, total_slices, p // np )   [but wait, the lime: each toast requires one slice, so total_slices is the maximum toasts (if we think of toasts as requiring one slice) but note: the drink requirement is nl per toast, and the salt requirement is np per toast.\n\n    However, the problem states: \n        Each toast requires: \n            drink: nl (per friend) -> but wait, this is confusing.\n\n    Let me re-define:\n\n    Option A (by per-friend toast count):\n\n        Let T be the number of toasts per friend.\n        Then total toasts (across all friends) is n * T.\n\n        Constraints:\n          n * T * nl <= k * l   => T <= (k*l) / (n * nl)\n          n * T <= c * d         => T <= (c*d) / n\n          n * T * np <= p       => T <= p / (n * np)\n\n        Then T_max = floor(min( (k*l)/(n*nl), (c*d)/n, p/(n*np) ))\n\n    Option B (by total toasts, say X):\n\n        Then each friend can make X / n toasts (so X must be divisible by n? Actually, we want the maximum T such that n*T <= X, but we are taking floor so T = floor(X / n) but actually we can set X = min( (k*l)//nl, (c*d), p//np )? \n\n        But wait, the drink: each toast (one toast for one friend) requires nl ml. So the total ml must be at least (number of toasts) * nl. Similarly, the lime: each toast requires one slice. The salt: each toast requires np grams.\n\n        Then the maximum total toasts X is limited by:\n            X <= (k*l) // nl\n            X <= (c*d)   [since each toast requires one lime slice, and we have c*d slices]\n            X <= p // np\n\n        Then each friend can make T = X // n   (because we must distribute equally, and we can only make whole toasts).\n\n        But wait, what if X is not divisible by n? Then we can only make T = floor(X/n) toasts per friend, because we cannot have a partial toast.\n\n        Example: \n            n=3, k=4, l=5, c=10, d=8, p=100, nl=3, np=1.\n\n            X_drink = 20 // 3 = 6\n            X_lime = 80\n            X_salt = 100 // 1 = 100\n\n            Then X = min(6, 80, 100) = 6.\n\n            Then T = 6 // 3 = 2.\n\n        Another example: \n            Input: \"5 100 10 1 19 90 4 3\"\n\n            n=5, k=100, l=10, c=1, d=19, p=90, nl=4, np=3.\n\n            X_drink = (100*10) // 4 = 1000//4 = 250\n            X_lime = 1*19 = 19\n            X_salt = 90 // 3 = 30\n\n            Then X = min(250, 19, 30) = 19.\n\n            Then T = 19 // 5 = 3 (since 19//5 is 3)\n\n        And the expected output is 3.\n\n        Now the third sample: \n            Input: \"10 1000 1000 25 23 1 50 1\"\n\n            n=10, k=1000, l=1000, c=25, d=23, p=1, nl=50, np=1.\n\n            X_drink = (1000*1000) // 50 = 1000000//50 = 20000\n            X_lime = 25*23 = 575\n            X_salt = 1 // 1 = 1\n\n            X = min(20000,575,1) = 1\n            T = 1 // 10 = 0\n\n        So the output is 0.\n\n    Now, which option is correct?\n\n    The problem says: \"each friend needs nl milliliters, a slice of lime and np grams of salt\" for one toast.\n\n    This means that one toast (for one friend) requires:\n        drink: nl\n        lime: 1 slice\n        salt: np\n\n    Therefore, if we are making T toasts per friend, then the entire group makes n*T toasts. Each toast (regardless of friend) requires the same resources.\n\n    So the resources are used per toast (each toast being one drink, one slice, one salt portion). \n\n    Then the total resources required are:\n        drink: (n*T) * nl\n        lime: (n*T) * 1   [because each toast requires one slice]\n        salt: (n*T) * np\n\n    Alternatively, we can compute the maximum total toasts (X) that can be made (without considering the equal distribution) as:\n\n        X <= (k*l) / nl   [each toast uses nl ml]\n        X <= (c*d)        [each toast uses 1 slice]\n        X <= p / np       [each toast uses np grams]\n\n    Then, since the friends must drink the same amount, the number of toasts per friend is X // n (because we have X total toasts and n friends, so each friend gets X//n toasts, and we can't exceed the total toasts).\n\n    However, note: we might have leftover toasts if X is not divisible by n, but the problem says they all drink the same amount, so we can only assign whole toasts.\n\n    But wait: the problem does not say that we must use all the resources. We are to maximize the number of toasts per friend, and they must be the same for all.\n\n    The above approach (Option B) is simpler and matches the examples.\n\n    However, note: the example calculation in the problem statement does:\n\n        Drink: 20 / 3 = 6 toasts (total toasts from drink) -> then 6 / 3 = 2 per friend.\n\n    So we can use:\n\n        total_toasts = min( (k*l) // nl, c*d, p // np )\n        per_friend = total_toasts // n\n\n    But wait, is that correct for the drink? \n\n        In the drink constraint: we are doing (k*l) // nl. This is the total toasts (each toast requiring nl ml) that the drink can support.\n\n    Similarly, lime: each toast requires one slice, so the total toasts cannot exceed c*d.\n\n    Salt: each toast requires np grams, so total toasts cannot exceed p // np.\n\n    Then we take the minimum of these three to get the total toasts (X) that can be made.\n\n    Then we distribute these toasts equally: each friend gets X // n.\n\n    Why floor? Because if we have 7 toasts and 3 friends, then we can only give 2 toasts per friend (since 2*3=6) and leave one toast unused.\n\n    But wait, the problem says: \"as many as they can\", and they must all drink the same amount. So we cannot use fractional toasts.\n\n    Therefore, the answer is:\n\n        total_toasts = min( (k*l) // nl, c*d, p // np )\n        answer = total_toasts // n\n\n    However, note: the integer division (//) in Python for positive numbers is floor division, which is what we want.\n\n    But let me test with the examples:\n\n    Example 1: \n        n=3, k=4, l=5, c=10, d=8, p=100, nl=3, np=1.\n        total_toasts = min( (4*5)//3, 10*8, 100//1 ) = min(20//3, 80, 100) = min(6,80,100)=6\n        answer = 6 // 3 = 2 -> Correct.\n\n    Example 2: \n        Input: \"5 100 10 1 19 90 4 3\"\n        n=5, k=100, l=10, c=1, d=19, p=90, nl=4, np=3.\n        total_toasts = min( (100*10)//4, 1*19, 90//3 ) = min(1000//4, 19, 30) = min(250,19,30)=19\n        answer = 19 // 5 = 3 -> Correct.\n\n    Example 3: \n        Input: \"10 1000 1000 25 23 1 50 1\"\n        n=10, k=1000, l=1000, c=25, d=23, p=1, nl=50, np=1.\n        total_toasts = min( (1000*1000)//50, 25*23, 1//1 ) = min(1000000//50, 575, 1) = min(20000,575,1)=1\n        answer = 1 // 10 = 0 -> Correct.\n\n    But wait, there's a catch: the drink constraint: (k*l) // nl is integer division. What if the drink is not enough for an integer number of toasts? \n\n    Example: if we have 7 ml and nl=3, then 7//3=2, meaning we can only make 2 toasts (each requiring 3 ml). That is correct.\n\n    However, note: the problem says \"positive integers\", so we don't have to worry about floating point.\n\n    Therefore, the solution is:\n\n        Read the 8 integers: n, k, l, c, d, p, nl, np.\n\n        total_drink_ml = k * l\n        total_slices = c * d\n\n        max_toasts_by_drink = total_drink_ml // nl\n        max_toasts_by_lime = total_slices\n        max_toasts_by_salt = p // np\n\n        total_toasts = min(max_toasts_by_drink, max_toasts_by_lime, max_toasts_by_salt)\n\n        answer = total_toasts // n\n\n    Print the answer.\n\n    However, wait: what if one of the constraints is zero? The problem says positive integers, so all are at least 1. So no zeros.\n\n    But note: the drink constraint uses integer division, and if nl is large then max_toasts_by_drink could be zero. That is acceptable.\n\n    Let me write the code accordingly.\n\n    However, wait: the problem says the numbers are positive and not less than 1, so we are safe.\n\n    But wait: what if the total_drink_ml is 0? But k and l are at least 1, so no.\n\n    Code:\n\n        data = input().split()\n        n = int(data[0])\n        k = int(data[1])\n        l = int(data[2])\n        c = int(data[3])\n        d = int(data[4])\n        p = int(data[5])\n        nl = int(data[6])\n        np = int(data[7])\n\n        total_drink = k * l\n        total_slices = c * d\n\n        # Calculate the maximum toasts from drink: total_drink // nl\n        max_toasts_drink = total_drink // nl\n        max_toasts_lime = total_slices\n        max_toasts_salt = p // np\n\n        total_toasts = min(max_toasts_drink, max_toasts_lime, max_toasts_salt)\n\n        # Since the toasts must be distributed equally, we do integer division by n.\n        ans = total_toasts // n\n\n        print(ans)\n\n    But wait, in the example, the drink constraint was calculated as total_drink // nl, which is correct because each toast requires nl ml.\n\n    However, note: the example calculation for drink was 20/3, which is 6.66... and then floor to 6. Our code does integer floor division, so that's the same.\n\n    But wait: the problem says the numbers are positive integers. The division for drink: total_drink (an integer) divided by nl (an integer) using floor division is the same as math.floor(total_drink / nl) for nonnegative numbers.\n\n    Therefore, the code is correct.\n\n    However, note: the example did 20/3 and got 6, which is floor(20/3). But in our code, 20//3 is 6 (in Python, integer floor division).\n\n    Let me run the provided examples:\n\n        Example 1: \n            Input: \"3 4 5 10 8 100 3 1\"\n            Output: 2\n\n        Example 2: \n            Input: \"5 100 10 1 19 90 4 3\"\n            Output: 3\n\n        Example 3: \n            Input: \"10 1000 1000 25 23 1 50 1\"\n            Output: 0\n\n    So we output the answers as integers.\n\n    However, note: the example input format: the first and only line contains positive integers.\n\n    Let me test with the sample inputs.\n\n    But wait, the sample input is given as a list of strings? Actually, the example input is provided as:\n\n        ['3 4 5 10 8 100 3 1', '5 100 10 1 19 90 4 3', '10 1000 1000 25 23 1 50 1']\n\n    But in the problem, the input is one line. So we read one line.\n\n    However, the problem says: \"The first and only line contains positive integers\"\n\n    So we read one line.\n\n    Code:\n\n        data = input().split()\n        # If the input is exactly one line, then split by space.\n\n    But note: the sample input in the problem statement is shown as a list of three strings. But the actual input is one line.\n\n    I'll assume the input is one line.\n\n    Let me test with the provided examples.\n\n    Example 1: \n        Input: \"3 4 5 10 8 100 3 1\"\n        Output: 2\n\n    Example 2: \n        Input: \"5 100 10 1 19 90 4 3\"\n        Output: 3\n\n    Example 3: \n        Input: \"10 1000 1000 25 23 1 50 1\"\n        Output: 0\n\n    We'll write the code accordingly.\n\n    One more edge: when n=1, then we just take the minimum of the three and then divide by 1.\n\n    Example: n=1, k=1, l=1, c=1, d=1, p=1, nl=1, np=1.\n        total_drink = 1\n        max_toasts_drink = 1 // 1 = 1\n        max_toasts_lime = 1\n        max_toasts_salt = 1 // 1 = 1\n        total_toasts = 1\n        ans = 1 // 1 = 1.\n\n    This is correct.\n\n    Therefore, the code is:\n\n        data = input().split()\n        n = int(data[0])\n        k = int(data[1])\n        l = int(data[2])\n        c = int(data[3])\n        d = int(data[4])\n        p = int(data[5])\n        nl = int(data[6])\n        np = int(data[7])\n\n        total_drink = k * l\n        total_slices = c * d\n\n        max_toasts_drink = total_drink // nl\n        max_toasts_lime = total_slices\n        max_toasts_salt = p // np\n\n        total_toasts = min(max_toasts_drink, max_toasts_lime, max_toasts_salt)\n\n        ans = total_toasts // n\n\n        print(ans)\n\n    However, wait: what if the drink, lime, or salt is not enough to even make one toast? Then the answer is 0.\n\n    Example: n=3, k=0 -> but k is at least 1. So no.\n\n    All constraints are satisfied.\n\n    But wait: what if the drink constraint is fractional and we are using floor division? That's correct because we can't make a fraction of a toast.\n\n    However, note: the drink constraint is total_drink // nl, which is the maximum number of toasts (each requiring nl) we can make from the drink. Similarly for the others.\n\n    Therefore, the solution is complete.\n\n    Let me submit the code.\n",
    "response": "\nTo solve this problem, we need to determine the maximum number of toasts each friend can make given the available resources. Each toast requires a specific amount of drink, lime slices, and salt per friend. The goal is to maximize the number of toasts per friend while ensuring all friends consume the same amount.\n\n### Approach\n1. **Problem Analysis**: The problem involves calculating the maximum number of toasts that can be made based on the available resources (drink, lime slices, and salt). Each toast requires:\n   - `nl` milliliters of drink per friend.\n   - One lime slice per friend.\n   - `np` grams of salt per friend.\n   \n2. **Key Insight**: The total number of toasts is constrained by the most limiting resource. The solution involves:\n   - Calculating the total available drink (k * l) and determining how many toasts it can support (total_drink // nl).\n   - Calculating the total available lime slices (c * d), which directly gives the maximum possible toasts since each toast requires one slice.\n   - Calculating the total available salt (p // np) to see how many toasts it can support.\n\n3. **Algorithm Selection**: The solution involves:\n   - Computing the maximum toasts possible from each resource.\n   - Taking the minimum of these values to get the overall maximum toasts that can be made.\n   - Dividing this number by the number of friends (n) to determine how many toasts each friend can make, using integer division to ensure whole numbers.\n\n4. **Complexity Analysis**: The approach involves basic arithmetic operations and comparisons, making it efficient with a constant time complexity O(1).\n\n### Solution Code\n```python\ndef main():\n    data = input().split()\n    n = int(data[0])\n    k = int(data[1])\n    l = int(data[2])\n    c = int(data[3])\n    d = int(data[4])\n    p = int(data[5])\n    nl = int(data[6])\n    np = int(data[7])\n    \n    total_drink = k * l\n    total_slices = c * d\n    \n    max_toasts_drink = total_drink // nl\n    max_toasts_lime = total_slices\n    max_toasts_salt = p // np\n    \n    total_toasts = min(max_toasts_drink, max_toasts_lime, max_toasts_salt)\n    \n    ans = total_toasts // n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input consists of eight integers representing the number of friends (n), bottles of drink (k), milliliters per bottle (l), number of limes (c), slices per lime (d), grams of salt (p), drink required per toast per friend (nl), and salt required per toast per friend (np).\n\n2. **Calculating Resources**:\n   - **Total Drink**: The total milliliters of drink is calculated as `k * l`.\n   - **Total Lime Slices**: The total number of lime slices is `c * d`.\n\n3. **Determining Maximum Toasts**:\n   - **From Drink**: The number of toasts supported by the drink is `total_drink // nl`.\n   - **From Lime**: The number of toasts supported by lime slices is simply the total slices (`total_slices`).\n   - **From Salt**: The number of toasts supported by salt is `p // np`.\n\n4. **Finding the Minimum Constraint**: The actual maximum number of toasts is the smallest value among the three constraints calculated above.\n\n5. **Calculating Per-Friend Toasts**: The number of toasts each friend can make is found by dividing the total toasts by the number of friends, using integer division to ensure a whole number.\n\nThis approach efficiently leverages basic arithmetic and comparison operations to determine the solution, ensuring optimal performance and correctness.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    data = input().split()\n    n = int(data[0])\n    k = int(data[1])\n    l = int(data[2])\n    c = int(data[3])\n    d = int(data[4])\n    p = int(data[5])\n    nl = int(data[6])\n    np = int(data[7])\n    \n    total_drink = k * l\n    total_slices = c * d\n    \n    max_toasts_drink = total_drink // nl\n    max_toasts_lime = total_slices\n    max_toasts_salt = p // np\n    \n    total_toasts = min(max_toasts_drink, max_toasts_lime, max_toasts_salt)\n    \n    ans = total_toasts // n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 533,
        "completion_token_count": 822,
        "thoughts_token_count": 6497
    }
}