{
    "start": 1758296557.686529,
    "end": 1758299490.7059817,
    "start-formatted": "2025-09-20 00:42 KST",
    "end-formatted": "2025-09-20 01:31 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\n Okay, let's analyze the problem:\n\nWe are given two integers a and b (with 1 <= a, b <= 10^9). We need to find a non-negative integer k such that:\n   LCM(a+k, b+k) is minimized.\n\nNote: If multiple k yield the same minimal LCM, choose the smallest k.\n\nLet d = (a+k) and e = (b+k). Then note that d - e = a - b (constant). So we are looking for k such that the LCM of two numbers that differ by a fixed amount (d = a-b) is minimized.\n\nWe can write:\n   Let g = gcd(a+k, b+k). Then note that g must divide (a-b) because:\n        g divides (a+k) and (b+k), so it divides their difference: (a+k) - (b+k) = a-b.\n\nTherefore, g is a divisor of |a-b|.\n\nBut note: if a == b, then we have two identical numbers. Then LCM(a+k, a+k) = a+k. We want to minimize a+k, so we take k=0.\n\nSo, assume a != b. Let d = |a-b| (we can consider absolute value without loss of generality, but note: we might not need absolute value if we handle negative differences).\n\nHowever, note that k is non-negative and we are adding k to both.\n\nIdea:\n\nWe know that:\n   LCM(x, y) = (x * y) / GCD(x, y)\n\nBut here, x = a+k, y = b+k, and note that x-y = a-b (if we don't take absolute, then we have to be cautious). Actually, the sign doesn't matter for GCD.\n\nBut note: the LCM is defined for positive integers, and we are adding k so both become positive (since a,b>=1 and k>=0, so a+k>=1, b+k>=1).\n\nSo, we can write:\n   LCM(a+k, b+k) = (a+k)*(b+k) / GCD(a+k, b+k)\n\nBut note: the GCD(a+k, b+k) must divide (a-b). Therefore, the divisors we care about are the divisors of |a-b|.\n\nBut wait: is that always true? Actually, yes: because GCD(a+k, b+k) divides any linear combination, in particular (a+k) - (b+k) = a-b.\n\nSo, let D = |a-b|. Then the GCD must be a divisor of D.\n\nNow, we want to minimize the LCM. However, we cannot iterate over all divisors of D (which might be too many) and then for each divisor g, we need to find k such that GCD(a+k, b+k) = g and then compute the LCM.\n\nBut note: if we fix g (a divisor of D), then what conditions must hold?\n   Condition 1: g divides (a+k) and (b+k). \n   Condition 2: Since g divides (a-b), we have that g divides (a-b) and also (a+k) mod g = 0 and (b+k) mod g = 0.\n\nThis implies that k ≡ (-a) mod g and k ≡ (-b) mod g. But since a ≡ b (mod g) [because g divides (a-b)]? Actually, note: g divides (a-b) so a ≡ b (mod g). Therefore, the congruence conditions are consistent.\n\nThen, the smallest non-negative k satisfying k ≡ (-a) mod g is:\n   k0 = (g - a % g) % g   [but note: if a % g is 0, then k0=0; else k0 = g - (a % g)]\n\nBut wait: actually, we require k such that (a+k) is divisible by g. The condition is k ≡ (-a) mod g. The smallest non-negative k is indeed (g - a % g) % g. However, note that if a % g == 0, then k=0. Otherwise, k = g - (a % g). \n\nBut note: we must also have that g divides (a+k) and (b+k). Since a ≡ b (mod g) (because g divides (a-b)), then if k satisfies (a+k) mod g == 0, then (b+k) mod g = (a+k + (b-a)) mod g = (a+k) mod g - (a-b) mod g. But (a-b) is divisible by g, so (b+k) mod g = (a+k) mod g. Therefore, the same k works for both.\n\nSo for each divisor g of D (where D = |a-b|), we",
    "response": "\nTo solve this problem, we need to find a non-negative integer \\( k \\) such that the least common multiple (LCM) of \\( a + k \\) and \\( b + k \\) is minimized. If multiple values of \\( k \\) yield the same minimal LCM, we should choose the smallest \\( k \\).\n\n### Approach\n1. **Problem Analysis**: The key observation here is that the GCD of \\( a + k \\) and \\( b + k \\) must be a divisor of the absolute difference between \\( a \\) and \\( b \\). This is because the difference between \\( (a + k) \\) and \\( (b + k) \\) is \\( |a - b| \\), and any common divisor of \\( a + k \\) and \\( b + k \\) must divide this difference.\n\n2. **Insight**: For each divisor \\( g \\) of \\( |a - b| \\), we can determine the smallest \\( k \\) such that \\( g \\) divides both \\( a + k \\) and \\( b + k \\). This \\( k \\) is derived from the congruence condition \\( k \\equiv (-a) \\mod g \\). The smallest non-negative \\( k \\) satisfying this condition is \\( k = (g - a \\% g) \\% g \\).\n\n3. **Algorithm Selection**: We generate all divisors of \\( |a - b| \\). For each divisor \\( g \\), compute the corresponding \\( k \\) and the LCM of \\( a + k \\) and \\( b + k \\). Among all these \\( k \\) values, we select the one that yields the smallest LCM. If multiple \\( k \\) values give the same LCM, we choose the smallest \\( k \\).\n\n4. **Complexity Analysis**: The number of divisors of \\( |a - b| \\) is \\( O(\\sqrt{n}) \\), where \\( n \\) is \\( |a - b| \\). For each divisor, we perform constant-time operations, making the overall complexity \\( O(\\sqrt{n}) \\), which is efficient for \\( n \\) up to \\( 10^9 \\).\n\n### Solution Code\n```python\nimport math\n\ndef main():\n    a, b = map(int, input().split())\n    \n    if a == b:\n        print(0)\n        return\n        \n    d = abs(a - b)\n    divisors = set()\n    i = 1\n    while i * i <= d:\n        if d % i == 0:\n            divisors.add(i)\n            divisors.add(d // i)\n        i += 1\n        \n    best_k = 0\n    best_lcm = (a + best_k) * (b + best_k) // math.gcd(a + best_k, b + best_k)\n    \n    for g in divisors:\n        rem = a % g\n        if rem == 0:\n            k_val = 0\n        else:\n            k_val = g - rem\n            \n        x = a + k_val\n        y = b + k_val\n        current_gcd = math.gcd(x, y)\n        current_lcm = (x * y) // current_gcd\n        \n        if current_lcm < best_lcm:\n            best_lcm = current_lcm\n            best_k = k_val\n            \n    print(best_k)\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Input Handling**: The code reads two integers \\( a \\) and \\( b \\). If \\( a \\) equals \\( b \\), it immediately returns \\( 0 \\) since the LCM of two identical numbers is minimized at \\( k = 0 \\).\n\n2. **Divisor Calculation**: For \\( a \\neq b \\), the code calculates all divisors of \\( |a - b| \\) by iterating up to the square root of \\( |a - b| \\). Each divisor and its complement are added to a set to avoid duplicates.\n\n3. **Finding Optimal \\( k \\)**: For each divisor \\( g \\), the code computes the smallest \\( k \\) such that \\( g \\) divides both \\( a + k \\) and \\( b + k \\). The LCM of \\( a + k \\) and \\( b + k \\) is then calculated. The smallest \\( k \\) yielding the minimal LCM is tracked and printed.\n\n4. **Efficiency**: The algorithm efficiently checks all possible divisors of \\( |a - b| \\), ensuring optimal performance even for large values of \\( a \\) and \\( b \\) (up to \\( 10^9 \\)). The use of mathematical operations like GCD and modular arithmetic ensures correctness and efficiency.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef main():\n    a, b = map(int, input().split())\n    \n    if a == b:\n        print(0)\n        return\n        \n    d = abs(a - b)\n    divisors = set()\n    i = 1\n    while i * i <= d:\n        if d % i == 0:\n            divisors.add(i)\n            divisors.add(d // i)\n        i += 1\n        \n    best_k = 0\n    best_lcm = (a + best_k) * (b + best_k) // math.gcd(a + best_k, b + best_k)\n    \n    for g in divisors:\n        rem = a % g\n        if rem == 0:\n            k_val = 0\n        else:\n            k_val = g - rem\n            \n        x = a + k_val\n        y = b + k_val\n        current_gcd = math.gcd(x, y)\n        current_lcm = (x * y) // current_gcd\n        \n        if current_lcm < best_lcm:\n            best_lcm = current_lcm\n            best_k = k_val\n            \n    print(best_k)\n\nif __name__ == '__main__':\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 397,
        "completion_token_count": 991,
        "thoughts_token_count": 1023
    }
}