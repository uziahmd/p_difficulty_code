{
    "start": 1758088077.9113863,
    "end": 1758089233.9011676,
    "start-formatted": "2025-09-17 14:47 KST",
    "end-formatted": "2025-09-17 15:07 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\n Okay, we are given n and x, then n lines of (li, ri, costi)\n Conditions: \n   - We need two distinct vouchers i and j such that:\n        (ri - li + 1) + (rj - lj + 1) = x   [total duration is x]\n   - The two vouchers do not intersect: meaning either ri < lj or rj < li.\n\n Steps:\n\n Observation: The total duration condition is (duration_i + duration_j = x). So if we let d_i = ri - li + 1, then we require d_i + d_j = x.\n\n Also, the two vouchers must be disjoint. That means one ends before the other starts.\n\n Since n and the days can go up to 200,000, we need an efficient solution.\n\n Approach:\n\n 1. Precompute the duration for each voucher: d = ri - li + 1.\n\n 2. We want to find two vouchers (i, j) such that:\n      d_i + d_j = x\n      and the intervals [li, ri] and [lj, rj] do not overlap.\n\n 3. How to check non-overlap? Without loss of generality, we can consider two cases:\n      Case 1: The first voucher ends before the second starts: ri < lj.\n      Case 2: The second voucher ends before the first starts: rj < li.\n\n 4. We can try to group the vouchers by their duration. For each duration d, we store the intervals (the start and end) and also the cost.\n\n 5. However, note: we are looking for pairs with specific durations (d and x-d). So we can iterate over all durations d that are <= x/2, and then look for duration x-d.\n\n 6. But note: the same duration might appear multiple times, so we need to store multiple vouchers per duration.\n\n 7. Additionally, we have to check the non-overlapping condition. The non-overlapping condition depends on the actual intervals.\n\n 8. We can precompute:\n      For a fixed duration d, we have a set of intervals [l, r] (with r = l+d-1). Then for a voucher with duration d1 and another with duration d2 = x-d1, we require that the two intervals do not overlap.\n\n 9. We can break the problem into two parts:\n\n    a. Grouping by duration: Let's create a dictionary `by_duration` where key is duration, value is a list of tuples (l, r, cost) for that duration.\n\n    b. Then, we want to combine two groups: for each duration d, we look at the group for d and the group for x-d (if exists).\n\n    c. But note: if d == x-d, then we are looking for two distinct vouchers from the same group. Then we must ensure they are non-overlapping.\n\n 10. However, the challenge is that the non-overlapping condition is about the time intervals. We cannot simply check every pair because there could be many vouchers with the same duration.\n\n 11. Alternate approach:\n\n     We can preprocess the vouchers by sorting them by start (or by end) and then use two pointers or segment trees? But we have two conditions: one voucher must end before the other starts.\n\n     Actually, we can do:\n\n        Condition 1: For voucher i (duration d) and voucher j (duration x-d): we require either r_i < l_j or r_j < l_i.\n\n        This is equivalent to: the two intervals are disjoint.\n\n        We can break the two cases:\n\n        Case A: r_i < l_j (voucher i ends before voucher j starts)\n        Case B: r_j < l_i (voucher j ends before voucher i starts)\n\n        We can handle these separately.\n\n     But note: we are grouping by duration. So for a fixed duration d, we have a set of intervals. Similarly for duration x-d.\n\n     We can do:\n\n        For each duration d (from 1 to x//2, but actually d from 1 to x-1 and then d2=x-d), we consider:\n\n          Let A = list of intervals (l, r, cost) for duration d.\n          Let B = list of intervals (l, r, cost) for duration x-d.\n\n        Then we want to find two intervals, one from A and one from B, that do not overlap.\n\n        The non-overlapping condition is either:\n          Condition 1: r_A < l_B   (voucher from A ends before B starts)\n          Condition 2: r_B < l_A   (voucher from B ends before A starts)\n\n        And we want the minimal total cost (cost_A + cost_B).\n\n 12. How to efficiently find the minimal cost pair in A and B that satisfies one of the conditions?\n\n     We can preprocess each group (for",
    "response": "\nTo solve this problem, we need to find two distinct travel vouchers such that their combined duration equals exactly `x` days, they do not overlap in time, and their total cost is minimized. \n\n### Approach\n1. **Problem Analysis**: The problem requires selecting two non-overlapping vouchers where the sum of their durations is exactly `x`. Each voucher is characterized by its start day (`li`), end day (`ri`), and cost (`costi`). The duration of a voucher is calculated as `ri - li + 1`.\n\n2. **Intuition**: We can group vouchers by their durations. For each duration `d`, we look for another duration `x - d` (if it exists). Then, we check all pairs of vouchers from these two groups to see if they are non-overlapping (either one ends before the other starts). \n\n3. **Algorithm Selection**:\n   - **Grouping by Duration**: First, we group all vouchers by their durations into a dictionary where the key is the duration and the value is a list of tuples (start day, end day, cost).\n   - **Checking Valid Pairs**: For each duration `d`, we check if `x - d` exists. If it does, we then find all pairs of vouchers from `d` and `x - d` that do not overlap. To efficiently find these pairs, we preprocess the lists of vouchers for each duration by sorting them by their start or end days and then using binary search to find valid non-overlapping pairs.\n\n4. **Complexity Analysis**: \n   - **Grouping Vouchers**: This step involves iterating through all `n` vouchers once, which takes O(n) time.\n   - **Sorting and Binary Search**: For each duration, we sort the list of vouchers, which in the worst case could be O(n log n) per group. However, since the total number of distinct durations is at most 200,000 (as `ri` can be up to 200,000), the overall complexity remains manageable.\n\n### Solution Code\n```python\nimport sys\nfrom bisect import bisect_right\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(-1)\n        return\n        \n    n = int(data[0])\n    x = int(data[1])\n    vouchers = []\n    index = 2\n    for i in range(n):\n        l = int(data[index])\n        r = int(data[index+1])\n        c = int(data[index+2])\n        index += 3\n        vouchers.append((l, r, c))\n        \n    durations = {}\n    for l, r, c in vouchers:\n        dur = r - l + 1\n        if dur not in durations:\n            durations[dur] = []\n        durations[dur].append((l, r, c))\n        \n    min_total_cost = float('inf')\n    found = False\n    \n    for dur1, lst1 in durations.items():\n        dur2 = x - dur1\n        if dur2 not in durations:\n            continue\n            \n        lst2 = durations[dur2]\n        \n        if dur1 == dur2:\n            arr1 = sorted(lst1, key=lambda x: x[0])\n            arr2 = sorted(lst2, key=lambda x: x[0])\n            for a in arr1:\n                l1, r1, c1 = a\n                pos = bisect_right([b[0] for b in arr2], r1)\n                if pos > 0:\n                    candidate = arr2[pos-1]\n                    l2, r2, c2 = candidate\n                    if r1 < l2:\n                        total_cost = c1 + candidate[2]\n                        if total_cost < min_total_cost:\n                            min_total_cost = total_cost\n                            found = True\n            continue\n            \n        arr1 = sorted(lst1, key=lambda x: x[1])\n        arr2 = sorted(lst2, key=lambda x: x[0])\n        \n        for a in arr1:\n            l1, r1, c1 = a\n            pos = bisect_right([b[0] for b in arr2], r1)\n            if pos:\n                cand = arr2[pos-1]\n                l2, r2, c2 = cand\n                if r1 < l2:\n                    total_cost = c1 + c2\n                    if total_cost < min_total_cost:\n                        min_total_cost = total_cost\n                        found = True\n                        \n        arr1 = sorted(lst1, key=lambda x: x[0])\n        arr2 = sorted(lst2, key=lambda x: x[1])\n        \n        for a in arr2:\n            l2, r2, c2 = a\n            pos = bisect_right([b[1] for b in arr1], r2)\n            if pos:\n                cand = arr1[pos-1]\n                l1, r1, c1 = cand\n                if r2 < l1:\n                    total_cost = c1 + c2\n                    if total_cost < min_total_cost:\n                        min_total_cost = total_cost\n                        found = True\n                        \n    if not found:\n        print(-1)\n    else:\n        print(min_total_cost)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into the number of vouchers `n` and the required total duration `x`, followed by the details of each voucher.\n2. **Grouping by Duration**: Vouchers are grouped into a dictionary where each key is a duration, and the value is a list of tuples containing the start day, end day, and cost of each voucher with that duration.\n3. **Checking Valid Pairs**: For each duration `d`, if `x - d` exists, the algorithm checks all pairs of vouchers between the groups of duration `d` and `x - d`. The pairs must not overlap, meaning one voucher ends before the other starts.\n4. **Efficiency**: To efficiently find non-overlapping pairs, the algorithm sorts the vouchers by their start or end days and uses binary search to quickly locate potential candidates.\n5. **Output**: The minimal total cost of valid pairs is printed, or `-1` if no such pair exists. \n\nThis approach ensures that we efficiently check all possible valid pairs while minimizing the computational complexity through grouping and binary search techniques.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom bisect import bisect_right\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(-1)\n        return\n        \n    n = int(data[0])\n    x = int(data[1])\n    vouchers = []\n    index = 2\n    for i in range(n):\n        l = int(data[index])\n        r = int(data[index+1])\n        c = int(data[index+2])\n        index += 3\n        vouchers.append((l, r, c))\n        \n    durations = {}\n    for l, r, c in vouchers:\n        dur = r - l + 1\n        if dur not in durations:\n            durations[dur] = []\n        durations[dur].append((l, r, c))\n        \n    min_total_cost = float('inf')\n    found = False\n    \n    for dur1, lst1 in durations.items():\n        dur2 = x - dur1\n        if dur2 not in durations:\n            continue\n            \n        lst2 = durations[dur2]\n        \n        if dur1 == dur2:\n            arr1 = sorted(lst1, key=lambda x: x[0])\n            arr2 = sorted(lst2, key=lambda x: x[0])\n            for a in arr1:\n                l1, r1, c1 = a\n                pos = bisect_right([b[0] for b in arr2], r1)\n                if pos > 0:\n                    candidate = arr2[pos-1]\n                    l2, r2, c2 = candidate\n                    if r1 < l2:\n                        total_cost = c1 + candidate[2]\n                        if total_cost < min_total_cost:\n                            min_total_cost = total_cost\n                            found = True\n            continue\n            \n        arr1 = sorted(lst1, key=lambda x: x[1])\n        arr2 = sorted(lst2, key=lambda x: x[0])\n        \n        for a in arr1:\n            l1, r1, c1 = a\n            pos = bisect_right([b[0] for b in arr2], r1)\n            if pos:\n                cand = arr2[pos-1]\n                l2, r2, c2 = cand\n                if r1 < l2:\n                    total_cost = c1 + c2\n                    if total_cost < min_total_cost:\n                        min_total_cost = total_cost\n                        found = True\n                        \n        arr1 = sorted(lst1, key=lambda x: x[0])\n        arr2 = sorted(lst2, key=lambda x: x[1])\n        \n        for a in arr2:\n            l2, r2, c2 = a\n            pos = bisect_right([b[1] for b in arr1], r2)\n            if pos:\n                cand = arr1[pos-1]\n                l1, r1, c1 = cand\n                if r2 < l1:\n                    total_cost = c1 + c2\n                    if total_cost < min_total_cost:\n                        min_total_cost = total_cost\n                        found = True\n                        \n    if not found:\n        print(-1)\n    else:\n        print(min_total_cost)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 734,
        "completion_token_count": 1337,
        "thoughts_token_count": 1023
    }
}