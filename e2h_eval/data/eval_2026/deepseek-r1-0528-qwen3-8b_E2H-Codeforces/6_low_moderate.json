{
    "start": 1758088071.9503536,
    "end": 1758089173.378225,
    "start-formatted": "2025-09-17 14:47 KST",
    "end-formatted": "2025-09-17 15:06 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\n Okay, we are given n and x, then n lines of (li, ri, costi)\n Conditions: \n   - We need two distinct vouchers i and j such that:\n        (ri - li + 1) + (rj - lj + 1) = x   [total duration is x]\n   - The two vouchers do not intersect: meaning either ri < lj or rj < li.\n\n Steps:\n\n Observation: The total duration condition is (duration_i + duration_j = x). So if we let d_i = ri - li + 1, then we require d_i + d_j = x.\n\n Also, the two vouchers must be disjoint. This means that one voucher must end before the other starts.\n\n Approach:\n\n 1. Precompute the duration for each voucher.\n 2. We are going to group the vouchers by their duration. For a given duration d, we want to consider all vouchers with that duration and also keep track of their intervals (l, r) so that we can check non-overlapping condition.\n\n However, note: we have two conditions for non-overlapping: \n      Condition 1: r1 < l2   (voucher i ends before voucher j starts)\n      Condition 2: r2 < l1   (voucher j ends before voucher i starts)\n\n But note: the two vouchers are independent, so we can consider two cases: \n      Case 1: The first voucher ends before the second starts (so for the two vouchers i and j, we require r_i < l_j)\n      Case 2: The second voucher ends before the first starts (so for the two vouchers i and j, we require r_j < l_i)\n\n Alternatively, we can think of the two vouchers as two intervals that do not overlap. We can also note that the two intervals must be separated by at least one day (or not even touch).\n\n Since we are grouping by duration, let's denote:\n   Let d = duration of the first voucher, then the second voucher must have duration = x - d.\n\n But note: the two vouchers can be in any order. So we might have two different ways: \n   Option A: Take a voucher with duration d and another with duration x-d, and check if they don't overlap.\n\n However, note: the condition for non-overlap is symmetric? Actually, the condition requires that one ends before the other starts. So we have two possibilities.\n\n How to check non-overlap for two vouchers i and j?\n   Condition 1: (voucher i: [l_i, r_i] and voucher j: [l_j, r_j]) -> r_i < l_j OR r_j < l_i.\n\n But note: if we fix the two durations, say d1 and d2 (with d1+d2=x), then we can consider:\n\n   For a voucher i (duration d1) and voucher j (duration d2) to be non-overlapping, we require either:\n        r_i < l_j   OR   r_j < l_i\n\n However, since the durations are fixed, we can express the intervals in terms of their start and end.\n\n Another idea: Instead of grouping by duration, we can precompute for each duration d, the set of vouchers with that duration and then for each voucher with duration d, we look for a voucher with duration x-d that does not overlap.\n\n But note: n and x can be up to 200,000, and the days (l, r) are also up to 200,000. We cannot iterate over every voucher for each duration.\n\n We need an efficient way.\n\n Alternate approach:\n\n  Step 1: Group the vouchers by their duration. So we have a dictionary (or list of lists) keyed by duration d, and for each d, we store the list of (l, r, cost) for each voucher.\n\n  Step 2: We are only interested in pairs of durations (d, x-d). Note: d must be at least 1 and at most x-1 (since we need two distinct vouchers and x>=2). Also, d <= x/2 and x-d <= x/2? Not necessarily, but we can consider d from 1 to x-1 and then x-d.\n\n  However, note: the two vouchers must have durations d and x-d. And we require two distinct vouchers.\n\n  Step 3: For each duration d, we have a list of intervals. Similarly, for duration x-d, we have another list.\n\n  Now, the problem becomes: for each pair (d, x-d), we want to find two intervals (one from d and one from x-d) that do not overlap and minimize the sum of their costs.\n\n  How to check non-overlap? There are two conditions: \n        Condition 1: r1 < l2 (for voucher from d and voucher from x-d)\n        Condition 2: r2 < l1 (for",
    "response": "\nTo solve this problem, we need to find two distinct travel vouchers such that their combined duration equals exactly `x` days, they do not overlap in time, and their total cost is minimized. \n\n### Approach\n1. **Group Vouchers by Duration**: We first group all vouchers by their duration. This allows us to efficiently access all vouchers that can potentially pair with another voucher to meet the total duration requirement of `x`.\n2. **Check for Valid Pairs**: For each voucher duration `d`, we look for vouchers with duration `x - d`. For each such pair, we check if they do not overlap (either the first ends before the second starts or vice versa) and keep track of the minimum cost for valid non-overlapping pairs.\n3. **Efficient Non-Overlap Check**: To efficiently determine if two vouchers from different duration groups do not overlap, we preprocess the vouchers by sorting them based on their end dates. This allows us to use binary search to quickly find vouchers that end before the start of another voucher begins, ensuring optimal performance.\n\n### Solution Code\n```python\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(-1)\n        return\n        \n    n = int(data[0])\n    x = int(data[1])\n    vouchers = []\n    index = 2\n    durations = defaultdict(list)\n    \n    for i in range(n):\n        l = int(data[index])\n        r = int(data[index+1])\n        c = int(data[index+2])\n        index += 3\n        duration_val = r - l + 1\n        vouchers.append((l, r, c))\n        durations[duration_val].append((l, r, c))\n        \n    dict_endpoints = {}\n    for dur, lst in durations.items():\n        sorted_list = sorted(lst, key=lambda x: x[1])\n        dict_endpoints[dur] = sorted_list\n        \n    min_total_cost = float('inf')\n    found = False\n    \n    for dur1, lst1 in durations.items():\n        dur2 = x - dur1\n        if dur2 not in durations:\n            continue\n            \n        list2 = dict_endpoints[dur2]\n        if not list2:\n            continue\n            \n        for l1, r1, c1 in lst1:\n            condition1 = r1 < l1\n            condition2 = r1 < l1\n            if dur1 == dur2:\n                if condition1 or condition2:\n                    idx = bisect.bisect_left(list2, (r1+1, 0, 0))\n                    if idx < len(list2) and list2[idx][0] > r1:\n                        candidate = list2[idx][2]\n                        if candidate < min_total_cost:\n                            min_total_cost = c1 + candidate\n                    if idx-1 >= 0:\n                        candidate2 = list2[idx-1][2]\n                        if candidate2 < min_total_cost:\n                            min_total_cost = c1 + candidate2\n            else:\n                if condition1:\n                    idx = bisect.bisect_left(list2, (r1+1, 0, 0))\n                    if idx < len(list2):\n                        candidate = list2[idx][2]\n                        if c1 + candidate < min_total_cost:\n                            min_total_cost = c1 + candidate\n                if condition2:\n                    idx = bisect.bisect_left(lst1, (r1+1, 0, 0))\n                    if idx < len(lst1):\n                        candidate = lst1[idx][2]\n                        if c1 + candidate < min_total_cost:\n                            min_total_cost = c1 + candidate\n                    \n    if min_total_cost == float('inf'):\n        print(-1)\n    else:\n        print(min_total_cost)\n\ndef bisect_left(a, x):\n    lo, hi = 0, len(a)\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if a[mid][0] < x[0]:\n            lo = mid + 1\n        elif a[mid][0] > x[0]:\n            hi = mid\n        else:\n            if a[mid][1] < x[1]:\n                lo = mid + 1\n            else:\n                hi = mid\n    return lo\n\nif __name__ == \"__main__\":\n    import bisect\n    main()\n```\n\n### Explanation\n1. **Input Handling**: The input is read and parsed into individual vouchers, each characterized by their start day, end day, and cost. These vouchers are grouped by their duration (end day - start day + 1).\n2. **Sorting and Binary Search**: For each duration group, the vouchers are sorted by their end day. This allows efficient binary search operations to find non-overlapping vouchers.\n3. **Finding Valid Pairs**: For each voucher in a duration group, we check if there exists a voucher in the complementary duration group (duration `x - current duration`) that does not overlap. The binary search helps quickly locate such vouchers.\n4. **Cost Calculation**: The costs of valid non-overlapping voucher pairs are compared to find the minimum total cost. If no valid pairs are found, the result is `-1`.\n\nThis approach efficiently narrows down the search space using grouping and binary search, ensuring optimal performance even for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import defaultdict\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(-1)\n        return\n        \n    n = int(data[0])\n    x = int(data[1])\n    vouchers = []\n    index = 2\n    durations = defaultdict(list)\n    \n    for i in range(n):\n        l = int(data[index])\n        r = int(data[index+1])\n        c = int(data[index+2])\n        index += 3\n        duration_val = r - l + 1\n        vouchers.append((l, r, c))\n        durations[duration_val].append((l, r, c))\n        \n    dict_endpoints = {}\n    for dur, lst in durations.items():\n        sorted_list = sorted(lst, key=lambda x: x[1])\n        dict_endpoints[dur] = sorted_list\n        \n    min_total_cost = float('inf')\n    found = False\n    \n    for dur1, lst1 in durations.items():\n        dur2 = x - dur1\n        if dur2 not in durations:\n            continue\n            \n        list2 = dict_endpoints[dur2]\n        if not list2:\n            continue\n            \n        for l1, r1, c1 in lst1:\n            condition1 = r1 < l1\n            condition2 = r1 < l1\n            if dur1 == dur2:\n                if condition1 or condition2:\n                    idx = bisect.bisect_left(list2, (r1+1, 0, 0))\n                    if idx < len(list2) and list2[idx][0] > r1:\n                        candidate = list2[idx][2]\n                        if candidate < min_total_cost:\n                            min_total_cost = c1 + candidate\n                    if idx-1 >= 0:\n                        candidate2 = list2[idx-1][2]\n                        if candidate2 < min_total_cost:\n                            min_total_cost = c1 + candidate2\n            else:\n                if condition1:\n                    idx = bisect.bisect_left(list2, (r1+1, 0, 0))\n                    if idx < len(list2):\n                        candidate = list2[idx][2]\n                        if c1 + candidate < min_total_cost:\n                            min_total_cost = c1 + candidate\n                if condition2:\n                    idx = bisect.bisect_left(lst1, (r1+1, 0, 0))\n                    if idx < len(lst1):\n                        candidate = lst1[idx][2]\n                        if c1 + candidate < min_total_cost:\n                            min_total_cost = c1 + candidate\n                    \n    if min_total_cost == float('inf'):\n        print(-1)\n    else:\n        print(min_total_cost)\n\ndef bisect_left(a, x):\n    lo, hi = 0, len(a)\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if a[mid][0] < x[0]:\n            lo = mid + 1\n        elif a[mid][0] > x[0]:\n            hi = mid\n        else:\n            if a[mid][1] < x[1]:\n                lo = mid + 1\n            else:\n                hi = mid\n    return lo\n\nif __name__ == \"__main__\":\n    import bisect\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 735,
        "completion_token_count": 1114,
        "thoughts_token_count": 1023
    }
}