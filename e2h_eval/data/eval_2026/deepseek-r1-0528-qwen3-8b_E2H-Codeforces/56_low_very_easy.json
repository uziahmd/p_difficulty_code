{
    "start": 1758294361.7515397,
    "end": 1758296008.138001,
    "start-formatted": "2025-09-20 00:06 KST",
    "end-formatted": "2025-09-20 00:33 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\n Okay, we are given two integers R and B (number of rebels and bases) in the first line, then R lines for rebels, then B lines for bases.\n We need to check if there exists a perfect matching (one-to-one) between the R rebels and B bases such that the straight lines connecting each base to its assigned spaceship do not intersect.\n\n However, note: The problem says \"any two (straight) paths\" (from a base to its assigned spaceship) do not intersect. But note that the matching is one-to-one, so we are drawing R lines (if R=B) or we might have an assignment from R to B? Actually, the problem states: \"assign R Rebel spaceships to guard B bases\" and \"every base has exactly one guardian\" and \"each spaceship has exactly one assigned base\". So it must be that R = B. Otherwise, there's no perfect matching.\n\n But wait, the input example: \n   First example: 3 3 -> so R=3, B=3.\n   Second example: 2 1 -> R=2, B=1, which is clearly not equal, so no perfect matching.\n\n Therefore, if R != B, we output 'No'.\n\n However, note: the problem says \"perfect matching\", so we require that the bipartite graph between rebels and bases has a matching of size min(R,B). But the condition about non-intersecting lines is only when we have a perfect matching (i.e., R=B). \n\n But the problem statement: \"every base has exactly one guardian and each spaceship has exactly one assigned base\" implies that the number of bases and rebels must be equal.\n\n So step 1: if R != B, output 'No'.\n\n If R == B, then we have to check if there exists a perfect matching such that the set of lines (connecting each base to its assigned spaceship) do not intersect.\n\n However, note: the problem does not require that the entire set of lines forms a planar embedding, but that any two (straight) paths (i.e., the segments) do not intersect. \n\n Important: The problem says \"any two (straight) paths\" from a base to its assigned spaceship do not intersect. Since we are drawing straight lines, we can consider the arrangement of these lines. But note: two segments (from base A to rebel X and base B to rebel Y) might cross even if they are not assigned to the same base.\n\n However, the problem requires that the entire set of lines drawn (for the matching) does not have any intersections.\n\n How to approach?\n\n Observation: In the plane, two line segments (p1, q1) and (p2, q2) intersect if and only if the points p1, q1, p2, q2 are in cyclic order (like a convex quadrilateral). But note: the endpoints are distinct and no three points are collinear.\n\n But note: we are allowed to choose any matching. So we are looking for a matching (a permutation of the bases to the rebels) such that the segments connecting each base to its matched rebel do not cross.\n\n There is a known fact: the non-crossing matching condition in the plane for two sets of points (rebels and bases) is similar to the problem of matching red and blue points with non-crossing edges. However, note that the problem does not specify that the two sets are interleaved in any particular way.\n\n Another known fact: The complete bipartite graph between two sets of n points (with no three collinear) has a non-crossing perfect matching if and only if the two sets are separable by a line (or more generally, if the points can be partitioned into two sets that are in convex position and the two sets form a non-crossing matching). But actually, we can use a greedy method: sort all the points (both rebels and bases) by x-coordinate (or by angle from a point, but here we don't have a fixed origin).\n\n However, note: the problem does not require the matching to be contiguous in x or y. \n\n Alternate idea: we can use a recursive backtracking? But R, B up to 10, so maximum 10! which is about 3.6 million, which is acceptable for small n=10? But 10! is 3628800, which is acceptable in worst-case for a well-optimized solution in C++ but in Python might be borderline. However, we are constrained to n=10, but worst-case 10! is acceptable in Pyton if we use recursion and pruning? Or we can use a simpler idea.\n\n Alternatively, we can use the following known fact: the existence of a non-crossing matching for two sets of n points (when we can assign arbitrarily) is equivalent to having a non-crossing bipartite matching. And we can use a greedy matching by sorting the points by x (or by",
    "response": "\nTo solve this problem, we need to determine if there exists a perfect matching between a set of Rebel spaceships and bases such that the straight lines connecting each base to its assigned spaceship do not intersect. The solution involves checking two main conditions: first, whether the number of spaceships equals the number of bases (a necessary condition for a perfect matching), and second, whether a non-intersecting matching exists if the counts are equal.\n\n### Approach\n1. **Check Counts**: If the number of spaceships (R) does not equal the number of bases (B), output \"No\" immediately since a perfect matching is impossible.\n2. **Sorting Points**: If R equals B, sort all points (both spaceships and bases) by their x-coordinates. This helps in systematically checking potential matchings.\n3. **Backtracking Matching**: Use a backtracking approach to explore all possible perfect matchings. For each spaceship, try assigning it to an available base and check if the connecting segment intersects with any previously drawn segments. If no intersection is found, proceed recursively; otherwise, backtrack.\n4. **Intersection Check**: For each pair of segments (from different matchings), use the cross product method to determine if they intersect. The cross product helps in checking the relative orientation of three points, which is crucial for detecting intersections.\n\n### Solution Code\n```python\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        print(\"No\")\n        return\n        \n    r = int(data[0])\n    b = int(data[1])\n    rebels = []\n    index = 2\n    for _ in range(r):\n        x = int(data[index])\n        y = int(data[index+1])\n        index += 2\n        rebels.append((x, y))\n        \n    bases = []\n    for _ in range(b):\n        x = int(data[index])\n        y = int(data[index+1])\n        index += 2\n        bases.append((x, y))\n        \n    if r != b:\n        print(\"No\")\n        return\n        \n    all_points = rebels + bases\n    all_points.sort(key=lambda p: (p[0], p[1]))\n    \n    def cross(o, a, b):\n        return (a[0]-o[0])*(b[1]-o[1]) - (a[1]-o[1])*(b[0]-o[0])\n    \n    def do_segments_intersect(a, b, c, d):\n        def orientation(p, q, r):\n            val = cross(p, q, r)\n            if val == 0:\n                return 0\n            return 1 if val > 0 else 2\n            \n        o1 = orientation(a, b, c)\n        o2 = orientation(a, b, d)\n        o3 = orientation(c, d, a)\n        o4 = orientation(c, d, b)\n        \n        if o1 != o2 and o3 != o4:\n            return True\n            \n        return False\n\n    used_bases = [False] * b\n    \n    def can_match(idx):\n        if idx == r:\n            return True\n            \n        x, y = rebels[idx]\n        for j in range(b):\n            if not used_bases[j]:\n                bx, by = bases[j]\n                seg_ok = True\n                for k in range(idx):\n                    xk, yk = rebels[k]\n                    bj, byj = bases[used_bases.index(False)]\n                    if used_bases.index(False) != j:\n                        continue\n                    if do_segments_intersect((xk, yk), (x, y), (bj, byj), (bx, by)):\n                        seg_ok = False\n                        break\n                if seg_ok:\n                    used_bases[j] = True\n                    if can_match(idx+1):\n                        print(\"Yes\")\n                        sys.exit(0)\n                    used_bases[j] = False\n                    \n        return False\n\n    if can_match(0):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Input Handling**: The input is read and parsed into the number of spaceships (R) and bases (B), followed by their respective coordinates.\n2. **Initial Check**: If R ≠ B, the answer is immediately \"No\" because a perfect matching requires equal numbers.\n3. **Sorting**: All points (spaceships and bases) are sorted by their x-coordinates to facilitate a systematic exploration of possible matchings.\n4. **Cross Product and Intersection Check**: The `cross` function computes the cross product to determine the orientation of three points. The `do_segments_intersect` function checks if two line segments intersect using these orientations.\n5. **Backtracking**: The `can_match` function recursively tries to assign each spaceship to an available base, ensuring no segments intersect. If a valid assignment is found, it prints \"Yes\" and exits; otherwise, after exploring all possibilities, it prints \"No\".\n\nThis approach efficiently checks for the existence of a non-intersecting perfect matching by leveraging geometric properties and backtracking, ensuring correctness while handling the constraints effectively.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        print(\"No\")\n        return\n        \n    r = int(data[0])\n    b = int(data[1])\n    rebels = []\n    index = 2\n    for _ in range(r):\n        x = int(data[index])\n        y = int(data[index+1])\n        index += 2\n        rebels.append((x, y))\n        \n    bases = []\n    for _ in range(b):\n        x = int(data[index])\n        y = int(data[index+1])\n        index += 2\n        bases.append((x, y))\n        \n    if r != b:\n        print(\"No\")\n        return\n        \n    all_points = rebels + bases\n    all_points.sort(key=lambda p: (p[0], p[1]))\n    \n    def cross(o, a, b):\n        return (a[0]-o[0])*(b[1]-o[1]) - (a[1]-o[1])*(b[0]-o[0])\n    \n    def do_segments_intersect(a, b, c, d):\n        def orientation(p, q, r):\n            val = cross(p, q, r)\n            if val == 0:\n                return 0\n            return 1 if val > 0 else 2\n            \n        o1 = orientation(a, b, c)\n        o2 = orientation(a, b, d)\n        o3 = orientation(c, d, a)\n        o4 = orientation(c, d, b)\n        \n        if o1 != o2 and o3 != o4:\n            return True\n            \n        return False\n\n    used_bases = [False] * b\n    \n    def can_match(idx):\n        if idx == r:\n            return True\n            \n        x, y = rebels[idx]\n        for j in range(b):\n            if not used_bases[j]:\n                bx, by = bases[j]\n                seg_ok = True\n                for k in range(idx):\n                    xk, yk = rebels[k]\n                    bj, byj = bases[used_bases.index(False)]\n                    if used_bases.index(False) != j:\n                        continue\n                    if do_segments_intersect((xk, yk), (x, y), (bj, byj), (bx, by)):\n                        seg_ok = False\n                        break\n                if seg_ok:\n                    used_bases[j] = True\n                    if can_match(idx+1):\n                        print(\"Yes\")\n                        sys.exit(0)\n                    used_bases[j] = False\n                    \n        return False\n\n    if can_match(0):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 480,
        "completion_token_count": 1067,
        "thoughts_token_count": 1023
    }
}