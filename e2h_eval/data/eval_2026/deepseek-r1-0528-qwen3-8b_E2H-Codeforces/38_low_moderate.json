{
    "start": 1758299439.1888008,
    "end": 1758303257.1381407,
    "start-formatted": "2025-09-20 01:30 KST",
    "end-formatted": "2025-09-20 02:34 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\n Okay, let's break down the problem.\n\n We are given an integer p (0 <= p <= 200000). We need to find:\n  1. The minimum number of nodes n such that there exists a directed graph with n nodes that is p-reachable.\n     - A graph is p-reachable if it contains exactly p ordered pairs (u, v) with u < v and u and v are mutually reachable.\n\n  2. Among all such graphs with n nodes, we need to maximize the number of unidirectional pairs (u, v) (with u != v, path from u to v but not from v to u).\n\n Observation:\n\n In a directed graph, mutual reachability (i.e., strongly connected components) is key.\n\n Let the graph have k strongly connected components (SCCs). Then, the entire graph can be represented as a DAG of these SCCs.\n\n Condition for mutual reachability: \n   - Within an SCC, every node is mutually reachable with every other node. So, if an SCC has size s, then it contributes C(s,2) = s*(s-1)//2 unordered pairs (but note: the problem counts ordered pairs? Actually, note the definition: the graph is p-reachable if it contains exactly p ordered pairs (u, v) with u < v and u and v are mutually reachable.\n\n However, note: the problem says \"exactly p ordered pairs (u, v) such that u < v\". But in an SCC, for two distinct nodes u and v, we have both (u,v) and (v,u) as mutually reachable. However, the condition for being counted is only for (u, v) with u < v. So an SCC of size s contributes C(s,2) = s*(s-1)//2 to p.\n\n Now, what about the entire graph? The entire graph must have exactly p such pairs. Therefore, the sum of C(s_i,2) over all SCCs must be p.\n\n Moreover, the entire graph must be built with the minimum number of nodes. How do we minimize the total number of nodes?\n\n We can use multiple SCCs. The total number of nodes is the sum of the sizes of the SCCs.\n\n We want to represent p as a sum of triangular numbers (each triangular number T(s) = s*(s-1)//2) and we want to minimize the total number of nodes (which is the sum of the side lengths s_i).\n\n Note: we can use any number of SCCs. However, each SCC must have at least 1 node, and the triangular numbers are fixed.\n\n Also note: we can use the same SCC size multiple times.\n\n But note: we are allowed to have a graph that is just one SCC? Then the entire graph is strongly connected and the number of mutual pairs is C(n,2). Then we set n such that C(n,2) >= p, but wait: the problem requires exactly p.\n\n However, we can also have multiple SCCs. The idea is to decompose p into a sum of triangular numbers (each T(s) = s*(s-1)//2) and minimize the sum of the corresponding s (the side lengths).\n\n Example: p=3.\n   T(2)=1, T(3)=3 -> so we can use one SCC of size 3: then total nodes = 3, and the triangular number is 3 (which equals p). Alternatively, we could use three SCCs of size 2: then total nodes = 6, which is worse.\n\n So we want to minimize the total nodes.\n\n How to compute the minimal n?\n\n Steps:\n\n  1. Precompute triangular numbers: for i from 1 upwards, T(i) = i*(i-1)//2 until T(i) > p_max (which is 200000).\n\n  2. We wish to represent p as a sum of some triangular numbers (each T(i) can be used multiple times) and minimize the total node count (which is the sum of the corresponding i's).\n\n  3. This is similar to a coin change problem (minimize the number of coins) but here the coin values are the triangular numbers and the cost for a coin of value T(i) is i (since we get T(i) by using a component of size i, and we pay i nodes).\n\n However, note: we are allowed to use as many as we want of each triangular number.\n\n But note: the triangular numbers are increasing: T(1)=0, T(2)=1, T(3)=3, T(4)=6, T(5)=10, ... \n\n Since we want to minimize the total nodes, we should use as large triangular numbers as possible (because a larger triangular number gives more p per node). However, we cannot exceed p.\n\n But note: the triangular numbers are not necessarily efficient in terms of node count: for example",
    "response": "\nTo solve this problem, we need to determine the minimum number of nodes required to create a directed graph that is exactly p-reachable, and among all such graphs with the minimum number of nodes, find the maximum number of unidirectional node pairs.\n\n### Approach\n1. **Understanding p-Reachable Graphs**: A directed graph is p-reachable if it contains exactly p ordered pairs (u, v) where u < v and u and v are mutually reachable. This mutual reachability implies that both u can reach v and v can reach u. The key insight is that these mutual reachabilities form strongly connected components (SCCs). Each SCC of size s contributes \\( \\binom{s}{2} = s(s-1)/2 \\) to the count p.\n\n2. **Minimizing Nodes**: To minimize the number of nodes, we should maximize the contribution of each SCC to p. Larger SCCs contribute more to p per node. Thus, we use as many large SCCs as possible without exceeding p.\n\n3. **Triangular Numbers**: The contribution of an SCC of size s to p is a triangular number \\( T(s) = s(s-1)/2 \\). We need to decompose p into a sum of such triangular numbers, minimizing the total nodes (sum of s values).\n\n4. **Greedy Selection**: Start with the largest possible triangular number less than or equal to p, subtract it from p, and repeat with the remaining value until p is fully decomposed. This greedy approach ensures the minimal node count.\n\n5. **Maximizing Unidirectional Pairs**: In the graph with minimal nodes, unidirectional pairs are those (u, v) where there is a path from u to v but not vice versa. To maximize these, we structure the graph such that after forming the SCCs, we add edges in a way that creates as many unidirectional paths as possible between different SCCs.\n\n### Solution Code\n```python\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    p = int(data[0])\n    \n    if p == 0:\n        print(\"0 0\")\n        return\n        \n    tri = {}\n    i = 1\n    while True:\n        t_val = i * (i - 1) // 2\n        if t_val > 200000:\n            break\n        tri[t_val] = i\n        i += 1\n        \n    n = 0\n    remaining = p\n    last_tri = 0\n    components = []\n    \n    while remaining > 0:\n        max_tri = 0\n        for t_val in sorted(tri.keys(), reverse=True):\n            if t_val <= remaining:\n                max_tri = t_val\n                break\n                \n        if max_tri == 0:\n            break\n            \n        comp_size = tri[max_tri]\n        n += comp_size\n        remaining -= max_tri\n        components.append(comp_size)\n        \n    if remaining != 0:\n        n = 0\n        remaining = p\n        i = 1\n        while True:\n            t_val = i * (i - 1) // 2\n            if t_val > p:\n                break\n            if p >= t_val:\n                n += i\n                p -= t_val\n            i += 1\n        n = n + (p * 2 + 1) ** 0.5 // 2\n        n = int(n) + 1\n        n_nodes = n\n        total_pairs = 0\n        for i in range(1, n_nodes + 1):\n            total_pairs += i * (i - 1) // 2\n        while total_pairs < p:\n            n_nodes += 1\n            total_pairs += n_nodes * (n_nodes - 1) // 2\n        n_nodes_used = n_nodes\n        n = n_nodes_used\n        remaining = p\n        for i in range(1, n_nodes_used + 1):\n            t_val = i * (i - 1) // 2\n            if t_val <= remaining:\n                remaining -= t_val\n        if remaining != 0:\n            n = n_nodes_used + 1\n    else:\n        n_nodes_used = n\n        \n    total_nodes = n\n    \n    # Now, compute the maximum number of unidirectional pairs in a graph with total_nodes nodes and exactly p mutual pairs.\n    total_ordered_pairs = total_nodes * (total_nodes - 1)\n    mutual_pairs = p\n    \n    # In the graph, the mutual pairs are exactly p, which are within the SCCs.\n    # The rest of the ordered pairs (excluding self-loops) are either unidirectional or have no path.\n    # But note: the entire graph is built from the decomposition. The graph has total_nodes nodes and we know the structure: \n    #   - There are k SCCs, each of size s_i, and the DAG structure between them.\n    # However, the problem asks for the maximum number of unidirectional pairs in any graph with total_nodes nodes and exactly p mutual pairs (i.e., p is fixed by the SCC sizes).\n    \n    # Actually, note: the graph must be p-reachable, so the mutual pairs are fixed to p (from the SCCs). The remaining pairs are between different SCCs (in the DAG) and may or may not be unidirectional.\n    # But note: in a DAG of SCCs, if there is an edge from component A to component B, then every node in A can reach every node in B, but not vice versa. Therefore, all pairs (u, v) where u is in A and v is in B (and A ≠ B) are unidirectional if the edge goes from A to B (and not the other way). However, if there is no edge between A and B, then they might still be considered not having a path in one direction? Actually, in a DAG, if there's no edge between two components, then there is no path between them in either direction. So such pairs (u, v) would not be counted as unidirectional (since neither direction exists) and also not as mutual (since they are in different components).\n\n    # Therefore, the unidirectional pairs come only from edges between different SCCs. And in the DAG, if we have an edge from A to B, then all pairs (u, v) with u in A and v in B are unidirectional. Similarly, if we have an edge from B to A, then all pairs (v, u) with v in B and u in A are unidirectional. But note: we cannot have both edges because then A and B would form a single SCC.\n\n    # To maximize unidirectional pairs, we should arrange the DAG such that all edges go in one direction (from earlier to later components). Then, for every ordered pair (u, v) where u and v are in different components, if u's component comes before v's component in the topological order, then there is a path from u to v (and not vice versa), making it unidirectional.\n\n    # The total number of such pairs is the total number of ordered pairs between distinct components minus the mutual pairs (which are already counted and excluded). However, note that the mutual pairs are only within components, so between components, all pairs are either unidirectional or non-existent (if no path). But in our DAG, we can choose to have edges in one direction only, so we can ensure that every pair between different components is unidirectional in one direction.\n\n    # Actually, the total number of ordered pairs between distinct components is:\n    #   total_inter_pairs = total_ordered_pairs - sum_{each component}(size_i * (size_i - 1))\n    # But note: the mutual pairs are exactly the pairs within components, so the remaining pairs (between components) are total_ordered_pairs - 2*p (since each mutual pair is counted once in the ordered pairs with u < v, but here we consider all ordered pairs excluding self-loops and within-component pairs? Actually, the total_ordered_pairs is n*(n-1), and the within-component pairs are exactly 2*p (because each unordered pair (u, v) with u and v in the same component contributes two ordered pairs, but wait: the problem counts only (u, v) with u < v. However, in our calculation, the mutual pairs p is the number of unordered pairs (each unordered pair corresponds to one ordered pair with u < v). But note: the mutual pairs p is given as the count of ordered pairs (u, v) with u < v and mutual reachability. So the total number of mutual ordered pairs (both directions) is 2*p.\n\n    # However, in our decomposition, we are only concerned with the count of mutual pairs (with u < v) being p. The DAG edges don't contribute to mutual pairs.\n\n    # Now, the total number of ordered pairs (excluding self-loops) is n*(n-1). The mutual pairs (both directions) are 2*p. The remaining pairs are n*(n-1) - 2*p. These remaining pairs can be split into unidirectional and non-existent (or bidirectional, but in our DAG structure we avoid bidirectional between components).\n\n    # But note: in our DAG, we can arrange the components in a total order and direct all edges from left to right. Then, for any two distinct components, if they are in different components, exactly one direction exists (the one from the earlier component to the later one). Therefore, every inter-component ordered pair is unidirectional. Hence, the number of unidirectional pairs is the total number of inter-component ordered pairs, which is n*(n-1) - 2*p.\n\n    # However, wait: is that correct? The total number of ordered pairs (excluding self-loops) is n*(n-1). The mutual pairs (both directions) are 2*p (since each mutual unordered pair gives two ordered pairs). The remaining pairs (n*(n-1) - 2*p) are exactly the unidirectional pairs (each inter-component pair is unidirectional in one direction). \n\n    # Therefore, the maximum number of unidirectional pairs is n*(n-1) - 2*p.\n\n    unidirectional_pairs = total_nodes * (total_nodes - 1) - 2 * p\n\n    print(f\"{total_nodes} {int(unidirectional_pairs)}\")\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read as a single integer p, which represents the number of mutual reachability pairs required.\n2. **Handling Special Case**: If p is 0, the solution is trivially 0 nodes and 0 unidirectional pairs.\n3. **Triangular Numbers Calculation**: We precompute triangular numbers (T(s) = s*(s-1)/2) up to the maximum possible value (200000) to facilitate decomposition of p.\n4. **Decomposing p**: Using a greedy approach, we decompose p into a sum of triangular numbers, each corresponding to an SCC size. The goal is to minimize the total nodes by maximizing the size of each SCC.\n5. **Calculating Unidirectional Pairs**: For the graph with the minimal nodes, the maximum number of unidirectional pairs is derived by considering all ordered pairs between distinct nodes and subtracting the mutual reachability pairs (2*p). This gives the count of pairs where there is a path in exactly one direction.\n6. **Output**: The result is printed as the minimal number of nodes and the maximum number of unidirectional pairs.\n\nThis approach efficiently solves the problem by leveraging properties of strongly connected components and triangular numbers to minimize nodes and maximize unidirectional edges.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    p = int(data[0])\n    \n    if p == 0:\n        print(\"0 0\")\n        return\n        \n    tri = {}\n    i = 1\n    while True:\n        t_val = i * (i - 1) // 2\n        if t_val > 200000:\n            break\n        tri[t_val] = i\n        i += 1\n        \n    n = 0\n    remaining = p\n    last_tri = 0\n    components = []\n    \n    while remaining > 0:\n        max_tri = 0\n        for t_val in sorted(tri.keys(), reverse=True):\n            if t_val <= remaining:\n                max_tri = t_val\n                break\n                \n        if max_tri == 0:\n            break\n            \n        comp_size = tri[max_tri]\n        n += comp_size\n        remaining -= max_tri\n        components.append(comp_size)\n        \n    if remaining != 0:\n        n = 0\n        remaining = p\n        i = 1\n        while True:\n            t_val = i * (i - 1) // 2\n            if t_val > p:\n                break\n            if p >= t_val:\n                n += i\n                p -= t_val\n            i += 1\n        n = n + (p * 2 + 1) ** 0.5 // 2\n        n = int(n) + 1\n        n_nodes = n\n        total_pairs = 0\n        for i in range(1, n_nodes + 1):\n            total_pairs += i * (i - 1) // 2\n        while total_pairs < p:\n            n_nodes += 1\n            total_pairs += n_nodes * (n_nodes - 1) // 2\n        n_nodes_used = n_nodes\n        n = n_nodes_used\n        remaining = p\n        for i in range(1, n_nodes_used + 1):\n            t_val = i * (i - 1) // 2\n            if t_val <= remaining:\n                remaining -= t_val\n        if remaining != 0:\n            n = n_nodes_used + 1\n    else:\n        n_nodes_used = n\n        \n    total_nodes = n\n    \n    # Now, compute the maximum number of unidirectional pairs in a graph with total_nodes nodes and exactly p mutual pairs.\n    total_ordered_pairs = total_nodes * (total_nodes - 1)\n    mutual_pairs = p\n    \n    # In the graph, the mutual pairs are exactly p, which are within the SCCs.\n    # The rest of the ordered pairs (excluding self-loops) are either unidirectional or have no path.\n    # But note: the entire graph is built from the decomposition. The graph has total_nodes nodes and we know the structure: \n    #   - There are k SCCs, each of size s_i, and the DAG structure between them.\n    # However, the problem asks for the maximum number of unidirectional pairs in any graph with total_nodes nodes and exactly p mutual pairs (i.e., p is fixed by the SCC sizes).\n    \n    # Actually, note: the graph must be p-reachable, so the mutual pairs are fixed to p (from the SCCs). The remaining pairs are between different SCCs (in the DAG) and may or may not be unidirectional.\n    # But note: in a DAG of SCCs, if there is an edge from component A to component B, then every node in A can reach every node in B, but not vice versa. Therefore, all pairs (u, v) where u is in A and v is in B (and A ≠ B) are unidirectional if the edge goes from A to B (and not the other way). However, if there is no edge between A and B, then they might still be considered not having a path in one direction? Actually, in a DAG, if there's no edge between two components, then there is no path between them in either direction. So such pairs (u, v) would not be counted as unidirectional (since neither direction exists) and also not as mutual (since they are in different components).\n\n    # Therefore, the unidirectional pairs come only from edges between different SCCs. And in the DAG, if we have an edge from A to B, then all pairs (u, v) with u in A and v in B are unidirectional. Similarly, if we have an edge from B to A, then all pairs (v, u) with v in B and u in A are unidirectional. But note: we cannot have both edges because then A and B would form a single SCC.\n\n    # To maximize unidirectional pairs, we should arrange the DAG such that all edges go in one direction (from earlier to later components). Then, for every ordered pair (u, v) where u and v are in different components, if u's component comes before v's component in the topological order, then there is a path from u to v (and not vice versa), making it unidirectional.\n\n    # The total number of such pairs is the total number of ordered pairs between distinct components minus the mutual pairs (which are already counted and excluded). However, note that the mutual pairs are only within components, so between components, all pairs are either unidirectional or non-existent (if no path). But in our DAG, we can choose to have edges in one direction only, so we can ensure that every pair between different components is unidirectional in one direction.\n\n    # Actually, the total number of ordered pairs between distinct components is:\n    #   total_inter_pairs = total_ordered_pairs - sum_{each component}(size_i * (size_i - 1))\n    # But note: the mutual pairs are exactly the pairs within components, so the remaining pairs (between components) are total_ordered_pairs - 2*p (since each mutual pair is counted once in the ordered pairs with u < v, but here we consider all ordered pairs excluding self-loops and within-component pairs? Actually, the total_ordered_pairs is n*(n-1), and the within-component pairs are exactly 2*p (because each unordered pair (u, v) with u and v in the same component contributes two ordered pairs, but wait: the problem counts only (u, v) with u < v. However, in our calculation, the mutual pairs p is the number of unordered pairs (each unordered pair corresponds to one ordered pair with u < v). But note: the mutual pairs p is given as the count of ordered pairs (u, v) with u < v and mutual reachability. So the total number of mutual ordered pairs (both directions) is 2*p.\n\n    # However, in our decomposition, we are only concerned with the count of mutual pairs (with u < v) being p. The DAG edges don't contribute to mutual pairs.\n\n    # Now, the total number of ordered pairs (excluding self-loops) is n*(n-1). The mutual pairs (both directions) are 2*p. The remaining pairs are n*(n-1) - 2*p. These remaining pairs can be split into unidirectional and non-existent (or bidirectional, but in our DAG structure we avoid bidirectional between components).\n\n    # But note: in our DAG, we can arrange the components in a total order and direct all edges from left to right. Then, for any two distinct components, if they are in different components, exactly one direction exists (the one from the earlier component to the later one). Therefore, every inter-component ordered pair is unidirectional. Hence, the number of unidirectional pairs is the total number of inter-component ordered pairs, which is n*(n-1) - 2*p.\n\n    # However, wait: is that correct? The total number of ordered pairs (excluding self-loops) is n*(n-1). The mutual pairs (both directions) are 2*p (since each mutual unordered pair gives two ordered pairs). The remaining pairs (n*(n-1) - 2*p) are exactly the unidirectional pairs (each inter-component pair is unidirectional in one direction). \n\n    # Therefore, the maximum number of unidirectional pairs is n*(n-1) - 2*p.\n\n    unidirectional_pairs = total_nodes * (total_nodes - 1) - 2 * p\n\n    print(f\"{total_nodes} {int(unidirectional_pairs)}\")\n\nif __name__ == '__main__':\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 475,
        "completion_token_count": 2486,
        "thoughts_token_count": 1023
    }
}