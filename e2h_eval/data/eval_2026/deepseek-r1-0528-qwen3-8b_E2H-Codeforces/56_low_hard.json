{
    "start": 1758294367.9213347,
    "end": 1758296044.451002,
    "start-formatted": "2025-09-20 00:06 KST",
    "end-formatted": "2025-09-20 00:34 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\n Okay, we are given two integers R and B (number of rebels and bases) and then 2R+B points (R lines for rebels, then B lines for bases). We need to check if there exists a perfect matching (one-to-one assignment) between the R rebels and the B bases such that the straight line segments (from each base to its assigned spaceship) do not intersect.\n\n However, note: the problem says \"any two (straight) paths\" from a base to its assigned spaceship do not intersect. But note that the matching is one-to-one, so each base is connected to exactly one spaceship and vice versa.\n\n Important: The condition is that the segments do not intersect. But note that the problem does not require the entire set of segments to be non-intersecting? Actually, the problem says \"any two (straight) paths\" meaning that no two segments should cross. However, note that the example might have been drawn with non-crossing segments.\n\n But note: the problem also says that the assignment is a perfect matching (so R = B). Wait, the input constraints say that R and B are at least 1 and at most 10, but they are independent. However, the problem says \"every base has exactly one guardian and each spaceship has exactly one assigned base\", so we must have R = B? \n\n Actually, the problem says: \"assign R Rebel spaceships to guard B bases\" and \"each spaceship has exactly one assigned base\". So it is a bijection only if R = B. Otherwise, if R != B, then we cannot have a perfect matching (unless we interpret as an injection or surjection, but the problem says \"perfect matching\" which typically means a bijection). \n\n Let's read the problem statement again: \n   \"every base has exactly one guardian and each spaceship has exactly one assigned base\"\n\n This implies that the number of bases must equal the number of spaceships. Therefore, if R != B, then the answer is No.\n\n However, the example input: \n   ['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n The second example has R=2, B=1 -> so R != B -> then output No.\n\n So step 1: if R != B, output 'No'.\n\n But wait, the problem says \"output Yes\" if it is possible, otherwise 'No'. And the second example input is \"2 1\", so R=2, B=1 -> not equal, so we output No.\n\n Now, what if R == B?\n\n Then we have a complete bipartite graph between the R rebels and R bases (we can think of bases as the other set). We need to assign each rebel (spaceship) to a base such that the straight line segments connecting them do not intersect.\n\n How to check for non-intersection of segments? Note that the segments are defined by two sets of points: the rebels (set A) and the bases (set B). We are to pick a matching (a set of R edges without common vertices) such that no two edges (segments) cross.\n\n Observation: In general, two segments (a1, b1) and (a2, b2) cross if and only if the four points are in alternating order (like the convex hull property or using the cross product). However, note that the problem says \"any two (straight) paths\" meaning that we must avoid crossings.\n\n But note: the problem does not require the entire drawing to be planar? Actually, the condition is stated as: \"any two (straight) paths – from a base to its assigned spaceship – do not intersect\".\n\n However, note that two segments (a1, b1) and (a2, b2) might share an endpoint (if they meet at a base or a spaceship) but that is allowed. The problem says \"intersect\", and typically in geometry, two segments that share an endpoint are considered to intersect at that endpoint. But note: the problem says \"in the galaxy plane (that is, in 2D)\" and the condition is to avoid risk of collision. \n\n However, the problem states: \"any two (straight) paths\" — meaning that two different connections (from a base to its spaceship) should not cross. But note: if two segments share an endpoint, they don't cross in the interior. So we are only concerned with crossings in the interior.\n\n But note: the problem does not specify whether endpoints are allowed to touch. The example input:\n\n Example 1: \n   Spaceships: (0,0), (2,0), (3,1)\n   Bases: (-2,1), (0,3), (2,2)\n\n One possible matching: \n   (0,0) -> (-2,1)   [segment from (0,",
    "response": "\nTo solve this problem, we need to determine if there exists a perfect matching between a set of Rebel spaceships and bases such that the straight-line segments connecting each spaceship to its assigned base do not intersect. The solution involves checking two main conditions: first, that the number of spaceships equals the number of bases (since a perfect matching requires equal counts), and second, that the segments formed by the matching do not cross each other.\n\n### Approach\n1. **Check for Perfect Matching Condition**: The first step is to verify if the number of spaceships (R) equals the number of bases (B). If they are not equal, it's impossible to form a perfect matching, and the answer is immediately \"No\".\n2. **Geometric Matching Check**: If R equals B, we proceed to check if there exists a matching where no two segments intersect. This involves:\n   - **Sorting Points**: Both the spaceships and bases are sorted based on their coordinates to facilitate a systematic comparison.\n   - **Crossing Segment Detection**: For each potential segment between a spaceship and a base, we check if it intersects with any other segment. The key insight here is that two segments (A-B) and (C-D) intersect if the points A and C are interleaved relative to the line defined by B and D, or vice versa. This is determined using the cross product to check the orientation of the points.\n\n### Solution Code\n```python\ndef cross(o, a, b):\n    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n\ndef orientation(a, b, c):\n    return cross(a, b, c)\n\ndef do_segments_intersect(a, b, c, d):\n    o1 = orientation(a, b, c)\n    o2 = orientation(a, b, d)\n    o3 = orientation(c, d, a)\n    o4 = orientation(c, d, b)\n    \n    if (o1 * o2 < 0) and (o3 * o4 < 0):\n        return True\n    \n    if o1 == 0 or o2 == 0 or o3 == 0 or o4 == 0:\n        return False\n        \n    return False\n\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"No\")\n        return\n    \n    r = int(data[0])\n    b = int(data[1])\n    index = 2\n    rebels = []\n    for i in range(r):\n        x = int(data[index])\n        y = int(data[index + 1])\n        index += 2\n        rebels.append((x, y))\n        \n    bases = []\n    for i in range(b):\n        x = int(data[index])\n        y = int(data[index + 1])\n        index += 2\n        bases.append((x, y))\n        \n    if r != b:\n        print(\"No\")\n        return\n        \n    rebels.sort(key=lambda p: (p[0], p[1]))\n    bases.sort(key=lambda p: (p[0], p[1]))\n    \n    n = r\n    \n    def can_assign(i, j):\n        if i == 0:\n            return True\n        k = 0\n        while k < i:\n            if do_segments_intersect(rebels[k], bases[k], rebels[i], bases[j]):\n                return False\n            k += 1\n        return True\n        \n    assignment = list(range(n))\n    from itertools import permutations\n    found = False\n    for perm in permutations(range(n)):\n        valid = True\n        for i in range(n):\n            for j in range(i + 1, n):\n                if do_segments_intersect(rebels[i], bases[perm[i]], rebels[j], bases[perm[j]]):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            found = True\n            break\n            \n    print(\"Yes\" if found else \"No\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Cross Product and Orientation**: The `cross` function calculates the cross product of vectors OA and OB, which helps determine the orientation of three points (collinear, clockwise, or counterclockwise).\n2. **Segment Intersection Check**: The `do_segments_intersect` function checks if two segments AB and CD intersect by verifying if the orientations of the points relative to each segment are opposite.\n3. **Main Function**:\n   - **Input Handling**: Reads and parses input values for spaceships and bases.\n   - **Initial Check**: If the counts of spaceships and bases differ, outputs \"No\".\n   - **Sorting**: Spaceships and bases are sorted to systematically explore potential matchings.\n   - **Permutation Check**: Generates all possible permutations of base assignments to spaceships. For each permutation, checks if any two segments intersect. If a valid permutation is found, outputs \"Yes\"; otherwise, \"No\".\n\nThis approach efficiently checks for the existence of a non-intersecting perfect matching by leveraging geometric properties and combinatorial exploration.",
    "ground_truth": "N/A",
    "extracted_answer": "def cross(o, a, b):\n    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n\ndef orientation(a, b, c):\n    return cross(a, b, c)\n\ndef do_segments_intersect(a, b, c, d):\n    o1 = orientation(a, b, c)\n    o2 = orientation(a, b, d)\n    o3 = orientation(c, d, a)\n    o4 = orientation(c, d, b)\n    \n    if (o1 * o2 < 0) and (o3 * o4 < 0):\n        return True\n    \n    if o1 == 0 or o2 == 0 or o3 == 0 or o4 == 0:\n        return False\n        \n    return False\n\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"No\")\n        return\n    \n    r = int(data[0])\n    b = int(data[1])\n    index = 2\n    rebels = []\n    for i in range(r):\n        x = int(data[index])\n        y = int(data[index + 1])\n        index += 2\n        rebels.append((x, y))\n        \n    bases = []\n    for i in range(b):\n        x = int(data[index])\n        y = int(data[index + 1])\n        index += 2\n        bases.append((x, y))\n        \n    if r != b:\n        print(\"No\")\n        return\n        \n    rebels.sort(key=lambda p: (p[0], p[1]))\n    bases.sort(key=lambda p: (p[0], p[1]))\n    \n    n = r\n    \n    def can_assign(i, j):\n        if i == 0:\n            return True\n        k = 0\n        while k < i:\n            if do_segments_intersect(rebels[k], bases[k], rebels[i], bases[j]):\n                return False\n            k += 1\n        return True\n        \n    assignment = list(range(n))\n    from itertools import permutations\n    found = False\n    for perm in permutations(range(n)):\n        valid = True\n        for i in range(n):\n            for j in range(i + 1, n):\n                if do_segments_intersect(rebels[i], bases[perm[i]], rebels[j], bases[perm[j]]):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            found = True\n            break\n            \n    print(\"Yes\" if found else \"No\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 479,
        "completion_token_count": 1077,
        "thoughts_token_count": 1023
    }
}