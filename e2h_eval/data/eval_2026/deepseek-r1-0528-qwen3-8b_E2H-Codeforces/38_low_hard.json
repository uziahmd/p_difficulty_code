{
    "start": 1758298501.8879585,
    "end": 1758301631.4175801,
    "start-formatted": "2025-09-20 01:15 KST",
    "end-formatted": "2025-09-20 02:07 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\n Okay, let's break down the problem.\n\n We are given an integer p (0 <= p <= 200000). We need to find:\n  1. The minimum number of nodes n such that there exists a directed graph with n nodes that is p-reachable.\n     - A graph is p-reachable if it contains exactly p ordered pairs (u, v) with u < v and u and v are mutually reachable.\n\n  2. Among all such graphs with n nodes, we need to maximize the number of unidirectional pairs (u, v) (with u != v, path from u to v but not from v to u).\n\n Observation:\n\n In a directed graph, mutual reachability (strongly connected components) is key.\n\n Let the graph have k strongly connected components (SCCs). Then, the entire graph can be represented as a DAG of these SCCs.\n\n In each SCC, every node is mutually reachable with every other node. Therefore, the condition for having exactly p pairs (u, v) with u < v and mutual reachability is that the total number of edges (in the condensation graph) must form a structure that has exactly p mutual pairs.\n\n However, note that the definition says: \"exactly p ordered pairs of nodes (u, v) such that u < v and u and v are reachable from each other\". But note: in a single SCC, if the SCC has m nodes, then the number of unordered pairs (but note: the problem uses ordered pairs? Actually, wait: the problem says \"ordered pairs\" but then specifies \"u < v\", so they are counting unordered pairs? Actually, no: the problem says \"ordered pair (u, v)\" but then adds the condition u < v. So effectively, we are counting unordered pairs (each unordered pair {u, v} with u<v is considered once). However, note that the condition for being mutually reachable is symmetric.\n\n In fact, the mutual reachability condition requires that there is a path from u to v and from v to u. This is symmetric. Therefore, for a set of nodes that forms a strongly connected component, the number of unordered pairs (u, v) with u < v that are mutually reachable is C(m, 2) = m*(m-1)//2.\n\n Therefore, the entire graph is p-reachable if the sum of C(m_i, 2) over all SCCs is p.\n\n Now, note that the entire graph is built from n nodes, and we can have multiple SCCs. The goal is to use the minimum n such that we can partition n into some positive integers (the sizes of the SCCs) and the sum of C(m_i, 2) equals p.\n\n Alternatively, note that the entire graph must have at least one SCC (unless p=0, then we can have no mutual pairs). But wait: what is the minimum n?\n\n Let the SCCs be of sizes m1, m2, ..., mk. Then, the total number of nodes is n = m1 + m2 + ... + mk.\n\n We require: \n   p = sum_{i} [m_i*(m_i-1)//2]\n\n We want the smallest n (i.e., the minimal sum of the m_i) such that we can represent p as the sum of triangular numbers (each triangular number being T(m_i) = m_i*(m_i-1)//2).\n\n However, note: we are allowed to have multiple SCCs. We can also have isolated nodes (which form SCCs of size 1) which contribute 0 to p.\n\n How to minimize n?\n\n We know that the triangular numbers grow quadratically. We can try to use as few large components as possible because T(m) grows faster than T(1)+T(1)+... (since T(1)=0, T(2)=1, T(3)=3, T(4)=6, etc.)\n\n But note: we are free to choose the decomposition. We are looking for the minimal n such that p can be written as the sum of triangular numbers (each at least 0) and the sum of the corresponding m_i is minimized.\n\n However, note: the triangular numbers are nonnegative and increasing. We can use a greedy-like method: use the largest triangular numbers first.\n\n But wait: we are minimizing the total nodes, which is the sum of the m_i. Each component of size m gives T(m)=m*(m-1)//2 and uses m nodes.\n\n We wish to minimize the total nodes for a fixed p.\n\n Consider: we have two ways to get the same triangular number? Actually, we can only use each triangular number once (but we can use multiple components of the same size).\n\n However, we cannot use fractional components. We have to decompose p as the sum of triangular numbers (each T(m) for m>=1) and we want to minimize the total nodes = sum(m_i).\n\n How do we compute",
    "response": "\nTo solve this problem, we need to determine the minimum number of nodes required to create a directed graph that is exactly p-reachable, and among all such graphs with the minimum number of nodes, find the maximum number of unidirectional node pairs.\n\n### Approach\n1. **Understanding p-Reachable Graphs**: A directed graph is p-reachable if it contains exactly p ordered pairs (u, v) where u < v and u and v are mutually reachable. This mutual reachability implies that both u can reach v and v can reach u. The key insight is that these mutual pairs correspond to edges within strongly connected components (SCCs) in the graph. The number of such pairs in an SCC of size m is given by the triangular number T(m) = m*(m-1)/2.\n\n2. **Minimizing Nodes**: To minimize the number of nodes, we should use as few large SCCs as possible because larger SCCs contribute more triangular numbers per node. Specifically, we decompose p into a sum of triangular numbers (each representing an SCC) and choose the combination that minimizes the total number of nodes (sum of the sizes of all SCCs).\n\n3. **Maximizing Unidirectional Pairs**: Once the minimal number of nodes is determined, we maximize the number of unidirectional pairs (u, v) where there is a path from u to v but not from v to u. This involves structuring the graph such that between any two SCCs, all possible directed edges exist in one direction but not the other, maximizing the count of such pairs.\n\n### Solution Code\n```python\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"0 0\")\n        return\n        \n    p = int(data[0])\n    \n    if p == 0:\n        print(\"1 0\")\n        return\n\n    n = 0\n    remaining = p\n    while remaining > 0:\n        n += 1\n        T_n = n * (n - 1) // 2\n        if T_n <= remaining:\n            remaining -= T_n\n        else:\n            break\n\n    if remaining != 0:\n        n += 1\n        remaining = p - (n-1)*(n-2)//2\n        T_n = n*(n-1)//2\n        while remaining > 0:\n            n += 1\n            T_n_prev = T_n\n            T_n = n*(n-1)//2\n            if T_n <= remaining + T_n_prev:\n                remaining -= (T_n - T_n_prev)\n            else:\n                break\n\n    k = 0\n    temp = n\n    while temp > 0:\n        k += 1\n        temp -= k\n\n    total_unidirectional_pairs = 0\n    for i in range(1, k+1):\n        total_unidirectional_pairs += i * (n - k*i)\n\n    print(f\"{n} {total_unidirectional_pairs}\")\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input consists of a single integer p, which is read from standard input.\n2. **Special Case Handling**: If p is 0, the solution requires only 1 node (since no mutual pairs exist), and the output is \"1 0\".\n3. **Finding Minimal Nodes**: The algorithm calculates the minimal number of nodes by decomposing p into a sum of triangular numbers. It starts with the largest possible triangular number and subtracts it from p until p is fully decomposed or the next triangular number exceeds the remaining value.\n4. **Adjusting for Exact Decomposition**: If the initial decomposition doesn't exactly match p, it adjusts by considering the next triangular number and ensures the total nodes are minimized.\n5. **Calculating Unidirectional Pairs**: The number of unidirectional pairs is derived by considering the structure of the graph formed by the SCCs. Each SCC of size i contributes i * (total nodes - sum of sizes of smaller SCCs) unidirectional pairs.\n6. **Output**: The solution outputs the minimal number of nodes and the maximum number of unidirectional pairs achievable with those nodes.\n\nThis approach efficiently addresses the problem by leveraging mathematical insights about triangular numbers and graph theory concepts to minimize nodes and maximize unidirectional pairs.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"0 0\")\n        return\n        \n    p = int(data[0])\n    \n    if p == 0:\n        print(\"1 0\")\n        return\n\n    n = 0\n    remaining = p\n    while remaining > 0:\n        n += 1\n        T_n = n * (n - 1) // 2\n        if T_n <= remaining:\n            remaining -= T_n\n        else:\n            break\n\n    if remaining != 0:\n        n += 1\n        remaining = p - (n-1)*(n-2)//2\n        T_n = n*(n-1)//2\n        while remaining > 0:\n            n += 1\n            T_n_prev = T_n\n            T_n = n*(n-1)//2\n            if T_n <= remaining + T_n_prev:\n                remaining -= (T_n - T_n_prev)\n            else:\n                break\n\n    k = 0\n    temp = n\n    while temp > 0:\n        k += 1\n        temp -= k\n\n    total_unidirectional_pairs = 0\n    for i in range(1, k+1):\n        total_unidirectional_pairs += i * (n - k*i)\n\n    print(f\"{n} {total_unidirectional_pairs}\")\n\nif __name__ == '__main__':\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 474,
        "completion_token_count": 910,
        "thoughts_token_count": 1023
    }
}