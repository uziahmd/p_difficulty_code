{
    "start": 1758088073.590935,
    "end": 1758089188.3882754,
    "start-formatted": "2025-09-17 14:47 KST",
    "end-formatted": "2025-09-17 15:06 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\n Okay, we are given n and x, then n lines of (li, ri, costi)\n Conditions: \n   - We need two distinct vouchers i and j such that:\n        (ri - li + 1) + (rj - lj + 1) = x   [total duration is x]\n   - The two vouchers do not intersect: meaning either ri < lj or rj < li.\n\n Steps:\n\n Observation: The total duration condition is (duration_i + duration_j = x). So if we let d_i = ri - li + 1, then we require d_i + d_j = x.\n\n Also, the two vouchers must be disjoint. This means that one voucher must end before the other starts.\n\n Approach:\n\n 1. Precompute the duration for each voucher.\n 2. We are going to group the vouchers by their duration. For a given duration d, we want to consider all vouchers with that duration and also keep track of their intervals (l, r) so that we can check non-overlapping condition.\n\n However, note: we have two conditions for non-overlapping: \n      Condition 1: r1 < l2   (voucher i ends before voucher j starts)\n      Condition 2: r2 < l1   (voucher j ends before voucher i starts)\n\n But note: the two vouchers are independent, so we can consider two cases: \n      Case 1: The first voucher ends before the second starts (so it's [l1, r1] and then [l2, r2] with r1 < l2).\n      Case 2: The second voucher ends before the first starts (so [l2, r2] and then [l1, r1] with r2 < l1).\n\n Alternatively, we can think: we require that the two intervals do not overlap, which is equivalent to having at least one gap.\n\n Since the total duration is fixed (d_i + d_j = x), we can iterate over one duration d, then look for the complementary duration x-d.\n\n Then, for a fixed pair (d, x-d), we have two groups: Group A (duration d) and Group B (duration x-d).\n\n Now, within these two groups, we need to find two vouchers (one from A and one from B) that do not overlap.\n\n How to check for non-overlapping? We have two possibilities: \n      a) The voucher from A ends before the voucher from B starts: rA < lB.\n      b) The voucher from B ends before the voucher from A starts: rB < lA.\n\n But note: the two vouchers are independent, so we can precompute for each group:\n\n   For group A (duration d): \n        We have a list of intervals (l, r). We can sort by l (or by r) and then for each interval in group B, we can use binary search to find an interval in A that ends before the start of the current B.\n\n However, we are going to combine two groups. The idea:\n\n   Let's consider the two groups: \n        Group A: all vouchers with duration d.\n        Group B: all vouchers with duration x-d.\n\n   We want to minimize the total cost: costA + costB.\n\n   We can break down the problem:\n\n   For a fixed pair (d, x-d) (with d <= x-d to avoid duplication, but note: d and x-d might be same if x is even, but then we consider two different vouchers from the same group? Actually, the problem says two distinct vouchers, so if d == x-d, then we need two distinct vouchers from the same group.)\n\n   Steps for a fixed d:\n\n   Let d1 = d, d2 = x - d.\n\n   If d1 > d2, then skip (if we assume d1<=d2, then we only consider when d <= x/2, unless we consider both orders? Actually, we can consider each unordered pair once. But note: the two groups are defined by d and x-d, and if d != x-d then we have two distinct groups. If d == x-d, then we are taking two vouchers from the same group.\n\n   However, the non-overlapping condition is symmetric.\n\n   We can do:\n\n     Step 1: Precompute a dictionary (or list of lists) for each duration from 1 to max_duration (max_duration is at most 200000) but note: the vacation days go up to 200000, so the maximum duration is 200000.\n\n     But note: the input constraints: n, x up to 200000, and li, ri up to 200000.\n\n     Step 2: We will create a list for each duration that appears.\n\n     Step 3: For each duration d that we have, we have a list of (l,",
    "response": "\nTo solve this problem, we need to find two distinct travel vouchers such that their combined duration equals exactly `x` days, they do not overlap in time, and their total cost is minimized. \n\n### Approach\n1. **Problem Analysis**: The problem requires selecting two non-overlapping vouchers where the sum of their durations is exactly `x`. The key challenge is efficiently checking for non-overlapping conditions and minimizing the total cost.\n2. **Intuition**: For each voucher, we can consider all other vouchers that complement its duration to reach `x`. However, directly checking all pairs would be too slow (O(n^2)), so we need a more efficient method.\n3. **Optimization**: \n   - **Grouping by Duration**: We group vouchers by their duration. For each duration `d`, we store all vouchers with that duration along with their start (`l`) and end (`r`) days.\n   - **Binary Search for Non-overlapping Intervals**: For each voucher in a group with duration `d`, we look for vouchers in the complementary group (duration `x - d`) that do not overlap. This involves checking if one voucher ends before the other starts.\n   - **Efficient Lookup**: To quickly find non-overlapping vouchers, we preprocess each group by sorting the start days and maintaining a separate list of the minimum costs for vouchers ending by certain days. This allows us to use binary search to find valid pairs efficiently.\n\n### Solution Code\n```python\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    data = sys.stdin.read().split()\n    it = iter(data)\n    n = int(next(it))\n    x = int(next(it))\n    \n    vouchers = []\n    for _ in range(n):\n        l = int(next(it))\n        r = int(next(it))\n        cost = int(next(it))\n        vouchers.append((l, r, cost))\n        \n    max_day = 200000\n    \n    duration_dict = defaultdict(list)\n    for l, r, cost in vouchers:\n        dur = r - l + 1\n        duration_dict[dur].append((l, r, cost))\n        \n    groups = {}\n    for dur, lst in duration_dict.items():\n        if dur > x:\n            continue\n        comp = x - dur\n        if comp < 0 or comp not in duration_dict:\n            continue\n        groups[dur] = lst\n        \n    min_costs = {}\n    for dur, lst in groups.items():\n        comp_dur = x - dur\n        if comp_dur not in groups:\n            continue\n            \n        arr = [item[0] for item in lst]\n        arr.sort()\n        min_cost_arr = [10**18] * len(arr)\n        min_so_far = 10**18\n        for idx, l_val in enumerate(arr):\n            min_so_far = min(min_so_far, lst[idx][2])\n            min_cost_arr[idx] = min_so_far\n        \n        min_costs[dur] = (arr, min_cost_arr)\n        \n    ans = 10**18\n    found = False\n    \n    for dur, lst in groups.items():\n        comp_dur = x - dur\n        if comp_dur not in groups:\n            continue\n            \n        arr1, min_cost_arr1 = min_costs[dur]\n        arr2 = [item[0] for item in groups[comp_dur]]\n        arr2.sort()\n        min_cost_arr2 = [10**18] * len(arr2)\n        min_so_far = 10**18\n        for idx, l_val in enumerate(arr2):\n            min_so_far = min(min_so_far, groups[comp_dur][idx][2])\n            min_cost_arr2[idx] = min_so_far\n            \n        i = 0\n        j = 0\n        while i < len(arr1) and j < len(arr2):\n            l1, r1 = lst[i][:2]\n            l2 = arr2[j]\n            if r1 < l2:\n                total_cost = lst[i][2] + groups[comp_dur][j][2]\n                candidate = min_cost_arr1[i] + min_cost_arr2[j]\n                ans = min(ans, candidate)\n                j += 1\n            else:\n                i += 1\n                \n    if ans == 10**18:\n        print(-1)\n    else:\n        print(ans)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into a list of vouchers, each characterized by start day, end day, and cost.\n2. **Grouping by Duration**: Vouchers are grouped by their duration (end day - start day + 1). Only durations that can form a pair summing to `x` are considered.\n3. **Preprocessing**: For each duration group, we sort the start days and prepare a list of minimum costs encountered up to each position. This helps in efficiently finding the cheapest voucher that ends before a given start day.\n4. **Finding Valid Pairs**: Using binary search, we check for non-overlapping pairs between the current duration group and its complement. The total cost is updated whenever a valid pair is found.\n5. **Output Result**: The minimum total cost is printed if valid pairs exist; otherwise, `-1` is printed indicating no solution.\n\nThis approach efficiently narrows down the search space using grouping and binary search, ensuring optimal performance even for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import defaultdict\n\ndef main():\n    data = sys.stdin.read().split()\n    it = iter(data)\n    n = int(next(it))\n    x = int(next(it))\n    \n    vouchers = []\n    for _ in range(n):\n        l = int(next(it))\n        r = int(next(it))\n        cost = int(next(it))\n        vouchers.append((l, r, cost))\n        \n    max_day = 200000\n    \n    duration_dict = defaultdict(list)\n    for l, r, cost in vouchers:\n        dur = r - l + 1\n        duration_dict[dur].append((l, r, cost))\n        \n    groups = {}\n    for dur, lst in duration_dict.items():\n        if dur > x:\n            continue\n        comp = x - dur\n        if comp < 0 or comp not in duration_dict:\n            continue\n        groups[dur] = lst\n        \n    min_costs = {}\n    for dur, lst in groups.items():\n        comp_dur = x - dur\n        if comp_dur not in groups:\n            continue\n            \n        arr = [item[0] for item in lst]\n        arr.sort()\n        min_cost_arr = [10**18] * len(arr)\n        min_so_far = 10**18\n        for idx, l_val in enumerate(arr):\n            min_so_far = min(min_so_far, lst[idx][2])\n            min_cost_arr[idx] = min_so_far\n        \n        min_costs[dur] = (arr, min_cost_arr)\n        \n    ans = 10**18\n    found = False\n    \n    for dur, lst in groups.items():\n        comp_dur = x - dur\n        if comp_dur not in groups:\n            continue\n            \n        arr1, min_cost_arr1 = min_costs[dur]\n        arr2 = [item[0] for item in groups[comp_dur]]\n        arr2.sort()\n        min_cost_arr2 = [10**18] * len(arr2)\n        min_so_far = 10**18\n        for idx, l_val in enumerate(arr2):\n            min_so_far = min(min_so_far, groups[comp_dur][idx][2])\n            min_cost_arr2[idx] = min_so_far\n            \n        i = 0\n        j = 0\n        while i < len(arr1) and j < len(arr2):\n            l1, r1 = lst[i][:2]\n            l2 = arr2[j]\n            if r1 < l2:\n                total_cost = lst[i][2] + groups[comp_dur][j][2]\n                candidate = min_cost_arr1[i] + min_cost_arr2[j]\n                ans = min(ans, candidate)\n                j += 1\n            else:\n                i += 1\n                \n    if ans == 10**18:\n        print(-1)\n    else:\n        print(ans)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 734,
        "completion_token_count": 1134,
        "thoughts_token_count": 1023
    }
}