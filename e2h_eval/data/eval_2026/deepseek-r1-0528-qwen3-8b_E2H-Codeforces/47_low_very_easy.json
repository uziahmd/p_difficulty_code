{
    "start": 1758294607.3333783,
    "end": 1758297393.7707171,
    "start-formatted": "2025-09-20 00:10 KST",
    "end-formatted": "2025-09-20 00:56 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\n Okay, let's analyze the problem:\n\nWe are given two integers a and b (with 1 <= a, b <= 10^9). We need to find a non-negative integer k such that:\n   LCM(a+k, b+k) is minimized.\n\nNote: If multiple k yield the same minimal LCM, choose the smallest k.\n\nLet d = a - b. Without loss of generality, we can assume a >= b by swapping if needed? Actually, note that k is added to both, so we can also consider symmetry.\n\nBut note: if a == b, then we have LCM(a+k, a+k) = a+k, which is minimized at k=0.\n\nNow, assume a != b. Let g = gcd(a+k, b+k). Then, we know that:\n   (a+k)*(b+k) / gcd(a+k, b+k) = LCM(a+k, b+k)\n\nAlso note that:\n   gcd(a+k, b+k) = gcd(a+k, (a+k)-(b+k)) = gcd(a+k, a-b)\n\nSo the gcd must divide (a-b). Therefore, the divisors of the gcd are divisors of |a-b|.\n\nLet d = |a-b|. Then, for each divisor g of d, we can set:\n   gcd(a+k, b+k) = g\n\nThen, we require that g divides (a+k) and (b+k). This implies that k ≡ (-a) mod g and k ≡ (-b) mod g. But since g divides d = a-b, note that a mod g and b mod g are related: a ≡ b + d (mod g) => so if we set k ≡ (-a) mod g, then it automatically satisfies k ≡ (-b) mod g because (-b) ≡ (-a) - d (mod g) and d is divisible by g.\n\nTherefore, for a divisor g of d, we can set k to be the smallest non-negative solution to:\n   k ≡ (-a) mod g   (which is equivalent to k ≡ (g - a % g) % g, but note: if a % g != 0, then k_min = (g - a%g) % g? Actually, we want k>=0 and minimal, so we can set k0 = (g - (a % g)) % g, but if a%g==0 then k0=0).\n\nHowever, note: we have two congruences, but they are the same modulo g. So we can set k0 = (g - (a % g)) % g, but wait: if we define r = a % g, then we require k ≡ -r (mod g). The smallest non-negative k is (g - r) % g, but if r==0 then (g-0)%g=0.\n\nBut note: we also have the possibility that k might be negative? We take non-negative, so we use modulo.\n\nActually, we can write: k0 = (g - (a % g)) % g, but note: if a % g == 0, then (g - 0) % g = 0, which is correct.\n\nBut note: there's another way. We can also consider the condition on the LCM. However, we are iterating over divisors of d. The idea is that the gcd must be a divisor of d, so we can consider all divisors g of d (including d itself and 1). Then for each divisor g, we can compute a candidate k0 (the minimal non-negative k that satisfies k ≡ (-a) mod g). Then, we can check the LCM for k0 and also for k0 + multiples of g? Actually, the condition is that the gcd is exactly g? Not necessarily. We only know that the gcd must divide d, but the actual gcd might be a multiple of g? Actually, no: the gcd must be a divisor of d, but when we set k to satisfy k ≡ (-a) mod g, then the gcd will be at least g (because g divides both numbers). However, the gcd might be greater than g? Actually, no: because the gcd must divide d, and we set the condition that g divides the gcd, but the gcd might be any divisor of d that is a multiple of g? \n\nWait, let me clarify: \n   We know that gcd(a+k, b+k) must divide d. Also, if we set k such that g divides (a+k) and (b+k), then the gcd will be at least g, but it could be any divisor of d that is divisible by g? Actually, no: the gcd is the greatest common divisor, so it must be the maximum divisor of d that divides both (a+k) and (b+k). However, we are setting k to satisfy the",
    "response": "\nTo solve this problem, we need to find a non-negative integer \\( k \\) such that the least common multiple (LCM) of \\( a + k \\) and \\( b + k \\) is minimized. If multiple values of \\( k \\) yield the same minimal LCM, we should choose the smallest \\( k \\).\n\n### Approach\n1. **Problem Analysis**: The key observation here is that the greatest common divisor (GCD) of \\( a + k \\) and \\( b + k \\) must be a divisor of the absolute difference between \\( a \\) and \\( b \\), denoted as \\( d = |a - b| \\). This is because \\( \\text{gcd}(a + k, b + k) = \\text{gcd}(a + k, d) \\).\n\n2. **Insight**: For each divisor \\( g \\) of \\( d \\), we can compute a candidate \\( k \\) such that \\( k \\equiv (-a) \\mod g \\). This ensures that \\( g \\) divides both \\( a + k \\) and \\( b + k \\). The smallest non-negative \\( k \\) for each divisor \\( g \\) is given by \\( k = (g - (a \\% g)) \\% g \\).\n\n3. **Algorithm Selection**: We generate all divisors of \\( d \\), compute the corresponding \\( k \\) for each divisor, and then evaluate the LCM for these \\( k \\) values. The \\( k \\) that results in the smallest LCM is our answer. If multiple \\( k \\) values yield the same minimal LCM, the smallest \\( k \\) is chosen.\n\n4. **Complexity Analysis**: The time complexity is dominated by the factorization of \\( d \\), which is \\( O(\\sqrt{d}) \\). Given the constraints \\( 1 \\leq a, b \\leq 10^9 \\), \\( d \\) can be up to \\( 10^9 \\), making the factorization feasible with efficient algorithms.\n\n### Solution Code\n```python\nimport math\n\ndef main():\n    a, b = map(int, input().split())\n    if a == b:\n        print(0)\n        return\n        \n    d = abs(a - b)\n    divisors = set()\n    i = 1\n    while i * i <= d:\n        if d % i == 0:\n            divisors.add(i)\n            divisors.add(d // i)\n        i += 1\n        \n    best_k = 0\n    best_lcm = float('inf')\n    \n    for g in divisors:\n        k_candidate = (g - (a % g)) % g\n        x = a + k_candidate\n        y = b + k_candidate\n        current_gcd = math.gcd(x, y)\n        lcm_val = x * y // current_gcd\n        \n        if lcm_val < best_lcm:\n            best_lcm = lcm_val\n            best_k = k_candidate\n            \n    print(best_k)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Input Handling**: The code reads two integers \\( a \\) and \\( b \\). If they are equal, it immediately prints \\( 0 \\) since the LCM of \\( a \\) and \\( a \\) is minimized at \\( k = 0 \\).\n\n2. **Divisor Calculation**: The absolute difference \\( d \\) between \\( a \\) and \\( b \\) is computed. All divisors of \\( d \\) are found by checking factors up to \\( \\sqrt{d} \\).\n\n3. **Candidate Evaluation**: For each divisor \\( g \\) of \\( d \\), the smallest non-negative \\( k \\) such that \\( g \\) divides both \\( a + k \\) and \\( b + k \\) is calculated. The LCM of \\( a + k \\) and \\( b + k \\) is then computed.\n\n4. **Optimal \\( k \\) Selection**: The candidate \\( k \\) that results in the smallest LCM is tracked. If multiple \\( k \\) values yield the same minimal LCM, the smallest \\( k \\) is retained.\n\nThis approach efficiently narrows down the candidates for \\( k \\) by leveraging the divisors of the difference between \\( a \\) and \\( b \\), ensuring optimal performance even for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef main():\n    a, b = map(int, input().split())\n    if a == b:\n        print(0)\n        return\n        \n    d = abs(a - b)\n    divisors = set()\n    i = 1\n    while i * i <= d:\n        if d % i == 0:\n            divisors.add(i)\n            divisors.add(d // i)\n        i += 1\n        \n    best_k = 0\n    best_lcm = float('inf')\n    \n    for g in divisors:\n        k_candidate = (g - (a % g)) % g\n        x = a + k_candidate\n        y = b + k_candidate\n        current_gcd = math.gcd(x, y)\n        lcm_val = x * y // current_gcd\n        \n        if lcm_val < best_lcm:\n            best_lcm = lcm_val\n            best_k = k_candidate\n            \n    print(best_k)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 397,
        "completion_token_count": 913,
        "thoughts_token_count": 1023
    }
}