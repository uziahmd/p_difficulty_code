{
    "start": 1758090717.135197,
    "end": 1758093133.0776198,
    "start-formatted": "2025-09-17 15:31 KST",
    "end-formatted": "2025-09-17 16:12 KST",
    "gpu": 2,
    "pid": 8,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\n Okay, we are given an undirected graph and the flow volume for each edge. We need to assign a direction (0 or 1) to each edge such that:\n   - For each vertex v (except source and sink), the sum of incoming flow equals the sum of outgoing flow.\n   - Vertex 1 has no incoming edges (so all edges incident to vertex 1 must be directed away from it? Actually note: condition says \"vertex with number 1 has no incoming edges\", so any edge connected to 1 must be directed from 1 to the neighbor).\n   - The directed graph does not have cycles.\n\n However, note that the problem is about a flow in an undirected graph. In a flow, we have conservation at every node (except source and sink, but actually the problem states for every vertex except the source and sink? Let me read again: \"for each vertex v (1 < v < n)\" -> so vertices 2 to n-1 must satisfy the conservation. But the source (vertex 1) and sink (vertex n) can have imbalance.\n\n Actually, the problem states:\n   - For each vertex v (1 < v < n): sum of incoming = sum of outgoing.\n   - Vertex 1 has no incoming edges (so all edges from 1 must go out, and no edge coming into 1).\n\n Also, the graph must not have cycles. This implies that the directed graph must be acyclic.\n\n How to think?\n\n Conditions:\n   - The entire flow must form a set of directed paths from the source to the sink (or possibly multiple sources and sinks? but here only one source and one sink). However, note that the problem does not require the flow to be acyclic in the sense of having only one path? Actually, the graph must not have cycles. So the directed graph must be acyclic.\n\n Observation: In a flow network, the edges are directed and the graph must not have cycles. Moreover, conservation conditions hold for internal nodes.\n\n Steps:\n\n 1. We know that the source (vertex 1) must have all edges going out. So for any edge (u, v) incident to 1, we must direct it from 1 to the other vertex (if u==1 then direction 0 meaning 1->v; if v==1 then direction 1 meaning u->1, but wait: the input gives (ai, bi, ci). The problem says: output 0 if the direction is ai->bi, and 1 otherwise.\n\n    However, note: the edge is given as (ai, bi). So if we are to direct the edge from ai to bi, then we output 0. Otherwise, if we direct it from bi to ai, then we output 1.\n\n    But the condition for vertex 1: no incoming. Therefore, if the edge is (1, v), then we must direct it from 1 to v (so output 0). Similarly, if the edge is (v, 1), then we must direct it from v to 1? But wait: if the edge is (v, 1) then we have two possibilities: either direct from v to 1 (then output 1) or from 1 to v (then output 0). However, note that the edge is undirected and the same edge is represented by (v, 1). Since the condition requires no incoming to vertex 1, we must direct the edge from v to 1? But wait: if we direct from v to 1, then that edge goes into 1, which is not allowed. Alternatively, we must direct from 1 to v. \n\n    Actually, the problem does not specify the order of the endpoints. The edge is undirected. So we can represent an edge between u and v. We have two choices: either u->v or v->u.\n\n    Condition for vertex 1: no incoming. Therefore, if an edge connects 1 and v, then the direction must be 1->v. So if the edge is given as (1, v) then we output 0 (meaning 1->v). If the edge is given as (v, 1) then we have to direct it as 1->v, so we would output 1 (because the given order is (v,1) and we want to reverse it to 1->v, so output 1).\n\n    However, note: the problem says \"each edge\" is given as (ai, bi). And we must output 0 if the direction is ai->bi, and 1 if bi->ai.\n\n    So for an edge (v, 1) we want to direct it as 1->v, which is the opposite of (v,1). So we output 1.\n\n 2. But there is more: the graph must be acyclic and the flow must be maximum. However, note the problem says: \"the",
    "response": "\nTo solve this problem, we need to determine the direction of flow for each edge in an undirected graph such that the resulting directed graph satisfies specific conditions: conservation of flow at each internal vertex (vertices 2 to n-1), no incoming edges to the source (vertex 1), and no cycles in the directed graph. The solution involves leveraging a spanning tree approach to ensure the directed graph meets these conditions efficiently.\n\n### Approach\n1. **Problem Analysis**: The problem requires transforming an undirected graph into a directed acyclic graph (DAG) where:\n   - For vertices 2 to n-1, the sum of incoming flow equals the sum of outgoing flow.\n   - Vertex 1 has no incoming edges.\n   - The directed graph is acyclic.\n   \n2. **Key Insight**: The solution can be derived by considering a spanning tree of the graph. In the spanning tree, edges are directed away from the source (vertex 1) to ensure no cycles and satisfy the flow conservation conditions. For edges not in the spanning tree, their directions are determined based on the shortest path distances from the source.\n\n3. **Algorithm Selection**:\n   - **BFS/DFS for Spanning Tree**: Use BFS starting from vertex 1 to compute the shortest path distances (levels) of all vertices.\n   - **Direction Determination**: For edges in the spanning tree, direct them away from the source (vertex 1). For non-spanning tree edges, direct them from the vertex with the smaller level to the vertex with the larger level. This ensures no cycles and meets the flow conservation conditions.\n\n4. **Complexity Analysis**: The algorithm involves a BFS traversal (O(n + m)) and processing each edge once (O(m)), making the overall complexity O(n + m), which is efficient for the given constraints (n and m up to 2·10^5).\n\n### Solution Code\n```python\nimport sys\nfrom collections import deque\n\ndef main():\n    data = sys.stdin.read().split()\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    \n    edges = []\n    for _ in range(m):\n        a = int(next(it))\n        b = int(next(it))\n        c = int(next(it))\n        edges.append((a, b, c))\n        \n    graph = [[] for _ in range(n+1)]\n    for a, b, c in edges:\n        graph[a].append((b, c))\n        graph[b].append((a, c))\n        \n    level = [-1] * (n+1)\n    parent = [0] * (n+1)\n    q = deque([1])\n    level[1] = 0\n    while q:\n        u = q.popleft()\n        for v, c in graph[u]:\n            if level[v] == -1:\n                level[v] = level[u] + 1\n                parent[v] = u\n                q.append(v)\n                \n    ans = [0] * m\n    for i, (a, b, c) in enumerate(edges):\n        if level[a] < level[b]:\n            ans[i] = 0 if a == parent[b] else 1\n        else:\n            ans[i] = 0 if b == parent[a] else 1\n            \n    for res in ans:\n        print(res)\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into the number of vertices (n) and edges (m), followed by the edges themselves.\n2. **Graph Construction**: An adjacency list is built to represent the undirected graph.\n3. **BFS Traversal**: Starting from vertex 1, BFS is used to compute the shortest path levels for all vertices and to establish parent-child relationships in the spanning tree.\n4. **Edge Direction Determination**: For each edge, the direction is determined based on the levels of the connected vertices:\n   - If the edge connects a parent to its child in the spanning tree, it is directed away from the parent (output 0).\n   - Otherwise, the edge is directed from the vertex with the smaller level to the one with the larger level (output 1), ensuring no cycles and flow conservation.\n5. **Output**: The directions for all edges are printed.\n\nThis approach efficiently transforms the undirected graph into a directed acyclic graph meeting the specified conditions using BFS and careful edge direction assignment based on vertex levels.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef main():\n    data = sys.stdin.read().split()\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    \n    edges = []\n    for _ in range(m):\n        a = int(next(it))\n        b = int(next(it))\n        c = int(next(it))\n        edges.append((a, b, c))\n        \n    graph = [[] for _ in range(n+1)]\n    for a, b, c in edges:\n        graph[a].append((b, c))\n        graph[b].append((a, c))\n        \n    level = [-1] * (n+1)\n    parent = [0] * (n+1)\n    q = deque([1])\n    level[1] = 0\n    while q:\n        u = q.popleft()\n        for v, c in graph[u]:\n            if level[v] == -1:\n                level[v] = level[u] + 1\n                parent[v] = u\n                q.append(v)\n                \n    ans = [0] * m\n    for i, (a, b, c) in enumerate(edges):\n        if level[a] < level[b]:\n            ans[i] = 0 if a == parent[b] else 1\n        else:\n            ans[i] = 0 if b == parent[a] else 1\n            \n    for res in ans:\n        print(res)\n\nif __name__ == '__main__':\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 695,
        "completion_token_count": 926,
        "thoughts_token_count": 1023
    }
}