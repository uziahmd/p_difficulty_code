{
    "start": 1758296897.5070927,
    "end": 1758300338.3412764,
    "start-formatted": "2025-09-20 00:48 KST",
    "end-formatted": "2025-09-20 01:45 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\n Okay, let's analyze the problem:\n\nWe are given two integers a and b (with 1 <= a, b <= 10^9). We need to find a non-negative integer k such that:\n   LCM(a+k, b+k) is minimized.\n\nNote: If multiple k yield the same minimal LCM, choose the smallest k.\n\nLet d = a - b. Without loss of generality, we can assume a >= b by swapping if needed? Actually, note that k is added to both, so the relative difference changes with k.\n\nBut note: We have to consider two cases: when a == b, then LCM(a+k, a+k) = a+k, so we want the smallest k that minimizes a+k. Since k>=0, the minimum is at k=0. But wait, what if a != b?\n\nAlternatively, we can use the following approach:\n\nWe know that LCM(x, y) = x * y / GCD(x, y). Therefore, minimizing LCM(x,y) is equivalent to maximizing GCD(x,y) because x and y are increasing with k. However, note that the product (x*y) also increases with k, so we cannot simply maximize the GCD. \n\nBut observe: Let x = a+k, y = b+k. Then note that:\n   x - y = a - b (a constant)\n\nSo, we can write: x = y + (a-b) [if a>=b] or y = x + (b-a) [if b>=a]. Without loss of generality, we can assume a>=b by symmetry.\n\nActually, we can set d = a - b. Then for k>=0, we have:\n   Let g be a divisor of d (because the gcd(x,y) must divide x-y, which is d). Then set g = gcd(x,y). Then we require that g divides d.\n\nBut note: There might be divisors that are not necessarily positive? We consider positive divisors.\n\nNow, we can think of k in terms of making the gcd as large as possible. However, note that even if we fix a divisor g of d, then we require that:\n   g divides (a+k) and g divides (b+k) => g divides (a+k - (b+k)) = a-b = d.\n\nSo, the gcd must be a divisor of d. But note: d might be negative? Actually, we can take absolute value? Since gcd is defined for absolute values.\n\nLet d = |a-b|.\n\nThen, the gcd(x,y) must be a divisor of d. So, we can consider all divisors of d (if d != 0). If d=0, then a==b, then the problem reduces to k=0.\n\nBut note: if d=0, then the numbers are equal. Then LCM(a+k, a+k) = a+k, which is minimized at k=0.\n\nNow, for d != 0, we consider the divisors of d. For each divisor g (positive) of d, we can set:\n\n   We require that g divides (a+k) and g divides (b+k). Then k must be chosen so that:\n        k ≡ (-a) mod g   and   k ≡ (-b) mod g.\n\nBut note that since g divides (a-b), then (-a) mod g and (-b) mod g are related. In fact, we require that (a+k) % g == 0 and (b+k) % g == 0. This is equivalent to k ≡ (-a) mod g and k ≡ (-b) mod g. But note that a ≡ b mod g (because g divides a-b). Therefore, we only need one congruence: k ≡ (-a) mod g.\n\nBut we are free to choose k as small as possible (non-negative). So for each divisor g (of d) we can set:\n\n   k0 = (g - a % g) % g   [This gives the smallest non-negative k such that (a+k) % g == 0]\n\nHowever, note: we are allowed to consider divisors g of d, but note that g must be positive and we consider all divisors (including 1 and d).\n\nBut wait: there might be more than one divisor. Then we have to consider the candidate k for each divisor g, and then compute the LCM for the candidate k and compare.\n\nBut note: the LCM for a candidate k is ( (a+k)*(b+k) ) / g. However, note that the gcd might be larger than g? Actually, the gcd is at least g, but could be a multiple of g? However, we are considering all divisors, and the actual gcd might be a divisor of d, but it must divide d. However, we are iterating over divisors, and the condition for k is that the gcd divides d, but the actual gcd might be any divisor of d (and in particular, the candidate k we found for divisor g will make the gcd divisible by g, but the actual gcd might be a multiple of g (if g is not the full gcd)). However, note: the k we choose for divisor g is the smallest k that satisfies both conditions. But the actual gcd might be greater than g. How do we account for that?\n\nAlternatively, we can note that the gcd(x,y) must be a divisor of d. And we can consider each divisor g (meaning the gcd might be g, but actually it might be a multiple of g). However, the candidate k we choose for divisor g is the minimal k that makes g divide both (a+k) and (b+k). But the actual gcd might be the gcd of (a+k) and (b+k), which is the same as the gcd of (a+k) and d (since (b+k) = (a+k) - d). \n\nBut note: the problem asks for the minimal k that minimizes the LCM. We have to consider that for different divisors, we get different k and then different LCM.\n\nHowever, there is a catch: the same k might be obtained from multiple divisors, and the LCM for a given k is fixed.\n\nAnother approach:\n\nWe know that the gcd(x,y) must be a divisor of d. So, the set of divisors of d is finite (at most around 1344 divisors for numbers up to 1e9). We can iterate over all divisors g of d (taking absolute value) and for each divisor, compute the minimal k (non-negative) such that g divides (a+k) and g divides (b+k). Then, for that k, the gcd(x,y) is at least g, and the LCM is (x*y)/gcd(x,y). But note: we don't know the exact gcd, but we know that the gcd divides d. However, the candidate k we choose for divisor g is the minimal k that satisfies the condition for g. Then, for that k, the gcd might be greater than g. But note: we are going to consider every divisor, including the ones that are factors of d. The key is that the gcd must divide d, so the actual gcd is one of the divisors of d. \n\nBut here's the issue: if we consider a divisor g, then the k we get is the minimal k such that g divides (a+k) and (b+k). However, the actual gcd might be a divisor h of d (which is a multiple of g?) No, actually the divisors of d are independent. But note: the condition for k to satisfy that g divides (a+k) and (b+k) does not guarantee that the gcd is exactly g. It just guarantees that g divides the gcd. So, the actual gcd might be any divisor of d that is a multiple of g? Not necessarily: the gcd must divide d, and it must divide (a+k) and (b+k). But note: the gcd must also divide d, and d is fixed.\n\nHowever, we are iterating over every divisor. The minimal k that we compute for a divisor g might be the same as the minimal k for a divisor h (if h divides g, then the condition for g implies the condition for h). But we are required to choose the smallest k that minimizes the LCM.\n\nBut note: the LCM for a given k is (a+k)*(b+k) / gcd(a+k, b+k). Since the gcd is at least g (from the divisor we considered), then the LCM is at most (a+k)*(b+k)/g. However, we don't know the exact gcd, so we cannot compare the LCMs without knowing the exact gcd.\n\nAlternative Insight:\n\nWe can relate the problem to the equation: \n   Let g = gcd(a+k, b+k). Then g divides (a-b). So, g must be a divisor of |a-b|.\n\nMoreover, note that the LCM is (a+k)*(b+k) / g. We want to minimize this.\n\nBut note: (a+k)*(b+k) is increasing with k (since a,b,k are positive). So, for smaller k we have smaller product, but the denominator g (the gcd) is increasing as k increases (if we choose k appropriately). There is a trade-off.\n\nBut note: the candidate k's we consider are determined by divisors of d. So, we can do:\n\n   Let d0 = abs(a-b)\n   Consider all divisors g of d0 (if d0 != 0). Also include k=0 as candidate? Actually, k=0 is already included when we consider divisors, because the divisor g must divide d0, and the condition for k=0 is that g divides both a and b. But note: if we consider g=1, then k=0 is a candidate if 1 divides a and b (which it always does). \n\nHowever, we must consider that the minimal k might not come from the divisors of d0? Actually, note: the gcd(a+k, b+k) must divide (a-b), so the candidate k must satisfy that the gcd divides (a-b). Therefore, the condition on k is that there exists a divisor g of (a-b) such that g divides (a+k) and (b+k). \n\nBut note: the minimal k for a divisor g is computed by:\n\n   k_min(g) = (g - (a % g)) % g   [This gives the smallest k such that (a+k) % g == 0, and similarly (b+k) % g == 0 because g divides (a-b)].\n\nBut wait, we must check: if a % g = r, then we need k such that (a+k) % g = 0 -> k_min(g) = (g - r) % g.\n\nHowever, note: if a % g == 0, then k_min(g)=0. Otherwise, k_min(g) = g - (a % g). But note: we require that (b+k) % g == 0. Since (a-b) % g == 0, then (b+k) % g = (b % g + k) % g = (b % g + (g - (a % g))) % g. But note: (a % g) = (b % g + (a-b)) % g = (b % g) + (a-b) (mod g) but (a-b) is divisible by g, so (a % g) = (b % g). Therefore, (b % g) = (a % g). Then (b+k) % g = ( (a % g) + (g - a % g) ) % g = g % g = 0. So the condition for b+k is automatically satisfied if the condition for a+k is satisfied.\n\nTherefore, for each divisor g of d0, we can compute k0 = (g - a % g) % g, and then the LCM for that k0 is:\n\n   lcm0 = (a+k0) * (b+k0) // gcd(a+k0, b+k0)\n\nBut note: we don't know the gcd(a+k0, b+k0) exactly. However, we know that the gcd must be at least g (because g divides both a+k0 and b+k0). But the gcd might be larger. How can we compute the gcd? Actually, we can compute it from (a+k0) and (b+k0). But note: the gcd must divide d0, and we know that the gcd is the gcd of (a+k0) and (b+k0). However, we can compute the gcd for the candidate k0.\n\nBut wait: the candidate k0 is the minimal k that makes g divide (a+k0) and (b+k0). The actual gcd might be a divisor of d0 that is greater than g. However, we are iterating over all divisors, so we will also consider the divisors that are multiples of g (if they exist). But note: the divisor g we are considering is arbitrary. \n\nHowever, we must consider: if we consider a divisor g, and then the actual gcd is h (a divisor of d0) that is greater than g, then the same k0 might be generated by the divisor h (if k0 is the minimal k for h). But note: the minimal k for h (if h divides d0) might be different. Actually, the minimal k for h is (h - a % h) % h. \n\nBut note: if h is a divisor of d0 and g is also a divisor of d0, and h divides g (so g is a multiple of h), then the condition for h (k must be such that a+k ≡ 0 mod h) is stronger than the condition for g (a+k ≡ 0 mod g). Therefore, the k0 for g might be different from the k0 for h. \n\nHowever, the problem is: we are iterating over divisors, and we are going to consider every divisor. Then, we can compute the LCM for each candidate k (from each divisor) and then pick the k that minimizes the LCM, and if there are multiple k, pick the smallest k.\n\nBut note: the same k might appear from multiple divisors. Then we must avoid duplicate computation? Actually, we can store the best k and its corresponding LCM.\n\nSteps:\n\n1. If a == b, then output 0.\n2. Else, let d = abs(a-b). Then, factorize d to get all divisors (positive).\n3. Initialize:\n      best_k = 0\n      best_lcm = LCM(a+0, b+0)   [which is (a*b)//gcd(a,b) if a>=b? Actually, we don't know which is bigger, but we can use math.gcd]\n\nBut note: we are going to consider k=0, but k=0 might be generated by divisor g=1 (because 1 divides everything). So we don't need to separately consider k=0.\n\nHowever, we must consider: the divisor set includes 1, and then k0 for g=1 is 0 if a%1==0 (which it is). So k0=0 is generated.\n\nBut note: the LCM at k=0 is (a*b)//gcd(a,b). We'll compare with other k0.\n\nBut the problem: the number of divisors can be up to about 1344 (for numbers around 10^9). So we can iterate over all divisors.\n\nBut wait: what if d=0? Then we skip. But we already handled a==b.\n\nBut note: the divisors of d include negative divisors? No, we consider positive divisors.\n\nAlgorithm:\n\n   if a == b:\n        print(0)\n        exit\n\n   d = abs(a-b)\n   divisors = all positive divisors of d (including 1 and d)\n\n   candidates = {}   # mapping from k to LCM value, but we want to minimize LCM and then k\n\n   But we can do: \n        best_k = None\n        best_lcm = None\n\n   For each divisor g in divisors:\n        k0 = (g - a % g) % g\n        # But note: if a % g == 0, then (g - a % g) % g = (g-0)%g = 0 % g = 0. That's correct.\n\n        # Now, we must compute the LCM for (a+k0) and (b+k0). However, we can compute the gcd between (a+k0) and (b+k0) and then the LCM = (a+k0)*(b+k0)//gcd_value.\n\n        x = a + k0\n        y = b + k0\n\n        # Compute gcd(x,y). Note: gcd(x,y) must divide d, but we can use Euclidean algorithm.\n\n        g_val = gcd(x, y)   # This is the actual gcd.\n\n        current_lcm = (x * y) // g_val\n\n        Then, we compare current_lcm with best_lcm. But note: the same k0 might appear multiple times (from different divisors). We can use a dictionary to record the best LCM for each distinct k0, but k0 is the same for the same k.\n\n        However, we are iterating over divisors and we might get the same k0 from different divisors. Then we don't want to compute the LCM twice. But note: the LCM for a fixed k0 is fixed, so we can record (k0, current_lcm) and then compare.\n\n        But wait: we are getting the same k0 from different divisors. Then we can break the iteration? Or we can store the best candidate for each k0.\n\n        Alternatively, we can simply consider all candidate k0 (each divisor gives one candidate k0) and then compare the LCM.\n\n        However, note: it is possible that the same k0 is generated by multiple divisors, but the LCM for that k0 is fixed. So we can avoid recalculating the same k0 multiple times by storing seen k0.\n\n        Steps:\n\n          seen = set()\n          best_k = 0\n          best_lcm = (a*b)//math.gcd(a,b)   [for k=0]\n\n          For each divisor g (positive divisor of d):\n            k0 = (g - a % g) % g\n            if k0 in seen: continue\n            seen.add(k0)\n\n            x = a+k0; y = b+k0\n            g_val = gcd(x, y)\n            current_lcm = (x*y) // g_val\n\n            if current_lcm < best_lcm:\n                best_lcm = current_lcm\n                best_k = k0\n            elif current_lcm == best_lcm and k0 < best_k:\n                best_k = k0\n\n          print(best_k)\n\nBut wait: is it possible that the same k0 is generated by multiple divisors? Yes, for example, if g1 and g2 are divisors and the k0 for both is the same. Then we avoid redundant calculation.\n\nBut note: the divisor set is the divisors of |a-b|. The candidate k0 is the smallest non-negative integer such that (a+k0) mod g == 0. The same k0 may be achieved by multiple divisors.\n\nHowever, we must also consider: are there divisors that are not positive? We are taking absolute value and positive divisors.\n\nBut note: the divisor set we consider is the positive divisors of d. That is correct.\n\nBut wait: what if d=0? We already handled a==b.\n\nBut there's a catch: the divisor set we get from d might be incomplete? Actually, no, we consider all divisors.\n\nBut note: the divisor g must divide d, and we are iterating over all divisors.\n\nHowever, we must consider: the condition for k0 is that g divides (a+k0) and (b+k0). But note: the gcd of (a+k0) and (b+k0) might be a divisor of d, but we are not requiring that the divisor g is the gcd. We are just using g to compute k0. Then we compute the actual gcd and the LCM.\n\nBut is this sufficient? Consider: we are generating candidate k0 for every divisor g of d. Then, the candidate k0 is the smallest k that makes g divide both numbers. However, the LCM might be further reduced by a larger divisor? Actually, no: because the gcd (which is the divisor of d) that we are using to generate k0 is arbitrary. But note: the candidate k0 for a divisor g is the same as the candidate k0 for a divisor h (if h divides g) only if the minimal k for h is the same as for g? Not necessarily: the minimal k for h (a divisor of g) is (h - a % h) % h, which is generally less than or equal to (g - a % g) % g? Actually, no: the k0 for h is independent. \n\nBut note: if h divides g, then the condition for g (which is a multiple of h) is stronger. So the k0 for h might be less than or equal to the k0 for g? Actually, no: consider a=5, b=3, then d=2. Divisors: 1,2.\n\nFor g=1: k0 = (1 - 5%1) % 1 -> but modulo 1: 5%1 is 0, so k0=0.\nFor g=2: k0 = (2 - 5%2) % 2 = (2-1)%2 = 1.\n\nNow, for k0=0: numbers are (5,3) -> gcd(5,3)=1, LCM=15.\nfor k0=1: numbers are (6,4) -> gcd(6,4)=2, LCM=12.\n\nBut note: the divisor set of d=2 is {1,2}. We considered both.\n\nWhat about divisors that are not divisors of d? We don't consider them.\n\nBut wait: is it possible that the minimal k that minimizes the LCM is not captured by the divisors of d? \n\nProof sketch: the gcd must divide (a-b). Therefore, the candidate k must be such that there exists a divisor g of (a-b) for which g divides (a+k) and (b+k). Therefore, we cover all possibilities.\n\nBut note: the candidate k0 we compute for divisor g is the minimal k that satisfies the condition for g. However, note that the actual minimal k that minimizes the LCM might be forced by a divisor that is not the gcd, but we are iterating over every divisor so we will eventually get the candidate k from the divisor that is the gcd (or a divisor that leads to the same k). \n\nBut wait: what if the gcd is not a divisor of d? Actually, the gcd must divide (a-b) because (a+k)-(b+k)=a-b. So yes, the gcd divides d.\n\nTherefore, the above method should work.\n\nHowever, note: the candidate k0 we compute is the minimal k for divisor g. But note: there might be a larger divisor h (that divides d) that gives an even smaller LCM? \n\nYes, but we are iterating over every divisor. We are comparing the LCM for every candidate k0 (from every divisor) and choosing the one with the smallest LCM, and if there are multiple we choose the smallest k0.\n\nBut note: the candidate k0 from a divisor g might be the same as from divisor h, so we avoid duplicates by the set.\n\nBut note: the number of divisors is about O(sqrt(d)), which is acceptable for d up to 10^9 (about 1e5 divisors worst-case, but actually the worst-case is around 1344 divisors for highly composite numbers).\n\nBut wait: 10^9 is the maximum for d, and the maximum number of divisors for numbers up to 10^9 is about 1344 (as per known highly composite numbers). So we can factorize d and then generate all divisors.\n\nHow to factorize d? We can do trial division up to sqrt(d).\n\nBut note: d = |a-b|, and a,b can be up to 10^9, so d can be up to 10^9. Factorization of a number up to 10^9 is feasible in Python if done efficiently (with trial division from 2 to sqrt(n)).\n\nHowever, we must be cautious: worst-case d is a prime number, then the divisors are only 1 and d. But the worst-case for the number of divisors is highly composite numbers, which we know has about 1344 divisors.\n\nBut note: the problem constraints say a,b from 1 to 10^9, so d from 0 to 10^9.\n\nBut if d=0, we handled separately.\n\nIf d>0, then we factorize d and get all divisors.\n\nBut note: we must consider that d might be very large (up to 10^9) but the factorization is acceptable because we only go up to sqrt(d) (which is 10^4.5, so about 31622). We can do trial division by primes up to sqrt(d), but we don't need primes: we can do trial by all integers.\n\nBut note: we are only doing this once, and the worst-case d is about 10^9, so the inner loop goes up to sqrt(d) which is about 31622, which is acceptable.\n\nSteps for factorization:\n\n   def factorize(n):\n        factors = {}\n        temp = n\n        d = 2\n        while d*d <= temp:\n            while temp % d == 0:\n                factors[d] = factors.get(d,0)+1\n                temp //= d\n            d += 1\n        if temp > 1:\n            factors[temp] = factors.get(temp,0)+1\n        return factors\n\nThen, generate all divisors from the factors.\n\nBut note: d might be 0, but we already handled a==b.\n\nBut wait: what if a and b are very close? Then d is small, factorization is fast.\n\nNow, we must also consider: what if the divisor g is 0? But we are iterating over positive divisors, and d is positive (so divisors are positive). So no.\n\nBut note: the divisor set generation: we want to include all divisors.\n\nAlternatively, we can use:\n\n   divisors = set()\n   factors = factorize(d)\n   # then use recursive generation or iterative (using exponents)\n\nBut there is a simpler way: iterate i from 1 to int(sqrt(d)) and if d % i == 0, then add i and d//i.\n\nBut note: d might be a perfect square, then we don't want to add the same divisor twice.\n\nBut we can do:\n\n   divisors = set()\n   i = 1\n   while i*i <= d:\n        if d % i == 0:\n            divisors.add(i)\n            divisors.add(d//i)\n        i += 1\n\nThis is efficient because the loop runs about sqrt(d) times.\n\nBut wait: d can be up to 10^9, then sqrt(d) is about 31622, which is acceptable.\n\nBut note: we are doing this only once.\n\nSo, the complete code:\n\n   import math\n   from math import gcd\n\n   def main():\n        data = input().split()\n        if not data:\n            return\n        a = int(data[0])\n        b = int(data[1])\n\n        if a == b:\n            print(0)\n            return\n\n        d = abs(a-b)\n\n        # If d is 0, handled above, so now d>0.\n        # Generate all divisors of d\n        divisors = set()\n        i = 1\n        # We'll iterate i from 1 to sqrt(d)\n        while i * i <= d:\n            if d % i == 0:\n                divisors.add(i)\n                divisors.add(d//i)\n            i += 1\n\n        # Now, we have the set of divisors (positive)\n        best_k = 0\n        # Compute LCM for k=0 initially\n        x0 = a\n        y0 = b\n        g0 = gcd(x0, y0)\n        best_lcm = (x0 * y0) // g0\n\n        # We'll use a set to record k0 we've already considered\n        seen_k = set()\n        for g in divisors:\n            # Skip g=0? divisors are positive, so no.\n            # Compute minimal k for this divisor g\n            # Note: a % g: if g is 0, then modulo by zero. But g is divisor of d (positive) and d>=1, so g>=1.\n            remainder = a % g\n            if remainder == 0:\n                k0 = 0\n            else:\n                k0 = g - remainder\n\n            # But note: the above formula is: k0 = (g - a % g) % g, but if a % g !=0, then (g - a % g) is the smallest positive k. However, if a % g ==0, then k0=0. But note: if we do (g - a % g) % g, then:\n            #   if a % g ==0, then (g-0)%g = 0.\n            #   else, (g - remainder) is between 1 and g-1, so modulo g doesn't change it.\n\n            # However, we can use the above if-else, or the one-liner: k0 = (g - a % g) % g. But note: if a % g ==0, then (g-0) % g = 0, which is correct.\n\n            # But wait: what if a % g is 0? then k0=0. Otherwise, k0 = g - (a % g). This is the minimal non-negative k.\n\n            # Now, if k0 is already in seen_k, skip.\n            if k0 in seen_k:\n                continue\n            seen_k.add(k0)\n\n            x = a + k0\n            y = b + k0\n            g_val = gcd(x, y)\n            current_lcm = (x * y) // g_val\n\n            # Compare current_lcm with best_lcm\n            if current_lcm < best_lcm:\n                best_lcm = current_lcm\n                best_k = k0\n            elif current_lcm == best_lcm and k0 < best_k:\n                best_k = k0\n\n        print(best_k)\n\nBut wait: is that correct? Let's test with the examples.\n\nExample 1: \"6 10\"\n\n   a=6, b=10, d=4, divisors of 4: {1,2,4}\n\n   For g=1: k0 = (1-6%1)%1 -> but 6%1 is 0, so k0=0.\n        x=6, y=10, gcd(6,10)=2, LCM= (6*10)//2 = 30.\n\n   For g=2: k0 = (2-6%2)%2 = (2-0)%2 = 0. (Because 6%2=0) -> k0=0 -> already seen? Then skip.\n\n   For g=4: k0 = (4-6%4)%4 = (4-2)%4=2.\n\n        x=8, y=12, gcd(8,12)=4, LCM=(8*12)//4=24.\n\n   Then best_lcm becomes 24, best_k=2.\n\n   Output: 2 -> matches.\n\nExample 2: \"21 31\"\n\n   a=21, b=31, d=10, divisors: {1,2,5,10}\n\n   g=1: k0=0 -> LCM(21,31)=651 (since gcd(21,31)=1)\n   g=2: k0 = (2-21%2)= (2-1)=1 -> k0=1\n        x=22, y=32, gcd(22,32)=2, LCM= (22*32)//2 = 352.\n   g=5: k0 = (5-21%5)= (5-1)=4 -> k0=4\n        x=25, y=35, gcd=5, LCM=(25*35)//5=175.\n   g=10: k0 = (10-21%10)= (10-1)=9 -> k0=9\n        x=30, y=40, gcd=10, LCM=(30*40)//10=120.\n\n   Then we compare: \n        k0=0: 651\n        k0=1: 352\n        k0=4: 175\n        k0=9: 120\n\n   So the minimal LCM is 120 at k0=9.\n\n   Output: 9 -> matches.\n\nExample 3: \"5 10\"\n\n   a=5, b=10, d=5, divisors: {1,5}\n   g=1: k0=0 -> LCM(5,10)=10 (gcd=5 -> wait: gcd(5,10)=5, so LCM=(5*10)//5=10)\n   g=5: k0=(5-5%5)=0 -> skip.\n\n   Output:0 -> matches.\n\nBut wait, the example input was ['6 10', '21 31', '5 10'] and output ['2','9','0'].\n\nHowever, note: in the example \"5 10\", k=0 gives LCM=10, but what about k=5?\n   k=5: numbers 10 and 15 -> gcd=5, LCM= (10*15)//5=30, which is worse.\n\nBut our method only considers divisors. What about k=5? Why wasn't k=5 considered?\n\nWait: the divisor set for d=5 is {1,5}. For divisor 5, k0 = (5-5%5)%5 = (5-0)%5=0. So k0=0 is generated. And for divisor 1, k0=0.\n\nBut note: is k=5 generated by any divisor? \n\nThe condition: we require that the gcd divides 5. The divisors are 1 and 5. \n\nFor k=5: \n   numbers: 10 and 15, gcd=5, which is a divisor. But how do we get k=5 from divisor 5? \n\nActually, the minimal k for divisor 5 is 0. But note: the condition for divisor 5 is that k must be such that 5 divides (5+k) and (10+k). \n\n   For k=5: (5+5)=10, divisible by 5; (10+5)=15, divisible by 5. But is k=5 the minimal k? \n\n   We compute: k0 = (5 - 5%5) %5 = 0. So the minimal k is 0, not 5.\n\nBut note: the minimal k for divisor 5 is 0. Then k=5 is not minimal. But we are only considering the minimal k for each divisor. \n\nIs it possible that a non-minimal k for one divisor might yield a lower LCM? \n\nIn this example, k=0 yields LCM=10, k=5 yields LCM=30. So the minimal k for divisor 5 is 0 and that gives a lower LCM.\n\nBut consider: \"4 6\" -> d=2, divisors {1,2}\n   k=0: numbers (4,6): gcd=2, LCM=12.\n   k=1: numbers (5,7): gcd=1, LCM=35.\n   k=2: numbers (6,8): gcd=2, LCM=24.\n\n   Our method: \n        divisors: {1,2}\n        g=1: k0=0 -> LCM= (4*6)//2=12\n        g=2: k0= (2-4%2)=0 -> skip.\n\n        Then we only consider k=0. But k=2 is not considered.\n\n   However, wait: the minimal k for divisor 2 is 0, but then k=0 is already considered. But note: the condition for divisor 2 is that the number must be even. The next k that satisfies divisor 2 is k=2 (then 4+2=6, 6+2=8). But we are only considering the minimal k for each divisor.\n\n   How do we get k=2? \n\n   Actually, k=2 is the minimal k for divisor 2 if we start from k=0? But no, because at k=0 we have 4 and 6, which are both even. So k0=0 is the minimal k for divisor 2.\n\n   However, note: the condition for divisor 2 is that the numbers are even. But at k=0 they are even, so k0=0.\n\n   But wait: k=0 is minimal. Then why is k=2 not considered? \n\n   The problem: the candidate k0 for divisor g is the minimal k that satisfies the condition. Therefore, we are not considering non-minimal k.\n\n   But note: the problem says: if there are multiple k that yield the same LCM, choose the smallest k. \n\n   However, k=0 and k=2 both yield even numbers, but k=0 is the minimal k for divisor ",
    "response": "\nTo solve this problem, we need to find a non-negative integer \\( k \\) such that the least common multiple (LCM) of \\( a + k \\) and \\( b + k \\) is minimized. If multiple values of \\( k \\) yield the same minimal LCM, we should choose the smallest \\( k \\).\n\n### Approach\n1. **Problem Analysis**: The key observation here is that the difference between \\( a + k \\) and \\( b + k \\) remains constant (\\( |a - b| \\)). The greatest common divisor (GCD) of \\( a + k \\) and \\( b + k \\) must be a divisor of this difference. Therefore, any candidate \\( k \\) must satisfy the condition that the GCD of \\( a + k \\) and \\( b + k \\) divides \\( |a - b| \\).\n\n2. **Insight**: For each divisor \\( g \\) of \\( |a - b| \\), we can compute the smallest non-negative \\( k \\) such that both \\( a + k \\) and \\( b + k \\) are divisible by \\( g \\). This \\( k \\) is given by \\( (g - (a \\% g)) \\% g \\). \n\n3. **Algorithm Selection**: \n   - **Case 1**: If \\( a = b \\), the answer is \\( k = 0 \\) since the LCM of \\( a + k \\) and \\( a + k \\) is minimized at \\( k = 0 \\).\n   - **Case 2**: For \\( a \\neq b \\), compute all positive divisors of \\( |a - b| \\). For each divisor \\( g \\), compute the minimal \\( k \\) that makes both \\( a + k \\) and \\( b + k \\) divisible by \\( g \\). Then, calculate the LCM for this \\( k \\) and keep track of the minimal LCM encountered, choosing the smallest \\( k \\) in case of ties.\n\n4. **Complexity Analysis**: The time complexity is dominated by the factorization of \\( |a - b| \\), which is \\( O(\\sqrt{d}) \\) where \\( d = |a - b| \\). Given \\( d \\) can be up to \\( 10^9 \\), the number of divisors is at most around 1344, making the approach efficient.\n\n### Solution Code\n```python\nimport math\nfrom math import gcd\n\ndef main():\n    data = input().split()\n    a = int(data[0])\n    b = int(data[1])\n    \n    if a == b:\n        print(0)\n        return\n        \n    d = abs(a - b)\n    divisors = set()\n    i = 1\n    while i * i <= d:\n        if d % i == 0:\n            divisors.add(i)\n            divisors.add(d // i)\n        i += 1\n        \n    best_k = 0\n    x0 = a\n    y0 = b\n    g0 = gcd(x0, y0)\n    best_lcm = (x0 * y0) // g0\n    \n    seen_k = set()\n    for g in divisors:\n        remainder = a % g\n        if remainder == 0:\n            k0 = 0\n        else:\n            k0 = g - remainder\n            \n        if k0 in seen_k:\n            continue\n        seen_k.add(k0)\n        \n        x_val = a + k0\n        y_val = b + k0\n        g_val = gcd(x_val, y_val)\n        current_lcm = (x_val * y_val) // g_val\n        \n        if current_lcm < best_lcm:\n            best_lcm = current_lcm\n            best_k = k0\n        elif current_lcm == best_lcm and k0 < best_k:\n            best_k = k0\n            \n    print(best_k)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Input Handling**: The code reads two integers \\( a \\) and \\( b \\) from the input.\n2. **Special Case Handling**: If \\( a \\) and \\( b \\) are equal, it immediately outputs \\( 0 \\) since the LCM is minimized at \\( k = 0 \\).\n3. **Divisor Calculation**: For \\( a \\neq b \\), the code calculates all positive divisors of \\( |a - b| \\) by iterating up to the square root of \\( |a - b| \\).\n4. **Finding Minimal \\( k \\)**: For each divisor \\( g \\), it computes the smallest \\( k \\) such that both \\( a + k \\) and \\( b + k \\) are divisible by \\( g \\). This \\( k \\) is derived using modulo arithmetic.\n5. **LCM Comparison**: For each computed \\( k \\), the code calculates the corresponding LCM and keeps track of the smallest LCM encountered, updating the best \\( k \\) whenever a smaller LCM is found or an equivalent LCM with a smaller \\( k \\) is found.\n6. **Output**: Finally, the smallest \\( k \\) that minimizes the LCM is printed.\n\nThis approach efficiently narrows down the candidates for \\( k \\) by leveraging the divisors of the difference between \\( a \\) and \\( b \\), ensuring optimal performance even for large values of \\( a \\) and \\( b \\).",
    "ground_truth": "N/A",
    "extracted_answer": "import math\nfrom math import gcd\n\ndef main():\n    data = input().split()\n    a = int(data[0])\n    b = int(data[1])\n    \n    if a == b:\n        print(0)\n        return\n        \n    d = abs(a - b)\n    divisors = set()\n    i = 1\n    while i * i <= d:\n        if d % i == 0:\n            divisors.add(i)\n            divisors.add(d // i)\n        i += 1\n        \n    best_k = 0\n    x0 = a\n    y0 = b\n    g0 = gcd(x0, y0)\n    best_lcm = (x0 * y0) // g0\n    \n    seen_k = set()\n    for g in divisors:\n        remainder = a % g\n        if remainder == 0:\n            k0 = 0\n        else:\n            k0 = g - remainder\n            \n        if k0 in seen_k:\n            continue\n        seen_k.add(k0)\n        \n        x_val = a + k0\n        y_val = b + k0\n        g_val = gcd(x_val, y_val)\n        current_lcm = (x_val * y_val) // g_val\n        \n        if current_lcm < best_lcm:\n            best_lcm = current_lcm\n            best_k = k0\n        elif current_lcm == best_lcm and k0 < best_k:\n            best_k = k0\n            \n    print(best_k)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 397,
        "completion_token_count": 1144,
        "thoughts_token_count": 8191
    }
}