{
    "start": 1758300671.2518008,
    "end": 1758304542.4058864,
    "start-formatted": "2025-09-20 01:51 KST",
    "end-formatted": "2025-09-20 02:55 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\n Okay, let's break down the problem.\n\n We are given an integer p (0 <= p <= 200000). We need to find:\n  1. The minimum number of nodes n such that there exists a directed graph with n nodes that is p-reachable.\n     - A graph is p-reachable if it contains exactly p ordered pairs (u, v) with u < v and u and v are mutually reachable.\n\n  2. Among all such graphs with n nodes, we need to maximize the number of unidirectional pairs (u, v) (where u != v, there is a path from u to v but not from v to u).\n\n Note: The graph must be directed and we are counting ordered pairs.\n\n Observation for part 1:\n\n In a directed graph, mutual reachability (i.e., two nodes u and v such that there is a path from u to v and from v to u) defines strongly connected components (SCCs). In fact, the entire graph can be decomposed into SCCs. Within an SCC, every node is mutually reachable with every other node.\n\n Let the graph have k strongly connected components (SCCs). Then, the condition for being p-reachable is that the total number of unordered pairs (u, v) with u < v and u and v in the same SCC is exactly p.\n\n However, note: the problem says \"exactly p ordered pairs (u, v) such that u < v and u and v are reachable from each other\". But note that in an SCC, for every unordered pair (u, v) with u < v, we have one ordered pair (u,v) (since u < v) that is counted? Actually, note: the problem counts ordered pairs (u, v) with u < v. So if we have an SCC of size s, then the number of unordered pairs (u, v) with u < v is C(s,2) = s*(s-1)//2. And since within the same SCC, every such pair is counted, the entire graph's p is the sum of the C(s_i, 2) for each SCC i.\n\n So, if we denote the sizes of the SCCs as s1, s2, ..., sk, then we require:\n   p = sum_{i=1}^{k} [ s_i*(s_i-1)//2 ]\n\n Additionally, the graph must have n = s1 + s2 + ... + sk nodes.\n\n We are to minimize n (the total number of nodes) subject to the above condition.\n\n How to minimize n?\n We can think of the problem as: represent p as a sum of triangular numbers (each term is s*(s-1)//2) and we want to minimize the total s1+s2+...+sk.\n\n Alternatively, note that we are allowed to have multiple SCCs. But the minimal n will be achieved by using as few SCCs as possible and making them as large as necessary? However, we can also use the fact that we can break one large SCC into smaller ones, but that might require more nodes because the triangular number for a component of size s is fixed.\n\n Actually, the problem is equivalent to: represent p as a sum of triangular numbers (each term is at most T(n) for the largest component) and minimize the sum of the bases (the s_i's). \n\n But note: the triangular numbers are nonnegative and increasing. The minimal total nodes would be achieved by having as few components as possible, but we can have one big component? Or maybe a mix?\n\n However, we cannot arbitrarily assign the components because the condition is that the entire graph must have exactly p mutual pairs (which are the pairs within the same SCC). So we are to write p as a sum of distinct triangular numbers? Not necessarily distinct, but the components are independent.\n\n Actually, we can use the same triangular number multiple times? But note: the SCCs are disjoint. So the triangular numbers are independent. However, we are free to choose any set of triangular numbers (each component's size s_i gives T(s_i)) such that the sum is p and the total nodes is minimized.\n\n How to minimize the total nodes? We want to maximize the size of the components because a larger component gives more triangular pairs per node? Actually, the triangular number grows as s^2, so to cover p we might want to use fewer large components.\n\n But note: we can also use multiple components. However, the problem is to minimize the total nodes. The total nodes is the sum of the sizes. We wish to minimize that.\n\n Consider: \n   Let T(s) = s*(s-1)//2.\n\n We can also note that if we use a component of size s, then it contributes T(s) and uses s nodes.\n\n We wish to minimize the total nodes (n) such that the sum of T(s_i) for each component is p.\n\n This is similar to the coin change problem where the coins are triangular numbers (with denominations T(1)=0, T(2)=1, T(3)=3, T(4)=6, etc.) and we want to minimize the total value of the coins (in terms of the base s_i) but wait: actually, the value of the coin is T(s) and the base is s. However, we want to minimize the sum of s_i, given that the sum of T(s_i) is p.\n\n But note: we are allowed to use any s_i (any positive integer) and we can use the same s_i multiple times? Actually, no: the components are disjoint and we can have multiple components of the same size. However, the minimal total nodes is the same as minimizing the sum of s_i, and we have the constraint that the sum of T(s_i) must be at least p? Actually, we require exactly p.\n\n However, note: we can break p arbitrarily as long as we use triangular numbers. But note: the triangular numbers are not necessarily distinct and we can use as many as we want.\n\n But observe: we are allowed to have any number of components. We wish to minimize the total nodes (the sum of the sizes) and achieve a total of p mutual pairs.\n\n Since T(s) = s*(s-1)//2, and we are to write p as a sum of some triangular numbers (each at least 0, and we can use 0 as well, but note: a component of size 1 has T(1)=0, so it doesn't contribute). \n\n However, we can also consider that we can have a component of size s only if T(s) is used. But note: we don't require the entire graph to be one SCC. We can have several.\n\n Now, we wish to minimize the total nodes (which is the sum of the s_i) such that the sum of T(s_i) is p.\n\n However, note: the triangular numbers are increasing and we can use greedy? Actually, we can use the following:\n\n   Let f(p) = minimal total nodes to achieve exactly p mutual pairs.\n\n   We can use dynamic programming? But p can be up to 200000, so we need an efficient way.\n\n Alternatively, we can note that the triangular numbers are the sequence: 0, 1, 3, 6, 10, 15, 21, ... \n\n We wish to minimize the sum of the bases (the s_i) when representing p as a sum of triangular numbers.\n\n However, note: we can use any triangular number multiple times. But wait, what is the maximum triangular number we can use? \n\n But note: the problem also requires that the graph is built with the minimum number of nodes. We are not restricted to using distinct s_i.\n\n However, the minimal representation of p as a sum of triangular numbers (minimizing the total nodes) is achieved by using as many large triangular numbers as possible? Why? Because a triangular number T(s) uses s nodes and gives T(s) pairs. The ratio T(s)/s = (s-1)/2, which increases as s increases. Therefore, to minimize the total nodes for a fixed p, we should use as large triangular numbers as possible.\n\n But wait: if we use two components of size s, then the total nodes is 2*s and the total pairs is 2*T(s). Alternatively, one component of size t such that T(t) = 2*T(s). Is that always better? Actually, we are not required to use the same triangular number. We can use a combination.\n\n However, note: the problem does not require the entire graph to be strongly connected. We can have multiple SCCs.\n\n Now, how to compute the minimal n (total nodes) for given p?\n\n We can consider:\n\n   Let g(x) = x*(x-1)//2.\n\n   We want to represent p as a sum of g(s_i) and minimize the sum of s_i.\n\n   Since g(x) is convex, we can use a greedy algorithm: use the largest triangular number <= p, subtract it, and then proceed.\n\n However, is that optimal for minimizing the total nodes? \n\n Example: p=5. \n   Triangular numbers: 0,1,3,6,...\n\n   If we use 3, then we have 2 left. Then we use two 1's (two components of size 2): so total nodes = 2 (for the first component) + 2+2 (for the two ones) = 6.\n\n   Alternatively, we can use two components: one of size 3 (gives 3) and one of size 2 (gives 1) -> total pairs 4, which is too low.\n\n   Actually, we need to get 5.\n\n   Another representation: \n        three components: one of size 3 (3), one of size 2 (1), and one of size 2 (1) -> total pairs 3+1+1=5, total nodes 3+2+2=7.\n\n   Or: one component of size 4 (gives 6) is too big (6>5).\n\n   Or: five components of size 2: each gives 1, so 5*1=5, total nodes 10.\n\n   Or: one component of size 3 (3) and two components of size 2 (1 each) -> 3+1+1=5, total nodes 3+2+2=7.\n\n   But wait, is there a representation with less than 7 nodes?\n\n   Consider: we can have one component of size 4? Then we have 6, which is too much. We cannot break the component arbitrarily? Actually, the graph can have multiple components. But note: the entire graph must have exactly p mutual pairs, so we cannot exceed p.\n\n   Alternatively, we can use a component of size 3 (3 pairs) and then we need 2 more pairs. The next smallest is 1 (size 2). So we need two more components of size 2, so total nodes 3+2+2=7.\n\n   However, note: we can have a component that is not just a complete graph? But the mutual pairs are defined by the existence of paths. In fact, the minimal way to get a component of size s is to make it strongly connected. The minimal number of edges to make a strongly connected component of size s is s (a directed cycle). Then the number of pairs is C(s,2). \n\n   But wait: the problem does not require the graph to be simple? Actually, the problem states a directed graph, so we can have multiple edges? However, the problem of counting pairs is about reachability, not edges. The minimal number of edges to make an SCC of size s is s (cycle). \n\n   However, the key point is: the mutual pairs are fixed by the SCCs. So we are forced to use the triangular numbers.\n\n   Now, is 7 the minimal for p=5? \n\n   Alternatively, we can use one component of size 4 (which gives 6) and then remove one edge? But then the graph might break into two components. However, we cannot arbitrarily adjust the mutual pairs by removing edges because the mutual pairs are determined by the SCCs. \n\n   Actually, we can only use the triangular numbers. So we have to represent p as a sum of triangular numbers (each T(s) for s>=1, and T(1)=0, T(2)=1, T(3)=3, T(4)=6, etc.). \n\n   So the problem reduces to: Represent p as a sum of triangular numbers (each T(s) for s>=1) and minimize the sum of the corresponding s_i.\n\n   This is known as the \"minimal representation\" of p in terms of triangular numbers, minimizing the total base.\n\n   We can use dynamic programming for small p, but p can be up to 200000.\n\n   Alternatively, we can use the following greedy: use the largest triangular number <= p, then solve for the remainder.\n\n   But is that optimal? \n\n   Example: p=5\n      Largest triangular <=5 is 3 (from s=3). Then remainder=2. Now, we can represent 2 by two 1's (each from s=2). Then total nodes = 3 + 2+2 = 7.\n\n      What if we use the next largest triangular number? 1 (from s=2) and then 1 (from s=2) and then 3? Actually, we are going from largest to smallest.\n\n   But note: the triangular numbers are: 0,1,3,6,10,15,... \n\n   However, there is a known fact: every number is the sum of at most three triangular numbers (Gauss proved that for the Euclidean algorithm, but actually that was for nonnegative integers and the greedy approach is not necessarily the best for minimizing the total base).\n\n   Actually, we are minimizing the sum of the bases (the s_i) and the triangular numbers are T(s)=s*(s-1)//2.\n\n   We can use a two-pointer or a mathematical insight.\n\n   Alternatively, we can note that the minimal total nodes is the minimal n such that the maximum p we can form with n nodes is at least p.\n\n   How much p can we form with n nodes? We can partition the n nodes into k components of sizes s1, s2, ..., sk (with s1+s2+...+sk = n) and then p = sum_i T(s_i). We wish to maximize p for a fixed n? Actually, we want to know: for a fixed n, what is the maximum p we can form? \n\n   To maximize p, we should use as few components as possible (because T(s) is convex: the function T(s) = s*(s-1)//2 is concave in the sense that the marginal gain for a given node is decreasing? Actually, the derivative of T(s) with respect to s is (s-1)/2, so adding one node to a component of size s increases the component's T by (s) [because T(s+1)-T(s)=s]. \n\n   However, to maximize p for fixed n, we should put all nodes in one component: then p = T(n) = n*(n-1)//2.\n\n   But wait, we are trying to represent p with minimal n. So for a fixed n, the maximum p we can get is T(n) (by having one big SCC). \n\n   Therefore, the minimal n must satisfy: T(n) >= p, but we can also use multiple components to get a p that is less than T(n). However, note: we are allowed to use multiple components. But the minimal n must be the smallest integer such that the maximum p (which is T(n)) is at least p? \n\n   Actually, no: because we can also use multiple components. For example, to get p=3, we can use one component of size 3 (T(3)=3) -> n=3. But we can also use three components of size 2: then p=3 (each gives 1, so 1+1+1=3) and n=6. So the minimal n is 3.\n\n   But wait, we can also use one component of size 2 (p=1) and then one component of size 2 (p=1) and then one component of size 2 (p=1) -> n=6, which is worse.\n\n   However, the minimal n must be the minimal integer such that the maximum p (which is T(n)) is at least p? \n\n   Actually, no: because we can also use a combination of components. The maximum p for n nodes is T(n) (if we use one big component). But the minimal n must satisfy that the maximum p (with n nodes) is at least p, but also we must be able to form p by some decomposition of n.\n\n   However, note: we can always break a component arbitrarily. The set of p values that can be formed with n nodes is the set of all numbers that are the sum of the triangular numbers of the sizes of a partition of n.\n\n   And the minimal n is the smallest n such that there exists a partition of n into positive integers s1, s2, ..., sk (each at least 1) and the sum of T(s_i) is exactly p.\n\n   But note: we are allowed to have components of size 1 (which contribute 0). \n\n   Alternatively, we can think: we have n nodes and we can assign them arbitrarily to form components. The total mutual pairs is the sum of T(s_i) for the components. We wish to achieve exactly p.\n\n   Since the triangular numbers are nonnegative, the minimal n must be at least the minimal n such that the maximum p (T(n)) is at least p, and also we can form p by a partition of n.\n\n   However, note: we can form any p that is at most T(n) (because we can break the graph arbitrarily). Actually, we can form any p between 0 and T(n) by appropriately breaking the n nodes.\n\n   Why? Consider: we have n nodes. We can form one component of size n, then p=T(n). We can break it into two components: one of size a and one of size n-a, then p = T(a)+T(n-a). Similarly, we can break arbitrarily. \n\n   But note: the set of achievable p with n nodes is the set of all numbers that can be written as the sum of triangular numbers from a partition of n. \n\n   However, we are allowed to have any partition. The set of achievable p is the entire set {0,1,...,T(n)}? \n\n   Actually, no: consider n=4. \n        One component: p=6.\n        Two components: possibilities are (1,3): p=0+3=3; (2,2): p=1+1=2; (3,1): same as (1,3); (4): already considered. Also, three components: (1,1,2): p=0+0+1=1; (1,2,1): same; (2,1,1): same. Four components: (1,1,1,1): p=0.\n        So we can get p=0,1,2,3,6. But what about 4 and 5? \n\n        With n=4, can we get p=4? \n        We need to partition 4: \n          4: 6 -> too big.\n          3+1: 3+0=3.\n          2+2: 1+1=2.\n          2+1+1: 1+0+0=1.\n          1+1+1+1:0.\n\n        So we cannot get 4 or 5.\n\n   Therefore, the set of achievable p for n nodes is not contiguous.\n\n   So we need to find the minimal n such that p is in the set of achievable p for n nodes.\n\n   How to do that? \n\n   Alternatively, we can use the following:\n\n   Let n be the total number of nodes.\n\n   We know that the maximum p we can have with n nodes is T(n)=n*(n-1)//2.\n\n   We need to find the minimal n such that T(n) >= p and p is in the set of achievable p for n.\n\n   But the set of achievable p for n nodes is the set of all numbers that can be represented as the sum of triangular numbers from a partition of n. \n\n   However, we can use the following theorem: \n        Every integer p can be represented as the sum of at most three triangular numbers (Landau-Göllnich theorem, but actually that is for nonnegative integers and without the constraint of the partition of n). \n\n   But here we are constrained by the partition of n.\n\n   We need to know: for a fixed n, what is the minimal p_min and maximal p_max? p_min=0 (all components of size 1) and p_max = T(n) (one component).\n\n   And we need to check if p is in the set.\n\n   However, we are iterating n from 0 upward until we find the smallest n such that p <= T(n) and p is achievable.\n\n   But note: the problem constraints say p up to 200000, so n is at most around sqrt(2*p) (since T(n) ~ n^2/2) so n is about 632 (because 632*631//2 ~ 200000). But then we have to check for each n from 0 to about 632 whether p is achievable by a partition of n.\n\n   How to check for a given n and p whether p is achievable?\n\n   We are to check if p can be written as the sum of triangular numbers (each T(s) for s>=1) and the sum of the s's is n.\n\n   This is similar to the integer partition problem, but with weights: each part s contributes T(s) and we have to use parts that sum to n.\n\n   We can use dynamic programming for a fixed n? But n is up to 632 and p up to 200000, and we have to do this for each n from 1 to 632, which is too slow.\n\n   Alternatively, we can precompute the minimal n for each p by iterating n and then updating the set of achievable p's for that n.\n\n   But p can be up to 200000, and n is about 632, so we can iterate n from 0 to 632 and for each n, we can compute the set of achievable p's for that n.\n\n   However, the state for a given n would be the set of p's (from 0 to T(n)) that are achievable. The size of T(n) is about 200000, and we are doing this for each n (about 632) so total states is 632 * 200000 which is about 126e6, which is acceptable in C++ but in Python might be borderline.\n\n   But note: we are only interested in the minimal n for which p is achievable.\n\n   Alternatively, we can use a greedy method: the minimal n is the smallest integer such that T(n) >= p and such that p is at most T(n) and p is in the set of numbers that are the sum of triangular numbers from partitions of n.\n\n   However, the set of achievable p for a fixed n is the set of numbers that can be written as the sum of T(s) for s in a partition of n.\n\n   There is a known combinatorial result: the set of achievable p for n nodes is the set of integers from 0 to T(n) that are congruent to T(n) modulo 1? Not helpful.\n\n   Another idea: use the concept of \"complete sequences\". But perhaps we can use generating functions.\n\n   Alternatively, note that we can use a DP for n from 0 to N (N=632) and for each n, we can compute the set of achievable p by:\n\n        dp[0] = {0}\n        for s from 1 to n:\n            new_dp = copy of dp\n            for each value in dp:\n                new_dp[value + T(s)] = True   # but we are partitioning n, so we need to use exactly n nodes.\n\n   But that is not straightforward.\n\n   Let me reframe: we have n nodes to partition. The partition is a multiset of positive integers (s_i) such that sum_i s_i = n.\n\n   The achievable p is the sum of T(s_i) for the parts.\n\n   We can use a DP that for a given total node count i, we store the set of achievable p's.\n\n   Steps:\n\n        Let dp[i] = set of all p that can be achieved by partitioning i nodes.\n\n        Then, for i from 0 to n_max (say 632):\n            dp[i] = set()\n            if i==0:\n                dp[0] = {0}\n            else:\n                for j from 1 to i:   # j is the size of one component\n                    for each p_val in dp[i-j]:\n                        add p_val + T(j) to dp[i]\n\n        Then, for each n (from 0 to n_max) we can check if p is in dp[n].\n\n        Then the minimal n is the smallest n such that p in dp[n].\n\n   But note: the above DP is O(n^2) for each i, and n goes up to 632, so the total operations would be about sum_{i=1}^{632} i * |dp[i]|. The |dp[i]| can be as large as T(i) (which is about 200000) but note that T(i) is about 200000 only when i is about 632, but for i=632, T(632)=632*631//2 = 199498, so the set dp[i] could have up to 200000 elements for i near 632.\n\n   The total operations would be:\n\n        i from 1 to 632: for each i, we do j from 1 to i, and for each j, we iterate over dp[i-j] and update dp[i].\n\n        The size of dp[i] is the number of distinct p's that can be formed by partitioning i nodes. The maximum p for i nodes is T(i), and the minimum is 0 (if we break into all ones). The distinct p's might be many.\n\n        However, note: the p's are not necessarily contiguous. But the number of distinct p's is at most T(i)+1, which is about 200000 for i=632.\n\n        Then the total operations would be about:\n\n            For i from 1 to 632: \n                for j from 1 to i: \n                    we iterate over dp[i-j] (which has at most T(i-j)+1 elements)\n\n            The total is the sum_{i=1}^{632} i * (max_p for i-j) ??? Actually, we are iterating j from 1 to i, and for each j, we iterate over dp[i-j]. The size of dp[i-j] is at most T(i-j)+1.\n\n        The worst-case i=632, then we iterate j from 1 to 632, and for each j, we look at dp[632-j] which has about T(632-j)+1 elements. The total for i=632 is about 632 * (average size of dp[k] for k from 0 to 631). The average size is roughly the average number of p's for k from 0 to 631.\n\n        The total number of states (p's) for all k is the same as the total distinct p's we can form for all n from 0 to 632. But note: the same p can appear in multiple n.\n\n        However, the total memory and time might be too high.\n\n   Alternative: we can use a different DP: we are only interested in the minimal n for which p is achievable. We can do:\n\n        Let n_min = None\n        We iterate n from 0 to N (N=ceil(sqrt(2*p)) + 10) (about 632+10) and for each n, we compute the set of achievable p's.\n\n        But we are only interested in p (the input) and we want the minimal n such that p is in the set.\n\n        However, we don't know which p to check until the end, but we are given one p.\n\n        We can do:\n\n            We are given p (0<=p<=200000). We want to find the minimal n such that p is in dp[n].\n\n        We can precompute for n from 0 to N (N=632) the set of achievable p's, but storing sets of integers for each n might be heavy.\n\n        Alternatively, we can use a 1D DP for the entire range of p (0 to max_p=200000) and then for each n, mark which p's are achievable.\n\n        Steps:\n\n            Let max_n = 632 (or maybe 633)\n            Let max_p = 200000\n\n            We'll create an array dp[0..max_n] where dp[i] is a boolean array of length max_p+1 (or a set) indicating which p's are achievable for i nodes.\n\n            But then the memory would be 633 * 200000 booleans, which is about 633*200000/8/1024/1024 ~ 150 MB, which is acceptable.\n\n            Alternatively, we can use a 2D DP but that is too heavy.\n\n        But note: we don't need to store all p's for all n. We can do:\n\n            Let dp[i] be a set of p's achievable with i nodes.\n\n            Then we iterate n from 0 to max_n, and for each n, we compute dp[n] from dp[n-1] and the triangular numbers.\n\n        However, we can use a BFS-like:\n\n            We know that a partition of n nodes can be obtained by taking a partition of n-k nodes and adding a component of size k (for k from 1 to n).\n\n            So:\n\n                dp[0] = {0}\n                for n from 1 to max_n:\n                    dp[n] = set()\n                    for k in range(1, n+1):\n                        # k is the size of the last component\n                        # Then the remaining n-k nodes can be partitioned arbitrarily, so we take all p' in dp[n-k] and add T(k) to each.\n                        for p_val in dp[n-k]:\n                            new_p = p_val + T(k)\n                            if new_p <= max_p:   # we only care up to 200000\n                                dp[n].add(new_p)\n\n            Then we look for the minimal n such that p in dp[n].\n\n        But note: the same partition can be done in different orders, but we are covering all partitions.\n\n        However, the set dp[n] might become very large (up to 200000 distinct p's for n near 632). The total memory and time is the sum_{n=0}^{632} (number of distinct p's in dp[n]) and the inner loop runs for k from 1 to n, and for each k, we iterate over dp[n-k] (which has up to 200000 elements). The total operations is about the sum_{n=0}^{632} n * (number of distinct p's in dp[0..n]). \n\n        The total distinct p's in dp[n] is at most T(n)+1, which is about 200000 for n=632.\n\n        Then the total operations is about:\n\n            For n from 1 to 632: we do n * (|dp[0]| + |dp[1]| + ... + |dp[n-1]|)\n\n            The total number of states (p's) for all dp[i] is the same as the total distinct p's for all n from 0 to 632, which is the set of all p's that are the sum of triangular numbers from partitions of n (for n from 0 to 632). \n\n        But note: the same p can appear in multiple n, so the total distinct p's overall is at most 200001 (from 0 to 200000). \n\n        However, the inner loop for n is:\n\n            for k in range(1, n+1):\n                for each p_val in dp[n-k]:\n                    new_p = p_val + T(k)\n\n            The work for n is O(n * |dp[n-k]|) for each k, but note that we are iterating k from 1 to n, so we are combining dp[n-1] (with k=1) and dp[n-2] (with k=2) and so on.\n\n        The total work is the sum_{n=1}^{632} n * (sum_{k=1}^{n} |dp[n-k]|)\n\n        And note that |dp[m]| is the number of distinct p's for m nodes.\n\n        The total distinct p's for all m from 0 to 632 is at most 200001, but the distribution is uneven.\n\n        However, the worst-case for n=632, we are iterating k from 1 to 632, and for each k, we are iterating over dp[632-k] which has about 200000 elements. Then the work for n=632 is 632 * 200000 = 126400000, which is acceptable in C++ but in Python might be borderline (but 632 is the last iteration, and the previous iterations are smaller). The total work is the sum_{n=1}^{632} (n * (total distinct p's for all dp[0] to dp[n-1])). The total distinct p's for all dp[i] is the set of all p's that are <= 200000 and that are the sum of triangular numbers from partitions of some i (0<=i<=632). \n\n        The total distinct p's is at most 200001, but we are storing each p only once per n? Actually, we are storing sets per n, so the same p may appear in multiple n, but we are not storing duplicates across n.\n\n        The total work is:\n\n            Let S(n) = |dp[n]|\n\n            Then the work for n is: sum_{k=1}^{n} S(n-k)\n\n            Then the total work is: sum_{n=0}^{632} [n * (S(0)+S(1)+...+S(n-1))] \n\n        The maximum S(n) is about 200000 (for n=632). The sum_{k=0}^{n-1} S(k) for n=632 is the sum of |dp[k]| for k=0 to 631. Since each dp[k] has at most 200000 elements, and there are 632 sets, the total storage is 632 * 200000 * (size of an integer) which is about 632 * 200000 * 8 / 1e6 = 1011.2 MB, which is too much for Python.\n\n   We need a better way.\n\n   Alternate Insight:\n\n   We are only asked for one p. We don't need to precompute all p's for all n. We can do a BFS/Dijkstra-like: we wish to know the minimal n (and the minimal total nodes) to achieve exactly p mutual pairs.\n\n   We can use a DP that for a given p, we find the minimal n (total nodes) such that p is achievable.\n\n   We can use:\n\n        Let dp[x] = minimal total nodes needed to achieve p=x.\n\n        Then we start from x=0 (n=0) and then we can extend by adding a component of size k (which adds T(k) to x and adds k nodes).\n\n        Then:\n\n            dp[0] = 0\n            Then for x from 0 to p, we can update:\n\n                for k in range(1, ?):   # k is the size of a component, but we don't know the limit.\n\n            But note: we are constrained by the fact that the total p must be exactly the given p.\n\n        Alternatively, we can iterate over the components. Since the components are independent, we can use a knapSack style:\n\n            We wish to minimize the total nodes (the sum of the sizes) given that the sum of T(s_i) is p.\n\n            We can use:\n\n                dp[i] = minimal total nodes to achieve p=i.\n\n                Then, for each triangular number t (t = T(k) for k>=1) and for each i from t to p, we do:\n\n                    dp[i] = min(dp[i], dp[i-t] + k)\n\n            Then the answer for part1 is dp[p].\n\n        But note: we are allowed to use multiple components of the same size. And we are allowed to use any k (any size).\n\n        However, the triangular numbers are not necessarily distinct. But we can use unlimited supply of each triangular number? Actually, yes, because we can have multiple components of the same size.\n\n        But note: the triangular number for k is T(k)=k*(k-1)//2.\n\n        Then, we have a coin change problem where the coins are the triangular numbers (each coin T(k) has weight k) and we wish to minimize the total weight (nodes) to achieve a total value of p.\n\n        However,",
    "response": "\nTo solve this problem, we need to determine the minimum number of nodes required to create a directed graph that is exactly p-reachable. Additionally, among all such graphs with the minimum number of nodes, we need to find the maximum number of unidirectional node pairs.\n\n### Approach\n1. **Problem Analysis**:\n   - A directed graph is p-reachable if it contains exactly p ordered pairs (u, v) where u < v and u and v are mutually reachable.\n   - The mutual reachability between nodes implies they belong to the same strongly connected component (SCC). The number of such pairs in an SCC of size s is given by the triangular number \\( T(s) = s*(s-1)/2 \\).\n   - The problem reduces to representing p as a sum of triangular numbers (each corresponding to an SCC) while minimizing the total number of nodes (sum of the sizes of all SCCs).\n\n2. **Key Insight**:\n   - The minimal number of nodes is found by using the largest possible triangular numbers first, as larger components contribute more pairs per node, thus minimizing the total nodes required.\n   - Once the minimal number of nodes (n) is determined, the maximum number of unidirectional pairs is calculated by considering all possible edges not included in the SCC structure. In a complete directed graph with n nodes, the total possible edges are \\( n*(n-1) \\). The number of edges within SCCs is fixed (since each SCC must be strongly connected), so the remaining edges are the unidirectional pairs.\n\n3. **Algorithm Selection**:\n   - **Dynamic Programming (DP)**: We use a DP approach to find the minimal n such that p can be represented as a sum of triangular numbers. The DP state tracks the minimal nodes required for each possible sum up to p.\n   - **Mathematical Calculation**: For the second part, the maximum unidirectional pairs is derived by subtracting the edges within SCCs from the total possible edges in the graph.\n\n4. **Complexity Analysis**:\n   - The DP approach efficiently computes the minimal n by leveraging the properties of triangular numbers, ensuring optimal performance even for large p (up to 200,000).\n   - The calculation of unidirectional pairs involves simple arithmetic operations, making it efficient.\n\n### Solution Code\n```python\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    p_val = int(data[0])\n    \n    if p_val == 0:\n        print(\"0 0\")\n        return\n        \n    max_tri = 0\n    n = 0\n    dp = [0] * (p_val + 1)\n    for i in range(1, p_val + 1):\n        if i * (i - 1) // 2 <= p_val:\n            max_tri = i * (i - 1) // 2\n            n = i\n        else:\n            break\n\n    dp[0] = 0\n    for i in range(1, p_val + 1):\n        dp[i] = float('inf')\n        \n    for k in range(1, n + 1):\n        t_val = k * (k - 1) // 2\n        if t_val > p_val:\n            continue\n        for j in range(t_val, p_val + 1):\n            if dp[j - t_val] != float('inf'):\n                if dp[j] > dp[j - t_val] + k:\n                    dp[j] = dp[j - t_val] + k\n\n    min_nodes = dp[p_val]\n\n    total_possible_edges = min_nodes * (min_nodes - 1)\n    edges_in_SCCs = 0\n    temp = min_nodes\n    k = 1\n    while temp > 0:\n        t_val = k * (k - 1) // 2\n        if t_val <= temp:\n            edges_in_SCCs += t_val\n            temp -= t_val\n            k += 1\n        else:\n            k += 1\n\n    unidirectional_pairs = total_possible_edges - edges_in_SCCs\n\n    print(f\"{min_nodes} {unidirectional_pairs}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input consists of a single integer p, which is read from standard input.\n2. **Special Case Handling**: If p is 0, the output is \"0 0\" since no nodes are needed and there are no pairs.\n3. **Finding Minimal Nodes**: The code calculates the minimal number of nodes required by checking triangular numbers up to p. It uses dynamic programming to determine the minimal nodes needed to form the sum p using triangular numbers.\n4. **Calculating Unidirectional Pairs**: The total possible edges in a complete directed graph with `min_nodes` nodes is computed. The edges within SCCs are subtracted from this total to find the maximum number of unidirectional pairs.\n5. **Output**: The result is printed as two integers: the minimal number of nodes and the maximum number of unidirectional pairs.\n\nThis approach efficiently addresses both parts of the problem by leveraging mathematical insights and dynamic programming to ensure optimal performance.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    p_val = int(data[0])\n    \n    if p_val == 0:\n        print(\"0 0\")\n        return\n        \n    max_tri = 0\n    n = 0\n    dp = [0] * (p_val + 1)\n    for i in range(1, p_val + 1):\n        if i * (i - 1) // 2 <= p_val:\n            max_tri = i * (i - 1) // 2\n            n = i\n        else:\n            break\n\n    dp[0] = 0\n    for i in range(1, p_val + 1):\n        dp[i] = float('inf')\n        \n    for k in range(1, n + 1):\n        t_val = k * (k - 1) // 2\n        if t_val > p_val:\n            continue\n        for j in range(t_val, p_val + 1):\n            if dp[j - t_val] != float('inf'):\n                if dp[j] > dp[j - t_val] + k:\n                    dp[j] = dp[j - t_val] + k\n\n    min_nodes = dp[p_val]\n\n    total_possible_edges = min_nodes * (min_nodes - 1)\n    edges_in_SCCs = 0\n    temp = min_nodes\n    k = 1\n    while temp > 0:\n        t_val = k * (k - 1) // 2\n        if t_val <= temp:\n            edges_in_SCCs += t_val\n            temp -= t_val\n            k += 1\n        else:\n            k += 1\n\n    unidirectional_pairs = total_possible_edges - edges_in_SCCs\n\n    print(f\"{min_nodes} {unidirectional_pairs}\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 475,
        "completion_token_count": 1096,
        "thoughts_token_count": 8191
    }
}