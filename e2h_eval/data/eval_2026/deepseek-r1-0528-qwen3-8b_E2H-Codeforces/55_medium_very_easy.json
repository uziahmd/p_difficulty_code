{
    "start": 1758308132.5586033,
    "end": 1758311655.1984236,
    "start-formatted": "2025-09-20 03:55 KST",
    "end-formatted": "2025-09-20 04:54 KST",
    "gpu": 2,
    "pid": 55,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Minimum Ternary String\n\nYou are given a ternary string (it is a string which consists only of characters '0', '1' and '2').You can swap any two adjacent (consecutive) characters '0' and '1' (i.e. replace \"01\" with \"10\" or vice versa) or any two adjacent (consecutive) characters '1' and '2' (i.e. replace \"12\" with \"21\" or vice versa).For example, for string \"010210\" we can perform the following moves:   \"010210\" $$$\\rightarrow$$$ \"100210\";  \"010210\" $$$\\rightarrow$$$ \"001210\";  \"010210\" $$$\\rightarrow$$$ \"010120\";  \"010210\" $$$\\rightarrow$$$ \"010201\". Note than you cannot swap \"02\" $$$\\rightarrow$$$ \"20\" and vice versa. You cannot perform any other operations with the given string excluding described above.You task is to obtain the minimum possible (lexicographically) string by using these swaps arbitrary number of times (possibly, zero).String $$$a$$$ is lexicographically less than string $$$b$$$ (if strings $$$a$$$ and $$$b$$$ have the same length) if there exists some position $$$i$$$ ($$$1 \\le i \\le |a|$$$, where $$$|s|$$$ is the length of the string $$$s$$$) such that for every $$$j < i$$$ holds $$$a_j = b_j$$$, and $$$a_i < b_i$$$.\n\n## Input\nThe first line of the input contains the string $$$s$$$ consisting only of characters '0', '1' and '2', its length is between $$$1$$$ and $$$10^5$$$ (inclusive).\n\n## Output\nPrint a single string — the minimum possible (lexicographically) string you can obtain by using the swaps described above arbitrary number of times (possibly, zero).\n\n## Example\n### Input\n['100210', '11222121', '20']\n\n### Output\n['001120', '11112222', '20']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\n We are allowed to swap adjacent '0' and '1', and adjacent '1' and '2'. This means that:\n - '0' can be moved freely to the left (since it can swap with '1' and then if there's a '2' we cannot directly swap, but note: \n   actually, the swaps are only between 0-1 and 1-2. So the relative order of the three digits might not be arbitrary.\n\n However, note that we can use the intermediate '1' to help move a '0' past a '2'? But wait, we cannot swap '0' and '2'. \n Actually, we can think of the operations as allowing us to rearrange the string so that:\n\n - The relative order of the zeros is fixed? Not exactly. Similarly for ones and twos.\n\n But note: we can swap adjacent 0 and 1, and adjacent 1 and 2. Therefore, we can also swap 0 and 2 via a sequence of moves if there is a '1' in between?\n\n However, consider: \n   We cannot swap \"02\" or \"20\". But if we have \"012\", we can do:\n        \"012\" -> swap the '0' and '1': becomes \"102\", then swap the '0' and '2' (but wait, we cannot swap '0' and '2').\n\n Alternatively, from \"012\":\n        swap the '1' and '2': becomes \"021\", then we cannot swap '0' and '2'.\n\n So how do we move a '0' past a '2'? It seems we cannot. Similarly, we cannot move a '2' past a '0'. \n\n Therefore, the relative order of the zeros and the relative order of the twos must be preserved? But what about the ones?\n\n Actually, the key is to note that the allowed swaps are only between 0-1 and 1-2. This forms two independent cycles? \n\n Let's break down the graph of allowed swaps:\n\n We can model the problem as having three types: 0, 1, 2.\n\n The allowed swaps are:\n   Between 0 and 1: so 0 and 1 can be rearranged arbitrarily relative to each other? \n   But note: the swaps are only adjacent and we cannot swap 0 and 2. However, because 1 acts as an intermediary, we can effectively move 0's and 2's independently through the ones.\n\n However, wait: consider two zeros and a two separated by ones. We can move the zeros to the left arbitrarily, and similarly the two's to the right arbitrarily, but without being able to cross over each other.\n\n But note: we can also move ones arbitrarily? Actually, the ones can be used to push zeros to the left and twos to the right. However, the zeros and twos cannot pass each other because they cannot swap.\n\n Therefore, the idea is that the relative order of zeros and twos must remain the same as in the original string. However, the ones can be rearranged arbitrarily with zeros and twos, but note that the entire set of zeros and ones can be rearranged arbitrarily (because we can swap 0-1 any number of times) and similarly the entire set of ones and twos can be rearranged arbitrarily (because we can swap 1-2 any number of times). But wait, what about the zeros and twos? They cannot be rearranged arbitrarily because they cannot swap.\n\n However, note: we can use the ones to separate zeros and twos. Actually, we can think of the following:\n\n Since we can swap 0 and 1 arbitrarily (meaning we can rearrange zeros and ones arbitrarily, as if they form a connected component) and similarly for ones and twos, but zeros and twos are not connected by a swap, the relative order of zeros and twos must be the same as in the original string.\n\n But wait, let me test with a small example:\n\n Original: \"02\" -> cannot be changed. So the relative order of zeros and twos is fixed.\n\n Now, consider \"01\": we can swap to \"10\". So the zeros and ones can be rearranged arbitrarily.\n\n Similarly, \"12\": can become \"21\".\n\n So the entire set of zeros and ones can be arranged in any order (so we can put all zeros to the left and ones to the right, or vice versa) and similarly the entire set of ones and twos can be arranged arbitrarily.\n\n However, when we consider zeros and twos: we cannot swap them directly. But note: if we have zeros, ones, and twos, we can use the ones to separate. Actually, the zeros and twos cannot change their relative order because to swap a zero and a two, we would need to bypass each other without a one? But even with ones, we cannot swap a zero and a two directly. \n\n Let me try with three characters: \"012\"\n\n We can do:\n   Start: \"012\"\n   Swap the middle 1 and 2: \"021\"\n   Then swap the first 0 and 2? -> Not allowed.\n\n Alternatively, start: \"012\"\n   Swap 0 and 1: \"102\"\n   Then swap 0 and 2? -> Not allowed.\n\n So we cannot change the order of zeros and twos. \n\n But wait, what about more than three? Consider \"0112\":\n\n We want to get the minimum lexicographical string.\n\n Lexicographically, we want to push zeros to the front, then ones, then twos? But we cannot put a zero after a two.\n\n Actually, the minimal string should have all zeros as left as possible, then ones, then twos? But note: we cannot change the relative order of zeros and twos. However, we can interleave zeros and ones arbitrarily, and ones and twos arbitrarily.\n\n But the catch: we cannot change the relative order of zeros and twos. So the zeros that originally appear before a two must remain before that two.\n\n Therefore, the minimal string will have:\n\n   All zeros at the beginning? Not necessarily: because we can have ones anywhere. But note, we can also have ones at the beginning. However, since '0' is the smallest, we want to push zeros as far left as possible.\n\n How to solve?\n\n Observation: the operations allow us to independently rearrange:\n\n   - The zeros and ones (they can be arbitrarily rearranged, meaning we can sort the zeros and ones part to be [all zeros][all ones] OR [all ones][all zeros]? Actually, we can do any permutation of zeros and ones? Yes, because adjacent swaps of 0 and 1 allow us to bubble sort zeros to the left and ones to the right, or vice versa.\n\n   - Similarly, the ones and twos can be arbitrarily rearranged.\n\n However, the zeros and twos must preserve their original relative order.\n\n So we can do:\n\n   Step 1: Break the string into zeros, ones, and twos, but preserving the relative order of zeros and twos.\n\n   Then, we can independently:\n\n     - Rearrange the zeros and ones arbitrarily (so we can put all zeros first and then ones, or all ones first and then zeros? But which is lex smaller? \n          Compare: \n            Option A: zeros then ones: \"0\"*a + \"1\"*b\n            Option B: ones then zeros: \"1\"*b + \"0\"*a\n\n        Since '0' < '1', Option A is lex smaller.\n\n     - Similarly, for ones and twos: we can put all ones first and then twos? \n          Option C: ones then twos: \"1\"*b + \"2\"*c\n          Option D: twos then ones: \"2\"*c + \"1\"*b\n\n        But note: we cannot change the relative order of zeros and twos, but the zeros and ones can be arbitrarily rearranged and ones and twos can be arbitrarily rearranged. \n\n   However, we cannot break the relative order of zeros and twos. So the zeros that are originally in the string must appear in the same relative order (with respect to the twos) as in the original.\n\n   But note: we can separate zeros and ones and then separate ones and twos, but we must merge them such that the zeros and twos do not change their relative order.\n\n   Alternate approach: \n\n   We can use the fact that the relative order of zeros and twos is fixed. So the positions of zeros and twos must be the same as in the original (the zeros that were originally at indices i1, i2, ... must appear in the same order in the final string, and similarly for twos). However, the ones can be placed arbitrarily.\n\n   But note: we can also remove ones from between zeros and twos? Actually, we can use the ones to fill gaps arbitrarily, but the zeros and twos must not change their relative order.\n\n   Therefore, the minimal string must have:\n\n     - All zeros as left as possible, but we cannot put a zero after a two (because the relative order of zeros and twos is fixed). So we can only put zeros that originally appeared before a particular two before that two.\n\n   Steps:\n\n   Let's denote:\n     Let A = list of zeros (keeping their original order, but we don't care about the order of zeros among themselves? Actually, no: the zeros can be rearranged arbitrarily with ones, but the relative order of zeros and twos is fixed. However, the zeros themselves can be arbitrarily rearranged? \n\n   Actually, we can rearrange the zeros arbitrarily with the ones. But the zeros and twos must maintain their original relative order. However, we can also rearrange the zeros arbitrarily with the ones, so the zeros can be moved arbitrarily as long as we don't cross a two? \n\n   Actually, we can use the ones to move zeros arbitrarily to the left, but we cannot move a zero to the right of a two that originally was to the left of that zero.\n\n   So the problem reduces to: \n\n   We have three types: 0, 1, 2.\n\n   We can independently:\n\n     - Rearrange the zeros and ones arbitrarily (so we can put all zeros at the beginning, then ones, then the rest? But wait, we cannot put zeros that originally were after a two before a two that originally was before a zero).\n\n   Another way: \n\n   Since we cannot swap zeros and twos, the zeros and twos must appear in the same relative order as in the original. But the ones can be inserted arbitrarily.\n\n   Therefore, we can imagine that the final string is built by:\n\n     - First, we have some zeros (from the original zeros that are available, but we can choose which zeros to put first? Actually, we can rearrange zeros arbitrarily with ones, so we can put all zeros at the beginning? \n\n   But wait: we cannot put a zero that originally was after a two before a two that originally was before a zero. \n\n   Example: Original string \"102\": \n        We have one zero. The two is at the end. We cannot put the zero after the two. In fact, the zero must be before the two. \n\n   But note: the original string is \"102\", and we can swap the 0 and 1 (adjacent) to get \"012\", then we cannot swap the 0 and 2 (because they are not adjacent in the sense of 0-1 or 1-2? Actually, we can use the 1 to help: from \"012\", we can swap the 1 and 2 to get \"021\", but then we cannot swap the 0 and 2. However, in \"012\" we can also leave it as is. The minimal lexicographical string is \"012\".\n\n   Now, what if we have \"210\": \n        We have two ones and a zero. We cannot swap the 2 and 1? Actually, we can swap the 1 and 0? No, because the adjacent pair is '1' and '0' (which is allowed). So from \"210\", we can swap the 1 and 0 to get \"201\", then swap the 2 and 0? -> Not allowed. Or we can swap the 2 and 1 first? Actually, we can swap the '1' and '2' (if they are adjacent). In \"210\", the first two characters are '2' and '1' -> adjacent, so we can swap to \"120\". Then we can swap the 1 and 0? -> \"102\". Then swap 0 and 2? -> not allowed. Or from \"120\", we can swap the 2 and 0? -> not allowed. \n\n   Actually, the allowed swaps are only for adjacent pairs that are either \"01\" or \"12\". In \"210\", the adjacent pairs are \"21\" (allowed) and \"10\" (allowed). So we can do:\n\n        \"210\" -> swap the '2' and '1' (because it's \"21\" -> allowed) -> \"120\"\n        Then in \"120\", we can swap the '2' and '0'? -> not allowed, but we can swap the '1' and '2'? Actually, the adjacent pairs in \"120\" are \"12\" and \"20\". Only \"12\" is allowed, so we can swap the '1' and '2' to get \"210\" again? \n\n   Alternatively, from \"120\", we can also swap the '2' and '0'? -> no, because the swap is only for adjacent pairs of 0-1 or 1-2. \n\n   But wait, the string \"120\": the adjacent pairs are (first two: '1','2') -> allowed (swap to \"210\") and (last two: '2','0') -> not allowed (because we cannot swap 2 and 0). \n\n   So from \"210\", we can only go to \"120\", and then from \"120\" we can only go back to \"210\" or leave it. \n\n   However, note: we can also do:\n\n        \"210\" -> swap the '1' and '0' (the last two characters: '1' and '0') -> \"201\"\n\n        Then from \"201\", we can swap the '2' and '0' (not allowed) or the '0' and '1' (allowed) -> \"210\" again.\n\n   So the minimal lexicographical string for \"210\" is \"120\"? \n\n   But note: \"120\" vs \"201\": \n        \"120\" < \"201\" because '1'<'2'\n\n   However, we can also consider: is there a way to get \"012\" from \"210\"? \n\n        We cannot move the zero to the front because the zero is stuck between a two and a one? \n\n   Actually, we cannot move the zero to the front because to get the zero to the front, we must swap it with the one, but then the two is still behind the one. Then we cannot swap the one and the two (because we just swapped the one and the zero, and now the one is next to the two) so we can swap the one and the two to get \"021\", but then we cannot swap the zero and the two. \n\n   However, from \"210\", we did two swaps to get \"021\": \n        \"210\" -> swap the one and zero (at positions 1 and 2): \"201\"\n        Then swap the two and one? -> but wait, in \"201\", the two is at the front and the one is at the end. The adjacent pairs are (2,0) and (0,1). We can swap the 0 and 1: becomes \"210\", or we can swap the 2 and 0? -> not allowed.\n\n   Alternatively, from \"210\", we first swap the two and one: \"120\", then swap the one and zero (now the one is at the front and the zero is at the end? Wait, in \"120\", the zeros are at the end. We cannot swap the two and zero because they are adjacent? Actually, in \"120\": \n        The two is at index0, then '1' at index1, then '0' at index2. Adjacent pairs: (1,2) and (2,0). The (1,2) is allowed, so we can swap the first two to get \"210\", and the (2,0) is not allowed.\n\n   So we cannot get \"012\". \n\n   Therefore, we must preserve the relative order of zeros and twos. \n\n   How to build the minimal string?\n\n   We know:\n\n     - We can rearrange the zeros and ones arbitrarily (so we can put all zeros at the beginning, then ones, then twos? But wait, we cannot put zeros that originally were after a two before a two that originally was before a zero.\n\n   Actually, we can use a two-pass method:\n\n     We can collect:\n\n        Let the positions of zeros: z0, z1, ... (in increasing order)\n        Let the positions of twos: t0, t1, ... (in increasing order)\n\n     Then the condition: for every i, j: if zi < tj then in the final string, the zero at zi must appear before the two at tj.\n\n   But note: the relative order of zeros and twos must be the same as in the original. So if we look at the original string, the zeros and twos must appear in the same interleaving order as they did originally.\n\n   However, we can remove the ones arbitrarily (by swapping them to the side). \n\n   Another idea: \n\n     We can consider that the final string must be such that:\n\n        - The zeros and ones form a contiguous block? Not necessarily.\n\n   Actually, the problem is similar to having two independent sets: zeros and the set {ones, twos}. But note, we can also swap ones and twos arbitrarily.\n\n   Let me reframe: \n\n     We can do:\n\n        Step 1: Remove all ones (or treat them as movable barriers) and focus on zeros and twos. We must keep the zeros and twos in the original relative order.\n\n        Step 2: We can insert ones arbitrarily. But we also have the freedom to rearrange the ones arbitrarily with zeros and with twos.\n\n        Therefore, the minimal lexicographical string will be:\n\n           We want to put zeros as left as possible, then ones, then twos? But wait, we cannot put a two before a zero if that two originally was after the zero.\n\n        However, we can use the following:\n\n          We can separate the string into three parts:\n\n            Part1: All zeros that originally appeared (we can rearrange zeros arbitrarily with ones, so we can put all zeros at the beginning, but we must not violate the relative order of zeros and twos)\n\n          Actually, we can use the following greedy:\n\n          We can use the fact that the relative order of zeros and twos is fixed. Then, we can do:\n\n            Let X = the original string.\n\n            We can count the frequency of zeros, ones, and twos.\n\n            Then, we can try to build the result by:\n\n              - We know that the zeros that are originally present must appear in the same relative order as they appear in the string, but we can interlace them arbitrarily with ones and zeros from the same set? Actually, we can rearrange zeros arbitrarily with ones, but the zeros and twos must be in the original order.\n\n          Alternate known solution for similar problems (like minimum string with allowed adjacent swaps for two types) is to use the fact that we can independently rearrange two groups.\n\n   Known similar problem: minimum string by swapping adjacent elements of two types (like 0 and 1) but here we have three types and two allowed swaps.\n\n   Insight:\n\n     The allowed swaps mean that:\n\n        - 0 and 1 can be rearranged arbitrarily (so we can put all zeros to the left and ones to the right, or vice versa, but we choose the lex smaller arrangement, which is zeros then ones).\n        - 1 and 2 can be rearranged arbitrarily (so we can put all ones to the left and twos to the right, or vice versa, but we choose the lex smaller arrangement, which is ones then twos).\n\n     However, we have two constraints:\n\n        Constraint 1: The relative order of zeros and twos must be the same as in the original.\n\n        Constraint 2: The ones can be arbitrarily rearranged (so we can use them to fill gaps arbitrarily).\n\n     But note: if we put all zeros first, then ones, then twos, does that satisfy the constraint? \n\n        Example: original string \"012\": \n            We can rearrange zeros and ones: put zeros first then ones -> \"0\" then \"1\", then we have a two. Then we can rearrange ones and twos: put ones first then twos -> so we get \"012\".\n\n        Example: original string \"210\": \n            We want to put zeros first, then ones, then twos. But the original string has one zero and two ones and one two. The constraint says: the relative order of zeros and twos must be the same as in the original. In \"210\", the zero is at the end (after the two). So we cannot put the zero at the very beginning if there is a two that originally was before the zero.\n\n        Therefore, we cannot simply put zeros first.\n\n   How about:\n\n        We can break the string into three segments:\n\n          Segment A: zeros that are originally before the first two.\n          Segment B: zeros that are originally between the first two and the second two, etc.\n\n        But note: we cannot change the order of zeros and twos.\n\n        Actually, we can use the following:\n\n          We know that the zeros and twos must appear in the same relative order. So we can consider the entire string and note that the zeros and twos form a subsequence. The ones can be arbitrarily rearranged (moved to the left or right) as long as we don't break the relative order of zeros and twos.\n\n        Therefore, the minimal string is:\n\n          We want to put as many zeros as possible at the beginning, but we cannot put a zero that originally was after a two (i.e., that comes after a two in the original) until we have put all the zeros that originally were before that two.\n\n        This is reminiscent of the problem of sorting with restricted swaps, or of inversion counting.\n\n   Another known idea: \n\n        We can use a two-pointer approach to place zeros and then ones and then twos, but we must account for the relative order of zeros and twos.\n\n        Specifically, we can:\n\n          - Traverse the string and record the positions of zeros, ones, and twos.\n\n        Then, we can use the following:\n\n          Let n0 = count of zeros, n1 = count of ones, n2 = count of twos.\n\n          We want to form a string of length n0+n1+n2.\n\n          We can decide the positions for zeros, ones, and twos, but:\n\n            Condition: The zeros must appear in the same relative order as in the original, and the twos must appear in the same relative order as in the original.\n\n          So, we can do:\n\n            We know the zeros and twos must appear in the order of their original appearance (but we can interlace with ones arbitrarily).\n\n          Therefore, the minimal lexicographical string will be:\n\n            We want to put as many zeros as possible at the beginning, then as many ones as possible, then as many twos as possible, but we cannot put a two that originally appeared before a zero (which is not allowed because the relative order of zeros and twos must be preserved) — wait, no: the relative order of zeros and twos is the same as the original. So if in the original, a two appears before a zero, then that two must appear before that zero in the final string.\n\n          But note: we can have ones anywhere.\n\n          Algorithm:\n\n            We can use the following:\n\n              Let's define:\n\n                Let A = sorted list of indices where the character is '0'\n                Let B = sorted list of indices where the character is '1'\n                Let C = sorted list of indices where the character is '2'\n\n            Then, the condition for zeros and twos: the relative order of zeros and twos must be the same as in the original. That is, if we look at the original string, the zeros and twos together form a sequence, and we must output that sequence (ignoring ones) in the same order.\n\n            How to incorporate the ones? We can insert ones arbitrarily. To minimize the lex order, we want to put zeros as left as possible, then ones, then twos? But wait: we cannot put a two that originally was before a zero if we put a zero after a two.\n\n            Actually, we can separate the string into two independent sequences: the zeros and twos must appear in the original order, and the ones can be placed arbitrarily.\n\n            Therefore, the minimal string is:\n\n              We will output:\n\n                For each occurrence of a zero or a two, we output the character.\n\n                And we can insert ones arbitrarily (so we can put all ones in the middle, but we must not break the zeros and twos order).\n\n            However, we can also rearrange zeros and ones arbitrarily (so we can put zeros and ones in any order, as long as the zeros and twos are in the original order). Similarly, we can rearrange ones and twos arbitrarily.\n\n            But note: the entire string must be of the same length and we cannot change the counts.\n\n            We can use a greedy algorithm:\n\n              Let's create an array for the final string.\n\n              We know the zeros and twos must appear in the order of the original string. However, we can choose to output a one at any time.\n\n              We want to output the smallest lex string. The smallest character is '0', then '1', then '2'.\n\n              Therefore, we want to output as many zeros as possible at the beginning.\n\n              But we are constrained by the original order of zeros and twos.\n\n              Steps:\n\n                We can use pointers for zeros and twos, and then we know the positions of ones.\n\n                However, note: the zeros and twos must appear in the original order, so we can consider:\n\n                  We are going to traverse the string and decide the next character.\n\n                  We have three possibilities for the next character: if there is a zero that hasn't been placed and that zero is the next in the original order (and there is no two that should come before this zero that hasn't been placed?), but wait, we can also use ones arbitrarily.\n\n                Actually, we can use the following:\n\n                  We know the entire multiset of characters. We can use a state machine that tracks:\n\n                    - How many zeros have been placed (from the original order) and how many twos have been placed (from the original order).\n\n                  But the constraint is: the zeros and twos must appear in the original order. So we must place the zeros and twos in the order of increasing index.\n\n                Alternatively, we can note:\n\n                  The final string must contain:\n\n                    - All the zeros (n0 times) and all the ones (n1 times) and all the twos (n2 times).\n\n                  And the zeros and twos must appear in the same relative order as in the original.\n\n                  Then, we can do:\n\n                    Let D = the original string with all the ones removed. Then D is a sequence of zeros and twos (in the original order). \n\n                    Now, we can insert the ones arbitrarily. The minimal lex string will be:\n\n                      We want to put as many zeros as possible at the beginning, then the ones, then the twos? But wait, we cannot break the order of zeros and twos.\n\n                  Actually, we can break the zeros and twos sequence by inserting ones, but the zeros and twos must appear in the same relative order.\n\n                  Example: original \"210\" -> D = \"20\" (remove the one). Then we have to insert one '1' somewhere. The minimal lex string would be:\n\n                    We can insert the '1' at the beginning: \"120\" -> but then the zeros and twos order is broken? In the original, the zero is after the two. In \"120\", the two is first and then the zero, which is the same as the original. So that's okay.\n\n                    Now, compare \"120\" and \"201\": \n\n                      \"120\": first char '1' -> not zero, but wait, we want to put zeros as left as possible. \n\n                    However, we cannot put a zero at the beginning because the two must come before the zero. But we can put a one at the beginning? \n\n                    But note: we can also use the freedom to rearrange zeros and ones arbitrarily (as long as the relative order of zeros and twos is preserved). \n\n                    Actually, we can use the ones to push zeros to the left only if the zeros are originally before the two. In the original \"210\", the zero is after the two, so we cannot push it to the front.\n\n                  Therefore, the minimal string is built by:\n\n                    We know the entire multiset of characters. We can use three independent queues for zeros, ones, and twos, but we must output the zeros and twos in the original order (with the ones inserted arbitrarily).\n\n                  Then, the minimal lex string is:\n\n                    We can use a greedy:\n\n                      We have three pointers for zeros, ones, and twos.\n\n                      We also have the original order of zeros and twos. We know the positions.\n\n                    Alternatively, we can use:\n\n                      Let's define:\n\n                        Let Z = sorted list of indices for zeros.\n                        Let O = sorted list of indices for ones.\n                        Let T = sorted list of indices for twos.\n\n                      Then, we can simulate:\n\n                        We'll create an array for the final string.\n\n                        We know that the zeros and twos must appear in increasing order of their original indices.\n\n                        We can do:\n\n                          Let i0 = 0, iT = 0 (pointers for zeros and twos)\n                          Let o = 0 (pointer for ones)\n\n                          Then, we consider:\n\n                            We have three choices for the next character:\n\n                              - If there is a zero that is the next in the original order (i0 < len(Z)) and that zero is the smallest index among the remaining zeros and twos, then we can output '0'. But wait, we cannot output a zero if there is a two that originally appeared earlier (i.e., has a smaller index) and that two hasn't been output yet? \n\n                            Actually, the constraint is the relative order of zeros and twos must be the same as the original. So if we haven't output a two that originally appeared before a zero, we cannot output that zero.\n\n                            Therefore, we must output the zeros and twos in the order of increasing index (i.e., the order they appear in the original string).\n\n                            Then, we can interlace with ones arbitrarily.\n\n                          So the idea:\n\n                            We are going to output the entire string by processing events in increasing index order (from left to right). But we have three types.\n\n                            However, we can delay outputting a character until we are forced to? \n\n                    Actually, we can use a different approach:\n\n                      Since we can arbitrarily rearrange zeros and ones (without affecting the zeros-twos order), we can consider that the zeros and ones together form a block that can be rearranged arbitrarily (so we can put all zeros at the beginning of this block, then ones). Similarly, the ones and twos together form a block that can be rearranged arbitrarily (so we can put all ones then twos). But the catch is that the zeros and twos must be in the original order.\n\n                    How to combine?\n\n                      We can do:\n\n                        Step 1: Extract the subsequence of zeros and twos (call it S) from the original string.\n\n                        Step 2: We can insert the ones arbitrarily. \n\n                        Step 3: We want to form a string that is the minimum lex, and we know that the subsequence S must appear in order.\n\n                        This is similar to the problem of inserting characters arbitrarily (the ones) into S to form the minimal lex string.\n\n                        Since we can put zeros and ones arbitrarily (without breaking S), the minimal lex string is:\n\n                          We can put all zeros (from S) at the beginning, then all ones, then all twos (from S)? \n\n                        But wait: the subsequence S is the original order of zeros and twos. If we put all zeros at the beginning, then all ones, then all twos, then we are essentially creating a new string where the zeros and twos are contiguous (with zeros first and then twos) and the ones are in the middle. However, this might break the original order of zeros and twos? \n\n                        Example: original string \"102\" -> S = ['0','2'] (the zeros and twos in order). Then putting zeros first: \"0\", then insert the one? But the one is from the original and must be inserted arbitrarily. Then we put the two. So we get \"012\", which is correct.\n\n                        Example: original string \"210\" -> S = ['2','0'] (the zeros and twos in order). Then putting zeros first: but the zeros in S are only one, and the two is first. So we cannot put zeros first because the two must come before the zero. \n\n                        Therefore, we cannot simply put zeros first.\n\n                    We must output the zeros and twos in the order given by S. And we can insert ones arbitrarily.\n\n                    So the minimal lex string is:\n\n                      We iterate over the positions from 0 to n-1, and at each position, we decide which character to put.\n\n                      We have a multiset of characters (zeros, ones, twos) and a fixed order for zeros and twos (S).\n\n                      We can use a priority queue for the available characters, but the available characters are constrained by S.\n\n                    Alternatively, we can do:\n\n                      We know the positions of zeros and twos. Let S be the concatenation of zeros and twos in the order of appearance.\n\n                      Then, we can also note that the ones can be placed arbitrarily.\n\n                      The minimal lex string is obtained by:\n\n                         We want to put the smallest available character at the front, provided that we do not break the condition that the zeros and twos must appear in the order S.\n\n                      How to ensure we don't break the condition?\n\n                         We must have the zeros and twos appear in the order S. This means that if we output a character that is not a zero or a two, then we are not affecting the order. But if we output a zero or a two, then we are advancing the corresponding pointer.\n\n                      We can use three pointers: for zeros, for ones, and for twos.\n\n                      But we also have the constraint that the zeros and twos must be in the original order.\n\n                      Actually, we can use:\n\n                         Let i0, iT be pointers for the next available zero and two in the original order (for zeros and twos).\n\n                         And we have a multiset for ones.\n\n                      Then, the condition for outputting a zero is that we haven't output all zeros and that the next zero in the original order (the smallest index zero not yet output) is available. But also, we must not output a two that appears before this zero if it hasn't been output.\n\n                      However, note: the original order is defined by the indices. We are allowed to output ones arbitrarily, so we can postpone outputting a two that is before a zero if we want to output the zero first? \n\n                      But wait, if a two has a smaller index than a zero, then in the original string the two comes before the zero. Therefore, the two must appear before the zero in the final string.\n\n                      Therefore, we cannot output a zero before outputting the two that originally appeared before it.\n\n                      So the rule:\n\n                         We can output a character if:\n\n                           - It is a one: always available (unless we've used them all) and outputting it doesn't break any condition.\n                           - It is a zero: only if there is no two that originally appeared before this zero and hasn't been output yet? Actually, no: we must output all characters that originally appeared before this zero (both zeros and twos) before we output this zero.\n\n                      But note: we can output ones arbitrarily, so the condition is solely based on the zeros and twos.\n\n                      Specifically, we must output the zeros and twos in increasing order of their original indices.\n\n                      Therefore, the available characters are:\n\n                         - All ones (we can output any number of ones at any time)\n                         - A zero, if the next zero in the original order is available (i.e., we haven't output a zero with a smaller index) and also we have output all the twos that have indices smaller than this zero's index.\n\n                      Similarly, a two is available only if we have output all the zeros and twos that have smaller indices.\n\n                      But note: the original order is by index. So we can simply sort the zeros and twos by index, and then we can output a zero only if there is no two with a smaller index that remains unoutput.\n\n                      However, we can output ones arbitrarily, so the condition for a zero is: the next zero (in the sorted order by index) must be the next event (either a zero or a two) in the combined zeros and twos sequence.\n\n                      We can do:\n\n                         Let events = sorted list of (index, char) for zeros and twos.\n\n                         Then, we also have the ones separately.\n\n                      Then, the minimal lex string is built by:\n\n                         We'll have a pointer for the events (for zeros and twos). We start at the smallest index.\n\n                         Then, at each step, we can choose to output:\n\n                            - A one (if available) -> '1' is the next smallest character? But",
    "response": "\nTo solve this problem, we need to find the lexicographically smallest string that can be obtained by performing any number of adjacent swaps between '0' and '1', or between '1' and '2'. The key observation here is that while '0's and '1's can be rearranged freely among themselves, and '1's and '2's can be rearranged freely among themselves, the relative order of '0's and '2's must remain the same as in the original string.\n\n### Approach\n1. **Problem Analysis**: The allowed swaps mean that '0's and '1's can be moved past each other, and '1's and '2's can be moved past each other. However, '0's and '2's cannot be swapped directly. Therefore, the relative order of '0's and '2's in the final string must match their relative order in the original string.\n2. **Insight**: The solution involves three main parts:\n   - **Zeros and Twos Handling**: The '0's and '2's must appear in the same relative order as in the original string. This means if a '0' appears before a '2' in the original string, it must also appear before that '2' in the final string.\n   - **Ones Insertion**: '1's can be placed anywhere in the string without affecting the relative order of '0's and '2's. To achieve the lexicographically smallest string, we should place '0's as early as possible, followed by '1's, and then '2's, while respecting the relative order of '0's and '2's.\n3. **Algorithm**:\n   - **Extract Positions**: Identify the positions of all '0's, '1's, and '2's in the original string.\n   - **Sort Indices**: Sort the indices of '0's and '2's to maintain their relative order.\n   - **Construct Result**: Build the result string by first placing all '0's (if they are the earliest possible), then '1's, and finally '2's, ensuring the relative order of '0's and '2's is preserved.\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    s = sys.stdin.readline().strip()\n    n = len(s)\n    \n    zeros = []\n    ones = []\n    twos = []\n    \n    for i, char in enumerate(s):\n        if char == '0':\n            zeros.append(i)\n        elif char == '1':\n            ones.append(i)\n        else:\n            twos.append(i)\n            \n    zeros_twos = sorted(zeros + twos)\n    result = []\n    index = 0\n    \n    for pos in range(n):\n        if index < len(zeros_twos) and pos == zeros_twos[index]:\n            if s[pos] == '0':\n                result.append('0')\n                index += 1\n            else:\n                result.append('2')\n                index += 1\n        else:\n            result.append('1')\n                \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input string is read from standard input.\n2. **Categorizing Characters**: The code categorizes each character in the string into '0's, '1's, or '2's and records their positions.\n3. **Sorting Combined Indices**: The positions of '0's and '2's are combined and sorted to maintain their relative order from the original string.\n4. **Building Result String**: The result string is constructed by iterating through each position in the original string. If the current position is part of the sorted '0's or '2's list, the corresponding character is added to the result. Otherwise, a '1' is added. This ensures that '0's appear as early as possible, '1's follow, and '2's come last, while preserving the relative order of '0's and '2's.\n5. **Output**: The constructed result string is printed, which is the lexicographically smallest string achievable under the given constraints.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    s = sys.stdin.readline().strip()\n    n = len(s)\n    \n    zeros = []\n    ones = []\n    twos = []\n    \n    for i, char in enumerate(s):\n        if char == '0':\n            zeros.append(i)\n        elif char == '1':\n            ones.append(i)\n        else:\n            twos.append(i)\n            \n    zeros_twos = sorted(zeros + twos)\n    result = []\n    index = 0\n    \n    for pos in range(n):\n        if index < len(zeros_twos) and pos == zeros_twos[index]:\n            if s[pos] == '0':\n                result.append('0')\n                index += 1\n            else:\n                result.append('2')\n                index += 1\n        else:\n            result.append('1')\n                \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 589,
        "completion_token_count": 856,
        "thoughts_token_count": 8191
    }
}