{
    "start": 1758299497.7580214,
    "end": 1758303242.264035,
    "start-formatted": "2025-09-20 01:31 KST",
    "end-formatted": "2025-09-20 02:34 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\n Okay, let's break down the problem.\n\nWe are to find:\n1. The minimum number of edges `t` that must be added to form a simple cycle of odd length (at least 3 vertices).\n2. The number of ways `w` (without adding parallel edges or loops) to add exactly `t` edges to achieve such a cycle.\n\nNote: The graph is undirected and without parallel edges or loops.\n\nObservations:\n\nCase 1: If the graph already contains an odd cycle, then t=0 and w=1? But note: we are only allowed to add edges, so if the graph already has an odd cycle, then we don't need to add any edge. However, note the problem says \"form a cycle\", meaning we can use existing edges and the condition is that after adding t edges (which might be zero) we have a cycle. So if the graph already has an odd cycle, then t=0 and w=1.\n\nBut wait: the problem says \"the minimum number of edges that must be added\". So if there is already an odd cycle, we don't need to add any edge. However, note that the graph might not necessarily be connected, and the odd cycle might be in one connected component.\n\nHowever, what if the graph has no odd cycle? Then we must consider adding edges until we form one.\n\nWhat are the possibilities?\n\nPossibility 1: Add one edge to form an odd cycle.\n\nCan we form an odd cycle by adding one edge?\nConsider: An odd cycle requires an odd-length cycle (like triangle, pentagon, etc). \n\nIn the original graph, we might have two even cycles or other structures. However, note that adding one edge can complete a triangle (if two edges are missing in a triangle) but wait, we are given an existing graph. We cannot assume which edges are missing.\n\nActually, note: if we add one edge, then the cycle formed by that edge must be of odd length. This means that the edge must be part of an odd cycle. How?\n\nLet the new edge be (u, v). Then, if there is already a path from u to v of even length (so that the total cycle length = even_length + 1 is odd), then adding (u, v) will form an odd cycle.\n\nBut note: the entire graph might not be connected, so we have to consider the connected components.\n\nAlternatively, we can think about the bipartiteness of the graph.\n\nImportant fact: A graph is bipartite if and only if it does not contain an odd cycle.\n\nSo, if the graph is not bipartite, then it already contains an odd cycle, so we output t=0 and w=1.\n\nBut wait, the problem says: \"It is prohibited to add loops or parallel edges.\" and we are to find the minimum number of edges to add to form a simple cycle of odd length. However, if the graph already has one, then we don't need to add any.\n\nNow, if the graph is bipartite, then we need to form an odd cycle by adding edges.\n\nHow many edges do we need to add to form an odd cycle?\n\nWe can consider:\n\n- Adding one edge: This would form an odd cycle if there exists a pair of vertices (u, v) such that the distance between u and v in the graph is even (so that the cycle length = even_distance + 1 is odd). However, note that the graph might have multiple connected components. Also, note that we are allowed to add edges only between non-adjacent pairs (no parallel edges or loops).\n\nBut wait: what if we are in a connected bipartite graph? Then we can check for each edge (u, v) that is not present: if we add (u, v) and the distance from u to v is even, then we get an odd cycle. However, we are looking for the minimum number of edges to add.\n\nPossibility 1: t=1.\n\nBut note: we might also form an odd cycle by adding more than one edge? However, we want the minimum.\n\nBut is t=1 always possible when the graph is bipartite? Not necessarily.\n\nConsider: In a bipartite graph, we can color the graph with two colors. Then, an edge between two nodes of the same color would create an odd cycle (because the path from one node to the other in the bipartite graph is through the other color, so the length is even, then adding the edge makes the cycle odd). \n\nHowever, we cannot add an edge between two nodes that are already adjacent (since no parallel edges). But note: the graph is simple, so if two nodes are adjacent, we cannot add that edge again. So we are only allowed to add edges that are not present.\n\nBut wait: what if the graph is disconnected? Then, we can also consider edges between different connected components. However, if we connect two",
    "response": "\nTo solve this problem, we need to determine the minimum number of edges `t` that must be added to an undirected graph to form a simple cycle of odd length, and the number of ways `w` to add those edges. The solution involves analyzing the graph's bipartiteness and leveraging properties of bipartite graphs to find the required cycles.\n\n### Approach\n1. **Check for Existing Odd Cycle**: If the graph is not bipartite, it already contains an odd cycle. In this case, no edges need to be added (`t = 0`), and there is exactly one way to achieve this (`w = 1`).\n\n2. **Bipartite Graph Handling**: If the graph is bipartite, we need to find the smallest number of edges to add to create an odd cycle. The key observation here is that adding an edge between two vertices in the same partition (color) of a bipartite graph will create an odd cycle if such an edge does not already exist.\n\n3. **Minimum Edges Calculation**: \n   - **Case 1 (t = 1)**: If there are at least two vertices in the same partition (color) that are not connected by an edge, adding one edge between them will form an odd cycle. The number of such edges is the count of non-edges between vertices of the same color.\n   - **Case 2 (t > 1)**: If no such edges exist (i.e., all vertices in the same partition are already fully connected), then we need to consider adding edges within a connected component or between components. However, the minimal number of edges required in this scenario is higher (at least 3), but our initial check for `t = 1` would have been satisfied if possible.\n\n4. **Disconnected Graphs**: For disconnected bipartite graphs, edges can be added between vertices in different components. However, the minimal solution still prioritizes edges within the same partition (if they exist) due to the odd cycle property.\n\n### Solution Code\n```python\nimport sys\nfrom collections import deque\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"0 0\")\n        return\n        \n    n = int(data[0])\n    m = int(data[1])\n    edges = []\n    index = 2\n    graph = [[] for _ in range(n+1)]\n    for i in range(m):\n        u = int(data[index]); v = int(data[index+1]); index += 2\n        edges.append((u, v))\n        graph[u].append(v)\n        graph[v].append(u)\n        \n    visited = [False] * (n+1)\n    color = [-1] * (n+1)\n    is_bipartite = True\n    components = []\n\n    for i in range(1, n+1):\n        if not visited[i]:\n            q = deque([i])\n            visited[i] = True\n            color[i] = 0\n            comp_nodes = [i]\n            while q:\n                node = q.popleft()\n                for neighbor in graph[node]:\n                    if not visited[neighbor]:\n                        visited[neighbor] = True\n                        color[neighbor] = color[node] ^ 1\n                        comp_nodes.append(neighbor)\n                        q.append(neighbor)\n                    else:\n                        if color[neighbor] == color[node]:\n                            is_bipartite = False\n            components.append(comp_nodes)\n            \n    if not is_bipartite:\n        print(\"0 1\")\n        return\n        \n    total_edges_to_add = 0\n    total_ways = 0\n    \n    for comp in components:\n        c0 = 0\n        c1 = 0\n        for node in comp:\n            if color[node] == 0:\n                c0 += 1\n            else:\n                c1 += 1\n                \n        total_edges_in_comp = (len(comp) * (len(comp)-1)) // 2\n        existing_edges = 0\n        for node in comp:\n            existing_edges += len(graph[node])\n        existing_edges //= 2\n        \n        missing_edges = total_edges_in_comp - existing_edges\n        \n        if c0 * c1 <= missing_edges:\n            t_val = 1\n            ways_in_comp = c0 * c1 - missing_edges\n            total_ways += ways_in_comp\n        else:\n            t_val = 2\n            ways_in_comp = (c0 * (c0-1))//2 + (c1 * (c1-1))//2\n            total_ways += ways_in_comp\n            \n    if total_ways > 0:\n        print(f\"1 {total_ways}\")\n    else:\n        print(f\"2 0\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Graph Input Handling**: The input is read and parsed into a graph structure using adjacency lists.\n2. **Bipartite Check**: Using BFS, each connected component is checked for bipartiteness. If any component is not bipartite, the graph contains an odd cycle, so `t = 0` and `w = 1`.\n3. **Component Analysis**: For each bipartite component, vertices are divided into two partitions (colors). The number of missing edges between vertices of the same color is calculated.\n4. **Edge Addition Logic**: \n   - If there are missing edges between same-colored vertices, adding one such edge creates an odd cycle. The number of such edges (`ways_in_comp`) is counted.\n   - If no such edges exist, edges within the same partition (but not present) are considered, requiring two edges to form a cycle, though the minimal solution is prioritized as `t = 1` whenever possible.\n5. **Output**: Based on the analysis, the solution outputs the minimal number of edges `t` and the number of ways `w` to add them, ensuring the graph forms an odd cycle.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"0 0\")\n        return\n        \n    n = int(data[0])\n    m = int(data[1])\n    edges = []\n    index = 2\n    graph = [[] for _ in range(n+1)]\n    for i in range(m):\n        u = int(data[index]); v = int(data[index+1]); index += 2\n        edges.append((u, v))\n        graph[u].append(v)\n        graph[v].append(u)\n        \n    visited = [False] * (n+1)\n    color = [-1] * (n+1)\n    is_bipartite = True\n    components = []\n\n    for i in range(1, n+1):\n        if not visited[i]:\n            q = deque([i])\n            visited[i] = True\n            color[i] = 0\n            comp_nodes = [i]\n            while q:\n                node = q.popleft()\n                for neighbor in graph[node]:\n                    if not visited[neighbor]:\n                        visited[neighbor] = True\n                        color[neighbor] = color[node] ^ 1\n                        comp_nodes.append(neighbor)\n                        q.append(neighbor)\n                    else:\n                        if color[neighbor] == color[node]:\n                            is_bipartite = False\n            components.append(comp_nodes)\n            \n    if not is_bipartite:\n        print(\"0 1\")\n        return\n        \n    total_edges_to_add = 0\n    total_ways = 0\n    \n    for comp in components:\n        c0 = 0\n        c1 = 0\n        for node in comp:\n            if color[node] == 0:\n                c0 += 1\n            else:\n                c1 += 1\n                \n        total_edges_in_comp = (len(comp) * (len(comp)-1)) // 2\n        existing_edges = 0\n        for node in comp:\n            existing_edges += len(graph[node])\n        existing_edges //= 2\n        \n        missing_edges = total_edges_in_comp - existing_edges\n        \n        if c0 * c1 <= missing_edges:\n            t_val = 1\n            ways_in_comp = c0 * c1 - missing_edges\n            total_ways += ways_in_comp\n        else:\n            t_val = 2\n            ways_in_comp = (c0 * (c0-1))//2 + (c1 * (c1-1))//2\n            total_ways += ways_in_comp\n            \n    if total_ways > 0:\n        print(f\"1 {total_ways}\")\n    else:\n        print(f\"2 0\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 573,
        "completion_token_count": 1246,
        "thoughts_token_count": 1023
    }
}