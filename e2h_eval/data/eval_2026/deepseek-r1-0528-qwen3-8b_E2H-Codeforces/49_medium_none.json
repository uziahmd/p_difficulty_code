{
    "start": 1758303963.3805716,
    "end": 1758307830.1744013,
    "start-formatted": "2025-09-20 02:46 KST",
    "end-formatted": "2025-09-20 03:50 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\n Okay, we are given a graph with n nodes and m edges. For each edge (u, v), we are given two numbers: gcd and lcm.\n We know that for two numbers a and b (the mushrooms on the two lawns), we have:\n   gcd(a, b) = g, and lcm(a, b) = l, and also we have the relation: a * b = g * l.\n\n However, note that from the definitions, we also have:\n   g divides a and g divides b, and a divides l and b divides l.\n\n But there is more: the prime factorization of a and b must be such that for every prime p:\n   Let exponent in g be x, in l be y. Then the exponents in a and b must be between [x, y] and they must add up to y (because the LCM takes the maximum exponent and the product has exponents adding up to y? Actually, wait: the product a*b is g*l, so for each prime, the exponents in a and b must add to (exponent in g) + (exponent in l) ??? \n\n But wait, let's recall:\n   If a = ∏ p_i^α_i, b = ∏ p_i^β_i, then:\n     gcd(a,b) = ∏ p_i^min(α_i, β_i) = g\n     lcm(a,b) = ∏ p_i^max(α_i, β_i) = l\n\n Then the product a*b = ∏ p_i^(α_i+β_i). Also, note that the exponents for each prime p_i in g and l are:\n   g: exponent = min(α_i, β_i)\n   l: exponent = max(α_i, β_i)\n\n And we have: min(α_i, β_i) + max(α_i, β_i) = α_i + β_i? \n Actually, no: if we let m = min(α_i, β_i) and M = max(α_i, β_i), then α_i+β_i = m + M.\n\n But note: the product a*b has exponent (α_i+β_i) = m + M. However, we also have that g*l has for the same prime exponent: min(α_i, β_i) + max(α_i, β_i) = m + M. So indeed a*b = g*l.\n\n Therefore, the condition for an edge (u, v) is that the product of the two numbers (a_u * a_v) must equal g*l, and also the gcd must be g.\n\n However, note: the problem does not require the entire graph to be connected necessarily. But the input says there are m roads (edges) and n lawns.\n\n Steps:\n\n 1. We are going to model the graph with n nodes and m edges, each edge having (g, l). Also note that from the problem, the original numbers were at least 1 and at most 10^6.\n\n 2. Conditions for an edge (u, v) with given g and l:\n    - The gcd(a_u, a_v) must be g, and the lcm(a_u, a_v) must be l.\n    - This implies that both a_u and a_v must be multiples of g, and both must divide l (if the gcd is g, then the numbers are multiples of g, and the lcm being l means that the numbers divide l only if we consider the entire set? Actually, note: the lcm is the smallest number that is divisible by both, but the numbers themselves don't necessarily divide l? Wait, no: because the lcm is the multiple of the two, but the numbers can be any divisors of the lcm? Actually, no: the numbers are divisors of the lcm? Not necessarily. However, we do know that the numbers must divide the lcm? Let me check:\n\n        We have: a_u divides a_u * a_v / g. But note: a_u * a_v = g * l. So a_u divides g*l. Similarly, a_v divides g*l. However, the lcm is l, which is the minimal common multiple, so the numbers must divide l? Actually, no: consider a_u=4, a_v=6, then g=2, l=12. Then 4 and 6 divide 12? Yes. In fact, it is a known property that if you have two numbers a and b, then a divides (a*b)/gcd(a,b) and b divides (a*b)/gcd(a,b). Since (a*b)/gcd(a,b)=lcm(a,b)=l, then yes, both a and b divide l.\n\n    So conditions for an edge (u, v):\n        Condition 1: g divides a_u and a_v, and a_u * a_v = g * l.\n        Condition 2: gcd(a_u, a_v) == g.\n\n    Alternatively, we can express a_u and a_v as:\n        a_u = g * x, a_v = g * y, then we require that:\n            gcd(x, y) = 1, and the lcm(g*x, g*y) = g * lcm(x,y) = g * (x*y) (because gcd(x,y)=1) must equal l.\n        So then: x*y = l // g, and gcd(x,y)=1.\n\n    So the two numbers for the edge must be two divisors d1 and d2 of (l//g) such that d1*d2 = l//g and gcd(d1,d2)=1.\n\n 3. However, note that the entire graph must be consistent. We have multiple edges and we need to assign a number to each node.\n\n 4. Approach:\n\n    We can use the following idea:\n\n    Let A[i] be the number of mushrooms on lawn i.\n\n    For an edge (u, v) with (g, l):\n        Condition 1: A[u] * A[v] = g * l.\n        Condition 2: gcd(A[u], A[v]) = g.\n\n    But note: from condition 1 and condition 2, we can derive that A[u] must be a divisor of g*l, and similarly for A[v]. Moreover, from condition 2, we have that g divides both A[u] and A[v]. Therefore, we can write:\n\n        A[u] = g * a, A[v] = g * b, and then a and b must be coprime and a*b = (l // g).\n\n    However, note: we must have l % g == 0, otherwise the edge is invalid.\n\n    Steps:\n\n        Step 1: For each edge, check that l % g == 0. If not, output \"NO\".\n\n        Step 2: Then, for each edge, we know that the two numbers must be factors of (l//g) that are coprime and their product is (l//g). But note: there might be multiple ways to factor (l//g) into two coprime factors. However, the assignment must be consistent across the entire graph.\n\n    Alternatively, we can think in terms of prime factorization. The entire graph must satisfy:\n\n        For each node i, let A[i] be represented by its prime factors. Then for an edge (u, v) with (g, l):\n\n            The exponents for each prime in A[u] and A[v] must be such that:\n                min(exponent in A[u], exponent in A[v]) = exponent in g for that prime.\n                max(exponent in A[u], exponent in A[v]) = exponent in l for that prime.\n\n        But note: the same node must have the same prime factors in all edges incident to it.\n\n    However, we can also use a different approach: assign a value to each node by considering the constraints from the edges.\n\n    Observation:\n\n        Since for each edge (u, v): \n            A[u] * A[v] = g * l   (condition 1)\n\n        Then, if we fix one node, say node 0, then we can propagate the values through the graph. But note: the graph might be disconnected.\n\n    But wait, the problem does not require the entire graph to be connected. So we must consider each connected component separately.\n\n    However, we also have the gcd condition. So even if the product condition is satisfied, the gcd condition must hold.\n\n    Alternatively, we can use the following:\n\n        We know that for each edge (u, v): \n            A[u] must be a divisor of g*l, and similarly for A[v]. Moreover, the ratio (A[u] / g) must be an integer and coprime with (A[v] / g) and (A[u] * A[v]) = g*l.\n\n        But note: from the product condition, A[u] = (g * (some divisor d)) and A[v] = (g * (l/(g*d))) and we require that gcd(d, l/(g*d)) = 1.\n\n    How to assign?\n\n        Idea: set up equations for each node. Since the product condition must hold for every edge, the entire graph's nodes must satisfy that the product of two adjacent nodes is fixed (g*l for that edge). \n\n        Then, if we take the logarithm, we could turn products into sums, but we are dealing with integers and gcd conditions.\n\n    Another idea: \n\n        Let’s denote for each node i, let B[i] = A[i] / g0, where g0 is the gcd of the entire component? But wait, we don't know the global gcd.\n\n    Actually, we can use the following:\n\n        From the product condition, the product of two adjacent nodes is fixed. Therefore, if we fix one node's value, then the adjacent ones are determined (up to a factor). However, we have multiple edges and the gcd condition must hold.\n\n    Steps for solving:\n\n        Step 1: Check for each edge (u, v): \n            - l % g == 0. If not, output \"NO\".\n            - Then, let k = l // g. Then the two numbers for the edge must be two divisors of k (since A[u] and A[v] are multiples of g, and their product is g*k, so A[u] = g * d1 and A[v] = g * d2, and d1*d2 = k).\n\n        But note: the gcd condition: gcd(A[u], A[v]) = g. This is equivalent to gcd(d1, d2) = 1.\n\n        Now, for the entire graph, we have to assign to each node a value (which is a multiple of g0, the base gcd) but note: the base gcd for the entire graph might vary per connected component? Actually, the gcd condition for an edge is specific to that edge.\n\n    However, we can use the following:\n\n        We can consider that the value of each node must be a divisor of the product of some k's (from edges) and also a multiple of the gcd from edges.\n\n    Alternate Insight:\n\n        Notice that the entire graph must be such that for each edge (u, v) with (g, l), the two numbers must be of the form (g * a) and (g * b) with a*b = (l//g) and gcd(a,b)=1.\n\n        Moreover, if two edges share a node, then the value assigned to the shared node must be consistent.\n\n    How about:\n\n        We can assign to each node a value that is the product of primes raised to certain exponents, but we don't know the primes. However, note the constraints: the numbers are at most 10^6.\n\n    Another idea: use the fact that the product condition and the gcd condition must hold simultaneously. We can set up a system of equations in terms of ratios.\n\n    However, note: we are allowed to output any arrangement.\n\n    Let me try a simpler idea:\n\n        Since for each edge (u, v) we have A[u] * A[v] = C (a constant for the edge), we can set:\n\n            Let A[0] = some value x0. Then for any node u connected to the starting node, we can compute A[u] = (edge_constant from 0->u) / x0, but then we must have integer and satisfying the gcd condition.\n\n        But wait: the edge_constant is the product, so if we start with node0 having value x, then node1 (connected to node0) must have value (g1 * l1) / x. Then for node2 connected to node1, we get (g2 * l2) / ( (g1*l1)/x ) = (g2*l2 * x) / (g1*l1). Then we must have that this is an integer and satisfies the gcd condition with the edges.\n\n        However, we don't know the base x. We can choose x arbitrarily? But note: the gcd conditions must hold. \n\n        Alternatively, we can set the entire graph by fixing a spanning tree and then checking the remaining edges.\n\n    Steps:\n\n        Step 1: Precompute for each edge (u, v) the value k = l // g (if l % g != 0, then invalid). Then, we know that the two numbers for the edge must be g * d1 and g * d2, with d1*d2 = k and gcd(d1,d2)==1.\n\n        Step 2: We can assign to each node a value by picking one node as root and then propagating. But we have to ensure consistency.\n\n        However, note: the graph is undirected and the product condition is symmetric. But the gcd condition is also symmetric.\n\n        Step 3: We can use union-find or DFS/BFS to traverse the graph.\n\n        But how to assign the base values?\n\n        Idea: For each connected component, we can assign the first node an arbitrary value that is a divisor of the product of the constants of the edges? But note: the product condition must hold for every edge.\n\n        Alternatively, note that the entire product of the two numbers in an edge is fixed. Therefore, if we fix the value of one node, then the values of the adjacent nodes are fixed (by division). However, we must ensure that the value assigned is an integer and satisfies the gcd condition.\n\n        But wait: the gcd condition is local to each edge. However, if we assign by propagation, then the same node might be reached by two different paths and we must check consistency.\n\n        Example: \n            Component: three nodes: 0-1-2.\n            Edge0: (0,1): (g0, l0) -> then A0 * A1 = g0*l0.\n            Edge1: (1,2): (g1, l1) -> then A1 * A2 = g1*l1.\n            Edge2: (0,2): (g2, l2) -> then A0 * A2 = g2*l2.\n\n            From 0 to 1: A1 = (g0*l0) / A0.\n            Then from 1 to 2: A2 = (g1*l1) / A1 = (g1*l1 * A0) / (g0*l0).\n            Then from 0 to 2: A0 * A2 = A0 * (g1*l1 * A0)/(g0*l0) = (g1*l1 * A0^2) / (g0*l0) must equal g2*l2.\n\n            Therefore, A0^2 = (g2*l2 * g0 * l0) / (g1*l1) must be a perfect square and A0 must be an integer.\n\n        But this is just one example. The assignment must be done in a way that the entire component's assignments are consistent.\n\n    However, note: the problem does not require a unique solution. We can choose an initial value for one node arbitrarily? But the condition is that the numbers must be integers and satisfy the gcd condition.\n\n    Actually, we can set the entire component's values by choosing one value for the root arbitrarily, but then the rest are determined. But we must check the gcd condition on every edge.\n\n    But the problem: the same node might be reached by two different paths and we have to assign the same value. Therefore, we can do:\n\n        For each connected component:\n            Choose a root node, set its value to 1 (for example). Then do BFS/DFS to assign the rest: for an edge (u, v) with (g, l), if we know A[u], then A[v] = (g * l) / A[u]. But wait, note: the product condition is A[u]*A[v] = g*l, so A[v] = (g*l) / A[u]. However, we must also have that the gcd(A[u], A[v]) = g.\n\n        But note: we must check that (g*l) is divisible by A[u] and that the gcd condition holds.\n\n        However, the initial value 1 for the root might lead to non-integer values? Or not satisfy the gcd condition.\n\n    We can choose the root value arbitrarily, but we have to choose one that will lead to integers and satisfy the gcd condition. Alternatively, we can avoid setting the root arbitrarily by using the fact that the entire product of the component must be consistent.\n\n    Another idea: \n\n        We know that for each edge, the two numbers must be divisors of (g*l) and multiples of g. Therefore, the entire graph's nodes must be divisors of the least common multiple of all the edge's (g*l) values? Not exactly.\n\n    After thinking, here's a better plan:\n\n        Step 1: For each edge (u, v) with (g, l):\n            - Check that l % g == 0. If not, return \"NO\".\n            - Let k = l // g. Then the two numbers must be g * d1 and g * d2, with d1 * d2 = k and gcd(d1, d2) == 1.\n\n        Step 2: We can consider that the entire graph must be such that for each node, the value A[i] must be the same regardless of the path we take. \n\n        We can set up a system of equations: for each edge (u, v) with (g, l), we have A[u] * A[v] = g*l.\n\n        Then, if we fix a root node, say node0, we can set A[0] = x (to be chosen). Then for any node i, we can define a variable x_i (the value at node i) and the product of the edge from 0 to i (along a path) must be consistent.\n\n        However, note: the product along a path from 0 to i is fixed (by the edges). But the actual value at node i would be x * (product of the reciprocals of the edge constants) along the path? Actually, if we have a path from 0 to i: \n            edge1: (g1, l1) -> then A1 = (l1 * g2 * ... ) / (g1 * g3 * ...) ? \n\n        Alternatively, we can use the multiplicative consistency: \n\n            For an edge (u, v): A[u] * A[v] = g*u*v? No, it's fixed to g*l.\n\n        But note: the product condition is fixed, so if we set A0 = x, then A1 = (g0*l0) / x, then A2 = (g1*l1) / A1 = (g1*l1 * x) / (g0*l0). Then for an edge (0,2) with (g2,l2): we require A0 * A2 = x * (g1*l1 * x)/(g0*l0) = (g1*l1 * x^2) / (g0*l0) = g2*l2.\n\n        So x^2 = (g2*l2 * g0*l0) / (g1*l1). This must be a perfect square and x must be an integer.\n\n        But we don't know the entire graph structure. We have to assign for each node without knowing the entire graph? \n\n    Alternatively, we can use the following method:\n\n        Since for each edge, the two numbers must be divisors of (g*l) and multiples of g, we can precompute for each node the set of possible values.\n\n        However, the constraints: n, m up to 10^6? Actually, the input constraints: n and m can be up to 10^6? The problem says: \"It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\" but n and m are not bounded explicitly by 10^6? Actually, the input format says: first line n, m, and then m lines. But the problem statement says: \"n, m ()\" — wait, the problem statement says: \"The first line contains two numbers n and m ()\", and then each of the following m lines ... — but the example inputs are small. However, we must assume worst-case n, m up to 10^6? Or is it n, m up to 10^5? The problem does not specify. But note: the numbers in the edges are at most 10^6.\n\n    But note: the problem says \"It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 10^6\", meaning the GCD and LCM are in [1,10^6]. So we have to handle graphs with up to maybe 10^5 edges and nodes.\n\n    We need an efficient solution.\n\n    Revised plan:\n\n        Step 1: For each edge, check that l % g == 0. If not, output \"NO\".\n\n        Step 2: For each edge, we store (g, l). Then, we build the graph.\n\n        Step 3: We want to assign a value to each node. We can use the following:\n\n            Let A[i] be the value for node i.\n\n            Consider: for an edge (u, v) with (g, l), the value A[u] must be a divisor of (g*l) and a multiple of g. Moreover, the other condition is that A[u] * A[v] = g*l.\n\n            But note: if we set A[u] = g * d, then A[v] = (g*l) / (g*d) = (l/g) / d, so d must divide (l/g). And then the gcd condition: gcd(g*d, (l/g)/d) = g * gcd(d, (l/g)/d / g?) — wait, no.\n\n            Actually, we have:\n                A[u] = g * d, A[v] = (g*l) / (g*d) = (l/g) / d.\n\n            Then the gcd(A[u], A[v]) = gcd(g*d, (l/g)//d). But note: we require this to be g.\n\n            So: gcd(g*d, (l/g)//d) = g * gcd(d, (l/g)//(g*d))? \n\n            Actually, let me write:\n\n                gcd(g*d, (l/g)//d) = g * gcd(d, (l/g)//d // g)? \n\n            Let me break down:\n\n                We know that (l/g) is an integer, say k. Then A[u] = g*d, A[v] = k//d.\n\n                Then gcd(g*d, k//d) = g * gcd(d, (k//d) // g) ??? Not exactly.\n\n            Actually, we can factor out the g from A[u] but not necessarily from A[v]? Because k = l/g, so k//d = (l/g)//d, and we don't know if g divides k//d.\n\n            Alternatively, we can use the condition: gcd(A[u], A[v]) = g.\n\n            We have: gcd(g*d, (l/g)//d) = g * gcd(d, (l/g)//d // g) is not necessarily true.\n\n            Let me do: \n                Let d' = d, and let t = k // d = (l/g) // d.\n\n                Then gcd(g*d', t) = g * gcd(d', t // g) only if g divides t. But t = (l/g)//d, and we know that d divides k (because d divides k for A[u] to be an integer) and k = l/g, so t is an integer. But does g divide t? \n\n                We know: A[u] * A[v] = g*d * t = g*d*(k//d) = g * (d * (k//d)) = g * (k) = g * (l/g) = l. So the product is correct.\n\n                However, the gcd condition: we require gcd(g*d, t) = g.\n\n                This is equivalent to: gcd(d, t/g) = 1, but wait: we cannot say that because t might not be divisible by g.\n\n            Actually, we have: \n                gcd(g*d, t) = g * gcd(d, t/g)   only if g divides t. But we don't know if g divides t.\n\n            Let me test: \n                Example: g=2, l=12, so k=6. Suppose d=3, then t=6//3=2. Then gcd(2*3,2)=gcd(6,2)=2, which equals g. But 2 divides t=2, so then: gcd(3, 2//2)=gcd(3,1)=1, so yes.\n\n                Example: g=2, l=12, k=6, d=2, then t=3. Then gcd(4,3)=1, but we require 2. This does not work. Why? Because the condition for the edge (2,3): \n                    A[u]=4, A[v]=3 -> product=12, gcd(4,3)=1, but we need gcd=2. So this assignment is invalid.\n\n            So the assignment d=2 for the edge (g=2, l=12) is invalid.\n\n            How do we check without assuming divisibility by g?\n\n            We require: gcd(g*d, t) = g.\n\n            We can write: \n                Let d1 = d, and t = (l/g) // d.\n                Then gcd(g*d1, t) = g * gcd(d1, t // g')? \n\n            Actually, we can use the property: \n                gcd(a, b) = g0, and we know that g divides both a and b? In our case, g divides g*d (obviously) and we require that g divides t as well? \n\n            But in the example above, when d=2, t=3, and g=2 does not divide 3. Then the gcd(6,3)=3, but we require 2. \n\n            Actually, we must have that g divides both numbers, so the gcd must be a multiple of g. But wait, the condition is that the gcd is exactly g. So if g does not divide t, then the gcd might be a divisor of g, but then it wouldn't be g. \n\n            Actually, the condition for the edge (g, l) requires that the two numbers are multiples of g. Therefore, t must be divisible by g? \n\n            But note: the two numbers are A[u] = g*d and A[v] = t. The condition for the gcd to be g requires that g divides both. Therefore, t must be divisible by g. \n\n            So we must have that (l/g) // d is divisible by g? \n\n            Actually, no: the two numbers are A[u] = g*d and A[v] = t. The condition is that g divides both. So we require that g divides t. \n\n            Therefore, we must have that (l/g) // d is divisible by g, i.e., (l/g) // d = t must be divisible by g.\n\n            But note: we already have that t = (l/g) // d, and we require that g divides t. \n\n            Then, we can write: t = g * e, so (l/g) // d = g * e, which means l/(g*d) = g*e => l = g^2 * d * e.\n\n            Then, the product condition: A[u]*A[v] = g*d * g*e = g^2 * d * e = l, so it holds.\n\n            And the gcd condition: gcd(g*d, g*e) = g * gcd(d,e) = g * 1 = g, provided that gcd(d,e)=1.\n\n            So the conditions for the edge (g, l) are:\n\n                Condition 1: l % g == 0.\n                Condition 2: Let k = l // g. Then we must have k % g == 0? Actually, no: wait, we have k = l//g, and then we require that k is divisible by g? Actually, from the above, we require that t = k//d is divisible by g, and d divides k, so we can choose d and e such that d*e = k//g? \n\n            Alternatively, we can reparameterize: \n\n                We know that the two numbers are g*d and g*e, and d*e = (l//g)//g = l//(g*g). \n\n            Then the condition becomes: l must be divisible by g^2, and then d*e = l // (g*g), and gcd(d,e)=1.\n\n            But wait, is that always the case? \n\n            Example: g=2, l=12. Then l//g = 6, and then d*e = 6//2 = 3. Then we need two coprime numbers d and e such that d*e=3. Then d=1, e=3 or d=3, e=1. Then the two numbers are (2*1=2) and (2*3=6). Then gcd(2,6)=2, and product=12. \n\n            So actually, the condition is that l must be divisible by g, and then the quotient k=l//g must be decomposed into two coprime factors d and e, and then the two numbers are g*d and g*e.\n\n            But note: the example above with d=2 (which led to t=3) was invalid because then we did not have the representation as (g*d, g*e) with the same g? Actually, no: in that example, we had (g=2, d=2, e=3/2) which is not an integer. \n\n            So the representation is: the two numbers are g*d and g*e, with d and e coprime and d*e = (l//g) // g? No, wait: we have:\n\n                A[u] * A[v] = g*d * g*e = g^2 * d*e = l.\n\n            So d*e = l // (g^2). \n\n            Therefore, we must have that l is divisible by g^2.\n\n            But wait, the example g=2, l=12: 12 // (2^2)=12//4=3, and d*e=3, which is correct.\n\n            What if the edge (g=2, l=8): then 8//4=2, so d*e=2, and d and e coprime. Then possibilities: (1,2) -> numbers are 2*1=2 and 2*2=4 -> product=8, gcd(2,4)=2 -> valid.\n\n            But what if the edge (g=2, l=6): then 6//4 is not an integer -> invalid. And indeed, 6%4=2, but wait, we first require that l % g==0, which is 6%2==0, so that passes, but then the second condition fails because 6//2=3, and then we require that 3 is decomposed into two coprime factors whose product is 3, which is possible (1 and 3). Then the two numbers are 2*1=2 and 2*3=6. Then the product is 12, not 6. \n\n            So wait, there's a mistake: the product condition is A[u]*A[v]=g*l, not g^2 * d*e = l. \n\n            Let me clarify:\n\n                We have two numbers: a = g*d, b = g*e, then a*b = g^2 * d*e.\n\n                But the edge gives: a*b = g*l.\n\n                So we must have: g*l = g^2 * d*e => l = g*d*e.\n\n                But wait, then d*e = l // g.\n\n                And then the gcd condition: gcd(a,b)=gcd(g*d, g*e)=g * gcd(d,e) must be g, so gcd(d,e)=1.\n\n            So the conditions are:\n\n                Condition 1: g divides l (so that l//g is an integer).\n                Condition 2: Factor l//g into two coprime factors d and e.\n\n            Then the two numbers are a = g*d, b = g*e.\n\n            Then the product is g*d * g*e = g^2 * d*e = g^2 * (l//g) = g*l, which matches.\n\n            And the gcd is g * gcd(d,e) = g * 1 = g.\n\n            So the earlier example (g=2, l=6): \n                Condition 1: 6 % 2 == 0 -> holds.\n                Then k = 6//2 = 3.\n                Then we need two coprime factors d and e of 3: (1,3) or (3,1). Then the two numbers are (2*1, 2*3) = (2,6). Then product=12, but the edge requires product=6. \n\n            Wait, that's a contradiction.\n\n            Let me recalc: the product should be g*l = 2*6 = 12, but we are given l=6. \n\n            The input gives (g, l) for the edge. In the example, we are given g=2, l=6. Then the product of the two numbers should be 12. But then the two numbers are 2 and 6, which indeed multiply to 12. \n\n            However, the problem states: the edge has two numbers: the GCD and the LCM. Then the LCM of 2 and 6 is 6, and the GCD is 2. So that matches.\n\n            But wait, the product is 12, and we have the condition that the product is g*l=12. \n\n            So the condition is: the product of the two numbers is g*l, not g*l being the LCM. \n\n            And the edge is given with GCD=g and LCM=l.\n\n            Then, the two numbers a and b must satisfy: \n                gcd(a,b)=g and lcm(a,b)=l.\n\n            And we know that: a*b = g*l.\n\n            So the example is correct.\n\n            Then, the condition for the edge (g=2, l=6) is satisfied by (2,6). \n\n            But then, why did I think the product should be 6? That was a misinterpretation.\n\n            So the algorithm for an edge (g, l) is:\n\n                Step 1: Check l % g == 0. If not, invalid.\n                Step 2: Let k = l // g.\n                Step 3: Factor k into two coprime factors d and e (any factorization, but we only need one) such that d*e=k and gcd(d,e)==1.\n\n            Then, the two numbers for the edge are (g*d, g*e).\n\n            Now, how to factor k into two coprime factors? \n\n                We can do: factorize k, then assign the factors to d and e arbitrarily as long as they are coprime. Note: the factorization into two coprime factors is unique up to ordering if we consider the fundamental theorem: we can assign each prime factor entirely to one side or the other.\n\n            However, we don't need to find all factorizations, just one. We can do:\n\n                d = 1\n                e = k\n                while d*d <= k:\n                    if k % d == 0:\n                        if gcd(d, k//d)==1:\n                            then we have found one: d and k//d.\n                        else:\n                            continue to next divisor?\n                    d++\n\n            But note: we can also use the prime factorization: the two factors must be composed of disjoint prime factors.\n\n            However, k can be up to 10^6 (since l<=10^6 and g>=1, so k<=10^6). We can factor k by trial division.\n\n            But note: we have m edges, and each edge has a k. The total sum of k's might be large, but we are only doing this for each edge independently? \n\n            But wait, we are not storing the factorization for each edge to use in the graph, we are just checking the existence of one factorization per edge.\n\n            However, we are going to assign the nodes consistently. \n\n        Now, how to assign the entire graph?\n\n            We have a graph with n nodes and m edges. For each edge, we know the product of the two nodes is g*l (but we don't know the individual values). \n\n            We can set up a system of multiplicative equations: \n\n                For edge (u,v): A[u] * A[v] = C_{uv}\n\n            This is a system of multiplicative equations. We can fix one node's value and then determine the others. But the catch is that the value must be an integer and satisfy the factorization condition for every edge.\n\n            Steps for one connected component:\n\n                Step 1: Pick a root node and assign an initial value. But what initial value? \n\n                Note: the value for a node must be a divisor of the product of the (g*l) for the edges incident to it? Not exactly.\n\n            Alternatively, we can use the following:\n\n                Let R",
    "response": "\nTo solve this problem, we need to determine if it's possible to restore the number of mushrooms on each lawn (vertex) in a forest graph based on given roads (edges). Each edge provides the greatest common divisor (GCD) and least common multiple (LCM) of the mushroom counts on its two connected lawns. The solution involves verifying the consistency of these values across the graph and assigning valid mushroom counts to each lawn.\n\n### Approach\n1. **Edge Validation**: For each edge, check if the LCM is divisible by the GCD. If not, the arrangement is impossible.\n2. **Factorization**: For each edge, decompose the quotient (LCM/GCD) into two coprime factors. These factors help in determining the mushroom counts for the connected lawns.\n3. **Graph Traversal**: Using a depth-first search (DFS) or breadth-first search (BFS), propagate the mushroom counts from one node to another, ensuring consistency with all adjacent edges.\n4. **Consistency Check**: During traversal, verify that the assigned mushroom counts for each node satisfy the GCD and LCM conditions for all connected edges.\n\n### Solution Code\n```python\nimport sys\nfrom math import gcd as math_gcd\nfrom collections import defaultdict, deque\n\ndef factorize(k):\n    d = 1\n    e = k\n    while d * d <= k:\n        if k % d == 0:\n            if math_gcd(d, k // d) == 1:\n                return d, k // d\n        d += 1\n    return 1, k\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"NO\")\n        return\n    \n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    \n    graph = [[] for _ in range(n)]\n    edges = []\n    for _ in range(m):\n        u = int(next(it)) - 1\n        v = int(next(it)) - 1\n        g_val = int(next(it))\n        l_val = int(next(it))\n        edges.append((u, v, g_val, l_val))\n        graph[u].append((v, g_val, l_val))\n        graph[v].append((u, g_val, l_val))\n    \n    for u, v, g_val, l_val in edges:\n        if l_val % g_val != 0:\n            print(\"NO\")\n            return\n    \n    visited = [False] * n\n    ans = [0] * n\n    parent = [-1] * n\n    \n    for i in range(n):\n        if visited[i]:\n            continue\n        stack = [i]\n        visited[i] = True\n        parent[i] = -2\n        components = {}\n        comp_nodes = set()\n        comp_nodes.add(i)\n        while stack:\n            node = stack.pop()\n            for neighbor, g_val, l_val in graph[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    parent[neighbor] = node\n                    comp_nodes.add(neighbor)\n                    stack.append(neighbor)\n        \n        comp_edges = {}\n        for u, v, g_val, l_val in edges:\n            if (u in comp_nodes and v in comp_nodes):\n                key = (min(u, v), max(u, v))\n                if key not in comp_edges:\n                    comp_edges[key] = (g_val, l_val)\n        \n        base = None\n        for _, (g_val, l_val) in comp_edges.items():\n            k = l_val // g_val\n            d1, d2 = factorize(k)\n            num1 = g_val * d1\n            num2 = g_val * d2\n            if base is None:\n                base = (num1, num2)\n            else:\n                if base != (num1, num2) and set(base) != set((num1, num2)):\n                    print(\"NO\")\n                    return\n        \n        if base is None:\n            base = (1, 1)\n        \n        q = deque([i])\n        ans[i] = base[0]\n        while q:\n            node = q.popleft()\n            for neighbor, g_val, l_val in graph[node]:\n                if parent[neighbor] == node:\n                    continue\n                k = l_val // g_val\n                d1, d2 = factorize(k)\n                expected = g_val * d1\n                if ans[node] * expected != l_val:\n                    expected = g_val * d2\n                    if ans[node] * expected != l_val:\n                        print(\"NO\")\n                        return\n                \n                ans[neighbor] = expected\n                q.append(neighbor)\n        \n        for node in comp_nodes:\n            for neighbor, g_val, l_val in graph[node]:\n                if parent[neighbor] == node:\n                    continue\n                if math_gcd(ans[node], ans[neighbor]) != g_val:\n                    print(\"NO\")\n                    return\n    \n    print(\"YES\")\n    print(\" \".join(map(str, ans)))\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Edge Validation**: The code first checks if the LCM for each edge is divisible by the GCD. If not, it immediately outputs \"NO\" since the arrangement is impossible.\n2. **Factorization**: For each edge, the quotient (LCM/GCD) is decomposed into two coprime factors. This decomposition helps in determining the mushroom counts for the connected lawns.\n3. **Graph Traversal**: Using BFS, the code traverses each connected component of the graph. It starts with an arbitrary node and assigns a base value derived from the edge's factorization.\n4. **Consistency Check**: During traversal, the code ensures that the product of the mushroom counts for adjacent nodes matches the edge's LCM and that their GCD matches the edge's GCD. If any inconsistency is found, it outputs \"NO\".\n5. **Output**: If all checks pass, the code outputs \"YES\" followed by the mushroom counts for each lawn, ensuring all given edge conditions are satisfied.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom math import gcd as math_gcd\nfrom collections import defaultdict, deque\n\ndef factorize(k):\n    d = 1\n    e = k\n    while d * d <= k:\n        if k % d == 0:\n            if math_gcd(d, k // d) == 1:\n                return d, k // d\n        d += 1\n    return 1, k\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"NO\")\n        return\n    \n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    \n    graph = [[] for _ in range(n)]\n    edges = []\n    for _ in range(m):\n        u = int(next(it)) - 1\n        v = int(next(it)) - 1\n        g_val = int(next(it))\n        l_val = int(next(it))\n        edges.append((u, v, g_val, l_val))\n        graph[u].append((v, g_val, l_val))\n        graph[v].append((u, g_val, l_val))\n    \n    for u, v, g_val, l_val in edges:\n        if l_val % g_val != 0:\n            print(\"NO\")\n            return\n    \n    visited = [False] * n\n    ans = [0] * n\n    parent = [-1] * n\n    \n    for i in range(n):\n        if visited[i]:\n            continue\n        stack = [i]\n        visited[i] = True\n        parent[i] = -2\n        components = {}\n        comp_nodes = set()\n        comp_nodes.add(i)\n        while stack:\n            node = stack.pop()\n            for neighbor, g_val, l_val in graph[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    parent[neighbor] = node\n                    comp_nodes.add(neighbor)\n                    stack.append(neighbor)\n        \n        comp_edges = {}\n        for u, v, g_val, l_val in edges:\n            if (u in comp_nodes and v in comp_nodes):\n                key = (min(u, v), max(u, v))\n                if key not in comp_edges:\n                    comp_edges[key] = (g_val, l_val)\n        \n        base = None\n        for _, (g_val, l_val) in comp_edges.items():\n            k = l_val // g_val\n            d1, d2 = factorize(k)\n            num1 = g_val * d1\n            num2 = g_val * d2\n            if base is None:\n                base = (num1, num2)\n            else:\n                if base != (num1, num2) and set(base) != set((num1, num2)):\n                    print(\"NO\")\n                    return\n        \n        if base is None:\n            base = (1, 1)\n        \n        q = deque([i])\n        ans[i] = base[0]\n        while q:\n            node = q.popleft()\n            for neighbor, g_val, l_val in graph[node]:\n                if parent[neighbor] == node:\n                    continue\n                k = l_val // g_val\n                d1, d2 = factorize(k)\n                expected = g_val * d1\n                if ans[node] * expected != l_val:\n                    expected = g_val * d2\n                    if ans[node] * expected != l_val:\n                        print(\"NO\")\n                        return\n                \n                ans[neighbor] = expected\n                q.append(neighbor)\n        \n        for node in comp_nodes:\n            for neighbor, g_val, l_val in graph[node]:\n                if parent[neighbor] == node:\n                    continue\n                if math_gcd(ans[node], ans[neighbor]) != g_val:\n                    print(\"NO\")\n                    return\n    \n    print(\"YES\")\n    print(\" \".join(map(str, ans)))\n\nif __name__ == '__main__':\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 544,
        "completion_token_count": 1274,
        "thoughts_token_count": 8191
    }
}