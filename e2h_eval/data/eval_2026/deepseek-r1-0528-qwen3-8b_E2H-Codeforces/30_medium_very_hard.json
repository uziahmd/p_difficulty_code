{
    "start": 1758308161.051349,
    "end": 1758311692.383737,
    "start-formatted": "2025-09-20 03:56 KST",
    "end-formatted": "2025-09-20 04:54 KST",
    "gpu": 2,
    "pid": 30,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# TV Game\n\nThere is a new TV game on BerTV. In this game two players get a number A consisting of 2n digits. Before each turn players determine who will make the next move. Each player should make exactly n moves. On it's turn i-th player takes the leftmost digit of A and appends it to his or her number Si. After that this leftmost digit is erased from A. Initially the numbers of both players (S1 and S2) are «empty». Leading zeroes in numbers A, S1, S2 are allowed. In the end of the game the first player gets S1 dollars, and the second gets S2 dollars.One day Homer and Marge came to play the game. They managed to know the number A beforehand. They want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize. Help them.\n\n## Input\nThe first line contains integer n (1 ≤ n ≤ 18). The second line contains integer A consisting of exactly 2n digits. This number can have leading zeroes.\n\n## Output\nOutput the line of 2n characters «H» and «M» — the sequence of moves of Homer and Marge, which gives them maximum possible total prize. Each player must make exactly n moves. If there are several solutions, output any of them.\n\n## Example\n### Input\n['2\\n1234', '2\\n9911']\n\n### Output\n['HHMM', 'HMHM']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\n Okay, we are given an integer n and a string A of 2n digits.\n We have two players: Homer (H) and Marge (M). Each makes exactly n moves.\n On each move, the leftmost digit is taken and appended to the respective player's number.\n\n The goal is to choose a sequence of moves (a string of length 2n containing n 'H's and n 'M's) such that the total prize (the sum of the two numbers S1 and S2) is maximized.\n\n Note: The game proceeds by removing the leftmost digit from A on each turn. The catch: we can decide arbitrarily which player takes the next digit (but each must take exactly n).\n\n However, note: the problem says \"each player should make exactly n moves\", and we have to output a string of length 2n with n H's and n M's.\n\n Let's denote:\n   Let the initial number A be represented as a string of 2n digits: d0 d1 ... d_{2n-1}\n\n After all moves, the two numbers are built as follows:\n   S1 = some selection of n digits from A (in order of appearance, but not contiguous in A because the removal is from the front) — actually, the digits taken by a player are taken in the order they appear, but the catch is: the entire A is processed from left to right, and when we assign a digit to a player, that digit is removed and the next digit becomes the new leftmost.\n\n Actually, the process is fixed: at each step we remove the leftmost digit and assign it to either H or M. So the two numbers will be two interleaved sequences of the original digits, but the assignment is arbitrary (any subset of n digits for H and the rest for M, and the order in each number is the order of appearance in A).\n\n But note: the assignment must be done so that the digits are taken in the order they appear in A. For example, if A is \"1234\" and n=2, then we have two possibilities for H: \n   Option 1: Take the first and third: then S1 = \"13\", S2 = \"24\"\n   Option 2: Take the first and fourth: then S1 = \"14\", S2 = \"23\"\n   Option 3: Take the second and third: then S1 = \"23\", S2 = \"14\"\n   etc.\n\n However, the problem does not require us to consider all assignments? We need to maximize the total prize: S1 + S2.\n\n Since the digits are taken in the order of A, the two numbers are built from the same set of digits (the entire A) and the two numbers are two sequences of n digits (without repetition, and preserving the relative order of the digits from A).\n\n But note: the total value is the numerical value of S1 plus the numerical value of S2.\n\n How to think?\n\n Let the final two numbers be X and Y (each of n digits, possibly with leading zeros). Then the total prize is X + Y.\n\n We want to maximize X + Y.\n\n How do we assign the digits? We have 2n digits, and we assign each digit to either X or Y, but the assignment must preserve the order (so the digits in X must appear in increasing index order, and similarly for Y).\n\n This is similar to: split the sequence A into two subsequences (each of length n) and form two numbers. Then we want to maximize the sum of these two numbers.\n\n However, note: the two numbers are formed by taking the digits in the order of the original sequence. Also, the first digit of A must be assigned to one of the numbers, and then the next, etc.\n\n We can use dynamic programming. But note n can be up to 18, so the total length is 36, which is too long for a naive DP (which would be O(2^36) states). Alternatively, we can use state (i, j) meaning we have processed i+j digits, with i being the count for the first number (H) and j for the second (M). But wait, we don't know which one is which.\n\n Actually, we have two numbers, and we have to assign each digit to one of the two. The value of the two numbers depends on the order.\n\n But note: the two numbers are built by appending the digits (so the first digit assigned to a player becomes the most significant digit of his number). Therefore, the assignment of a digit to a player at an early stage (say the k-th digit) becomes a digit with weight 10^(n-1 - (position in that player's number)).\n\n However, the catch: the assignment is interleaved arbitrarily. The positions in the two numbers are fixed: the first time a player takes a digit, it becomes the first (most significant) digit of his number, the second time his digit becomes the second (next most significant) and so on.\n\n Therefore, the total value contributed by the digits assigned to H is:\n   Let the digits assigned to H (in the order they are assigned) be d_i1, d_i2, ..., d_in (where i1 < i2 < ... < in). Then the value for H is:\n        H_value = d_i1 * (10^(n-1)) + d_i2 * (10^(n-2)) + ... + d_in * (10^0)\n\n Similarly for M.\n\n And the total prize is H_value + M_value.\n\n Now, note that the entire set of digits is fixed. We are allowed to assign each digit to one of the two numbers, but the assignment must be such that the indices in each number form an increasing sequence (which they do because we are taking from left to right).\n\n But note: we cannot change the order. The digits assigned to H must be taken in the order they appear in A, and similarly for M.\n\n We wish to maximize the sum.\n\n How to solve?\n\n We can use DP with state (i, a, b) where i is the current index (from 0 to 2n), and a is the number of digits already assigned to H, and b to M. Then we can also keep track of the current value for H and M? But the numbers have n digits, and the digits are base 10, so the numbers can be up to 10^n which is 10^18, and n up to 18 -> numbers up to 10^18, and we have 36 digits, so the state space would be 36 * 19 * 19 which is about 36*361 ~ 13000 states, but then the value of H and M is too big to store.\n\n Alternatively, we can use the fact that the digits are only 0-9 and the length is fixed. We can use DP that tracks:\n\n   dp[i][j] = maximum total value (H_value + M_value) we can achieve after processing the first i+j digits, having assigned j digits to H and i digits to M? Wait, let me define:\n\n   Let dp[i][j] = the maximum total value (H_value + M_value) we can have after having processed the first (i+j) digits, with i digits assigned to H and j digits assigned to M? Actually, no, because the digits we've assigned to H are the ones we've chosen, and they matter for the place value.\n\n But note: the place value of a digit depends on how many more digits the player will get. For example, if we assign a digit now to H, and there will be k more digits for H, then this digit will be multiplied by 10^(k). However, we don't know k until the end.\n\n Alternatively, we can use a different state: \n\n   Let dp[i][a][b] = the maximum total value achieved after processing i digits (from A) and having assigned a digits to H and b digits to M (with a+b=i). But then we also need to know the current values of H and M? Or we can break down the contribution.\n\n Another idea: since the assignment is fixed and the digits are assigned in order, the value of a digit assigned to H at the k-th move of H (which will be the k-th most significant digit) is d * (10^(n-k)). Similarly for M.\n\n Then the total value is the sum over all digits of (digit * (10^(n - (move number in the respective player))) if assigned to that player.\n\n But the move number in the respective player is determined by the time we assign the digit.\n\n However, we can postpone the calculation until we know the entire assignment.\n\n Alternatively, we can use a greedy approach? But note: the problem is combinatorial.\n\n We can use DP with state (i, a) where i is the index (from 0 to 2n) and a is the number of digits assigned to H so far (then M has i - a digits). But then we need to know the exact sequence for H and M to compute the value? That would be too heavy.\n\n Insight: The total value is:\n\n   Let the assignment for H be the digits at positions (indices) p1, p2, ..., pn (with p1 < p2 < ... < pn). Then H_value = Σ_{k=1}^{n} (digit at pk) * (10^(n-k))\n\n   Similarly, M_value = Σ_{k=1}^{n} (digit at qk) * (10^(n-k))\n\n   Then total = Σ_{k=1}^{n} [ (digit at pk) * (10^(n-k)) + (digit at qk) * (10^(n-k)) ]\n\n   Notice that the exponents are fixed per position in the two numbers. However, the assignment of the digits to the two numbers is free (subject to the increasing index condition) and we wish to maximize the total.\n\n But note: the two numbers are independent in the sense that the exponent for a digit depends on the total number of digits (n) and the position in the respective number. However, the same digit cannot be used twice.\n\n We can reframe: we have two sets of n digits (each set being a subsequence of A of length n) and we wish to maximize the sum:\n\n   Sum_{k=1}^{n} [ d_k * (10^(n-k)) ] for H and similarly for M, but note the digits are taken from A in order.\n\n Actually, the entire set of digits is fixed. We are just partitioning the 2n digits into two subsequences (each of length n). The value of a digit d in H is d * (10^(exponent)), and the exponent is determined by how many digits we assign to H after this one? No, the exponent is determined by the position in H: the first digit assigned to H is multiplied by 10^(n-1), the second by 10^(n-2), etc.\n\n But note: the assignment order is fixed by the increasing index in A. However, the exponent for a digit in H is fixed once we know that this digit is the j-th digit of H. And j is the number of digits assigned to H that are taken from A at or before the current digit.\n\n Actually, we can precompute the exponent factors:\n\n   For H, the first digit (the earliest in A) will have exponent 10^(n-1), the next (when we assign the next to H) will have exponent 10^(n-2), etc.\n\n But note: the assignment must be done in increasing index order. So we are forced to assign the digits in the order of A.\n\n We can use dynamic programming that goes through the 2n digits and decides whether to assign the current digit to H or to M.\n\n State: (i, a) where i is the index (0-indexed, from 0 to 2n-1) and a is the number of digits we have assigned to H so far. Then the number of digits assigned to M is (i+1 - a) (if we are at index i, we've processed i+1 digits). But we must ensure that a <= n and i+1 - a <= n.\n\n Transition: at index i, we can assign the digit A[i] to H or to M.\n\n However, the value we get from assigning A[i] to H depends on how many more digits we will assign to H (because then the exponent for this digit is 10^(remaining_digits_in_H)), but wait: the remaining digits in H is (n - a) if we assign to H, then this digit will be the next one (so the exponent is 10^(n - (a+1))? Actually, no: the value of the digit in H is determined by its position in H. The first digit (the earliest) gets the highest power. If we assign a digit now to H, then it will be the (a+1)-th digit of H (so the exponent is 10^(n - (a+1))).\n\n But note: the entire number H is built from the digits we assign, and the order is the order of A. The first time we assign a digit to H, that digit is the most significant (multiplied by 10^(n-1)), the next time (if we assign again) then that digit is the next most significant (multiplied by 10^(n-2)), etc.\n\n So the exponent for a digit assigned to H at the time when there are (a) digits already in H is 10^(n - (a+1))? Actually, no: the exponent is determined by the position in the final number. The first digit of H (which is the earliest in A) is the most significant. So if we have already assigned a digits to H, then the next digit we assign to H will be the (a+1)-th digit of H, and the exponent for that digit is 10^(n - (a+1))? \n\n But wait: the entire number H has n digits. The leftmost digit (first assigned) is the highest (10^(n-1)), then 10^(n-2) for the next, etc.\n\n So if we are going to assign a digit to H when we have already assigned a digits to H, then this digit will be the (a+1)-th digit, so its exponent is 10^(n - (a+1)).\n\n Similarly, for M: if we have already assigned b digits to M, then the next digit to M will be the (b+1)-th digit, so exponent 10^(n - (b+1)).\n\n But note: we are processing the digits in order. The state (i, a) does not tell us how many digits have been assigned to M, but we can compute it: total digits processed so far is i+1, so M has (i+1 - a) digits.\n\n However, the problem: the exponent for a digit assigned to H at state (i, a) is 10^(n - (a+1)), but then later we might assign more digits to H, so the earlier digits (which are already assigned) were assigned with higher exponents. But wait, the exponent for a digit is fixed at the time of assignment: because the entire number H is built from the digits we assign, and the digit assigned at an earlier step (in terms of the game) is the more significant one.\n\n So actually, we can compute the value for a digit if we know the entire assignment (the order in which we assign to H). However, we are building the number as we go.\n\n Alternatively, we can use DP that accumulates the total value so far, but we must account for the fact that the digits we assign now will be shifted by the subsequent assignments.\n\n Example: n=2, A=\"1234\"\n\n Consider the assignment: H takes the first and third, M takes the second and fourth.\n\n Step0: assign first digit '1' to H. Then the value for H becomes 1 * 10^(1) = 10. (since n=2, so exponent 10^(2-1)=10)\n Step1: assign second digit '2' to M. Then M's value becomes 2 * 10^(1) = 20.\n Step2: assign third digit '3' to H. Then H's value becomes 10 + 3 * 10^(0) = 13.\n Step3: assign fourth digit '4' to M. Then M's value becomes 20 + 4 * 10^(0) = 24.\n\n Total = 13 + 24 = 37.\n\n But if we assign the first digit to H, then the second to H, then the third to M, then the fourth to M:\n\n Step0: assign '1' to H -> H=10\n Step1: assign '2' to H -> H=10 + 2 * 10^0 = 12\n Step2: assign '3' to M -> M=3 * 10^1 = 30\n Step3: assign '4' to M -> M=30 + 4 * 10^0 = 34\n Total = 12+34 = 46.\n\n However, note: the above assignment is not valid because we must assign exactly n moves to each. In this case, n=2, so we assign two to H and two to M. The above assignment is valid.\n\n But wait: the example input ['2\\n1234', '2\\n9911'] outputs ['HHMM','HMHM'].\n\n Let's compute for A=\"1234\" with the assignment \"HHMM\":\n\n   H: digits at positions0 and 1: \"12\", so value = 1*10 + 2 = 12.\n   M: digits at positions2 and 3: \"34\", so value = 3*10 + 4 = 34.\n   Total = 46.\n\n For \"HMHM\":\n   H: digits at positions0 and 2: \"13\", so value = 1*10 + 3 = 13.\n   M: digits at positions1 and 3: \"24\", so value = 2*10 + 4 = 24.\n   Total = 37.\n\n So the example output says that for \"1234\", the answer is \"HHMM\" (which gives 46) and for \"9911\", the answer is \"HMHM\".\n\n Why is \"HHMM\" better than \"HMHM\"? Because 46 > 37.\n\n But note: the problem says \"maximize their total prize\". So we want the maximum total.\n\n However, the example input also includes ['2\\n9911'] and the output is \"HMHM\". Let's check:\n\n   For A=\"9911\", n=2.\n\n   Assignment \"HHMM\":\n        H: \"99\", value = 99.\n        M: \"11\", value = 11.\n        Total = 110.\n\n   Assignment \"HMHM\":\n        H: \"91\", value = 91.\n        M: \"91\", value = 91.\n        Total = 182.\n\n   But wait, 182 > 110, so why is the example output \"HMHM\" for \"9911\"?\n\n   Actually, the example input is provided as:\n\n        Input: \n            ['2\\n1234', '2\\n9911']\n\n        Output:\n            ['HHMM', 'HMHM']\n\n   But wait, the example output is two strings: the first for \"1234\" and the second for \"9911\".\n\n   For \"9911\": \n        The example output is \"HMHM\", which gives 91+91 = 182.\n\n        But what about the assignment \"HM HM\" (which is the same as \"HMHM\")? \n        Alternatively, what about \"MM HH\"? \n        Let me check:\n\n        Assignment \"MMHH\":\n            H: \"11\", M: \"99\" -> total = 11 + 99 = 110.\n\n        Assignment \"HHMM\": 99 + 11 = 110.\n\n        Assignment \"MHMH\":\n            H: \"91\", M: \"91\" -> same as \"HMHM\", total 182.\n\n        Assignment \"MHHM\": \n            H: \"91\", M: \"91\" -> same.\n\n        So the maximum total is 182, and one way to achieve it is \"HMHM\".\n\n   Why then for \"1234\" the maximum is 46 and the assignment is \"HHMM\"?\n\n        Let me check other assignments for \"1234\":\n\n        Possibilities:\n\n        \"HHMM\": 12 + 34 = 46.\n        \"HM MH\": i.e., \"HMMH\" is not allowed because we must have exactly two H and two M, and the moves are interleaved arbitrarily. Actually, the moves are in the order of A: the digits are processed from left to right, and we decide at each step who takes it.\n\n        We have to assign the four digits to two players, two each, in the order of the digits.\n\n        Let me list all possibilities:\n\n          0: H, 1: M, 2: H, 3: M -> \"HMHM\": 13+24=37\n          0: H, 1: M, 2: M, 3: H -> \"HMMH\": invalid because we need two H and two M, and we are at step3: we have three H? Actually, step3: we have two H and two M? \n                Step0: H -> count H=1, M=0\n                Step1: M -> H=1, M=1\n                Step2: M -> H=1, M=2 -> then step3: H -> H=2, M=2 -> valid.\n                Then H: digits at index0 and index3: \"14\", value=14; M: digits at index1 and index2: \"23\", value=23 -> total=37.\n\n          0: M, 1: H, 2: H, 3: M -> \"MHHM\": M: \"1\", then H: \"2\", then H: \"3\", then M: \"4\" -> M: 1 and 4 -> 14, H: 2 and 3 -> 23 -> total=37.\n          0: M, 1: H, 2: M, 3: H -> \"MHMH\": M: \"14\", H: \"23\" -> total=37.\n\n          0: H, 1: H, 2: M, 3: M -> \"HHMM\": 12+34=46.\n          0: M, 1: M, 2: H, 3: H -> \"MMHH\": 11+22=33? \n                Actually, M: \"11\", H: \"22\" -> 11+22=33.\n\n          0: M, 1: H, 2: H, 3: M -> same as above: 37.\n\n          0: H, 1: H, 2: M, 3: M -> 46.\n\n        So the maximum is 46.\n\n        Why is 46 the maximum? Because we want to put the larger digits in the more significant places.\n\n        In \"1234\", the two largest digits are '3' and '4'. But note: the assignment \"HHMM\" puts the two smallest digits ('1' and '2') in the more significant positions for both numbers? \n\n        Actually, let's break down:\n\n          In \"HHMM\": \n            H: \"12\" -> the two smallest digits, but we are forced to assign the first two digits to H? Then the two largest digits are assigned to M, which are the last two.\n\n          Why is that good? Because the first digit (the most significant) for H is 1 and for M is 3 (from the third digit). \n\n          Alternatively, we want to maximize the total. \n\n          We can compare:\n\n          Assignment \"HHMM\": \n            H: 1*10 + 2 = 12\n            M: 3*10 + 4 = 34\n            Total: 46\n\n          What if we try to put the largest digits in the most significant places?\n\n          The two largest digits are '3' and '4'. We can assign the first digit to M? Then M gets the most significant digit as 1? That doesn't sound good.\n\n          But wait, the first digit is the most significant for whoever gets it. So if we assign the first digit to M, then M's number starts with 1 (which is small). Then we assign the second digit to H: then H's number starts with 2 (also small). Then the third and fourth to whoever: then the third digit (3) goes to H or M, and fourth (4) to the other.\n\n          Example: \"MH..\" for the first two:\n\n          \"MH..\" : \n            Step0: M takes '1' -> M: 10\n            Step1: H takes '2' -> H: 20\n            Step2: say M takes '3' -> M: 10 + 3 (but wait, M's number: first digit is 1, then 3 -> so it's 1*10 + 3 = 13? \n            Step3: H takes '4' -> H: 20 + 4 = 24 -> total=13+24=37.\n\n          Or \"MH..\" with step2: H takes '3', step3: M takes '4': \n            M: 10 + 4 (but wait, the second digit of M is 4, so M: 1*10 + 4 = 14\n            H: 20 + 3 = 23 -> total=37.\n\n          So it seems that \"HHMM\" is the best.\n\n        Why is that? Because the first digit is the most significant, and we want to avoid giving the large digits to the opponent in the most significant places? Actually, we are both trying to maximize our own number, but the total is the sum. \n\n        However, note: we are allowed to choose arbitrarily. We are not competing against each other in the usual sense (like one maximizing and the other minimizing). Both players are trying to maximize the total prize? Actually, the problem says: \"maximizes their total prize\". So we are cooperating to maximize the sum.\n\n        Therefore, we want to assign the digits so that the two numbers (which are built from the same set of digits, but in order) are as large as possible. But note: the two numbers are built from disjoint sets.\n\n        How to assign the digits to maximize the sum?\n\n        We wish to maximize:\n          Σ_{k=1}^{n} [ (digit assigned to H at the k-th move) * (10^(n-k)) ] \n          + \n          Σ_{k=1}^{n} [ (digit assigned to M at the k-th move) * (10^(n-k)) ]\n\n        The exponents are fixed: the first move (whichever player) gets multiplied by 10^(n-1), the second move (by the same or the other player) by 10^(n-2), etc.\n\n        Therefore, the total multiplier for a digit that is assigned at a particular step (say the j-th step, j from 1 to 2n) is 10^(n - j) if we assign it to a player, but then the same digit might be assigned to either player. However, the same digit cannot be assigned twice.\n\n        But note: the assignment must be done in increasing index order. We are forced to use the digits in the order of A.\n\n        The key: the j-th step (the j-th digit from A) has a fixed multiplier? Actually, no: the multiplier for a digit depends on the player and the number of moves that player has already made. Specifically, if at step j (0-indexed) we assign a digit to a player, then the exponent for that digit is 10^(n - (number_of_moves_that_player_has_so_far)).\n\n        However, the number_of_moves_that_player_has_so_far is known from the state.\n\n        We can use DP:\n\n          dp[i][a] = the maximum total value achievable after processing the first i digits (i from 0 to 2n) and having assigned a digits to H (and therefore i - a digits to M). The state must also account for the fact that the value we get from assigning a digit now to H or M depends on the current count.\n\n        But note: the value for a digit assigned to H at this state (with a digits already assigned to H) is (digit * (10^(n - (a)))) because then this digit will be the (a+1)-th digit of H, so it gets multiplied by 10^(n - (a+1))? Actually, no: the first digit (a=0) is multiplied by 10^(n-1). The second (a=1) by 10^(n-2). So the exponent is 10^(n - (a+1)).\n\n        However, wait: if we assign a digit to H at a state where we have already assigned a digits to H, then the exponent is 10^(n - (a+1)), and for M, if we have already assigned b digits to M, then the exponent is 10^(n - (b+1)).\n\n        But we don't know the entire assignment until the end. However, we can compute the value as we go.\n\n        The recurrence:\n\n          dp[i][a] = maximum total value (sum of H and M) after processing i digits (so i = a + b, and b = i - a) and having assigned a digits to H and i-a digits to M.\n\n          Then, for the next digit (the i-th digit, 0-indexed, so the digit A[i]):\n\n          Option 1: Assign to H. Then we require a < n. The value added by this digit is: int(A[i]) * (10**(n - (a+1)))\n          Then the state becomes dp[i+1][a+1] = max(dp[i+1][a+1], dp[i][a] + int(A[i]) * (10**(n - (a+1))))\n\n          Option 2: Assign to M. Then we require (i+1 - a) < n, i.e., a > i - n (or simply a >= i+1 - n). The value added by this digit is: int(A[i]) * (10**(n - (i - a))) [because the current count for M is (i - a), so the exponent is 10^(n - (i - a + 1))? \n\n          Actually, for M: the number of moves M has so far is (i - a). Then the next move for M will be the (i - a + 1)-th move, so exponent is 10^(n - (i - a + 1)).\n\n          But wait, the state is (i, a): we have processed i digits, and we have assigned a to H, so M has i - a. Then the next move for M is the (i - a + 1)-th, so the exponent is 10^(n - (i - a)) ? \n\n          Let me clarify: \n\n          In the state (i, a), we have processed i digits. The next digit (the i-th, 0-indexed) is the (i+1)-th digit. \n\n          For H: if we assign this digit, then the exponent for this digit is 10^(n - (a+1)) because we are going to have a+1 digits for H, and the next digit for H (if we assign now) is the (a+1)-th, so the exponent is 10^(n - (a+1)).\n\n          For M: the next digit for M (if we assign to M) is the (i - a + 1)-th digit for M, so the exponent is 10^(n - (i - a)).\n\n          Why for M: the exponent is 10^(n - (i - a))? \n\n          Example: n=2, state (i=0, a=0): we have processed 0 digits. Then M has 0 digits so far, so the next digit for M would be the first digit of M, which gets exponent 10^(2-1)=10. But according to the formula: 10^(n - (i - a)) = 10^(2 - (0-0)) = 10^2 = 100 -> that's wrong.\n\n          Correction: \n\n          In the state (i, a): \n            H has a digits, M has i - a digits.\n\n          Then, if we assign the next digit to H, the exponent is 10^(n - (a+1)).\n          If we assign to M, the exponent is 10^(n - ((i - a)+1)).\n\n          Example: n=2, i=0, a=0, assign to M: exponent = 10^(2 - (0+1)) = 10^1 = 10. Correct.\n\n          Example: n=2, i=1, a=0 (so M has 1 digit already). Then if we assign the next digit to M, the exponent is 10^(2 - (1+1)) = 10^0 = 1. Correct.\n\n        Therefore, the recurrence:\n\n          dp[0][0] = 0\n\n          For i from 0 to 2n-1:\n            For a from 0 to min(i, n) and from max(0, i-n+1) to i (for M) but we can iterate a from 0 to i, and check bounds.\n\n          However, we have two choices:\n\n          If we assign the i-th digit (0-indexed) to H, then we require a < n, and then:\n\n            dp[i+1][a+1] = max(dp[i+1][a+1], dp[i][a] + int(A[i]) * (10**(n - (a+1))))\n\n          If we assign to M, then we require (i - a) < n (so that we can assign one more to M), i.e., a >= i+1 - n (if we are going to assign to M, then the number of M digits will be i - a + 1, so we require i - a + 1 <= n -> a >= i+1 - n). Then:\n\n            dp[i+1][a] = max(dp[i+1][a], dp[i][a] + int(A[i]) * (10**(n - (i - a))))\n\n          But wait, in the M assignment, the state for H remains a (we are adding to M, so H count doesn't change). So the next state is (i+1, a) (not a+1).\n\n        However, note: we are processing the i-th digit (0-indexed) and we are at state (i, a). Then we update state (i+1, a+1) for H and (i+1, a) for M.\n\n        Then the answer is the maximum of dp[2n][n] (because at the end we must have assigned n digits to H and n to M) and the corresponding sequence of moves.\n\n        But wait: we are only storing the maximum value, not the sequence. We need to reconstruct the sequence.\n\n        Steps:\n\n          1. Precompute the powers: we need exponents from 0 to n-1 (for base 10). We can precompute a list: power[i] = 10**i, but note: for H, the exponent for the j-th move is 10^(n - j) (j from 1 to n). Similarly for M.\n\n          2. Use DP with state (i, a) and store the dp table and the choice (whether we assigned the digit at position i to H or M) for reconstruction.\n\n          3. The dimensions: i from 0 to 2n (so 2n+1) and a from 0 to n (so n+1). So the DP table has (2n+1) * (n+1) states.\n\n          4. We'll store:\n\n               dp[i][a] = maximum total value from the first i digits (processed) with a digits assigned to H.\n\n               choice[i][a] = 0 for M, 1 for H, or None if not updated.\n\n          5. Then, after filling the table, we start from state (2n, n) and backtrack to reconstruct the moves.\n\n        However, note: the exponent for M in the state (i, a) is 10^(n - (i - a + 1))? \n\n        Actually, when we assign the current digit (at index i) to M, the current count for M is (i - a) (because we have processed i digits and assigned a to H, so M has i - a). Then the next assignment to M (this one) is the (i - a + 1)-th move for M, so the exponent is 10^(n - (i - a)).\n\n        But wait: the exponent for",
    "response": "\nTo solve this problem, we need to maximize the total prize for two players, Homer and Marge, who take turns selecting digits from a given number A. The goal is to determine the optimal sequence of moves (comprising exactly n 'H's and n 'M's) such that the sum of the numerical values of the numbers formed by each player is maximized.\n\n### Approach\n1. **Problem Analysis**: The problem involves processing a string of 2n digits, where each digit is assigned to either player H or M in sequence. Each player must receive exactly n digits. The numerical value of each player's number is determined by the digits they collect in the order they appear in A. The challenge is to assign digits optimally to maximize the sum of both players' numbers.\n\n2. **Dynamic Programming (DP) Setup**: We use a DP approach where `dp[i][a]` represents the maximum total value achievable after processing the first `i` digits with `a` digits assigned to player H. The state transitions involve deciding whether to assign the next digit to H or M, updating the total value accordingly based on the digit's position in the respective player's number.\n\n3. **State Transitions**:\n   - **Assign to H**: The digit's value is added as `digit * 10^(n - (a + 1))`, where `a` is the current count of digits assigned to H.\n   - **Assign to M**: The digit's value is added as `digit * 10^(n - (i - a))`, where `i - a` is the current count of digits assigned to M.\n\n4. **Reconstruction**: After filling the DP table, we backtrack from the state `(2n, n)` to determine the sequence of moves (H or M) that led to the maximum total value.\n\n### Solution Code\n```python\ndef main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    n = int(data[0].strip())\n    A_str = data[1].strip()\n\n    total_digits = 2 * n\n\n    # Precompute powers of 10 for exponents up to n-1\n    powers = [10**i for i in range(n)]\n\n    # dp[i][a] will store the maximum total value after processing i digits with a digits for H\n    dp = [[-1] * (n + 1) for _ in range(total_digits + 1)]\n    # choice[i][a] stores whether the last move at position i was H (1) or M (0)\n    choice = [[0] * (n + 1) for _ in range(total_digits + 1)]\n    \n    dp[0][0] = 0\n\n    for i in range(total_digits):\n        for a in range(n + 1):\n            if dp[i][a] == -1:\n                continue\n            if a < n:\n                exp = n - (a + 1)\n                add_value = int(A_str[i]) * (10 ** exp)\n                new_val = dp[i][a] + add_value\n                if dp[i+1][a+1] == -1 or new_val > dp[i+1][a+1]:\n                    dp[i+1][a+1] = new_val\n                    choice[i+1][a+1] = 1\n            if (i - a) < n:\n                exp = n - (i - a)\n                add_value = int(A_str[i]) * (10 ** exp)\n                new_val = dp[i][a] + add_value\n                if dp[i+1][a] == -1 or new_val > dp[i+1][a]:\n                    dp[i+1][a] = new_val\n                    choice[i+1][a] = 0\n\n    result = []\n    i = total_digits\n    a = n\n    while i > 0:\n        c = choice[i][a]\n        result.append('H' if c == 1 else 'M')\n        if c == 1:\n            a -= 1\n        i -= 1\n\n    result.reverse()\n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input consists of an integer `n` and a string `A` of length `2n`.\n2. **Initialization**: The DP table `dp` is initialized to store the maximum value achievable at each state, and `choice` keeps track of the optimal move (H or M) at each step.\n3. **DP Table Population**: For each digit in `A`, the algorithm checks all possible states `(i, a)` where `i` is the number of digits processed and `a` is the count of digits assigned to H. It updates the DP table by considering both possible moves (assigning the current digit to H or M).\n4. **Backtracking**: Starting from the state `(2n, n)`, the algorithm backtracks through the `choice` table to construct the sequence of moves (H or M) that maximizes the total prize.\n5. **Output**: The constructed sequence is printed, ensuring both players have exactly `n` moves and the total prize is maximized.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    n = int(data[0].strip())\n    A_str = data[1].strip()\n\n    total_digits = 2 * n\n\n    # Precompute powers of 10 for exponents up to n-1\n    powers = [10**i for i in range(n)]\n\n    # dp[i][a] will store the maximum total value after processing i digits with a digits for H\n    dp = [[-1] * (n + 1) for _ in range(total_digits + 1)]\n    # choice[i][a] stores whether the last move at position i was H (1) or M (0)\n    choice = [[0] * (n + 1) for _ in range(total_digits + 1)]\n    \n    dp[0][0] = 0\n\n    for i in range(total_digits):\n        for a in range(n + 1):\n            if dp[i][a] == -1:\n                continue\n            if a < n:\n                exp = n - (a + 1)\n                add_value = int(A_str[i]) * (10 ** exp)\n                new_val = dp[i][a] + add_value\n                if dp[i+1][a+1] == -1 or new_val > dp[i+1][a+1]:\n                    dp[i+1][a+1] = new_val\n                    choice[i+1][a+1] = 1\n            if (i - a) < n:\n                exp = n - (i - a)\n                add_value = int(A_str[i]) * (10 ** exp)\n                new_val = dp[i][a] + add_value\n                if dp[i+1][a] == -1 or new_val > dp[i+1][a]:\n                    dp[i+1][a] = new_val\n                    choice[i+1][a] = 0\n\n    result = []\n    i = total_digits\n    a = n\n    while i > 0:\n        c = choice[i][a]\n        result.append('H' if c == 1 else 'M')\n        if c == 1:\n            a -= 1\n        i -= 1\n\n    result.reverse()\n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 420,
        "completion_token_count": 1105,
        "thoughts_token_count": 8191
    }
}