{
    "start": 1758304005.6406696,
    "end": 1758307919.4700363,
    "start-formatted": "2025-09-20 02:46 KST",
    "end-formatted": "2025-09-20 03:51 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\n Okay, we are given a graph with n nodes and m edges. For each edge (u, v), we are given two numbers: gcd and lcm.\n We know that for two numbers a and b (the mushrooms on the two lawns), we have:\n   gcd(a, b) = g, lcm(a, b) = l.\n And the relationship: a * b = g^2 * (l // g)   [Wait, actually: a*b = gcd * (lcm) is not correct? Let's recall: \n Actually, we know that: a * b = gcd(a,b) * lcm(a,b). So yes, a * b = g * l.\n\n However, note that the same lawn might appear in multiple edges. The problem is to assign a positive integer to each lawn (at least 1) such that for every edge (u, v) with given gcd and lcm, the product of the two numbers at u and v is g*l, and the gcd of the two numbers is g, and the lcm is l.\n\n But note: the condition \"gcd(a, b) = g\" and \"lcm(a, b) = l\" must hold. Also, note that from the definition, we have:\n   g divides both a and b, and l is the smallest number divisible by both a and b.\n\n Steps:\n\n 1. For each edge, we can derive the product: a * b = g * l. However, note that g and l must satisfy: g divides l, because g = gcd(a,b) and l = lcm(a,b) implies g * l = a * b, and also g divides l (since g divides a and a divides l, so g divides l). So if g does not divide l, then the edge is invalid.\n\n 2. Moreover, the numbers a and b must be multiples of g. Let a = g * a', b = g * b'. Then the equation becomes: \n        (g*a') * (g*b') = g * l   =>   g * (a' * b' * g) = g * l   =>   g * (g * a' * b') = g * l   =>   g * a' * b' = l.\n    Also, the condition for LCM: \n        lcm(a, b) = lcm(g*a', g*b') = g * lcm(a', b') = l.\n    So we have: lcm(a', b') = l // g.\n\n 3. But note: a' and b' must be such that they are coprime? Not necessarily, but we know that the gcd(a, b) is g, so gcd(a', b') must be 1. Why?\n        gcd(a, b) = g * gcd(a', b') = g => gcd(a', b') = 1.\n\n 4. Therefore, for an edge (u, v) with gcd g and lcm l, we require that g divides l, and then we can set:\n        a = g * a', b = g * b'\n    where a' and b' are coprime positive integers and a' * b' = l // g.\n\n 5. Now, how do we assign values to all lawns?\n    This is a graph labeling problem. We have constraints on the products and the gcds for adjacent nodes.\n\n 6. We can use the following idea:\n\n    Let x_i be the value at node i.\n\n    For an edge (u, v) with gcd g and lcm l, we have:\n        x_u * x_v = g * l   ... (1)\n        and the gcd(x_u, x_v) = g.\n\n    Also, note that g must divide both x_u and x_v.\n\n    We can think of the entire graph and try to assign exponents for the prime factors? However, note that the constraints are up to 10^6.\n\n 7. Alternatively, we can consider the following:\n\n    Since the product of two adjacent nodes is fixed (g*l) and the gcd is fixed, we can factorize the product and the gcd and then distribute the factors appropriately.\n\n 8. However, note that there might be multiple connected components. But the input says that the roads we have are m, and the graph has n nodes.\n\n 9. Another idea: \n\n    We can use the following necessary conditions:\n\n      - For each edge, g divides l. If not, output \"NO\".\n\n      - The product of the two numbers must be g*l.\n\n      - The gcd must be g.\n\n    But how to assign the entire graph?\n\n    Observation: Since the value at a node must be a divisor of the product of its incident edges? Actually, we can consider that for each node, the value must be consistent with all edges.\n\n 10. We can try to do:\n\n     Step 1: Check for each edge that g divides l. If not, return \"NO\".\n\n     Step 2: For each edge, let P = g*l. Then the two numbers must multiply to P, and their gcd is g.\n\n        Note: Since the two numbers are multiples of g, we can write them as g*a and g*b, then a*b = l//g and gcd(a,b)=1.\n\n        So the two numbers are determined by the factorization of l//g into two coprime factors.\n\n        However, there might be more than one way to factorize l//g. But note: the entire graph must be consistent.\n\n 11. We can try to fix a starting node and then propagate the factors.\n\n    However, note: the problem does not require the restoration to be unique. Any arrangement is acceptable.\n\n 12. Steps for solving:\n\n    a) Precompute the prime factorizations? But note that the numbers are up to 10^6, and we have m edges (up to 10^6? actually n<=10^6? but the problem states n and m, but the constraints on n and m are not given. However, note that the input says n and m, and then m lines, so we assume n and m can be large (like up to 10^5 or 10^6).\n\n    b) But note: the example input has small numbers.\n\n    c) Alternative approach:\n\n        Let d[i] be the value at node i.\n\n        Conditions for an edge (u, v) with gcd g and lcm l:\n\n            d[u] * d[v] = g * l   ... (1)\n\n            gcd(d[u], d[v]) = g\n\n        Also, note that d[u] must be divisible by g, and d[v] must be divisible by g.\n\n        Moreover, let d[u] = g * a, d[v] = g * b, then:\n\n            (g*a)*(g*b) = g * l   =>   g * a * b = l / g   ??? Wait, no: from (1): g*a * g*b = g*l -> g^2 * a*b = g*l -> g * a*b = l -> a*b = l/g.\n\n        And gcd(a, b) = 1.\n\n        Now, consider two adjacent edges sharing a node. Suppose node u is connected to v and w.\n\n            For edge (u, v): d[u] * d[v] = g1 * l1, and d[u] = g1 * a1, d[v] = g1 * b1, with gcd(a1, b1)=1.\n\n            For edge (u, w): d[u] * d[w] = g2 * l2, and d[u] = g2 * a2, d[w] = g2 * b2, with gcd(a2, b2)=1.\n\n        Then we have: g1 * a1 = g2 * a2.\n\n        So the value d[u] must be divisible by both g1 and g2, and the ratio must be consistent.\n\n    d) We can set:\n\n        Let ans[i] be the value for node i.\n\n        We can start by assigning a base value for a root node (say node 0). However, we don't know the base.\n\n    e) Another idea: since d[u] must be divisible by the gcd of all edges incident to u? Not exactly, but by the gcd of the gcds of the edges? Actually, the gcd condition is per edge: for each edge (u, v), the gcd of d[u] and d[v] must be the given gcd.\n\n        But note: the gcd of two numbers must be at least the gcd of the two base givens? Actually, the given gcd for an edge is fixed.\n\n        However, consider: if we have two edges from u to v and u to w, then the gcd for (u,v) is g1 and for (u,w) is g2. Then d[u] must be divisible by g1 and g2, because d[u] must be divisible by the gcd of d[u] and d[v] (which is g1) and similarly for d[w]. So d[u] must be divisible by the least common multiple of all the g's from the edges incident to u? Actually, no: the gcd condition for an edge (u, v) is that the gcd of d[u] and d[v] is g1. This does not necessarily imply that d[u] is divisible by g1 only if we consider the edge alone. But note: the gcd condition requires that g1 divides d[u] and d[v]. So yes, d[u] must be divisible by g1, and also by g2, etc. So d[u] must be divisible by the least common multiple of all g's for the edges incident to u? Not exactly: it must be divisible by each g_i (from each edge incident to u). So d[u] must be divisible by the least common multiple of the gcds of the edges incident to u.\n\n        However, wait: the gcd condition for an edge (u, v) is that gcd(d[u], d[v]) = g. This does not require that d[u] is divisible by g? Actually, yes, because if the gcd is g, then g divides both d[u] and d[v]. So for each edge incident to u, d[u] must be divisible by the gcd of that edge.\n\n        So for node u, let G_u = LCM{ g | (u, v) is an edge with gcd g }? Actually, no: we need d[u] to be divisible by each g (from each edge). So d[u] must be divisible by the least common multiple of all the g's for the edges incident to u? Actually, no: the condition is that for each edge (u, v) with gcd g, d[u] must be divisible by g. So d[u] must be divisible by the LCM of all the g's from the edges incident to u? \n\n        Example: \n          Edge1: (u, v) with gcd 4, then d[u] divisible by 4.\n          Edge2: (u, w) with gcd 6, then d[u] divisible by 6.\n          Then d[u] must be divisible by LCM(4,6)=12.\n\n        So yes, we can define for each node u, let R[u] = LCM{ g for each edge incident to u }.\n\n        Then d[u] must be divisible by R[u].\n\n        Then, for an edge (u, v) with gcd g and lcm l, we have:\n\n            d[u] * d[v] = g * l.\n\n        And d[u] is divisible by R[u] (which includes g) and d[v] divisible by R[v] (which includes g). \n\n        Then we can set d[u] = k * R[u]? But note: R[u] is the LCM of the gcds of the edges incident to u, so it is at least the gcd of the edge (u, v) (which is g). But d[u] must be divisible by R[u]. Then for edge (u, v):\n\n            d[u] = (some multiple) * R[u]   -> then d[u] is divisible by R[u] which is divisible by g.\n\n        Similarly, d[v] divisible by R[v] (so by g).\n\n        Then, we have:\n\n            d[u] * d[v] = (multiple_u * R[u]) * (multiple_v * R[v]) = g * l.\n\n        But note: R[u] is divisible by g, and R[v] is divisible by g, so let R[u] = g * a, R[v] = g * b, then:\n\n            (multiple_u * g * a) * (multiple_v * g * b) = g * l\n            => multiple_u * multiple_v * g^2 * a * b = g * l\n            => multiple_u * multiple_v * g * a * b = l\n\n        This seems complicated.\n\n 13. We can try to assign the value for a node by considering the product of the edge conditions.\n\n    However, there is a simpler observation:\n\n        Since for an edge (u, v) we have d[u] * d[v] = g * l, and d[u] must be divisible by the gcd of the edge (which is g) and similarly for d[v], we can set:\n\n            d[u] = g * x, d[v] = (l // g) // x   [but wait, then x must divide (l // g) and also (l//g)//x must be integer, and then we must have gcd(d[u], d[v]) = g * gcd(x, (l//g)//x) = g, so gcd(x, (l//g)//x) must be 1.\n\n        But note: the same node u appears in multiple edges. So the value of x (which is d[u] // g) must be consistent for all edges.\n\n        In fact, for node u, let T[u] be the set of values that d[u]//g must take for each edge. But the same node u is involved in multiple edges.\n\n        For edge (u, v) with gcd g1 and lcm l1, we have:\n\n            d[u] = g1 * a, d[v] = (l1 // g1) // a   (if we set d[u] = g1 * a, then d[v] = (g1 * a * d[v] = g1 * l1) so d[v] = (g1 * l1) / (g1 * a) = l1 / a, and then we require that a divides l1 and gcd(a, l1//a) = 1.\n\n        Similarly, for edge (u, w) with gcd g2 and lcm l2, we have:\n\n            d[u] = g2 * b, and then d[w] = l2 // b, and gcd(b, l2//b)=1.\n\n        Then, we must have: g1 * a = g2 * b.\n\n        So a = (g2 * b) / g1, and a must be an integer.\n\n        This gives a constraint between the two edges.\n\n 14. How to assign? We can do:\n\n        Step 1: For each edge (u, v) with gcd g and lcm l, check that g divides l. If not, return \"NO\".\n\n        Step 2: For each node, we will record the candidate values for d[u] (or the value of d[u]//g0, where g0 is the gcd of the first edge incident to u?).\n\n        However, note that the same node u might have multiple edges, and the gcd for the edges might be different.\n\n        We can use a BFS/DFS and assign the value for a node by one edge and then check consistency with others.\n\n        But the product condition and the gcd condition are global.\n\n 15. Another idea: use the fact that the product condition and the gcd condition are multiplicative. We can work in terms of the prime factorizations.\n\n        Let F(u) = d[u]. Then for an edge (u, v) with gcd g and lcm l, we have:\n\n            F(u) * F(v) = g * l.\n\n        And we know the prime factorizations of g and l.\n\n        Then, for each prime p:\n\n            Let exponent in g: a, in l: b, then in F(u) and F(v): the exponents must add to b, and the minimum exponent in F(u) and F(v) must be a.\n\n        So for prime p:\n\n            Let e_u = exponent in F(u), e_v = exponent in F(v).\n\n            Then: min(e_u, e_v) = a (exponent in g) and e_u + e_v - max(e_u, e_v) = b - a? Actually, the product F(u)*F(v) has exponent b, so e_u + e_v = b (if we ignore the gcd condition)? \n\n        Actually, the gcd condition: the minimum exponent is a, and the maximum exponent is arbitrary, but the product is b.\n\n        Conditions for prime p:\n\n            Let a = exponent of p in g, b = exponent of p in l.\n\n            Then we must have a <= e_u and a <= e_v, and min(e_u, e_v) = a, and e_u + e_v = b? Not exactly, because the product condition is that the sum of exponents is b.\n\n        So: \n            e_u + e_v = b\n            and min(e_u, e_v) = a\n\n        Then, the two exponents must be a and b-a? \n\n        But note: the minimum is a, and the sum is b. Then one exponent is a, and the other is b - a? Then the minimum is a, so we require that a <= b - a? That is, a <= b/2.\n\n        However, consider: what if the exponents are (a, b-a)? Then the minimum is a, and the sum is b. But also, if we have (c, d) such that min(c,d)=a and c+d=b, then without loss of generality, c=a and d=b-a, because if we set the smaller one to a, the larger one is b-a, and then we require a <= b-a, i.e., a <= b/2.\n\n        But wait, what if we have another possibility? Actually, the two exponents must be a and b-a because the sum is b and the minimum is a. So the exponents for p in F(u) and F(v) are fixed: one must be a, the other must be b-a.\n\n        Then, for the entire graph, for each prime p, the assignment of exponents to the nodes must be such that for each edge, the two nodes have exponents (a, b-a) for p (where a is the exponent in g, and b is the exponent in l).\n\n        Then, the problem reduces to: for each prime, we have a graph (the same graph) and we assign to each node an exponent for p such that for each edge, the two endpoints have exponents (a, b-a) (in some order). \n\n        However, note: the same node must have the same exponent for p in every edge incident to it? Actually, the exponent of p in F(u) is fixed for node u, and then for each edge, the condition for p must hold.\n\n        Then, for each edge (u, v) with gcd g and lcm l, for prime p:\n\n            Let a = exponent of p in g, b = exponent of p in l.\n            Then the exponents of p in F(u) and F(v) must be a and b-a (in some order).\n\n        Then, for a fixed prime p, we can build a graph for this prime: the same graph, and for each edge, we have two possible labels: (a, b-a) or (b-a, a). But note: the edge is undirected.\n\n        Then, we can do a DFS/BFS for each prime p to assign the exponents to the nodes, but the entire graph must be consistent.\n\n        However, the number of primes is about 7 (since 10^6 < 2^20, but primes up to 10^6: there are about 100000 primes, but we only need primes that appear in any of the gcds or lcms). But note: the input numbers are up to 10^6, so we can factorize numbers up to 10^6.\n\n        Steps:\n\n            Precomputation: factorize all the gcds and lcms? Actually, we have m edges, and each edge has two numbers (gcd and lcm). The total distinct primes we need is the union of primes in all gcds and lcms.\n\n            Then, for each prime p, we build a graph (actually, we use the original graph) and for each edge, we have two possibilities. Then, we want to assign to each node a single exponent for p (that is fixed) such that for each edge, the two exponents are either (a, b-a) or (b-a, a).\n\n        But note: the same node must have the same exponent for p in every edge incident to it. So we can traverse the graph and assign.\n\n        However, the problem: we have to satisfy for all primes simultaneously. And the value d[u] is the product over primes of p raised to the exponent assigned for that prime.\n\n        This is a system of constraints that is very structured.\n\n        Algorithm for a fixed prime p:\n\n            Let the entire graph be G.\n\n            For each edge (u, v) with gcd g and lcm l, let a = exponent of p in g, b = exponent of p in l.\n\n            Then we require that the exponents of p in F(u) and F(v) are (a, b-a) (in some order). But note: if a != b-a, then the edge (u, v) must have one endpoint with exponent a and the other with exponent b-a.\n\n            However, if a == b-a, then the edge condition is that the exponents must be (a, a). Then we cannot distinguish the two, but note: then the two endpoints must have exponent a.\n\n            Actually, when a = b/2, then the two exponents are both a.\n\n            But note: the condition for the edge is that the minimum exponent is a (which is b/2) and the sum is b (which is 2a). Then the two exponents must be a and a.\n\n            So, for each edge, we have:\n\n                Case 1: a != b-a (i.e., the two exponents are different). Then the two endpoints must have different exponents (a and b-a).\n\n                Case 2: a == b-a (i.e., b=2a). Then the two endpoints must have the same exponent (a).\n\n            Now, we can do:\n\n                For each edge, we have two possibilities if the two exponents are different, but if the two exponents are the same then no choice.\n\n            Then, we can use a graph coloring-like approach for each prime p:\n\n                We create a graph where each edge is either:\n\n                    Type 0: (same exponent required) then the two nodes must have the same exponent.\n\n                    Type 1: (different exponent required) then the two nodes must have different exponents.\n\n            But note: the entire graph must be bipartite for the different-type edges? Actually, the different-type edges form a graph that must be bipartite (if we assign 0 and 1 to the two exponents, then edges of type 1 connect 0 and 1, and edges of type 0 connect same). But wait, we have two fixed exponents: a and b-a. We don't care about the actual value, just the relative difference.\n\n            However, the catch: the same node must have the same exponent for p in all edges. So for the entire graph, we must assign to each node either a or b-a (if the edge is of type 1) and for type 0 edges, the two nodes must be assigned the same (which could be either a or b-a). But note: the value of the exponent for p is determined by the prime factorization and must be nonnegative integers.\n\n            Actually, the exponent for p in F(u) must be either a or b-a (if the edge is present and the prime p divides the gcd or lcm). But wait, what if the prime p does not divide the gcd? Then a=0, and then the condition is that the two exponents must be 0 and b (since b is the exponent in l). But note: if p divides l (so b>=1) but not g (so a=0), then the condition is that one exponent is 0 and the other is b. Then we have two possibilities: (0, b) or (b,0). \n\n            However, note: the condition for the edge is that the gcd is g (which does not have p) so the minimum exponent must be 0, and the product has exponent b, so the exponents must be (0, b) or (b,0). \n\n            Similarly, if p divides g (a>=1) then the minimum exponent must be a (so at least a) and the product is b, so the exponents are (a, b-a) or (b-a, a). But note: if a > b/2, then b-a < a, so the minimum would be b-a, not a. But wait: the condition is that the minimum is a. So if a > b/2, then we cannot have an edge with gcd having exponent a and lcm having exponent b (because then the minimum exponent would be min(a, b-a) = b-a, which is less than a, contradicting the gcd condition). \n\n            Therefore, for an edge (u, v) and prime p, we require that a <= b/2. Otherwise, the edge is invalid.\n\n        So step for prime p and edge (u, v) with gcd g and lcm l:\n\n            Let a = exponent of p in g, b = exponent of p in l.\n\n            Condition: a <= b/2 must hold. If not, then this edge is impossible -> return \"NO\".\n\n            Then, the exponents for p in F(u) and F(v) must be either (a, b-a) or (b-a, a).\n\n        Now, we can build for prime p:\n\n            We'll create an array exp[u] for each node u, which is initially unknown (or None).\n\n            Then, for each edge (u, v) with gcd g and lcm l (and for prime p, we have a and b):\n\n                If we know one of the exponents, then we can deduce the other.\n\n                If not, then we set:\n\n                    If a == b-a (so b=2a), then we must assign the same exponent (a) to both u and v. But note: if we haven't assigned, then we assign a to both.\n\n                    Else (a != b-a), then we have two possibilities. But we need to assign consistently.\n\n            However, we can use union-find or BFS to assign the exponents for the entire graph for prime p.\n\n            Steps for prime p:\n\n                Let's create two sets: S0 and S1 (for the two exponents: a and b-a). But note: the graph may be disconnected.\n\n                We traverse the graph (each connected component) and assign:\n\n                    For each edge (u, v) that is of type 'same' (when a==b-a) then we force u and v to have the same exponent.\n\n                    For edges of type 'different' (a != b-a) then we force u and v to have different exponents.\n\n                But note: the entire graph must be consistent.\n\n                We can do:\n\n                    Let comp = connected component for the graph (ignoring direction) for prime p.\n\n                    We'll maintain a dictionary for the component: we don't need the actual exponent, just the relative assignment (like in a bipartite graph).\n\n                    However, the same prime p: the two exponents are fixed: let them be x and y (with x+y=b and min(x,y)=a). Then the two exponents are fixed and known.\n\n                    We can do:\n\n                        Let d[u] be the exponent for node u for prime p. Initially, we don't know.\n\n                        For an edge (u, v) with parameters (a, b):\n\n                            If we know d[u] and d[v] is unknown, then set d[v] = b - d[u] (if d[u] is a, then d[v] should be b-a; if d[u] is b-a, then d[v] should be a). But wait: the condition is that the edge requires one to be a and the other b-a. So if d[u] is a, then d[v] must be b-a; if d[u] is b-a, then d[v] must be a. If d[u] is neither, then we cannot determine.\n\n                        But note: we have two fixed values: a and b-a.\n\n                        We can use:\n\n                            For each edge, we have a constraint: {d[u], d[v]} = {a, b-a}\n\n                        Then, we can do:\n\n                            For each connected component (for prime p, we consider the entire graph? Or we can consider the graph built by including only edges that have p dividing either gcd or lcm? Actually, if p does not divide g or l, then a=0 and b=0, then we don't care? Actually, if p doesn't divide g and doesn't divide l, then a=0, b=0, and the condition is automatically satisfied (exponents 0 for both) but we don't need to consider such edges for prime p? \n\n                        However, note: if p doesn't divide the gcd, then the condition is that the minimum exponent is 0 and the product exponent is 0 (if b=0) then both exponents must be 0. But if b>0, then one exponent is 0 and the other is b.\n\n                        Actually, we must consider every edge that has p in its factorization (i.e., g or l is divisible by p). \n\n                        Steps for prime p:\n\n                            Build a graph for prime p: include an edge (u, v) if the edge's gcd or lcm is divisible by p.\n\n                            For each edge (u, v) in the graph for p, we have a and b (exponents of p in g and l).\n\n                            Then, we require a<=b/2 and then the exponents must be (a, b-a) (in some order).\n\n                        Then, we can use a BFS/DFS for the graph for prime p to assign the two values (a and b-a) to the nodes.\n\n                        We'll assign two values: let value0 = a, value1 = b-a.\n\n                        Then, for an edge (u, v) with parameters (a, b):\n\n                            If the edge is of type 'same' (a==b-a), then we require d[u] == d[v] (both must be a).\n\n                            If the edge is of type 'different' (a != b-a), then we require d[u] != d[v] (one is a, the other is b-a).\n\n                        Then, we can do:\n\n                            Use a BFS and assign:\n\n                                Start with a node, assign it value0 (a) arbitrarily.\n\n                                Then, for each neighbor:\n\n                                    If the edge is of type 'same', then the neighbor must get the same value.\n\n                                    If the edge is of type 'different', then the neighbor must get the opposite value.\n\n                        Then, check for consistency.\n\n            However, note: the graph for prime p might have multiple connected components.\n\n            Then, after processing all primes, the value for a node u is the product over primes p of (p raised to the exponent assigned for u and p).\n\n        But wait: is this valid? \n\n            Consider: the product condition: for an edge (u, v) with gcd g and lcm l, we have:\n\n                d[u] * d[v] = g * l.\n\n            We have broken down the condition by primes: for each prime p, the exponents in d[u] and d[v] must be (a, b-a) (in some order). Then the product for p is p^(a+(b-a)) = p^b, which matches the exponent in l. And the gcd for p is min(a, b-a) = a (since we have the condition a<=b/2, so a<=b-a) which matches the exponent in g.\n\n            So the condition is satisfied.\n\n        Steps for the entire solution:\n\n            Step 1: Precompute the list of primes that appear in any of the gcds or lcms.\n\n            Step 2: For each edge, check that for every prime p that divides the gcd or the lcm, the condition a<=b/2 holds (where a = exponent of p in g, b = exponent of p in l). If not, output \"NO\".\n\n            Step 3: For each prime p, build a graph (only the edges that involve p, i.e., the edge's gcd or lcm is divisible by p) and then do a BFS/DFS to assign the two values (a and b-a) to the nodes. Remember: for an edge, the two exponents must be (a, b-a) (and we don't care which is which, but the relative assignment must be consistent).\n\n            Step 4: After assigning exponents for all primes, compute for each node u: \n                    d[u] = product_{p} (p ^ exponent[u][p])\n\n            Step 5: Then, we must verify the edge conditions (to be safe, but the problem does not require the particular assignment, but the conditions were used). However, the problem says \"any one\", so we can output the assignment.\n\n        But note: the condition a<=b/2 for each edge and prime p must hold. We already checked that.\n\n        However, there is one more condition: the value d[u] must be an integer and positive. Since exponents are nonnegative, that's fine.\n\n        But wait: what if the graph for prime p is disconnected? Then we can assign arbitrarily the starting node's value (either a or b-a) for each connected component. However, the condition must hold for all edges. But note: the assignment is independent for each prime.\n\n        Implementation details:\n\n            Factorizing up to 10^6 for m edges (each edge has two numbers: gcd and lcm) and then building graphs for each prime? \n\n            The total distinct primes might be large, but note: the numbers are up to 10^6, so the total distinct primes in all numbers is about the primes up to 10^6, which is ~10000. However, we only consider primes that appear in at least one gcd or lcm.\n\n            But m can be up to 10^6, so the total factorization work might be heavy.\n\n        Alternatively, we can:\n\n            Precompute the smallest prime factor (spf) for numbers up to 10^6.\n\n            Then, for each edge, factorize g and l (two numbers per edge) to get the exponents for each prime.\n\n            But the total number of edges is m, and each factorization of a number up to 10^6 takes O(log n). So worst-case m=10^6, then we factorize 2e6 numbers, which is acceptable in C++ but in Python we must be careful.\n\n            However, we can precompute the factorization for all numbers from 1 to 10^6? That is, build a spf array for 10^6.\n\n            Then, for a given number x, we can factorize quickly.\n\n        Steps:\n\n            Precomputation:\n\n                Build an array spf[0..max_val] (max_val=10^6) such that spf[i] is the smallest prime factor of i.\n\n            Then, for each edge, for g and l, we factorize using spf.\n\n            Then, for each prime p that appears in any factorization, we build a graph (actually, we don't need to build the graph explicitly for each prime, but we can iterate over the edges and for each prime that divides g or l, we record the edge and the exponents (a, b)).\n\n            Then, for each prime p, we gather all edges that have p in g or l.\n\n            Then, we build a graph for prime p: nodes are the lawns that appear in these edges.\n\n            Then, we traverse the graph (for prime p) and assign the exponents.\n\n        However, note: the same lawn might appear in multiple edges for the same prime, and we must assign the same exponent to the same node.\n\n        Steps for prime p:\n\n            Let E_p = list of edges (u, v, a, b) for which p divides g (so a>=1) or p divides l (so b>=1). Note: if p divides g, then a>=1, and if p divides l, then b>=1.\n\n            But note: even if p does not divide g, we still have a=0, and then we require that the edge condition for p is that the exponents are (0, b). Then we must consider the edge.\n\n            So we include every edge that has p in g or p in l.\n\n            Then, for each node u, we consider the edges incident to u in E_p.\n\n            Then, we do:\n\n                Let color[u] = None for each node u.\n\n                For each connected component in the graph (nodes appearing in E_p):\n\n                    Pick a node r, and set color[r] = 0 (meaning the exponent is a) [Note: a is the exponent in g, and the other exponent is b-a]. But wait: what if the edge has a=0 (then we don't know the base value)? Actually, the two exponents are fixed: the two exponents are a and b-a (with a=0, then the two exponents are 0 and b). \n\n                    Then, for each neighbor v of u in the graph for p:\n\n                        Let (a, b) = the exponents for the edge (u, v). \n\n                        If the edge is of type 'same' (a==b-a), then the neighbor v must have the",
    "response": "\nTo solve this problem, we need to determine if it's possible to restore the number of mushrooms on each lawn in a forest based on given roads, each annotated with the greatest common divisor (GCD) and least common multiple (LCM) of the mushroom counts on the connected lawns. The solution involves verifying the consistency of these GCD and LCM values across all edges and then reconstructing the mushroom counts if possible.\n\n### Approach\n1. **Problem Analysis**: The problem requires assigning positive integers to each node (lawn) such that for every edge (road), the product of the node values equals the product of the GCD and LCM provided, and the GCD of the two node values matches the given GCD. \n\n2. **Key Insight**: For each edge, the given GCD and LCM must satisfy that the GCD divides the LCM. Additionally, the prime factorization of the GCD and LCM must allow the node values to be consistent across all edges. Specifically, for each prime factor, the exponents in the GCD and LCM must satisfy certain conditions to ensure the node values can be derived.\n\n3. **Algorithm Selection**:\n   - **Precompute Smallest Prime Factors (SPF)**: This helps in efficiently factorizing numbers up to 10^6.\n   - **Check Edge Validity**: For each edge, verify that the GCD divides the LCM. If not, the solution is impossible.\n   - **Prime Factorization Handling**: For each prime factor involved in any GCD or LCM, ensure that the exponents in the GCD and LCM meet the condition where the exponent in the GCD is at most half the exponent in the LCM.\n   - **Graph Coloring for Consistency**: For each prime factor, model the problem as a graph where nodes must be assigned one of two possible exponents (based on the GCD and LCM exponents). Use BFS to propagate these assignments and check for consistency.\n\n4. **Complexity Analysis**: The solution involves factorizing numbers up to 10^6, which is feasible with precomputed SPF arrays. The overall complexity is dominated by the factorization step and the BFS traversal for each prime factor, which is manageable given the constraints.\n\n### Solution Code\n```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef build_spf(n):\n    spf = list(range(n+1))\n    for i in range(2, int(n**0.5)+1):\n        if spf[i] == i:\n            for j in range(i*i, n+1, i):\n                if spf[j] == j:\n                    spf[j] = i\n    return spf\n\ndef factorize_with_spf(x, spf):\n    factors = {}\n    while x > 1:\n        p = spf[x]\n        cnt = 0\n        while spf[x] == p:\n            cnt += 1\n            x //= p\n        factors[p] = cnt\n    return factors\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"NO\")\n        return\n    \n    it = iter(data)\n    n = int(next(it)); m = int(next(it))\n    \n    edges = []\n    for _ in range(m):\n        u = int(next(it)) - 1\n        v = int(next(it)) - 1\n        g_val = int(next(it))\n        l_val = int(next(it))\n        edges.append((u, v, g_val, l_val))\n    \n    max_val = 10**6\n    spf_arr = build_spf(max_val)\n    \n    valid_edges = True\n    for u, v, g_val, l_val in edges:\n        if g_val > l_val:\n            valid_edges = False\n            break\n        if l_val % g_val != 0:\n            valid_edges = False\n            break\n            \n    if not valid_edges:\n        print(\"NO\")\n        return\n        \n    all_numbers = set()\n    for u, v, g_val, l_val in edges:\n        all_numbers.add(g_val)\n        all_numbers.add(l_val)\n        \n    primes_set = set()\n    for num in all_numbers:\n        temp = num\n        while temp > 1:\n            p = spf_arr[temp]\n            primes_set.add(p)\n            while temp % p == 0:\n                temp //= p\n                \n    prime_edges = defaultdict(list)\n    for (u, v, g_val, l_val) in edges:\n        factors_g = factorize_with_spf(g_val, spf_arr)\n        factors_l = factorize_with_spf(l_val, spf_arr)\n        for p in set(factors_g.keys()) | set(factors_l.keys()):\n            if p not in factors_g:\n                exp_g = 0\n            else:\n                exp_g = factors_g[p]\n            if p not in factors_l:\n                exp_l = 0\n            else:\n                exp_l = factors_l[p]\n            if exp_g > exp_l // 2:\n                print(\"NO\")\n                return\n            prime_edges[p].append((u, v, exp_g, exp_l))\n            \n    node_exponents = {}\n    for p, edges_p in prime_edges.items():\n        graph = defaultdict(list)\n        node_set = set()\n        for (u, v, exp_g, exp_l) in edges_p:\n            node_set.add(u)\n            node_set.add(v)\n            if exp_g == exp_l - exp_g:\n                graph[u].append((v, 'same'))\n                graph[v].append((u, 'same'))\n            else:\n                graph[u].append((v, 'diff'))\n                graph[v].append((u, 'diff'))\n                \n        comp_nodes = defaultdict(list)\n        visited = set()\n        for node in node_set:\n            if node not in visited:\n                stack = [node]\n                visited.add(node)\n                while stack:\n                    cur = stack.pop()\n                    for neighbor, typ in graph[cur]:\n                        if neighbor not in visited:\n                            visited.add(neighbor)\n                            stack.append(neighbor)\n                comp_nodes[node].extend(visited - {node})\n                \n        for comp in comp_nodes.values():\n            color_map = {}\n            q = deque()\n            start_node = comp[0]\n            color_map[start_node] = 0\n            q.append(start_node)\n            while q:\n                node = q.popleft()\n                for neighbor, typ in graph[node]:\n                    if typ == 'same':\n                        if neighbor not in color_map:\n                            color_map[neighbor] = color_map[node]\n                            q.append(neighbor)\n                        elif color_map[neighbor] != color_map[node]:\n                            print(\"NO\")\n                            return\n                    else:\n                        if neighbor not in color_map:\n                            color_map[neighbor] = 1 - color_map[node]\n                            q.append(neighbor)\n                        elif color_map[neighbor] == color_map[node]:\n                            print(\"NO\")\n                            return\n            for node in comp:\n                if node not in node_exponents:\n                    node_exponents[node] = {}\n                node_exponents[node][p] = 0 if color_map.get(node, 0) == 0 else (exp_l - exp_g)\n                    \n    ans = [1] * n\n    for p, edges_p in prime_edges.items():\n        for (u, v, exp_g, exp_l) in edges_p:\n            if u in node_exponents and p in node_exponents[u]:\n                exp_u = node_exponents[u][p]\n            else:\n                exp_u = 0\n            if v in node_exponents and p in node_exponents[v]:\n                exp_v = node_exponents[v][p]\n            else:\n                exp_v = 0\n            if u < n:\n                ans[u] *= (p ** exp_u)\n            if v < n:\n                ans[v] *= (p ** exp_v)\n                \n    for i in range(n):\n        while ans[i] < 1:\n            ans[i] = 1\n            \n    print(\"YES\")\n    print(\" \".join(map(str, ans)))\n    \nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Precompute Smallest Prime Factors (SPF)**: The `build_spf` function constructs an array where each entry at index `i` contains the smallest prime factor of `i`. This aids in efficient factorization of numbers up to 10^6.\n\n2. **Edge Validation**: The code checks if the given GCD divides the LCM for each edge. If not, the solution is immediately deemed impossible.\n\n3. **Prime Factorization Handling**: For each number (GCD or LCM), the code factorizes it using the SPF array. It ensures that for each prime factor, the exponent in the GCD does not exceed half the exponent in the LCM, which is crucial for the solution's feasibility.\n\n4. **Graph Coloring for Consistency**: For each prime factor, the problem is modeled as a graph where nodes (lawns) must be assigned exponents (either the GCD exponent or the LCM minus the GCD exponent). BFS is used to propagate these assignments, ensuring consistency across all edges.\n\n5. **Result Construction**: After processing all primes, the mushroom counts are reconstructed by multiplying the respective prime powers. The solution outputs \"YES\" along with the counts if feasible; otherwise, it outputs \"NO\".\n\nThis approach efficiently checks the feasibility of the mushroom count assignment and constructs a valid solution if possible, leveraging prime factorization and graph traversal techniques.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import defaultdict, deque\n\ndef build_spf(n):\n    spf = list(range(n+1))\n    for i in range(2, int(n**0.5)+1):\n        if spf[i] == i:\n            for j in range(i*i, n+1, i):\n                if spf[j] == j:\n                    spf[j] = i\n    return spf\n\ndef factorize_with_spf(x, spf):\n    factors = {}\n    while x > 1:\n        p = spf[x]\n        cnt = 0\n        while spf[x] == p:\n            cnt += 1\n            x //= p\n        factors[p] = cnt\n    return factors\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"NO\")\n        return\n    \n    it = iter(data)\n    n = int(next(it)); m = int(next(it))\n    \n    edges = []\n    for _ in range(m):\n        u = int(next(it)) - 1\n        v = int(next(it)) - 1\n        g_val = int(next(it))\n        l_val = int(next(it))\n        edges.append((u, v, g_val, l_val))\n    \n    max_val = 10**6\n    spf_arr = build_spf(max_val)\n    \n    valid_edges = True\n    for u, v, g_val, l_val in edges:\n        if g_val > l_val:\n            valid_edges = False\n            break\n        if l_val % g_val != 0:\n            valid_edges = False\n            break\n            \n    if not valid_edges:\n        print(\"NO\")\n        return\n        \n    all_numbers = set()\n    for u, v, g_val, l_val in edges:\n        all_numbers.add(g_val)\n        all_numbers.add(l_val)\n        \n    primes_set = set()\n    for num in all_numbers:\n        temp = num\n        while temp > 1:\n            p = spf_arr[temp]\n            primes_set.add(p)\n            while temp % p == 0:\n                temp //= p\n                \n    prime_edges = defaultdict(list)\n    for (u, v, g_val, l_val) in edges:\n        factors_g = factorize_with_spf(g_val, spf_arr)\n        factors_l = factorize_with_spf(l_val, spf_arr)\n        for p in set(factors_g.keys()) | set(factors_l.keys()):\n            if p not in factors_g:\n                exp_g = 0\n            else:\n                exp_g = factors_g[p]\n            if p not in factors_l:\n                exp_l = 0\n            else:\n                exp_l = factors_l[p]\n            if exp_g > exp_l // 2:\n                print(\"NO\")\n                return\n            prime_edges[p].append((u, v, exp_g, exp_l))\n            \n    node_exponents = {}\n    for p, edges_p in prime_edges.items():\n        graph = defaultdict(list)\n        node_set = set()\n        for (u, v, exp_g, exp_l) in edges_p:\n            node_set.add(u)\n            node_set.add(v)\n            if exp_g == exp_l - exp_g:\n                graph[u].append((v, 'same'))\n                graph[v].append((u, 'same'))\n            else:\n                graph[u].append((v, 'diff'))\n                graph[v].append((u, 'diff'))\n                \n        comp_nodes = defaultdict(list)\n        visited = set()\n        for node in node_set:\n            if node not in visited:\n                stack = [node]\n                visited.add(node)\n                while stack:\n                    cur = stack.pop()\n                    for neighbor, typ in graph[cur]:\n                        if neighbor not in visited:\n                            visited.add(neighbor)\n                            stack.append(neighbor)\n                comp_nodes[node].extend(visited - {node})\n                \n        for comp in comp_nodes.values():\n            color_map = {}\n            q = deque()\n            start_node = comp[0]\n            color_map[start_node] = 0\n            q.append(start_node)\n            while q:\n                node = q.popleft()\n                for neighbor, typ in graph[node]:\n                    if typ == 'same':\n                        if neighbor not in color_map:\n                            color_map[neighbor] = color_map[node]\n                            q.append(neighbor)\n                        elif color_map[neighbor] != color_map[node]:\n                            print(\"NO\")\n                            return\n                    else:\n                        if neighbor not in color_map:\n                            color_map[neighbor] = 1 - color_map[node]\n                            q.append(neighbor)\n                        elif color_map[neighbor] == color_map[node]:\n                            print(\"NO\")\n                            return\n            for node in comp:\n                if node not in node_exponents:\n                    node_exponents[node] = {}\n                node_exponents[node][p] = 0 if color_map.get(node, 0) == 0 else (exp_l - exp_g)\n                    \n    ans = [1] * n\n    for p, edges_p in prime_edges.items():\n        for (u, v, exp_g, exp_l) in edges_p:\n            if u in node_exponents and p in node_exponents[u]:\n                exp_u = node_exponents[u][p]\n            else:\n                exp_u = 0\n            if v in node_exponents and p in node_exponents[v]:\n                exp_v = node_exponents[v][p]\n            else:\n                exp_v = 0\n            if u < n:\n                ans[u] *= (p ** exp_u)\n            if v < n:\n                ans[v] *= (p ** exp_v)\n                \n    for i in range(n):\n        while ans[i] < 1:\n            ans[i] = 1\n            \n    print(\"YES\")\n    print(\" \".join(map(str, ans)))\n    \nif __name__ == '__main__':\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 553,
        "completion_token_count": 1987,
        "thoughts_token_count": 8191
    }
}