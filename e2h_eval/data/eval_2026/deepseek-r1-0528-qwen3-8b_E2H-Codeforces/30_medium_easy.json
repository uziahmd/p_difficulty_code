{
    "start": 1758308460.137721,
    "end": 1758311911.4009147,
    "start-formatted": "2025-09-20 04:01 KST",
    "end-formatted": "2025-09-20 04:58 KST",
    "gpu": 2,
    "pid": 30,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# TV Game\n\nThere is a new TV game on BerTV. In this game two players get a number A consisting of 2n digits. Before each turn players determine who will make the next move. Each player should make exactly n moves. On it's turn i-th player takes the leftmost digit of A and appends it to his or her number Si. After that this leftmost digit is erased from A. Initially the numbers of both players (S1 and S2) are «empty». Leading zeroes in numbers A, S1, S2 are allowed. In the end of the game the first player gets S1 dollars, and the second gets S2 dollars.One day Homer and Marge came to play the game. They managed to know the number A beforehand. They want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize. Help them.\n\n## Input\nThe first line contains integer n (1 ≤ n ≤ 18). The second line contains integer A consisting of exactly 2n digits. This number can have leading zeroes.\n\n## Output\nOutput the line of 2n characters «H» and «M» — the sequence of moves of Homer and Marge, which gives them maximum possible total prize. Each player must make exactly n moves. If there are several solutions, output any of them.\n\n## Example\n### Input\n['2\\n1234', '2\\n9911']\n\n### Output\n['HHMM', 'HMHM']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\n Okay, we are given an integer n and a string A of 2n digits.\n We have two players: Homer (H) and Marge (M). Each makes exactly n moves.\n On each move, the leftmost digit is taken and appended to the respective player's number.\n\n The goal is to choose a sequence of moves (a string of length 2n containing n 'H's and n 'M's) such that the total prize (the sum of the two numbers S1 and S2) is maximized.\n\n Note: The game proceeds by removing the leftmost digit from A on each turn. The catch: we can decide which player takes the digit at each step.\n\n How to think?\n Let the entire process be represented by a sequence of moves: a string s of length 2n with exactly n 'H' and n 'M'.\n\n At step i (0-indexed), the digit d_i = A[i] is assigned to either H or M.\n\n However, note that the value of a player's number depends on the order in which the digits are received.\n\n Specifically, if Homer collects the digits in positions i_1, i_2, ..., i_n (in increasing order, because the leftmost is taken first) then his number S1 is:\n   S1 = d_{i_1} * 10^(n-1) + d_{i_2} * 10^(n-2) + ... + d_{i_n} * 10^0\n\n Similarly for Marge.\n\n But note: the sequence of moves does not necessarily assign the k-th move (from the beginning) to one player; it assigns the next available digit (which is the one that has been left in A at that time) to a player.\n\n However, the key is: the assignment must be consistent with the removal of the digits from the left. The entire process is:\n\n   Start with the string A (of length 2n). Then, for each move (each character in our output sequence):\n\n        - If the current move is H, then take the first character of A, assign it to H, then remove it from A.\n        - Similarly for M.\n\n So the two numbers are built by interleaving the digits from A.\n\n But note: the digits are fixed in order. The only choice is which player gets the next digit (until we have assigned n to each).\n\n How do we maximize the total prize?\n\n Total prize = S1 + S2.\n\n Since the digits are fixed and the positions are fixed, we can consider:\n\n   Let the entire set of digits be D[0], D[1], ... , D[2n-1].\n\n   In the final assignment, each digit goes to either H or M.\n\n   However, the value of a digit depends on when it was taken. Specifically, the first digit (D0) will always be the most significant in its assigned number (if assigned to H, then it becomes the first digit of S1; similarly for M). But note: the second digit (D1) might become the second most significant for one of them, unless the first digit was taken by the other, then D1 would be the most significant for the one who took it.\n\n Actually, the significance is determined by the position in the original string and the order of assignment. However, we can also note:\n\n   The first n digits of the original string (if we assign all to one player) would form a very large number (with n digits) but if we assign some to the other, then we break the continuity.\n\n Alternate approach:\n\n   We want to maximize the two numbers. But note: the total prize is the sum.\n\n   Consider: if we assign a digit to a player, then that digit will be placed at a certain position (from the most significant to least) in that player's number.\n\n   However, we cannot change the order of the digits (they appear in the string from left to right). The catch is: the assignment must use the digits in the order of the string.\n\n   We can model this as: we are going to split the 2n-digit string into two subsequences (each of length n) without changing the relative order.\n\n   Then, the value of H's number is the base-10 interpretation of the subsequence of digits assigned to H (taken in order) and similarly for M.\n\n   And we want to maximize H_value + M_value.\n\n How to solve?\n\n   Since n is at most 18 (so the total digits is 36), we cannot iterate over all sequences (which would be C(36,18) ~ 9e9) in the worst-case.\n\n   We need a smarter way.\n\n   Observation: We have two numbers, and we want to maximize their sum.\n\n   Another observation: the two numbers are built from contiguous segments? No, they are interleaved arbitrarily (but preserving the original order). However, the positions in the two numbers are fixed: the earliest digit assigned to a player becomes the most significant.\n\n   We can use dynamic programming:\n\n   Let dp[i][j][k] be the maximum total sum we can achieve after processing the first i+j digits (so we have assigned i digits to H and j digits to M) and we have built two numbers: H's number has i digits and M's number has j digits.\n\n   However, we also need to know the actual digits that have been assigned to each and the positions they will hold. But wait: the digits are fixed and known.\n\n   Alternatively, note that the total sum is independent of the order of assignment? Actually no, because the same digit in a higher position (earlier in the string) is more valuable.\n\n   But here's the catch: the digit at position p (0-indexed) will be multiplied by 10^(n - count) where count is the number of digits assigned to that player from the remaining ones? Actually, we don't know the exact power until we know how many digits are left.\n\n   However, we can precompute the contribution of each digit if it is assigned to H or M at a certain time.\n\n   But note: the assignment must be in increasing order of the index. So if we assign a digit at index i to H, then the digit at index j (with j>i) can be assigned to H later, so the digit at i will be in a more significant position than the digit at j.\n\n   Therefore, the value of a digit is determined by the time (position) at which it is assigned and the total number of digits that will be assigned to the same player after it.\n\n   Specifically, if a digit is assigned to H at the k-th move (0-indexed, so the first move is k=0) then it will be the (k+1)-th digit in H's number (so the exponent is (n - 1 - k) if we were building the entire number? Actually, no: the assignment is in the order of the string. But note: the move order is the same as the order of the string: the first move uses the first digit, the second move uses the second digit, etc.\n\n   However, wait: the moves are interleaved. The first move is the first digit, the second move is the second digit, regardless of which player takes it. So the digit at position i is always the (i+1)-th digit in the entire sequence of moves.\n\n   But the assignment to a player breaks the continuity. For example, if we have the string \"1234\" and n=2, and we assign:\n\n        Move1: H -> takes '1'\n        Move2: M -> takes '2'\n        Move3: H -> takes '3'\n        Move4: M -> takes '4'\n\n   Then H's number is \"13\", which is 1*10 + 3 = 13.\n   M's number is \"24\", which is 2*10 + 4 = 24.\n\n   But if we assign:\n\n        Move1: H -> '1'\n        Move2: H -> '2'\n        Move3: M -> '3'\n        Move4: M -> '4'\n\n   Then H's number is \"12\" (12) and M's number is \"34\" (34). Then total is 46.\n\n   Now, if we assign:\n\n        Move1: M -> '1'\n        Move2: H -> '2'\n        Move3: M -> '3'\n        Move4: H -> '4'\n\n   Then H's number is \"24\", M's number is \"13\", total is 24+13=37.\n\n   So the value of a digit is not independent of the other assignments. Actually, the digit at position i (0-indexed) is the (i+1)-th digit in the entire sequence. When we assign a digit to a player, it will be placed in that player's number at the position corresponding to the number of moves that player has already made.\n\n   However, note: the entire sequence of moves uses the digits in order. The digit at position i is used at move i (because we remove the leftmost each time). But the assignment to the players can be arbitrary (with exactly n moves per player).\n\n   Therefore, the two numbers are built by taking the digits at the indices where H moves occur (in order) and similarly for M.\n\n   Let H_moves = [i0, i1, ..., i_{n-1}] (in increasing order) and M_moves = [j0, j1, ..., j_{n-1}] (in increasing order).\n\n   Then the value of H's number is: \n        H_value = d_{i0} * 10^(n-1) + d_{i1} * 10^(n-2) + ... + d_{i_{n-1}} * 10^0\n\n   Similarly for M.\n\n   So the total is: \n        Total = d_{i0} * 10^(n-1) + d_{i1} * 10^(n-2) + ... + d_{i_{n-1}} * 10^0 + d_{j0} * 10^(n-1) + ... \n\n   Now, note: the exponents for the same digit depend on the order in which they are collected for the same player. The earlier the digit is taken (the lower the index) the more significant it is.\n\n   But the problem is: we can choose the assignment arbitrarily (as long as we use each digit exactly once and each player gets n digits). However, the constraint is that the moves are in the order of the digits: we cannot assign a digit to a player before we have removed the previous ones (so the indices must be increasing).\n\n   This is equivalent to: we are going to partition the set {0,1,...,2n-1} into two subsets of size n, and the value of the total is computed as above.\n\n   How to compute the maximum total?\n\n   We can use DP with state (i, j) where i = number of digits assigned to H so far, j = number of digits assigned to M so far, and we are at the digit index pos = i+j (because we have processed i+j digits). But we need to know the positions of the digits we've assigned to H and M to compute the exponents.\n\n   Alternatively, we can precompute the value of assigning a digit at position k to a player that currently has x digits (so it will be the (x+1)-th digit for that player, hence exponent (n - (x+1))).\n\n   However, we don't know the future. But note: the entire assignment is independent of the order of moves? Actually, the moves are forced: we must use the digits in order. So the decision is: at each step (from left to right) we decide which player takes the digit.\n\n   We can do DP over the index (from 0 to 2n) and the counts of moves for H and M.\n\n   Let dp[i][h][m] = maximum total sum we can get from the digits from index i to the end, having already assigned h digits to H and m digits to M (so we have used up h+m digits so far). But we are at the beginning of the string, so we haven't used any.\n\n   Alternatively, let dp[i][h] = the maximum total sum from the remaining part (from index i to 2n-1) given that H has h moves and M has (n - m) ??? Not straightforward.\n\n   Alternatively, we can do:\n\n   We are going to assign the digits from left to right. We have two players, and we know that we must assign n to each.\n\n   Let f(i, h, m) be the maximum total value we can get from the suffix starting at index i, given that H has already made h moves and M has made m moves.\n\n   Then, at index i, we can assign the digit to H if h < n, and then the value for H is: digit[i] * (10^(n-h-1)) [because after this move, H will have h+1 moves, so this digit is the (h+1)-th digit for H, which is at exponent (n - (h+1))] and then we add the value from the rest.\n\n   Similarly, we can assign to M if m < n.\n\n   But note: the entire number for H will have n digits, so the first digit (the one at the smallest index) gets the highest power (10^(n-1)). The second gets 10^(n-2), etc.\n\n   However, in our DP state, we don't know the entire history, but we know how many digits have been assigned to H so far. Then the next digit assigned to H will be the next one (in terms of the entire string) and it will be the (h+1)-th digit for H, so its power is 10^(n - h - 1).\n\n   But wait: what if we assign a digit from the beginning to H, then the next digit (even if we assign it to M) doesn't change the power of the first H digit? Actually, no. The power of the first H digit is fixed: it is the most significant digit. The subsequent digits in H's number are less significant.\n\n   However, note: the digits we assign to H must be taken in increasing order of their index. So the digit we assign to H now (at index i) will be the (h+1)-th digit of H's number, meaning that there will be (n - h - 1) digits after it in H's number. Therefore, its value is digit[i] * (10^(n - h - 1)).\n\n   Similarly, for M, if we assign the digit at index i to M, then its value is digit[i] * (10^(n - m - 1)).\n\n   Then, the recurrence:\n\n   dp[i][h][m] = \n        if h == n and m == n: 0   (base case)\n        else:\n            option1: if h < n, then assign current digit to H: \n                value_H = int(A[i]) * (10**(n - h - 1))\n                then we have to account for the rest: the remaining digits (from i+1 to the end) will be assigned arbitrarily, but note: the rest of the moves for H and M are independent? Actually, no: the remaining part has to be assigned with (h+1, m) and we can use the same logic.\n\n            Similarly, option2: if m < n, then assign to M:\n                value_M = int(A[i]) * (10**(n - m - 1))\n\n   Then, dp[i][h][m] = max( \n        (value_H + dp[i+1][h+1][m]) if h < n,\n        (value_M + dp[i+1][h][m+1]) if m < n\n   )\n\n   But note: the exponents for the same digit are fixed by the current count (h or m). However, the problem is that the total exponent for a digit depends on the entire assignment for that player. But we are breaking down by the current count: the next move for H will be the h+1-th digit, so we use 10^(n - h - 1). \n\n   However, wait: is that correct? \n\n   Example: n=2, and we assign the first two digits to H. Then the first digit (at index0) is the first digit of H, so exponent 10^(2-1-1)=10^0? That's not correct: it should be 10^(2-1)=10^1.\n\n   Correction: In the DP, we are at the start of the string and we haven't assigned any digits. Then:\n\n        First assignment to H: h=0 -> exponent = 10^(n-0-1) = 10^(n-1) -> correct.\n\n        Second assignment to H: h=1 -> exponent = 10^(n-1-1)=10^(n-2) -> correct.\n\n   So the exponent for a digit assigned to H at a state (h) is 10^(n - h - 1). Similarly for M.\n\n   But note: the entire number for H will have n digits, so the first digit (h=0) is multiplied by 10^(n-1), the second by 10^(n-2), etc.\n\n   However, the catch: the same digit is being considered in the entire sequence. But note: the DP state does not remember the actual digits we've chosen, but we are processing from left to right and the digits are fixed.\n\n   But the issue: the DP state must also account for the fact that the remaining digits will be assigned arbitrarily. However, we are not tracking the specific digits that have been assigned, but the counts. This is valid because the value of a digit is independent of the others (except for the order, which is fixed by the index) and the exponent only depends on the count (how many moves the player has made so far) and the total n.\n\n   However, note: the same digit cannot be assigned twice, and we are processing in order.\n\n   The state: (i, h, m) where i from 0 to 2n, h from 0 to n, m from 0 to n.\n\n   The total states: (2n+1) * (n+1) * (n+1) = 36 * 19 * 19 = about 13000 states for n=18 (2n=36) -> acceptable.\n\n   Steps:\n\n        dp[2*n][h][m] = 0 for all h, m (if we have processed all digits, then no more moves)\n\n        Then, we can do bottom-up from i=2n-1 downto 0.\n\n        But we can also do top-down memoization.\n\n   However, we also need to reconstruct the sequence of moves (the string of 'H' and 'M').\n\n   So we can store:\n\n        dp[i][h][m] = (max_total_value, move_sequence_from_index_i)   OR\n\n        Alternatively, we can store:\n\n        dp[i][h][m] = (max_value, prev_move) and then we can backtrack.\n\n   But the problem requires to output the sequence of moves (a string of length 2n). We can store the entire sequence in the state? That would be too heavy.\n\n   Instead, we can store the decisions (what move was made at each index) and then build the sequence backwards.\n\n   Alternatively, we can do:\n\n        dp[i][h][m] = (max_value, choice) where choice is None if we cannot complete, or 'H' or 'M' if we choose that.\n\n        Then we can backtrack from the initial state (0,0,0) to the end.\n\n   Steps:\n\n        Let i=0, h=0, m=0.\n\n        We want to compute dp[0][0][0].\n\n        Then, we backtrack: at each step, we know the best move (either H or M) and then update i, h, or m.\n\n   However, the state space is about 36*19*19 = 13000, which is acceptable.\n\n   But note: the exponentiation: we need to compute 10^(n - h - 1) for h from 0 to n-1. Since n<=18, we can precompute powers.\n\n   But note: the exponent base is 10, and the exponent is from 0 to n-1 (max 17). We can precompute:\n\n        power10[k] = 10^k for k from 0 to n (or n-1)\n\n   However, for H: when we assign a digit at state (i, h, m) to H, the exponent is (n - h - 1). But note: if h==n, we don't assign.\n\n   Also, note: if we assign a digit to H, then the value added is (int(A[i])) * (10 ** (n - h - 1))\n\n   Similarly for M: (int(A[i])) * (10 ** (n - m - 1))\n\n   But wait: the exponent for M is (n - m - 1). \n\n   However, note: the entire assignment for M: the first digit for M (when m=0) gets 10^(n-1), then 10^(n-2), etc.\n\n   But the catch: the digit we assign to M at a state (i, h, m) is the next digit (from the original string) and it is the (m+1)-th digit for M. So the exponent is (n - (m+1)) = (n - m - 1).\n\n   Implementation:\n\n        Precompute a list: \n            pow10 = [10**k for k in range(n)]   # but we need exponents from 0 to n-1 (inclusive) but note: the exponent for the first digit is 10^(n-1) which is the largest.\n\n        Actually, we need exponents from 0 to n-1. But note: the formula for H: exponent = n - h - 1, which can be from n-1 down to 0.\n\n        We can precompute:\n\n            exp_table = {}\n            for base in ['H','M']:\n                for count in range(0, n):   # count is the number of moves already made for that base (so the next move will be the (count+1)-th)\n                    exp = n - count - 1\n                    # if exp is negative? no, because count from 0 to n-1, so exp from n-1 down to 0.\n                    # But if count == n, then we don't use.\n\n        Actually, we can just compute on the fly with pow(10, n - h - 1) but since n is small (<=18) and h from 0 to n-1, it's acceptable.\n\n   Alternatively, we can precompute an array for exponents for H and M separately.\n\n        H_exponents = [10**(n-1-i) for i in range(n)]\n        M_exponents = [10**(n-1-i) for i in range(n)]\n\n   Then, at state (i, h, m), if we assign to H, then the value is int(A[i]) * H_exponents[h] (since h is the count of moves already done for H, so the next move is the h-th move (0-indexed) and the exponent is 10^(n-1-h)).\n\n   Similarly for M: value = int(A[i]) * M_exponents[m]\n\n   But note: the two players are symmetric, so we can use the same exponent array for both, but the exponent array should be the same for both because the exponent for the k-th digit (0-indexed) is 10^(n-1-k). However, we are using the same k for both players. But wait: the k for H and M are independent. \n\n   Actually, we don't care about the entire string, but the fact that for a player, the first digit (k=0) gets 10^(n-1), the second (k=1) gets 10^(n-2), etc.\n\n   So we can define:\n\n        exponents = [10**(n-1-i) for i in range(n)]\n\n   Then, for H, the next digit (if we are at state h) is exponents[h] (if h < n). Similarly for M, exponents[m] (if m < n).\n\n   However, note: the state h is the number of moves H has already taken (so the next move for H is the (h+1)-th, so we use exponents[h]). \n\n   But wait: if H has taken h moves, then the next digit will be the h-th digit (0-indexed) in H's number, so it gets 10^(n-1-h). \n\n   Example: n=2, h=0 -> exponent = 10^(1) -> correct for first digit.\n            h=1 -> exponent = 10^(0) -> correct for second digit.\n\n   So yes.\n\n   Steps:\n\n        Precompute exponents = [10**(n-1-i) for i in range(n)]\n\n        dp[i][h][m] = maximum total value from the rest of the string (from index i to the end) given that H has h moves and M has m moves.\n\n        Base case: i == 2*n, then return 0.\n\n        Then, at state (i, h, m):\n\n            value = -infinity\n            seq = None\n\n            Option1: if h < n, then assign the current digit to H.\n                candidate1 = exponents[h] * int(A[i]) + dp[i+1][h+1][m]\n\n            Option2: if m < n, then assign the current digit to M.\n                candidate2 = exponents[m] * int(A[i]) + dp[i+1][h][m+1]\n\n            Then, dp[i][h][m] = max(candidate1, candidate2)   (if both options are available, or the available ones)\n\n        Then, we backtrack to find the sequence.\n\n   However, note: the exponents for H and M are independent, and we are using the same exponent array for both, but that's okay because the exponent for the k-th digit for H is 10^(n-1-k) and for M is 10^(n-1-k) as well. But wait: is that correct?\n\n   Actually, the two numbers are independent. The total sum is the sum of the two numbers. The value of the digit for H is added to H's number and for M to M's. There is no interaction between the two numbers except that they use disjoint sets of digits.\n\n   But note: the same digit cannot be used twice, and we are processing the digits in order.\n\n   However, the exponent for the k-th digit of H is independent of the exponent for the k-th digit of M. So we can use the same exponent array.\n\n   But wait: the k-th digit of H and the k-th digit of M are at different positions in the original string. However, the exponent only depends on the order of moves for that particular player, not the global position.\n\n   Therefore, the above DP is correct.\n\n   However, note: the exponent array is defined for k from 0 to n-1 (for each player). The state h for H tells us which \"slot\" (from most significant to least) we are filling for H. Similarly for M.\n\n   But the entire assignment must cover all digits, and the digits are fixed. The DP state (i, h, m) means we have processed i digits (from 0 to i-1) and we have assigned h digits to H and m digits to M. Then we are at the i-th digit (0-indexed, so the next digit is A[i]).\n\n   We'll use memoization or bottom-up. Since i goes from 0 to 2n (which is 36) and h from 0 to n (19) and m from 0 to n (19) -> 36*19*19=13000 states, which is acceptable.\n\n   However, we must be cautious: we are doing recursion and the state space is 13000, which is acceptable in Python if we use caching.\n\n   Alternatively, we can do bottom-up. But we'll use memoization.\n\n   Steps for memoization:\n\n        Let memo[i][h][m] = the maximum total value from state (i, h, m)\n\n        We can use:\n\n        from functools import lru_cache\n\n        @lru_cache(maxsize=None)\n        def dp(i, h, m):\n            if i == 2*n:\n                return 0\n            # exponents for H and M: we have precomputed exponents = [10**(n-1-i) for i in range(n)]\n            # But note: our exponent array is indexed by the count (0 to n-1). So for H, if we assign the current digit, we use exponents[h] (because h is the next index for H)\n\n            res = -1   # but we have to consider the possibilities\n\n            # Option 1: assign to H\n            if h < n:\n                # The current digit is A[i]\n                val1 = dp(i+1, h+1, m)\n                # Add the value for H: digit A[i] * exponents[h]\n                total1 = int(A[i]) * (10**(n-1-h)) + val1\n            else:\n                total1 = -1   # invalid\n\n            # Option 2: assign to M\n            if m < n:\n                val2 = dp(i+1, h, m+1)\n                total2 = int(A[i]) * (10**(n-1-m)) + val2\n            else:\n                total2 = -1\n\n            if total1 == -1 and total2 == -1:\n                # This state is invalid, but actually one of them must be available because we have to assign the digit to someone? \n                # Actually, if both h and m are n, then we shouldn't be here (base case i==2n). So we assume that at state (i, h, m) we must have h+m < 2n, and we are going to assign one of them. But if both are n, we are done. So we require that h+m < 2n? Actually, we are at index i, so we have processed i digits, and h+m = i. Then we have 2n - i digits left, and we need to assign n-h to H and n-m to M. But we are at the condition: we are going to assign one digit, so we must have h+m < 2n.\n\n            Actually, the state (i, h, m) must satisfy h+m == i, because we have processed i digits and assigned h+m of them.\n\n            Then, we are at the i-th digit (0-indexed) and we have to assign it to either H or M (if they haven't reached n). But note: it's possible that we are at the last digit and both h and m are n-1, then we assign to either.\n\n            We can combine:\n\n            if h < n and total1 > -1:\n                candidate1 = total1\n            else:\n                candidate1 = -1\n\n            if m < n and total2 > -1:\n                candidate2 = total2\n            else:\n                candidate2 = -1\n\n            Then, if both are -1, then we have an error.\n\n            Otherwise, we take the maximum.\n\n            However, note: we must assign the digit to one of them. So we must have at least one of h<n or m<n.\n\n            Because the total digits is 2n, and we are at i (which is the number of digits processed) and we have h+m = i, then the remaining digits are 2n - i, and we still need to assign n-h to H and n-m to M, so we require that n-h + n-m = 2n - i, which is the remaining digits.\n\n            And we are at the condition: we are going to assign the next digit (the i-th digit, which is the next one). So we must assign it to either H or M (if they have not reached n).\n\n            But note: if one of the players has reached n, then we must assign to the other (if the other hasn't reached n). But wait, what if one player has reached n and the other hasn't? Then we must assign to the one that hasn't.\n\n            Actually, the problem says: each player must make exactly n moves. So we must assign exactly n to each. Therefore, at the beginning of the game, we are free to assign to either, but by the end we must have n for each.\n\n            In the DP, we are ensuring that we don't exceed n for H and M.\n\n            So the recurrence is:\n\n            if h < n and m < n:\n                candidate1 = int(A[i]) * (10**(n-1-h)) + dp(i+1, h+1, m)\n                candidate2 = int(A[i]) * (10**(n-1-m)) + dp(i+1, h, m+1)\n                dp(i, h, m) = max(candidate1, candidate2)\n            elif h < n:\n                dp(i, h, m) = int(A[i]) * (10**(n-1-h)) + dp(i+1, h+1, m)\n            elif m < n:\n                dp(i, h, m) = int(A[i]) * (10**(n-1-m)) + dp(i+1, h, m+1)\n            else:\n                # This state should not occur because h+m == i and we have to assign the next digit, but if both h and m are n, then i should be 2n, which is the base case.\n                # But if i < 2n and both h and m are n, then we have a contradiction because h+m = 2n and i = h+m, so i=2n, which is the base case.\n                # So we don't need to handle this.\n\n        Then, we store the dp table and also the choice made at each state so that we can backtrack.\n\n   However, we must avoid recalculating the exponentiation (which is cheap) but we can precompute the exponents for each h and m.\n\n   Alternatively, we can precompute:\n\n        exp_H = [10**(n-1-i) for i in range(n)]\n        exp_M = [10**(n-1-i) for i in range(n)]\n\n   Then, at state (i, h, m) for H: use exp_H[h] (if h < n) and for M: use exp_M[m] (if m < n). But note: the exponent for the h-th move for H is 10^(n-1-h) and similarly for M.\n\n   But wait: the exponent for the h-th move for H is the same as the exponent for the h-th move for M? Yes, because the exponent depends only on the position in the player's number, not the global index.\n\n   Therefore, we can precompute:\n\n        exp_list = [10**(n-1-i) for i in range(n)]\n\n   Then use:\n\n        value_H = int(A[i]) * exp_list[h]   (if h < n)\n        value_M = int(A[i]) * exp_list[m]   (if m < n)\n\n   But note: the exponent list is the same for both.\n\n   However, the exponent for the h-th move for H is the same as the exponent for the h-th move for M, so we can use the same list.\n\n   Implementation:\n\n        n = int(input().strip())\n        A = input().strip()\n\n        total_digits = 2*n\n        # Precompute exponents: for k in [0, n-1]: exponent = 10^(n-1-k)\n        exp_list = [10**(n-1-k) for k in range(n)]\n\n        from functools import lru_cache\n\n        @lru_cache(maxsize=None)\n        def dp(i, h, m):\n            # i: current index (from 0 to 2*n)\n            # h: number of moves for H so far\n            # m: number of moves for M so far\n            if i == total_digits:\n                return 0\n\n            # We know that at state (i, h, m), we must have h+m == i (because we've processed i digits and assigned h+m of them)\n            # Now, we have two choices if available.\n\n            res = None\n\n            # Option 1: assign to H\n            if h < n:\n                # The current digit is A[i]\n                val1 = dp(i+1, h+1, m)\n                total1 = int(A[i]) * exp_list[h] + val1\n            else:\n                total1 = -1   # invalid\n\n            # Option 2: assign to M\n            if m < n:\n                val2 = dp(i+1, h, m+1)\n                total2 = int(A[i]) * exp_list[m] + val2\n            else:\n                total2 = -1\n\n            # We must assign the current digit to one of the players (unless both are full, but then i==total_digits)\n            # Since we are at i < total_digits, at least one of h or m is less than n (because h+m == i, and we have 2n - i digits left, and we need to assign n-h and n-m, so we require that n-h + n-m >= 1, which is true because 2n - i >= 1). But note: it could be that one is full and the other is not.\n\n            # But if both are full,",
    "response": "\nTo solve this problem, we need to maximize the total prize for two players, Homer and Marge, in a game where they alternately take digits from a given number. The goal is to determine the optimal sequence of moves such that both players make exactly `n` moves each, and the sum of their resulting numbers is maximized.\n\n### Approach\n1. **Problem Analysis**: The game involves processing a 2n-digit number from left to right. Each player takes turns picking the leftmost digit, appending it to their respective number. The challenge is to decide at each step which player should pick the digit to maximize the sum of both numbers at the end.\n\n2. **Intuition**: The value of a digit depends on its position in the final number. A digit picked earlier (leftmost) will have a higher place value (e.g., thousands, hundreds) compared to a digit picked later. Thus, assigning higher-value digits to players who can leverage their place values more effectively is crucial.\n\n3. **Dynamic Programming (DP) Setup**: We use a DP approach where the state is defined by the current digit index, the number of moves each player has made so far. The DP function computes the maximum possible sum from the remaining digits given the current counts of moves for each player.\n\n4. **Exponent Calculation**: For each digit assigned to a player, its contribution to the total sum is determined by its place value, which is calculated as \\(10^{(n-1-\\text{move\\_count})}\\), where `move_count` is the number of moves the player has already made.\n\n5. **Backtracking**: After computing the DP table, we backtrack from the initial state (0, 0, 0) to determine the sequence of moves (H or M) that leads to the maximum sum. At each step, we choose the move (H or M) that yields the higher value based on the DP results.\n\n### Solution Code\n```python\ndef main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    n = int(data[0].strip())\n    A = data[1].strip()\n    total_digits = 2 * n\n    \n    exp_list = [10**(n-1-i) for i in range(n)]\n    \n    from functools import lru_cache\n\n    @lru_cache(maxsize=None)\n    def dp(i, h, m):\n        if i == total_digits:\n            return 0\n        res = -1\n        if h < n:\n            val1 = dp(i+1, h+1, m)\n            total1 = int(A[i]) * exp_list[h] + val1\n        else:\n            total1 = -1\n        if m < n:\n            val2 = dp(i+1, h, m+1)\n            total2 = int(A[i]) * exp_list[m] + val2\n        else:\n            total2 = -1\n        \n        if total1 == -1 and total2 == -1:\n            return -1\n        elif total1 == -1:\n            return total2\n        elif total2 == -1:\n            return total1\n        else:\n            return max(total1, total2)\n\n    total_val = dp(0, 0, 0)\n    seq = []\n    i, h, m = 0, 0, 0\n    while i < total_digits:\n        if h < n:\n            val1 = dp(i+1, h+1, m)\n            total1 = int(A[i]) * exp_list[h] + val1\n        else:\n            total1 = -1\n            \n        if m < n:\n            val2 = dp(i+1, h, m+1)\n            total2 = int(A[i]) * exp_list[m] + val2\n        else:\n            total2 = -1\n            \n        if total1 == -1:\n            seq.append('M')\n            m += 1\n            i += 1\n        elif total2 == -1:\n            seq.append('H')\n            h += 1\n            i += 1\n        else:\n            if total1 > total2:\n                seq.append('H')\n                h += 1\n                i += 1\n            else:\n                seq.append('M')\n                m += 1\n                i += 1\n                \n    result_str = ''.join(seq)\n    print(result_str)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input consists of an integer `n` and a string `A` of 2n digits.\n2. **Exponent List**: The `exp_list` array precomputes the place values (exponents of 10) for each possible move count (from 0 to n-1).\n3. **DP Function**: The `dp` function uses memoization to store the maximum sum achievable from the current state (digit index, moves by H, moves by M). It recursively evaluates both possible moves (H or M) and returns the maximum sum.\n4. **Backtracking**: After determining the maximum sum, the code backtracks through the DP states to construct the move sequence. At each step, it checks which move (H or M) contributes more to the total sum and appends the corresponding character to the result sequence.\n5. **Output**: The constructed sequence of 'H' and 'M' characters is printed, representing the optimal move order for the players.\n\nThis approach efficiently explores all possible move sequences using dynamic programming and backtracking to ensure the maximum total prize is achieved.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    n = int(data[0].strip())\n    A = data[1].strip()\n    total_digits = 2 * n\n    \n    exp_list = [10**(n-1-i) for i in range(n)]\n    \n    from functools import lru_cache\n\n    @lru_cache(maxsize=None)\n    def dp(i, h, m):\n        if i == total_digits:\n            return 0\n        res = -1\n        if h < n:\n            val1 = dp(i+1, h+1, m)\n            total1 = int(A[i]) * exp_list[h] + val1\n        else:\n            total1 = -1\n        if m < n:\n            val2 = dp(i+1, h, m+1)\n            total2 = int(A[i]) * exp_list[m] + val2\n        else:\n            total2 = -1\n        \n        if total1 == -1 and total2 == -1:\n            return -1\n        elif total1 == -1:\n            return total2\n        elif total2 == -1:\n            return total1\n        else:\n            return max(total1, total2)\n\n    total_val = dp(0, 0, 0)\n    seq = []\n    i, h, m = 0, 0, 0\n    while i < total_digits:\n        if h < n:\n            val1 = dp(i+1, h+1, m)\n            total1 = int(A[i]) * exp_list[h] + val1\n        else:\n            total1 = -1\n            \n        if m < n:\n            val2 = dp(i+1, h, m+1)\n            total2 = int(A[i]) * exp_list[m] + val2\n        else:\n            total2 = -1\n            \n        if total1 == -1:\n            seq.append('M')\n            m += 1\n            i += 1\n        elif total2 == -1:\n            seq.append('H')\n            h += 1\n            i += 1\n        else:\n            if total1 > total2:\n                seq.append('H')\n                h += 1\n                i += 1\n            else:\n                seq.append('M')\n                m += 1\n                i += 1\n                \n    result_str = ''.join(seq)\n    print(result_str)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 419,
        "completion_token_count": 1164,
        "thoughts_token_count": 8191
    }
}