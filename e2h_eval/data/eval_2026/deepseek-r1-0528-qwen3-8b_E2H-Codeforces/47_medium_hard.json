{
    "start": 1758296817.2119749,
    "end": 1758300201.5504527,
    "start-formatted": "2025-09-20 00:46 KST",
    "end-formatted": "2025-09-20 01:43 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\n Okay, let's analyze the problem:\n\nWe are given two integers a and b (with 1 <= a, b <= 10^9). We need to find a non-negative integer k such that:\n   LCM(a+k, b+k) is minimized.\n\nNote: If multiple k yield the same minimal LCM, choose the smallest k.\n\nLet d = (a+k) and e = (b+k). Then note that d - e = a - b (constant). So we are looking for k such that the LCM of two numbers that differ by a fixed amount (d = a-b) is minimized.\n\nWe can write:\n   Let g = gcd(a+k, b+k). Then LCM(a+k, b+k) = (a+k)*(b+k) / g.\n\nBut note that (a+k) and (b+k) are co-prime to each other? Not necessarily. However, note that the difference between them is |a-b|, so any common divisor must divide |a-b|.\n\nActually, we can set d0 = |a-b|. Then the gcd(a+k, b+k) must divide d0.\n\nIdea: Instead of iterating over k (which can be very large because a,b up to 10^9), we can consider divisors of d0.\n\nNote: Without loss of generality, assume a <= b. Then d0 = b - a (if a<=b). But if a > b, then d0 = a-b. So let d0 = |a-b|.\n\nThen, for a candidate divisor g (which divides d0) and for a particular k, we have:\n   g divides both (a+k) and (b+k). Therefore, g divides (b+k) - (a+k) = b-a = d0.\n\nMoreover, note that k must be chosen so that (a+k) is divisible by g and (b+k) is divisible by g. This means that k ≡ (-a) mod g, and also k ≡ (-b) mod g. But since g divides d0, and note that d0 = b-a, then (-a) ≡ (-b) mod g? Actually, if g divides d0, then b ≡ a mod g. So the condition is consistent.\n\nSo for each divisor g of d0 (if d0 != 0; if d0 == 0 then a==b and then k=0 is the only candidate? Actually, if a==b then we have two same numbers, and the LCM is (a+k)^2. We want to minimize this. The minimal value is achieved at k=0, because as k increases, (a+k)^2 increases. So when a==b, answer is 0).\n\nBut note: there might be cases where d0=0, so we handle separately.\n\nNow, for each divisor g of d0 (including d0 itself and 1), we can set k such that:\n   k ≡ (-a) mod g   [which is equivalent to k ≡ (-b) mod g because b≡a mod g]\n\nBut note: k must be non-negative. The smallest non-negative k satisfying k ≡ (-a) mod g is:\n   k = (g - a % g) % g   [but note: if a % g == 0, then k=0; else, k = g - (a % g)]\n\nHowever, wait: \n   We require (a+k) mod g == 0, so k ≡ (-a) mod g. The smallest non-negative k is:\n        k0 = (g - (a % g)) % g\n\nBut note: if a % g == 0, then k0=0.\n\nNow, for a given divisor g (which divides d0), we get a candidate k0.\n\nBut note: is that the only candidate? Actually, we can also consider k0 + t*g for t>=0. However, we are to choose the smallest k that gives the minimal LCM. But note: we are going to compute the LCM for candidate k0 and then compare. However, we must consider that there might be multiple divisors and hence multiple candidates.\n\nBut wait: is it sufficient to consider the minimal k for each divisor? Or could a larger k (for the same divisor) yield a smaller LCM?\n\nRecall: LCM(d, e) = d * e / g. And d = a+k, e = b+k, so d*e = (a+k)*(b+k). As k increases, (a+k)*(b+k) increases (unless k is negative, but k>=0). Therefore, for fixed g (so fixed divisor), the LCM is minimized at the smallest k that satisfies k ≡ (-a) mod g.\n\nTherefore, for each divisor g of d0, we can compute:\n   candidate_k = (g - a % g) % g   [but if a % g == 0, then candidate_k=0, otherwise candidate_k = g - (a % g)]\n\nBut note: we must also consider the possibility that g might not be positive? Our divisors are positive.\n\nBut wait: what if d0=0? Then we skip divisors and just return 0.\n\nHowever, note: the divisors we consider must be positive and divide d0. Also, note that if d0 is negative, we take absolute value.\n\nBut the problem says a,b from 1 to 10^9, so d0 can be zero or positive.\n\nBut note: There might be more than one divisor? Actually, we must consider all divisors of d0 (positive divisors).\n\nBut here's an issue: the condition we have is that the gcd of (a+k) and (b+k) must divide d0. However, it doesn't necessarily have to be exactly g. But note: we are free to choose any divisor of d0 to set the gcd. However, the actual gcd might be a multiple of g? No, actually the gcd must divide d0, so it must be a divisor of d0. But we are considering all divisors, so we will eventually consider the gcd.\n\nBut note: the above candidate k0 is the smallest k that makes g divide both (a+k) and (b+k). However, the actual gcd might be larger than g? Then why would we use g? \n\nWait: we are trying to minimize the LCM. The LCM is (a+k)*(b+k) / gcd. So a larger gcd reduces the LCM. However, note that increasing the gcd (to a divisor of d0) requires k to satisfy a congruence condition for that divisor. But note: the candidate k0 for a divisor g might not yield an actual gcd of g. It yields an actual gcd that is at least g (because g divides both numbers). But the actual gcd might be greater than g (and still divides d0). \n\nBut here's a catch: if we choose a divisor g, then the actual gcd might be a multiple of g (if g is not the greatest common divisor). However, we are considering every divisor. The minimal k for a divisor g might be the same as for a divisor h (where h is a multiple of g) if k0 for g is the same as for h? Actually, no: the conditions are different.\n\nBut note: the problem asks for the k that minimizes the LCM, and if there are multiple k with the same minimal LCM, choose the smallest k.\n\nHowever, we cannot iterate over all divisors and then for each divisor compute the candidate k and then compute the LCM for that k and then choose the k that minimizes the LCM? Because the number of divisors of d0 is about O(sqrt(d0)), which is acceptable even for d0 up to 10^9 (since sqrt(10^9) is about 31622, which is acceptable in a loop).\n\nBut wait: what if d0 is 0? Then we skip divisors and just output 0.\n\nBut note: there is another candidate: k=0? Actually, when d0=0, a=b, then our candidate k0 for divisor g (which must divide 0) is problematic. Actually, we should handle d0=0 separately.\n\nSo steps:\n\n1. If a == b, then k=0 is the answer.\n\n2. Otherwise, d0 = abs(a-b). Then, we factorize d0 to get all divisors? But note: d0 can be up to 10^9, and factoring numbers up to 10^9 is acceptable in Python if done carefully (using trial division up to sqrt(d0)).\n\nBut note: the problem constraints say a,b up to 10^9, so d0 can be up to 10^9, and we need to factorize d0. However, worst-case d0 is a prime number, then the number of divisors is 2 (only 1 and d0). But worst-case for divisors is when d0 is a highly composite number, but the maximum number of divisors for a number around 10^9 is about 1344 (for example, 735134400 has 1344 divisors). So we can factorize d0 and then generate all divisors.\n\nBut note: we don't need to factorize d0 if we use a method that iterates from 1 to sqrt(d0) to collect divisors. Alternatively, we can do:\n\n   divisors = set()\n   for i in range(1, int(math.isqrt(d0)) + 1):\n        if d0 % i == 0:\n            divisors.add(i)\n            divisors.add(d0 // i)\n\nThen we have all divisors.\n\nBut wait: what about negative divisors? We consider positive divisors only.\n\nThen, we consider each divisor g in divisors.\n\nBut note: we must consider that k must be non-negative. For each divisor g, we compute candidate_k = (g - a % g) % g. However, note that if a % g == 0, then candidate_k=0, else candidate_k = g - (a % g). But note: if g is a divisor of d0, then we can use this candidate_k.\n\nHowever, note: the problem says that the gcd of (a+k) and (b+k) might be any divisor of d0. But we are generating candidate_k for each divisor g. Then we compute the LCM for that candidate_k and then choose the candidate_k that minimizes the LCM.\n\nBut wait: is it possible that the actual minimal LCM occurs at a k that is not generated by any divisor of d0? \n\nLet me think: the gcd of (a+k) and (b+k) must divide (a+k) and (b+k) and hence must divide (b+k)-(a+k)=d0. Therefore, the gcd must be a divisor of d0. Therefore, the candidate k must satisfy k ≡ (-a) mod g for some divisor g (the gcd). But note: we are generating k for every divisor g. However, the actual k we use might have a gcd that is a divisor of d0, but we don't know which one. However, for each divisor g, we are generating a candidate k that makes g divide both numbers. Then the actual gcd might be a multiple of g (if g is not the actual gcd). But note: the LCM formula uses the actual gcd. So for candidate_k, we can compute the actual gcd and then the LCM.\n\nBut wait: we are iterating over divisors, but then we are not using the divisor g to compute the LCM, but the actual gcd. That is, for candidate_k, we can compute:\n   x = a + candidate_k\n   y = b + candidate_k\n   g_actual = gcd(x, y)\n   lcm = x * y // g_actual\n\nThen we compare these lcm values.\n\nBut note: the candidate_k for a divisor g is the smallest k that makes g divide both (a+k) and (b+k). However, the actual gcd might be larger (a divisor of d0 that is a multiple of g) and then the LCM would be (x*y)/g_actual, which is less than (x*y)/g (since g_actual >= g). Therefore, the same candidate_k might be generated by multiple divisors (in fact, by all divisors that divide the actual gcd). But we are only computing the LCM once for that candidate_k, so we are safe.\n\nBut wait: we are generating candidate_k from divisors, but the same candidate_k might be generated by multiple divisors. For example, if k0 is generated by divisor g and also by divisor h (where h divides g), then we would get duplicate candidate_k. To avoid duplicates, we can use a set for candidate_k.\n\nAlternatively, we can compute the LCM for each candidate_k and then choose the minimal one. But note: the same candidate_k might be generated multiple times (from different divisors). So we should use a set to record the candidate_k we've already considered.\n\nBut note: the candidate_k from divisor g and divisor g' might be the same even if g != g'. \n\nHowever, we can do:\n\n   candidates = set()\n   for each divisor g of d0:\n        k0 = (g - a % g) % g\n        candidates.add(k0)\n\n   Then also include k=0? Actually, note: if a % g == 0 then k0=0. But 0 is always included if there exists a divisor g (like g=1) then k0=0.\n\nBut wait: what if d0=0? Then we handled separately.\n\nBut note: there's another candidate: k = -min(a, b) (if negative, but k>=0) so we don't consider negative.\n\nBut note: we must consider that the minimal k might be 0 even if d0!=0. \n\nHowever, the above method does not consider that the minimal LCM might occur for a k that is not the minimal k for any divisor? \n\nBut note: the condition is that the gcd must divide d0, so the candidate_k we generate by divisors are the minimal k for each divisor. But note: the same k might be generated by multiple divisors, and we are only storing distinct k.\n\nBut wait: what if the minimal LCM is achieved by a k that is not the minimal k for any divisor? \n\nActually, no. Because the gcd must divide d0, so the k must be such that for the actual gcd g0 (which divides d0), k ≡ (-a) mod g0. Therefore, k must be at least the minimal k for g0 (which is (g0 - a % g0) % g0). Hence, we must consider at least the minimal k for each divisor.\n\nBut note: we are generating the minimal k for each divisor. However, it is possible that a larger k (that is not minimal for any divisor) might yield a smaller LCM? \n\nBut note: the LCM is (a+k)*(b+k)/gcd(a+k, b+k). Since (a+k)*(b+k) is increasing with k, the LCM is increasing with k for fixed gcd. However, the gcd might change as k increases. \n\nBut note: the gcd(a+k, b+k) divides d0, so it is bounded by d0. However, as k increases, the gcd might become larger (if we hit a multiple of a larger divisor). \n\nBut observe: the minimal k for a divisor g is k0 = (g - a % g) % g. Then the next k that satisfies the condition for g is k0 + g, then k0+2g, etc. \n\nHowever, we are only required to find the smallest k (non-negative) that minimizes the LCM. Therefore, for each divisor, the minimal k (k0) is the best candidate for that divisor. And we are iterating over all divisors. Therefore, we are covering all minimal k for each divisor.\n\nBut note: the LCM at k0 might be larger than the LCM at k0 + g (if we use the same divisor) because (a+k)*(b+k) is larger. However, wait: the gcd might change. Actually, at k0, the gcd is at least g (because g divides both). But it might be larger (if the two numbers share more factors). \n\nBut note: the problem is asking for the minimal LCM overall. We cannot assume that the minimal k for a divisor gives the minimal LCM. However, we are comparing across divisors. \n\nBut note: the LCM is (a+k)*(b+k) / gcd. Since (a+k)*(b+k) is increasing with k, and the gcd might be increasing or decreasing, but we are forced to consider the minimal k for each divisor. However, it is possible that a larger k (for a divisor g) might have a larger gcd (say g') and then the LCM might be smaller than the LCM at a small k for a divisor g' (with a larger gcd). \n\nBut wait: the same candidate_k might be generated by multiple divisors. And we are going to compute the LCM for candidate_k regardless of which divisor generated it.\n\nBut note: we are not iterating over all k, but we are iterating over all divisors and for each divisor we take the minimal k that satisfies the congruence. However, it is possible that a k that is not the minimal for any divisor might yield a lower LCM? \n\nLet me try with an example: a=6, b=10, d0=4, divisors: 1,2,4.\n\nFor g=1: k0 = (1 - 6%1)%1 -> 0 (since 6%1 is 0, so k0=0)\n   Then numbers: 6,10 -> gcd(6,10)=2, LCM = 6*10/2 = 30.\n\nFor g=2: k0 = (2 - 6%2)%2 = (2-0)%2 = 0\n   Then numbers: 6,10 -> same as above.\n\nFor g=4: k0 = (4 - 6%4)%4 = (4-2)%4 = 2\n   Then numbers: 8,12 -> gcd(8,12)=4, LCM=8*12/4=24.\n\nSo the minimal LCM is 24 at k=2.\n\nBut note: k=0 gives 30, k=2 gives 24.\n\nNow, what if we consider k=1? \n   Then numbers: 7,11 -> gcd(7,11)=1, LCM=77, which is worse.\n\nWhat if we consider k=3?\n   Then numbers: 9,13 -> gcd=1, LCM=117.\n\nWhat if we consider k=4?\n   Then numbers: 10,14 -> gcd=2, LCM=70.\n\nSo the minimal is indeed k=2.\n\nBut note: we did not consider k=0 and k=2. \n\nBut wait, what if we consider divisor g=2, and then k=2 (which is k0+2)? \n   k0 for g=2 was 0, then k=2 is 0+2 (which is 2). Then we would compute the LCM for k=2 again? But we didn't consider k=2 from divisor g=2? \n\nActually, from divisor g=2, the minimal k is 0. Then we don't consider k=2 from divisor g=2? \n\nBut note: we are generating candidate_k for each divisor as the minimal k that satisfies the congruence. Then we store distinct candidate_k. So we have candidate_k: {0,2}. Then we compute LCM for 0 and 2.\n\nBut wait: how did we get k=2? From divisor g=4. \n\nSo we are covering all minimal k for each divisor, and we are storing distinct k.\n\nBut note: we must also consider k=0 (from divisor 1 and 2) and k=2 (from divisor 4). \n\nBut what if a divisor g does not appear in the divisors list? Then we miss candidate_k. However, we are generating divisors from d0.\n\nBut wait: the gcd must divide d0, so the divisors we consider are the divisors of d0. \n\nBut note: the minimal k for divisor g is the smallest non-negative solution to k ≡ (-a) mod g. \n\nHowever, we must consider that the same candidate_k might be generated by multiple divisors (like k=0). \n\nBut the problem is: are we missing any candidate_k? \n\nConsider: the condition for k is that there exists a divisor g (of d0) such that g divides (a+k) and (b+k). Then k must be such that (a+k) mod g == 0 for some divisor g of d0. But note: the set of divisors we consider is complete. \n\nBut wait: the minimal k for each divisor is the smallest k that satisfies the condition for that divisor. Then the entire set of k that satisfy the condition for at least one divisor is the union of all arithmetic progressions (starting from k0(g) and then adding multiples of g). \n\nHowever, we are only taking the minimal k from each progression. Then we are missing the rest. But note: the LCM is increasing with k (because (a+k)*(b+k) is increasing, and the gcd might be increasing too, but the product is increasing). Therefore, for a fixed divisor g, the minimal k (k0) is the best candidate for achieving a low LCM with that divisor. However, it is possible that a candidate_k from a divisor g1 is worse than a candidate_k from a divisor g2 (even if g2 is larger) because the gcd becomes larger and reduces the LCM more.\n\nBut note: the LCM is (a+k)*(b+k)/gcd. The denominator (gcd) can be as large as d0 (if d0 divides both a+k and b+k). \n\nBut note: the minimal k for divisor g0 (the largest divisor, which is d0) is k0 = (d0 - a % d0) % d0. Then the LCM at k0 is (a+k0)*(b+k0)/gcd(a+k0, b+k0). But note: gcd(a+k0, b+k0) must divide d0, but it might not be d0. \n\nBut wait: we are not guaranteed that at k0 the gcd is g (the divisor we used). It might be a multiple of g (if the two numbers share more factors). \n\nSo we must compute the actual gcd for the candidate_k. \n\nSteps:\n\n1. If a == b, output 0.\n\n2. Else, d0 = abs(a-b). Then, factor d0 to get all divisors.\n\n3. Create a set of candidate_k from each divisor g (positive divisor) by:\n        k0 = (g - a % g) % g\n        add k0 to the set.\n\n4. Also, we must consider that k might be 0 even if d0 != 0? Actually, k=0 is included because for g=1, k0=0.\n\n5. Then, for each candidate_k in the set, compute:\n        x = a + candidate_k\n        y = b + candidate_k\n        g_actual = gcd(x, y)\n        lcm_val = (x * y) // g_actual\n\n   But note: x and y can be very large (up to 10^9 + candidate_k, and candidate_k can be up to d0 which is 10^9, so x and y up to 2e9). Then x*y can be up to 4e18, which is acceptable in Python (integers are arbitrary precision, but we must be cautious for performance). However, the number of divisors is at most around 1344, so we can do 1344 iterations, each time computing gcd (which is logarithmic) and multiplying two numbers (each ~1e9, so product ~1e18, which is acceptable).\n\n6. Then, we choose the candidate_k that gives the smallest lcm_val. If multiple candidate_k give the same lcm_val, choose the smallest candidate_k.\n\nBut wait: is it possible that the same candidate_k appears twice? Then we are using a set, so we avoid duplicates.\n\nHowever, note: we must consider that k=0 is included. But what if there are no divisors? Then d0=0, but we handled d0=0 separately.\n\nBut wait: what if d0=0? Then we don't enter the divisor loop. But we already handled a==b.\n\nBut note: there's a catch: what if d0 is very large? Factorization of d0 (up to 10^9) might take some time, but 10^9 is acceptable in Python if we do trial division up to sqrt(d0) (which is about 31622). However, worst-case is when d0 is prime, then we iterate up to 31622, which is acceptable.\n\nBut wait: what if a and b are very close? Then d0 is small, then factorization is fast.\n\nHowever, note: there's an alternative approach: without factorizing d0, we can iterate over the divisors by checking all numbers from 1 to sqrt(d0). But we are doing that.\n\nBut note: the above candidate_k set might be incomplete? \n\nWait: we argued that the gcd must divide d0, so the minimal k for each divisor is a candidate. But note: there might be a k that is not the minimal for any divisor but the LCM is lower? \n\nExample: Consider a=21, b=31 (from example input). Expected output is 9.\n\nd0 = 10, divisors: 1,2,5,10.\n\nCompute candidate_k for each divisor:\n\ng=1: k0 = (1-21%1)%1 -> 0 (since 21%1=0)\ng=2: k0 = (2-21%2)%2 = (2-1)%2 = 1\ng=5: k0 = (5-21%5)%5 = (5-1)%5 = 4\ng=10: k0 = (10-21%10)%10 = (10-1)%10 = 9\n\nThen we compute the LCM for k=0,1,4,9.\n\nk=0: numbers 21,31 -> gcd=1, LCM=651.\nk=1: numbers 22,32 -> gcd=2, LCM= (22*32)//2 = 352.\nk=4: numbers 25,35 -> gcd=5, LCM= (25*35)//5 = 175.\nk=9: numbers 30,40 -> gcd=10, LCM= (30*40)//10 = 120.\n\nThe minimal LCM is 120, so k=9 is chosen.\n\nBut wait, the example output is 9. So it matches.\n\nBut note: what if we consider k=6? \n   numbers: 27,37 -> gcd=1, LCM=999 -> worse.\n\nk=2: 23,33 -> gcd=1, LCM=759.\nk=3: 24,34 -> gcd=2, LCM= (24*34)//2 = 408.\nk=5: 26,36 -> gcd=2, LCM= (26*36)//2 = 468.\nk=7: 28,38 -> gcd=2, LCM= (28*38)//2 = 532.\nk=8: 29,39 -> gcd=1, LCM=1131.\n\nSo k=9 gives the minimal.\n\nBut note: k=9 is the minimal k for divisor 10.\n\nAnother example: Input \"5 10\" -> Output \"0\"\n\na=5, b=10, d0=5, divisors: 1,5.\n\ng=1: k0=0\ng=5: k0=(5-5%5)%5 = (5-0)%5=0\n\nSo candidate_k set = {0}. Then we compute for k=0: numbers 5,10 -> gcd=5, LCM=(5*10)//5=10.\n\nBut wait, what if k=5? Then numbers 10,15 -> gcd=5, LCM= (10*15)//5=30, which is worse.\n\nBut note: we only consider k=0.\n\nBut wait: is k=0 the minimal for divisor 5? Yes, because 5 divides 5+0=5.\n\nBut note: the example output is 0.\n\nBut wait: the example input is \"5 10\", and the example output is \"0\".\n\nSo our method works.\n\nHowever, note: the above method does not consider k that are not minimal for any divisor. But we argued that the condition for k is that the gcd divides d0, so the minimal k for each divisor is the smallest k that satisfies the condition for that divisor. Then, if a k satisfies the condition for a divisor, then the minimal k for that divisor is <= k. And since the LCM is increasing with k (for fixed divisor, because the product is increasing and the gcd might be increasing, but note: the gcd can only increase when k increases, so the denominator increases and the numerator increases, but the overall effect is that the LCM may decrease? Actually, no: because the product is increasing and the gcd is increasing (so the denominator is increasing). However, the ratio might be complex.\n\nBut note: the LCM is (a+k)*(b+k)/gcd(a+k, b+k). Since gcd(a+k, b+k) divides d0, the gcd is bounded by d0. However, as k increases, (a+k)*(b+k) is increasing and the gcd might be increasing (so the denominator is increasing). But the LCM is not necessarily increasing with k.\n\nExample: a=6, b=10, k=0: LCM=30, k=2: LCM=24, k=4: LCM= (10,14): gcd=2, LCM=70 -> so k=2 is better than k=0 and k=4.\n\nBut note: k=2 is the minimal k for divisor 4, and k=0 is for divisors 1 and 2. \n\nBut wait: what if we consider a divisor g and a k that is not the minimal? \n\nExample: a=6, b=10, divisor g=2. Minimal k is 0. Then k=2: 2 is a multiple of 2 away from 0? Actually, k=2 is 0+2, so it satisfies the condition for divisor 2 (because 6+2=8, divisible by 2). But we already considered k=0 and k=2. However, we only stored k=0 from divisor 2 and k=2 from divisor 4.\n\nBut note: k=2 is generated by divisor 4, so we don't miss it.\n\nBut wait: what if a divisor g has a minimal k0, and then k0 + t*g (t>=1) might yield a lower LCM? \n\nIn the example a=6, b=10, divisor g=2: k0=0, then k=2 (which is 0+2) is generated by divisor 4. Then we compute the LCM for k=2 from divisor 4, and we don't compute the LCM for k=2 from divisor 2 separately? \n\nBut note: we are storing distinct candidate_k. So k=2 is stored once.\n\nBut wait: we are not storing k=2 from divisor 2. But we are storing k=0 from divisor 2. Then k=2 is stored from divisor 4. Then we compute the LCM for k=2.\n\nBut note: the LCM for k=2 is computed once. \n\nBut what if the minimal k for divisor g is k0, and then k0 + t*g (for t>=1) is the minimal k for a multiple divisor? Then we are storing it from the multiple divisor.\n\nSo the algorithm:\n\n   if a == b:\n        print(0)\n        exit()\n\n   d0 = abs(a-b)\n   divisors = set()\n   # Factorize d0\n   n = d0\n   i = 1\n   while i*i <= n:\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n//i)\n        i += 1\n\n   candidates = set()\n   for g in divisors:\n        # Compute candidate_k for divisor g\n        # We want k such that (a+k) % g == 0, and k minimal and non-negative.\n        # k ≡ (-a) mod g\n        remainder = a % g\n        if remainder == 0:\n            k0 = 0\n        else:\n            k0 = g - remainder   # because we want (a+k0) mod g = (remainder + k0) mod g = (remainder + g - remainder) mod g = g mod g = 0.\n        # But note: k0 might be negative? No, because remainder is in [0, g-1], so if remainder==0 then k0=0, else k0=g-remainder (which is in [1, g-1]).\n        candidates.add(k0)\n\n   # Additionally, note: we must consider k=0 separately? But k0 for g=1 is 0, so we have it.\n\n   best_k = 0\n   best_lcm = None\n\n   for k in candidates:\n        x = a + k\n        y = b + k\n        # Compute gcd of x and y\n        g_actual = math.gcd(x, y)\n        # But note: x and y might be huge, but they are up to 10^9 + k, and k is at most d0 (<=10^9) so numbers up to 2e9, which is acceptable for math.gcd (logarithmic in the number).\n        current_lcm = (x * y) // g_actual\n\n        if best_lcm is None or current_lcm < best_lcm or (current_lcm == best_lcm and k < best_k):\n            # But wait: if we have the same LCM, we choose the smallest k.\n            # However, we are iterating and we want the smallest k in case of tie. But note: we are storing distinct k, and we want the smallest k that minimizes the LCM.\n            # But if we find a candidate with the same LCM but a smaller k, we update.\n            # However, note: we are iterating arbitrarily. We should first check if current_lcm < best_lcm, then update best_lcm and best_k.\n            # If equal, then update best_k to the minimum k.\n            if current_lcm < best_lcm:\n                best_lcm = current_lcm\n                best_k = k\n            elif current_lcm == best_lcm and k < best_k:\n                best_k = k\n\n   print(best_k)\n\nBut wait: what if there are no divisors? Then d0=0, but we handled a==b.\n\nBut note: the above code does not consider that k must be non-negative. Our candidate_k are non-negative because k0 = (g - a%g) % g, and if a%g==0 then 0, else g - (a%g) which is positive and less than g, so non-negative.\n\nBut wait: the modulus operation: (g - a%g) % g is redundant? Because if a%g==0, then g - a%g = g, and then g % g = 0. So we can do:\n\n        if a % g == 0:\n            k0 = 0\n        else:\n            k0 = g - (a % g)\n\nBut note: we can also write k0 = (-a) % g, but that is the same as (g - a % g) % g? \n\nActually, (-a) % g is defined as the smallest non-negative integer congruent to -a modulo g. And that is the same as (g - a % g) % g. But if a%g==0, then (-a)%g=0, and (g - a%g)%g = (g-0)%g = g % g = 0. So it is the same.\n\nBut note: the modulus operation in Python for negative numbers: (-a) % g gives a non-negative result. But we are using positive a, so a%g is in [0, g-1]. Then (g - a%g) is in [1, g]. Then (g - a%g) % g: if (g - a%g) == g, then %g gives 0. Otherwise, it gives g - a%g.\n\nSo we can simply do:\n\n        k0 = (-a) % g\n\nBut note: if g divides a, then (-a)%g=0, else it is g - (a%g). \n\nBut note: the modulus operation for negative numbers: \n   In Python, (-a) % g is equivalent to g - (a % g) if a % g != 0, and 0 if a % g == 0.\n\nBut wait, let me test:\n\n   a=6, g=4: (-6)%4 = 2, and 4 - (6%4)=4-2=2 -> correct.\n\n   a=4, g=4: (-4)%4=0, and 4-(",
    "response": "\nTo solve this problem, we need to find a non-negative integer \\( k \\) such that the least common multiple (LCM) of \\( a + k \\) and \\( b + k \\) is minimized. If multiple values of \\( k \\) yield the same minimal LCM, we should choose the smallest \\( k \\).\n\n### Approach\n1. **Problem Analysis**: The key observation here is that the difference between \\( a + k \\) and \\( b + k \\) remains constant (\\( |a - b| \\)). The greatest common divisor (GCD) of \\( a + k \\) and \\( b + k \\) must therefore divide this difference. This insight allows us to limit our search for \\( k \\) by considering all divisors of \\( |a - b| \\).\n\n2. **Intuition**: For each divisor \\( g \\) of \\( |a - b| \\), we compute the smallest non-negative \\( k \\) such that both \\( a + k \\) and \\( b + k \\) are divisible by \\( g \\). This \\( k \\) is given by \\( (-a) \\mod g \\). Once we have all candidate \\( k \\) values from all divisors, we evaluate each candidate by computing the LCM of \\( a + k \\) and \\( b + k \\), then select the \\( k \\) that yields the smallest LCM.\n\n3. **Algorithm Selection**: \n   - **Special Case Handling**: If \\( a \\) equals \\( b \\), the answer is trivially 0 since the LCM of two identical numbers is minimized at \\( k = 0 \\).\n   - **Divisor Enumeration**: For \\( a \\neq b \\), compute all divisors of \\( |a - b| \\).\n   - **Candidate Generation**: For each divisor \\( g \\), compute the minimal \\( k \\) such that \\( g \\) divides both \\( a + k \\) and \\( b + k \\).\n   - **LCM Evaluation**: For each candidate \\( k \\), compute the LCM of \\( a + k \\) and \\( b + k \\) and keep track of the minimal LCM encountered, along with the corresponding smallest \\( k \\).\n\n4. **Complexity Analysis**: The most computationally intensive part is factorizing \\( |a - b| \\) to find all its divisors. For a number up to \\( 10^9 \\), this involves checking divisors up to \\( \\sqrt{n} \\), which is feasible as \\( \\sqrt{10^9} \\approx 31622 \\). The number of divisors is also manageable, typically in the hundreds or thousands, making the overall approach efficient.\n\n### Solution Code\n```python\nimport math\n\ndef main():\n    data = input().split()\n    a = int(data[0])\n    b = int(data[1])\n    \n    if a == b:\n        print(0)\n        return\n        \n    d0 = abs(a - b)\n    divisors = set()\n    i = 1\n    while i * i <= d0:\n        if d0 % i == 0:\n            divisors.add(i)\n            divisors.add(d0 // i)\n        i += 1\n        \n    candidates = set()\n    for g in divisors:\n        k0 = (-a) % g\n        candidates.add(k0)\n        \n    best_k = 0\n    best_lcm = None\n    \n    for k in candidates:\n        x = a + k\n        y = b + k\n        g_actual = math.gcd(x, y)\n        current_lcm = (x * y) // g_actual\n        \n        if best_lcm is None or current_lcm < best_lcm:\n            best_lcm = current_lcm\n            best_k = k\n        elif current_lcm == best_lcm and k < best_k:\n            best_k = k\n            \n    print(best_k)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Input Handling**: The code reads two integers \\( a \\) and \\( b \\) from standard input.\n2. **Special Case Check**: If \\( a \\) and \\( b \\) are equal, it immediately outputs 0 since no \\( k > 0 \\) can reduce the LCM further.\n3. **Divisor Calculation**: The absolute difference \\( |a - b| \\) is computed, and all its divisors are found by checking up to the square root of \\( |a - b| \\).\n4. **Candidate Generation**: For each divisor \\( g \\), the smallest non-negative \\( k \\) ensuring \\( g \\) divides both \\( a + k \\) and \\( b + k \\) is calculated using \\( (-a) \\mod g \\).\n5. **LCM Evaluation**: For each candidate \\( k \\), the LCM of \\( a + k \\) and \\( b + k \\) is computed. The candidate with the smallest LCM is selected, with ties broken by choosing the smallest \\( k \\).\n6. **Output**: The optimal \\( k \\) is printed.\n\nThis approach efficiently narrows down potential candidates for \\( k \\) by leveraging mathematical properties of divisors and GCD, ensuring optimal performance even for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef main():\n    data = input().split()\n    a = int(data[0])\n    b = int(data[1])\n    \n    if a == b:\n        print(0)\n        return\n        \n    d0 = abs(a - b)\n    divisors = set()\n    i = 1\n    while i * i <= d0:\n        if d0 % i == 0:\n            divisors.add(i)\n            divisors.add(d0 // i)\n        i += 1\n        \n    candidates = set()\n    for g in divisors:\n        k0 = (-a) % g\n        candidates.add(k0)\n        \n    best_k = 0\n    best_lcm = None\n    \n    for k in candidates:\n        x = a + k\n        y = b + k\n        g_actual = math.gcd(x, y)\n        current_lcm = (x * y) // g_actual\n        \n        if best_lcm is None or current_lcm < best_lcm:\n            best_lcm = current_lcm\n            best_k = k\n        elif current_lcm == best_lcm and k < best_k:\n            best_k = k\n            \n    print(best_k)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 396,
        "completion_token_count": 1102,
        "thoughts_token_count": 8191
    }
}