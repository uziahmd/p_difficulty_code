{
    "start": 1758308339.8721676,
    "end": 1758311808.6676805,
    "start-formatted": "2025-09-20 03:58 KST",
    "end-formatted": "2025-09-20 04:56 KST",
    "gpu": 2,
    "pid": 30,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# TV Game\n\nThere is a new TV game on BerTV. In this game two players get a number A consisting of 2n digits. Before each turn players determine who will make the next move. Each player should make exactly n moves. On it's turn i-th player takes the leftmost digit of A and appends it to his or her number Si. After that this leftmost digit is erased from A. Initially the numbers of both players (S1 and S2) are «empty». Leading zeroes in numbers A, S1, S2 are allowed. In the end of the game the first player gets S1 dollars, and the second gets S2 dollars.One day Homer and Marge came to play the game. They managed to know the number A beforehand. They want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize. Help them.\n\n## Input\nThe first line contains integer n (1 ≤ n ≤ 18). The second line contains integer A consisting of exactly 2n digits. This number can have leading zeroes.\n\n## Output\nOutput the line of 2n characters «H» and «M» — the sequence of moves of Homer and Marge, which gives them maximum possible total prize. Each player must make exactly n moves. If there are several solutions, output any of them.\n\n## Example\n### Input\n['2\\n1234', '2\\n9911']\n\n### Output\n['HHMM', 'HMHM']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\n We are given n and a string A of 2n digits.\n There are two players: Homer (H) and Marge (M). Each makes exactly n moves.\n On each move, the player takes the leftmost digit of A and appends it to their own number.\n\n The goal is to maximize the total prize, which is S1 (Homer's number) + S2 (Marge's number).\n\n However, note that the game proceeds in 2n moves. At each move, we decide which player takes the digit.\n But note: the problem says \"They managed to know the number A beforehand. They want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize.\"\n\n Since the entire process is deterministic (each time we take the leftmost digit), the main decision is the assignment of the 2n digits to two numbers: one for Homer and one for Marge, each of length n.\n\n But note: the order of digits in each number is fixed by the order of moves. However, the catch is that the moves alternate? Actually, no: the problem does not specify that the moves must alternate. It only says that each player makes exactly n moves.\n\n However, the example outputs: \n   Input: 2\\n9911 -> Output: HMHM\n\n This implies that the moves are interleaved arbitrarily (but the digits are taken from the left). The entire string A is split into two subsequences (each of length n) and the order of the digits in each subsequence is the order they appear in A.\n\n But note: the problem says \"the leftmost digit\" is taken. So the digits are removed from the front. The entire process uses all digits.\n\n Actually, the moves do not have to be alternating. The problem says: \"On its turn i-th player takes the leftmost digit of A and appends it to his or her number Si.\" and \"each player should make exactly n moves\". \n\n However, the example input \"1234\" with n=2 and output \"HHMM\" means:\n   First two moves are by Homer: \n        Move1: Take '1' -> S1 becomes \"1\", then A becomes \"234\"\n        Move2: Take '2' -> S1 becomes \"12\", then A becomes \"34\"\n   Then two moves by Marge:\n        Move3: Take '3' -> S2 becomes \"3\", then A becomes \"4\"\n        Move4: Take '4' -> S2 becomes \"34\"\n\n But wait, is that allowed? The problem doesn't say the moves must alternate. So we can assign any n moves to Homer and the other n to Marge, and the digits are taken from the front in order.\n\n Therefore, the entire string A is split into two strings of length n: one for Homer and one for Marge, preserving the original order.\n\n The total prize is the numerical value of Homer's number plus the numerical value of Marge's number.\n\n However, note: if there are leading zeros, the number might be small. But the problem allows leading zeros.\n\n We wish to maximize S1 + S2.\n\n How to think?\n Let the entire string A be split into two subsequences (not necessarily contiguous) but preserving the order. However, note: the moves remove the leftmost digit at each step. Therefore, the assignment of digits to Homer and Marge must be such that the digits assigned to a player form a contiguous block from the start? Actually, no.\n\n Example: n=2, A=\"1234\"\n Option 1: HHMM -> Homer gets the first two digits: \"12\", Marge gets the last two: \"34\". Then S1=12, S2=34, total=46.\n Option 2: HMHM -> Homer gets the first and third: \"1\" and \"3\" -> so his number is \"13\"; Marge gets the second and fourth: \"2\" and \"4\" -> \"24\". Total=13+24=37.\n Option 3: HMMH -> Homer gets the first and fourth: \"14\"; Marge gets the second and third: \"23\". Total=14+23=37.\n\n But wait, the example output for \"1234\" is \"HHMM\", which gives the maximum total of 46.\n\n However, what if we consider the assignment as: we choose which n digits go to Homer (and the rest to Marge) and the digits are taken in the order they appear. Then the problem reduces to:\n\n We need to select a set of indices (exactly n) from the 2n indices (0 to 2n-1) to assign to Homer. Then:\n   S1 = the concatenation of the digits at these indices (in increasing index order)\n   S2 = the concatenation of the remaining digits (in increasing index order)\n\n Then we wish to maximize the sum of the two numbers.\n\n But note: the moves are sequential and we remove the leftmost digit. However, the assignment does not require that the digits assigned to a player are consecutive. But the removal is from the left. The catch: the moves are in order, so the assignment must be such that the relative order of the digits in A is preserved for each player.\n\n However, the problem does not require that the moves are interleaved arbitrarily. Actually, the entire process is fixed: we are going to remove the digits one by one from the left. And at each removal, we assign the digit to either Homer or Marge. But the assignment must be such that after 2n moves, each has exactly n moves.\n\n Now, note: the moves are sequential and the same digit cannot be taken twice. So the two sets are disjoint and together form A.\n\n The key: the assignment of the digits to the two players is arbitrary (any n digits to Homer, the rest to Marge) but the order of the digits in each player's number is the same as their order in A.\n\n So the problem becomes: choose a subset of n digits from A (keeping their original order) to form Homer's number, and the remaining n digits form Marge's number. Then the total prize is the integer value of Homer's number plus the integer value of Marge's number.\n\n However, note: if we have leading zeros, the integer value might be affected. But the problem allows leading zeros. But note: if we have a string of digits that starts with zeros, then when converted to an integer, the zeros are ignored. But the problem says \"leading zeroes are allowed\", so we must consider the entire string as having up to n digits.\n\n Actually, the problem says: \"Initially the numbers of both players (S1 and S2) are empty.\" and then they append the digits. So if a player collects a digit '0' at the beginning, then his number is \"0...\", and then if he collects more digits, that's okay. But note: the problem does not say the numbers are interpreted as integers. However, the prize is given in dollars, and the example uses integers.\n\n But wait, the example: \n   Input: 2\\n9911 -> Output: HMHM, and the total prize would be 99 (if we do HHMM) vs 91+91 (if we do HMMH) or 91+99 (if we do HMHM) ?\n\n Let me recast: For A=\"9911\", n=2.\n\n Possibilities for Homer's set (size 2):\n\n   Option 1: indices {0,1} -> \"99\", then Marge: \"11\" -> 99+11 = 110.\n   Option 2: indices {0,2} -> \"91\", then Marge: \"91\" -> 91+91 = 182.\n   Option 3: indices {0,3} -> \"91\", then Marge: \"91\" -> 182.\n   Option 4: indices {1,2} -> \"91\", then Marge: \"91\" -> 182.\n   Option 5: indices {1,3} -> \"91\", then Marge: \"91\" -> 182.\n   Option 6: indices {2,3} -> \"11\", then Marge: \"99\" -> 11+99 = 110.\n\n So the maximum total prize is 182.\n\n And the example output is \"HMHM\", which corresponds to taking the first and third digits for Homer (index0 and index2) and the second and fourth for Marge (index1 and index3). \n\n But wait, the sequence of moves \"HMHM\" would be:\n\n   Move1: H takes the first digit '9' -> S1=\"9\", A becomes \"911\"\n   Move2: M takes the first digit '9' -> S2=\"9\", A becomes \"11\"\n   Move3: H takes the first digit '1' -> S1=\"91\", A becomes \"1\"\n   Move4: M takes the first digit '1' -> S2=\"91\"\n\n So indeed the two numbers are \"91\" and \"91\".\n\n However, note that the example input \"2\\n1234\" leads to maximum total 46, which is achieved by the assignment {0,1} for Homer and {2,3} for Marge (which gives 12+34=46).\n\n Therefore, the problem is: choose a subset of n digits from A (preserving order) to maximize (number formed by the subset) + (number formed by the complement).\n\n But note: the two numbers are formed by the digits in the order they appear. \n\n However, we can also note: the total prize is independent of the assignment of the two numbers because the entire set of digits is fixed. In fact, let T be the entire number A (as a string). Then the total prize is:\n\n   [Number formed by the chosen n digits] + [Number formed by the remaining n digits]\n\n But note: we can also consider that the two numbers together use all the digits. However, the assignment matters because the digits are in fixed positions.\n\n Alternate view: the total prize is:\n\n   Let X be the number formed by the digits assigned to Homer, and Y by Marge.\n\n   We want to maximize (X + Y).\n\n Since the digits are fixed, we can also note that the two numbers are built from the same set of digits, but the assignment to the two numbers (and the order) is fixed by the original order.\n\n However, the problem is equivalent to: assign each digit to either Homer or Marge (exactly n to each) such that the two resulting numbers (when read in the original order) are maximized in sum.\n\n How to solve?\n\n We have 2n digits, and we are to choose n for Homer. The total prize is:\n\n   X = d1 * 10^(n-1) + d2 * 10^(n-2) + ... + dn * 10^0   (where d1, d2, ..., dn are the digits chosen for Homer in the order they appear)\n\n   Y = e1 * 10^(n-1) + e2 * 10^(n-2) + ... + en * 10^0   (for Marge)\n\n But note: the digits in X and Y are taken from the original string A in order.\n\n Alternatively, we can think of the entire string as being split into two strings of length n (without reordering). Then the value of X is the number formed by the first occurrence of the Homer digits in A, and similarly for Y.\n\n However, we are free to choose which ones to pick for Homer, but the relative order must be the same as in A.\n\n We wish to maximize X + Y.\n\n Since the entire set of digits is fixed, and the two numbers are built from disjoint sets, we can try to use dynamic programming.\n\n But note: n is at most 18, so the total length is 36. We can consider iterating over the possible splits? There are C(36,18) possibilities, which is about 9e9, too many.\n\n Alternatively, we can use DP that goes digit by digit and decides whether to assign the current digit to Homer or Marge, keeping track of how many digits we have assigned to each and the current values? But the numbers can be up to 18 digits, so the numbers are huge (up to 10^18). We cannot store the actual numbers.\n\n Another idea: since the two numbers are built from the same set of digits (but in the original order) and we are forced to use all digits, the total prize is independent of the assignment? Actually, no. Consider:\n\n   We have two ways to assign: one where the largest digits go to the most significant places in one number, and another where the largest digits are split.\n\n But note: the assignment must preserve the order. So the digits that appear earlier are more significant (because they will be placed at the beginning of the number).\n\n How about: we consider the two numbers as two stacks of digits (with the earliest digit being the most significant). Then the total prize is:\n\n   Let the two numbers be X and Y, then:\n\n   X = x0 * 10^(n-1) + x1 * 10^(n-2) + ... + x_{n-1} * 10^0\n   Y = y0 * 10^(n-1) + y1 * 10^(n-2) + ... + y_{n-1} * 10^0\n\n and the digits for X and Y are chosen from A without changing the order.\n\n But note: the digits are fixed in the original order. The catch is that we are allowed to interleave arbitrarily, but the relative order of the digits in each number must be the same as in A.\n\n Actually, the entire assignment is: we choose a set of n indices for Homer, and the remaining for Marge. Then:\n\n   X is the concatenation of the digits at the chosen indices (in increasing index order)\n   Y is the concatenation of the digits at the non-chosen indices (in increasing index order)\n\n Now, the total prize is X + Y.\n\n How to maximize? We can use dynamic programming that considers the position and the count for Homer and Marge, and also the current length of the numbers (which is the count). But the numbers are too big to store.\n\n Alternative insight: we can consider the contribution of each digit in the entire string.\n\n The entire string A has 2n digits. When we assign a digit at position i (0-indexed) to a player, then the digit's contribution to the total prize depends on how many digits remain to the right of it (both for the entire string) and which player it is assigned to.\n\n However, note: if we assign a digit to Homer, then its position in Homer's number is determined by how many digits Homer has taken from the left (that is, from the positions before i) and also by the total number of digits that are assigned to Homer that are at positions <= i.\n\n Actually, the value of a digit d at position i if assigned to a player is:\n\n   d * 10^(k)\n\n where k is the number of digits that are assigned to the same player and appear to the right of i (so that this digit will be placed at the (total_count - k - 1)th power? Actually, wait: the digits are taken in order. So if we assign a set of n digits, then the digit at position i will be placed in the j-th position (from the left) of the player's number, where j is the rank of i among the indices chosen for that player (or not chosen). But note: the entire process: the digits are taken from the front, so the relative order is fixed.\n\n Actually, the value of the digit d at position i is:\n\n   If we assign it to Homer, then its power is 10^(n - 1 - r) where r is the number of digits assigned to Homer that are at positions greater than i? No, because the number is built by appending the digit to the current number. So the first digit assigned to Homer is multiplied by 10^(n-1), the next by 10^(n-2), etc.\n\n But note: the assignment does not necessarily assign the first n digits to Homer. The assignment is arbitrary (any n digits). The digit at position i will be the (r)-th digit (0-indexed) in Homer's number, where r is the number of digits assigned to Homer that are at positions less than i? Actually, no: the digit is appended to the current number, and the current number is built from the digits taken so far (which are the ones with smaller indices). Therefore, the digit at position i is the (count_H - 1)th digit from the right? \n\n Let me clarify:\n\n   The entire assignment: we have two sequences (for Homer and Marge) of length n. The value of Homer's number is:\n\n      H = d_{i1} * 10^(n-1) + d_{i2} * 10^(n-2) + ... + d_{in} * 10^0\n\n   where i1 < i2 < ... < in are the indices chosen for Homer.\n\n Similarly for Marge.\n\n So the digit at the smallest index chosen for Homer gets the highest power (10^(n-1)), the next gets 10^(n-2), and so on.\n\n Therefore, the contribution of a digit d at a given index i is:\n\n   If we assign it to Homer, then its power is 10^(n-1 - r) where r is the number of digits assigned to Homer that are at indices less than i.\n\n   Similarly, if we assign it to Marge, then its power is 10^(n-1 - s) where s is the number of digits assigned to Marge that are at indices less than i.\n\n But note: the entire assignment must assign exactly n digits to each.\n\n Now, the total prize is the sum over all digits of (digit * its_power) for the assignment.\n\n However, the power of a digit depends on the assignment of the digits that come before it (both for the same player and the other player). This makes it difficult.\n\n We can use dynamic programming that goes from left to right (by the index) and for each digit we decide to assign it to Homer or Marge, and we keep track of:\n\n   - the index (i)\n   - the number of digits assigned to Homer so far (h)\n   - the number of digits assigned to Marge so far (m)\n\n Additionally, we need to know for each player, the count of digits that have been assigned and that will determine the power for the next digits? Actually, for a digit at position i, if we assign it to Homer, then its power is 10^(n-1 - h_prev) where h_prev is the number of Homer's digits already assigned (at indices < i). But wait, the power is determined by the final position in the number. The digit at position i will be placed at the (h_prev)th position (0-indexed from left) in Homer's number, so its power is 10^(n-1 - h_prev). Similarly for Marge.\n\n However, we don't know the future assignments. But note: the total number of digits for Homer is n, so the power for a digit assigned to Homer is 10^(n-1 - h_prev) regardless of the future. Because the future digits assigned to Homer will not affect the current digit's power.\n\n Therefore, we can compute the contribution of the current digit at the moment we assign it.\n\n Then the problem becomes: we have 2n digits, and we wish to assign each to either Homer or Marge (exactly n each) and maximize the total prize, where the prize for a digit d at position i is:\n\n   If assigned to Homer: d * 10^(n-1 - h)   [where h is the number of Homer's digits assigned so far (before this one)]\n   If assigned to Marge: d * 10^(n-1 - m)   [where m is the number of Marge's digits assigned so far]\n\n But wait: the exponents for the two numbers are the same (n-1) because both numbers are of length n. However, note: the digit is placed at the next available position in the respective number.\n\n However, the above formula is correct.\n\n Now, we can use DP with state (i, h, m) meaning we have processed the first i digits, assigned h to Homer and m to Marge (so h+m = i). Then the next digit (i-th) can be assigned to Homer (if h < n) or Marge (if m < n).\n\n The base case: i=0, h=0, m=0 -> total prize 0.\n\n Then, for each digit at position i (0-indexed), the digit is int(A[i]).\n\n If we assign to Homer, then the contribution is: int(A[i]) * (10 ** (n-1-h))   [because h was the count of Homer's digits before this one]\n\n Similarly, if we assign to Marge: int(A[i]) * (10 ** (n-1-m))\n\n Then update the state.\n\n However, the exponentiation: n is at most 18, so the exponent is at most 17. But 10**17 is a big number, but we are just doing arithmetic and we are only storing the total prize so far (which might be huge). But note: we are only interested in the maximum total prize. However, the numbers are huge (up to 10^18 * 10^18? Actually, the total prize is the sum of two numbers, each up to 10^n-1, so the total prize is up to 2*(10^n-1) which is about 2e18, which is within the range of Python integers.\n\n But the state space: i from 0 to 2n (which is 36), h from 0 to n (n<=18) and m from 0 to n, so the state space is (36+1) * (n+1) * (n+1) = 37*19*19 ~ 13000 states. That is acceptable.\n\n Steps:\n\n   dp[i][h][m] = maximum total prize we can get from the first i digits, having assigned h to Homer and m to Marge.\n\n   Then, for the next digit (i-th, 0-indexed, so i from 0 to 2n-1) we have:\n\n   Option 1: assign to Homer (if h < n)\n        new_h = h+1\n        contribution = int(A[i]) * (10 ** (n-1 - h))   [because h was the count for Homer before this digit]\n        dp[i+1][new_h][m] = max(dp[i+1][new_h][m], dp[i][h][m] + contribution)\n\n   Option 2: assign to Marge (if m < n)\n        new_m = m+1\n        contribution = int(A[i]) * (10 ** (n-1 - m))\n        dp[i+1][h][new_m] = max(dp[i+1][h][new_m], dp[i][h][m] + contribution)\n\n   But note: the exponent for Homer is (n-1 - h) because we are going to have h digits already (so the next digit is the (h+1)-th digit, which is the (n-1 - h) power). Similarly for Marge.\n\n   However, wait: the entire number has n digits, so the first digit (the one with the highest power) is assigned the exponent 10^(n-1). The second digit (if assigned) is 10^(n-2), etc.\n\n   In our state, when we assign a digit to Homer, the current count of Homer's digits is h (so we have used h digits for Homer). Then the next digit (this one) will be the (h+1)-th digit for Homer, so its place is 10^(n-1 - h). Similarly for Marge.\n\n   Base: dp[0][0][0] = 0.\n\n   Then, we iterate i from 0 to 2n-1.\n\n   Then, we want to find the state (i=2n, h=n, m=n) and then backtrack to get the assignment.\n\n   However, we also need to record the moves. We can store the decisions (which player took the digit) in a separate 3D array (or we can reconstruct the path).\n\n   But note: the problem also requires to output the sequence of moves (a string of 'H' and 'M' of length 2n). We can store the decision at each step.\n\n   Alternatively, we can store the entire sequence during the DP.\n\n   But the state space is 37*19*19, which is acceptable. We can store:\n\n        dp[i][h][m] = the maximum total prize from the first i digits with h and m assigned.\n\n   and also parent[i][h][m] = (previous_state, last_move) but then we need to reconstruct the entire sequence.\n\n   However, we can store the move at each step. Alternatively, we can do:\n\n        Let dp[i][h][m] = (max_total, seq)   but then the state space would be too big for the string (2^36 possibilities?).\n\n   Instead, we can do:\n\n        We'll do the DP and then backtrack to get the moves.\n\n   Steps for backtracking:\n\n        We know we end at state (2n, n, n). Then we look at the previous state.\n\n        How did we get to (2n, n, n)? From (2n-1, n-1, n) by assigning the last digit to Homer, or from (2n-1, n, n-1) by assigning to Marge.\n\n        But note: the contribution for the last digit depends on the counts at the previous step.\n\n        However, we stored the dp table with the maximum total prize. But we didn't store the actual assignment. We can store a separate 3D array for the decision (whether the i-th digit was assigned to Homer or Marge) but we don't know until we know the path.\n\n   Alternatively, we can store two tables: dp[i][h][m] = the maximum total prize, and then we store a 3D array choice[i][h][m] which records the last move (either 'H' or 'M') that led to this state, and also the previous state (i-1, h-1, m) or (i-1, h, m-1).\n\n   However, we don't need the entire sequence until the end. We can reconstruct the sequence backwards.\n\n   Steps:\n\n        Let dp[0][0][0] = 0, and then for each i from 0 to 2n-1, and for each h from 0 to n, and for each m from 0 to n, we update.\n\n        Then, we find the state (2n, n, n) and then:\n\n            Start from the last digit (index 2n-1). The move for the last digit:\n\n                If the state (2n, n, n) was reached by assigning the last digit to Homer, then the last digit (A[2n-1]) was assigned to Homer, and the previous state was (2n-1, n-1, n). Similarly for Marge.\n\n            But note: we don't know which one. So we can store:\n\n                parent[i][h][m] = (i-1, prev_h, prev_m, move) but then we have to store the move.\n\n            Alternatively, we can store:\n\n                dp[i][h][m] = (max_value, move_at_i, prev_state) but then we are storing too much.\n\n        We can do:\n\n            Let dp[i][h][m] = maximum total prize for the first i digits.\n\n            Let move[i][h][m] = the last move made at the i-th digit (0-indexed, so the (i+1)-th digit) that led to this state. The move is either 'H' or 'M'. But then how do we know the previous state?\n\n            Actually, we can store:\n\n                dp[i][h][m] = maximum total prize for the first i digits with h and m.\n\n                and we store two arrays: \n                    from_h[i][h][m] = whether we came from a state with h-1 and m (meaning the last move was 'H')\n                    from_m[i][h][m] = whether we came from a state with h and m-1 (meaning the last move was 'M')\n\n            But then we can backtrack.\n\n        However, we want the entire sequence. We can store the entire sequence in the dp table as a string, but the state space is 13000 and the string is of length 2n (at most 36) so that would be 13000*36 bytes, which is about 468000 bytes, acceptable.\n\n        But we can avoid storing the entire string by storing the moves as we go. Alternatively, we can store the entire sequence in the dp table by using a list of characters, but that is memory heavy.\n\n        Alternatively, we can store the moves in a 3D array: \n\n            move[i][h][m] = the move (either 'H' or 'M') that was made at the i-th digit (0-indexed) to get to state (i+1, h, m). But then we need to know the previous state.\n\n        Actually, we can do:\n\n            We'll create an array `moves` of dimension [2n][n+1][n+1] (all initialized to None) to store the move at each step.\n\n            Then, when updating:\n\n                If we assign the i-th digit to Homer:\n\n                    new_state = (i+1, h+1, m)\n                    moves[i][h][m] = 'H'\n\n                Similarly for Marge.\n\n            Then, at the end, we start from (2n, n, n) and backtrack:\n\n                i = 2n-1, h = n, m = n\n                while i>=0:\n                    move_char = moves[i][h][m]\n                    # Then we know that at the i-th digit, the move was move_char.\n                    # Then we update: if move_char is 'H', then we came from (h-1, m) at step i-1; if 'M', then (h, m-1).\n                    # Then set h and m accordingly, and i decreases by 1.\n\n            Then we record the move at each step.\n\n        But note: the digit index i is from 0 to 2n-1. We assign the i-th digit (0-indexed) at step i.\n\n        Then we output the moves from the first digit to the last.\n\n        However, the problem requires the sequence of moves (of length 2n). \n\n        Steps:\n\n            n = int(input().strip())\n            A = input().strip()\n\n            dp = a 3D array: dimensions [2n+1][n+1][n+1] (initialize with -1 or -inf for impossible states, or use None)\n\n            Alternatively, we can use dp[i][h][m] = maximum total prize, and we initialize with -1 meaning unreachable.\n\n            Steps:\n\n                dp[0][0][0] = 0\n                Then, for i in range(0, 2*n):\n                    for h in range(0, n+1):\n                        for m in range(0, n+1):\n                            if dp[i][h][m] is not set (or is -1), skip.\n                            Then, consider two moves.\n\n                Then, we backtrack.\n\n        However, we must be cautious: the exponentiation might be expensive, but n is at most 18, and we have at most 2n (36) digits, so we can precompute powers.\n\n        Precomputation: \n            Let power_table[k] = 10**(n-1-k) for k from 0 to n-1.\n\n        But note: for a digit assigned to Homer at a state (h, m) (current counts) the exponent is (n-1 - h) because h is the current count (so after assigning, the count becomes h+1, and the digit is the (h+1)-th digit, so its power is 10^(n-1 - h)). However, wait: if we have already assigned h digits to Homer, then the next digit (if assigned to Homer) will be the (h+1)-th digit, so its power is 10^(n-1 - h). But note: we are going to assign n digits, so the first digit (h=0) gets 10^(n-1), the second (h=1) gets 10^(n-2), etc.\n\n        However, in our DP, the state (i, h, m) has already assigned h digits to Homer (from the first i digits). Then the next digit (if assigned to Homer) will be the (h+1)-th digit for Homer, so its power is 10^(n-1 - h). Similarly for Marge: 10^(n-1 - m).\n\n        But note: we are processing the digits from left to right. The digit we are processing now is the (i)-th digit (0-indexed). The assignment of this digit will affect the power of the digits that come after? No, because the power is determined solely by the count of digits assigned to the same player that have appeared so far (to the left). \n\n        However, the above reasoning is correct.\n\n        Implementation:\n\n            Precompute: \n                n_val = n (given)\n                total_digits = 2 * n_val\n\n            Precompute a list `powers` for exponents: \n                powers = [10**(n_val-1 - i) for i in range(n_val)]\n\n            But note: for Homer, the digit assigned at a state (h, m) (before assignment) is the (h+1)-th digit, so we use power = 10**(n_val-1 - h)\n\n            However, wait: the entire number has n_val digits. The first digit (the one with the highest power) is the 0-th digit (if assigned) and gets 10^(n_val-1). The second gets 10^(n_val-2), etc.\n\n            So the exponent for a digit assigned to Homer at step i (with h being the current count) is 10**(n_val-1 - h). Similarly for Marge.\n\n            Then, we iterate:\n\n                for i from 0 to total_digits-1:\n                    for h from 0 to n_val:\n                        for m from 0 to n_val:\n                            if h+m != i: then skip (or we don't, because we are iterating by i) but we are iterating i from 0 to total_digits-1, so h+m should be i.\n\n                Actually, we are iterating i from 0 to total_digits-1, and h from 0 to n_val, m from 0 to n_val, but we must have h+m == i.\n\n            Then, for each state (i, h, m) (which is the first i digits processed, with h to Homer and m to Marge):\n\n                Option 1: assign the next digit (A[i]) to Homer, if h < n_val.\n                    contribution_H = int(A[i]) * (10**(n_val-1 - h))\n                    new_dp = dp[i][h][m] + contribution_H\n                    Then update dp[i+1][h+1][m] and record the move.\n\n                Option 2: assign to Marge, if m < n_val.\n                    contribution_M = int(A[i]) * (10**(n_val-1 - m))\n                    new_dp = dp[i][h][m] + contribution_M\n                    Then update dp[i+1][h][m+1] and record the move.\n\n            We initialize dp[0][0][0] = 0.\n\n            Then, we must initialize the dp table with -1 (or a very small number) for unreachable states.\n\n            After processing, we look for dp[total_digits][n_val][n_val] (if total_digits=2*n_val).\n\n            Then, we backtrack to get the sequence.\n\n        However, note: the problem allows multiple solutions. We just need to output one.\n\n        But wait: the above DP does not store the entire sequence, so we need to store the moves.\n\n        We can store:\n\n            dp[i][h][m] = maximum total prize for the first i digits.\n\n            And we store a 3D array `assign` of characters (or None) for each state (i, h, m) to record the move at the i-th digit (if we are at state (i, h, m) then the move at the (i-1)-th digit? Actually, we are processing the i-th digit (0-indexed) at state (i, h, m). \n\n        Actually, we are storing the state after processing the i-th digit. So the move for the i-th digit is stored in the transition from (i-1, h_prev, m_prev) to (i, h, m). \n\n        We can store:\n\n            move_table[i][h][m] = the move (either 'H' or 'M') that was made at the i-th digit (so the digit at index i) to get to state (i, h, m). But then the previous state is (i-1, h-1, m) if move is 'H', or (i-1, h, m-1) if move is 'M'.\n\n        Then, to backtrack:\n\n            i =",
    "response": "\nTo solve this problem, we need to maximize the total prize for two players, Homer and Marge, who take turns selecting digits from the left end of a given number A. Each player must make exactly n moves, and the goal is to split the digits of A into two subsequences (one for each player) such that the sum of the numerical values formed by these subsequences is maximized.\n\n### Approach\n1. **Problem Analysis**: The problem requires splitting a sequence of 2n digits into two subsequences of length n each, preserving the original order of digits. The numerical value of each subsequence is formed by concatenating the selected digits in order. The challenge is to find the optimal split that maximizes the sum of these two numbers.\n\n2. **Insight**: The key observation is that the contribution of each digit to the total prize depends on its position in the respective player's number. Digits selected earlier (leftmost) contribute more to the total prize because they occupy higher place values (e.g., the first digit contributes 10^(n-1), the second 10^(n-2), etc.).\n\n3. **Dynamic Programming (DP) Setup**: We use a DP approach where the state `dp[i][h][m]` represents the maximum total prize achievable after processing the first `i` digits, with `h` digits assigned to Homer and `m` digits assigned to Marge. The transitions involve deciding whether to assign the current digit to Homer or Marge, updating the state accordingly.\n\n4. **Backtracking**: After filling the DP table, we backtrack from the state `(2n, n, n)` to determine the sequence of moves (Homer or Marge) that led to the maximum prize. This involves checking whether the last move was by Homer or Marge and adjusting the counts accordingly.\n\n5. **Complexity**: The DP table has dimensions `(2n+1) x (n+1) x (n+1)`, leading to a space complexity of O(n³). The time complexity is also O(n³) due to iterating over each state and possible move.\n\n### Solution Code\n```python\ndef main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    n_val = int(data[0].strip())\n    A_str = data[1].strip()\n    total_digits = 2 * n_val\n\n    # Precompute powers of 10 for exponents from 0 to n_val-1\n    powers = [10**(n_val - 1 - i) for i in range(n_val)]\n    \n    # Initialize DP table and move tracking\n    dp = [[[None for _ in range(n_val + 1)] for _ in range(n_val + 1)] for __ in range(total_digits + 1)]\n    dp[0][0][0] = 0.0\n    \n    # Directions for backtracking: we'll store the move at each step\n    move_table = [[[None for _ in range(n_val + 1)] for _ in range(n_val + 1)] for __ in range(total_digits + 1)]\n    \n    # Fill the DP table\n    for i in range(total_digits):\n        for h in range(n_val + 1):\n            for m in range(n_val + 1):\n                if dp[i][h][m] is None:\n                    continue\n                current_digit = int(A_str[i])\n                # Option 1: assign to Homer\n                if h < n_val:\n                    exp = powers[h]\n                    new_value = dp[i][h][m] + current_digit * exp\n                    if new_value > dp[i + 1][h + 1][m]:\n                        dp[i + 1][h + 1][m] = new_value\n                        move_table[i + 1][h + 1][m] = 'H'\n                # Option 2: assign to Marge\n                if m < n_val:\n                    exp = powers[m]\n                    new_value = dp[i][h][m] + current_digit * exp\n                    if new_value > dp[i + 1][h][m + 1]:\n                        dp[i + 1][h][m + 1] = new_value\n                        move_table[i + 1][h][m + 1] = 'M'\n    \n    # Backtrack to find the sequence of moves\n    seq = []\n    i, h, m = total_digits, n_val, n_val\n    while i > 0:\n        move_char = move_table[i][h][m]\n        seq.append(move_char)\n        if move_char == 'H':\n            h -= 1\n        else:\n            m -= 1\n        i -= 1\n    seq.reverse()\n    print(''.join(seq))\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Initialization**: The code reads the input values for `n` and the string `A`. It precomputes the powers of 10 needed for calculating the contribution of each digit based on its position in the player's number.\n\n2. **DP Table Setup**: The DP table `dp` is initialized to store the maximum prize achievable for each state `(i, h, m)`. The `move_table` keeps track of the last move (Homer or Marge) that led to each state.\n\n3. **DP Table Population**: For each digit in `A`, the code checks all possible states `(i, h, m)` and updates the DP table by considering both possible moves (assigning the current digit to Homer or Marge). The contribution of each digit is calculated based on its position in the respective player's number.\n\n4. **Backtracking**: After processing all digits, the code backtracks from the state `(2n, n, n)` to construct the sequence of moves. It checks the `move_table` to determine whether the last move was by Homer or Marge, adjusting the counts of digits assigned to each player accordingly.\n\n5. **Output**: The constructed sequence of moves (a string of 'H' and 'M' characters) is printed, which ensures the maximum total prize for both players.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    n_val = int(data[0].strip())\n    A_str = data[1].strip()\n    total_digits = 2 * n_val\n\n    # Precompute powers of 10 for exponents from 0 to n_val-1\n    powers = [10**(n_val - 1 - i) for i in range(n_val)]\n    \n    # Initialize DP table and move tracking\n    dp = [[[None for _ in range(n_val + 1)] for _ in range(n_val + 1)] for __ in range(total_digits + 1)]\n    dp[0][0][0] = 0.0\n    \n    # Directions for backtracking: we'll store the move at each step\n    move_table = [[[None for _ in range(n_val + 1)] for _ in range(n_val + 1)] for __ in range(total_digits + 1)]\n    \n    # Fill the DP table\n    for i in range(total_digits):\n        for h in range(n_val + 1):\n            for m in range(n_val + 1):\n                if dp[i][h][m] is None:\n                    continue\n                current_digit = int(A_str[i])\n                # Option 1: assign to Homer\n                if h < n_val:\n                    exp = powers[h]\n                    new_value = dp[i][h][m] + current_digit * exp\n                    if new_value > dp[i + 1][h + 1][m]:\n                        dp[i + 1][h + 1][m] = new_value\n                        move_table[i + 1][h + 1][m] = 'H'\n                # Option 2: assign to Marge\n                if m < n_val:\n                    exp = powers[m]\n                    new_value = dp[i][h][m] + current_digit * exp\n                    if new_value > dp[i + 1][h][m + 1]:\n                        dp[i + 1][h][m + 1] = new_value\n                        move_table[i + 1][h][m + 1] = 'M'\n    \n    # Backtrack to find the sequence of moves\n    seq = []\n    i, h, m = total_digits, n_val, n_val\n    while i > 0:\n        move_char = move_table[i][h][m]\n        seq.append(move_char)\n        if move_char == 'H':\n            h -= 1\n        else:\n            m -= 1\n        i -= 1\n    seq.reverse()\n    print(''.join(seq))\n\nif __name__ == '__main__':\n    main()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 420,
        "completion_token_count": 1289,
        "thoughts_token_count": 8189
    }
}