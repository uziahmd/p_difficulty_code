{
    "start": 1758088066.8640392,
    "end": 1758089053.8522906,
    "start-formatted": "2025-09-17 14:47 KST",
    "end-formatted": "2025-09-17 15:04 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\n Okay, we are given n vouchers and a total duration x.\n Each voucher: (l, r, cost) with duration = (r - l + 1)\n\n Conditions:\n 1. We need exactly two distinct vouchers i and j such that the sum of their durations is exactly x.\n 2. They must not intersect: either ri < lj or rj < li.\n\n Approach:\n\n Since x can be up to 200,000, and the days (l, r) are also up to 200,000, we need an efficient way.\n\n Steps:\n\n 1. Precompute the duration for each voucher: d = r - l + 1.\n\n 2. We want to find two vouchers (i, j) such that:\n      d_i + d_j = x\n    and they do not intersect.\n\n 3. How to check non-intersection? \n        Condition: voucher i [l_i, r_i] and voucher j [l_j, r_j] don't intersect if r_i < l_j OR r_j < l_i.\n\n 4. We can group vouchers by their duration. For each duration d, we have a list of vouchers (each represented by (l, r, cost)).\n    Then for a given duration d, we are interested in the other duration d2 = x - d.\n\n 5. But note: the condition for non-intersection requires that one voucher ends before the other starts.\n\n 6. We can break down the problem:\n\n    Let's define:\n        For a voucher with duration d, we know its [l, r] and cost.\n\n    We can consider two cases for the two vouchers:\n        Case 1: The first voucher ends before the second starts (voucher i comes first, then voucher j).\n                Condition: r_i < l_j.\n\n        Case 2: The second voucher ends before the first starts (voucher j comes first, then voucher i).\n                Condition: r_j < l_i.\n\n    But note: since we are grouping by duration, we don't know the order. However, we can consider the two orders.\n\n 7. Alternate approach:\n\n    We can preprocess the vouchers by storing them in two ways:\n\n    Idea 1: Group by duration, and then for each duration d, store all vouchers (with their l, r, cost) and then sort by something.\n\n    Also, we need to consider that the two vouchers must have durations adding to x.\n\n    So, for each duration d, we look for d2 = x - d.\n\n    But then, how to enforce the non-intersection condition?\n\n    We can try:\n\n        For a fixed pair of durations (d, d2) (where d + d2 = x), we want to choose one voucher from d and one from d2 such that they don't overlap.\n\n        There are two possibilities: \n            Possibility 1: The voucher from duration d ends before the voucher from duration d2 starts.\n            Possibility 2: The voucher from duration d2 ends before the voucher from duration d starts.\n\n        However, note: the two vouchers are unordered in the input, but the non-intersection condition is symmetric.\n\n        Actually, the condition is: either the first voucher ends before the second starts OR the second ends before the first starts.\n\n        But which one is first? In time? \n\n        Since we don't know the order of the two vouchers, we have to consider both orders. However, note that the condition does not depend on which voucher is which, except for the time intervals.\n\n        Actually, we can break the condition into two independent conditions:\n\n            Condition A: (r_i < l_j)   [voucher i ends before voucher j starts]\n            Condition B: (r_j < l_i)   [voucher j ends before voucher i starts]\n\n        But note: we are considering two different vouchers. We cannot assign arbitrarily which one is i and which one is j because the durations are fixed (d and d2). However, we can consider two scenarios:\n\n        Scenario 1: The voucher with duration d goes first and the one with duration d2 goes next.\n                    Then we require: r_d < l_{d2}\n\n        Scenario 2: The voucher with duration d2 goes first and the one with duration d goes next.\n                    Then we require: r_{d2} < l_d\n\n        So we have two separate conditions to check.\n\n 8. How to efficiently check for a given duration d and d2?\n\n    We can precompute:\n\n        For each duration d, we want to store:\n            - All the vouchers (l, r, cost) for that duration.\n\n        And we want to quickly query:\n\n            For Scenario 1 (d first, then d2): \n                We want to find a voucher in d (with [l1, r1]) and a voucher in d2 (with [l2, r2]) such that r",
    "response": "\nTo solve this problem, we need to find two distinct travel vouchers such that the sum of their durations equals exactly `x` (the total vacation days), and they do not overlap in time. The goal is to minimize the total cost of these two vouchers.\n\n### Approach\n1. **Group Vouchers by Duration**: We first group all vouchers by their duration. This allows us to efficiently access all vouchers that contribute to a specific part of the total duration `x`.\n\n2. **Check Valid Pairs**: For each voucher with duration `d`, we look for another voucher with duration `x - d`. We then check if these two vouchers can be used together without overlapping. There are two scenarios to consider:\n   - **First Scenario**: The voucher with duration `d` ends before the voucher with duration `x - d` starts.\n   - **Second Scenario**: The voucher with duration `x - d` ends before the voucher with duration `d` starts.\n\n3. **Efficient Lookup Using Sorting and Binary Search**: For each duration group, we sort the vouchers by their end date (`r`). This allows us to use binary search to quickly find the cheapest voucher that meets the non-overlapping condition when paired with another voucher from a different duration group.\n\n4. **Minimize Total Cost**: For each valid pair of vouchers found, we keep track of the minimum total cost encountered during our search.\n\n### Solution Code\n```python\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    data = sys.stdin.read().split()\n    it = iter(data)\n    n = int(next(it))\n    x = int(next(it))\n    vouchers = []\n    for _ in range(n):\n        l = int(next(it))\n        r = int(next(it))\n        cost_val = int(next(it))\n        vouchers.append((l, r, cost_val))\n    \n    duration_map = defaultdict(list)\n    for l, r, cost_val in vouchers:\n        dur = r - l + 1\n        duration_map[dur].append((l, r, cost_val))\n    \n    for key in duration_map:\n        duration_map[key] = sorted(duration_map[key], key=lambda x: x[1])\n    \n    ans = float('inf')\n    found = False\n    \n    for dur, vouchers_list in duration_map.items():\n        other_dur = x - dur\n        if other_dur not in duration_map:\n            continue\n        \n        for voucher in vouchers_list:\n            l1, r1, cost1 = voucher\n            if other_dur == dur:\n                if len(vouchers_list) >= 2:\n                    idx = bisect.bisect_left(vouchers_list, (r1 + 1, 0, 0))\n                    if idx < len(vouchers_list):\n                        cand_cost = cost1 + vouchers_list[idx][2]\n                        if cand_cost < ans:\n                            ans = cand_cost\n                            found = True\n            else:\n                other_vouchers = duration_map[other_dur]\n                if other_vouchers:\n                    pos = bisect.bisect_left(other_vouchers, (r1 + 1, 0, 0))\n                    if pos < len(other_vouchers):\n                        cand_cost = cost1 + other_vouchers[pos][2]\n                        if cand_cost < ans:\n                            ans = cand_cost\n                            found = True\n                    \n                    pos = bisect.bisect_left(vouchers_list, (other_vouchers[0][0], 0, 0))\n                    if pos < len(vouchers_list):\n                        cand_cost = cost1 + vouchers_list[pos][2]\n                        if cand_cost < ans:\n                            ans = cand_cost\n                            found = True\n    \n    if not found:\n        print(-1)\n    else:\n        print(ans)\n\ndef bisect_left(arr, x):\n    lo, hi = 0, len(arr)\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if arr[mid][0] < x[0]:\n            lo = mid + 1\n        elif arr[mid][0] > x[0]:\n            hi = mid\n        else:\n            if arr[mid][1] < x[1]:\n                lo = mid + 1\n            else:\n                hi = mid + 1\n    return lo\n\nif __name__ == \"__main__\":\n    import bisect\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into a list of vouchers, each characterized by its start day, end day, and cost.\n2. **Grouping by Duration**: Vouchers are grouped by their duration (calculated as `end - start + 1`). Each group is sorted by the end day to facilitate efficient binary search operations later.\n3. **Checking Valid Pairs**: For each voucher, we check if there exists another voucher with a duration equal to `x - current_duration`. Using binary search, we find the cheapest voucher that does not overlap with the current voucher.\n4. **Output Result**: If no valid pair is found, the output is `-1`. Otherwise, the minimum total cost of all valid pairs is printed.\n\nThis approach efficiently narrows down the search space using grouping and binary search, ensuring optimal performance even for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import defaultdict\n\ndef main():\n    data = sys.stdin.read().split()\n    it = iter(data)\n    n = int(next(it))\n    x = int(next(it))\n    vouchers = []\n    for _ in range(n):\n        l = int(next(it))\n        r = int(next(it))\n        cost_val = int(next(it))\n        vouchers.append((l, r, cost_val))\n    \n    duration_map = defaultdict(list)\n    for l, r, cost_val in vouchers:\n        dur = r - l + 1\n        duration_map[dur].append((l, r, cost_val))\n    \n    for key in duration_map:\n        duration_map[key] = sorted(duration_map[key], key=lambda x: x[1])\n    \n    ans = float('inf')\n    found = False\n    \n    for dur, vouchers_list in duration_map.items():\n        other_dur = x - dur\n        if other_dur not in duration_map:\n            continue\n        \n        for voucher in vouchers_list:\n            l1, r1, cost1 = voucher\n            if other_dur == dur:\n                if len(vouchers_list) >= 2:\n                    idx = bisect.bisect_left(vouchers_list, (r1 + 1, 0, 0))\n                    if idx < len(vouchers_list):\n                        cand_cost = cost1 + vouchers_list[idx][2]\n                        if cand_cost < ans:\n                            ans = cand_cost\n                            found = True\n            else:\n                other_vouchers = duration_map[other_dur]\n                if other_vouchers:\n                    pos = bisect.bisect_left(other_vouchers, (r1 + 1, 0, 0))\n                    if pos < len(other_vouchers):\n                        cand_cost = cost1 + other_vouchers[pos][2]\n                        if cand_cost < ans:\n                            ans = cand_cost\n                            found = True\n                    \n                    pos = bisect.bisect_left(vouchers_list, (other_vouchers[0][0], 0, 0))\n                    if pos < len(vouchers_list):\n                        cand_cost = cost1 + vouchers_list[pos][2]\n                        if cand_cost < ans:\n                            ans = cand_cost\n                            found = True\n    \n    if not found:\n        print(-1)\n    else:\n        print(ans)\n\ndef bisect_left(arr, x):\n    lo, hi = 0, len(arr)\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if arr[mid][0] < x[0]:\n            lo = mid + 1\n        elif arr[mid][0] > x[0]:\n            hi = mid\n        else:\n            if arr[mid][1] < x[1]:\n                lo = mid + 1\n            else:\n                hi = mid + 1\n    return lo\n\nif __name__ == \"__main__\":\n    import bisect\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 735,
        "completion_token_count": 1078,
        "thoughts_token_count": 1023
    }
}