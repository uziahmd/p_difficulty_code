{
    "start": 1758298950.736773,
    "end": 1758302304.7138155,
    "start-formatted": "2025-09-20 01:22 KST",
    "end-formatted": "2025-09-20 02:18 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\n Okay, let's break down the problem.\n\n We are given an integer p (0 <= p <= 200000). We need to find:\n  1. The minimum number of nodes required to create a p-reachable directed graph.\n  2. Among all such graphs with the minimum number of nodes, the maximum number of unidirectional pairs.\n\n Definitions:\n - A directed graph is p-reachable if it contains exactly p ordered pairs (u, v) (with u < v) such that u and v are mutually reachable (i.e., there is a path from u to v and from v to u).\n\n Note: The condition \"exactly p ordered pairs (u, v) with u < v\" refers to the mutual reachability. However, note that the definition of unidirectional pair (u, v) requires that there is a path from u to v but not from v to u, and also u != v.\n\n Steps:\n\n 1. Understanding the structure for mutual reachability (strongly connected components?):\n    In a directed graph, if we have a set of nodes that form a strongly connected component (SCC), then every two nodes in that SCC are mutually reachable. Moreover, the entire SCC will contribute C(n,2) = n*(n-1)//2 mutual pairs (for n nodes in the SCC).\n\n    However, note: the problem says \"exactly p ordered pairs (u, v) with u < v\" that are mutually reachable. So, the entire graph must have exactly p such pairs.\n\n    But note: the problem does not require the graph to be strongly connected. It can have multiple SCCs. However, if two nodes are in different SCCs, they might not be mutually reachable.\n\n    Actually, the condition for mutual reachability is that the two nodes are in the same SCC (if we assume the graph is decomposed into SCCs, then two nodes are mutually reachable only if they are in the same SCC). Therefore, the total number of mutual pairs (with u < v) is the sum over each SCC of C(size_i, 2).\n\n    So, we need to represent p as the sum of combinations (triangular numbers) from some integers (the sizes of the SCCs). And we want to minimize the total number of nodes (which is the sum of the sizes of the SCCs). \n\n    Why? Because we are allowed to have multiple SCCs, and each SCC must be a complete directed cycle (to maximize the mutual reachability within the component) or at least strongly connected. But note: we are free to choose the graph structure as long as the mutual reachability condition holds.\n\n    However, note: the problem asks for the minimum number of nodes. We can combine the SCCs arbitrarily (but the mutual reachability is confined within SCCs). \n\n    The problem then reduces to: represent p as the sum of triangular numbers (T_k = k*(k-1)//2) and minimize the total nodes (the sum of the k's). But note: we are allowed to break p into any combination of triangular numbers (each representing an SCC of size k). Since the graph must have exactly p mutual pairs, we must have:\n\n        p = T_{a} + T_{b} + ... \n\n    and the total nodes is a + b + ...\n\n    How do we minimize the total nodes? \n\n    Example: \n        If p=3, then we can use one SCC of size 3 (which gives T_3 = 3). Alternatively, we could use three SCCs of size 2 (each T_2 = 1, so 1+1+1=3). Then the total nodes would be 3 (for one SCC) vs 6 (for three SCCs). Clearly, we want the minimal total nodes.\n\n    But note: the example input p=3, output is \"3 0\". So the minimal nodes is 3.\n\n    Another example: p=4. We cannot use one SCC of size 4 because T_4=6 which is too big. Let's try two SCCs: \n        T_3 = 3, then we need 1 more. We can use an SCC of size 2 (which gives T_2=1). Then total nodes = 3+2=5. \n        Alternatively, four SCCs of size 2: T_2*4 = 4, then total nodes=8 -> not minimal.\n\n    Therefore, we need to represent p as a sum of triangular numbers (each T_k = k*(k-1)//2) and minimize the sum of the k's.\n\n    This is similar to the classic problem of representing a number as a sum of triangular numbers (or more specifically, the minimal number of nodes is the minimal sum of k's for which the triangular numbers sum to p).\n\n    However, note: we are allowed to use any triangular numbers (any k",
    "response": "\nTo solve this problem, we need to determine the minimum number of nodes required to create a directed graph that is exactly p-reachable, and among all such graphs with the minimum number of nodes, find the maximum number of unidirectional node pairs.\n\n### Approach\n1. **Understanding p-Reachable Graphs**: A directed graph is p-reachable if it contains exactly p ordered pairs (u, v) where u < v and u and v are mutually reachable. This mutual reachability implies that both u can reach v and v can reach u. The key insight is that these mutual reachabilities form strongly connected components (SCCs). Each SCC of size k contributes \\( \\binom{k}{2} = \\frac{k(k-1)}{2} \\) mutual pairs.\n\n2. **Minimizing Nodes**: To minimize the total number of nodes, we need to represent p as a sum of triangular numbers (each triangular number corresponds to an SCC of size k). The goal is to find the combination of triangular numbers that sums to p while minimizing the sum of their corresponding k values.\n\n3. **Maximizing Unidirectional Pairs**: For graphs with the minimum number of nodes, the maximum number of unidirectional pairs is derived by considering all possible ordered pairs (u, v) where u ≠ v and only one direction of reachability exists between u and v. The calculation involves:\n   - Total possible ordered pairs: \\( n(n-1) \\)\n   - Subtracting the mutual reachabilities (p) and the pairs within the same SCC (which are not considered in unidirectional pairs).\n\n### Solution Code\n```python\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"0 0\")\n        return\n    p = int(data[0])\n    \n    if p == 0:\n        print(\"0 0\")\n        return\n        \n    n_nodes = 0\n    current_tri = 0\n    k = 1\n    \n    while current_tri < p:\n        tri_val = k * (k - 1) // 2\n        if current_tri + tri_val <= p:\n            current_tri += tri_val\n            n_nodes += k\n            k += 1\n        else:\n            break\n            \n    n_nodes += (p - current_tri) * 2\n    n_nodes += 1\n    \n    total_ordered_pairs = n_nodes * (n_nodes - 1)\n    max_unidirectional = total_ordered_pairs - 2 * p - (n_nodes - 1)\n    \n    print(f\"{n_nodes} {max_unidirectional}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read from standard input, which is a single integer p.\n2. **Handling Special Case**: If p is 0, the solution is trivially 0 nodes and 0 unidirectional pairs.\n3. **Calculating Minimum Nodes**: The algorithm iteratively adds the largest possible triangular numbers (from SCCs of increasing size) until the sum of these triangular numbers is at least p. The remaining value (p minus the sum of triangular numbers) is handled by adding pairs of nodes (each contributing 1 mutual pair per node).\n4. **Calculating Unidirectional Pairs**: The total number of ordered pairs is \\( n(n-1) \\), where n is the total number of nodes. The unidirectional pairs are computed by subtracting twice the mutual pairs (since each mutual pair is counted once in the ordered pairs) and adjusting for pairs within the same SCC.\n5. **Output**: The result is printed as the minimum number of nodes and the maximum number of unidirectional pairs.\n\nThis approach efficiently determines the solution by leveraging properties of triangular numbers and combinatorial mathematics to minimize nodes and maximize unidirectional pairs.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"0 0\")\n        return\n    p = int(data[0])\n    \n    if p == 0:\n        print(\"0 0\")\n        return\n        \n    n_nodes = 0\n    current_tri = 0\n    k = 1\n    \n    while current_tri < p:\n        tri_val = k * (k - 1) // 2\n        if current_tri + tri_val <= p:\n            current_tri += tri_val\n            n_nodes += k\n            k += 1\n        else:\n            break\n            \n    n_nodes += (p - current_tri) * 2\n    n_nodes += 1\n    \n    total_ordered_pairs = n_nodes * (n_nodes - 1)\n    max_unidirectional = total_ordered_pairs - 2 * p - (n_nodes - 1)\n    \n    print(f\"{n_nodes} {max_unidirectional}\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 475,
        "completion_token_count": 802,
        "thoughts_token_count": 1023
    }
}