{
    "start": 1758296006.6369867,
    "end": 1758298853.974193,
    "start-formatted": "2025-09-20 00:33 KST",
    "end-formatted": "2025-09-20 01:20 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\n Okay, let's analyze the problem:\n\nWe are given two integers a and b (with 1 <= a, b <= 10^9). We need to find a non-negative integer k such that:\n   LCM(a+k, b+k) is minimized.\n\nNote: If multiple k yield the same minimal LCM, choose the smallest k.\n\nLet d = a - b. Without loss of generality, we can assume a >= b by swapping if needed. But note: the problem doesn't require that.\n\nActually, note that when k increases, both numbers increase. However, observe:\n\nLet x = a + k, y = b + k. Then note that x - y = a - b (a constant). So we are looking for two numbers with fixed difference d = |a-b| (but actually we can consider d = a-b if a>=b, else negative? Let's set d = a-b and then consider absolute value in divisors? Actually, note the LCM formula: LCM(x,y) = (x*y)/GCD(x,y)\n\nBut note: GCD(x,y) = GCD(a+k, b+k) = GCD(a+k, (a+k)-(b+k)) = GCD(a+k, a-b). Similarly, if we swap, then it's the same.\n\nSo without loss of generality, let g = GCD(a+k, a-b). Then we can write:\n   x = g * m, y = g * n, where m and n are coprime and m-n = (a-b)/g.\n\nBut note: the LCM is (x*y)/g = g * (m*n). Since m and n are coprime, the product m*n is minimized when m and n are as close as possible? Actually, we have fixed the difference (a-b) which is fixed. Alternatively, we can think about the divisors.\n\nAlternatively, note that the condition for the LCM to be minimal is related to having the GCD as large as possible, because:\n   LCM(x,y) = (x*y) / GCD(x,y) = ((a+k)*(b+k)) / GCD(a+k, b+k)\n\nBut note that the product (a+k)*(b+k) also changes with k. However, we know that the GCD must divide (a-b). So the divisors of the absolute difference (let D = |a-b|) are the candidates for the GCD.\n\nLet d be a divisor of D = |a-b|. Then we are looking for k such that GCD(a+k, b+k) = d (or a multiple of d, but actually the GCD must divide D). However, note that the GCD is exactly d if and only if d divides (a+k) and (b+k) and also d divides (a-b). Moreover, the condition for k is:\n   k ≡ (-a) mod d   and   k ≡ (-b) mod d\n\nBut since a ≡ b mod d (because d divides a-b), so we require k ≡ (-a) mod d. The smallest non-negative k for divisor d is k0 = (d - a % d) % d. However, note that k must be non-negative and we can write k0 = (d - (a % d)) % d, but if a % d == 0 then k0=0.\n\nBut wait, note that d divides (a-b). We can consider all divisors d of |a-b|. Then for each divisor d, we compute the minimal non-negative k0 that satisfies k0 ≡ (-a) mod d (and automatically also k0 ≡ (-b) mod d, because a ≡ b mod d). Then, for that k0, the GCD(a+k0, b+k0) is at least d. Actually, we can get the exact GCD from k0: the GCD will be d' (which might be a multiple of d? Actually, no: the GCD is the greatest common divisor, so if we set k0 so that d divides both, then the GCD is at least d, but it might be larger. However, we are iterating over divisors of D, so we are covering all possibilities.\n\nBut note: the GCD might be a divisor of D, so we can iterate over the divisors of D. However, the problem is that the GCD could be any divisor of D, but also note that the GCD must divide D. So we can consider all divisors d of D, and then for each divisor d, we compute k0 (the smallest non-negative solution to k ≡ (-a) mod d). Then, we can compute the actual GCD for k0 (call it g0) and then use that to compute the LCM.\n\nHowever, note: the problem does not require to iterate over all div",
    "response": "\nTo solve this problem, we need to find a non-negative integer \\( k \\) such that the least common multiple (LCM) of \\( a + k \\) and \\( b + k \\) is minimized. If multiple values of \\( k \\) yield the same minimal LCM, we should choose the smallest \\( k \\).\n\n### Approach\n1. **Problem Analysis**: The key observation here is that the difference between \\( a + k \\) and \\( b + k \\) remains constant, i.e., \\( (a + k) - (b + k) = a - b \\). This means the GCD of \\( a + k \\) and \\( b + k \\) must divide \\( a - b \\). Therefore, we can consider all divisors of the absolute difference \\( |a - b| \\) to find potential candidates for \\( k \\) that maximize the GCD, which in turn minimizes the LCM.\n\n2. **Intuition**: For each divisor \\( d \\) of \\( |a - b| \\), we compute the smallest non-negative \\( k \\) such that \\( k \\equiv -a \\mod d \\). This \\( k \\) ensures that both \\( a + k \\) and \\( b + k \\) are divisible by \\( d \\). The actual GCD of \\( a + k \\) and \\( b + k \\) might be a multiple of \\( d \\), but we only need to consider divisors of \\( |a - b| \\) because any common divisor of \\( a + k \\) and \\( b + k \\) must divide their difference.\n\n3. **Algorithm Selection**: \n   - Compute all divisors of \\( |a - b| \\).\n   - For each divisor \\( d \\), compute the smallest \\( k \\) such that \\( k \\equiv -a \\mod d \\). This \\( k \\) is given by \\( k = (d - (a \\% d)) \\% d \\).\n   - For each computed \\( k \\), calculate the LCM of \\( a + k \\) and \\( b + k \\).\n   - Track the \\( k \\) that yields the smallest LCM. If multiple \\( k \\) values yield the same LCM, choose the smallest \\( k \\).\n\n4. **Complexity Analysis**: The number of divisors of \\( |a - b| \\) is \\( O(\\sqrt{n}) \\), where \\( n = |a - b| \\). For each divisor, we perform constant-time operations, making the overall complexity \\( O(\\sqrt{n}) \\), which is efficient for \\( n \\) up to \\( 10^9 \\).\n\n### Solution Code\n```python\nimport math\n\ndef get_divisors(n):\n    divisors = set()\n    if n == 0:\n        return {0}\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n        i += 1\n    return divisors\n\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    a = int(data[0])\n    b = int(data[1])\n    \n    if a == b:\n        print(0)\n        return\n        \n    D = abs(a - b)\n    divisors_list = sorted(get_divisors(D))\n    \n    best_k = 0\n    best_lcm = float('inf')\n    \n    for d in divisors_list:\n        remainder = a % d\n        if remainder == 0:\n            k = 0\n        else:\n            k = d - (a % d)\n        candidate1 = a + k\n        candidate2 = b + k\n        g = math.gcd(candidate1, candidate2)\n        current_lcm = (candidate1 * candidate2) // g\n        \n        if current_lcm < best_lcm:\n            best_lcm = current_lcm\n            best_k = k\n        elif current_lcm == best_lcm and k < best_k:\n            best_k = k\n            \n    print(best_k)\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input consists of two integers \\( a \\) and \\( b \\).\n2. **Special Case Handling**: If \\( a \\) and \\( b \\) are equal, the LCM is trivially minimized at \\( k = 0 \\).\n3. **Divisor Calculation**: The absolute difference \\( D = |a - b| \\) is computed, and all divisors of \\( D \\) are found.\n4. **Finding Optimal \\( k \\)**: For each divisor \\( d \\), the smallest \\( k \\) that satisfies \\( k \\equiv -a \\mod d \\) is calculated. The LCM of \\( a + k \\) and \\( b + k \\) is then computed.\n5. **Tracking Minimum LCM**: The algorithm keeps track of the smallest LCM encountered and the corresponding \\( k \\). If multiple \\( k \\) values yield the same LCM, the smallest \\( k \\) is chosen.\n6. **Output**: The optimal \\( k \\) is printed.\n\nThis approach efficiently narrows down the candidates for \\( k \\) by leveraging the divisors of the difference between \\( a \\) and \\( b \\), ensuring optimal performance even for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef get_divisors(n):\n    divisors = set()\n    if n == 0:\n        return {0}\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n        i += 1\n    return divisors\n\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    a = int(data[0])\n    b = int(data[1])\n    \n    if a == b:\n        print(0)\n        return\n        \n    D = abs(a - b)\n    divisors_list = sorted(get_divisors(D))\n    \n    best_k = 0\n    best_lcm = float('inf')\n    \n    for d in divisors_list:\n        remainder = a % d\n        if remainder == 0:\n            k = 0\n        else:\n            k = d - (a % d)\n        candidate1 = a + k\n        candidate2 = b + k\n        g = math.gcd(candidate1, candidate2)\n        current_lcm = (candidate1 * candidate2) // g\n        \n        if current_lcm < best_lcm:\n            best_lcm = current_lcm\n            best_k = k\n        elif current_lcm == best_lcm and k < best_k:\n            best_k = k\n            \n    print(best_k)\n\nif __name__ == '__main__':\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 396,
        "completion_token_count": 1124,
        "thoughts_token_count": 1023
    }
}