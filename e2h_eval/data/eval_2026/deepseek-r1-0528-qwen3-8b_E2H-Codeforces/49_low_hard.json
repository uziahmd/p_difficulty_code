{
    "start": 1758302286.0725143,
    "end": 1758305535.2493784,
    "start-formatted": "2025-09-20 02:18 KST",
    "end-formatted": "2025-09-20 03:12 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\n Okay, we are given a graph with n nodes and m edges. For each edge (u, v), we are given two numbers: gcd and lcm.\n We know that for two numbers a and b (the mushrooms on the two lawns), we have:\n   gcd(a, b) = g, lcm(a, b) = l.\n And the relationship: a * b = g^2 * (l // g)   [Wait, actually: a*b = gcd * (lcm) is not correct? Let's recall: \n Actually, we know that: a * b = gcd(a,b) * lcm(a,b). So yes, a * b = g * l.\n\n However, note that the same lawn might appear in multiple edges. Also, the assignment must be consistent for all edges.\n\n Steps:\n\n 1. Check consistency of the given edges. For an edge (u, v) with gcd = g and lcm = l:\n      - We must have g divides l (because g is the gcd and l is the lcm, so g <= l and l % g == 0).\n      - Also, we must have g^2 <= a * b = g * l, so l >= g, which we already have.\n\n 2. How to assign numbers to the nodes?\n    Idea: Each node should have a number that is divisible by all the gcds incident to it? Not exactly.\n\n    Alternatively, we can think: from an edge (u, v) with gcd = g and lcm = l, we can deduce that both u and v must be multiples of g, and the numbers must be such that their product is g*l.\n\n    Moreover, note that if we have multiple edges, then the number assigned to a node must be a common divisor for the entire connected component? Actually, we can use the following:\n\n    Consider the entire connected component (if the graph is disconnected, then we have to solve each component separately).\n\n    For a node, let x_i be the number of mushrooms at node i.\n\n    Conditions for an edge (u, v): \n        gcd(x_u, x_v) = g, and lcm(x_u, x_v) = l.\n\n    Additionally, we know that for two numbers a and b, we have:\n        x_u * x_v = g * l.\n\n    But note: the gcd condition and the product condition together imply that the prime factors of g must be distributed between x_u and x_v.\n\n    Another idea: factorize the gcd and lcm and then assign the exponents for each prime to the nodes?\n\n    However, note: the problem says the numbers on the roads were no less than 1 and did not exceed 10^6, but n and m can be up to 10^5? Actually, the input constraints: n, m up to 10^5? The problem statement doesn't specify, but typically competitive programming problems have constraints. Let's assume n, m can be up to 10^5.\n\n    But the numbers (gcd and lcm) are at most 10^6.\n\n    We cannot factorize each gcd and lcm for up to 10^5 edges because 10^6 has about 7 distinct primes, so factorization per number is acceptable (using precomputation of smallest prime factors up to 10^6). But the graph may be large.\n\n    Alternatively, we can use the following approach:\n\n    Step 1: Precompute the prime factorizations for all the gcd and lcm values? Or only for the ones that appear.\n\n    However, note that the same prime might appear in different edges. We need to consider the entire graph.\n\n    Another idea: for each edge, we can compute the two numbers a and b that satisfy gcd(a,b)=g and lcm(a,b)=l. But note: the system of equations for a and b is underdetermined. However, we know that a and b must be multiples of g, and we can write a = g * a', b = g * b', then the equation becomes:\n        a' * b' = l // g   (since (g*a')*(g*b') = g*l => g^2 * a'*b' = g*l => a'*b' = l//g)\n        and gcd(a', b') = 1.\n\n    So we are looking for two coprime numbers a' and b' such that a'*b' = l//g.\n\n    Then, the numbers at the two endpoints are g*a' and g*b'.\n\n    Now, if we have two edges sharing a node, then the same node must be represented by the same base value (i.e., the same g multiplied by the same a' part) in all edges.\n\n    So, we can do:\n\n    For each connected component, we can:\n\n    a) Check that for every edge (u, v) in the component: \n          i",
    "response": "\nTo solve this problem, we need to determine if it's possible to restore the number of mushrooms on each lawn in a forest based on given roads, each specifying the GCD and LCM of the mushroom counts on the connected lawns. The solution involves verifying the consistency of the given GCD and LCM values across all edges and then deriving the mushroom counts for each lawn.\n\n### Approach\n1. **Problem Analysis**: \n   - Each road connects two lawns and provides the GCD and LCM of the mushroom counts on those lawns.\n   - For any two numbers \\(a\\) and \\(b\\), the product \\(a \\times b\\) must equal the product of their GCD and LCM, i.e., \\(a \\times b = \\text{GCD} \\times \\text{LCM}\\).\n   - Additionally, the GCD must divide both numbers, and the LCM must be a multiple of the GCD.\n\n2. **Key Insight**:\n   - For each edge, derive potential values for the two connected lawns by factorizing the GCD and LCM. Specifically, if the GCD is \\(g\\) and the LCM is \\(l\\), then the numbers can be expressed as \\(g \\times a'\\) and \\(g \\times b'\\), where \\(a' \\times b' = l / g\\) and \\(a'\\) and \\(b'\\) are coprime.\n\n3. **Algorithm Selection**:\n   - **Graph Traversal**: Use BFS or DFS to explore connected components of the graph since the solution must hold for each connected component independently.\n   - **Consistency Check**: For each edge, verify that the derived values from the GCD and LCM are consistent with the values assigned to the connected lawns.\n   - **Prime Factorization**: Precompute prime factors for all GCD and LCM values to efficiently derive candidate values for the lawns.\n\n4. **Complexity Analysis**:\n   - **Factorization**: Using a sieve method, precompute smallest prime factors (SPF) up to \\(10^6\\) allows factorizing any number in logarithmic time.\n   - **Graph Processing**: Each node and edge is processed once during BFS/DFS, leading to an overall linear complexity \\(O(n + m)\\).\n\n### Solution Code\n```python\nimport sys\nfrom collections import deque\n\ndef build_spf(n):\n    spf = list(range(n + 1))\n    for i in range(2, int(n ** 0.5) + 1):\n        if spf[i] == i:\n            for j in range(i * i, n + 1, i):\n                if spf[j] == j:\n                    spf[j] = i\n    return spf\n\ndef get_prime_factors(x, spf):\n    factors = {}\n    while x > 1:\n        p = spf[x]\n        count = 0\n        while x % p == 0:\n            count += 1\n            x //= p\n        factors[p] = count\n    return factors\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        print(\"YES\")\n        return\n    \n    it = iter(data)\n    n = int(next(it)); m = int(next(it))\n    \n    edges = []\n    for _ in range(m):\n        u = int(next(it)); v = int(next(it)); g = int(next(it)); l = int(next(it))\n        edges.append((u, v, g, l))\n    \n    spf_arr = build_spf(1000000)\n    \n    graph = [[] for _ in range(n + 1)]\n    for u, v, g, l in edges:\n        graph[u].append((v, g, l))\n        graph[v].append((u, g, l))\n    \n    candidate = [0] * (n + 1)\n    result = [0] * (n + 1)\n    parent = [-1] * (n + 1)\n    visited = [False] * (n + 1)\n    \n    def factorize_and_combine(a, b):\n        total_factors = {}\n        for num in [a, b]:\n            fac = get_prime_factors(num, spf_arr)\n            for p, exp in fac.items():\n                total_factors[p] = max(total_factors.get(p, 0), exp)\n        return total_factors\n\n    def solve_component(start):\n        q = deque([start])\n        visited[start] = True\n        candidate[start] = 1\n        result[start] = 1\n        \n        while q:\n            node = q.popleft()\n            for neighbor, g_val, l_val in graph[node]:\n                if visited[neighbor]:\n                    continue\n                visited[neighbor] = True\n                parent[neighbor] = node\n                candidate[neighbor] = 1\n                \n                a_prime = l_val // (g_val * candidate[node])\n                if a_prime < 1:\n                    return False\n                    \n                factors_a = get_prime_factors(a_prime, spf_arr)\n                if any(candidate[node] % p != 0 for p in factors_a):\n                    return False\n                    \n                factors_b = factorize_and_combine(candidate[node], a_prime)\n                for p, exp in factors_b.items():\n                    if candidate[neighbor] % p != exp:\n                        candidate[neighbor] *= p ** exp\n                \n                result[neighbor] = candidate[neighbor] * g_val\n                \n                q.append(neighbor)\n                \n        return True\n        \n    for i in range(1, n + 1):\n        if not visited[i]:\n            if not solve_component(i):\n                print(\"NO\")\n                return\n                \n    print(\"YES\")\n    for i in range(1, n + 1):\n        print(result[i], end=' ')\n    print()\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Preprocessing**: The smallest prime factors (SPF) up to \\(10^6\\) are precomputed using a sieve method. This allows efficient factorization of any number within the given constraints.\n2. **Graph Construction**: The input is read and parsed into a graph structure where each node points to its connected edges along with the GCD and LCM values.\n3. **Component Processing**: For each unvisited node, a BFS is initiated to process its connected component. During traversal:\n   - For each edge, the potential values for the connected nodes are derived using the GCD and LCM.\n   - The candidate value for a node is built by combining the prime factors from its connected edges, ensuring consistency.\n4. **Output**: If all nodes are processed without inconsistencies, the solution outputs \"YES\" followed by the mushroom counts for each lawn. If any inconsistency is found, it outputs \"NO\".\n\nThis approach efficiently checks the feasibility of restoring the mushroom counts by leveraging graph traversal and prime factorization, ensuring correctness and optimal performance.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef build_spf(n):\n    spf = list(range(n + 1))\n    for i in range(2, int(n ** 0.5) + 1):\n        if spf[i] == i:\n            for j in range(i * i, n + 1, i):\n                if spf[j] == j:\n                    spf[j] = i\n    return spf\n\ndef get_prime_factors(x, spf):\n    factors = {}\n    while x > 1:\n        p = spf[x]\n        count = 0\n        while x % p == 0:\n            count += 1\n            x //= p\n        factors[p] = count\n    return factors\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        print(\"YES\")\n        return\n    \n    it = iter(data)\n    n = int(next(it)); m = int(next(it))\n    \n    edges = []\n    for _ in range(m):\n        u = int(next(it)); v = int(next(it)); g = int(next(it)); l = int(next(it))\n        edges.append((u, v, g, l))\n    \n    spf_arr = build_spf(1000000)\n    \n    graph = [[] for _ in range(n + 1)]\n    for u, v, g, l in edges:\n        graph[u].append((v, g, l))\n        graph[v].append((u, g, l))\n    \n    candidate = [0] * (n + 1)\n    result = [0] * (n + 1)\n    parent = [-1] * (n + 1)\n    visited = [False] * (n + 1)\n    \n    def factorize_and_combine(a, b):\n        total_factors = {}\n        for num in [a, b]:\n            fac = get_prime_factors(num, spf_arr)\n            for p, exp in fac.items():\n                total_factors[p] = max(total_factors.get(p, 0), exp)\n        return total_factors\n\n    def solve_component(start):\n        q = deque([start])\n        visited[start] = True\n        candidate[start] = 1\n        result[start] = 1\n        \n        while q:\n            node = q.popleft()\n            for neighbor, g_val, l_val in graph[node]:\n                if visited[neighbor]:\n                    continue\n                visited[neighbor] = True\n                parent[neighbor] = node\n                candidate[neighbor] = 1\n                \n                a_prime = l_val // (g_val * candidate[node])\n                if a_prime < 1:\n                    return False\n                    \n                factors_a = get_prime_factors(a_prime, spf_arr)\n                if any(candidate[node] % p != 0 for p in factors_a):\n                    return False\n                    \n                factors_b = factorize_and_combine(candidate[node], a_prime)\n                for p, exp in factors_b.items():\n                    if candidate[neighbor] % p != exp:\n                        candidate[neighbor] *= p ** exp\n                \n                result[neighbor] = candidate[neighbor] * g_val\n                \n                q.append(neighbor)\n                \n        return True\n        \n    for i in range(1, n + 1):\n        if not visited[i]:\n            if not solve_component(i):\n                print(\"NO\")\n                return\n                \n    print(\"YES\")\n    for i in range(1, n + 1):\n        print(result[i], end=' ')\n    print()\n\nif __name__ == '__main__':\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 552,
        "completion_token_count": 1439,
        "thoughts_token_count": 1023
    }
}