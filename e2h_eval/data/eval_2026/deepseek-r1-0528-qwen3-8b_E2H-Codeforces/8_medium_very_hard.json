{
    "start": 1758092037.2881565,
    "end": 1758093953.3863742,
    "start-formatted": "2025-09-17 15:53 KST",
    "end-formatted": "2025-09-17 16:25 KST",
    "gpu": 2,
    "pid": 8,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\n Okay, we are given an undirected graph and a flow volume for each edge. We need to assign a direction (0 or 1) to each edge such that:\n 1. For each vertex v (except source and sink), the sum of the incoming flow equals the sum of the outgoing flow.\n 2. The source (vertex 1) has no incoming edges.\n 3. The directed graph is acyclic.\n\n However, note that the problem says the graph is connected and a solution always exists.\n\n Observing the conditions, this is essentially about directing the edges so that the graph becomes a directed acyclic graph (DAG) with the conservation condition at every intermediate vertex (source and sink have no constraint on conservation except the source having no incoming).\n\n But note: the entire graph must form a flow from source to sink. The flow conservation condition is standard for flows.\n\n How to think?\n In a flow network, we usually have directed edges. Here, we start with an undirected graph and assign directions. The flow conservation condition (for vertices other than source and sink) is the key.\n\n However, note that the problem does not require the flow to be integer? But the input ci are integers and the example uses integers.\n\n Also note: the problem says \"the obtained directed graph does not have cycles\", so we are looking for a DAG.\n\n Moreover, the source must have no incoming edges.\n\n Since the graph is connected and the flow exists, we can use the following idea:\n\n The flow in a graph can be decomposed into paths and cycles. But here we are only given the capacities and the graph structure.\n\n However, note that the problem says: \"if there are several solutions, print any\".\n\n Approach:\n\n Idea 1: Use DFS/BFS to assign directions? But the graph is large (up to 200,000 nodes and 200,000 edges) so we need an efficient algorithm.\n\n Another idea: The flow conservation condition implies that the graph must be oriented so that the edges form directed paths from the source to the sink (with possible multiple layers). This is similar to topological ordering.\n\n We can try to assign directions by assigning a direction from the source to the sink for edges that are part of a path from source to sink, and the opposite direction for edges that are in the residual graph? But note: the problem does not specify the flow decomposition.\n\n Alternatively, consider the following:\n\n Condition: For each vertex (except source and sink), the in-flow must equal the out-flow.\n\n This is analogous to the flow being a circulation? Actually, the entire flow is from source to sink, so it is a unit flow (or multiple) but the graph might have multiple paths.\n\n However, note: the graph is undirected and we are assigning directions arbitrarily (but the total flow conditions must hold). \n\n Observation: The entire flow must be from source to sink. Therefore, the graph must have a directed acyclic structure with source at one end and sink at the other.\n\n How about building a spanning tree? We know that the graph is connected.\n\n Steps:\n\n 1. We can use BFS/DFS to traverse the graph and assign directions based on the distance from the source.\n\n However, note: the problem does not specify the exact flow, so we are free to choose any orientation as long as the conservation holds and the graph is acyclic.\n\n Let's think of a simpler way:\n\n Consider that the graph must be split into two parts: one from source to sink. Then, we can direct edges from the source side to the sink side as one direction, and the reverse as the other? But wait: an edge might be connecting two nodes that are both in the same side? Then how?\n\n Actually, the flow conservation condition requires that the net flow through each node (except source and sink) is zero. Therefore, we can think of the graph as having a kind of bipartition: nodes that are closer to the source and nodes that are closer to the sink.\n\n But note: the graph is undirected and we are allowed to use any assignment. \n\n Alternate approach:\n\n We can use the concept of a \"depth\" from the source. Assign a depth (or level) to each node by doing a BFS starting from the source (vertex 1). Then, we can direct an edge (u, v) from u to v if the depth of u is less than the depth of v, and from v to u otherwise.\n\n Why would this work?\n\n - The source (depth 0) has no incoming: because all edges incident to source go from source (depth 0) to higher depth nodes (so they are outgoing).\n - For an internal node, the incoming edges are those from nodes with smaller depth (so from the source side) and outgoing to larger depth (sink side). But then the flow conservation condition: the total incoming flow must equal the total outgoing flow.\n\n However, consider an edge that connects two nodes with the same depth? Then we have to direct one of them arbitrarily. But wait, if we have an edge between two nodes of the same depth, then we cannot assign a direction without violating the condition? Actually, we can: the condition for that node (if it is not the source) must have the same amount of flow coming in and going out.\n\n But note: if two adjacent nodes have the same depth, then one of the two edges must be directed towards the node and the other away? Not necessarily, because there might be other edges.\n\n However, the problem states that the graph is connected and a solution exists. But our BFS depth assignment might not be unique (we can have multiple shortest paths). \n\n But let me test with the example:\n\n Example 1: \n   Input: \"3 3\\n3 2 10\\n1 2 10\\n3 1 5\"\n\n   We have three edges: (3,2,10), (1,2,10), (3,1,5)\n\n   Let's build the graph and do BFS from node 1:\n\n     Node 1: depth 0\n     From 1: edge to 2 (weight 10) -> depth[2] = 1\n             edge to 3 (weight 5) -> depth[3] = 1\n\n     Now, from 2: we see edge to 3 (weight 10). Since depth[3] is already 1, which is same as depth[2] (which is 1)? Then we have an edge between two nodes of the same level.\n\n   Now, how to direct the edge (2,3) with weight 10? \n\n   According to the rule: \n        if depth[u] < depth[v]: then u->v\n        else if depth[u] > depth[v]: then v->u\n        else: we have a tie.\n\n   But note: the problem says the graph is connected and solution exists. However, the above method might not satisfy the flow conservation condition for node 2 and node 3.\n\n   Let's compute the flow for node 2:\n        Incoming edges: from 1 (flow 10) and from 3 (flow 10) [if we direct the edge from 3 to 2 then that is incoming]\n        Outgoing edges: to 3 (if we direct the edge from 2 to 3, then that is outgoing) or none if we direct from 3 to 2.\n\n   If we direct the edge (2,3) from 3 to 2, then:\n        Node 2: incoming = 10 (from 1) + 10 (from 3) = 20; outgoing = 0 -> not balanced.\n\n   If we direct from 2 to 3, then:\n        Node 2: incoming = 10 (from 1); outgoing = 10 (to 3) -> balanced.\n        Node 3: incoming = 10 (from 2) and 5 (from 1) [because edge (3,1) is directed from 1 to 3?] -> wait, edge (1,3) was from 1 (depth0) to 3 (depth1) so that's outgoing from 1 and incoming to 3. Then edge (3,2) is directed from 3 to 2 (if we break the tie by using the order of the BFS? Or by some rule) but we didn't specify.\n\n   Actually, in the BFS we set depth[3]=1 from the edge (1,3). Then when we process node 2, we see edge (2,3) and since depth[2]==depth[3], we have to choose an arbitrary direction.\n\n   But note: the condition requires the entire graph to be acyclic. So we cannot have a cycle. Therefore, we must direct edges consistently with the depth ordering, but when there is a tie, we cannot create a cycle.\n\n   However, if we direct the edge (2,3) from 2 to 3, then the path from 1->2->3 is directed and we don't have a cycle. But what about the edge (3,1)? It was directed from 1 to 3. Then we have a cycle? \n        1->3->2->3? No, because from 3 to 2 is an edge, and then from 2 to 3 is an edge, so we have a cycle 2->3->2.\n\n   So we must avoid cycles.\n\n   Therefore, we cannot arbitrarily direct edges between nodes of the same depth. We must ensure that the entire graph is acyclic.\n\n   How to enforce acyclicity? We can use the depth (or level) to break ties, but if we direct an edge from a node to another node of the same depth, then we might create a cycle.\n\n   Alternative idea: use DFS to assign directions? Or use strongly connected components? But the graph is undirected and we are building a directed graph that must be acyclic.\n\n   Actually, we can use the concept of a spanning tree and then the remaining edges are non-tree edges. We can direct the tree edges from the root (source) to the leaves (sink) and then for the non-tree edges, we direct them from the node closer to the source to the node further (if they are in the same tree) or arbitrarily? But wait, the graph is undirected and we are not given a rooted tree.\n\n   However, note: the BFS tree we built from the source gives us levels. Then we can require that for every edge (u, v):\n        if depth[u] < depth[v], then we direct from u to v (meaning flow from u to v)\n        if depth[u] > depth[v], then we direct from v to u (meaning flow from v to u)\n        if depth[u] == depth[v], then we have to choose one direction. But note: if we choose arbitrarily, we might create a cycle.\n\n   But observe: the BFS tree is acyclic. The non-tree edges (with same depth) form cycles? Actually, in a BFS tree, edges between nodes of the same depth are exactly the ones that connect two nodes in the same level (and they form cycles). However, we must direct them without creating a cycle.\n\n   How about: for edges with the same depth, we direct them from the node that was visited first (by BFS) to the node visited later? Then, the entire graph would be acyclic? \n\n   Actually, no: because if we have two nodes u and v at the same depth, and we direct from u to v, then we are adding an edge that goes forward (from the BFS tree) and doesn't form a cycle? \n\n   But consider: we have two nodes u and v at depth d, and suppose they are connected by an edge. We also have paths from the source to u and to v (which are the same length). Then, if we direct from u to v, then we have a path from u to v, and also from v to u? No, because we only direct one way. But then, the flow conservation condition must hold.\n\n   However, note: the entire graph must be acyclic. So we cannot have a back edge (in the directed sense) that forms a cycle.\n\n   But if we direct an edge from u to v and u was visited before v in BFS, then we are effectively making an edge from an earlier node to a later node. Then, the entire graph is a DAG if we only allow edges from lower depth to higher depth, and for same depth we direct from the one visited first to the one visited later (so that we don't create backward edges). However, this does not necessarily form a DAG because two nodes of the same depth might be connected to nodes of the same depth and then we have edges that are not increasing the depth.\n\n   Actually, the condition for acyclicity is that the graph has a topological order. We can define the topological order as the BFS order (by depth) and then for same depth, the order of discovery.\n\n   Then, we can say: \n        For an edge (u, v):\n            if depth[u] < depth[v]: then direct from u to v (so u->v)\n            if depth[u] > depth[v]: then direct from v to u (so v->u)\n            if depth[u] == depth[v]:\n                then check the discovery time (or the order in which we visited them in BFS): \n                    if u was discovered before v, then direct from u to v (so u->v)\n                    else from v to u (so v->u)\n\n   Then, the entire graph has edges that go from a node to a node that is either deeper (so increasing depth) or at the same depth but later in BFS order. This ensures that there is no cycle because if you follow the edges, the depth is non-decreasing and within the same depth we are moving from earlier to later (so no cycles).\n\n   Now, let's test with the example:\n\n        Nodes: 1 (depth0), 2 (depth1), 3 (depth1)\n        Edges: \n            (3,2,10): depth[3] == depth[2] (both 1). Which one was discovered first? \n                We started from 1. We first discovered 2 (edge 1-2) then 3 (edge 1-3). So for the edge (3,2): \n                    depth[3]==depth[2] -> same, and 3 was discovered after 2? So we direct from 2 to 3? \n                But wait, we have to be consistent with the BFS order: we can record the time (discovery order) for each node.\n\n        Let me reassign: \n            We do BFS from 1: \n                Queue: [1]\n                Pop 1, mark depth[1]=0, time[1]=0.\n                Then we look at neighbors: 2 and 3. Suppose we visit 2 first (then 3) because the input order? But the problem does not specify the graph's structure beyond the given edges.\n\n        However, the input order of edges is fixed, but we can choose the order of exploring edges arbitrarily? \n\n        We are told the edges, so we can build the graph arbitrarily. But the problem does not specify the BFS order. \n\n        But note: the graph is undirected. We can break ties arbitrarily, but we must output the answer in the order of the input edges.\n\n        However, the problem requires to output m lines, each corresponding to the i-th edge.\n\n        So we must assign a direction for each edge independently, but the entire graph must be acyclic and satisfy flow conservation.\n\n        The above method (using BFS and then same depth by discovery time) produces a DAG.\n\n        Now, does it satisfy the flow conservation?\n\n        Example 1: \n            Edge1: (3,2,10) -> directed from 2 to 3 (because 2 was discovered before 3, so we direct from 2 to 3? Actually, wait: we have two nodes of same depth. We are at edge (3,2). We compare: \n                depth[3] == depth[2] -> same.\n                discovery_time[2] = t1, discovery_time[3] = t2 (t1 < t2). Then we direct from the node with lower discovery_time (2) to the node with higher (3) for the edge (2,3) but note: the edge is given as (3,2). \n\n            Actually, we have to consider the two endpoints. We don't know which one was discovered first. But note: the edge (3,2) is stored as (3,2). We can write a function for the edge (u, v):\n\n            Rule:\n                if depth[u] < depth[v]: then direction is from u to v -> output 0 (meaning u->v, so for the edge (u,v) we output 0 for the direction from u to v)\n                if depth[u] > depth[v]: then direction is from v to u -> output 1 (meaning we output 1 for the edge (u,v) because we are directing from v to u, which is the opposite of u->v)\n                if depth[u] == depth[v]:\n                    if discovery_time[u] < discovery_time[v]: then direction is from u to v -> output 0\n                    else: output 1\n\n            But note: the edge is given as (ai, bi). So for the edge (3,2): \n                u=3, v=2: depth[3]==depth[2] -> same, then compare discovery_time: if discovery_time[3] < discovery_time[2]? Then output 0 (meaning 3->2) else 1 (meaning 2->3).\n\n            However, we built the BFS tree from node 1. In the BFS, we started from 1 and then we visited 2 first (because the edge (1,2) is given second? Actually, the input order is:\n\n                \"3 3\"\n                \"3 2 10\"\n                \"1 2 10\"\n                \"3 1 5\"\n\n            So the edges are: \n                edge0: (3,2,10)\n                edge1: (1,2,10)\n                edge2: (3,1,5)\n\n            Now, we build the graph:\n\n                Node1: neighbors: 2 (weight10), 3 (weight5)\n                Node2: neighbors: 1 (weight10), 3 (weight10)\n                Node3: neighbors: 1 (weight5), 2 (weight10)\n\n            BFS from 1:\n\n                We start at 1. We look at edges (1,2) and (1,3). The order of processing these edges is not specified. But we can choose the order arbitrarily? \n\n            However, the problem does not specify the BFS order. But note: the graph is connected and we are free to choose any solution.\n\n            Let's assume we process edges in the order of the input? Actually, we can use any order, but we need to assign discovery_time.\n\n            But note: the problem requires to output the direction for each edge in the order of the input.\n\n            How do we know the discovery_time of a node? We can do:\n\n                Let's store the graph as an adjacency list. For each node, we store the neighbors and the edge index (so we know which edge we are considering).\n\n            However, we don't need to know the edge index during BFS for the rule, but we need to assign the direction for each edge.\n\n            Steps:\n\n                Step1: Read n, m and the m edges.\n\n                Step2: Build graph: for each edge i, store (neighbor, weight) for node u, and (neighbor, weight) for node v.\n\n                Step3: Do BFS starting from node 1 to assign depth and discovery_time (the time when the node is first visited).\n\n                But note: the graph is undirected, so we must avoid going back to parent? We can do:\n\n                    Let parent be recorded to avoid immediate cycle, but actually BFS naturally avoids cycles.\n\n                Step4: For each edge (u, v, w) (in the input order), apply the rule:\n\n                    if depth[u] < depth[v]:\n                        direction = 0   (u->v)\n                    elif depth[u] > depth[v]:\n                        direction = 1   (v->u, meaning the edge is directed from v to u, so for the representation (u,v) we output 1 because the desired direction is from v to u)\n                    else: # same depth\n                        if discovery_time[u] < discovery_time[v]:\n                            direction = 0   (u->v)\n                        else:\n                            direction = 1   (v->u)\n\n                However, wait: in the same depth case, we are comparing two nodes. But we must know the discovery_time of u and v.\n\n            But note: during BFS, we assign depth and discovery_time (as the time step when the node is popped from the queue, or pushed? Typically we assign the time when we first enqueue the node).\n\n            Example 1:\n\n                We have three edges. Let's do BFS from node 1.\n\n                Option: We process edges from node 1 in the order of input? Or in any order? \n\n                The input order of edges incident to 1: \n                    First edge: (3,2,10) -> but node1 is not in this edge.\n                    Second edge: (1,2,10) -> edge from 1 to 2.\n                    Third edge: (3,1,5) -> edge from 1 to 3.\n\n                Actually, we should build the graph with all edges. Then, from node1, the neighbors are 2 and 3.\n\n                How we order the edges from node1? The problem does not specify. We can choose the order arbitrarily. But the discovery_time depends on the order.\n\n                Let's choose an order for the edges from a node. We can sort the edges by the node index? Or simply use the order of the input for the edges? \n\n                Actually, we don't care about the particular BFS order as long as the entire graph is acyclic and the flow conservation holds.\n\n                However, the example output is:\n\n                    Input: \n                        3 3\n                        3 2 10\n                        1 2 10\n                        3 1 5\n\n                    Output:\n                        1\n                        0\n                        1\n\n                Meaning: \n                    Edge0: (3,2,10) -> direction 1 (so from 2 to 3)\n                    Edge1: (1,2,10) -> direction 0 (from 1 to 2)\n                    Edge2: (3,1,5) -> direction 1 (so from 1 to 3? Wait, no: direction 1 means the opposite of (3,1). The edge is (3,1). So if direction is 1, then we direct from 1 to 3.\n\n                Now, let's simulate with our rule:\n\n                    Edge0: (3,2,10): \n                        depth[3] and depth[2]: \n                            We did BFS from 1. \n                            We must assign depths to 2 and 3.\n\n                    How did we get the depths?\n                        We start at 1 (depth0). Then we visit its neighbors: 2 and 3.\n\n                    What order did we use to visit the neighbors of 1? \n\n                    We have two edges from 1: (1,2) and (1,3). The input order of edges is:\n\n                        0: (3,2,10) -> not incident to 1\n                        1: (1,2,10) -> incident to 1\n                        2: (3,1,5) -> incident to 1\n\n                    So the edges incident to 1 are the second and third in input. We can process the edges in any order? \n\n                    Let's assume we process the edges incident to 1 in the order of increasing node index? Then we would process node2 first (since 2<3) and then node3.\n\n                    Then:\n                        1: depth0, then we visit 2: depth1, then 3: depth1.\n\n                    Then for edge0: (3,2): depth[3]==depth[2] -> same. Then compare discovery_time: \n                        2 was discovered at time t=1 (if we consider the first neighbor processed at time1, then the next at time2) and 3 at time2.\n                        Then for edge (3,2): since discovery_time[3] (which is 2) > discovery_time[2] (which is 1), then we direct from 2 to 3 -> so for edge0 (which is (3,2)) we output 1 (meaning from 2 to 3) -> matches the expected output.\n\n                    Edge1: (1,2): depth[1]=0 < depth[2]=1 -> output 0 (from 1 to 2) -> matches.\n\n                    Edge2: (3,1): depth[3]=1 > depth[1]=0 -> output 1 (meaning from 1 to 3) -> matches.\n\n                So the example works.\n\n            Example 2:\n\n                Input: \"4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5\"\n\n                Expected output: \"0\\n0\\n1\\n1\\n0\"\n\n                Let's build the graph:\n\n                    Nodes: 1,2,3,4\n\n                    Edges:\n                        0: (1,2,10)\n                        1: (1,3,10)\n                        2: (2,3,5)\n                        3: (4,2,15)\n                        4: (3,4,5)\n\n                Now, do BFS from node1:\n\n                    Start at 1 (depth0, time0).\n                    Neighbors: 2 and 3 (from edges0 and 1).\n\n                    We can choose the order of visiting 2 and 3 arbitrarily. Let's say we visit 2 first then 3.\n\n                    Then:\n                        1 -> 2: depth1, time1\n                        1 -> 3: depth1, time2\n\n                    Then from 2: \n                        2's neighbors: 1 (already visited), 3 (edge2: weight5), 4 (edge3: weight15)\n                        We go to 3 (depth1, same as 2) and 4 (depth2).\n\n                    Then from 3: \n                        3's neighbors: 1 (visited), 2 (visited), 4 (edge4: weight5) -> but 4 is already visited from 2? Actually, we visit 4 from 2 first.\n\n                    Let's do:\n\n                        Queue: [1] -> pop 1, then push 2 and 3 (in that order) -> then we process 2 next.\n\n                        From 2: \n                            Check neighbors: 1 (skip), 3 (edge2) -> depth[3] is 1 (same as 2) -> so we mark 3 as visited again? Actually, we don't need to push 3 again because we already visited 3.\n\n                        Then from 2, we also have 4: so we push 4 (depth2, time3).\n\n                        Then from 3: \n                            Already visited, so skip.\n\n                        Then from 4: \n                            Check neighbors: 2 (visited), 3 (edge4) -> depth[3]=1 < depth[4]=2, so we don't push 3 again.\n\n                    So depths:\n                        1:0, 2:1, 3:1, 4:2\n\n                    Now, process each edge in input order:\n\n                    Edge0: (1,2,10): depth1=0<1 -> output0 (from1 to2)\n                    Edge1: (1,3,10): depth1=0<1 -> output0 (from1 to3)\n                    Edge2: (2,3,5): depth2=1 == depth3=1 -> same. Then compare discovery_time: \n                            discovery_time: 1:0, 2:1, 3:2, 4:3.\n                            For node2: time1, node3: time2 -> 1<2 -> output0 (from2 to3) -> but expected output for edge2 is 1.\n\n                    Wait, the expected output is: \n                        0\n                        0\n                        1\n                        1\n                        0\n\n                    So the third edge (edge2) should output 1.\n\n                    Our rule for edge2 (2,3) outputs 0.\n\n                    Why?\n\n                    The expected output for edge2 is 1, meaning the direction is from 3 to2.\n\n                    According to the rule, we output 0 if we direct from the node with lower discovery_time to the one with higher. But 2 was discovered at time1 and 3 at time2, so we direct from2 to3.\n\n                    Why is the expected output 1?\n\n                    Let me check the example: \n\n                    The example input: \n                        4 5\n                        1 2 10\n                        1 3 10\n                        2 3 5\n                        4 2 15\n                        3 4 5\n\n                    Expected output: \n                        0\n                        0\n                        1\n                        1\n                        0\n\n                    This means:\n                        Edge0: (1,2) -> 0 (1->2)\n                        Edge1: (1,3) -> 0 (1->3)\n                        Edge2: (2,3) -> 1 (so the direction is from 3 to2, i.e., 3->2)\n                        Edge3: (4,2) -> 1 (so from2 to4? Wait, no: the edge is (4,2). Direction 1 means the opposite of (4,2) so from2 to4? Actually, the problem says: \n                            \"0 if the direction of the i-th edge is ai→bi\"\n                            \"1 otherwise\"\n\n                        So for edge3: (4,2) -> direction1 means the flow is from 2 to4.\n\n                        Edge4: (3,4) -> 0: from3 to4.\n\n                    Now, let's check the flow conservation:\n\n                    Node1: \n                        Outgoing: (1->2)=10, (1->3)=10 -> total 20.\n                        Incoming: none -> ok.\n\n                    Node2:\n                        Incoming: from1 (10), from4 (15) [if edge3 is directed from2 to4, then wait no: edge3 is (4,2) with direction1, so we direct from2 to4, so incoming to2 is from4? Actually, no: if we direct edge3 as from2 to4, then for node2, that edge is outgoing. And for node4, that edge is incoming.\n\n                        But wait, the rule for edge3 (4,2): \n                            depth[4]=2, depth[2]=1 -> 2>1, so we direct from2 to4 (output1) -> correct.\n\n                        Now, for node2: \n                            Outgoing: (2->1) -> no, because edge0 is directed from1 to2 (so 1->2) and edge3 is from2 to4, and edge2 is from3 to2 (so 3->2) -> so outgoing: 10 (from2 to?) and 15 (from2 to4) and incoming: from1 (10) and from3 (5) [edge2 is (2,3) with direction1 meaning from3 to2, so 3->2: that's incoming] and also from4? no, because edge3 is directed from2 to4, so no incoming from4.\n\n                        Actually, the edges incident to node2 are: \n                            edge0: (1,2) -> 0 (from1 to2) -> incoming to2: 10\n                            edge2: (2,3) -> 1 (from3 to2) -> incoming to2: 5\n                            edge3: (4,2) -> 1 (from2 to4) -> outgoing: 15\n\n                        Then the incoming flow to2: 10+5=15, outgoing:15 -> balanced.\n\n                    Node3:\n                        Outgoing: edge1: (1->3)=10 (outgoing from1 to3, so incoming to3:10), edge2: (3->2)=5 (outgoing from3 to2) -> wait, no: edge2 is (2,3) and we directed from3 to2, so outgoing from3 to2:5.\n                        Incoming: edge1: from1:10, edge4: from4? Let's check edge4: (3,4): depth[3]=1, depth[4]=2 -> 1<2, so we direct from3 to4 (output0) -> so outgoing from3 to4:5.\n\n                        Then node3: \n                            Incoming: from1:10\n                            Outgoing: to2:5, to4:5 -> total outgoing 10 -> balanced.\n\n                    Node4:\n                        Incoming: from2:15, from3:5 -> total 20\n                        Outgoing: none? (sink) -> ok.\n\n                    Now, why did our rule output 0 for edge2 (2,3) but the expected output is 1?\n\n                    Our rule for edge2 (2,3): \n                        depth[2]=1, depth[3]=1 -> same.\n                        discovery_time[2]=1, discovery_time[3]=2 -> so we direct from2 to3 (output0). \n\n                    But the expected output is 1 (direct from3 to2).\n\n                    Why is that?\n\n                    The problem says: \"if there are several solutions, print any\". So both are valid? \n\n                    However, we must check the entire graph for acyclicity.\n\n                    With our direction for edge2: from2 to3, then the graph has edges:\n                        1->2, 1->3, 2->3, 2->4, 3->4.\n\n                    Then we have a cycle: 2->3->4->2? \n                        There's no edge from4 to2. But we have edge from2 to4 and from4 to3 (via edge4: (3,4) directed from3 to4, so no, edge4 is from3 to4, not from4 to3). \n\n                    Actually, the graph is:\n                        1->2, 1->3, 2->3, 2->4, 3->4.\n\n                    This is acyclic.\n\n                    Now, with the other direction (edge2: from3 to2) then the graph has edges:\n                        1->2, 1->3, 3->2, 2->4, 3->4.\n\n                    Then, we have an edge from3 to2 and from2 to4 and from3 to4. This is also acyclic.\n\n                    So both are valid. Then why the sample output is 1?\n\n                    The problem says: \"if there are several solutions, you can print any\".\n\n                    So we can output either. But our rule outputs 0 for edge2, and the sample output is 1.\n\n                    Therefore, we must be cautious: the problem expects a specific output? \n\n                    Looking at the example output, it is provided. But note: the problem statement says \"help him find for each edge the direction\", and \"if there are several solutions, print any\".\n\n                    So our solution is acceptable even if we output 0 for edge2.\n\n                    However, the example output is given as:\n\n                        0\n                        0\n                        1\n                        1\n                        0\n\n                    So if we output:\n\n                        0\n                        0\n                        0\n                        1\n                        0\n\n                    Then that is also acceptable.\n\n                    But wait, the example output is:\n\n                        ['0\\n0\\n1\\n1\\n0']\n\n                    So they expect the third edge to be 1.\n\n                    Why? \n\n                    Maybe the problem expects the flow to be decomposed in a particular way? \n\n                    Alternatively, the problem might require that the flow is directed so that the entire graph is a directed acyclic graph with the source at one end and the sink at the other, and the flow is from source to sink. \n\n                    But note: the problem does not specify the flow decomposition.\n\n                    However, note: the problem says \"the resulting flow should be correct maximum flow\". \n\n                    But we are not given the maximum flow value, only the graph and the edge capacities. And we are to assign directions arbitrarily as long as the conditions hold.\n\n                    So both solutions are correct.\n\n                    But the problem says: \"You should direct all edges in such way that the following conditions hold\".\n\n                    Conditions are:\n                        1. For each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges.\n                        2. Vertex with number 1 has no incoming edges.\n                        3. The obtained directed graph does not have cycles.\n\n                    Both solutions satisfy these.\n\n                    Therefore, we can output either.\n\n                    However, the sample output is 1 for the third edge.\n\n                    Why did they choose that?\n\n                    Let me check the example flow:\n\n                    The graph has 4 nodes and 5 edges.\n\n                    The maximum flow from 1 to 4: \n\n                        We can send 10 along 1->2->4 (edge0:10, edge3:15 -> but wait, edge3 is (4,2) with capacity15, so we can send min(10,15)=10 from 1->2->4.\n                        And we can send 10 along 1->3->4 (edge1:10, edge4:5) -> but edge4 (3,4) has capacity5, so we can send 5 from 1->3->4, and the remaining 5 from 1->3->2->4? \n\n                    Actually",
    "response": "\nTo solve this problem, we need to direct the edges of an undirected graph such that the resulting directed graph satisfies specific flow conditions. The conditions are: for each vertex (except the source and sink), the sum of incoming flow equals the sum of outgoing flow; the source has no incoming edges; and the graph is acyclic. \n\n### Approach\n1. **Problem Analysis**: The problem involves transforming an undirected graph into a directed acyclic graph (DAG) where flow conservation holds at each intermediate vertex. The key insight is that the graph must be oriented in a way that mimics a topological order from the source to the sink.\n2. **Intuition**: Using BFS starting from the source (vertex 1), we assign each node a depth (distance from the source) and a discovery time (order in which nodes are visited). For each edge, we direct it from the node with the smaller depth to the node with the larger depth. If depths are equal, we direct it based on the discovery time (earlier discovered node to later discovered node).\n3. **Algorithm Selection**: BFS is chosen because it efficiently computes the shortest path distances (depths) from the source. The discovery time helps break ties when nodes are at the same depth, ensuring the graph remains acyclic.\n4. **Complexity Analysis**: The BFS runs in O(n + m) time, where n is the number of vertices and m is the number of edges. Processing each edge during BFS and determining its direction is O(1) per edge, making the overall complexity O(n + m), which is efficient for the given constraints.\n\n### Solution Code\n```python\nimport sys\nfrom collections import deque\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    it = iter(data)\n    n = int(next(it)); m = int(next(it))\n    \n    graph = [[] for _ in range(n+1)]\n    edges = []\n    \n    for i in range(m):\n        a = int(next(it)); b = int(next(it)); c = int(next(it))\n        edges.append((a, b, c))\n        graph[a].append((b, c, i))\n        graph[b].append((a, c, i))\n    \n    depth = [-1] * (n+1)\n    disc_time = [-1] * (n+1)\n    parent = [-1] * (n+1)\n    depth[1] = 0\n    disc_time[1] = 0\n    q = deque([1])\n    \n    while q:\n        u = q.popleft()\n        for v, weight, idx in graph[u]:\n            if depth[v] == -1:\n                depth[v] = depth[u] + 1\n                disc_time[v] = disc_time[u] + 1\n                parent[v] = u\n                q.append(v)\n    \n    res = [0] * m\n    for i in range(m):\n        a, b, c = edges[i]\n        if depth[a] < depth[b]:\n            res[i] = 0\n        elif depth[a] > depth[b]:\n            res[i] = 1\n        else:\n            if disc_time[a] < disc_time[b]:\n                res[i] = 0\n            else:\n                res[i] = 1\n                \n    for i in range(m):\n        print(res[i])\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into the number of vertices (n) and edges (m), followed by the edges themselves.\n2. **Graph Construction**: An adjacency list is built to represent the graph, storing each edge's endpoints, weight, and index for reference.\n3. **BFS Initialization**: Starting from the source vertex (1), BFS initializes the depth and discovery time for each node. The depth is the shortest path distance from the source, and the discovery time records the order of node visits.\n4. **Edge Direction Determination**: For each edge, the direction is determined by comparing the depths of its endpoints. If depths differ, the edge is directed from the node with the smaller depth to the larger. If depths are equal, the edge is directed from the node with the earlier discovery time to the later one.\n5. **Output**: The directions for all edges are printed in the order they were read.\n\nThis approach ensures the directed graph meets all specified conditions, leveraging BFS for efficient depth and discovery time computation, and handling edge directions based on these values to maintain acyclicity and flow conservation.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    it = iter(data)\n    n = int(next(it)); m = int(next(it))\n    \n    graph = [[] for _ in range(n+1)]\n    edges = []\n    \n    for i in range(m):\n        a = int(next(it)); b = int(next(it)); c = int(next(it))\n        edges.append((a, b, c))\n        graph[a].append((b, c, i))\n        graph[b].append((a, c, i))\n    \n    depth = [-1] * (n+1)\n    disc_time = [-1] * (n+1)\n    parent = [-1] * (n+1)\n    depth[1] = 0\n    disc_time[1] = 0\n    q = deque([1])\n    \n    while q:\n        u = q.popleft()\n        for v, weight, idx in graph[u]:\n            if depth[v] == -1:\n                depth[v] = depth[u] + 1\n                disc_time[v] = disc_time[u] + 1\n                parent[v] = u\n                q.append(v)\n    \n    res = [0] * m\n    for i in range(m):\n        a, b, c = edges[i]\n        if depth[a] < depth[b]:\n            res[i] = 0\n        elif depth[a] > depth[b]:\n            res[i] = 1\n        else:\n            if disc_time[a] < disc_time[b]:\n                res[i] = 0\n            else:\n                res[i] = 1\n                \n    for i in range(m):\n        print(res[i])\n\nif __name__ == '__main__':\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 696,
        "completion_token_count": 951,
        "thoughts_token_count": 8191
    }
}