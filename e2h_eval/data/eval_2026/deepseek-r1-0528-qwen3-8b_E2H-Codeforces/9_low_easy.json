{
    "start": 1758093133.078029,
    "end": 1758094938.6841822,
    "start-formatted": "2025-09-17 16:12 KST",
    "end-formatted": "2025-09-17 16:42 KST",
    "gpu": 2,
    "pid": 9,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Selling Souvenirs\n\nAfter several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.This morning, as usual, Petya will come to the market. Petya has n different souvenirs to sell; ith souvenir is characterised by its weight wi and cost ci. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than m, and total cost is maximum possible.Help Petya to determine maximum possible total cost.\n\n## Input\nThe first line contains two integers n and m (1 ≤ n ≤ 100000, 1 ≤ m ≤ 300000) — the number of Petya's souvenirs and total weight that he can carry to the market.Then n lines follow. ith line contains two integers wi and ci (1 ≤ wi ≤ 3, 1 ≤ ci ≤ 109) — the weight and the cost of ith souvenir.\n\n## Output\nPrint one number — maximum possible total cost of souvenirs that Petya can carry to the market.\n\n## Example\n### Input\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\n### Output\n['0', '3', '10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\n We are given up to 100000 souvenirs, each with weight in {1,2,3} and cost up to 10^9.\n Since the weights are only 1, 2, or 3, we can group the souvenirs by their weight.\n\n Let:\n   type1 = list of costs for souvenirs with weight 1\n   type2 = list of costs for souvenirs with weight 2\n   type3 = list of costs for souvenirs with weight 3\n\n Then, we need to choose a subset such that the total weight is <= m and the total cost is maximized.\n\n Note: The total weight is the sum of the weights of the chosen souvenirs.\n\n Since the weights are small (only 1,2,3) and the maximum m is 300000, we can use dynamic programming but note that n can be up to 100000.\n\n However, we have three types. We can consider:\n\n Option 1: Use DP with state [i][j] meaning using the first i types (grouped by weight) and having total weight j, what is the maximum total cost?\n But m can be up to 300000, so a naive DP table would be too big.\n\n Alternative approach:\n\n We can use the idea of \"knapsack with small weights\" and \"unbounded knapsack\" but note that we have multiple items per weight and we cannot use an item more than once (each souvenir is one copy). Actually, each souvenir is distinct and we can only take one copy of each.\n\n However, note that the problem says \"subset\", so we have 0/1 knapsack for each souvenir. But the weights are only 1,2,3 and we have many items (up to 100000) but the total weight is limited to 300000.\n\n We can do:\n\n   Sort the souvenirs by weight? But actually, we have three groups.\n\n Another idea: since the weights are only 1,2,3, we can consider that any total weight can be written as:\n   Let x1 be the number of weight1 items, x2 for weight2, x3 for weight3.\n   Then the total weight is: x1 + 2*x2 + 3*x3 <= m.\n\n And we want to maximize: sum of costs from the chosen items.\n\n We can break the problem into three independent groups and then combine? But note: we can choose at most all the items from each group, but we must choose without exceeding the weight.\n\n However, we have to consider that we can choose any combination of the three. This is a bounded knapsack with three types and small weights.\n\n Steps:\n\n 1. Group the items by weight (1,2,3).\n\n 2. For each group, sort the items by cost (or value) in descending order. Why? Because we want to use the most valuable ones first.\n\n 3. Precompute for each group the prefix sums for the top k items (for k from 0 to the size of the group). But note: we might not use all, and we are going to combine with other groups.\n\n 4. Then, we can iterate over the number of items we take from each group. But the total weight constraint is m, and the total cost is the sum of the prefix sums.\n\n However, the direct iteration over x1, x2, x3 is too expensive because the sizes of the groups can be up to 100000 and m is 300000.\n\n Alternatively, we can use the following:\n\n   Let f(w) be the maximum total cost we can get with total weight exactly w (using all three groups). Then we want max{ f(w) for w in [0, m] }.\n\n   How to compute f(w)? We can do:\n\n      Let dp[w] = maximum total cost for weight w.\n\n      We can initialize dp[0] = 0, and negative infinity for others.\n\n      Then, for each group (weight 1, then 2, then 3) we update the dp array.\n\n   But the state space is 0 to m (300001 states) and we have three groups, and for each group we update by adding items of that weight. However, the update for a group of weight w would be:\n\n        for w_val in [1,2,3]:\n            For each item in the group (with cost c), we can do:\n                for weight from m down to w_val:\n                    dp[weight] = max(dp[weight], dp[weight - w_val] + c)\n\n   But wait, we have multiple items per group and we can only use each item once. So we must use a knapsack for 0",
    "response": "\nTo solve this problem, we need to maximize the total cost of souvenirs that Petya can carry to the market without exceeding a given weight limit. Each souvenir has a weight of either 1, 2, or 3, and a corresponding cost. The challenge is to select a subset of these souvenirs such that their combined weight is within the limit and their total cost is maximized.\n\n### Approach\n1. **Grouping by Weight**: First, we group all souvenirs by their weights (1, 2, or 3). This allows us to handle each weight category separately.\n2. **Sorting and Prefix Sums**: For each weight group, we sort the souvenirs in descending order of their costs. Then, we compute prefix sums for each group. The prefix sum at index `i` represents the maximum total cost achievable by selecting the top `i` most valuable souvenirs from that group.\n3. **Dynamic Programming with Prefix Sums**: Using the prefix sums, we determine the maximum number of souvenirs we can include from each weight group without exceeding the weight limit. For each possible weight contribution from one group, we find the best combination with another group's weight contribution. This involves iterating through all possible weight combinations and using prefix sums to quickly access the maximum cost achievable for a given number of items.\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(0)\n        return\n    \n    n = int(data[0])\n    m = int(data[1])\n    index = 2\n    type1 = []\n    type2 = []\n    type3 = []\n    \n    for _ in range(n):\n        w = int(data[index])\n        c = int(data[index + 1])\n        index += 2\n        if w == 1:\n            type1.append(c)\n        elif w == 2:\n            type2.append(c)\n        elif w == 3:\n            type3.append(c)\n            \n    type1.sort(reverse=True)\n    type2.sort(reverse=True)\n    type3.sort(reverse=True)\n    \n    def build_prefix(arr):\n        prefix = [0]\n        total = 0\n        for i in range(len(arr)):\n            total += arr[i]\n            prefix.append(total)\n        return prefix\n        \n    pre1 = build_prefix(type1)\n    pre2 = build_prefix(type2)\n    pre3 = build_prefix(type3)\n    \n    def find_max_index(prefix, max_weight, group_weight):\n        idx = 0\n        while idx < len(prefix) and idx * group_weight <= max_weight:\n            idx += 1\n        return idx - 1\n        \n    max_val = 0\n    size1 = len(type1)\n    size2 = len(type2)\n    size3 = len(type3)\n    \n    max1 = min(size1, (m // 1))\n    max2 = min(size2, (m // 2))\n    max3 = min(size3, (m // 3))\n    \n    for w1 in range(0, max1 + 1):\n        rem = m - w1\n        if rem < 0:\n            continue\n        cost1 = pre1[w1] if w1 <= size1 else pre1[size1]\n        \n        if rem == 0:\n            if cost1 > max_val:\n                max_val = cost1\n            continue\n            \n        max_w2 = min(max2, rem // 2)\n        for w2 in range(0, max_w2 + 1):\n            rem2 = rem - 2 * w2\n            if rem2 < 0:\n                break\n            cost2 = pre2[w2] if w2 <= size2 else pre2[size2]\n            total_cost = cost1 + cost2\n            if total_cost <= max_val:\n                continue\n                \n            max_w3 = min(max3, rem2 // 3)\n            w3 = min(w2 + 1, max_w3 + 1)\n            rem3 = rem2 - 3 * w3\n            cost3 = pre3[w3] if w3 <= size3 else pre3[size3]\n            total_cost = cost1 + cost2 + cost3\n            if total_cost > max_val:\n                max_val = total_cost\n                \n    print(max_val)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Input Handling**: The input is read and parsed into the number of souvenirs `n` and the maximum weight `m`. Each souvenir's weight and cost are stored in separate lists based on their weight (1, 2, or 3).\n2. **Sorting and Prefix Sums**: Each weight group is sorted in descending order of cost. Prefix sums are computed for each group to quickly access the cumulative cost of the top `k` most valuable items.\n3. **Iterating Over Possible Combinations**: For each possible number of souvenirs taken from the first weight group (weight 1), the remaining weight is calculated. The algorithm then iterates over possible numbers of souvenirs from the second (weight 2) and third (weight 3) groups, ensuring the total weight does not exceed `m`. The maximum cost is updated whenever a higher total cost is found.\n4. **Output**: The maximum total cost achievable within the weight limit is printed.\n\nThis approach efficiently combines the use of grouping, sorting, prefix sums, and nested loops to explore all feasible combinations of souvenirs while adhering to the weight constraint. The complexity is optimized by leveraging the small weight values (1, 2, 3) and the prefix sums for quick cost calculations.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(0)\n        return\n    \n    n = int(data[0])\n    m = int(data[1])\n    index = 2\n    type1 = []\n    type2 = []\n    type3 = []\n    \n    for _ in range(n):\n        w = int(data[index])\n        c = int(data[index + 1])\n        index += 2\n        if w == 1:\n            type1.append(c)\n        elif w == 2:\n            type2.append(c)\n        elif w == 3:\n            type3.append(c)\n            \n    type1.sort(reverse=True)\n    type2.sort(reverse=True)\n    type3.sort(reverse=True)\n    \n    def build_prefix(arr):\n        prefix = [0]\n        total = 0\n        for i in range(len(arr)):\n            total += arr[i]\n            prefix.append(total)\n        return prefix\n        \n    pre1 = build_prefix(type1)\n    pre2 = build_prefix(type2)\n    pre3 = build_prefix(type3)\n    \n    def find_max_index(prefix, max_weight, group_weight):\n        idx = 0\n        while idx < len(prefix) and idx * group_weight <= max_weight:\n            idx += 1\n        return idx - 1\n        \n    max_val = 0\n    size1 = len(type1)\n    size2 = len(type2)\n    size3 = len(type3)\n    \n    max1 = min(size1, (m // 1))\n    max2 = min(size2, (m // 2))\n    max3 = min(size3, (m // 3))\n    \n    for w1 in range(0, max1 + 1):\n        rem = m - w1\n        if rem < 0:\n            continue\n        cost1 = pre1[w1] if w1 <= size1 else pre1[size1]\n        \n        if rem == 0:\n            if cost1 > max_val:\n                max_val = cost1\n            continue\n            \n        max_w2 = min(max2, rem // 2)\n        for w2 in range(0, max_w2 + 1):\n            rem2 = rem - 2 * w2\n            if rem2 < 0:\n                break\n            cost2 = pre2[w2] if w2 <= size2 else pre2[size2]\n            total_cost = cost1 + cost2\n            if total_cost <= max_val:\n                continue\n                \n            max_w3 = min(max3, rem2 // 3)\n            w3 = min(w2 + 1, max_w3 + 1)\n            rem3 = rem2 - 3 * w3\n            cost3 = pre3[w3] if w3 <= size3 else pre3[size3]\n            total_cost = cost1 + cost2 + cost3\n            if total_cost > max_val:\n                max_val = total_cost\n                \n    print(max_val)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 476,
        "completion_token_count": 1190,
        "thoughts_token_count": 1023
    }
}