{
    "start": 1758296497.4313247,
    "end": 1758299438.8562632,
    "start-formatted": "2025-09-20 00:41 KST",
    "end-formatted": "2025-09-20 01:30 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\n Okay, let's analyze the problem:\n\nWe are given two integers a and b (with 1 <= a, b <= 10^9). We need to find a non-negative integer k such that:\n   LCM(a+k, b+k) is minimized.\n\nNote: If multiple k yield the same minimal LCM, choose the smallest k.\n\nLet d = a - b. Without loss of generality, we can assume a >= b by swapping if needed. But note: the problem doesn't require that.\n\nActually, note that when k increases, both numbers increase. The LCM of two numbers x and y is (x * y) / GCD(x,y).\n\nBut note: we can write the two numbers as (a+k) and (b+k). Let d = |a-b|. Then without loss of generality, assume a>=b, then we have d>=0.\n\nBut note: if a==b, then we have LCM(a+k, a+k) = a+k, so we want to minimize a+k. The smallest k is 0.\n\nNow, consider a > b. Then we have two numbers: (a+k) and (b+k). Their difference is fixed: (a+k) - (b+k) = a-b = d (positive).\n\nWe know that for two numbers x and y, LCM(x,y) * GCD(x,y) = x*y.\n\nBut note: we can also use the fact that GCD(a+k, b+k) must divide the difference (a+k) - (b+k) = a-b.\n\nSo, let g be a divisor of |a-b| (or more precisely, of d = |a-b|). Then, we can set k such that g divides both a+k and b+k. Actually, we require that g divides (a+k) and (b+k). But note that if g divides the difference, then:\n\n   We can set k to be the smallest non-negative solution to:\n        k ≡ (-a) mod g   (i.e., a+k ≡ 0 mod g)\n\nBut note: we are allowed to take k from 0 upwards. So for each divisor g of d (where d = |a-b|), we can set k0 = (g - a % g) % g. However, note that we require that (a+k0) % g == 0 and (b+k0) % g == 0? Actually, if g divides (a+k) and g divides (b+k), then g divides (a-b). But note: we are iterating over divisors of |a-b|, so that condition holds.\n\nHowever, note: there is a catch. The GCD of (a+k) and (b+k) might be a multiple of g? Actually, the GCD must divide (a-b), so we can only consider divisors of |a-b|.\n\nBut wait, is it true that the GCD of (a+k) and (b+k) must divide |a-b|? Yes, because any common divisor divides (a+k) - (b+k) = a-b.\n\nTherefore, we can consider all divisors of |a-b| (if a != b) and also consider k=0 separately? Actually, we are going to consider k for each divisor.\n\nHowever, note that k must be chosen such that the two numbers (a+k) and (b+k) have a GCD that is a divisor of |a-b|. But we are not limited to one divisor? Actually, the GCD could be any divisor of |a-b|, but we don't know which one.\n\nAlternatively, we can think: For each divisor g of d (d = |a-b|), we can set k such that g divides both a+k and b+k. Then the GCD of (a+k) and (b+k) will be at least g, but actually the GCD will be a multiple of g? No, because the GCD must divide d and also be a divisor of (a+k) and (b+k). However, we are free to choose k so that g divides both, and then the actual GCD might be larger than g? Actually, no: because we are choosing k so that the condition is met for g, but the actual GCD could be any divisor of d that divides both.\n\nBut note: the idea is to let g run through the divisors of d, and then set k to be the smallest non-negative integer such that g divides (a+k) and (b+k). Then, the LCM would be (a+k)*(b+k)/g (because the GCD is at least g, but wait: the GCD might be greater than g. Actually, the GCD is the gcd of (a+k) and (b+k). However, we are only ensuring that g divides both. Then the GCD might be a multiple of",
    "response": "\nTo solve this problem, we need to find a non-negative integer \\( k \\) such that the least common multiple (LCM) of \\( a+k \\) and \\( b+k \\) is minimized. If multiple values of \\( k \\) yield the same minimal LCM, we should choose the smallest \\( k \\).\n\n### Approach\n1. **Problem Analysis**: The key observation here is that the GCD of \\( a+k \\) and \\( b+k \\) must divide the difference \\( |a - b| \\). Therefore, for each divisor \\( g \\) of \\( |a - b| \\), we can determine a candidate \\( k \\) that ensures \\( g \\) divides both \\( a+k \\) and \\( b+k \\). This \\( k \\) is computed as the smallest non-negative solution to the congruences \\( a + k \\equiv 0 \\mod g \\) and \\( b + k \\equiv 0 \\mod g \\), which simplifies to \\( k \\equiv (-a) \\mod g \\).\n\n2. **Algorithm Selection**: The algorithm involves:\n   - Calculating the absolute difference \\( d = |a - b| \\).\n   - Finding all divisors of \\( d \\).\n   - For each divisor \\( g \\), compute the corresponding \\( k \\) that satisfies the congruence condition.\n   - Among all computed \\( k \\) values, select the one that minimizes the LCM of \\( a+k \\) and \\( b+k \\). If multiple \\( k \\) values yield the same minimal LCM, choose the smallest \\( k \\).\n\n3. **Complexity Analysis**: The time complexity is dominated by the factorization of \\( d \\), which is \\( O(\\sqrt{d}) \\). Given the constraints \\( 1 \\leq a, b \\leq 10^9 \\), \\( d \\) can be up to \\( 10^9 \\), making the factorization feasible with efficient algorithms.\n\n### Solution Code\n```python\nimport math\nfrom math import gcd\n\ndef get_divisors(n):\n    divisors = set()\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n        i += 1\n    return divisors\n\ndef main():\n    a, b = map(int, input().split())\n    if a == b:\n        print(0)\n        return\n        \n    d = abs(a - b)\n    divisors = get_divisors(d)\n    candidates = {}\n    \n    for g in divisors:\n        k = (-a) % g\n        if k < 0:\n            k += g\n        x = a + k\n        y = b + k\n        g_val = gcd(x, y)\n        lcm_val = x * y // g_val\n        if lcm_val not in candidates or k < candidates[lcm_val]:\n            candidates[lcm_val] = k\n            \n    best_k = min(candidates.keys(), key=lambda x: (candidates[x], x))\n    print(best_k)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Input Handling**: The code reads two integers \\( a \\) and \\( b \\). If they are equal, it immediately prints \\( 0 \\) since the LCM of any number with itself is the number itself, and minimizing it requires \\( k = 0 \\).\n\n2. **Divisor Calculation**: The function `get_divisors` computes all divisors of the absolute difference \\( d = |a - b| \\). This is done efficiently by iterating up to the square root of \\( d \\).\n\n3. **Candidate Generation**: For each divisor \\( g \\) of \\( d \\), the code calculates the smallest non-negative \\( k \\) such that \\( g \\) divides both \\( a+k \\) and \\( b+k \\). This \\( k \\) is derived using modular arithmetic.\n\n4. **LCM Calculation**: For each candidate \\( k \\), the code computes the LCM of \\( a+k \\) and \\( b+k \\) using their GCD. The LCM is stored along with the corresponding \\( k \\).\n\n5. **Result Selection**: The code selects the smallest \\( k \\) that yields the minimal LCM. If multiple \\( k \\) values produce the same minimal LCM, the smallest \\( k \\) is chosen.\n\nThis approach efficiently narrows down the search space to relevant divisors, ensuring optimal performance even for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\nfrom math import gcd\n\ndef get_divisors(n):\n    divisors = set()\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n        i += 1\n    return divisors\n\ndef main():\n    a, b = map(int, input().split())\n    if a == b:\n        print(0)\n        return\n        \n    d = abs(a - b)\n    divisors = get_divisors(d)\n    candidates = {}\n    \n    for g in divisors:\n        k = (-a) % g\n        if k < 0:\n            k += g\n        x = a + k\n        y = b + k\n        g_val = gcd(x, y)\n        lcm_val = x * y // g_val\n        if lcm_val not in candidates or k < candidates[lcm_val]:\n            candidates[lcm_val] = k\n            \n    best_k = min(candidates.keys(), key=lambda x: (candidates[x], x))\n    print(best_k)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 396,
        "completion_token_count": 947,
        "thoughts_token_count": 1023
    }
}