{
    "start": 1758302682.2511535,
    "end": 1758306401.02976,
    "start-formatted": "2025-09-20 02:24 KST",
    "end-formatted": "2025-09-20 03:26 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\n Okay, we are given a graph with n nodes and m edges. For each edge (u, v), we are given two numbers: gcd and lcm.\n We know that for two numbers a and b (the mushrooms on the two lawns), we have:\n   gcd(a, b) = g, lcm(a, b) = l.\n And the relationship: a * b = g^2 * (l // g)   [Wait, actually: a*b = g * l, because lcm(a,b) * gcd(a,b) = a * b]\n\n But note: there might be multiple pairs (a, b) that satisfy gcd(a,b)=g and lcm(a,b)=l.\n However, note that we can factorize g and l. Let a = g * x, b = g * y, then we require that gcd(x,y)=1 and g*x * g*y = g*l -> x*y = l//g.\n\n So the problem is: given a graph, assign to each node i a positive integer a_i such that for every edge (u, v) with given gcd=g and lcm=l, we have:\n   gcd(a_u, a_v) = g and lcm(a_u, a_v) = l.\n\n Also note: the initial map had numbers at least 1 and at most 10^6.\n\n Steps:\n\n 1. For each edge (u, v) with given gcd = g and lcm = l, we must have:\n      g divides both a_u and a_v, and then let x = a_u // g, y = a_v // g, then:\n          gcd(x, y) = 1 and x * y = l // g.\n\n 2. Also note: for an edge (u, v): \n        a_u must be divisible by g, and similarly a_v must be divisible by g.\n        Moreover, the LCM condition: the LCM of (a_u, a_v) must be l. This implies that the maximum exponents in the prime factorizations of a_u and a_v must be the same as in l.\n\n 3. However, note that from the equation: \n        a_u = g * x, a_v = g * y, and x * y = l // g, and gcd(x,y)=1.\n\n    Then the LCM is: LCM(g*x, g*y) = g * LCM(x,y) = g * (x*y) / gcd(x,y) = g * (l//g) / 1 = l.\n\n    So the conditions are necessary and sufficient if we set the numbers in this form.\n\n 4. But we have multiple edges. The same node may appear in several edges. So we have to assign one number to each node that satisfies all the constraints from incident edges.\n\n 5. How to approach?\n\n    Let's denote the number at node i as a_i.\n\n    For an edge (u, v) with gcd g and lcm l, we must have:\n        a_u is divisible by g, and a_v is divisible by g.\n        Moreover, if we write a_u = g * x, then the other endpoint a_v must be g * y, and x * y = l//g, and gcd(x,y)=1.\n\n    Alternatively, note that the entire assignment must be consistent. \n\n    Observation: The value of a_i must be divisible by the gcd from every edge incident to i.\n\n    Also, for an edge (u, v) with gcd g and lcm l, the value assigned to u must be such that when we divide by g (the gcd) we get a co-prime factor that multiplies with the factor from v to give l//g.\n\n 6. Another idea: Factorize the gcd and lcm? But note: the numbers can be up to 10^6, and we have up to 10^5 edges (n, m up to 200000). Factorization for each edge might be too heavy.\n\n 7. Alternatively, we can try to assign the numbers by propagating the constraints.\n\n    Steps:\n\n    a) First, check consistency of each edge independently:\n\n        Condition 1: g divides l. Because from a_u and a_v being multiples of g, and their product is g*l, but also the LCM is l, which must be divisible by g. Actually, we have the relation: g divides l (because the GCD divides the LCM). But more importantly, we require that (l // g) is an integer and that the equation x*y = l//g with gcd(x,y)=1 has solutions.\n\n        Condition 2: The equation x*y = l//g must have a solution with gcd(x,y)=1. This is always possible? Not necessarily. For example, if l//g is 4, then the solutions are (1,4) and (2,2) and (4,1",
    "response": "\nTo solve this problem, we need to determine if it's possible to assign numbers of mushrooms to each lawn in a forest such that the given GCD and LCM conditions for each road are satisfied. The solution involves checking the consistency of these conditions across all edges and ensuring that the assigned numbers meet all constraints.\n\n### Approach\n1. **Problem Analysis**: The problem requires assigning positive integers to each node (lawn) such that for every edge (road), the GCD and LCM of the numbers at its endpoints match the given values. The key insight is that for any two numbers \\(a\\) and \\(b\\), their product \\(a \\times b\\) must equal their GCD multiplied by their LCM. Additionally, after factoring out the GCD, the remaining parts of the numbers must be coprime.\n\n2. **Graph Processing**: For each edge, we derive the product of the remaining factors after dividing by the GCD. This product must be an integer, and the factors must be coprime. We also ensure that the GCD divides the LCM, which is inherently true but must be checked.\n\n3. **Consistency Check**: For each node, we collect all GCDs from incident edges. The number assigned to the node must be divisible by all these GCDs. We then use these GCDs to factorize the node's value and ensure that for each edge, the derived factors are coprime and their product matches the derived value from the LCM.\n\n4. **Algorithm Selection**: The solution involves parsing input data, processing each edge to derive necessary values, and then performing a graph traversal (like BFS or DFS) to propagate constraints and check consistency. If all constraints are satisfied, we output \"YES\" along with the assigned numbers; otherwise, we output \"NO\".\n\n### Solution Code\n```python\nimport sys\nfrom collections import deque\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"NO\")\n        return\n    \n    n = int(data[0])\n    m = int(data[1])\n    edges = []\n    index = 2\n    for i in range(m):\n        u = int(data[index]); v = int(data[index+1]); g = int(data[index+2]); l = int(data[index+3])\n        index += 4\n        edges.append((u-1, v-1, g, l))\n    \n    graph = [[] for _ in range(n)]\n    for u, v, g, l in edges:\n        graph[u].append((v, g, l))\n        graph[v].append((u, g, l))\n        \n    base_gcds = [set() for _ in range(n)]\n    base_products = [0] * n\n    for u, v, g, l in edges:\n        if l % g != 0:\n            print(\"NO\")\n            return\n        p_val = l // g\n        graph[u][0] = (v, g, l)\n        graph[v][0] = (u, g, l)\n        \n        base_gcds[u].add(g)\n        base_gcds[v].add(g)\n        \n        if base_products[u] == 0:\n            base_products[u] = p_val\n        else:\n            base_products[u] *= p_val\n            \n        if base_products[v] == 0:\n            base_products[v] = p_val\n        else:\n            base_products[v] *= p_val\n\n    ans = [0] * n\n    parent = [-1] * n\n    q = deque()\n    for i in range(n):\n        if base_products[i] != 0:\n            continue\n        if base_gcds[i]:\n            g0 = next(iter(base_gcds[i]))\n            ans[i] = g0\n            q.append(i)\n            parent[i] = -2\n        else:\n            q.append(i)\n            parent[i] = -2\n            ans[i] = 1\n\n    while q:\n        node = q.popleft()\n        for neighbor, g, l in graph[node]:\n            if parent[neighbor] != -1:\n                continue\n            if ans[node] % g != 0:\n                print(\"NO\")\n                return\n                \n            p_val = l // g\n            x = ans[node] // g\n            if base_products[neighbor] != 0:\n                base_prod_neighbor = base_products[neighbor]\n                temp = 1\n                for edge in edges:\n                    if edge[0] == neighbor or edge[1] == neighbor:\n                        if edge[0] == neighbor and edge[1] == neighbor:\n                            continue\n                        if edge[0] == neighbor:\n                            g_edge = edge[2]\n                            p_edge = edge[3] // g_edge\n                        else:\n                            g_edge = edge[3]\n                            p_edge = edge[2] // g_edge\n                        temp *= p_edge\n                if base_prod_neighbor != temp:\n                    print(\"NO\")\n                    return\n                continue\n            else:\n                base_products[neighbor] = p_val\n                if neighbor == node:\n                    continue\n                parent[neighbor] = node\n                q.append(neighbor)\n                continue\n            \n            if base_products[neighbor] != p_val:\n                print(\"NO\")\n                return\n                \n            if ans[neighbor] != 0:\n                continue\n            if ans[node] // g != x:\n                print(\"NO\")\n                return\n            ans[neighbor] = g * x\n            base_products[neighbor] = p_val\n            parent[neighbor] = node\n            q.append(neighbor)\n            \n    for i in range(n):\n        if ans[i] == 0:\n            print(\"NO\")\n            return\n\n    for u, v, g, l in edges:\n        a = ans[u]\n        b = ans[v]\n        if a % g != 0 or b % g != 0:\n            print(\"NO\")\n            return\n        g1 = gcd(a, b)\n        if g1 != g:\n            print(\"NO\")\n            return\n        lcm_val = a * b // g1\n        if lcm_val != l:\n            print(\"NO\")\n            return\n\n    print(\"YES\")\n    print(\" \".join(map(str, ans)))\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Input Parsing**: The input is read and parsed into the number of nodes (n) and edges (m). Each edge is stored with its connecting nodes and the given GCD and LCM values.\n2. **Graph Construction**: A graph is built where each node points to its adjacent edges along with the GCD and LCM values.\n3. **Base Conditions**: For each node, we collect all GCD values from incident edges and compute the product of the derived values (LCM divided by GCD) for these edges.\n4. **BFS Traversal**: Using BFS, we traverse the graph starting from nodes with known values. For each node, we ensure its value is divisible by all GCD values from its edges. The derived values from edges must be consistent across the graph.\n5. **Validation**: After assigning values to all nodes, we validate that all edges satisfy the GCD and LCM conditions. If any condition fails, we output \"NO\"; otherwise, we output \"YES\" along with the assigned values.\n\nThis approach efficiently checks the feasibility of the mushroom count assignment by leveraging graph traversal and mathematical properties of GCD and LCM.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"NO\")\n        return\n    \n    n = int(data[0])\n    m = int(data[1])\n    edges = []\n    index = 2\n    for i in range(m):\n        u = int(data[index]); v = int(data[index+1]); g = int(data[index+2]); l = int(data[index+3])\n        index += 4\n        edges.append((u-1, v-1, g, l))\n    \n    graph = [[] for _ in range(n)]\n    for u, v, g, l in edges:\n        graph[u].append((v, g, l))\n        graph[v].append((u, g, l))\n        \n    base_gcds = [set() for _ in range(n)]\n    base_products = [0] * n\n    for u, v, g, l in edges:\n        if l % g != 0:\n            print(\"NO\")\n            return\n        p_val = l // g\n        graph[u][0] = (v, g, l)\n        graph[v][0] = (u, g, l)\n        \n        base_gcds[u].add(g)\n        base_gcds[v].add(g)\n        \n        if base_products[u] == 0:\n            base_products[u] = p_val\n        else:\n            base_products[u] *= p_val\n            \n        if base_products[v] == 0:\n            base_products[v] = p_val\n        else:\n            base_products[v] *= p_val\n\n    ans = [0] * n\n    parent = [-1] * n\n    q = deque()\n    for i in range(n):\n        if base_products[i] != 0:\n            continue\n        if base_gcds[i]:\n            g0 = next(iter(base_gcds[i]))\n            ans[i] = g0\n            q.append(i)\n            parent[i] = -2\n        else:\n            q.append(i)\n            parent[i] = -2\n            ans[i] = 1\n\n    while q:\n        node = q.popleft()\n        for neighbor, g, l in graph[node]:\n            if parent[neighbor] != -1:\n                continue\n            if ans[node] % g != 0:\n                print(\"NO\")\n                return\n                \n            p_val = l // g\n            x = ans[node] // g\n            if base_products[neighbor] != 0:\n                base_prod_neighbor = base_products[neighbor]\n                temp = 1\n                for edge in edges:\n                    if edge[0] == neighbor or edge[1] == neighbor:\n                        if edge[0] == neighbor and edge[1] == neighbor:\n                            continue\n                        if edge[0] == neighbor:\n                            g_edge = edge[2]\n                            p_edge = edge[3] // g_edge\n                        else:\n                            g_edge = edge[3]\n                            p_edge = edge[2] // g_edge\n                        temp *= p_edge\n                if base_prod_neighbor != temp:\n                    print(\"NO\")\n                    return\n                continue\n            else:\n                base_products[neighbor] = p_val\n                if neighbor == node:\n                    continue\n                parent[neighbor] = node\n                q.append(neighbor)\n                continue\n            \n            if base_products[neighbor] != p_val:\n                print(\"NO\")\n                return\n                \n            if ans[neighbor] != 0:\n                continue\n            if ans[node] // g != x:\n                print(\"NO\")\n                return\n            ans[neighbor] = g * x\n            base_products[neighbor] = p_val\n            parent[neighbor] = node\n            q.append(neighbor)\n            \n    for i in range(n):\n        if ans[i] == 0:\n            print(\"NO\")\n            return\n\n    for u, v, g, l in edges:\n        a = ans[u]\n        b = ans[v]\n        if a % g != 0 or b % g != 0:\n            print(\"NO\")\n            return\n        g1 = gcd(a, b)\n        if g1 != g:\n            print(\"NO\")\n            return\n        lcm_val = a * b // g1\n        if lcm_val != l:\n            print(\"NO\")\n            return\n\n    print(\"YES\")\n    print(\" \".join(map(str, ans)))\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 544,
        "completion_token_count": 1584,
        "thoughts_token_count": 1023
    }
}