{
    "start": 1758095741.2474542,
    "end": 1758097929.1846218,
    "start-formatted": "2025-09-17 16:55 KST",
    "end-formatted": "2025-09-17 17:32 KST",
    "gpu": 2,
    "pid": 5,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Colored Boots\n\nThere are $$$n$$$ left boots and $$$n$$$ right boots. Each boot has a color which is denoted as a lowercase Latin letter or a question mark ('?'). Thus, you are given two strings $$$l$$$ and $$$r$$$, both of length $$$n$$$. The character $$$l_i$$$ stands for the color of the $$$i$$$-th left boot and the character $$$r_i$$$ stands for the color of the $$$i$$$-th right boot.A lowercase Latin letter denotes a specific color, but the question mark ('?') denotes an indefinite color. Two specific colors are compatible if they are exactly the same. An indefinite color is compatible with any (specific or indefinite) color.For example, the following pairs of colors are compatible: ('f', 'f'), ('?', 'z'), ('a', '?') and ('?', '?'). The following pairs of colors are not compatible: ('f', 'g') and ('a', 'z').Compute the maximum number of pairs of boots such that there is one left and one right boot in a pair and their colors are compatible.Print the maximum number of such pairs and the pairs themselves. A boot can be part of at most one pair.\n\n## Input\nThe first line contains $$$n$$$ ($$$1 \\le n \\le 150000$$$), denoting the number of boots for each leg (i.e. the number of left boots and the number of right boots).The second line contains the string $$$l$$$ of length $$$n$$$. It contains only lowercase Latin letters or question marks. The $$$i$$$-th character stands for the color of the $$$i$$$-th left boot.The third line contains the string $$$r$$$ of length $$$n$$$. It contains only lowercase Latin letters or question marks. The $$$i$$$-th character stands for the color of the $$$i$$$-th right boot.\n\n## Output\nPrint $$$k$$$ â€” the maximum number of compatible left-right pairs of boots, i.e. pairs consisting of one left and one right boot which have compatible colors.The following $$$k$$$ lines should contain pairs $$$a_j, b_j$$$ ($$$1 \\le a_j, b_j \\le n$$$). The $$$j$$$-th of these lines should contain the index $$$a_j$$$ of the left boot in the $$$j$$$-th pair and index $$$b_j$$$ of the right boot in the $$$j$$$-th pair. All the numbers $$$a_j$$$ should be distinct (unique), all the numbers $$$b_j$$$ should be distinct (unique).If there are many optimal answers, print any of them.\n\n## Example\n### Input\n['10\\ncodeforces\\ndodivthree', '7\\nabaca?b\\nzabbbcc', '9\\nbambarbia\\nhellocode', '10\\ncode??????\\n??????test']\n\n### Output\n['5\\n7 8\\n4 9\\n2 2\\n9 10\\n3 1', '5\\n6 5\\n2 3\\n4 6\\n7 4\\n1 2', '0', '10\\n6 2\\n1 6\\n7 3\\n3 5\\n4 8\\n9 7\\n5 1\\n2 4\\n10 9\\n8 10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\n Okay, we are given two strings `l` and `r` of length n (n up to 150000). Each string contains lowercase Latin letters or '?'\n We need to form as many pairs as possible (each boot in at most one pair) such that:\n   - Two specific colors are compatible if they are the same.\n   - An indefinite color '?' is compatible with any color.\n\n However, note: the problem requires to output the maximum number of pairs and then the pairs themselves.\n\n Important: The pairs must be distinct by boot indices.\n\n Approach:\n We cannot try all possibilities because n can be up to 150000.\n\n Let's break down:\n\n 1. We have two strings: left (l) and right (r).\n 2. We can consider matching a left boot i with a right boot j.\n\n Conditions for compatibility:\n   - If l[i] is a letter and r[j] is a letter: then they must be equal.\n   - If l[i] is '?' or r[j] is '?', then they are compatible.\n\n However, note: we are allowed to use each boot only once.\n\n But there is a catch: we are to maximize the number of pairs.\n\n We can think of two types of boots:\n   - Boots with fixed color (letters)\n   - Boots with '?' (indefinite)\n\n We might try to first match as many fixed-to-fixed as possible, then use the '?' to match the leftovers.\n\n However, note that sometimes using a fixed boot with a '?' might be necessary to free up a fixed boot for another fixed boot? \n Actually, we want to maximize the total pairs. We can use a greedy matching strategy:\n\n Step 1: Count the frequency of each color (letter) in both left and right.\n\n But note: we have two separate lists. We can also have '?' in both.\n\n However, the problem is that '?' can be used anywhere. So we can use '?' to match any remaining boot.\n\n But here's the catch: we don't know which '?' to use first. We have to assign each boot at most once.\n\n Alternate approach:\n\n We can consider two phases:\n\n Phase 1: Match all fixed-to-fixed where the colors match and the other side is not a '?'.\n\n However, note: even if one side is fixed and the other is '?', that is a valid match. So we have to consider:\n\n How to maximize?\n\n Observation:\n   Since '?' can match anything, we can use them to fill in the gaps. But we want to use the fixed boots first because they are more constrained.\n\n However, we can also use a '?' to match a fixed boot, but then we might prevent a fixed boot from being matched with another fixed boot of the same color.\n\n Therefore, we should:\n\n  1. First, try to match as many fixed boots as possible without using the '?' boots.\n\n  But wait: what if we have two fixed boots of the same color on opposite sides? Then we can match them. But what if we have an excess of one color?\n\n  Actually, we can do:\n\n  Let's define:\n\n    L_fixed = [char for char in l if char != '?']\n    R_fixed = [char for char in r if char != '?']\n\n  But note: we cannot simply match fixed boots arbitrarily because the positions matter (each boot has an index). We need to assign specific indices.\n\n  However, the problem does not require a particular matching (any optimal set is acceptable).\n\n  Steps:\n\n  We can use a bipartite graph? But n is 150000 so we cannot build a complete graph.\n\n  Alternate Insight:\n\n  We can consider:\n\n    Let A = list of indices for left boots, and B = list of indices for right boots.\n\n    We want to form k pairs (i, j) such that either:\n        (a) l[i] == r[j] and both are letters (so not '?') OR\n        (b) at least one is '?'\n\n    But note: condition (b) is actually two cases: \n        (b1) l[i] is '?' and r[j] is any -> then compatible\n        (b2) r[j] is '?' and l[i] is any -> then compatible\n        (b3) both are '?' -> compatible\n\n    We can break the problem:\n\n    Step 1: Count the fixed boots and the '?' boots separately.\n\n    However, we can also think:\n\n    We can first try to match fixed boots (without '?') by their color. But note: we can also use a fixed boot to match a '?'? \n\n    But wait: we want to maximize the total pairs. The maximum number of pairs is at most n, and we can form at most n pairs.\n\n    We can use a greedy matching:\n\n    Idea:\n\n    We can consider two sets:\n\n      Left: \n          Fixed: the letters in l (with index) and the '?' in l (with index)\n      Right: similarly.\n\n    We can use a two-step matching:\n\n    Step 1: Match fixed boots with fixed boots (if they are the same letter) and fixed boots with '?' (if the fixed boot's letter is present, then it's okay to use the '?' to match the fixed one, but wait: we want to reserve the '?' for when fixed boots cannot be matched? Actually, no: we want to use the fixed boots as much as possible because they are more constrained.\n\n    However, let's reframe:\n\n    We want to maximize the total pairs. We can use a '?' in one side to match any boot, so we can use them to fill the remaining boots.\n\n    But note: we can also use fixed boots to match '?'.\n\n    However, we can use the following:\n\n    We can first match the fixed boots to fixed boots of the same color. Then, we can use the remaining fixed boots (which are unmatched) and the remaining '?' boots to form more pairs.\n\n    But wait: what if we have a fixed boot and a '?' boot? They can be matched. However, we have to decide: should we use a fixed boot to match a '?' boot or vice versa?\n\n    Actually, we can use a fixed boot to match a '?' boot, but then we lose the possibility of matching two fixed boots of the same color? \n\n    Alternatively, we can use the '?' boots to match fixed boots that don't have a fixed counterpart. \n\n    Actually, the best way is:\n\n    We can form pairs in two ways:\n\n      Type 1: (fixed, fixed) with same letter.\n      Type 2: (fixed, ?) \n      Type 3: (?, fixed)\n      Type 4: (?, ?)\n\n    And note: we want to maximize the total pairs.\n\n    Since Type 1, Type 2, Type 3, and Type 4 are all allowed, we can use the '?' boots to cover the mismatches.\n\n    However, we can also note: we can use a '?' boot to match a fixed boot, but then that fixed boot might have been matched by a fixed boot on the other side? \n\n    Let me explain:\n\n      Consider: \n        l: ['a', '?'] \n        r: ['a', 'b']\n\n      We can form two pairs: \n        Option 1: \n            left0 (a) with right0 (a) -> fixed-fixed\n            left1 (?) with right1 (b) -> matches because left1 is '?'\n        Option 2:\n            left0 (a) with right1 (b) -> not compatible (unless we consider that '?' is allowed, but wait: in this case left0 is fixed and right1 is fixed? Actually, we have two fixed boots: left0 is fixed, right1 is fixed and they are different -> not compatible.\n            left1 (?) with right0 (a) -> matches.\n\n      Both options yield 2 pairs.\n\n    But now consider:\n\n        l: ['a', 'b', '?'] \n        r: ['a', 'c', '?']\n\n      We want to form 3 pairs? Actually, we have 3 left and 3 right, so maximum 3 pairs.\n\n      How?\n        Option 1: \n          left0 (a) with right0 (a) -> fixed-fixed\n          left1 (b) with right2 (?) -> fixed with '?' -> valid\n          left2 (?) with right1 (c) -> valid\n\n        Option 2: \n          left0 (a) with right0 (a) -> fixed-fixed\n          left1 (b) with right0 (a) -> not valid (because b != a and neither is '?')\n          left0 (a) with right2 (?) -> valid\n          left1 (b) with right1 (c) -> not valid\n          left2 (?) with right0 (a) -> valid -> but then we get two pairs: (0,2) and (2,0) -> no, because we cannot use the same boot twice.\n\n      Actually, we have to assign each boot at most once.\n\n    We can use a matching algorithm that considers:\n\n      We have two sets: left and right.\n\n      We can create a bipartite graph where an edge exists between left boot i and right boot j if:\n          (l[i] == r[j]) or (l[i]=='?' and r[j]!='?') or (l[i]!='?' and r[j]=='?') or (l[i]=='?' and r[j]=='?')\n\n      Actually, the condition is: \n          if l[i] is not '?' and r[j] is not '?' then they must be equal.\n          if l[i] is '?' or r[j] is '?', then they are compatible.\n\n      This is equivalent to: \n          (l[i] == r[j]) or (l[i]=='?' and r[j] in [all letters and '?']) or (r[j]=='?' and l[i] in [all letters and '?'])\n\n      But note: if both are '?', then we have (l[i]=='?' and r[j]=='?') which is included in the above.\n\n      However, we can write the condition as: \n          if l[i] == '?' or r[j] == '?':\n              then compatible\n          else:\n              then l[i] must equal r[j]\n\n      But wait: what if one is fixed and the other is '?'? Then we don't require the fixed one to equal the '?'? Actually, no: the condition is that the '?' can match any, so yes.\n\n      So the condition is: \n          compatible = True\n          if l[i] != '?' and r[j] != '?':\n              compatible = (l[i] == r[j])\n          else:\n              compatible = True   # because at least one is '?'\n\n      However, note: if one is '?' and the other is fixed, then it's always compatible.\n\n    Now, we have a bipartite graph with two parts (left and right) and edges as above.\n\n    But n is 150000, so we cannot build the entire graph (which would have up to 150000*150000 edges).\n\n    We need a more efficient way.\n\n    We can try:\n\n      Step 1: Precompute the fixed boots and the '?' boots.\n\n      Step 2: Use a greedy matching for fixed boots.\n\n    However, note: the matching of fixed boots is only possible if the fixed boots on the left and right have the same color.\n\n    But how to match fixed boots? We can use a dictionary to count the fixed boots by color.\n\n    For fixed boots on the left, we have a multiset of colors (ignoring '?'). Similarly for the right.\n\n    Then, for each color c that appears in both left and right, we can match min(count_left[c], count_right[c]) pairs.\n\n    But wait: what about the fact that the '?' boots can be used to match the fixed boots that don't have enough counterparts?\n\n    Actually, we can use the '?' boots to fill the remaining boots. But note: the fixed boots that are not matched by the fixed ones can be matched by the '?' boots.\n\n    However, the problem is that the '?' boots can be used for either fixed or non-fixed.\n\n    Let me break down:\n\n    Let:\n\n      Let L_fixed = { color: count } for left fixed boots (non '?')\n      Let R_fixed = { color: count } for right fixed boots (non '?')\n\n      Also, we have:\n        L_question = list of indices for left boots that are '?'\n        R_question = list of indices for right boots that are '?'\n\n    Then, the maximum number of pairs we can form from fixed boots is limited by the color counts. Specifically, for a color c, we can form at most min(L_fixed[c], R_fixed[c]) pairs.\n\n    But note: we might not use all fixed boots because we are going to use the '?' boots to match the rest.\n\n    However, we are going to use the fixed boots to match fixed boots of the same color. Then, we will have:\n\n      Total fixed pairs = sum_{c} min(L_fixed[c], R_fixed[c])\n\n    Then, we have:\n\n      Remaining left boots (that are fixed) = total_fixed_left - (number of fixed boots used in fixed pairs)\n      Similarly, remaining right boots (that are fixed) = total_fixed_right - (number of fixed boots used in fixed pairs)\n\n    Then, we can use the '?' boots to match the remaining fixed boots? Actually, we can also use the '?' boots to match the remaining '?' boots.\n\n    But note: we can also use the '?' boots to match the fixed boots that were not matched by fixed boots. \n\n    However, the condition: the '?' boots can match any boot (fixed or not). \n\n    So, after matching the fixed boots (by color) we can:\n\n      Let U = n - (total_fixed_left + total_fixed_right - (fixed_pairs))   -> No, wait.\n\n    Actually, we have:\n\n      total_fixed_left = sum_{c} L_fixed[c]\n      total_fixed_right = sum_{c} R_fixed[c]\n\n      fixed_pairs = sum_{c} min(L_fixed[c], R_fixed[c])\n\n      Then, the remaining fixed boots (that haven't been matched) are:\n\n        L_fixed_remaining = total_fixed_left - fixed_pairs\n        R_fixed_remaining = total_fixed_right - fixed_pairs\n\n      Now, we can also match:\n\n        The '?' boots can match the remaining fixed boots and the remaining '?' boots.\n\n      How many pairs can we form from the remaining boots?\n\n        We have:\n          L_remaining = (L_question) + L_fixed_remaining   [but wait: the fixed boots that are not matched are still fixed, so they are part of the left fixed? Actually, we already separated the fixed and the '?'.]\n\n        Actually, the total left boots: \n          left: \n            fixed: total_fixed_left\n            question: len(L_question)\n\n        Similarly for right.\n\n        After matching the fixed pairs, we have:\n\n          left: \n            fixed_remaining: L_fixed_remaining (which is the fixed boots that weren't matched by fixed boots)\n            question: len(L_question)\n\n          right:\n            fixed_remaining: R_fixed_remaining\n            question: len(R_question)\n\n        Now, we can match:\n\n          - The fixed_remaining on the left can be matched with the fixed_remaining on the right? Actually, no: because the fixed boots must match by color. But wait, we already did the color matching for fixed boots. The remaining fixed boots are the ones that didn't find a fixed boot of the same color. However, they might be able to match with a '?' on the other side.\n\n        In fact, we can match:\n\n          Any fixed_remaining (on left) with any boot (fixed_remaining or question) on the right? Actually, the condition is that a fixed boot can only match a fixed boot of the same color or a '?'.\n\n        But note: we already considered fixed boots matching fixed boots. The remaining fixed boots on the left cannot be matched with fixed boots on the right (because for a given color, we took the minimum; so if there was an excess of fixed boots on the right for color c, then these right fixed boots of color c remain and cannot be matched with the left fixed boots of color c because we've taken as many as the left had. And they also cannot be matched with left fixed boots of a different color (unless via '?')? \n\n        Actually, no: the condition for fixed boots is that they must match a fixed boot of the same color or a '?'. \n\n        So:\n\n          We can use the '?' boots to match the remaining fixed boots (both sides). \n\n        Therefore, the total pairs we can form from the remaining boots is:\n\n          We have a bipartite graph between:\n\n            Left: \n                Group1: fixed_remaining (each node is a fixed boot that wasn't matched, and each has a specific color, say c_i)\n                Group2: question marks (each node is a '?')\n\n            Right:\n                Group1: fixed_remaining (each node is a fixed boot that wasn't matched, and each has a specific color, say d_j)\n                Group2: question marks (each node is a '?')\n\n          And edges:\n\n            Between a fixed_remaining (color c) and a fixed_remaining (color d) on the right: only if we allow fixed boots to match fixed boots? Actually, no: because we already did the fixed pairing by color and we took the maximum. The remaining fixed boots are those that did not get matched by the other side's fixed boot of the same color. However, we can still match two fixed boots (from left and right) if they have the same color? But wait: we already did that. \n\n          Actually, the fixed_remaining on the left are the ones that were not matched by the opposite fixed boots. So for a color c, if L_fixed[c] > min(L_fixed[c], R_fixed[c]), then we have L_fixed[c] - min(L_fixed[c], R_fixed[c]) left fixed boots of color c remaining. Similarly for the right.\n\n          But note: the fixed boots on the left and right are independent. We cannot match a left fixed boot of color c with a right fixed boot of color d if c != d, even if one or both are '?'? No, wait: no, if both are fixed, then they must be the same. But if one is fixed and the other is fixed, then same color. \n\n          However, we can match a left fixed boot of color c with a right '?' (regardless of the color c). Similarly, we can match a left '?' with a right fixed boot of color c.\n\n          Also, we can match a left '?' with a right '?'.\n\n        So the remaining graph is:\n\n          Left nodes: \n            Type F: fixed_remaining (with color known) -> can connect to any right node (if the right node is either fixed_remaining (then must be same color?) no, wait: the condition is that if the left is fixed and the right is fixed, then they must be the same. But we are in the remaining fixed boots, and we haven't matched them by color because we only did the matching for the fixed boots. However, we did the matching for fixed boots by color, so the remaining fixed boots are the ones that were not matched by the opposite fixed boots. But note: we did the matching by color for the fixed boots, so we did:\n\n                For each color c, we matched min(L_fixed[c], R_fixed[c]) pairs.\n\n            Then, the remaining fixed boots (on left) are the ones that are fixed and did not get matched by a fixed boot of the same color. They can still be matched with:\n\n                - A right fixed boot of the same color? -> no, because we already took the minimum, so if there was a surplus of right fixed boots of color c, then the left fixed boots of color c can only be matched with a right fixed boot of color c if there are still available? But wait, we did the matching by color: we matched as many as the minimum. Then, the remaining fixed boots of color c on the left can only be matched with:\n\n                    - A right fixed boot of color c? -> no, because we took the minimum, so the right fixed boots of color c that are left are exactly (R_fixed[c] - min(L_fixed[c], R_fixed[c])). But wait, we did not account for matching the remaining fixed boots of the same color? \n\n          Actually, the initial matching for fixed boots is done by color, so we don't have the freedom to match fixed boots of the same color across different colors. \n\n        Correction:\n\n          The standard way to match fixed boots (without using '?') is to use the color counts. But note: the problem allows matching fixed boots only if they are the same color. So we can only match fixed boots of the same color. Therefore, we must use the same color matching.\n\n        But now, the remaining fixed boots (left) and fixed boots (right) are of the same color? \n\n          For a given color c, the number of left fixed boots of color c is L_fixed[c]. The number of right fixed boots of color c is R_fixed[c]. We matched min(L_fixed[c], R_fixed[c]) pairs. Then, we are left with |L_fixed[c] - R_fixed[c]| boots of color c (if positive, then on the left; if negative, then on the right). \n\n        However, we cannot match these remaining fixed boots of color c with fixed boots of a different color. Because the condition requires exact match for fixed boots.\n\n        So the remaining fixed boots (both sides) can only be matched if we use the '?' boots.\n\n        Now, we have:\n\n          Total pairs from fixed boots: fixed_pairs = sum_c min(L_fixed[c], R_fixed[c])\n\n          Then, we have:\n\n            Left: \n                fixed_remaining_by_color = { c: max(0, L_fixed[c] - R_fixed[c]) for each color c }\n            Right:\n                fixed_remaining_by_color = { c: max(0, R_fixed[c] - L_fixed[c]) for each color c }\n\n          But note: we don't need to store by color for matching the remaining fixed boots with '?' because:\n\n          The remaining fixed boots (left) can be matched with the right's '?' boots (any right boot that is '?') and vice versa.\n\n          Similarly, the remaining fixed boots (right) can be matched with the left's '?' boots.\n\n        Then, the total pairs we can form from the remaining boots is:\n\n          Let X = total number of '?' on left = len(L_question)\n          Let Y = total number of '?' on right = len(R_question)\n\n          Now, we have:\n\n            We can form:\n\n              Type 1: Match a left fixed_remaining (any color) with a right '?' -> we can do at most min(X, (total_remaining_fixed_left)) but wait: actually, we have:\n\n              The left has two kinds: fixed_remaining and '?'\n              The right has two kinds: fixed_remaining and '?'\n\n          We can form:\n\n            Let A = total_remaining_fixed_left = sum_{c} max(0, L_fixed[c]-R_fixed[c])\n            Let B = total_remaining_fixed_right = sum_{c} max(0, R_fixed[c]-L_fixed[c])\n\n          Then, we can use the '?' boots to match:\n\n            - The remaining fixed boots (A + B) but note: we cannot match a fixed boot with a fixed boot (because they are of different colors or same color but we already accounted for same color matching) unless we use a '?' in between? Actually, no: the fixed boots must be matched by a '?' if there is no fixed boot of the same color available.\n\n          However, we can use the '?' boots arbitrarily. The maximum number of pairs we can form from the remaining boots is:\n\n            We can form at most (A + B) + min(X+Y, n - fixed_pairs - (A+B))? \n\n          Actually, let's think:\n\n            We have two groups:\n\n              Left: \n                  Group1: fixed_remaining (size = A)\n                  Group2: '?' (size = X)\n\n              Right:\n                  Group1: fixed_remaining (size = B)\n                  Group2: '?' (size = Y)\n\n            The edges:\n\n              - Group1 (left) can connect to:\n                  Group1 (right): only if same color? -> but we don't have the same color information for the remaining fixed boots. Actually, we don't have the color information for the entire set, but we know the color distribution.\n\n            Alternatively, we can use the following:\n\n              The maximum matching from the remaining graph is:\n\n                We can match:\n\n                  - All the fixed_remaining on the left (A) and fixed_remaining on the right (B) with the '?' boots, but note: we can also match the '?' boots together.\n\n            Actually, the condition for matching is:\n\n              - A left fixed_remaining (color c) can match:\n                  - A right fixed_remaining (color d) only if c==d? But wait, no: because we are in the remaining fixed boots, and we already matched the same color ones. The remaining fixed boots are the ones that were not matched by the opposite fixed boots. However, we did not require that the fixed boots of different colors can be matched. They must be the same color.\n\n              So the remaining fixed boots (left) and (right) cannot be matched with each other unless they are the same color. But wait: we did the matching by color, so the remaining fixed boots of a given color c are the ones that were in excess on one side. And note: the remaining fixed boots of color c on the left cannot be matched with the remaining fixed boots of color c on the right because we already matched as many as the minimum, so the remaining are the excess. But we can match the left fixed_remaining (color c) with the right fixed_remaining (color c) if we haven't done so? Actually, no: because we did the matching by color, we matched min(L_fixed[c], R_fixed[c]) for each color. Then the remaining fixed boots of color c on the left are L_fixed[c] - min(L_fixed[c], R_fixed[c]) and on the right are R_fixed[c] - min(L_fixed[c], R_fixed[c]). These are the same as:\n\n                  left: max(0, L_fixed[c] - R_fixed[c])\n                  right: max(0, R_fixed[c] - L_fixed[c])\n\n              So they are nonnegative and if both are positive, then the left has more of color c and the right has less. But note: we did the matching by color independently for each color.\n\n              Therefore, we cannot match a left fixed_remaining (color c) with a right fixed_remaining (color d) for c != d, and for c=d, we can only match if there are remaining right fixed boots of color c (which there are if R_fixed[c] > L_fixed[c]). But wait, for color c, the left has L_fixed[c] and the right has R_fixed[c]. We matched min(L_fixed[c], R_fixed[c]). Then the left has L_fixed[c] - min(L_fixed[c], R_fixed[c]) = max(0, L_fixed[c]-R_fixed[c]) and the right has R_fixed[c] - min(L_fixed[c], R_fixed[c]) = max(0, R_fixed[c]-L_fixed[c]). \n\n              Now, if we have a left fixed_remaining of color c and a right fixed_remaining of color d (d != c), then they are not compatible (since fixed boots must match by color). \n\n              Therefore, the remaining fixed boots (both sides) cannot be matched with each other.\n\n            Then, the only possibilities for the remaining boots are:\n\n              - Left fixed_remaining (any color) can be matched with right '?' (any color)\n              - Left '?' can be matched with right fixed_remaining (any color)\n              - Left '?' can be matched with right '?'\n              - Left fixed_remaining (any color) can be matched with right fixed_remaining (only if same color? but note: we are not allowed to match two fixed boots of the same color if there is a surplus? Actually, no: because the condition requires same color. But if we have a surplus of left fixed boots of color c and a surplus of right fixed boots of color c, then we cannot match them because the left fixed_remaining of color c is from the left and the right fixed_remaining of color c is from the right, and they are the same color. But wait, we already matched the fixed boots by color, so the remaining fixed boots of color c are the ones that were not matched by the opposite side's fixed boots. However, we did not account for matching the left fixed boots of color c with the right fixed boots of color c beyond the minimum. \n\n            Actually, we did the matching by color, so we used the fixed boots of color c to match as many as the minimum. The remaining fixed boots of color c on the left and right are independent. \n\n            But note: we can match a left fixed boot of color c with a right fixed boot of color c if we haven't exhausted the right fixed boots of color c? \n\n            Let me clarify:\n\n              We did: for each color c, we matched min(L_fixed[c], R_fixed[c]) pairs.\n\n              Then, the remaining left fixed boots of color c is L_fixed[c] - min(L_fixed[c], R_fixed[c]).\n              The remaining right fixed boots of color c is R_fixed[c] - min(L_fixed[c], R_fixed[c]).\n\n              Now, if we want to match a left fixed boot of color c with a right fixed boot of color c, we can only do that if there is a remaining right fixed boot of color c? But wait, we already used all the right fixed boots of color c that we could (min(L_fixed[c], R_fixed[c])) so the remaining right fixed boots of color c is R_fixed[c] - min(L_fixed[c], R_fixed[c]) = max(0, R_fixed[c]-L_fixed[c]). \n\n              Similarly, the remaining left fixed boots of color c is max(0, L_fixed[c]-R_fixed[c]).\n\n              Therefore, we can only match a left fixed boot of color c with a right fixed boot of color c if R_fixed[c] > L_fixed[c]? But then the left fixed boot of color c is in surplus, so we don't have any right fixed boot of color c left. \n\n            So no, we cannot match the remaining fixed boots of the same color.\n\n            Therefore, the remaining fixed boots (both sides) must be matched with the '?' boots.\n\n            Now, we have:\n\n              We can form:\n\n                pairs1: match left fixed_remaining (any color) with right '?' -> we can do at most min(A, Y) [because we have A left fixed_remaining and Y right '?']\n                pairs2: match left '?' with right fixed_remaining (any color) -> we can do at most min(X, B) [because we have X left '?' and B right fixed_remaining]\n                pairs3: match left '?' with right '?' -> we can do at most min(X - pairs2_used, Y - pairs1_used)\n\n            But note: the '?' boots are shared. So we have to consider the total usage.\n\n            Alternatively, we can think: the total pairs from the remaining graph is:\n\n              total_remaining_pairs = min(A + B, X + Y)   ??? \n\n            But wait, we have two kinds of edges: \n                - Edges between fixed_remaining and '?'\n                - Edges between '?' and fixed_remaining\n                - Edges between '?' and '?'\n\n            Actually, the entire remaining graph is:\n\n              Left: A + X\n              Right: B + Y\n\n            And the edges: every left node (whether fixed_remaining or '?') can connect to every right node (whether fixed_remaining or '?') EXCEPT:\n\n                - There is no restriction for '?' nodes (they can connect to anything)\n                - For fixed_remaining nodes, they can only connect to:\n                    - '?' nodes (on the right) and \n                    - fixed_remaining nodes (on the right) if they have the same color? \n\n            But we just determined that we cannot match fixed_remaining nodes with fixed_remaining nodes (because they are of different colors or same color but we don't have the same color in the opposite side). Actually, we can only match fixed_remaining nodes with '?' nodes, and '?' nodes can also match with fixed_remaining nodes and with '?' nodes.\n\n            However, note: the condition for fixed_remaining nodes (which are fixed boots) is that they must match a fixed boot of the same color OR a '?'. But we cannot match two fixed boots of the same color that are remaining (as discussed). So the fixed_remaining nodes can only match with '?' nodes.\n\n            Similarly, the fixed_remaining nodes on the right can only match with '?' nodes on the left.\n\n            And the '?' nodes can match with any.\n\n            Therefore, we can model the remaining graph as:\n\n              Left: \n                Type F: fixed_remaining (size A) -> can only connect to right nodes of type '?' (size Y) and also to right nodes of type fixed_remaining? -> no, because the condition for fixed boots is that they must match by color, and we don't know the color of the fixed_remaining on the right? Actually, the fixed_remaining on the right are fixed boots (so they have a specific color) and the fixed_remaining on the left has a specific color. They can only match if the colors are the same. But we don't know if the colors match. \n\n            However, we did the initial matching by color. The remaining fixed boots are the ones that were not matched by the opposite side's fixed boots. There is no guarantee that a left fixed_remaining of color c can be matched with a right fixed_remaining of color c because we already matched min(L_fixed[c], R_fixed[c]) and the remaining on the left is L_fixed[c] - min(L_fixed[c], R_fixed[c]) and on the right is R_fixed[c] - min(L_fixed[c], R_fixed[c]). \n\n            But note: the remaining fixed boots of color c on the left are the ones that were not matched by the right's fixed boots of color c. The right's fixed boots of color c are all matched (if R_fixed[c] <= L_fixed[c]) then the left has R_fixed[c] left and the right has 0 left. But if R_fixed[c] > L_fixed[c], then the right has R_fixed[c] - L_fixed[c] left, and the left has 0. So the remaining fixed boots of color c on one side cannot be matched with the remaining fixed boots of color c on the other side because we already matched as many as the minimum.\n\n            Therefore, the remaining fixed boots (both sides) cannot be matched with each other.\n\n            Then, the fixed_remaining nodes (left) can only connect to the '?' nodes (right) and the fixed_remaining nodes (right) can only connect to the '?' nodes (left). \n\n            Additionally, the '?' nodes can connect to any.\n\n            Then, the problem reduces to:\n\n              We have two sets:\n\n                Left: A fixed_remaining (each has a color, but we don't care) and X '?' \n                Right: B fixed_remaining and Y '?'\n\n              Constraints:\n\n                - Each fixed_remaining (left) can only connect to '?' (right)\n                - Each fixed_remaining (right) can only connect to '?' (left)\n                - Each '?' (left) can connect to any (right)\n                - Each '?' (right) can connect to any (left)\n\n            We wish to maximize the total pairs.\n\n            We can use a bipartite matching that accounts for the fact that the fixed_remaining nodes have restrictions.\n\n            But note: the graph is actually a complete bipartite graph between:\n\n                Left: fixed_remaining and '?' \n                Right: fixed_remaining and '?'\n\n            except that fixed_remaining nodes cannot connect to fixed_remaining nodes (unless they are the same color and we are allowed to match them? But we just said no).\n\n            Actually, the condition is:\n\n                Edge between left fixed_remaining (color c) and right fixed_remaining (color d): exists only if c==d? -> but we don't know the color distribution. However, we cannot rely on color matching for the remaining fixed boots because we already matched by color. But wait, what if we have two fixed boots of the same color that are remaining on opposite sides? \n\n            Example: \n                l: \"a?\" \n                r: \"?a\"\n\n            Here, we have:\n                fixed boots: \n                    left: ['a'] -> fixed\n                    right: ['a'] -> fixed\n\n                Then, we match the fixed boots: min(1,1)=1 pair.\n\n                Then, we have:\n                    left: ['?'] -> 1 '?' \n                    right: ['?'] -> 1 '?'\n\n                Then, we can form one more pair: the '?' and '?'.\n\n            But wait, the example:\n\n                l: \"a??\"\n                r: \"??a\"\n\n            We have:\n                fixed boots: \n                    left: ['a'] -> fixed\n                    right: ['a'] -> fixed\n\n                Then, we match the fixed boots: 1 pair.\n\n                Then, left: ['?', '?'] (2)\n                right: ['?', '?'] (2)\n\n                Then, we can form 2 more pairs.\n\n            But now, consider:\n\n                l: \"a?b\"\n                r: \"b?a\"\n\n            We have:\n                fixed boots: \n                    left: ['a','b'] -> fixed\n                    right: ['b','a'] -> fixed\n\n                Matching by color: \n                    color 'a': left has 1, right has 1 -> 1 pair.\n                    color 'b': left has 1, right has 1 -> 1 pair.\n\n                Then, no fixed boots left.\n\n                Then, left: [] (because we used all fixed boots) and right: [] -> no '?'.\n\n                But wait, the input has no '?'? \n\n            So the above example is fixed boots only.\n\n            Now, consider with '?':\n\n                l: \"a?b\"\n                r: \"b?a\"\n\n            Actually, that example has no '?'. \n\n            Let me take:\n\n                l: \"a?b\"\n                r: \"b??\"\n\n            Then, fixed boots:\n                left: ['a','b'] -> fixed\n                right: ['b'] -> fixed\n\n            Matching by color:\n                'a': left has 1, right has 0 -> 0\n                'b': left has 1, right has 1 -> 1\n\n            Then, fixed pairs: 1.\n\n            Then, left: ['?'] (1)\n            right: ['?'] (2) -> but wait, the right string is \"b??\" -> so two '?'.\n\n            Then, we can form:\n\n                The left '?' can match any of the two right '?'.\n\n            But note: we can also consider matching the left fixed boots differently? \n\n            However, the",
    "response": "\nTo solve this problem, we need to maximize the number of compatible pairs of boots (left and right) where each boot can be part of at most one pair. The compatibility is defined such that two specific colors must be the same, while an indefinite color '?' can match any color.\n\n### Approach\n1. **Problem Analysis**: The problem involves matching left and right boots based on their colors. The key observation is that fixed colors (non '?') can only match other fixed colors of the same type, while '?' can match any color. The challenge is to maximize the number of pairs efficiently, especially given the constraints (n up to 150,000).\n\n2. **Intuition**: The solution involves two main steps:\n   - **Step 1: Match Fixed Boots**: First, match as many fixed boots (non '?') as possible by their color. For each color, the number of pairs is the minimum of its occurrences in the left and right boots.\n   - **Step 2: Match Remaining Boots**: After matching fixed boots, use the remaining '?' boots to match the unmatched fixed boots and other '?' boots. The remaining fixed boots can only be matched with '?' boots, and '?' boots can match any remaining boots.\n\n3. **Algorithm Selection**: \n   - **Frequency Counting**: Use dictionaries to count occurrences of each color in both left and right boots.\n   - **Greedy Matching**: For each color, match the minimum of its counts in left and right boots. Then, use a bipartite graph approach for the remaining '?' boots, but optimized to avoid full graph construction due to large input size.\n\n4. **Complexity Analysis**: The algorithm processes each boot once for counting and matching, resulting in an O(n) time complexity, which is efficient for the given constraints.\n\n### Solution Code\n```python\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    if not data: \n        return\n    n = int(data[0].strip())\n    l_str = data[1].strip()\n    r_str = data[2].strip()\n    \n    left_fixed = []\n    left_question = []\n    right_fixed = []\n    right_question = []\n    \n    for i, (lc, rc) in enumerate(zip(l_str, r_str)):\n        if lc != '?':\n            left_fixed.append((i+1, lc))\n        else:\n            left_question.append(i+1)\n        if rc != '?':\n            right_fixed.append((i+1, rc))\n        else:\n            right_question.append(i+1)\n            \n    fixed_left_count = defaultdict(int)\n    for _, color in left_fixed:\n        fixed_left_count[color] += 1\n        \n    fixed_right_count = defaultdict(int)\n    for _, color in right_fixed:\n        fixed_right_count[color] += 1\n        \n    pairs_from_fixed = 0\n    result_pairs = []\n    \n    for color in fixed_left_count:\n        if color in fixed_right_count:\n            count_min = min(fixed_left_count[color], fixed_right_count[color])\n            pairs_from_fixed += count_min\n            for _ in range(count_min):\n                idx_l = left_fixed.pop(0)[0]\n                idx_r = right_fixed.pop(0)[0]\n                result_pairs.append((idx_l, idx_r))\n                \n    total_pairs = pairs_from_fixed\n    \n    fixed_left_remaining = left_fixed\n    fixed_right_remaining = right_fixed\n    \n    q_left = left_question\n    q_right = right_question\n    \n    total_left_remaining = fixed_left_remaining + q_left\n    total_right_remaining = fixed_right_remaining + q_right\n    \n    while fixed_left_remaining and fixed_right_remaining:\n        lc = fixed_left_remaining[0][1]\n        rc = fixed_right_remaining[0][1]\n        if lc == rc:\n            idx_l = fixed_left_remaining.pop(0)[0]\n            idx_r = fixed_right_remaining.pop(0)[0]\n            result_pairs.append((idx_l, idx_r))\n            total_pairs += 1\n        else:\n            break\n            \n    while fixed_left_remaining and q_right:\n        idx_l = fixed_left_remaining.pop(0)[0]\n        idx_r = q_right.pop(0)\n        result_pairs.append((idx_l, idx_r))\n        total_pairs += 1\n        \n    while fixed_right_remaining and q_left:\n        idx_r = fixed_right_remaining.pop(0)[0]\n        idx_l = q_left.pop(0)\n        result_pairs.append((idx_l, idx_r))\n        total_pairs += 1\n        \n    while q_left and q_right:\n        idx_l = q_left.pop(0)\n        idx_r = q_right.pop(0)\n        result_pairs.append((idx_l, idx_r))\n        total_pairs += 1\n        \n    result_pairs.sort(key=lambda x: (x[0], x[1]))\n    \n    print(total_pairs)\n    for a, b in result_pairs:\n        print(f\"{a} {b}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input consists of the number of boots and two strings representing the left and right boots' colors.\n2. **Separating Boots**: The code separates the boots into fixed colors (non '?') and '?' boots for both left and right sides.\n3. **Matching Fixed Boots**: It counts occurrences of each fixed color and matches them by their color, ensuring maximum pairs without using '?' boots.\n4. **Handling Remaining Boots**: After matching fixed boots, the remaining fixed boots are matched with '?' boots. Finally, any remaining '?' boots are paired together.\n5. **Output**: The total number of pairs is printed, followed by each pair's indices in the specified format.\n\nThis approach efficiently maximizes the number of compatible pairs by leveraging frequency counting and greedy matching, ensuring optimal performance even for large inputs.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import defaultdict\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    if not data: \n        return\n    n = int(data[0].strip())\n    l_str = data[1].strip()\n    r_str = data[2].strip()\n    \n    left_fixed = []\n    left_question = []\n    right_fixed = []\n    right_question = []\n    \n    for i, (lc, rc) in enumerate(zip(l_str, r_str)):\n        if lc != '?':\n            left_fixed.append((i+1, lc))\n        else:\n            left_question.append(i+1)\n        if rc != '?':\n            right_fixed.append((i+1, rc))\n        else:\n            right_question.append(i+1)\n            \n    fixed_left_count = defaultdict(int)\n    for _, color in left_fixed:\n        fixed_left_count[color] += 1\n        \n    fixed_right_count = defaultdict(int)\n    for _, color in right_fixed:\n        fixed_right_count[color] += 1\n        \n    pairs_from_fixed = 0\n    result_pairs = []\n    \n    for color in fixed_left_count:\n        if color in fixed_right_count:\n            count_min = min(fixed_left_count[color], fixed_right_count[color])\n            pairs_from_fixed += count_min\n            for _ in range(count_min):\n                idx_l = left_fixed.pop(0)[0]\n                idx_r = right_fixed.pop(0)[0]\n                result_pairs.append((idx_l, idx_r))\n                \n    total_pairs = pairs_from_fixed\n    \n    fixed_left_remaining = left_fixed\n    fixed_right_remaining = right_fixed\n    \n    q_left = left_question\n    q_right = right_question\n    \n    total_left_remaining = fixed_left_remaining + q_left\n    total_right_remaining = fixed_right_remaining + q_right\n    \n    while fixed_left_remaining and fixed_right_remaining:\n        lc = fixed_left_remaining[0][1]\n        rc = fixed_right_remaining[0][1]\n        if lc == rc:\n            idx_l = fixed_left_remaining.pop(0)[0]\n            idx_r = fixed_right_remaining.pop(0)[0]\n            result_pairs.append((idx_l, idx_r))\n            total_pairs += 1\n        else:\n            break\n            \n    while fixed_left_remaining and q_right:\n        idx_l = fixed_left_remaining.pop(0)[0]\n        idx_r = q_right.pop(0)\n        result_pairs.append((idx_l, idx_r))\n        total_pairs += 1\n        \n    while fixed_right_remaining and q_left:\n        idx_r = fixed_right_remaining.pop(0)[0]\n        idx_l = q_left.pop(0)\n        result_pairs.append((idx_l, idx_r))\n        total_pairs += 1\n        \n    while q_left and q_right:\n        idx_l = q_left.pop(0)\n        idx_r = q_right.pop(0)\n        result_pairs.append((idx_l, idx_r))\n        total_pairs += 1\n        \n    result_pairs.sort(key=lambda x: (x[0], x[1]))\n    \n    print(total_pairs)\n    for a, b in result_pairs:\n        print(f\"{a} {b}\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 794,
        "completion_token_count": 1202,
        "thoughts_token_count": 8191
    }
}