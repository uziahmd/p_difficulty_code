{
    "start": 1758300891.4568548,
    "end": 1758304713.0155978,
    "start-formatted": "2025-09-20 01:54 KST",
    "end-formatted": "2025-09-20 02:58 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\n Okay, let's break down the problem.\n\n We are given an integer p (0 <= p <= 200000). We need to find:\n  1. The minimum number of nodes n such that there exists a directed graph with n nodes that is p-reachable.\n     - A graph is p-reachable if it contains exactly p ordered pairs (u, v) with u < v and u and v are mutually reachable.\n\n  2. Among all such graphs with n nodes, we need to maximize the number of unidirectional pairs (u, v) (with u != v, path from u to v but not from v to u).\n\n Observation:\n\n In a directed graph, mutual reachability (i.e., strongly connected components) is important.\n\n Let the graph have k strongly connected components (SCCs). Then, the entire graph can be represented as a DAG of these SCCs.\n\n Condition for mutual reachability: \n   - Within an SCC, every node is mutually reachable with every other node. Therefore, the number of unordered pairs (u, v) with u < v in an SCC of size s is C(s,2) = s*(s-1)//2.\n   - However, note the problem counts ordered pairs (u, v) with u < v and mutual reachability. But note: the condition is for ordered pairs (u, v) with u < v? Actually, the problem says \"exactly p ordered pairs (u, v) such that u < v and u and v are reachable from each other\". \n\n But wait: the definition of p-reachable is about the number of pairs (u, v) with u < v (so unordered by index) that are mutually reachable. However, note that in the entire graph, mutual reachability is defined within an SCC. And the entire graph might have multiple SCCs.\n\n However, note that two nodes in different SCCs are not mutually reachable (unless they are in the same SCC). So the total number of mutually reachable pairs (with u < v) is the sum over each SCC of C(size_i, 2).\n\n Therefore, we require:\n   sum_{i=1}^{k} [size_i*(size_i-1)//2] = p\n\n But note: the graph must be built with n nodes (which is the sum of the sizes of the SCCs). We are allowed to have a DAG structure on the SCCs. However, we can also choose the sizes arbitrarily as long as the sum of the C(size_i,2) equals p and the total nodes n is minimized.\n\n However, note: the graph must be built with the minimum number of nodes. How do we minimize n?\n\n We note that we can combine SCCs arbitrarily (since we are building a DAG, we can arrange the SCCs in a linear order to avoid cycles between them). The condition for having exactly p mutual pairs is that the multiset of SCC sizes must satisfy that the sum of combinations (each component gives C(s_i,2)) is p.\n\n But note: we are free to choose the decomposition of the n nodes into SCCs. We want the minimum n such that there exists a decomposition of n into positive integers (each at least 1) so that the sum of C(s_i,2) is p.\n\n Alternatively, we can think of the problem as: we need to represent p as the sum of triangular numbers (each triangular number being C(s,2) for some s>=1). And we wish to minimize the total n = s_1 + s_2 + ... + s_k.\n\n However, note: the triangular numbers are T_s = s*(s-1)//2. We can use the fact that the minimal n is achieved by using as few components as possible? Actually, we want to minimize the total nodes, so we want to represent p as a sum of triangular numbers with the smallest possible total s_1+s_2+...+s_k.\n\n How to minimize the total nodes? Note that the total nodes is the sum of the sizes.\n\n We know that for a fixed set of triangular numbers (each T_s = s*(s-1)//2) we are looking for a representation of p as the sum of these triangular numbers, and we wish to minimize the sum of the corresponding s.\n\n Since the triangular numbers are nonnegative and increasing, we can consider the greedy approach: use the largest triangular number that is <= p, then subtract and continue.\n\n However, note: we are allowed to use any triangular number multiple times (because we can have multiple SCCs of the same size). But note: the triangular numbers are not necessarily distinct.\n\n But we cannot use a triangular number more than once? Actually, we can have multiple SCCs of the same size. For example, two SCCs of size 3: then we get 2 * T_3 = 2 * 3 = 6.\n\n So we are to represent p as the sum of some triangular numbers (each T_s = s*(s-1)//2) and we wish to minimize the sum of the corresponding s.\n\n However, note: the problem does not require the graph to be connected. We can have any number of SCCs.\n\n Let's denote:\n   Let x_s be the number of SCCs of size s.\n\n Then we have: sum_{s>=1} x_s * T_s = p, and the total nodes n = sum_{s>=1} x_s * s.\n\n We wish to minimize n.\n\n Alternatively, we can think of the problem as: we wish to write p as the sum of triangular numbers (each term is a triangular number) and minimize the sum of the bases (the s for each triangular number T_s).\n\n But note: the triangular numbers are fixed for each s.\n\n Example: p=3.\n\n   We can use one SCC of size 3: T_3 = 3 -> then n = 3.\n   Or we can use three SCCs of size 2: T_2 = 1, so 1+1+1=3, then n = 2+2+2 = 6.\n\n So the minimum n is 3.\n\n Example: p=4.\n\n   One way: four SCCs of size 2: 4*1=4 -> n=8.\n   Another way: one SCC of size 3 (which gives 3) and one SCC of size 2 (which gives 1): total p=4, then n=3+2=5.\n\n So we need to minimize n.\n\n We can use dynamic programming or greedy? But note p up to 200000.\n\n Alternative approach: we note that the triangular numbers are T_s = s*(s-1)//2. The maximum s needed: since T_s = s*(s-1)//2 <= p, then s is at most about sqrt(2p). For p=200000, s_max ~ sqrt(400000) ~ 632.\n\n But we are going to use a greedy algorithm that uses the largest triangular numbers first? However, we are minimizing the total nodes, so we want to use as large SCCs as possible because one large SCC (with size s) gives T_s = s*(s-1)//2 and the cost is s. The ratio of T_s to s is (s-1)/2, which increases with s. So we prefer larger s to cover more p with fewer nodes.\n\n However, note: we are minimizing the total nodes. Using one large SCC of size s gives T_s and uses s nodes. But if we break that large SCC into smaller ones, we might get the same p? Not necessarily. Actually, we want to minimize the total nodes, so we want to use as few nodes as possible to account for p.\n\n But wait: the goal is to have exactly p mutual pairs (which is the sum of T_s over SCCs). The total nodes is the sum of the sizes.\n\n Now, note that the same p can be achieved by different decompositions. We wish to minimize the total nodes.\n\n How to compute the minimal n?\n\n Observation: the function f(s) = T_s (the triangular number) and the cost g(s)=s. We want to represent p as a sum of triangular numbers and minimize the sum of the corresponding s.\n\n This is similar to the classic coin change problem but with minimization of the total value (here the value is the node count) and coins are the triangular numbers (each triangular number is available unlimitedly). However, the triangular numbers grow quadratically so we can use a greedy method? Actually, we can use a greedy method because the triangular numbers are increasing and we want to minimize the total nodes.\n\n But note: sometimes using a larger triangle might lead to a lower total node count? Actually, no: because the density (T_s / s) is (s-1)/2, which increases with s. So using larger triangles is more efficient (more p per node). Therefore, we should use as many large triangles as possible.\n\n However, we must check if we can use a particular triangle. For example, for p=4:\n\n   Use the largest triangular number <=4: T_3=3, then we have 4-3=1 left. Then we use T_2=1 (since 1<=1). Then total nodes = 3+2=5.\n\n   Alternatively, if we try to use two T_2's: 1+1=2, then we need 4-2=2 left. Then we use two more T_2's? Then total p=4, total nodes=8.\n\n   But wait, we can also use four T_1's? T_1=0, but note: T_1 = 0 (because 1*(0)//2=0). So that doesn't help.\n\n   Actually, the problem requires p-reachable, and if we have an SCC of size 1, then T_1=0, so we don't count any mutual pair for that node. But we can have multiple isolated nodes (each is an SCC) and they don't contribute to p. However, they add to the node count.\n\n   So we must avoid using T_1 if we can avoid it because they only add nodes without contributing to p.\n\n Steps:\n\n   Step 1: Find the minimum n (number of nodes) such that there exists a decomposition of n into positive integers (each representing an SCC size) and the sum of T_s (for each s) is p.\n\n   Step 2: Then, among all graphs with n nodes that are p-reachable, we want to maximize the number of unidirectional pairs.\n\n How to maximize the number of unidirectional pairs?\n\n   In a graph, an unidirectional pair (u, v) is an ordered pair (u != v) such that there is a path from u to v but not from v to u.\n\n   Note: In our graph, we have a DAG of SCCs. Within an SCC, every node is mutually reachable, so no unidirectional edge within an SCC. Between two different SCCs, say A and B, if there is an edge from A to B but not from B to A, then every node in A and every node in B form unidirectional pairs (because from any node in A you can reach any node in B, but not vice versa). However, note: the graph is directed and we can choose the edges arbitrarily (as long as the mutual reachability condition holds). But note: the problem does not specify the structure beyond the SCCs. However, the mutual reachability condition is defined by the SCCs.\n\n   The key is: we can have edges only in one direction between two SCCs (since if we have an edge from A to B and an edge from B to A, then A and B would form a single SCC). So between two distinct SCCs, we can have at most one direction of edges (from one to the other) to avoid merging them.\n\n   Now, what edges are present? We are allowed to choose any edges as long as the mutual reachability is exactly the SCCs we defined. So we can choose the edges arbitrarily as long as within each SCC the graph is strongly connected and between SCCs the edges form a DAG (no cycles).\n\n   However, we are to maximize the number of unidirectional pairs.\n\n   Note: The unidirectional pairs can come from two types:\n\n      Type 1: Between two different SCCs, if there is an edge from A to B, then for every node u in A and every node v in B, we have a unidirectional pair (u, v). Similarly, if there is an edge from B to A, then we have unidirectional pairs (v, u) for every v in B and u in A.\n\n      But note: we cannot have both edges (A->B and B->A) because then A and B would be merged.\n\n   Also, note: we can have multiple edges from A to B? Actually, we can have as many edges as we want, but note: the problem is about reachability. However, the definition of unidirectional pair is based on the existence of a path, not necessarily a direct edge.\n\n   But observe: if we have a path from A to B, then regardless of the internal edges, we get unidirectional pairs from A to B. However, the problem allows us to design the graph arbitrarily (as long as the mutual reachability is the given SCCs). To maximize the unidirectional pairs, we would want to have as many paths as possible in one direction between two SCCs and none in the reverse.\n\n   However, note: the mutual reachability condition is fixed by the SCCs. The DAG structure on the SCCs must be acyclic. So we can have edges from an earlier SCC to a later one (in topological order) but not backward.\n\n   Now, the total number of unidirectional pairs:\n\n     Consider two SCCs A and B (with |A|=a, |B|=b). If there is a path from A to B (but not from B to A), then we get a*b unidirectional pairs (from A to B). Similarly, if there is a path from B to A, we get b*a unidirectional pairs.\n\n     But note: we cannot have both. So for two distinct SCCs, we can have either:\n\n        - No edges: then no unidirectional pairs between A and B.\n\n        - Edges from A to B: then a*b unidirectional pairs.\n\n        - Edges from B to A: then b*a unidirectional pairs.\n\n     However, we are allowed to have multiple edges? Actually, the problem does not specify. But note: the existence of a path is what matters. We can choose the edges arbitrarily as long as the mutual reachability is preserved. We can even have no edges at all between two SCCs.\n\n     But note: the mutual reachability condition is already fixed by the SCCs. The DAG structure must be such that if there is a path from A to B, then we have a directed edge in the DAG from A to B? Actually, no. The DAG is the condensation of the graph, so we only include an edge between two SCCs if there is at least one edge from one to the other. But we can have multiple edges.\n\n     However, for the purpose of counting unidirectional pairs, we only care about the existence of a path. So we can assume that if we want a path from A to B, we can put a direct edge from A to B (to save edges) and then we get a*b unidirectional pairs.\n\n     But note: we are allowed to have as many edges as we want, so we can always arrange the DAG edges arbitrarily (without creating cycles). To maximize the unidirectional pairs, we should set up the DAG such that for every pair of SCCs (A, B) (with A and B distinct) we choose the direction (if any) that maximizes the product. However, we cannot choose both directions. But we are free to choose the DAG arbitrarily (as long as it is acyclic). \n\n     Actually, we are not forced to have edges in the DAG. We can choose which pairs of SCCs to connect and in which direction. However, the condition for mutual reachability is that if two SCCs are connected by edges (in either direction) then they would merge? Actually, no: if we have edges from A to B and from B to A, then they merge. But we are not allowed to have cycles (the condensation is a DAG). So we can only have edges in one direction (or none) between two SCCs.\n\n     Therefore, the DAG is arbitrary as long as it is acyclic.\n\n     Now, to maximize the unidirectional pairs, we should set up the DAG so that for every pair of distinct SCCs, we put an edge from the one with the smaller index (by the order we assign) to the one with the larger index? But wait, we can choose the order arbitrarily. However, note: the problem does not fix the labeling of the nodes. We are only concerned with the number of unidirectional pairs.\n\n     Actually, we can arrange the DAG to be a total order (linear) of the SCCs. Then, we have edges from every earlier SCC to every later SCC. Then, for two SCCs A and B, if A comes before B, then we have edges from A to B (and hence a*b unidirectional pairs) but not from B to A.\n\n     Then, the total number of unidirectional pairs is the sum over all pairs (A, B) with A < B (in the topological order) of (a * b). But note: we can also choose to not connect some pairs? However, if we don't connect a pair, we don't get those unidirectional pairs.\n\n     But wait: the problem is about the entire graph. The unidirectional pairs are defined by the existence of a path. In a linear DAG (total order), we have a path from every SCC to every SCC that comes after it. Therefore, we get unidirectional pairs for every ordered pair (u, v) where u is in an earlier SCC and v is in a later SCC.\n\n     However, we are allowed to have a DAG that is not necessarily a total order. But if we leave out some edges, then we don't have a path from an earlier to a later SCC, so we lose the unidirectional pairs for that edge.\n\n     Therefore, to maximize the unidirectional pairs, we should make the DAG a complete DAG (i.e., a total order) and then we get all the pairs from earlier to later.\n\n     Then, the total unidirectional pairs is the sum_{i<j} (size_i * size_j) for the SCCs, but wait: actually, we have a linear ordering of the SCCs. However, we can choose the ordering arbitrarily. The sum of products for two sets of numbers (the sizes) is maximized when we order the SCCs arbitrarily? Actually, the expression is independent of the order: \n\n        Sum_{i<j} (size_i * size_j) = (Total)^2 - (sum_i size_i^2)) / 2\n\n     But note: we have fixed the sizes (from the decomposition). The total is n (the total number of nodes). Then:\n\n        Total pairs (if we consider all ordered pairs of distinct nodes) is n*(n-1).\n        The mutual pairs (within SCCs) is p (given). But note: the mutual pairs are counted only for pairs (u, v) with u<v and mutual reachability. However, in our graph, the mutual reachability is only within the same SCC. There are no mutual pairs between different SCCs.\n\n        Then, the total number of ordered pairs (u, v) with u != v is n*(n-1). This includes:\n          - Mutual pairs (within SCCs): p (but note: p is defined as the number of pairs (u, v) with u < v and mutual reachability. However, note that the mutual reachability is symmetric: if (u, v) is mutual then (v, u) is also mutual, but the problem only counts (u, v) with u < v. So the total mutual pairs (counting both directions) is 2*p? Actually, no: the problem defines the p-reachable condition by counting only the pairs (u, v) with u < v. But note: the graph is directed and the mutual reachability is symmetric. However, the problem does not require the entire graph to be symmetric.\n\n        Actually, we have:\n\n          - In the entire graph, the total number of ordered pairs (u, v) (with u != v) that are mutually reachable is 2 * (the number of unordered pairs of nodes in the same SCC). But wait: for an SCC of size s, the number of ordered pairs (u, v) (with u != v) that are mutually reachable is s*(s-1). However, the problem only counts the pairs (u, v) with u < v (so half of these, but note: the condition u < v is by node index, not by the graph structure). \n\n        But note: the problem's condition for p-reachable is exactly p (the number of pairs (u, v) with u < v and mutual reachability). This is independent of the graph structure's indexing? Actually, the problem does not specify how the nodes are labeled. However, we are constructing the graph arbitrarily.\n\n        Let me clarify: the graph has n nodes, and we can label them arbitrarily. So we can assign labels arbitrarily to the SCCs. Therefore, we can arrange the nodes so that the mutual pairs (within an SCC) are exactly the pairs (u, v) with u < v (if we label the entire SCC with consecutive indices). Then, the total p is the sum of C(s_i, 2) (which is the same as the number of unordered pairs in the SCCs).\n\n        Now, the total number of ordered pairs (u, v) (with u != v) that are mutually reachable is 2 * p? Actually, no: because the condition for mutual reachability is symmetric. However, the problem only counts the pairs (u, v) with u < v. So if we have an SCC of size 3, then the number of pairs (u, v) with u < v and mutual reachability is 3 (since C(3,2)=3). And the graph has 3*2=6 ordered pairs (u, v) (with u != v) that are mutually reachable: (u1,u2), (u1,u3), (u2,u3) and the reverses (u2,u1), (u3,u1), (u3,u2). But the problem only counts the 3 forward pairs (assuming u1<u2<u3).\n\n        Therefore, the entire graph has:\n\n          - Total ordered pairs (u, v) with u != v: n*(n-1)\n          - Number of mutual ordered pairs (both directions) is 2 * (the number of pairs (u, v) with u < v and mutual reachability) = 2 * p.\n\n        But wait: in the entire graph, the mutual pairs (both directions) are exactly the edges of the underlying undirected graph of the SCCs. The total mutual pairs (both directions) is 2 * (sum_i C(s_i,2)) = 2 * p.\n\n        Then, the remaining ordered pairs (u, v) (with u != v) are the unidirectional ones. But note: the unidirectional pairs are defined as: there exists a path from u to v and not from v to u. These are the non-symmetric pairs.\n\n        Therefore, the total number of ordered pairs (u, v) (u != v) is n*(n-1). This equals:\n\n          (mutual pairs) + (unidirectional pairs)\n\n        But mutual pairs are counted twice? Actually, no: the mutual pairs are two-way. The unidirectional pairs are one-way. And the rest are the opposite one-way? Actually, we have:\n\n          For each ordered pair (u, v) (u != v):\n            - Either there is a path from u to v and not from v to u (then it's unidirectional from u to v)\n            - Or there is a path from v to u and not from u to v (then it's unidirectional from v to u)\n            - Or both (then it's mutual, but note: mutual requires both, so if both exist then it's not unidirectional)\n            - Or neither.\n\n        However, note: the graph is built from SCCs and a DAG on top. The mutual pairs (both ways) occur only within an SCC. Between two different SCCs, if there is a path from u (in A) to v (in B) and no path from B to A, then we have unidirectional from A to B. Similarly, if there is a path from B to A, then unidirectional from B to A. But if there is no path in either direction, then it's not counted.\n\n        Now, note: the entire graph is built from SCCs and the DAG. The mutual pairs are only within the same SCC. The unidirectional pairs are only between different SCCs.\n\n        And the total number of ordered pairs (u, v) (u != v) is:\n\n          = (mutual pairs in the same SCC) + (unidirectional pairs from A to B for all A != B) + (unidirectional pairs from B to A for all A != B) + (pairs with no path in either direction)\n\n        But wait, the problem does not require that the graph is strongly connected or anything else. We can have pairs of nodes that are not connected in either direction.\n\n        However, the problem's definition of unidirectional requires that there is a path from u to v and no path from v to u. So if there is no path in either direction, then it's not unidirectional.\n\n        Therefore, the total number of unidirectional pairs is:\n\n          = (for every pair of distinct SCCs (A, B): if there is a path from A to B but not from B to A, then we count |A|*|B|)\n\n        But note: we can choose the DAG arbitrarily (as long as acyclic). Therefore, we can choose to have a complete DAG (all edges from earlier to later) and then we get for every ordered pair (A, B) with A < B (in the topological order) the unidirectional pairs |A|*|B|, and for (B, A) we don't have (because we don't have edges from B to A). \n\n        Then, the total unidirectional pairs is:\n\n          Sum_{i < j} (size_i * size_j)   [if we order the SCCs arbitrarily, but note: the DAG must be acyclic and we can choose the ordering arbitrarily]\n\n        However, note: the expression Sum_{i < j} (size_i * size_j) is independent of the order. It is:\n\n          = ( (sum_i size_i)^2 - sum_i size_i^2 ) / 2\n          = (n^2 - sum_i (size_i^2)) / 2\n\n        But wait, that is the sum over all unordered pairs (i, j) (i != j) of size_i * size_j. However, we are counting for every ordered pair (i, j) with i < j (in the topological order) the product. But note: the DAG structure (being a total order) ensures that for every unordered pair (A, B) we have exactly one direction (from the earlier to the later) and we count the product for that direction. However, if we choose the ordering arbitrarily, we can assign the SCCs to the topological order arbitrarily. But note: the product size_i * size_j is the same regardless of the order. Therefore, the total unidirectional pairs (if we choose a total order) is fixed by the multiset of SCC sizes: it is (n^2 - sum_i (size_i^2)) / 2.\n\n        However, wait: what if we don't choose a total order? Then we might miss some pairs. But to maximize the unidirectional pairs, we must choose a total order (so that we have a path from every earlier to every later). Then the above formula holds.\n\n        But note: the problem asks for the maximum number of unidirectional pairs among all p-reachable graphs with the minimum number of nodes.\n\n        Therefore, the maximum number of unidirectional pairs is (n^2 - sum_i (size_i^2)) / 2, provided we use a total order DAG.\n\n        However, is that the maximum? What if we leave out some edges? Then we don't get the full amount. So to maximize we must include all possible edges (in one direction) for the DAG.\n\n        Therefore, the answer for the second part is (n^2 - sum_i (size_i^2)) / 2.\n\n        But note: we have multiple decompositions that yield the same n (the minimal n). However, we want the maximum unidirectional pairs. We have shown that the maximum is achieved by the total order DAG and is (n^2 - sum_i (size_i^2))/2.\n\n        However, note: the decomposition (the multiset of SCC sizes) is fixed by the minimal n? Actually, no: there might be multiple decompositions that yield the same minimal n and the same p. Then, we must choose the decomposition that maximizes (n^2 - sum_i (size_i^2))/2.\n\n        But wait: we are to find the maximum unidirectional pairs among all graphs with the minimal n. The minimal n is fixed (we found the minimal n). Then, we have to decompose n into positive integers (the SCC sizes) such that the sum of T_s (the triangular numbers) is p, and we wish to maximize (n^2 - sum_i (size_i^2))/2.\n\n        Note: (n^2 - sum_i (size_i^2)) / 2 = (n^2 - (sum_i s_i^2)) / 2, and n is fixed. So to maximize this, we need to minimize sum_i (s_i^2). Why? Because n^2 is fixed.\n\n        So the problem reduces to: for a fixed n (minimal) and fixed p (the sum of T_s = p), we wish to minimize the sum of the squares of the sizes.\n\n        However, note: we are not free to choose the decomposition arbitrarily: we must have the sum of T_s equal to p.\n\n        But wait: we have already chosen the decomposition that achieves p and minimal n. Now, we are to choose the decomposition (with the same n) that maximizes the unidirectional pairs, i.e., minimizes the sum of squares.\n\n        How do we do that?\n\n        We are to minimize the sum of squares of the sizes (each size>=1) and the decomposition must satisfy:\n\n          sum_i C(s_i,2) = p   [Note: C(s_i,2)=s_i*(s_i-1)//2]\n\n        and the total sum of s_i is n.\n\n        We wish to minimize the sum_i (s_i^2).\n\n        Now, note: the function we are minimizing is the sum of squares. We know that for a fixed sum (n), the sum of squares is minimized when the numbers are as equal as possible. However, we have an additional constraint: the sum of T_s must be p.\n\n        But wait: we are not free to choose the decomposition arbitrarily: we must have the sum of T_s = p. However, we have already fixed n as the minimal n for which there exists a decomposition with sum of T_s = p. Now, we wish to know: is there only one decomposition? Or are there multiple?\n\n        Actually, the minimal n is computed by decomposing p into triangular numbers (each T_s) and then the total nodes is the sum of the s_i. But note: the triangular numbers are not necessarily distinct and we can use the same s multiple times.\n\n        Now, we wish to minimize the sum of squares (to maximize the unidirectional pairs) for the same n and same p.\n\n        How to relate?\n\n        We have two conditions:\n\n          Condition1: sum_i (s_i*(s_i-1)//2) = p\n          Condition2: sum_i s_i = n\n\n        And we wish to minimize sum_i (s_i^2).\n\n        Note: the sum of squares is minimized when the numbers are as equal as possible. However, we have an additional constraint (condition1). \n\n        But note: we have already fixed n (the minimal n). Then, we must choose a decomposition (a multiset of positive integers) that satisfies condition1 and has total sum n, and we wish to minimize the sum of squares.\n\n        However, the minimal n was computed by using as large s as possible (greedy). But there might be multiple decompositions (with the same n) that yield the same p.\n\n        Example: p=3, n=3: \n          Decomposition: one SCC of size 3: T_3=3, then condition1 holds. The sum of squares is 9.\n          Alternatively, we could have three SCCs of size 2? But T_2=1, so 1+1+1=3, then n=6. But n=6 is not minimal (we have n=3 is minimal). So the decomposition for minimal n is fixed.\n\n        Example: p=4, n=5: \n          Decomposition: one SCC of size 3 (T_3=3) and one SCC of size 2 (T_2=1) -> total p=4, n=5. Sum of squares=9+4=13.\n          Alternatively, we could have four SCCs of size 2: T_2=1, so 4*1=4, but then n=8, which is not minimal.\n\n        So for the minimal n, there might be only one decomposition? Actually, no. Consider p=6:\n\n          Option1: one SCC of size 4: T_4=6, then n=4. Sum of squares=16.\n          Option2: two SCCs of size 3: T_3=3, so two of them: 3+3=6, then n=6. But 6>4, so n=4 is minimal.\n\n          Now, is there another decomposition for n=4? Only one: one SCC of size 4.\n\n        Another example: p=7.\n\n          Option1: one SCC of size 4 (T_4=6) and one SCC of size 2 (T_2=1): total p=7, n=6.\n          Option2: one SCC of size 5: T_5=10 -> too big.\n          Option3: two SCCs: one of size 4 and one of size 2 -> n=6.\n          Option4: three SCCs: one of size 3 (T_3=3) and two of size 2 (T_2=1): 3+1+1=5, not enough.\n          Option5: one SCC of size 3 and one of size 2 and one of size 2: same as above.\n\n          Actually, we can also use one SCC of size 4 and one SCC of size 2: n=6.\n\n          Now, is there another decomposition for n=6? We have one SCC of size 6: T_6=15 -> too big. Two SCCs: we have 4+2=6, or 3+3=6 (but T_3+T_3=3+3=6, which is less than 7). So no.\n\n          But wait: we can also use four SCCs of size 2 and one SCC of size 1? That would be: four T_2's (each 1) and one T_1 (0): total p=4, not 7.\n\n          So for p=7, the minimal n is 6, and the decomposition is fixed: one SCC of size 4 and one of size 2.\n\n        However, consider p=8:\n\n          Option1: one SCC of size 5: T_5=10 -> too big.\n          Option2: one SCC of size 4 (T_4=6) and two SCCs of size 2: 6+1+1=8, then n=4+2+2=8.\n          Option3: two SCCs of size 4: T_4=6, then we need 8-6=2, which is two T_2's? Then n=4+4+2+2=12 -> too big.\n\n          Alternatively, one SCC of size 5 is too big, so we break the 5? Actually, we can use:\n\n          Option4: one SCC of size 5 is not allowed (too big). Then the next is one SCC of size 4 and two SCCs of size 2: n=8.\n\n          Option5: four SCCs of size 3: T_3=3, so 3*4=12 -> too big.\n\n          Option6: one SCC of size 3 and five SCCs of size 2: 3 + 5*1 = 8, then n=3+5*2=13.\n\n          So minimal n is 8.\n\n          Now, is there another decomposition for n=8? \n\n          We have one SCC of size 4 and two of size 2: [4,2,2] -> sum of T_s = 6+1+1=8.\n\n          Or we could have two SCCs of size 3 and one SCC of size 2: 3+3+1=7, not 8.\n\n          Or one SCC of size 3 and two SCCs of size 2 and one SCC of size 1: 3+1+1+0=5, not 8.\n\n          So the decomposition is fixed for minimal n.\n\n        But wait: consider p=0.\n\n          Then we need 0 mutual pairs. The minimal n is 0? But the problem says nodes, and p=0: we can have 0 nodes. Then the graph has 0 nodes, so no pairs. Then n=0.\n\n          Then the unidirectional pairs: 0.\n\n        However, the problem states that the graph has nodes. But note: the problem does not specify that the",
    "response": "\nTo solve this problem, we need to determine the minimum number of nodes required to create a directed graph that is exactly p-reachable, and among all such graphs with the minimum number of nodes, find the maximum number of unidirectional node pairs.\n\n### Approach\n1. **Problem Analysis**:\n   - A directed graph is p-reachable if it contains exactly p ordered pairs (u, v) where u < v and there exists a path from u to v but not necessarily from v to u.\n   - The solution involves decomposing the integer p into sums of triangular numbers (each representing the number of mutual pairs in a strongly connected component (SCC)) while minimizing the total number of nodes (sum of the sizes of these SCCs).\n\n2. **Key Insight**:\n   - The minimal number of nodes is achieved by using as many large SCCs as possible, leveraging the fact that larger SCCs provide more mutual pairs per node.\n   - Once the minimal number of nodes is determined, the maximum number of unidirectional pairs is calculated by considering all possible ordered pairs between different SCCs, which is given by the formula \\((n^2 - \\sum s_i^2) / 2\\), where \\(n\\) is the total number of nodes and \\(s_i\\) are the sizes of the SCCs.\n\n3. **Algorithm Selection**:\n   - **Greedy Decomposition**: To find the minimal number of nodes, decompose p into the largest possible triangular numbers (corresponding to largest SCCs) first.\n   - **Sum of Squares Calculation**: For the same minimal node count, compute the sum of squares of the SCC sizes to maximize the unidirectional pairs using the derived formula.\n\n4. **Complexity Analysis**:\n   - The algorithm efficiently computes the decomposition by iterating through possible SCC sizes up to \\(\\sqrt{2p}\\), making it suitable for large values of p (up to \\(2 \\times 10^5\\)).\n\n### Solution Code\n```python\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    p = int(data[0])\n    \n    if p == 0:\n        print(\"0 0\")\n        return\n        \n    n = 0\n    remaining = p\n    components = []\n    s = 1\n    while remaining > 0:\n        t_val = s * (s - 1) // 2\n        if t_val <= remaining:\n            count = remaining // t_val\n            components.append(count)\n            remaining %= t_val\n            n += count * s\n        s += 1\n        \n    n_min = n\n    \n    sq_sum = 0\n    for count in components:\n        sq_sum += count * (s * s)\n        s -= 1\n        \n    unidirectional_pairs = (n_min * n_min - sq_sum) // 2\n    \n    print(f\"{n_min} {unidirectional_pairs}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input consists of a single integer p, which represents the number of ordered pairs (u, v) where u < v and mutual reachability is required.\n2. **Special Case Handling**: If p is 0, the solution is trivially 0 nodes and 0 unidirectional pairs.\n3. **Greedy Decomposition**: The algorithm iterates over possible SCC sizes (starting from 1) and uses the largest possible triangular numbers to decompose p, accumulating the total nodes required.\n4. **Sum of Squares Calculation**: For the computed SCC sizes, the sum of their squares is calculated to determine the maximum number of unidirectional pairs using the formula \\((n^2 - \\sum s_i^2) / 2\\).\n5. **Output**: The minimal number of nodes and the maximum number of unidirectional pairs are printed.\n\nThis approach efficiently addresses the problem by leveraging mathematical insights and greedy decomposition to ensure optimal performance even for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    p = int(data[0])\n    \n    if p == 0:\n        print(\"0 0\")\n        return\n        \n    n = 0\n    remaining = p\n    components = []\n    s = 1\n    while remaining > 0:\n        t_val = s * (s - 1) // 2\n        if t_val <= remaining:\n            count = remaining // t_val\n            components.append(count)\n            remaining %= t_val\n            n += count * s\n        s += 1\n        \n    n_min = n\n    \n    sq_sum = 0\n    for count in components:\n        sq_sum += count * (s * s)\n        s -= 1\n        \n    unidirectional_pairs = (n_min * n_min - sq_sum) // 2\n    \n    print(f\"{n_min} {unidirectional_pairs}\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 474,
        "completion_token_count": 838,
        "thoughts_token_count": 8191
    }
}