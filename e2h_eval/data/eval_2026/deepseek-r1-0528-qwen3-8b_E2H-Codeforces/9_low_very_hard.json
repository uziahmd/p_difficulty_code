{
    "start": 1758092345.737585,
    "end": 1758094060.7204792,
    "start-formatted": "2025-09-17 15:59 KST",
    "end-formatted": "2025-09-17 16:27 KST",
    "gpu": 2,
    "pid": 9,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Selling Souvenirs\n\nAfter several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.This morning, as usual, Petya will come to the market. Petya has n different souvenirs to sell; ith souvenir is characterised by its weight wi and cost ci. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than m, and total cost is maximum possible.Help Petya to determine maximum possible total cost.\n\n## Input\nThe first line contains two integers n and m (1 ≤ n ≤ 100000, 1 ≤ m ≤ 300000) — the number of Petya's souvenirs and total weight that he can carry to the market.Then n lines follow. ith line contains two integers wi and ci (1 ≤ wi ≤ 3, 1 ≤ ci ≤ 109) — the weight and the cost of ith souvenir.\n\n## Output\nPrint one number — maximum possible total cost of souvenirs that Petya can carry to the market.\n\n## Example\n### Input\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\n### Output\n['0', '3', '10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\n We are given up to 100000 souvenirs, each with weight in {1,2,3} and cost up to 10^9.\n Since the weights are only 1, 2, or 3, we can group the souvenirs by their weight.\n\n Let:\n   type1 = list of costs for souvenirs with weight 1\n   type2 = list of costs for souvenirs with weight 2\n   type3 = list of costs for souvenirs with weight 3\n\n Then, we need to choose a non-negative integer a (number of type1 items), b (type2) and c (type3) such that:\n   a*1 + b*2 + c*3 <= m\n\n And we want to maximize the total cost: \n   total_cost = (sum of a largest 'a' items from type1) + (sum of b largest from type2) + (sum of c largest from type3)\n\n However, note that we cannot use more than the available items in each group.\n\n Steps:\n\n 1. Group the souvenirs by weight (1,2,3). For each group, sort the list of costs in descending order and then compute the prefix sums.\n\n 2. We note that the total weight constraint is m (up to 300000). Since the weights are small (only 1,2,3) and the number of items is large, we need an efficient way.\n\n Observation: The problem is similar to a bounded knapsack problem with three types and small weights (1,2,3). But note that we have many items (n up to 100000) but only three distinct weights.\n\n We can break the problem into two parts:\n\n   a) We are allowed to take at most as many as we have in each group.\n\n   b) The total weight is limited to m.\n\n However, note that the cost can be very large (up to 10^9) so we must use efficient DP or greedy?\n\n Alternatively, we can consider:\n\n   Let x1, x2, x3 be the number of items we take from group1, group2, group3 respectively.\n\n   Then, we require: x1 + 2*x2 + 3*x3 <= m.\n\n   We wish to maximize: \n        S1(x1) + S2(x2) + S3(x3)\n\n where S1(x1) is the sum of the top x1 items in group1, similarly for S2 and S3.\n\n How to iterate? The constraints on x1, x2, x3: x1 <= len(type1), x2 <= len(type2), x3 <= len(type3). But m can be up to 300000, so we cannot iterate over all possibilities.\n\n Alternate approach:\n\n   We can iterate over the number of type3 items (c) from 0 to min(len(type3), m//3). Then, the remaining weight is m - 3*c.\n\n   Then, we have to distribute the remaining weight between type1 and type2. Note that type1 and type2 can be mixed arbitrarily.\n\n   Now, we have a two-variable problem: we need to choose non-negative integers a and b such that:\n        a + 2*b <= R   (where R = m - 3*c)\n        and we want to maximize: prefix1[a] + prefix2[b]\n\n   But note: we can also think of it as: we have two independent groups (with weights 1 and 2) and we can choose any combination (a,b) as long as a+2*b <= R.\n\n   However, the catch: we have two separate sorted arrays and we want to combine them optimally.\n\n   We can precompute:\n\n        prefix1[i] = sum of top i items from type1 (for i from 0 to len(type1))\n        prefix2[j] = sum of top j items from type2 (for j from 0 to len(type2))\n\n   Then, for a fixed c, we need to find the maximum value of prefix1[a] + prefix2[b] for all a,b >=0 such that a+2*b <= R.\n\n   We can try to fix b (from 0 to min(len(type2), R//2)), then a can be at most R - 2*b, and we take the maximum prefix1[a] for a from 0 to min(len(type1), R-2*b).\n\n   But note: R can be up to 300000, and we cannot iterate over b from 0 to R//2 (which is 150000) and for each b do a scan of prefix1 (which is 100000) because that would be 150000 * 1",
    "response": "\nTo solve this problem, we need to maximize the total cost of souvenirs that Petya can carry to the market without exceeding the weight limit. The souvenirs are categorized by their weights (1, 2, or 3), and each category has a list of costs. The challenge is to select a combination of items from these categories such that their total weight is within the given limit and their total cost is maximized.\n\n### Approach\n1. **Grouping and Sorting**: First, we group the souvenirs by their weights (1, 2, or 3). For each group, we sort the items in descending order of their costs. This allows us to easily access the most valuable items first.\n2. **Prefix Sums**: We compute prefix sums for each group. This means for each group, we create an array where each element at index `i` represents the sum of the top `i` most valuable items in that group. This helps in quickly calculating the total cost of selecting any number of items from a group.\n3. **Iterate Over Possible Items**: We iterate over the possible number of items from the heaviest group (weight 3) that can be included without exceeding the weight limit. For each such count, we calculate the remaining weight available for the lighter items (weights 1 and 2).\n4. **Maximize Combined Cost**: For the remaining weight, we determine the optimal combination of items from the weight 1 and weight 2 groups. This involves checking all feasible combinations where the total weight does not exceed the remaining limit and keeping track of the maximum total cost encountered.\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(0)\n        return\n        \n    n = int(data[0])\n    m = int(data[1])\n    index = 2\n    \n    type1 = []\n    type2 = []\n    type3 = []\n    \n    for i in range(n):\n        w = int(data[index])\n        c = int(data[index+1])\n        index += 2\n        if w == 1:\n            type1.append(c)\n        elif w == 2:\n            type2.append(c)\n        elif w == 3:\n            type3.append(c)\n            \n    type1.sort(reverse=True)\n    type2.sort(reverse=True)\n    type3.sort(reverse=True)\n    \n    len1 = len(type1)\n    len2 = len(type2)\n    len3 = len(type3)\n    \n    prefix1 = [0]*(len1+1)\n    for i in range(1, len1+1):\n        prefix1[i] = prefix1[i-1] + type1[i-1]\n        \n    prefix2 = [0]*(len2+1)\n    for i in range(1, len2+1):\n        prefix2[i] = prefix2[i-1] + type2[i-1]\n        \n    prefix3 = [0]*(len3+1)\n    for i in range(1, len3+1):\n        prefix3[i] = prefix3[i-1] + type3[i-1]\n        \n    best = 0\n    max_c = min(len3, m//3)\n    for c in range(0, max_c+1):\n        remaining_weight = m - 3*c\n        if remaining_weight < 0:\n            continue\n            \n        current_cost = prefix3[c]\n        if current_cost < best:\n            continue\n            \n        R = remaining_weight\n        max_b = min(len2, R//2)\n        for b in range(0, max_b+1):\n            remaining_after_b = R - 2*b\n            a = min(len1, remaining_after_b)\n            total_cost = current_cost + prefix2[b] + prefix1[a]\n            if total_cost > best:\n                best = total_cost\n                \n    print(best)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Input Handling**: The input is read and parsed into the number of souvenirs `n` and the maximum allowed weight `m`. Each souvenir's weight and cost are then categorized into one of three lists based on their weight.\n2. **Sorting and Prefix Sums**: Each list of costs is sorted in descending order to prioritize higher-cost items. Prefix sums are computed for each list to quickly access the cumulative cost of selecting the top `k` items.\n3. **Iterating Over Weight 3 Items**: The outer loop iterates over the possible number of weight 3 items (`c`) that can be included. For each `c`, the remaining weight is calculated.\n4. **Combining Lighter Items**: For each `c`, the inner loop checks all possible counts of weight 2 items (`b`). The remaining weight after including `b` weight 2 items is used to determine the maximum number of weight 1 items (`a`) that can be included. The total cost for each valid combination is compared to the current maximum, updating the maximum if a higher cost is found.\n5. **Output**: The highest total cost encountered during the iterations is printed as the result.\n\nThis approach efficiently narrows down the problem by leveraging the constraints on item weights and using prefix sums for quick cost calculations, ensuring optimal performance even for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(0)\n        return\n        \n    n = int(data[0])\n    m = int(data[1])\n    index = 2\n    \n    type1 = []\n    type2 = []\n    type3 = []\n    \n    for i in range(n):\n        w = int(data[index])\n        c = int(data[index+1])\n        index += 2\n        if w == 1:\n            type1.append(c)\n        elif w == 2:\n            type2.append(c)\n        elif w == 3:\n            type3.append(c)\n            \n    type1.sort(reverse=True)\n    type2.sort(reverse=True)\n    type3.sort(reverse=True)\n    \n    len1 = len(type1)\n    len2 = len(type2)\n    len3 = len(type3)\n    \n    prefix1 = [0]*(len1+1)\n    for i in range(1, len1+1):\n        prefix1[i] = prefix1[i-1] + type1[i-1]\n        \n    prefix2 = [0]*(len2+1)\n    for i in range(1, len2+1):\n        prefix2[i] = prefix2[i-1] + type2[i-1]\n        \n    prefix3 = [0]*(len3+1)\n    for i in range(1, len3+1):\n        prefix3[i] = prefix3[i-1] + type3[i-1]\n        \n    best = 0\n    max_c = min(len3, m//3)\n    for c in range(0, max_c+1):\n        remaining_weight = m - 3*c\n        if remaining_weight < 0:\n            continue\n            \n        current_cost = prefix3[c]\n        if current_cost < best:\n            continue\n            \n        R = remaining_weight\n        max_b = min(len2, R//2)\n        for b in range(0, max_b+1):\n            remaining_after_b = R - 2*b\n            a = min(len1, remaining_after_b)\n            total_cost = current_cost + prefix2[b] + prefix1[a]\n            if total_cost > best:\n                best = total_cost\n                \n    print(best)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 477,
        "completion_token_count": 1107,
        "thoughts_token_count": 1023
    }
}