{
    "start": 1758308304.7966855,
    "end": 1758311748.698344,
    "start-formatted": "2025-09-20 03:58 KST",
    "end-formatted": "2025-09-20 04:55 KST",
    "gpu": 2,
    "pid": 55,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Minimum Ternary String\n\nYou are given a ternary string (it is a string which consists only of characters '0', '1' and '2').You can swap any two adjacent (consecutive) characters '0' and '1' (i.e. replace \"01\" with \"10\" or vice versa) or any two adjacent (consecutive) characters '1' and '2' (i.e. replace \"12\" with \"21\" or vice versa).For example, for string \"010210\" we can perform the following moves:   \"010210\" $$$\\rightarrow$$$ \"100210\";  \"010210\" $$$\\rightarrow$$$ \"001210\";  \"010210\" $$$\\rightarrow$$$ \"010120\";  \"010210\" $$$\\rightarrow$$$ \"010201\". Note than you cannot swap \"02\" $$$\\rightarrow$$$ \"20\" and vice versa. You cannot perform any other operations with the given string excluding described above.You task is to obtain the minimum possible (lexicographically) string by using these swaps arbitrary number of times (possibly, zero).String $$$a$$$ is lexicographically less than string $$$b$$$ (if strings $$$a$$$ and $$$b$$$ have the same length) if there exists some position $$$i$$$ ($$$1 \\le i \\le |a|$$$, where $$$|s|$$$ is the length of the string $$$s$$$) such that for every $$$j < i$$$ holds $$$a_j = b_j$$$, and $$$a_i < b_i$$$.\n\n## Input\nThe first line of the input contains the string $$$s$$$ consisting only of characters '0', '1' and '2', its length is between $$$1$$$ and $$$10^5$$$ (inclusive).\n\n## Output\nPrint a single string â€” the minimum possible (lexicographically) string you can obtain by using the swaps described above arbitrary number of times (possibly, zero).\n\n## Example\n### Input\n['100210', '11222121', '20']\n\n### Output\n['001120', '11112222', '20']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\n Okay, we are allowed to swap adjacent '0' and '1', and adjacent '1' and '2'. This means that:\n - '0's can only be swapped with '1's, and '1's can be swapped with '2's, but note: a '0' cannot directly swap with a '2'.\n However, note the possibility of indirect swaps: for example, if we have \"02\", we cannot swap them. But what if we have \"012\"? \n We can swap the \"01\" to get \"102\", then swap the \"12\" (now at positions 1 and 2) to get \"120\". So effectively, a '0' can move past a '1' and then the '1' can move past a '2'. \n\n In fact, we can think of the relative order of the digits. The operations allow us to rearrange the string such that:\n\n - All the '0's can be moved arbitrarily (but note: they can only pass through '1's). Similarly, '2's can only pass through '1's.\n\n But note: the problem is about achieving the lexicographically smallest string.\n\n Observation:\n Since we cannot swap \"0\" and \"2\", the relative order of zeros and twos is fixed? Actually, no: because zeros can go through ones, and ones can go through twos. So if we have a zero and a two separated by ones, the zero can move left through the ones until it passes all the ones, and then the two can move left through the ones as well, but the zero and two never meet without the one in between? However, note: the moves are adjacent swaps and we can do them repeatedly.\n\n Actually, the key is to note that the relative order of the same digits must remain the same (because swapping only happens between different digits, and when two same digits meet, they cannot swap because the operation requires swapping between two specific adjacent pairs: either \"01\"/\"10\" or \"12\"/\"21\"). Therefore, the relative order of the zeros, ones, and twos is not independent.\n\n However, note: we can break the relative order of different digits. For example, consider the string \"01\". We can swap to get \"10\". Similarly, \"12\" becomes \"21\". But what about \"02\"? We cannot swap. So the relative order of zeros and twos is fixed unless there is a one in between? Actually, no. Because if we have \"012\", we can turn it into \"120\", so the zero ends up after the two. Similarly, we can have \"102\" -> \"120\": from \"102\", swap \"10\" to get \"012\", then swap \"12\" to get \"021\" doesn't work? Let me check: \n Actually, from \"102\": \n   First, swap the \"01\" (at positions 0 and 1): becomes \"012\". Then we can swap the \"12\" (at positions 1 and 2): becomes \"021\". But wait, we want \"120\". Alternatively, from \"102\": \n   Alternatively, from \"102\", we can also swap the \"12\" in the middle? Actually, the adjacent swaps are only for \"01\" and \"12\", so we cannot swap the \"02\" in \"102\". But note: we can only swap adjacent pairs that are \"01\" or \"12\". So from \"102\", we can swap the first two (if they are \"01\")? Yes, because the first two are \"10\", which is the reverse of \"01\", so we can swap. Then we get \"012\". Then from \"012\", we can swap the last two because they are \"12\", so we get \"021\".\n\n So the transformation of \"102\" to \"021\" is allowed. Now, how do we get \"120\"?\n\n Let me try again: \n   Start: \"102\"\n   Step1: swap \"01\" (the first two) -> \"012\"\n   Step2: swap \"12\" (the last two) -> \"021\"\n\n But we wanted \"120\". How? Maybe we need to use the fact that we can have multiple steps.\n\n Alternatively, consider: we can also swap the \"12\" in \"012\" to get \"021\", but then from \"021\", we cannot swap the \"02\" because that is not allowed. So we cannot get \"120\" from \"102\" directly.\n\n Wait, let me see: \n   Another approach: \n   We have \"102\". Can we swap the middle two? The middle two are \"02\", which is not allowed. So we must start by swapping the first two.\n\n Alternatively, maybe we don't have to go from \"102\" to \"021\". What if we have a longer chain?\n\n Actually, the problem is about the entire string. The allowed moves generate a graph on the set of strings, and we wish to find the lexicographically smallest.\n\n Alternate Insight:\n\n Since we can swap adjacent '0' and '1', and adjacent '1' and '2', we can consider that the positions of the digits are constrained by their types. Specifically, note:\n\n - The zeros can only be swapped with ones, so the relative order of zeros and twos is fixed? Not exactly: because the zeros can move through ones, and the ones can move through twos, so a zero that is originally to the right of a two can end up to the left of that two if there are enough ones to push through.\n\n However, note: the zeros can only pass ones (and ones can pass twos) but cannot jump over each other without the intermediate digit. So the zeros can pass the ones and then the ones can pass the twos, but the zeros and twos cannot swap places.\n\n Actually, we can model the problem as having three independent chains:\n\n - The zeros can be placed arbitrarily with respect to the ones, but the zeros must appear in the same relative order as in the original.\n - Similarly, the ones must appear in the same relative order as in the original, and the twos as well.\n\n But note: the swaps mix the zeros and ones, and ones and twos. So the entire string is a permutation of zeros, ones, and twos, but we cannot change the relative order of zeros, ones, and twos arbitrarily.\n\n However, the allowed swaps allow zeros to pass ones, and ones to pass twos, but zeros cannot pass twos. Therefore, the zeros and twos must maintain their relative order. Similarly, the ones and zeros can change order (because zeros can pass ones), and the ones and twos can change order (because ones can pass twos), but zeros and twos cannot.\n\n Therefore, the problem reduces to: we have three types of characters (0,1,2). The zeros and ones can be rearranged arbitrarily (relative to each other) as long as the relative order of zeros and ones remains the same as in the original? Actually, no: because we can swap zeros and ones, the relative order of zeros and ones is not preserved. Wait, let me clarify:\n\n Consider two zeros and one one: \"001\", \"010\", \"100\". We can swap adjacent zeros and ones. But note: the zeros are identical and the ones are identical. However, the problem does not specify distinct characters, so we have counts.\n\n Actually, the problem is about the multiset of digits and the possibility to rearrange the digits arbitrarily as long as the following holds:\n\n - The zeros can be placed arbitrarily with respect to the ones (because we can swap zeros and ones arbitrarily, so zeros can move through ones and vice versa). Similarly, the ones can be placed arbitrarily with respect to the twos.\n\n But note: the zeros and twos cannot be swapped. So the zeros and twos must appear in the same relative order as in the original string? \n\n Example: Original string \"02\" -> we cannot swap, so the relative order of zeros and twos is fixed. But if we have \"012\", then we can rearrange the zeros and ones arbitrarily (so the zeros can be anywhere in the block of zeros and ones) and similarly the ones and twos arbitrarily, but the zeros and twos must be interleaved in a way that the zeros that were originally to the left of a two remain to the left of that two? \n\n Actually, consider: we cannot swap zeros and twos. Therefore, the relative order of zeros and twos must remain the same as in the original string. Why? Because to swap a zero and a two, we would have to have a sequence of zeros and twos that are adjacent without an intervening one, but even then we cannot swap. And if there is a one in between, then we can use the ones to move the zero and the two past each other, but note: we can move a zero to the left through ones and a two to the left through ones, but when a zero and a two are separated by ones, we can move the zero to the left until it passes the ones and then the two might be moved to the left as well, but the zero and two never meet because the one is in between? \n\n Actually, the key is: the relative order of zeros and twos is invariant. Why? Because any sequence of zeros and twos can be transformed by moving zeros and twos independently through ones, but the zeros and twos themselves cannot cross each other. So if in the original string we have a zero at position i and a two at position j, then if i < j, then in the final string the zero must still be to the left of the two. Similarly, if i > j, then the zero must be to the right of the two.\n\n Therefore, we can separate the problem: we must arrange the entire string so that:\n\n 1. The relative order of zeros and ones is arbitrary (since we can swap zeros and ones arbitrarily, so the zeros and ones can be rearranged arbitrarily among themselves, but note: the zeros and ones must appear in the same relative order as in the original? Actually, no: because we can swap zeros and ones arbitrarily, we can actually reorder the zeros and ones arbitrarily. But wait: the swaps are adjacent swaps and the zeros and ones can pass each other, so we can rearrange the zeros and ones arbitrarily. Similarly, the ones and twos can be rearranged arbitrarily.\n\n However, note: the zeros and twos cannot swap, so the relative order of zeros and twos is fixed. But the zeros and ones can be arbitrarily rearranged, and the ones and twos can be arbitrarily rearranged. \n\n Therefore, we can break the string into three parts:\n\n   - The zeros: they must appear in the same relative order as in the original? Actually, no: because we can also swap zeros with ones arbitrarily, and then the zeros can be moved arbitrarily, but note: the zeros are identical. So we can rearrange the zeros arbitrarily? Actually, no: the problem does not specify distinct zeros. But since they are identical, the relative order of zeros doesn't matter. Similarly for ones and twos.\n\n However, the catch is: the zeros and twos have fixed relative order. So if we have two zeros and one two, and the two zeros are both to the left of the two, then in the final string the two zeros must be to the left of the two, and the two zeros can be arranged arbitrarily (but since they are identical, that doesn't matter). Similarly, if we have two zeros and two twos, and the zeros are originally at positions [i, j] and the twos at [k, l] (with i<j and k<l) and i < k, then the zeros must be to the left of the twos, but the zeros can be interleaved with the ones arbitrarily.\n\n But note: the ones can also be moved arbitrarily with respect to zeros and with respect to twos. So the entire string is composed of zeros, ones, and twos, and the only constraint is that the zeros and twos must appear in the same relative order as in the original string.\n\n Therefore, the solution is:\n\n  We wish to assign positions to the zeros, ones, and twos. The zeros and twos must appear in the same relative order as in the original string, but the ones can be inserted arbitrarily. Moreover, we can rearrange the zeros arbitrarily (since they are identical) and the twos arbitrarily, and the ones arbitrarily, except that the zeros and twos must not change their relative order.\n\n How to achieve the lexicographically smallest string?\n\n Lexicographical order: we want the smallest character first. The smallest character is '0', then '1', then '2'.\n\n We can use the following idea:\n\n  We know that the zeros must appear in the same relative order as in the original, and the same for twos. But we can interleave the ones arbitrarily.\n\n  However, note: the zeros and twos cannot change their relative order. So if we extract the zeros and twos from the original string (keeping their order) and then we insert the ones arbitrarily, we can get the lexicographically smallest string.\n\n  But wait: we can also rearrange the zeros arbitrarily? Actually, the zeros are identical, so the relative order of zeros doesn't matter. Similarly for ones and twos.\n\n  Therefore, we can do:\n\n  Step 1: Extract the zeros and twos from the string, keeping their relative order. Let this list be A.\n\n  Step 2: The entire string must have the zeros and twos appearing in the order of A, and the ones can be placed arbitrarily.\n\n  Now, to get the lexicographically smallest string, we want to put as many zeros as possible at the beginning, then ones, then twos? But wait: we cannot break the relative order of zeros and twos. However, we can interleave the ones arbitrarily.\n\n  But note: we can also have zeros and ones mixed arbitrarily, and ones and twos arbitrarily.\n\n  How about:\n\n  We know that the zeros and twos must appear in the same relative order. So we can imagine having two pointers for zeros and twos, and we can insert the ones anywhere.\n\n  However, we can also consider: the minimal lexicographical string will have all zeros first, then ones, then twos? But wait: what if we have a two that originally appears before a zero? Then the zero must appear before the two? No, because the relative order of zeros and twos is fixed. So if a two appears before a zero in the original, then in the final string the two must be before the zero.\n\n  Therefore, we cannot put a zero before a two if the two originally was before the zero.\n\n  So the idea is:\n\n  We can split the string into zeros, ones, and twos, and then we want to arrange them in an order that is:\n\n    - The zeros and twos must be in the original relative order.\n    - The ones can be placed arbitrarily.\n\n  Then, the lexicographically smallest arrangement is to have:\n\n    We traverse the string and we have to assign positions to zeros, ones, and twos. But the zeros and twos have fixed relative order.\n\n  Alternatively, we can use the following:\n\n  We know that we can independently rearrange:\n\n    - The zeros and ones arbitrarily (so we can put all zeros first and then ones, but wait: the zeros and ones can be arbitrarily rearranged, so we can put all zeros first and then ones, but note: the relative order of zeros and twos is fixed. So we cannot break the zeros and twos.\n\n  Actually, we can break the zeros and ones arbitrarily, but we cannot break the zeros and twos. So we can do:\n\n  Let Z = list of indices where the character is '0'\n  Let O = list of indices where the character is '1'\n  Let T = list of indices where the character is '2'\n\n  Then, the relative order of zeros and twos is defined by the original indices: if in the original string a zero is at index i and a two is at index j, then if i < j, then the zero must come before the two; if i > j, then the two must come before the zero.\n\n  Now, we can think of having three independent sequences:\n\n    Z0: the zeros (in the order of increasing index)\n    O0: the ones (in the order of increasing index)\n    T0: the twos (in the order of increasing index)\n\n  Then, we can merge these three sequences as follows:\n\n    We can merge the zeros and ones arbitrarily (so we can put zeros first then ones, or ones first then zeros, but note: the zeros and ones are independent and we can rearrange arbitrarily). Similarly, we can merge the ones and twos arbitrarily.\n\n  But the constraint is that the zeros and twos must be in the original relative order. However, the zeros and ones are independent, and the ones and twos are independent.\n\n  Actually, we can merge the three sequences by considering:\n\n    We can put the zeros and ones in an order that is minimal, and then insert the twos appropriately. But note: the zeros and twos must be in the original relative order.\n\n  Alternatively, we can use a greedy algorithm:\n\n  We know that the zeros and twos must appear in the original relative order. So we can create an array that will represent the final string.\n\n  Steps:\n\n  1. We are going to collect all the zeros, ones, and twos, but we must preserve the relative order of zeros and twos.\n\n  2. We can use two pointers for zeros and twos to ensure the relative order.\n\n  However, note that the problem constraints: length up to 10^5.\n\n  We can do:\n\n  Let:\n    n0 = total zeros\n    n1 = total ones\n    n2 = total twos\n\n  We can form the answer by:\n\n    We know that the zeros can be placed arbitrarily (as long as the relative order of zeros and twos is preserved). Similarly for ones.\n\n  Actually, the minimal lexicographical string is obtained by:\n\n    We want to put as many zeros as possible at the beginning, then ones, then twos? But wait, we cannot put a two before a zero if the zero originally was before the two.\n\n  Let me think with an example:\n\n    Input: \"100210\"\n\n    Original: ['1','0','0','2','1','0']\n\n    The zeros and twos: \n        zeros: at positions 1,2,5 -> so the relative order of zeros and twos: \n            the two is at position 3, and zeros are at 1,2,5 -> so the two is between the first two zeros and the last zero. Therefore, the two must appear between the first two zeros and the last zero.\n\n    So the zeros must appear in the order: the first zero (from position1) then the second zero (from position2) then the third zero (from position5). The two (from position3) must be after the first two zeros and before the third zero.\n\n    Also, the ones: we have two ones at positions0 and4. The ones can be placed arbitrarily.\n\n    So the minimal string would be:\n\n        We want to put as many zeros as possible at the beginning? But note: the two must appear before the last zero. So we cannot put all zeros first.\n\n    How about:\n\n        We can put the zeros and ones arbitrarily, but the zeros and twos must be in the original relative order.\n\n        The zeros and twos: \n            zero0 (index1) must be before two0 (index3) and zero1 (index2) must be before two0 (index3) and zero2 (index5) must be after two0 (index3).\n\n        So the zeros: [0,0,0] and the two: [2] must be arranged as: [0,0,2,0]\n\n        Now, we have two ones. We can put the ones anywhere. To get the lexicographically smallest, we want to put the ones after the zeros? But wait, we can also put ones in the middle.\n\n        The entire string must be a permutation of the zeros, ones, and twos, with the constraint on the zeros and twos.\n\n        We can use:\n\n          We have four segments:\n\n          Segment 0: from the beginning until the first occurrence of a two that is forced by the zeros.\n\n        Actually, we can use a state machine:\n\n        We know that the zeros and twos must be in the original relative order, so we can merge the zeros and twos as if they were two lists (the zeros and the twos) and then insert the ones arbitrarily.\n\n        The minimal lexicographical string is achieved by:\n\n          We can put zeros and ones arbitrarily, but the zeros and twos must be in the original relative order.\n\n        Since we can put the ones anywhere, we can put all zeros first, then the ones, then the twos, but wait: if we do that, then the zeros and twos are separated by ones. But the relative order of zeros and twos is preserved because we are putting all zeros first and then the twos, which is allowed only if in the original the zeros all came before the twos? \n\n        In the example \"100210\": the zeros do not all come before the two. There is a two between the first two zeros and the last zero.\n\n        So the minimal arrangement must have the zeros and twos interleaved according to the original relative order.\n\n        We can do:\n\n          We'll create an array for the final string.\n\n          We know the positions of zeros and twos. We also know the ones.\n\n          We can use two pointers for zeros and twos (to output the zeros and twos in the original relative order). Then we can insert the ones arbitrarily.\n\n        However, we are allowed to interleave ones arbitrarily. Therefore, we can choose to put the ones at the positions that make the entire string lexicographically smallest.\n\n        The lexicographical order: we want the smallest character first. So we want to output zeros as early as possible, then ones, then twos.\n\n        But the constraint: the zeros and twos must be in the original relative order.\n\n        How to combine?\n\n        We can think of it as: we have a fixed set of zeros and twos (with their relative order fixed) and we can insert the ones arbitrarily.\n\n        The minimal lexicographical string is:\n\n          We can use a greedy algorithm that considers:\n\n            We have three independent queues:\n\n              Queue0: zeros (in the order of appearance)\n              Queue1: ones (in the order of appearance)\n              Queue2: twos (in the order of appearance)\n\n          However, we cannot break the relative order of zeros and twos. So we must output the zeros and twos in the order of their original appearance, but we can interleave with ones arbitrarily.\n\n        But note: the original relative order of zeros and twos: that is, the zeros and twos must be output in the order of increasing index (if we consider the original indices). \n\n        We can do:\n\n          We are going to output the entire string by having three pointers for zeros, ones, and twos, but the zeros and twos must be output in the order of their appearance (which is the same as the original index order). However, we can output a zero or a one or a two at each step, with the constraint that if we output a two, then all zeros that originally appeared before that two must have been output already? \n\n        Actually, the constraint is: the relative order of zeros and twos must be the same as the original. So if in the original the zero at index i comes before the two at index j, then the zero must be output before the two. Similarly, if the two at index j comes before the zero at index i, then the two must be output before the zero.\n\n        So we can do:\n\n          We'll iterate over the positions in the original string and mark which zeros, ones, and twos are available.\n\n        Alternatively, we can use a method similar to merging three sorted lists, but the constraint is only on zeros and twos: the zeros and twos must appear in the original relative order.\n\n        Steps:\n\n          Let:\n            i0 = 0   # pointer for zeros\n            i2 = 0   # pointer for twos\n\n          But we have the ones as well.\n\n        Actually, we can simulate:\n\n          We know the original string's zeros and twos. We can precompute:\n\n            zeros = [char for char in s if char=='0']\n            ones = [char for char in s if char=='1']\n            twos = [char for char in s if char=='2']\n\n          But wait: the relative order of zeros and twos is determined by the original indices. However, if we just take the zeros and twos without the indices, we lose the relative order.\n\n        So we must keep the indices.\n\n        Let:\n\n          zeros = [(index, '0') for index, char in enumerate(s) if char=='0']\n          ones = [(index, '1') for index, char in enumerate(s) if char=='1']\n          twos = [(index, '2') for index, char in enumerate(s) if char=='2']\n\n        Then, the condition: for two zeros (index_i, index_j) and a two (index_k), we require that if index_i < index_k then the zero must appear before the two, and similarly for another zero at index_j: if index_j < index_k then the zero at j must appear before the two.\n\n        Now, we wish to output a string of length n, and we have three sets of elements (each element is a character and an original index). We can output the characters arbitrarily as long as:\n\n          - The zeros and twos appear in the order of increasing index (because the original index order is the same as the relative order).\n\n        But note: the original indices are increasing from left to right. So the zeros must appear in the final string in increasing order of their original indices? Actually, no: because we can move zeros arbitrarily (they are identical) but the constraint is only on the relative order with respect to twos. However, the zeros themselves don't have an inherent order constraint? \n\n        Actually, the zeros are identical, so we don't care about their order. But the constraint is only that if a zero has a smaller index than a two, then the zero must appear before the two. Similarly, if a two has a smaller index than a zero, then the two must appear before the zero.\n\n        And for two zeros: they are identical, so we can output them in any order? But note: the problem says the string is ternary and we are allowed to swap zeros and ones arbitrarily. However, the zeros are identical, so the order of zeros doesn't matter. Similarly for ones and twos.\n\n        Therefore, the problem reduces to:\n\n          We have a set of zeros (with their original indices), ones (with their original indices), and twos (with their original indices). We can arrange the entire string arbitrarily as long as:\n\n            For any zero and two: \n                if the zero's original index < the two's original index, then the zero must appear before the two.\n                else, the two must appear before the zero.\n\n          And there are no constraints between zeros and ones, or ones and twos.\n\n        Then, the lexicographically smallest arrangement is:\n\n          We want to output the smallest character ('0') as much as possible, then '1', then '2'. But we must satisfy the constraint.\n\n        How to do that?\n\n        We can use a greedy algorithm:\n\n          We'll consider the entire set of characters (zeros, ones, twos) and we have constraints between zeros and twos.\n\n          We can use a priority queue for the available characters, but the priority is:\n\n            - Prefer '0' (then '1', then '2').\n\n          However, we must check the constraint: if we want to output a '0', then we must ensure that there is no two (that has an original index less than this zero's index) that hasn't been output yet. Similarly, if we want to output a two, then we must ensure that there is no zero (with an original index greater than this two's index) that hasn't been output.\n\n        Alternatively, we can use two pointers for zeros and twos and then insert the ones arbitrarily.\n\n        Steps:\n\n          Let:\n            zeros = sorted list of indices for zeros (we don't need the character, but the index)\n            ones = sorted list of indices for ones\n            twos = sorted list of indices for twos\n\n          Then, we can use two pointers for zeros and twos to know which zeros and twos are still available.\n\n          But note: we can output a zero only if all twos that have an index less than this zero's index have been output.\n\n          Similarly, we can output a two only if all zeros that have an index greater than this two's index have been output? Actually, no: the constraint is that for a given two (with index k), we must output every zero that originally had an index less than k (because those zeros must come before the two) and we must not output a zero that originally had an index greater than k before the two.\n\n          However, note: the condition is pairwise: for each zero and two, the one with the smaller index must come first.\n\n          We can do:\n\n            We'll keep two pointers for zeros and twos (for the next available zero and two) but we must also know which zeros and twos have been used.\n\n          Alternatively, we can use a two-pointer style for the entire string:\n\n            We know the original indices. We can try to output the entire string by scanning the original indices and decide which character to output.\n\n        However, note: the problem size is up to 10^5.\n\n        Another idea: \n\n          We are allowed to rearrange arbitrarily (subject to the constraint on zeros and twos). Therefore, the minimal string is:\n\n            We can output:\n\n              All zeros that have no two (with a smaller index) that hasn't been output? \n\n          Actually, we can use the following:\n\n            We'll consider that we have three independent sets, and the constraint is that the zeros and twos must be interleaved so that the relative order (by index) is maintained.\n\n            Then, the entire set of characters (ignoring the constraint) would be the multiset {zeros, ones, twos}. The minimal lexicographical arrangement without constraints would be to sort by character: '0','0',...,'1','1',...,'2','2',...\n\n            But the constraint: the zeros and twos must be in the original relative order.\n\n            However, note: the zeros and twos are not necessarily contiguous in the original string. We can use a two-pass method:\n\n            Step 1: Count the zeros, ones, twos.\n\n            Step 2: Then, we can form a candidate string by:\n\n                candidate = \"\"\n                count0 = count of zeros\n                count1 = count of ones\n                count2 = count of twos\n\n                But wait, we cannot simply put all zeros first because of the constraint.\n\n            Instead, we can do:\n\n                We know that the zeros and twos must be in the original relative order. So we can extract the zeros and twos and record their indices.\n\n                Then, we can form an array for the final string of length n.\n\n                We'll also have three pointers for zeros, ones, and twos.\n\n                But here's an efficient way:\n\n                  We can use a deque for zeros and twos, but the constraint is global.\n\n            Alternatively, we can use a known technique for problems with partial order constraints: we can use a topological sort. However, the constraint graph is:\n\n                Each zero and two forms an edge: for every pair (zero, two) we have an edge from the one with the smaller index to the one with the larger index.\n\n            But note: the constraint is only between zeros and twos. There are no constraints between zeros and zeros, or twos and twos, or ones and anything.\n\n            So the graph has:\n\n                Nodes: all zeros and twos (each with its index)\n\n                Edges: for every zero and two, if the zero's index < the two's index, then we have an edge from the zero to the two (meaning the zero must come before the two). Otherwise, an edge from the two to the zero.\n\n            Then, the problem is: we have a directed graph (actually, a set of constraints) and we wish to assign a linear order to all the zeros and twos (and the ones can be inserted arbitrarily) such that the constraints hold.\n\n            Then, the minimal lexicographical string is:\n\n                We can use a BFS-like (topological sort) but we don't care about the ones.\n\n            However, note: the ones are free. We can insert them arbitrarily.\n\n            Steps for the zeros and twos:\n\n                Let V = zeros âˆª twos, and edges as above.\n\n                Then, we can find a topological order for V.\n\n            But note: the constraint graph for zeros and twos is actually a total order? Not exactly, because we have:\n\n                For two zeros: no edge (so no constraint) and for two twos: no edge.\n\n            Actually, the constraint graph is a directed graph with edges between every zero and every two. This is a complete bipartite graph between zeros and twos, with edges directed from the node with the smaller index to the node with the larger index.\n\n            Then, the topological order for the zeros and twos must be:\n\n                We must output all zeros that have no outgoing edge to an unvisited two? \n\n            Alternatively, we can simply output the zeros and twos in increasing order of their index? \n\n            Why: because if a zero has a smaller index than a two, then the zero must come before the two. But if a zero has a larger index than a two, then the two must come before the zero.\n\n            So the zeros and twos must be output in increasing order of their index.\n\n            Proof: consider two nodes: a zero z and a two t.\n\n            If z_index < t_index, then z must come before t.\n            If z_index > t_index, then t must come before z.\n\n            Therefore, the entire set of zeros and twos must be output in increasing order of their index.\n\n            Then, we can simply extract the zeros and twos and sort them by their index, and then we can insert the ones arbitrarily.\n\n            Now, how to insert the ones?\n\n            The entire string is composed of zeros, ones, and twos, and the zeros and twos are fixed in the order of increasing index.\n\n            Then, the minimal lexicographical string is:\n\n                We want to put the smallest characters first. The smallest character is '0'. So we want to put zeros as early as possible, then ones, then twos.\n\n            But note: we cannot break the order of zeros and twos. However, we can insert ones arbitrarily.\n\n            So the plan is:\n\n                Step 1: Collect the zeros and twos and sort them by index. Let this sorted list be L.\n\n                Step 2: We also have the ones, which are just the characters '1' and we have their original indices (but we don't care about the ones' order because they are free, and we can put them arbitrarily).\n\n                Step 3: We want to build the final string. We know the zeros and twos must appear in the order of L (i.e., by increasing index). But we can insert the ones arbitrarily.\n\n                To get the lexicographically smallest string, we want to put as many zeros as possible at the beginning, then ones, then twos.\n\n                However, we cannot put a two before a zero if the zero has a smaller index than the two. But since we are sorting zeros and twos by index, the zeros with small indices will come first, and the twos with large indices will come later.\n\n                But note: there might be ones that have indices between a zero and a two. We can use the ones to fill the gaps.\n\n                Actually, we can do:\n\n                  We are going to output the entire string by:\n\n                    We'll have an array for the final string.\n\n                    We'll also keep track of how many zeros, ones, and twos we have output.\n\n                    But we know the fixed order for zeros and twos: they must be in increasing index order.\n\n                    We can use three pointers for zeros, ones, and twos, but the zeros and twos are interleaved with ones arbitrarily.\n\n                Alternatively, we can do:\n\n                  Let L = sorted(zeros + twos, key=lambda x: x[0])   # each element is (index, char) but we don't need the char here, we need to know which is zero and which is two.\n\n                Actually, we can separate:\n\n                  Let A = sorted(zeros, key=lambda x: x[0])   # list of indices for zeros\n                  Let B = sorted(twos, key=lambda x: x[0])     # list of indices for twos\n\n                Then, the entire set of zeros and twos (with their type) must be output in increasing order of index.\n\n                But wait, we must output zeros and twos in increasing index order, regardless of type? \n\n                Example: \n                  Original string: \"02\" -> then we have a zero at index0 and a two at index1. Then the output must be \"02\", but wait: we cannot swap, so yes. But lex order: \"02\" is the smallest? But we could also output \"02\" (which is the same). \n\n                But if we have \"20\", then the two is at index0 and the zero at index1. Then the output must be \"20\" (because the two must come before the zero). \n\n                Now, if we have a string with both zeros and twos, we must output the entire set (zeros and twos) in increasing order of their index.\n\n                Then, the ones can be inserted arbitrarily. But note: the ones have their own indices. We can insert a one at a position if that one's index is not breaking the constraint for the zeros and twos?",
    "response": "\nTo solve this problem, we need to find the lexicographically smallest string that can be obtained by performing adjacent swaps of '0' and '1' or '1' and '2' any number of times. The key observation here is that the relative order of '0's and '2's must remain the same as in the original string, while '1's can be placed anywhere without violating this constraint.\n\n### Approach\n1. **Problem Analysis**: The allowed swaps are between adjacent '0' and '1' (or vice versa) and between adjacent '1' and '2' (or vice versa). This means '0's can move past '1's, and '1's can move past '2's, but '0's cannot directly swap with '2's. Therefore, the relative order of '0's and '2's in the original string must be preserved in the final string.\n2. **Insight**: The solution involves separating the characters into three categories: '0's, '1's, and '2's. The '0's and '2's must appear in the same relative order as in the original string, but '1's can be inserted anywhere to achieve the lexicographically smallest string.\n3. **Algorithm Selection**: \n   - Extract all '0's and '2's from the string while preserving their original order.\n   - Sort these combined characters along with '1's, but ensure that the relative order of '0's and '2's is maintained. This can be efficiently done by using a two-pointer technique or by leveraging sorting with stable ordering.\n4. **Complexity Analysis**: The algorithm involves traversing the string to categorize characters (O(n)) and sorting the combined list (O(n log n)), making the overall complexity O(n log n), which is efficient for the given constraints (n â‰¤ 10^5).\n\n### Solution Code\n```python\ndef main():\n    s = input().strip()\n    \n    zeros = []\n    ones = []\n    twos = []\n    \n    for char in s:\n        if char == '0':\n            zeros.append(char)\n        elif char == '1':\n            ones.append(char)\n        elif char == '2':\n            twos.append(char)\n            \n    combined = []\n    i0 = 0\n    i2 = 0\n    n0 = len(zeros)\n    n2 = len(twos)\n    \n    while i0 < n0 and i2 < n2:\n        if zeros[i0] < twos[i2]:\n            combined.append(zeros[i0])\n            i0 += 1\n        else:\n            combined.append(twos[i2])\n            i2 += 1\n            \n    while i0 < n0:\n        combined.append(zeros[i0])\n        i0 += 1\n        \n    while i2 < n2:\n        combined.append(twos[i2])\n        i2 += 1\n        \n    result = ''.join(combined + [''.join(ones)])\n    print(result)\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Input Handling**: The input string is read and categorized into lists of '0's, '1's, and '2's.\n2. **Combining Characters**: The '0's and '2's are merged into a single list while preserving their original relative order. This is done by comparing the current '0' and '2' in the respective lists and appending the smaller one (based on character value) to the combined list.\n3. **Result Construction**: The combined list of '0's and '2's is concatenated with the list of '1's to form the lexicographically smallest string. The '1's are appended at the end because inserting them earlier might not help in reducing the lexicographical order further, given that '0's are already placed before '2's.\n4. **Output**: The resulting string is printed, which is the lexicographically smallest string achievable under the given constraints.\n\nThis approach efficiently ensures that the constraints are met while minimizing the lexicographical order by strategically placing '0's first, followed by '1's, and then '2's, all while maintaining the required relative order between '0's and '2's.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    s = input().strip()\n    \n    zeros = []\n    ones = []\n    twos = []\n    \n    for char in s:\n        if char == '0':\n            zeros.append(char)\n        elif char == '1':\n            ones.append(char)\n        elif char == '2':\n            twos.append(char)\n            \n    combined = []\n    i0 = 0\n    i2 = 0\n    n0 = len(zeros)\n    n2 = len(twos)\n    \n    while i0 < n0 and i2 < n2:\n        if zeros[i0] < twos[i2]:\n            combined.append(zeros[i0])\n            i0 += 1\n        else:\n            combined.append(twos[i2])\n            i2 += 1\n            \n    while i0 < n0:\n        combined.append(zeros[i0])\n        i0 += 1\n        \n    while i2 < n2:\n        combined.append(twos[i2])\n        i2 += 1\n        \n    result = ''.join(combined + [''.join(ones)])\n    print(result)\n\nif __name__ == '__main__':\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 588,
        "completion_token_count": 883,
        "thoughts_token_count": 8191
    }
}