{
    "start": 1758303235.1007903,
    "end": 1758306958.8483968,
    "start-formatted": "2025-09-20 02:33 KST",
    "end-formatted": "2025-09-20 03:35 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\n Okay, we are given a graph with n nodes and m edges. For each edge (u, v), we are given two numbers: gcd and lcm.\n We know that for two numbers a and b (the mushrooms on the two lawns), we have:\n   gcd(a, b) = g, lcm(a, b) = l.\n And the relationship: a * b = g^2 * (l // g)   [Wait, actually: a*b = g * l * g? Let me recall: \n   Actually, we know that: g = gcd(a,b), then we can write a = g * a', b = g * b', and then gcd(a',b')=1.\n   Then, lcm(a,b) = g * a' * b'. Therefore, a * b = g^2 * a' * b' = g^2 * (lcm(a,b) // g) = g * lcm(a,b).\n\n But note: Also, the condition must hold: g divides both a and b, and the LCM must be divisible by g.\n\n Steps:\n\n 1. For an edge (u, v, g, l):\n      - Check that g divides l. Because if g is the gcd and l the lcm, then we must have g divides l (since g divides both numbers, and the lcm is a multiple of the gcd). If not, then it's impossible -> output \"NO\".\n\n 2. Moreover, from the equation: a * b = g * l. So the product of the two numbers must be g*l.\n\n 3. However, we don't know the individual numbers. We have to assign numbers to each node such that for every edge (u, v) with gcd g and lcm l, the conditions hold.\n\n 4. Also note: The number at a node must be consistent across all edges incident to it.\n\n How to approach?\n\n Idea: Use the fact that the entire graph must satisfy the constraints. We can try to set:\n\n   For each node i, let x_i be the number of mushrooms.\n\n   Then for an edge (u, v): \n        gcd(x_u, x_v) = g, and lcm(x_u, x_v) = l.\n\n   Conditions for an edge (g, l):\n        Condition 1: g divides both x_u and x_v.\n        Condition 2: x_u * x_v = g * l.\n        Condition 3: The gcd of x_u and x_v is g, and the lcm is l.\n\n   Alternatively, we can factorize the numbers. However, note that the numbers can be up to 10^6 and n, m up to 10^6 (as per constraints, but note: the input says n, m and then m lines, and the numbers in the edges are between 1 and 10^6).\n\n   But note: the problem constraints say that n and m can be up to 10^6? Actually, the problem statement says: \"It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106\" — meaning the gcd and lcm are in [1,10^6]. And the graph has n lawns and m roads.\n\n   However, the example inputs are small. But the constraints might be large.\n\n   Alternative idea:\n\n   Since we have the product and the gcd, we can set for each node i, let x_i = g_i * k_i, where g_i is the gcd of the node with all its neighbors? Not exactly.\n\n   Another known fact: \n        For two numbers a and b, we have:\n            a = gcd(a,b) * (some divisor of (a//gcd(a,b))) but more importantly, we can express a and b as:\n\n        Let d = gcd(a,b). Then a = d * a', b = d * b', and gcd(a',b')=1.\n\n        Then, lcm(a,b) = d * a' * b' = d * (a*b)//d^2 = (a*b)/d.\n\n        So, a * b = d * (lcm(a,b)).\n\n   Now, consider the entire graph. We can use the following:\n\n        Let's define for each node i, a variable base_i which is the gcd of the node i with some reference? \n\n   But note: we have multiple edges.\n\n   Steps:\n\n   a. First, check for each edge: does g divide l? If not, return \"NO\".\n\n   b. Then, for each edge, we know that the product of the two numbers must be g*l.\n\n   c. We can use a union-find or DFS to assign numbers to nodes.\n\n   However, the problem is that the same node must have one fixed number.\n\n   Alternate Insight:\n\n        Consider: Let x_i be the number for node i.\n\n        Then, for an edge",
    "response": "\nTo solve this problem, we need to determine if it's possible to restore the number of mushrooms on each lawn (vertex) in a graph based on given roads (edges), where each edge provides the greatest common divisor (GCD) and least common multiple (LCM) of the mushroom counts on the connected lawns. The solution involves verifying the consistency of the given GCD and LCM values across all edges and then assigning appropriate mushroom counts to each node.\n\n### Approach\n1. **Initial Checks**: For each edge, verify that the GCD divides the LCM. If not, the arrangement is impossible.\n2. **Graph Construction**: Build an adjacency list for the graph where each node stores connected edges along with their GCD and LCM values.\n3. **Prime Factorization**: Factorize the product of the GCD and LCM for each edge to derive potential candidate numbers for the nodes. This helps in ensuring that the derived numbers meet the GCD and LCM constraints.\n4. **DFS/BFS for Assignment**: Use a depth-first search (DFS) or breadth-first search (BFS) to propagate the assigned values through the graph. For each node, the value must be consistent with all its connected edges' GCD and LCM constraints.\n5. **Validation**: After assigning values, validate all edges to ensure they meet the given GCD and LCM conditions. If any edge fails, the arrangement is impossible.\n\n### Solution Code\n```python\nimport sys\nfrom collections import defaultdict, deque\n\nsys.setrecursionlimit(1000000)\n\ndef factorize(x):\n    factors = {}\n    d = 2\n    while d * d <= x:\n        while x % d == 0:\n            factors[d] = factors.get(d, 0) + 1\n            x //= d\n        d += 1\n    if x > 1:\n        factors[x] = factors.get(x, 0) + 1\n    return factors\n\ndef merge_factors(factors_list):\n    merged = defaultdict(int)\n    for d in factors_list[0].keys():\n        merged[d] = max([factors_list[i].get(d, 0) for i in range(len(factors_list))])\n    return merged\n\ndef lcm_from_gcd(g, l):\n    if l % g != 0:\n        return None\n    total_product = g * l\n    return total_product\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"NO\")\n        return\n        \n    n = int(data[0]); m = int(data[1])\n    edges = []\n    index = 2\n    graph = [[] for _ in range(n+1)]\n    for i in range(m):\n        u = int(data[index]); v = int(data[index+1]); g_val = int(data[index+2]); l_val = int(data[index+3])\n        index += 4\n        edges.append((u, v, g_val, l_val))\n        graph[u].append((v, g_val, l_val))\n        graph[v].append((u, g_val, l_val))\n\n    for (u, v, g_val, l_val) in edges:\n        if l_val % g_val != 0:\n            print(\"NO\")\n            return\n\n    candidate_ans = [0] * (n+1)\n    candidate_ans[0] = 1\n    for i in range(1, n+1):\n        candidate_ans[i] = 0\n\n    for i in range(1, n+1):\n        if candidate_ans[i] != 0:\n            continue\n        stack = [i]\n        candidate_ans[i] = 1\n        factors_dict = defaultdict(dict)\n        factorized_edges = []\n        for neighbor, g_val, l_val in graph[i]:\n            total_product = g_val * l_val\n            prod_factors = factorize(total_product)\n            factors_dict[neighbor] = prod_factors\n            factorized_edges.append(prod_factors)\n\n        merged_factors = merge_factors(factorized_edges)\n        base = 1\n        for p, exp in merged_factors.items():\n            base *= pow(p, exp)\n\n        candidate_ans[i] = base\n\n        while stack:\n            node = stack.pop()\n            for neighbor, g_val, l_val in graph[node]:\n                if candidate_ans[neighbor] == 0:\n                    total_product = g_val * l_val\n                    prod_factors = factorize(total_product)\n                    factors_dict[neighbor] = prod_factors\n                    factorized_edges.append(prod_factors)\n                    merged_factors = merge_factors([factors_dict[j] for j in graph[node]])\n                    new_base = 1\n                    for p, exp in merged_factors.items():\n                        new_base *= pow(p, exp)\n                    candidate_ans[neighbor] = new_base\n                    stack.append(neighbor)\n\n    valid = True\n    for (u, v, g_val, l_val) in edges:\n        a = candidate_ans[u]\n        b = candidate_ans[v]\n        if a == 0 or b == 0:\n            valid = False\n            break\n        if a % g_val != 0 or b % g_val != 0:\n            valid = False\n            break\n        if a * b != g_val * l_val:\n            valid = False\n            break\n        if gcd(a, b) != g_val or lcm(a, b) != l_val:\n            valid = False\n            break\n\n    if not valid:\n        print(\"NO\")\n        return\n\n    print(\"YES\")\n    print(\" \".join(str(x) for x in candidate_ans[1:]))\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Initial Checks**: The code first checks if the GCD divides the LCM for each edge. If not, it immediately outputs \"NO\".\n2. **Graph Construction**: The graph is built using an adjacency list where each node points to its connected neighbors along with their respective GCD and LCM values.\n3. **Factorization and Merging**: For each node, the product of the GCD and LCM of its edges is factorized. The merged factors from all edges incident to a node are used to determine the candidate value for that node.\n4. **DFS Propagation**: Using DFS, the code propagates the candidate values through the graph, ensuring each node's value is consistent with all connected edges.\n5. **Validation**: After assigning values, the code validates all edges to ensure the assigned values meet the GCD and LCM constraints. If any edge fails, it outputs \"NO\"; otherwise, it outputs \"YES\" followed by the assigned values.\n\nThis approach efficiently checks for the feasibility of the mushroom arrangement and assigns values while adhering to the given constraints.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import defaultdict, deque\n\nsys.setrecursionlimit(1000000)\n\ndef factorize(x):\n    factors = {}\n    d = 2\n    while d * d <= x:\n        while x % d == 0:\n            factors[d] = factors.get(d, 0) + 1\n            x //= d\n        d += 1\n    if x > 1:\n        factors[x] = factors.get(x, 0) + 1\n    return factors\n\ndef merge_factors(factors_list):\n    merged = defaultdict(int)\n    for d in factors_list[0].keys():\n        merged[d] = max([factors_list[i].get(d, 0) for i in range(len(factors_list))])\n    return merged\n\ndef lcm_from_gcd(g, l):\n    if l % g != 0:\n        return None\n    total_product = g * l\n    return total_product\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"NO\")\n        return\n        \n    n = int(data[0]); m = int(data[1])\n    edges = []\n    index = 2\n    graph = [[] for _ in range(n+1)]\n    for i in range(m):\n        u = int(data[index]); v = int(data[index+1]); g_val = int(data[index+2]); l_val = int(data[index+3])\n        index += 4\n        edges.append((u, v, g_val, l_val))\n        graph[u].append((v, g_val, l_val))\n        graph[v].append((u, g_val, l_val))\n\n    for (u, v, g_val, l_val) in edges:\n        if l_val % g_val != 0:\n            print(\"NO\")\n            return\n\n    candidate_ans = [0] * (n+1)\n    candidate_ans[0] = 1\n    for i in range(1, n+1):\n        candidate_ans[i] = 0\n\n    for i in range(1, n+1):\n        if candidate_ans[i] != 0:\n            continue\n        stack = [i]\n        candidate_ans[i] = 1\n        factors_dict = defaultdict(dict)\n        factorized_edges = []\n        for neighbor, g_val, l_val in graph[i]:\n            total_product = g_val * l_val\n            prod_factors = factorize(total_product)\n            factors_dict[neighbor] = prod_factors\n            factorized_edges.append(prod_factors)\n\n        merged_factors = merge_factors(factorized_edges)\n        base = 1\n        for p, exp in merged_factors.items():\n            base *= pow(p, exp)\n\n        candidate_ans[i] = base\n\n        while stack:\n            node = stack.pop()\n            for neighbor, g_val, l_val in graph[node]:\n                if candidate_ans[neighbor] == 0:\n                    total_product = g_val * l_val\n                    prod_factors = factorize(total_product)\n                    factors_dict[neighbor] = prod_factors\n                    factorized_edges.append(prod_factors)\n                    merged_factors = merge_factors([factors_dict[j] for j in graph[node]])\n                    new_base = 1\n                    for p, exp in merged_factors.items():\n                        new_base *= pow(p, exp)\n                    candidate_ans[neighbor] = new_base\n                    stack.append(neighbor)\n\n    valid = True\n    for (u, v, g_val, l_val) in edges:\n        a = candidate_ans[u]\n        b = candidate_ans[v]\n        if a == 0 or b == 0:\n            valid = False\n            break\n        if a % g_val != 0 or b % g_val != 0:\n            valid = False\n            break\n        if a * b != g_val * l_val:\n            valid = False\n            break\n        if gcd(a, b) != g_val or lcm(a, b) != l_val:\n            valid = False\n            break\n\n    if not valid:\n        print(\"NO\")\n        return\n\n    print(\"YES\")\n    print(\" \".join(str(x) for x in candidate_ans[1:]))\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\nif __name__ == '__main__':\n    main()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 553,
        "completion_token_count": 1449,
        "thoughts_token_count": 1023
    }
}