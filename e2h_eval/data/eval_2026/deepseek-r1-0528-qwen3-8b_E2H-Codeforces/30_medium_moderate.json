{
    "start": 1758307863.4539225,
    "end": 1758311441.0730891,
    "start-formatted": "2025-09-20 03:51 KST",
    "end-formatted": "2025-09-20 04:50 KST",
    "gpu": 2,
    "pid": 30,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# TV Game\n\nThere is a new TV game on BerTV. In this game two players get a number A consisting of 2n digits. Before each turn players determine who will make the next move. Each player should make exactly n moves. On it's turn i-th player takes the leftmost digit of A and appends it to his or her number Si. After that this leftmost digit is erased from A. Initially the numbers of both players (S1 and S2) are «empty». Leading zeroes in numbers A, S1, S2 are allowed. In the end of the game the first player gets S1 dollars, and the second gets S2 dollars.One day Homer and Marge came to play the game. They managed to know the number A beforehand. They want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize. Help them.\n\n## Input\nThe first line contains integer n (1 ≤ n ≤ 18). The second line contains integer A consisting of exactly 2n digits. This number can have leading zeroes.\n\n## Output\nOutput the line of 2n characters «H» and «M» — the sequence of moves of Homer and Marge, which gives them maximum possible total prize. Each player must make exactly n moves. If there are several solutions, output any of them.\n\n## Example\n### Input\n['2\\n1234', '2\\n9911']\n\n### Output\n['HHMM', 'HMHM']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\n Okay, we are given an integer n and a string A of 2n digits.\n We have two players: Homer (H) and Marge (M). Each makes exactly n moves.\n On each move, the leftmost digit is taken and appended to the respective player's number.\n\n The goal is to choose a sequence of moves (a string of length 2n containing n 'H's and n 'M's) such that the total prize (S1 + S2) is maximized.\n\n Note: The total prize is the sum of two numbers: \n   S1 is the number formed by the digits that Homer took (in order, so the first digit Homer takes becomes the most significant)\n   S2 is the number formed by the digits that Marge took.\n\n However, note that the entire string A is fixed and will be split into two sequences (each of length n) in the order of moves.\n\n Observation:\n   Let the sequence of moves be represented by a string of length 2n with exactly n H's and n M's. Then the digits that form S1 are the ones taken at positions where the move is H, and similarly for S2.\n\n But note: the moves happen from left to right. So the first move (the very first character) is the first digit of A. Then the next move (second character) is the next digit of the remaining string, etc.\n\n However, the catch: we can interleave the moves arbitrarily (as long as there are exactly n H and n M). \n\n How to approach?\n\n Let's denote:\n   Let X = list of digits for Homer, and Y = list of digits for Marge.\n\n Then the total prize is int(X[0])*10^(n-1) + ... + int(X[n-1]) + int(Y[0])*10^(n-1) + ... + int(Y[n-1])\n\n But note: the digits are taken from the beginning of A in the order of the moves. However, the assignment of digits to H or M is determined by the move sequence.\n\n We need to assign the 2n digits (from A) to two sequences of length n. The catch: the moves must be in the order of the original string (i.e., the i-th digit of A is assigned to the j-th move, but which player is determined by the move at that step).\n\n Alternatively, we can think: we are going to remove the digits one by one from the left of A, and assign each removed digit to either H or M, but we cannot assign more than n to either.\n\n The total prize is the sum of the two numbers. Since the numbers are base-10, the value of a digit depends on its position.\n\n However, note: the digits that go to Homer will appear in the order they are taken, and similarly for Marge. But the positions (i.e., the power of 10) for each digit in the final number depend on when it is taken.\n\n Specifically, if we take a digit at an early move, it gets a higher power (if it goes to a player, then it becomes the next digit in that player's number). \n\n Example: \n   n=2, A=\"1234\"\n\n   If we have the sequence \"HHMM\":\n        H takes '1' (first digit) -> S1 starts with 1, then H takes the next available? Actually, wait: the sequence is HHMM, meaning:\n          Move1 (H): take first digit '1' -> A becomes \"234\"\n          Move2 (H): take first digit '2' -> A becomes \"34\"\n          Move3 (M): take first digit '3' -> A becomes \"4\"\n          Move4 (M): take first digit '4'\n\n        Then S1 = \"12\" (which is 12) and S2 = \"34\" (which is 34). Total = 12+34 = 46.\n\n   Another sequence: \"HMHM\":\n        Move1 (H): take '1' -> A becomes \"234\"\n        Move2 (M): take '2' -> A becomes \"34\"\n        Move3 (H): take '3' -> A becomes \"4\"\n        Move4 (M): take '4'\n        Then S1 = \"13\", S2 = \"24\". Total = 13+24 = 37.\n\n   And the example output says for input \"2\\n1234\" we output \"HHMM\" (and for \"2\\n9911\" we output \"HMHM\").\n\n Why is \"HHMM\" better? Because 12+34=46 > 13+24=37.\n\n What is the problem? We want to maximize the total.\n\n Alternate view: we are going to split the 2n-digit string A into two numbers, each of n digits, but the catch is that the two numbers are built by interleaving the removals. However, the removals must follow the order of A.\n\n Actually, note: the entire string A is fixed. The only decision is: at each step, which player takes the next digit.\n\n But note: the two numbers are built from the same set of digits (the entire A) but in two different orders (the order of appearance in A, but assigned to two players arbitrarily as long as we have n for each). However, the assignment is forced by the move sequence: the first move assigns the first digit, the second move the second, etc.\n\n However, the value of a digit in a player's number is determined by its position in that player's sequence. In particular, if a digit is taken by a player at his k-th move (k from 1 to n), then its value is multiplied by 10^(n-k).\n\n Therefore, the total contribution of a digit d at a particular move (say, the i-th move overall) that is assigned to a player who has made k moves so far (so this would be his (k+1)-th move) is: d * (10^(n - (k+1)))\n\n But note: the entire sequence of moves defines the order in which digits are assigned to the two players.\n\n However, we can also consider: the entire set of digits is fixed. The total sum is independent of the assignment? No, because the same digit might be multiplied by different powers.\n\n Example: In \"1234\", n=2:\n\n   Sequence \"HHMM\": \n        Homer: first two digits: [1,2] -> 1*10^1 + 2*10^0 = 12\n        Marge: last two: [3,4] -> 3*10^1 + 4*10^0 = 34\n\n   Sequence \"HMHM\":\n        Homer: [1,3] -> 1*10^1 + 3*10^0 = 13\n        Marge: [2,4] -> 2*10^1 + 4*10^0 = 24\n\n How do we maximize the total? The total is 12+34 = 46 vs 13+24=37.\n\n Notice: In the first assignment, the two largest digits (3 and 4) get the highest powers (each 10^1) because they are taken in the first two moves by Marge (but wait, actually they are taken in the third and fourth moves, so they are the first two moves for Marge, hence they get the full two-digit numbers). \n\n However, in the second assignment, the two largest digits (3 and 4) are not together: 3 is assigned to Homer (so it gets a power of 10^0) and 4 is assigned to Marge (also 10^0). \n\n This suggests: we want to assign the larger digits to the higher powers. But note: the same digit might be available at different positions (with different potential powers) and we have to assign them to the two players.\n\n But note: the moves are fixed: the digits are removed from left to right. The assignment must be done in the order of removal.\n\n However, we can decide at each step which player takes the digit. The constraint is that each player must take exactly n moves.\n\n We can use dynamic programming:\n\n Let dp[i][j][k] = maximum total prize achievable after processing the first i+j digits (i moves by H, j moves by M, so i+j is the current index) and we have used i digits for H and j digits for M.\n\n But wait, how do we account for the value? The value of a digit depends on the order in which it is taken by a player.\n\n Alternatively, we can consider that the digits are being assigned to two sequences, and the value of a digit in a sequence depends on the position (the later you assign, the lower the power). But note: the move number (the k-th move for a player) is fixed by the count of moves already taken by that player.\n\n However, we can also note: the total prize can be broken down by the digit's own contribution.\n\n For a digit d that is assigned to a player at his k-th move (so this is the k-th digit for that player, and there are n-k digits after this for that player), then the digit d contributes d * (10^(n-k)).\n\n But note: the assignment must be in the order of the string. \n\n Alternatively, we can think greedily: we want to assign the largest digits to the highest available powers.\n\n The highest power is 10^(n-1) for the first move of each player. Then 10^(n-2) for the second, etc.\n\n However, the catch: we don't know which digits will be available at which time.\n\n We have to assign the digits in the order of A.\n\n We can consider: the entire game has 2n moves. The first move (the very first digit) can be assigned to either player. But if we assign it to a player, then that digit will be the most significant digit for that player (i.e., it gets multiplied by 10^(n-1)). \n\n Now, if we have two digits: the first digit is '9' and the second is '8', and we have two moves. Then:\n\n Option 1: HH\n   H: [9,8] -> 9*10^1 + 8*10^0 = 98\n   M: [] -> 0\n   Total = 98\n\n Option 2: HM\n   H: [9] -> 9*10^(n-1) = 90\n   M: [8] -> 8*10^(n-1) = 80\n   Total = 170\n\n Option 3: MH\n   H: [8] -> 80\n   M: [9] -> 90\n   Total = 170\n\n Option 4: MM\n   H: [] -> 0\n   M: [9,8] -> 98\n   Total = 98\n\n So clearly, assigning the largest digit to the highest power (which is the first move) is beneficial. But note: we have two players, and we must assign exactly n moves to each.\n\n Therefore, the idea is to assign the largest digits to the earliest moves (so that they get the highest powers). However, we must assign n moves to each.\n\n How to do that? \n\n We can use a greedy algorithm:\n\n   We have two pointers for the two players: the next available power for H is 10^(n-1) and for M is 10^(n-1). Then we have 2n digits from A.\n\n   We want to assign the largest available digit to the highest available power. But note: we are constrained by the order of the digits in A.\n\n   However, the digits must be taken from left to right. So we cannot rearrange the digits arbitrarily.\n\n   Example: n=2, A=\"1234\"\n\n   Steps:\n\n     We have two sequences: H and M, both empty. The available powers for H: [10^1, 10^0], for M: [10^1, 10^0].\n\n     The first digit is '1'. We can assign it to H or M. But if we assign it to H, then H's next available power is 10^0, and M still has [10^1, 10^0]. Then the next digit is '2': we can assign to H (then H gets 2 at 10^0) or to M (then M gets 2 at 10^1). Then we have two possibilities.\n\n     Alternatively, we can use a state DP that considers the number of moves each player has taken and the current total value, but 2n is up to 36, and n up to 18, so state space is (n+1)*(n+1) = 19*19=361 states, but we have 36 steps. However, we also need to remember the exact digits we've taken and their contributions? That would be too heavy.\n\n   Alternatively, we can note that the total prize is fixed by the assignment of the digits to the two players and the order (because the power for a digit is determined by the count of moves the player has taken so far). \n\n   We can reframe: We are going to assign the 2n digits to two sets (each of size n) and then sort each set in descending order? But wait, no: the order of the digits is fixed by the order of A. \n\n   Actually, the digits that a player takes must appear in the order of A. However, the value of a digit for a player is determined by the number of moves the player has made so far (the position in the player's number). \n\n   But note: the same digit cannot be taken twice, and the assignment must be in the order of A.\n\n   Another idea: we want to maximize the total. The total is the sum over the two numbers. The two numbers are built from the digits assigned to each, but the digits in a number are in the order they were taken (which is the order in A). \n\n   However, the value of the digits in a player's number is:\n\n        S1 = d0 * 10^(i0) + d1 * 10^(i1) + ... \n\n   But note: the digits are taken in increasing indices (from A). And the power for a digit is 10^(n - (the index of the move in that player's sequence)).\n\n   We can break the total prize as:\n\n        Total = (digit1) * (10^(n - h1)) + (digit2) * (10^(n - h2)) + ... for H\n               + (digit1) * (10^(n - m1)) + (digit2) * (10^(n - m2)) + ... for M\n\n   But note: the assignment must be in the order of A.\n\n   Alternatively, we can use a greedy matching: we have two lists of exponents (for H: [10^(n-1), 10^(n-2), ..., 10^0]; for M: [10^(n-1), 10^(n-2), ..., 10^0]). Then we want to assign the digits (in the order of A) to these exponents, but the constraint is that the exponents for H must be assigned to digits that are taken consecutively (without skipping any digit in between for H) and similarly for M? Actually, no: the moves are interleaved arbitrarily.\n\n   However, note: the digits are taken in the order of A. So if we assign a digit to a player, then all the digits that come before in A are already assigned.\n\n   We can use a DP that goes digit by digit and decides which player takes it, but we must keep track of:\n\n        i: the number of moves by H (from 0 to n)\n        j: the number of moves by M (from 0 to n)\n\n        and the total value so far? But the value depends on the entire sequence, and we haven't fixed the exponents for future moves.\n\n   But note: the exponent for a digit is determined by the number of moves the player has already made (for that player). \n\n   Specifically, if we assign the current digit (at position k) to H, then this digit will be the (i+1)-th digit of H, and its power is 10^(n - (i+1)). Similarly for M.\n\n   Then the contribution of this digit is: digit_value * (10^(n - (i+1))) if assigned to H, or to M.\n\n   However, the rest of the digits (the ones we haven't processed) will be assigned to the two players, and the total prize is the sum of the contributions of all digits.\n\n   But we cannot compute the entire total until we assign all digits. However, we can use DP that accumulates the total value.\n\n   Let dp[i][j] = maximum total prize we can achieve from the remaining part (from the current digit to the end) given that H has made i moves and M has made j moves.\n\n   Then the current state is defined by i (0<=i<=n) and j (0<=j<=n) and the current index in A (which is i+j). We traverse from index 0 to 2n-1.\n\n   Transition: \n        At state (i, j), we are at the (i+j)-th digit (0-indexed) of A.\n\n        Option 1: assign this digit to H, if i < n.\n            Then the digit d = A[i+j] (as integer) will contribute d * (10^(n - (i+1))) [because H will now have i+1 moves, so the next available exponent for H is 10^(n - (i+1))].\n            Then the next state is (i+1, j) and we add the contribution.\n\n        Option 2: assign this digit to M, if j < n.\n            Then the digit d = A[i+j] contributes d * (10^(n - (j+1)))\n            Then the next state is (i, j+1)\n\n   Then we take the maximum of the two options.\n\n   However, note: the exponent for a digit depends on the total number of moves the player will have at the time of taking the digit. But wait: the rest of the digits are not known. Actually, the exponent for a digit is fixed by the time it is taken: if a player takes a digit at his k-th move, then it gets 10^(n-k). \n\n   But in the DP above, we are only tracking the number of moves so far. The digit is taken at the current move, so for H, the exponent is 10^(n - (i+1)), because after this move, H will have i+1 moves, so the current digit is the (i+1)-th digit of H (which is the least significant digit so far for H? Actually, no: the first digit taken by H is the most significant, and the last is the least.\n\n   But note: the way we are building the numbers: the first digit taken by H is the most significant (multiplied by 10^(n-1)), the second by 10^(n-2)), etc.\n\n   In our DP, we are assigning the current digit to the next available slot for the player. And the next available slot for H is the (i+1)-th move, so the power is 10^(n - (i+1)) (because the first move is the highest power, then second is next, etc.).\n\n   However, the entire sequence for H will have n digits. The first digit taken by H (when i=0) will be the most significant (power 10^(n-1)), the second (i=1) will be 10^(n-2)), and the last (i=n-1) will be 10^0.\n\n   This matches.\n\n   But note: we are processing the digits in the order of A, and the digit we are assigning now is the (i+j)-th digit of A. The exponent for the digit does not depend on the position in A, but on the count of moves for the player.\n\n   Then the recurrence:\n\n        dp[i][j] = max( \n            (if i < n: d * (10**(n-i-1)) + dp[i+1][j]),\n            (if j < n: d * (10**(n-j-1)) + dp[i][j+1])\n        )\n\n   However, we must note: the entire number is built by the digits in the order of A. But the above DP does not consider that the same digit might be used multiple times? No, we are processing each digit once.\n\n   Base case: when i+j == 2*n, then we have processed all digits, and we require i==n and j==n. Then dp[n][n] = 0.\n\n   But wait: we are at state (i, j) and we have processed i+j digits. Then we need to process the next digit (if any). The state (i, j) should be at the beginning of processing the (i+j)-th digit.\n\n   However, we need to store the entire state (i, j) and the index is i+j. We can iterate from the end.\n\n   But note: the exponent calculation uses the current count (i and j) to determine the power. \n\n   But wait: what about the digits that are assigned to the other player? They are not affecting the current digit's power.\n\n   The problem: the DP state (i, j) does not capture the entire history, but the total value is additive. However, the exponents are predetermined by the order of moves (for the player) and independent of the other player.\n\n   But note: the same digit is used only once, and the assignment to a player gives it a fixed exponent (depending on the player's move count at the time). \n\n   However, there is a catch: the DP state must remember the entire sequence of assignments? Actually, no: the total value is the sum of the contributions of each digit. And the contribution of a digit is independent of the other digits (except for the constraint that we must assign each digit exactly once). \n\n   But wait: the exponent for a digit is fixed by the move index of the player at the time the digit is taken. And the move index is just the count (so we don't need to know which digits the player has taken, only the count).\n\n   Therefore, the DP state (i, j) is sufficient.\n\n   However, the exponents: the digit we are processing now, if assigned to H, will be the (i+1)-th digit for H (so it will be placed at the (i+1)-th position from the left, meaning the power is 10^(n-i-1)). Similarly for M.\n\n   But note: the entire number for H is built from the digits assigned to H, and the order is the order of appearance in A. However, the DP does not record the order in which H takes the digits? Actually, the order is fixed by the fact that we are processing the digits from left to right. When we assign a digit to H, then in the future, when we assign the next digit to H, that digit will be the next (more significant? Actually, no: the first digit taken by H is the most significant, and the subsequent ones are less. But in our assignment, the first digit we assign to H (at the first occurrence) is the most significant, and the next one we assign to H (even if it appears later in A) is the next significant. \n\n   However, note: the entire set of digits for H must be taken in the order they appear in A. But the DP does not enforce that the digits for H are taken in increasing index? Actually, we are processing A from left to right, and we are free to assign any digit to any player at the moment we see it. But the assignment must be such that the digits for H appear in the order of A (because we are removing from left to right). \n\n   The DP above does not enforce that the digits assigned to H are contiguous? Actually, no: the digits for H can be non-contiguous (we can interleave with M's moves). But the relative order of the digits assigned to H is the same as in A. Similarly for M.\n\n   However, the exponent for a digit assigned to H is determined solely by the number of moves H has made so far (at the time of assignment). This is correct because:\n\n        The first digit assigned to H (the first time we assign to H) will be the most significant (because it is the first digit of H's number) and gets 10^(n-1). The second digit assigned to H (the next time we assign to H) will be the next significant (so 10^(n-2)), etc.\n\n   But note: the digit that is assigned to H at the first move is the first digit of H's number. The next digit assigned to H (even if it comes much later) is the second digit (so it must be placed to the right of the first one). However, the entire sequence of A is fixed, and the digits assigned to H must appear in the order they appear in A.\n\n   This is automatically satisfied because we are processing A from left to right and we assign each digit exactly once.\n\n   Therefore, the DP is:\n\n        Let dp[i][j] = maximum total prize from the suffix starting at the (i+j)-th digit (0-indexed) to the end, given that H has made i moves and M has made j moves.\n\n        Then, for state (i, j):\n            index = i+j\n            if index == 2*n: \n                return 0\n\n            d = int(A[index])\n\n            option1 = -1\n            option2 = -1\n\n            if i < n:\n                # Assign to H: this is the (i+1)-th move for H, so exponent is 10^(n-i-1)\n                exp_H = 10**(n-i-1)\n                option1 = d * exp_H + dp[i+1][j]\n\n            if j < n:\n                exp_M = 10**(n-j-1)\n                option2 = d * exp_M + dp[i][j+1]\n\n            Then dp[i][j] = max(option1, option2)   (if both are available, else the available one)\n\n        We need to compute dp[0][0].\n\n   However, we are asked to output the sequence of moves (a string of length 2n with n H's and n M's) that achieves the maximum total prize.\n\n   We can do:\n\n        Use DP to compute the maximum total prize, and then backtrack to find the moves.\n\n   But note: the problem says if there are several solutions, output any.\n\n   Steps:\n\n        1. Precompute the DP table for i from 0 to n and j from 0 to n, for states (i, j) with i+j from 2*n down to 0.\n\n        2. Then, starting from (0,0), we look at the first digit and decide: if assigning to H gives a higher total than assigning to M, then we choose H, else M.\n\n        However, note: the DP recurrence is additive and the exponent for the current digit depends on the move counts (i and j). \n\n        But wait: the DP recurrence we defined:\n\n            dp[i][j] = max( \n                (if i<n: d * (10**(n-i-1)) + dp[i+1][j]),\n                (if j<n: d * (10**(n-j-1)) + dp[i][j+1])\n            )\n\n        However, the two options are not necessarily independent because the exponents for the same digit would be different. But note: the digit is fixed, and we are comparing two different ways of assigning the current digit and then the rest.\n\n        But the rest (the suffix) is independent of the current assignment? Actually, the rest of the digits (from index+1 to the end) will be assigned independently, and the exponents for the rest of the digits for H and M are predetermined by the move counts (so the DP state captures that).\n\n        However, we must note: the exponents for the same digit are fixed by the move count at the time of assignment, and the rest of the digits are assigned optimally.\n\n        But the above DP does not account for the fact that the same digit might be used in multiple assignments? No, each digit is used once.\n\n   But wait: the exponents for the same digit are fixed by the move count at the time of assignment, and the rest of the digits are assigned optimally. This is correct.\n\n   However, the exponent for a digit that is assigned to H at the current state is 10^(n-i-1). But note: the entire number for H must have n digits, and the current digit is the (i+1)-th digit. The rest of the digits for H (if any) will be assigned in the future and they will have lower exponents (because the move counts for H will increase). Similarly for M.\n\n   But note: the entire number for H is built by the digits assigned to H, and the order is the order of A. The DP does not break down the entire number into separate parts, but the additive property holds because the value is linear.\n\n   However, let's test with the example n=2, A=\"1234\":\n\n        We'll build the DP table from the end.\n\n        dp[2][2] = 0 (base)\n\n        Then state (2,1): i+j=3, so index=3, last digit is '4'\n            Only M can take it (since i=2, so H has already taken 2 moves, so only M can take the last move).\n            d=4, exponent for M: 10^(2-1-1)=10^0=1 -> 4*1 = 4\n            dp[2][1] = 4\n\n        State (2,0): i+j=2, index=2, digit='3'\n            Only M can take (since i=2, so j must go from 0 to 1, then to 2)\n            d=3, exponent for M: 10^(2-0-1)=10^1=10 -> 30\n            dp[2][0] = 30\n\n        State (1,2): i+j=3, index=3, digit='4'\n            Only H can take (because j=2, so M has taken 2, H has taken 1, so H must take the last one)\n            d=4, exponent for H: 10^(2-1-1)=10^0=1 -> 4\n            dp[1][2] = 4\n\n        State (1,1): i+j=2, index=2, digit='3'\n            Both can take.\n            Option1 (assign to H): 3 * 10^(2-1-1) = 3 * 1 = 3, then dp[2][1]=4 -> total 7\n            Option2 (assign to M): 3 * 10^(2-1-1)=3, then dp[1][2]=4 -> total 7\n            dp[1][1] = 7\n\n        State (1,0): i+j=1, index=1, digit='2'\n            Only H can take (since j=0, so M hasn't taken any, but we have i=1, so H can take one more)\n            Option1: 2 * 10^(2-1-1)=2, then dp[2][0]=30 -> total 32\n            Option2: not allowed (j=0, so M can take one more? Actually, we are at (1,0): H has taken 1, M 0. Then we can assign to M: \n                M: 2 * 10^(2-0-1)=2*10=20, then dp[1][1]=7 -> total 27\n            So dp[1][0] = max(32, 27) = 32\n\n        State (0,2): i+j=2, index=2, digit='3'\n            Only H can take (because j=2, so M has taken 2, H has taken 0, so H must take one)\n            d=3, exponent for H: 10^(2-0-1)=10, so 30, then dp[1][2]=4 -> total 34\n\n        State (0,1): i+j=1, index=1, digit='2'\n            Both can take.\n            Option1 (H): 2 * 10^(2-0-1)=2*10=20, then dp[1][1]=7 -> 27\n            Option2 (M): 2 * 10^(2-1-1)=2*1=2, then dp[0][2]=34 -> 36\n            dp[0][1] = 36\n\n        State (0,0): i+j=0, index=0, digit='1'\n            Both can take.\n            Option1 (H): 1 * 10^(2-0-1)=10, then dp[1][0]=32 -> 42\n            Option2 (M): 1 * 10^(2-1-1)=1, then dp[0][1]=36 -> 37\n            dp[0][0] = 42\n\n        Then the maximum total prize is 42.\n\n        Now, we backtrack:\n\n            Start at (0,0): \n                Option1: 42, Option2:37 -> choose H.\n\n            Then we go to state (1,0). \n\n            Then at (1,0): \n                We have two options: \n                    Option1 (H): 32, which came from 2 (at index1) assigned to H: then from state (1,0) we did: \n                        2 * 10^(2-1-1)=2, then dp[2][0]=30 -> so that's the move for the second digit: H.\n\n                Then we go to state (2,0). \n\n            Then at (2,0): \n                Only M can take, so the third digit (index2) is assigned to M: 3 * 10^(2-0-1)=30.\n\n            Then state (2,1): then the last digit (index3) is assigned to M: 4 * 10^0=4.\n\n            So the moves: \n                First: H\n                Second: H\n                Third: M\n                Fourth: M\n\n            The sequence is \"HHMM\", which matches the example.\n\n        Now, the other example: n=2, A=\"9911\"\n\n        We want to output \"HMHM\".\n\n        Let's compute dp[0][0] for A=\"9911\":\n\n            dp[2][2]=0\n\n            dp[2][1]: index=3, digit='1' -> M: 1 * 10^0=1\n            dp[1][2]: index=2, digit='1' -> H: 1 * 10^0=1\n            dp[2][0]: index=2, digit='1' -> M: 1 * 10^1=10\n            dp[0][2]: index=1, digit='9' -> H: 9 * 10^1=90, then dp[1][2]=1 -> 91\n\n            dp[1][1]: index=1, digit='9'\n                Option1 (H): 9 * 10^(2-1-1)=9*1=9, then dp[2][1]=1 -> 10\n                Option2 (M): 9 * 10^(2-1-1)=9, then dp[1][2]=1 -> 10\n                dp[1][1]=10\n\n            dp[1][0]: index=0, digit='9'\n                Option1 (H): 9 * 10^(2-1-1)=9, then dp[2][0]=10 -> 19\n                Option2 (M): 9 * 10^(2-0-1)=90, then dp[1][1]=10 -> 100\n                dp[1][0]=100\n\n            dp[0][1]: index=0, digit='9'\n                Option1 (H): 9 * 10^(2-0-1)=90, then dp[1][1]=10 -> 100\n                Option2 (M): 9 * 10^(2-1-1)=9, then dp[0][2]=91 -> 100\n                dp[0][1]=100\n\n            dp[0][0]: index=0, digit='9'\n                Option1 (H): 90 + dp[1][0]=100 -> 190\n                Option2 (M): 9 + dp[0][1]=100 -> 109\n                dp[0][0]=190\n\n            Now, backtrack:\n\n                At (0,0): choose H.\n\n                Then state (1,0): \n                    Then at (1,0): the digit at index0 was assigned to H, then we have the rest of the string \"911\" (from index1 to end) to",
    "response": "\nTo solve this problem, we need to maximize the total prize for two players, Homer and Marge, who take turns selecting digits from a given number A. The goal is to determine the optimal sequence of moves (comprising exactly n 'H's and n 'M's) such that the sum of the numbers formed by each player's selected digits is maximized.\n\n### Approach\n1. **Problem Analysis**: The problem involves splitting a 2n-digit number A into two n-digit numbers (one for each player) by selecting digits in a specific order. The key observation is that the value of a digit depends on its position in the respective player's number. Digits selected earlier contribute more significantly to the total prize due to their higher place values (e.g., the first digit selected by a player contributes 10^(n-1) times its value).\n\n2. **Dynamic Programming (DP) Setup**: We use a DP table `dp[i][j]` where `i` and `j` represent the number of moves made by Homer and Marge, respectively. The value `dp[i][j]` stores the maximum total prize achievable from the remaining digits starting at position `i+j` in A.\n\n3. **DP Transition**: For each state `(i, j)`, we consider assigning the current digit to either player (if they haven't exceeded their move limit). The digit's contribution is calculated based on its position in the player's number (using exponents of 10). The DP state transitions involve moving to the next state after assigning the digit to a player.\n\n4. **Backtracking**: After filling the DP table, we backtrack from `dp[0][0]` to construct the move sequence. At each step, we choose the move (H or M) that leads to the higher total prize, based on the DP table values.\n\n### Solution Code\n```python\ndef main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    if not data:\n        return\n    \n    n_line = data[0].strip()\n    n_val = int(n_line)\n    A_str = data[1].strip()\n    \n    total_digits = 2 * n_val\n    dp = [[0] * (n_val+1) for _ in range(n_val+1)]\n    path = [[''] * (n_val+1) for _ in range(n_val+1)]\n    \n    for i in range(n_val-1, -1, -1):\n        for j in range(n_val-1, -1, -1):\n            idx = i + j\n            if idx >= total_digits:\n                continue\n                \n            d_char = A_str[idx]\n            d_int = int(d_char)\n            \n            option1 = -1\n            option2 = -1\n            \n            if i < n_val:\n                exp_H = 10**(n_val - i - 1)\n                option1 = d_int * exp_H + dp[i+1][j]\n                \n            if j < n_val:\n                exp_M = 10**(n_val - j - 1)\n                option2 = d_int * exp_M + dp[i][j+1]\n                \n            if option1 == -1 and option2 == -1:\n                dp[i][j] = 0\n                continue\n                \n            if option1 == -1:\n                dp[i][j] = option2\n                path[i][j] = 'M'\n            elif option2 == -1:\n                dp[i][j] = option1\n                path[i][j] = 'H'\n            else:\n                if option1 > option2:\n                    dp[i][j] = option1\n                    path[i][j] = 'H'\n                else:\n                    dp[i][j] = option2\n                    path[i][j] = 'M'\n                    \n    seq = []\n    i, j = 0, 0\n    while i < n_val and j < n_val:\n        move = path[i][j]\n        seq.append(move)\n        if move == 'H':\n            i += 1\n        else:\n            j += 1\n            \n    while i < n_val:\n        seq.append('H')\n        i += 1\n        \n    while j < n_val:\n        seq.append('M')\n        j += 1\n        \n    result_seq = ''.join(seq)\n    print(result_seq)\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input consists of an integer `n` and a string `A` of 2n digits.\n2. **DP Table Initialization**: The DP table `dp` is initialized to store the maximum prize achievable from each state `(i, j)`. The `path` table keeps track of the move (H or M) taken to reach each state.\n3. **Filling DP Table**: Starting from the end of the string, the DP table is filled by considering both possible moves (assigning the current digit to H or M) and updating the state accordingly.\n4. **Backtracking**: The optimal move sequence is constructed by backtracking from `dp[0][0]` to `dp[n][n]`, following the moves recorded in the `path` table.\n5. **Output**: The constructed sequence of moves is printed, ensuring both players make exactly `n` moves and the total prize is maximized.\n\nThis approach efficiently computes the optimal move sequence using dynamic programming, leveraging the fact that each digit's contribution depends on its selection order and the player's move count at the time of selection.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    if not data:\n        return\n    \n    n_line = data[0].strip()\n    n_val = int(n_line)\n    A_str = data[1].strip()\n    \n    total_digits = 2 * n_val\n    dp = [[0] * (n_val+1) for _ in range(n_val+1)]\n    path = [[''] * (n_val+1) for _ in range(n_val+1)]\n    \n    for i in range(n_val-1, -1, -1):\n        for j in range(n_val-1, -1, -1):\n            idx = i + j\n            if idx >= total_digits:\n                continue\n                \n            d_char = A_str[idx]\n            d_int = int(d_char)\n            \n            option1 = -1\n            option2 = -1\n            \n            if i < n_val:\n                exp_H = 10**(n_val - i - 1)\n                option1 = d_int * exp_H + dp[i+1][j]\n                \n            if j < n_val:\n                exp_M = 10**(n_val - j - 1)\n                option2 = d_int * exp_M + dp[i][j+1]\n                \n            if option1 == -1 and option2 == -1:\n                dp[i][j] = 0\n                continue\n                \n            if option1 == -1:\n                dp[i][j] = option2\n                path[i][j] = 'M'\n            elif option2 == -1:\n                dp[i][j] = option1\n                path[i][j] = 'H'\n            else:\n                if option1 > option2:\n                    dp[i][j] = option1\n                    path[i][j] = 'H'\n                else:\n                    dp[i][j] = option2\n                    path[i][j] = 'M'\n                    \n    seq = []\n    i, j = 0, 0\n    while i < n_val and j < n_val:\n        move = path[i][j]\n        seq.append(move)\n        if move == 'H':\n            i += 1\n        else:\n            j += 1\n            \n    while i < n_val:\n        seq.append('H')\n        i += 1\n        \n    while j < n_val:\n        seq.append('M')\n        j += 1\n        \n    result_seq = ''.join(seq)\n    print(result_seq)\n\nif __name__ == '__main__':\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 420,
        "completion_token_count": 1159,
        "thoughts_token_count": 8191
    }
}