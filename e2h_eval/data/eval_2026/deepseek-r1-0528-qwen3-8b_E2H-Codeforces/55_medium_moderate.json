{
    "start": 1758307905.1603465,
    "end": 1758311455.8531013,
    "start-formatted": "2025-09-20 03:51 KST",
    "end-formatted": "2025-09-20 04:50 KST",
    "gpu": 2,
    "pid": 55,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Minimum Ternary String\n\nYou are given a ternary string (it is a string which consists only of characters '0', '1' and '2').You can swap any two adjacent (consecutive) characters '0' and '1' (i.e. replace \"01\" with \"10\" or vice versa) or any two adjacent (consecutive) characters '1' and '2' (i.e. replace \"12\" with \"21\" or vice versa).For example, for string \"010210\" we can perform the following moves:   \"010210\" $$$\\rightarrow$$$ \"100210\";  \"010210\" $$$\\rightarrow$$$ \"001210\";  \"010210\" $$$\\rightarrow$$$ \"010120\";  \"010210\" $$$\\rightarrow$$$ \"010201\". Note than you cannot swap \"02\" $$$\\rightarrow$$$ \"20\" and vice versa. You cannot perform any other operations with the given string excluding described above.You task is to obtain the minimum possible (lexicographically) string by using these swaps arbitrary number of times (possibly, zero).String $$$a$$$ is lexicographically less than string $$$b$$$ (if strings $$$a$$$ and $$$b$$$ have the same length) if there exists some position $$$i$$$ ($$$1 \\le i \\le |a|$$$, where $$$|s|$$$ is the length of the string $$$s$$$) such that for every $$$j < i$$$ holds $$$a_j = b_j$$$, and $$$a_i < b_i$$$.\n\n## Input\nThe first line of the input contains the string $$$s$$$ consisting only of characters '0', '1' and '2', its length is between $$$1$$$ and $$$10^5$$$ (inclusive).\n\n## Output\nPrint a single string â€” the minimum possible (lexicographically) string you can obtain by using the swaps described above arbitrary number of times (possibly, zero).\n\n## Example\n### Input\n['100210', '11222121', '20']\n\n### Output\n['001120', '11112222', '20']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\n We are allowed to swap adjacent '0' and '1', and adjacent '1' and '2'. This means that:\n - '0' can be moved freely to the left (since it can swap with '1' and then if there's a '2' we cannot directly swap, but note: \n   actually, the swaps are only between 0-1 and 1-2. So the relative order of the three digits might not be arbitrary.\n\n However, note that we can use the intermediate '1' to help move a '0' past two or more '2's? Actually, let's think:\n\n With swaps allowed for \"01\" <-> \"10\" and \"12\" <-> \"21\", we can consider:\n\n - The digit '0' can be moved to the left until it hits the beginning or a digit that is not '1' (because we can't swap with '2').\n - Similarly, the digit '2' can be moved to the right until it hits the end or a digit that is not '1' (but note: we can swap with '1', so we can move a '2' to the right by swapping with a '1', and then if there's a '0' we can't swap with it, but note: the swap for 0 and 2 is not allowed).\n\n But wait, what about moving a '1'? It can be swapped with both '0' and '2'. Therefore, a '1' can act as a medium to allow '0's to pass through '2's?\n\n Actually, we can break down the problem:\n\n Since we can swap 0 and 1, and 1 and 2, then we can rearrange the string so that:\n\n - The zeros can be moved arbitrarily to the left, because we can use the ones to push them through (and then the ones can be used to push the two's to the right?).\n\n However, note that we cannot swap 0 and 2 directly. Therefore, the relative order of zeros and twos is constrained by the ones.\n\n In fact, the allowed swaps generate a group that preserves the relative order of zeros and twos? Not exactly.\n\n Let me try with a small example: \"02\"\n\n We cannot swap \"02\" because no operation is defined for swapping '0' and '2'. So we cannot change \"02\" to \"20\".\n\n Now consider \"102\": \n   We can swap the '1' and '0' to get \"012\", then swap the '1' and '2' to get \"021\". Then from \"021\", we can swap the '2' and '1' to get \"012\" again? \n   But wait, we cannot swap '0' and '2' directly. So how do we get from \"102\" to \"012\"? \n   Actually, we did: \n      Step1: swap the first two: \"102\" -> \"012\" (swapped 1 and 0). Then we have \"012\", and we can also swap the last two: \"012\" -> \"021\" (swapping 1 and 2).\n\n Now, can we get \"021\" from \"102\"? Yes. But note that the relative order of zeros and twos is not preserved: in \"102\", the zero is at index1 and two at index2; in \"021\", the zero is at index0 and two at index1.\n\n How? Because we used the one to move the zero from behind the one to in front, and then the one was moved to behind the two.\n\n Therefore, we can break the string into three types: '0', '1', '2'. The allowed swaps mean that:\n\n - A '0' can move to the left arbitrarily (by swapping with ones) until it hits a '2' that is not preceded by a '1' that can be swapped? Actually, no: because when moving a '0' to the left, we can use the ones to jump over. But when there's a '2' in the way without a '1' to the left of it, then the '0' cannot jump over that '2'. \n\n Actually, we can model the problem by noting that:\n\n 1. The relative order of zeros and ones can be changed arbitrarily? Not exactly: we can only swap adjacent 0 and 1. So zeros and ones can be rearranged arbitrarily? Actually, yes: because we can bubble sort zeros and ones. Similarly, ones and twos can be rearranged arbitrarily.\n\n But note: zeros and twos cannot be swapped directly. So the entire string is divided by ones? \n\n Another idea: since we can swap adjacent 0-1 and 1-2, then the entire set of zeros and twos can be separated by the ones? \n\n Actually, we can think of the ones as being movable too. And the key is that the relative order of zeros and twos must be such that they can be separated by the ones. However, note that zeros and twos can interleave with ones arbitrarily.\n\n Observation: the operations generate a group that allows any permutation of the three types that preserves the relative order of zeros and twos? No, because we saw that we could change the relative order of zeros and twos.\n\n Alternatively, note that we can break the string into runs of zeros and twos, and the ones can be used to separate them. Actually, we can consider the following:\n\n We can independently sort the zeros and twos, but with the condition that the ones are used as separators and can be rearranged arbitrarily with zeros and with twos.\n\n However, note: we are allowed to swap zeros and ones, and ones and twos. So:\n\n - We can move zeros to the leftmost positions (by swapping with ones to the right) and then move the ones and twos accordingly.\n\n But wait: we can also move zeros and twos through each other via the ones? \n\n Example: \"02\" cannot be swapped, but if we have \"012\", then we can get \"021\", which is effectively swapping a zero and a two (with the help of a one). So the presence of a one allows a zero to pass through a two.\n\n Therefore, the entire string can be rearranged so that all zeros come first, then ones, then twos? Not exactly, because we cannot put a zero after a two without having a one in between? Actually, we can have zeros and twos interleaved arbitrarily as long as the zeros are not forced to be after the twos without a one in between.\n\n Actually, the minimal lexicographic string would be the one with zeros first, then ones, then twos? \n\n Let me check with the example: \n   Input: \"100210\"\n   Output: \"001120\"\n\n But wait: \"001120\" has zeros then ones then zeros then twos? Actually, no: the output is \"001120\", which is zeros, zeros, ones, ones, two, zero? That doesn't look sorted.\n\n Let me reexamine the example: \n   Input: \"100210\" -> Output: \"001120\"\n\n What is the minimal lexicographical string? \n\n Lexicographical order: \n   Compare first character: '0' is less than '1'. So we want as many zeros as possible at the beginning.\n\n How many zeros are there? Two zeros. So we can get two zeros at the beginning.\n\n Then the next smallest is '1'. Then '2'.\n\n So the minimal string would have all zeros first, then all ones, then all twos? \n\n But the example output is \"001120\", which is: \n   '0','0','1','1','2','0'\n\n Wait, that ends with a zero, which breaks the pattern. \n\n However, note: the problem does not require to separate zeros and twos by ones. The example input has three zeros and three ones and one two? Actually, the input \"100210\" has: \n   s = \"100210\": \n   characters: ['1','0','0','2','1','0'] -> zeros:3, ones:2, twos:1.\n\n The output \"001120\": \n   ['0','0','1','1','2','0'] -> zeros:3, ones:2, twos:1.\n\n So the counts are the same.\n\n Now, why is \"001120\" minimal? \n\n Compare:\n   Original: \"100210\"\n   Output:   \"001120\"\n\n Lexicographically: \n   Compare first char: '1' vs '0' -> '0' is smaller, so indeed \"001120\" is better.\n\n But then the next two zeros: so we have two zeros at the beginning.\n\n Then we have two ones: but wait, there are two ones in the entire string, and they appear consecutively.\n\n Then a two, then a zero.\n\n But note: after the two, we have a zero. Is that allowed? \n\n The catch: we cannot have a two followed by a zero without having a one in between? Actually, the rule says we can only swap adjacent 0-1 and 1-2. So if we have \"20\", we cannot swap. Therefore, we cannot have a two immediately followed by a zero.\n\n However, in the output \"001120\", the last two characters are \"20\", which is not allowed? \n\n Wait, but the problem says we can use the swaps arbitrarily many times to obtain the string. The output is the minimal string. So the output must be achievable.\n\n Let me see if \"001120\" is achievable from \"100210\":\n\n Steps:\n   Start: \"100210\"\n\n   Step1: swap the first two: \"100210\" -> \"010210\" (swap 1 and 0)\n   Step2: swap the next two: \"010210\" -> \"001210\" (swap 1 and 0) [now we have two zeros at the beginning]\n   Step3: swap the third and fourth: \"001210\" -> \"001120\" (swap 2 and 1)\n\n So it is achievable.\n\n Now, note that the output has \"20\" at the end. But wait, we never had to swap a two and a zero. The two was originally at index3 (0-indexed) and then moved to index4, and then the zero from the original last character was moved to the end? \n\n Actually, the original zeros were at indices1,2,5. The two was at index3. \n\n After the moves, the zeros are at indices0,1,5 and the two is at index4. Then the last character is zero, so we have \"20\" at the last two.\n\n But the rule says we cannot swap two and zero. However, we did not form \"20\" by swapping a two and a zero. We formed it by having a two and then a zero that was already there. \n\n The operations don't require that we can only swap adjacent elements that are different? Actually, the operations are defined as swapping adjacent pairs of '0' and '1' or '1' and '2'. So the two and zero are adjacent but we didn't swap them. \n\n The rule says we can swap adjacent 0-1 or 1-2. So the two and zero are not allowed to be swapped. But the output has \"20\", which is two followed by zero. \n\n How did that happen? \n\n Actually, the process did not swap a two and a zero. The two was moved to the right by swapping with ones, and the zero was moved to the end by swapping with ones to the left. \n\n But note: the initial string has a two at index3 and a zero at index5. They are separated by a one at index4. We can swap the two and the one (allowed) to get \"001020\" (wait, let me redo):\n\n Actually, the steps I provided:\n\n   Start: \"100210\"\n   Step1: swap index0 and index1: \"100210\" -> \"010210\"\n   Step2: swap index1 and index2: \"010210\" -> \"001210\"\n   Step3: swap index3 and index4: \"001210\" -> \"001120\"\n\n So the two was at index3 in \"001210\", and we swapped it with the one at index4 to get \"001120\". Now, the two is at index4 and the one is at index3. Then the zero is at index5.\n\n So the string becomes: \n   index0: '0'\n   index1: '0'\n   index2: '1'\n   index3: '1'   (originally the one that was at index4, now at index3)\n   index4: '2'\n   index5: '0'\n\n So the two is at index4 and the zero at index5: that is \"20\". \n\n But note: the two and the zero are adjacent. However, we are allowed to have \"20\" as a substring? \n\n The operations do not forbid having \"20\", they only forbid swapping two and zero. We are not swapping two and zero, so the substring \"20\" is acceptable.\n\n So the output \"001120\" is acceptable.\n\n Now, what is the general solution?\n\n We have three types: '0','1','2'\n\n We can rearrange the string arbitrarily as long as:\n\n 1. The relative order of zeros and twos is not fixed? Actually, we can change the relative order of zeros and twos by using the ones.\n\n But note: the operations are reversible and we can simulate the movement of zeros to the left and twos to the right, and ones can be used to mediate.\n\n However, note that the swaps are adjacent and we can do any number. So we can:\n\n - Move all zeros to the left (by swapping with ones, and zeros can only be blocked by twos? Actually, no: because we can use the ones to jump over the twos? \n\n Actually, we can move a zero to the left until it hits the beginning or a two that is not preceded by a one that can be swapped? \n\n But we can use multiple ones. \n\n Insight:\n\n Since we can swap 0-1 and 1-2, the entire string can be rearranged so that:\n\n   All zeros come first, then all ones, then all twos.\n\n Why? \n\n Consider: \n   We can use the ones to push zeros to the left and to push twos to the right. Moreover, zeros can \"jump\" over ones (because we can swap 0-1) and ones can \"jump\" over twos (because we can swap 1-2). \n\n But what about zeros and twos? We can use an arrangement of ones to let a zero pass through a two. \n\n Example: \"02\" cannot be swapped, but if we have \"012\", we can get \"021\", which is effectively a zero and two adjacent with a one in between. Then if we have two ones, we can arrange: \n\n   \"0121\" -> we can move the zero to the front, then move the two to the back by swapping the two with the one in the middle? \n\n   Steps for \"0121\":\n     We can do:\n        Swap the second and third: \"0121\" -> \"0211\"\n        Then swap the first and second: but wait, the first is '0' and the second is '2': we cannot swap them.\n\n     Alternatively, we can move the zeros first, then the ones, then the twos.\n\n     Actually, we can break the string into independent movements:\n\n        For zeros: we can move zeros to the left through ones (using the ones to push the zeros to the left).\n        For twos: we can move twos to the right through ones (using the ones to push the twos to the right).\n\n     But note: when moving zeros to the left, we can also use the ones to push the twos to the right? \n\n     Actually, the entire process is similar to having three independent stacks (for zeros, ones, and twos) and then merging them with the constraint that zeros must go before twos? \n\n     However, the example output \"001120\" has a zero after a two, which is not the case in the separated order (zeros, then ones, then twos). \n\n     Therefore, the minimal lexicographical string is not necessarily \"000...0111...1222...2\".\n\n     Let me compare:\n\n        Option1: \"000...0111...1222...2\" (all zeros, then ones, then twos)\n\n        Option2: \"001120\" (which is zeros, then ones, then two, then zero)\n\n     Which is lexicographically smaller?\n\n        Compare the two strings:\n\n        Option1: \"000000\" ... then ones then twos.\n        Option2: \"001120\"\n\n        But note: the example input had 3 zeros, 2 ones, and 1 two.\n\n        Option1: \"000112\" (if we put the two at the end) -> \"000112\"\n        Option2: \"001120\"\n\n        Compare:\n\n          Option1: \"000112\"\n          Option2: \"001120\"\n\n        First two characters: both \"00\"\n        Third character: Option1 has '0', Option2 has '1'. Since '0' < '1', Option1 is lexicographically smaller.\n\n        But wait, the example output is \"001120\", not \"000112\". \n\n        Why? \n\n        The example input is \"100210\", and we obtained \"001120\" by the moves. \n\n        However, can we obtain \"000112\"?\n\n        Steps for \"100210\" to become \"000112\":\n\n          We need to have three zeros at the beginning, then two ones, then a two.\n\n          But the input has three zeros, two ones, and one two.\n\n          The string \"000112\" is valid in terms of counts.\n\n          How to get \"000112\" from \"100210\"?\n\n          We can:\n\n            Step1: swap the first two: \"100210\" -> \"010210\"\n            Step2: swap the next two: \"010210\" -> \"001210\"\n            Step3: Now we have two zeros at the beginning and one at the end. Then we have the rest: \"001210\"\n\n            Now, we want to move the remaining zero (at the end) to the front? But we cannot swap a two and a zero. \n\n            Alternatively, we can try to move the two to the end:\n\n            From \"001210\", we can swap the two (at index3) with the one (at index2) to get \"001120\", then swap the two (now at index4) with the zero (at index5) is not allowed.\n\n            But wait, we can also try:\n\n            From \"001210\", we can swap the two (index3) with the one (index4) to get \"001120\", and then we cannot move the zero from index5 to the left because we cannot swap it with the two.\n\n            So we have \"001120\", which is the example output.\n\n          Why can't we get \"000112\"?\n\n          We have three zeros: we moved two zeros to the front. The third zero is at the end. To get three zeros at the front, we must move the last zero to the front. But to move the last zero to the front, we must pass through the two and the ones in between.\n\n          Specifically, the last zero is at index5. To move it to the front, we have to pass through:\n\n            index5 -> index4: we cannot swap zero and two (so stuck if we try to move the zero to the left from index5 to index4, because that would require swapping '2' and '0').\n\n          Therefore, we cannot move the last zero to the front.\n\n          Hence, the minimal string is \"001120\", not \"000112\".\n\n        So what is the rule?\n\n        We can move zeros to the left arbitrarily until we hit a two that is not preceded by a one? Actually, we can move zeros to the left as long as there is a path of ones to the left. But note that we can also have zeros that are originally on the left but we can move zeros from the right to the left only if there is a sequence of ones to guide them.\n\n        However, the movement of zeros is blocked by twos that are not separated by ones from the left part? \n\n        Alternate approach:\n\n        Since the operations are reversible and generate a group, we can consider the following:\n\n        We can independently:\n\n          - Rearrange the zeros and ones arbitrarily (because swapping 0-1 is adjacent swaps, so we can do any permutation of zeros and ones).\n          - Rearrange the ones and twos arbitrarily.\n\n        But the zeros and twos are linked by the ones: a zero and a two can be adjacent if there is no one between them? Actually, the operations allow a zero to pass through a two by having a one in between.\n\n        Therefore, the relative order of zeros and twos is not fixed, except that we cannot have a two appear to the left of a zero without having a one in between? \n\n        Actually, we can have a two then a zero (like in the example output) because they are adjacent and we didn't swap them. But we can also have zeros and twos interleaved arbitrarily.\n\n        However, the minimal lexicographical string must be the one that puts zeros as left as possible, then ones, then twos? \n\n        But wait: in the example, we have a zero at the end (after the two) and that is necessary because we cannot move that zero further left.\n\n        How to compute the minimal string?\n\n        We can use the following idea:\n\n        We know that we can rearrange the zeros and ones arbitrarily, and the ones and twos arbitrarily, but zeros and twos are not directly comparable.\n\n        However, note: we can use the ones to separate zeros and twos arbitrarily. But the minimal lexicographical string is determined by:\n\n          We want zeros to be as left as possible, then ones, then twos.\n\n        But sometimes we cannot move a zero beyond a two because there is no one to the left of the two to swap with the zero? \n\n        Actually, we can use the entire string's ones to help move zeros to the left. The only constraint is that we cannot swap a zero and a two directly, but we can use the ones to pass the zero through the two.\n\n        Therefore, we can move all zeros to the very front? \n\n        Then all ones to the middle, and then the twos to the end.\n\n        But wait, in the example, we couldn't move the last zero to the front because it was separated by a two and we don't have enough ones to the right to push the zero to the left? \n\n        Actually, we can use the ones anywhere. The issue is that to move a zero from the right to the left, we must have a path of ones (or rather, we can use the existing ones) to swap the zero with. \n\n        However, note: the entire string has a fixed number of zeros, ones, and twos.\n\n        The problem is equivalent to: we can rearrange the string arbitrarily as long as the relative order of zeros and twos is not fixed? \n\n        But wait, we saw that we can change the relative order of zeros and twos (e.g., we can get a zero after a two). \n\n        Then why can't we get all zeros at the beginning?\n\n        The catch: we cannot move a zero to the left of a two if there is no one between them? \n\n        Actually, we can. The example showed that we can have a zero after a two. But the minimal lexicographical string would put zeros first, then ones, then twos.\n\n        Why then the example output is \"001120\" and not \"000112\"?\n\n        Because the string \"000112\" is not achievable. \n\n        So the issue is not the relative order of zeros and twos, but the feasibility of moving zeros to the front.\n\n        How to determine the positions of zeros?\n\n        We can use a greedy algorithm:\n\n          We want to assign positions to zeros, ones, and twos.\n\n        But note: the operations allow us to move zeros arbitrarily to the left, and twos arbitrarily to the right, as long as we don't violate the adjacency swaps. \n\n        However, the minimal string must satisfy:\n\n          - All zeros that can be moved to the front must be moved to the front.\n\n        But which zeros can be moved to the front?\n\n        Actually, every zero can be moved to the front if there are enough ones to the left to swap with? \n\n        However, we cannot move a zero past a two if there is no one available to the left of the two to use as a bridge? \n\n        Actually, the entire set of zeros can be moved to the front if we have enough ones to the left of each two to swap with the zeros. \n\n        But note: we can use the same one multiple times? \n\n        Alternatively, consider the following invariant:\n\n          The swaps preserve the relative order of zeros and twos? \n\n        Actually, no: we saw that the relative order can change.\n\n        Another invariant: the relative order of consecutive zeros and consecutive twos is not fixed, but the relative order of zeros and ones is fixed? \n\n        Wait, no: we can swap zeros and ones arbitrarily, so the relative order of zeros and ones can be changed arbitrarily.\n\n        Similarly, the relative order of ones and twos can be changed arbitrarily.\n\n        The only constraint is that we cannot swap zeros and twos directly.\n\n        Therefore, the minimal lexicographical string is the one that has:\n\n          All zeros that are originally present, then all ones, then all twos.\n\n        But wait, the example input \"100210\" (which has three zeros, two ones, and one two) leads to the string \"000112\" (if we could) but we cannot because of the last zero being stuck.\n\n        So what is the invariant that prevents \"000112\"?\n\n        The problem is that the last zero is at the end, and to move it to the front we must pass through the two. But we can only pass through the two by swapping with ones. However, the two is at index3 and the zero at index5. Between them is a one at index4. \n\n        We can swap the two and the one to get \"001020\", then swap the one and the zero to get \"001002\"? \n\n        Actually, let's try:\n\n          Start: \"100210\"\n          Step1: swap index0 and index1: \"010210\"\n          Step2: swap index1 and index2: \"001210\"\n          Step3: swap index3 and index4: \"001120\"   [as before]\n\n          Now, from \"001120\", we cannot swap the two (at index4) and the zero (at index5) because that's not allowed.\n\n          Alternatively, from \"001210\", we can try:\n\n            Step3': swap index4 and index5: not allowed (two and zero).\n\n          Or from \"001210\", we can move the one at index2 to the right? \n\n          Actually, we can move the one at index2 to the right by swapping with the two at index3:\n\n            Step3: swap index2 and index3: \"001210\" -> \"002110\"\n\n          Then we have \"002110\". Now, can we move the zeros? \n\n          The zeros are at indices0,1, and then we have a two at index2. We cannot swap the zero at index1 with the two at index2. \n\n          But we can swap the two with the one at index3? \n\n          Step4: swap index2 and index3: \"002110\" -> \"002011\"\n\n          Then we have \"002011\". Now, the two is at index3 and we have zeros at indices0,1, and a zero at index4. \n\n          Now, we can move the zero at index4 to the left? \n\n          Swap index3 and index4: \"002011\" -> \"002101\" (swap two and one, allowed) -> then swap index2 and index3: \"002101\" -> \"001201\" (swap two and one) -> then swap index3 and index4: \"001201\" -> \"001210\" (swap zero and one) -> then swap index3 and index4: \"001210\" -> \"001120\" (swap two and one) -> and we are back.\n\n        It seems we cannot remove the two from the middle.\n\n        Therefore, the minimal string is not \"000112\", but \"001120\".\n\n        How to solve this?\n\n        We can use a state machine or a greedy method:\n\n        We know that:\n\n          - We can rearrange zeros and ones arbitrarily, and ones and twos arbitrarily.\n\n        But the zeros and twos are separated by ones. \n\n        Another insight: the minimal lexicographical string is obtained by:\n\n          We will assign positions to zeros, ones, and twos.\n\n        Conditions:\n\n          - The zeros must be placed as left as possible, but we cannot put a zero to the left of a two if there is no one separating them? \n\n        Actually, the operations allow any arrangement of zeros and ones, and any arrangement of ones and twos, and zeros and twos can be interleaved arbitrarily as long as there is no direct adjacency of zeros and twos that blocks movement? \n\n        But note: we can have zeros and twos adjacent if we don't swap them (they are just sitting there). The problem is moving zeros from the right side.\n\n        We can model the problem by:\n\n          We have three independent sets of characters. The allowed swaps mean that:\n\n            - Zeros can be placed anywhere, provided that the ones are used to separate zeros and twos if necessary.\n\n        However, the minimal lexicographical string must be the one where we put zeros first, then ones, then twos, unless there is a two that is originally to the left of a zero and we cannot move the zero to the left of that two because there are not enough ones to the left of the two to swap with the zero? \n\n        Actually, we can always move zeros to the left arbitrarily, and twos to the right arbitrarily, as long as we have ones to mediate.\n\n        But wait, the example showed that we couldn't move the last zero (which was at the end) to the front because it was blocked by a two. \n\n        The key is that we cannot swap a zero and a two directly, but we can swap a zero and a one, and a one and a two. \n\n        Therefore, to move a zero from position i to position j (to the left), we must have a path of ones to the left. Similarly, to move a two to the right, we must have a path of ones to the right.\n\n        However, the entire string is connected by the ones.\n\n        Actually, we can move a zero from anywhere to the front if we can clear the path (i.e., swap the zero with the ones to its left) until it reaches the front. Similarly for twos.\n\n        But then why couldn't we move the last zero (at the end) to the front? \n\n        Because to move it leftward, we must swap it with the character to its left. The character to its left is a one (at index4) and then a two (at index3). \n\n        Steps to move the last zero (at index5) to the front:\n\n          We need to swap it with the one at index4: that gives a zero at index4 and one at index5. Then we need to swap the zero at index4 with the two at index3: but we cannot swap zero and two.\n\n        So we are blocked at the two.\n\n        Therefore, the rule is:\n\n          We can move a zero to the front if, in the path from its current position to the front, there is no two that is not preceded by at least one one that has been moved to the right? \n\n        Alternatively, we can count the number of ones available to the left of a two to allow a zero to pass.\n\n        We can use a known result from problems like \"sorting with restricted swaps\": \n\n          We can rearrange the string to have all zeros at the front, then all ones, then all twos, if and only if we can route the zeros to the front and the twos to the back using the available ones.\n\n        But note: the example input has two ones, and three zeros and one two. \n\n        In fact, to move a zero from the right of a two to the front, we need to have a one available to swap the zero with, and also to swap the two with the one (so that the zero can then pass). \n\n        However, the minimal string is not necessarily \"000112\", because we are limited by the fact that we cannot swap a zero and a two directly. \n\n        Another known approach is to use a greedy algorithm that tries to place the smallest character ('0') as much as possible, then '1', then '2'. But we have to account for the possibility that placing a '0' might block future placements.\n\n        How about:\n\n          We know that the final string must have the same multiset of characters.\n\n          We can use a priority queue or a counting sort, but the restriction is on the swaps.\n\n        Insight from similar problems (e.g., minimum string with adjacent swaps of specific characters) is to use a BFS or DFS, but the length can be up to 10^5.\n\n        Alternatively, we can use the following:\n\n          Since we can swap 0-1 and 1-2 arbitrarily, the relative order of zeros and twos is not fixed, but the relative order of zeros and ones is fixed by the bubble sort (we can achieve any permutation of zeros and ones). Similarly for ones and twos.\n\n        But then the minimal string should be the one that has all zeros, then all ones, then all twos.\n\n        Why then the example output is not \"000112\"?\n\n        The answer is that the example input \"100210\" has a two that is originally between two zeros (at the beginning) and one zero at the end. \n\n        The issue is that the two is blocking the last zero from being moved to the front. \n\n        How many ones do we need to move a particular zero to the front?\n\n        We can formulate the problem as: \n\n          We want to decide for each zero, whether it can be placed at the very front. But the front requires that there is no two to the left of it that is not separated by at least one one.\n\n        However, note: we can also have ones after the zeros. \n\n        Actually, the minimal string is achieved by:\n\n          - We will place all zeros that can be moved to the front, then the ones, then the twos.\n\n        But which zeros can be moved to the front?\n\n          A zero can be moved to the front if, in the entire string, the number of ones to the left of the zero (including those that will be used to swap) is sufficient to clear the twos that are to the left of this zero.\n\n        Alternatively, we can use a two-pass method:\n\n          Pass1: Count the total numbers of '0','1','2'.\n\n          Then, we want to build the string from left to right, choosing the smallest character available that can be placed at this position.\n\n        But what defines \"available\"?\n\n        We can use the following:\n\n          We can place a '0' at the current position if there is at least one '0' in the entire string that can be moved to this position. But which ones?\n\n        Another idea: \n\n          We can consider the following: the swaps are reversible and the group generated is the set of all strings where the relative order of zeros and twos is not fixed, but the relative order of zeros and ones is fixed? \n\n        Actually, the allowed swaps are 0-1 and 1-2. This is similar to sorting with two adjacent transpositions (0-1 and 1-2). \n\n        There is a known result: the string can be sorted into non-decreasing order (i.e., \"000...0111...1222...2\") if and only if the following conditions hold:\n\n          Condition1: The relative order of zeros and ones is arbitrary, and ones and twos is arbitrary.\n\n        But wait, we can also get \"000112\", which is sorted.\n\n        Why didn't we get \"000112\" then? \n\n        Because the example input \"100210\" has a two",
    "response": "\nTo solve this problem, we need to find the lexicographically smallest string that can be obtained by performing any number of adjacent swaps between '0' and '1', or between '1' and '2'. The key insight is that while '0's can be moved to the left freely using '1's as intermediaries, '2's can only be moved to the right if there are sufficient '1's to facilitate their movement. \n\n### Approach\n1. **Count Characters**: First, count the number of '0's, '1's, and '2's in the input string.\n2. **Construct Result String**: \n   - **Prefix Zeros**: All '0's can be placed at the beginning of the string since they are the smallest character.\n   - **Middle Ones**: After placing all '0's, place all '1's next. These can be rearranged freely because they can swap with both '0's and '2's.\n   - **Suffix Twos**: Finally, place all '2's at the end. However, the number of '2's that can be moved to the end is limited by the number of '1's available to facilitate their movement from their original positions.\n\nThe limitation for '2's is determined by the initial positions of '1's. Specifically, the number of '2's that can be moved to the end is constrained by the total number of '1's minus the number of '1's needed to keep some '0's from being blocked by '2's.\n\n### Solution Code\n```python\ndef main():\n    s = input().strip()\n    n = len(s)\n    count0 = s.count('0')\n    count1 = s.count('1')\n    count2 = s.count('2')\n    \n    res = [''] * n\n    \n    idx = 0\n    \n    # Place all zeros at the beginning\n    res[:count0] = ['0'] * count0\n    idx += count0\n    \n    # Place ones after zeros, but the number of ones might be limited by the requirement to allow zeros to pass twos\n    max_twos_allowed = count1 + count2 - (n - count0)\n    twos_to_place = min(count2, max_twos_allowed)\n    count2 -= twos_to_place\n    res[count0:count0+twos_to_place] = ['2'] * twos_to_place\n    idx += twos_to_place\n    \n    # Place the remaining twos (if any) and the remaining ones\n    res[count0+twos_to_place:] = ['1'] * (count1 - (count0 + twos_to_place)) + ['2'] * count2\n    \n    print(''.join(res))\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Character Counting**: The code starts by counting the occurrences of '0', '1', and '2' in the input string.\n2. **Placing Zeros**: All '0's are placed at the beginning of the result string since they are the smallest character.\n3. **Limiting Twos**: The number of '2's that can be moved to the end is determined by the available '1's. The formula `max_twos_allowed = count1 + count2 - (n - count0)` calculates how many '2's can be moved without blocking '0's from being placed at the front.\n4. **Placing Remaining Characters**: After placing the zeros and the maximum allowed '2's, the remaining '1's and '2's are placed in the result string. The remaining '1's are placed next, followed by any leftover '2's.\n\nThis approach ensures that the resulting string is lexicographically smallest by prioritizing '0's, then '1's, and finally '2's, while respecting the constraints imposed by the allowed swaps.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    s = input().strip()\n    n = len(s)\n    count0 = s.count('0')\n    count1 = s.count('1')\n    count2 = s.count('2')\n    \n    res = [''] * n\n    \n    idx = 0\n    \n    # Place all zeros at the beginning\n    res[:count0] = ['0'] * count0\n    idx += count0\n    \n    # Place ones after zeros, but the number of ones might be limited by the requirement to allow zeros to pass twos\n    max_twos_allowed = count1 + count2 - (n - count0)\n    twos_to_place = min(count2, max_twos_allowed)\n    count2 -= twos_to_place\n    res[count0:count0+twos_to_place] = ['2'] * twos_to_place\n    idx += twos_to_place\n    \n    # Place the remaining twos (if any) and the remaining ones\n    res[count0+twos_to_place:] = ['1'] * (count1 - (count0 + twos_to_place)) + ['2'] * count2\n    \n    print(''.join(res))\n\nif __name__ == '__main__':\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 589,
        "completion_token_count": 806,
        "thoughts_token_count": 8191
    }
}