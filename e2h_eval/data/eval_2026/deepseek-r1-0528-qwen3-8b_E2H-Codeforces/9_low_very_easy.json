{
    "start": 1758093285.8542287,
    "end": 1758094985.9399085,
    "start-formatted": "2025-09-17 16:14 KST",
    "end-formatted": "2025-09-17 16:43 KST",
    "gpu": 2,
    "pid": 9,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Selling Souvenirs\n\nAfter several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.This morning, as usual, Petya will come to the market. Petya has n different souvenirs to sell; ith souvenir is characterised by its weight wi and cost ci. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than m, and total cost is maximum possible.Help Petya to determine maximum possible total cost.\n\n## Input\nThe first line contains two integers n and m (1 ≤ n ≤ 100000, 1 ≤ m ≤ 300000) — the number of Petya's souvenirs and total weight that he can carry to the market.Then n lines follow. ith line contains two integers wi and ci (1 ≤ wi ≤ 3, 1 ≤ ci ≤ 109) — the weight and the cost of ith souvenir.\n\n## Output\nPrint one number — maximum possible total cost of souvenirs that Petya can carry to the market.\n\n## Example\n### Input\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\n### Output\n['0', '3', '10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\n We are given up to 100000 souvenirs, each with weight in {1,2,3} and cost up to 10^9.\n Since the weights are only 1, 2, or 3, we can group the souvenirs by weight.\n\n Let:\n   type1 = list of costs for weight 1\n   type2 = list of costs for weight 2\n   type3 = list of costs for weight 3\n\n Then the total weight is at most m (which can be up to 300000). The maximum number of items we can take from type1 is floor(m/1) but note that we might not use all because of the other types.\n\n However, note: the problem is similar to the bounded knapsack but with very small weights (only 1,2,3) and the fact that we can take multiple copies? Actually, wait: the input says \"n different souvenirs\", meaning we have one of each? But the example input:\n\n Input example: \n   \"1 1\\n2 1\" -> two lines? Actually, the example input is given as:\n\n   ['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\n But wait, the example output is ['0','3','10'].\n\n Let me parse the example:\n\n Example 1: \n   Input: \"1 1\\n2 1\"\n   This means n=1, m=1, and then one souvenir with w=2, c=1.\n   Then we cannot carry this souvenir (since 2>1), so total cost=0.\n\n Example 2:\n   Input: \"2 2\\n1 3\\n2 2\"\n   n=2, m=2. Souvenirs: [ (1,3), (2,2) ]\n   We can take the first one: weight=1, cost=3 -> total weight=1<=2, cost=3.\n   We can also take the second one: weight=2, cost=2 -> total weight=2<=2, cost=2.\n   But note: we cannot take both because 1+2=3>2.\n   So maximum cost is 3.\n\n Example 3:\n   Input: \"4 3\\n3 10\\n2 7\\n2 8\\n1 1\"\n   n=4, m=3. Souvenirs: [ (3,10), (2,7), (2,8), (1,1) ]\n   We can take at most one item of weight 3 (but 3<=3) -> cost 10.\n   Or we can take one item of weight 2 and one of weight 1: max cost from weight2 items: 8 and weight1:1 -> 8+1=9, but 8+1=9 < 10.\n   Alternatively, two items of weight 2: 2+2=4 >3 -> not allowed.\n   So maximum is 10.\n\n However, note that we have multiple souvenirs per type? The problem says \"n different souvenirs\", so each line is a distinct souvenir.\n\n But the catch: we have three types (by weight 1,2,3) and we can take multiple souvenirs of same weight? Actually, yes, because they are different souvenirs.\n\n However, note: the example input for the third test case has:\n   (3,10), (2,7), (2,8), (1,1)\n   There are two souvenirs of weight2: one with cost7 and one with cost8.\n\n So we have to consider that we can take multiple items of the same weight, but each souvenir is distinct.\n\n But note: the total weight is additive. Since the weights are only 1,2,3, we can use dynamic programming for knapsack, but m can be up to 300000 and n up to 100000. However, the state space for DP would be too big if we try to do a standard knapsack.\n\n Alternative approach:\n\n Since the weights are only 1,2,3, we can break the problem into:\n\n Let:\n   a = sorted(type1)   # for weight1, we want to take the most expensive ones first? Actually, we want to maximize the cost, so we should take the highest cost items first for each weight.\n\n But note: we are allowed to take multiple items of the same weight. However, the problem is that we have a limited total weight.\n\n Observation: the total weight is the sum of the weights of the chosen items. We have three types. We can use:\n\n",
    "response": "\nTo solve this problem, we need to maximize the total cost of souvenirs that Petya can carry to the market without exceeding the given weight limit. Each souvenir has a weight of either 1, 2, or 3, and a corresponding cost. The challenge is to select a subset of these souvenirs such that their combined weight is within the limit, and their total cost is as high as possible.\n\n### Approach\n1. **Grouping by Weight**: First, we group all souvenirs by their weights (1, 2, or 3). This allows us to handle each weight category separately.\n2. **Sorting Costs**: For each weight category, we sort the costs in descending order. This ensures that when we consider taking multiple items of the same weight, we always pick the most expensive ones first, maximizing the total cost.\n3. **Prefix Sum Arrays**: For each weight category, we compute prefix sums of the sorted costs. This helps in quickly determining the maximum total cost achievable by taking a certain number of items from that category.\n4. **Iterate Over Possible Combinations**: We then iterate over all possible combinations of items from the three weight categories. For each combination, we check if the total weight does not exceed the limit and keep track of the maximum total cost encountered.\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(0)\n        return\n        \n    n = int(data[0])\n    m = int(data[1])\n    index = 2\n    type1 = []\n    type2 = []\n    type3 = []\n    \n    for i in range(n):\n        w = int(data[index])\n        c = int(data[index+1])\n        index += 2\n        if w == 1:\n            type1.append(c)\n        elif w == 2:\n            type2.append(c)\n        elif w == 3:\n            type3.append(c)\n            \n    type1.sort(reverse=True)\n    type2.sort(reverse=True)\n    type3.sort(reverse=True)\n    \n    len1 = len(type1)\n    len2 = len(type2)\n    len3 = len(type3)\n    \n    pre1 = [0] * (len1 + 1)\n    for i in range(1, len1 + 1):\n        pre1[i] = pre1[i-1] + type1[i-1]\n        \n    pre2 = [0] * (len2 + 1)\n    for i in range(1, len2 + 1):\n        pre2[i] = pre2[i-1] + type2[i-1]\n        \n    pre3 = [0] * (len3 + 1)\n    for i in range(1, len3 + 1):\n        pre3[i] = pre3[i-1] + type3[i-1]\n        \n    best = 0\n    max_count1 = m // 1\n    max_count2 = m // 2\n    max_count3 = m // 3\n    \n    for i in range(min(len1, max_count1) + 1):\n        rem = m - i\n        if rem < 0:\n            continue\n        cost1 = pre1[i]\n        count2 = min(len2, rem // 2)\n        cost2 = pre2[count2]\n        rem_after2 = rem - 2 * count2\n        count3 = min(len3, rem_after2 // 3)\n        cost3 = pre3[count3]\n        total = cost1 + cost2 + cost3\n        if total > best:\n            best = total\n            \n    for i in range(min(len1, max_count1) + 1):\n        rem = m - i\n        if rem < 0:\n            continue\n        cost1 = pre1[i]\n        count3 = min(len3, rem // 3)\n        cost3 = pre3[count3]\n        rem_after3 = rem - 3 * count3\n        count2 = min(len2, rem_after3 // 2)\n        cost2 = pre2[count2]\n        total = cost1 + cost2 + cost3\n        if total > best:\n            best = total\n            \n    for i in range(min(len2, max_count2) + 1):\n        rem = m - 2 * i\n        if rem < 0:\n            continue\n        cost2 = pre2[i]\n        count1 = min(len1, rem)\n        cost1 = pre1[count1]\n        rem_after1 = rem - count1\n        count3 = min(len3, rem_after1 // 3)\n        cost3 = pre3[count3]\n        total = cost2 + cost1 + cost3\n        if total > best:\n            best = total\n            \n    for i in range(min(len2, max_count2) + 1):\n        rem = m - 2 * i\n        if rem < 0:\n            continue\n        cost2 = pre2[i]\n        count3 = min(len3, rem // 3)\n        cost3 = pre3[count3]\n        rem_after3 = rem - 3 * count3\n        count1 = min(len1, rem_after3)\n        cost1 = pre1[count1]\n        total = cost2 + cost1 + cost3\n        if total > best:\n            best = total\n            \n    for i in range(min(len3, max_count3) + 1):\n        rem = m - 3 * i\n        if rem < 0:\n            continue\n        cost3 = pre3[i]\n        count1 = min(len1, rem)\n        cost1 = pre1[count1]\n        rem_after1 = rem - count1\n        count2 = min(len2, rem_after1 // 2)\n        cost2 = pre2[count2]\n        total = cost3 + cost1 + cost2\n        if total > best:\n            best = total\n            \n    for i in range(min(len3, max_count3) + 1):\n        rem = m - 3 * i\n        if rem < 0:\n            continue\n        cost3 = pre3[i]\n        count2 = min(len2, rem // 2)\n        cost2 = pre2[count2]\n        rem_after2 = rem - 2 * count2\n        count1 = min(len1, rem_after2)\n        cost1 = pre1[count1]\n        total = cost3 + cost2 + cost1\n        if total > best:\n            best = total\n            \n    print(best)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Input Handling**: The input is read and parsed into the number of souvenirs `n` and the maximum weight `m`. Each souvenir's weight and cost are stored in separate lists based on their weight (1, 2, or 3).\n2. **Sorting and Prefix Sums**: For each weight category, the costs are sorted in descending order, and prefix sums are computed. These prefix sums allow quick calculation of the maximum cost achievable by taking up to `k` items of a specific weight.\n3. **Combination Iteration**: The algorithm iterates over all possible combinations of items from the three weight categories. For each combination, it checks if the total weight is within the limit and updates the maximum total cost accordingly.\n4. **Output**: The highest total cost found during the iteration is printed as the result.\n\nThis approach efficiently handles the constraints by leveraging the limited weight values (1, 2, 3) and using prefix sums to optimize the selection process. The solution ensures that the maximum cost is achieved without exceeding the weight limit.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(0)\n        return\n        \n    n = int(data[0])\n    m = int(data[1])\n    index = 2\n    type1 = []\n    type2 = []\n    type3 = []\n    \n    for i in range(n):\n        w = int(data[index])\n        c = int(data[index+1])\n        index += 2\n        if w == 1:\n            type1.append(c)\n        elif w == 2:\n            type2.append(c)\n        elif w == 3:\n            type3.append(c)\n            \n    type1.sort(reverse=True)\n    type2.sort(reverse=True)\n    type3.sort(reverse=True)\n    \n    len1 = len(type1)\n    len2 = len(type2)\n    len3 = len(type3)\n    \n    pre1 = [0] * (len1 + 1)\n    for i in range(1, len1 + 1):\n        pre1[i] = pre1[i-1] + type1[i-1]\n        \n    pre2 = [0] * (len2 + 1)\n    for i in range(1, len2 + 1):\n        pre2[i] = pre2[i-1] + type2[i-1]\n        \n    pre3 = [0] * (len3 + 1)\n    for i in range(1, len3 + 1):\n        pre3[i] = pre3[i-1] + type3[i-1]\n        \n    best = 0\n    max_count1 = m // 1\n    max_count2 = m // 2\n    max_count3 = m // 3\n    \n    for i in range(min(len1, max_count1) + 1):\n        rem = m - i\n        if rem < 0:\n            continue\n        cost1 = pre1[i]\n        count2 = min(len2, rem // 2)\n        cost2 = pre2[count2]\n        rem_after2 = rem - 2 * count2\n        count3 = min(len3, rem_after2 // 3)\n        cost3 = pre3[count3]\n        total = cost1 + cost2 + cost3\n        if total > best:\n            best = total\n            \n    for i in range(min(len1, max_count1) + 1):\n        rem = m - i\n        if rem < 0:\n            continue\n        cost1 = pre1[i]\n        count3 = min(len3, rem // 3)\n        cost3 = pre3[count3]\n        rem_after3 = rem - 3 * count3\n        count2 = min(len2, rem_after3 // 2)\n        cost2 = pre2[count2]\n        total = cost1 + cost2 + cost3\n        if total > best:\n            best = total\n            \n    for i in range(min(len2, max_count2) + 1):\n        rem = m - 2 * i\n        if rem < 0:\n            continue\n        cost2 = pre2[i]\n        count1 = min(len1, rem)\n        cost1 = pre1[count1]\n        rem_after1 = rem - count1\n        count3 = min(len3, rem_after1 // 3)\n        cost3 = pre3[count3]\n        total = cost2 + cost1 + cost3\n        if total > best:\n            best = total\n            \n    for i in range(min(len2, max_count2) + 1):\n        rem = m - 2 * i\n        if rem < 0:\n            continue\n        cost2 = pre2[i]\n        count3 = min(len3, rem // 3)\n        cost3 = pre3[count3]\n        rem_after3 = rem - 3 * count3\n        count1 = min(len1, rem_after3)\n        cost1 = pre1[count1]\n        total = cost2 + cost1 + cost3\n        if total > best:\n            best = total\n            \n    for i in range(min(len3, max_count3) + 1):\n        rem = m - 3 * i\n        if rem < 0:\n            continue\n        cost3 = pre3[i]\n        count1 = min(len1, rem)\n        cost1 = pre1[count1]\n        rem_after1 = rem - count1\n        count2 = min(len2, rem_after1 // 2)\n        cost2 = pre2[count2]\n        total = cost3 + cost1 + cost2\n        if total > best:\n            best = total\n            \n    for i in range(min(len3, max_count3) + 1):\n        rem = m - 3 * i\n        if rem < 0:\n            continue\n        cost3 = pre3[i]\n        count2 = min(len2, rem // 2)\n        cost2 = pre2[count2]\n        rem_after2 = rem - 2 * count2\n        count1 = min(len1, rem_after2)\n        cost1 = pre1[count1]\n        total = cost3 + cost2 + cost1\n        if total > best:\n            best = total\n            \n    print(best)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 477,
        "completion_token_count": 1617,
        "thoughts_token_count": 1023
    }
}