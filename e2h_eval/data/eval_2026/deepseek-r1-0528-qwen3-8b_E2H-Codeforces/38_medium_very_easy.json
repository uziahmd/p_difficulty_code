{
    "start": 1758300574.1132832,
    "end": 1758304430.557213,
    "start-formatted": "2025-09-20 01:49 KST",
    "end-formatted": "2025-09-20 02:53 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\n Okay, let's break down the problem.\n\n We are given an integer p (0 <= p <= 200000). We need to find:\n  1. The minimum number of nodes required to create a p-reachable directed graph.\n  2. Among all such graphs with the minimum number of nodes, the maximum number of unidirectional pairs.\n\n Definitions:\n - A directed graph is p-reachable if it contains exactly p ordered pairs (u, v) (with u < v) such that u and v are mutually reachable (i.e., there is a path from u to v and from v to u).\n\n Note: The condition \"exactly p ordered pairs (u, v) with u < v\" refers to the mutual reachability. However, note that the definition of unidirectional pair (u, v) requires that there is a path from u to v but not from v to u, and also u != v.\n\n Steps:\n\n 1. Understanding mutual reachability (strongly connected components, SCCs):\n    In a directed graph, the set of nodes that are mutually reachable forms strongly connected components (SCCs). But note: the problem counts only the pairs (u, v) with u < v. So if we have a set of k nodes that form a strongly connected component, then the number of mutual pairs (with u < v) in that component is C(k,2) = k*(k-1)//2.\n\n    However, note that the entire graph can be decomposed into strongly connected components (SCCs) and then we have edges between these components (like a DAG). But note: the condition for being p-reachable is that the total number of mutual pairs (i.e., pairs (u,v) with u<v and u and v mutually reachable) is exactly p.\n\n    But wait: in a DAG of SCCs, two nodes from different SCCs cannot be mutually reachable. So the mutual reachability only happens within an SCC. Therefore, the entire graph's mutual pairs are the sum over all SCCs of C(size_i, 2).\n\n    Let the graph have n nodes and let the SCCs have sizes s1, s2, ..., sm. Then the condition is:\n        sum_{i=1}^{m} [ s_i*(s_i-1)//2 ] = p\n\n    And we want to minimize n (the total number of nodes) such that there exists a decomposition of n nodes into SCCs (each node in one SCC) and the above equation holds.\n\n 2. What does the problem ask for?\n    - First integer: the minimum n (number of nodes) such that there exists a set of positive integers {s1, s2, ..., sm} (each at least 1) with sum(s_i) = n and sum_i [s_i*(s_i-1)//2] = p.\n\n    - Second integer: the maximum number of unidirectional pairs among all graphs with n nodes (minimum n) that satisfy the above.\n\n 3. How to think about the first part?\n\n    We are allowed to partition n nodes into SCCs. The mutual pairs are the sum of C(s_i,2) for each SCC.\n\n    We want to know the smallest n such that there is a partition of n into positive integers (each at least 1) and the sum of C(s_i,2) equals p.\n\n    Note: The function f(x) = x*(x-1)//2 is convex. Therefore, to minimize n (the total nodes) for a fixed sum of f(s_i)=p, we should use as few SCCs as possible? Actually, we want to minimize n, but note that the same p can be achieved by different decompositions.\n\n    Alternatively, we can think: what is the minimal n such that the maximum possible p' (which is the maximum mutual pairs we can have with n nodes) is at least p? But note: we need exactly p.\n\n    However, note: we are allowed to choose any decomposition. The mutual pairs must be exactly p.\n\n    But observe: we can also have multiple SCCs. The total mutual pairs is the sum of the pairs within each SCC.\n\n    Also note: the entire graph might not be strongly connected, so we can have multiple SCCs.\n\n    We can also consider: what is the maximum p we can get with n nodes? That is when we have one big SCC of size n: p_max(n) = C(n,2) = n*(n-1)//2.\n\n    Then, we are looking for the smallest n such that there exists a decomposition (partition) of n into positive integers (each at least 1) and the sum of the triangular numbers (for each part) is exactly p, and note that p must be between 0 and C(n,2).\n\n    But note: the problem says that the graph must be p-reachable, meaning the mutual pairs (counted for u<v) is exactly p.\n\n    However, note that the entire graph must have exactly p mutual pairs. Since the mutual pairs are the sum of the pairs within each SCC, we require:\n        p = sum_{i} C(s_i, 2)\n\n    And the total nodes n = sum_i s_i.\n\n    Now, we wish to minimize n for a given p.\n\n    We can consider that we are going to represent p as a sum of triangular numbers (without repetition, and the triangular numbers are for integers >=1). But note: we can use the same triangular number multiple times (if we have multiple SCCs of the same size).\n\n    However, we are allowed to break the graph arbitrarily. The minimal n is the minimal total number of nodes such that p can be written as the sum of C(s_i,2) for some positive integers s_i (each s_i>=1) and the sum of the s_i is n.\n\n    How to compute minimal n?\n\n    Observation:\n        We know that if we use one SCC of size k, then p = C(k,2). But we can also use multiple SCCs.\n\n        For example, p=3: \n            One SCC of size 3: C(3,2)=3 -> n=3.\n            Two SCCs: one of size 2 and one of size 1: C(2,2)=1, C(1,2)=0 -> total 1, which is less than 3.\n            Another two SCCs: one of size 3? no, wait: we need to break 3? Actually, if we break into three SCCs: [1,1,1] -> total 0, too low.\n\n        So the minimal n for p=3 is 3.\n\n        Example p=4: \n            One SCC: C(n,2)=4 -> n*(n-1)=8 -> n≈3, but 3 gives 3, 4 gives 6 -> so one SCC is not enough.\n            Two SCCs: possibilities: \n                [2,2]: then C(2,2)+C(2,2)=1+1=2 -> too low.\n                [3,1]: then 3 + 0 = 3 -> too low.\n            Three SCCs: \n                [2,1,1]: 1+0+0=1 -> too low.\n            Four SCCs: [1,1,1,1]: 0 -> too low.\n\n            Wait, how can we get 4? Actually, note: we can have more than one SCC and we can have an SCC of size 3 and then another of size 2? No, because 3+2=5 nodes and then the mutual pairs would be 3+1=4. So n=5.\n\n            Alternatively, we can have two SCCs of size 3? That would be n=6, and mutual pairs 3+3=6, which is too high.\n\n            Actually, we need to form 4 as the sum of triangular numbers (each triangular number is T_k = k*(k-1)//2). \n\n            We can use:\n                4 = T_3 + T_2? But T_3=3, T_2=1 -> 3+1=4. So we need an SCC of size 3 and an SCC of size 2, so total nodes=3+2=5.\n\n            But note: we can also use four triangular numbers? T_2+T_2+T_2+T_2 = 1+1+1+1=4, then we would have four SCCs of size 2, so n=8. But 8 is larger than 5, so we don't want that.\n\n        Therefore, we want to represent p as a sum of triangular numbers (each T_k>=0) and then the minimal n is the minimal total when we take the sum of the corresponding k's (each k is the size of an SCC).\n\n        However, note: the triangular numbers are defined for k>=1 (T_1=0, T_2=1, T_3=3, T_4=6, ...). So we can use zeros (but zeros correspond to SCCs of size 1, which don't contribute to p) but they add to n.\n\n        So the problem reduces to: represent p as a sum of triangular numbers (each T_k for k>=2, but note T_1=0 so we can also use zeros arbitrarily) and then the total n is the sum of the k's (each k being the size of an SCC). We wish to minimize the total n.\n\n        But note: we can use the same triangular number multiple times.\n\n        This is similar to the classic coin change problem where the coins are the triangular numbers, and we want to minimize the total value of the coins (the total value is p) but also the total number of nodes is the sum of the denominations (each denomination k gives T_k and adds k to the total n). However, we are allowed to use any triangular number (any k>=1) and we want to minimize the total n (sum of k) for a given p (sum of T_k).\n\n        However, note: the representation of p as a sum of triangular numbers is not unique, and we want to minimize the total n (the sum of the k's) for the given p.\n\n        We can use dynamic programming? But p up to 200000, and the triangular numbers grow as k^2/2, so k_max is about sqrt(2*p). For p=200000, k_max is about sqrt(400000) ~ 632.\n\n        But note: we are only interested in the minimal total n (the sum of the k's) for representing p as a sum of triangular numbers (allowing repetition). However, note: we are allowed to break the graph arbitrarily, so we can use any combination of SCCs.\n\n        Alternatively, we can think: what is the maximum p we can achieve with a given n? It is when we have one big SCC: T_n = n*(n-1)//2. But we can also break the graph arbitrarily. However, note that we are representing p as the sum of triangular numbers (each T_k) and the total n is the sum of the k's.\n\n        We are looking for the minimal n such that there exists a set of positive integers {k1, k2, ..., km} (each k_i>=1) with:\n            n = k1 + k2 + ... + km\n            p = T_{k1} + T_{k2} + ... + T_{km}\n\n        And we wish to minimize n.\n\n        How to minimize n? We want to use as few nodes as possible to represent p. Since T_k = k*(k-1)//2, we can use large k to cover more of p with fewer nodes.\n\n        Example: to get p=4, we used k1=3 (T_3=3) and k2=2 (T_2=1): total n=5. If we use two k=3's, then T_3+T_3=6, which is too much. But we can use one k=3 and one k=2, which gives 3+1=4, and n=5.\n\n        Why is 5 the minimal? Because if we try n=4: the maximum p we can get is T_4=6, but we can also break 4 into [4] -> p=6, or [3,1] -> p=3, or [2,2] -> p=2, or [2,1,1] -> p=1, or [1,1,1,1] -> p=0. None of these give 4.\n\n        Similarly, n=5: we can get p=4 by [3,2] (3+2=5, and 3+1=4). We can also get p=5? \n            [3,2] -> 3+1=4, so no. But we can get p=5 by [3,3] but that requires n=6, which is bigger.\n\n        So the minimal n is the minimal number such that there exists a representation of p as a sum of triangular numbers (each T_k) and the sum of the k's is n.\n\n        However, note: we are allowed to use the same triangular number multiple times.\n\n        How to compute the minimal n?\n\n        Observation: since T_k = k*(k-1)//2, we can also write the problem as: we wish to minimize the total k's (which is n) such that the sum of T_k's is p.\n\n        We can use a greedy approach: use the largest triangular number that is <= p, then subtract and continue.\n\n        But is that optimal for minimizing the total k? Not necessarily, because the goal is to minimize the sum of k's (the total nodes). \n\n        Example: p=4. \n            Using the largest triangular number <=4: T_3=3, then remainder=1 -> T_2=1, then we have k=3 and k=2, total n=5.\n\n        Example: p=5.\n            Largest triangular <=5: T_3=3, remainder=2 -> then we need T_2=1 and then T_2=1 again: so [3,2,2] -> n=3+2+2=7, but is that minimal?\n            Alternatively: T_3=3, and then two T_2's: 3+1+1=5, so n=3+2+2=7.\n\n            But wait, is there a way to get 5 with fewer nodes? \n            We can use T_3=3 and T_3=3? That gives 6, too much.\n            Or use T_4=6? too big.\n\n            Alternatively, we can use two T_3's? 3+3=6, too big. Or one T_3 and then two T_2's: 3+1+1=5, so n=3+2+2=7.\n\n            But wait, what if we use an SCC of size 3 and two SCCs of size 1? Then the mutual pairs: 3 + 0 + 0 = 3, not 5.\n\n            Actually, the representation is: we are breaking the graph into SCCs. The total mutual pairs is the sum of T_k for each SCC.\n\n            However, note: we can also use an SCC of size 4? Then T_4=6, which is too big. Or an SCC of size 3 and an SCC of size 2: that gives 3+1=4, not 5.\n\n            So 5 must be represented by three SCCs: one of size 3 and two of size 2? Then the total mutual pairs: 3+1+1=5, and n=3+2+2=7.\n\n            Alternatively, is there a triangular number representation for 5? \n                5 = 3 + 1 + 1 -> yes.\n\n            But note: the triangular numbers are T_1=0, T_2=1, T_3=3, T_4=6, etc. So we cannot use T_1 because then we are adding 0 to p and 1 to n. So we don't want to use T_1 unless necessary.\n\n            However, we can also consider: is there a representation with two SCCs? \n                Let the two SCCs have sizes k and l. Then T_k + T_l = 5.\n                Possibilities: \n                    k=3, l=2 -> 3+1=4 -> no.\n                    k=4, l=1 -> 6+0=6 -> no.\n                    k=3, l=3 -> 3+3=6 -> no.\n\n            So we must use at least three SCCs.\n\n        But note: the problem says that the graph must be p-reachable. There's no requirement on the structure between SCCs, so we can have multiple SCCs.\n\n        However, the minimal n for p=5 is 7.\n\n        But wait, the sample input provided:\n\n        Input: ['3', '4', '0']\n        Output: ['3 0', '5 6', '0 0']\n\n        So for p=3: output is 3 and 0.\n        For p=4: output is 5 and 6.\n\n        Now, what is the second integer? The maximum number of unidirectional pairs in a graph with n nodes (minimal n) that is p-reachable.\n\n        Definition of unidirectional pair (u, v): \n          - u != v\n          - there exists a path from u to v, but not from v to u.\n\n        In our graph, we have broken the graph into SCCs. Within an SCC, there are no unidirectional pairs (because from any node you can reach any other). Between two SCCs, say A and B, if there is an edge from A to B (but not from B to A), then for every u in A and v in B, (u, v) is a unidirectional pair (provided there is a path from A to B). But note: the problem does not require the graph to be connected. However, we can design the graph arbitrarily.\n\n        How to maximize the number of unidirectional pairs?\n\n        Consider: \n          - We have m SCCs (from the decomposition) with sizes s1, s2, ..., sm (and the sum of the s_i is n).\n          - The graph must have exactly p mutual pairs (so the sum of C(s_i,2) = p).\n\n        The total number of ordered pairs (u, v) with u != v is n*(n-1).\n\n        The graph can be seen as having:\n          - Mutual pairs: the pairs (u, v) that are in the same SCC and u and v are connected (which we already accounted for, and there are p such pairs with u<v, but note: the definition of unidirectional requires an ordered pair and the direction condition. However, note that the mutual pairs (both directions) are not counted as unidirectional. But the problem counts unidirectional pairs without the u<v condition? Actually, the definition says \"ordered pair (u, v)\" and then u != v, and the conditions on paths. So we are counting both (u, v) and (v, u) separately.\n\n        However, note: if (u, v) is unidirectional (from u to v but not back) then (v, u) cannot be unidirectional (since if we had a path from v to u, then the mutual condition would hold). But note: the graph might not have both directions even if they are in different SCCs.\n\n        Actually, the entire graph has:\n          - The mutual pairs: for each SCC, the pairs (u, v) with u and v in the same SCC and u->v and v->u exist (so they are not unidirectional). The rest of the pairs are either unidirectional or not present? \n\n        But note: the definition of unidirectional requires that there is a path from u to v and no path from v to u. The graph can have arbitrary edges between SCCs (as long as the condensation is a DAG). \n\n        How many unidirectional pairs are there?\n\n        Consider two distinct SCCs, say A and B. If there is an edge from A to B (or more generally, if there is a path from A to B but not from B to A), then every pair (u, v) with u in A and v in B is a unidirectional pair. Similarly, if there is an edge from B to A, then every pair (u, v) with u in B and v in A is unidirectional.\n\n        However, note: the condensation of the graph is a DAG. In a DAG, if we have two SCCs, then either there is a path from A to B or from B to A, but not both (unless they are connected by multiple paths and the entire condensation is not a strict DAG? Actually, no: in a DAG, the relation is acyclic, so if we have two nodes (SCCs) then we can have edges in one direction or none, but not both). However, we can have edges from A to B and from B to A? Then the entire component would become strongly connected. But wait, we defined the SCCs as maximal strongly connected components. So if we have edges in both directions, then A and B should be merged.\n\n        Therefore, the condensation is a DAG and the edges go only from one SCC to another in one direction. So between two distinct SCCs, we can have edges from A to B (meaning A can reach B) but not from B to A.\n\n        Then, the unidirectional pairs come from two parts:\n\n          Part 1: Pairs (u, v) such that u and v are in the same SCC: none (because within an SCC, both directions are present).\n\n          Part 2: Pairs (u, v) such that u and v are in different SCCs and there is a path from u's component to v's component (but not the reverse). \n\n        How many such pairs? For each ordered pair of distinct SCCs (A, B) (with A != B) and if there is a path from A to B (i.e., the edge from A to B exists in the condensation, or more generally, the DAG has an edge or a path from A to B), then every node in A can reach every node in B, but not vice versa. Therefore, for each ordered pair (A, B) (with A and B being different SCCs) that has a directed edge (in the condensation) from A to B, we get |A| * |B| unidirectional pairs (each u in A, v in B).\n\n        However, note: the problem does not require the graph to be connected. We can have arbitrary DAG structure on the SCCs. To maximize the unidirectional pairs, we want to maximize the total number of pairs (u, v) from different SCCs that have a path from u to v (and not from v to u). In a DAG, the relation is a partial order. The maximum number of edges (and hence maximum reachability) in a DAG is achieved by a total order (i.e., a linear order). In that case, for every two distinct SCCs, there is a directed edge (or a path) from one to the other. Specifically, if we order the SCCs as C1, C2, ..., Cm (a total order), then for any i < j, there is a path from Ci to Cj (and we can arrange the edges accordingly). Then the total unidirectional pairs from different SCCs is:\n\n          Sum_{i=1}^{m} Sum_{j=1, j != i}^{m} [ (if i < j then |Ci|*|Cj|, else 0) ]\n\n        But note: the DAG can be arranged arbitrarily. However, to maximize the unidirectional pairs, we want as many pairs (u, v) as possible to have a path from u to v (and not the reverse). The maximum is achieved when the condensation is a total order (linear). Then, the number of unidirectional pairs is:\n\n          TotalPairsBetweenSCCs = (TotalOrderedPairsBetweenSCCs) - (MutualPairsWithinSCCs)   [but wait, the mutual pairs are only within the same SCC, and between SCCs, if the condensation is a total order, then for two nodes in different SCCs, exactly one direction is possible (so no mutual reachability)].\n\n        Actually, the total number of ordered pairs (u, v) (with u != v) is n*(n-1). The mutual pairs (within SCCs) is p (given). The remaining pairs are:\n\n          n*(n-1) - 2*p   [because the mutual pairs are counted for both (u,v) and (v,u)? Actually, no: the problem counts mutual pairs by the condition u<v. But note: the definition of unidirectional requires an ordered pair (u, v) and then the condition. The mutual pairs (u and v) are counted twice in the entire graph? \n\n        However, note: the problem states that the graph is p-reachable, meaning the number of unordered pairs (with u<v) that are mutually reachable is p. But the entire graph has:\n\n          - For each SCC of size s: the number of mutual pairs (u, v) with u<v is C(s,2). And the entire graph has p = sum_i C(s_i,2).\n\n        Now, the entire graph has:\n\n          - Total ordered pairs (u, v) with u != v: n*(n-1)\n          - These are partitioned into:\n                - Mutual pairs: for each SCC, the pairs (u, v) and (v, u) (if u and v are in the same SCC) are mutual. But note: the problem does not count (u, v) and (v, u) separately for the mutual condition? Actually, the mutual condition is symmetric: if (u, v) is mutual then (v, u) is also mutual. However, the problem counts the mutual pairs by the condition \"exactly p ordered pairs (u, v) with u < v\". So the total mutual ordered pairs (considering both orders) is 2*p? \n\n        But wait, the problem says: \"exactly p ordered pairs of nodes (u, v) such that u < v and u and v are reachable from each other.\" \n\n        So the mutual condition is symmetric and we count only the pairs with u<v. Therefore, the entire graph has exactly p mutual pairs (each unordered pair is counted once, and then the reverse is also mutual but not counted because the condition u<v). \n\n        Now, the unidirectional pairs: they are ordered pairs (u, v) (with u != v) such that there is a path from u to v and not from v to u. \n\n        Therefore, the entire graph has:\n\n          - For each unordered pair (u, v) (u != v):\n            * If u and v are in the same SCC: then the pair is mutual. But note: the problem counts the mutual pairs by u<v, so we have exactly p such unordered pairs (each mutual unordered pair is counted once in p). Then the two ordered pairs (u, v) and (v, u) are mutual. So the total mutual ordered pairs is 2*p.\n\n          - For the remaining ordered pairs: n*(n-1) - 2*p, these are the ones that are not mutual. But note: in a directed graph, if (u, v) is not mutual, then either there is a path from u to v and not from v to u (then it is unidirectional) or there is no path in either direction? \n\n        However, the problem does not require the graph to be strongly connected or weakly connected. But note: the definition of unidirectional requires the existence of a path from u to v and the non-existence of a path from v to u. \n\n        But in our graph, we have broken the graph into SCCs and the condensation is a DAG. Then, for two nodes in different SCCs, say u in A and v in B, then either there is a path from A to B or from B to A, but not both. So in this case, exactly one of (u, v) or (v, u) is unidirectional.\n\n        However, wait: what if there is no path from A to B and no path from B to A? Then neither (u, v) nor (v, u) is unidirectional, and also they are not mutual. \n\n        But note: the problem does not require the graph to be connected. However, to maximize the unidirectional pairs, we can assume that the condensation is a total order (so that for every two distinct SCCs, there is a path in one direction). Then, for every ordered pair (u, v) with u and v in different SCCs, exactly one of (u, v) or (v, u) is unidirectional.\n\n        Therefore, the total unidirectional pairs is:\n\n          (Total ordered pairs between different SCCs) / 2 * 2? Actually, no:\n\n          The total ordered pairs between different SCCs is: n*(n-1) - (sum_{i} s_i*(s_i-1)) = n*(n-1) - 2*p.\n\n          But wait, the mutual pairs (within SCCs) account for 2*p (each unordered pair gives two ordered pairs). Then the remaining ordered pairs are n*(n-1) - 2*p, and these are exactly the ones that are either unidirectional or not connected. \n\n        However, in the condensation being a total order, every pair of nodes from different SCCs has exactly one direction (so one unidirectional and one not? Actually, no: for two nodes u and v in different SCCs, we have two ordered pairs: (u, v) and (v, u). In a total order, one of these two will be unidirectional (the one from the earlier SCC to the later) and the other is not (because the reverse path doesn't exist). \n\n        But wait, the definition requires the existence of a path from u to v and the non-existence of a path from v to u. In a total order, if we have a linear ordering of the SCCs, then for two distinct SCCs A and B, if A comes before B, then there is a path from A to B and not from B to A. Then the ordered pair (u, v) (u in A, v in B) is unidirectional, and the ordered pair (v, u) is not unidirectional (because there is no path from v to u) and also not mutual (because they are in different SCCs). \n\n        Actually, the definition of unidirectional requires the existence of a path from u to v and the non-existence of a path from v to u. So (v, u) is not unidirectional, but it is not mutual either (because mutual requires both). \n\n        Therefore, the total unidirectional pairs is:\n\n          For each ordered pair (A, B) of distinct SCCs (A and B) that has a path from A to B (and not from B to A), we have |A| * |B| unidirectional pairs.\n\n        And if the condensation is a total order, then for every unordered pair of distinct SCCs (A, B), there is exactly one direction (either A->B or B->A). Then the total unidirectional pairs is:\n\n          Sum_{i<j} (|C_i| * |C_j|)   [if we order the SCCs and take the product for each edge in the total order]?\n\n        Actually, no: the total order gives a linear arrangement. Then the unidirectional pairs from different SCCs is:\n\n          Sum_{i=1}^{m} Sum_{j=i+1}^{m} (|C_i| * |C_j|) * 2? \n\n        Wait, no: in the total order, if we have an ordering of the SCCs: C1, C2, ..., Cm, then for any two SCCs C_i and C_j (with i<j), we have a path from C_i to C_j, so the pairs (u, v) with u in C_i and v in C_j are unidirectional. Similarly, the pairs (u, v) with u in C_j and v in C_i are not unidirectional (because there's no path from C_j to C_i). \n\n        But note: the definition requires the existence of a path from u to v. For u in C_i and v in C_j (with i<j), we have a path from u to v. For u in C_j and v in C_i (with j>i), there is no path from u to v (because the total order goes from left to right). Therefore, the unidirectional pairs are only the pairs (u, v) with u in an earlier SCC and v in a later SCC.\n\n        Then the total unidirectional pairs is:\n\n          Sum_{i=1}^{m} Sum_{j=i+1}^{m} (|C_i| * |C_j|)   [this counts the pairs (u, v) from C_i to C_j for every i<j]\n\n        But note: we can also have edges that skip multiple SCCs? Actually, the total order implies that if we have edges from C_i to C_{i+1} and then from C_{i+1} to C_{i+2}, then there is a path from C_i to C_{i+2}. However, the existence of a path does not change the fact that the unidirectional pairs are counted for every pair (u, v) with u in an earlier SCC and v in a later SCC. And the total number of such pairs is the same as the number of edges in the complete directed acyclic graph (with all edges from earlier to later) multiplied by the sizes.\n\n        Alternatively, we can compute:\n\n          TotalUnidirectional = (1/2) * [ (Sum_i |C_i|)^2 - Sum_i |C_i|^2 ] - (something for the same SCC?) \n\n        But wait, the entire graph has:\n\n          Total ordered pairs (u, v) (u != v) = n*(n-1)\n\n          Mutual ordered pairs = 2*p\n\n          Then the remaining ordered pairs are n*(n-1) - 2*p.\n\n          And these remaining pairs are split into:\n            - Unidirectional: the ones that have a path from u to v but not from v to u.\n            - The ones that have no path in either direction.\n\n        In our condensation being a total order, there are no pairs with no path in either direction (because for any two nodes in different SCCs, there is a path in one direction). Therefore, the entire remaining pairs are unidirectional.\n\n        So the total unidirectional pairs is n*(n-1) - 2*p.\n\n        However, wait: in the total order, we have:\n\n          For two nodes in the same SCC: 2*p (mutual) and for two nodes in different SCCs: the entire set of ordered pairs (which is n*(n-1)-2*p) is unidirectional? \n\n        But note: the definition of unidirectional requires that there is a path from u to v and not from v to u. In the total order, for two nodes in different SCCs, there is always a path in one direction. So yes, the entire set of ordered pairs between different SCCs are unidirectional (one direction) and the reverse is not (so the reverse is absent). \n\n        However, note: the entire set of ordered pairs between different SCCs is n*(n-1) - 2*p. But wait, the mutual pairs are 2*p (because each mutual unordered pair gives two ordered pairs). Then the rest are n*(n-1)-2*p, and in the total order, all of them are unidirectional.\n\n        Therefore, the maximum number of unidirectional pairs we can have in a graph with n nodes (and fixed SCC decomposition) is n*(n-1) - 2*p.\n\n        But wait: is that independent of the decomposition? \n\n        Actually, no: the decomposition must be such that the sum of C(s_i,2) is p. Then the total n is fixed (the minimal n we found). And the unidirectional pairs is n*(n-1) - 2*p.\n\n        However, note: the problem asks for the maximum number of unidirectional pairs among all graphs with the minimal n that are p-reachable.\n\n        But wait: is the expression n*(n-1)-2*p always achievable? \n\n        Yes, because we can arrange the condensation as a total order (linear) and then all the inter-SCC pairs are unidirectional.\n\n        Therefore, the answer is:\n\n          First integer: the minimal n (number of nodes) such that there exists a decomposition of n into positive integers (the SCCs) with the sum of C(s_i,2) = p.\n\n          Second integer: n*(n-1) - 2*p.\n\n        Now, the challenge is to compute the minimal n for a given p.\n\n        How to compute the minimal n?\n\n        We are to represent p as a sum of triangular numbers (each T_k = k*(k-1)//2) and minimize the total n = sum_i (k_i) (where k_i is the size of the i-th SCC).\n\n        Note: we can use the same triangular number multiple times.\n\n        We can use dynamic programming:\n\n          Let dp[i] = minimal total n (nodes) needed to represent the integer i (i.e., p=i) as a sum of triangular numbers.\n\n          Then, we iterate i from 0 to p, and for each triangular number T_k (for k>=1) that is <= i, we do:\n\n            dp[i] = min_{k such that T_k <= i} { dp[i - T_k] + k }\n\n          But p can be up to 2000",
    "response": "\nTo solve this problem, we need to determine the minimum number of nodes required to create a directed graph that is p-reachable, and among all such graphs with the minimum number of nodes, find the maximum number of unidirectional node pairs.\n\n### Approach\n1. **Problem Analysis**:\n   - A directed graph is p-reachable if it contains exactly p ordered pairs (u, v) where u < v and u and v are mutually reachable (i.e., there is a path from u to v and from v to u).\n   - The mutual reachability between nodes implies they belong to the same strongly connected component (SCC). The number of such pairs in an SCC of size k is given by the triangular number \\( T_k = k*(k-1)/2 \\).\n   - The goal is to partition the nodes into SCCs such that the sum of their triangular numbers equals p, and the total number of nodes (sum of sizes of all SCCs) is minimized.\n\n2. **Key Insight**:\n   - The minimal number of nodes is found by representing p as a sum of triangular numbers (each corresponding to an SCC size) while minimizing the sum of these sizes.\n   - Once the minimal node count n is determined, the maximum number of unidirectional pairs (pairs where there is a path from u to v but not from v to u) is calculated as \\( n*(n-1) - 2*p \\). This is derived from the fact that all remaining ordered pairs (after accounting for mutual pairs) are unidirectional when the condensation of the graph is a total order.\n\n3. **Algorithm Selection**:\n   - **Dynamic Programming**: We use a dynamic programming approach to compute the minimal node count for each possible p up to the given value. The DP array `dp[i]` stores the minimal node count required to achieve exactly i mutual pairs.\n   - **Triangular Numbers**: For each p, we consider all possible triangular numbers \\( T_k \\) (for k from 1 upwards) and update the DP array accordingly.\n\n4. **Complexity Analysis**:\n   - The algorithm efficiently computes the solution for p up to 200,000 by leveraging dynamic programming and the properties of triangular numbers. The time complexity is linear with respect to p, making it suitable for large inputs.\n\n### Solution Code\n```python\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    p = int(data[0])\n    \n    if p == 0:\n        print(\"0 0\")\n        return\n        \n    dp = [0] * (p + 1)\n    for i in range(1, p + 1):\n        dp[i] = float('inf')\n        \n    for i in range(1, p + 1):\n        k = 1\n        while True:\n            t_val = k * (k - 1) // 2\n            if t_val > i:\n                break\n            if dp[i - t_val] != float('inf'):\n                dp[i] = min(dp[i], dp[i - t_val] + k)\n            k += 1\n            \n    n_nodes = dp[p]\n    if n_nodes == float('inf'):\n        n_nodes = p + 1  # Fallback, though theoretically should not happen for p>=1\n        print(f\"{n_nodes} 0\")\n    else:\n        unidirectional_pairs = n_nodes * (n_nodes - 1) - 2 * p\n        print(f\"{n_nodes} {unidirectional_pairs}\")\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input consists of a single integer p, which is read from standard input.\n2. **Special Case Handling**: If p is 0, the output is \"0 0\" since no nodes are needed and there are no unidirectional pairs.\n3. **Dynamic Programming Initialization**: The DP array `dp` is initialized to store the minimal node counts for each value from 0 to p.\n4. **DP Array Population**: For each value i from 1 to p, the algorithm checks all triangular numbers \\( T_k \\) (for k starting from 1) that are less than or equal to i. It updates `dp[i]` by considering the minimal node count from subtracting \\( T_k \\) from i and adding k to the result.\n5. **Result Calculation**: After computing the minimal node count `n_nodes`, the maximum number of unidirectional pairs is calculated as \\( n_nodes*(n_nodes - 1) - 2*p \\), which accounts for all non-mutual ordered pairs in the graph.\n6. **Output**: The results are printed, showing the minimal node count and the maximum unidirectional pairs.\n\nThis approach efficiently solves the problem by leveraging dynamic programming and properties of triangular numbers, ensuring optimal performance even for large values of p.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    p = int(data[0])\n    \n    if p == 0:\n        print(\"0 0\")\n        return\n        \n    dp = [0] * (p + 1)\n    for i in range(1, p + 1):\n        dp[i] = float('inf')\n        \n    for i in range(1, p + 1):\n        k = 1\n        while True:\n            t_val = k * (k - 1) // 2\n            if t_val > i:\n                break\n            if dp[i - t_val] != float('inf'):\n                dp[i] = min(dp[i], dp[i - t_val] + k)\n            k += 1\n            \n    n_nodes = dp[p]\n    if n_nodes == float('inf'):\n        n_nodes = p + 1  # Fallback, though theoretically should not happen for p>=1\n        print(f\"{n_nodes} 0\")\n    else:\n        unidirectional_pairs = n_nodes * (n_nodes - 1) - 2 * p\n        print(f\"{n_nodes} {unidirectional_pairs}\")\n\nif __name__ == '__main__':\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 475,
        "completion_token_count": 1031,
        "thoughts_token_count": 8191
    }
}