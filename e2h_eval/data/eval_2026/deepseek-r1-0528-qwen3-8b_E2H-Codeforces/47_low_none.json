{
    "start": 1758296421.3275537,
    "end": 1758299299.8787768,
    "start-formatted": "2025-09-20 00:40 KST",
    "end-formatted": "2025-09-20 01:28 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\n Okay, let's analyze the problem:\n\nWe are given two integers a and b (with 1 <= a, b <= 10^9). We need to find a non-negative integer k such that:\n   LCM(a+k, b+k) is minimized.\n\nNote: If multiple k yield the same minimal LCM, choose the smallest k.\n\nLet d = gcd(a+k, b+k). Then we know:\n   LCM(a+k, b+k) = (a+k)*(b+k) / d.\n\nAlso note that (a+k) - (b+k) = a-b (a constant). So the difference between the two numbers is fixed.\n\nLet x = a+k, y = b+k, then x-y = a-b (which we can denote as D = |a-b|, but actually we don't know which is bigger, so let's keep it as a-b or just consider absolute value? Actually, note: if a < b, then after adding k, x becomes a+k and y becomes b+k, and then x-y = a-b (negative). But we can assume without loss of generality that we consider the absolute difference? Actually, we can work with the equation:\n\n   Let g = gcd(x, y). Then g divides (x-y) = a-b. So g must be a divisor of |a-b|.\n\nTherefore, we can consider all divisors g of |a-b|. However, note: what if a == b?\n   Then |a-b| = 0, and divisors of 0 are undefined? Actually, if a == b, then for any k, we have two identical numbers: a+k and b+k. Then LCM(a+k, a+k) = a+k. We want to minimize a+k, so we choose k=0.\n\nBut note: the problem says \"non-negative integer k\", and if a==b, then k=0 gives the smallest LCM (since a+k is minimized when k=0).\n\nSo in general, we can break down:\n\nCase 1: a == b -> then k=0 is the answer.\n\nCase 2: a != b.\n\nThen the gcd g must divide |a-b|. However, note that g also has to satisfy:\n   There exists k>=0 such that g divides both (a+k) and (b+k). Moreover, we can express k in terms of g.\n\nBut note: we are free to choose k. The condition is that g divides (a+k) and (b+k). Then g divides (a+k) - (b+k) = a-b. So g is a divisor of |a-b|.\n\nNow, for a fixed divisor g (which is positive) of |a-b|, we can set:\n   (a+k) ≡ 0 (mod g)\n   (b+k) ≡ 0 (mod g)\n\nBut note: subtracting these two, we get (a-b) ≡ 0 (mod g), which is true because g divides |a-b|.\n\nNow, from (a+k) ≡ 0 (mod g), we have k ≡ (-a) mod g. Similarly, k ≡ (-b) mod g.\n\nBut note: (-a) mod g is the same as (g - a % g) if a % g !=0, but actually we can define k_min(g) as the smallest non-negative k such that g divides (a+k). That is:\n\n   k_min(g) = (g - a % g) % g\n\nHowever, note: if a % g == 0, then k_min(g)=0. Otherwise, we need to add (g - a%g) to a to make it divisible by g.\n\nBut wait: we have two conditions. Actually, we have two congruences. However, note that the two congruences are consistent because (a+k) and (b+k) must be congruent modulo g (since (a+k)-(b+k)=a-b is divisible by g). So we can use either one.\n\nThus, for each divisor g of |a-b|, we can compute k0 = (g - a % g) % g (which is the smallest non-negative k that makes a+k divisible by g). Then the corresponding LCM would be:\n\n   LCM = (a+k0)*(b+k0) // g   [because gcd(a+k0, b+k0) must be at least g? Actually, note: the gcd might be larger than g? \n\nWait, no: we are fixing g as the divisor of |a-b|, but note: the gcd of (a+k0, b+k0) might be a multiple of g? Actually, no: we have that g divides (a+k0) and (b+k0). But the gcd might be exactly g or a multiple of g? \n\nHowever, observe: the gcd of (a+k",
    "response": "\nTo solve this problem, we need to find a non-negative integer \\( k \\) such that the least common multiple (LCM) of \\( a+k \\) and \\( b+k \\) is minimized. If multiple values of \\( k \\) yield the same minimal LCM, we should choose the smallest \\( k \\).\n\n### Approach\n1. **Problem Analysis**: The key observation here is that the difference between \\( a+k \\) and \\( b+k \\) is constant (\\( a - b \\)). The greatest common divisor (gcd) of \\( a+k \\) and \\( b+k \\) must be a divisor of this constant difference. Therefore, we can consider all divisors of \\( |a - b| \\) to determine potential values of \\( k \\).\n\n2. **Special Case Handling**: If \\( a \\) equals \\( b \\), the LCM of \\( a+k \\) and \\( b+k \\) is simply \\( a+k \\). To minimize this, the smallest \\( k \\) (which is 0) is chosen.\n\n3. **Divisor Enumeration**: For cases where \\( a \\neq b \\), we compute all divisors of \\( |a - b| \\). For each divisor \\( g \\), we calculate the smallest \\( k \\) such that both \\( a+k \\) and \\( b+k \\) are divisible by \\( g \\). This \\( k \\) is given by \\( (g - (a \\% g)) \\% g \\).\n\n4. **LCM Calculation**: For each candidate \\( k \\), compute the LCM of \\( a+k \\) and \\( b+k \\). The LCM is calculated as \\( \\frac{(a+k) \\times (b+k)}{\\text{gcd}(a+k, b+k)} \\). We keep track of the minimal LCM encountered and the corresponding smallest \\( k \\).\n\n5. **Result Selection**: After evaluating all divisors, the solution is the smallest \\( k \\) that yields the minimal LCM.\n\n### Solution Code\n```python\nimport math\nfrom functools import reduce\nimport sys\n\ndef get_divisors(n):\n    if n == 0:\n        return set()\n    divisors = set()\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n        i += 1\n    return divisors\n\ndef main():\n    data = sys.stdin.read().split()\n    a = int(data[0])\n    b = int(data[1])\n    \n    if a == b:\n        print(0)\n        return\n        \n    D = abs(a - b)\n    divisors = get_divisors(D)\n    candidates = {}\n    \n    for g in divisors:\n        k0 = (g - a % g) % g\n        if k0 not in candidates:\n            x = a + k0\n            y = b + k0\n            g_val = math.gcd(x, y)\n            lcm_val = x * y // g_val\n            candidates[k0] = lcm_val\n            \n    best_k = None\n    best_lcm = None\n    \n    for k, lcm_val in candidates.items():\n        if best_lcm is None or lcm_val < best_lcm:\n            best_lcm = lcm_val\n            best_k = k\n        elif lcm_val == best_lcm and k < best_k:\n            best_k = k\n            \n    print(best_k)\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input consists of two integers \\( a \\) and \\( b \\).\n2. **Special Case Handling**: If \\( a \\) equals \\( b \\), the solution immediately returns \\( k = 0 \\) since the LCM is minimized at this point.\n3. **Divisor Calculation**: The function `get_divisors` computes all divisors of \\( |a - b| \\), which helps in determining potential values of \\( k \\).\n4. **Candidate Generation**: For each divisor \\( g \\), the smallest \\( k \\) that makes both \\( a+k \\) and \\( b+k \\) divisible by \\( g \\) is calculated. The LCM for each such \\( k \\) is then computed.\n5. **Optimal \\( k \\) Selection**: The algorithm keeps track of the minimal LCM encountered and the corresponding smallest \\( k \\). If multiple \\( k \\) values yield the same minimal LCM, the smallest \\( k \\) is chosen.\n6. **Output**: The optimal \\( k \\) is printed as the result.\n\nThis approach efficiently narrows down the search space by leveraging mathematical properties of divisors and gcd, ensuring optimal performance even for large values of \\( a \\) and \\( b \\).",
    "ground_truth": "N/A",
    "extracted_answer": "import math\nfrom functools import reduce\nimport sys\n\ndef get_divisors(n):\n    if n == 0:\n        return set()\n    divisors = set()\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n        i += 1\n    return divisors\n\ndef main():\n    data = sys.stdin.read().split()\n    a = int(data[0])\n    b = int(data[1])\n    \n    if a == b:\n        print(0)\n        return\n        \n    D = abs(a - b)\n    divisors = get_divisors(D)\n    candidates = {}\n    \n    for g in divisors:\n        k0 = (g - a % g) % g\n        if k0 not in candidates:\n            x = a + k0\n            y = b + k0\n            g_val = math.gcd(x, y)\n            lcm_val = x * y // g_val\n            candidates[k0] = lcm_val\n            \n    best_k = None\n    best_lcm = None\n    \n    for k, lcm_val in candidates.items():\n        if best_lcm is None or lcm_val < best_lcm:\n            best_lcm = lcm_val\n            best_k = k\n        elif lcm_val == best_lcm and k < best_k:\n            best_k = k\n            \n    print(best_k)\n\nif __name__ == '__main__':\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 388,
        "completion_token_count": 996,
        "thoughts_token_count": 1023
    }
}