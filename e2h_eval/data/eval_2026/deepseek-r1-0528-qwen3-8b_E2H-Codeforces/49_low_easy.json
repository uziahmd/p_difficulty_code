{
    "start": 1758303158.7882743,
    "end": 1758306622.5876522,
    "start-formatted": "2025-09-20 02:32 KST",
    "end-formatted": "2025-09-20 03:30 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\n Okay, we are given a graph with n nodes and m edges. For each edge (u, v), we are given two numbers: gcd and lcm.\n We know that for two numbers a and b (the mushrooms on the two lawns connected by the edge), we have:\n   gcd(a, b) = g\n   lcm(a, b) = l\n And we also know that for two numbers: \n   a * b = g * l   (since lcm(a,b) * gcd(a,b) = a * b)\n\n Moreover, note that we can write a and b in terms of their gcd:\n   a = g * x\n   b = g * y\n where x and y are coprime integers (gcd(x, y) = 1).\n\n Then, the condition on the LCM is:\n   lcm(a, b) = g * x * y   (because lcm(g*x, g*y) = g * lcm(x,y) and since x and y are coprime, lcm(x,y)=x*y)\n\n So we must have: g * x * y = l   =>   x * y = l // g.\n\n But note: it is necessary that g divides l and that l//g is an integer. Also, x and y must be coprime and factors of l//g.\n\n However, the problem is to assign to each lawn (vertex) a positive integer (at least 1) such that for every edge (u, v):\n   gcd(a[u], a[v]) = given_gcd, and\n   lcm(a[u], a[v]) = given_lcm.\n\n Alternatively, we can think: for each node, we can assign a value which is the product of primes raised to some exponents.\n But note: the constraints say that the numbers on the roads were at least 1 and at most 10^6, but the lawn numbers can be up to 10^6? Actually, the input constraints say the GCD and LCM are between 1 and 10^6, but the original numbers could be up to 10^6 as well? Or maybe larger? \n\n However, note: the condition a * b = g * l. Since g and l are at most 10^6, then a and b cannot exceed 10^6 * 10^6 (which is 1e12). But wait, the problem says \"It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106\", meaning the GCD and LCM are in [1,10^6]. The lawn numbers (a and b) must be divisors of numbers that are products (g*l) which is up to 10^12, so we have to be cautious.\n\n Approach:\n\n One idea: use the fact that the entire graph must be consistent. We can try to assign to each node a value that is the product of prime factors.\n\n However, note: we are not required to find all solutions, just one.\n\n Steps:\n\n 1. Check for each edge that the given gcd divides the lcm. If not, output \"NO\".\n\n 2. For each edge, we know that the two numbers must be multiples of the gcd, and the ratio (lcm / gcd) must be the product of two coprime integers (the cofactors). But note: the same node might appear in multiple edges, so we need to assign a single number for each node.\n\n Alternate approach:\n\n Let's denote by x_i the number of mushrooms on lawn i.\n\n For an edge (u, v) with given (g, l):\n   Condition 1: x_u and x_v must both be divisible by g.\n   Condition 2: x_u * x_v = g * l.\n\n But wait, actually: \n   Condition 1: g = gcd(x_u, x_v)\n   Condition 2: l = lcm(x_u, x_v) = (x_u * x_v) / g   => x_u * x_v = g * l.\n\n So for each edge, the product of the two numbers must be g*l.\n\n However, note: the product condition alone does not guarantee that the gcd is exactly g. For example, if we set x_u = g * a, x_v = g * b, then the product is g^2 * a * b, and we require g^2 * a * b = g * l => g * a * b = l. So we must have a * b = l / g, and also gcd(a, b) must be 1 (so that the overall gcd is g).\n\n So for an edge (u, v): \n   Let k = l // g. Then k must be an integer (if not, return \"NO\"). Then we need two factors a and b of k (possibly not necessarily divisors, but",
    "response": "\nTo solve this problem, we need to determine if it's possible to assign numbers of mushrooms to each lawn in a forest such that for every given road (edge) between two lawns, the greatest common divisor (GCD) and least common multiple (LCM) of the numbers on the connected lawns match the provided values. \n\n### Approach\n1. **Problem Analysis**: The key observation here is that for any two numbers \\(a\\) and \\(b\\), the product \\(a \\times b\\) must equal the product of their GCD and LCM, i.e., \\(a \\times b = \\text{GCD}(a, b) \\times \\text{LCM}(a, b)\\). Additionally, the numbers must be multiples of their GCD. \n\n2. **Edge Validation**: For each edge, check if the provided GCD divides the LCM. If not, the arrangement is impossible. \n\n3. **Graph Construction**: Construct an undirected graph where each node represents a lawn, and edges represent roads with their respective GCD and LCM values.\n\n4. **Prime Factorization Insight**: Each number can be represented by its prime factorization. The GCD of two numbers will have exponents as the minimum of corresponding exponents in their factorizations, while the LCM will have exponents as the maximum. \n\n5. **Consistency Check**: For each node, the assigned number must be consistent across all its edges. This means for any two edges connected to the same node, the exponents of each prime factor in the node's number must satisfy the constraints derived from the edges.\n\n6. **Solution Assignment**: Assign to each node a number that is the product of primes raised to the minimum exponents required by all its incident edges. This ensures that the GCD and LCM conditions are met for all edges.\n\n### Solution Code\n```python\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    edges = []\n    index = 2\n    for i in range(m):\n        u = int(data[index]); v = int(data[index+1]); \n        g = int(data[index+2]); l_val = int(data[index+3])\n        index += 4\n        edges.append((u-1, v-1, g, l_val))\n        \n    graph = [[] for _ in range(n)]\n    for u, v, g, l_val in edges:\n        if l_val % g != 0:\n            print(\"NO\")\n            return\n        graph[u].append((v, g, l_val))\n        graph[v].append((u, g, l_val))\n        \n    factors_needed = [dict() for _ in range(n)]\n    for i in range(n):\n        factors_needed[i] = {}\n        \n    for u, v, g, l_val in edges:\n        k = l_val // g\n        factors = defaultdict(int)\n        temp = k\n        d = 2\n        while d * d <= temp:\n            while temp % d == 0:\n                factors[d] += 1\n                temp //= d\n            d += 1\n        if temp > 1:\n            factors[temp] += 1\n            \n        for p, exp in factors.items():\n            graph[u][0] = (v, g, l_val)\n            graph[v][0] = (u, g, l_val)\n            \n            if p not in factors_needed[u]:\n                factors_needed[u][p] = 0\n            if p not in factors_needed[v]:\n                factors_needed[v][p] = 0\n                \n            factors_needed[u][p] = max(factors_needed[u][p], exp)\n            factors_needed[v][p] = max(factors_needed[v][p], exp)\n            \n    result = [1] * n\n    for i in range(n):\n        for p, exp in factors_needed[i].items():\n            result[i] *= (p ** exp)\n            \n    for u, v, g, l_val in edges:\n        a = result[u]\n        b = result[v]\n        if a % g != 0 or b % g != 0:\n            print(\"NO\")\n            return\n        if a * b != g * l_val:\n            print(\"NO\")\n            return\n            \n    print(\"YES\")\n    print(\" \".join(map(str, result)))\n    \nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Input Parsing**: The input is read and parsed into the number of lawns \\(n\\) and roads \\(m\\), followed by the details of each road (edges) including the lawns they connect and their respective GCD and LCM values.\n\n2. **Edge Validation**: For each edge, it checks if the GCD divides the LCM. If not, the solution immediately outputs \"NO\" since the conditions cannot be satisfied.\n\n3. **Graph Construction**: An adjacency list is built to represent the graph structure, where each node points to its connected edges with their GCD and LCM values.\n\n4. **Prime Factorization Handling**: For each edge, the ratio \\(k = \\text{LCM} / \\text{GCD}\\) is factorized into its prime factors. The exponents of these primes are recorded for both nodes connected by the edge, ensuring that the node's number must include at least these exponents to satisfy the edge's conditions.\n\n5. **Result Calculation**: Each node's mushroom count is computed as the product of primes raised to the maximum exponents required by any of its incident edges. This ensures consistency across all edges connected to the node.\n\n6. **Final Validation**: After computing the potential mushroom counts, the solution verifies that for every edge, the GCD and LCM conditions are met. If all conditions are satisfied, it outputs \"YES\" followed by the mushroom counts; otherwise, it outputs \"NO\".\n\nThis approach efficiently checks the feasibility of the mushroom arrangement and computes a valid assignment if possible, leveraging prime factorization and graph traversal to ensure consistency across all edges.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import defaultdict\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    edges = []\n    index = 2\n    for i in range(m):\n        u = int(data[index]); v = int(data[index+1]); \n        g = int(data[index+2]); l_val = int(data[index+3])\n        index += 4\n        edges.append((u-1, v-1, g, l_val))\n        \n    graph = [[] for _ in range(n)]\n    for u, v, g, l_val in edges:\n        if l_val % g != 0:\n            print(\"NO\")\n            return\n        graph[u].append((v, g, l_val))\n        graph[v].append((u, g, l_val))\n        \n    factors_needed = [dict() for _ in range(n)]\n    for i in range(n):\n        factors_needed[i] = {}\n        \n    for u, v, g, l_val in edges:\n        k = l_val // g\n        factors = defaultdict(int)\n        temp = k\n        d = 2\n        while d * d <= temp:\n            while temp % d == 0:\n                factors[d] += 1\n                temp //= d\n            d += 1\n        if temp > 1:\n            factors[temp] += 1\n            \n        for p, exp in factors.items():\n            graph[u][0] = (v, g, l_val)\n            graph[v][0] = (u, g, l_val)\n            \n            if p not in factors_needed[u]:\n                factors_needed[u][p] = 0\n            if p not in factors_needed[v]:\n                factors_needed[v][p] = 0\n                \n            factors_needed[u][p] = max(factors_needed[u][p], exp)\n            factors_needed[v][p] = max(factors_needed[v][p], exp)\n            \n    result = [1] * n\n    for i in range(n):\n        for p, exp in factors_needed[i].items():\n            result[i] *= (p ** exp)\n            \n    for u, v, g, l_val in edges:\n        a = result[u]\n        b = result[v]\n        if a % g != 0 or b % g != 0:\n            print(\"NO\")\n            return\n        if a * b != g * l_val:\n            print(\"NO\")\n            return\n            \n    print(\"YES\")\n    print(\" \".join(map(str, result)))\n    \nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 552,
        "completion_token_count": 1279,
        "thoughts_token_count": 1023
    }
}