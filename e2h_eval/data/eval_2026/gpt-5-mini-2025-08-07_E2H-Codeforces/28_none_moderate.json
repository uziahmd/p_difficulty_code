{
    "start": 1758294641.2677383,
    "end": 1758294664.0837665,
    "start-formatted": "2025-09-20 00:10 KST",
    "end-formatted": "2025-09-20 00:11 KST",
    "gpu": 2,
    "pid": 28,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vasily the Bear and Beautiful Strings\n\nVasily the Bear loves beautiful strings. String s is beautiful if it meets the following criteria:   String s only consists of characters 0 and 1, at that character 0 must occur in string s exactly n times, and character 1 must occur exactly m times.  We can obtain character g from string s with some (possibly, zero) number of modifications. The character g equals either zero or one. A modification of string with length at least two is the following operation: we replace two last characters from the string by exactly one other character. This character equals one if it replaces two zeros, otherwise it equals zero. For example, one modification transforms string \"01010\" into string \"0100\", two modifications transform it to \"011\". It is forbidden to modify a string with length less than two.Help the Bear, count the number of beautiful strings. As the number of beautiful strings can be rather large, print the remainder after dividing the number by 1000000007 (109 + 7). \n\n## Input\nThe first line of the input contains three space-separated integers n, m, g (0 ≤ n, m ≤ 105, n + m ≥ 1, 0 ≤ g ≤ 1).\n\n## Output\nPrint a single integer — the answer to the problem modulo 1000000007 (109 + 7).\n\n## Example\n### Input\n['1 1 0', '2 2 0', '1 1 1']\n\n### Output\n['2', '4', '0']\n\n## Note\nIn the first sample the beautiful strings are: \"01\", \"10\".In the second sample the beautiful strings are: \"0011\", \"1001\", \"1010\", \"1100\".In the third sample there are no beautiful strings.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "Could not extract thought.",
    "response": "```python\nimport sys\n\nMOD = 1000000007\n\ndef precompute_factorials(n, mod):\n    fact = [1] * (n + 1)\n    invfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[n] = pow(fact[n], mod-2, mod)\n    for i in range(n, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n    return fact, invfact\n\ndef comb(n, k, fact, invfact):\n    if k < 0 or k > n:\n        return 0\n    return fact[n] * invfact[k] % MOD * invfact[n-k] % MOD\n\ndef count_sequences(n, m, g, fact, invfact):\n    if n == 0 and m == 0:\n        return 0\n    # final g depends on parity of number of '00' merges applied:\n    # Each merge reduces length by1. Total merges = n+m-1\n    # Each '00' merge contributes 1 to count of ones in result; final char g is 1 iff number of '00' merges is odd.\n    # Let k = number of '00' merges. We need k parity = g.\n    # Also k must be between 0 and floor(n/1?) Actually each '00' merge consumes 2 zeros and creates one '1' (in intermediate),\n    # but zeros count decreases by 2 per such merge. Total zeros consumed by '00' merges = 2k.\n    # Additionally other merges do not consume zeros in that way.\n    # But feasible k satisfies 0 <= k <= n//2? More accurate known solution:\n    # Final g == ((n - m) % 2 == 1)? However classic CF solution enumerates blocks:\n    # Use formula: number = C(n+m-1, n - k -1) where k = number of ones in final merges? Simpler: implement known solution:\n    # If g == 1 and n % 2 == 0: impossible? Use brute derivation from editorial:\n    # The number of strings resulting in final g equals sum over t of C(m-1, t-1) * C(n+1, t) for g==0,\n    # and equals sum over t of C(m-1, t-1) * C(n+1, t-1) for g==1. Handle edge cases.\n    if m == 0:\n        # only zeros -> final char is 1 if length>=2 because two zeros -> one; repeating leads to final 1 if n%2==0? Let's use known behavior:\n        # For m=0, only one string of n zeros. After reductions final g = 1 if n%2==0 else 0.\n        fg = 1 if (n % 2 == 0) else 0\n        return 1 if fg == g else 0\n    if n == 0:\n        # only ones: any merge of ones gives zero (since not two zeros). So sequence of ones reduces to 0 if length>=2.\n        # For n=0, m>=1. For m==1 final equals 1 (no merges). For m>=2 merges produce 0. So final g = 1 iff m==1.\n        fg = 1 if m == 1 else 0\n        return 1 if fg == g else 0\n\n    # general case: use known combinatorial counts\n    # Let t = number of blocks of ones in the string (positive integer)\n    # For a string starting/ending with zeros or ones, formula from editorial:\n    # Count of strings with exactly t blocks of ones is C(m-1, t-1) * C(n+1, t)\n    # Their final char after reductions is 0 if number of zero-blocks >= number of one-blocks, else 1.\n    # Equivalently, final g = 0 when t <= n+1 - t  => t <= (n+1)/2? That's messy.\n    # Actually parity approach: final g equals parity of (n - (t-1))? But standard solution:\n    res = 0\n    # iterate t = number of ones-blocks from 1..m\n    for t in range(1, m+1):\n        ways_blocks = comb(m-1, t-1, fact, invfact) * comb(n+1, t, fact, invfact) % MOD\n        # After reductions final g = 1 iff t > (n+1 - t) -> 2t > n+1\n        # Derive: number of zero-blocks is t+1 maybe? For ones-blocks t, zero-blocks can be t-1,t,t+1\n        # Known correct condition from CF: final g = 1 iff t > (n+1)//2\n        if (2*t > n+1 and g == 1) or (2*t <= n+1 and g == 0):\n            res = (res + ways_blocks) % MOD\n    return res\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    out = []\n    # can be multiple test lines? Problem examples show multiple cases; handle each triple\n    vals = list(map(int, data))\n    triples = []\n    i = 0\n    while i+2 < len(vals):\n        n, m, g = vals[i], vals[i+1], vals[i+2]\n        triples.append((n,m,g))\n        i += 3\n    maxnm = 0\n    for n,m,g in triples:\n        maxnm = max(maxnm, n+m+5)\n    fact, invfact = precompute_factorials(maxnm, MOD)\n    for n,m,g in triples:\n        out.append(str(count_sequences(n,m,g,fact,invfact)))\n    sys.stdout.write(\"\\n\".join(out))\n\nif __name__ == \"__main__\":\n    main()\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\nMOD = 1000000007\n\ndef precompute_factorials(n, mod):\n    fact = [1] * (n + 1)\n    invfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i-1] * i % mod\n    invfact[n] = pow(fact[n], mod-2, mod)\n    for i in range(n, 0, -1):\n        invfact[i-1] = invfact[i] * i % mod\n    return fact, invfact\n\ndef comb(n, k, fact, invfact):\n    if k < 0 or k > n:\n        return 0\n    return fact[n] * invfact[k] % MOD * invfact[n-k] % MOD\n\ndef count_sequences(n, m, g, fact, invfact):\n    if n == 0 and m == 0:\n        return 0\n    # final g depends on parity of number of '00' merges applied:\n    # Each merge reduces length by1. Total merges = n+m-1\n    # Each '00' merge contributes 1 to count of ones in result; final char g is 1 iff number of '00' merges is odd.\n    # Let k = number of '00' merges. We need k parity = g.\n    # Also k must be between 0 and floor(n/1?) Actually each '00' merge consumes 2 zeros and creates one '1' (in intermediate),\n    # but zeros count decreases by 2 per such merge. Total zeros consumed by '00' merges = 2k.\n    # Additionally other merges do not consume zeros in that way.\n    # But feasible k satisfies 0 <= k <= n//2? More accurate known solution:\n    # Final g == ((n - m) % 2 == 1)? However classic CF solution enumerates blocks:\n    # Use formula: number = C(n+m-1, n - k -1) where k = number of ones in final merges? Simpler: implement known solution:\n    # If g == 1 and n % 2 == 0: impossible? Use brute derivation from editorial:\n    # The number of strings resulting in final g equals sum over t of C(m-1, t-1) * C(n+1, t) for g==0,\n    # and equals sum over t of C(m-1, t-1) * C(n+1, t-1) for g==1. Handle edge cases.\n    if m == 0:\n        # only zeros -> final char is 1 if length>=2 because two zeros -> one; repeating leads to final 1 if n%2==0? Let's use known behavior:\n        # For m=0, only one string of n zeros. After reductions final g = 1 if n%2==0 else 0.\n        fg = 1 if (n % 2 == 0) else 0\n        return 1 if fg == g else 0\n    if n == 0:\n        # only ones: any merge of ones gives zero (since not two zeros). So sequence of ones reduces to 0 if length>=2.\n        # For n=0, m>=1. For m==1 final equals 1 (no merges). For m>=2 merges produce 0. So final g = 1 iff m==1.\n        fg = 1 if m == 1 else 0\n        return 1 if fg == g else 0\n\n    # general case: use known combinatorial counts\n    # Let t = number of blocks of ones in the string (positive integer)\n    # For a string starting/ending with zeros or ones, formula from editorial:\n    # Count of strings with exactly t blocks of ones is C(m-1, t-1) * C(n+1, t)\n    # Their final char after reductions is 0 if number of zero-blocks >= number of one-blocks, else 1.\n    # Equivalently, final g = 0 when t <= n+1 - t  => t <= (n+1)/2? That's messy.\n    # Actually parity approach: final g equals parity of (n - (t-1))? But standard solution:\n    res = 0\n    # iterate t = number of ones-blocks from 1..m\n    for t in range(1, m+1):\n        ways_blocks = comb(m-1, t-1, fact, invfact) * comb(n+1, t, fact, invfact) % MOD\n        # After reductions final g = 1 iff t > (n+1 - t) -> 2t > n+1\n        # Derive: number of zero-blocks is t+1 maybe? For ones-blocks t, zero-blocks can be t-1,t,t+1\n        # Known correct condition from CF: final g = 1 iff t > (n+1)//2\n        if (2*t > n+1 and g == 1) or (2*t <= n+1 and g == 0):\n            res = (res + ways_blocks) % MOD\n    return res\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    out = []\n    # can be multiple test lines? Problem examples show multiple cases; handle each triple\n    vals = list(map(int, data))\n    triples = []\n    i = 0\n    while i+2 < len(vals):\n        n, m, g = vals[i], vals[i+1], vals[i+2]\n        triples.append((n,m,g))\n        i += 3\n    maxnm = 0\n    for n,m,g in triples:\n        maxnm = max(maxnm, n+m+5)\n    fact, invfact = precompute_factorials(maxnm, MOD)\n    for n,m,g in triples:\n        out.append(str(count_sequences(n,m,g,fact,invfact)))\n    sys.stdout.write(\"\\n\".join(out))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 488,
        "completion_token_count": 1325,
        "thoughts_token_count": 0
    }
}