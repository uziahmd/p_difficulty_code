{
    "start": 1758313552.0874407,
    "end": 1758313942.5967293,
    "start-formatted": "2025-09-20 05:25 KST",
    "end-formatted": "2025-09-20 05:32 KST",
    "gpu": 2,
    "pid": 6,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\nOkay, I need to solve this programming problem. Let me read the problem carefully.\n\nSo the task is to find two vouchers that don't overlap, their durations add up exactly to x, and their total cost is minimized. If there's no such pair, output -1.\n\nFirst, let's understand the problem. Each voucher has a duration of ri - li + 1. We need two vouchers i and j such that (duration_i + duration_j) = x, and they don't overlap. Also, i and j must be different.\n\nThe challenge is to find the minimal sum of their costs.\n\nConstraints are n up to 2e5, which suggests that an O(n^2) approach would be too slow. So we need an efficient way to process this.\n\nLet me think about possible approaches.\n\nFor each voucher, we can check if there exists another voucher with duration equal to (x - current duration), and that they don't overlap. But how do we efficiently find those?\n\nLet me break it down:\n\nFor each voucher i, compute its duration d_i. Then, we need to find a voucher j where d_j = x - d_i, and the vouchers don't overlap. For each such j, we need to find the minimum cost.\n\nBut how do we efficiently find the minimum cost for vouchers j with duration x - d_i and not overlapping with voucher i?\n\nHmm. So perhaps we can pre-process vouchers by their duration. Like, for each possible duration, store a list of vouchers with that duration, sorted by their start or end times, so that we can query for the minimum cost of a voucher that ends before the start of voucher i, or starts after the end of voucher i.\n\nWait, but for each voucher i, we need to find vouchers j that have duration (x - d_i), and either r_j < l_i or r_i < l_j. So for each voucher i, we can check for vouchers of duration (target = x - d_i) that end before l_i, or start after r_i.\n\nSo here's an idea: group all vouchers by their duration. For each duration d, we can have two structures:\n\n- A sorted list of their end times, along with their costs. So that for a given l_i, we can find all vouchers in this group that end before l_i, and find the minimum cost among them.\n\nSimilarly, a sorted list of their start times, so that for a given r_i, we can find all vouchers in this group that start after r_i, and find the minimum cost.\n\nWait, but for the first case (r_j < l_i), we need vouchers j with duration target, and r_j < l_i. For these vouchers, the earliest possible end time is up to l_i - 1. So if we have a sorted list of end times for vouchers of target duration, then for a given l_i, we can find the maximum end time that is less than l_i. But how do we find the minimum cost among those vouchers?\n\nAlternatively, for each duration d, we can pre-process two arrays:\n\n- One sorted by end time, and for each position in the sorted array, keep track of the minimum cost up to that point. Then, for a given l_i, we can binary search the largest end time <= l_i - 1, and get the min cost up to that index.\n\nSimilarly, for the other case where the voucher j starts after r_i. For those vouchers, we need their start time >= r_i + 1. So if we have the start times sorted, we can find the first start time >= r_i + 1, and then find the minimum cost in the suffix.\n\nSo the plan is:\n\n1. Preprocess all vouchers into groups by their duration. For each duration d, we have two sorted lists:\n\n   a. Sorted by end time (ri), and for each position, the minimum cost up to that position.\n\n   b. Sorted by start time (li), and for each position, the minimum cost from that position onwards.\n\nBut maybe for each duration d, we can have two structures:\n\n- A list of (end_time, cost), sorted by end_time. And for this list, a prefix min array. So when we want to find the minimum cost among all vouchers with duration d that end before a certain value, we can binary search the end_time and then get the min from the prefix up to that index.\n\n- Similarly, a list of (start_time, cost), sorted by start_time. And for this list, a suffix min array. So when we want to find the minimum cost among all vouchers with duration d that start after a certain value, we can binary search the start_time and get the min from that index onwards.\n\nSo for each voucher i, compute target = x - d_i. If target is not present in the duration groups, skip. Otherwise, check for vouchers of duration target that end before l_i, or start after r_i",
    "response": "To solve this problem, we need to find two non-overlapping vouchers whose combined duration exactly matches a given value `x` and whose total cost is minimized. The solution involves efficiently grouping vouchers by their duration and using binary search to quickly find the minimum cost of valid vouchers.\n\n### Approach\n1. **Group Vouchers by Duration**: We first group all vouchers by their duration. This allows us to quickly access vouchers of a specific duration when needed.\n2. **Preprocess for Efficient Queries**: For each duration, we maintain two sorted lists:\n   - One sorted by end time (`ri`) with a prefix minimum cost array to quickly find the minimum cost of vouchers ending before a certain day.\n   - Another sorted by start time (`li`) with a suffix minimum cost array to quickly find the minimum cost of vouchers starting after a certain day.\n3. **Check Valid Pairs**: For each voucher, compute the required complementary duration. Using the preprocessed data, check if there are valid vouchers that can be paired with the current voucher without overlapping and compute the minimum cost for such pairs.\n\n### Solution Code\n```python\nimport bisect\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n\n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        vouchers.append((l, r, cost))\n\n    # Preprocess: group by duration\n    duration_dict = defaultdict(list)\n    for l, r, cost in vouchers:\n        d = r - l + 1\n        duration_dict[d].append((l, r, cost))\n\n    # For each duration, prepare two structures:\n    # 1. sorted by end time, with prefix min cost\n    # 2. sorted by start time, with suffix min cost\n    duration_info = dict()\n\n    for d in duration_dict:\n        lst = duration_dict[d]\n        # Sort by end time\n        end_sorted = sorted(lst, key=lambda x: x[1])\n        # Prepare prefix min cost\n        prefix_min = []\n        min_cost = float('inf')\n        for item in end_sorted:\n            min_cost = min(min_cost, item[2])\n            prefix_min.append(min_cost)\n        # Sort by start time\n        start_sorted = sorted(lst, key=lambda x: x[0])\n        # Prepare suffix min cost\n        suffix_min = [0] * len(start_sorted)\n        min_cost = float('inf')\n        for i in range(len(start_sorted)-1, -1, -1):\n            min_cost = min(min_cost, start_sorted[i][2])\n            suffix_min[i] = min_cost\n        duration_info[d] = (end_sorted, prefix_min, start_sorted, suffix_min)\n\n    min_total = float('inf')\n\n    for l_i, r_i, cost_i in vouchers:\n        d_i = r_i - l_i + 1\n        target_d = x - d_i\n        if target_d not in duration_info:\n            continue\n        # Check for vouchers with duration target_d that don't overlap with [l_i, r_i]\n        end_sorted, prefix_min, start_sorted, suffix_min = duration_info[target_d]\n\n        # Case 1: voucher j ends before l_i\n        # Find the largest end time <= l_i - 1\n        # end_sorted is sorted by end time (r_j)\n        # So we can use bisect_right on the end times\n        end_times = [item[1] for item in end_sorted]\n        pos = bisect.bisect_right(end_times, l_i - 1)\n        if pos > 0:\n            current_min = prefix_min[pos - 1]\n            min_total = min(min_total, current_min + cost_i)\n\n        # Case 2: voucher j starts after r_i\n        # Find the first start time >= r_i + 1\n        # start_sorted is sorted by start time (l_j)\n        start_times = [item[0] for item in start_sorted]\n        pos = bisect.bisect_left(start_times, r_i + 1)\n        if pos < len(start_times):\n            current_min = suffix_min[pos]\n            min_total = min(min_total, current_min + cost_i)\n\n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Grouping by Duration**: Vouchers are grouped by their duration to allow efficient lookups when checking for complementary durations.\n- **Binary Search for Efficiency**: By sorting vouchers by their start and end times, we use binary search to quickly find valid non-overlapping vouchers and compute the minimum cost using precomputed prefix and suffix arrays.\n- **Handling Edge Cases**: The solution checks for both possible non-overlapping conditions (voucher ending before another starts and vice versa) and ensures the minimum cost is calculated efficiently.\n\nThis approach ensures that we efficiently handle up to the maximum constraints, providing an optimal solution with minimal computational overhead.",
    "ground_truth": "N/A",
    "extracted_answer": "import bisect\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n\n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        vouchers.append((l, r, cost))\n\n    # Preprocess: group by duration\n    duration_dict = defaultdict(list)\n    for l, r, cost in vouchers:\n        d = r - l + 1\n        duration_dict[d].append((l, r, cost))\n\n    # For each duration, prepare two structures:\n    # 1. sorted by end time, with prefix min cost\n    # 2. sorted by start time, with suffix min cost\n    duration_info = dict()\n\n    for d in duration_dict:\n        lst = duration_dict[d]\n        # Sort by end time\n        end_sorted = sorted(lst, key=lambda x: x[1])\n        # Prepare prefix min cost\n        prefix_min = []\n        min_cost = float('inf')\n        for item in end_sorted:\n            min_cost = min(min_cost, item[2])\n            prefix_min.append(min_cost)\n        # Sort by start time\n        start_sorted = sorted(lst, key=lambda x: x[0])\n        # Prepare suffix min cost\n        suffix_min = [0] * len(start_sorted)\n        min_cost = float('inf')\n        for i in range(len(start_sorted)-1, -1, -1):\n            min_cost = min(min_cost, start_sorted[i][2])\n            suffix_min[i] = min_cost\n        duration_info[d] = (end_sorted, prefix_min, start_sorted, suffix_min)\n\n    min_total = float('inf')\n\n    for l_i, r_i, cost_i in vouchers:\n        d_i = r_i - l_i + 1\n        target_d = x - d_i\n        if target_d not in duration_info:\n            continue\n        # Check for vouchers with duration target_d that don't overlap with [l_i, r_i]\n        end_sorted, prefix_min, start_sorted, suffix_min = duration_info[target_d]\n\n        # Case 1: voucher j ends before l_i\n        # Find the largest end time <= l_i - 1\n        # end_sorted is sorted by end time (r_j)\n        # So we can use bisect_right on the end times\n        end_times = [item[1] for item in end_sorted]\n        pos = bisect.bisect_right(end_times, l_i - 1)\n        if pos > 0:\n            current_min = prefix_min[pos - 1]\n            min_total = min(min_total, current_min + cost_i)\n\n        # Case 2: voucher j starts after r_i\n        # Find the first start time >= r_i + 1\n        # start_sorted is sorted by start time (l_j)\n        start_times = [item[0] for item in start_sorted]\n        pos = bisect.bisect_left(start_times, r_i + 1)\n        if pos < len(start_times):\n            current_min = suffix_min[pos]\n            min_total = min(min_total, current_min + cost_i)\n\n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 740,
        "completion_token_count": 1105,
        "thoughts_token_count": 1024
    }
}