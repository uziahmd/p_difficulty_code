{
    "start": 1758008333.9225147,
    "end": 1758008557.8385324,
    "start-formatted": "2025-09-16 16:38 KST",
    "end-formatted": "2025-09-16 16:42 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\nOkay, let's see. I need to solve this programming problem. Let's read the problem carefully.\n\nSo, the problem is about finding two non-overlapping vouchers such that their total duration is exactly x, and their combined cost is minimized. If there's no such pair, output -1.\n\nFirst, let's understand the problem. Each voucher has a start day li, end day ri, and cost. The duration is ri - li + 1. We need two vouchers i and j where their durations add up to x. Also, they must not overlap. That means either the first ends before the second starts, or the second ends before the first starts.\n\nThe approach here is to find pairs of vouchers where one has duration d, and the other has duration x - d. Then check if they can be non-overlapping.\n\nBut how do I efficiently find these pairs?\n\nConstraints are n up to 2e5. So O(n^2) is impossible. Need something more efficient.\n\nLet me think. For each voucher, we can check if there exists another voucher with duration (x - duration_i), and that they don't overlap. But how to find the minimal cost?\n\nMaybe we can pre-process vouchers by their duration. For example, create a dictionary where for each duration d, we have a list of vouchers with that duration, sorted by their end time (or start time?), and also track the minimum cost for certain ranges.\n\nWait, but for each voucher with duration d, we need to find a voucher with duration (x - d) that ends before the start of this voucher, or starts after the end of this voucher.\n\nSo perhaps for each voucher, we can check two possibilities:\n\n1. Find a voucher with duration (x - d) that ends before li of the current voucher. Then the current voucher can be the second part.\n\n2. Find a voucher with duration (x - d) that starts after ri of the current voucher. Then the current voucher can be the first part.\n\nBut how to do this efficiently?\n\nLet me think. For each possible duration d, we can pre-process all vouchers with that duration. For example, for each d, we can have a list of vouchers sorted by their end time, and for each voucher in that list, we can also track the minimum cost up to that point. Similarly, maybe sorted by start time?\n\nAlternatively, for each voucher with duration d, we can check for vouchers of duration x - d that end before the current voucher's li. To find the minimal cost among those vouchers.\n\nSimilarly, check for vouchers of duration x - d that start after the current voucher's ri.\n\nBut how to query that quickly?\n\nLet me think about the steps:\n\nFirst, group all vouchers by their duration. For example, a dictionary where key is duration, value is a list of vouchers with that duration.\n\nThen, for each voucher i with duration d, we need to look for vouchers with duration (x - d). Let's call that target duration t = x - d.\n\nIf t is negative, skip. Also, if t is not present in the duration map, skip.\n\nFor each voucher i, we need to find the minimal cost of vouchers with duration t that end before li (so that voucher i can be the second part), or start after ri (so that voucher i can be the first part).\n\nBut how to find the minimal cost in those cases?\n\nFor example, for vouchers of duration t, we can sort them by their end time. Then, for a given li, we can find all vouchers with end time < li. Among those, we want the minimal cost.\n\nSimilarly, for vouchers of duration t, sorted by start time. For a given ri, find all vouchers with start time > ri, and take the minimal cost.\n\nSo, for each duration t, we can pre-process two structures:\n\n- A sorted list of end times, along with the minimum cost up to that end time. This would allow us to perform a binary search for the maximum end time less than li, and then get the minimal cost up to that point.\n\n- A sorted list of start times, along with the minimum cost from that start time onward. Or maybe for each start time, we can have the minimal cost in the suffix.\n\nWait, but for the first case, where we need vouchers ending before li, we can sort the vouchers of duration t by their end time, and for each position in the sorted list, keep track of the minimum cost up to that index. Then, when we perform a binary search to find the largest end time less than li, we can get the min cost up to that index.\n\nSimilarly, for vouchers that start after ri, we can sort the vouchers of duration t by their start time, and for each position, track the minimum cost from that position onwards. Then, when we find the earliest start time greater than ri, we can get the min cost from that position.\n\nBut how to build these structures?\n\nLet me think. For each",
    "response": "\n\nTo solve this problem, we need to find two non-overlapping vouchers such that their combined duration equals a given value `x` and their total cost is minimized. If no such pair exists, we return -1.\n\n### Approach\n1. **Group Vouchers by Duration**: First, we group all vouchers by their duration. This helps in efficiently checking for pairs of vouchers that sum up to the required duration `x`.\n2. **Preprocess Vouchers**: For each duration, we preprocess the vouchers to allow efficient querying:\n   - Sort vouchers by their end time and maintain a prefix minimum cost array.\n   - Sort vouchers by their start time and maintain a suffix minimum cost array.\n3. **Check Valid Pairs**: For each voucher, check if there exists another voucher with the complementary duration such that they do not overlap. Use binary search to efficiently find valid non-overlapping vouchers and compute the minimum cost.\n\n### Solution Code\n```python\nimport sys\nimport bisect\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n\n    vouchers = []\n    duration_map = defaultdict(list)\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n        duration_map[duration].append((l, r, cost))\n\n    # Preprocess each duration's list\n    # For each duration d, we have:\n    # sorted_end: list of (end, min_cost_up_to_here)\n    # sorted_start: list of (start, min_cost_from_here)\n    preprocessed = dict()\n    for d in duration_map:\n        lst = duration_map[d]\n        # Sort by end time\n        sorted_by_end = sorted(lst, key=lambda x: x[1])\n        # Create prefix min cost array\n        prefix_min = []\n        min_so_far = float('inf')\n        for item in sorted_by_end:\n            min_so_far = min(min_so_far, item[2])\n            prefix_min.append(min_so_far)\n        # Sort by start time\n        sorted_by_start = sorted(lst, key=lambda x: x[0])\n        # Create suffix min cost array\n        suffix_min = [0] * len(sorted_by_start)\n        min_so_far = float('inf')\n        for i in reversed(range(len(sorted_by_start))):\n            min_so_far = min(min_so_far, sorted_by_start[i][2])\n            suffix_min[i] = min_so_far\n        preprocessed[d] = (sorted_by_end, prefix_min, sorted_by_start, suffix_min)\n\n    min_total = float('inf')\n\n    for l, r, cost, d in vouchers:\n        t = x - d\n        if t < 1:\n            continue\n        if t not in preprocessed:\n            continue\n        # Check for vouchers with duration t that end before l\n        sorted_end, prefix_min, sorted_start, suffix_min = preprocessed[t]\n        # Find the largest end <= l-1\n        ends = [item[1] for item in sorted_end]\n        pos = bisect.bisect_right(ends, l - 1) - 1\n        if pos >= 0:\n            min_cost = prefix_min[pos]\n            min_total = min(min_total, min_cost + cost)\n        # Check for vouchers with duration t that start after r\n        starts = [item[0] for item in sorted_start]\n        pos = bisect.bisect_right(starts, r)\n        if pos < len(starts):\n            min_cost = suffix_min[pos]\n            min_total = min(min_total, min_cost + cost)\n\n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into vouchers, each characterized by their start day, end day, cost, and duration.\n2. **Grouping by Duration**: Vouchers are grouped by their duration using a dictionary for quick access.\n3. **Preprocessing**: For each duration, vouchers are sorted by end time and start time. Prefix and suffix arrays are created to keep track of minimum costs for efficient querying.\n4. **Checking Valid Pairs**: For each voucher, we check if there exists a valid complementary voucher with the required duration that does not overlap. Binary search is used to efficiently find valid non-overlapping vouchers and compute the minimum cost.\n\nThis approach ensures that we efficiently check for valid pairs while maintaining a time complexity that is feasible for large inputs.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport bisect\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n\n    vouchers = []\n    duration_map = defaultdict(list)\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n        duration_map[duration].append((l, r, cost))\n\n    # Preprocess each duration's list\n    # For each duration d, we have:\n    # sorted_end: list of (end, min_cost_up_to_here)\n    # sorted_start: list of (start, min_cost_from_here)\n    preprocessed = dict()\n    for d in duration_map:\n        lst = duration_map[d]\n        # Sort by end time\n        sorted_by_end = sorted(lst, key=lambda x: x[1])\n        # Create prefix min cost array\n        prefix_min = []\n        min_so_far = float('inf')\n        for item in sorted_by_end:\n            min_so_far = min(min_so_far, item[2])\n            prefix_min.append(min_so_far)\n        # Sort by start time\n        sorted_by_start = sorted(lst, key=lambda x: x[0])\n        # Create suffix min cost array\n        suffix_min = [0] * len(sorted_by_start)\n        min_so_far = float('inf')\n        for i in reversed(range(len(sorted_by_start))):\n            min_so_far = min(min_so_far, sorted_by_start[i][2])\n            suffix_min[i] = min_so_far\n        preprocessed[d] = (sorted_by_end, prefix_min, sorted_by_start, suffix_min)\n\n    min_total = float('inf')\n\n    for l, r, cost, d in vouchers:\n        t = x - d\n        if t < 1:\n            continue\n        if t not in preprocessed:\n            continue\n        # Check for vouchers with duration t that end before l\n        sorted_end, prefix_min, sorted_start, suffix_min = preprocessed[t]\n        # Find the largest end <= l-1\n        ends = [item[1] for item in sorted_end]\n        pos = bisect.bisect_right(ends, l - 1) - 1\n        if pos >= 0:\n            min_cost = prefix_min[pos]\n            min_total = min(min_total, min_cost + cost)\n        # Check for vouchers with duration t that start after r\n        starts = [item[0] for item in sorted_start]\n        pos = bisect.bisect_right(starts, r)\n        if pos < len(starts):\n            min_cost = suffix_min[pos]\n            min_total = min(min_total, min_cost + cost)\n\n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 739,
        "completion_token_count": 1018,
        "thoughts_token_count": 1023
    }
}