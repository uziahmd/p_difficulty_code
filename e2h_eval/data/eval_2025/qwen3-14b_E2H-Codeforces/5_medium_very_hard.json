{
    "start": 1758024114.3822408,
    "end": 1758026932.0693996,
    "start-formatted": "2025-09-16 21:01 KST",
    "end-formatted": "2025-09-16 21:48 KST",
    "gpu": 2,
    "pid": 5,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Colored Boots\n\nThere are $$$n$$$ left boots and $$$n$$$ right boots. Each boot has a color which is denoted as a lowercase Latin letter or a question mark ('?'). Thus, you are given two strings $$$l$$$ and $$$r$$$, both of length $$$n$$$. The character $$$l_i$$$ stands for the color of the $$$i$$$-th left boot and the character $$$r_i$$$ stands for the color of the $$$i$$$-th right boot.A lowercase Latin letter denotes a specific color, but the question mark ('?') denotes an indefinite color. Two specific colors are compatible if they are exactly the same. An indefinite color is compatible with any (specific or indefinite) color.For example, the following pairs of colors are compatible: ('f', 'f'), ('?', 'z'), ('a', '?') and ('?', '?'). The following pairs of colors are not compatible: ('f', 'g') and ('a', 'z').Compute the maximum number of pairs of boots such that there is one left and one right boot in a pair and their colors are compatible.Print the maximum number of such pairs and the pairs themselves. A boot can be part of at most one pair.\n\n## Input\nThe first line contains $$$n$$$ ($$$1 \\le n \\le 150000$$$), denoting the number of boots for each leg (i.e. the number of left boots and the number of right boots).The second line contains the string $$$l$$$ of length $$$n$$$. It contains only lowercase Latin letters or question marks. The $$$i$$$-th character stands for the color of the $$$i$$$-th left boot.The third line contains the string $$$r$$$ of length $$$n$$$. It contains only lowercase Latin letters or question marks. The $$$i$$$-th character stands for the color of the $$$i$$$-th right boot.\n\n## Output\nPrint $$$k$$$ â€” the maximum number of compatible left-right pairs of boots, i.e. pairs consisting of one left and one right boot which have compatible colors.The following $$$k$$$ lines should contain pairs $$$a_j, b_j$$$ ($$$1 \\le a_j, b_j \\le n$$$). The $$$j$$$-th of these lines should contain the index $$$a_j$$$ of the left boot in the $$$j$$$-th pair and index $$$b_j$$$ of the right boot in the $$$j$$$-th pair. All the numbers $$$a_j$$$ should be distinct (unique), all the numbers $$$b_j$$$ should be distinct (unique).If there are many optimal answers, print any of them.\n\n## Example\n### Input\n['10\\ncodeforces\\ndodivthree', '7\\nabaca?b\\nzabbbcc', '9\\nbambarbia\\nhellocode', '10\\ncode??????\\n??????test']\n\n### Output\n['5\\n7 8\\n4 9\\n2 2\\n9 10\\n3 1', '5\\n6 5\\n2 3\\n4 6\\n7 4\\n1 2', '0', '10\\n6 2\\n1 6\\n7 3\\n3 5\\n4 8\\n9 7\\n5 1\\n2 4\\n10 9\\n8 10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\nOkay, let's see. I need to solve this Colored Boots problem. Let me read the problem statement carefully.\n\nSo, there are n left boots and n right boots. Each has a color which is a lowercase letter or a question mark. The goal is to pair them such that each pair has compatible colors. The maximum number of such pairs. And then output those pairs with their indices.\n\nCompatibility rules: two specific colors are compatible if they are the same. A question mark can be paired with any color, including another question mark. So, for example, a '?' on left and 'a' on right is okay, as well as '?' and '?'.\n\nThe challenge is to find the maximum number of pairs. Also, each boot can be in at most one pair.\n\nHmm. How to approach this?\n\nLet me think about how to model this. It's a matching problem between left and right boots, with certain constraints.\n\nBut since n can be up to 150,000, any O(n^2) approach is impossible. So we need an efficient way.\n\nFirst, perhaps we can process the pairs in a way that maximizes matches. Let's think about the possible cases:\n\nFor each left boot and right boot, their colors must be compatible. But since the problem allows us to choose any pairing as long as it's compatible, how do we maximize the count?\n\nAn idea is to first match the specific colors. For example, if a left boot has color 'a', and a right boot also has 'a', then that's a direct match. But if there are more left 'a's than right 'a's, then some of them can't be matched. Similarly for the other way around.\n\nBut then, the question marks can be used as wildcards. So, perhaps we can first match the specific colors, and then use the remaining question marks to cover the leftovers.\n\nWait, but how?\n\nLet me think of steps:\n\nStep 1: Match all possible direct pairs (same color, not ?). For example, for each color c (excluding ?), count how many left and right boots have that color. Then, the number of pairs for each color is min(left_count[c], right_count[c]). But we need to track which specific boots are matched here.\n\nBut how to track which ones are matched? Because once a left boot is matched with a right one, they can't be used again.\n\nBut maybe we can first process the non-question marks. For example, for each color c (not ?), collect the list of left boots with that color and the list of right boots with that color. Then, pair them up. For example, for color 'a', if there are 3 left and 2 right, then we can pair 2 lefts with 2 rights. The remaining left 'a's would need to be matched with question marks, or not.\n\nBut how to do this efficiently?\n\nAlternatively, for each color c (non-?), create a list of left indices and a list of right indices. Then, pair them in order. Like, for each left in left_c, pair with a right in right_c, up to the minimum of the two counts.\n\nOnce these are paired, we can mark those boots as used.\n\nThen, for the remaining left and right boots (those not matched yet), we have to use the question marks.\n\nBut the question marks can be used in two ways: either as a left or right. So, for example, a left '?' can pair with any right (including ?), and vice versa.\n\nBut how to maximize the number of pairs here?\n\nLet me think. After processing the specific colors, we have some left boots (possibly with ?) and some right boots (possibly with ?). We need to pair them such that each pair is compatible.\n\nSo, the remaining left boots are those that couldn't be matched with their specific color counterparts. Similarly for the right.\n\nLet me think of the remaining left boots as L and the remaining right boots as R.\n\nEach left in L can be either a specific color (but not matched with its counterpart) or a ?. Similarly for right.\n\nNow, for the remaining, how to pair them?\n\nThe idea is to pair as many as possible. The question marks can act as wildcards.\n\nSo, perhaps we can:\n\n- Count the number of left ? (call it left_q) and right ? (right_q).\n\nBut also, there are left boots with specific colors that are not matched yet (call them left_s) and right boots with specific colors not matched yet (right_s).\n\nWait, but left_s and right_s would have colors that are not compatible with each other (since otherwise they would have been paired in step 1). Wait no. For example, suppose a left has color 'a' and a right has color 'b'. They weren't matched in step 1 because they are different. Now, in this case, they can't be paired unless one of them is a question mark. So, in the remaining steps, the left and right that are not matched in step 1 are those that have specific colors that don't match each other. Unless they are question marks.\n\nSo, after step 1, the remaining left boots are:\n\nEither:\n\n- Left boots with color c (non-?), which couldn't find a matching right boot with same color.\n\nOr:\n\n- Left boots with color ?.\n\nSame for right.\n\nSo, the remaining left and right boots can be paired only if:\n\n- One is a ?, or both are ?.\n\nOr, if they have the same color (but in that case, they should have been matched in step 1, unless there was a shortage of one side).\n\nWait, no. For example, suppose there are 3 left 'a's and 2 right 'a's. Then, in step 1, we pair 2 left 'a's with 2 right 'a's. The third left 'a' remains. So, in this case, the remaining left 'a' can't be matched with any right 'a's (since all right 'a's are already used). So, that left 'a' can't be matched with any other right boot unless the right boot is a ?.\n\nSo, for the remaining left and right boots, the only possible pairs are:\n\n- A left ? with any right (including ?).\n\n- A right ? with any left (including ?).\n\n- Or, two ?s.\n\n- Or, a left and right with same color (but why wasn't this handled in step 1? Because maybe the left and right had same color, but there were not enough on one side. For example, if there were 2 left 'a's and 3 right 'a's. Then, in step 1, we pair 2 left and 2 right. The remaining right 'a's can't be paired with any left 'a's. So, those remaining right 'a's would be in the remaining group. So, perhaps they can be paired with left ?s or right ?s.)\n\nBut how to handle this?\n\nSo, the problem is that after step 1, there are some left and right boots that have specific colors, but no matching counterparts. These can't be paired with each other, but can be paired with ?s.\n\nSo, the approach could be:\n\nAfter step 1, collect all the remaining left boots and right boots.\n\nThen, for the remaining left and right, we can try to pair them using ?s.\n\nSo, perhaps the following steps:\n\nFor the remaining left and right boots:\n\n- First, pair as many as possible between left ? and right ?.\n\n- Then, pair left ? with right specific colors (if possible).\n\n- Then, pair right ? with left specific colors.\n\nBut how to model this?\n\nAlternatively, the maximum possible pairs from the remaining is the minimum of (number of remaining left boots + number of remaining right boots) and (the sum of the number of ?s on left and right plus the number of matching specific color pairs that can be made between remaining left and right? No, not sure.\n\nAlternatively, think of the remaining left and right as follows:\n\nEach left boot can be matched with any right boot if:\n\n- Either left is ? or right is ?.\n\nOR\n\n- Both are same specific color.\n\nBut since in step 1, we've already matched all possible same specific color pairs (up to the min of counts per color), the only remaining same specific color pairs would be when there are left and right with same color, but not enough to pair them all. So, for example, if there are left 'a's and right 'a's, but after step 1, there are some left 'a's and some right 'a's left. But wait, in step 1, for each color, we paired min(left_count, right_count) of them. So, for example, if left_count is 3 and right_count is 2, then after step 1, there is 1 left 'a' and 0 right 'a's. So, in that case, the remaining left 'a's cannot be matched with any right 'a's, since there are none left. So, the only possible pairs for the remaining left 'a's are with right ?s.\n\nSo, in the remaining phase, the only possible pairs are between:\n\n- Left ? and right (any).\n\n- Right ? and left (any).\n\n- Or, between left and right with same specific color (but only if they were not matched in step 1. Wait, but how could that happen? Because during step 1, for each color, we paired as much as possible. So, for example, if there are left 'a's and right 'a's, but after step 1, there are some left 'a's and some right 'a's left? No. Because suppose that for color 'a', there were L left and R right. Then, during step 1, we paired min(L, R) of them. So, after that, for color 'a', either there are zero left or zero right. Because suppose L=3 and R=2: after step 1, 2 left and 2 right are paired. The remaining left is 1, and the right is zero. So, no more left 'a's and right 'a's. Hence, in the remaining phase, there are no left and right with same specific colors. So, the only possible pairs in the remaining phase are those involving a question mark.\n\nTherefore, the remaining phase can be handled by:\n\nPairing the left ? with right boots that are not yet paired (and vice versa), but since the question marks can be used as wildcards.\n\nSo, how to pair them optimally?\n\nLet me think: the total number of pairs possible in the remaining phase is equal to the number of left ? plus the number of right ? minus the number of overlaps? No. Because for example, if you have a left ? and a right ?, pairing them uses both. But if you have a left ? and a right non-?, then you can pair them. Similarly for a right ? and a left non-?.\n\nSo, the maximum possible pairs here would be the total number of remaining left and right boots, but that's not possible because each pair requires one left and one right.\n\nWait, the maximum possible pairs in the remaining phase is the minimum between the total number of remaining left boots and the total number of remaining right boots. Because each pair uses one of each. But how to achieve that?\n\nBut given that any left can be paired with any right if at least one is a ?.\n\nSo, the maximum possible pairs is min(remaining_left_count, remaining_right_count). But how to achieve that?\n\nSo, the approach is:\n\nWe have remaining_left (which includes left ? and non-? that couldn't be matched in step 1) and remaining_right (same).\n\nWe can pair them as follows:\n\n- For each left in remaining_left, if it's a ?, pair it with any available right (preferably non-? if possible? Or not? Doesn't matter, as long as they are paired).\n\nBut how to do this efficiently?\n\nBut perhaps the best way is to:\n\nTake all the left ? and right ? and pair them first. Then, take the remaining left ? and pair them with the remaining right non-? (and vice versa). But how?\n\nAlternatively, the following approach:\n\nFor the remaining left and right:\n\n- For each left that is a ?, pair it with any right that hasn't been paired yet.\n\n- For each right that is a ?, pair it with any left that hasn't been paired yet.\n\nBut how to implement this?\n\nBut since the order may affect the result, perhaps we can proceed as follows:\n\n1. Collect all the left boots that are not yet paired and have color ?. Let's call them left_q.\n\n2. Collect all the right boots that are not yet paired and have color ?. Let's call them right_q.\n\n3. Pair as many as possible between left_q and right_q. For example, the number of pairs here is min(len(left_q), len(right_q)). So, pair them one by one.\n\n4. Then, for the remaining left_q and right_q (after this step), pair them with the non-? boots on the other side.\n\nBut how?\n\nWait, after step 3, there may be some left_q left (if there were more left_q than right_q) and some right_q left (if there were more right_q than left_q). Let's say after step 3, there are x left_q and y right_q left.\n\nThen, for the remaining left_q, we can pair them with any remaining right boots that are not ? and not yet paired. Similarly for the remaining right_q.\n\nBut how to find those?\n\nAlternatively, after step 3, the remaining left and right boots are:\n\n- left_non_q: left boots not paired yet, and color is not ?.\n\n- right_non_q: same.\n\n- left_q_remaining: left ? not paired yet.\n\n- right_q_remaining: right ? not paired yet.\n\nBut since the left_non_q and right_non_q can't be paired with each other (as their colors are not same, and they are not ?), the only way to pair them is to pair them with the remaining ?s.\n\nSo, for example, left_non_q can be paired with right_q_remaining (since right_q_remaining is ?), and right_non_q can be paired with left_q_remaining.\n\nBut how to do that?\n\nSo, the steps would be:\n\nAfter step 3:\n\nFor the remaining left_non_q and right_non_q, they can't be paired with each other. So, we need to pair them with the remaining ?s.\n\nSo:\n\nFor each left_non_q (color c), we can pair it with any right_q_remaining. Similarly for right_non_q.\n\nSimilarly, for each right_non_q, pair with left_q_remaining.\n\nSo, the number of pairs possible here is min( len(left_non_q) + len(right_non_q), len(left_q_remaining) + len(right_q_remaining) ) ?\n\nWait, but each pair requires one left and one right. So the maximum possible pairs here is the minimum between the total number of remaining left and right boots.\n\nBut how to compute that.\n\nAlternatively, the total number of possible pairs after step 3 is the sum of:\n\n- The number of left_non_q and right_q_remaining (each left_non_q can be paired with a right_q_remaining).\n\n- The number of right_non_q and left_q_remaining (each right_non_q can be paired with a left_q_remaining).\n\nBut since each of these is a possible pairing, and we can pair as many as possible.\n\nBut how to implement this?\n\nPerhaps:\n\nCollect all left_non_q and right_non_q.\n\nThen, for each left in left_non_q, pair with a right_q_remaining (if any). Similarly, for each right in right_non_q, pair with a left_q_remaining (if any).\n\nBut how to track which ones are available.\n\nThis seems complicated. But perhaps the way to implement this is:\n\nWe can have two queues or lists:\n\nleft_q_remaining = list of left ? not yet paired.\n\nright_q_remaining = list of right ? not yet paired.\n\nleft_non_q = list of left non-? not yet paired.\n\nright_non_q = list of right non-? not yet paired.\n\nThen:\n\nFor each left in left_non_q:\n\n   if there are any right_q_remaining, pair them. Remove one from right_q_remaining.\n\nSimilarly, for each right in right_non_q:\n\n   if there are any left_q_remaining, pair them. Remove one from left_q_remaining.\n\nThen, after that, there may be some left_q_remaining and right_q_remaining left. But since they are both ?, they can be paired among themselves. However, this was already handled in step 3.\n\nWait, but step 3 was pairing left_q and right_q. So, after that, the left_q_remaining and right_q_remaining are the ones that couldn't be paired in step 3. So, for example, if there were more left_q than right_q, then after step 3, left_q_remaining would be left_q - right_q, and right_q_remaining is zero.\n\nSo, after step 3, the left_q_remaining and right_q_remaining can't be paired with each other (since they are all ? and there are no more of the other side). So, the left_q_remaining can only be paired with right_non_q (but those are non-? and can't be paired with ?s? No, right_non_q are non-? but can be paired with left_q_remaining (since the left is ?).\n\nWait, the right_non_q are non-? and have specific colors. The left_q_remaining are ?. So, yes, they can be paired.\n\nBut in the previous step, I thought that after step 3, the left_non_q and right_non_q are not paired with each other. So, the approach would be:\n\nAfter step 3, pair left_non_q with right_q_remaining, and right_non_q with left_q_remaining.\n\nOnce that's done, any remaining left_q_remaining and right_q_remaining can't be paired (since all other options are exhausted). So, the maximum possible pairs is the sum of the pairs made in step 3, plus the pairs made in this step.\n\nBut how to implement this?\n\nBut perhaps the code can be structured as follows:\n\nFirst, process all the direct matches (specific colors same).\n\nThen, collect the remaining left and right boots.\n\nFor the remaining:\n\nCollect all left ? into a list L_q.\n\nCollect all right ? into a list R_q.\n\nCollect all left non-? into L_s.\n\nCollect all right non-? into R_s.\n\nThen, pair as many as possible between L_q and R_q. For example, take the first min(len(L_q), len(R_q)) pairs. Let's say we pair them.\n\nThen, for the remaining L_q and R_q:\n\nWe can pair the remaining L_q with R_s (since R_s are non-? but can be paired with ?).\n\nSimilarly, pair the remaining R_q with L_s.\n\nBut how to do this?\n\nWait, but R_s are non-? and can't be paired with each other. So, for example, if there are any R_s left, they can only be paired with L_q (if any left), or with other R_s if they are ? (but they are not). So, no.\n\nSo, the process would be:\n\nAfter pairing L_q and R_q as much as possible, pair the remaining L_q with R_s (each L_q can be paired with any R_s), and pair the remaining R_q with L_s.\n\nSo, the code can be:\n\nfor i in range(len(L_q)):\n\n    if there are R_s left:\n\n        pair L_q[i] with R_s[0], remove R_s[0]\n\n    else:\n\n        break\n\nSimilarly for R_q and L_s.\n\nBut how to manage the lists?\n\nBut perhaps the way to do this is:\n\nWe can have pointers or iterators for the L_q, R_q, L_s, R_s.\n\nBut perhaps the easiest way is to iterate through the L_q and R_s and pair them, then iterate through R_q and L_s and pair them.\n\nBut in practice, how to implement this?\n\nBut perhaps for code efficiency, we can use queues or just lists.\n\nBut given the size of n (up to 150,000), even O(n) operations are acceptable.\n\nSo, putting this all together.\n\nNow, the problem is to track which boots are already paired. So, for each boot (left or right), we need to know whether it's been used in a pair or not.\n\nSo, perhaps the steps are:\n\nInitialize two arrays: used_left and used_right, of size n, initialized to False.\n\nThen, during step 1, for each color c (non-?), we pair left boots with color c with right boots with color c. For example, for each c, collect the list of left indices (not used) and right indices (not used). Then, pair them up as much as possible, marking them as used.\n\nThen, collect the remaining left and right boots (not used) into the four groups: L_q, R_q, L_s, R_s.\n\nThen, process the four groups as described.\n\nNow, the challenge is to implement this efficiently.\n\nBut how to collect the left and right boots for each color.\n\nFor example, for step 1, for each color c (excluding '?'), collect the list of left indices where l[i] == c and not used, and same for right.\n\nBut for large n, we can pre-process for each color, the list of left and right indices.\n\nBut for each color, we can have a list of left indices and a list of right indices.\n\nThen, for each color c, we pair the first min(len(left_c), len(right_c)) pairs.\n\nBut how to track which ones are used.\n\nAlternatively, for step 1, we can:\n\nFor each color c (non-?), collect the left indices and right indices.\n\nThen, for each such color, pair as many as possible between left and right. For example, for color c, we can take the first m = min(len(left_c), len(right_c)) pairs. For each i in 0..m-1, pair left_c[i] with right_c[i]. Mark them as used.\n\nBut how to collect the left_c and right_c lists.\n\nSo, in code:\n\nWe can create dictionaries for left and right, mapping color to list of indices.\n\nFor example:\n\nfrom collections import defaultdict\n\nleft_colors = defaultdict(list)\n\nright_colors = defaultdict(list)\n\nfor i in range(n):\n\n    if l[i] != '?':\n\n        left_colors[l[i]].append(i)\n\n    if r[i] != '?':\n\n        right_colors[r[i]].append(i)\n\nThen, for each color c in left_colors and right_colors:\n\nwe can pair min(len(left_colors[c]), len(right_colors[c])) pairs.\n\nBut how to do this for all colors?\n\nWait, but for each color c, we can process it once. For example, for each color c in left_colors:\n\n    if c is in right_colors:\n\n        num_pairs = min(len(left_colors[c]), len(right_colors[c]))\n\n        for i in 0 to num_pairs-1:\n\n            pair left_colors[c][i] with right_colors[c][i]\n\n            mark them as used.\n\nBut this approach would miss colors that are present in right_colors but not in left_colors. But for those, they can't be paired in this step.\n\nBut in this approach, for each color c, we process the left and right lists, and pair them up to the minimum.\n\nBut how to make sure that each index is only processed once. Because once a left index is marked as used, it's not considered in any further steps.\n\nWait, but the way I'm thinking here is that for each color c, the left_colors[c] and right_colors[c] are lists of indices that have not been used yet. So, during the initial processing, when we process color c, we pair as many as possible between left and right of that color, and mark them as used. Then, when processing other colors, those indices are already marked as used and won't be considered again.\n\nBut how to collect the left_colors and right_colors for all colors?\n\nAh, but initially, the left_colors and right_colors are built with all indices. So, during step 1, when we pair left and right of same color, we need to mark them as used, so that they are not considered again.\n\nBut this approach would not work, because the initial left_colors and right_colors include all indices, including those that have been used in previous steps.\n\nSo, for example, if we process color 'a' first, pair some left and right, and then process color 'b', but some of the left 'b's may have been used in previous steps. But no, because when building the left_colors and right_colors, we have all indices. However, when we pair them, we have to mark them as used, so that during the processing of other colors, they are not considered again.\n\nSo, perhaps the correct way is:\n\nInitialize used_left and used_right as False arrays.\n\nFor each color c in left_colors (non-?):\n\n    if c is not in right_colors, continue.\n\n    left_list = [indices in left_colors[c] that are not used]\n\n    right_list = [indices in right_colors[c] that are not used]\n\n    num_pairs = min(len(left_list), len(right_list))\n\n    for i in 0 to num_pairs-1:\n\n        pair left_list[i] with right_list[i]\n\n        mark used_left[left_list[i]] = True\n\n        mark used_right[right_list[i]] = True\n\nBut how to get left_list and right_list? Because during the initial processing, the left_colors[c] contains all indices of that color, but some may have been marked as used in previous steps.\n\nThis suggests that we need to process the colors in some order, and for each color, collect the unused indices.\n\nBut this would be time-consuming if done naively.\n\nAlternative approach: For each color c (non-?), collect all left indices and right indices once. Then, for each color, pair the first possible left and right indices that are not yet used.\n\nBut how to do that?\n\nAlternatively, for each color c, we can have a pointer indicating how many have been paired already. For example, for left_colors[c], we can have a pointer starting at 0, and for each step, we check if the current index is used. If not, we pair it with the corresponding right index.\n\nBut this seems complicated.\n\nAnother approach is to process each color once, and for each color, pair as many as possible between left and right, and mark them as used. For example:\n\nWe can have for each color c:\n\nleft_list = list of indices where l[i] == c.\n\nright_list = list of indices where r[i] == c.\n\nThen, for each color c, the number of pairs is min(len(left_list), len(right_list)), but we need to pair them in a way that the indices are not used yet.\n\nBut how to track that.\n\nWait, perhaps the initial approach is to process all colors, and for each color, pair as many as possible between left and right, but in a way that each left and right is used only once.\n\nSo, for example, for color c, we can have a list of left indices and a list of right indices. Then, for each pair (left_i, right_j), we pair them and mark them as used. However, once a left index is used, it's not considered again. Similarly for right indices.\n\nBut how to track which indices are used.\n\nSo, here's a possible approach:\n\nInitialize used_left and used_right arrays as False.\n\nFor each color c in the set of all possible colors (excluding '?'):\n\n    left_list = [i for i in range(n) if l[i] == c and not used_left[i]]\n\n    right_list = [i for i in range(n) if r[i] == c and not used_right[i]]\n\n    num_pairs = min(len(left_list), len(right_list))\n\n    for i in range(num_pairs):\n\n        pair left_list[i] with right_list[i]\n\n        used_left[left_list[i]] = True\n\n        used_right[right_list[i]] = True\n\nBut this approach would be O(n * k), where k is the number of colors. Since n is 150,000 and k is up to 26, this would be O(150,000 * 26) which is acceptable.\n\nBut for n=150,000, this would require for each color, scanning all n elements. Which is O(26n) time. That's acceptable for n=150,000.\n\nBut this would be very slow. Because for each color, we have to scan all n elements. For example, for 26 colors, it's 26 * 150,000 = 3.9 million operations, which is manageable.\n\nBut perhaps there's a better way. For example, precompute for each color, the list of indices. Then, during the pairing, for each color c, we can track how many have been used so far.\n\nFor example, for each color c, have left_indices and right_indices as precomputed lists. Then, during pairing, for color c, we can iterate through the left_indices and right_indices, and pair them up until one of the lists is exhausted, and mark them as used.\n\nBut how to track which ones have been used.\n\nLet me think. For example, for color 'a', the left_indices are stored as a list. Then, for each left index in left_indices, we can check if it's not used. If not, we can pair it with the next available right index.\n\nBut this seems like it would require for each color, to keep track of how many left and right have been paired so far.\n\nSo, for example:\n\nprecompute for each color c:\n\nleft_indices = list of indices where l[i] == c.\n\nright_indices = list of indices where r[i] == c.\n\nThen, for each color c:\n\n    left_ptr = 0\n\n    right_ptr = 0\n\n    while left_ptr < len(left_indices) and right_ptr < len(right_indices):\n\n        left_idx = left_indices[left_ptr]\n\n        right_idx = right_indices[right_ptr]\n\n        if not used_left[left_idx] and not used_right[right_idx]:\n\n            pair them.\n\n            used_left[left_idx] = True\n\n            used_right[right_idx] = True\n\n            left_ptr += 1\n\n            right_ptr += 1\n\n        elif not used_left[left_idx]:\n\n            left_ptr += 1\n\n        elif not used_right[right_idx]:\n\n            right_ptr += 1\n\n        else:\n\n            # both are used, move both pointers\n\n            left_ptr += 1\n\n            right_ptr += 1\n\nBut this approach would work, but for each color, we have to loop through the left and right indices until they are all processed. However, this may be more efficient than checking all n elements for each color.\n\nBut how to implement this.\n\nAlternatively, during preprocessing, for each color, store the list of left and right indices. Then, for each color, process the left and right indices in order, and pair them as long as they are not used.\n\nBut how to handle this in code.\n\nThis seems feasible.\n\nOnce step 1 is done, then collect the remaining left and right boots (those not used) into L_q, R_q, L_s, R_s.\n\nThen, proceed to step 2.\n\nSo, for step 2:\n\nCollect all left indices not used and with color '?', into L_q.\n\nCollect all right indices not used and with color '?', into R_q.\n\nCollect all left indices not used and with color not '?', into L_s.\n\nCollect all right indices not used and with color not '?', into R_s.\n\nThen, process them as follows:\n\nFirst, pair as many as possible between L_q and R_q. For example, pair the first min(len(L_q), len(R_q)) pairs.\n\nThen, pair the remaining L_q with R_s (each left ? can pair with any right not used, regardless of color).\n\nThen, pair the remaining R_q with L_s (each right ? can pair with any left not used).\n\nSo, for example:\n\nFor the first part, pairing L_q and R_q:\n\nfor i in range(min(len(L_q), len(R_q))):\n\n    pair L_q[i] with R_q[i]\n\n    mark them as used.\n\nThen, for the remaining L_q and R_q:\n\nfor each left in L_q:\n\n    if there are any R_s not used, pair with them.\n\nSimilarly for R_q and L_s.\n\nBut how to track which ones are available.\n\nIn code, perhaps:\n\nWe can create a list for L_q and R_q, and then for R_s and L_s.\n\nBut for the remaining L_q and R_q, after pairing with each other, the remaining ones can be paired with R_s and L_s.\n\nSo, for example:\n\nremaining_L_q = L_q after pairing with R_q.\n\nremaining_R_q = R_q after pairing with L_q.\n\nThen, for each left in remaining_L_q:\n\n    if there are any right in R_s not yet used:\n\n        pair them.\n\nSimilarly for each right in remaining_R_q:\n\n    if there are any left in L_s not yet used:\n\n        pair them.\n\nBut how to track the R_s and L_s.\n\nBut during the initial collection, R_s and L_s are lists of indices not used. So, for example, R_s is a list of right indices not used, with color not '?'.\n\nSo, during this step, we can iterate through R_s and pair them with remaining_L_q.\n\nBut how to do this in code.\n\nAn efficient way would be to have pointers for R_s and L_s.\n\nBut perhaps, for code simplicity, we can use queues.\n\nBut given the time constraints, perhaps the following code steps:\n\nOnce we have L_q, R_q, L_s, R_s:\n\npair_Lq_Rq = min(len(L_q), len(R_q))\n\nfor i in 0 to pair_Lq_Rq - 1:\n\n    pair L_q[i] with R_q[i]\n\n    mark used_left[L_q[i]] = True\n\n    mark used_right[R_q[i]] = True\n\nThen, for the remaining L_q (after pair_Lq_Rq):\n\nremaining_Lq = L_q[pair_Lq_Rq : ]\n\nremaining_Rq = R_q[pair_Lq_Rq : ]\n\nThen, for each left in remaining_Lq:\n\n    if there are any right in R_s not used:\n\n        pair them.\n\nSimilarly for each right in remaining_Rq:\n\n    if there are any left in L_s not used:\n\n        pair them.\n\nBut how to track which R_s are not used.\n\nWait, R_s was collected as the list of right indices not used, with color not '?'. But during the pairing of L_q and R_q, some of the R_s may have been used? No, because R_s are the right indices not used and with color not '?'. The R_q are right indices not used with color '?'. So, during the pairing of L_q and R_q, they are from R_q, not R_s.\n\nSo, after pairing L_q and R_q, the R_s and L_s are still not used.\n\nThus, during the next steps, the R_s and L_s are still available.\n\nSo, for the remaining_Lq, we can pair them with R_s.\n\nSo, for example:\n\nWe can iterate through the remaining_Lq and R_s, and pair as many as possible.\n\nSimilarly for remaining_Rq and L_s.\n\nBut how to do this.\n\nFor example, for the remaining_Lq and R_s:\n\nWe can take the first len(remaining_Lq) elements from R_s (if available), and pair them.\n\nBut how to track which elements of R_s are not yet used.\n\nBut R_s is a list of right indices not used. Once we pair them, we have to mark them as used.\n\nSo, perhaps:\n\nWe can have a pointer for R_s, say r_s_ptr = 0.\n\nfor left in remaining_Lq:\n\n    if r_s_ptr < len(R_s):\n\n        pair left with R_s[r_s_ptr]\n\n        mark used_left[left] = True\n\n        mark used_right[R_s[r_s_ptr]] = True\n\n        r_s_ptr += 1\n\n    else:\n\n        break\n\nSimilarly, for the remaining_Rq and L_s:\n\nl_s_ptr = 0\n\nfor right in remaining_Rq:\n\n    if l_s_ptr < len(L_s):\n\n        pair right with L_s[l_s_ptr]\n\n        mark used_right[right] = True\n\n        mark used_left[L_s[l_s_ptr]] = True\n\n        l_s_ptr += 1\n\n    else:\n\n        break\n\nThis would pair as many as possible.\n\nBut what about the remaining elements in R_s and L_s after this? Well, they can't be paired with anything else, since they are non-? and there are no ? left to pair with them.\n\nSo, this would give the maximum possible pairs.\n\nThus, the overall plan is:\n\nProcess step 1: pair all same-color non-? boots.\n\nThen, process step 2: pair the remaining boots using ?s.\n\nNow, the problem is to implement this in code.\n\nNow, considering that the code needs to output the pairs, we need to collect all the pairs made during step 1 and step 2.\n\nSo, the code will need to collect all the pairs in a list.\n\nNow, the code steps in Python:\n\nRead n.\n\nRead l and r.\n\nInitialize used_left and used_right as arrays of False.\n\nCollect the pairs.\n\nThen, for step 1:\n\nprecompute for each color c (non-?), the left_indices and right_indices.\n\nfor each color c in all possible colors (a-z):\n\n    left_indices = list of i where l[i] == c.\n\n    right_indices = list of i where r[i] == c.\n\n    left_ptr = 0\n\n    right_ptr = 0\n\n    while left_ptr < len(left_indices) and right_ptr < len(right_indices):\n\n        left_idx = left_indices[left_ptr]\n\n        right_idx = right_indices[right_ptr]\n\n        if not used_left[left_idx] and not used_right[right_idx]:\n\n            # pair them\n\n            pairs.append( (left_idx+1, right_idx+1) )\n\n            used_left[left_idx] = True\n\n            used_right[right_idx] = True\n\n            left_ptr += 1\n\n            right_ptr += 1\n\n        elif not used_left[left_idx]:\n\n            left_ptr += 1\n\n        elif not used_right[right_idx]:\n\n            right_ptr += 1\n\n        else:\n\n            left_ptr += 1\n\n            right_ptr += 1\n\nWait, but how to get the list of colors? For example, for all c in 'a' to 'z'?\n\nYes. So, for each color in 'a' to 'z':\n\nBut in",
    "response": "\n\nTo solve this problem, we need to maximize the number of compatible pairs of boots between left and right boots. Each boot can be either a specific color (denoted by a lowercase letter) or an indefinite color (denoted by a question mark '?'). A pair is considered compatible if both boots are the same specific color or if at least one of them is an indefinite color.\n\n### Approach\n1. **Direct Pairing of Specific Colors**: First, we pair all left boots with specific colors that match the corresponding right boots with the same specific color. This is done by iterating through each possible color (from 'a' to 'z') and matching available left and right boots for each color.\n\n2. **Handling Indefinite Colors**: After pairing all direct matches, we handle the remaining boots which either have indefinite colors or could not find a match due to insufficient counterparts. We use the indefinite colors to pair with any remaining specific color boots or other indefinite colors.\n\n3. **Efficient Matching**: We use pointers to efficiently track and pair remaining boots with indefinite colors, ensuring that we maximize the number of valid pairs without reusing any boot.\n\n### Solution Code\n```python\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    l = input[idx]\n    idx += 1\n    r = input[idx]\n    idx += 1\n\n    used_left = [False] * n\n    used_right = [False] * n\n    pairs = []\n\n    # Step 1: Pair specific colors\n    for c in 'abcdefghijklmnopqrstuvwxyz':\n        left_indices = []\n        right_indices = []\n        for i in range(n):\n            if l[i] == c:\n                left_indices.append(i)\n            if r[i] == c:\n                right_indices.append(i)\n        left_ptr = 0\n        right_ptr = 0\n        while left_ptr < len(left_indices) and right_ptr < len(right_indices):\n            li = left_indices[left_ptr]\n            ri = right_indices[right_ptr]\n            if not used_left[li] and not used_right[ri]:\n                pairs.append((li + 1, ri + 1))\n                used_left[li] = True\n                used_right[ri] = True\n                left_ptr += 1\n                right_ptr += 1\n            elif not used_left[li]:\n                left_ptr += 1\n            elif not used_right[ri]:\n                right_ptr += 1\n            else:\n                left_ptr += 1\n                right_ptr += 1\n\n    # Step 2: Collect remaining boots\n    L_q = []\n    R_q = []\n    L_s = []\n    R_s = []\n    for i in range(n):\n        if not used_left[i]:\n            if l[i] == '?':\n                L_q.append(i)\n            else:\n                L_s.append(i)\n        if not used_right[i]:\n            if r[i] == '?':\n                R_q.append(i)\n            else:\n                R_s.append(i)\n\n    # Pair L_q and R_q\n    min_len = min(len(L_q), len(R_q))\n    for i in range(min_len):\n        pairs.append((L_q[i] + 1, R_q[i] + 1))\n        used_left[L_q[i]] = True\n        used_right[R_q[i]] = True\n\n    # Remaining L_q and R_q after pairing with each other\n    remaining_Lq = L_q[min_len:]\n    remaining_Rq = R_q[min_len:]\n\n    # Pair remaining_Lq with R_s\n    r_s_ptr = 0\n    for li in remaining_Lq:\n        if r_s_ptr < len(R_s):\n            pairs.append((li + 1, R_s[r_s_ptr] + 1))\n            used_left[li] = True\n            used_right[R_s[r_s_ptr]] = True\n            r_s_ptr += 1\n\n    # Pair remaining_Rq with L_s\n    l_s_ptr = 0\n    for ri in remaining_Rq:\n        if l_s_ptr < len(L_s):\n            pairs.append((L_s[l_s_ptr] + 1, ri + 1))\n            used_left[L_s[l_s_ptr]] = True\n            used_right[ri] = True\n            l_s_ptr += 1\n\n    print(len(pairs))\n    for p in pairs:\n        print(p[0], p[1])\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into the number of boots and their respective color strings for left and right boots.\n2. **Direct Pairing**: For each color from 'a' to 'z', we check for matching left and right boots and pair them if both are unused.\n3. **Collecting Remaining Boots**: After direct pairing, we collect remaining boots with specific colors and indefinite colors separately.\n4. **Pairing Indefinite Colors**: We first pair remaining indefinite left boots with indefinite right boots. Then, we pair any remaining indefinite left boots with specific right boots and vice versa.\n5. **Output**: Finally, the number of valid pairs and the pairs themselves are printed.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    l = input[idx]\n    idx += 1\n    r = input[idx]\n    idx += 1\n\n    used_left = [False] * n\n    used_right = [False] * n\n    pairs = []\n\n    # Step 1: Pair specific colors\n    for c in 'abcdefghijklmnopqrstuvwxyz':\n        left_indices = []\n        right_indices = []\n        for i in range(n):\n            if l[i] == c:\n                left_indices.append(i)\n            if r[i] == c:\n                right_indices.append(i)\n        left_ptr = 0\n        right_ptr = 0\n        while left_ptr < len(left_indices) and right_ptr < len(right_indices):\n            li = left_indices[left_ptr]\n            ri = right_indices[right_ptr]\n            if not used_left[li] and not used_right[ri]:\n                pairs.append((li + 1, ri + 1))\n                used_left[li] = True\n                used_right[ri] = True\n                left_ptr += 1\n                right_ptr += 1\n            elif not used_left[li]:\n                left_ptr += 1\n            elif not used_right[ri]:\n                right_ptr += 1\n            else:\n                left_ptr += 1\n                right_ptr += 1\n\n    # Step 2: Collect remaining boots\n    L_q = []\n    R_q = []\n    L_s = []\n    R_s = []\n    for i in range(n):\n        if not used_left[i]:\n            if l[i] == '?':\n                L_q.append(i)\n            else:\n                L_s.append(i)\n        if not used_right[i]:\n            if r[i] == '?':\n                R_q.append(i)\n            else:\n                R_s.append(i)\n\n    # Pair L_q and R_q\n    min_len = min(len(L_q), len(R_q))\n    for i in range(min_len):\n        pairs.append((L_q[i] + 1, R_q[i] + 1))\n        used_left[L_q[i]] = True\n        used_right[R_q[i]] = True\n\n    # Remaining L_q and R_q after pairing with each other\n    remaining_Lq = L_q[min_len:]\n    remaining_Rq = R_q[min_len:]\n\n    # Pair remaining_Lq with R_s\n    r_s_ptr = 0\n    for li in remaining_Lq:\n        if r_s_ptr < len(R_s):\n            pairs.append((li + 1, R_s[r_s_ptr] + 1))\n            used_left[li] = True\n            used_right[R_s[r_s_ptr]] = True\n            r_s_ptr += 1\n\n    # Pair remaining_Rq with L_s\n    l_s_ptr = 0\n    for ri in remaining_Rq:\n        if l_s_ptr < len(L_s):\n            pairs.append((L_s[l_s_ptr] + 1, ri + 1))\n            used_left[L_s[l_s_ptr]] = True\n            used_right[ri] = True\n            l_s_ptr += 1\n\n    print(len(pairs))\n    for p in pairs:\n        print(p[0], p[1])\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 799,
        "completion_token_count": 1095,
        "thoughts_token_count": 8191
    }
}