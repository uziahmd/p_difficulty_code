{
    "start": 1758309478.1480663,
    "end": 1758309708.2324278,
    "start-formatted": "2025-09-20 04:17 KST",
    "end-formatted": "2025-09-20 04:21 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\nOkay, let's try to figure out this problem. So the task is to find two things for a given p: the minimum number of nodes required to create a p-reachable directed graph, and then among all such graphs with that minimum number of nodes, find the maximum number of unidirectional pairs.\n\nFirst, I need to understand what exactly a p-reachable graph is. The definition says it's a directed graph that contains exactly p ordered pairs (u, v) where u < v and u and v are reachable from each other. So for each such pair, both directions must have paths. Wait, no—reachability is mutual here. So if u and v are reachable from each other, then (u, v) and (v, u) are both in the reachability relation. But the problem counts only the ordered pairs where u < v. So for each pair of nodes that are mutually reachable, we count exactly one ordered pair (the one with u < v).\n\nSo the first part of the problem is to find the minimal number of nodes n such that there exists a directed graph with exactly p such pairs. Then, among those graphs, find the maximum number of unidirectional pairs.\n\nLet me think about how to model this. Let's consider the structure of the graph that would minimize the number of nodes for a given p.\n\nThe key here is that the number of mutual pairs (u, v) with u < v depends on the structure of strongly connected components (SCCs). Because if two nodes are in the same SCC, they are mutually reachable. Also, if there's a path from component A to component B, then any node in A can reach any node in B, but not vice versa. However, for mutual reachability between two nodes, they must be in the same SCC.\n\nTherefore, the mutual pairs are exactly the pairs of nodes within the same SCC. For each SCC of size k, the number of ordered pairs (u, v) with u < v and u and v in the same SCC is C(k, 2) = k*(k-1)/2. Because for each pair of nodes in the same component, since they are mutually reachable, and u < v contributes one such pair.\n\nSo the total p is the sum over all SCCs of C(k_i, 2), where k_i is the size of each SCC.\n\nOur goal is to find the minimal n such that there exists a set of integers k_1, k_2, ..., k_m with sum k_i = n, and sum_{i} C(k_i, 2) = p.\n\nMoreover, once we have the minimal n, we need to maximize the number of unidirectional pairs. How do unidirectional pairs come into play?\n\nA unidirectional pair (u, v) is one where u != v, there's a path from u to v, but no path from v to u. So such pairs are between nodes in different SCCs. Suppose there's an edge from component A to component B, but not the other way. Then any pair (a, b) where a is in A and b is in B would be unidirectional if there's a path from a to b but not vice versa.\n\nBut how to count the total number of such pairs? Let's think about the structure of the DAG formed by the SCCs. Let's say the DAG has components arranged in a way that there's a topological order. For each pair of components A and B, if there is a directed edge from A to B (and no edge from B to A), then all pairs (a, b) where a is in A and b is in B contribute to unidirectional pairs. However, if there's a path from A to B, but not the other way, then all such pairs are unidirectional.\n\nBut in the case of a DAG of components, the number of unidirectional pairs between components can be calculated as follows: for each pair of components (A, B) where A comes before B in the topological order (so there's a path from A to B but not the reverse), the number of such pairs is |A| * |B|. However, if there's a path from A to B and also from B to A, then they would be in the same component, so that's not possible.\n\nWait, but in the DAG of components, there are no cycles. So between any two components, there's at most one direction of path. So for two components A and B, either there's a path from A to B, or from B to A, or neither. But if there's a path from A to B, then all pairs (a, b) where a is in A and b is in B are unidirectional pairs (since there's a path from a to b, but not from b to a). Similarly, if there's a path from B to A, then the pairs (b,",
    "response": "To solve this problem, we need to determine the minimum number of nodes required to create a p-reachable directed graph and then find the maximum number of unidirectional pairs in such graphs.\n\n### Approach\n1. **Understanding Reachability**: A p-reachable graph contains exactly `p` ordered pairs (u, v) where u < v and both nodes are mutually reachable. This is equivalent to counting the number of unordered pairs within each strongly connected component (SCC) of the graph.\n\n2. **Minimizing Nodes**: The goal is to minimize the number of nodes `n` such that the sum of combinations of sizes of SCCs equals `p`. This is achieved by using the largest possible SCC sizes first, which minimizes the total number of nodes needed.\n\n3. **Maximizing Unidirectional Pairs**: Once the minimal number of nodes is determined, we maximize the number of unidirectional pairs by considering the structure of the DAG formed by the SCCs. The maximum number of unidirectional pairs is derived from the arrangement of these components.\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    p = int(sys.stdin.readline())\n    if p == 0:\n        print(\"0 0\")\n        return\n    \n    # Find minimal n\n    n = 0\n    remaining = p\n    k = 1\n    while remaining > 0:\n        max_c = k * (k - 1) // 2\n        if remaining >= max_c:\n            remaining -= max_c\n            n += k\n            k += 1\n        else:\n            break\n    # Now, find the correct k\n    # The current k-1 is the largest possible, but we may need to adjust\n    # Let's try to find the correct size\n    # So, the minimal n is sum of sizes of components, which are as large as possible\n    # We need to adjust the last component\n    # For example, if after adding all k from 1 to m, we have some remaining, we need to replace the last component\n    # Let's redo it properly\n    n = 0\n    remaining = p\n    components = []\n    k = 1\n    while True:\n        c = k * (k - 1) // 2\n        if remaining >= c:\n            components.append(k)\n            remaining -= c\n            n += k\n            k += 1\n        else:\n            break\n    if remaining > 0:\n        # Need to adjust the last component\n        # Find the smallest m such that m*(m-1)/2 >= remaining\n        # But since we have already added up to k-1, now we have to replace the last component\n        # Let's remove the last component and find the new one\n        if components:\n            last = components.pop()\n            n -= last\n        # Now find the size for the new component\n        m = 1\n        while m * (m - 1) // 2 < remaining:\n            m += 1\n        components.append(m)\n        n += m\n        remaining -= m * (m - 1) // 2\n    # Now, components contains the sizes of the SCCs, sum to n\n    # Now compute the maximum number of unidirectional pairs\n    # The maximum is achieved when the DAG of components is a linear chain (each component points to the next)\n    # The number of unidirectional pairs is sum_{i<j} (size_i * size_j) * 2? No.\n    # Wait, no. Each pair of components A and B, if there's a path from A to B, then all pairs (a,b) where a is in A and b is in B contribute to unidirectional pairs.\n    # If the DAG is a linear chain, then for each pair of components (A_i, A_j), i < j, there's a path from A_i to A_j. Thus, the number of unidirectional pairs is sum_{i < j} (size_i * size_j)\n    # Because for each such pair, all a in A_i and b in A_j contribute one unidirectional pair (a,b)\n    # So the total is (total_nodes^2 - sum (size_i^2)) ) / 2\n    # Because sum_{i != j} size_i * size_j = (sum size_i)^2 - sum size_i^2\n    # And since we count only i < j, it's half of that\n    total_nodes = n\n    sum_sq = sum(x*x for x in components)\n    total_uni = (total_nodes * total_nodes - sum_sq) // 2\n    print(f\"{n} {total_uni}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Finding Minimum Nodes**: We start by determining the minimum number of nodes required by greedily using the largest possible sizes of SCCs. This ensures that we minimize the total number of nodes while achieving the required number of mutual pairs.\n\n2. **Calculating Unidirectional Pairs**: Once the minimal number of nodes is determined, we calculate the maximum number of unidirectional pairs by considering the structure of the DAG formed by the SCCs. The maximum number of unidirectional pairs is derived from the sum of products of sizes of different SCCs arranged in a linear chain, which maximizes the number of such pairs.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    p = int(sys.stdin.readline())\n    if p == 0:\n        print(\"0 0\")\n        return\n    \n    # Find minimal n\n    n = 0\n    remaining = p\n    k = 1\n    while remaining > 0:\n        max_c = k * (k - 1) // 2\n        if remaining >= max_c:\n            remaining -= max_c\n            n += k\n            k += 1\n        else:\n            break\n    # Now, find the correct k\n    # The current k-1 is the largest possible, but we may need to adjust\n    # Let's try to find the correct size\n    # So, the minimal n is sum of sizes of components, which are as large as possible\n    # We need to adjust the last component\n    # For example, if after adding all k from 1 to m, we have some remaining, we need to replace the last component\n    # Let's redo it properly\n    n = 0\n    remaining = p\n    components = []\n    k = 1\n    while True:\n        c = k * (k - 1) // 2\n        if remaining >= c:\n            components.append(k)\n            remaining -= c\n            n += k\n            k += 1\n        else:\n            break\n    if remaining > 0:\n        # Need to adjust the last component\n        # Find the smallest m such that m*(m-1)/2 >= remaining\n        # But since we have already added up to k-1, now we have to replace the last component\n        # Let's remove the last component and find the new one\n        if components:\n            last = components.pop()\n            n -= last\n        # Now find the size for the new component\n        m = 1\n        while m * (m - 1) // 2 < remaining:\n            m += 1\n        components.append(m)\n        n += m\n        remaining -= m * (m - 1) // 2\n    # Now, components contains the sizes of the SCCs, sum to n\n    # Now compute the maximum number of unidirectional pairs\n    # The maximum is achieved when the DAG of components is a linear chain (each component points to the next)\n    # The number of unidirectional pairs is sum_{i<j} (size_i * size_j) * 2? No.\n    # Wait, no. Each pair of components A and B, if there's a path from A to B, then all pairs (a,b) where a is in A and b is in B contribute to unidirectional pairs.\n    # If the DAG is a linear chain, then for each pair of components (A_i, A_j), i < j, there's a path from A_i to A_j. Thus, the number of unidirectional pairs is sum_{i < j} (size_i * size_j)\n    # Because for each such pair, all a in A_i and b in A_j contribute one unidirectional pair (a,b)\n    # So the total is (total_nodes^2 - sum (size_i^2)) ) / 2\n    # Because sum_{i != j} size_i * size_j = (sum size_i)^2 - sum size_i^2\n    # And since we count only i < j, it's half of that\n    total_nodes = n\n    sum_sq = sum(x*x for x in components)\n    total_uni = (total_nodes * total_nodes - sum_sq) // 2\n    print(f\"{n} {total_uni}\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 481,
        "completion_token_count": 1139,
        "thoughts_token_count": 1024
    }
}