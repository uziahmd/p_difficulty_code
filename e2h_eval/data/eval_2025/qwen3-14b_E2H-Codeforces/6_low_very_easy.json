{
    "start": 1758313547.1327102,
    "end": 1758313873.2228925,
    "start-formatted": "2025-09-20 05:25 KST",
    "end-formatted": "2025-09-20 05:31 KST",
    "gpu": 2,
    "pid": 6,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\nOkay, let's see. The problem is about finding two non-overlapping vouchers whose durations add up to exactly x, and their total cost is minimized. Hmm.\n\nSo first, I need to process each voucher and check for pairs that meet the conditions. But with n up to 2e5, a brute-force approach checking all pairs would be O(n²), which is way too slow. So I need an efficient way.\n\nLet me think about the duration. Each voucher has a duration of (ri - li + 1). Let's call this d_i. We need two vouchers where d_i + d_j = x, and they don't overlap.\n\nSo for each voucher, maybe I can look for another voucher with duration x - d_i, and check if they don't overlap. But how to efficiently find the minimum cost for such vouchers?\n\nThe idea is to group vouchers by their duration. For example, for each duration d, we can keep track of all vouchers with that duration, and for each voucher, check if there's a voucher with duration (x - d) that doesn't overlap with it.\n\nBut even then, for each voucher, checking all vouchers of the complementary duration might be expensive. Unless we can pre-process the vouchers for each duration in a way that allows us to quickly find the minimum cost of a voucher that ends before the current one starts, or starts after the current one ends.\n\nWait, here's a plan:\n\n- Precompute for each possible duration d, a sorted list of vouchers with that duration. Then, for each voucher i with duration d, we can look for vouchers with duration (x - d). For each such voucher j, check if they are non-overlapping. But how to find the minimal cost for those j's that are non-overlapping with i?\n\nAlternatively, for each voucher, we can check if there exists a voucher of duration (x - d_i) that ends before l_i, or starts after r_i. Then, among those, find the minimal cost.\n\nSo the steps could be:\n\n1. Preprocess all vouchers, grouping them by their duration. Let's have a dictionary, say, duration_dict, where keys are durations and values are lists of (l, r, cost) tuples.\n\n2. For each voucher i with duration d, check if (x - d) exists in duration_dict. If not, skip.\n\n3. For each such voucher i, we need to find the minimal cost of vouchers in duration_dict[x - d] that do not overlap with i. How to find that?\n\nFor the vouchers in duration_dict[x - d], we need to find those where r_j < l_i (so they end before i starts) or l_j > r_i (so they start after i ends). For each of these cases, we need the minimal cost.\n\nBut how to efficiently find the minimal cost for those vouchers?\n\nLet me think. For each duration d, we can pre-process the vouchers in a way that allows us to query for the minimal cost of vouchers that end before a certain time, or start after a certain time.\n\nFor example, for vouchers with a certain duration, say, target_duration, we can sort them based on their r (end time) and l (start time). Then, for a given voucher i, we can find all vouchers in target_duration that end before l_i, and find the minimal cost among those. Similarly, find all vouchers in target_duration that start after r_i, and find the minimal cost among those.\n\nSo for each duration d, we can have:\n\n- A sorted list of end times (r) along with the minimal cost up to that point. Or perhaps, for each duration, we can have two sorted arrays: one sorted by end time, and another sorted by start time. Then, for a given l_i, we can perform a binary search on the sorted end times to find all vouchers ending before l_i, and take the minimum cost from those.\n\nBut how to store the minimal cost? For example, for vouchers in a certain duration, sorted by their end time, we can have a prefix min array. So when we find the latest end time that is less than l_i, we can get the minimum cost up to that index.\n\nSimilarly, for vouchers sorted by start time, we can have a suffix min array. So when we find the earliest start time that is greater than r_i, we can get the minimum cost from that index onwards.\n\nSo here's the plan:\n\nFor each duration d in duration_dict:\n\n- Sort the vouchers in two ways:\n\n   a. Sorted by end time (r), and for each position in this sorted list, keep track of the minimum cost up to that position. This allows us to quickly find the minimum cost of vouchers ending before a certain time.\n\n   b. Sorted by start time (l), and for each position in this sorted list, keep track of the minimum cost from that position onwards. This allows us to quickly find the minimum cost of vouchers starting after",
    "response": "```python\nimport sys\nimport bisect\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    x = int(data[idx])\n    idx += 1\n    \n    vouchers = []\n    duration_dict = {}\n    \n    for _ in range(n):\n        l = int(data[idx])\n        idx += 1\n        r = int(data[idx])\n        idx += 1\n        cost = int(data[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n        if duration not in duration_dict:\n            duration_dict[duration] = []\n        duration_dict[duration].append((l, r, cost))\n    \n    # Preprocess each duration's list for efficient querying\n    # For each duration d, we have:\n    # sorted by end time (r), with prefix min cost\n    # sorted by start time (l), with suffix min cost\n    preprocessed = {}\n    for d in duration_dict:\n        lst = duration_dict[d]\n        # Sort by end time\n        sorted_by_end = sorted(lst, key=lambda x: x[1])\n        prefix_min = []\n        min_cost = float('inf')\n        for item in sorted_by_end:\n            min_cost = min(min_cost, item[2])\n            prefix_min.append(min_cost)\n        # Sort by start time\n        sorted_by_start = sorted(lst, key=lambda x: x[0])\n        suffix_min = [0]*len(sorted_by_start)\n        min_cost = float('inf')\n        for i in range(len(sorted_by_start)-1, -1, -1):\n            min_cost = min(min_cost, sorted_by_start[i][2])\n            suffix_min[i] = min_cost\n        preprocessed[d] = (sorted_by_end, prefix_min, sorted_by_start, suffix_min)\n    \n    min_total = float('inf')\n    \n    for l1, r1, cost1, d1 in vouchers:\n        target_d = x - d1\n        if target_d not in preprocessed:\n            continue\n        # Get the preprocessed data for target_d\n        sorted_by_end, prefix_min, sorted_by_start, suffix_min = preprocessed[target_d]\n        \n        # Find vouchers that end before l1\n        # Binary search in sorted_by_end for the largest r <= l1-1\n        end_times = [item[1] for item in sorted_by_end]\n        pos = bisect.bisect_right(end_times, l1 - 1) - 1\n        if pos >= 0:\n            min_cost_before = prefix_min[pos]\n            min_total = min(min_total, cost1 + min_cost_before)\n        \n        # Find vouchers that start after r1\n        # Binary search in sorted_by_start for the first l >= r1 + 1\n        start_times = [item[0] for item in sorted_by_start]\n        pos = bisect.bisect_left(start_times, r1 + 1)\n        if pos < len(start_times):\n            min_cost_after = suffix_min[pos]\n            min_total = min(min_total, cost1 + min_cost_after)\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport bisect\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    x = int(data[idx])\n    idx += 1\n    \n    vouchers = []\n    duration_dict = {}\n    \n    for _ in range(n):\n        l = int(data[idx])\n        idx += 1\n        r = int(data[idx])\n        idx += 1\n        cost = int(data[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n        if duration not in duration_dict:\n            duration_dict[duration] = []\n        duration_dict[duration].append((l, r, cost))\n    \n    # Preprocess each duration's list for efficient querying\n    # For each duration d, we have:\n    # sorted by end time (r), with prefix min cost\n    # sorted by start time (l), with suffix min cost\n    preprocessed = {}\n    for d in duration_dict:\n        lst = duration_dict[d]\n        # Sort by end time\n        sorted_by_end = sorted(lst, key=lambda x: x[1])\n        prefix_min = []\n        min_cost = float('inf')\n        for item in sorted_by_end:\n            min_cost = min(min_cost, item[2])\n            prefix_min.append(min_cost)\n        # Sort by start time\n        sorted_by_start = sorted(lst, key=lambda x: x[0])\n        suffix_min = [0]*len(sorted_by_start)\n        min_cost = float('inf')\n        for i in range(len(sorted_by_start)-1, -1, -1):\n            min_cost = min(min_cost, sorted_by_start[i][2])\n            suffix_min[i] = min_cost\n        preprocessed[d] = (sorted_by_end, prefix_min, sorted_by_start, suffix_min)\n    \n    min_total = float('inf')\n    \n    for l1, r1, cost1, d1 in vouchers:\n        target_d = x - d1\n        if target_d not in preprocessed:\n            continue\n        # Get the preprocessed data for target_d\n        sorted_by_end, prefix_min, sorted_by_start, suffix_min = preprocessed[target_d]\n        \n        # Find vouchers that end before l1\n        # Binary search in sorted_by_end for the largest r <= l1-1\n        end_times = [item[1] for item in sorted_by_end]\n        pos = bisect.bisect_right(end_times, l1 - 1) - 1\n        if pos >= 0:\n            min_cost_before = prefix_min[pos]\n            min_total = min(min_total, cost1 + min_cost_before)\n        \n        # Find vouchers that start after r1\n        # Binary search in sorted_by_start for the first l >= r1 + 1\n        start_times = [item[0] for item in sorted_by_start]\n        pos = bisect.bisect_left(start_times, r1 + 1)\n        if pos < len(start_times):\n            min_cost_after = suffix_min[pos]\n            min_total = min(min_total, cost1 + min_cost_after)\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 741,
        "completion_token_count": 719,
        "thoughts_token_count": 1024
    }
}