{
    "start": 1758008327.4052413,
    "end": 1758008505.11671,
    "start-formatted": "2025-09-16 16:38 KST",
    "end-formatted": "2025-09-16 16:41 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\nOkay, let's see. I need to solve this programming problem. Let me read the problem carefully again.\n\nThe problem is about Leha choosing two vouchers such that their durations add up exactly to x, and they don't overlap. And we need to find the minimal total cost of such a pair. If it's impossible, output -1.\n\nSo, the input is n vouchers, each with li (start day), ri (end day), and cost. The duration of a voucher is ri - li + 1. We need two vouchers i and j where the sum of their durations is exactly x. Also, they must not overlap. That means either the first ends before the second starts, or vice versa.\n\nFirst, I need to think about how to approach this efficiently. Because n can be up to 2e5, so O(n^2) approaches are definitely out of the question. So we need something smarter.\n\nLet me think: For each voucher, check if there exists another voucher that can pair with it such that their durations sum to x, and they don't overlap. But how to do this efficiently?\n\nLet me break it down. Let's say for a voucher with duration d, we need another voucher with duration x - d. So for each voucher, we can look for vouchers of duration (x - d) that end before the current voucher starts, or start after the current voucher ends.\n\nBut how to find the minimum cost for those?\n\nSo perhaps we can preprocess vouchers by their duration. Let's create a dictionary where for each possible duration, we have a list of vouchers with that duration, sorted by their end time (or start time?), and also keep track of the minimum cost for certain ranges.\n\nWait, but for each voucher of duration d, we need to find vouchers of duration (x - d) that don't overlap with it. So for example, if the current voucher is [li, ri], then any voucher of duration (x - d) that ends before li (so their ri' <= li - 1) or starts after ri (so their li' >= ri + 1).\n\nSo for each voucher, we can check for vouchers of the required duration that are before it or after it.\n\nBut how to find the minimum cost in those cases?\n\nAn idea: for each duration, we can have two structures:\n\n- A sorted list of the end times of vouchers with that duration, along with their minimum cost up to that point. So for example, for duration k, we can have a list sorted by end time, and for each position in the list, we have the minimum cost among all vouchers up to that position. Similarly, for the start times, maybe?\n\nAlternatively, for each duration k, we can pre-process two arrays:\n\n- For vouchers with duration k, sorted by their end time. Then, for a given li, we can find all vouchers in this list that end before li-1. The minimal cost among these would be the best candidate for the first case (voucher before current).\n\nSimilarly, for vouchers with duration k, sorted by their start time. Then, for a given ri, we can find all vouchers that start after ri+1. The minimal cost among these would be the best candidate for the second case (voucher after current).\n\nBut how to efficiently query these minima?\n\nLet me think. For each duration k, we can have two sorted lists:\n\n1. Sorted by end time (ri). For each such list, we can precompute a prefix minimum array. So when we need to find the minimal cost of vouchers with duration k that end before a certain value (say, li - 1), we can binary search the end time in the sorted list, find the largest end time that is <= li - 1, and then take the corresponding prefix minimum.\n\nSimilarly, for the other case, sorted by start time (li). For vouchers with duration k, sorted by start time. For a given ri, we want vouchers with start time >= ri + 1. So we can binary search the first start time that is >= ri + 1, and then take the suffix minimum from that index onwards.\n\nSo the plan is:\n\n- Preprocess all vouchers into a dictionary, where for each duration d, we have two sorted lists:\n\n   a) A list of vouchers with duration d, sorted by their end time (ri), along with a prefix min array.\n\n   b) A list of vouchers with duration d, sorted by their start time (li), along with a suffix min array.\n\nThen, for each voucher in the original list, compute its duration d. Then, check if x - d is a valid duration (i.e., exists in the dictionary). For each such voucher, we can look for vouchers of duration (x - d) that are before or after it.\n\nLet me formalize this.\n\nFor each voucher i with duration d_i:\n\n   target_duration = x - d_i\n\n   if target_duration is not present in the dictionary",
    "response": "\n\nTo solve this problem, we need to find two non-overlapping vouchers whose combined duration exactly matches a given value `x`, while minimizing the total cost. The solution involves efficiently searching for valid pairs using preprocessing and binary search techniques.\n\n### Approach\n1. **Preprocessing Vouchers by Duration**: Group vouchers by their duration. For each duration, maintain two sorted lists:\n   - One sorted by the end day of the voucher.\n   - Another sorted by the start day of the voucher.\n   \n2. **Prefix and Suffix Minimum Arrays**: For each sorted list of vouchers by end day, maintain a prefix minimum array to quickly find the minimum cost of vouchers ending before a specific day. Similarly, for the sorted list by start day, maintain a suffix minimum array to quickly find the minimum cost of vouchers starting after a specific day.\n\n3. **Binary Search for Efficient Lookup**: For each voucher, determine the required complementary duration. Use binary search on the preprocessed lists to find valid non-overlapping vouchers and compute the minimum cost efficiently.\n\n### Solution Code\n```python\nimport bisect\nimport sys\nimport collections\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    x = int(input[ptr])\n    ptr += 1\n\n    vouchers = []\n    duration_dict = collections.defaultdict(lambda: {'end': [], 'start': []})\n\n    for _ in range(n):\n        l = int(input[ptr])\n        ptr += 1\n        r = int(input[ptr])\n        ptr += 1\n        cost = int(input[ptr])\n        ptr += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n        # Add to duration_dict\n        duration_dict[duration]['end'].append((r, cost))\n        duration_dict[duration]['start'].append((l, cost))\n\n    # Preprocess the duration_dict to have sorted lists and min arrays\n    for d in duration_dict:\n        # Sort end list by end time (r)\n        end_list = duration_dict[d]['end']\n        end_list.sort()\n        # Create prefix min array\n        prefix_min = []\n        min_cost = float('inf')\n        for r, cost in end_list:\n            if cost < min_cost:\n                min_cost = cost\n            prefix_min.append(min_cost)\n        duration_dict[d]['end_prefix'] = prefix_min\n\n        # Sort start list by start time (l)\n        start_list = duration_dict[d]['start']\n        start_list.sort()\n        # Create suffix min array\n        suffix_min = [0] * len(start_list)\n        min_cost = float('inf')\n        for i in reversed(range(len(start_list))):\n            l, cost = start_list[i]\n            if cost < min_cost:\n                min_cost = cost\n            suffix_min[i] = min_cost\n        duration_dict[d]['start_suffix'] = suffix_min\n\n    min_total = float('inf')\n\n    for l, r, cost, d in vouchers:\n        target = x - d\n        if target not in duration_dict:\n            continue\n\n        # Check for vouchers with duration target that end before l\n        end_list = duration_dict[target]['end']\n        end_prefix = duration_dict[target]['end_prefix']\n        # Find the largest r' <= l-1\n        idx = bisect.bisect_right(end_list, (l-1, float('inf'))) - 1\n        if idx >= 0:\n            current_min = end_prefix[idx]\n            min_total = min(min_total, current_min + cost)\n\n        # Check for vouchers with duration target that start after r\n        start_list = duration_dict[target]['start']\n        start_suffix = duration_dict[target]['start_suffix']\n        # Find the first l' >= r+1\n        idx = bisect.bisect_left(start_list, (r+1, 0))\n        if idx < len(start_list):\n            current_min = start_suffix[idx]\n            min_total = min(min_total, current_min + cost)\n\n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into a list of vouchers, each characterized by start day, end day, cost, and duration.\n2. **Grouping by Duration**: Vouchers are grouped by their duration in a dictionary. Each entry in the dictionary contains lists sorted by end day and start day, along with prefix and suffix minimum cost arrays.\n3. **Efficient Lookup with Binary Search**: For each voucher, the required complementary duration is calculated. Using binary search, we efficiently find the minimum cost of non-overlapping vouchers either ending before or starting after the current voucher's period.\n4. **Result Calculation**: The minimum total cost of valid voucher pairs is computed and printed, or -1 if no valid pairs exist.",
    "ground_truth": "N/A",
    "extracted_answer": "import bisect\nimport sys\nimport collections\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    x = int(input[ptr])\n    ptr += 1\n\n    vouchers = []\n    duration_dict = collections.defaultdict(lambda: {'end': [], 'start': []})\n\n    for _ in range(n):\n        l = int(input[ptr])\n        ptr += 1\n        r = int(input[ptr])\n        ptr += 1\n        cost = int(input[ptr])\n        ptr += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n        # Add to duration_dict\n        duration_dict[duration]['end'].append((r, cost))\n        duration_dict[duration]['start'].append((l, cost))\n\n    # Preprocess the duration_dict to have sorted lists and min arrays\n    for d in duration_dict:\n        # Sort end list by end time (r)\n        end_list = duration_dict[d]['end']\n        end_list.sort()\n        # Create prefix min array\n        prefix_min = []\n        min_cost = float('inf')\n        for r, cost in end_list:\n            if cost < min_cost:\n                min_cost = cost\n            prefix_min.append(min_cost)\n        duration_dict[d]['end_prefix'] = prefix_min\n\n        # Sort start list by start time (l)\n        start_list = duration_dict[d]['start']\n        start_list.sort()\n        # Create suffix min array\n        suffix_min = [0] * len(start_list)\n        min_cost = float('inf')\n        for i in reversed(range(len(start_list))):\n            l, cost = start_list[i]\n            if cost < min_cost:\n                min_cost = cost\n            suffix_min[i] = min_cost\n        duration_dict[d]['start_suffix'] = suffix_min\n\n    min_total = float('inf')\n\n    for l, r, cost, d in vouchers:\n        target = x - d\n        if target not in duration_dict:\n            continue\n\n        # Check for vouchers with duration target that end before l\n        end_list = duration_dict[target]['end']\n        end_prefix = duration_dict[target]['end_prefix']\n        # Find the largest r' <= l-1\n        idx = bisect.bisect_right(end_list, (l-1, float('inf'))) - 1\n        if idx >= 0:\n            current_min = end_prefix[idx]\n            min_total = min(min_total, current_min + cost)\n\n        # Check for vouchers with duration target that start after r\n        start_list = duration_dict[target]['start']\n        start_suffix = duration_dict[target]['start_suffix']\n        # Find the first l' >= r+1\n        idx = bisect.bisect_left(start_list, (r+1, 0))\n        if idx < len(start_list):\n            current_min = start_suffix[idx]\n            min_total = min(min_total, current_min + cost)\n\n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 740,
        "completion_token_count": 1038,
        "thoughts_token_count": 1023
    }
}