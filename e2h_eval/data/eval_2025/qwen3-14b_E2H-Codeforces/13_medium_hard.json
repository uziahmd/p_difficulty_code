{
    "start": 1758344177.843233,
    "end": 1758344938.0482993,
    "start-formatted": "2025-09-20 13:56 KST",
    "end-formatted": "2025-09-20 14:08 KST",
    "gpu": 2,
    "pid": 13,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Chord\n\nVasya studies music. He has learned lots of interesting stuff. For example, he knows that there are 12 notes: C, C#, D, D#, E, F, F#, G, G#, A, B, H. He also knows that the notes are repeated cyclically: after H goes C again, and before C stands H. We will consider the C note in the row's beginning and the C note after the H similar and we will identify them with each other. The distance between the notes along the musical scale is measured in tones: between two consecutive notes there's exactly one semitone, that is, 0.5 tone. The distance is taken from the lowest tone to the uppest one, that is, the distance between C and E is 4 semitones and between E and C is 8 semitonesVasya also knows what a chord is. A chord is an unordered set of no less than three notes. However, for now Vasya only works with triads, that is with the chords that consist of exactly three notes. He can already distinguish between two types of triads — major and minor.Let's define a major triad. Let the triad consist of notes X, Y and Z. If we can order the notes so as the distance along the musical scale between X and Y equals 4 semitones and the distance between Y and Z is 3 semitones, then the triad is major. The distance between X and Z, accordingly, equals 7 semitones.A minor triad is different in that the distance between X and Y should be 3 semitones and between Y and Z — 4 semitones.For example, the triad \"C E G\" is major: between C and E are 4 semitones, and between E and G are 3 semitones. And the triplet \"C# B F\" is minor, because if we order the notes as \"B C# F\", than between B and C# will be 3 semitones, and between C# and F — 4 semitones.Help Vasya classify the triad the teacher has given to him.\n\n## Input\nThe only line contains 3 space-separated notes in the above-given notation.\n\n## Output\nPrint \"major\" if the chord is major, \"minor\" if it is minor, and \"strange\" if the teacher gave Vasya some weird chord which is neither major nor minor. Vasya promises you that the answer will always be unambiguous. That is, there are no chords that are both major and minor simultaneously.\n\n## Example\n### Input\n['C E G', 'C# B F', 'A B H']\n\n### Output\n['major', 'minor', 'strange']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\nOkay, let's see. I need to solve this programming problem where I have to determine if a given set of three musical notes forms a major triad, minor triad, or is strange. Let's break down the problem step by step.\n\nFirst, I need to understand the structure of major and minor triads. According to the problem statement:\n\nA major triad has three notes X, Y, Z such that when ordered, the distance between X and Y is 4 semitones, and between Y and Z is 3 semitones. So the total from X to Z would be 7 semitones. \n\nA minor triad is similar but with the distances reversed: X to Y is 3 semitones, Y to Z is 4 semitones. So total from X to Z is 7 semitones as well. \n\nBut since the triad is unordered, I need to check all possible permutations of the three notes to see if any of them fit either the major or minor pattern.\n\nSo the steps I need to do are:\n\n1. Convert the note names into their corresponding positions in the 12-note scale. For example, C is 0, C# is 1, D is 2, etc. Then H (which is B) is 11. Wait, the problem says the notes are C, C#, D, D#, E, F, F#, G, G#, A, B, H? Wait no, looking back at the problem statement:\n\nThe notes are listed as: C, C#, D, D#, E, F, F#, G, G#, A, B, H. Wait, but in the problem statement, it says that after H comes C again. Wait, but the list given includes B and H. Oh, perhaps there's a typo here. Wait, in the problem statement, the list says: \"C, C#, D, D#, E, F, F#, G, G#, A, B, H.\" So that's 12 notes. But in standard music theory, B and H are the same note. Oh right, in some countries, like Germany, they use H for B. So the problem uses H as B. So the order is:\n\nThe order is C, C#, D, D#, E, F, F#, G, G#, A, B, H? Wait wait, no. Wait the problem says that the notes are listed as C, C#, D, D#, E, F, F#, G, G#, A, B, H. Wait that's 12 notes. But then after H comes C again. So the order is:\n\nLet me list them in order:\n\n0: C\n\n1: C#\n\n2: D\n\n3: D#\n\n4: E\n\n5: F\n\n6: F#\n\n7: G\n\n8: G#\n\n9: A\n\n10: B\n\n11: H\n\nWait, but then after H (11) comes C again. So the next note after H is C (0). So the distance between H and C is 1 semitone. \n\nSo the first thing I need to do is create a mapping from note names to their numerical positions. For example, 'C' is 0, 'C#' is 1, 'D' is 2, etc., up to 'H' being 11.\n\nSo I can create a dictionary that maps each note to its index. Let me think about the order. The problem lists the notes as:\n\nC, C#, D, D#, E, F, F#, G, G#, A, B, H. Wait, but that's 12 elements. Let me count:\n\nC (0), C# (1), D (2), D# (3), E (4), F (5), F# (6), G (7), G# (8), A (9), B (10), H (11). Yes. So the order is correct.\n\nSo for example, the distance between C and E is 4 semitones. Because from C (0) to E (4) is 4 semitones. So the distance is calculated as (target - start) mod 12? Or just target - start if it's positive? Wait the problem says that the distance is measured from the lower to the upper note. So for example, between C and E, it's 4 semitones. Between E and C, it's 8 semitones. Because going the other way around. \n\nBut how do I compute the distance between two notes? Let's say we have two notes, X and Y. The distance from X to Y is (Y - X) if Y is higher than X. But if Y is lower than X, then the distance is (Y + 12 - X) semitones? Or wait, the problem says that the distance is measured along the musical scale from the lower to the upper note. So for example, if X is C (0), Y is H (11), then the distance from X to Y is 11 semitones. But if X is H (11) and Y is C (0), then the distance is (0 + 12 - 11) = 1 semitone. Wait, but according to the problem statement, the distance between X and Y is computed as the number of semitones moving upwards from X to Y. So if X is lower than Y, then it's Y - X. If X is higher than Y, then it's (Y + 12 - X) semitones. But how do I compute that?\n\nAlternatively, the distance between X and Y can be calculated as (Y - X) mod 12. But wait, that would give negative numbers. Wait, no. For example, if X is 0 (C) and Y is 4 (E), then Y - X is 4. Which is correct. If X is E (4) and Y is C (0), then Y - X is -4, which mod 12 is 8. Which is correct. So the distance from X to Y is (Y - X) if positive, else (Y - X + 12). But that's equivalent to (Y - X) % 12, but only when considering the distance as the number of semitones moving upwards. \n\nWait, no. Let's take X=0 (C), Y=11 (H). Then the distance from X to Y is 11 semitones. If X is Y=11 (H), and Y is 0 (C), then the distance from X to Y is 1 semitone. So (Y - X) mod 12 would be (0 - 11) mod 12 = 1. So that's correct. So the distance between X and Y is (Y - X) mod 12. But wait, when X is lower than Y, (Y - X) is positive. When X is higher than Y, (Y - X) is negative, but mod 12 gives the correct positive value.\n\nBut wait, the problem says that the distance is taken from the lower note to the upper note. So for example, the distance between C and E is 4 semitones. The distance between E and C is 8 semitones. So for two notes, the distance is (Y - X) if Y > X, else (Y - X + 12). Which is the same as (Y - X) % 12. But wait, (Y - X) mod 12 would be 4 when X is C and Y is E. When X is E and Y is C, (Y - X) is -4, mod 12 is 8. So that's correct. So the distance between X and Y is (Y - X) mod 12. However, in the problem statement, the distance between X and Y is considered as the number of semitones when moving upward from X to Y. So if the distance is 4 semitones, then moving upward from X to Y is 4 semitones. But if the distance is 8 semitones, that's moving upward from X to Y via the wrap-around.\n\nSo for the problem, the distance between X and Y is (Y - X) mod 12. But when considering the order of the notes, for example, in a major triad, the distance between X and Y must be exactly 4 semitones. So for the ordered triplet X, Y, Z, the distance between X and Y is 4, and between Y and Z is 3. So the total from X to Z would be 7 semitones. But how to find this in the given three notes.\n\nBut since the triad is unordered, I have to check all possible permutations of the three notes. For example, given three notes, I need to check all possible orderings to see if any permutation satisfies the major or minor conditions.\n\nSo for the three notes, there are 3! = 6 possible permutations. For each permutation, check if the first to second is 4, second to third is 3 (major), or first to second is 3, second to third is 4 (minor). If any permutation satisfies major, then output major. Similarly for minor. Otherwise, strange.\n\nSo the plan is:\n\n- Read the three notes.\n\n- Convert each note to its numerical index (using a dictionary).\n\n- Generate all permutations of the three notes (since the order matters for checking the distances).\n\n- For each permutation, check if it meets the major or minor conditions.\n\n- If any permutation meets major, return 'major'; if any meets minor, return 'minor'; else 'strange'.\n\nBut how to generate permutations? Well, in Python, itertools.permutations can be used. For example, for a list of three elements, permutations will generate all 6 possible orderings.\n\nNow, the steps in code:\n\nFirst, create a mapping from note names to their indices. Let's make a list of the notes in order, then use a dictionary to map each note to its index.\n\nnotes_order = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B', 'H']\n\nWait, but the problem says that the notes are listed as C, C#, D, D#, E, F, F#, G, G#, A, B, H. So the order is correct. So the indexes are 0 to 11.\n\nSo for example, 'B' is at index 10, 'H' is at index 11.\n\nSo the dictionary can be built as:\n\nnote_to_index = {note: idx for idx, note in enumerate(notes_order)}\n\nBut need to make sure that the list is correctly ordered. Let's check:\n\nThe order is:\n\n0: C\n\n1: C#\n\n2: D\n\n3: D#\n\n4: E\n\n5: F\n\n6: F#\n\n7: G\n\n8: G#\n\n9: A\n\n10: B\n\n11: H\n\nYes.\n\nOnce the three notes are converted into their indices, say a, b, c, then for each permutation (x, y, z) of (a, b, c), check:\n\ndistance from x to y is 4, and from y to z is 3 → major.\n\nOR\n\ndistance from x to y is 3, and from y to z is 4 → minor.\n\nBut how to calculate the distance between x and y? As (y - x) mod 12? Wait, no. Because the distance is calculated as the number of semitones moving upward from x to y. So for example, if x is 0 (C), y is 4 (E), then distance is 4. If x is 4 (E), y is 0 (C), then the distance is 8 semitones (since you have to go up from E to C via the cycle). So the distance is (y - x) if y >=x, else (y -x + 12). But that's equivalent to (y - x) % 12. But wait, (y -x) mod 12 gives the correct value. Let's see:\n\nFor x=4, y=0: (0 -4) mod 12 is 8, which is correct. So yes, the distance from x to y is (y -x) mod 12.\n\nSo for each permutation (x, y, z):\n\ndistance_xy = (y - x) % 12\n\ndistance_yz = (z - y) % 12\n\nThen, check if distance_xy ==4 and distance_yz ==3 → major.\n\nOr if distance_xy ==3 and distance_yz ==4 → minor.\n\nBut wait, the problem says that the distance between X and Y is 4 semitones, and between Y and Z is 3 semitones. So in the permutation (X,Y,Z), the distance from X to Y is 4, and from Y to Z is 3. But how do we ensure that the actual positions are such that when you move from X to Y, it's 4 semitones. For example, if X is C (0), Y is E (4), then distance is 4. If X is E (4), Y is C (0), the distance is 8. So in that case, the permutation (E, C, ...) would not satisfy the condition for major, because the distance between E and C is 8, not 4. So for the permutation to be valid, the distance between x and y must be exactly 4, and between y and z exactly 3.\n\nSo for each permutation, check those two distances.\n\nBut since the problem says that the answer is unambiguous, we can check all permutations and if any permutation meets the major condition, then the answer is major. Similarly for minor.\n\nSo, in code:\n\nRead the input. For example, the input is three space-separated notes. For example, 'C E G' → split into ['C', 'E', 'G'].\n\nConvert each note to its index. So for the example, they become 0, 4, 7.\n\nThen generate all permutations of these three indices. For each permutation, check for major and minor.\n\nOnce any permutation meets the major condition, return 'major'. Similarly for minor.\n\nNow, code steps:\n\nFirst, build the note_to_index dictionary.\n\nnotes_order = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B', 'H']\n\nnote_to_index = {note: idx for idx, note in enumerate(notes_order)}\n\nThen read the input. The input is a single line with three notes. For example, in the sample input, it's ['C E G', 'C# B F', 'A B H'] but the actual input is three space-separated notes. Wait, the problem says that the input is the only line contains 3 space-separated notes. So for example, in the sample input, the input is three different test cases? Wait, no. The sample input shows that the input is given as a list of three examples, but in reality, the input is a single line with three notes. For example, the sample input is:\n\nInput:\n\n['C E G', 'C# B F', 'A B H']\n\nBut that's probably a mistake. Wait, the problem says:\n\nInput:\n\nThe only line contains 3 space-separated notes in the above-given notation.\n\nSo for example, the input is something like \"C E G\" (for the first example), and the output is \"major\".\n\nBut in the sample input given in the problem, the input is given as a list of three examples. But that's probably a mistake in the problem description, and the actual input is three notes in one line. So for example, the sample input is:\n\nC E G\n\nand the output is major.\n\nBut in the problem's sample input, the input is written as ['C E G', 'C# B F', 'A B H'], but that's probably an error. Because in the problem statement, the input is a single line. So the sample input is three separate test cases, but the actual code should process one line of input.\n\nSo the code should read a single line, split into three notes.\n\nSo in code:\n\nimport sys\n\nfrom itertools import permutations\n\nnotes_order = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B', 'H']\n\nnote_to_index = {note: idx for idx, note in enumerate(notes_order)}\n\ninput_notes = input().strip().split()\n\nThen, for the three notes, get their indices:\n\na, b, c = input_notes\n\nindices = [note_to_index[a], note_to_index[b], note_to_index[c]]\n\nThen generate all permutations of these three indices.\n\nfor perm in permutations(indices):\n\n    x, y, z = perm\n\n    dist_xy = (y - x) % 12\n\n    dist_yz = (z - y) % 12\n\n    if dist_xy ==4 and dist_yz ==3:\n\n        print(\"major\")\n\n        exit()\n\n    if dist_xy ==3 and dist_yz ==4:\n\n        print(\"minor\")\n\n        exit()\n\nAfter checking all permutations, if none found, print 'strange'.\n\nBut wait, the problem says that the answer is always unambiguous, so there's no case where both major and minor are possible. So once any permutation meets the major condition, we can immediately return 'major', and similarly for minor.\n\nBut what about permutations that may have multiple possibilities? For example, if there are two permutations that meet the major condition, but that's okay.\n\nSo the code would check all permutations, and for each, check if it meets the major or minor condition.\n\nOnce any permutation meets major, output 'major' and exit. Same for minor.\n\nSo the code would proceed as follows:\n\nOnce the three notes are converted to indices, generate all permutations of the three indices. For each permutation, check for major or minor.\n\nNow, testing the sample input:\n\nSample Input 1: C E G → indices 0,4,7.\n\nPermutations:\n\nCheck all permutations. Let's take (0,4,7):\n\ndist_xy = (4-0) mod 12 = 4 → correct. dist_yz = (7-4) mod 12 = 3 → yes. So major. So output is major.\n\nSample Input 2: C# B F → which are C#, B, F. Let's convert to indices:\n\nC# is index 1.\n\nB is index 10.\n\nF is index 5.\n\nSo the indices are [1, 10, 5].\n\nLooking for permutations. One of them is (10, 1, 5). Let's check:\n\nx=10 (B), y=1 (C#), z=5 (F).\n\ndist_xy = (1 -10) mod 12 → ( -9 ) mod 12 → 3. Because 1 -10 = -9. 12 -9 = 3. So yes, 3. Then dist_yz is (5 -1) mod 12 →4. So 3 and 4 → minor. So output minor.\n\nAnother sample input is A B H → indices:\n\nA is 9, B is 10, H is 11.\n\nCheck all permutations.\n\nFor example, (9,10,11): dist_xy is 1, dist_yz is 1. No.\n\nAnother permutation: (9,11,10). dist_xy is (11-9)=2 mod 12 → 2. dist_yz is (10-11) mod 12 → ( -1 ) mod 12 = 11. No.\n\nAnother permutation: (10, 9, 11). dist_xy is (9-10) mod 12 → 11. No.\n\nAnother permutation: (10, 11, 9). dist_xy is (11-10) =1. dist_yz is (9-11) mod 12 → 10. No.\n\nAnother permutation: (11, 9, 10). dist_xy is (9-11) mod 12 = ( -2 ) mod 12 = 10. No.\n\nAnother permutation: (11, 10, 9). dist_xy is (10-11) mod 12 = 11. No.\n\nNo permutation meets the major or minor conditions. So output 'strange'.\n\nWhich matches the sample.\n\nSo the code seems correct.\n\nNow, possible edge cases:\n\nWhat if the three notes are the same? Well, according to the problem statement, the input is three notes. But the problem says that the answer is unambiguous. But according to the problem, the chord is a set of three notes. But the problem says that the input is three notes. But the problem says that the answer is always unambiguous. So perhaps the input will always be three distinct notes. But the code should handle even if they are not, but according to the problem statement, it's guaranteed that the answer is unique.\n\nBut the code doesn't need to check that. It just needs to process the three notes as given.\n\nAnother case: for example, a major triad that can be arranged in different permutations. For example, if the three notes are X, Y, Z, which are in the major triad. But when permuting, for example, (X, Y, Z) is major, but (Y, Z, X) would have distance between Y and Z as 3, and between Z and X as (X - Z) mod 12. Let's see: X to Y is 4, Y to Z is 3. So X to Z is 7. Then, Y to Z is 3, Z to X is (X - Z) mod 12 = (X - Z) mod 12. Since X is 4 semitones from Y, and Z is 3 semitones from Y. So X is Y +4, Z is Y +3. So X is Z +1. So Z to X is 1 semitone. So the permutation (Y, Z, X) would have distance between Y and Z as 3, and between Z and X as 1. Which does not meet the major or minor conditions. So the code will only detect the correct permutations.\n\nSo the code is correct.\n\nNow, code implementation:\n\nImplementing this in Python.\n\nNeed to import permutations from itertools.\n\nSo the code would be:\n\nRead the input line, split into three notes.\n\nCheck if any permutation of the three notes meets the major or minor condition.\n\nNow, code:\n\nimport sys\nfrom itertools import permutations\n\ndef main():\n    notes_order = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B', 'H']\n    note_to_index = {note: idx for idx, note in enumerate(notes_order)}\n    \n    input_line = sys.stdin.read().strip()\n    notes = input_line.split()\n    \n    # Get the indices of the three notes\n    try:\n        a, b, c = notes\n        indices = [note_to_index[a], note_to_index[b], note_to_index[c]]\n    except KeyError as e:\n        # According to the problem statement, input is valid, so this shouldn't happen\n        print(\"strange\")\n        return\n    \n    for perm in permutations(indices):\n        x, y, z = perm\n        dist_xy = (y - x) % 12\n        dist_yz = (z - y) % 12\n        if dist_xy == 4 and dist_yz == 3:\n            print(\"major\")\n            return\n        if dist_xy == 3 and dist_yz == 4:\n            print(\"minor\")\n            return\n    \n    print(\"strange\")\n\nif __name__ == \"__main__\":\n    main()\n\nWait, but the code uses permutations from itertools. So need to import that.\n\nBut in the code, the 'permutations' function is imported.\n\nTesting the sample input:\n\nSample input:\n\nC E G → outputs major.\n\nSample input C# B F → outputs minor.\n\nSample input A B H → outputs strange.\n\nAnother test case: C# B F → the code would process the notes as C#, B, F → indices 1, 10, 5.\n\nIn permutations, one of the permutations is (10, 1, 5). Let's compute:\n\nx=10, y=1 → (1 -10) mod 12 = ( -9 ) mod 12 = 3. dist_xy is 3. Then z=5. dist_yz is (5 -1) mod 12 = 4. So 3 and 4 → minor. So code returns minor.\n\nAnother test case: C E G → permutations (0,4,7) → dist_xy is 4, dist_yz is 3 → major.\n\nAnother test case: C E G# → indices 0,4,8. Let's see:\n\nCheck permutations. For example, (0,4,8): dist_xy is 4, dist_yz is 4 → no. Other permutations?\n\n(0,8,4): dist_xy is (8-0) mod 12 = 8. No.\n\nWhat about (4, 0, 8)? dist_xy is 0 -4 mod 12 → ( -4 ) mod 12 = 8. No.\n\nAnother permutation: (4, 8, 0). dist_xy is 4 → 8-4=4. dist_yz is (0 -8) mod 12 → 4. So 4 and 4 → no. Not major or minor. So output strange.\n\nSo code would return strange.\n\nSo the code seems correct.\n\nNow, what about a minor triad. For example, the sample input C# B F. So the code returns minor.\n\nAnother example: B C# F → which is the same as C# B F. The code will process it as the same.\n\nSo the code is correct.\n\nNow, what about a case where the same notes are arranged in a way that could be major or minor? But according to the problem statement, the answer is always unambiguous. So the code will find either major or minor, but not both.\n\nThus, the code should work.\n",
    "response": "To solve this problem, we need to determine if a given set of three musical notes forms a major triad, minor triad, or neither. The solution involves converting the notes into numerical indices, checking all permutations of these indices to see if they fit the criteria for a major or minor triad, and then outputting the result accordingly.\n\n### Approach\n1. **Convert Notes to Indices**: Map each note to its corresponding position in the 12-note musical scale.\n2. **Generate Permutations**: Since the order of notes in a triad can vary, generate all permutations of the three notes.\n3. **Check Distances**: For each permutation, calculate the distances between consecutive notes. A major triad requires a distance of 4 semitones between the first and second note, and 3 semitones between the second and third note. A minor triad requires the distances to be 3 and 4 semitones respectively.\n4. **Determine Result**: If any permutation matches the criteria for a major or minor triad, print the corresponding result. If none match, print \"strange\".\n\n### Solution Code\n```python\nimport sys\nfrom itertools import permutations\n\ndef main():\n    notes_order = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B', 'H']\n    note_to_index = {note: idx for idx, note in enumerate(notes_order)}\n    \n    input_line = sys.stdin.read().strip()\n    notes = input_line.split()\n    \n    # Get the indices of the three notes\n    try:\n        a, b, c = notes\n        indices = [note_to_index[a], note_to_index[b], note_to_index[c]]\n    except KeyError as e:\n        # According to the problem statement, input is valid, so this shouldn't happen\n        print(\"strange\")\n        return\n    \n    for perm in permutations(indices):\n        x, y, z = perm\n        dist_xy = (y - x) % 12\n        dist_yz = (z - y) % 12\n        if dist_xy == 4 and dist_yz == 3:\n            print(\"major\")\n            return\n        if dist_xy == 3 and dist_yz == 4:\n            print(\"minor\")\n            return\n    \n    print(\"strange\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Mapping Notes to Indices**: The notes are mapped to their respective positions in a list representing the 12-note scale. This allows easy conversion from note names to numerical values.\n- **Permutations Check**: By generating all permutations of the three notes, we ensure that every possible order is checked for the required distances.\n- **Distance Calculation**: Using modulo arithmetic, we compute the distances between notes considering the cyclic nature of the musical scale. This ensures that distances wrap around correctly from the end of the scale back to the beginning.\n- **Result Determination**: The solution checks each permutation for the specific distance criteria of major and minor triads, printing the appropriate result once a match is found. If no valid triad is found, it prints \"strange\".\n\nThis approach efficiently checks all possible configurations of the given notes, ensuring correctness and adherence to the problem constraints.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom itertools import permutations\n\ndef main():\n    notes_order = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'B', 'H']\n    note_to_index = {note: idx for idx, note in enumerate(notes_order)}\n    \n    input_line = sys.stdin.read().strip()\n    notes = input_line.split()\n    \n    # Get the indices of the three notes\n    try:\n        a, b, c = notes\n        indices = [note_to_index[a], note_to_index[b], note_to_index[c]]\n    except KeyError as e:\n        # According to the problem statement, input is valid, so this shouldn't happen\n        print(\"strange\")\n        return\n    \n    for perm in permutations(indices):\n        x, y, z = perm\n        dist_xy = (y - x) % 12\n        dist_yz = (z - y) % 12\n        if dist_xy == 4 and dist_yz == 3:\n            print(\"major\")\n            return\n        if dist_xy == 3 and dist_yz == 4:\n            print(\"minor\")\n            return\n    \n    print(\"strange\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 683,
        "completion_token_count": 692,
        "thoughts_token_count": 5699
    }
}