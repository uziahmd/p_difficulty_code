{
    "start": 1758008505.1170373,
    "end": 1758008700.6153326,
    "start-formatted": "2025-09-16 16:41 KST",
    "end-formatted": "2025-09-16 16:45 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\nOkay, let's try to figure out how to solve this problem. The task is to determine for a given n whether there exists a snowflake graph with exactly n vertices. The snowflake is constructed in a specific way, so I need to understand the structure of such a graph.\n\nFrom the problem description, the snowflake is built as follows:\n\n1. Start with one vertex.\n2. Connect it to k new vertices (k > 1). So after this step, there are 1 + k vertices.\n3. Then, each vertex that has only one connection (i.e., the leaves) must be connected to k new vertices. This step must be done at least once. \n\nWait, so the process is like building layers. Let me think about how the number of vertices grows with each step.\n\nLet me think of the snowflake construction step by step. Let's consider the initial steps.\n\nLet me take an example. Suppose k=2.\n\nInitial step: 1 node. Then connect to 2 nodes. Now total nodes is 1 + 2 = 3. Now, each of those 2 nodes is a leaf. Then we add k=2 new nodes to each of them. So each of the two leaves gets 2 new children. So adding 2*2=4 nodes. Total becomes 3+4=7. Then, if we do another step, each of the 4 new leaves would get 2 children each, adding 4*2=8 nodes, making total 7+8=15, etc.\n\nSo the structure seems to be that each time, the number of new nodes added is multiplied by k. But how does this relate to the total number of nodes?\n\nLet me model this. Let's think of the snowflake as having m layers. The first layer is the root. The second layer is the k children of the root. Then, each subsequent layer adds k times the previous layer's leaves. Wait, but each layer is built by expanding all the leaves from the previous layer.\n\nSo for example, the first step (after the initial node) is layer 1, which has k nodes. Then layer 2 adds k * k nodes, layer 3 adds k^3 nodes, etc. But how many layers are there?\n\nBut the problem says that the process of adding new nodes to the leaves must be done at least once. So the minimum number of steps after the initial step is one more step. Let me think again.\n\nThe initial step is the root. Then, the first expansion (step 1) adds k nodes. Then, the second expansion (step 2) adds k * k nodes. Then step 3 adds k^3, etc. So the total number of nodes after m expansions (where m >= 1) is:\n\nTotal = 1 + k + k^2 + k^3 + ... + k^m ?\n\nWait, no. Wait, the initial node is 1. Then the first expansion adds k nodes. Then the next expansion adds k * k nodes. Because each of the k nodes from the first expansion (which are all leaves) adds k new nodes. Then the third expansion adds k^2 * k = k^3 nodes. So after m expansions, the total number of nodes is 1 + k + k^2 + k^3 + ... + k^m ?\n\nYes. Because each expansion adds k^i where i is the expansion step. For example, the first expansion (step 1) adds k^1, the second adds k^2, etc. So the total is 1 + sum_{i=1}^m k^i.\n\nBut wait, the problem says that the second step (adding new nodes to leaves) must be done at least once. So the minimal case is when m=1. So the total number of nodes would be 1 + k + k^2? Or wait, maybe I'm getting confused here.\n\nWait, the initial step is the root. Then, the first expansion (step 1) adds k nodes. Then, the second expansion (step 2) adds k * k nodes. So for m expansions, the total is 1 + k + k^2 + ... + k^m? No, because the first expansion is step 1 (adding k), then step 2 adds k^2, etc. So for m expansions, the sum is 1 + sum_{i=1}^m k^i.\n\nBut the problem says that the step of adding new nodes to leaves must be done at least once. So m must be at least 1. So the total number of nodes is 1 + k + k^2 + ... + k^m where m ≥ 1. However, this sum can be written as (k^{m+1} - 1)/(k-1) - 1 + 1? Wait, no. Wait, the sum from",
    "response": "\n\nTo solve this problem, we need to determine whether a given number of vertices $ n $ can form a valid snowflake graph as defined in the problem. The snowflake graph is constructed in a specific hierarchical manner, and our task is to check if such a structure can exist for the given $ n $.\n\n---\n\n### **Understanding the Structure of the Snowflake Graph**\n\nThe construction of the snowflake graph follows these rules:\n\n1. Start with a single vertex (root).\n2. Connect this root to $ k $ new vertices.\n3. Each leaf (vertex with only one connection) must be connected to $ k $ new vertices. This expansion step must be done **at least once**.\n\nThis implies that the total number of vertices in the snowflake graph is:\n$$\nn = 1 + k + k^2 + k^3 + \\dots + k^m\n$$\nWhere:\n- $ m \\geq 1 $\n- $ k > 1 $\n\nThis sum is a geometric series:\n$$\nn = \\frac{k^{m+1} - 1}{k - 1}\n$$\n\nSo, for a given $ n $, we need to find values of $ k > 1 $ and $ m \\geq 1 $ such that this equation holds.\n\n---\n\n### **Approach to Solve the Problem**\n\nGiven the constraints ($ n \\leq 10^{18} $), a brute-force approach is not feasible. Instead, we can use the following strategy:\n\n1. For each test case value $ n $, iterate over possible values of $ k $ from 2 up to a maximum that could possibly satisfy the equation.\n2. For each $ k $, perform a binary search on $ m $ (number of expansions) to check if the sum equals $ n $.\n3. If such a pair $ (k, m) $ exists for any $ k > 1 $, return \"YES\"; otherwise, return \"NO\".\n\nWe optimize by noting that the maximum possible $ k $ is bounded by $ \\sqrt[n]{n} $, which is very small even for large $ n $, so checking all $ k $ from 2 to $ \\sqrt{n} $ is manageable.\n\n---\n\n### **Python Code Implementation**\n\n```python\nimport sys\nimport math\n\ndef is_snowflake(n):\n    if n == 1:\n        return False\n    max_k = int(n ** (1/2)) + 2\n    for k in range(2, max_k + 1):\n        # Binary search for m such that 1 + k + k^2 + ... + k^m == n\n        low = 1\n        high = 60  # since k^60 is way larger than 1e18\n        while low <= high:\n            mid = (low + high) // 2\n            total = (pow(k, mid + 1) - 1) // (k - 1)\n            if total == n:\n                return True\n            elif total < n:\n                low = mid + 1\n            else:\n                high = mid - 1\n    return False\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    results = []\n    for i in range(1, t + 1):\n        n = int(data[i])\n        if is_snowflake(n):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n---\n\n### **Explanation of the Code**\n\n- The function `is_snowflake(n)` checks whether there exists a valid $ k > 1 $ and $ m \\geq 1 $ such that $ n $ matches the geometric series formula.\n- We use a binary search on $ m $ for each possible $ k $ from 2 up to $ \\sqrt{n} $, ensuring the algorithm remains efficient even for large values of $ n $.\n- If any such pair $ (k, m) $ exists, we return \"YES\" for that test case.\n\n---\n\n### **Edge Cases Considered**\n\n- $ n = 1 $: Only one node, but the snowflake requires at least 2 nodes, so it's invalid.\n- $ n = 2 $: Not possible because the minimal snowflake has $ 1 + k + k^2 $ where $ k > 1 $, so minimum is $ 1 + 2 + 4 = 7 $.\n- Large $ n $: The loop is optimized to avoid unnecessary iterations.\n\nThis solution handles all edge cases efficiently and adheres to the constraints.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\n\ndef is_snowflake(n):\n    if n == 1:\n        return False\n    max_k = int(n ** (1/2)) + 2\n    for k in range(2, max_k + 1):\n        # Binary search for m such that 1 + k + k^2 + ... + k^m == n\n        low = 1\n        high = 60  # since k^60 is way larger than 1e18\n        while low <= high:\n            mid = (low + high) // 2\n            total = (pow(k, mid + 1) - 1) // (k - 1)\n            if total == n:\n                return True\n            elif total < n:\n                low = mid + 1\n            else:\n                high = mid - 1\n    return False\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    results = []\n    for i in range(1, t + 1):\n        n = int(data[i])\n        if is_snowflake(n):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 562,
        "completion_token_count": 985,
        "thoughts_token_count": 1023
    }
}