{
    "start": 1758313951.2209032,
    "end": 1758314308.4564908,
    "start-formatted": "2025-09-20 05:32 KST",
    "end-formatted": "2025-09-20 05:38 KST",
    "gpu": 2,
    "pid": 30,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# TV Game\n\nThere is a new TV game on BerTV. In this game two players get a number A consisting of 2n digits. Before each turn players determine who will make the next move. Each player should make exactly n moves. On it's turn i-th player takes the leftmost digit of A and appends it to his or her number Si. After that this leftmost digit is erased from A. Initially the numbers of both players (S1 and S2) are «empty». Leading zeroes in numbers A, S1, S2 are allowed. In the end of the game the first player gets S1 dollars, and the second gets S2 dollars.One day Homer and Marge came to play the game. They managed to know the number A beforehand. They want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize. Help them.\n\n## Input\nThe first line contains integer n (1 ≤ n ≤ 18). The second line contains integer A consisting of exactly 2n digits. This number can have leading zeroes.\n\n## Output\nOutput the line of 2n characters «H» and «M» — the sequence of moves of Homer and Marge, which gives them maximum possible total prize. Each player must make exactly n moves. If there are several solutions, output any of them.\n\n## Example\n### Input\n['2\\n1234', '2\\n9911']\n\n### Output\n['HHMM', 'HMHM']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\nOkay, let's try to figure out how to solve this problem. The problem says that Homer and Marge are playing a game where they take turns picking digits from the front of a number A. Each player takes exactly n moves, and we need to find the sequence of moves (H for Homer, M for Marge) that maximizes their total prize, which is S1 + S2. \n\nFirst, I need to understand the problem correctly. So, the number A has 2n digits. Each turn, the current player takes the leftmost digit and appends it to their own number. Then that digit is removed from A. The goal is to maximize the sum of the two numbers S1 and S2. \n\nThe key here is that each player wants to maximize their own number, but since they alternate turns, the choices they make affect each other. However, since the total sum is what's being maximized, perhaps there's a way to model this as a decision process where at each step, we choose whether Homer or Marge takes the next digit, considering the remaining digits and the optimal choices for the rest of the game.\n\nBut given that n can be up to 18, the total number of digits is 36. So for a brute force approach, trying all possible combinations of H and M (with exactly n H's and n M's) would be C(36, 18) possibilities, which is way too big. That's around 9e10, which is impossible to compute directly. So we need a dynamic programming approach here.\n\nLet me think about the state. Let's consider that during the game, the number of digits left is 2n - k, where k is the number of steps taken so far. But more importantly, the state depends on how many moves each player has made so far. Let's say that after some steps, Homer has made h moves and Marge has made m moves. Since each player must make exactly n moves, we have h + m = k steps taken. Also, h can't exceed n, and m can't exceed n. So the state could be represented by (h, m), and the current position in the string A. Wait, but the current position can be determined by how many digits have been taken. For example, if we have taken k digits, then the current A is the original string with the first k digits removed. So the state can be represented by the number of digits taken so far (k) and who's turn it is. Wait, no. Because the players take turns based on the sequence of moves. But the problem says that before each turn, the players decide who will make the next move. So the order of moves is determined by the sequence of H and M. However, the problem requires that exactly n H and n M moves are made. So the state needs to track how many H and M moves have been made so far, and which player is to move next. Wait, no. Because the choice of who moves next depends on the sequence. But the problem is that the players can choose who takes the next move, but the constraints are that each player makes exactly n moves. So the choice of who takes the next move depends on the current counts of H and M moves made. For example, if Homer has already taken h moves and Marge has taken m moves, then the next move can be either H or M, provided that h < n or m < n respectively. But the problem is that the players want to choose the next move (H or M) in a way that maximizes the total sum. \n\nBut how do we model this? Let's think recursively. Suppose we have a certain number of digits left, and the current state is (h, m) where h is the number of moves Homer has taken so far, m is the number of moves Marge has taken. The next move can be either H or M, depending on which is allowed. For example, if h < n, then Homer can take the next move. Similarly for Marge. But since the players are trying to maximize the total sum, the decision at each step depends on which choice (H or M) leads to a higher total sum.\n\nBut how do we compute the maximum sum for a given state? Let's think of the digits that are left. Suppose that the current state is (h, m) and there are k = h + m digits already taken. The remaining digits are the original A[k:]. So, for each state (h, m), we can consider the next move. If it's Homer's turn (i.e., we choose to take H next), then he takes the first digit of the remaining digits. Then the new state becomes (h+1, m). Similarly for Marge. But the problem is that the choice of who takes the next move is not fixed. For example, if both players still have moves left, the decision is which one to take next. But the players are trying to maximize the total sum. So the decision at each step is to choose between taking H or M, whichever gives a better total sum.\n\nSo the DP state can be represented by (h, m), and the current position in the string. But since the position is determined by h + m (since each step takes one digit from the front), the current position is fixed once h and m are known. For example, if h + m = k, then the current digits are A[k:].\n\nTherefore, the DP state can be represented as (h, m), and the value is the maximum total sum achievable from this state onwards. The transitions would be:\n\nFor the current state (h, m), the next move can be H if h < n, or M if m < n. However, the players are choosing between these options. For example, if both are possible, the decision is which option gives a higher total sum.\n\nWait, but how do we know which player is to choose next? The problem says that before each turn, the players decide who will make the next move. So, perhaps the choice is made by the players in a way that optimizes their total. But since both players are working towards maximizing the total sum, maybe the decision is made greedily. However, since the players are cooperating (they want to maximize the total sum, not just their own individual gains), the decision at each step is to choose between H and M, whichever leads to a higher total sum.\n\nWait, but the problem states that Homer and Marge want to maximize their total prize. So their goal is to maximize S1 + S2. Therefore, when choosing between H or M for the next move, they should choose the option that leads to the maximum total sum.\n\nSo the DP approach can work as follows: For each state (h, m), compute the maximum possible total sum from that state onwards. The base case is when h = n and m = n, in which case the total sum is 0. For other cases, we look at the current digit (the first digit of the remaining string, which is A[k], where k = h + m). Then, if the next move is H (possible only if h < n), then Homer takes that digit. The value contributed is the digit's value (since it's added to his number, which contributes to the total sum). Then, we add the result of the next state (h+1, m). Similarly, if the next move is M (possible only if m < n), then Marge takes the digit, which contributes to the total sum, and we add the result of the next state (h, m+1).\n\nWait, but how does the digit contribute to the total sum? Let me think. Suppose the current digit is d. If Homer takes it, then it's added to his number S1. Similarly for Marge. The total sum is S1 + S2. However, the digits are added to their numbers in the order they are taken. For example, if Homer takes digits d1, d2, then his number is d1 followed by d2. But the actual value of S1 is d1 * 10^{n-1} + d2 * 10^{n-2} + ... etc. But wait, the problem says that the total prize is S1 + S2. However, the problem says that the numbers S1 and S2 are formed by appending digits. So, for example, if n is 2, and Homer takes digits 1 and 2, his number is 12. Similarly for Marge. So the total is 12 + whatever Marge's number is.\n\nBut how can we model this in DP? Because the contribution of each digit depends on its position in the number. For example, the first digit taken by a player contributes more than the second, etc. So, the problem is that the same digit can contribute different values depending on when it's taken. Therefore, the DP approach can't just track the sum of digits, because the positions matter. Oh wait, this complicates things a lot. Because the total sum isn't just the sum of all digits, but the actual numerical values of S1 and S2.\n\nThis seems like a big problem. Because if we have to track the actual value of S1 and S2, then for n=18, each number can be up to 1e18 digits long, which is impossible to store. Therefore, we need another approach.\n\nWait, but the problem says that we need to maximize the sum of S1 and S2. Let's think about how the digits contribute to this sum. Each digit taken by Homer contributes to S1, and each digit taken by Marge contributes to S2. The value of each digit in S1 depends on the position in which it was taken. For example, if Homer takes a digit in his i-th move (where i ranges from 1 to n), then that digit is multiplied by 10^{n - i} in the final value of S1. Similarly for Marge.\n\nSo, for example, the first digit Homer takes is the first digit of his number, which contributes d * 10^{n-1}, the second digit contributes d * 10^{n-2}, etc. Similarly for Marge.\n\nSo the total sum S1 + S2 can be calculated as the sum over all digits taken by Homer multiplied by their respective weights plus the sum over all digits taken by Marge multiplied by their respective weights.\n\nBut how can we model this in the DP? Because each time a digit is taken, the weight depends on the number of moves that the player has already made. For example, when Homer takes his h-th move (so he has taken h digits so far), the digit is added to his number as the h-th digit. Wait, no. Wait, the first move for Homer adds the first digit of his number. The second move adds the second digit, and so on. So, when he takes the h-th digit (i.e., his h-th move), that digit is the h-th digit in his number. Therefore, its weight is 10^{n - h} (since the number has n digits, and the first digit is multiplied by 10^{n-1}, the second by 10^{n-2}, etc.)\n\nWait, let's think of n=2. If Homer takes two digits, the first one is the first digit of his number. So, for example, if he takes 1 then 2, his number is 12, which is 1*10^1 + 2*10^0. So the first digit (taken in his first move) has weight 10^{n-1} = 10^(2-1) = 10^1. The second digit (taken in his second move) has weight 10^{n-2} = 10^0.\n\nSo, for any digit that a player takes in their k-th move (k ranges from 1 to n), the weight is 10^{n - k}.\n\nTherefore, when a player takes a digit, the contribution to the total sum is digit * 10^{n - (current_move_count)} where current_move_count is how many times that player has taken a digit before this move. For example, if Homer has taken h moves before this move, and this is his h+1-th move, then the weight is 10^{n - (h+1)}.\n\nSo, the problem reduces to selecting the order of H and M moves such that the sum of all digits multiplied by their respective weights (based on when they were taken) is maximized.\n\nNow, the challenge is to model this in a DP. Let's think of the state as (h, m), where h is the number of moves Homer has made so far, and m is the number of moves Marge has made so far. At this state, the next move can be H (if h < n) or M (if m < n). The current position in the string is determined by h + m, since each move takes one digit from the front.\n\nAt each step, when choosing to take H, the current digit is added to Homer's count, contributing digit * 10^{n - (h + 1)} to the total sum. Then, we proceed to the state (h + 1, m). Similarly for M.\n\nTherefore, the DP function can be defined as follows: dp(h, m) returns the maximum total sum achievable from the state (h, m) onwards. The recurrence is:\n\ndp(h, m) = max(\n    if h < n: value of taking H now + dp(h+1, m),\n    if m < n: value of taking M now + dp(h, m+1)\n)\n\nBut since we have to choose between H and M, the decision is which option gives a higher total sum. However, in the case where both options are possible (h < n and m < n), we have to choose the one that gives the maximum sum.\n\nBut how do we compute this? Let's think of the base case. When h = n and m = n, the total sum is zero. Otherwise, for each state (h, m), we can compute the maximum possible sum.\n\nBut the problem is that for n=18, the number of possible states is (n+1) * (n+1) = 19*19=361. Which is very manageable. So the DP is feasible here.\n\nWait, but for each state (h, m), the current digit is A[k], where k = h + m. So for each state, we can compute the current digit. Then, when choosing H or M, we calculate the contribution of that digit to the sum, and then add the result of the next state.\n\nSo the DP approach is feasible. The maximum number of states is (n+1)*(n+1) = 361 for n=18. And for each state, we have to compute the value of taking H or M, if possible.\n\nSo the DP can be memoized. Now, the question is how to compute the contribution of the current digit when choosing H or M.\n\nLet's formalize this. For state (h, m), the current position is k = h + m. The current digit is A[k]. If we choose to take H, then the contribution is digit * 10^{n - (h + 1)}, because this is Homer's (h+1)-th move. Similarly, if we take M, the contribution is digit * 10^{n - (m + 1)}.\n\nSo the DP function can be implemented with memoization, and for each state (h, m), we can compute the maximum sum possible.\n\nOnce we have the DP table, how do we reconstruct the path (the sequence of H and M moves) that leads to the maximum sum?\n\nWe need to track, for each state (h, m), which choice (H or M) was taken to reach the maximum sum. So during the DP computation, we can also track the decision made at each state.\n\nSo, the plan is:\n\n1. Precompute the digits of A as a list, so that we can quickly get the current digit for a given state (h, m) as A[h + m].\n\n2. Implement a memoization-based DP function that returns the maximum sum for state (h, m), and also tracks the choice (H or M) made at each step.\n\n3. Once the DP is computed, reconstruct the path by starting from (0, 0) and, for each state, choosing the best option (H or M) according to the tracked decisions.\n\nBut how do we handle the memoization? Since Python allows memoization via lru_cache for small parameters, but for n up to 18, the parameters h and m are up to 18, which is manageable.\n\nBut the problem is that the digits are part of the input, and the DP depends on them. However, since the digits are fixed once the input is read, the DP function can be written with access to the digits array.\n\nNow, the code structure would be something like:\n\nRead n and A.\n\ndigits = list of integers of A's characters.\n\nCompute the DP for (h, m) states.\n\nBut for the DP, we need to compute for each (h, m) the maximum sum. Let's think of memoizing with memo[(h, m)] = (max_sum, choice), where choice is 'H' or 'M'.\n\nBut how to implement this. Let's think recursively.\n\nBut recursion may not be efficient for Python, but with n=18, it's manageable. Alternatively, we can use memoization with a memo table.\n\nLet's think of writing a recursive function with memoization. For example:\n\nmemo = {}\n\ndef dp(h, m):\n\n    if (h, m) in memo:\n        return memo[(h, m)]\n\n    k = h + m\n    if k == 2n:\n        return 0\n\n    current_digit = int(A[k])\n\n    max_sum = -infinity\n\n    # check if H can be chosen\n    if h < n:\n        contribution_H = current_digit * (10 ** (n - (h + 1)))\n        next_sum = dp(h + 1, m)\n        total_H = contribution_H + next_sum\n        if total_H > max_sum:\n            max_sum = total_H\n            choice_H = 'H'\n\n    # check if M can be chosen\n    if m < n:\n        contribution_M = current_digit * (10 ** (n - (m + 1)))\n        next_sum = dp(h, m + 1)\n        total_M = contribution_M + next_sum\n        if total_M > max_sum:\n            max_sum = total_M\n            choice_M = 'M'\n\n    memo[(h, m)] = (max_sum, choice)\n    return max_sum\n\nWait, but in the code above, for each state (h, m), we need to decide whether to take H or M, whichever gives a higher sum. However, in the case where both options are possible, we need to compare the two possibilities.\n\nBut the problem is that the choice of H or M affects the future steps. For example, taking H now may allow for higher contributions in the future steps.\n\nBut the DP approach correctly accounts for that, because the next_sum is the maximum sum possible from the next state.\n\nHowever, the problem is that the exponents can be very large. For example, when n is 18, 10^18 is a very big number. However, since Python handles big integers well, this shouldn't be a problem. But for n=18, 10^18 is manageable as an integer.\n\nBut wait, for each state (h, m), when we compute the contribution for H, it's current_digit multiplied by 10 raised to (n - (h + 1)). For example, if h is 0, then the contribution is digit * 10^{n-1}.\n\nBut for n=18, this is 10^17, which is a 1 followed by 17 zeros. However, even with 361 states, multiplying these numbers may be computationally intensive. However, given that n is up to 18, and each state is processed once, this is manageable.\n\nNow, the next step is to implement this DP with memoization, and then reconstruct the path.\n\nBut the problem is that for memoization, the function needs to return not only the maximum sum but also the choice (H or M) that was made. Therefore, perhaps the memoization should store both the maximum sum and the choice.\n\nBut in Python, memoization can be done with lru_cache, but since the function returns two things, perhaps it's easier to split into two functions: one that computes the maximum sum, and another that reconstructs the path based on the choices made.\n\nAlternatively, during the DP computation, we can track for each state (h, m) which choice (H or M) gives the maximum sum. Then, during reconstruction, we can follow these choices.\n\nSo the plan is:\n\n- Precompute the digits as a list of integers.\n\n- Implement a memoization-based DP function that returns the maximum sum for state (h, m).\n\n- Also, during the DP computation, track for each state (h, m) which choice (H or M) was taken.\n\nOnce the DP is computed, we can start from (0, 0) and for each state, choose the best option (H or M) according to the stored choice, and build the sequence of moves.\n\nBut how to track the choices. Perhaps, we can create a separate memoization table that stores for each (h, m) the choice made (H or M) that leads to the maximum sum.\n\nSo, during the DP computation, for each state (h, m), we compute the maximum sum and store the choice (H or M) that leads to that maximum.\n\nNow, the code structure in Python would be something like:\n\nRead n and A.\n\ndigits = [int(c) for c in A]\n\nmemo_sum = {}\nmemo_choice = {}\n\ndef dp(h, m):\n    if (h, m) in memo_sum:\n        return memo_sum[(h, m)]\n    k = h + m\n    if k == 2 * n:\n        memo_sum[(h, m)] = 0\n        return 0\n    current_digit = digits[k]\n    max_sum = -inf\n    best_choice = ''\n    # check H\n    if h < n:\n        contribution = current_digit * (10 ** (n - (h + 1)))\n        next_sum = dp(h + 1, m)\n        total = contribution + next_sum\n        if total > max_sum:\n            max_sum = total\n            best_choice = 'H'\n    # check M\n    if m < n:\n        contribution = current_digit * (10 ** (n - (m + 1)))\n        next_sum = dp(h, m + 1)\n        total = contribution + next_sum\n        if total > max_sum:\n            max_sum = total\n            best_choice = 'M'\n    memo_sum[(h, m)] = max_sum\n    memo_choice[(h, m)] = best_choice\n    return max_sum\n\nThen, after computing dp(0, 0), we can reconstruct the path by starting at (0, 0) and for each step, checking memo_choice[(h, m)] and appending 'H' or 'M' accordingly, and moving to the next state (h+1, m) or (h, m+1).\n\nBut wait, this code may not work correctly. Because when both H and M are possible, the code compares which gives a higher sum and chooses that. However, when the maximum is the same for both options, which one to choose? The problem says that if there are multiple solutions, output any of them. So in that case, we can choose either.\n\nBut in the code above, when both options are possible and the totals are equal, the code will choose the last one considered (M, since the code checks H first, then M). However, the problem allows any of the options. So that's acceptable.\n\nNow, the code for reconstruction would be:\n\nresult = []\nh = 0\nm = 0\nfor _ in range(2 * n):\n    choice = memo_choice[(h, m)]\n    result.append(choice)\n    if choice == 'H':\n        h += 1\n    else:\n        m += 1\n\nreturn ''.join(result)\n\nBut how to handle the memoization? The problem is that the DP function may not have filled memo_choice for all states. But since the DP is called recursively, all necessary states would have been processed.\n\nBut the code for the DP function needs to be memoized. However, in Python, using a dictionary for memoization may be a bit slow, but for n=18, the number of states is 19*19=361, which is manageable.\n\nBut wait, the code for dp is recursive. However, in Python, recursion depth can be a problem. For example, for n=18, the maximum recursion depth would be 2*18 = 36 steps. Which is well under Python's default recursion limit (which is 1000). So it's safe.\n\nBut perhaps a memoization approach using lru_cache would be more efficient. Let's think about using memoization with lru_cache. However, since the digits are part of the input, but the DP function uses them, the digits are fixed once the input is read. Therefore, the DP function can be written with parameters h and m, and the digits are accessed via the global variable.\n\nBut in Python, using lru_cache with mutable parameters is not allowed, but here h and m are integers, so it's okay.\n\nSo, perhaps the code can be rewritten with memoization via lru_cache. Let me think about that.\n\nBut for the purposes of tracking the choice, perhaps we can have two separate memoization tables: one for the maximum sum, and another for the choice. Alternatively, during the DP computation, we can track both the sum and the choice.\n\nAlternatively, perhaps we can compute the DP with memoization for the maximum sum, and then during the reconstruction phase, for each state (h, m), we re-calculate which choice (H or M) gives the maximum sum. However, this would require recomputing the same values again, which is not efficient. So better to track the choice during the DP phase.\n\nAnother approach is to write a memoization function that returns both the maximum sum and the choice. For example, using a memoization table that stores tuples (max_sum, choice).\n\nBut in Python, perhaps using a memoization decorator for the function that returns both values. However, for code clarity, perhaps it's better to proceed with the initial approach.\n\nBut let's proceed with the code.\n\nNow, considering that for n=18, 10^17 is a very big number. However, in Python, integers can be arbitrarily large, so that's not a problem.\n\nBut calculating 10 ** (n - (h + 1)) for each step. For example, when h is 0 and n is 18, it's 10^17. However, for each state, this calculation is done once. But with 361 states, this is manageable.\n\nNow, testing the code with the sample input.\n\nSample Input 1:\n\nn=2, A=1234.\n\nDigits are [1,2,3,4].\n\nThe optimal output is HHMM. Let's see what the DP would compute.\n\nFor state (0, 0), the current digit is 1 (index 0). The options are H or M.\n\nIf we choose H:\n\ncontribution is 1 * 10^(2-1) = 1 * 10^1 = 10. Then, the next state is (1, 0).\n\nIn state (1, 0), current digit is 2 (index 1). Options are H or M.\n\nIf we choose H again: contribution is 2 * 10^(2-2) = 2 * 1 = 2. Next state (2, 0). Now, since h=2 (equal to n=2), the next move must be M. So for state (2, 0), current digit is 3 (index 2). Only M is allowed. Contribution is 3 * 10^(2 - (0 + 1)) = 3 * 10^1 = 30. Next state (2, 1). Current digit is 4 (index 3). Only M is allowed. Contribution is 4 * 10^(2 - (1+1)) = 4 * 1 = 4. Total sum: 10 + 2 + 30 +4 = 46.\n\nAlternatively, in state (1, 0), if we choose M: contribution is 2 * 10^(2 - (0 + 1)) = 2 * 10^1 = 20. Next state (1, 1). Current digit is 3 (index 2). Now, options are H or M. Let's say choose H: contribution is 3 * 10^(2-2) = 3 * 1 = 3. Next state (2, 1). Then, M takes 4, contributing 4 * 10^0 =4. Total sum is 10 + 20 +3 +4 = 37. Which is less than 46. So the first path is better.\n\nSo the choice for state (1,0) is H.\n\nSo the first two steps are H and H. Then, the next steps are M and M, leading to the sequence HHMM.\n\nWhich matches the sample output.\n\nAnother sample input is ['2\\n9911'] with output 'HMHM'.\n\nLet me see. A is 9911. Digits [9,9,1,1]. n=2.\n\nLet's think of the optimal sequence.\n\nPossible options:\n\nIf the sequence is HMHM.\n\nH takes first digit 9 (contribution 9*10^1 =90).\n\nM takes next digit 9 (contribution 9*10^1=90).\n\nH takes next digit 1 (contribution 1*10^0=1).\n\nM takes next digit 1 (contribution 1*10^0=1). Total sum is 90+90+1+1= 182.\n\nAnother option: HHMM. H takes 9 (90), H takes 9 (9*10^0=9), then M takes 1 (1*10^1=10), M takes 1 (1*10^0=1). Total sum is 90+9+10+1= 110. Which is worse.\n\nAnother option: HMHM gives 182, which is better.\n\nSo the code should choose HMHM.\n\nSo the DP approach should correctly compute this.\n\nNow, the code for the DP function.\n\nBut in the code, for each state (h, m), the current digit is A[k], where k = h + m.\n\nBut the code must be written in Python. Now, the problem is that for n=18, the exponents 10^(n - ...) can be very large. However, Python can handle that.\n\nBut in practice, for n=18, 10^17 is manageable as an integer.\n\nNow, the code structure:\n\nRead n from input, then read A. Then process.\n\nBut in the problem statement, the input is given as two lines. Wait, looking back:\n\nThe input is given as:\n\nThe first line contains integer n.\n\nThe second line contains integer A consisting of exactly 2n digits.\n\nBut the sample input shows:\n\n['2\\n1234', '2\\n9911']\n\nBut perhaps the input is read as two separate test cases. However, the problem says that the code should read input from stdin and output the answer. So the code should read one test case. Wait, the problem says:\n\nInput:\n\nThe first line contains integer n (1 ≤ n ≤ 18). The second line contains integer A consisting of exactly 2n digits.\n\nSo the code should read two lines: first line is n, second is A.\n\nBut the sample input shows two test cases. However, the code is supposed to process one input. So perhaps the sample input is for two different test cases, but the code is supposed to process one input.\n\nSo the code reads n and A from stdin.\n\nNow, the code:\n\nImplementing the DP with memoization, and reconstructing the path.\n\nBut in Python, recursion with memoization can be done with lru_cache. However, since the digits are part of the global state, the DP function can be written as follows.\n\nBut for memoization, the code can use lru_cache with parameters h and m.\n\nBut since the digits are fixed during the DP computation, the code can proceed.\n\nBut let's proceed to code.\n\nFirst, read n and A.\n\nimport sys\n\nn = int(sys.stdin.readline())\nA = sys.stdin.readline().strip()\n\ndigits = [int(c) for c in A]\n\nThen, implement the DP.\n\nBut in Python, using memoization with lru_cache.\n\nBut for the choice tracking, perhaps we can use another memoization table. However, perhaps during the DP computation, we can compute both the maximum sum and the choice.\n\nBut for the code, perhaps we can use memoization with lru_cache for the maximum sum, and then during the reconstruction phase, for each state (h, m), we can check which option (H or M) gives the maximum sum.\n\nBut that would require recomputing the sum for each state during reconstruction, which may be expensive. However, since the number of states is small, it's manageable.\n\nAlternatively, during the DP phase, we can track the choice for each state.\n\nBut perhaps the code can be structured as follows:\n\nWe can use memoization for the maximum sum, and then during the reconstruction phase, for each state (h, m), we check whether taking H gives the same sum as taking M, or which is better.\n\nBut how?\n\nFor example, during reconstruction, for state (h, m):\n\ncurrent_digit = digits[k], where k = h + m.\n\nif h < n and m < n:\n\n   sum_H = current_digit * 10 ** (n - (h + 1)) + dp(h + 1, m)\n\n   sum_M = current_digit * 10 ** (n - (m + 1)) + dp(h, m + 1)\n\n   if sum_H >= sum_M:\n\n       choose H\n\n   else:\n\n       choose M\n\nBut during reconstruction, we can compute the sum for both options, and choose the one with higher sum. However, this requires that the dp function is already computed.\n\nThus, the code can proceed as:\n\nCompute the dp table with memoization for the maximum sum, and then during reconstruction, for each state, compare the two options.\n\nBut how to compute the dp table? Using memoization with lru_cache.\n\nSo, let's proceed to code.\n\nImplementing the DP function with memoization.\n\nfrom functools import lru_cache\n\nBut note that for Python versions, lru_cache may have issues with mutable parameters, but here h and m are integers.\n\nBut the code would be:\n\nimport sys\nfrom functools import lru_cache\n\nn = int(sys.stdin.readline())\nA = sys.stdin.readline().strip()\ndigits = [int(c) for c in A]\n\n@lru_cache(maxsize=None)\ndef dp(h, m):\n    k = h + m\n    if k == 2 * n:\n        return 0\n    current_digit = digits[k]\n    max_sum = -1\n    # Check H\n    if h < n:\n        contribution_h = current_digit * (10 ** (n - (h + 1)))\n        sum_h = contribution_h + dp(h + 1, m)\n    else:\n        sum_h = -1\n    # Check M\n    if m < n:\n        contribution_m = current_digit * (10 ** (n - (m + 1)))\n        sum_m = contribution_m + dp(h, m + 1)\n    else:\n        sum_m = -1\n    # choose the maximum\n    if sum_h >= sum_m:\n        return sum_h\n    else:\n        return sum_m\n\nBut wait, this code doesn't track the choice, but during reconstruction, we can check which option is better.\n\nBut during reconstruction, for each state (h, m), we can compute the sum for both options, and choose the one with higher sum.\n\nBut this would require recomputing the sum for both options. However, since the dp function is memoized, it's already computed, so the calls would be O(1).\n\nBut during the reconstruction phase, we need to know for each state (h, m) whether to choose H or M.\n\nSo, the code for reconstruction would be:\n\nh = 0\nm = 0\nresult = []\nfor _ in range(2 * n):\n    k = h + m\n    current_digit = digits[k]\n    # check if H is possible and better\n    if h < n and m < n:\n        contribution_h = current_digit * (10 ** (n - (h + 1)))\n        sum_h = contribution_h + dp(h + 1, m)\n        contribution_m = current_digit * (10 ** (n - (m + 1)))\n        sum_m = contribution_m + dp(h, m + 1)\n        if sum_h >= sum_m:\n            result.append('H')\n            h += 1\n        else:\n            result.append('M')\n            m += 1\n    elif h < n:\n        result.append('H')\n        h += 1\n    else:\n        result.append('M')\n        m += 1\n\nprint(''.join(result))\n\nBut this approach may have some issues. For example, when one of the options is not possible (like when h == n, then only M can be chosen).\n\nBut during reconstruction, the code checks whether H and M are possible. For example, when h < n and m < n, then both options are possible, and compare which gives higher sum. Otherwise, choose the available option.\n\nBut this approach would work.\n\nBut what about when the sum_h and sum_m are equal? The code chooses H, which is acceptable as per the",
    "response": "To solve this problem, we need to determine the optimal sequence of moves for Homer and Marge such that their total prize money is maximized. The game involves taking turns to pick digits from a given number, with each player making exactly `n` moves. The challenge is to maximize the sum of the numbers formed by the digits each player collects.\n\n### Approach\n1. **Dynamic Programming (DP) with Memoization**: We use a DP approach to explore all possible sequences of moves while keeping track of the maximum total prize achievable from each state. The state is defined by the number of moves each player has made so far.\n2. **Recursive Function with Memoization**: A recursive function with memoization is used to compute the maximum total prize from a given state `(h, m)` where `h` is the number of moves Homer has made and `m` is the number of moves Marge has made.\n3. **Reconstruction of Path**: After computing the DP table, we reconstruct the optimal sequence of moves by checking which choice (Homer or Marge taking the next digit) leads to the higher total prize at each step.\n\n### Solution Code\n```python\nimport sys\nfrom functools import lru_cache\n\ndef main():\n    n = int(sys.stdin.readline())\n    A = sys.stdin.readline().strip()\n    digits = [int(c) for c in A]\n    total_length = 2 * n\n\n    @lru_cache(maxsize=None)\n    def dp(h, m):\n        k = h + m\n        if k == total_length:\n            return 0\n        current_digit = digits[k]\n        max_sum = -1\n        # Check H\n        if h < n:\n            contribution_h = current_digit * (10 ** (n - (h + 1)))\n            sum_h = contribution_h + dp(h + 1, m)\n        else:\n            sum_h = -1\n        # Check M\n        if m < n:\n            contribution_m = current_digit * (10 ** (n - (m + 1)))\n            sum_m = contribution_m + dp(h, m + 1)\n        else:\n            sum_m = -1\n        # choose the maximum\n        if sum_h >= sum_m:\n            return sum_h\n        else:\n            return sum_m\n\n    h = 0\n    m = 0\n    result = []\n    for _ in range(total_length):\n        k = h + m\n        current_digit = digits[k]\n        if h < n and m < n:\n            contribution_h = current_digit * (10 ** (n - (h + 1)))\n            sum_h = contribution_h + dp(h + 1, m)\n            contribution_m = current_digit * (10 ** (n - (m + 1)))\n            sum_m = contribution_m + dp(h, m + 1)\n            if sum_h >= sum_m:\n                result.append('H')\n                h += 1\n            else:\n                result.append('M')\n                m += 1\n        elif h < n:\n            result.append('H')\n            h += 1\n        else:\n            result.append('M')\n            m += 1\n\n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input consists of an integer `n` and a string `A` of length `2n`.\n2. **Dynamic Programming Function**: The `dp` function uses memoization to avoid recalculating results for the same state. It computes the maximum total prize from the current state `(h, m)` by considering both possible moves (Homer or Marge taking the next digit).\n3. **Reconstructing the Path**: After computing the DP table, we reconstruct the optimal sequence by iterating through each move, determining whether Homer or Marge should take the next digit based on which choice yields a higher total prize.\n\nThis approach efficiently explores all possible move sequences using dynamic programming and memoization, ensuring that the solution is both optimal and efficient.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom functools import lru_cache\n\ndef main():\n    n = int(sys.stdin.readline())\n    A = sys.stdin.readline().strip()\n    digits = [int(c) for c in A]\n    total_length = 2 * n\n\n    @lru_cache(maxsize=None)\n    def dp(h, m):\n        k = h + m\n        if k == total_length:\n            return 0\n        current_digit = digits[k]\n        max_sum = -1\n        # Check H\n        if h < n:\n            contribution_h = current_digit * (10 ** (n - (h + 1)))\n            sum_h = contribution_h + dp(h + 1, m)\n        else:\n            sum_h = -1\n        # Check M\n        if m < n:\n            contribution_m = current_digit * (10 ** (n - (m + 1)))\n            sum_m = contribution_m + dp(h, m + 1)\n        else:\n            sum_m = -1\n        # choose the maximum\n        if sum_h >= sum_m:\n            return sum_h\n        else:\n            return sum_m\n\n    h = 0\n    m = 0\n    result = []\n    for _ in range(total_length):\n        k = h + m\n        current_digit = digits[k]\n        if h < n and m < n:\n            contribution_h = current_digit * (10 ** (n - (h + 1)))\n            sum_h = contribution_h + dp(h + 1, m)\n            contribution_m = current_digit * (10 ** (n - (m + 1)))\n            sum_m = contribution_m + dp(h, m + 1)\n            if sum_h >= sum_m:\n                result.append('H')\n                h += 1\n            else:\n                result.append('M')\n                m += 1\n        elif h < n:\n            result.append('H')\n            h += 1\n        else:\n            result.append('M')\n            m += 1\n\n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 426,
        "completion_token_count": 842,
        "thoughts_token_count": 8192
    }
}