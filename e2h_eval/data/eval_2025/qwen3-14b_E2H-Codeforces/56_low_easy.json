{
    "start": 1758309278.6434906,
    "end": 1758309473.3691366,
    "start-formatted": "2025-09-20 04:14 KST",
    "end-formatted": "2025-09-20 04:17 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\nOkay, I need to solve this programming problem. Let's read the problem carefully.\n\nThe problem is about assigning R Rebel spaceships to B bases such that each base has exactly one guardian and each spaceship is assigned to exactly one base. Additionally, the paths between each spaceship and its assigned base must not intersect with any other path. The paths are straight lines, and they shouldn't cross in the 2D plane. Also, it's given that no two points coincide and no three are colinear. So, the main task is to determine if there's a perfect matching between the spaceships and bases where all the connecting lines are non-intersecting.\n\nFirst, I need to understand what conditions make two line segments intersect. Since all points are unique and no three are colinear, any two line segments (from spaceship to base) will either not intersect or cross each other. But how can I check if two line segments intersect?\n\nBut the problem requires that for the entire matching, all the line segments are non-intersecting. So, the question reduces to finding a perfect matching between the two sets (spaceships and bases) such that none of the line segments between matched pairs cross each other.\n\nNow, since R and B are up to 10, the total possible perfect matchings are manageable. For example, when R=B=10, the number of possible permutations is 10! which is around 3.6 million. Wait, 10! is 3,628,800. That's manageable for small constraints. So, perhaps the approach is to generate all possible perfect matchings (permutations) and check for each whether all the line segments are non-intersecting.\n\nSo the plan is:\n\n1. Check if R != B. If not, output No. Because a perfect matching requires equal numbers. Wait, the input says that R and B are given. The problem says \"every base has exactly one guardian and each spaceship has exactly one assigned base\", so R must equal B. Otherwise, it's impossible. So first, if R != B, output No. But looking at the input examples, the first input is 3 3 and the second is 2 1. The second case outputs No because R and B are different. So that's the first check.\n\nSo first step: if R != B, output No.\n\nOtherwise, proceed to check all possible perfect matchings.\n\nFor each possible permutation (since the problem is to assign each spaceship to a base, which is a bijection), we need to check whether all the line segments between the matched pairs do not cross each other.\n\nBut how to check if two line segments cross?\n\nSo, given two line segments AB and CD, how do I check if they intersect?\n\nI remember that there's a computational geometry method to check this. The steps are:\n\n- Check if the two line segments intersect by using the orientation method. The standard way is to use the cross product to determine orientations.\n\nBut since the problem states that no three points are colinear, we don't have to worry about overlapping lines or colinear points. So for two line segments AB and CD, they intersect if and only if the orientations of (A,B,C) and (A,B,D) are different, and the orientations of (C,D,A) and (C,D,B) are different. Or, if one of the endpoints lies on the other segment. However, since the problem states that no three points are colinear, the endpoints can't lie on the other segment. Because if that were the case, then three points would be colinear. So for example, if A is on CD, then C, A, D would be colinear, which is not allowed. Therefore, the only possibility is that the two segments cross each other in the interior.\n\nSo, for two line segments AB and CD, they cross if and only if the orientations of AB with C and D are different, and the orientations of CD with A and B are different.\n\nSo, the function to check if two line segments AB and CD intersect is:\n\ndef segments_intersect(A, B, C, D):\n\n   return (orientation(A,B,C) != orientation(A,B,D)) and (orientation(C,D,A) != orientation(C,D,B))\n\nBut how to compute orientation?\n\nThe orientation of three points (p, q, r) is determined by the cross product of vectors pq and pr.\n\nThe formula is:\n\ndef orientation(p, q, r):\n\n    val = (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0])\n\n    if val == 0:\n\n        return 0 # colinear\n\n    return 1 if val > 0 else 2 # 1 for clockwise, 2 for counterclockwise\n\nBut since the problem states that no three points are colinear, we can ignore the case",
    "response": "To solve this problem, we need to determine if it's possible to assign Rebel spaceships to bases such that each base has exactly one guardian and each spaceship is assigned to exactly one base, with the additional constraint that no two connecting paths intersect.\n\n### Approach\n1. **Check for Equal Numbers**: First, check if the number of spaceships (R) is equal to the number of bases (B). If not, output \"No\" immediately since a perfect matching is impossible.\n2. **Generate Permutations**: If R equals B, generate all possible permutations of assignments between spaceships and bases.\n3. **Check for Intersections**: For each permutation, check if any pair of connecting paths intersect. This is done using computational geometry to determine if line segments intersect.\n4. **Determine Validity**: If any permutation results in non-intersecting paths, output \"Yes\"; otherwise, output \"No\".\n\n### Solution Code\n```python\nimport sys\nimport itertools\n\ndef orientation(p, q, r):\n    val = (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0])\n    if val == 0:\n        return 0  # colinear\n    return 1 if val > 0 else 2  # 1 for clockwise, 2 for counterclockwise\n\ndef segments_intersect(a, b, c, d):\n    o1 = orientation(a, b, c)\n    o2 = orientation(a, b, d)\n    o3 = orientation(c, d, a)\n    o4 = orientation(c, d, b)\n    \n    if (o1 != o2) and (o3 != o4):\n        return True\n    return False\n\ndef main():\n    input = sys.stdin.read().splitlines()\n    idx = 0\n    R = int(input[idx].split()[0])\n    B = int(input[idx].split()[1])\n    idx += 1\n    \n    rebels = []\n    for _ in range(R):\n        x, y = map(int, input[idx].split())\n        rebels.append((x, y))\n        idx += 1\n    \n    bases = []\n    for _ in range(B):\n        x, y = map(int, input[idx].split())\n        bases.append((x, y))\n        idx += 1\n    \n    if R != B:\n        print(\"No\")\n        return\n    \n    # Generate all possible permutations of bases\n    for perm in itertools.permutations(bases):\n        valid = True\n        # Check all pairs of segments\n        for i in range(R):\n            for j in range(i+1, R):\n                a = rebels[i]\n                b = perm[i]\n                c = rebels[j]\n                d = perm[j]\n                if segments_intersect(a, b, c, d):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Orientation Check**: The `orientation` function calculates the orientation of three points using the cross product to determine if they are clockwise, counterclockwise, or collinear.\n2. **Segment Intersection Check**: The `segments_intersect` function uses the orientation results to determine if two line segments intersect.\n3. **Permutations Check**: The main function reads input values, checks if the number of spaceships and bases are equal, generates all permutations of bases, and checks each permutation for intersecting paths. If any permutation is valid, it prints \"Yes\"; otherwise, it prints \"No\".",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport itertools\n\ndef orientation(p, q, r):\n    val = (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0])\n    if val == 0:\n        return 0  # colinear\n    return 1 if val > 0 else 2  # 1 for clockwise, 2 for counterclockwise\n\ndef segments_intersect(a, b, c, d):\n    o1 = orientation(a, b, c)\n    o2 = orientation(a, b, d)\n    o3 = orientation(c, d, a)\n    o4 = orientation(c, d, b)\n    \n    if (o1 != o2) and (o3 != o4):\n        return True\n    return False\n\ndef main():\n    input = sys.stdin.read().splitlines()\n    idx = 0\n    R = int(input[idx].split()[0])\n    B = int(input[idx].split()[1])\n    idx += 1\n    \n    rebels = []\n    for _ in range(R):\n        x, y = map(int, input[idx].split())\n        rebels.append((x, y))\n        idx += 1\n    \n    bases = []\n    for _ in range(B):\n        x, y = map(int, input[idx].split())\n        bases.append((x, y))\n        idx += 1\n    \n    if R != B:\n        print(\"No\")\n        return\n    \n    # Generate all possible permutations of bases\n    for perm in itertools.permutations(bases):\n        valid = True\n        # Check all pairs of segments\n        for i in range(R):\n            for j in range(i+1, R):\n                a = rebels[i]\n                b = perm[i]\n                c = rebels[j]\n                d = perm[j]\n                if segments_intersect(a, b, c, d):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 485,
        "completion_token_count": 769,
        "thoughts_token_count": 1024
    }
}