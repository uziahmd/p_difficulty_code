{
    "start": 1758309799.2701187,
    "end": 1758310046.7951486,
    "start-formatted": "2025-09-20 04:23 KST",
    "end-formatted": "2025-09-20 04:27 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\nOkay, I need to solve this programming problem. Let's read the problem carefully.\n\nThe problem is about finding the minimum number of nodes required to create a p-reachable directed graph, and then among all such graphs with that minimum number of nodes, find the maximum number of unidirectional pairs.\n\nFirst, understanding what a p-reachable graph is. The definition says that it contains exactly p ordered pairs (u, v) where u < v and u and v are reachable from each other. Wait, so for each pair u < v, if they are mutually reachable, that counts as one towards p. So the total number of such pairs must be exactly p.\n\nNow, the first part is to find the minimal number of nodes needed to achieve exactly p such pairs. Then, among those minimal node graphs, find the maximum number of unidirectional pairs.\n\nLet me think about how to approach this.\n\nFirst, for the minimal number of nodes. Let's think about how many mutual reachable pairs can exist in a graph with n nodes.\n\nBut what's the structure of a graph that maximizes or minimizes the number of mutual pairs? Well, for the minimal number of nodes, we need to arrange the graph such that the number of mutual pairs is exactly p, but using as few nodes as possible.\n\nWait, but the problem is not to maximize or minimize the mutual pairs. It's to have exactly p mutual pairs. So the question is: find the smallest n such that there exists a directed graph on n nodes with exactly p mutual pairs (u < v, u and v reachable from each other).\n\nSo how do we model this?\n\nLet me think of the mutual reachable pairs. For a graph with n nodes, the maximum number of mutual pairs possible would be C(n, 2), which occurs when every pair of nodes is mutually reachable. For example, a strongly connected component (SCC) where all nodes are in a single SCC. However, if the graph is split into multiple SCCs, then nodes in different SCCs may not be mutually reachable.\n\nBut for our problem, we need exactly p mutual pairs. So perhaps the minimal n is determined by the largest triangular number less than or equal to p, and then adding some components.\n\nAlternatively, think of the mutual pairs as being formed by the number of pairs within each strongly connected component (SCC). Because if two nodes are in the same SCC, then they are mutually reachable. But if they are in different SCCs, then depending on the direction of edges between the SCCs, they might not be mutually reachable.\n\nWait, but in order for two nodes u and v to be mutually reachable, they must be in the same SCC. Because if u is in an SCC A and v is in another SCC B, then if there's a path from A to B and vice versa, then A and B would be part of the same SCC. So, two nodes are in the same SCC if and only if they are mutually reachable.\n\nTherefore, the number of mutual pairs in the graph is the sum over all SCCs of C(k, 2), where k is the size of the SCC. Because for each SCC of size k, there are k choose 2 pairs of nodes that are mutually reachable.\n\nSo the problem reduces to choosing a set of integers (k_1, k_2, ..., k_m) such that the sum of C(k_i, 2) for each i equals p. And we want to find the minimal total number of nodes (sum of k_i) for such a decomposition of p.\n\nMoreover, once we find the minimal n, we need to find the maximum number of unidirectional pairs possible in such a graph.\n\nSo the first part of the problem becomes: find the minimal n such that there exists a decomposition of p into sum of C(k_i, 2) terms, and the sum of k_i is minimized.\n\nWait, but how?\n\nFor example, let's take p=3. The possible decompositions are:\n\n- One component of size 3: C(3,2) = 3. Sum of k_i is 3. Which is minimal. Hence the answer for the first part is 3.\n\nAnother example: p=4. The possible decompositions:\n\nOption 1: One component of size 4: C(4,2)=6. That's more than 4. Not acceptable.\n\nOption 2: Two components: one of size 3 (C(3,2)=3) and one of size 2 (C(2,2)=1). Total sum is 3+1=4. So total nodes is 3+2=5. Alternatively, can we have a better decomposition? What about a component of size 3 (3) and then a component of size 1 (0), but that gives 3. Not enough. Or maybe two components of size 2 and 2: sum is 1 + 1 = 2. No. So the",
    "response": "To solve this problem, we need to determine the minimum number of nodes required to create a p-reachable directed graph and then find the maximum number of unidirectional pairs in such graphs with that minimum number of nodes.\n\n### Approach\n1. **Understanding Mutual Reachability**: For a directed graph, two nodes are mutually reachable if they are in the same strongly connected component (SCC). The number of mutual pairs in a graph can be determined by summing combinations of sizes of SCCs, i.e., for an SCC of size `k`, there are `C(k, 2)` mutual pairs.\n\n2. **Decomposition into SCCs**: To achieve exactly `p` mutual pairs, we decompose `p` into sums of combinations `C(k, 2)`. The goal is to minimize the total number of nodes used in this decomposition.\n\n3. **Finding Minimum Nodes**: We use a greedy approach to find the minimal number of nodes. Starting from the largest possible `k` such that `C(k, 2)` is less than or equal to `p`, we subtract this value from `p` and repeat until `p` is zero.\n\n4. **Maximizing Unidirectional Pairs**: Once the minimal number of nodes is determined, we maximize the number of unidirectional pairs. This is achieved by ensuring that each SCC is as small as possible while maintaining the required mutual pairs.\n\n### Solution Code\n```python\nimport sys\nimport math\n\ndef main():\n    p = int(sys.stdin.readline())\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    # First part: find minimal number of nodes\n    n_total = 0\n    remaining = p\n    k = 1\n    while True:\n        c = k * (k - 1) // 2\n        if c > remaining:\n            k -= 1\n            c = k * (k - 1) // 2\n            if c <= remaining:\n                n_total += k\n                remaining -= c\n                k = 1\n            else:\n                break\n        else:\n            n_total += k\n            remaining -= c\n            k += 1\n        if remaining == 0:\n            break\n\n    # Now, find the maximum number of unidirectional pairs\n    # The maximum unidirectional pairs is total_pairs - mutual_pairs - same_scc_pairs\n    # Wait, let's think differently.\n    # The total number of ordered pairs (u, v) with u != v is n*(n-1)\n    # Among them, mutual pairs are 2 * sum(C(k_i, 2)) (since each unordered pair is counted twice)\n    # Wait no. The problem defines \"unidirectional\" as ordered pairs (u, v) where u != v, there's a path from u to v but not vice versa.\n    # So the total number of unidirectional pairs is total_ordered_pairs - mutual_pairs - self_loops (but self loops are not considered since u != v).\n    # But the problem says that the graph is p-reachable, which counts ordered pairs (u, v) with u < v and mutual reachability. So the mutual pairs in the graph is p, which is the count of unordered pairs (u < v) that are mutual. Each such pair contributes two ordered pairs (u, v) and (v, u), both mutual.\n    # So the total number of mutual ordered pairs is 2p.\n    # The total number of ordered pairs (u, v) with u != v is n*(n-1).\n    # So the number of unidirectional pairs is total_ordered_pairs - mutual_ordered_pairs - number of pairs where there is no path in either direction.\n    # However, in our case, the graph is structured such that all nodes are in SCCs. Between different SCCs, there is a directed path from one to another but not vice versa. So for any two nodes in different SCCs, exactly one of the paths exists (if the SCCs are arranged in a DAG).\n    # Thus, the number of unidirectional pairs is the number of ordered pairs between different SCCs, which is total_ordered_pairs - mutual_ordered_pairs (2p) - number of pairs where neither can reach the other (which is zero if the SCCs form a DAG with no cycles between them).\n\n    # So the maximum number of unidirectional pairs is total_ordered_pairs - 2p.\n\n    # Wait, but how to compute that?\n    # The total ordered pairs (u != v) is n*(n-1)\n    # The mutual ordered pairs are 2*p (since each unordered pair (u < v) that is mutual contributes two ordered pairs)\n    # So the unidirectional pairs would be total_ordered_pairs - 2p - (number of pairs where neither can reach the other)\n    # But in the optimal configuration, we arrange the SCCs in a DAG, so for any two nodes in different SCCs, there is a directed path from one to the other, but not vice versa. Therefore, the number of such pairs is total_ordered_pairs - 2p.\n\n    # So the maximum unidirectional pairs is n*(n-1) - 2*p\n\n    # But wait, the example given in the problem:\n    # Input 3, output is 3 0\n    # n=3, total ordered pairs is 3*2=6. 2p = 6. 6-6=0. Which matches the example.\n\n    # Another example: input 4, output is 5 6.\n    # n=5, total ordered pairs is 5*4=20. 2p=8. 20-8=12. But the output is 6. Hmm, that doesn't match. So my previous reasoning is wrong.\n\n    # Let me re-examine the example.\n\n    # For the second sample input: p=4, output is 5 6.\n    # The minimal number of nodes is 5. How?\n\n    # The decomposition for p=4 is C(3,2)=3 and C(2,2)=1. Sum is 4. So the SCCs are of size 3 and 2. Total nodes is 3+2=5.\n\n    # The total number of ordered pairs is 5*4=20. The mutual ordered pairs are 3*2 + 2*1 = 6 + 2 = 8? Or 2*4=8? Because p=4, which is the number of unordered pairs. So 2p=8.\n\n    # Then according to previous logic, unidirectional pairs would be 20 - 8 = 12. But the sample output says 6. So clearly that's wrong.\n\n    # So what's the correct way?\n\n    # Let's think again about the definition of unidirectional pairs. It's ordered pairs (u, v) where u != v, there's a path from u to v, and no path from v to u.\n\n    # In the example, the graph has two SCCs: one of size 3 (call it A), and one of size 2 (call it B). Between A and B, suppose there is a directed edge from A to B. Then:\n\n    - For nodes within A: they are mutually reachable. So their ordered pairs are mutual, not unidirectional.\n    - For nodes within B: same as above.\n    - For pairs between A and B: (a, b) where a is in A and b is in B: there is a path from a to b. But no path from b to a. So these are unidirectional pairs.\n    - Similarly, (b, a) would have no path from b to a, but there is a path from a to b. So (b, a) is not unidirectional because there's a path from a to b, but not from b to a. Wait, no: for (b, a), since there's a path from a to b, but not from b to a. So the pair (b, a) would have no path from b to a, but there is a path from a to b. So (b, a) is not unidirectional. Unidirectional requires that there's a path from u to v and no path from v to u. So (u, v) is unidirectional if there is a path from u to v but not vice versa.\n\n    So for the pair (a, b) where a is in A and b is in B, there is a path from a to b, so (a, b) is unidirectional. But for (b, a), there is no path from b to a, so it's not unidirectional. Thus, for each such pair, only one of the ordered pairs is unidirectional.\n\n    So the number of unidirectional pairs between A and B is |A| * |B|.\n\n    Also, for pairs between different SCCs, if the SCCs are arranged in a DAG, then for any two SCCs S and T, if there is a path from S to T, then all ordered pairs from S to T are unidirectional (assuming no reverse paths). But if there's a cycle between SCCs, that's not allowed.\n\n    To maximize the number of unidirectional pairs, the SCCs should be arranged in a linear order (like a chain), so that for every pair of SCCs S and T where S comes before T, there's a path from S to T but not vice versa. Thus, the number of unidirectional pairs between all such SCCs is the product of their sizes multiplied by 1 (each pair (s, t) contributes one unidirectional pair).\n\n    So the total number of unidirectional pairs is the sum over all ordered pairs of SCCs (S, T) where S comes before T in the DAG of |S| * |T|.\n\n    Additionally, for nodes within the same SCC, there are no unidirectional pairs because they are mutually reachable.\n\n    So the problem reduces to finding the decomposition of p into sum of C(k_i, 2) with minimal sum of k_i, and then arranging the SCCs in a DAG such that the sum of products of sizes of all pairs of SCCs in the DAG order is maximized.\n\n    To maximize this sum, we should arrange the SCCs in non-decreasing order of size, or non-increasing order? Let's think.\n\n    Suppose we have two components, A and B. If A is before B in the DAG, then the contribution is |A| * |B|. If we swap their positions, the contribution is |B| * |A|, same value. So the order of components does not matter for the total sum. Thus, the total number of unidirectional pairs is the sum over all pairs of components (S, T) where S != T of |S| * |T| divided by 2? No, because each pair (S, T) where S comes before T contributes |S| * |T|. If the DAG is a total order, then for all pairs of distinct components, exactly one of (S, T) or (T, S) is in the DAG order. So the total is the sum over all pairs of components S and T (S != T) of |S| * |T| multiplied by 1 if S comes before T, and 0 otherwise. But since the DAG can be arranged to have all possible pairs in one direction, the maximum sum is the sum over all pairs of components S and T (S != T) of |S| * |T| / 2? No, wait. If you arrange the components in a linear order, then for each pair of components, you get exactly one direction. So the total is the sum for all pairs (S, T) where S is before T of |S| * |T|.\n\n    However, this sum can be calculated as follows. Let’s denote the sizes of the components as s_1, s_2, ..., s_m. Then the total number of unidirectional pairs is (sum_{i} s_i)^2 - sum_{i} s_i^2 all divided by 2. Because:\n\n    (sum s_i)^2 = sum s_i^2 + 2 * sum_{i < j} s_i s_j.\n\n    So sum_{i < j} s_i s_j = [(sum s_i)^2 - sum s_i^2] / 2.\n\n    But in our case, the sum of all pairs (i, j) where i != j is sum_{i != j} s_i s_j = (sum s_i)^2 - sum s_i^2.\n\n    However, since in the DAG, each pair (i, j) is counted once if i is before j. So the total unidirectional pairs is exactly sum_{i < j} s_i s_j, assuming the DAG is a total order of the components. Thus, the maximum possible unidirectional pairs is sum_{i < j} s_i s_j.\n\n    So the formula is:\n\n    total_unidirectional = (total_nodes^2 - sum(s_i^2)) // 2\n\n    Because sum_{i < j} s_i s_j = [ (sum s_i)^2 - sum s_i^2 ] / 2\n\n    Let me verify with the example where p=4 and n=5. The components are sizes 3 and 2.\n\n    sum s_i^2 = 3^2 + 2^2 = 9 + 4 = 13\n\n    total_nodes = 5, so 5^2 = 25\n\n    25 - 13 = 12, divided by 2 gives 6. Which matches the sample output of 6.\n\n    So the formula is correct.\n\n    Therefore, the steps are:\n\n    1. Find the minimal number of nodes n by decomposing p into sum of C(k_i, 2), choosing the decomposition that minimizes the sum of k_i.\n\n    2. Once we have the sizes of the components (s_1, s_2, ..., s_m), compute the maximum number of unidirectional pairs as (n^2 - sum(s_i^2)) // 2.\n\n    Now, the challenge is to find the decomposition of p into sum of C(k_i, 2) with minimal sum of k_i.\n\n    To do this, we can greedily take the largest possible k such that C(k, 2) <= remaining p, subtract it from p, and proceed.\n\n    Let's implement this.\n\n    Let's code this:\n\n    For the first part:\n\n    Initialize n_total = 0, remaining = p.\n\n    while remaining > 0:\n\n        find the largest k where k*(k-1)/2 <= remaining.\n\n        add k to n_total.\n\n        subtract k*(k-1)/2 from remaining.\n\n    However, this may not always give the minimal sum. For example, consider p=4. The largest k is 3 (3*2/2=3). Remaining becomes 1. Then the largest k is 2 (1), so total n is 3+2=5. Which is correct.\n\n    Another example: p=5. Greedy would take 3 (3), then 2 (1), total 5. But 3+2=5. Alternatively, could we have a single component of 4 (6) which is larger than 5. So no. So the greedy approach works.\n\n    So the algorithm is correct.\n\n    Now, let's implement this in code.\n\n    Then, once we have the decomposition, we need to collect all the sizes of the components. However, for the purpose of calculating sum(s_i^2), we need to know all the component sizes.\n\n    So during the decomposition process, we can track the sizes of the components.\n\n    For example, for p=4, the components are [3, 2], sum of squares is 9 + 4 = 13.\n\n    So, the code needs to collect the component sizes.\n\n    Let me adjust the code to collect the component sizes.\n\n    So here's the plan:\n\n    - Decompose p into components, storing their sizes.\n\n    - Once we have the component sizes, calculate sum_squares = sum(s^2 for s in components)\n\n    - The maximum unidirectional pairs is (n^2 - sum_squares) // 2\n\n    Now, coding this:\n\n    So, the code will be:\n\n    Read p.\n\n    if p == 0:\n\n        print 0 0\n\n    else:\n\n        components = []\n\n        remaining = p\n\n        while remaining > 0:\n\n            # find largest k such that k*(k-1)//2 <= remaining\n\n            k = 1\n\n            while k*(k-1)//2 <= remaining:\n\n                k += 1\n\n            k -= 1\n\n            components.append(k)\n\n            remaining -= k*(k-1)//2\n\n        n_total = sum(components)\n\n        sum_squares = sum(s*s for s in components)\n\n        max_unidirectional = (n_total * n_total - sum_squares) // 2\n\n        print(f\"{n_total} {max_unidirectional}\")\n\n    Let's test this with the sample inputs.\n\n    Sample Input 1: 3\n\n    components: find 3 (3*2/2=3). remaining becomes 0. components = [3]. sum_squares = 9. n_total = 3.\n\n    max_unidirectional = (9 - 9)/2 = 0. Correct.\n\n    Sample Input 2: 4\n\n    components: first k is 3 (3), remaining 1. Next k is 2 (1). components [3,2]. sum_squares = 9 +4 =13. n=5. 5^2 =25. 25-13=12. 12/2=6. Correct.\n\n    Sample Input 3: 0 → output 0 0.\n\n    Another test case: p=1. The decomposition is [2], sum_squares=4. n=2. max_unidirectional = (4-4)/2 = 0. Which makes sense: the two nodes are in the same SCC. So no unidirectional pairs.\n\n    Another case: p=2. Decomposition is [2] (C(2,2)=1) and then [2] again? No. Wait, remaining is 2.\n\n    Wait, initial remaining is 2. The largest k is 2 (C(2,2)=1). Subtract 1, remaining is 1. Then again k=2? No, because 2*1/2=1. So components would be [2,2]. sum_squares is 4+4=8. n_total=4. max_unidirectional = (16-8)/2=4. So the maximum number of unidirectional pairs is 4.\n\n    What is the actual scenario? Two components of size 2. The total unidirectional pairs is 2*2=4, which matches.\n\n    So the code seems correct.\n\n    Now, code in Python:\n\n    But note that for large p (up to 2e5), the loop for finding k can be optimized. However, since for each step, we can compute k via binary search or using math.\n\n    But for the purposes of code submission, even a linear search for k would be acceptable for p up to 2e5.\n\n    Let's code it:\n\n    Now, the code:\n\n    import sys\n\n    def main():\n        p = int(sys.stdin.readline())\n        if p == 0:\n            print(\"0 0\")\n            return\n\n        components = []\n        remaining = p\n        while remaining > 0:\n            # Find the largest k such that k*(k-1)//2 <= remaining\n            k = 1\n            while (k * (k - 1)) // 2 <= remaining:\n                k += 1\n            k -= 1\n            components.append(k)\n            remaining -= (k * (k - 1)) // 2\n\n        n_total = sum(components)\n        sum_squares = sum(s * s for s in components)\n        max_unidirectional = (n_total * n_total - sum_squares) // 2\n        print(f\"{n_total} {max_unidirectional}\")\n\n    if __name__ == \"__main__\":\n        main()\n\n    But wait, for the case where p=0, the code prints 0 0. Which is correct.\n\n    Let me check the sample input:\n\n    For input 3, the output is 3 0.\n\n    For input 4, output is 5 6.\n\n    For input 0, output is 0 0.\n\n    All correct.\n\n    So this should handle all cases.\nTo solve this problem, we need to determine the minimum number of nodes required to create a p-reachable directed graph and then find the maximum number of unidirectional pairs in such graphs with that minimum number of nodes.\n\n### Approach\n1. **Understanding Mutual Reachability**: For a directed graph, two nodes are mutually reachable if they are in the same strongly connected component (SCC). The number of mutual pairs in a graph can be determined by summing combinations of sizes of SCCs, i.e., for an SCC of size `k`, there are `C(k, 2)` mutual pairs.\n\n2. **Decomposition into SCCs**: To achieve exactly `p` mutual pairs, we decompose `p` into sums of combinations `C(k, 2)`. The goal is to minimize the total number of nodes used in this decomposition.\n\n3. **Finding Minimum Nodes**: Using a greedy approach, we find the largest possible `k` such that `C(k, 2)` is less than or equal to the remaining value of `p`, subtract this value from `p`, and repeat until `p` is zero.\n\n4. **Maximizing Unidirectional Pairs**: Once the minimal number of nodes is determined, we calculate the maximum number of unidirectional pairs using the formula derived from the total number of nodes and the sum of squares of the sizes of the components.\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    p = int(sys.stdin.readline())\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    components = []\n    remaining = p\n    while remaining > 0:\n        # Find the largest k such that k*(k-1)//2 <= remaining\n        k = 1\n        while (k * (k - 1)) // 2 <= remaining:\n            k += 1\n        k -= 1\n        components.append(k)\n        remaining -= (k * (k - 1)) // 2\n\n    n_total = sum(components)\n    sum_squares = sum(s * s for s in components)\n    max_unidirectional = (n_total * n_total - sum_squares) // 2\n    print(f\"{n_total} {max_unidirectional}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input value `p` is read from standard input.\n2. **Handling Zero Case**: If `p` is zero, the output is immediately set to \"0 0\".\n3. **Decomposing `p` into Components**: Using a greedy approach, the largest possible size `k` for each component is determined such that the number of mutual pairs `C(k, 2)` does not exceed the remaining value of `p`.\n4. **Calculating Minimum Nodes**: The total number of nodes is the sum of all component sizes.\n5. **Maximizing Unidirectional Pairs**: Using the formula derived from the total number of nodes and the sum of squares of component sizes, the maximum number of unidirectional pairs is calculated and printed.\n\nThis approach ensures that we efficiently determine the minimum number of nodes required and maximize the number of unidirectional pairs in the resulting graph.",
    "ground_truth": "N/A",
    "extracted_answer": "### Explanation\n1. **Reading Input**: The input value `p` is read from standard input.\n2. **Handling Zero Case**: If `p` is zero, the output is immediately set to \"0 0\".\n3. **Decomposing `p` into Components**: Using a greedy approach, the largest possible size `k` for each component is determined such that the number of mutual pairs `C(k, 2)` does not exceed the remaining value of `p`.\n4. **Calculating Minimum Nodes**: The total number of nodes is the sum of all component sizes.\n5. **Maximizing Unidirectional Pairs**: Using the formula derived from the total number of nodes and the sum of squares of component sizes, the maximum number of unidirectional pairs is calculated and printed.\n\nThis approach ensures that we efficiently determine the minimum number of nodes required and maximize the number of unidirectional pairs in the resulting graph.",
    "score": -1,
    "metadata": {
        "prompt_token_count": 480,
        "completion_token_count": 5107,
        "thoughts_token_count": 1024
    }
}