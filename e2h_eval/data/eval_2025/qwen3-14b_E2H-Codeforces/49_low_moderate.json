{
    "start": 1758309763.3461337,
    "end": 1758309809.8236334,
    "start-formatted": "2025-09-20 04:22 KST",
    "end-formatted": "2025-09-20 04:23 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\nOkay, let's try to figure out how to solve this problem. The problem is about reconstructing the number of mushrooms on each lawn based on the GCD and LCM values given for each road (edge) between two lawns. \n\nSo, each edge connects two nodes (lawns) and has a GCD and LCM value. Our goal is to assign a number to each node such that for every edge, the GCD of the two nodes' numbers equals the given GCD, and the LCM equals the given LCM. If there's no such assignment, we output NO.\n\nFirst, I need to think about the constraints between the GCD and LCM. For two numbers a and b, we know that GCD(a, b) * LCM(a, b) = a*b. So for each edge, if the given GCD is g and LCM is l, then the product of the two numbers must be g*l. Also, since GCD(a, b) is g, both a and b must be multiples of g. Let me denote a = g * x, b = g * y. Then, GCD(x, y) must be 1 (since we factored out the GCD). And the LCM of a and b would be g * x * y. Because LCM(a,b) = (a*b)/GCD(a,b) = (g^2 x y)/g = g x y. So according to the problem, the LCM given is l. Therefore, we have g * x * y = l. Which implies that x*y = l/g. Since x and y are coprime, this tells us that x and y must be divisors of l/g and their product is l/g, and they are coprime. \n\nSo for each edge, given g and l, we must check that l is divisible by g. Because if not, then it's impossible. For example, if l is not a multiple of g, then the product g * x * y can't equal l. So first step: for each edge, check if l % g != 0. If any such case exists, output NO.\n\nBut wait, the problem says that the original numbers on the roads were between 1 and 1e6, but in the input, the GCD and LCM could be anything. However, the problem says that the input is guaranteed that the original numbers were between 1 and 1e6. But perhaps during processing, we can have cases where l is not divisible by g. So for example, if an edge has GCD=2 and LCM=3, then 3 is not divisible by 2. So this would be invalid. So in that case, the answer is NO.\n\nSo first, for each edge, check if LCM is divisible by GCD. If not, return NO.\n\nOnce that's done, for each edge, we can compute the product of x and y as (l/g), and x and y are coprime. Now, the problem is to assign values to each node such that for each edge, the two nodes connected by the edge have values that are multiples of g, and their ratio (divided by g) gives x and y which are coprime and multiply to l/g.\n\nBut how do we model this? It seems like a graph problem where each node's value is determined by some constraints from edges.\n\nThis feels like a problem where we can model the nodes with variables, and for each edge, we have constraints between pairs of variables. But since the variables are connected through multiplicative relationships, perhaps we can model this with a graph where each node's value is determined relative to others.\n\nLet me think of the problem as building a graph where each node's value is determined based on the edges. For example, suppose we have an edge between u and v with GCD g and LCM l. Then, the numbers for u and v must be a = g * x, b = g * y, with x*y = l/g and gcd(x,y)=1. So, x and y are coprime factors of (l/g). \n\nNow, for each edge, there are two possibilities for x and y. For example, if (l/g) is 6, then possible (x,y) pairs are (1,6), (6,1), (2,3), (3,2). But since x and y are coprime, these are the only options. However, which one to choose?\n\nBut how do we decide which pair to choose for each edge? This seems like a problem that can be modeled as a graph where each node's value is connected to others via certain multiplicative factors. However, since the same node can be part of multiple edges, the assignments must be consistent across all edges.\n\nThis seems similar to a system of equations where each edge imposes a relationship between two variables. But",
    "response": "To solve this problem, we need to reconstruct the number of mushrooms on each lawn based on given GCD and LCM values for each road (edge) between two lawns. The solution involves checking constraints and using a graph traversal approach to assign values consistently across all nodes.\n\n### Approach\n1. **Input Validation**: For each edge, check if the LCM is divisible by the GCD. If not, it's impossible to satisfy the constraints, so the answer is \"NO\".\n2. **Graph Construction**: Construct a graph where each node represents a lawn and each edge represents the given GCD and LCM values.\n3. **BFS Traversal**: Use BFS to traverse the graph starting from an arbitrary node. For each node, assign values based on the constraints derived from the edges.\n4. **Consistency Check**: During BFS traversal, ensure that the assigned values are consistent with all edges. If any inconsistency is found, return \"NO\".\n\n### Solution Code\n```python\nimport sys\nimport math\nfrom collections import deque, defaultdict\n\ndef main():\n    input = sys.stdin.read().splitlines()\n    idx = 0\n    n, m = map(int, input[idx].split())\n    idx += 1\n    edges = []\n    for _ in range(m):\n        u, v, g, l = map(int, input[idx].split())\n        edges.append((u-1, v-1, g, l))\n        idx += 1\n\n    # First, check if any LCM is not divisible by GCD\n    possible = True\n    for u, v, g, l in edges:\n        if l % g != 0:\n            possible = False\n            break\n    if not possible:\n        print(\"NO\")\n        return\n\n    # Build the graph with the relationships\n    graph = defaultdict(list)\n    for u, v, g, l in edges:\n        product = l // g\n        graph[u].append((v, g, product))\n        graph[v].append((u, g, product))\n\n    # Assign values to each node\n    values = [-1] * n\n    visited = [False] * n\n\n    def bfs(start):\n        q = deque()\n        q.append(start)\n        visited[start] = True\n        values[start] = 1  # We can start with 1, but need to adjust based on edges\n        while q:\n            u = q.popleft()\n            for v, g, prod in graph[u]:\n                if values[v] == -1:\n                    # We need to determine values[u] and values[v]\n                    # Since values[u] = g * x, values[v] = g * y, x*y = prod, gcd(x,y)=1\n                    # But since we have values[u], we can compute values[v]\n                    if values[u] % g != 0:\n                        return False\n                    x = values[u] // g\n                    y = prod // x\n                    if math.gcd(x, y) != 1:\n                        return False\n                    values[v] = g * y\n                    visited[v] = True\n                    q.append(v)\n                else:\n                    # Check consistency\n                    if values[u] % g != 0 or values[v] % g != 0:\n                        return False\n                    x = values[u] // g\n                    y = values[v] // g\n                    if x * y != prod or math.gcd(x, y) != 1:\n                        return False\n        return True\n\n    # Try to assign values starting from each unvisited node\n    for i in range(n):\n        if not visited[i]:\n            if values[i] == -1:\n                values[i] = 1\n            if not bfs(i):\n                print(\"NO\")\n                return\n\n    # Now, verify all edges\n    for u, v, g, l in edges:\n        a = values[u]\n        b = values[v]\n        if math.gcd(a, b) != g or (a * b) // math.gcd(a, b) != l:\n            print(\"NO\")\n            return\n\n    print(\"YES\")\n    print(' '.join(map(str, values)))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Input Validation**: The code first checks if the LCM for each edge is divisible by the GCD. If not, it immediately outputs \"NO\".\n2. **Graph Construction**: The graph is built using adjacency lists where each edge stores the GCD and the product of the coprime factors derived from the LCM and GCD.\n3. **BFS Traversal**: Starting from each unvisited node, BFS is used to assign values to nodes. The value of each node is determined based on the constraints from its connected edges.\n4. **Consistency Check**: After assigning values, the code verifies that all edges meet the required GCD and LCM conditions. If any inconsistency is found, it outputs \"NO\"; otherwise, it prints the values.\n\nThis approach ensures that we efficiently check and assign values while maintaining the constraints given by the problem.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\nfrom collections import deque, defaultdict\n\ndef main():\n    input = sys.stdin.read().splitlines()\n    idx = 0\n    n, m = map(int, input[idx].split())\n    idx += 1\n    edges = []\n    for _ in range(m):\n        u, v, g, l = map(int, input[idx].split())\n        edges.append((u-1, v-1, g, l))\n        idx += 1\n\n    # First, check if any LCM is not divisible by GCD\n    possible = True\n    for u, v, g, l in edges:\n        if l % g != 0:\n            possible = False\n            break\n    if not possible:\n        print(\"NO\")\n        return\n\n    # Build the graph with the relationships\n    graph = defaultdict(list)\n    for u, v, g, l in edges:\n        product = l // g\n        graph[u].append((v, g, product))\n        graph[v].append((u, g, product))\n\n    # Assign values to each node\n    values = [-1] * n\n    visited = [False] * n\n\n    def bfs(start):\n        q = deque()\n        q.append(start)\n        visited[start] = True\n        values[start] = 1  # We can start with 1, but need to adjust based on edges\n        while q:\n            u = q.popleft()\n            for v, g, prod in graph[u]:\n                if values[v] == -1:\n                    # We need to determine values[u] and values[v]\n                    # Since values[u] = g * x, values[v] = g * y, x*y = prod, gcd(x,y)=1\n                    # But since we have values[u], we can compute values[v]\n                    if values[u] % g != 0:\n                        return False\n                    x = values[u] // g\n                    y = prod // x\n                    if math.gcd(x, y) != 1:\n                        return False\n                    values[v] = g * y\n                    visited[v] = True\n                    q.append(v)\n                else:\n                    # Check consistency\n                    if values[u] % g != 0 or values[v] % g != 0:\n                        return False\n                    x = values[u] // g\n                    y = values[v] // g\n                    if x * y != prod or math.gcd(x, y) != 1:\n                        return False\n        return True\n\n    # Try to assign values starting from each unvisited node\n    for i in range(n):\n        if not visited[i]:\n            if values[i] == -1:\n                values[i] = 1\n            if not bfs(i):\n                print(\"NO\")\n                return\n\n    # Now, verify all edges\n    for u, v, g, l in edges:\n        a = values[u]\n        b = values[v]\n        if math.gcd(a, b) != g or (a * b) // math.gcd(a, b) != l:\n            print(\"NO\")\n            return\n\n    print(\"YES\")\n    print(' '.join(map(str, values)))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 559,
        "completion_token_count": 1061,
        "thoughts_token_count": 1024
    }
}