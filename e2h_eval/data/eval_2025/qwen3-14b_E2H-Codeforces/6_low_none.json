{
    "start": 1758008324.8670514,
    "end": 1758008506.4288611,
    "start-formatted": "2025-09-16 16:38 KST",
    "end-formatted": "2025-09-16 16:41 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\nOkay, let's see. I need to solve this programming problem. Let me read the problem carefully again.\n\nThe problem is about Leha choosing two vouchers such that their durations add up exactly to x, and they don't overlap. And we need to find the minimal total cost of such a pair. If it's impossible, output -1.\n\nSo, the input is n vouchers, each with li (start day), ri (end day), and cost. The duration of a voucher is ri - li + 1. We need two vouchers i and j where the sum of their durations is exactly x, and they don't overlap. Also, i and j must be different.\n\nFirst, I need to think about how to approach this efficiently given the constraints. The n can be up to 2e5, which is 200,000. So O(n^2) approaches are definitely out of the question. We need something more efficient, like O(n log n) or O(n).\n\nLet me think: For each voucher, if I can find another voucher that has a duration of (x - duration of current voucher), and that doesn't overlap with it. Then, for each voucher, check if there exists a voucher with the required duration that comes before or after it.\n\nBut how to efficiently find the minimal cost for those vouchers?\n\nLet me break down the steps:\n\n1. Preprocess all vouchers by their duration. For each possible duration d, keep track of the minimum cost for vouchers of that duration. But also, for each duration d, we need to know the earliest end time (so that another voucher can start after it) and the latest start time (so that another voucher can end before it). Wait, maybe not. Let me think.\n\nAlternatively, for each voucher, let's say its duration is d. Then we need another voucher with duration (x - d). Let's call that target duration t = x - d. So for each voucher, we need to find a voucher with duration t that does not overlap with it.\n\nBut how to find such vouchers efficiently?\n\nLet me think about the two cases where vouchers do not overlap:\n\nCase 1: voucher A ends before voucher B starts. So, A's end day < B's start day.\n\nCase 2: voucher B ends before voucher A starts. So, B's end day < A's start day.\n\nSo for a given voucher A, if we have a voucher B with duration t, then either B ends before A starts, or A ends before B starts.\n\nSo for each voucher A with duration d, we need to find vouchers B with duration t = x - d, such that B's end is <= A's start - 1 (so that B ends before A starts), or B's start is >= A's end + 1 (so that A ends before B starts).\n\nBut how to find the minimal cost for these possibilities?\n\nHmm. Maybe for each possible duration d, we can pre-process the vouchers of that duration in a way that allows us to quickly query the minimal cost for vouchers that end before a certain day, or start after a certain day.\n\nFor example, for all vouchers of duration t, we can sort them by their end day. Then, for a given voucher A, which requires a voucher B of duration t, we can find the minimal cost of vouchers B where B's end is <= (A's start - 1). Similarly, we can sort vouchers of duration t by their start day, and find the minimal cost of vouchers B where B's start >= (A's end + 1).\n\nBut how to do that?\n\nLet me think about building two structures for each duration:\n\n- For vouchers of duration t, sorted by their end day. Then, for a given value of (A's start - 1), we can perform a binary search to find all vouchers B with end day <= that value. Among those, we want the minimal cost.\n\nSimilarly, for vouchers of duration t, sorted by their start day. For a given value of (A's end + 1), find all vouchers B with start day >= that value. Again, find the minimal cost among those.\n\nSo, for each duration t, we can have two sorted lists:\n\n- One sorted by end day, with prefix minima (so that for any position, we can know the minimal cost up to that point).\n\n- One sorted by start day, with suffix minima (so that for any position, we can know the minimal cost from that position onwards).\n\nWait, but how to handle that?\n\nAlternatively, for each duration t, we can have two arrays:\n\n- A list of vouchers sorted by end day. Then, for each such list, we can precompute a prefix minimum array. So when we need to find the minimal cost of vouchers ending before a certain day, we can binary search the sorted list to find the largest end day <= target, and then get the prefix minimum up to that index.\n\nSimilarly,",
    "response": "\n\nTo solve this problem efficiently, we need to find two non-overlapping vouchers whose combined duration equals a given value `x`, and whose total cost is minimized. The solution involves preprocessing vouchers by their duration and using binary search to quickly find valid pairs.\n\n### Approach\n1. **Preprocessing by Duration**: Group vouchers by their duration. For each duration, maintain two sorted lists: one sorted by end day and another sorted by start day.\n2. **Prefix and Suffix Minimum Arrays**: For each duration, create prefix minimum arrays for the end-sorted list and suffix minimum arrays for the start-sorted list. These arrays help in quickly finding the minimum cost of valid vouchers.\n3. **Binary Search**: For each voucher, determine if there exists another voucher with the required duration that does not overlap. Use binary search on the sorted lists to find valid vouchers efficiently.\n\n### Solution Code\n```python\nimport sys\nimport bisect\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n    \n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        vouchers.append((l, r, cost))\n    \n    # Preprocess: group vouchers by their duration\n    duration_dict = defaultdict(list)\n    for l, r, cost in vouchers:\n        d = r - l + 1\n        duration_dict[d].append((l, r, cost))\n    \n    # For each duration, prepare sorted lists and min arrays\n    # For each duration t, we have:\n    # - sorted_end: list of (end_day, start_day, cost), sorted by end_day\n    #   and prefix_min array\n    # - sorted_start: list of (start_day, end_day, cost), sorted by start_day\n    #   and suffix_min array\n    duration_data = dict()\n    for d in duration_dict:\n        lst = duration_dict[d]\n        # Prepare sorted by end day\n        sorted_end = sorted(lst, key=lambda x: x[1])\n        prefix_min = []\n        min_cost = float('inf')\n        for item in sorted_end:\n            min_cost = min(min_cost, item[2])\n            prefix_min.append(min_cost)\n        # Prepare sorted by start day\n        sorted_start = sorted(lst, key=lambda x: x[0])\n        suffix_min = [0] * len(sorted_start)\n        min_cost = float('inf')\n        for i in range(len(sorted_start)-1, -1, -1):\n            min_cost = min(min_cost, sorted_start[i][2])\n            suffix_min[i] = min_cost\n        duration_data[d] = (sorted_end, prefix_min, sorted_start, suffix_min)\n    \n    min_total = float('inf')\n    \n    for l1, r1, cost1 in vouchers:\n        d1 = r1 - l1 + 1\n        t = x - d1\n        if t < 1:\n            continue\n        if t not in duration_data:\n            continue\n        \n        # Check for vouchers of duration t that end before l1\n        sorted_end, prefix_min, sorted_start, suffix_min = duration_data[t]\n        # Find the largest end_day <= l1 - 1\n        # sorted_end is sorted by end_day (item[1])\n        end_days = [item[1] for item in sorted_end]\n        pos = bisect.bisect_right(end_days, l1 - 1) - 1\n        if pos >= 0:\n            min_cost = prefix_min[pos]\n            if min_cost != float('inf'):\n                min_total = min(min_total, cost1 + min_cost)\n        \n        # Check for vouchers of duration t that start after r1\n        # sorted_start is sorted by start_day (item[0])\n        start_days = [item[0] for item in sorted_start]\n        pos = bisect.bisect_left(start_days, r1 + 1)\n        if pos < len(start_days):\n            min_cost = suffix_min[pos]\n            if min_cost != float('inf'):\n                min_total = min(min_total, cost1 + min_cost)\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Preprocessing**: Vouchers are grouped by their duration. For each duration, we maintain two sorted lists: one sorted by end day and another by start day.\n2. **Prefix and Suffix Minimum Arrays**: These arrays allow quick lookup of the minimum cost for vouchers up to a certain point in the sorted lists.\n3. **Binary Search**: For each voucher, we check for valid non-overlapping vouchers using binary search on the preprocessed lists. This ensures efficient querying and maintains an overall time complexity of O(n log n).",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport bisect\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n    \n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        vouchers.append((l, r, cost))\n    \n    # Preprocess: group vouchers by their duration\n    duration_dict = defaultdict(list)\n    for l, r, cost in vouchers:\n        d = r - l + 1\n        duration_dict[d].append((l, r, cost))\n    \n    # For each duration, prepare sorted lists and min arrays\n    # For each duration t, we have:\n    # - sorted_end: list of (end_day, start_day, cost), sorted by end_day\n    #   and prefix_min array\n    # - sorted_start: list of (start_day, end_day, cost), sorted by start_day\n    #   and suffix_min array\n    duration_data = dict()\n    for d in duration_dict:\n        lst = duration_dict[d]\n        # Prepare sorted by end day\n        sorted_end = sorted(lst, key=lambda x: x[1])\n        prefix_min = []\n        min_cost = float('inf')\n        for item in sorted_end:\n            min_cost = min(min_cost, item[2])\n            prefix_min.append(min_cost)\n        # Prepare sorted by start day\n        sorted_start = sorted(lst, key=lambda x: x[0])\n        suffix_min = [0] * len(sorted_start)\n        min_cost = float('inf')\n        for i in range(len(sorted_start)-1, -1, -1):\n            min_cost = min(min_cost, sorted_start[i][2])\n            suffix_min[i] = min_cost\n        duration_data[d] = (sorted_end, prefix_min, sorted_start, suffix_min)\n    \n    min_total = float('inf')\n    \n    for l1, r1, cost1 in vouchers:\n        d1 = r1 - l1 + 1\n        t = x - d1\n        if t < 1:\n            continue\n        if t not in duration_data:\n            continue\n        \n        # Check for vouchers of duration t that end before l1\n        sorted_end, prefix_min, sorted_start, suffix_min = duration_data[t]\n        # Find the largest end_day <= l1 - 1\n        # sorted_end is sorted by end_day (item[1])\n        end_days = [item[1] for item in sorted_end]\n        pos = bisect.bisect_right(end_days, l1 - 1) - 1\n        if pos >= 0:\n            min_cost = prefix_min[pos]\n            if min_cost != float('inf'):\n                min_total = min(min_total, cost1 + min_cost)\n        \n        # Check for vouchers of duration t that start after r1\n        # sorted_start is sorted by start_day (item[0])\n        start_days = [item[0] for item in sorted_start]\n        pos = bisect.bisect_left(start_days, r1 + 1)\n        if pos < len(start_days):\n            min_cost = suffix_min[pos]\n            if min_cost != float('inf'):\n                min_total = min(min_total, cost1 + min_cost)\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 731,
        "completion_token_count": 1068,
        "thoughts_token_count": 1023
    }
}