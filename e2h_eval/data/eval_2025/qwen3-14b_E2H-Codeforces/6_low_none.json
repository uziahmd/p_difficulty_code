{
    "start": 1758313549.9021847,
    "end": 1758313599.0969226,
    "start-formatted": "2025-09-20 05:25 KST",
    "end-formatted": "2025-09-20 05:26 KST",
    "gpu": 2,
    "pid": 6,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\nOkay, let's see. I need to solve this programming problem. Let me read the problem carefully again.\n\nSo, the problem is about finding two non-overlapping vouchers such that their durations add up exactly to x, and the sum of their costs is minimized. If it's not possible, output -1.\n\nFirst, let's understand the input. Each voucher has li (departure day), ri (return day), and cost. The duration is ri - li + 1. We need two vouchers where one's end is before the other's start (so they don't overlap), and their durations sum to x. And find the minimum total cost.\n\nHmm. So the approach would be to find pairs of vouchers where the first voucher's duration is d, and the second's is x - d. And for each possible d, we need to check if there are vouchers with duration d and x-d, and they don't overlap.\n\nBut how to efficiently do this given the constraints on n (up to 2e5)? A brute force approach checking all pairs would be O(n²), which is way too slow for n=2e5.\n\nSo we need a smarter way. Let's think about grouping vouchers by their duration. For each voucher, we can note its duration and then for each possible d, we can look for vouchers of duration d and x-d.\n\nBut even then, for each voucher with duration d, we need to find another voucher with duration (x -d) that does not overlap with it. But how?\n\nWait, but for each possible duration d, we can precompute the minimal cost of vouchers with duration d that end before a certain day, or start after a certain day. Because for a voucher with duration d, if we want to pair it with a voucher of duration (x-d), then the second voucher must either end before the first starts, or start after the first ends.\n\nSo here's an idea: For each possible duration d, we can have two structures:\n\n- For vouchers of duration d, sorted by their end time. Then, for a voucher with duration d that starts at l and ends at r, any voucher of duration (x-d) that ends before l would be a candidate. Similarly, any voucher of duration (x-d) that starts after r would be a candidate.\n\nBut how to efficiently find the minimal cost for vouchers of duration (x-d) that end before a certain value (like l) or start after a certain value (like r)?\n\nSo maybe we can pre-process for each duration, the list of vouchers sorted by their end time, and also have a prefix minimum array. Similarly, sorted by start time and have a suffix minimum array?\n\nAlternatively, for each duration, we can have two sorted lists:\n\n- One sorted by end time (ri), and for each position in this list, we can have the minimum cost up to that point. Then, when we have a voucher with duration d that starts at l, we can find the earliest end time that is less than l, and get the minimum cost for vouchers of duration (x-d) that end before l.\n\nSimilarly, for vouchers of duration (x-d) sorted by start time, we can find the earliest start time that is after r, and get the minimum cost for those.\n\nWait, but for each duration, say k, we can have:\n\n- A list of vouchers with duration k, sorted by their end time. And for each such list, we can have a prefix min array. So, for example, if we have vouchers sorted by end time, then for any query \"what's the minimal cost of a voucher with duration k that ends before some value L\", we can perform a binary search on the end times to find the largest end time <= L, and then take the prefix min up to that index.\n\nSimilarly, for vouchers of duration k, sorted by their start time, and a suffix min array. So for a query \"find the minimal cost of a voucher with duration k that starts after some value R\", we can binary search to find the first start time > R, and then take the suffix min from that index onwards.\n\nBut how to handle both cases (before and after)?\n\nSo the plan is:\n\nFor each voucher, compute its duration. Let's say the duration is d. Then, for each voucher with duration d, we need to find another voucher with duration x-d, such that they don't overlap.\n\nSo, for each voucher i, with duration d, we can check if there exists vouchers with duration (x -d). For each such voucher j, we need to check if they don't overlap. However, doing this for every voucher would be O(n) per voucher, which is O(n²) again.\n\nBut using the preprocessed data structures, we can for each voucher i with duration d, find the minimal cost of vouchers with duration (x-d) that end before li (so that voucher i starts after voucher j ends), or start after ri (so that",
    "response": "To solve this problem, we need to find two non-overlapping vouchers such that their combined duration exactly matches a given value `x`, and their total cost is minimized. If no such pair exists, we return -1.\n\n### Approach\n1. **Group Vouchers by Duration**: First, we group all vouchers by their duration. This helps in efficiently checking pairs of vouchers with specific durations.\n2. **Preprocess for Efficient Querying**: For each duration, we maintain two sorted lists:\n   - One sorted by the end date (`ri`) to find vouchers ending before a certain date.\n   - Another sorted by the start date (`li`) to find vouchers starting after a certain date.\n3. **Prefix and Suffix Minimum Arrays**: For each sorted list, we create prefix minimum arrays to quickly determine the minimum cost of vouchers up to a certain point in the list.\n4. **Binary Search for Efficient Lookup**: Using binary search, we efficiently find the appropriate positions in the sorted lists to check for non-overlapping vouchers.\n\n### Solution Code\n```python\nimport sys\nimport bisect\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n    \n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n    \n    from collections import defaultdict\n    duration_dict = defaultdict(list)\n    for l, r, cost, d in vouchers:\n        duration_dict[d].append((l, r, cost))\n    \n    # Preprocess for each duration: sorted by end time, and sorted by start time\n    # Also compute prefix min for end-sorted, suffix min for start-sorted\n    preprocessed = dict()\n    for d in duration_dict:\n        lst = duration_dict[d]\n        # Sort by end time\n        end_sorted = sorted(lst, key=lambda x: x[1])\n        # Create prefix min array\n        prefix_min_end = []\n        min_cost = float('inf')\n        for item in end_sorted:\n            min_cost = min(min_cost, item[2])\n            prefix_min_end.append(min_cost)\n        # Sort by start time\n        start_sorted = sorted(lst, key=lambda x: x[0])\n        # Create suffix min array\n        suffix_min_start = [0] * len(start_sorted)\n        min_cost = float('inf')\n        for i in range(len(start_sorted)-1, -1, -1):\n            min_cost = min(min_cost, start_sorted[i][2])\n            suffix_min_start[i] = min_cost\n        preprocessed[d] = (end_sorted, prefix_min_end, start_sorted, suffix_min_start)\n    \n    min_total = float('inf')\n    \n    for l, r, cost, d in vouchers:\n        target_d = x - d\n        if target_d < 1:\n            continue\n        if target_d not in preprocessed:\n            continue\n        # Check for vouchers of duration target_d that end before l\n        end_sorted, prefix_min_end, _, _ = preprocessed[target_d]\n        # Find the largest end <= l-1\n        # Use bisect_right on end times\n        ends = [item[1] for item in end_sorted]\n        pos = bisect.bisect_right(ends, l-1)\n        if pos > 0:\n            current_min = prefix_min_end[pos-1]\n            min_total = min(min_total, cost + current_min)\n        # Check for vouchers of duration target_d that start after r\n        _, _, start_sorted, suffix_min_start = preprocessed[target_d]\n        starts = [item[0] for item in start_sorted]\n        pos = bisect.bisect_right(starts, r)\n        if pos < len(starts):\n            current_min = suffix_min_start[pos]\n            min_total = min(min_total, cost + current_min)\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into a list of vouchers, each with their start date, end date, cost, and duration.\n2. **Grouping by Duration**: Vouchers are grouped by their duration using a dictionary for efficient lookup.\n3. **Preprocessing**: For each duration, vouchers are sorted by their end and start times. Prefix and suffix minimum arrays are created to quickly find the minimum cost up to a certain point in the sorted lists.\n4. **Checking Valid Pairs**: For each voucher, we check if there exists another voucher with the required duration that does not overlap. This is done using binary search on the preprocessed lists to find valid non-overlapping vouchers efficiently.\n5. **Result Calculation**: The minimum total cost of valid voucher pairs is tracked and printed, or -1 if no valid pairs are found.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport bisect\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n    \n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n    \n    from collections import defaultdict\n    duration_dict = defaultdict(list)\n    for l, r, cost, d in vouchers:\n        duration_dict[d].append((l, r, cost))\n    \n    # Preprocess for each duration: sorted by end time, and sorted by start time\n    # Also compute prefix min for end-sorted, suffix min for start-sorted\n    preprocessed = dict()\n    for d in duration_dict:\n        lst = duration_dict[d]\n        # Sort by end time\n        end_sorted = sorted(lst, key=lambda x: x[1])\n        # Create prefix min array\n        prefix_min_end = []\n        min_cost = float('inf')\n        for item in end_sorted:\n            min_cost = min(min_cost, item[2])\n            prefix_min_end.append(min_cost)\n        # Sort by start time\n        start_sorted = sorted(lst, key=lambda x: x[0])\n        # Create suffix min array\n        suffix_min_start = [0] * len(start_sorted)\n        min_cost = float('inf')\n        for i in range(len(start_sorted)-1, -1, -1):\n            min_cost = min(min_cost, start_sorted[i][2])\n            suffix_min_start[i] = min_cost\n        preprocessed[d] = (end_sorted, prefix_min_end, start_sorted, suffix_min_start)\n    \n    min_total = float('inf')\n    \n    for l, r, cost, d in vouchers:\n        target_d = x - d\n        if target_d < 1:\n            continue\n        if target_d not in preprocessed:\n            continue\n        # Check for vouchers of duration target_d that end before l\n        end_sorted, prefix_min_end, _, _ = preprocessed[target_d]\n        # Find the largest end <= l-1\n        # Use bisect_right on end times\n        ends = [item[1] for item in end_sorted]\n        pos = bisect.bisect_right(ends, l-1)\n        if pos > 0:\n            current_min = prefix_min_end[pos-1]\n            min_total = min(min_total, cost + current_min)\n        # Check for vouchers of duration target_d that start after r\n        _, _, start_sorted, suffix_min_start = preprocessed[target_d]\n        starts = [item[0] for item in start_sorted]\n        pos = bisect.bisect_right(starts, r)\n        if pos < len(starts):\n            current_min = suffix_min_start[pos]\n            min_total = min(min_total, cost + current_min)\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 732,
        "completion_token_count": 1082,
        "thoughts_token_count": 1024
    }
}