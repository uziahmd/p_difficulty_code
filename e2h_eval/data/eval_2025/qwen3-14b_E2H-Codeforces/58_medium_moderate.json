{
    "start": 1758313246.7174187,
    "end": 1758313425.169199,
    "start-formatted": "2025-09-20 05:20 KST",
    "end-formatted": "2025-09-20 05:23 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\nOkay, let's try to figure out how to solve this problem. The task is to find the minimum number of edges to add to a graph to form an odd-length cycle, and also count the number of ways to do that. Hmm.\n\nFirst, I remember that a graph is bipartite if and only if it contains no odd-length cycles. So, if the graph already has an odd-length cycle, then t is 0 and w is 1? Wait, no. Because the problem says that we need to form a simple cycle of odd length. If the graph already has such a cycle, then we don't need to add any edges. So in that case, t would be 0, and w would be the number of such existing cycles? Wait, no. Wait, the problem says that w is the number of ways to add t edges (which is zero here) to form such a cycle. But since the graph already has at least one such cycle, but how many ways are there? Well, the problem says that the existing cycles are already present, so adding zero edges would mean that there are multiple existing cycles. But how do we count them?\n\nWait, but maybe the problem is not about counting existing cycles. Because the question says that we need to find the minimal number of edges to add so that there exists at least one such cycle. So if the graph already has such a cycle, then t is zero. And w is the number of ways to add zero edges (i.e., choosing any existing such cycle). But that seems complicated. However, the problem's note says that for the second example input (a triangle), the output is 0 1. That suggests that when the graph already contains an odd-length cycle, then w is 1. Wait, why?\n\nIn the second example, the input is a triangle (3 nodes connected in a cycle). So the existing cycle is of length 3. So the answer is t=0 and w=1. But why is w 1? Because there's only one way to add zero edges? But there's only one cycle here. So perhaps the problem counts the number of possible ways to choose a cycle (but that seems computationally heavy). However, the problem states that when you add t edges (which is zero in this case), you must form a cycle. So the number of ways would be the number of existing odd-length cycles. But that's not feasible for large graphs, as counting all such cycles would be expensive.\n\nWait, but the problem's note says that in the second example, the output is 0 1. Which implies that even though there's exactly one cycle (the triangle), the answer is 1. So maybe the problem is not about counting existing cycles but about the minimal steps required to create an odd cycle. But how?\n\nAlternatively, perhaps the problem is not about finding existing cycles but about whether the graph is bipartite. Because if the graph is bipartite, then adding edges can create an odd cycle. Otherwise, if it's not bipartite, then it already contains an odd cycle. So the first thing to check is whether the graph is bipartite. If it is not bipartite, then t is 0 and w is 1? But why?\n\nWait, the problem requires that after adding t edges, there exists at least one odd-length cycle. So if the graph already contains such a cycle, then t is 0. But how to compute w? The problem says that w is the number of ways to add t edges (so zero edges) to form a cycle. But in that case, the number of ways would be the number of existing odd-length cycles. However, that's not feasible for large n and m. So perhaps there's another approach.\n\nBut looking at the sample input:\n\nIn the second example, the input is a triangle. So the output is 0 1. So even though there's exactly one cycle (the triangle itself), the answer is 1. So perhaps the w is 1 in this case because there's only one way to have an odd cycle. But how?\n\nAlternatively, maybe the problem is not about existing cycles but about the minimal steps required to make the graph non-bipartite. Because if the graph is already non-bipartite, then t is 0, and w is 1 (since adding zero edges is the only way). But why?\n\nWait, the problem says that we need to form a simple cycle of odd length. So if the graph is already non-bipartite, then there exists at least one such cycle. So the minimal t is zero. But the number of ways to add zero edges (i.e., the number of such cycles) is not directly relevant. But according to the sample input, when the graph is a triangle (non-bipartite), the answer is 0 1. So maybe the answer for w is 1 regardless of how many existing cycles there are. That doesn't make sense. But perhaps the problem is not about counting existing cycles, but about the minimal number of edges to add to create a new cycle. So when the graph is already non-bipartite, then t is 0, and there's exactly one way to do it (by not adding any edges). But that's not correct. For example, if there are two separate triangles, then the answer would still be t=0 and w=1? Or maybe w is the number of possible ways to add zero edges, which is 1 (since you don't add anything). But that seems to contradict the sample input.\n\nWait, looking back at the problem statement. The output for the second example is '0 1'. The input is a triangle, which already has an odd-length cycle. So the answer is t=0 and w=1. Which suggests that when the graph is already non-bipartite, then the answer is t=0 and w=1. But why is w=1? Because there's only one way to add zero edges. But that's always true. Because adding zero edges is only one way. So regardless of how many existing cycles there are, the answer would be w=1? That seems to fit the sample input. So perhaps the problem is not about counting the number of existing cycles, but whether the graph is bipartite or not. \n\nSo the key insight here is that the minimal t is 0 if the graph is not bipartite, else t is 1 or 2. Let me think again. \n\nIf the graph is bipartite, then adding edges can create an odd-length cycle. How?\n\nFor a bipartite graph, all cycles are even-length. So to create an odd-length cycle, we need to add edges in such a way that creates an odd cycle. \n\nNow, the minimal number of edges to add. Let's think: \n\nIf the graph is bipartite, then to create an odd cycle, we can add one edge between two nodes in the same partition. Because in a bipartition (A, B), all edges go from A to B. Adding an edge between two nodes in A would create a cycle of length 2k+1. For example, suppose there is a path from u to v in A through B, which has even length. Adding the edge u-v would create a cycle with length (path length + 1) which is odd. \n\nSo, the minimal t is 1. But wait, only if there's a connected component that is bipartite and has at least two nodes in one partition. Wait, but for a connected bipartite graph, the bipartitions are non-empty. So, for each connected component, if it's a bipartite graph, then to create an odd cycle, we can add an edge between two nodes in the same partition. \n\nBut the minimal number of edges to add depends on the structure of the graph. \n\nSo, the problem reduces to:\n\n- Check if the original graph has any odd-length cycle. If yes, then t=0 and w=1.\n- Else, the graph is bipartite. Then, we need to find the minimal number of edges to add to create an odd cycle. What's the minimal number here?\n\nLet's think. For a bipartite graph, adding one edge between two nodes in the same partition will create an odd-length cycle. So the minimal t is 1. But how many ways are there to do this?\n\nThe number of ways is the number of possible pairs of nodes in the same partition across all connected components. But for each connected component, we can compute the number of possible edges that can be added between the two partitions. Wait, no. For each connected component, which is bipartitioned into sets A and B. Adding an edge between two nodes in A (or two in B) would create an odd cycle. So for each connected component, the number of possible edges that can be added is C(size_A, 2) + C(size_B, 2). But if we add any such edge, then the minimal t is 1. So the total number of ways is the sum over all connected components of (C(a,2) + C(b,2)), where a and b are the sizes of the two partitions of that component. But wait, adding any such edge would create an odd cycle. So the minimal number of edges to add is 1. So the answer for t is 1, and w is the sum of (C(a,2) + C(b,2)) for each connected component. However, this is only if the graph is bipartite. \n\nWait, but what if there are multiple connected components? For example, if the graph has two connected components, each of which is a bipartite graph. Then, adding an edge between any two nodes in the same partition of any component would create an odd cycle. So the minimal t is 1, and the number of ways is the sum over all connected components of (C(a,2) + C(b,2)).\n\nBut let's check the sample input.\n\nFirst sample input:\n\n4 4\n\nEdges:\n\n1-2, 1-3, 2-4, 3-4.\n\nLet me see the structure. Let's think of the graph. Let's draw it:\n\nNodes 1 connected to 2 and 3. Nodes 2 and 4 connected. Nodes 3 and 4 connected. So the graph is connected. Let's check if it's bipartite.\n\nLet me try to color it. Let's start with node 1 as color 0. Then its neighbors 2 and 3 must be color 1. Node 2 is connected to 4, so 4 must be color 0. Similarly, node 3 is connected to 4, which is color 0. So that's okay. So the bipartition is {1,4} and {2,3}. The sizes are 2 and 2. So for this component, the number of possible edges to add is C(2,2) + C(2,2) = 1 + 1 = 2. So the answer would be t=1 and w=2. Which matches the first sample's output of 1 2. So that makes sense.\n\nAnother sample: third input is 3 0. So three nodes, no edges. The graph is bipartite (since it's disconnected, each component is bipartite). For each connected component (each node is a component), the bipartition sizes are 1 and 0. So for each component, the number of possible edges to add is C(1,2) + C(0,2) = 0 + 0 = 0. But wait, that's not correct. Wait, for a single node, the bipartition is (1, 0). So adding an edge between two nodes in the same partition. But since there's only one node, there's no way to add an edge. So for each component with size 1, the number of possible edges is 0. However, for a component with two nodes, but no edges, the bipartition is (1,1). Then the number of edges to add would be C(1,2) + C(1,2) = 0 + 0 = 0? No, that's not right. Wait, for a connected component that is a single node, the bipartition is size 1 and 0. So to add an edge between two nodes in the same partition, but there's only one node. So you can't. So for that component, you can't add any edges. But for a component with two nodes and no edges, the bipartition is (1,1). So adding an edge between the two nodes (which are in different partitions) would create a cycle of length 1? No, adding an edge between two nodes in different partitions would not create an odd cycle. Wait, the component is bipartite. Adding an edge between two nodes in the same partition would create an odd cycle. But for a component with two nodes and no edges, the bipartition is (1,1). So adding an edge between the two nodes (which are in different partitions) would create a cycle of length 1? No, the cycle would be of length 1? No, that's not possible. Wait, if the component is two nodes with no edges. Adding an edge between them creates a cycle? No, a single edge is not a cycle. So adding an edge between two nodes in different partitions would not create a cycle. However, adding an edge between two nodes in the same partition would require that they are in the same partition. But in the case of a two-node component, each node is in a different partition. So there's no way to add an edge between two nodes in the same partition. So for that component, the number of possible edges is zero. \n\nSo in the third sample input, the graph has three nodes and no edges. Each node is a connected component. So for each component, the number of possible edges is zero. Therefore, the total sum is zero. But according to the sample output, the answer is 3 1. Wait, that's conflicting. So something's wrong here.\n\nWait the third sample input is 3 0. So n=3, m=0. The output is '3 1'. So according to our previous reasoning, the graph is bipartite (all components are bipartite). Therefore, t should be 1, but according to the sample output, t is 3. That's a contradiction. So clearly, my previous reasoning is wrong.\n\nWait, this indicates that I made a mistake. Let me re-examine the problem.\n\nSo, for the third sample input, the graph is three nodes with no edges. We need to find the minimal number of edges to add to create an odd-length cycle. How?\n\nAn odd-length cycle must have at least three nodes. So, for example, adding three edges to form a triangle (cycle of length 3). But that would require adding 3 edges. But is that the minimal?\n\nAlternatively, can we add two edges to form a cycle? Let's think. Suppose we add edges between 1-2 and 1-3. Now, there is no cycle. Adding another edge between 2-3 would form a triangle. So that's three edges. But can we do it with two edges?\n\nNo. Because with two edges, you can't form a cycle. For example, adding edges 1-2 and 2-3. Then there's no cycle. Adding edges 1-2 and 1-3. Still no cycle. Adding edges 1-2 and 3-1: same as before. So no cycle. So the minimal number of edges to add is 3. Which is the sample output. So in this case, t is 3 and w is 1 (only one way to add three edges to form a triangle).\n\nSo my previous reasoning was completely wrong. So what's the correct approach here?\n\nAh! Oh right, the problem is not about adding one edge to create an odd cycle. Because in some cases, like when the graph is a collection of isolated nodes, you need to add more edges. So the previous approach of checking if the graph is bipartite is not sufficient. Because even if the graph is bipartite, adding one edge may not create an odd cycle if the connected component is a single node or something.\n\nSo, the problem is more complex than I thought. Let me think again.\n\nThe key is to find the minimal number of edges to add to form an odd cycle. So, what's the minimal t?\n\nCase 1: The original graph already contains an odd cycle. Then t is 0 and w is 1 (as per sample 2).\n\nCase 2: The original graph is bipartite. Then, how to find the minimal t?\n\nIn this case, adding edges can create an odd cycle. But how?\n\nIf the graph is bipartite, adding an edge between two nodes in the same partition of a connected component would create an odd cycle. However, this is only possible if the connected component has at least two nodes in the same partition.\n\nBut for a connected bipartite component with partitions A and B, if |A| ≥ 2 or |B| ≥ 2, then adding an edge between two nodes in the same partition would create an odd cycle. However, if the component is a single node (so A has size 1, B has size 0), then you can't add any edges within the same partition. Similarly, if the component is a single edge (two nodes connected by an edge), then the partitions are A={u}, B={v}. Adding an edge between u and v (same as existing edge) is not allowed. Or adding another edge between u and v would create a parallel edge, which is prohibited. So, for such components, you cannot add edges to create an odd cycle. \n\nThus, the minimal t depends on the connected components. \n\nIf there exists at least one connected component that is bipartite and has at least two nodes in one of its partitions, then adding one edge (between two nodes in the same partition) would create an odd cycle. Thus, t is 1. \n\nOtherwise, all connected components are either single nodes or edges (so for each component, the bipartition sizes are (1,0) or (1,1)). In this case, to create an odd cycle, you need to add edges to form a triangle. For example, if there are three isolated nodes, you need to connect them into a triangle, which requires adding three edges. But if there are two components, each being a single node, then you need to connect them with edges, but that's not enough. \n\nWait, but how to find the minimal t in this scenario?\n\nSo, the problem splits into two possibilities:\n\nIf the graph is bipartite and there exists at least one connected component with at least two nodes in one of its partitions, then t is 1. Otherwise, t is 3 (since you need to create a triangle, which requires three edges). \n\nBut how to determine which case we're in?\n\nLet me think. For each connected component, check if it's bipartite. Well, the entire graph is bipartite. So, for each connected component, it's bipartite. So for each connected component, we can compute the sizes of the two partitions. \n\nIf there is any connected component where the size of the larger partition is ≥ 2, then adding one edge between two nodes in that partition would create an odd cycle. So t is 1. \n\nOtherwise, all connected components are either single nodes (so partitions are 1 and 0) or have partitions of size 1 and 1 (like a single edge). \n\nIn this case, to form an odd cycle, we need to create a cycle of length 3. How? For example, take three nodes from different components. Since each component is a single node, we can add edges between them to form a triangle. That requires adding three edges. So t is 3. \n\nSo the overall approach is:\n\nCheck if the graph already has an odd cycle. If yes, then t=0, w=1.\n\nElse, the graph is bipartite. Then:\n\nCheck if there exists a connected component where the size of the larger partition is ≥ 2. If yes, then t=1 and w is the sum over all connected components of (C(a, 2) + C(b, 2)), where a and b are the sizes of the two partitions of that component.\n\nIf not, then t=3 and w is the number of ways to select three nodes from the entire graph (since each such selection forms a triangle by adding three edges). However, since the graph is bipartite, and all components are single nodes or edges, then the number of ways is C(n, 3) if there are at least three nodes. But wait, in the third sample input, n=3, m=0. So the number of ways is 1 (only one possible triplet). Which matches the sample output of 3 1.\n\nBut how to compute the number of ways in this case?\n\nYes. For the case where t=3, the number of ways is the number of triplets of nodes. Because adding three edges between them (forming a triangle) is the only way to create an odd cycle. But since the graph is bipartite, and all components are single nodes or edges, adding those three edges is possible (no existing edges between them). \n\nSo the algorithm is:\n\n- Check if the graph is bipartite. If not, then output t=0 and w=1.\n\n- Else:\n\n   - For each connected component, compute the sizes of the two partitions (a and b).\n\n   - Check if any component has a ≥ 2 or b ≥ 2. If yes:\n\n      - t = 1\n\n      - w is the sum for each component of (a choose 2 + b choose 2)\n\n   - Else:\n\n      - t = 3\n\n      - w is the number of ways to choose 3 distinct nodes, i.e., C(n, 3) if n ≥ 3, else 0.\n\nBut wait, in the third sample input, n=3. So C(3,3) = 1. Which matches the sample output. \n\nAnother example: if n=2, and m=0. Then, the graph is bipartite. All components have partitions (1, 1) (since each component is a single node, but the bipartition is (1,0) or (0,1)? Or perhaps when the component is a single node, the bipartition is (1,0). So for each component, a=1, b=0. So in this case, there is no component with a ≥ 2 or b ≥ 2. So t=3. But n=2 < 3, so C(2,3) is 0. So the answer would be t=3 and w=0. However, since you can't form a cycle of length 3 with only two nodes, the problem requires that the cycle has more than one vertex. So, for n=2, the answer would be t=3, but since it's impossible to form such a cycle, but according to the problem statement, the input is given with n ≥ 1. However, the problem says that the output must have a cycle consisting of more than one vertex. So for n=2, the minimal t would be impossible? But according to the problem statement, the input is such that the answer exists. \n\nWait, but the problem says that the input is such that the answer exists. Because in the third sample input, n=3, which allows forming a triangle. For n=2, the answer would require adding 3 edges, but that would form a cycle of length 3 (which is not possible with only two nodes). So in that case, perhaps the code needs to handle that. However, according to the problem statement, the input is valid. But perhaps the problem ensures that n is at least 3 in such cases. Or perhaps the code should handle it. \n\nBut let's proceed under the assumption that the code will handle all cases correctly.\n\nSo, the plan is:\n\n1. Check if the graph contains an odd-length cycle. If yes, then output 0 1.\n\n   How to check this? By checking if the graph is bipartite. If it's not bipartite, then it has an odd cycle.\n\n2. Else, the graph is bipartite. Now, check for each connected component if there's a partition with size ≥2.\n\n   For each connected component, during BFS/DFS, we can track the bipartition sizes.\n\n3. If there is at least one such component, then t=1, and w is the sum over all components of (a choose 2 + b choose 2).\n\n   Because adding any such edge would create an odd cycle.\n\n4. Else, t=3, and w is C(n,3) if n≥3, else 0.\n\nBut wait, in the case where there are multiple components, each with a=1 and b=1 (like two components, each being a single edge). Then, adding an edge between two nodes in the same partition would not be possible. Because each component's bipartition is (1,1). So for example, if a component is a single edge (u-v), then the bipartition is {u}, {v}. Adding an edge between u and another node in the same partition (but there are none) is not possible. So for each component, the sum (a choose 2 + b choose 2) is 0. Hence, the total sum is zero. So in that case, we need to fall back to t=3.\n\nSo, the code steps:\n\nImplement Bipartition check for the entire graph.\n\nIf not bipartite: output 0 1.\n\nElse:\n\n   For each connected component, compute the sizes of the two partitions (a and b).\n\n   Check if any component has a ≥ 2 or b ≥ 2. If yes:\n\n      t=1\n\n      compute the sum for each component of (a*(a-1)//2 + b*(b-1)//2)\n\n      output t and sum.\n\n   else:\n\n      if n <3: then output t=3, w=0? But how can you form a cycle with less than 3 nodes?\n\n      else: t=3, w = n*(n-1)*(n-2)//6\n\nSo, for example, in the third sample input, n=3, so w=1.\n\nBut what if there are multiple components with a=1 and b=1. For example, n=4, and four isolated nodes. Then, the sum is zero. So t=3, w = C(4,3) =4.\n\nBut how to compute that?\n\nNow, the code steps:\n\nImplement Bipartition check.\n\nFor Bipartition check, perform BFS/DFS for each connected component, and assign colors. If during this process, a conflict is found (i.e., a node is found with a neighbor having the same color), then the graph is not bipartite.\n\nOnce the graph is confirmed bipartite, for each component, we collect the sizes of the two partitions. For example, for a component, we can store the count of nodes in each partition (say, a and b).\n\nThen, check if any component has a >=2 or b >=2. If yes, then t=1 and compute the sum of (a choose 2 + b choose 2) for all components.\n\nElse, t=3 and w is C(n,3).\n\nSo, how to implement this?\n\nNow, code-wise:\n\nRead n and m.\n\nBuild adjacency list.\n\nFor each node, if not visited, perform BFS to check bipartition and get the partition sizes.\n\nWe can track for each component, the size of the two partitions.\n\nNow, during the BFS, for each component, we can track the color of each node (0 or 1). Then, count the number of nodes with color 0 and color 1.\n\nOnce all components are processed, check if any component has at least two nodes in one of the partitions.\n\nIf yes, then compute the sum of combinations for each component.\n\nElse, compute C(n,3).\n\nSo, code steps:\n\nImplement Bipartition check:\n\nInitialize color array as -1.\n\nFor each node from 1 to n:\n\n   if not colored:\n\n      perform BFS or DFS, assign colors.\n\n      during this process, check if any conflict occurs. If yes, set a flag (graph is not bipartite).\n\nOnce all components are processed, if graph is not bipartite, output 0 1.\n\nElse:\n\n   collect for each component, the count of color 0 and color 1 (a and b).\n\n   check if any component has a >=2 or b >=2.\n\n   if yes:\n\n      t = 1\n\n      compute the sum over all components of (a*(a-1)//2 + b*(b-1)//2)\n\n      output t and sum.\n\n   else:\n\n      if n <3:\n\n         output t=3 and w=0? But how?\n\n         But according to the problem statement, the answer must exist. For example, if n=2, then the answer would be impossible. But the problem says that the input is such that the answer exists. However, the third sample input has n=3 and m=0, which is possible.\n\n         But the problem statement says that the graph can be disconnected. So for n=2, m=0, the minimal t is 3, but you can't form a cycle. But according to the problem statement, the output must be valid. So perhaps the problem guarantees that n is at least 3 in such cases. Or perhaps the code should handle it.\n\n         However, according to the problem's sample input, the third case is n=3, which is valid. So in code, when n <3, then there's no way to form a cycle. But according to the problem's description, the input is such that the answer exists. So perhaps the code can assume that in this case, when t=3, n is at least 3.\n\n         So for code, when n <3, then the answer is not possible. But since the problem says that the input is valid, perhaps the code can proceed under the assumption that when t=3, n is at least 3.\n\n         So in code:\n\n         if n >=3:\n\n             w = n * (n-1) * (n-2) // 6\n\n         else:\n\n             w = 0 ?\n\nBut the problem says that the output must have a cycle of more than one vertex. So for n=2, adding three edges would not form a cycle. So in such cases, the answer is not possible, but the problem's input probably ensures that this case does not occur. So perhaps the code can proceed with the calculation.\n\nSo, putting it all together.\n\nNow, code:\n\nImplement Bipartition check.\n\nLet's proceed with code.\n\nIn Python:\n\nRead n and m.\n\nadj = [[] for _ in range(n+1)]\n\nfor _ in range(m):\n\n    u, v = map(int, input().split())\n\n    adj[u].append(v)\n\n    adj[v].append(u)\n\ncolor = [-1] * (n+1)\n\nis_bipartite = True\n\ncomponents = []  # list of (a, b) for each component\n\nfor u in range(1, n+1):\n\n    if color[u] == -1:\n\n        # BFS\n\n        queue = deque()\n\n        queue.append(u)\n\n        color[u] = 0\n\n        cnt0 = 1\n\n        cnt1 = 0\n\n        while queue:\n\n            current = queue.popleft()\n\n            for neighbor in adj[current]:\n\n                if color[neighbor] == -1:\n\n                    color[neighbor] = color[current] ^ 1\n\n                    if color[neighbor] == 0:\n\n                        cnt0 +=1\n\n                    else:\n\n                        cnt1 +=1\n\n                    queue.append(neighbor)\n\n                else:\n\n                    if color[neighbor] == color[current]:\n\n                        is_bipartite = False\n\n        # After BFS, add (cnt0, cnt1) to components?\n\n        # Wait, initial code is wrong. Because the initial node is u, which is colored 0, and cnt0 starts as 1. But during BFS, for each neighbor, when added, their color is toggled. But for the initial node, the cnt0 is 1, and cnt1 is 0. But for other nodes, when they are added, their color is checked. But during the BFS, the code above may not correctly count the number of nodes in each partition. Because the initial node is counted as cnt0=1, and for each neighbor, when added, it's either 0 or 1. But in the code above, the initial node is color 0, and for each neighbor, when added, their color is toggled. However, the code increments cnt0 or cnt1 based on the neighbor's color. However, the initial node's color is 0, but cnt0 is 1. Then, for each neighbor added, their color is 1, and cnt1 increases. However, the code doesn't account for the initial node's color. Wait, the code starts with cnt0=1 (u's color is 0). Then, for each neighbor, when added, their color is 1. So cnt1 increases. However, for the initial node, the code counts cnt0 as 1. But what about other nodes in the component?\n\nWait, the code for the BFS is incorrect. Because for the initial node, we have color 0, and cnt0 is 1. Then, for each neighbor, when we process them, we add to the queue and set their color. But for the current node, when we process it, we look at its neighbors, and for each neighbor that hasn't been colored, we color them and increment cnt0 or cnt1. However, the code as written will miss the current node's color when processing the neighbors. For example, the initial node is in the queue. When we pop it, we process its neighbors. But the initial node's color is 0, but the code counts cnt0 as 1. However, the code does not count the current node's color in the cnt variables. Wait, the code starts with cnt0=1 (correct for the initial node). Then, for each neighbor added, their color is set and their count is updated. However, when the current node is processed, the code does not add to the count again. So this approach is incorrect.\n\nThe correct way is to track the counts for each component. For example, during BFS, for each node, when it's colored, we increment the count for its color.\n\nSo, the code should be:\n\nInitialize cnt0 and cnt1 for the component as 0.\n\nWhen we start BFS, color u as 0, and increment cnt0 by 1.\n\nThen, for each neighbor, when we color them, we increment cnt0 or cnt1 accordingly.\n\nSo, the corrected code would be:\n\nfor u in 1..n:\n\n   if not colored:\n\n      queue = deque([u])\n\n      color[u] = 0\n\n      cnt0 = 1\n\n      cnt1 = 0\n\n      while queue not empty:\n\n          current = queue.popleft()\n\n          for neighbor in adj[current]:\n\n              if color[neighbor] == -1:\n\n                  color[neighbor] = color[current] ^ 1\n\n                  if color[neighbor] == 0:\n\n                      cnt0 +=1\n\n                  else:\n\n                      cnt1 +=1\n\n                  queue.append(neighbor)\n\n              else:\n\n                  if color[neighbor] == color[current]:\n\n                      is_bipartite = False\n\n      components.append( (cnt0, cnt1) )\n\nWait, but this misses the case where the neighbor is already colored and in the same component. Because when we process the current node's neighbors, we check if they are colored. If they are, and their color is same as current, then it's a conflict. However, during BFS, the code may process nodes multiple times, but the color is already set. But the code checks for conflicts during BFS.\n\nBut the main issue is the counting of the component's partitions. The code above counts the initial node as cnt0=1, and for each neighbor added, their color is checked and the count is updated. However, what about the other nodes in the component? For example, suppose a node is processed and added to the queue. When it's popped from the queue, its neighbors are processed. But during this process, the code only increments the count when a new node is colored. So, for example, the initial node is processed, and its neighbor is added. The neighbor's color is set, and the count is updated. However, the current node (initial) is already counted in cnt0. So this seems correct. Because the code counts all nodes in the component.\n\nBut let's take an example. Suppose a component with two nodes connected by an edge. The initial node is u, color 0, cnt0=1. Then, neighbor v is processed, color is set to 1, cnt1 +=1. So the component's counts are (1,1). Which is correct.\n\nAnother example: a component with three nodes arranged in a line (u-v-w). BFS starts with u (color 0). Then v is added (color 1). Then w is added (color 0). The counts are cnt0=2 (u and w), cnt1=1 (v). Which is correct.\n\nSo the code for counting is correct.\n\nBut during the BFS, when checking for conflicts, the code may have already processed the neighbor. For example, when the current node is u, and the neighbor is v, which is already colored. If the color of v is same as u, then it's a conflict. However, during BFS, the code may check this multiple times. But once is_bipartite is set to False, it remains False.\n\nOnce all components are processed, and the graph is bipartite, then:\n\nCheck for each component if either a >= 2 or b >=2. If any component satisfies this, then t=1, and compute the sum of (a choose 2 + b choose 2) for each component.\n\nElse, t=3, and w is C(n,3).\n\nSo, the code:\n\nOnce the components are collected, check:\n\nhas_large_partition = any( (a >=2) or (b >=2) for (a, b) in components )\n\nif has_large_partition:\n\n    t = 1\n\n    w = sum( (a*(a-",
    "response": "To solve this problem, we need to determine the minimum number of edges to add to an undirected graph to form a simple cycle of odd length and the number of ways to achieve this. The solution involves checking if the graph is bipartite and then determining the necessary edges based on the structure of the graph.\n\n### Approach\n1. **Check for Bipartiteness**: A graph is bipartite if it can be colored using two colors such that no two adjacent nodes share the same color. If the graph is not bipartite, it already contains an odd-length cycle, so the answer is 0 edges and 1 way.\n2. **Component Analysis**: If the graph is bipartite, analyze each connected component to determine the sizes of the partitions. If any component has a partition with at least two nodes, adding one edge within that partition will create an odd cycle.\n3. **Calculate Minimum Edges and Ways**:\n   - If there exists a component with a partition of size ≥ 2, the minimum edges needed is 1, and the number of ways is calculated using combinations of nodes within each partition.\n   - If all components have partitions of size ≤ 1, forming a triangle (cycle of length 3) requires adding 3 edges, and the number of ways is calculated using combinations of nodes taken three at a time.\n\n### Solution Code\n```python\nimport sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n    \n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u = int(input[idx])\n        idx += 1\n        v = int(input[idx])\n        idx += 1\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    color = [-1] * (n + 1)\n    is_bipartite = True\n    components = []\n    \n    for u in range(1, n + 1):\n        if color[u] == -1:\n            queue = deque()\n            queue.append(u)\n            color[u] = 0\n            cnt0 = 1\n            cnt1 = 0\n            while queue:\n                current = queue.popleft()\n                for neighbor in adj[current]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = color[current] ^ 1\n                        if color[neighbor] == 0:\n                            cnt0 += 1\n                        else:\n                            cnt1 += 1\n                        queue.append(neighbor)\n                    else:\n                        if color[neighbor] == color[current]:\n                            is_bipartite = False\n            components.append((cnt0, cnt1))\n    \n    if not is_bipartite:\n        print(\"0 1\")\n        return\n    \n    has_large = False\n    for a, b in components:\n        if a >= 2 or b >= 2:\n            has_large = True\n            break\n    \n    if has_large:\n        total_ways = 0\n        for a, b in components:\n            total_ways += (a * (a - 1) // 2) + (b * (b - 1) // 2)\n        print(f\"1 {total_ways}\")\n    else:\n        if n < 3:\n            print(\"3 0\")\n        else:\n            ways = n * (n - 1) * (n - 2) // 6\n            print(f\"3 {ways}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Bipartite Check**: Using BFS, we check if the graph can be colored with two colors. If not, it contains an odd cycle.\n- **Component Analysis**: For each connected component, track the number of nodes in each partition of the bipartite graph.\n- **Edge Calculation**: Depending on whether any component has a large enough partition, determine the minimum edges required and the number of valid ways to add those edges to form an odd cycle.\n\nThis approach efficiently checks the graph's properties and calculates the required values using combinatorial logic based on the structure of the graph.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n    \n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u = int(input[idx])\n        idx += 1\n        v = int(input[idx])\n        idx += 1\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    color = [-1] * (n + 1)\n    is_bipartite = True\n    components = []\n    \n    for u in range(1, n + 1):\n        if color[u] == -1:\n            queue = deque()\n            queue.append(u)\n            color[u] = 0\n            cnt0 = 1\n            cnt1 = 0\n            while queue:\n                current = queue.popleft()\n                for neighbor in adj[current]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = color[current] ^ 1\n                        if color[neighbor] == 0:\n                            cnt0 += 1\n                        else:\n                            cnt1 += 1\n                        queue.append(neighbor)\n                    else:\n                        if color[neighbor] == color[current]:\n                            is_bipartite = False\n            components.append((cnt0, cnt1))\n    \n    if not is_bipartite:\n        print(\"0 1\")\n        return\n    \n    has_large = False\n    for a, b in components:\n        if a >= 2 or b >= 2:\n            has_large = True\n            break\n    \n    if has_large:\n        total_ways = 0\n        for a, b in components:\n            total_ways += (a * (a - 1) // 2) + (b * (b - 1) // 2)\n        print(f\"1 {total_ways}\")\n    else:\n        if n < 3:\n            print(\"3 0\")\n        else:\n            ways = n * (n - 1) * (n - 2) // 6\n            print(f\"3 {ways}\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 579,
        "completion_token_count": 888,
        "thoughts_token_count": 8192
    }
}