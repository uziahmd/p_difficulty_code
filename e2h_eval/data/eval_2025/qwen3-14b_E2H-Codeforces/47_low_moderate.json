{
    "start": 1758309511.0990505,
    "end": 1758309568.0419219,
    "start-formatted": "2025-09-20 04:18 KST",
    "end-formatted": "2025-09-20 04:19 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\nOkay, let's try to figure out how to solve this problem. The task is to find the smallest non-negative integer k such that the LCM of (a + k) and (b + k) is minimized. And if there are multiple k's with the same minimal LCM, pick the smallest one.\n\nFirst, let's think about what the LCM depends on. The LCM of two numbers x and y is (x*y)/gcd(x,y). So, to minimize the LCM, we need to maximize the GCD of x and y. Because if the GCD is larger, then the LCM would be smaller for the same product.\n\nBut since x and y are a + k and b + k, let's denote them as x and y. Let me think: x = a + k, y = b + k. Then, y - x = (b + k) - (a + k) = b - a. So the difference between the two numbers is fixed, equal to (b - a) if a < b, or (a - b) otherwise. Wait, but since the problem is symmetric in a and b, maybe we can assume without loss of generality that a ≤ b? Or maybe not. Let's see.\n\nLet me suppose that a and b are given. Let's say that a < b. Then, when we add k, the two numbers are x = a +k and y = b +k. Their difference is (b -a). So, the difference between the two numbers is fixed. Let's call this d = |a - b|. So, the difference between the two numbers is d.\n\nNow, for two numbers x and y with difference d, their GCD must divide d. Because gcd(x, y) divides x and y, so it divides their difference. Therefore, the maximum possible GCD of x and y is the maximum divisor of d that can be achieved by choosing x and y such that they are multiples of that divisor.\n\nSo, the idea is that the optimal k would be such that x and y are multiples of some divisor of d. Let's think about this.\n\nLet me take the example from the first input: a=6, b=10. So d = 4. The difference between the two numbers is 4. So, the maximum possible GCD of x and y would be a divisor of 4. For example, if we can make x and y both multiples of 4, then their GCD would be at least 4, which would minimize the LCM.\n\nIn the example, when k=2, x=8 and y=12. Their GCD is 4, LCM is (8*12)/4 = 24. Which is indeed the minimum.\n\nSo, the approach here is to find the maximum possible GCD of x and y, which is a divisor of d. Then, find the minimal k that allows x and y to be multiples of that GCD.\n\nBut how do we find this?\n\nLet me think. Let's assume that a and b are such that a < b. Then, d = b - a. Let's consider all possible divisors of d. For each divisor g of d, we can check if there exists a k such that (a +k) and (b +k) are both multiples of g. Let's see.\n\nSince (b +k) - (a +k) = d. So, if x = a +k, then y = x +d. For x and y to be multiples of g, then x must be a multiple of g, and y must be a multiple of g. But since y = x +d, and x is a multiple of g, then y must be congruent to d mod g. So for y to be a multiple of g, d must be congruent to 0 mod g. Which is true because g is a divisor of d. So, if x is a multiple of g, then y = x +d is also a multiple of g. Therefore, for any divisor g of d, we can find k such that x and y are multiples of g.\n\nSo, the problem reduces to finding the maximum possible g (divisor of d) such that there exists a k where x = a +k is a multiple of g. Then, the LCM of x and y will be (x * y)/g. Since x and y are multiples of g, and their difference is d, which is a multiple of g. So, x = m * g, y = m * g + d. But since d is a multiple of g, let's say d = t * g. Then y = m * g + t * g = (m + t) * g. So, x and y are multiples of g, and their GCD is at least g. However, the actual GCD could be higher",
    "response": "To solve this problem, we need to find the smallest non-negative integer $ k $ such that the least common multiple (LCM) of $ a + k $ and $ b + k $ is minimized. The key insight is that the LCM of two numbers is minimized when their greatest common divisor (GCD) is maximized. \n\n### Approach\n1. **Difference Calculation**: Calculate the absolute difference $ d $ between $ a $ and $ b $. This difference is crucial because the GCD of $ a + k $ and $ b + k $ must be a divisor of $ d $.\n2. **Divisors of Difference**: Find all divisors of $ d $. These divisors are potential candidates for the maximum GCD of $ a + k $ and $ b + k $.\n3. **Check Each Divisor**: For each divisor $ g $ of $ d $, determine the smallest non-negative $ k $ such that both $ a + k $ and $ b + k $ are multiples of $ g $. The optimal $ k $ will be the one that results in the maximum possible GCD, thus minimizing the LCM.\n\n### Solution Code\n```python\nimport sys\nimport math\n\ndef get_divisors(n):\n    divisors = set()\n    for i in range(1, int(math.isqrt(n)) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sorted(divisors)\n\ndef find_min_k(a, b):\n    d = abs(a - b)\n    if d == 0:\n        return 0\n    divisors = get_divisors(d)\n    min_k = float('inf')\n    for g in divisors:\n        # We want a + k ≡ 0 mod g => k ≡ (-a) mod g\n        # Similarly for b + k ≡ 0 mod g => k ≡ (-b) mod g\n        # Since a + k = x, and x must be divisible by g, then k = m*g - a\n        # But since x must be positive, m >= ceil(a/g) if a is not already divisible by g\n        # However, since (a + k) must be divisible by g, then k = (g - (a % g)) % g\n        # But also, since (b + k) must be divisible by g, we can compute the same for b\n        # So the required k is the same for both, because d is divisible by g\n        # So compute k as (g - (a % g)) % g\n        # But we need to ensure that a + k and b + k are positive\n        # However, since a and b are at least 1, and k is non-negative, adding k will make them positive\n        k = (g - (a % g)) % g\n        if k < min_k:\n            min_k = k\n    return min_k\n\ndef main():\n    input = sys.stdin.read().split()\n    for i in range(0, len(input), 2):\n        a = int(input[i])\n        b = int(input[i+1])\n        print(find_min_k(a, b))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read from standard input and processed in pairs of integers $ a $ and $ b $.\n2. **Divisors Calculation**: For each pair $ (a, b) $, compute the absolute difference $ d $. The divisors of $ d $ are calculated as potential GCD values.\n3. **Finding Optimal $ k $**: For each divisor $ g $ of $ d $, compute the smallest non-negative $ k $ such that both $ a + k $ and $ b + k $ are multiples of $ g $. The smallest $ k $ among these divisors is chosen to ensure the LCM is minimized.\n\nThis approach efficiently narrows down the potential candidates for $ k $ by leveraging the properties of divisors and GCD, ensuring an optimal solution with minimal computational overhead.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\n\ndef get_divisors(n):\n    divisors = set()\n    for i in range(1, int(math.isqrt(n)) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sorted(divisors)\n\ndef find_min_k(a, b):\n    d = abs(a - b)\n    if d == 0:\n        return 0\n    divisors = get_divisors(d)\n    min_k = float('inf')\n    for g in divisors:\n        # We want a + k ≡ 0 mod g => k ≡ (-a) mod g\n        # Similarly for b + k ≡ 0 mod g => k ≡ (-b) mod g\n        # Since a + k = x, and x must be divisible by g, then k = m*g - a\n        # But since x must be positive, m >= ceil(a/g) if a is not already divisible by g\n        # However, since (a + k) must be divisible by g, then k = (g - (a % g)) % g\n        # But also, since (b + k) must be divisible by g, we can compute the same for b\n        # So the required k is the same for both, because d is divisible by g\n        # So compute k as (g - (a % g)) % g\n        # But we need to ensure that a + k and b + k are positive\n        # However, since a and b are at least 1, and k is non-negative, adding k will make them positive\n        k = (g - (a % g)) % g\n        if k < min_k:\n            min_k = k\n    return min_k\n\ndef main():\n    input = sys.stdin.read().split()\n    for i in range(0, len(input), 2):\n        a = int(input[i])\n        b = int(input[i+1])\n        print(find_min_k(a, b))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 403,
        "completion_token_count": 856,
        "thoughts_token_count": 1024
    }
}