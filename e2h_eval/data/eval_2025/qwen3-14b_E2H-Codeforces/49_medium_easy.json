{
    "start": 1758308457.6333163,
    "end": 1758308861.301521,
    "start-formatted": "2025-09-20 04:00 KST",
    "end-formatted": "2025-09-20 04:07 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\nOkay, let's try to figure out how to solve this problem. So the problem is about restoring the number of mushrooms on each lawn based on the GCD and LCM values given for each road between two lawns. \n\nFirst, I need to understand the constraints. For each edge between two lawns u and v, we have a GCD (g) and LCM (l) of their mushroom counts. Let's denote the mushroom counts as a_u and a_v. Then, we know that:\n\ngcd(a_u, a_v) = g\nlcm(a_u, a_v) = l\n\nBut there's a relationship between GCD and LCM: the product of the GCD and LCM of two numbers equals the product of the numbers themselves. So, a_u * a_v = g * l. Also, since the GCD divides both a_u and a_v, each of them must be multiples of g. Let me think: Let's say a_u = g * x, a_v = g * y. Then, the GCD of a_u and a_v is g * gcd(x, y). But since the given GCD is exactly g, this implies that gcd(x, y) must be 1. Also, the LCM of a_u and a_v is g * x * y (since LCM(a_u, a_v) = (a_u * a_v)/GCD(a_u, a_v) = (g^2 x y)/(g * gcd(x,y)) ) = g x y / gcd(x,y). But since we already have that gcd(x,y)=1, then LCM becomes g * x * y. And this is supposed to equal the given LCM l. So, g * x * y = l. Which implies that x * y = l / g. \n\nSo, for each edge, we can derive that x and y are coprime integers whose product is (l/g). Therefore, for each edge, the pair (x, y) must be such that they are coprime and multiply to (l/g). However, since x and y are factors of (l/g), and coprime, this means that x and y must be divisors of (l/g) and their product is exactly that value. \n\nBut how does this help us? Well, for each edge between u and v, we can assign variables to the nodes such that their values are multiples of the GCD. So, for example, if we have an edge between u and v with GCD g and LCM l, then the values of u and v must be g multiplied by some factors x and y which are coprime and x*y = l/g. \n\nNow, the problem is to assign values to each node such that all edges satisfy these conditions. This seems like a graph problem where each node's value is determined by constraints from its connected edges. \n\nSo, perhaps we can model this as a graph where each edge imposes constraints on the values of the nodes. But how to model this? \n\nLet me think about the variables. For each node, we can represent its value as a multiple of the GCD of the edges connected to it. Wait, but each edge may have different GCDs. Hmm, but for any two connected nodes, their values must be multiples of the GCD of that edge. \n\nWait, but for each edge between u and v, the GCD of a_u and a_v is given. So, for example, if there's an edge between u and v with GCD g, then both a_u and a_v must be multiples of g. However, if there are multiple edges connected to u, each with different GCDs, then a_u must be a multiple of all those GCDs. \n\nWait, no. Because if u is connected to v with GCD g1, and to w with GCD g2, then a_u must be a multiple of g1 and also a multiple of g2. Therefore, the value of a_u must be a multiple of the LCM of all the GCDs of edges connected to u. But that's not necessarily true. Wait, no. Because for each individual edge, the GCD of the two nodes is given. So for example, if u is connected to v with GCD g1, then a_u and a_v must be multiples of g1. Similarly, if u is connected to w with GCD g2, then a_u and a_w must be multiples of g2. Therefore, a_u must be a multiple of both g1 and g2, so it must be a multiple of LCM(g1, g2). \n\nBut that seems complicated. How do we handle this? \n\nAlternatively, perhaps we can model this as a graph where each edge defines a relationship between two nodes. Let's consider that for each edge between u and v with GCD g and LCM l, we have that a_u = g * x, a_v = g * y, where x and y are coprime and x * y = l/g. \n\nBut then, for each edge, we have that x and y are coprime. So, for example, if there are multiple edges connected to the same node, how do these x and y relate?\n\nThis seems like a problem that can be modeled with a union-find structure or some kind of constraint propagation. However, since the constraints involve multiplicative relationships, perhaps we can model this with a graph where each node's value is determined relative to another node. \n\nLet me think about building a graph where each node has a value that's a multiple of some base. For example, if we can assign a value to each node in terms of a base value, perhaps using a BFS approach. \n\nSuppose we pick a starting node, assign it a value, and then propagate the constraints through the graph. For example, suppose we have an edge between u and v with GCD g and LCM l. Let's say we assign a value to u. Then, the value of v can be determined based on u's value. \n\nBut how? Let's think again. For the edge between u and v, we have that a_u = g * x, a_v = g * y. And x and y are coprime, and x * y = l/g. So, x and y are divisors of (l/g), and their product is exactly that. \n\nBut since x and y are coprime, each of them must be a divisor of (l/g), and they must be such that one is a factor and the other is the co-factor. So for example, if l/g is 6, possible (x,y) pairs are (1,6), (2,3), (3,2), (6,1). But since x and y are coprime, they can't have any common factors. \n\nBut how do we choose which pair to assign? Because for each edge, there are multiple possibilities. However, once we fix the value of one node, the other node's value is determined. \n\nSo, perhaps we can model this as a graph where each node's value is determined relative to another. For example, if we have a connected component, we can assign a value to one node and then compute the others based on the constraints. \n\nLet me take an example. Suppose we have a connected component with nodes u and v connected by an edge with GCD g and LCM l. Let's say we assign a_u as g * x, then a_v must be g * y where x * y = l/g and gcd(x,y)=1. However, since x and y are coprime, once x is chosen, y is determined as (l/g)/x. But how do we choose x? \n\nWait, but for the edge between u and v, the product of x and y is fixed. So, if we have a_u = g * x, then a_v = g * y = g * (l/g)/x = l/x. But since a_u must be divisible by g, and a_v must be divisible by g. \n\nBut here's the thing: once we assign a value to u, then v's value is fixed. However, if there are multiple edges connected to u, then the assignments must be consistent. \n\nThis seems similar to a bipartition problem, but with multiplicative constraints. \n\nAnother approach: For each connected component, we can assign a base value to one node, and then compute the values of the other nodes based on the edges. However, the problem is that the assignments must be consistent across all edges. \n\nFor example, suppose we have a chain of edges. Let's say u-v with certain constraints, and v-w with other constraints. The assignment for u determines v, which then determines w. But if there's a cycle, we need to ensure that the constraints are satisfied. \n\nSo, the steps could be:\n\n1. Check for each edge whether the given GCD and LCM are compatible. For example, since GCD divides LCM, but also, since LCM must be a multiple of both numbers. Wait, but for the given GCD and LCM, we need to check that the GCD divides the LCM. Because for any two numbers, their GCD divides their LCM. So if the input has a case where the GCD doesn't divide the LCM, then it's impossible. \n\nWait, that's a necessary condition. For example, if the GCD is 2 and the LCM is 3, then since GCD divides LCM, 2 divides 3? No. So that would be invalid. Therefore, for each edge, we must first check that the given GCD divides the given LCM. If not, the answer is immediately NO.\n\nSo that's a preliminary check. For each edge, if l % g != 0, then it's impossible. So we can check that first. \n\nThen, for each edge, we can compute the product of the two numbers (a_u and a_v) as g * l. So, for each edge, the product of the two numbers is fixed. \n\nBut how to proceed? \n\nLet me think of each edge as defining a relation between the two nodes. For example, if we have a_u and a_v, then a_u = g * x, a_v = g * y, with x * y = l/g, and x and y coprime. \n\nBut since x and y are coprime, the product x * y is (l/g), and since they are coprime, each must be a divisor of (l/g). \n\nNow, for the purposes of assigning values, perhaps we can model this as a graph where each node's value is determined relative to another. For example, if we have a tree structure, we can assign a value to the root and compute the rest. However, for cycles, we need to ensure that the constraints are consistent. \n\nLet me think of the problem as building a graph where each edge has a relation between the nodes. Let's imagine that for each edge between u and v, we can express a_u and a_v in terms of each other. For example, once a_u is known, a_v can be computed as (g * l) / a_u. Because a_u * a_v = g * l. \n\nYes! Because a_u * a_v = g * l. So, given that, if we have a_u, then a_v is fixed as (g*l)/a_u. \n\nBut wait, this is only possible if a_u divides (g*l). But since a_u is a multiple of g (because the GCD of a_u and a_v is g), then a_u = g * x, so a_v = (g*l)/(g*x) = l/(x). But since x * y = l/g, then x * y = l/g => y = (l/g)/x. Then, a_v = g * y = g * (l/g)/x = l/x. Which is the same as (g*l)/a_u. \n\nSo yes, for any edge between u and v, once one of the nodes' value is determined, the other's is fixed. \n\nThis suggests that the problem can be modeled as a graph where each edge defines a relationship between two nodes: a_u * a_v = g * l. \n\nTherefore, the problem reduces to assigning values to nodes such that for every edge, the product of the two nodes equals g*l. However, there's an additional constraint that the GCD of the two nodes must be equal to the given g. \n\nWait, but how do we ensure that the GCD is correct? Because even if a_u * a_v = g*l, that doesn't automatically imply that the GCD is g. \n\nFor example, suppose a_u = 2 and a_v = 6. Their product is 12. Suppose the given g is 2 and l is 6. Then, GCD(2,6) is 2, which matches. But if a_u = 3 and a_v =4, their product is 12. Suppose the given g is 1, and l is 12. Then GCD(3,4) is 1. So it works. However, if someone gives a_u = 3 and a_v =4, but the given GCD is 2, then even though the product is 12, which is equal to 2*6, the actual GCD is 1, which is not equal to the given GCD. So the product being equal to g*l is necessary but not sufficient. \n\nAh, right. So the product condition is necessary, but not sufficient. Therefore, we need to ensure that the GCD of the two nodes is exactly the given g. \n\nBut how can we ensure that? Let's think again. \n\nWe have that a_u = g * x, a_v = g * y, where x and y are coprime. Then, the product is g^2 x y = g * l. Which implies that x y = l/g. Also, since x and y are coprime, the GCD of a_u and a_v is g * GCD(x, y) = g * 1 = g. So if we ensure that x and y are coprime, then the GCD will be correct. \n\nBut how do we ensure that x and y are coprime? Well, since x * y = l/g, and x and y are coprime, then x must be a divisor of l/g and y must be l/g divided by x, and x and y must be coprime. \n\nBut how does this fit into our earlier approach of using the product a_u * a_v = g*l? Because if we have that, then x * y = l/g, but we also need that x and y are coprime. \n\nSo, the problem is that even if a_u * a_v = g*l, it's possible that the GCD of a_u and a_v is not equal to the given g. \n\nSo, how to reconcile this? \n\nLet me think. Let me take the example of an edge between u and v with GCD g and LCM l. Suppose we have a_u and a_v such that a_u * a_v = g*l. Then, the GCD of a_u and a_v is g if and only if (a_u/g) and (a_v/g) are coprime. \n\nYes, because:\n\nLet’s denote a_u = g * x, a_v = g * y. Then GCD(a_u, a_v) = g * GCD(x, y). We want this to be equal to g, so GCD(x, y) must be 1. \n\nBut x * y = (a_u * a_v) / (g^2) = (g*l) / (g^2) ) = l/g. \n\nSo, for the product to be correct, we have that x * y = l/g. And for the GCD to be correct, we need that x and y are coprime. \n\nBut how can we ensure that when we assign values to the nodes? \n\nThe problem arises when during the assignment process, the values assigned to the nodes result in x and y not being coprime. \n\nBut how can we avoid that? \n\nPerhaps during the assignment process, when we assign a value to a node, we need to make sure that for each edge, the pair (x, y) is coprime. \n\nBut how to do that? \n\nLet me think of the following approach:\n\nFor each connected component in the graph, we can perform a BFS or DFS traversal. Starting with a node, assign it a value, then propagate the constraints through the edges. \n\nBut what value should we assign to the starting node? \n\nWell, for the starting node, say u, we can assign a value. Then, for each edge connected to u, we can compute the value of the adjacent node. However, the problem is that the value of u must be such that for each edge, when we compute the adjacent node's value, the x and y (the factors divided by the GCD) are coprime. \n\nBut how do we choose the initial value of u? \n\nAlternatively, perhaps for each edge, the value of the nodes must be multiples of the GCD of that edge. So, for example, if we have an edge between u and v with GCD g, then a_u must be a multiple of g, and a_v must be a multiple of g. \n\nBut if the graph is connected, then all nodes in the component must be multiples of the GCDs of all edges connected to them. Which might be complicated. \n\nAlternatively, perhaps we can model the problem as follows: for each edge, the ratio between a_u and a_v must be such that a_u / g and a_v / g are coprime. \n\nBut how to enforce that. \n\nAnother idea: Let's think of each node's value as a multiple of the GCD of the edges connected to it. However, this seems too vague. \n\nWait, but for each edge between u and v, a_u and a_v must be multiples of g. So, the value of a_u must be a multiple of all the GCDs of edges connected to u. \n\nSo, for example, if u is connected to v with GCD g1, and to w with GCD g2, then a_u must be a multiple of LCM(g1, g2). \n\nBut how can we find this LCM? \n\nThis seems complicated. Perhaps we can model this as a system of equations where for each edge, the product of the two nodes is fixed, and then check for consistency. \n\nBut how to proceed? \n\nLet me think of the following approach:\n\nFor each connected component in the graph, we can perform a BFS/DFS, assigning values to nodes. \n\nStart with a node, assign it a value. Then, for each edge, compute the adjacent node's value. But when we assign the value, we need to ensure that the GCD condition is satisfied. \n\nBut how to choose the initial value for the starting node? \n\nAlternatively, perhaps the initial value can be arbitrary, but we need to check that the constraints are satisfied. However, this might not work because if the initial value is not compatible with the constraints, the assignment will fail. \n\nBut how to choose the initial value? \n\nLet me think. For example, take the first edge between u and v. Suppose we assign a_u = g (the GCD). Then, a_v must be l (since a_u * a_v = g*l). But then, we need to check that GCD(g, l) is equal to the given GCD. Wait, but the given GCD is g. Let's see: \n\nIf a_u = g, a_v = l. Then, GCD(g, l) must be equal to the given GCD. \n\nBut since l is the LCM of a_u and a_v, which is LCM(g, l). Wait, but that's not possible. Because LCM(g, l) is l if l is a multiple of g. Which it must be, since the given LCM is l and the GCD is g. \n\nWait, but according to the problem statement, for each edge, the given GCD and LCM must satisfy that GCD divides LCM. So, the given LCM is a multiple of the given GCD. \n\nSo, if a_u = g, then a_v = (g*l)/a_u = l. Now, the GCD of a_u and a_v is GCD(g, l). But since l is a multiple of g, GCD(g, l) = g. Which is exactly the required GCD. \n\nSo this works. \n\nSo, for example, if we assign the initial node's value as the GCD of the edge, then the other node's value is l. And this will satisfy the GCD condition. \n\nBut what if the node is part of multiple edges? \n\nFor example, suppose node u is connected to node v via edge1 (g1, l1), and to node w via edge2 (g2, l2). \n\nIf we assign a_u = g1, then for edge1, a_v = l1. But then, for edge2, a_w = (g2 * l2) / a_u. However, a_u must be a multiple of g2. But a_u is set to g1. So unless g1 is a multiple of g2, this will not be possible. \n\nAh! So this suggests that the initial assignment of a_u as g1 (from edge1) may not be compatible with other edges connected to u. \n\nSo this approach may not work. \n\nTherefore, the problem requires that for all edges connected to a node, the value of that node must be a multiple of the respective GCDs. \n\nWhich implies that the value of the node must be a multiple of the LCM of all the GCDs of the edges connected to it. \n\nBut how can we ensure that during the assignment process? \n\nThis seems complex. \n\nAlternative approach: \n\nFor each edge, the product of the two nodes is fixed as g * l. Therefore, the entire graph can be considered as a system of equations where for each edge (u, v), a_u * a_v = g * l. \n\nThis is a system of equations that must be satisfied. \n\nBut solving such a system is possible if the graph is bipartitioned. For example, in a tree, we can assign a value to the root and compute the rest. However, in a cycle, the product equations must be consistent. \n\nLet me think of the equations. Suppose we have a cycle u1 - u2 - ... - uk - u1. Each consecutive pair has a product equation. \n\nLet me take the product of all equations around the cycle. \n\nFor example, a_u1 * a_u2 = p1 (product of g and l for edge u1-u2)\na_u2 * a_u3 = p2\n...\na_uk * a_u1 = pk\n\nMultiplying all left sides: (a_u1 * a_u2) * (a_u2 * a_u3) * ... * (a_uk * a_u1) ) = product of p_i's. \n\nLeft side: (a_u1^2 * a_u2^2 * ... * a_uk^2) ) = product of p_i's. \n\nTaking square root: product of a_ui's = sqrt(product of p_i's). \n\nBut this must be an integer. However, this is only possible if the product of all p_i's is a perfect square. Otherwise, the system is inconsistent. \n\nBut how does this relate to our problem? Well, for the system to be consistent, the product of all p_i's around each cycle must be a perfect square. \n\nBut this is a necessary condition. However, even if this holds, there may be other constraints. \n\nBut in our case, the product equations are a_u * a_v = p for each edge. \n\nThis system is similar to a graph where each edge enforces that the product of the two nodes is p. \n\nThis type of system can be solved by checking if the graph is bipartite, but with multiplicative factors. \n\nIn such cases, we can model the graph as a bipartition, where each node's value is determined relative to a base. For example, if the graph is bipartitioned into two sets, then the product of the values of the nodes in each set must be compatible. \n\nBut how to model this? \n\nLet me think of the following approach: \n\n- For each connected component, we can assign a value to one node, then propagate the values through the edges. \n\n- For example, start with node u, assign a value x. Then, for each neighbor v connected by an edge with product p, assign a_v = p / x. \n\n- Then, proceed to propagate this to other nodes. \n\n- However, when we reach a node that has already been assigned a value, we need to check that the new value matches the existing one. \n\nThis is similar to a BFS approach. \n\nBut what about the GCD constraints? Because even if the product equations are satisfied, the GCD may not be. \n\nWait, earlier analysis showed that if the product is correct and the GCD of the two nodes is equal to the given GCD, then the product is correct. But how to ensure that the GCD is correct? \n\nBecause the product being correct is necessary but not sufficient. \n\nSo, the problem is that even if we assign values to the nodes such that for each edge, a_u * a_v = g*l, it's possible that the actual GCD of a_u and a_v is not equal to the given g. \n\nBut how can that happen? \n\nLet's take an example. Suppose we have an edge between u and v with g=2 and l=6. Then, the product is 2*6=12. \n\nIf we assign a_u=2 and a_v=6, then GCD(2,6)=2 which is correct. \n\nIf we assign a_u=4 and a_v=3 (since 4*3=12), then GCD(4,3)=1, which is not equal to the given g=2. \n\nSo this violates the condition. \n\nTherefore, the product being correct is not sufficient. \n\nThus, the approach of ensuring the product is correct is not enough. \n\nSo, how can we ensure that the GCD is correct? \n\nThe previous analysis said that for each edge, a_u and a_v must be multiples of g. So, in the example above, if a_u is 4 and a_v is 3, then neither is a multiple of 2 (the given GCD). Wait, no. 4 is a multiple of 2, and 3 is not. So this violates the condition that both a_u and a_v must be multiples of g. \n\nAh! So this is the key point. \n\nIf the product a_u * a_v is equal to g*l, and also both a_u and a_v are multiples of g, then the GCD will be exactly g. \n\nLet me see. \n\nAssume that a_u and a_v are multiples of g. Let's say a_u = g * x, a_v = g * y. Then their product is g² x y = g*l → x y = l/g. \n\nThe GCD of a_u and a_v is g * GCD(x, y). \n\nWe need this to be equal to g, so GCD(x, y) must be 1. \n\nBut x and y are such that x * y = l/g. \n\nSo, the problem reduces to ensuring that x and y are coprime. \n\nBut x and y are determined by the product equations. \n\nWait, if a_u is a multiple of g and a_v is a multiple of g, then x and y are integers, and their product is l/g. However, they may not be coprime. \n\nBut how can we ensure that x and y are coprime? \n\nLet me think. If the product of x and y is l/g, and x and y are coprime, then l/g must be equal to x * y, and since x and y are coprime, l/g must be square-free? No, not necessarily. For example, l/g could be 6, which is 2*3. x=2, y=3 (coprime), or x=6, y=1 (coprime). \n\nBut how can we ensure that x and y are coprime? \n\nThis seems to depend on the values of x and y, which are determined by the product equations. \n\nBut if we ensure that for each edge, a_u and a_v are multiples of g, then x and y are integers, and their product is l/g. But whether they are coprime depends on the values. \n\nBut how can we ensure that during the assignment process? \n\nLet me think again. Suppose during the assignment process, we ensure that for each edge, the two nodes are multiples of the given g. Then, the GCD of the two nodes is g multiplied by the GCD of x and y. \n\nBut how to ensure that GCD(x,y) is 1? \n\nThis seems tricky. \n\nLet me think of the following approach. For each edge, during the assignment process, after determining a_u and a_v, we check that their GCD is equal to the given g. If not, the answer is NO. \n\nBut how can we do this during the BFS/DFS traversal? \n\nLet me think of the following steps:\n\n1. For each edge, check that l % g == 0. If not, output NO.\n\n2. For each connected component in the graph, perform BFS/DFS:\n\n   a. Assign a value to the starting node. How? Well, for the first edge, we can assign a value that is a multiple of the GCD of that edge. For example, assign the starting node's value as g (the GCD of the first edge). Then, the adjacent node's value is l (since a_u * a_v = g*l).\n\n   b. Then, for each subsequent edge, propagate the values, ensuring that the values are multiples of the respective GCDs of the edges. \n\n   c. However, when propagating, we must also check that the GCD of the two nodes equals the given GCD. \n\nBut how to choose the initial value of the starting node? \n\nWait, if we assign the starting node's value as g, then for the first edge, the adjacent node's value is l. Now, for this edge, since a_u is g (which is a multiple of g) and a_v is l (which must be a multiple of g, since l is the LCM of a_u and a_v. Since LCM(a_u, a_v) is l, and a_u is g, then l must be a multiple of g. Which it is, because l % g == 0 as checked earlier. \n\nSo, in this case, both a_u and a_v are multiples of g. \n\nBut then, their GCD is GCD(g, l). But since l is a multiple of g, GCD(g, l) is g. Which is correct. \n\nSo this works. \n\nSo, for the first edge, assigning the starting node's value as g ensures that the GCD is correct. \n\nNow, what about other edges connected to this node? \n\nFor example, suppose the starting node u is connected to v via edge1 (g1, l1), and to w via edge2 (g2, l2). \n\nWe assigned u = g1. Then, for edge1, v = l1. \n\nNow, for edge2, we have that a_u * a_w = g2 * l2. Since a_u is g1, a_w = (g2 * l2) / g1. \n\nBut for this to be valid, a_w must be an integer. Also, since a_w must be a multiple of g2. \n\nSo, (g2 * l2) / g1 must be divisible by g2. Which implies that l2 must be divisible by g1. \n\nBut why would that be the case? \n\nThis depends on the specific values of g1, l2, and g2. \n\nBut this may not hold. For example, suppose g1 is 2, g2 is 3, l2 is 6. Then, a_w = (3 * 6) / 2 = 9. Which is divisible by g2 (3). \n\nYes, 9 is divisible by 3. \n\nAnother example: g1=2, g2=3, l2=5. But earlier we checked that l2 must be divisible by g2, since for the edge between u and w, the LCM is l2 and GCD is g2. Therefore, l2 must be divisible by g2. Which it is, since LCM(a_u, a_w) must be a multiple of both a_u and a_w. \n\nWait, but the LCM for edge2 is given as l2. So for edge2, the LCM of a_u and a_w is l2. But a_u is g1. So l2 must be a multiple of GCD(a_u, a_w) and also a multiple of both a_u and a_w. \n\nBut this is not directly helpful. \n\nBut during the initial step, we have ensured that for each edge, l is divisible by g. \n\nBut in the case of the example above, when we assign a_u as g1, then a_w = (g2 * l2) / g1. \n\nBut for a_w to be a multiple of g2, we need that (g2 * l2) / g1 must be divisible by g2 → l2 / g1 must be an integer. \n\nBut why would that be the case? \n\nIt's not guaranteed. \n\nThis suggests that the initial assignment of a_u as g1 may not be compatible with other edges connected to u. \n\nThus, this approach may fail in such cases. \n\nSo, what can we do? \n\nMaybe the initial assignment needs to be chosen such that for all edges connected to u, the value of a_u is a multiple of the respective GCDs. \n\nBut how to choose this value? \n\nThis seems like a problem of finding a value for u that is a common multiple of all the GCDs of the edges connected to u. \n\nBut how can we find such a value? \n\nFor example, suppose u is connected to v with GCD g1, and to w with GCD g2. Then, the value of u must be a multiple of LCM(g1, g2). \n\nSo, the minimal value for u is LCM(g1, g2). \n\nBut how to choose this value during the BFS/DFS traversal? \n\nThis seems complicated. \n\nAlternatively, perhaps during the BFS/DFS traversal, whenever we assign a value to a node, we must ensure that it is a multiple of all the GCDs of the edges connected to it. \n\nBut how? \n\nLet me think of the following approach:\n\nWhen processing an edge between u and v with GCD g and LCM l, the value of u and v must be multiples of g. \n\nSo, during the BFS/DFS, whenever we assign a value to a node, we must ensure that it is a multiple of the GCD of the edge through which it was assigned. \n\nBut how to ensure this? \n\nFor example, when we assign a value to u, say from the edge between u and v, we set a_u to be a multiple of g. \n\nBut how to choose this multiple? \n\nLet me think of the following: \n\nFor each edge, the product of the two nodes is g*l. So, a_u * a_v = g*l. \n\nBut since a_u and a_v must be multiples of g, let me write a_u = g * x and a_v = g * y. \n\nThen, x * y = l/g. \n\nAlso, since the GCD of x and y must be 1. \n\nBut how to ensure that? \n\nIf x and y are coprime, then their product is l/g. So, x and y are coprime divisors of l/g. \n\nBut how to choose x and y? \n\nThis seems to require that l/g is a product of two coprime numbers. But since l/g is fixed, it's always possible to choose x and y as 1 and l/g, or other coprime pairs. \n\nBut how to choose which pair to use? \n\nPerhaps for the purposes of the assignment, we can choose x=1 and y=l/g. This way, x and y are coprime. \n\nBut then, a_u = g * x = g, and a_v = g * y = g * (l/g) = l. \n\nThis choice ensures that x and y are coprime, since x=1 and y is any number. \n\nSo, this seems to be a valid choice. \n\nSo, perhaps during the BFS/DFS traversal, whenever we encounter an edge, we assign the current node's value as g (the GCD of the edge), and the adjacent node's value as l (the LCM). \n\nBut then, what if this leads to inconsistencies in other edges? \n\nLet me try with an example. \n\nExample: \n\nConsider two edges:\n\nEdge1: u-v with g=2, l=6.\n\nEdge2: u-w with g=2, l=8.\n\nSo, for Edge1: a_u * a_v = 2*6=12.\n\nFor Edge2: a_u * a_w = 2*8=16.\n\nLet's assign a_u = 2 (from Edge1). Then a_v = 6, and a_w = 16 / 2 = 8. \n\nNow, check Edge2: a_u=2, a_w=8. GCD(2,8)=2, which matches the given GCD. LCM is 8, which matches. \n\nSo this works. \n\nAnother example:\n\nEdge1: u-v with g=2, l=6 (so a_u=2, a_v=6).\n\nEdge2: v-w with g=3, l=6. \n\nSo, for Edge2, a_v * a_w = 3*6=18. \n\nSince a_v is 6, then a_w = 18",
    "response": "To solve this problem, we need to determine the number of mushrooms on each lawn based on given GCD and LCM values for each road connecting two lawns. The solution involves checking for consistency in the constraints provided by these values and using a graph traversal approach to assign mushroom counts.\n\n### Approach\n1. **Check Validity of Input**: For each edge, ensure that the LCM is divisible by the GCD. If not, the configuration is invalid.\n2. **Graph Traversal**: Use BFS (Breadth-First Search) to traverse the graph starting from each unvisited node. During traversal, assign values to nodes such that the product of mushroom counts on connected nodes matches the product of their GCD and LCM.\n3. **Consistency Check**: Ensure that the assigned values satisfy the GCD and LCM constraints for each edge. If any inconsistency is found during traversal, the configuration is invalid.\n\n### Solution Code\n```python\nimport sys\nimport math\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    m = int(input[ptr])\n    ptr += 1\n\n    edges = []\n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        u = int(input[ptr]) - 1\n        ptr += 1\n        v = int(input[ptr]) - 1\n        ptr += 1\n        g = int(input[ptr])\n        ptr += 1\n        l = int(input[ptr])\n        ptr += 1\n        if l % g != 0:\n            print(\"NO\")\n            return\n        edges.append((u, v, g, l))\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l))\n\n    result = [0] * n\n    visited = [False] * n\n\n    for start in range(n):\n        if not visited[start]:\n            queue = deque()\n            queue.append(start)\n            visited[start] = True\n            result[start] = 1  # Placeholder, will be adjusted later\n            valid = True\n            while queue:\n                u = queue.popleft()\n                for (v, g, l) in adj[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        # Compute the value for v based on u's current value\n                        # a_u * a_v = g*l\n                        # a_v = (g*l) / a_u\n                        # But a_u must be a multiple of g\n                        # So, initially set a_u as g, then a_v is l\n                        # However, since we might have already assigned a_u, we need to check\n                        # Here, we use the current value of a_u to compute a_v\n                        if result[u] == 0:\n                            # This should not happen if we are processing edges properly\n                            valid = False\n                            break\n                        product = g * l\n                        if product % result[u] != 0:\n                            valid = False\n                            break\n                        a_v = product // result[u]\n                        result[v] = a_v\n                        queue.append(v)\n                    else:\n                        # Check if the current values satisfy the condition\n                        product = g * l\n                        if result[u] * result[v] != product:\n                            valid = False\n                            break\n                if not valid:\n                    break\n            if not valid:\n                print(\"NO\")\n                return\n    # Now verify all edges\n    for u, v, g, l in edges:\n        a_u = result[u]\n        a_v = result[v]\n        if a_u * a_v != g * l:\n            print(\"NO\")\n            return\n        current_gcd = math.gcd(a_u, a_v)\n        if current_gcd != g:\n            print(\"NO\")\n            return\n    print(\"YES\")\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Input Reading and Initial Checks**: The input is read and stored, with initial checks ensuring that each edge's LCM is divisible by its GCD.\n2. **Graph Traversal with BFS**: Each node is processed using BFS. Starting from an unvisited node, values are assigned to nodes such that the product of values on connected nodes matches the product of their GCD and LCM.\n3. **Validation**: After assigning values, all edges are checked to ensure they meet both the product and GCD constraints. If any inconsistency is found, the answer is \"NO\"; otherwise, the assigned values are printed.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    m = int(input[ptr])\n    ptr += 1\n\n    edges = []\n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        u = int(input[ptr]) - 1\n        ptr += 1\n        v = int(input[ptr]) - 1\n        ptr += 1\n        g = int(input[ptr])\n        ptr += 1\n        l = int(input[ptr])\n        ptr += 1\n        if l % g != 0:\n            print(\"NO\")\n            return\n        edges.append((u, v, g, l))\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l))\n\n    result = [0] * n\n    visited = [False] * n\n\n    for start in range(n):\n        if not visited[start]:\n            queue = deque()\n            queue.append(start)\n            visited[start] = True\n            result[start] = 1  # Placeholder, will be adjusted later\n            valid = True\n            while queue:\n                u = queue.popleft()\n                for (v, g, l) in adj[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        # Compute the value for v based on u's current value\n                        # a_u * a_v = g*l\n                        # a_v = (g*l) / a_u\n                        # But a_u must be a multiple of g\n                        # So, initially set a_u as g, then a_v is l\n                        # However, since we might have already assigned a_u, we need to check\n                        # Here, we use the current value of a_u to compute a_v\n                        if result[u] == 0:\n                            # This should not happen if we are processing edges properly\n                            valid = False\n                            break\n                        product = g * l\n                        if product % result[u] != 0:\n                            valid = False\n                            break\n                        a_v = product // result[u]\n                        result[v] = a_v\n                        queue.append(v)\n                    else:\n                        # Check if the current values satisfy the condition\n                        product = g * l\n                        if result[u] * result[v] != product:\n                            valid = False\n                            break\n                if not valid:\n                    break\n            if not valid:\n                print(\"NO\")\n                return\n    # Now verify all edges\n    for u, v, g, l in edges:\n        a_u = result[u]\n        a_v = result[v]\n        if a_u * a_v != g * l:\n            print(\"NO\")\n            return\n        current_gcd = math.gcd(a_u, a_v)\n        if current_gcd != g:\n            print(\"NO\")\n            return\n    print(\"YES\")\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 558,
        "completion_token_count": 977,
        "thoughts_token_count": 8192
    }
}