{
    "start": 1758313732.3907356,
    "end": 1758313777.1555371,
    "start-formatted": "2025-09-20 05:28 KST",
    "end-formatted": "2025-09-20 05:29 KST",
    "gpu": 2,
    "pid": 9,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Selling Souvenirs\n\nAfter several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.This morning, as usual, Petya will come to the market. Petya has n different souvenirs to sell; ith souvenir is characterised by its weight wi and cost ci. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than m, and total cost is maximum possible.Help Petya to determine maximum possible total cost.\n\n## Input\nThe first line contains two integers n and m (1 ≤ n ≤ 100000, 1 ≤ m ≤ 300000) — the number of Petya's souvenirs and total weight that he can carry to the market.Then n lines follow. ith line contains two integers wi and ci (1 ≤ wi ≤ 3, 1 ≤ ci ≤ 109) — the weight and the cost of ith souvenir.\n\n## Output\nPrint one number — maximum possible total cost of souvenirs that Petya can carry to the market.\n\n## Example\n### Input\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\n### Output\n['0', '3', '10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\nOkay, let's see. The problem is about selecting souvenirs with maximum total cost without exceeding the weight limit. The constraints are that n can be up to 1e5 and m up to 3e5. Each souvenir's weight is between 1 and 3. Hmm, so the weights are small. That probably suggests a dynamic programming approach optimized for these small weights.\n\nWait, the standard knapsack problem is O(nm), which for n=1e5 and m=3e5 would be way too slow. So we need a smarter approach here. Since the weights are limited to 1, 2, or 3, maybe we can group items by their weight and then find an optimal way to select them.\n\nLet me think. For each weight category (1, 2, 3), we can sort the items in descending order of cost. Then, for each weight, we can precompute the prefix sums of the costs. This way, for any number of items taken from that weight group, we can quickly calculate the total cost.\n\nBut how do we combine these groups optimally? Let's say we have a certain number of weight 1 items, weight 2 items, and weight 3 items. The challenge is to choose how many of each to take such that the total weight is <= m and the total cost is maximized.\n\nLet me break it down. For example, suppose we have a total weight capacity of m. Let's consider all possible numbers of weight 3 items. For each possible count of weight 3 items, we can compute the remaining weight and then decide how to best fill that with weight 1 and 2 items.\n\nBut even that might not be efficient if done naively. However, since the maximum possible number of weight 3 items is m//3, which for m up to 3e5 is around 1e5, that might be manageable. But combining that with processing the other weights could be tricky.\n\nAlternatively, perhaps we can handle each weight group separately and find the optimal combination.\n\nAnother idea: since the weight is small, for each weight class, we can process them in a way that allows us to compute the best possible selection for each possible weight.\n\nLet me think of the approach step by step:\n\n1. Separate the items into three groups based on their weight (w=1, w=2, w=3). For each group, sort them in descending order of cost. Then compute prefix sums for each group. For example, for weight 1 items, prefix_sum_1[i] is the sum of the first i items. Similarly for weight 2 and 3.\n\nOnce we have these prefix sums, for any number of items taken from each group, we can compute the total cost quickly.\n\nNow, the problem becomes: select a number of items from each group (say, a from group 1, b from group 2, c from group 3) such that a*1 + b*2 + c*3 <= m, and the total cost is maximized.\n\nBut how to efficiently compute this?\n\nThe key is that for each possible count of group 3 items (c), we can determine the maximum possible a and b that can fit in the remaining weight. Similarly, for each possible count of group 2 items, but maybe that's not as efficient.\n\nAlternatively, since group 3's weight is larger, perhaps we can iterate over the possible number of group 3 items, and for each, compute the best combination of group 1 and group 2 items.\n\nBut for each possible c (number of group 3 items), the maximum possible is up to floor(m / 3). Let's say that's up to 1e5 steps. For each such c, the remaining weight is rem = m - 3*c. Then, we need to find the best way to fill rem with group 1 and 2 items.\n\nNow, how to compute the best combination of group 1 and 2 items for a given rem?\n\nFor the group 1 and 2 items, we can think of this as a variation of the knapsack problem where the weight is 1 and 2, and we want to maximize the value. But since the weights are small, perhaps we can find an optimal way for each possible rem.\n\nLet me think: For a given rem, the maximum number of group 2 items is up to rem//2, and the rest can be filled with group 1 items. However, since group 1 items have higher value per unit (if they are more valuable than group 2 items), but that depends on the actual items.\n\nBut since the group 1 and group 2 items are sorted in descending order, perhaps we can precompute the best possible selection for all possible weights up to m.\n\nWait, but for each possible rem, which can be up to m, which is 3e5. How can we compute for each possible",
    "response": "To solve this problem efficiently, we use a dynamic programming approach that leverages the small weight constraints (1, 2, or 3). Here's the plan:\n\n1. **Group and Sort**: Separate items by their weights (1, 2, 3) and sort each group in descending order of cost.\n2. **Prefix Sums**: Precompute prefix sums for each group to quickly calculate the total value of the top `k` items in each group.\n3. **Iterate Over Weight 3 Items**: For each possible number of weight 3 items, compute how many weight 1 and 2 items can be included in the remaining capacity using an optimized approach.\n\n---\n\n### Key Steps:\n\n- **Grouping and Sorting**:\n  - Group all items with weight 1, 2, and 3 separately.\n  - Sort each group in descending order of cost to prioritize more valuable items.\n\n- **Prefix Sums**:\n  - Compute prefix sums for each group to get the total cost for taking the first `i` items from each group.\n\n- **Combining Groups**:\n  - Iterate through possible numbers of weight 3 items.\n  - For each number of weight 3 items, determine the remaining capacity and find the optimal combination of weight 1 and 2 items using a two-pointer technique.\n\n---\n\n### Time Complexity:\n- Sorting: $ O(n \\log n) $\n- Prefix Sum Computation: $ O(n) $\n- Iterating over weight 3 items and combining with weight 1 and 2 items: $ O(m) $\n\nThis ensures the solution is efficient even for large values of $n$ and $m$.\n\n---\n\n### Python Code:\n\n```python\nimport sys\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    m = int(data[idx + 1])\n    idx += 2\n    \n    w1 = []\n    w2 = []\n    w3 = []\n    \n    for _ in range(n):\n        wi = int(data[idx])\n        ci = int(data[idx + 1])\n        idx += 2\n        if wi == 1:\n            w1.append(ci)\n        elif wi == 2:\n            w2.append(ci)\n        else:\n            w3.append(ci)\n    \n    # Sort each group in descending order\n    w1.sort(reverse=True)\n    w2.sort(reverse=True)\n    w3.sort(reverse=True)\n    \n    # Compute prefix sums\n    prefix1 = [0]\n    for c in w1:\n        prefix1.append(prefix1[-1] + c)\n    \n    prefix2 = [0]\n    for c in w2:\n        prefix2.append(prefix2[-1] + c)\n    \n    prefix3 = [0]\n    for c in w3:\n        prefix3.append(prefix3[-1] + c)\n    \n    max_total = 0\n    len3 = len(prefix3) - 1\n    \n    # Try all possible counts of weight 3 items\n    for c3 in range(len3 + 1):\n        weight_used = c3 * 3\n        if weight_used > m:\n            continue\n        rem = m - weight_used\n        \n        # Now, try to fill rem using w1 and w2\n        i = 0\n        j = 0\n        best = 0\n        while i <= len(w1) and j <= len(w2):\n            weight = i + 2 * j\n            if weight <= rem:\n                best = max(best, prefix1[i] + prefix2[j])\n                i += 1\n            else:\n                j += 1\n        max_total = max(max_total, prefix3[c3] + best)\n    \n    print(max_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n---\n\n### Explanation:\n- The algorithm groups and sorts items based on weight.\n- It then uses prefix sums to quickly calculate the value of selecting the top `k` items from each group.\n- For each possible count of weight 3 items, it calculates the best way to fill the remaining capacity using weight 1 and 2 items via a two-pointer technique, ensuring optimal performance.\n\nThis approach ensures that the solution is both time-efficient and handles all edge cases effectively.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    n = int(data[idx])\n    m = int(data[idx + 1])\n    idx += 2\n    \n    w1 = []\n    w2 = []\n    w3 = []\n    \n    for _ in range(n):\n        wi = int(data[idx])\n        ci = int(data[idx + 1])\n        idx += 2\n        if wi == 1:\n            w1.append(ci)\n        elif wi == 2:\n            w2.append(ci)\n        else:\n            w3.append(ci)\n    \n    # Sort each group in descending order\n    w1.sort(reverse=True)\n    w2.sort(reverse=True)\n    w3.sort(reverse=True)\n    \n    # Compute prefix sums\n    prefix1 = [0]\n    for c in w1:\n        prefix1.append(prefix1[-1] + c)\n    \n    prefix2 = [0]\n    for c in w2:\n        prefix2.append(prefix2[-1] + c)\n    \n    prefix3 = [0]\n    for c in w3:\n        prefix3.append(prefix3[-1] + c)\n    \n    max_total = 0\n    len3 = len(prefix3) - 1\n    \n    # Try all possible counts of weight 3 items\n    for c3 in range(len3 + 1):\n        weight_used = c3 * 3\n        if weight_used > m:\n            continue\n        rem = m - weight_used\n        \n        # Now, try to fill rem using w1 and w2\n        i = 0\n        j = 0\n        best = 0\n        while i <= len(w1) and j <= len(w2):\n            weight = i + 2 * j\n            if weight <= rem:\n                best = max(best, prefix1[i] + prefix2[j])\n                i += 1\n            else:\n                j += 1\n        max_total = max(max_total, prefix3[c3] + best)\n    \n    print(max_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 474,
        "completion_token_count": 898,
        "thoughts_token_count": 1024
    }
}