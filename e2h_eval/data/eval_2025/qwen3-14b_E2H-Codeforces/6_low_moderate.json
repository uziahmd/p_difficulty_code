{
    "start": 1758008325.502422,
    "end": 1758008504.348385,
    "start-formatted": "2025-09-16 16:38 KST",
    "end-formatted": "2025-09-16 16:41 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\nOkay, let's see. I need to solve this programming problem. Let's read the problem carefully.\n\nSo, the problem is about finding two non-overlapping vouchers such that their total duration is exactly x, and their combined cost is minimized. If there's no such pair, output -1.\n\nFirst, let's understand the problem. Each voucher has a start day li, end day ri, and cost. The duration is ri - li + 1. We need two vouchers i and j where their durations add up to x. Also, they must not overlap. That means either the first ends before the second starts, or the second ends before the first starts.\n\nThe challenge is to find the minimal sum of costs for such pairs.\n\nConstraints: n can be up to 2e5, which is 200,000. So any O(n^2) approach is definitely out of the question. Need something efficient, like O(n log n) or O(n).\n\nLet me think about how to approach this.\n\nFirst, for each voucher, we can compute its duration. Let's say for a voucher i, duration is d_i. Then, for each voucher, we need to find another voucher j such that d_i + d_j = x, and the vouchers don't overlap. And among all such pairs, find the minimum cost.\n\nBut how to efficiently find for each voucher, possible other vouchers that have duration (x - d_i), and are non-overlapping.\n\nSo here's an idea: group vouchers by their duration. For example, create a dictionary where the key is the duration, and the value is a list of vouchers with that duration. Then, for each voucher with duration d, check if there exists vouchers with duration (x - d). Then, for each such voucher, check if they are non-overlapping.\n\nBut even then, for each voucher, checking all vouchers of duration (x - d) could be O(n) in the worst case, leading to O(n^2) time again. Not feasible.\n\nAlternative approach: for each duration d, pre-process the vouchers so that for a given d, we can quickly find the minimal cost of a voucher that ends before a certain date, or starts after a certain date. Because when we have a voucher with duration d, and another with duration (x - d), we need to find one that ends before the start of the first voucher, or starts after the end of the first voucher.\n\nWait, but how?\n\nLet me think. Suppose I have a voucher A with duration d, and I want to find a voucher B with duration (x - d) that does not overlap with A. So, voucher B can be either:\n\n- Ends before A's start (i.e., B.r < A.l)\nOR\n- Starts after A's end (i.e., B.l > A.r)\n\nSo for each voucher A, I need to find the minimal cost of vouchers B of duration (x - d) that satisfy either of these conditions.\n\nBut how do I find that efficiently?\n\nFor each duration, we can pre-process the vouchers in such a way that for a given query (like, find the minimal cost voucher with duration k that ends before a certain value, or starts after a certain value), we can answer quickly.\n\nFor example, for all vouchers with duration k, we can sort them by their end date. Then, for a given A's l, we can find the minimal cost among vouchers with duration k where r < A.l. Similarly, sort them by their start date, and find the minimal cost where l > A.r.\n\nBut how to do that?\n\nLet me think about the steps:\n\n1. Preprocess all vouchers, group them by their duration. For each duration d, we have a list of vouchers. For each such list, we can sort the vouchers by their end date (ri) and also by their start date (li). Also, for each sorted list, we can precompute prefix minima or suffix minima.\n\nWait, for example, for vouchers with duration k, sorted by their end date. Then, if we want to find the minimal cost voucher that ends before a certain value (say, L), we can perform a binary search to find the largest end date less than L. Then, among all vouchers up to that index, the minimal cost can be found using a prefix min array.\n\nSimilarly, for vouchers with duration k sorted by their start date, if we want to find the minimal cost voucher that starts after a certain value (say, R), we can binary search for the first start date greater than R, and then look for the minimal cost in the suffix.\n\nSo the plan is:\n\nFor each duration d, we have:\n\n- A list sorted by ri (end date), along with a prefix min array of cost. This allows us to find the minimal cost of a voucher with duration d that ends before a certain date.\n\n- A list sorted by li (start date), along with a",
    "response": "\n\nTo solve this problem efficiently, we need to find two non-overlapping vouchers such that their combined duration equals exactly `x` and their total cost is minimized. The solution involves preprocessing vouchers by their duration and using binary search to quickly find the optimal non-overlapping vouchers.\n\n### Approach\n1. **Group Vouchers by Duration**: First, group all vouchers by their duration. This allows us to efficiently look up vouchers of a specific duration.\n2. **Sort and Preprocess**: For each duration, sort the vouchers by their end date and start date. Additionally, create prefix minimum arrays for the sorted end dates and suffix minimum arrays for the sorted start dates. This helps in quickly finding the minimum cost vouchers that meet specific criteria.\n3. **Check for Valid Pairs**: For each voucher, check if there exists another voucher with the complementary duration (i.e., `x - duration`). Use binary search on the preprocessed lists to find non-overlapping vouchers and compute the minimum cost.\n\n### Solution Code\n```python\nimport sys\nimport bisect\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    x = int(input[ptr])\n    ptr += 1\n\n    vouchers_by_duration = defaultdict(list)\n\n    for _ in range(n):\n        l = int(input[ptr])\n        ptr += 1\n        r = int(input[ptr])\n        ptr += 1\n        cost = int(input[ptr])\n        ptr += 1\n        duration = r - l + 1\n        vouchers_by_duration[duration].append((l, r, cost))\n\n    # Preprocess each duration's vouchers\n    # For each duration d, we have:\n    # sorted_by_end: list of (r, l, cost), sorted by r\n    # prefix_min: list of min costs up to index i\n    # sorted_by_start: list of (l, r, cost), sorted by l\n    # suffix_min: list of min costs from index i onwards\n\n    duration_data = {}\n\n    for d in vouchers_by_duration:\n        v_list = vouchers_by_duration[d]\n        # Sort by end date (r)\n        sorted_by_end = sorted(v_list, key=lambda x: x[1])\n        prefix_min = []\n        min_so_far = float('inf')\n        for v in sorted_by_end:\n            min_so_far = min(min_so_far, v[2])\n            prefix_min.append(min_so_far)\n        # Sort by start date (l)\n        sorted_by_start = sorted(v_list, key=lambda x: x[0])\n        suffix_min = [0] * len(sorted_by_start)\n        min_so_far = float('inf')\n        for i in reversed(range(len(sorted_by_start))):\n            min_so_far = min(min_so_far, sorted_by_start[i][2])\n            suffix_min[i] = min_so_far\n        duration_data[d] = (sorted_by_end, prefix_min, sorted_by_start, suffix_min)\n\n    min_total = float('inf')\n\n    # Iterate through each voucher\n    for l, r, cost in vouchers_by_duration.values():\n        for voucher in voucher:\n            duration = r - l + 1\n            needed = x - duration\n            if needed < 1:\n                continue\n            if needed not in duration_data:\n                continue\n            # Get the data for needed duration\n            sorted_by_end, prefix_min, sorted_by_start, suffix_min = duration_data[needed]\n            # Check for vouchers ending before l\n            # Binary search in sorted_by_end for the largest r_i < l\n            end_dates = [v[1] for v in sorted_by_end]\n            idx = bisect.bisect_left(end_dates, l) - 1\n            if idx >= 0:\n                min_cost1 = prefix_min[idx]\n                min_total = min(min_total, min_cost1 + cost)\n            # Check for vouchers starting after r\n            start_dates = [v[0] for v in sorted_by_start]\n            idx = bisect.bisect_right(start_dates, r)\n            if idx < len(start_dates):\n                min_cost2 = suffix_min[idx]\n                min_total = min(min_total, min_cost2 + cost)\n\n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Grouping by Duration**: Vouchers are grouped by their duration to quickly access those with specific durations.\n- **Sorting and Preprocessing**: For each duration, vouchers are sorted by their end and start dates. Prefix and suffix minimum arrays are created to allow quick lookup of minimum costs.\n- **Binary Search**: For each voucher, we use binary search to find non-overlapping vouchers with the required complementary duration, ensuring efficient query processing.\n\nThis approach ensures that we efficiently check all possible valid pairs of vouchers while keeping the complexity manageable, making it feasible even for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport bisect\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    x = int(input[ptr])\n    ptr += 1\n\n    vouchers_by_duration = defaultdict(list)\n\n    for _ in range(n):\n        l = int(input[ptr])\n        ptr += 1\n        r = int(input[ptr])\n        ptr += 1\n        cost = int(input[ptr])\n        ptr += 1\n        duration = r - l + 1\n        vouchers_by_duration[duration].append((l, r, cost))\n\n    # Preprocess each duration's vouchers\n    # For each duration d, we have:\n    # sorted_by_end: list of (r, l, cost), sorted by r\n    # prefix_min: list of min costs up to index i\n    # sorted_by_start: list of (l, r, cost), sorted by l\n    # suffix_min: list of min costs from index i onwards\n\n    duration_data = {}\n\n    for d in vouchers_by_duration:\n        v_list = vouchers_by_duration[d]\n        # Sort by end date (r)\n        sorted_by_end = sorted(v_list, key=lambda x: x[1])\n        prefix_min = []\n        min_so_far = float('inf')\n        for v in sorted_by_end:\n            min_so_far = min(min_so_far, v[2])\n            prefix_min.append(min_so_far)\n        # Sort by start date (l)\n        sorted_by_start = sorted(v_list, key=lambda x: x[0])\n        suffix_min = [0] * len(sorted_by_start)\n        min_so_far = float('inf')\n        for i in reversed(range(len(sorted_by_start))):\n            min_so_far = min(min_so_far, sorted_by_start[i][2])\n            suffix_min[i] = min_so_far\n        duration_data[d] = (sorted_by_end, prefix_min, sorted_by_start, suffix_min)\n\n    min_total = float('inf')\n\n    # Iterate through each voucher\n    for l, r, cost in vouchers_by_duration.values():\n        for voucher in voucher:\n            duration = r - l + 1\n            needed = x - duration\n            if needed < 1:\n                continue\n            if needed not in duration_data:\n                continue\n            # Get the data for needed duration\n            sorted_by_end, prefix_min, sorted_by_start, suffix_min = duration_data[needed]\n            # Check for vouchers ending before l\n            # Binary search in sorted_by_end for the largest r_i < l\n            end_dates = [v[1] for v in sorted_by_end]\n            idx = bisect.bisect_left(end_dates, l) - 1\n            if idx >= 0:\n                min_cost1 = prefix_min[idx]\n                min_total = min(min_total, min_cost1 + cost)\n            # Check for vouchers starting after r\n            start_dates = [v[0] for v in sorted_by_start]\n            idx = bisect.bisect_right(start_dates, r)\n            if idx < len(start_dates):\n                min_cost2 = suffix_min[idx]\n                min_total = min(min_total, min_cost2 + cost)\n\n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 740,
        "completion_token_count": 1046,
        "thoughts_token_count": 1023
    }
}