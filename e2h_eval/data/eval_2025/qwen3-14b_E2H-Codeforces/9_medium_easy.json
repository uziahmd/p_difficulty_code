{
    "start": 1758345072.5024254,
    "end": 1758345224.9416502,
    "start-formatted": "2025-09-20 14:11 KST",
    "end-formatted": "2025-09-20 14:13 KST",
    "gpu": 2,
    "pid": 9,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Selling Souvenirs\n\nAfter several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.This morning, as usual, Petya will come to the market. Petya has n different souvenirs to sell; ith souvenir is characterised by its weight wi and cost ci. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than m, and total cost is maximum possible.Help Petya to determine maximum possible total cost.\n\n## Input\nThe first line contains two integers n and m (1 ≤ n ≤ 100000, 1 ≤ m ≤ 300000) — the number of Petya's souvenirs and total weight that he can carry to the market.Then n lines follow. ith line contains two integers wi and ci (1 ≤ wi ≤ 3, 1 ≤ ci ≤ 109) — the weight and the cost of ith souvenir.\n\n## Output\nPrint one number — maximum possible total cost of souvenirs that Petya can carry to the market.\n\n## Example\n### Input\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\n### Output\n['0', '3', '10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\nOkay, let's see. I need to solve this problem where Petya wants to choose souvenirs with maximum total cost without exceeding a weight limit m. The constraints are that n can be up to 1e5 and m up to 3e5. Also, each souvenir's weight is between 1 and 3. Hmm, right. So the weights are small. That probably suggests some approach that takes advantage of that.\n\nThe classic knapsack problem, but with n up to 1e5 and m up to 3e5. A standard dynamic programming approach for 0-1 knapsack would be O(nm), which here would be 3e11 operations. That's way too slow. So we need a smarter approach.\n\nSince the weights are limited to 1, 2, 3, maybe we can group items by their weight and then find an optimal way to select them. For example, for each weight category (1, 2, 3), sort the items in descending order of cost. Then, for each weight category, we can precompute the prefix sums so that we can quickly determine the maximum cost for taking k items of that weight.\n\nLet me think. Suppose we have all items of weight 1 sorted by cost. Then for any number of items taken from weight 1, say x, the total cost is sum of the top x items. Same for weight 2 and 3.\n\nSo the idea is to process each weight group separately, and then find the best combination of taking some number of items from each group such that the total weight doesn't exceed m.\n\nBut how to combine them efficiently?\n\nLet me consider that the total weight is w1*count1 + w2*count2 + w3*count3 ≤ m. But since the weights are 1,2,3, maybe we can iterate over the possible number of items taken from one group, and compute the remaining capacity for the others.\n\nAlternatively, perhaps we can use a two-step approach. Let's say we first handle weight 1 and 2, and then handle weight 3. Or maybe find for each possible weight of the third group, the best combination of the other two.\n\nAlternatively, since the weight is small, maybe we can do the following:\n\nFor each weight group (1, 2, 3), sort their items in descending order of cost. Then, for each group, create a prefix sum array. For example, for weight 1, prefix_sum_1[i] is the sum of the first i items. Similarly for weight 2 and 3.\n\nOnce we have these prefix sums, the problem becomes selecting a certain number of items from each group (say, a from weight 1, b from weight 2, c from weight 3) such that a*1 + b*2 + c*3 ≤ m, and the total cost is maximized.\n\nBut even with this, how do we compute this efficiently?\n\nLet's think about the possible combinations. Since the weight is up to 3, perhaps we can iterate over the number of items taken from weight 3, then for the remaining capacity, compute the best combination of weight 1 and 2.\n\nAlternatively, for each possible number of weight 3 items (c), we can calculate how much weight is left, and then solve the problem for weight 1 and 2 with that remaining capacity. But how?\n\nLet me think. For example, if we have a maximum capacity of m. For each possible c (number of weight 3 items), we can take up to min(k, m//3) items, where k is the number of available items of weight 3. For each such c, the remaining weight is m - 3*c. Then, the problem reduces to solving the same problem for weight 1 and 2 with capacity rem = m - 3*c, and then take the maximum over all possible c.\n\nSo the key is to find for each possible rem, the maximum value that can be achieved with weight 1 and 2 items, given that rem is the capacity.\n\nBut how to compute that efficiently?\n\nFor the weight 1 and 2 case: Let's say we have a capacity of rem. How can we select a number of weight 1 items (a) and weight 2 items (b) such that a + 2b ≤ rem. And the total cost is sum_1[a] + sum_2[b], which is the sum of the first a items of weight 1 and the first b items of weight 2.\n\nBut how to compute the maximum for this?\n\nLet me think. For each possible b (number of weight 2 items), we can take up to min( (rem - 2*b) , len(weight 1 items) ) items of weight 1. So for each possible b, the maximum a is (rem - 2*b). Then, the total cost is sum_2[b] + sum_1[ (rem - 2*b) ].\n\nBut since rem can be up to m (which is 3e5), and for each c (for the weight 3 items), rem can be up to 3e5, and for each rem, the possible b is up to rem//2, which is up to 1.5e5. So if we loop through all possible b for each rem, that would be O(rem) per rem, which could be expensive.\n\nBut perhaps there's a way to precompute for all possible capacities up to m, the maximum value for weight 1 and 2.\n\nWait, but what's the maximum possible capacity for the weight 1 and 2 part? It's m. Which is up to 3e5. So if we can precompute for all capacities up to m, the maximum value for weight 1 and 2, then for each possible c (number of weight 3 items), we can take the precomputed value for rem = m - 3*c, and add the sum_3[c].\n\nBut how to compute that precomputed array for weight 1 and 2?\n\nLet me think. Let's suppose that we have for weight 1 and 2 items, sorted by cost. Let's say we have sorted the weight 1 items in descending order, and the same for weight 2.\n\nThen, for any capacity x, the maximum value is the maximum over all possible b (number of weight 2 items taken) such that 2*b <= x, and then take as many weight 1 items as possible (x - 2*b) items.\n\nBut for each x, how do we find the best b?\n\nAlternatively, for each x, the optimal choice of b is such that 2b is as large as possible, but not exceeding x, and the sum of weight 2's first b items plus the sum of weight 1's first (x - 2b) items is maximum.\n\nBut how to compute this for all x up to m?\n\nLet me think of the following approach. For the weight 1 and 2 items, for each possible x (capacity), we can compute the maximum value by considering all possible numbers of weight 2 items. However, this seems O(m * (m/2)) which is not feasible.\n\nBut perhaps we can optimize this by noting that for each x, the best b is up to min( (x//2), len(weight 2 items) ). However, even that might be O(m^2) in the worst case.\n\nAnother idea: For each possible number of weight 2 items, we can compute the maximum number of weight 1 items that can be added. For example, for each b, the maximum possible is when we take b weight 2 items, and then as many weight 1 items as possible. Then, for each x, the maximum is the maximum over all possible b where 2*b ≤ x. But how to find that efficiently?\n\nAlternatively, we can precompute for each possible b (up to the number of weight 2 items), the maximum number of weight 1 items that can be taken given a capacity. Then, for each x, we can find the best b such that 2*b ≤x.\n\nBut again, how to do that?\n\nWait, but for each x, the maximum possible 2b is x. So for each x, we can try all possible b up to min(x//2, len2), where len2 is the number of weight 2 items. However, for x up to 3e5, and len2 up to 1e5, this would be O(3e5 * 1e5) which is 3e10 operations. That's way too slow.\n\nHmm, this approach isn't going to work. So I need another way.\n\nAlternative approach: Let's think about combining the weight 1 and 2 items. For each possible capacity, we can find the best way to take items of weight 1 and 2. Since weight 1 and 2 can be considered as two separate groups, perhaps we can model this as a knapsack problem with two types of items. However, since the number of items is up to 1e5, even that approach may not be feasible.\n\nWait, but the weight of each item is either 1 or 2. So for each weight group, we have sorted them in descending order of cost. Let's say that for weight 1, we have a list sorted in descending order, and for weight 2, same.\n\nNow, for a given capacity x, the optimal selection is to take as many as possible of the highest value items. For example, for the weight 2 items, taking the first b items gives sum_2[b], and then taking the first (x - 2b) items from weight 1 gives sum_1[x - 2b]. So for each possible x, the maximum is the maximum over all possible b (number of weight 2 items taken) such that 2b <= x. But how can we compute this for all x efficiently?\n\nLet me think. For each x, the maximum value can be found by considering all possible b such that 2b <=x. However, for each x, the possible values of b can be up to x//2. But if we can precompute for each x, the best b, perhaps using some sliding window approach.\n\nAlternatively, note that for each possible number of weight 2 items (say, up to len2), we can compute the maximum number of weight 1 items that can be taken. For example, if we take b items of weight 2, then the total weight is 2b. The remaining weight is x - 2b, which can be filled with weight 1 items. But x can vary. However, for a given b, the maximum contribution to any x >= 2b is sum_2[b] + sum_1[min(x - 2b, len1)], where len1 is the number of weight 1 items.\n\nBut how to use this to compute for all x?\n\nAnother idea: For each possible b (number of weight 2 items taken), we can generate a function f_b(x) = sum_2[b] + sum_1[min(x - 2b, len1)] for x >= 2b. Then, the maximum over all b for each x is the maximum of all f_b(x) for which 2b <=x.\n\nBut how can we compute this for all x?\n\nThis seems like a problem where for each x, we can consider all possible b that could contribute to it. However, again, this seems computationally heavy.\n\nAlternatively, for each possible x, the optimal b is either floor(x/2) or something close. But that's not necessarily true.\n\nWait, but here's a thought. Since the sum_1 is non-decreasing (as we take more items), and sum_2 is also non-decreasing. For a fixed x, when you increase b, the 2b increases, which reduces the available space for weight 1 items. However, the sum_2[b] increases. So the optimal b is somewhere where the trade-off between taking more weight 2 items and less weight 1 items is best.\n\nBut how to find this optimal b for each x?\n\nMaybe for each x, the optimal b is in the range [max(0, (x - len1)/2), x//2]. Because if we take more than (x - len1)/2, then the available space for weight 1 items would be x - 2b < len1, so we can't take all the weight 1 items. But I'm not sure.\n\nAlternatively, perhaps for each x, the optimal b is either the maximum possible (i.e., x//2) or the maximum possible minus some small number. But again, not sure.\n\nWait, but here's an alternative approach. Let's precompute the prefix sums for weight 1 and 2. Let's call them s1 and s2. Now, for any x, the maximum value is the maximum over all b (from 0 to min(x//2, len2)), of s2[b] + s1[ min(x - 2*b, len1) ].\n\nBut for x up to 3e5, and len2 up to 1e5, this would be O(3e5 * 1e5) operations, which is way too slow.\n\nSo this approach is not feasible. So I need a better way.\n\nLet me think again. Since the weight is small, maybe we can find for each possible remainder modulo 2 or something. Wait, but the weight for 1 and 2 is variable.\n\nAnother idea: For the weight 1 and 2 items, we can model this as follows. Let's imagine that we can take any number of weight 1 and 2 items. Let's think of the problem as trying to maximize the sum, given that the total weight is at most x.\n\nBut since the items are sorted, we can take as many as possible of the highest value items.\n\nLet me think of the following approach. For each possible number of weight 2 items (b), we can compute the maximum number of weight 1 items that can be taken given that the total weight is x. So for each b, the maximum number of weight 1 items is max_a = min( (x - 2*b), len1 ). The total cost is s2[b] + s1[max_a].\n\nNow, for each x, the maximum value is the maximum over all possible b. But how can we compute this for all x efficiently?\n\nAlternatively, for each possible b, we can compute the contribution to all x that are >= 2b. For example, if we take b weight 2 items, then for x >= 2b, the contribution is s2[b] + s1[ min(x - 2b, len1) ].\n\nBut how can we precompute this for all x?\n\nLet me think of the following. For each possible b, we can compute the value of s2[b] + s1[k], where k is the maximum number of weight 1 items that can be taken with the remaining weight (x - 2b). However, for varying x, this is equivalent to adding s2[b] to the s1 array shifted by 2b positions. So for each x, the maximum value is the maximum of all s2[b] + s1[x - 2b] (if x - 2b is within the length of s1).\n\nBut how can we compute this for all x?\n\nThis sounds like a convolution-like problem, but I'm not sure. However, given that the maximum x is 3e5, and the maximum b is up to len2, which can be up to 1e5, this seems challenging.\n\nWait, but for each x, the possible 2b can be up to x. So for each x, we can iterate over all possible b where 2b <= x. But again, this is O(m^2), which is not feasible.\n\nAnother Idea: Since the weight 1 items are sorted, and we can take as many as possible, perhaps for each x, the optimal number of weight 2 items is such that the remaining weight after taking b weight 2 items allows us to take as many weight 1 items as possible. But since weight 1 items are sorted, taking as many as possible is always better.\n\nSo for each x, the optimal strategy is to take some number of weight 2 items, and then fill the rest with weight 1 items. Now, the question is, for each x, what is the optimal b?\n\nLet me think of the following: For a given x, the maximum number of weight 2 items we can take is up to x//2. But maybe taking the first k items of weight 2, and then filling the rest with weight 1. However, since the weight 2 items are sorted in descending order, taking the first b items of weight 2 is better than taking any other combination of items of weight 2. So the optimal for a given x is to take some number of weight 2 items (possibly zero) and then fill the rest with weight 1.\n\nBut how to find the best b for x?\n\nLet me think of this as follows: For each x, the best b can be found by considering the possible values of b where 2b is as large as possible, but not exceeding x. However, since the sum_2[b] increases with b, but the sum_1[x - 2b] decreases as b increases (since x - 2b decreases), there's a trade-off. The optimal b is the one where this trade-off is best.\n\nBut how to find this quickly?\n\nLet me think of binary search. Suppose I can find for each x the best b. However, I don't see an obvious way to apply binary search here.\n\nAlternative Idea: Precompute for all possible x, the maximum between taking 0 weight 2 items (so all weight 1) and taking as many weight 2 items as possible (up to x//2), and also check a few possibilities around that. But this is heuristic and may not work for all cases.\n\nAlternatively, considering that for weight 2 items, taking the first b items gives us sum_2[b], and the remaining weight is x - 2b. So for each x, the maximum is the maximum of sum_2[b] + sum_1[ min(x - 2b, len1) ] for all b from 0 to min(x//2, len2). \n\nBut here's a trick: For each x, the optimal b can be up to min(x//2, len2). Let's say that for x, the maximum b is B = min(x//2, len2). Then, we can check all possible b in the range from max(0, B - K) to B, where K is a small number (like 100). This would be O(K) per x, which for x up to 3e5 and K=100 would be 3e7 operations. This might be feasible.\n\nBut why would this work? Because the optimal b is likely to be near the maximum possible B, since the sum_2[b] increases with b, and the sum_1 decreases with b. So the optimal point is where the gain from adding another weight 2 item is offset by the loss in weight 1 items.\n\nBut this is just a heuristic. However, given that the time constraints are tight, this might be the only feasible way.\n\nAlternatively, for each x, we can consider two possibilities: the maximum possible b (B), and B-1. But I'm not sure.\n\nLet me think of an example. Suppose x is 5. The maximum possible b is 2 (2*2=4). Then, the remaining weight is 1, which can take one weight 1 item. Alternatively, taking b=1 (weight 2 items: 2), remaining weight is 3, which can take 3 weight 1 items. Which is better depends on the actual values.\n\nBut if the weight 2 items are very valuable, then taking b=2 may be better. If the weight 1 items are very valuable, then taking b=1 may be better.\n\nBut how to find the optimal b without checking all possibilities?\n\nAlternatively, since the sum_2 is non-decreasing and the sum_1 is non-decreasing, but the term x - 2b decreases as b increases, the function f(b) = sum_2[b] + sum_1[ min(x - 2b, len1) ] may have a single maximum, which can be found via ternary search.\n\nBut since the function may not be unimodal, this is not guaranteed. However, given that the sum_2 is increasing and sum_1 is decreasing as b increases, the function f(b) might be unimodal. Let's think:\n\nAs b increases, sum_2[b] increases, but sum_1 decreases. The overall function could have a single peak. So ternary search might work.\n\nIf that's the case, then for each x, we can perform a ternary search on b in the range [0, B], where B is min(x//2, len2). This would take O(log B) steps per x, which for x up to 3e5 would be acceptable.\n\nBut how to implement this? Well, for each x, we can perform a ternary search on b, and for each candidate b, compute the value of f(b). Then take the maximum.\n\nBut how to handle the cases where x - 2b exceeds the number of weight 1 items. In that case, the sum_1 is sum_1[len1], which is the maximum possible for weight 1.\n\nSo, for each x, the maximum value for the weight 1 and 2 part is the maximum over all b in 0..B of (sum_2[b] + sum_1[ min(x - 2*b, len1) ]).\n\nAssuming that this function is unimodal, ternary search can find the maximum.\n\nBut I'm not sure if this is the case. For example, imagine sum_2 is [10, 10], sum_1 is [5, 5, 5]. For x=5:\n\nb=0: 0 + 5 = 5.\n\nb=1: 10 + 5 = 15.\n\nb=2: 20 + (5 - 2*2 = 1) → 20 + 5 = 25.\n\nSo the function increases with b.\n\nAnother example: sum_2 is [3, 3], sum_1 is [10, 10]. x=5:\n\nb=0: 0 + 10 = 10.\n\nb=1: 3 + 10 (5-2=3 → 3 items of weight 1, but len1 is 2 → sum is 10+10=20? Wait, no. Wait, x is 5. 2*b is 2. So x-2b is 3. But len1 is 2. So sum_1 is sum of 2 items. So total is 3 + 10 = 13.\n\nb=2: 6 + (5-4=1) → sum_1[1] = 10 → total 16. So the function increases with b. So in this case, it's unimodal.\n\nAnother example where it's not unimodal: sum_2 is [5, 5], sum_1 is [4, 4]. x=4.\n\nb=0: 0 + 4 = 4.\n\nb=1: 5 + (4-2=2 → sum_1[2] = 8 → total 13.\n\nb=2: 10 + (4-4=0 → sum_1[0]=0 → total 10.\n\nSo here, the function increases then decreases. So it's unimodal. So ternary search would find the maximum.\n\nSo perhaps the function is indeed unimodal, and thus ternary search is applicable.\n\nIf this holds, then for each x, we can perform a ternary search on the possible b values to find the maximum. This would take O(log B) steps per x, which for x up to 3e5 is manageable.\n\nSo this seems promising.\n\nThus, the plan is:\n\n1. Separate the items into three groups based on their weight (1, 2, 3).\n\n2. Sort each group in descending order of cost.\n\n3. Compute prefix sums for each group. For example, s1[i] is the sum of the first i items in the weight 1 group.\n\n4. For the weight 3 group, compute its prefix sum as well (s3).\n\n5. Now, for the overall problem, we can iterate over the possible number of weight 3 items (c). For each c, the total weight used is 3*c, and the remaining capacity is rem = m - 3*c. If rem is negative, skip. Otherwise, we need to compute the maximum value for the weight 1 and 2 items with capacity rem, and then add s3[c].\n\n6. The maximum of all these possibilities (for all c) is the answer.\n\nNow, the challenge is step 5, which involves computing the maximum value for weight 1 and 2 with capacity rem. For this, we can use the ternary search approach for each rem.\n\nSo the steps are:\n\n- Preprocess the weight 1 and 2 groups, sorted and prefix sums computed.\n\n- For each possible c (number of weight 3 items), compute rem = m - 3*c. If rem <0, skip. Else, compute the best value for weight 1 and 2 with capacity rem.\n\nBut how to compute that best value efficiently?\n\nImplementing the ternary search approach for each rem:\n\nFor a given rem, the maximum possible b is B = min(rem // 2, len2). So the range for b is 0 to B. We can perform a ternary search on this interval to find the best b.\n\nBut what if len2 is larger than B? Well, the min ensures that we don't take more than B items of weight 2.\n\nSo, for each rem, we can perform the ternary search.\n\nBut how to handle the case where rem is larger than the maximum possible weight for weight 1 and 2 items?\n\nFor example, if rem is 1e5, but the total weight of all weight 1 and 2 items is less than that. In that case, the maximum value is simply the sum of all weight 1 and 2 items.\n\nBut the ternary search approach would naturally account for this, since for b=0, the sum_1 would be sum of all items (if rem is larger than the total weight of weight 1 items).\n\nBut wait, the sum_1 is the prefix sum of the sorted items. So for example, if rem is larger than the total weight of weight 1 items (i.e., len1 * 1), then min(rem - 2*b, len1) is len1. So the sum_1 is s1[len1].\n\nSo the ternary search approach will automatically account for that.\n\nSo now, the plan is:\n\nImplement the ternary search for the weight 1 and 2 part. For each rem, compute the maximum value.\n\nNow, the code outline:\n\nRead n and m.\n\nInitialize three lists: w1, w2, w3.\n\nFor each of the n items:\n\n   read wi and ci.\n\n   append to the corresponding list.\n\nSort each list in descending order of cost.\n\nCompute prefix sums for each list:\n\ns1 = [0]\n\nfor i in range(len(w1)):\n\n    s1.append(s1[-1] + w1[i].cost)\n\nSimilarly for s2 and s3.\n\nThen, for the weight 3 items, compute s3 as the prefix sum.\n\nNow, for the overall solution:\n\nInitialize max_total = 0.\n\nFor c in 0 to min( len3, m // 3 ):\n\n    current_weight = 3 * c\n\n    rem = m - current_weight\n\n    if rem <0:\n\n        continue\n\n    # compute the best value for rem using weight 1 and 2\n\n    val = compute_max_1_2(rem)\n\n    total = val + s3[c]\n\n    if total > max_total:\n\n        max_total = total\n\nreturn max_total\n\nNow, the function compute_max_1_2(rem) needs to compute the maximum value for weight 1 and 2 items with capacity rem.\n\nImplementing compute_max_1_2(rem):\n\ndef compute_max_1_2(rem):\n\n    len1 = len(s1) - 1\n\n    len2 = len(s2) - 1\n\n    low = 0\n\n    high = min( rem // 2, len2 )\n\n    best = 0\n\n    # perform ternary search between 0 and high\n\n    while low <= high:\n\n        mid1 = low + (high - low) // 3\n\n        mid2 = high - (high - low) // 3\n\n        val1 = get_value(mid1, rem)\n\n        val2 = get_value(mid2, rem)\n\n        if val1 < val2:\n\n            low = mid1 + 1\n\n            best = max(best, val2)\n\n        else:\n\n            high = mid2 - 1\n\n            best = max(best, val1)\n\n    # Also check the boundaries, because sometimes ternary search may miss\n\n    for b in [low, high, 0, high//2, ... ]:\n\n        best = max(best, get_value(b, rem))\n\n    return best\n\nBut this is a rough sketch. The exact implementation of the ternary search may vary. However, the main idea is to find the optimal b in the range [0, B], where B = min(rem//2, len2).\n\nAlternatively, since the function is unimodal, we can use binary search to find the maximum. However, implementing ternary search may be easier.\n\nBut for the purposes of code, perhaps a better approach is to iterate over all possible b in the range [max(0, B - K), B], where K is a small number like 100. This would be O(K) per rem. For example, if K is 200, then for m=3e5, the total operations would be 3e5 * 200 = 6e7, which is manageable.\n\nBut why would this work? Because the optimal b is likely to be near the maximum possible B. For example, in the previous examples, the optimal was either B or B-1. So checking a few values around B could capture the maximum.\n\nLet me think. Suppose that for a given rem, the optimal b is in the range [B - 100, B]. Then checking all values in this range would find the maximum.\n\nBut why would this be the case? Because the sum_2 is increasing and the sum_1 is decreasing. The optimal point is where the marginal gain of adding a weight 2 item is higher than the loss from reducing the weight 1 items. However, this could happen anywhere. But given that the items are sorted, perhaps the optimal b is not too far from B.\n\nBut this is a heuristic. However, given the time constraints, this approach may be feasible.\n\nLet me test this idea with some examples.\n\nExample 1:\n\nrem = 5, len2 = 2 (so B = 2). Suppose the best is at b=2.\n\nCheck B-100 to B. Since B is 2, and B-100 is negative, we check from 0 to 2. Which is 3 values. So for K=100, this is okay.\n\nAnother example where the optimal is B-100. But that would require that the sum_2[B-100] is significantly higher than sum_2[B], which is unlikely given that the items are sorted in descending order. Because sum_2[b] increases with b. So if the optimal b is B-100, that would mean that taking B-100 items of weight 2 and then taking a lot of weight 1 items gives a better total than taking B items of weight 2 and less weight 1 items. But since the weight 2 items are sorted in descending order, the sum_2[B] is larger than sum_2[B-100], and the weight 1 items taken would be less. However, it's possible that the difference in sum_2 is not enough to compensate for the loss in sum_1.\n\nBut this scenario would require that the sum_2 increases by a small amount, while the sum_1 decreases by a large amount. But since the weight 1 items are sorted, adding more weight 1 items would give higher values. So for example, if the weight 1 items are very valuable, and the weight 2 items are not, then taking fewer weight 2 items and more weight 1 items would be better.\n\nBut in this case, the optimal b would be small, but checking up to B-100 would miss it. However, if the code checks all possible values of b from 0 to B, then it would find it. But that would be O(B) per rem, which is again O(m^2) in the worst case.\n\nThus, the K idea is a trade-off between accuracy and speed.\n\nBut given that the weight of the items is small (1 and 2), and that the sum_1 is non-decreasing, perhaps the optimal b is either the maximum possible B, or B-1, or B-2, etc., up to some small number.\n\nBut how to determine how many to check?\n\nAlternatively, for each rem, we can check all possible b from max(0, B - 200) to B. Since 200 is small, this would be manageable.\n\nBut how to choose the number of checks?\n\nAlternatively, since the weight of the items is small, perhaps the optimal b is within B - (len1) or something. Not sure.\n\nAlternatively, considering that the maximum possible sum_1 is s1[len1], and the maximum sum_2 is s2[len2], perhaps for each rem, the optimal b can be found by checking all possible b from 0 to min(B, 300), and also B itself. Because if B is larger than 300, then checking up to 300 may capture the optimal point.\n\nBut this is getting complicated.\n\nPerhaps, given the time constraints, it's better to proceed with the ternary search approach.\n\nLet me think about how to implement the ternary search. For example:\n\ndef compute_max_1_2(rem):\n\n    len1 = len(s1) - 1\n\n    len2 = len(s2) - 1\n\n    # maximum number of weight 2 items we can take is B\n\n    B = min(rem // 2, len2)\n\n    low = 0\n\n    high = B\n\n    best = 0\n\n    # perform ternary search\n\n    for _ in range(100):\n\n        if high - low < 3:\n\n            break\n\n        m1 = low + (high - low) // 3\n\n        m2 = high - (high - low) // 3\n\n        v1 = get_value(m1, rem)\n\n        v2 = get_value(m2, rem)\n\n        if v1 < v2:\n\n            low = m1 + 1\n\n        else:\n\n            high = m2 - 1\n\n    # after narrowing down, check all values in [low, high]\n\n    for b in range(low, high + 1):\n\n        current_val = get_value(b, rem)\n\n        if current_val > best:\n\n            best = current_val\n\n    return best\n\nWhere get_value(b, rem) is:\n\ndef get_value(b, rem):\n\n    # returns s2[b] + s1[ min(rem - 2*b, len1) ]\n\n    available = rem - 2 * b\n\n    a = min(available, len1)\n\n    return s2[b] + s1[a]\n\nThis way, after narrowing down the range using ternary search, we check all values in the small range.\n\nThis should work for most cases.\n\nNow, let's think about the code structure.\n\nNow, for the code:\n\nWe need to process the input, group the items by weight, sort them in descending order, compute prefix sums.\n\nThen, for each possible c in 0 to max_c (where max_c is min(len3, m//3)), compute rem = m - 3*c. For each rem, compute the max value from weight 1 and 2 items, and add s3[c].\n\nNow, the code in Python:\n\nBut for large n (up to 1e5), and m up to 3e5, this approach should be efficient.\n\nNow, the code:\n\nRead n and m.\n\nThen read n lines of wi and ci.\n\nGroup into lists:\n\nw1 = []\nw2 = []\nw3 = []\n\nfor each item:\n    if wi == 1:\n        w1.append(ci)\n    elif wi == 2:\n        w2.append(ci)\n    else:\n        w3.append(ci)\n\nSort each list in descending order.\n\nCompute prefix sums:\n\ns1 = [0]\nfor c in sorted(w1, reverse=True):\n    s1.append(s1[-1] + c)\n\nSimilarly for s2 and s3.\n\nThen, for the compute_max_1_2 function.\n\nNow, the code for compute_max_1_2(rem):\n\ndef compute_max_1_2(rem, s1, s2):\n\n    len1 = len(s1) - 1\n\n    len2 = len(s2) - 1\n\n    B = min(rem // 2, len2)\n\n    low = 0\n\n    high = B\n\n    best = 0\n\n    for _ in range(100):\n\n        if high - low < 3:\n\n            break\n\n        m1 = low + (high - low) // 3\n\n        m2 = high - (high - low) // 3\n\n        v1 = get_value(m1, rem, s1, s2)\n\n        v2 = get_value(m2, rem, s1, s2)\n\n        if v1 < v2:\n\n            low = m1 + 1\n\n        else:\n\n            high = m2 - 1\n\n    # check all between low and high",
    "response": "To solve this problem, we need to determine the maximum possible total cost of souvenirs that Petya can carry to the market given a weight constraint. The solution leverages the fact that each souvenir has a weight of either 1, 2, or 3, allowing us to use optimized strategies for each weight category.\n\n### Approach\n1. **Group Items by Weight**: Separate the souvenirs into three groups based on their weights (1, 2, and 3).\n2. **Sort and Compute Prefix Sums**: Sort each group in descending order of cost and compute prefix sums for efficient range sum queries.\n3. **Iterate Over Possible Counts of Weight 3 Items**: For each possible count of weight 3 items, calculate the remaining capacity and determine the optimal combination of weight 1 and 2 items using a ternary search approach.\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n    \n    w1 = []\n    w2 = []\n    w3 = []\n    \n    for _ in range(n):\n        wi = int(input[idx])\n        idx += 1\n        ci = int(input[idx])\n        idx += 1\n        if wi == 1:\n            w1.append(ci)\n        elif wi == 2:\n            w2.append(ci)\n        else:\n            w3.append(ci)\n    \n    # Sort each list in descending order\n    w1.sort(reverse=True)\n    w2.sort(reverse=True)\n    w3.sort(reverse=True)\n    \n    # Compute prefix sums\n    s1 = [0]\n    for c in w1:\n        s1.append(s1[-1] + c)\n    \n    s2 = [0]\n    for c in w2:\n        s2.append(s2[-1] + c)\n    \n    s3 = [0]\n    for c in w3:\n        s3.append(s3[-1] + c)\n    \n    max_total = 0\n    \n    len3 = len(w3)\n    max_c = min(len3, m // 3)\n    \n    def get_value(b, rem, s1, s2):\n        available = rem - 2 * b\n        a = min(available, len(s1)-1)\n        return s2[b] + s1[a]\n    \n    for c in range(0, max_c + 1):\n        current_weight = 3 * c\n        rem = m - current_weight\n        if rem < 0:\n            continue\n        len1 = len(s1) - 1\n        len2 = len(s2) - 1\n        B = min(rem // 2, len2)\n        low = 0\n        high = B\n        best = 0\n        \n        # Ternary search\n        for _ in range(100):\n            if high - low < 3:\n                break\n            m1 = low + (high - low) // 3\n            m2 = high - (high - low) // 3\n            v1 = get_value(m1, rem, s1, s2)\n            v2 = get_value(m2, rem, s1, s2)\n            if v1 < v2:\n                low = m1 + 1\n            else:\n                high = m2 - 1\n        \n        # Check all values in the narrowed range\n        for b in range(low, high + 1):\n            if b > len2:\n                continue\n            val = get_value(b, rem, s1, s2)\n            if val > best:\n                best = val\n        \n        total = best + s3[c]\n        if total > max_total:\n            max_total = total\n    \n    print(max_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Grouping and Sorting**: The souvenirs are grouped by their weights and sorted in descending order of cost to prioritize higher value items.\n2. **Prefix Sums**: Prefix sums are computed for each weight group to quickly determine the total cost of selecting the top `k` items.\n3. **Ternary Search**: For each possible count of weight 3 items, the remaining capacity is used to determine the optimal combination of weight 1 and 2 items using a ternary search approach to efficiently find the maximum possible value within the constraints.\n\nThis approach ensures that we efficiently explore the possible combinations of items while leveraging sorting and prefix sums for quick calculations, leading to an optimal solution within the problem constraints.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n    \n    w1 = []\n    w2 = []\n    w3 = []\n    \n    for _ in range(n):\n        wi = int(input[idx])\n        idx += 1\n        ci = int(input[idx])\n        idx += 1\n        if wi == 1:\n            w1.append(ci)\n        elif wi == 2:\n            w2.append(ci)\n        else:\n            w3.append(ci)\n    \n    # Sort each list in descending order\n    w1.sort(reverse=True)\n    w2.sort(reverse=True)\n    w3.sort(reverse=True)\n    \n    # Compute prefix sums\n    s1 = [0]\n    for c in w1:\n        s1.append(s1[-1] + c)\n    \n    s2 = [0]\n    for c in w2:\n        s2.append(s2[-1] + c)\n    \n    s3 = [0]\n    for c in w3:\n        s3.append(s3[-1] + c)\n    \n    max_total = 0\n    \n    len3 = len(w3)\n    max_c = min(len3, m // 3)\n    \n    def get_value(b, rem, s1, s2):\n        available = rem - 2 * b\n        a = min(available, len(s1)-1)\n        return s2[b] + s1[a]\n    \n    for c in range(0, max_c + 1):\n        current_weight = 3 * c\n        rem = m - current_weight\n        if rem < 0:\n            continue\n        len1 = len(s1) - 1\n        len2 = len(s2) - 1\n        B = min(rem // 2, len2)\n        low = 0\n        high = B\n        best = 0\n        \n        # Ternary search\n        for _ in range(100):\n            if high - low < 3:\n                break\n            m1 = low + (high - low) // 3\n            m2 = high - (high - low) // 3\n            v1 = get_value(m1, rem, s1, s2)\n            v2 = get_value(m2, rem, s1, s2)\n            if v1 < v2:\n                low = m1 + 1\n            else:\n                high = m2 - 1\n        \n        # Check all values in the narrowed range\n        for b in range(low, high + 1):\n            if b > len2:\n                continue\n            val = get_value(b, rem, s1, s2)\n            if val > best:\n                best = val\n        \n        total = best + s3[c]\n        if total > max_total:\n            max_total = total\n    \n    print(max_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 482,
        "completion_token_count": 979,
        "thoughts_token_count": 8192
    }
}