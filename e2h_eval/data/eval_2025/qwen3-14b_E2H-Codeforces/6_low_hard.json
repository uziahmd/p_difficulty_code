{
    "start": 1758313552.3804371,
    "end": 1758313774.112799,
    "start-formatted": "2025-09-20 05:25 KST",
    "end-formatted": "2025-09-20 05:29 KST",
    "gpu": 2,
    "pid": 6,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\nOkay, let's try to figure out how to solve this problem. The task is to find two non-overlapping vouchers whose total duration equals exactly x, and their combined cost is minimized. If there's no such pair, return -1.\n\nFirst, I need to understand the problem thoroughly. Each voucher has a start day (li), end day (ri), and cost. The duration is ri - li + 1. We need two vouchers where their durations add up to x. Also, they must not overlap. So for two vouchers i and j, either the first ends before the second starts (ri < lj) or the second ends before the first starts (rj < li). \n\nThe challenge is to find such pairs efficiently given the constraints on n (up to 2e5). A brute-force approach checking all pairs would be O(n²), which is way too slow for n=2e5. So we need an optimized approach.\n\nLet me think about possible steps:\n\n1. Preprocess vouchers by their duration. For each voucher, check if there exists another voucher with duration (x - duration_i). Then, check if those two vouchers can be non-overlapping.\n\nBut even this approach might be tricky. How do I efficiently find for each voucher, the minimal cost of another voucher with required duration that doesn't overlap?\n\nAlternatively, maybe group vouchers by their duration. For example, for each possible duration d, store a list of vouchers with that duration. Then, for each voucher with duration d, look for vouchers with duration (x - d), and check if any of them are non-overlapping.\n\nBut how to check for non-overlapping efficiently?\n\nLet's consider that for each voucher i with duration d, we need to find a voucher j with duration (x - d) such that either j ends before i starts or i ends before j starts.\n\nSo, for each voucher i, we can check two possibilities:\n\na) Find the minimal cost voucher j with duration (x - d) that ends before li. Because then voucher j ends before i starts (since j's end is <= li-1, and i starts at li).\n\nb) Find the minimal cost voucher j with duration (x - d) that starts after ri. Because then i ends at ri, and j starts at rj >= ri+1, so they don't overlap.\n\nBut how do I efficiently find these minima?\n\nThis seems like a problem that can be solved with some preprocessing. For example, for each duration d, we can have sorted lists of vouchers' end times and start times, along with their costs. Then for a given voucher i, we can query the earliest end time (for case a) or earliest start time (for case b) for the required duration.\n\nWait, but for case a, we want vouchers of duration (x - d) that end before li. So for those vouchers, we need to find the minimal cost among those that end before li. Similarly, for case b, find the minimal cost among vouchers of duration (x - d) that start after ri.\n\nTo handle this, perhaps for each duration d, we can maintain two structures:\n\n- A sorted list of end times, along with the minimum cost up to that end time. So for a given end time, we can find all vouchers with end time <= some value and get the minimum cost.\n\nSimilarly, for start times: a sorted list of start times, along with the minimum cost from that start time onwards.\n\nWait, but how to structure this. Let's think for each duration d, we have a list of vouchers. For each such list, we can sort them by their end time, and precompute a prefix minimum array. Then, for a given li, we can perform a binary search to find the largest end time <= li-1, and then get the minimum cost up to that point.\n\nSimilarly, for the start times: sort the vouchers by their start time, and precompute a suffix minimum array. Then, for a given ri, find the smallest start time >= ri+1, and get the minimum cost from that point onwards.\n\nSo the plan is:\n\n- Preprocess all vouchers into groups by their duration. For each duration d, we have two sorted lists:\n\n   a) Sorted by end time, with prefix minima for cost.\n\n   b) Sorted by start time, with suffix minima for cost.\n\nThen, for each voucher i with duration d, compute required duration as (x - d). Check if this required duration exists in our groups. If it does, then:\n\n   For case a: find the minimal cost in the required duration group where end time < li. This can be done by binary searching in the sorted end times list for the required duration group. For example, in the sorted end times, find the largest end time that is <= li -1. Then, the prefix minima up to that index gives the minimal cost.\n\n   For case b: find the minimal cost in the required duration",
    "response": "To solve this problem, we need to find two non-overlapping vouchers whose combined duration equals exactly x and whose total cost is minimized. The solution involves preprocessing vouchers by their duration and efficiently querying for the minimum cost of valid vouchers that can be paired with each voucher.\n\n### Approach\n1. **Preprocessing by Duration**: Group all vouchers by their duration. This allows us to quickly access vouchers of a specific duration when checking potential pairs.\n2. **Sorting and Prefix/Suffix Minima**: For each duration group, maintain two sorted lists:\n   - One sorted by end time with prefix minima for costs.\n   - Another sorted by start time with suffix minima for costs.\n3. **Efficient Querying**: For each voucher, check if there exists another voucher with the required complementary duration. Use binary search to efficiently find valid non-overlapping vouchers and determine the minimum cost using the precomputed prefix/suffix minima arrays.\n\n### Solution Code\n```python\nimport sys\nimport bisect\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n\n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n\n    # Group vouchers by duration\n    duration_dict = defaultdict(list)\n    for l, r, cost, d in vouchers:\n        duration_dict[d].append((l, r, cost))\n\n    # Preprocess each duration group\n    # For each duration d, we have:\n    # - list sorted by end time, with prefix minima\n    # - list sorted by start time, with suffix minima\n    processed = dict()\n    for d in duration_dict:\n        lst = duration_dict[d]\n        # Sort by end time\n        sorted_by_end = sorted(lst, key=lambda x: x[1])\n        # Create prefix minima for end-sorted list\n        prefix_min = []\n        min_cost = float('inf')\n        for l, r, cost in sorted_by_end:\n            if cost < min_cost:\n                min_cost = cost\n            prefix_min.append(min_cost)\n        # Sort by start time\n        sorted_by_start = sorted(lst, key=lambda x: x[0])\n        # Create suffix minima for start-sorted list\n        suffix_min = [0] * len(sorted_by_start)\n        min_cost = float('inf')\n        for i in range(len(sorted_by_start)-1, -1, -1):\n            l, r, cost = sorted_by_start[i]\n            if cost < min_cost:\n                min_cost = cost\n            suffix_min[i] = min_cost\n        processed[d] = (sorted_by_end, prefix_min, sorted_by_start, suffix_min)\n\n    min_total = float('inf')\n\n    for l_i, r_i, cost_i, d_i in vouchers:\n        required_d = x - d_i\n        if required_d < 1:\n            continue\n        if required_d not in processed:\n            continue\n        # Check for vouchers of required_d that end before l_i\n        sorted_by_end, prefix_min, sorted_by_start, suffix_min = processed[required_d]\n        # Case 1: voucher j ends before l_i\n        # Find the largest end <= l_i - 1\n        end_list = [entry[1] for entry in sorted_by_end]\n        pos = bisect.bisect_right(end_list, l_i - 1) - 1\n        if pos >= 0:\n            min_cost_j = prefix_min[pos]\n            total = cost_i + min_cost_j\n            if total < min_total:\n                min_total = total\n        # Case 2: voucher j starts after r_i\n        start_list = [entry[0] for entry in sorted_by_start]\n        pos = bisect.bisect_left(start_list, r_i + 1)\n        if pos < len(start_list):\n            min_cost_j = suffix_min[pos]\n            total = cost_i + min_cost_j\n            if total < min_total:\n                min_total = total\n\n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into a list of vouchers, each with their start day, end day, cost, and duration.\n2. **Grouping by Duration**: Vouchers are grouped by their duration using a dictionary for efficient access.\n3. **Sorting and Minima Arrays**: For each duration group, vouchers are sorted by end time and start time. Prefix minima arrays are created for end-sorted lists and suffix minima arrays for start-sorted lists to quickly determine the minimum cost for valid ranges.\n4. **Checking Valid Pairs**: For each voucher, we check if there exists a valid complementary voucher with the required duration. Binary search is used to efficiently find valid non-overlapping vouchers and their minimum costs using the preprocessed arrays.\n\nThis approach ensures that we efficiently check all possible valid pairs without resorting to a brute-force O(n²) solution, making it feasible for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport bisect\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n\n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n\n    # Group vouchers by duration\n    duration_dict = defaultdict(list)\n    for l, r, cost, d in vouchers:\n        duration_dict[d].append((l, r, cost))\n\n    # Preprocess each duration group\n    # For each duration d, we have:\n    # - list sorted by end time, with prefix minima\n    # - list sorted by start time, with suffix minima\n    processed = dict()\n    for d in duration_dict:\n        lst = duration_dict[d]\n        # Sort by end time\n        sorted_by_end = sorted(lst, key=lambda x: x[1])\n        # Create prefix minima for end-sorted list\n        prefix_min = []\n        min_cost = float('inf')\n        for l, r, cost in sorted_by_end:\n            if cost < min_cost:\n                min_cost = cost\n            prefix_min.append(min_cost)\n        # Sort by start time\n        sorted_by_start = sorted(lst, key=lambda x: x[0])\n        # Create suffix minima for start-sorted list\n        suffix_min = [0] * len(sorted_by_start)\n        min_cost = float('inf')\n        for i in range(len(sorted_by_start)-1, -1, -1):\n            l, r, cost = sorted_by_start[i]\n            if cost < min_cost:\n                min_cost = cost\n            suffix_min[i] = min_cost\n        processed[d] = (sorted_by_end, prefix_min, sorted_by_start, suffix_min)\n\n    min_total = float('inf')\n\n    for l_i, r_i, cost_i, d_i in vouchers:\n        required_d = x - d_i\n        if required_d < 1:\n            continue\n        if required_d not in processed:\n            continue\n        # Check for vouchers of required_d that end before l_i\n        sorted_by_end, prefix_min, sorted_by_start, suffix_min = processed[required_d]\n        # Case 1: voucher j ends before l_i\n        # Find the largest end <= l_i - 1\n        end_list = [entry[1] for entry in sorted_by_end]\n        pos = bisect.bisect_right(end_list, l_i - 1) - 1\n        if pos >= 0:\n            min_cost_j = prefix_min[pos]\n            total = cost_i + min_cost_j\n            if total < min_total:\n                min_total = total\n        # Case 2: voucher j starts after r_i\n        start_list = [entry[0] for entry in sorted_by_start]\n        pos = bisect.bisect_left(start_list, r_i + 1)\n        if pos < len(start_list):\n            min_cost_j = suffix_min[pos]\n            total = cost_i + min_cost_j\n            if total < min_total:\n                min_total = total\n\n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 740,
        "completion_token_count": 1141,
        "thoughts_token_count": 1024
    }
}