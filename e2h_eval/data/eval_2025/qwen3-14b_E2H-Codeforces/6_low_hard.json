{
    "start": 1758008334.0881736,
    "end": 1758008574.8974946,
    "start-formatted": "2025-09-16 16:38 KST",
    "end-formatted": "2025-09-16 16:42 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\nOkay, let's see. I need to solve this programming problem. Let's read the problem carefully.\n\nSo, the problem is about finding two non-overlapping vouchers such that their total duration is exactly x, and their combined cost is minimized. If there's no such pair, output -1.\n\nFirst, let's understand the problem. Each voucher has a start day li, end day ri, and cost. The duration is ri - li + 1. We need two vouchers i and j where their durations add up to x. Also, they must not overlap. That means either the first ends before the second starts, or the second ends before the first starts.\n\nThe challenge is to find the minimal sum of costs for such pairs.\n\nConstraints: n can be up to 2e5, which is 200,000. So any O(n^2) approach is definitely out of the question. Need an efficient solution, probably O(n log n) or similar.\n\nLet me think about how to approach this.\n\nFirst, for each voucher, we can compute its duration. Let's say for a voucher i, duration is d_i. Then, for each voucher, we need to find another voucher j such that d_i + d_j = x, and the vouchers don't overlap. And among all such pairs, find the minimum cost.\n\nBut how to efficiently find for each voucher, possible other vouchers that have duration (x - d_i), and are non-overlapping.\n\nSo here's an idea: group vouchers by their duration. For example, create a dictionary where the key is the duration, and the value is a list of vouchers with that duration. Then, for each voucher with duration d, check if there exists vouchers with duration (x - d). Then, for each such voucher, check if they are non-overlapping.\n\nBut even then, for each voucher, checking all vouchers of duration (x - d) could be O(n) in the worst case, leading to O(n^2) time again. So that's not feasible.\n\nAlternative approach: for each possible duration d, pre-process the vouchers so that for any voucher of duration d, we can quickly find the minimum cost of a voucher of duration (x - d) that does not overlap with it.\n\nBut how?\n\nLet's think about the two cases where voucher A comes before voucher B, or B comes before A. For a given voucher A with duration d, we need to find vouchers B with duration (x - d) that end before A starts, or start after A ends.\n\nSo for each voucher, we can look for vouchers of duration (x - d) that are either entirely before it, or entirely after it.\n\nBut how to find the minimal cost for those?\n\nMaybe for each duration, we can pre-process the vouchers sorted by their end time, and also track the minimal cost up to that point. Similarly for start times.\n\nAlternatively, for each duration, we can have two structures:\n\n- A sorted list of vouchers' end times, along with the minimal cost up to that end time. So for a voucher that ends at some time, we can query the minimum cost of vouchers that end before a certain time.\n\nWait, maybe for each duration, we can pre-process two arrays:\n\nFor vouchers of duration t:\n\n- Sorted by their end time. Then, for each voucher, if we want to find vouchers that end before a certain time (say, li - 1 of the current voucher), we can find the earliest ones and take the minimum cost.\n\nSimilarly, sorted by start time. For vouchers that start after a certain time (say, ri + 1 of the current voucher), we can find the earliest ones and take the minimum cost.\n\nBut how to do that efficiently?\n\nLet me think. Suppose we have all vouchers of duration t. For each such voucher, when we want to find vouchers of duration t' = x - d (where d is the current voucher's duration), that end before the current voucher's start. So for the current voucher's li, we need to find all vouchers of duration t' that end before li - 1. Among those, find the one with the minimal cost.\n\nSimilarly, find vouchers of duration t' that start after the current voucher's end (ri + 1). Among those, find the minimal cost.\n\nIf we can do that for each voucher, then for each voucher, we can check both possibilities and take the minimum.\n\nSo the plan is:\n\n- Preprocess for each duration t, a sorted list of vouchers (sorted by end time) and also have a prefix min array. Similarly, sorted by start time and have a suffix min array.\n\nWait, perhaps for each duration, we can have:\n\n- A sorted list of vouchers sorted by their end time. Then, for each voucher in this list, we can have a prefix minimum cost array. So for any query of \"find the minimal cost of vouchers with end time <= some value\", we can perform a binary search",
    "response": "\n\nTo solve this problem efficiently, we need to find two non-overlapping vouchers such that their combined duration equals exactly `x` and their total cost is minimized. The solution involves preprocessing vouchers by their duration and using binary search to quickly find the minimum cost of compatible vouchers.\n\n### Approach\n1. **Group Vouchers by Duration**: First, group all vouchers by their duration. This allows us to efficiently look up vouchers of a specific duration.\n2. **Sort and Preprocess**: For each duration, sort the vouchers by their end time and maintain a prefix minimum cost array. This helps in quickly finding the minimum cost of vouchers that end before a given start time.\n3. **Check for Valid Pairs**: For each voucher, check if there exists another voucher with the complementary duration (i.e., `x - duration`). Use binary search to find the minimum cost of such vouchers that do not overlap with the current voucher.\n\n### Solution Code\n```python\nimport sys\nimport bisect\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n    \n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        vouchers.append((l, r, cost))\n    \n    # Preprocess: group vouchers by duration\n    duration_dict = defaultdict(list)\n    for l, r, cost in vouchers:\n        d = r - l + 1\n        duration_dict[d].append((l, r, cost))\n    \n    # For each duration, sort by end time and create prefix min cost array\n    # Also sort by start time and create suffix min cost array\n    # We will use sorted by end time for checking vouchers ending before current start\n    # And sorted by start time for checking vouchers starting after current end\n    \n    # Preprocess data structure\n    # key: duration, value: list of (end_time, min_cost_up_to_here)\n    # and list of (start_time, min_cost_from_here)\n    preprocessed = dict()\n    for d in duration_dict:\n        lst = duration_dict[d]\n        # Sort by end time\n        sorted_by_end = sorted(lst, key=lambda x: x[1])\n        # Create prefix min cost array\n        prefix_min = []\n        min_so_far = float('inf')\n        for l, r, cost in sorted_by_end:\n            if cost < min_so_far:\n                min_so_far = cost\n            prefix_min.append(min_so_far)\n        # Sort by start time\n        sorted_by_start = sorted(lst, key=lambda x: x[0])\n        # Create suffix min cost array\n        suffix_min = [0] * len(sorted_by_start)\n        min_so_far = float('inf')\n        for i in range(len(sorted_by_start)-1, -1, -1):\n            l, r, cost = sorted_by_start[i]\n            if cost < min_so_far:\n                min_so_far = cost\n            suffix_min[i] = min_so_far\n        preprocessed[d] = (sorted_by_end, prefix_min, sorted_by_start, suffix_min)\n    \n    min_total = float('inf')\n    \n    for l1, r1, cost1 in vouchers:\n        d1 = r1 - l1 + 1\n        d2 = x - d1\n        if d2 < 1:\n            continue\n        if d2 not in duration_dict:\n            continue\n        \n        # Check vouchers with duration d2 that end before l1\n        # Use the sorted_by_end list and prefix_min\n        sorted_by_end_d2, prefix_min_d2, sorted_by_start_d2, suffix_min_d2 = preprocessed[d2]\n        \n        # Find the largest end time <= l1 - 1\n        # Binary search on sorted_by_end_d2's end times\n        end_times = [r for (l, r, c) in sorted_by_end_d2]\n        target = l1 - 1\n        idx_end = bisect.bisect_right(end_times, target) - 1\n        if idx_end >= 0:\n            min_cost = prefix_min_d2[idx_end]\n            if min_cost + cost1 < min_total:\n                min_total = min_cost + cost1\n        \n        # Check vouchers with duration d2 that start after r1\n        # Use the sorted_by_start_d2 and suffix_min_d2\n        start_times = [l for (l, r, c) in sorted_by_start_d2]\n        target = r1 + 1\n        idx_start = bisect.bisect_left(start_times, target)\n        if idx_start < len(start_times):\n            min_cost = suffix_min_d2[idx_start]\n            if min_cost + cost1 < min_total:\n                min_total = min_cost + cost1\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Grouping by Duration**: Vouchers are grouped by their duration to facilitate quick lookups when checking for complementary durations.\n2. **Sorting and Prefix/Suffix Arrays**: For each duration, vouchers are sorted by end time and start time. Prefix minimum arrays help find the minimum cost of vouchers ending before a certain time, while suffix minimum arrays help find the minimum cost of vouchers starting after a certain time.\n3. **Binary Search**: Efficiently find valid vouchers using binary search on sorted lists, ensuring the solution runs in O(n log n) time complexity, which is suitable for large inputs.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport bisect\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n    \n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        vouchers.append((l, r, cost))\n    \n    # Preprocess: group vouchers by duration\n    duration_dict = defaultdict(list)\n    for l, r, cost in vouchers:\n        d = r - l + 1\n        duration_dict[d].append((l, r, cost))\n    \n    # For each duration, sort by end time and create prefix min cost array\n    # Also sort by start time and create suffix min cost array\n    # We will use sorted by end time for checking vouchers ending before current start\n    # And sorted by start time for checking vouchers starting after current end\n    \n    # Preprocess data structure\n    # key: duration, value: list of (end_time, min_cost_up_to_here)\n    # and list of (start_time, min_cost_from_here)\n    preprocessed = dict()\n    for d in duration_dict:\n        lst = duration_dict[d]\n        # Sort by end time\n        sorted_by_end = sorted(lst, key=lambda x: x[1])\n        # Create prefix min cost array\n        prefix_min = []\n        min_so_far = float('inf')\n        for l, r, cost in sorted_by_end:\n            if cost < min_so_far:\n                min_so_far = cost\n            prefix_min.append(min_so_far)\n        # Sort by start time\n        sorted_by_start = sorted(lst, key=lambda x: x[0])\n        # Create suffix min cost array\n        suffix_min = [0] * len(sorted_by_start)\n        min_so_far = float('inf')\n        for i in range(len(sorted_by_start)-1, -1, -1):\n            l, r, cost = sorted_by_start[i]\n            if cost < min_so_far:\n                min_so_far = cost\n            suffix_min[i] = min_so_far\n        preprocessed[d] = (sorted_by_end, prefix_min, sorted_by_start, suffix_min)\n    \n    min_total = float('inf')\n    \n    for l1, r1, cost1 in vouchers:\n        d1 = r1 - l1 + 1\n        d2 = x - d1\n        if d2 < 1:\n            continue\n        if d2 not in duration_dict:\n            continue\n        \n        # Check vouchers with duration d2 that end before l1\n        # Use the sorted_by_end list and prefix_min\n        sorted_by_end_d2, prefix_min_d2, sorted_by_start_d2, suffix_min_d2 = preprocessed[d2]\n        \n        # Find the largest end time <= l1 - 1\n        # Binary search on sorted_by_end_d2's end times\n        end_times = [r for (l, r, c) in sorted_by_end_d2]\n        target = l1 - 1\n        idx_end = bisect.bisect_right(end_times, target) - 1\n        if idx_end >= 0:\n            min_cost = prefix_min_d2[idx_end]\n            if min_cost + cost1 < min_total:\n                min_total = min_cost + cost1\n        \n        # Check vouchers with duration d2 that start after r1\n        # Use the sorted_by_start_d2 and suffix_min_d2\n        start_times = [l for (l, r, c) in sorted_by_start_d2]\n        target = r1 + 1\n        idx_start = bisect.bisect_left(start_times, target)\n        if idx_start < len(start_times):\n            min_cost = suffix_min_d2[idx_start]\n            if min_cost + cost1 < min_total:\n                min_total = min_cost + cost1\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 739,
        "completion_token_count": 1210,
        "thoughts_token_count": 1023
    }
}