{
    "start": 1758313549.456645,
    "end": 1758313767.0369923,
    "start-formatted": "2025-09-20 05:25 KST",
    "end-formatted": "2025-09-20 05:29 KST",
    "gpu": 2,
    "pid": 6,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\nOkay, I need to solve this programming problem. Let's read the problem carefully.\n\nThe problem says that Leha wants to choose two vouchers such that their durations sum up exactly to x, and they don't overlap. And we have to find the minimal total cost of such a pair. If it's not possible, output -1.\n\nFirst, let's understand the voucher details. Each voucher has a departure day li, return day ri, and cost. The duration is ri - li + 1. So for two vouchers i and j, their durations must add up to x. Also, they must not overlap. That means either the first ends before the second starts (ri < lj) or the second ends before the first starts (rj < li).\n\nSo the approach is to find pairs of vouchers where their durations sum to x, and they are non-overlapping, then find the minimum cost among all such pairs.\n\nBut with n up to 2e5, checking all pairs would be O(n^2), which is way too slow. So we need an efficient way.\n\nLet me think about how to approach this. For each voucher, if we can find another voucher that has duration (x - duration_i), and that doesn't overlap with it, then we can check the cost.\n\nBut how to efficiently find those vouchers?\n\nLet me think about grouping vouchers by their duration. For example, for each duration d, we can store all vouchers with that duration. Then, for each voucher with duration d, we look for vouchers with duration (x - d). But even then, how do we check for non-overlapping?\n\nAlternatively, for each voucher, we can check if there exists a voucher with duration (x - d) that starts after this voucher ends, or ends before this voucher starts.\n\nBut how to find the minimal cost for such vouchers?\n\nLet me think of pre-processing. Suppose for each possible duration d, we have a list of vouchers sorted by their end time (ri), and also for each voucher, we can find the minimal cost for vouchers that end before a certain time, or start after a certain time.\n\nWait, here's an idea:\n\nFor each voucher i with duration d_i, we need to find a voucher j with duration (x - d_i). Let's say that d_i + d_j = x. So for each voucher i, we can look for vouchers j with duration (x - d_i) that end before li (so that j's ri < li) or start after ri (so that lj > ri).\n\nSo for each voucher i, we can split into two cases:\n\nCase 1: Find a voucher j that ends before li. Then, the voucher j can be any with duration (x - d_i), and ri_j < li_i.\n\nCase 2: Find a voucher j that starts after ri_i. So lj_j > ri_i, and duration (x - d_i).\n\nSo for each voucher i, we need to check both possibilities, and find the minimal cost for each case.\n\nBut how to do this efficiently?\n\nLet me think about pre-processing for each duration. Let's create a dictionary that maps duration values to some data structure. For example, for each duration d, we can have two sorted lists:\n\n- One sorted by end time (ri), and for each end time, we can track the minimal cost up to that point. So that for a given li, we can find the minimal cost of vouchers with duration d that end before li.\n\nSimilarly, another sorted list sorted by start time (li), and for each start time, track the minimal cost from that point onwards. Wait, but for case 2, we need vouchers that start after ri_i. So for vouchers with duration (x - d_i), we need the minimal cost among those with lj >= (ri_i + 1). So if we have the vouchers sorted by start time, we can find the minimal cost in the suffix starting from that point.\n\nAlternatively, for each duration d, we can have two structures:\n\n- A list sorted by ri, and for each entry, we can keep track of the minimum cost up to that position. This allows us to perform binary search for the maximum ri that is less than a certain value (like li of voucher i), and then get the minimum cost in that range.\n\nSimilarly, a list sorted by lj, and for each position, track the minimum cost from that position to the end. Then, for a given ri_i, we can find the earliest lj that is greater than ri_i, and get the minimum cost in that suffix.\n\nBut how to build these structures?\n\nLet me think for each duration d, we can collect all vouchers with that duration. Then, for each such list, we can sort them by their ri (for case 1) and by their lj (for case 2). Then, for the sorted list by ri, we can precompute a prefix minimum array. Similarly, for the sorted list by lj, we can pre",
    "response": "To solve this problem, we need to find two non-overlapping vouchers whose combined duration equals a given value `x`, and the sum of their costs is minimized. If no such pair exists, we should return -1.\n\n### Approach\n1. **Group Vouchers by Duration**: We first group all vouchers by their duration. This helps in efficiently looking up vouchers with specific durations.\n2. **Preprocessing for Efficient Queries**: For each duration, we maintain two sorted lists:\n   - One sorted by the end date (`ri`) to help find vouchers that end before a given start date.\n   - Another sorted by the start date (`li`) to help find vouchers that start after a given end date.\n3. **Prefix Minimum Arrays**: For each sorted list of vouchers by end date, we maintain a prefix minimum array to quickly find the minimum cost of vouchers ending before a certain date.\n4. **Suffix Minimum Arrays**: For each sorted list of vouchers by start date, we maintain a suffix minimum array to quickly find the minimum cost of vouchers starting after a certain date.\n\n### Solution Code\n```python\nimport sys\nimport bisect\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n\n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        r = int(input[idx+1])\n        cost = int(input[idx+2])\n        idx += 3\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n\n    # Group vouchers by duration\n    duration_map = defaultdict(list)\n    for l, r, cost, d in vouchers:\n        duration_map[d].append((l, r, cost))\n\n    # Preprocess for each duration: sorted by ri and lj, and prefix/suffix min\n    # For each duration d, we have:\n    # - sorted_ri: list of (r, l, cost), sorted by r\n    # - prefix_min: list where prefix_min[i] is min cost from 0 to i\n    # - sorted_lj: list of (l, r, cost), sorted by l\n    # - suffix_min: list where suffix_min[i] is min cost from i to end\n    preprocessed = dict()\n    for d in duration_map:\n        lst = duration_map[d]\n        # Sort by ri\n        sorted_by_ri = sorted(lst, key=lambda x: x[1])\n        prefix_min = []\n        min_cost = float('inf')\n        for item in sorted_by_ri:\n            min_cost = min(min_cost, item[2])\n            prefix_min.append(min_cost)\n        # Sort by lj\n        sorted_by_lj = sorted(lst, key=lambda x: x[0])\n        suffix_min = [0]*len(sorted_by_lj)\n        min_cost = float('inf')\n        for i in range(len(sorted_by_lj)-1, -1, -1):\n            min_cost = min(min_cost, sorted_by_lj[i][2])\n            suffix_min[i] = min_cost\n        preprocessed[d] = (sorted_by_ri, prefix_min, sorted_by_lj, suffix_min)\n\n    min_total = float('inf')\n\n    for l1, r1, cost1, d1 in vouchers:\n        target_d = x - d1\n        if target_d < 1:\n            continue\n        if target_d not in preprocessed:\n            continue\n        # Check case 1: voucher j ends before l1\n        sorted_by_ri, prefix_min, sorted_by_lj, suffix_min = preprocessed[target_d]\n        # Find the largest r_j <= l1 - 1\n        # Binary search on sorted_by_ri's r\n        left, right = 0, len(sorted_by_ri) - 1\n        best_idx = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if sorted_by_ri[mid][1] <= l1 - 1:\n                best_idx = mid\n                left = mid + 1\n            else:\n                right = mid - 1\n        if best_idx != -1:\n            min_cost = prefix_min[best_idx]\n            min_total = min(min_total, cost1 + min_cost)\n        # Check case 2: voucher j starts after r1\n        # Binary search on sorted_by_lj's l\n        sorted_by_lj = preprocessed[target_d][2]\n        suffix_min = preprocessed[target_d][3]\n        left, right = 0, len(sorted_by_lj) - 1\n        best_idx = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if sorted_by_lj[mid][0] > r1:\n                best_idx = mid\n                right = mid - 1\n            else:\n                left = mid + 1\n        if best_idx != -1:\n            min_cost = suffix_min[best_idx]\n            min_total = min(min_total, cost1 + min_cost)\n\n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Grouping by Duration**: Vouchers are grouped by their duration to facilitate efficient lookups.\n- **Binary Search for Efficient Querying**: For each voucher, we use binary search to find the best possible non-overlapping vouchers with the required duration.\n- **Prefix and Suffix Minimum Arrays**: These arrays help quickly determine the minimum cost for valid vouchers found using binary search, ensuring the solution runs efficiently even for large inputs.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport bisect\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n\n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        r = int(input[idx+1])\n        cost = int(input[idx+2])\n        idx += 3\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n\n    # Group vouchers by duration\n    duration_map = defaultdict(list)\n    for l, r, cost, d in vouchers:\n        duration_map[d].append((l, r, cost))\n\n    # Preprocess for each duration: sorted by ri and lj, and prefix/suffix min\n    # For each duration d, we have:\n    # - sorted_ri: list of (r, l, cost), sorted by r\n    # - prefix_min: list where prefix_min[i] is min cost from 0 to i\n    # - sorted_lj: list of (l, r, cost), sorted by l\n    # - suffix_min: list where suffix_min[i] is min cost from i to end\n    preprocessed = dict()\n    for d in duration_map:\n        lst = duration_map[d]\n        # Sort by ri\n        sorted_by_ri = sorted(lst, key=lambda x: x[1])\n        prefix_min = []\n        min_cost = float('inf')\n        for item in sorted_by_ri:\n            min_cost = min(min_cost, item[2])\n            prefix_min.append(min_cost)\n        # Sort by lj\n        sorted_by_lj = sorted(lst, key=lambda x: x[0])\n        suffix_min = [0]*len(sorted_by_lj)\n        min_cost = float('inf')\n        for i in range(len(sorted_by_lj)-1, -1, -1):\n            min_cost = min(min_cost, sorted_by_lj[i][2])\n            suffix_min[i] = min_cost\n        preprocessed[d] = (sorted_by_ri, prefix_min, sorted_by_lj, suffix_min)\n\n    min_total = float('inf')\n\n    for l1, r1, cost1, d1 in vouchers:\n        target_d = x - d1\n        if target_d < 1:\n            continue\n        if target_d not in preprocessed:\n            continue\n        # Check case 1: voucher j ends before l1\n        sorted_by_ri, prefix_min, sorted_by_lj, suffix_min = preprocessed[target_d]\n        # Find the largest r_j <= l1 - 1\n        # Binary search on sorted_by_ri's r\n        left, right = 0, len(sorted_by_ri) - 1\n        best_idx = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if sorted_by_ri[mid][1] <= l1 - 1:\n                best_idx = mid\n                left = mid + 1\n            else:\n                right = mid - 1\n        if best_idx != -1:\n            min_cost = prefix_min[best_idx]\n            min_total = min(min_total, cost1 + min_cost)\n        # Check case 2: voucher j starts after r1\n        # Binary search on sorted_by_lj's l\n        sorted_by_lj = preprocessed[target_d][2]\n        suffix_min = preprocessed[target_d][3]\n        left, right = 0, len(sorted_by_lj) - 1\n        best_idx = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if sorted_by_lj[mid][0] > r1:\n                best_idx = mid\n                right = mid - 1\n            else:\n                left = mid + 1\n        if best_idx != -1:\n            min_cost = suffix_min[best_idx]\n            min_total = min(min_total, cost1 + min_cost)\n\n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 741,
        "completion_token_count": 1212,
        "thoughts_token_count": 1024
    }
}