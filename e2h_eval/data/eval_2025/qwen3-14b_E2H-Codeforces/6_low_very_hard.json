{
    "start": 1758008330.2961907,
    "end": 1758008511.5014248,
    "start-formatted": "2025-09-16 16:38 KST",
    "end-formatted": "2025-09-16 16:41 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\nOkay, let's see. I need to solve this programming problem. Let's read the problem carefully again.\n\nThe problem is about finding two vouchers that don't overlap, their durations add up exactly to x, and their total cost is minimized. If there's no such pair, output -1.\n\nSo, the input is n vouchers, each with li, ri, costi. The duration is ri - li + 1. We need two vouchers i and j (i≠j) such that:\n\n- Their durations sum to x. So duration_i + duration_j = x.\n- They don't overlap. Which means either ri < lj or rj < li.\n\nAnd find the minimal sum of their costs.\n\nHmm. How to approach this?\n\nFirst, let's think about the constraints. The n can be up to 2e5, which is big. So any O(n²) approach is out of the question. Need something efficient.\n\nLet me think: for each voucher, we can check if there exists another voucher with duration equal to (x - duration_i), and that they don't overlap. But how to do this efficiently?\n\nSo, perhaps pre-process vouchers by their duration. For each possible duration d, store a list of vouchers with that duration. Then, for each voucher with duration d, look for vouchers with duration (x - d), and check if they are non-overlapping.\n\nBut even then, for each voucher, checking all vouchers with the required duration could be expensive if there are many of them. However, maybe we can find a way to find the minimal cost for vouchers that meet the non-overlapping condition.\n\nWait, but for each voucher i with duration d, we need to find vouchers j with duration (x - d) that end before li (so that rj < li) or start after ri (so that lj > ri). So for each voucher i, we can check two possibilities:\n\nCase 1: Find a voucher j with duration (x - d) that ends before li. So rj < li. So for these vouchers, their end time is less than li. So for such vouchers, the earliest possible li is the start of voucher i.\n\nCase 2: Find a voucher j with duration (x - d) that starts after ri. So lj > ri. So for these vouchers, their start time is after ri.\n\nSo for each voucher i, we can look for vouchers with duration (x - d) that are either entirely before it or entirely after it.\n\nBut how do we find the minimal cost for those vouchers?\n\nAn idea: For each duration d, we can pre-process two data structures:\n\n- One sorted list of vouchers with duration d, sorted by their end time (ri). Then, for case 1 (rj < li), we can find all vouchers with duration (x - d) that end before li. Since they are sorted by end time, we can perform a binary search to find the maximum end time less than li. Then, among those vouchers, find the one with minimal cost.\n\nSimilarly, for case 2, we can have a sorted list of vouchers with duration (x - d), sorted by their start time (lj). Then, find all vouchers where lj > ri. Again, binary search can help here to find the earliest start time greater than ri, and among those, find the minimal cost.\n\nBut how to store the minimal cost for these ranges?\n\nAlternatively, for each duration d, we can pre-process two arrays:\n\n- For vouchers with duration d, sorted by their end time. And for each position in this sorted array, keep track of the minimum cost up to that point. This way, when we want to find the minimal cost for all vouchers with end time < some value, we can binary search the latest end time that is less than the target, and then get the min cost up to that index.\n\nSimilarly, for vouchers sorted by start time, and for each position, track the minimum cost from that index onwards. Or maybe for the start time sorted list, have a prefix min array? Wait, no. For case 2, we need vouchers with lj > ri. So if we have vouchers sorted by lj, then we can find the first lj that is > ri, and then take the min cost from that index to the end.\n\nSo, for each duration d, we can have:\n\n- A list sorted by end time (ri), and a prefix min array. For example, for each voucher in the sorted list, the prefix_min[i] is the minimum cost among the first i+1 elements. Then, when we need to find all vouchers with end time < X, we can find the rightmost voucher with end time < X, and then take the prefix_min up to that index.\n\n- A list sorted by start time (lj), and a suffix min array. For example, for each voucher in the sorted list, the suffix_min[i] is the minimum cost among elements from i to end",
    "response": "\n\nTo solve this problem efficiently, we need to find two non-overlapping vouchers whose combined duration equals a given value `x` and whose total cost is minimized. The solution involves preprocessing vouchers by their duration and using binary search to efficiently find valid pairs.\n\n### Approach\n1. **Preprocessing by Duration**: Group vouchers by their duration. For each duration, maintain two sorted lists:\n   - One sorted by the end date (`ri`) for checking vouchers that end before the start of another voucher.\n   - Another sorted by the start date (`li`) for checking vouchers that start after the end of another voucher.\n\n2. **Binary Search**: For each voucher, use binary search to quickly find valid vouchers that meet the non-overlapping criteria and have the required complementary duration. This helps in efficiently finding the minimum cost for valid pairs.\n\n3. **Prefix and Suffix Minimum Arrays**: Maintain prefix minimum arrays for the end-sorted lists and suffix minimum arrays for the start-sorted lists to quickly determine the minimum cost of valid vouchers.\n\n### Solution Code\n```python\nimport sys\nimport bisect\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n    \n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n    \n    from collections import defaultdict\n\n    # Preprocess: for each duration d, store two lists:\n    # one sorted by end time (r), and another sorted by start time (l)\n    # Also, for each list, precompute prefix min and suffix min\n    duration_dict = defaultdict(lambda: {'end_sorted': [], 'start_sorted': []})\n    for l, r, cost, d in vouchers:\n        duration_dict[d]['end_sorted'].append((r, cost))\n        duration_dict[d]['start_sorted'].append((l, cost))\n    \n    # Precompute prefix min for end_sorted lists\n    # And suffix min for start_sorted lists\n    for d in duration_dict:\n        end_list = duration_dict[d]['end_sorted']\n        end_list.sort()\n        # Create prefix_min array\n        prefix_min = []\n        min_so_far = float('inf')\n        for r, cost in end_list:\n            if cost < min_so_far:\n                min_so_far = cost\n            prefix_min.append(min_so_far)\n        duration_dict[d]['end_prefix_min'] = prefix_min\n        \n        start_list = duration_dict[d]['start_sorted']\n        start_list.sort()\n        # Create suffix_min array\n        suffix_min = [0] * len(start_list)\n        min_so_far = float('inf')\n        for i in reversed(range(len(start_list))):\n            l, cost = start_list[i]\n            if cost < min_so_far:\n                min_so_far = cost\n            suffix_min[i] = min_so_far\n        duration_dict[d]['start_suffix_min'] = suffix_min\n\n    min_total = float('inf')\n\n    for l1, r1, cost1, d1 in vouchers:\n        required_d = x - d1\n        if required_d < 1:\n            continue\n        if required_d not in duration_dict:\n            continue\n        # Check for vouchers with duration required_d that end before l1\n        end_sorted = duration_dict[required_d]['end_sorted']\n        end_prefix_min = duration_dict[required_d]['end_prefix_min']\n        # Find the largest rj < l1\n        # end_sorted is sorted by r\n        pos = bisect.bisect_left(end_sorted, (l1, 0)) - 1\n        if pos >= 0:\n            current_min = end_prefix_min[pos]\n            min_total = min(min_total, cost1 + current_min)\n        # Check for vouchers with duration required_d that start after r1\n        start_sorted = duration_dict[required_d]['start_sorted']\n        start_suffix_min = duration_dict[required_d]['start_suffix_min']\n        # Find the first lj > r1\n        pos = bisect.bisect_right(start_sorted, (r1, float('inf')))\n        if pos < len(start_sorted):\n            current_min = start_suffix_min[pos]\n            min_total = min(min_total, cost1 + current_min)\n\n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Preprocessing**: Vouchers are grouped by their duration. For each duration, we maintain sorted lists of vouchers based on their end and start times.\n- **Binary Search**: For each voucher, we use binary search to efficiently find valid vouchers that either end before or start after the current voucher, ensuring they do not overlap.\n- **Prefix and Suffix Minimum Arrays**: These arrays help quickly determine the minimum cost of valid vouchers found using binary search, ensuring the solution is efficient even for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport bisect\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    x = int(input[idx])\n    idx += 1\n    \n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        idx += 1\n        r = int(input[idx])\n        idx += 1\n        cost = int(input[idx])\n        idx += 1\n        duration = r - l + 1\n        vouchers.append((l, r, cost, duration))\n    \n    from collections import defaultdict\n\n    # Preprocess: for each duration d, store two lists:\n    # one sorted by end time (r), and another sorted by start time (l)\n    # Also, for each list, precompute prefix min and suffix min\n    duration_dict = defaultdict(lambda: {'end_sorted': [], 'start_sorted': []})\n    for l, r, cost, d in vouchers:\n        duration_dict[d]['end_sorted'].append((r, cost))\n        duration_dict[d]['start_sorted'].append((l, cost))\n    \n    # Precompute prefix min for end_sorted lists\n    # And suffix min for start_sorted lists\n    for d in duration_dict:\n        end_list = duration_dict[d]['end_sorted']\n        end_list.sort()\n        # Create prefix_min array\n        prefix_min = []\n        min_so_far = float('inf')\n        for r, cost in end_list:\n            if cost < min_so_far:\n                min_so_far = cost\n            prefix_min.append(min_so_far)\n        duration_dict[d]['end_prefix_min'] = prefix_min\n        \n        start_list = duration_dict[d]['start_sorted']\n        start_list.sort()\n        # Create suffix_min array\n        suffix_min = [0] * len(start_list)\n        min_so_far = float('inf')\n        for i in reversed(range(len(start_list))):\n            l, cost = start_list[i]\n            if cost < min_so_far:\n                min_so_far = cost\n            suffix_min[i] = min_so_far\n        duration_dict[d]['start_suffix_min'] = suffix_min\n\n    min_total = float('inf')\n\n    for l1, r1, cost1, d1 in vouchers:\n        required_d = x - d1\n        if required_d < 1:\n            continue\n        if required_d not in duration_dict:\n            continue\n        # Check for vouchers with duration required_d that end before l1\n        end_sorted = duration_dict[required_d]['end_sorted']\n        end_prefix_min = duration_dict[required_d]['end_prefix_min']\n        # Find the largest rj < l1\n        # end_sorted is sorted by r\n        pos = bisect.bisect_left(end_sorted, (l1, 0)) - 1\n        if pos >= 0:\n            current_min = end_prefix_min[pos]\n            min_total = min(min_total, cost1 + current_min)\n        # Check for vouchers with duration required_d that start after r1\n        start_sorted = duration_dict[required_d]['start_sorted']\n        start_suffix_min = duration_dict[required_d]['start_suffix_min']\n        # Find the first lj > r1\n        pos = bisect.bisect_right(start_sorted, (r1, float('inf')))\n        if pos < len(start_sorted):\n            current_min = start_suffix_min[pos]\n            min_total = min(min_total, cost1 + current_min)\n\n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 740,
        "completion_token_count": 1081,
        "thoughts_token_count": 1023
    }
}