{
    "start": 1758309735.2484643,
    "end": 1758309776.9571142,
    "start-formatted": "2025-09-20 04:22 KST",
    "end-formatted": "2025-09-20 04:22 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\nOkay, let's try to figure out how to solve this problem. The task is to find the minimum number of edges to add to form an odd-length cycle, and the number of ways to do that. Hmm.\n\nFirst, I remember that a graph is bipartite if and only if it doesn't contain any odd-length cycles. So, if the graph already has an odd-length cycle, then t would be 0 because we don't need to add any edges. But if the graph is bipartite, then we need to add edges to create an odd cycle.\n\nSo the first thing I need to check is whether the graph already contains an odd-length cycle. If yes, then the answer is t=0 and w=1? Wait, no. Wait, the problem says that the existing graph might have multiple such cycles, but the question is about the minimum number of edges to add. If there's already an odd cycle, then t is zero. But the w is the number of ways to add zero edges. But since the existing graph already has at least one such cycle, but how many ways are there? Well, the problem says that the answer for w is the number of ways to add t edges. Since t is zero, it's the number of existing odd cycles? No, no. Wait, the problem says that when you add t edges (which is zero in this case), you need to form a cycle of odd length. But if the graph already has such cycles, then any of those existing cycles would count as valid. However, the problem says that the answer w is the number of ways to add t edges to form such a cycle. But adding zero edges would mean that the existing cycles are already there. However, the problem says that the answer is the number of ways to add edges. But if the graph already has an odd cycle, then there are multiple possible ways (each existing odd cycle counts as a way?), but according to the sample input, when the input is a triangle (3 nodes connected in a cycle), the output is 0 1. Because adding zero edges gives exactly one way (the existing cycle). But if there are multiple existing cycles, like two separate triangles, then the answer would be 0 and the number of ways would be the number of existing odd cycles? Or maybe not. Wait, the problem says that the ways are considered equal if they have the same set of added edges. But when t=0, the added edges are none. So the number of ways is 1 if there's at least one existing cycle. Because adding zero edges is one way, regardless of how many existing cycles there are. Wait, no. Because the problem says that the way is to add edges such that the resulting graph has a cycle. But if there are multiple existing cycles, but the way of adding zero edges is just one way. Because the way is determined by the edges added. Since adding zero edges is one way, regardless of how many existing cycles there are. Wait, the problem says that the output w is the number of ways to add t edges to form a cycle. So if the graph already has a cycle, then adding zero edges is the only way (since t is zero). But the problem says that the answer for the second sample input is 0 1. Let me check that sample input. The second input is a triangle (3 nodes connected as a cycle). So the output is 0 1. Which suggests that even though there's exactly one cycle, the answer is 1. So perhaps the w is 1 if there's already an odd cycle. But how?\n\nWait, the problem says that the way to add edges must form a cycle. So if the original graph already contains an odd cycle, then adding zero edges is the way. However, the problem says that the answer w is the number of ways to add t edges. But adding zero edges can be done in exactly one way. Because the way is determined by the set of edges added. So regardless of how many existing cycles there are, the number of ways is 1. Because the way is to add zero edges. But that seems conflicting with the sample input. Wait, in the second sample input, the graph is a triangle. So the output is 0 1. Which matches this idea. So in this case, even though there's exactly one cycle, the answer is 1. So for the case where the graph already contains an odd cycle, the answer is t=0 and w=1. So that's the first case.\n\nSo the first step is to check if the graph already has an odd-length cycle. If yes, then output t=0 and w=1.\n\nIf not, then the graph is bipartite. Because a graph is bipartite if and only if it has no odd-length cycles. So, in this case, we need to add edges to create an odd-length cycle.\n\nNow, how to do that? Well, in",
    "response": "To solve this problem, we need to determine the minimum number of edges to add to a given undirected graph to form an odd-length cycle and the number of ways to achieve this. The solution leverages properties of bipartite graphs, as a graph is bipartite if and only if it contains no odd-length cycles.\n\n### Approach\n1. **Check for Existing Odd Cycles**: If the graph already contains an odd-length cycle, the answer is trivial: `t = 0` and `w = 1`.\n2. **Bipartite Graph Check**: If the graph is bipartite (no odd cycles), we need to determine the minimum number of edges to add to create an odd cycle.\n3. **Component Analysis**: For each connected component of the graph, determine the number of vertices in each partition (using BFS/DFS). The minimum number of edges required to form an odd cycle in a bipartite graph is determined by the size of the smaller partition.\n4. **Calculate Minimum Edges and Ways**: The minimum number of edges required to form an odd cycle from a bipartite graph is 1, and the number of ways is the product of the sizes of the two partitions in each component.\n\n### Solution Code\n```python\nimport sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        u = int(input[idx]) - 1\n        idx += 1\n        v = int(input[idx]) - 1\n        idx += 1\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # Check if the graph has any odd-length cycle\n    color = [-1] * n\n    is_bipartite = True\n\n    def bfs(start):\n        nonlocal is_bipartite\n        queue = deque()\n        queue.append(start)\n        color[start] = 0\n        while queue:\n            u = queue.popleft()\n            for v in graph[u]:\n                if color[v] == -1:\n                    color[v] = color[u] ^ 1\n                    queue.append(v)\n                else:\n                    if color[v] == color[u]:\n                        is_bipartite = False\n                        return\n\n    for i in range(n):\n        if color[i] == -1:\n            bfs(i)\n            if not is_bipartite:\n                break\n\n    if not is_bipartite:\n        print(\"0 1\")\n        return\n\n    # Now the graph is bipartite, need to find the minimum edges to add\n    # For each component, count the size of each partition\n    visited = [False] * n\n    components = []\n\n    for i in range(n):\n        if not visited[i]:\n            queue = deque()\n            queue.append(i)\n            visited[i] = True\n            cnt0 = 0\n            cnt1 = 0\n            if color[i] == 0:\n                cnt0 += 1\n            else:\n                cnt1 += 1\n            while queue:\n                u = queue.popleft()\n                for v in graph[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        if color[v] == 0:\n                            cnt0 += 1\n                        else:\n                            cnt1 += 1\n                        queue.append(v)\n            components.append((cnt0, cnt1))\n\n    # Calculate the minimum t and w\n    t = 1\n    w = 1\n    for c0, c1 in components:\n        w *= (c0 * c1)\n    print(f\"{t} {w}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Bipartite Check**: We use BFS to check if the graph is bipartite. If during BFS we find an edge connecting two nodes of the same color, the graph contains an odd-length cycle.\n2. **Component Analysis**: For each connected component of the graph, we count the number of nodes in each partition (color group).\n3. **Minimum Edges Calculation**: If the graph is bipartite, the minimum number of edges needed to form an odd cycle is 1. The number of ways to do this is the product of the sizes of the two partitions in each component, as adding an edge between nodes of the same partition creates an odd cycle.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        u = int(input[idx]) - 1\n        idx += 1\n        v = int(input[idx]) - 1\n        idx += 1\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # Check if the graph has any odd-length cycle\n    color = [-1] * n\n    is_bipartite = True\n\n    def bfs(start):\n        nonlocal is_bipartite\n        queue = deque()\n        queue.append(start)\n        color[start] = 0\n        while queue:\n            u = queue.popleft()\n            for v in graph[u]:\n                if color[v] == -1:\n                    color[v] = color[u] ^ 1\n                    queue.append(v)\n                else:\n                    if color[v] == color[u]:\n                        is_bipartite = False\n                        return\n\n    for i in range(n):\n        if color[i] == -1:\n            bfs(i)\n            if not is_bipartite:\n                break\n\n    if not is_bipartite:\n        print(\"0 1\")\n        return\n\n    # Now the graph is bipartite, need to find the minimum edges to add\n    # For each component, count the size of each partition\n    visited = [False] * n\n    components = []\n\n    for i in range(n):\n        if not visited[i]:\n            queue = deque()\n            queue.append(i)\n            visited[i] = True\n            cnt0 = 0\n            cnt1 = 0\n            if color[i] == 0:\n                cnt0 += 1\n            else:\n                cnt1 += 1\n            while queue:\n                u = queue.popleft()\n                for v in graph[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        if color[v] == 0:\n                            cnt0 += 1\n                        else:\n                            cnt1 += 1\n                        queue.append(v)\n            components.append((cnt0, cnt1))\n\n    # Calculate the minimum t and w\n    t = 1\n    w = 1\n    for c0, c1 in components:\n        w *= (c0 * c1)\n    print(f\"{t} {w}\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 579,
        "completion_token_count": 949,
        "thoughts_token_count": 1024
    }
}