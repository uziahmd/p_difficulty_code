{
    "start": 1758009297.4238713,
    "end": 1758009661.5853267,
    "start-formatted": "2025-09-16 16:54 KST",
    "end-formatted": "2025-09-16 17:01 KST",
    "gpu": 2,
    "pid": 9,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Selling Souvenirs\n\nAfter several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.This morning, as usual, Petya will come to the market. Petya has n different souvenirs to sell; ith souvenir is characterised by its weight wi and cost ci. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than m, and total cost is maximum possible.Help Petya to determine maximum possible total cost.\n\n## Input\nThe first line contains two integers n and m (1 ≤ n ≤ 100000, 1 ≤ m ≤ 300000) — the number of Petya's souvenirs and total weight that he can carry to the market.Then n lines follow. ith line contains two integers wi and ci (1 ≤ wi ≤ 3, 1 ≤ ci ≤ 109) — the weight and the cost of ith souvenir.\n\n## Output\nPrint one number — maximum possible total cost of souvenirs that Petya can carry to the market.\n\n## Example\n### Input\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\n### Output\n['0', '3', '10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\nOkay, let's see. I need to solve this problem where Petya wants to maximize the total cost of souvenirs he can carry, given that each souvenir has a weight (either 1, 2, or 3) and a cost. The constraints are n up to 1e5 and m up to 3e5. So, a standard knapsack approach won't work here because the m is too big for O(nm) time.\n\nHmm, right. Since the weights are limited to 1, 2, or 3, maybe there's a way to optimize based on that. Let me think about how to handle each weight category separately.\n\nFirst, for items with weight 1, 2, 3. For each weight group, we can sort them in descending order of cost. Then, for each group, we can precompute the prefix sums. That way, when we have to choose how many items to take from each group, we can quickly calculate the total cost.\n\nBut how do we combine these groups optimally? Because taking some items from weight 1 and 2 might affect how many we can take from the others.\n\nLet me think. Let's suppose we have all items sorted by their cost per unit weight. But since the weight is fixed, maybe for each weight group, we sort them in descending order of cost, then compute the prefix sum.\n\nThen, for each possible number of weight 1 items taken, we can calculate the remaining capacity and see how many weight 2 and 3 items can be taken. But even that seems computationally heavy if done naively.\n\nWait, but maybe we can iterate through the possible number of weight 3 items and then handle the rest with weight 1 and 2. Or perhaps find a way to combine weight 1 and 2 items efficiently.\n\nAnother idea: since the weight is small (only 1,2,3), we can process each group and for each possible total weight, find the maximum value. However, since m can be up to 3e5, maybe we can use a dynamic programming approach that's optimized for these small weights.\n\nAlternatively, here's a plan:\n\n1. Separate the items into three groups: w=1, w=2, w=3.\n\n2. Sort each group in descending order of cost. Then, compute prefix sums for each group. For example, for group 1, prefix_sum_1[i] is the sum of the first i items' costs.\n\n3. Now, the problem becomes choosing how many items to take from each group such that the total weight is <= m, and the total cost is maximized.\n\nBut how to combine these choices?\n\nLet's consider that for each possible number of weight 3 items taken (let's say k), we can compute how much weight is left, then compute the optimal selection of weight 1 and 2 items for that remaining weight. But even that could be O(m) in the worst case, but maybe manageable.\n\nBut considering that for weight 3, the maximum number of items is floor(m/3). If m is up to 3e5, then that's 1e5 steps. For each of those steps, we need to compute the best combination of weight 1 and 2 items. How can that be done efficiently?\n\nFor the weight 1 and 2 items, perhaps we can precompute for all possible total weights up to m. But again, with m being 3e5, that's possible.\n\nWait, but maybe there's a smarter way. Let's think about the weight 1 and 2 items. Suppose we have a total available weight of 'rem'. We need to select some number of weight 1 and 2 items to maximize the cost. How to compute that quickly?\n\nThis is similar to the classic unbounded knapsack problem, but with items of two types. But since we have a fixed number of items for each weight (since they are sorted and we can take any number up to the count available), perhaps we can find an optimal way to choose between the two.\n\nLet me think. Let's say we have for weight 1, a list of prefix sums. Similarly for weight 2. For a given rem, how to choose x items of weight 1 and y items of weight 2 such that x + 2y ≤ rem. We want to maximize (sum1[x] + sum2[y]).\n\nBut how to compute this quickly?\n\nAn alternative approach is to iterate over the number of weight 2 items taken, and compute how many weight 1 items can be taken with the remaining weight. But again, for each possible rem, this would take O(k) steps where k is the number of weight 2 items. Which could be expensive if done naively.\n\nBut maybe for the weight 1 and 2 items, we can precompute for all possible total weights up to m. However, with m up",
    "response": "\n\nTo solve this problem efficiently, we leverage the fact that each souvenir has a weight of either 1, 2, or 3. This allows us to optimize the solution by grouping items by their weights and using prefix sums to quickly calculate the maximum cost for any number of items taken from each group.\n\n### Approach\n1. **Group Items by Weight**: Separate the souvenirs into three groups based on their weights (1, 2, 3).\n2. **Sort and Compute Prefix Sums**: For each group, sort the items in descending order of cost and compute prefix sums to quickly determine the total cost of taking the first `k` items.\n3. **Iterate Over Possible Counts of Weight 3 Items**: For each possible number of weight 3 items that can be taken, compute the remaining capacity and then determine the optimal combination of weight 1 and 2 items that fit within the remaining capacity.\n4. **Optimize Weight 1 and 2 Items**: For the remaining capacity after considering weight 3 items, use a two-pointer technique to find the optimal combination of weight 1 and 2 items.\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n    \n    w1 = []\n    w2 = []\n    w3 = []\n    \n    for _ in range(n):\n        wi = int(input[idx])\n        idx += 1\n        ci = int(input[idx])\n        idx += 1\n        if wi == 1:\n            w1.append(ci)\n        elif wi == 2:\n            w2.append(ci)\n        else:\n            w3.append(ci)\n    \n    # Sort and compute prefix sums\n    w1.sort(reverse=True)\n    w2.sort(reverse=True)\n    w3.sort(reverse=True)\n    \n    prefix1 = [0]\n    for c in w1:\n        prefix1.append(prefix1[-1] + c)\n    \n    prefix2 = [0]\n    for c in w2:\n        prefix2.append(prefix2[-1] + c)\n    \n    prefix3 = [0]\n    for c in w3:\n        prefix3.append(prefix3[-1] + c)\n    \n    max_total = 0\n    len1 = len(prefix1)\n    len2 = len(prefix2)\n    len3 = len(prefix3)\n    \n    # Iterate over possible number of weight 3 items\n    for k3 in range(len3):\n        weight_used = k3 * 3\n        if weight_used > m:\n            break\n        rem = m - weight_used\n        # Now find best combination of w1 and w2 with total weight <= rem\n        # Use two pointers approach\n        i = len1 - 1\n        j = len2 - 1\n        best = 0\n        while i >= 0 and j >= 0:\n            weight = i + 2 * j\n            if weight <= rem:\n                current = prefix1[i+1] + prefix2[j+1]\n                if current > best:\n                    best = current\n                i -= 1\n            else:\n                j -= 1\n        # Also check cases where only w1 or only w2 are used\n        # Check all possible i for w1\n        max_i = min(rem, len1 - 1)\n        if max_i >= 0:\n            current = prefix1[max_i + 1]\n            if current > best:\n                best = current\n        # Check all possible j for w2\n        max_j = min(rem // 2, len2 - 1)\n        if max_j >= 0:\n            current = prefix2[max_j + 1]\n            if current > best:\n                best = current\n        total = prefix3[k3 + 1] + best\n        if total > max_total:\n            max_total = total\n    \n    print(max_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Grouping and Sorting**: Items are grouped by their weights and sorted in descending order of cost to prioritize higher-value items.\n- **Prefix Sums**: Prefix sums allow quick calculation of the total cost for any number of items taken from each group.\n- **Two-Pointer Technique**: Used to efficiently find the optimal combination of weight 1 and 2 items for the remaining capacity after considering weight 3 items. This ensures the solution is efficient even for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n    \n    w1 = []\n    w2 = []\n    w3 = []\n    \n    for _ in range(n):\n        wi = int(input[idx])\n        idx += 1\n        ci = int(input[idx])\n        idx += 1\n        if wi == 1:\n            w1.append(ci)\n        elif wi == 2:\n            w2.append(ci)\n        else:\n            w3.append(ci)\n    \n    # Sort and compute prefix sums\n    w1.sort(reverse=True)\n    w2.sort(reverse=True)\n    w3.sort(reverse=True)\n    \n    prefix1 = [0]\n    for c in w1:\n        prefix1.append(prefix1[-1] + c)\n    \n    prefix2 = [0]\n    for c in w2:\n        prefix2.append(prefix2[-1] + c)\n    \n    prefix3 = [0]\n    for c in w3:\n        prefix3.append(prefix3[-1] + c)\n    \n    max_total = 0\n    len1 = len(prefix1)\n    len2 = len(prefix2)\n    len3 = len(prefix3)\n    \n    # Iterate over possible number of weight 3 items\n    for k3 in range(len3):\n        weight_used = k3 * 3\n        if weight_used > m:\n            break\n        rem = m - weight_used\n        # Now find best combination of w1 and w2 with total weight <= rem\n        # Use two pointers approach\n        i = len1 - 1\n        j = len2 - 1\n        best = 0\n        while i >= 0 and j >= 0:\n            weight = i + 2 * j\n            if weight <= rem:\n                current = prefix1[i+1] + prefix2[j+1]\n                if current > best:\n                    best = current\n                i -= 1\n            else:\n                j -= 1\n        # Also check cases where only w1 or only w2 are used\n        # Check all possible i for w1\n        max_i = min(rem, len1 - 1)\n        if max_i >= 0:\n            current = prefix1[max_i + 1]\n            if current > best:\n                best = current\n        # Check all possible j for w2\n        max_j = min(rem // 2, len2 - 1)\n        if max_j >= 0:\n            current = prefix2[max_j + 1]\n            if current > best:\n                best = current\n        total = prefix3[k3 + 1] + best\n        if total > max_total:\n            max_total = total\n    \n    print(max_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 481,
        "completion_token_count": 958,
        "thoughts_token_count": 1023
    }
}