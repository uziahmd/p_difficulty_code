{
    "start": 1758314764.1205726,
    "end": 1758314807.8187041,
    "start-formatted": "2025-09-20 05:46 KST",
    "end-formatted": "2025-09-20 05:46 KST",
    "gpu": 2,
    "pid": 9,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Selling Souvenirs\n\nAfter several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.This morning, as usual, Petya will come to the market. Petya has n different souvenirs to sell; ith souvenir is characterised by its weight wi and cost ci. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than m, and total cost is maximum possible.Help Petya to determine maximum possible total cost.\n\n## Input\nThe first line contains two integers n and m (1 ≤ n ≤ 100000, 1 ≤ m ≤ 300000) — the number of Petya's souvenirs and total weight that he can carry to the market.Then n lines follow. ith line contains two integers wi and ci (1 ≤ wi ≤ 3, 1 ≤ ci ≤ 109) — the weight and the cost of ith souvenir.\n\n## Output\nPrint one number — maximum possible total cost of souvenirs that Petya can carry to the market.\n\n## Example\n### Input\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\n### Output\n['0', '3', '10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\nOkay, let's see. I need to solve this problem where Petya wants to maximize the total cost of souvenirs he can carry, given that each souvenir has a weight (1, 2, or 3) and a cost. The constraints are n up to 1e5 and m up to 3e5. So a standard knapsack approach won't work here because the m is too big for O(nm) time.\n\nHmm. Since the weights are limited to 1, 2, or 3, maybe there's a way to optimize based on that. Let me think. For each weight category, we can sort the items in descending order of cost per unit weight. Then, for each weight type, we can take as many as possible of the highest value items first.\n\nBut how do we combine these? Because taking some items of weight 1, 2, or 3 might have different trade-offs. For example, maybe taking a few weight 3 items gives more value than taking multiple weight 1 or 2 items.\n\nWait, but since the weights are small, maybe we can handle each weight group separately. Let's think about grouping all items by their weight. For each group, we can sort them in descending order of cost. Then, for each group, we can precompute the prefix sums so that for any number of items taken from that group, we can quickly compute the total cost.\n\nOnce we have those prefix sums, the problem becomes choosing how many items to take from each group (with their respective weights) such that the total weight does not exceed m, and the sum of their costs is maximized.\n\nBut how to combine these choices efficiently?\n\nLet me think: since there are three weight groups (1, 2, 3), perhaps we can iterate over the number of items taken from one group, say group 3, and then for each possible number of group 3 items, compute the remaining weight and then find the optimal combination of group 1 and 2 items.\n\nBut even that might be computationally heavy if done naively. However, since the weight is small, perhaps we can find an efficient way.\n\nAlternatively, considering that the maximum number of items in each group is limited. For example, for group 1, the maximum number of items that can be taken is m (since each item has weight 1). But m can be up to 3e5, which is still a lot.\n\nBut perhaps we can precompute the best possible for group 1 and group 2, then combine them with group 3. Let me think:\n\nFor group 1, after sorting, the best is to take as many as possible of the highest cost items. Similarly for group 2 and 3.\n\nBut when combining, for example, if we take x items from group 3, then we have some remaining weight left. Then, for that remaining weight, we can take the best combination of group 1 and 2 items.\n\nBut how to compute that efficiently?\n\nAnother idea: since group 1 and group 2 can be combined optimally for any given weight capacity. Let's think of it as a knapsack problem with items of weight 1 and 2. However, since the items are sorted and we can take as many as possible of the highest value items, maybe there's a way to compute the best possible for each possible weight.\n\nWait, but for group 1 and 2, the optimal selection for a given capacity can be determined by considering the prefix sums for group 1 and group 2. Let's say we have a total capacity of W. How to choose between group 1 and group 2 items?\n\nFor example, for group 1, we can take up to k items (each of weight 1) and for group 2, up to l items (each of weight 2). The total weight is k + 2l <= W. We want to maximize the sum of their prefix sums.\n\nBut how to compute this for all possible W?\n\nAlternatively, for group 1 and 2, we can precompute for each possible weight up to m, the maximum value possible using only those two groups. Then, when considering group 3, we can take some number of group 3 items (each of weight 3), and then look up the precomputed value for the remaining weight.\n\nBut with m up to 3e5, and group 3 items possibly up to m/3 items, this could be feasible.\n\nSo here's a plan:\n\n1. Split the items into three groups: w=1, w=2, w=3.\n\n2. Sort each group in descending order of cost. Then compute prefix sums for each group.\n\n   For example, for group 1, prefix_sum_1[i] is the sum of the first i items. Similarly for group 2 and 3.\n\n3. For the group 1 and 2, we can",
    "response": "To solve this problem efficiently, we need to maximize the total cost of souvenirs Petya can carry, given that each souvenir has a weight of either 1, 2, or 3. The constraints are large, so we need an optimized approach leveraging the small range of weights.\n\n### Approach\n1. **Group Items by Weight**: Separate the souvenirs into three groups based on their weights (1, 2, and 3).\n2. **Sort and Prefix Sums**: For each group, sort the items in descending order of cost and compute prefix sums to quickly determine the maximum value for any number of items taken from that group.\n3. **Dynamic Programming for Groups 1 and 2**: Use dynamic programming to precompute the maximum value achievable for each possible weight using only items of weight 1 and 2.\n4. **Combine with Group 3**: For each possible number of items taken from the group with weight 3, use the precomputed values from the dynamic programming array to find the optimal combination of remaining weight capacity using items from groups 1 and 2.\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n\n    w1 = []\n    w2 = []\n    w3 = []\n\n    for _ in range(n):\n        wi = int(input[idx])\n        idx += 1\n        ci = int(input[idx])\n        idx += 1\n        if wi == 1:\n            w1.append(ci)\n        elif wi == 2:\n            w2.append(ci)\n        else:\n            w3.append(ci)\n\n    # Sort each group in descending order\n    w1.sort(reverse=True)\n    w2.sort(reverse=True)\n    w3.sort(reverse=True)\n\n    # Compute prefix sums for each group\n    prefix1 = [0]\n    for c in w1:\n        prefix1.append(prefix1[-1] + c)\n\n    prefix2 = [0]\n    for c in w2:\n        prefix2.append(prefix2[-1] + c)\n\n    prefix3 = [0]\n    for c in w3:\n        prefix3.append(prefix3[-1] + c)\n\n    # Now compute dp for group 1 and 2\n    max_weight = m\n    # dp[i] is the maximum value for weight i using group1 and group2\n    dp = [0] * (max_weight + 1)\n\n    # For group 1, we can take up to len(w1) items\n    # For group 2, we can take up to len(w2) items\n    # We can compute dp as follows:\n    # For each possible weight, consider taking some items from group1 and group2\n\n    # First, fill dp using group1 and group2\n    # We can use a two-pointer approach for group1 and group2\n    # Alternatively, for each possible number of group2 items, compute the best for group1\n\n    # Let's iterate over all possible number of group2 items\n    max_g2 = min(len(w2), m // 2)\n    for k in range(0, max_g2 + 1):\n        weight_used = k * 2\n        if weight_used > m:\n            continue\n        val = prefix2[k]\n        # Now for the remaining weight (m - weight_used), take as many group1 items as possible\n        rem = m - weight_used\n        take = min(len(w1), rem)\n        val += prefix1[take]\n        if val > dp[weight_used]:\n            dp[weight_used] = val\n\n    # Now, for each possible number of group3 items, compute the best\n    max_g3 = min(len(w3), m // 3)\n    res = 0\n    for k in range(0, max_g3 + 1):\n        weight_used = k * 3\n        if weight_used > m:\n            continue\n        val = prefix3[k]\n        rem = m - weight_used\n        if rem >= 0:\n            val += dp[rem]\n            if val > res:\n                res = val\n    print(res)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Grouping and Sorting**: Items are grouped by their weights and sorted to prioritize higher-value items.\n2. **Prefix Sums**: Prefix sums for each group allow quick calculation of the total value for any number of items taken from that group.\n3. **Dynamic Programming**: A dynamic programming array `dp` is used to precompute the maximum value for each weight capacity using only items of weight 1 and 2.\n4. **Combining Groups**: For each possible number of items taken from the weight 3 group, the remaining capacity is checked against the precomputed `dp` array to find the optimal combination of items from groups 1 and 2, ensuring the solution is efficient even for large inputs.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n\n    w1 = []\n    w2 = []\n    w3 = []\n\n    for _ in range(n):\n        wi = int(input[idx])\n        idx += 1\n        ci = int(input[idx])\n        idx += 1\n        if wi == 1:\n            w1.append(ci)\n        elif wi == 2:\n            w2.append(ci)\n        else:\n            w3.append(ci)\n\n    # Sort each group in descending order\n    w1.sort(reverse=True)\n    w2.sort(reverse=True)\n    w3.sort(reverse=True)\n\n    # Compute prefix sums for each group\n    prefix1 = [0]\n    for c in w1:\n        prefix1.append(prefix1[-1] + c)\n\n    prefix2 = [0]\n    for c in w2:\n        prefix2.append(prefix2[-1] + c)\n\n    prefix3 = [0]\n    for c in w3:\n        prefix3.append(prefix3[-1] + c)\n\n    # Now compute dp for group 1 and 2\n    max_weight = m\n    # dp[i] is the maximum value for weight i using group1 and group2\n    dp = [0] * (max_weight + 1)\n\n    # For group 1, we can take up to len(w1) items\n    # For group 2, we can take up to len(w2) items\n    # We can compute dp as follows:\n    # For each possible weight, consider taking some items from group1 and group2\n\n    # First, fill dp using group1 and group2\n    # We can use a two-pointer approach for group1 and group2\n    # Alternatively, for each possible number of group2 items, compute the best for group1\n\n    # Let's iterate over all possible number of group2 items\n    max_g2 = min(len(w2), m // 2)\n    for k in range(0, max_g2 + 1):\n        weight_used = k * 2\n        if weight_used > m:\n            continue\n        val = prefix2[k]\n        # Now for the remaining weight (m - weight_used), take as many group1 items as possible\n        rem = m - weight_used\n        take = min(len(w1), rem)\n        val += prefix1[take]\n        if val > dp[weight_used]:\n            dp[weight_used] = val\n\n    # Now, for each possible number of group3 items, compute the best\n    max_g3 = min(len(w3), m // 3)\n    res = 0\n    for k in range(0, max_g3 + 1):\n        weight_used = k * 3\n        if weight_used > m:\n            continue\n        val = prefix3[k]\n        rem = m - weight_used\n        if rem >= 0:\n            val += dp[rem]\n            if val > res:\n                res = val\n    print(res)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 482,
        "completion_token_count": 1062,
        "thoughts_token_count": 1024
    }
}