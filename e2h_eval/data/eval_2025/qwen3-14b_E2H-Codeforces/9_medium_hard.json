{
    "start": 1758021742.124772,
    "end": 1758024301.566491,
    "start-formatted": "2025-09-16 20:22 KST",
    "end-formatted": "2025-09-16 21:05 KST",
    "gpu": 2,
    "pid": 9,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Selling Souvenirs\n\nAfter several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.This morning, as usual, Petya will come to the market. Petya has n different souvenirs to sell; ith souvenir is characterised by its weight wi and cost ci. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than m, and total cost is maximum possible.Help Petya to determine maximum possible total cost.\n\n## Input\nThe first line contains two integers n and m (1 ≤ n ≤ 100000, 1 ≤ m ≤ 300000) — the number of Petya's souvenirs and total weight that he can carry to the market.Then n lines follow. ith line contains two integers wi and ci (1 ≤ wi ≤ 3, 1 ≤ ci ≤ 109) — the weight and the cost of ith souvenir.\n\n## Output\nPrint one number — maximum possible total cost of souvenirs that Petya can carry to the market.\n\n## Example\n### Input\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\n### Output\n['0', '3', '10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\nOkay, let's see. I need to solve this problem where Petya wants to maximize the total cost of souvenirs he can carry, given that each souvenir has a weight (either 1, 2, or 3) and a cost. The constraints are n up to 1e5 and m up to 3e5. So, a standard knapsack approach won't work here because the m is too big for O(nm) time.\n\nHmm, right. Since the weights are limited to 1, 2, or 3, maybe there's a way to optimize based on that. Let me think about how to handle each weight category separately.\n\nFirst, for items with weight 1, 2, 3. For each weight group, we can sort them in descending order of cost. Then, for each group, we can precompute the prefix sums. That way, when we have to choose how many items to take from each group, we can quickly calculate the total cost.\n\nBut how do we combine these groups optimally? Let's think about it. Suppose we have all items sorted by weight. For each possible number of weight 1 items taken, and weight 2 items taken, we can compute how much weight is left for the weight 3 items. But since there are three variables here, that might not be efficient.\n\nAlternatively, since the weight is small (only 1, 2, 3), perhaps we can find for each possible number of weight 1 and 2 items, and then compute the maximum possible for weight 3. But even that might be too slow if done naively.\n\nWait, here's an idea. Let's process each weight group separately. For example, for weight 1 items, we can take as many as possible, but maybe we need to balance with other items. But since the problem is about choosing the best combination, perhaps we can iterate over the possible number of weight 3 items, and for each, determine the best way to fill the remaining weight with 1s and 2s.\n\nAlternatively, considering that the maximum weight is 3e5, and the weights are small, maybe we can use dynamic programming for the weight 1 and 2 items, and then handle the weight 3 items in a way that allows us to combine with the DP.\n\nWait, let me think again. Let's split the problem into three parts: items of weight 1, weight 2, and weight 3. Let's sort each group in descending order of cost. Then, for each group, compute prefix sums. For example, for weight 1 items, the prefix sum array would be sum_1[k] = sum of the first k items. Similarly for sum_2 and sum_3.\n\nNow, the problem becomes: select some number of items from each group such that their total weight is <= m, and the total cost is maximized.\n\nThe challenge is how to efficiently combine the choices from the three groups.\n\nLet me consider that for weight 3 items, since each takes up 3 units of weight, and the maximum possible number of such items is up to m//3. However, even if m is 3e5, m//3 is 1e5. So iterating over all possible numbers of weight 3 items might be feasible, but combined with other steps.\n\nSo here's a plan:\n\n1. Preprocess each weight group by sorting them in descending order of cost and compute prefix sums.\n\n2. For each possible number of weight 3 items (say, t), we can compute the remaining weight (rem = m - 3*t). Then, the problem reduces to finding the maximum cost from weight 1 and 2 items with total weight <= rem. How to compute that?\n\nFor the weight 1 and 2 items, given a maximum weight limit (rem), what's the maximum cost? This is a classic unbounded knapsack problem but with two types of items. Wait, no. Because each item can be taken once. So it's the 0-1 knapsack problem with items of weight 1 and 2. However, with n up to 1e5, but m up to 3e5, we need an efficient way to compute this.\n\nBut perhaps there's a way to compute the optimal selection of weight 1 and 2 items for any given capacity. Let me think about that.\n\nLet's say we have a certain capacity, say, cap. We need to select some number of weight 1 items (say, x) and some number of weight 2 items (say, y), such that x + 2y ≤ cap. The maximum cost is sum_1[x] + sum_2[y], where x is up to the number of weight 1 items available, and similarly for y.\n\nBut how to find the optimal x and y for a given cap?\n\nThis seems like a problem that can be solved with a two-pointer approach. Let's think: for each possible y (number of weight 2 items), the maximum x is min( (cap - 2*y), len_1 ), where len_1 is the number of weight 1 items. So for each y, we can compute the corresponding x. But since y can be up to len_2, which could be 1e5, and for each of those we have to check, this would be O(len_2) per cap. Which would be too slow if we have to do this for multiple caps.\n\nAlternatively, since the cap can be up to m (3e5), and for each possible cap, we need to compute the maximum value, perhaps we can precompute for all possible capacities up to m, the maximum value using weight 1 and 2 items.\n\nBut how?\n\nLet me think. Let's suppose we have all weight 1 items sorted and prefix sums, same for weight 2.\n\nFor a given capacity cap, the maximum value is the maximum of sum_1[x] + sum_2[y], where x + 2y ≤ cap. How can we compute this efficiently?\n\nAnother approach: for each possible number of weight 2 items (y), the maximum x is (cap - 2y), but we can't take more than the available weight 1 items. So for each y, the maximum x is min( (cap - 2y), len_1 ), but we can't take more than the number of weight 1 items. However, since the weight 1 items are sorted, taking as many as possible (up to the available count) gives the maximum sum_1[x].\n\nSo for each possible y, the maximum contribution is sum_2[y] + sum_1[ min( len_1, cap - 2y ) ].\n\nBut how do we find the best y for a given cap?\n\nThe possible y can range from 0 to min( len_2, cap // 2 ). So for each cap, we can iterate y from 0 to that upper bound, compute the corresponding x and sum, and take the maximum. However, if cap is up to 3e5, and for each cap we do O( len_2 ) operations, that would be O(3e5 * 1e5) which is 3e10 operations. That's way too slow.\n\nThat's not feasible. So this approach is not going to work.\n\nAlternative idea: For each possible cap, find the optimal number of weight 2 items y that can be used, given that we can take up to (cap - 2y) weight 1 items.\n\nBut how can we find that y quickly?\n\nLet me think about the following: For the weight 2 items, since they are sorted, taking the first y items gives the maximum sum_2[y]. So for a given cap, the maximum possible y is min( len_2, cap // 2 ). But for each possible y, the corresponding x is min( cap - 2y, len_1 ). However, since the weight 1 items are sorted, taking as many as possible (up to the available count) is optimal.\n\nSo for each cap, the optimal y is somewhere between 0 and min( len_2, cap//2 ). But how to find the best y quickly?\n\nLet me think of the function f(y) = sum_2[y] + sum_1[ min( len_1, cap - 2y ) ].\n\nWe can try to find the maximum of this function over all valid y. How?\n\nSince sum_2 is increasing (since we sorted the items in descending order), and sum_1 is also increasing, but the term cap - 2y decreases as y increases.\n\nSo the function f(y) may have a single peak. Maybe we can find the maximum by binary search or using two pointers.\n\nAlternatively, considering that for a given cap, the optimal y is around (cap - x)/2, where x is the number of weight 1 items taken. But this seems vague.\n\nAnother approach: For each possible cap, the optimal choice between weight 1 and 2 items can be found by considering that for a given amount of weight, we can take as many weight 2 items as possible, and then fill the rest with weight 1. Or take as many weight 1 items as possible, and then fill with weight 2. But that's not necessarily optimal. However, perhaps for each cap, the optimal is either to take as many weight 2 items as possible, or take as many weight 1 items as possible, or some combination in between. But again, how to find it.\n\nAlternatively, since the weight 1 and 2 items are sorted, perhaps for a given cap, the optimal number of weight 2 items is up to min( len_2, cap//2 ), and for each y in that range, the x is min( len_1, cap - 2y ). So the maximum of sum_2[y] + sum_1[ min( len_1, cap - 2y ) ].\n\nBut how to find this maximum quickly. Let's think of this as a function of y. Let's imagine that for each possible y, we can compute the x.\n\nBut for a given cap, the maximum y is y_max = min( len_2, cap // 2 )\n\nBut even if we can compute y_max, trying all possible y from 0 to y_max is O(y_max) per cap. Which again is not feasible if we have to do this for many caps.\n\nWait, but in our original problem, we are going to iterate over the number of weight 3 items. Let's think again about the overall plan.\n\nOriginal plan: For each possible number of weight 3 items (t), compute the remaining capacity rem = m - 3*t. Then, compute the maximum value from weight 1 and 2 items with capacity rem. Then, the total value is sum_3[t] + max_value_1_2(rem).\n\nBut how to compute max_value_1_2(rem) quickly.\n\nSo, if we can precompute for all possible rem (up to m), the max value from weight 1 and 2 items, then we can do this in O(1) per t.\n\nBut how to compute this for all possible rem.\n\nLet me think about the maximum possible rem. It's up to m, which is 3e5. So for each possible rem (from 0 to m), compute the max value for weight 1 and 2 items.\n\nHow?\n\nLet me think of the following approach:\n\nFor each possible rem (from 0 to m), compute the maximum value that can be obtained by selecting some number of weight 1 and 2 items with total weight ≤ rem.\n\nTo compute this, we can use dynamic programming. However, since the items are of weight 1 and 2, and the number of items is large (up to 1e5 each), we need an optimized approach.\n\nWait, but for weight 1 and 2 items, the problem is similar to the 0-1 knapsack problem with two types of items. However, since the items are sorted, perhaps there's a way to compute this for all possible capacities efficiently.\n\nLet me think again. Suppose we have sorted the weight 1 items in descending order of cost, and the same for weight 2 items. Then, for each capacity, the optimal selection would be to take as many as possible of the highest value items.\n\nBut how to model this.\n\nAn alternative approach: For each possible capacity, the maximum value is the maximum between:\n\na) Taking as many weight 1 items as possible (up to capacity) plus the best for the remaining capacity (but since weight 1 is 1, that's already the maximum).\n\nWait, no. If I take x weight 1 items, then x can be up to min( len_1, capacity ). The sum is sum_1[x]. But maybe taking some weight 2 items would give a better sum.\n\nAlternatively, for a given capacity, the optimal solution is to take some number of weight 2 items and fill the rest with weight 1 items.\n\nSo for each capacity, the maximum value is the maximum over all possible y (number of weight 2 items) of sum_2[y] + sum_1[ min( len_1, capacity - 2*y ) ].\n\nBut how to compute this for all capacities.\n\nBut if we can precompute the prefix sums for weight 1 and 2, then for each capacity, we can find the best y quickly.\n\nBut how?\n\nLet me think for each capacity. Let's say capacity is c. The maximum y for weight 2 items is min( len_2, c//2 ). For each possible y in 0 to that max, we can compute the corresponding x as min( len_1, c - 2y ). Then sum_2[y] + sum_1[x].\n\nBut even if we can compute this for each c, the question is how to do it efficiently.\n\nBut if we can precompute for all possible c, then perhaps during the processing of the weight 3 items, we can use that.\n\nBut how to compute this for all c from 0 to m.\n\nLet me think of the following approach:\n\nWe can precompute for all possible c in 0 to m, the best possible value for weight 1 and 2 items.\n\nTo compute this, for each c, we can find the optimal y in the range [max(0, (c - len_1))//2 ... min(len_2, c//2)] ?\n\nNot sure. Alternatively, for each c, the optimal y is somewhere between 0 and min(len_2, c//2). To find the best y for each c, perhaps we can use a two-pointer approach.\n\nLet me think: For each c, the maximum number of weight 2 items is y_max = min( len_2, c // 2 ). For each c, the optimal y is such that 2y is as large as possible, but not exceeding c, and allowing enough space for weight 1 items.\n\nBut how to find that y.\n\nAlternatively, for each possible y, we can determine the range of c where this y is the optimal choice. But that seems complicated.\n\nAlternatively, for each possible y, we can compute the minimum capacity needed to take y weight 2 items, which is 2y. Then, for any capacity c >= 2y, the contribution is sum_2[y] + sum_1[ min( len_1, c - 2y ) ].\n\nBut how to find for each c the maximum over all y where 2y ≤ c.\n\nThis seems like a problem that can be approached with a sliding window or two pointers.\n\nLet me think of this: For a given c, the maximum value is the maximum of sum_2[y] + sum_1[ min( len_1, c - 2y ) ] for all y in 0 ≤ y ≤ y_max.\n\nIf we fix y, then for all c ≥ 2y, this term contributes to the value. But how to find for each c the maximum over all possible y.\n\nAlternatively, for each possible y, we can compute the best c that can be handled by this y. But I'm not sure.\n\nAnother idea: For each possible c, the optimal y is around (c - x)/2, where x is the number of weight 1 items. But again, not helpful.\n\nWait, here's a different approach. Let's precompute for all possible numbers of weight 2 items (y), the maximum number of weight 1 items that can be added. For example, for each y, the maximum x is min( len_1, c - 2y ), where c is varying. But how to find the best combination.\n\nAlternatively, for each possible y, we can note that for any capacity c ≥ 2y, the contribution of taking y weight 2 items and x = min( len_1, c - 2y ) weight 1 items is sum_2[y] + sum_1[x]. So for each y, this is a function of c, which is sum_2[y] + sum_1[ min( len_1, c - 2y ) ].\n\nNow, the maximum over all y for each c would be the maximum among all these functions evaluated at c.\n\nBut how to compute this for all c.\n\nLet me think about the following: For each possible y, we can generate a range of c where this y is considered. For example, for y, the minimal c is 2y, and the maximal c is m. For each c in [2y, m], the contribution is sum_2[y] + sum_1[ min( len_1, c - 2y ) ].\n\nBut how to find for each c the maximum of all these contributions.\n\nBut this seems like a problem that can be addressed with line sweep or other techniques.\n\nAlternatively, for each possible y, we can compute the best possible contribution for all c ≥ 2y. However, since for each c, the contribution depends on how much c - 2y is, which is the remaining capacity for weight 1 items.\n\nBut sum_1 is a non-decreasing function. So for a fixed y, the contribution increases as c increases. Because as c increases, c - 2y increases, so min(len_1, c - 2y) increases, leading to higher sum_1.\n\nSo for each y, the contribution to c is a non-decreasing function. Thus, for each c, the maximum among all possible y's contributions would be the maximum of all such functions evaluated at c.\n\nBut how to compute this.\n\nPerhaps for each c, the optimal y is the one that maximizes sum_2[y] + sum_1[ min( len_1, c - 2y ) ].\n\nBut how?\n\nLet me think of the following approach. For each c, we can find the optimal y in the range [max(0, (c - len_1) // 2 ), min( len_2, c // 2 ) ].\n\nWait, why? Because if we take y weight 2 items, then the remaining capacity is c - 2y. The maximum number of weight 1 items we can take is min( len_1, c - 2y ). To ensure that c - 2y ≥ 0, we have 2y ≤ c → y ≤ c//2.\n\nAlso, if we take more than len_1 weight 1 items, then it's not useful. So for the remaining capacity, if it's larger than len_1, then it's equivalent to taking all len_1 items.\n\nSo for a given c, the optimal y could be anywhere between 0 and min( len_2, c//2 ). However, perhaps there's a way to find the optimal y quickly.\n\nLet me think of the following. For each possible c, the optimal y is such that 2y is as large as possible without making c - 2y too small. For example, if we take as many weight 2 items as possible, but then fill the rest with weight 1. Or take as many weight 1 as possible and fill the rest with weight 2.\n\nBut again, not sure.\n\nAnother idea: Since sum_2 is non-decreasing, and sum_1 is non-decreasing, then for a given c, the optimal y is somewhere in the range where adding more y increases sum_2[y], but decreases the available capacity for sum_1. So there's a trade-off.\n\nThis sounds like a convex function, which may have a single maximum. If that's the case, then we can perform ternary search on y for each c. But since c can be up to 3e5, and for each c we perform a ternary search over y (which is up to 1e5), that would be O(3e5 * log(1e5)) operations, which is acceptable.\n\nWait, but how to verify if the function is unimodal. Let me think: for a fixed c, the function f(y) = sum_2[y] + sum_1[ min( len_1, c - 2y ) ].\n\nAs y increases, sum_2[y] increases, but c - 2y decreases, so sum_1[...] decreases. So the function could have a single peak. If that's the case, ternary search can find the maximum.\n\nBut I need to confirm this. Suppose for some c, the function first increases and then decreases. That would make it unimodal, allowing ternary search.\n\nLet me take an example. Let's say sum_2[y] increases by 5 for each step, and sum_1 decreases by 4 for each step. Then, for some y, the function increases until a certain point and then decreases. So yes, it's unimodal.\n\nIn general, the function may be unimodal. So ternary search is possible.\n\nIf this is true, then for each c, we can perform a ternary search on y in the range [0, y_max], where y_max = min( len_2, c // 2 ), to find the maximum value of f(y).\n\nBut how to implement this in Python efficiently.\n\nBut for each c, doing a ternary search would take O(log y_max) time. And since c ranges up to 3e5, and y_max can be up to 1e5, the total time would be O(3e5 * log 1e5) ≈ 3e5 * 20 = 6e6 operations, which is manageable.\n\nSo this seems feasible.\n\nSo the steps are:\n\n1. Preprocess the weight 1, 2, 3 items by sorting them in descending order of cost, and compute their prefix sums.\n\nFor example:\n\nsum_1[i] = sum of first i weight 1 items.\n\nsum_2[i] = sum of first i weight 2 items.\n\nsum_3[i] = sum of first i weight 3 items.\n\nThen, for each possible number of weight 3 items (t), which can range from 0 to min( len_3, m // 3 ), compute the remaining capacity rem = m - 3*t. Then compute the max value from weight 1 and 2 items with capacity rem. Add that to sum_3[t], and track the maximum over all t.\n\nSo the problem reduces to, for each rem, compute the max value from weight 1 and 2 items. Which we can do with the ternary search approach for each rem.\n\nBut for each rem, the ternary search would take O(log y_max) time.\n\nNow, the question is: How to implement this in Python efficiently.\n\nBut what about the cases where rem is negative? Well, in that case, we can't take any weight 3 items, so we skip that t.\n\nSo the plan is:\n\n- Separate the items into three lists based on weight.\n\n- Sort each list in descending order of cost.\n\n- Compute prefix sums for each list.\n\n- For each possible t (number of weight 3 items taken), from 0 to min( len_3, m//3 ), compute rem = m - 3*t. If rem <0, skip. Else, compute the maximum value from weight 1 and 2 items with capacity rem.\n\n- The maximum over all t is the answer.\n\nNow, the key part is implementing the function to compute the max value for weight 1 and 2 items given capacity c.\n\nSo, implementing that function with ternary search.\n\nLet me outline the code steps.\n\nFirst, separate the items:\n\nw1 = list of all items with weight 1.\n\nw2 = list of all items with weight 2.\n\nw3 = list of all items with weight 3.\n\nSort each list in descending order of cost.\n\nCompute prefix sums:\n\nsum1 = [0]\n\nfor i in range(len(w1)):\n\n    sum1.append( sum1[-1] + w1[i][1] )\n\nSimilarly for sum2 and sum3.\n\nNow, for the function max_1_2(c):\n\n    y_max = min( len(w2), c // 2 )\n\n    low = 0\n\n    high = y_max\n\n    best = 0\n\n    while low <= high:\n\n        mid = (low + high) // 2\n\n        # compute the value for mid\n\n        rem = c - 2*mid\n\n        x = min( len(w1), rem )\n\n        val = sum2[mid] + sum1[x]\n\n        # compare with neighboring points to find the maximum\n\n        # but how to do ternary search?\n\nWait, ternary search is for finding the maximum of a unimodal function. But how to implement it here.\n\nAlternatively, for the ternary search, we can perform a loop that narrows down the possible range of y.\n\nBut I'm not sure if the function is strictly unimodal. However, assuming it is, we can proceed.\n\nAnother approach is to find the optimal y by checking around the point where 2y is approximately equal to c - x, where x is the maximum number of weight 1 items.\n\nAlternatively, since the sum_2 and sum_1 are sorted, for each possible y, the optimal x is min( len_1, c - 2y ), which is the maximum possible.\n\nSo for each c, the optimal y is the one where the marginal gain of adding a weight 2 item is higher than the loss of not being able to add some weight 1 items.\n\nBut this is getting complicated.\n\nAlternatively, given that the number of weight 2 items is not too large (up to 1e5), perhaps for each c, we can find the optimal y by checking the possible candidates around the value where 2y is approximately c - x, but I'm not sure.\n\nAlternatively, for each c, we can try all possible y in the range [max(0, y_max - K), y_max], where K is a small number like 100. Since for large K, this would be O(1e5 * 100) = 1e7 operations, which is manageable.\n\nBut this is a heuristic and may not work for all cases.\n\nBut given the time constraints, perhaps the ternary search approach is better.\n\nLet me think about implementing the ternary search.\n\nFor a given c, the function f(y) = sum_2[y] + sum_1[ min( len_1, c - 2y ) ].\n\nWe want to find the maximum value of f(y) for y in [0, y_max].\n\nAssuming that the function is unimodal, we can perform ternary search.\n\nBut how to check if the function is unimodal. For example, if sum_2 increases rapidly and sum_1 decreases slowly, the function may increase until a certain point and then decrease.\n\nLet me think of a small example:\n\nSuppose sum_2 is [0, 10, 15], sum_1 is [0, 5, 8], and c is 4.\n\nFor y=0: rem is 4, x= min(2,4) =2 → sum is 0 + 8 =8.\n\ny=1: rem=4-2=2 → x=2 → sum is 10+8=18.\n\ny=2: rem=4-4=0 → x=0 → sum is 15+0=15.\n\nSo the maximum is at y=1.\n\nAnother example: sum_2 is [0, 10, 15], sum_1 is [0, 5, 8], c=5.\n\ny=0: rem=5 → x=2 → sum 0 +8=8.\n\ny=1: rem=5-2=3 → x=2 → sum 10+8=18.\n\ny=2: rem=5-4=1 → x=1 → sum 15+5=20.\n\nSo maximum is at y=2.\n\nSo the function increases from y=0 to y=2. So it's not unimodal. Hence, ternary search may not work.\n\nIn this case, the function increases with y. So the maximum is at the end of the range.\n\nAnother example: sum_2 is [0, 10, 15], sum_1 is [0, 5, 8], c=6.\n\ny=0: rem=6 → x=2 → sum 0+8=8.\n\ny=1: rem=6-2=4 → x=2 → sum 10+8=18.\n\ny=2: rem=6-4=2 → x=2 → sum 15+8=23.\n\nSo function increases with y.\n\nAnother example: sum_2 is [0, 10, 15], sum_1 is [0, 5, 8], c=3.\n\ny=0: rem=3 → x=2 → sum 0+8=8.\n\ny=1: rem=3-2=1 → x=1 → sum 10+5=15.\n\ny=2: rem=3-4= -1 → invalid. So y_max is 1. So the maximum is at y=1.\n\nSo the function increases with y.\n\nAnother example where the function first increases and then decreases.\n\nLet me think:\n\nsum_2 = [0, 5, 10, 14], sum_1 = [0, 10, 18, 20], c=5.\n\nFor y=0: rem=5 → x=3 → sum 0 + 20 =20.\n\ny=1: rem=5-2=3 → x=3 → sum 5 + 20 =25.\n\ny=2: rem=5-4=1 → x=1 → sum 10 + 10 =20.\n\ny=3: rem=5-6=-1 → invalid.\n\nSo the function increases from y=0 to 1, then decreases. So it's unimodal.\n\nSo in this case, ternary search would find the maximum.\n\nSo perhaps the function is unimodal. But in previous examples, it was increasing throughout. However, in the case where the sum_2 increases but the sum_1 decreases, the function can be unimodal.\n\nSo perhaps the function is unimodal. Thus, ternary search can be applied.\n\nTherefore, I can proceed with the ternary search approach.\n\nNow, implementing this in code.\n\nBut how to implement the ternary search for a given c.\n\nThe code for max_1_2(c) would be something like:\n\ndef max_1_2(c):\n\n    if c < 0:\n\n        return 0\n\n    len1 = len(w1)\n\n    len2 = len(w2)\n\n    y_max = min(len2, c // 2)\n\n    low = 0\n\n    high = y_max\n\n    best = 0\n\n    while low <= high:\n\n        mid1 = low + (high - low) // 3\n\n        mid2 = high - (high - low) // 3\n\n        val1 = get_value(mid1, c)\n\n        val2 = get_value(mid2, c)\n\n        if val1 < val2:\n\n            best = max(best, val2)\n\n            low = mid1 + 1\n\n        else:\n\n            best = max(best, val1)\n\n            high = mid2 - 1\n\n    # after loop, check some points around low, high\n\n    for y in range(max(0, low - 2), min(y_max, low + 2)):\n\n        best = max(best, get_value(y, c))\n\n    return best\n\nBut this is a rough sketch. Alternatively, perform the ternary search until the range is small, then check all possibilities in that range.\n\nAlternatively, use binary search to find the maximum.\n\nBut perhaps the easiest way is to perform a linear scan for small ranges. However, for large y_max, this is not feasible.\n\nAnother idea: since the function is unimodal, the maximum is achieved at the point where the derivative changes sign. So for each step, compare mid and mid+1 to decide which direction to go.\n\nBut in discrete terms, this can be implemented as follows:\n\nInitialize low = 0, high = y_max.\n\nwhile low < high:\n\n    mid = (low + high) // 2\n\n    if f(mid) < f(mid + 1):\n\n        low = mid + 1\n\n    else:\n\n        high = mid\n\nreturn f(low)\n\nThis is the standard approach for finding the maximum in a unimodal function.\n\nBut does this work?\n\nLet me test it with the previous examples.\n\nExample 1: c=5, sum_2 [0, 10, 15], sum_1 [0,5,8], len1=2, len2=2.\n\ny_max = 2 (since 5//2=2).\n\nInitially low=0, high=2.\n\nmid = (0+2)//2 = 1.\n\nCompare f(1) and f(2).\n\nf(1) = 10 + sum1[5-2*1=3 → min(2,3)=2 → sum1[2]=8 → total 18.\n\nf(2) = 15 + sum1[5-4=1 → sum1[1]=5 → total 20.\n\nSince 18 < 20 → low becomes mid+1 = 2.\n\nNow, low == high (2). Return f(2) = 20 → correct.\n\nAnother example: c=3, sum_2 [0, 10, 15], sum_1 [0,5,8], len1=2, len2=2.\n\ny_max=1 (3//2=1).\n\nlow=0, high=1.\n\nmid = 0.\n\nf(0) = 0 + sum1[3] → min(2,3) is 2 → 8.\n\nf(1) = 10 + sum1[3-2=1 → 5 → total 15. Since 8 < 15 → low becomes 1. Now low == high. return 15 → correct.\n\nAnother example where the function increases then decreases.\n\nc=5, sum_2 [0,5,10,14], sum_1 [0,10,18,20], len1=3, len2=3.\n\ny_max = 5//2 = 2.\n\nLet me see:\n\nFor y=0: rem=5 → x=3 → sum1[3] =20 → total 0+20=20.\n\ny=1: rem=5-2=3 → x=3 → sum1[3]=20 → total 5+20=25.\n\ny=2: rem=5-4=1 → x=1 → sum1[1]=10 → total 10+10=20.\n\nSo the maximum is at y=1.\n\nLet's see the algorithm:\n\nlow=0, high=2.\n\nmid = 1.\n\nCompare f(1) and f(2). f(1)=25, f(2)=20. Since 25>20 → set high=1.\n\nNow low=0, high=1.\n\nmid=(0+1)//2=0.\n\nCompare f(0) and f(1). f(0)=20 < f(1)=25 → set low=0+1=1.\n\nNow low=high=1. Return f(1)=25 → correct.\n\nSo this seems to work.\n\nAnother example where the maximum is at the end.\n\nc=6, sum_2 [0, 5, 10, 14], sum_1 [0, 10, 18, 20], len1=3, len2=3.\n\ny_max = 6//2=3.\n\nFor y=3: rem=6-6=0 → x=0 → sum1[0]=0 → total 14+0=14.\n\ny=2: rem=6-4=2 → x=2 → sum1[2]=18 → total 10+18=28.\n\ny=1: rem=6-2=4 → x=3 → sum1[3]=20 → 5+20=25.\n\ny=0: rem=6 → x=3 → 0+20=20.\n\nSo maximum is at y=2.\n\nLet's see the algorithm:\n\nlow=0, high=3.\n\nmid=1 (0+3)//2=1. Compare f(1)=25 and f(2)=28. Since 25<28, set low=2.\n\nNow low=2, high=3.\n\nmid=2+3//2=2. Compare f(2)=28 and f(3)=14. 28>14 → set high=2.\n\nNow low=high=2. return 28 → correct.\n\nSo this algorithm seems to work.\n\nThus, the approach is to find the maximum y in the range [0, y_max] using this binary search-like method.\n\nSo the code for max_1_2(c) would be:\n\ndef compute_max_1_2(c):\n\n    len1 = len(sum1) - 1  # since sum1 starts from 0\n\n    len2 = len(sum2) - 1\n\n    y_max = min",
    "response": "\n\nTo solve this problem, we need to maximize the total cost of souvenirs Petya can carry given a weight constraint. The souvenirs have weights of 1, 2, or 3, and we need an efficient solution due to the constraints on the number of items and the maximum weight capacity.\n\n### Approach\n1. **Separate Items by Weight**: Divide the souvenirs into three groups based on their weights (1, 2, and 3).\n2. **Sort and Precompute Prefix Sums**: For each group, sort the items in descending order of cost and compute prefix sums to quickly calculate the total cost for any number of items taken from each group.\n3. **Iterate Over Possible Numbers of Weight 3 Items**: For each possible number of weight 3 items that can be taken, calculate the remaining weight capacity and determine the optimal combination of weight 1 and 2 items that can fit into this remaining capacity.\n4. **Binary Search for Optimal Combination**: Use binary search to efficiently determine the optimal number of weight 2 items to take, considering the remaining capacity after accounting for weight 3 items. This helps in maximizing the total cost from weight 1 and 2 items.\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n\n    w1 = []\n    w2 = []\n    w3 = []\n\n    for _ in range(n):\n        wi = int(input[idx])\n        idx += 1\n        ci = int(input[idx])\n        idx += 1\n        if wi == 1:\n            w1.append(ci)\n        elif wi == 2:\n            w2.append(ci)\n        else:\n            w3.append(ci)\n\n    # Sort each list in descending order\n    w1.sort(reverse=True)\n    w2.sort(reverse=True)\n    w3.sort(reverse=True)\n\n    # Compute prefix sums\n    sum1 = [0]\n    for c in w1:\n        sum1.append(sum1[-1] + c)\n\n    sum2 = [0]\n    for c in w2:\n        sum2.append(sum2[-1] + c)\n\n    sum3 = [0]\n    for c in w3:\n        sum3.append(sum3[-1] + c)\n\n    max_total = 0\n\n    len3 = len(w3)\n    max_t = min(len3, m // 3)\n    for t in range(0, max_t + 1):\n        rem = m - 3 * t\n        if rem < 0:\n            continue\n        # Now compute max value from w1 and w2 with capacity rem\n        len1 = len(sum1) - 1\n        len2 = len(sum2) - 1\n        y_max = min(len2, rem // 2)\n        low = 0\n        high = y_max\n        best = 0\n        while low < high:\n            mid = (low + high) // 2\n            val_mid = sum2[mid]\n            rem_mid = rem - 2 * mid\n            x = min(len1, rem_mid)\n            val_mid += sum1[x]\n            val_mid_plus1 = sum2[mid + 1]\n            rem_mid_plus1 = rem - 2 * (mid + 1)\n            x_plus1 = min(len1, rem_mid_plus1)\n            val_mid_plus1 += sum1[x_plus1]\n            if val_mid < val_mid_plus1:\n                low = mid + 1\n            else:\n                high = mid\n        # Now check low\n        y = low\n        rem_y = rem - 2 * y\n        x = min(len1, rem_y)\n        current = sum2[y] + sum1[x]\n        best = current\n        # Also check y=0 and y=y_max in case of edge cases\n        # Check y=0\n        rem_0 = rem - 0\n        x0 = min(len1, rem_0)\n        current0 = sum2[0] + sum1[x0]\n        best = max(best, current0)\n        # Check y=y_max\n        rem_ymax = rem - 2 * y_max\n        xymax = min(len1, rem_ymax)\n        currentymax = sum2[y_max] + sum1[xymax]\n        best = max(best, currentymax)\n        # Update max_total\n        total = sum3[t] + best\n        if total > max_total:\n            max_total = total\n\n    print(max_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Input Handling**: The input is read and parsed into three separate lists based on the weight of the souvenirs.\n2. **Sorting and Prefix Sums**: Each list of souvenirs is sorted in descending order of cost, and prefix sums are computed to quickly calculate the total cost of taking the first `k` items from each list.\n3. **Iterating Over Weight 3 Items**: For each possible number of weight 3 items that can be taken, the remaining capacity is calculated. This remaining capacity is used to determine the optimal combination of weight 1 and 2 items using binary search.\n4. **Binary Search for Optimal Combination**: The binary search helps efficiently determine the optimal number of weight 2 items to take, ensuring that the total cost is maximized for the remaining capacity after accounting for weight 3 items.\n\nThis approach ensures that we efficiently explore all possible combinations while leveraging sorting and prefix sums to quickly compute costs, resulting in an optimal solution within the constraints.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n\n    w1 = []\n    w2 = []\n    w3 = []\n\n    for _ in range(n):\n        wi = int(input[idx])\n        idx += 1\n        ci = int(input[idx])\n        idx += 1\n        if wi == 1:\n            w1.append(ci)\n        elif wi == 2:\n            w2.append(ci)\n        else:\n            w3.append(ci)\n\n    # Sort each list in descending order\n    w1.sort(reverse=True)\n    w2.sort(reverse=True)\n    w3.sort(reverse=True)\n\n    # Compute prefix sums\n    sum1 = [0]\n    for c in w1:\n        sum1.append(sum1[-1] + c)\n\n    sum2 = [0]\n    for c in w2:\n        sum2.append(sum2[-1] + c)\n\n    sum3 = [0]\n    for c in w3:\n        sum3.append(sum3[-1] + c)\n\n    max_total = 0\n\n    len3 = len(w3)\n    max_t = min(len3, m // 3)\n    for t in range(0, max_t + 1):\n        rem = m - 3 * t\n        if rem < 0:\n            continue\n        # Now compute max value from w1 and w2 with capacity rem\n        len1 = len(sum1) - 1\n        len2 = len(sum2) - 1\n        y_max = min(len2, rem // 2)\n        low = 0\n        high = y_max\n        best = 0\n        while low < high:\n            mid = (low + high) // 2\n            val_mid = sum2[mid]\n            rem_mid = rem - 2 * mid\n            x = min(len1, rem_mid)\n            val_mid += sum1[x]\n            val_mid_plus1 = sum2[mid + 1]\n            rem_mid_plus1 = rem - 2 * (mid + 1)\n            x_plus1 = min(len1, rem_mid_plus1)\n            val_mid_plus1 += sum1[x_plus1]\n            if val_mid < val_mid_plus1:\n                low = mid + 1\n            else:\n                high = mid\n        # Now check low\n        y = low\n        rem_y = rem - 2 * y\n        x = min(len1, rem_y)\n        current = sum2[y] + sum1[x]\n        best = current\n        # Also check y=0 and y=y_max in case of edge cases\n        # Check y=0\n        rem_0 = rem - 0\n        x0 = min(len1, rem_0)\n        current0 = sum2[0] + sum1[x0]\n        best = max(best, current0)\n        # Check y=y_max\n        rem_ymax = rem - 2 * y_max\n        xymax = min(len1, rem_ymax)\n        currentymax = sum2[y_max] + sum1[xymax]\n        best = max(best, currentymax)\n        # Update max_total\n        total = sum3[t] + best\n        if total > max_total:\n            max_total = total\n\n    print(max_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 481,
        "completion_token_count": 1205,
        "thoughts_token_count": 8191
    }
}