{
    "start": 1758313401.9734197,
    "end": 1758313578.905233,
    "start-formatted": "2025-09-20 05:23 KST",
    "end-formatted": "2025-09-20 05:26 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\nOkay, let's try to understand this problem. So the task is to find two things for a given p: the minimum number of nodes needed in a directed graph that is p-reachable, and then among all such graphs with that minimal node count, find the maximum number of unidirectional pairs.\n\nFirst, let's parse the definitions again. A p-reachable graph has exactly p ordered pairs (u, v) where u < v and u and v are reachable from each other. Wait, but ordered pairs here? Wait, the problem says \"exactly p ordered pairs of nodes (u, v) such that u < v and u and v are reachable from each other.\" So for each pair u and v where u < v, if they are mutually reachable, that counts as one towards p. So the total p is the count of such pairs.\n\nNow, the first part is to find the minimum number of nodes required. Then, among all such minimal-node graphs, find the maximum possible number of unidirectional pairs.\n\nLet me think about how to model this.\n\nFirst, for the minimum number of nodes. Let's consider that for a graph with n nodes, the maximum number of mutual pairs (u, v) with u < v is C(n, 2), but that's only if all nodes are mutually reachable. But if we have a graph that's strongly connected, then all pairs are mutually reachable. However, if the graph is not strongly connected, then some pairs may not be mutually reachable.\n\nWait, but for the p-reachable condition, the graph must have exactly p such pairs. So our goal is to find the smallest n such that there exists a graph with exactly p mutual pairs (u < v).\n\nBut how can we model the number of mutual pairs in a graph?\n\nLet me think about the structure of the graph. Suppose we have a graph composed of several strongly connected components (SCCs). For any two nodes u and v in different SCCs, if there's a path from u to v but not vice versa, then they are not mutually reachable. However, if there's a path both ways, then they are in the same SCC. So the mutual reachability pairs are within each SCC. Because if two nodes are in different SCCs, then there's no path between them both ways. Therefore, the total number of mutual pairs in the entire graph is the sum over each SCC of C(k, 2), where k is the size of the SCC. Because within each SCC, every pair of nodes (u, v) with u < v is mutually reachable.\n\nWait, but that's only if the SCC is strongly connected. So if the graph is partitioned into SCCs, and each SCC is a strongly connected component, then the mutual pairs are exactly the sum of C(k_i, 2) for each component of size k_i.\n\nSo, to get exactly p mutual pairs, we need to find a set of integers k_1, k_2, ..., k_m such that sum_{i} C(k_i, 2) = p, and the total number of nodes is sum k_i, and this sum is minimized.\n\nAh! Because the minimal number of nodes would be achieved when the sum of k_i is as small as possible, given that the sum of C(k_i, 2) equals p. So the problem reduces to finding the minimal sum of integers (k_1 + ... +k_m) such that sum (k_i choose 2) = p. And once we find that minimal n, then the next part is to find the maximum number of unidirectional pairs.\n\nSo the first part is to find the minimal n where there exists a decomposition of p into sum (k_i choose 2), and the sum of k_i is minimized.\n\nLet me think about how to find that decomposition. For example, in the first sample input, p=3. The possible decomposition is 3 = C(3,2) = 3. So the minimal n is 3. If we tried to split into smaller components, say C(2,2) + C(2,2) = 1+1=2 <3. So that's not enough. So the minimal n is 3.\n\nAnother example, when p=4. The sample output is 5 6. Let's see: the minimal n for p=4. Let's see:\n\nPossible options:\n\nOption 1: one component of size 4. C(4,2) = 6, which is more than 4. Not good.\n\nOption 2: split into components. For example, 3 + 1: C(3,2) + C(1,2) = 3 + 0 =3. Not enough.\n\nWhat about 2+2: 1 +1 =2. Still less than 4.\n\nWhat about 3 and 2? C(3,2) + C(2,2) = 3 + 1 =4. Sum of sizes is 3+2=5. Which is the sample output. So that's the minimal n. So yes, that's correct.\n\nSo the problem for the first part is to find the minimal sum of k_i where sum (k_i choose 2) = p.\n\nSo how do we find this decomposition?\n\nThis seems like a problem where we need to find the minimal sum of numbers, given that their combination of (k_i choose 2) adds up to p. The approach is to find the optimal way to break p into sum of terms (k choose 2), such that the sum of k's is minimized.\n\nThe key observation here is that for a given sum of (k_i choose 2) = p, the minimal sum of k_i is achieved by using as many large components as possible. Wait, but that might not be the case. Let me think. For example, suppose p is 4. If we use one component of size 3 (C(3,2) =3) and another of size 2 (C(2,2)=1), sum is 3+2=5. Alternatively, if we could find a way to split into components with higher values. But 4 can't be written as a single C(k, 2). Because C(3,2)=3, C(4,2)=6. So the next best is to take the largest possible component, then proceed with the remainder.\n\nSo perhaps the optimal strategy is to take the largest possible k_i for each step, such that C(k,2) ≤ remaining p, and subtract that from p, then proceed recursively.\n\nBut wait, maybe sometimes splitting into smaller components gives a better sum. For example, let's say p is 5. Let's see:\n\nIf we take the largest possible component. C(3,2)=3. Remaining is 2. Then take C(2,2)=1, remaining 1. Then take C(2,2)=1 again. So total sum is 3+2+2=7. But another option is C(3,2) + C(2,2) = 3+1=4, which is less than 5. So that's not helpful. Wait, maybe I'm missing something. Let's think again. What's the sum of (k_i choose 2) for p=5? We need to find a way to get sum equal to 5.\n\nAlternative approach: Let's think of the decomposition as a set of integers where each term is (k_i choose 2), and the sum is p. To minimize the total sum of k_i's, we want each term to be as large as possible. Because for a given value of (k choose 2), the larger the k, the smaller the sum of k_i's. For example, (k choose 2) is 3 for k=3, and sum is 3. If instead we have two components with (k1 choose 2) + (k2 choose 2) =3, like 1+2, then the sum of k's would be 2+2=4, which is worse than 3.\n\nWait, so the optimal way is to take as large as possible components. So the algorithm would be:\n\nStart with p. Find the maximum possible k such that (k choose 2) ≤ p. Subtract (k choose 2) from p, add k to the sum, and repeat until p is zero.\n\nBut wait, this approach may not always give the minimal sum. Let's test with some examples.\n\nFor example, p=6. The maximum k is 4 (since C(4,2)=6). Sum is 4. That's optimal. If we split into 3 and 3, sum is 3+3=6, which is worse than 4.\n\nAnother example: p=5. The maximum k is 3 (C(3,2)=3), then remaining p=2. Then the maximum k is 2 (C(2,2)=1). Subtract 1, remaining 1. Then again take 2 (C(2,2)=1). So total sum is 3+2+2=7. Alternatively, can we find a better decomposition?\n\nWhat if we take k=3 (3) and then k=2 (1) and then k=2 (another 1). Total sum is 3+2+2=7. But another option: take two components of size 3 and 2. Wait, but 3+1=4. No, that's not 5. Wait, what's 3 + 1? It's 3 + 1=4. Not 5. Hmm. How else can we get 5?\n\nAnother idea: Maybe using a component of size 4 (C(4,2)=6) is too big. But 6>5. So not allowed. What about using a component of size 3 (3) and then a component of size 2 (1) and then a component of size 1 (0). So sum is 3+2+1=6. But that's worse than the previous approach.\n\nAlternatively, perhaps using a component of size 3 (3) and then a component of size 3 (3) would sum to 6. Which is more than 5. So no. So maybe the initial approach is correct. But in that case, for p=5, the minimal sum is 3+2+2=7? But maybe there's a better way.\n\nWait, maybe there's a way to have a component of size 4 and then subtract something? Well, no, because C(4,2)=6 which is bigger than 5. So that's not allowed. So the initial approach seems to be the way to go.\n\nBut let's think of another example. Let's take p=4. According to the sample, the minimal sum is 5 (3+2). But according to the approach: the maximum k is 3 (C(3,2)=3). Then remaining is 1. The maximum k for 1 is 2 (C(2,2)=1). So sum is 3+2=5. Which is correct.\n\nAnother example: p=2. The maximum k is 2 (C(2,2)=1). Then remaining is 1. Take another 2. Sum is 2+2=4. But alternatively, can we have a single component of size 3? No, because C(3,2)=3>2. So the minimal sum is 2+2=4. But another approach: perhaps split into one component of size 2 (C(2,2)=1) and one component of size 2 again. But that's same as 4. But what about a component of size 3 and then subtracting something? No, since 3 is larger than 2. So the approach works.\n\nBut let's think of another case. Suppose p=5. According to the approach, we take 3 (C(3,2)=3) and then 2 (C(2,2)=1), then another 2 (C(2,2)=1). Total is 3+2+2=7. But what if we take a component of size 3 (3) and a component of size 3 (3) but subtract 1? No, because that's not allowed. Wait, but maybe there's a way to have a component of size 4 (which gives 6) and then subtract 1. But that's not possible. So the approach seems to work.\n\nBut perhaps there's another way. For example, if p=5, can we have components of size 3 (3) and 2 (1) and 1 (0). Sum is 3+2+1=6. Which is better than 7? No, 6 is less than 7. Wait, but why didn't the algorithm take that? Because when p=5-3=2, the maximum k for 2 is 2 (C(2,2)=1), then subtract 1, leaving 1. Then take another 2. So the algorithm gives 3+2+2=7. But if we take 3+2+1, that would be sum 3+2+1=6. But how? Because the sum of C(3,2) + C(2,2) + C(1,2) =3+1+0=4. Which is less than 5. So that's not acceptable.\n\nAh, right. So that's not a valid decomposition. So the algorithm is correct.\n\nSo the conclusion is that the minimal sum is achieved by greedily taking the largest possible component at each step.\n\nSo the algorithm for finding the minimal n is:\n\nInitialize n = 0, remaining_p = p.\n\nWhile remaining_p > 0:\n\n   find the largest k such that k*(k-1)/2 <= remaining_p.\n\n   add k to n.\n\n   subtract k*(k-1)/2 from remaining_p.\n\nBut wait, what if after taking k, the remaining_p is not zero? Then we proceed.\n\nBut how to find this k? For each step, given a remaining_p, find the maximum k where k(k-1)/2 ≤ remaining_p.\n\nThis can be done via binary search.\n\nOnce we have the decomposition into k_i's, then the minimal n is the sum of the k_i's.\n\nOnce we have the minimal n, the next part is to compute the maximum number of unidirectional pairs among all such graphs with that minimal n.\n\nSo now, the second part. How to compute the maximum number of unidirectional pairs.\n\nUnidirectional pairs are ordered pairs (u, v) where u != v, there's a path from u to v, but no path from v to u. Also, note that the problem defines unidirectional pairs as those where u !=v and there's a path from u to v and no path from v to u.\n\nBut in the context of the graph structure, which is composed of strongly connected components (SCCs), arranged in a DAG. Because the SCCs form a DAG when condensed into a single node per component.\n\nIn such a DAG, for any two components A and B, if there is an edge from A to B, then all nodes in A can reach all nodes in B, but not vice versa (assuming the DAG is properly structured). However, if there is a path from A to B, then nodes in A can reach nodes in B, but not the other way around.\n\nSo for the unidirectional pairs, we have two types:\n\n1. Pairs within the same component: if the component is strongly connected, then for any two nodes u and v in it, they are mutually reachable. So there are no unidirectional pairs here.\n\n2. Pairs between different components. Suppose component A is before component B in the DAG. Then for any u in A and v in B, there is a path from u to v, but not from v to u. So each such pair contributes to a unidirectional pair. However, since the problem counts ordered pairs (u, v) with u < v. Wait, the original definition of unidirectional pairs is ordered pairs (u, v) where u != v, there's a path from u to v and no path from v to u. But the problem statement says that in the second part, we need to count the maximum number of such pairs.\n\nBut the problem says that the graph is p-reachable, and we need to maximize the number of unidirectional pairs. So given that the graph's SCCs are arranged in a DAG, and the decomposition of p into sum C(k_i, 2), the number of unidirectional pairs depends on the arrangement of the components.\n\nSo to maximize the number of unidirectional pairs, we need to arrange the components in a DAG such that as many pairs of nodes between different components as possible contribute to unidirectional pairs. However, the arrangement of components affects this.\n\nBut the maximum number of such pairs occurs when the DAG is a linear chain. Let me think. Suppose we have components arranged in a linear order, where each component points to all subsequent components. Then, for any two components A and B where A comes before B, all nodes in A can reach all nodes in B, and vice versa? No, if the DAG is a linear chain, then there is a path from A to B if A is before B, but no path from B to A. So for each pair of components A and B where A comes before B, all pairs (u in A, v in B) contribute to unidirectional pairs, but the reverse pairs (v in B, u in A) do not. Also, for pairs between components where A comes after B, the direction is reversed.\n\nSo the total number of unidirectional pairs between components is the sum over all ordered pairs of components (A, B) where A comes before B in the DAG, of (size of A) * (size of B). Because for each such pair (u in A, v in B), u can reach v, but not vice versa. So each of these contributes 1 to the unidirectional count.\n\nAdditionally, we need to consider the ordered pairs (u, v) where u and v are in different components, but the direction is such that u can reach v but not vice versa. But the way to maximize this is to arrange the components in a linear order, so that for any two components, one is before the other, and all cross-component pairs contribute to the unidirectional count.\n\nSo the maximum number of unidirectional pairs is achieved when the components are arranged in a linear order (a chain), and each component points to all components that come after it. Thus, the total number of unidirectional pairs is the sum_{i < j} (size_i * size_j), where size_i is the size of component i in the linear order.\n\nBut wait, the problem counts ordered pairs (u, v) where u < v. Wait, the original definition of unidirectional pairs includes u < v. So the actual count is the number of such ordered pairs (u, v) where u < v and u can reach v but not vice versa.\n\nBut when considering the components, the arrangement of the components in the DAG affects the count. However, the problem requires us to count all ordered pairs (u, v) with u < v and the unidirectional condition. So even if the components are arranged in a linear order, the actual count depends on the sizes of the components and their order.\n\nBut how can we model this? Let's think. For the components arranged in a linear order, say, component 1, component 2, ..., component m. Each component i has size s_i. The total number of ordered pairs (u, v) with u in component i, v in component j, i < j, and u < v. Wait, but u < v depends on the numbering of the nodes. However, the problem allows us to arrange the nodes in any way, so to maximize the number of unidirectional pairs, we can arrange the nodes in such a way that for each component, all nodes in component i are numbered lower than all nodes in component j when i < j. This way, for any u in component i and v in component j (i < j), u < v. So the number of such pairs (u, v) is the sum_{i < j} (s_i * s_j). And since all these pairs are unidirectional (as there's a path from u to v but not vice versa), this would be the maximum possible number of unidirectional pairs.\n\nTherefore, the problem reduces to, given the decomposition of p into sum C(k_i, 2), find the arrangement of the components (with sizes s_1, s_2, ..., s_m) in a linear order such that the sum of s_i*s_j over all i<j is maximized. But since the sum of s_i*s_j for i<j is equal to [(sum s_i)^2 - sum s_i^2]/2. And since sum s_i is fixed (it's the minimal n), the maximum value of this sum is achieved when the sum of squares of the s_i is minimized. Because:\n\nsum_{i<j} s_i s_j = [ (sum s_i)^2 - sum s_i^2 ] / 2.\n\nSo to maximize this expression, we need to minimize sum s_i^2.\n\nTherefore, the problem becomes: given the decomposition of p into sum C(s_i, 2), and the sum of s_i is n (the minimal possible), how can we arrange the s_i's such that sum s_i^2 is minimized?\n\nWait, but the decomposition into s_i's is determined by the first part. For example, in the first sample, p=3, the decomposition is a single component of size 3. sum s_i^2 is 9. So the sum of s_i s_j for i<j is zero (since there's only one component). Hence, the maximum number of unidirectional pairs is zero, which matches the sample.\n\nIn the second sample, p=4, the decomposition is components of size 3 and 2. So sum s_i^2 is 3² + 2² = 9 +4 =13. The total sum of s_i is 5. So the sum_{i<j} s_i s_j is (5^2 - 13)/2 = (25-13)/2 = 6, which is the sample output's second value (6). Which matches.\n\nSo the problem is, once we have the decomposition of p into the s_i's (the sizes of the components), we need to arrange them in a way that sum s_i^2 is minimized. But how?\n\nBecause for a fixed sum of s_i (n), the sum of squares is minimized when the s_i's are as equal as possible. For example, if you have a sum of numbers, the sum of squares is minimized when the numbers are as equal as possible.\n\nBut in our case, the decomposition of p into the sum of C(s_i, 2) is fixed. So the question is: given that the decomposition of p into the sum of C(s_i, 2) is such that the sum of s_i is minimal, how can we arrange the s_i's to minimize the sum of squares?\n\nBut wait, the decomposition is determined by the greedy approach. For example, in the case of p=4, the decomposition is 3 and 2. But what if there's another decomposition with the same sum of s_i but different s_i's leading to a smaller sum of squares?\n\nBut in the first part, the decomposition is chosen to have the minimal sum of s_i. So the decomposition is fixed once we find the minimal n. However, perhaps there are multiple decompositions that achieve the same minimal n. For example, if p can be written in different ways as sum C(s_i, 2) with the same sum of s_i.\n\nIn that case, we need to choose the decomposition that minimizes the sum of squares of the s_i's, which will maximize the number of unidirectional pairs.\n\nBut how can that happen? For example, suppose p is 6. One possible decomposition is a single component of size 4 (C(4,2)=6). Sum of s_i is 4, sum of squares is 16. Another decomposition could be 3 and 3 (each C(3,2) = 3, sum is 6). Sum of s_i is 6. But since the first decomposition has sum 4, which is better (smaller), the second is not considered. So the minimal sum is 4, and the decomposition is 4.\n\nBut suppose there's a case where two decompositions have the same minimal sum of s_i. For example, suppose p is 6. Let's see:\n\nAnother possible decomposition is 3 + 2 + 2. C(3,2) =3, C(2,2)=1, so sum is 3+1+1=5 <6. Not helpful. So not possible.\n\nWait, perhaps another example. Let's think of p= 3 + 3 =6. Suppose that the minimal sum for p=6 is 4 (from a single component of 4), but another decomposition could be two components of 3 and 3, which would sum to 6. Which is larger than 4, so the minimal sum is 4, so that decomposition isn't considered.\n\nSo in general, the decomposition into the s_i's is uniquely determined by the greedy approach. Wait, no. Suppose that for a certain p, there are multiple decompositions that give the same minimal sum. For example, let's say p= 5. The greedy approach would take 3 (C(3,2)=3), then 2 (C(2,2)=1), then 2 (another 1), giving sum 3+2+2=7. But is there another decomposition with sum 7? For example, 3 + 2 + 2 (sum 7) or 2+2+2+1 (sum 7, but C(2,2)*3 + C(1,2)= 3*1 +0=3 <5). So no. So that's not a valid decomposition. So perhaps the decomposition is unique once the minimal sum is found.\n\nBut regardless, the problem says that once the minimal number of nodes is found, we have to choose among all possible graphs with that minimal number of nodes, the one that maximizes the number of unidirectional pairs. Which depends on the decomposition of the p into the sum of C(s_i, 2) with the sum of s_i being minimal. So for example, if there are multiple decompositions of p into sum C(s_i, 2) with the same sum of s_i, then we need to choose the decomposition that minimizes sum s_i^2, which in turn maximizes the number of unidirectional pairs.\n\nBut how to handle that? Well, during the first part, when finding the minimal sum of s_i, we need to generate all possible decompositions that achieve that minimal sum, and then select the one that minimizes sum s_i^2. However, given that the greedy approach may not generate the optimal decomposition for the second part, perhaps we need to adjust the decomposition during the first part.\n\nBut how? Let's think. For example, suppose that the minimal sum is achieved by two different decompositions. For instance, say p is 6, and the minimal sum is 4 (using a single component of 4). But suppose there's another decomposition with sum 4, like 3 and 2 (sum is 5?), no. Wait, 3+2=5. So no. So that's not possible.\n\nAlternatively, let's imagine p= 2. The minimal sum is 4 (two components of 2 each, since C(2,2)=1 each, sum 2). But another decomposition could be a single component of 3 (C(3,2)=3) which is larger than 2, so not allowed. So the minimal sum is 4.\n\nBut in this case, the decomposition is two components of 2 each. So sum of squares is 2^2 + 2^2 = 8. The number of unidirectional pairs is [(4^2 - 8)/2] = (16-8)/2=4. Which would be the sum of 2*2 (since the components are arranged in a linear order, and there's one pair of components (i=1, j=2) contributing 2*2=4).\n\nBut suppose that there's a way to arrange the decomposition into different components with same sum but smaller sum of squares. For example, if the decomposition was 3 and 1, but that would have sum 3+1=4. But C(3,2) + C(1,2) =3+0=3 which is less than p=2. So that's invalid.\n\nSo in this case, the decomposition is fixed as two components of 2.\n\nSo perhaps the initial approach of using the greedy decomposition is sufficient, and once we have the decomposition, the sum of squares is determined. However, perhaps during the decomposition process, we can choose different ways to split p into the sum of C(s_i, 2) with the same sum of s_i but different s_i's, leading to a lower sum of squares.\n\nBut how can we do that?\n\nLet me think of an example. Suppose p= 5, and the minimal sum is 7. The decomposition is 3, 2, 2. Sum of squares is 9 +4+4=17. Alternatively, could we have a decomposition of 3, 3, 1. But C(3,2) is 3, and C(3,2) is 3 again, plus C(1,2)=0. Total sum is 3+3=6>5. No. Not allowed. Or 3, 2, 1, 1. Sum of C(3,2) + C(2,2) + C(1,2) + C(1,2) =3+1+0+0=4 <5. No. So no other decomposition.\n\nAnother example: p= 6. Greedy approach gives a single component of 4 (sum 4). sum of squares is 16. Alternatively, if there's a decomposition with sum 4, but different components. For example, 3 and 2 and ... but C(3,2)+C(2,2) =3+1=4 <6. No. So no.\n\nSo perhaps the decomposition is unique once the minimal sum is determined. Therefore, the initial approach of using the greedy decomposition is sufficient, and once we have the list of s_i's, we can compute the sum of squares, and then calculate the number of unidirectional pairs as [(sum s_i)^2 - sum s_i^2 ] / 2.\n\nWait, but in the case where the components are arranged in a linear order, the number of unidirectional pairs is sum_{i<j} s_i * s_j. Which equals [ (sum s_i)^2 - sum s_i^2 ] / 2. So yes.\n\nThus, the steps for solving the problem are:\n\n1. For the given p, compute the minimal n (number of nodes) by decomposing p into sum of C(k_i, 2) with minimal sum of k_i.\n\n   To do this, use the greedy approach: at each step, take the largest possible k such that C(k, 2) ≤ remaining_p.\n\n2. Once we have the list of k_i's (the sizes of the components), compute the sum of squares of the k_i's.\n\n3. Compute the number of unidirectional pairs as (n^2 - sum_sq) // 2, where n is the sum of the k_i's, and sum_sq is the sum of squares of the k_i's.\n\nBut wait, why is that? Because sum_{i<j} s_i s_j = [ (sum s_i)^2 - sum s_i^2 ] / 2. And since the components are arranged in a linear order, all such pairs contribute to the unidirectional count. Also, the problem counts ordered pairs (u, v) with u < v. So if the components are arranged in such a way that all nodes in earlier components are numbered lower than those in later components, then all pairs (u, v) between different components where u is in an earlier component and v is in a later component contribute to the unidirectional pairs. Thus, the total is indeed the sum of s_i s_j for i < j.\n\nSo the formula holds.\n\nNow, let's test this with the sample inputs.\n\nSample Input 1: p=3.\n\nDecomposition: [3]. sum_sq = 3^2 =9. n=3. So (3^2 -9)/2 = (9-9)/2=0. Which matches the sample output of 0.\n\nSample Input 2: p=4. Decomposition is [3,2]. sum_sq = 9 +4=13. n=5. (5^2 -13)/2 = (25-13)/2=6. Which matches the sample output of 6.\n\nSample Input 3: p=0. Then, the minimal n is 0? Or wait, the problem says that for p=0, the graph has exactly zero mutual pairs. Which means that the graph has no pairs of nodes that are mutually reachable. Which implies that the graph is a DAG of components, each of which is a single node (so that there are no mutual pairs). Wait, but for n=0, there are no nodes. But the problem says that the input p can be 0. Let's see the sample input for p=0: output is 0 0.\n\nBut for p=0, what is the minimal number of nodes? Well, for p=0, the sum of C(k_i, 2) must be zero. Which implies that all k_i are 1 (since C(1,2)=0). So the sum of k_i is the number of components. But the minimal sum is achieved by having as few components as possible. Wait, but for p=0, the sum of C(k_i, 2) must be zero. Which requires that each k_i is 1. Because C(1, 2)=0. So the minimal number of nodes is the number of components, but since each component is of size 1, the sum is the number of components. But since the sum can be as small as possible. Wait, but the problem requires that the graph has exactly p=0 mutual pairs. So for example, a graph with 0 nodes (no nodes) satisfies that. But maybe the problem expects that the graph has at least one node? Or perhaps for p=0, the minimal number of nodes is 0. But looking at the sample input for p=0, the output is 0 0. So that's the case.\n\nBut when p=0, the minimal n is 0. However, perhaps the problem expects that for p=0, the minimal n is 0. However, in practice, for p=0, the graph can have any number of nodes as long as there are no mutual pairs. Which would require that the graph is a DAG of components where each component is a single node (so that there are no mutual pairs between any two nodes). But the minimal number of nodes is zero. However, perhaps the problem requires that the graph has at least one node. Let's check the sample input for p=0. The sample output is 0 0, which suggests that for p=0, the answer is 0 nodes and 0 unidirectional pairs.\n\nBut perhaps when p=0, the minimal number of nodes is zero. However, for p=0, the minimal number of nodes can also be 1 (a single node, which has zero mutual pairs). But the minimal n is 0. However, the problem may have constraints that n ≥ 1. But looking at the sample input where p=0, the output is 0 0. So that's acceptable.\n\nBut perhaps the code needs to handle p=0 correctly. Let's think.\n\nNow, how to implement the first part.\n\nImplementing the greedy decomposition:\n\nWe can write a function that, given p, returns the list of k_i's.\n\nFor example:\n\ndef find_decomposition(p):\n\n    decomposition = []\n\n    while p > 0:\n\n        # find the maximum k such that k*(k-1)//2 <= p\n\n        # binary search for k.\n\n        low = 1\n\n        high = 2 * 10**5 + 2  # arbitrary upper bound.\n\n        best_k = 1\n\n        while low <= high:\n\n            mid = (low + high) // 2\n\n            val = mid * (mid -1) // 2\n\n            if val <= p:\n\n                best_k = mid\n\n                low = mid + 1\n\n            else:\n\n                high = mid -1\n\n        decomposition.append(best_k)\n\n        p -= best_k * (best_k -1) // 2\n\n    return decomposition\n\nBut for p=0, the loop doesn't run, and returns empty list.\n\nBut then, for the case when p=0, the decomposition is empty. So the sum of the decomposition is zero. Which is correct.\n\nOnce we have the decomposition, the minimal n is sum(decomposition). However, there's a corner case when p=0. For example, if p=0, the decomposition is empty, sum is 0. So the minimal n is zero. Which matches the sample input.\n\nBut when p=0, the graph can be constructed with zero nodes. However, perhaps the problem requires that the graph has at least one node. But according to the sample input, when p=0, the output is 0 0, which implies that zero nodes is acceptable.\n\nBut what about when p=0 and the user wants a graph with at least one node? Well, according to the problem statement, the input p can be zero, and the output for p=0 is 0 0. So the code should return that.\n\nBut let's think about the case when p=0 and n=0. Then, the number of unidirectional pairs is zero, which is correct.\n\nAnother example: p=0, but the decomposition is empty. So sum_sq is 0. Then, the number of unidirectional pairs is",
    "response": "To solve this problem, we need to determine the minimum number of nodes required to create a p-reachable directed graph and then find the maximum number of unidirectional pairs in such graphs with the minimum number of nodes.\n\n### Approach\n1. **Understanding p-reachable Graphs**: A p-reachable graph has exactly `p` ordered pairs (u, v) where `u < v` and both nodes are mutually reachable.\n2. **Decomposition into Strongly Connected Components (SCCs)**: The key insight is that the number of mutual pairs can be determined by decomposing `p` into sums of combinations of component sizes. Each component contributes `C(k, 2)` mutual pairs where `k` is the size of the component.\n3. **Greedy Decomposition**: To minimize the number of nodes, we use a greedy approach to decompose `p` into the largest possible components. This ensures the minimal sum of node counts.\n4. **Maximizing Unidirectional Pairs**: Once the minimum number of nodes is determined, the maximum number of unidirectional pairs is derived by arranging these components in a linear order and calculating the number of such pairs using the formula derived from the sum of products of component sizes.\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    p = int(sys.stdin.readline())\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    decomposition = []\n    remaining_p = p\n\n    while remaining_p > 0:\n        # Binary search for the largest k such that k*(k-1)//2 <= remaining_p\n        low = 1\n        high = 2 * 10**5 + 2  # Upper bound for k\n        best_k = 1\n        while low <= high:\n            mid = (low + high) // 2\n            val = mid * (mid - 1) // 2\n            if val <= remaining_p:\n                best_k = mid\n                low = mid + 1\n            else:\n                high = mid - 1\n        decomposition.append(best_k)\n        remaining_p -= best_k * (best_k - 1) // 2\n\n    n = sum(decomposition)\n    sum_sq = sum(k * k for k in decomposition)\n    unidirectional = (n * n - sum_sq) // 2\n    print(f\"{n} {unidirectional}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read as an integer `p`.\n2. **Handling Edge Case for p=0**: Directly handle the case where `p=0` which requires 0 nodes and 0 unidirectional pairs.\n3. **Greedy Decomposition**: For each remaining value of `p`, find the largest `k` such that `C(k, 2)` does not exceed the remaining value of `p`. This is done using binary search to efficiently determine the largest valid `k`.\n4. **Summing Component Sizes**: The total number of nodes `n` is the sum of all component sizes found during decomposition.\n5. **Calculating Unidirectional Pairs**: Using the formula derived from the sum of products of component sizes arranged in a linear order, we compute the maximum number of unidirectional pairs.\n\nThis approach ensures that we efficiently determine the minimal number of nodes and maximize the unidirectional pairs using mathematical properties of combinations and component arrangements.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    p = int(sys.stdin.readline())\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    decomposition = []\n    remaining_p = p\n\n    while remaining_p > 0:\n        # Binary search for the largest k such that k*(k-1)//2 <= remaining_p\n        low = 1\n        high = 2 * 10**5 + 2  # Upper bound for k\n        best_k = 1\n        while low <= high:\n            mid = (low + high) // 2\n            val = mid * (mid - 1) // 2\n            if val <= remaining_p:\n                best_k = mid\n                low = mid + 1\n            else:\n                high = mid - 1\n        decomposition.append(best_k)\n        remaining_p -= best_k * (best_k - 1) // 2\n\n    n = sum(decomposition)\n    sum_sq = sum(k * k for k in decomposition)\n    unidirectional = (n * n - sum_sq) // 2\n    print(f\"{n} {unidirectional}\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 481,
        "completion_token_count": 720,
        "thoughts_token_count": 8192
    }
}