{
    "start": 1758309688.115385,
    "end": 1758309727.2461631,
    "start-formatted": "2025-09-20 04:21 KST",
    "end-formatted": "2025-09-20 04:22 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\nOkay, let's try to figure out how to solve this problem. The problem is about restoring the number of mushrooms on each lawn based on the GCD and LCM values given for each road (edge) between two lawns (vertices). \n\nFirst, I need to understand the constraints. For each edge between two nodes u and v, we have a GCD (g) and LCM (l) of their mushroom counts. Let's denote the mushroom counts as a_u and a_v. Then, we know that:\n\ngcd(a_u, a_v) = g\nlcm(a_u, a_v) = l\n\nBut there's a relationship between GCD and LCM: for any two numbers, gcd(a, b) * lcm(a, b) = a * b. So, that gives us that a_u * a_v = g * l. Also, since the GCD is g, both a_u and a_v must be multiples of g. Let me think: if a_u and a_v are multiples of g, then we can write them as a_u = g * x, a_v = g * y, where x and y are coprime (since their GCD is 1). Then, the LCM of a_u and a_v would be g * x * y. But according to the problem, the LCM is l. So, g * x * y = l → x * y = l / g. Also, since x and y are coprime, this product must be such that x and y are factors of l/g and coprime.\n\nSo, for each edge, the product of x and y must be equal to l/g, and x and y must be coprime. Therefore, for each edge, we can derive that l must be divisible by g. Otherwise, it's impossible. Because if l is not divisible by g, then l/g is not an integer, and thus x*y can't be that. So that's a check we need to perform first. If for any edge, l % g != 0, then the answer is immediately NO.\n\nSo the first step is to check for each edge if LCM is divisible by GCD. If not, output NO.\n\nOnce that's done, for each edge, we can model the problem as building a graph where each node has a value, and for each edge, the two nodes' values must be multiples of the GCD, and their product must be GCD * LCM. But how do we assign these values?\n\nThis seems like a problem that can be modeled with a graph and constraints. Since each edge gives a relationship between two nodes, perhaps we can model this as a graph where each node's value is determined relative to others. However, since the relationships are multiplicative, maybe we can model this with some kind of union-find structure with constraints, or perhaps a BFS approach where we assign values based on connected components.\n\nLet me think. For example, suppose we have a connected component. We can assign a value to one node, and then determine the values of the others based on the edges. But how?\n\nLet me take an example. Suppose there is an edge between u and v with GCD g and LCM l. Then, a_u and a_v must be multiples of g. Also, a_u * a_v = g*l. Let's say that a_u = g * x, a_v = g * y. Then x*y = l/g, and gcd(x,y) = 1. So for each edge, x and y must be coprime. But how do we find x and y?\n\nBut since the problem allows any valid assignment, perhaps we can choose x and y as factors of l/g that are coprime. However, the choice of x and y affects the rest of the graph. For example, if another edge connects v to w, then the value of a_v would affect the possible values of a_w.\n\nThis suggests that the problem can be modeled as a graph where each node's value is determined relative to others, but with constraints. However, since the constraints involve multiplicative factors, perhaps we can model this as a system of equations where each equation is a_u / g = x, a_v / g = y, etc., and x and y are coprime.\n\nAlternatively, considering that each node's value is a multiple of the GCD of its edges. Wait, but each node can be part of multiple edges. So the value of a node must be a multiple of all the GCDs of the edges connected to it. Wait, no. For example, if a node u is connected to v with GCD g1 and to w with GCD g2, then a_u must be a multiple of g1 and also a multiple of g2. Therefore, the value of a_u must be a multiple of the LCM of all the GCDs of edges connected to u. But that",
    "response": "To solve this problem, we need to determine if it is possible to restore the number of mushrooms on each lawn based on given GCD and LCM values for each road connecting two lawns. The solution involves checking constraints and using a graph traversal approach to assign mushroom counts.\n\n### Approach\n1. **Check Validity of Input**: For each edge, ensure that the LCM is divisible by the GCD. If not, the configuration is impossible.\n2. **Graph Construction**: Use a graph where each node represents a lawn and edges represent the constraints (GCD and LCM).\n3. **Breadth-First Search (BFS)**: Traverse the graph starting from an arbitrary node, assigning mushroom counts based on the constraints provided by the edges. This ensures that we propagate valid values through the connected components of the graph.\n4. **Validation**: During BFS traversal, validate that the assigned values satisfy both GCD and LCM constraints for each edge.\n\n### Solution Code\n```python\nimport sys\nimport math\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n    \n    edges = []\n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        u = int(input[idx]) - 1\n        idx += 1\n        v = int(input[idx]) - 1\n        idx += 1\n        g = int(input[idx])\n        idx += 1\n        l = int(input[idx])\n        idx += 1\n        if l % g != 0:\n            print(\"NO\")\n            return\n        edges.append((u, v, g, l))\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l))\n    \n    visited = [False] * n\n    values = [0] * n\n    \n    for start in range(n):\n        if not visited[start]:\n            queue = deque()\n            queue.append(start)\n            visited[start] = True\n            values[start] = 1  # arbitrary value, will be adjusted later\n            \n            while queue:\n                u = queue.popleft()\n                for (v, g, l) in adj[u]:\n                    if not visited[v]:\n                        # Compute product of a_u and a_v must be g*l\n                        # Also, a_u must be multiple of g, same for a_v\n                        # We have a_u = g * x, a_v = g * y, x*y = l/g, gcd(x,y)=1\n                        # Since we have a_u already, compute a_v\n                        if values[u] == 0:\n                            # This should not happen as we are processing connected components\n                            print(\"NO\")\n                            return\n                        prod = g * l\n                        a_u = values[u]\n                        if a_u % g != 0:\n                            print(\"NO\")\n                            return\n                        a_v = prod // a_u\n                        # Check if gcd(a_u, a_v) == g and lcm(a_u, a_v) == l\n                        if math.gcd(a_u, a_v) != g or (a_u * a_v) // math.gcd(a_u, a_v) != l:\n                            print(\"NO\")\n                            return\n                        values[v] = a_v\n                        visited[v] = True\n                        queue.append(v)\n                    else:\n                        # Check if current values satisfy the constraints\n                        a_u = values[u]\n                        a_v = values[v]\n                        if math.gcd(a_u, a_v) != g or (a_u * a_v) // math.gcd(a_u, a_v) != l:\n                            print(\"NO\")\n                            return\n    \n    print(\"YES\")\n    print(' '.join(map(str, values)))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Input Reading and Initial Checks**: The input is read and parsed. For each edge, we check if the LCM is divisible by the GCD. If not, the answer is immediately \"NO\".\n2. **Graph Traversal with BFS**: Using BFS, we traverse each connected component of the graph. Starting from an arbitrary node, we assign values ensuring that they meet the constraints of GCD and LCM for each edge.\n3. **Validation During Traversal**: As we assign values during BFS, we validate that the values satisfy the GCD and LCM constraints for each edge. If any inconsistency is found, the answer is \"NO\".\n4. **Output**: If all constraints are satisfied, the mushroom counts for each lawn are printed. If any inconsistency is found during traversal, the answer is \"NO\".",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n    \n    edges = []\n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        u = int(input[idx]) - 1\n        idx += 1\n        v = int(input[idx]) - 1\n        idx += 1\n        g = int(input[idx])\n        idx += 1\n        l = int(input[idx])\n        idx += 1\n        if l % g != 0:\n            print(\"NO\")\n            return\n        edges.append((u, v, g, l))\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l))\n    \n    visited = [False] * n\n    values = [0] * n\n    \n    for start in range(n):\n        if not visited[start]:\n            queue = deque()\n            queue.append(start)\n            visited[start] = True\n            values[start] = 1  # arbitrary value, will be adjusted later\n            \n            while queue:\n                u = queue.popleft()\n                for (v, g, l) in adj[u]:\n                    if not visited[v]:\n                        # Compute product of a_u and a_v must be g*l\n                        # Also, a_u must be multiple of g, same for a_v\n                        # We have a_u = g * x, a_v = g * y, x*y = l/g, gcd(x,y)=1\n                        # Since we have a_u already, compute a_v\n                        if values[u] == 0:\n                            # This should not happen as we are processing connected components\n                            print(\"NO\")\n                            return\n                        prod = g * l\n                        a_u = values[u]\n                        if a_u % g != 0:\n                            print(\"NO\")\n                            return\n                        a_v = prod // a_u\n                        # Check if gcd(a_u, a_v) == g and lcm(a_u, a_v) == l\n                        if math.gcd(a_u, a_v) != g or (a_u * a_v) // math.gcd(a_u, a_v) != l:\n                            print(\"NO\")\n                            return\n                        values[v] = a_v\n                        visited[v] = True\n                        queue.append(v)\n                    else:\n                        # Check if current values satisfy the constraints\n                        a_u = values[u]\n                        a_v = values[v]\n                        if math.gcd(a_u, a_v) != g or (a_u * a_v) // math.gcd(a_u, a_v) != l:\n                            print(\"NO\")\n                            return\n    \n    print(\"YES\")\n    print(' '.join(map(str, values)))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 559,
        "completion_token_count": 986,
        "thoughts_token_count": 1024
    }
}