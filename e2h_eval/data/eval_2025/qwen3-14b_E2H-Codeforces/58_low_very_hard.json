{
    "start": 1758309586.970089,
    "end": 1758309811.405218,
    "start-formatted": "2025-09-20 04:19 KST",
    "end-formatted": "2025-09-20 04:23 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\nOkay, I need to solve this programming problem. Let's read the problem carefully.\n\nThe task is to find the minimum number of edges (t) that must be added to a given undirected graph so that there exists a simple cycle of odd length (more than one vertex). Also, find the number of ways (w) to add exactly t edges to achieve this.\n\nFirst, let's understand what's required. A simple cycle with odd length. So, the graph needs to have at least one such cycle. But the original graph may not have it. We need to find the minimal t and count the number of ways to add edges to reach that.\n\nLet me think about the properties of bipartite graphs. Because a bipartite graph cannot have any odd-length cycles. Conversely, if a graph has an odd-length cycle, it's not bipartite. So, the problem reduces to checking if the graph is bipartite. If it's not bipartite already, then there exists an odd cycle, so t is 0 and w is 1? Wait no. Because the question says to find the minimal number of edges to add to form such a cycle. If the graph already contains such a cycle, then t is 0 and w is 1? Or maybe there are multiple existing cycles?\n\nWait, the output requires that t is the minimal number of edges needed. So if the graph already has an odd-length cycle, then t is 0. But how do we compute w? The number of ways to add t edges (which is zero) to form such a cycle. But since adding zero edges would mean that there's already such a cycle. However, the problem says that the answer w is the number of ways to add exactly t edges (so zero edges) to form a cycle. But in that case, the way is just 1? Or maybe there are multiple existing cycles, but the problem counts the number of ways to add edges (which is zero) to form any of them. However, the problem says that the ways are considered equal if they have the same set of added edges. Since adding zero edges, there's only one way. But perhaps the question is not about existing cycles. Wait, the problem says that the answer is the number of ways to add t edges to form a cycle. So when t is zero, the answer is the number of existing cycles that are odd-length? No, no. Because the problem says that you need to find the number of ways to add exactly t edges (which is zero) such that after adding those edges, there exists a cycle of odd length. But since the graph already has such a cycle, then adding zero edges would satisfy this. However, the problem says that the answer for w is the number of ways to add t edges to form a cycle. But adding zero edges can be done in exactly one way (no edges added), but the existence of multiple existing cycles doesn't affect that. Because the way is determined by the edges added, not by the existing cycles. So if the graph already has an odd cycle, then t is 0 and w is 1. But looking at the sample input:\n\nIn the second example, input is 3 nodes and 3 edges forming a triangle (which is an odd cycle). The output is 0 1. Which matches that. So yes, in this case, the answer is t=0 and w=1. So that makes sense.\n\nSo first, check if the graph already contains an odd-length cycle. If yes, then t=0 and w=1.\n\nBut how to check if the graph has an odd-length cycle? Well, the graph is bipartite if and only if it has no odd-length cycles. So if the graph is not bipartite, then it has at least one odd-length cycle. Therefore, the first step is to check if the graph is bipartite. If it's not bipartite, then t is 0 and w is 1. But wait, maybe there are multiple ways to form such a cycle. However, the problem says that the answer for w is the number of ways to add t edges (which is zero here) to form a cycle. But since adding zero edges is only one way, regardless of how many existing cycles there are. So the answer is 1 in that case.\n\nSo the first case: if the graph is not bipartite, then t=0 and w=1.\n\nNow, if the graph is bipartite, then we need to add edges to create an odd-length cycle. How can we do that?\n\nIn a bipartite graph, all cycles are even-length. So adding edges to create an odd-length cycle. How?\n\nLet me think. For a bipartite graph, each connected component is bipartite. Let's consider each connected component. Suppose that a connected component is bipartite. Let's say that the component has two partitions, say A and B",
    "response": "To solve this problem, we need to determine the minimum number of edges (t) that must be added to an undirected graph to form a simple cycle of odd length, and the number of ways (w) to do so.\n\n### Approach\n1. **Check for Existing Odd Cycle**: If the graph already contains an odd-length cycle, then no edges need to be added (t = 0) and there is exactly one way to achieve this (w = 1).\n2. **Bipartite Graph Check**: If the graph is bipartite, it does not contain any odd-length cycles. We need to determine how to add edges to create such a cycle.\n3. **Component Analysis**: For each connected component in the graph, if it is bipartite, we need to consider the sizes of its two partitions. Adding an edge between two vertices in the same partition of a bipartite graph will create an odd-length cycle.\n4. **Minimum Edges Calculation**: The minimum number of edges required to form an odd-length cycle in a bipartite graph is 1. This can be done by connecting two vertices in the same partition.\n5. **Counting Ways**: The number of ways to add such edges is determined by the number of possible pairs of vertices within each partition of each connected component.\n\n### Solution Code\n```python\nimport sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split('\\n')\n    idx = 0\n    while idx < len(input) and input[idx] == '':\n        idx += 1\n    if idx >= len(input):\n        print(\"0 1\")\n        return\n\n    n, m = map(int, input[idx].split())\n    idx += 1\n    edges = []\n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        while idx < len(input) and input[idx] == '':\n            idx += 1\n        if idx >= len(input):\n            break\n        a, b = map(int, input[idx].split())\n        edges.append((a-1, b-1))\n        adj[a-1].append(b-1)\n        adj[b-1].append(a-1)\n        idx += 1\n\n    # Check if the graph is bipartite\n    color = [-1] * n\n    is_bipartite = True\n    components = []\n\n    for start in range(n):\n        if color[start] == -1:\n            queue = deque()\n            queue.append(start)\n            color[start] = 0\n            cnt = [0, 0]\n            cnt[0] += 1\n            comp = []\n            while queue:\n                u = queue.popleft()\n                comp.append(u)\n                for v in adj[u]:\n                    if color[v] == -1:\n                        color[v] = color[u] ^ 1\n                        cnt[color[v]] += 1\n                        queue.append(v)\n            components.append(cnt)\n    \n    # Check if the graph is bipartite\n    # If any component is not bipartite, then the graph is not bipartite\n    # But since we used BFS, if the graph is bipartitioned, then all components are bipartite\n    # So the check is whether the graph is bipartite or not\n    # Wait, the code above checks for bipartition during BFS, but if the graph is not bipartite, then during BFS, we would have found a conflict\n    # So we need to redo the check properly\n\n    color = [-1] * n\n    is_bipartite = True\n    for start in range(n):\n        if color[start] == -1:\n            queue = deque()\n            queue.append(start)\n            color[start] = 0\n            while queue:\n                u = queue.popleft()\n                for v in adj[u]:\n                    if color[v] == -1:\n                        color[v] = color[u] ^ 1\n                        queue.append(v)\n                    elif color[v] == color[u]:\n                        is_bipartite = False\n\n    if not is_bipartite:\n        print(\"0 1\")\n        return\n\n    # Now, the graph is bipartite, so need to find t and w\n    # t is 1, since adding one edge between two nodes in the same partition of a component\n    # w is the sum over all components of (count_A choose 2 + count_B choose 2)\n    total_ways = 0\n    for cnt in components:\n        a, b = cnt\n        total_ways += (a * (a - 1) // 2) + (b * (b - 1) // 2)\n\n    print(f\"1 {total_ways}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into vertices and edges.\n2. **Bipartite Check**: Using BFS, we check if the graph is bipartite. If it is not bipartite, the graph already contains an odd-length cycle.\n3. **Component Analysis**: For each connected component in the graph, we count the number of vertices in each partition.\n4. **Calculating Ways**: For each component, the number of ways to add an edge between vertices in the same partition is calculated using combinations. The total number of ways across all components is summed up.\n5. **Output**: If the graph is bipartite, the minimum edges needed (t) is 1 and the number of ways (w) is the total calculated from the components. If the graph is not bipartite, the answer is 0 and 1.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split('\\n')\n    idx = 0\n    while idx < len(input) and input[idx] == '':\n        idx += 1\n    if idx >= len(input):\n        print(\"0 1\")\n        return\n\n    n, m = map(int, input[idx].split())\n    idx += 1\n    edges = []\n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        while idx < len(input) and input[idx] == '':\n            idx += 1\n        if idx >= len(input):\n            break\n        a, b = map(int, input[idx].split())\n        edges.append((a-1, b-1))\n        adj[a-1].append(b-1)\n        adj[b-1].append(a-1)\n        idx += 1\n\n    # Check if the graph is bipartite\n    color = [-1] * n\n    is_bipartite = True\n    components = []\n\n    for start in range(n):\n        if color[start] == -1:\n            queue = deque()\n            queue.append(start)\n            color[start] = 0\n            cnt = [0, 0]\n            cnt[0] += 1\n            comp = []\n            while queue:\n                u = queue.popleft()\n                comp.append(u)\n                for v in adj[u]:\n                    if color[v] == -1:\n                        color[v] = color[u] ^ 1\n                        cnt[color[v]] += 1\n                        queue.append(v)\n            components.append(cnt)\n    \n    # Check if the graph is bipartite\n    # If any component is not bipartite, then the graph is not bipartite\n    # But since we used BFS, if the graph is bipartitioned, then all components are bipartite\n    # So the check is whether the graph is bipartite or not\n    # Wait, the code above checks for bipartition during BFS, but if the graph is not bipartite, then during BFS, we would have found a conflict\n    # So we need to redo the check properly\n\n    color = [-1] * n\n    is_bipartite = True\n    for start in range(n):\n        if color[start] == -1:\n            queue = deque()\n            queue.append(start)\n            color[start] = 0\n            while queue:\n                u = queue.popleft()\n                for v in adj[u]:\n                    if color[v] == -1:\n                        color[v] = color[u] ^ 1\n                        queue.append(v)\n                    elif color[v] == color[u]:\n                        is_bipartite = False\n\n    if not is_bipartite:\n        print(\"0 1\")\n        return\n\n    # Now, the graph is bipartite, so need to find t and w\n    # t is 1, since adding one edge between two nodes in the same partition of a component\n    # w is the sum over all components of (count_A choose 2 + count_B choose 2)\n    total_ways = 0\n    for cnt in components:\n        a, b = cnt\n        total_ways += (a * (a - 1) // 2) + (b * (b - 1) // 2)\n\n    print(f\"1 {total_ways}\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 579,
        "completion_token_count": 1190,
        "thoughts_token_count": 1024
    }
}