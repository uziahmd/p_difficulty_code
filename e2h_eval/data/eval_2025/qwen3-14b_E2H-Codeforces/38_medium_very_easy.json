{
    "start": 1758338785.0927117,
    "end": 1758338992.636881,
    "start-formatted": "2025-09-20 12:26 KST",
    "end-formatted": "2025-09-20 12:29 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\nOkay, let's try to understand this problem. So the task is to find two things for a given p: the minimum number of nodes needed in a directed graph that is p-reachable, and then among all such graphs with that minimum number of nodes, find the maximum number of unidirectional pairs.\n\nFirst, let's parse the definitions again. A p-reachable graph has exactly p ordered pairs (u, v) where u < v and u and v are reachable from each other. Wait, but reachability here is mutual? Like, both can reach each other. So for each such pair (u, v), they form a strongly connected component, or maybe part of a larger component where they can reach each other.\n\nThe first part of the problem is to find the minimal number of nodes required to have exactly p such pairs. Then, among those graphs with that minimal node count, find the maximum number of unidirectional pairs.\n\nLet me think about how to model this. For the first part, perhaps we need to find the minimal n such that the maximum possible number of pairs (u < v) that are mutually reachable is at least p. Wait, no. Because the graph must have exactly p such pairs. But how do we arrange the graph to get exactly p?\n\nBut maybe the minimal number of nodes is determined by finding the smallest n where the maximum possible number of pairs (u < v) that can be mutually reachable is at least p. Wait, but how?\n\nAlternatively, think about the structure of the graph. Let's consider that the graph is composed of multiple strongly connected components (SCCs). For any two nodes in the same SCC, they are mutually reachable. Also, if there's a path from one SCC to another, then nodes in the first can reach nodes in the second, but not vice versa (assuming the components are arranged in a DAG structure).\n\nBut the problem counts ordered pairs (u, v) where u < v and they are mutually reachable. So for each pair of nodes in the same SCC, if u < v, that contributes 1 to p. So the total number of such pairs is the sum over all SCCs of C(k, 2), where k is the size of the SCC. Because for each SCC of size k, there are k choose 2 ordered pairs (u, v) with u < v.\n\nSo the problem reduces to choosing a set of SCC sizes such that the sum of C(k_i, 2) for each component equals exactly p. And we need to find the minimal total number of nodes (sum of k_i) for which this sum is exactly p. Then, among all such configurations, find the maximum number of unidirectional pairs.\n\nWait, but what about the unidirectional pairs? Those are pairs (u, v) where u != v, there's a path from u to v, but not vice versa. So for two different components, if there's a path from component A to component B, then all pairs (u in A, v in B) where u can reach v, but not vice versa, contribute to unidirectional pairs. However, since the components are arranged in a DAG, there can be edges between them. But the way to maximize the number of unidirectional pairs would be to arrange the components in a way that maximizes these cross-component pairs.\n\nBut first, let's focus on the first part: finding the minimal number of nodes for the p-reachable condition.\n\nSo the key is to find the minimal sum of k_i (the sizes of the components) such that the sum of C(k_i, 2) equals exactly p. However, since the sum of C(k_i, 2) can be less than p, but we need it to be exactly p. Wait, no. The problem says that the graph must contain exactly p such pairs. Therefore, the sum of C(k_i, 2) must equal p. Because each pair of nodes in the same component contributes exactly once to the count (since u < v).\n\nSo the problem reduces to partitioning p into a sum of terms of the form C(k_i, 2), and find the minimal sum of k_i across all such partitions. Then, the minimal n is that sum.\n\nFor example, in the first sample input where p is 3. Let's see:\n\nC(3, 2) = 3, so a single component of size 3 gives sum 3. So minimal n is 3. That's the first sample.\n\nAnother sample is when p is 0. Then, the sum of C(k_i, 2) must be zero. Which implies that all components have size 1, since C(1, 2) is zero. So the minimal number of nodes is 0? Wait, no. Wait, if p is zero, then the graph must have exactly zero ordered pairs (u, v) with u < v and mutually reachable. Which can be achieved by having all components of size 1. So the number of nodes can be any number, but the minimal is 0? Wait, but the problem says \"nodes\" — but for p=0, perhaps the graph can have zero nodes? But that's probably not allowed. Let's check the sample input.\n\nIn the third example, input is 0, output is 0 0. So that's allowed. So for p=0, the minimal number of nodes is 0. But maybe the problem allows that. But in general, for p=0, the minimal number of nodes is zero. But perhaps the problem expects that for p=0, the answer is 0 nodes, and the maximum number of unidirectional pairs is zero.\n\nBut how do we handle the case when p is zero? Well, the problem's note shows that for p=0, the output is 0 0. So that's correct.\n\nNow, the problem is to find the minimal n such that there exists a set of integers k_1, k_2, ..., k_m where sum_{i} C(k_i, 2) = p, and sum k_i is minimized.\n\nSo how to find that minimal sum of k_i given p?\n\nThis seems similar to a problem where you want to represent p as the sum of combinations, and minimize the sum of the numbers. For example, for each term C(k,2), which is k*(k-1)/2. We need to find the minimal sum of k_i's such that their combination sums to p.\n\nTo minimize the sum of k_i's, we should maximize the value of each term per unit of sum. For example, for a given value of C(k, 2), the sum k is as small as possible. For example, if we can take the largest possible C(k, 2) that is less than or equal to p, subtract it from p, and repeat. But this is a greedy approach, but is it correct?\n\nLet me think. Suppose we have p=5. What's the best way to split it?\n\nOption 1: C(3,2)=3, and C(2,2)=1, and C(2,2)=1. Total sum is 3+2+2=7 nodes. Or maybe C(3,2) + C(2,2) + ... but wait 3+1+1=5. So sum is 3+2+2=7?\n\nAlternatively, can we use C(4,2) = 6, which is larger than 5. So no. So the next option is 3 (C(3,2)) and then 2 (C(2,2) =1). Then 5-3=2, which needs another 2. So 3+2+2=7 nodes.\n\nBut another approach: using two C(3,2) terms. 3+3=6, which is more than 5. Not allowed. So perhaps the greedy approach is to take the largest possible C(k,2) less than or equal to the remaining p.\n\nWait, but for p=5, the largest possible is C(3,2)=3. Then remaining is 2. The largest possible for 2 is C(2,2)=1. Then remaining is 1, again C(2,2)=1. So total is 3+2+2=7 nodes. But another way: maybe using two C(3,2) terms would be 3+3=6, which is over. Not allowed. Alternatively, maybe using one C(3,2) and one C(2,2) and one C(2,2) gives 3+1+1=5. So that's correct. But sum is 3+2+2=7.\n\nBut another possibility: can we split into C(3,2) + C(2,2) = 3+1=4, and then have 1 left. So that's 3+2 + ... but then how?\n\nAlternatively, perhaps splitting into C(2,2) five times. Sum is 2*5=10 nodes, which is worse than 7. So the greedy approach of taking the largest possible C(k,2) seems better.\n\nSo the minimal sum is achieved by taking as many as possible of the largest possible C(k,2) terms. But how to compute that?\n\nSo the idea is to find the maximum possible k for which C(k, 2) <= p, subtract it from p, and repeat. But this may not be optimal. For example, maybe splitting into smaller terms could result in a smaller sum.\n\nWait, let's take an example. Suppose p=4. The largest C(k, 2) is 3 (for k=3). Then remaining is 1. Then take another C(2,2)=1. Total sum is 3+2=5. Alternatively, can we use two C(3,2) terms? No, because 3+3=6>4. But what about using one C(3,2) and one C(2,2) gives 3+1=4. So that's correct. But what if we take two C(2,2) terms (each 1) and one C(2,2) term. No, that's 3 terms. So 2*3=6 nodes. So the greedy approach is better.\n\nAnother example: p=6. C(4,2) is 6. So sum is 4 nodes. Which is better than splitting into 3+3 (but that would require two components of size 3, sum 3+3=6 nodes. So the greedy approach is better. So yes, the greedy approach of taking the maximum possible C(k,2) each time seems to be optimal.\n\nSo the algorithm for the first part is:\n\nFind the minimal sum of k_i's such that sum C(k_i, 2) = p.\n\nThis can be done greedily by taking the largest possible k for which C(k,2) <= current p, subtract it from p, and repeat until p becomes 0.\n\nSo for example, for p=3, the largest k is 3 (since C(3,2)=3). So sum is 3.\n\nFor p=4, take 3 (C(3,2)=3), then 1 (C(2,2)=1). So sum 3+2=5.\n\nBut wait, what if there's a way to split into components that gives a smaller sum? Let's see.\n\nSuppose p=4. Another way is to have two components of size 2 and 3. Wait, C(3,2) is 3, and C(2,2) is 1. Sum 3+1=4. So sum of nodes is 3+2=5. Alternatively, can we have a component of size 4? C(4,2) is 6, which is larger than 4. So no. So the minimal sum is indeed 5.\n\nBut what about p=5? Greedy approach would take 3 (C(3,2)=3), then 2 (C(2,2)=1) and another 2 (C(2,2)=1). Total sum 3+2+2=7. Alternatively, can we find a better way?\n\nWhat if we take two components of size 3 and 2. C(3,2) is 3, and C(2,2) is 1. Sum is 4. But that's only 4. So need to add another 1. So maybe another component of size 2. Then sum is 3+2+2=7. Same as before.\n\nAlternatively, is there a way to split into components with sum of C(k_i, 2) = 5?\n\nYes. For example, one component of size 3 (3) and one component of size 3 (3). But that gives 6, which is more than 5. Not allowed. How about one component of size 3 (3) and one component of size 2 (1) and one component of size 2 (1). Total is 3+1+1=5. So sum of nodes is 3+2+2=7. So same as before.\n\nAnother way: can we have a component of size 4? C(4,2) is 6, which is larger than 5. No. So no.\n\nSo the minimal sum is indeed 7.\n\nTherefore, the greedy approach seems correct.\n\nSo the algorithm for the first part is:\n\nInitialize n = 0.\n\nWhile p > 0:\n\n   Find the maximum k such that k*(k-1)/2 ≤ p.\n\n   Subtract k*(k-1)/2 from p.\n\n   Add k to n.\n\nBut wait, how do we find that k? For a given p, we can compute k as the floor of (sqrt(8p + 1) + 1)/2.\n\nLet me think. The equation k(k-1)/2 = p → k² -k - 2p = 0. The positive solution is [1 + sqrt(1 + 8p)] / 2. So the maximum k is floor([sqrt(8p + 1) + 1]/2).\n\nBut let me check with p=3. sqrt(8*3 +1) = sqrt(25) =5. So (5+1)/2=3. So k=3. Correct.\n\nFor p=4: sqrt(33) is approx 5.744. Adding 1 gives 6.744. Divided by 2 is ~3.37. So floor is 3. So k=3. Which is correct.\n\nOnce we find that k, subtract k*(k-1)/2 from p, and add k to the total nodes.\n\nSo this process will give us the minimal number of nodes for the first part.\n\nNow, once we have the minimal number of nodes, we need to compute the maximum number of unidirectional pairs.\n\nSo, for the second part, given that the graph is structured with certain components (the ones chosen in the first part), how can we arrange the components in a DAG to maximize the number of unidirectional pairs?\n\nThe unidirectional pairs are pairs (u, v) where u and v are in different components, and there is a directed path from u to v but not vice versa. Also, pairs within the same component are not counted as unidirectional (since they are mutually reachable).\n\nSo the maximum number of unidirectional pairs is achieved by arranging the components in a linear order, such that each component points to all components that come after it. Then, for any two components A and B, if A comes before B, then all pairs (u in A, v in B) contribute to unidirectional pairs. Similarly, if B comes before A, then all pairs (v in B, u in A) contribute to unidirectional pairs. But since we want to maximize the total, we need to arrange the components in a way that maximizes the number of ordered pairs (u, v) where u is in a component before v, and there's a path from u to v.\n\nThe maximum is achieved when the components are arranged in a linear order (a chain), and each component has edges to all components that come after it. In this case, for each pair of components (A, B), if A is before B, then all pairs (u in A, v in B) are unidirectional. So the total number of such pairs is sum_{i < j} (size_i * size_j), where size_i is the size of component i.\n\nBut wait, the problem counts ordered pairs (u, v) where u != v, and there's a path from u to v but not vice versa. So in this setup, for any two components A and B, if A is before B, then all pairs (u in A, v in B) are unidirectional. But if there's a path from B to A, then those pairs (v in B, u in A) would be considered as well. However, in a linear arrangement, each component only points to those after it, so B cannot reach A. Thus, for each pair of components A and B, if A is before B, then all pairs (u in A, v in B) are unidirectional. If A is after B, then all pairs (u in B, v in A) are unidirectional. But since the components are arranged in a linear order, for any two components, exactly one of these is true. So the total number of unidirectional pairs between components is sum_{i < j} (size_i * size_j) * 1 (since each pair is counted once).\n\nBut also, for the same component, there are no unidirectional pairs (since they are mutually reachable). So the total number of unidirectional pairs is sum_{i < j} (size_i * size_j) * 1.\n\nBut what about the internal edges? For example, if a component has multiple nodes, but the internal edges are such that there are some unidirectional pairs? Wait, no. Because the component is strongly connected. So any pair (u, v) within the same component are mutually reachable. So they don't contribute to unidirectional pairs.\n\nTherefore, the maximum number of unidirectional pairs is achieved when the components are arranged in a linear order (so that each component points to all later components), and the total is the sum of size_i * size_j for all i < j.\n\nNow, the question is: given the sizes of the components (from the first part), how to arrange them to maximize this sum. Since the sum is maximized when the components are ordered in a way that the larger components are placed in positions where they are multiplied by as many other components as possible. Wait, but the sum is the same regardless of the order. Because sum_{i < j} (size_i * size_j) is equal to [ (sum size_i)^2 - sum (size_i^2) ] / 2. So regardless of the order, this sum is fixed. Therefore, the maximum number of unidirectional pairs is fixed once the component sizes are determined.\n\nWait, that's a crucial point. Because the sum of size_i * size_j for i < j is independent of the order of the components. Therefore, for a given set of component sizes, the maximum number of unidirectional pairs is fixed. Therefore, the second part of the problem depends on the component sizes chosen in the first part.\n\nBut wait, the first part requires that the sum of C(k_i, 2) equals p. However, the way we split p into the sum of C(k_i, 2) could affect the sum of size_i * size_j. Therefore, for the second part, among all possible ways to split p into the sum of C(k_i, 2) with minimal sum of k_i, we need to choose the one that maximizes the sum of size_i * size_j for i < j.\n\nWait, but the first part requires that the sum of k_i is minimal. So perhaps there are multiple ways to split p into the sum of C(k_i, 2) with the same minimal sum of k_i. For example, if p=4, the minimal sum is 5 (as discussed earlier, with components of size 3 and 2). But maybe there's another split with the same sum of k_i. For example, components of size 2, 2, and 2. Sum of C(2,2) is 1+1+1=3, which is not enough. So no. So perhaps the split is unique for the minimal sum. Therefore, the way we split p into the sum of C(k_i, 2) is unique for the minimal sum of k_i. Hence, once we find the minimal sum, the component sizes are fixed, and thus the maximum unidirectional pairs can be computed as [ (total_nodes)^2 - sum (size_i^2) ] / 2.\n\nBut wait, the total_nodes is the sum of size_i. Let's denote S = sum size_i. Then sum_{i < j} size_i * size_j = [S^2 - sum size_i^2 ] / 2.\n\nTherefore, the problem reduces to:\n\nOnce we have the component sizes (from the first part), compute S = sum size_i (which is the minimal number of nodes), then compute [S^2 - sum (size_i^2)] / 2.\n\nSo the steps are:\n\n1. Find the minimal number of nodes n, which is the sum of the sizes of the components, where the components are chosen via the greedy approach (maximizing C(k, 2) each time).\n\n2. Once the component sizes are known, compute the sum of their squares, then calculate the unidirectional pairs as (n^2 - sum_squares) // 2.\n\nBut wait, let's check the first sample. For p=3, the component is size 3. So sum_squares is 3^2 =9. n is 3. So (3^2 -9)/2 = (9-9)/2=0. Which matches the sample output of 0. Correct.\n\nAnother example: for p=4, the component sizes are 3 and 2. sum_squares is 9 +4=13. n is 5. So (5^2 -13)/2 = (25-13)/2 = 6. Which matches the sample output for input 4, which is 5 6. Yes, that's correct.\n\nSo the approach for the second part is to compute the sum of squares of the component sizes, and then apply the formula.\n\nSo the plan for the code is:\n\n- For a given p, compute the minimal number of nodes by greedily taking the largest possible k for each step.\n\n- While doing this, collect all the component sizes (like, for p=4, it's 3, 2).\n\n- Then compute sum_squares = sum(k_i^2) for those components.\n\n- The unidirectional pairs are (n^2 - sum_squares) // 2.\n\nBut how to collect the component sizes during the greedy process?\n\nLet me think. For example, for p=3:\n\nWe start with p=3. Compute k as 3. Subtract 3, add 3 to the list. Now p=0, stop.\n\nFor p=4: first k=3, subtract 3, p=1. Then compute k for p=1: which is 2 (since 2*1/2=1). Subtract 1, add 2 to the list. So component sizes are [3, 2].\n\nSo during the code, we can collect the list of component sizes.\n\nOnce we have that list, compute sum_squares.\n\nSo the code steps are:\n\nRead p.\n\nIf p is 0, then the answer is 0 0.\n\nElse:\n\nInitialize list components = empty.\n\ncurrent_p = p.\n\nwhile current_p > 0:\n\n   compute k as the maximum integer such that k*(k-1)//2 <= current_p.\n\n   add k to components.\n\n   subtract k*(k-1)//2 from current_p.\n\nOnce components is built, compute n = sum(components).\n\nsum_squares = sum(k*k for k in components)\n\nunidirectional_pairs = (n*n - sum_squares) // 2\n\nThen output n and unidirectional_pairs.\n\nBut wait, what about when p is zero? For p=0, the components list is empty. So sum(components) is zero. sum_squares is zero. So (0^2 - 0)/2 = 0. Which is correct.\n\nBut let's test for p=0. The code would output 0 0. Which is correct.\n\nAnother test case: p=1.\n\nThe maximum k is 2, since C(2, 2) =1. So components is [2]. n=2. sum_squares is 4. unidirectional pairs is (2^2 -4)/2 = 0. So output is 2 0.\n\nAnother example: p=2. What is the minimal n?\n\nGreedy approach: find k for p=2. C(2,2)=1, C(3,2)=3>2. So k=2. subtract 1, p becomes 1. Again, take k=2. subtract 1. p becomes 0. components are [2,2]. sum is 4. sum_squares is 4+4=8. unidirectional pairs is (4^2 - 8)/2 = (16-8)/2 = 4. So output is 4 4.\n\nBut is there a better way? For example, can we have a component of size 3? C(3,2) is 3, which is more than 2. So no. So the minimal n is 4. But what if we have a component of size 3 and subtract 3, but p=2 is less than 3. So no. So the code is correct.\n\nAnother example: p=6. The maximum k is 4, since C(4,2)=6. So components is [4], sum is 4. sum_squares is 16. unidirectional pairs is (4^2 - 16)/2 = (16-16)/2=0. So output is 4 0.\n\nWhich makes sense. Because all nodes are in the same component, so there are no pairs between components. Hence, no unidirectional pairs.\n\nBut if p=6, what if there's another way to split into components? For example, two components of size 3 each. sum C(3,2) is 3+3=6. So sum of nodes is 3+3=6. Which is worse than 4. So the code correctly chooses the minimal sum of 4.\n\nSo the code seems correct.\n\nNow, the problem is how to compute k for each step.\n\nHow to compute k given current_p.\n\nAs mentioned before, k is the floor of (sqrt(8*current_p + 1) + 1)/2.\n\nBut perhaps we can compute it via binary search. Alternatively, compute it with math.\n\nLet me think about the formula:\n\nk = floor( (sqrt(8p + 1) + 1)/2 )\n\nBut let's test for p=3: 8p+1=25, sqrt is 5. (5+1)/2=3. Correct.\n\nFor p=1: 8*1+1=9, sqrt 3. (3+1)/2=2. Correct.\n\nFor p=4: 8*4+1=33, sqrt is ~5.744. (5.744 +1)/2 is ~3.37, floor is 3. Correct.\n\nSo the formula works.\n\nBut how to compute it in code.\n\nIn Python, we can compute it as follows:\n\nimport math\n\ndef get_k(p):\n\n    if p == 0:\n\n        return 0\n\n    # solve k*(k-1)/2 <= p\n\n    # find the maximum k such that k*(k-1)/2 <= p.\n\n    # compute k as floor( (sqrt(8p +1) + 1)/2 )\n\n    sqrt_val = math.sqrt(8*p +1)\n\n    k = int( (sqrt_val +1 ) // 2 )\n\n    # but need to check if k*(k-1)/2 exceeds p.\n\n    # because sometimes due to floating point precision errors, the calculation may be off.\n\n    while k*(k-1)//2 > p:\n\n        k -=1\n\n    while (k+1)*k//2 <= p:\n\n        k +=1\n\n    return k\n\nWait, but perhaps a better way is to compute k as the floor of the expression, then check if (k+1)*k//2 <= p. But perhaps the initial calculation is sufficient. Let me think.\n\nAlternatively, compute k as the integer part of (sqrt(8p +1) + 1)/2, then adjust.\n\nBut perhaps it's easier to use binary search for k.\n\nBut given that p can be up to 2e5, even a loop is acceptable.\n\nBut for code efficiency, perhaps the formula is better.\n\nBut let's proceed with the code.\n\nIn Python, for each current_p, compute k as follows:\n\nCompute sqrt_val = sqrt(8 * current_p + 1)\n\nk_candidate = int( (sqrt_val + 1) // 2 )\n\nBut then we need to check whether k_candidate*(k_candidate -1)//2 <= current_p. Also, check if (k_candidate + 1)*k_candidate//2 <= current_p? No, because the formula gives the maximum k.\n\nWait, for example, if sqrt_val is exactly an integer, say 5, then (5 +1)/2 = 3. So k_candidate is 3. Which is correct.\n\nBut if the sqrt_val is not integer, then the formula gives the floor of (sqrt_val +1)/2.\n\nBut perhaps there's a better way. Let's think of it as:\n\nk is the maximum integer such that k*(k-1)/2 <= p.\n\nWe can compute k via:\n\nk = floor( (sqrt(8p + 1) + 1)/2 )\n\nBut how to compute that in code.\n\nIn code:\n\nimport math\n\ndef max_k(p):\n\n    if p == 0:\n\n        return 0\n\n    k = int( (math.sqrt(8*p +1) + 1) // 2 )\n\n    # Now check if k*(k-1)//2 is <= p. If not, decrease by 1.\n\n    while k*(k-1)//2 > p:\n\n        k -=1\n\n    # Also check if (k+1)*k//2 <= p? No, because the initial calculation should have given the correct value.\n\n    return k\n\nWait, but why the while loop? Because math.sqrt may have precision issues. For example, when 8p+1 is a perfect square, but due to floating point precision, the calculated sqrt_val may be slightly less than the actual value.\n\nBut for the purposes of code, perhaps this is sufficient.\n\nLet me test with p=3:\n\nsqrt(25) =5.0. (5+1)/2 =3.0. k=3. Check 3*2/2=3 <=3. Correct.\n\nAnother example, p=4:\n\nsqrt(33) is ~5.74456. (5.74456 +1)/2 = 3.372... so integer division is 3. So k=3. Check 3*2/2=3 <=4. Correct.\n\nAnother example, p=6: sqrt(49) is 7. (7+1)/2=4. So k=4. 4*3/2=6 <=6. Correct.\n\nAnother example, p=5: sqrt(41) is ~6.4. (6.4 +1)/2 = 3.7. integer division is 3. So k=3. Check 3*2/2=3 <=5. Then, check if (k+1)*k//2 =4*3/2=6 <=5? No. So the code returns 3. Which is correct.\n\nSo the code seems to work.\n\nOnce we have the components, we can proceed.\n\nNow, the code steps.\n\nNow, handling p=0. For that, the minimal number of nodes is 0, and the maximum unidirectional pairs is 0.\n\nNow, let's code this.\n\nBut for the code, let's think about the steps:\n\nRead p from input.\n\nif p is 0:\n\n    print 0 0\n\nelse:\n\n    components = list()\n\n    current_p = p\n\n    while current_p > 0:\n\n        compute k as above\n\n        add k to components\n\n        subtract k*(k-1)//2 from current_p\n\n    n = sum(components)\n\n    sum_squares = sum(k*k for k in components)\n\n    unidirectional_pairs = (n*n - sum_squares) // 2\n\n    print(n, unidirectional_pairs)\n\nBut wait, for the case when p=0, the code returns 0 0, which is correct.\n\nTesting the sample inputs:\n\nSample Input 3: 0 → Output 0 0.\n\nSample Input 3: input is 3. Let's see:\n\ncurrent_p =3 → compute k=3. components = [3]. current_p becomes 0. n=3. sum_squares=9. unidirectional_pairs = (9 -9)/2 =0. Output is 3 0. Correct.\n\nSample input 4: p=4. components are 3 and 2. sum is 5. sum_squares 9+4=13. (25-13)/2=6. Output 5 6. Which matches the sample.\n\nAnother sample: p=6. components is [4]. sum is 4. sum_squares 16. (16-16)/2=0. Output 4 0.\n\nAnother sample: p=2. components [2, 2]. sum is 4. sum_squares 8. (16-8)/2=4. So output is 4 4.\n\nSo the code seems correct.\n\nNow, code in Python.\n\nBut note that for p=0, the code returns 0 0. But what if p=0 is given?\n\nNow, code:\n\nimport math\n\ndef main():\n    import sys\n    p = int(sys.stdin.readline())\n    if p == 0:\n        print(\"0 0\")\n        return\n    components = []\n    current_p = p\n    while current_p > 0:\n        # compute k\n        sqrt_val = math.sqrt(8 * current_p + 1)\n        k = int( (sqrt_val + 1) // 2 )\n        # adjust k\n        while k * (k -1) // 2 > current_p:\n            k -=1\n        # add to components\n        components.append(k)\n        current_p -= k * (k-1) // 2\n    n = sum(components)\n    sum_squares = sum(k*k for k in components)\n    unidirectional = (n * n - sum_squares) // 2\n    print(f\"{n} {unidirectional}\")\n\nBut wait, what if the components list is empty? Well, for p=0, the code returns early. Otherwise, for p>0, the loop runs until current_p is zero, so components will not be empty.\n\nTesting for p=0, returns 0 0.\n\nAnother test case: p=1. components [2], n=2. sum_squares=4. (4-4)/2=0. Output 2 0.\n\nAnother test case: p=2. components [2, 2]. sum is 4. sum_squares 8. (16-8)/2=4. Output 4 4.\n\nAnother test case: p=5. Let's see:\n\ncurrent_p =5.\n\nCompute sqrt(8*5 +1) = sqrt(41) ≈6.4. (6.4 +1)/2= 3.7 → k=3.\n\nCheck 3*2//2=3 ≤5 → yes. components add 3. current_p =5-3=2.\n\ncurrent_p=2. sqrt(8*2 +1) = sqrt(17)=~4.123. (4.123 +1)/2 = ~2.56 → k=2.\n\nCheck 2*1//2=1 ≤2. Add 2. current_p =2-1=1.\n\ncurrent_p=1. sqrt(8*1 +1) = 3. (3+1)/2=2. Check 2*1//2=1 ≤1. Add 2. current_p=0.\n\ncomponents are [3,2,2]. sum is 3+2+2=7. sum_squares=9+4+4=17. unidirectional = (49 -17)/2= 32/2=16.\n\nSo output 7 16.\n\nBut what if there's a better way to split p=5 into components with same sum of nodes? Let's see. For example, can we have components of size 3 and 3? sum C(3,2) is 3+3=6>5. No. So no. Or 3 and 2 and 2, sum 3+1+1=5. So that's the only way. So the code is correct.\n\nThus, the code should handle all cases.\n\nBut let's think about when the components are not in the optimal way. For example, suppose there are multiple splits with the same sum of nodes. For example, p=6 can be split into [4] (sum 4) or [3,3] (sum 6). But the code would choose [4], since it's the greedy approach. Which is better for minimal nodes. So the code is correct.\n\nThus, the code should handle all cases correctly.\n",
    "response": "To solve this problem, we need to determine the minimum number of nodes required to create a p-reachable directed graph and the maximum number of unidirectional pairs among all such graphs with the minimum number of nodes. \n\n### Approach\n1. **Understanding p-reachable Graphs**: A p-reachable graph has exactly `p` ordered pairs (u, v) where `u < v` and both nodes are mutually reachable. This can be achieved by partitioning the graph into strongly connected components (SCCs) such that the sum of combinations of each component's size taken two at a time equals `p`.\n\n2. **Greedy Component Selection**: To minimize the number of nodes, we use a greedy approach. For each step, we find the largest possible component size `k` such that the combination `C(k, 2)` (k choose 2) does not exceed the remaining value of `p`. This is done iteratively until `p` is reduced to zero.\n\n3. **Unidirectional Pairs Calculation**: Once the component sizes are determined, the maximum number of unidirectional pairs can be calculated using the formula derived from the sum of products of component sizes. This is based on the total number of nodes and the sum of squares of component sizes.\n\n### Solution Code\n```python\nimport math\nimport sys\n\ndef main():\n    p = int(sys.stdin.readline())\n    if p == 0:\n        print(\"0 0\")\n        return\n    components = []\n    current_p = p\n    while current_p > 0:\n        sqrt_val = math.sqrt(8 * current_p + 1)\n        k = int((sqrt_val + 1) // 2)\n        # Adjust k to ensure it's valid\n        while k * (k - 1) // 2 > current_p:\n            k -= 1\n        components.append(k)\n        current_p -= k * (k - 1) // 2\n    n = sum(components)\n    sum_squares = sum(k * k for k in components)\n    unidirectional = (n * n - sum_squares) // 2\n    print(f\"{n} {unidirectional}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input value `p` is read from standard input.\n2. **Special Case Handling**: If `p` is 0, the output is immediately set to \"0 0\" since no nodes are needed.\n3. **Component Size Calculation**: Using a greedy approach, we determine the largest component size `k` such that `C(k, 2)` does not exceed the remaining value of `p`. This process continues until `p` is reduced to zero.\n4. **Summing Nodes and Squares**: The total number of nodes `n` is the sum of all component sizes. The sum of squares of these component sizes is computed to later determine the number of unidirectional pairs.\n5. **Unidirectional Pairs Calculation**: Using the formula `(n^2 - sum_squares) // 2`, we compute the maximum number of unidirectional pairs based on the total nodes and their component sizes.\n\nThis approach ensures that we efficiently determine the minimal node count and maximize the unidirectional pairs using mathematical properties of combinations and sums.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\nimport sys\n\ndef main():\n    p = int(sys.stdin.readline())\n    if p == 0:\n        print(\"0 0\")\n        return\n    components = []\n    current_p = p\n    while current_p > 0:\n        sqrt_val = math.sqrt(8 * current_p + 1)\n        k = int((sqrt_val + 1) // 2)\n        # Adjust k to ensure it's valid\n        while k * (k - 1) // 2 > current_p:\n            k -= 1\n        components.append(k)\n        current_p -= k * (k - 1) // 2\n    n = sum(components)\n    sum_squares = sum(k * k for k in components)\n    unidirectional = (n * n - sum_squares) // 2\n    print(f\"{n} {unidirectional}\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 481,
        "completion_token_count": 690,
        "thoughts_token_count": 8150
    }
}