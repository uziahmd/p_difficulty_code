{
    "start": 1758309916.949734,
    "end": 1758309963.1598623,
    "start-formatted": "2025-09-20 04:25 KST",
    "end-formatted": "2025-09-20 04:26 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\nOkay, let's try to figure out how to solve this problem. The problem is about restoring the number of mushrooms on each lawn based on the GCD and LCM values given for each road (edge) between two lawns (vertices). \n\nFirst, I need to understand the constraints. For each edge between two nodes u and v, we have a GCD (g) and LCM (l) of their mushroom counts. Let's denote the mushroom counts as a_u and a_v. Then, we know that:\n\ngcd(a_u, a_v) = g\nlcm(a_u, a_v) = l\n\nBut there's a relationship between GCD and LCM: for any two numbers, gcd(a, b) * lcm(a, b) = a * b. So, that gives us that a_u * a_v = g * l. Also, since the GCD is g, both a_u and a_v must be multiples of g. Let me think: if a_u and a_v are multiples of g, then we can write them as a_u = g * x, a_v = g * y, where x and y are coprime (since their GCD is 1). Then, the LCM of a_u and a_v would be g * x * y. So, according to the problem, the LCM given is l, so:\n\ng * x * y = l → x * y = l / g.\n\nBut since x and y are coprime, this implies that x and y must be divisors of l/g, and their product is exactly l/g. Also, since x and y are coprime, they must be such that one is a divisor of l/g and the other is the corresponding co-divisor, but with no common factors.\n\nSo for each edge, given g and l, we need to ensure that l is divisible by g. Because if not, then it's impossible. For example, if l is not a multiple of g, then there's no way for the product of the two numbers to be g*l. Because, for example, if l is not divisible by g, then l/g is not an integer, which would make x*y non-integer, which is impossible since x and y are integers.\n\nSo first, for each edge, we check if l % g != 0. If that's the case, then the answer is immediately NO.\n\nAssuming that l is divisible by g, then we have x * y = (l/g), and x and y are coprime. Now, for each edge, we need to assign values to the two nodes such that their product is g * l, and their GCD is g. But how do we model this?\n\nThis seems like a graph problem where each node's value is determined by the constraints of the edges connected to it. But since each edge connects two nodes, the problem is similar to building a system of equations or constraints that must be satisfied.\n\nLet me think of this as building a graph where each node has a value, and each edge imposes a relation between two nodes. The challenge is to assign values to all nodes such that all edges' constraints are satisfied.\n\nNow, considering that each edge's constraints can be modeled as a_u and a_v being multiples of g, and their ratio (a_u/g and a_v/g) being coprime. So, perhaps we can model this as a graph where each node's value is determined relative to others, and we need to assign values in such a way that all constraints are met.\n\nBut how can we approach this? It seems like a problem that can be modeled using Union-Find (Disjoint Set Union) structure, but with some additional constraints. However, the constraints here are multiplicative and not just equality. Alternatively, maybe we can model this as a graph where each node's value is determined through a system of equations, and we need to perform a BFS or DFS to assign values.\n\nLet me think again. For each edge between u and v, we have that a_u = g * x, a_v = g * y, with x and y coprime, and x * y = l/g. So, the possible pairs (x, y) are such that x divides l/g and y is l/g divided by x, and gcd(x,y)=1. But how do we choose x and y for each edge?\n\nBut since x and y are coprime, once we choose x for a_u, then y is fixed as (l/g)/x. However, the problem is that the same node may be part of multiple edges, so the values must be consistent across all edges connected to it.\n\nThis suggests that the problem is similar to checking for consistency in a graph where each edge defines a relationship between two variables. For example, in a bipartition problem, or in a system where variables are related multiplicatively.\n\nSo, perhaps we can model this as a graph",
    "response": "To solve this problem, we need to determine if it is possible to restore the number of mushrooms on each lawn based on given GCD and LCM values for each road connecting two lawns. The solution involves checking constraints and using a graph traversal approach to assign mushroom counts consistently.\n\n### Approach\n1. **Constraints Check**: For each edge, check if the LCM is divisible by the GCD. If not, it's impossible to satisfy the constraints, so the answer is immediately \"NO\".\n2. **Graph Representation**: Represent the lawns and roads as a graph where each node (lawn) has edges with associated GCD and LCM values.\n3. **BFS Traversal**: Use BFS to traverse the graph starting from an arbitrary node, assigning mushroom counts while ensuring consistency with the given GCD and LCM constraints.\n4. **Consistency Check**: During BFS traversal, ensure that the assigned mushroom counts for connected nodes are consistent with the given constraints. If inconsistency is found, output \"NO\".\n\n### Solution Code\n```python\nimport sys\nimport math\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n    \n    edges = []\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        u = int(input[idx]) - 1\n        idx += 1\n        v = int(input[idx]) - 1\n        idx += 1\n        g = int(input[idx])\n        idx += 1\n        l = int(input[idx])\n        idx += 1\n        edges.append((u, v, g, l))\n        graph[u].append((v, g, l))\n        graph[v].append((u, g, l))\n    \n    result = [None] * n\n    visited = [False] * n\n    \n    for start in range(n):\n        if visited[start]:\n            continue\n        queue = deque()\n        queue.append(start)\n        visited[start] = True\n        result[start] = 1  # arbitrary value, will be adjusted later\n        \n        while queue:\n            u = queue.popleft()\n            for (v, g, l) in graph[u]:\n                if visited[v]:\n                    # Check if current assignment is consistent\n                    a_u = result[u]\n                    a_v = result[v]\n                    if math.gcd(a_u, a_v) != g or (a_u * a_v) // math.gcd(a_u, a_v) != l:\n                        print(\"NO\")\n                        return\n                    continue\n                # Compute the product of the two numbers: a_u * a_v = g * l\n                # Since a_u is known, compute a_v\n                a_u = result[u]\n                if a_u % g != 0:\n                    print(\"NO\")\n                    return\n                product = g * l\n                a_v_candidate = product // a_u\n                # Check if gcd(a_u, a_v_candidate) == g and lcm == l\n                if math.gcd(a_u, a_v_candidate) != g or (a_u * a_v_candidate) // math.gcd(a_u, a_v_candidate) != l:\n                    print(\"NO\")\n                    return\n                result[v] = a_v_candidate\n                visited[v] = True\n                queue.append(v)\n    \n    print(\"YES\")\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into a list of edges and a graph structure.\n2. **Initial Checks**: For each edge, check if the LCM is divisible by the GCD. If not, immediately output \"NO\".\n3. **BFS Traversal**: Starting from each unvisited node, perform BFS to assign mushroom counts. For each node, ensure that the assigned value is consistent with the GCD and LCM constraints of its connected edges.\n4. **Consistency Check**: During BFS, if any inconsistency is found between the current node's mushroom count and its neighbor's, output \"NO\". If all checks pass, output \"YES\" followed by the mushroom counts for each lawn.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n    \n    edges = []\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        u = int(input[idx]) - 1\n        idx += 1\n        v = int(input[idx]) - 1\n        idx += 1\n        g = int(input[idx])\n        idx += 1\n        l = int(input[idx])\n        idx += 1\n        edges.append((u, v, g, l))\n        graph[u].append((v, g, l))\n        graph[v].append((u, g, l))\n    \n    result = [None] * n\n    visited = [False] * n\n    \n    for start in range(n):\n        if visited[start]:\n            continue\n        queue = deque()\n        queue.append(start)\n        visited[start] = True\n        result[start] = 1  # arbitrary value, will be adjusted later\n        \n        while queue:\n            u = queue.popleft()\n            for (v, g, l) in graph[u]:\n                if visited[v]:\n                    # Check if current assignment is consistent\n                    a_u = result[u]\n                    a_v = result[v]\n                    if math.gcd(a_u, a_v) != g or (a_u * a_v) // math.gcd(a_u, a_v) != l:\n                        print(\"NO\")\n                        return\n                    continue\n                # Compute the product of the two numbers: a_u * a_v = g * l\n                # Since a_u is known, compute a_v\n                a_u = result[u]\n                if a_u % g != 0:\n                    print(\"NO\")\n                    return\n                product = g * l\n                a_v_candidate = product // a_u\n                # Check if gcd(a_u, a_v_candidate) == g and lcm == l\n                if math.gcd(a_u, a_v_candidate) != g or (a_u * a_v_candidate) // math.gcd(a_u, a_v_candidate) != l:\n                    print(\"NO\")\n                    return\n                result[v] = a_v_candidate\n                visited[v] = True\n                queue.append(v)\n    \n    print(\"YES\")\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 558,
        "completion_token_count": 888,
        "thoughts_token_count": 1024
    }
}