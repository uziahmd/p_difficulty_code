{
    "start": 1758310442.1732066,
    "end": 1758310759.6640804,
    "start-formatted": "2025-09-20 04:34 KST",
    "end-formatted": "2025-09-20 04:39 KST",
    "gpu": 2,
    "pid": 30,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# TV Game\n\nThere is a new TV game on BerTV. In this game two players get a number A consisting of 2n digits. Before each turn players determine who will make the next move. Each player should make exactly n moves. On it's turn i-th player takes the leftmost digit of A and appends it to his or her number Si. After that this leftmost digit is erased from A. Initially the numbers of both players (S1 and S2) are «empty». Leading zeroes in numbers A, S1, S2 are allowed. In the end of the game the first player gets S1 dollars, and the second gets S2 dollars.One day Homer and Marge came to play the game. They managed to know the number A beforehand. They want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize. Help them.\n\n## Input\nThe first line contains integer n (1 ≤ n ≤ 18). The second line contains integer A consisting of exactly 2n digits. This number can have leading zeroes.\n\n## Output\nOutput the line of 2n characters «H» and «M» — the sequence of moves of Homer and Marge, which gives them maximum possible total prize. Each player must make exactly n moves. If there are several solutions, output any of them.\n\n## Example\n### Input\n['2\\n1234', '2\\n9911']\n\n### Output\n['HHMM', 'HMHM']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\nOkay, let's see. I need to solve this programming problem. Let's read the problem carefully again.\n\nThe problem is about Homer and Marge playing a game where they take digits from a number A. The number A has 2n digits. Each player takes exactly n turns. On each turn, the current player takes the leftmost digit of A and appends it to their own number. The goal is to maximize the total prize, which is S1 + S2. We have to find the sequence of moves (H for Homer, M for Marge) that achieves this maximum total. If there are multiple solutions, any is acceptable.\n\nSo, the challenge is to find the optimal way for Homer and Marge to take digits such that their combined numbers sum to the maximum possible value. But how do we approach this?\n\nLet me think about the problem. Since each move affects the remaining digits, and the choice depends on future steps, this seems like a dynamic programming problem. However, with n up to 18, the total number of digits is 36. So the state space might be manageable if we can find a way to represent it efficiently.\n\nWait, but for each step, the state depends on how many digits each player has taken so far. For example, after k moves, Homer could have taken h moves and Marge m moves, with h + m = k. But since each must take exactly n moves, the state can be represented by the number of moves each has made so far. Let's say, the state is (h, m), where h is the number of moves Homer has made, and m is the number of moves Marge has made. At any state, the total moves so far is h + m, which is equal to the number of digits already taken. So the remaining digits are the original A with the first (h+m) digits removed.\n\nBut since the digits are taken in order, the current state is determined by how many digits have been taken. Wait, but the order of taking digits depends on the choices made. For example, if we have taken k digits, then the next digit is the (k+1)th digit of the original A. So the state can be represented by the number of digits taken so far (k). Then, since h + m = k, and since h can be from max(0, k - (n - m))... Wait, maybe not. Let me think: since each player must make exactly n moves, at any state, h can be between 0 and n, and m can be between 0 and n, and h + m = k. Also, since h can't exceed n, and m can't exceed n. So for a given k, h can range from max(0, k - (n - m))... Hmm, perhaps not. Let me think again. For example, when k is the number of digits taken so far, h can be from max(0, k - (n)) to min(k, n). Because m = k - h. Since m can't exceed n, then k - h ≤ n → h ≥ k - n. Also, since h can't be more than n, h ≤ n. So for each k, h ranges between max(0, k - n) and min(n, k). But since h and m can't be negative, etc.\n\nSo the state can be represented as (h, m) or equivalently (k, h), since m = k - h. But since k = h + m, and h can be up to n, and m can be up to n. So the state can be represented by the current number of digits taken (k) and the number of moves Homer has made (h). Then, for each state, the next move can be either H or M, provided that Homer hasn't taken n moves yet, or Marge hasn't taken n moves yet.\n\nBut the problem is that for each state, we need to choose whether to take H or M, and choose the option that leads to the maximum total sum. But how do we compute the sum? Because the sum is the sum of the numbers S1 and S2. However, the numbers S1 and S2 are built by appending digits. For example, if Homer takes a digit d, then it's added to his number. The value of S1 is the number formed by the digits he took. Similarly for S2. But the sum S1 + S2 depends on the digits each player has taken and their positions. However, when building the numbers, the digits are added in the order they are taken. So, for example, if Homer takes digits d1, d2, ..., dn, then S1 is d1 * 10^{n-1} + d2 * 10^{n-2} + ... + dn * 10^0. Similarly for S2.\n\nBut calculating the actual sum during DP would be expensive because the numbers can be very large. For n=18, the numbers can be up to 1e18 digits, which is impossible to handle directly. However, since we only care about the total sum S1 + S2, perhaps we can find a way to represent the contribution of each digit to the total sum based on when it is taken.\n\nLet me think: each digit in the original A will be added to either S1 or S2. Suppose a digit is taken by Homer at position i (i.e., when he takes it, it's the j-th digit he takes). Then, the contribution of this digit to S1 is digit * 10^{n - j}. Similarly for Marge's digits. But since the digits are taken in order, the position in which they are taken (the order) determines their weight in the final sum.\n\nAlternatively, the total sum S1 + S2 can be considered as the sum over all digits of (digit) multiplied by (10^p), where p depends on when the digit was taken by the respective player.\n\nBut how can we model this in DP?\n\nLet me think: For each state (h, m), which represents that Homer has taken h digits and Marge has taken m digits. At this state, the next digit to take is the (h + m + 1)th digit of A. Let's denote the current position as pos = h + m. So, the next digit is A[pos], and we can choose to take it as H or M, provided that h < n or m < n respectively.\n\nThe key is to find, for each state, the maximum possible total sum that can be achieved from that state onward.\n\nSo the DP state can be dp[h][m] = maximum total sum achievable when Homer has taken h digits and Marge has taken m digits. The transitions would be:\n\nIf we choose to take H next (if h < n), then the current digit is A[pos], where pos = h + m. This digit contributes to S1. How much does it contribute? Well, when Homer takes this digit, it's his (h+1)th digit. Since he will have n digits in total, the weight of this digit in S1 is 10^{n - (h+1)}.\n\nSimilarly, if M takes the digit, it's her (m+1)th digit, contributing 10^{n - (m+1)} to S2.\n\nTherefore, the DP recurrence can be written as:\n\ndp[h][m] = max(\n    (current_digit_contribution_H + dp[h+1][m]), \n    (current_digit_contribution_M + dp[h][m+1])\n)\n\nBut how do we calculate the current_digit_contribution? Let's see:\n\nFor the current digit (which is A[pos], where pos = h + m), if we take it as H, then the contribution is (digit) * 10^{n - (h+1)}.\n\nSimilarly, if taken as M, it's (digit) * 10^{n - (m+1)}.\n\nSo, for each state (h, m), we can compute the contribution of the next digit depending on which player takes it. Then, the DP state will store the maximum total sum possible from that state onwards.\n\nThe base case is when h = n and m = n. Then, there are no more digits to take, so the total sum is 0.\n\nSo, the idea is to compute this DP table, and then backtrack through the choices to find the optimal sequence of moves.\n\nBut considering that n can be up to 18, the DP table would be of size (n+1) x (n+1). For n=18, that's 19x19=361 states. For each state, we need to compute the maximum between two options. That seems manageable.\n\nBut what about the computation of the contributions? Let's think about precomputing the powers of 10. For example, for each possible h and m, we can calculate the exponent needed.\n\nFor example, when Homer takes a digit as his (h+1)th move, the exponent is n - (h+1) = (n - h - 1). So, for each possible h (from 0 to n), we can precompute 10^{n - h - 1} for the contribution of a digit taken by Homer at that step. Similarly for Marge's steps.\n\nBut wait, for a given h and m, when we are at state (h, m), the next digit is being taken as the (h + m + 1)th digit. So, if we take it as H, then the contribution is digit * 10^{n - (h + 1)}. Similarly for M.\n\nSo, for each state (h, m), the current digit is A[h + m], and the contribution for H is digit * pow10_h[h], where pow10_h[h] is 10^{n - (h + 1)}. Similarly for M, it's digit * pow10_m[m], where pow10_m[m] is 10^{n - (m + 1)}.\n\nSo, we can precompute these pow10 values for all possible h and m. For example, pow10_h is an array where pow10_h[i] = 10^{n - i - 1} for i from 0 to n-1. Similarly for pow10_m.\n\nBut wait, for h ranging from 0 to n-1 (since when h is n, the player can't take any more digits). So for each h in 0..n-1, the exponent for Homer's (h+1)th digit is (n - (h+1)) = n - h - 1. So yes, precompute those.\n\nNow, the DP approach seems feasible. The next step is to implement this DP with memoization or using a table. However, since n can be up to 18, the maximum exponent is n-1 = 17. So 10^17 is a big number, but since Python handles big integers well, it's manageable.\n\nBut for n=18, the maximum exponent is 17, so 10^17 is okay. But for the DP, the numbers can be up to (for each digit) 9 * 10^17 * 18 digits, but since we are adding them all, the total sum can be up to 18 * 9 * 10^17 * 18 (but no, each digit contributes once, so the maximum sum would be 36 digits, each multiplied by up to 1e17, which is 36*9*1e17, which is manageable in Python.\n\nSo the plan is:\n\n1. Precompute pow10_h and pow10_m arrays. For each possible h (number of digits Homer has taken so far), when he takes another digit, it's his (h+1)th digit, so the exponent is n - (h+1). Similarly for m.\n\nBut wait, for pow10_h, for a given h (current count of Homer's digits), when he takes the next digit, the exponent is n - (h + 1). So for h from 0 to n-1, pow10_h[h] = 10^{n - h - 1}.\n\nSame for pow10_m[m] = 10^{n - m - 1}.\n\nOnce these are precomputed, then for each state (h, m), the current digit is A[pos], where pos = h + m. Then, if we choose H, the contribution is digit * pow10_h[h], and then add the dp value of (h+1, m). Similarly for choosing M.\n\nSo the DP can be implemented recursively with memoization, or iteratively using a bottom-up approach.\n\nBut for the DP, since the state transitions depend on higher h or m values, perhaps a bottom-up approach is better. For example, the base case is when h = n and m = n, which gives 0. Then, for states where h + m = 2n - 1, which is the last step, etc.\n\nBut since h + m can range from 0 to 2n. Wait, h can be up to n, m can be up to n. So for each state (h, m), the sum h + m can be up to 2n. But since the total number of digits is 2n, when h + m = 2n, it's the end of the game.\n\nSo for the bottom-up approach, we can iterate over the possible values of k = h + m. For each k from 2n down to 0, and for each possible h and m such that h + m = k, compute dp[h][m].\n\nBut how to iterate this? For example, for k = 2n, only h = n and m = n. For k = 2n - 1, either h = n and m = n-1, or h = n-1 and m = n. And so on.\n\nSo for each k in reverse order (from 2n down to 0), and for each possible h and m where h + m = k, compute dp[h][m] based on the next steps.\n\nBut how to generate all possible h and m pairs for each k?\n\nFor each k, h can range from max(0, k - n) to min(n, k). Because m = k - h, and m must be between 0 and n. So for h, the lower bound is max(0, k - n) (since m = k - h <= n → h >= k - n). Upper bound is min(n, k) (since h can't be more than n, and also can't be more than k).\n\nSo for each k, loop through h from max(0, k - n) to min(n, k), and compute m = k - h. Then, for each such (h, m), compute dp[h][m].\n\nThis seems feasible.\n\nOnce the DP table is filled, we can then backtrack from (0, 0) to determine the sequence of moves. For each state (h, m), we check whether choosing H or M gives the maximum value. If both choices lead to the same value, we can choose either (the problem allows any solution in such cases).\n\nBut how to track the path? For that, during the DP calculation, we can also keep track of the choice made (H or M) for each state. Alternatively, once the DP table is filled, we can perform a backtracking step, starting from (0, 0), and for each state, check which option (H or M) gives the maximum value, and proceed accordingly.\n\nSo the steps are:\n\n- Read n and A.\n\n- Precompute pow10_h and pow10_m arrays.\n\n- Initialize a DP table of size (n+1) x (n+1), with dp[h][m] storing the maximum total sum achievable from state (h, m).\n\n- Fill the DP table using bottom-up approach.\n\n- Then, backtrack from (0, 0) to build the sequence of moves.\n\nNow, the implementation details.\n\nFirst, the pow10 arrays. Let's think about n being up to 18. For pow10_h, for h from 0 to n-1, the exponents are n - h - 1. For example, if n is 2, then for h=0, exponent is 2 - 0 -1 = 1 → 10^1 = 10. For h=1, exponent is 2 - 1 -1 = 0 → 10^0 = 1.\n\nSimilarly for pow10_m.\n\nWe can precompute these as lists. For example, pow10_h = [10 ** (n - i - 1) for i in range(n)].\n\nBut note that when h is n, the player can't take more digits, so those are not used.\n\nNow, the DP table.\n\nLet me think about the code structure.\n\nIn Python:\n\nRead n.\n\nRead A as a string. Then, the digits are A[0], A[1], ..., A[2n-1].\n\nThen, precompute pow10_h and pow10_m.\n\npow10_h = [10 ** (n - i - 1) for i in range(n)]\n\npow10_m = [10 ** (n - i - 1) for i in range(n)]\n\nWait, but for pow10_m, when M takes the (m+1)th digit, the exponent is n - (m + 1). So same as pow10_h, but for m's steps.\n\nYes. So the pow10_h and pow10_m can be the same array, but in code, perhaps we can just use the same array for both.\n\nBut in code, perhaps it's easier to compute them as follows:\n\nFor each h in 0 to n-1, the exponent is (n - h - 1). So pow10_h is precomputed as [10 ** (n - i - 1) for i in range(n)].\n\nSame for pow10_m.\n\nBut since both are same, perhaps we can use the same array for both. But for code clarity, perhaps separate variables.\n\nNow, the DP table. Let's create a 2D array dp of size (n+1) x (n+1). For each dp[h][m], it holds the maximum sum achievable from that state.\n\nInitialize dp as a 2D array of size (n+1) x (n+1). For each h and m, the value is computed based on transitions.\n\nThe base case is dp[n][n] = 0.\n\nFor other states, we need to compute based on transitions.\n\nFor each k in reverse order (from 2n down to 0):\n\nWait, the k is h + m. For each state (h, m), the next step is to take the (h + m)th digit (since the next digit is the (h + m)th index, since the first digit is taken when h + m = 0, and the next is when h + m increases by 1).\n\nWait, the original A is a string of 2n digits. When h + m digits have been taken, the next digit to take is the (h + m)th index (assuming zero-based). For example, when h + m = 0, the first digit is A[0]. Then, after taking one digit, h + m = 1, and the next digit is A[1], etc.\n\nSo for a state (h, m), the next digit is A[k], where k = h + m.\n\nSo, during the DP computation, for each state (h, m), we can get the current digit as A[k], where k = h + m.\n\nSo, during the bottom-up filling of the DP table, for each state (h, m), we check if we can take H or M.\n\nSo, for each (h, m):\n\ncurrent_digit = int(A[h + m])\n\nif h < n and m < n:\n\n   option1: take H. Then, the contribution is current_digit * pow10_h[h], plus dp[h+1][m]\n\n   option2: take M. Contribution is current_digit * pow10_m[m], plus dp[h][m+1]\n\n   dp[h][m] = max(option1, option2)\n\nBut if h == n, then we can't take H, so only M is allowed. Similarly, if m == n, only H is allowed.\n\nSo, in code:\n\nfor each k from 2n-1 down to 0:\n\n   for each h in possible range for this k:\n\n       m = k - h\n\n       if m is not between 0 and n, skip (but according to earlier logic, h is chosen such that m is valid)\n\n       current_digit = int(A[k])\n\n       if h < n and m < n:\n\n           option1 = current_digit * pow10_h[h] + dp[h+1][m]\n\n           option2 = current_digit * pow10_m[m] + dp[h][m+1]\n\n           dp[h][m] = max(option1, option2)\n\n       elif h < n:\n\n           # can only take H\n\n           dp[h][m] = current_digit * pow10_h[h] + dp[h+1][m]\n\n       elif m < n:\n\n           # can only take M\n\n           dp[h][m] = current_digit * pow10_m[m] + dp[h][m+1]\n\n       else:\n\n           # h and m are both n, which is the base case.\n\n           dp[h][m] = 0\n\nWait, but when k is h + m, for example, when k is 2n - 1, then h + m = 2n - 1. Since h and m can't exceed n, then for example, if h = n, m = n -1. Or h = n-1, m = n. Either way, one of them is at maximum.\n\nSo, during the filling of the DP table, for each state (h, m), we can compute the value based on the transitions.\n\nOnce the DP table is filled, we can then backtrack from (0, 0) to determine the sequence of moves.\n\nFor backtracking, we can start with h = 0, m = 0. At each step, we check which choice (H or M) leads to the maximum value. For example:\n\ncurrent_h = 0, current_m = 0.\n\nAt each step, we look at the current state (h, m). We check if taking H gives the same value as taking M, or which is better.\n\nBut how to know which choice was taken during the DP computation? Well, during the DP filling, we can also store the choice (H or M) for each state. Alternatively, during backtracking, we can recompute the options and choose the one that matches the DP value.\n\nFor example, during backtracking:\n\nresult = []\n\nh = 0\n\nm = 0\n\nwhile h + m < 2n:\n\n    k = h + m\n\n    current_digit = int(A[k])\n\n    if h < n and m < n:\n\n        option1 = current_digit * pow10_h[h] + dp[h+1][m]\n\n        option2 = current_digit * pow10_m[m] + dp[h][m+1]\n\n        if option1 >= option2:\n\n            result.append('H')\n\n            h += 1\n\n        else:\n\n            result.append('M')\n\n            m += 1\n\n    elif h < n:\n\n        result.append('H')\n\n        h += 1\n\n    else:\n\n        result.append('M')\n\n        m += 1\n\nOnce this loop completes, the result list will have the sequence of moves.\n\nBut how do we know which option was taken during the DP? Because during the DP calculation, the value stored in dp[h][m] is the maximum between option1 and option2. So during backtracking, we can compare the options again and choose the one that gives the maximum value.\n\nThis approach should work.\n\nNow, considering the example:\n\nSample Input 1:\n\n2\n\n1234\n\nSample Output: HHMM\n\nLet's see. Let's compute the DP.\n\nn=2, A is '1234'.\n\npow10_h for h in 0, 1:\n\nfor h=0: 10^(2 - 0 -1) = 10^1 = 10\n\nh=1: 10^(2 -1 -1) = 10^0 = 1.\n\nSimilarly for pow10_m.\n\nLet's compute the DP table for this case.\n\nThe DP table is 3x3 (since n=2, h and m can be 0,1,2).\n\nBase case: dp[2][2] = 0.\n\nNow, let's compute for k from 3 down to 0.\n\nk=3: h + m =3. Since h and m can't exceed 2, possible h is 2 and m=1, or h=1 and m=2.\n\nLet's process these states.\n\nFirst, for (h=2, m=1):\n\ncurrent_digit is A[3] = '4'.\n\nh is 2 (max n=2), so can't take H. Only M can take. So:\n\ndp[2][1] = 4 * pow10_m[1] + dp[2][2]\n\npow10_m[1] is 10^(2 - 1 -1) = 10^0 = 1. So 4*1 + 0 = 4.\n\nSimilarly for (h=1, m=2):\n\ncurrent_digit is A[3] = '4'.\n\nm=2, can't take M. So take H.\n\ndp[1][2] = 4 * pow10_h[1] + dp[2][2] = 4 * 1 + 0 =4.\n\nNow, k=3 done.\n\nNext, k=2:\n\nPossible (h, m) pairs:\n\nh can be from max(0, 2 - 2) = 0 to min(2, 2) = 2.\n\nSo h can be 0, 1, 2.\n\nFor h=0, m=2: but m is 2 which is n=2. So can't take M. So take H. But h is 0 < 2.\n\ncurrent_digit is A[2] = '3'.\n\ndp[0][2] = 3 * pow10_h[0] + dp[1][2] = 3*10 + 4 = 34.\n\nFor h=1, m=1: both can take.\n\ncurrent_digit is A[2] = '3'.\n\noption1: take H: 3 * pow10_h[1] (which is 1) + dp[2][1] (which is 4) → 3*1 +4=7.\n\noption2: take M: 3 * pow10_m[1] (1) + dp[1][2] (4) → 3*1 +4=7. So choose either. Let's say we pick H.\n\nSo dp[1][1] =7.\n\nFor h=2, m=0: can't take H. Take M. current_digit is A[2] = '3'.\n\ndp[2][0] = 3 * pow10_m[0] + dp[2][1]. pow10_m[0] is 10^(2-0-1) =10^1=10. So 3*10 +4=34.\n\nNow, k=2 done.\n\nk=1:\n\npossible h ranges from max(0, 1-2)=0 to min(2,1)=1.\n\nSo h=0, m=1; h=1, m=0.\n\nFor h=0, m=1:\n\ncurrent_digit is A[1] = '2'.\n\ncan take H or M.\n\noption1: take H → 2 * pow10_h[0] (10) + dp[1][1] (7) → 2*10 +7=27.\n\noption2: take M → 2 * pow10_m[1] (1) + dp[0][2] (34) → 2*1 +34=36. So choose option2. dp[0][1] =36.\n\nFor h=1, m=0:\n\ncurrent_digit is A[1] = '2'.\n\noption1: take H → 2 * pow10_h[1] (1) + dp[2][0] (34) → 2*1 +34=36.\n\noption2: take M → 2 * pow10_m[0] (10) + dp[1][1] (7) → 2*10 +7=27. So choose option1. dp[1][0] =36.\n\nk=1 done.\n\nk=0:\n\nh=0, m=0.\n\ncurrent_digit is A[0] = '1'.\n\noption1: take H → 1 * pow10_h[0] (10) + dp[1][0] (36) → 10 +36 =46.\n\noption2: take M → 1 * pow10_m[0] (10) + dp[0][1] (36) → 10 +36 =46. So choose either. Let's say H.\n\nSo dp[0][0] =46.\n\nSo the maximum sum is 46. Now, backtracking:\n\nStart with h=0, m=0. At this state, the options are H and M, both leading to 46.\n\nWhich one to choose? The problem says any solution is acceptable. So for example, choosing H first.\n\nThen, h becomes 1, m=0.\n\nNow, at (1,0), the options were H and M. The dp value was 36, which was achieved by taking H. So next is H.\n\nh=2, m=0. Now, can't take H. Take M. So next is M. Then, m becomes 1.\n\nNow, state is (2,1). Take M again. So next is M. The sequence is H H M M → 'HHMM', which matches the sample output.\n\nAnother possibility is if during backtracking, when there is a tie, we choose M first. For example, in the first step, choosing M would lead to HMHM. Which is also a valid solution, as per the sample input's second example.\n\nBut in the first sample input, the correct output is 'HHMM' or 'HMHM'? Wait, the sample input shows that for input 2\\n1234, the output is 'HHMM'.\n\nBut according to the problem statement, the first sample input is ['2\\n1234', '2\\n9911'], and outputs are ['HHMM', 'HMHM'].\n\nWait, perhaps the first sample input is two separate test cases. The first input is 2 and 1234, output is HHMM. The second input is 2 and 9911, output is HMHM.\n\nBut regardless, the code needs to choose any of the possible optimal paths.\n\nNow, the code needs to generate the correct sequence.\n\nNow, the code in Python:\n\nImplementing the DP and backtracking.\n\nBut first, handling the pow10 arrays. For n=18, the exponents can be up to 10^17, which is manageable in Python.\n\nNow, code steps:\n\nRead n.\n\nRead A as a string.\n\nprecompute pow10_h and pow10_m:\n\npow10_h = [10 ** (n - i - 1) for i in range(n)]\n\npow10_m = [10 ** (n - i - 1) for i in range(n)]\n\nBut since they are same, perhaps we can use the same array. But for code, perhaps separate variables.\n\nThen, create a DP table. For Python, a 2D list.\n\nBut for n up to 18, (n+1) is 19, so a 19x19 list is manageable.\n\nInitialize dp as a 2D array of (n+1) rows and (n+1) columns.\n\nThen, fill the DP table in bottom-up manner.\n\nOnce filled, backtrack.\n\nNow, code:\n\nImplementing the DP:\n\nn = int(input())\nA = input().strip()\n\npow10_h = [10 ** (n - i - 1) for i in range(n)]\npow10_m = [10 ** (n - i - 1) for i in range(n)]\n\ndp = [[0]*(n+1) for _ in range(n+1)]\n\nfor k in range(2*n - 1, -1, -1):\n    for h in range(max(0, k - n), min(n, k) + 1):\n        m = k - h\n        if m < 0 or m > n:\n            continue\n        # current digit is A[k]\n        current_digit = int(A[k])\n        if h < n and m < n:\n            # can choose H or M\n            option1 = current_digit * pow10_h[h] + dp[h+1][m]\n            option2 = current_digit * pow10_m[m] + dp[h][m+1]\n            dp[h][m] = max(option1, option2)\n        elif h < n:\n            # can only take H\n            dp[h][m] = current_digit * pow10_h[h] + dp[h+1][m]\n        elif m < n:\n            # can only take M\n            dp[h][m] = current_digit * pow10_m[m] + dp[h][m+1]\n        else:\n            # both are n, which is base case\n            dp[h][m] = 0\n\nWait, but for the loop over k, the code is for k in range(2n-1, -1, -1). But in Python, the range is handled with for k in reversed(range(2n)) ?\n\nWait, the original code is for k from 2n-1 down to 0. So for example, for 2n digits, the maximum k is 2n-1 (since h + m can be up to 2n, but when h + m is 2n, it's the end, which is the base case).\n\nBut in the code above, the loop is for k in range(2*n -1, -1, -1). So for example, for n=2, 2n is 4. So 2n-1 is 3, and the loop runs from 3 down to 0.\n\nBut the code for k in range(2*n -1, -1, -1) would not be correct in Python, because the range is exclusive. So to generate numbers from 2n-1 down to 0, inclusive, the code should be:\n\nfor k in range(2*n -1, -1, -1):\n\nBut in Python, range(a, b, step) includes a, but stops before reaching b. So for example, range(3, -1, -1) would produce 3, 2, 1, 0.\n\nYes. So for 2n-1 down to 0, inclusive, the code is correct.\n\nBut in the code above, for each k, the for h in range(...) loops through possible h values.\n\nBut the code for h in range(max(0, k -n), min(n, k) + 1):\n\nWait, for example, when k is 3, and n=2, max(0, 3-2) = 1. min(n, k) is min(2, 3) = 2. So h ranges from 1 to 2 inclusive. So range(1, 2+1) → 1, 2.\n\nYes.\n\nNow, once the DP is filled, backtracking:\n\nh = 0\nm = 0\nresult = []\nfor _ in range(2*n):\n    # current state is (h, m)\n    k = h + m\n    current_digit = int(A[k])\n    if h < n and m < n:\n        option1 = current_digit * pow10_h[h] + dp[h+1][m]\n        option2 = current_digit * pow10_m[m] + dp[h][m+1]\n        if option1 >= option2:\n            result.append('H')\n            h += 1\n        else:\n            result.append('M')\n            m += 1\n    elif h < n:\n        result.append('H')\n        h += 1\n    else:\n        result.append('M')\n        m += 1\n\nprint(''.join(result))\n\nWait, but in the backtracking loop, how many times do we loop? For 2n steps, since each step corresponds to one move. So the loop runs 2n times.\n\nBut in code, for _ in range(2n) ?\n\nYes. Because initially, h + m = 0, and after 2n steps, h + m = 2n.\n\nSo, the code for backtracking is as above.\n\nBut let's test with the sample input.\n\nSample Input 1:\n\nn=2, A=1234.\n\nBacktracking starts with h=0, m=0.\n\nk=0: current_digit is 1.\n\noption1: 1 * 10 + dp[1][0] (which was 36) → 10 + 36 =46.\n\noption2: 1 * 10 + dp[0][1] (which was 36) → same. So choose H or M.\n\nSuppose the code chooses H (since option1 >= option2 is True, since they are equal). So append 'H', h becomes 1, m=0.\n\nNext step: h=1, m=0. k=1.\n\ncurrent_digit is 2.\n\n",
    "response": "To solve this problem, we need to determine the optimal sequence of moves for Homer and Marge in a game where they take turns picking digits from a given number to maximize their total prize. The solution involves dynamic programming (DP) to efficiently explore all possible sequences of moves and backtracking to reconstruct the optimal sequence.\n\n### Approach\n1. **Dynamic Programming (DP) Setup**: We use a DP table `dp[h][m]` where `h` is the number of moves Homer has made and `m` is the number of moves Marge has made. The value at `dp[h][m]` represents the maximum total prize achievable from the state where Homer has taken `h` digits and Marge has taken `m` digits.\n2. **Precompute Powers of 10**: Since each digit's contribution to the total prize depends on its position in the final number, we precompute powers of 10 for both Homer and Marge to quickly calculate their contributions during DP transitions.\n3. **Bottom-Up DP Filling**: We fill the DP table starting from the end state (both players have taken all their digits) and move backwards to the initial state. This ensures that each state transition is computed based on already known results.\n4. **Backtracking to Determine Moves**: After filling the DP table, we backtrack from the initial state to determine the sequence of moves that leads to the maximum total prize. At each step, we choose the move (Homer or Marge) that maximizes the total prize.\n\n### Solution Code\n```python\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    n = int(input[0])\n    A = input[1]\n    \n    pow10_h = [10 ** (n - i - 1) for i in range(n)]\n    pow10_m = [10 ** (n - i - 1) for i in range(n)]\n    \n    dp = [[0]*(n+1) for _ in range(n+1)]\n    \n    for k in range(2*n - 1, -1, -1):\n        for h in range(max(0, k - n), min(n, k) + 1):\n            m = k - h\n            if m < 0 or m > n:\n                continue\n            current_digit = int(A[k])\n            if h < n and m < n:\n                option1 = current_digit * pow10_h[h] + dp[h+1][m]\n                option2 = current_digit * pow10_m[m] + dp[h][m+1]\n                dp[h][m] = max(option1, option2)\n            elif h < n:\n                dp[h][m] = current_digit * pow10_h[h] + dp[h+1][m]\n            elif m < n:\n                dp[h][m] = current_digit * pow10_m[m] + dp[h][m+1]\n            else:\n                dp[h][m] = 0\n    \n    h, m = 0, 0\n    result = []\n    for _ in range(2 * n):\n        k = h + m\n        current_digit = int(A[k])\n        if h < n and m < n:\n            option1 = current_digit * pow10_h[h] + dp[h+1][m]\n            option2 = current_digit * pow10_m[m] + dp[h][m+1]\n            if option1 >= option2:\n                result.append('H')\n                h += 1\n            else:\n                result.append('M')\n                m += 1\n        elif h < n:\n            result.append('H')\n            h += 1\n        else:\n            result.append('M')\n            m += 1\n    \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Dynamic Programming Table Initialization**: The DP table `dp` is initialized to store the maximum total prize from each state `(h, m)`.\n- **Power of 10 Precomputation**: Arrays `pow10_h` and `pow10_m` are used to quickly compute the contribution of each digit based on its position in the respective player's number.\n- **Bottom-Up DP Calculation**: By iterating from the end of the game back to the start, we ensure that each state transition is calculated using previously computed values, leading to an efficient solution.\n- **Backtracking**: After filling the DP table, we backtrack from the initial state to determine the optimal sequence of moves by always choosing the move (Homer or Marge) that maximizes the total prize, considering both players' contributions.\n\nThis approach ensures that we efficiently compute the optimal sequence of moves while handling all edge cases, including ties where either move is equally optimal.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n    input = sys.stdin.read().split()\n    n = int(input[0])\n    A = input[1]\n    \n    pow10_h = [10 ** (n - i - 1) for i in range(n)]\n    pow10_m = [10 ** (n - i - 1) for i in range(n)]\n    \n    dp = [[0]*(n+1) for _ in range(n+1)]\n    \n    for k in range(2*n - 1, -1, -1):\n        for h in range(max(0, k - n), min(n, k) + 1):\n            m = k - h\n            if m < 0 or m > n:\n                continue\n            current_digit = int(A[k])\n            if h < n and m < n:\n                option1 = current_digit * pow10_h[h] + dp[h+1][m]\n                option2 = current_digit * pow10_m[m] + dp[h][m+1]\n                dp[h][m] = max(option1, option2)\n            elif h < n:\n                dp[h][m] = current_digit * pow10_h[h] + dp[h+1][m]\n            elif m < n:\n                dp[h][m] = current_digit * pow10_m[m] + dp[h][m+1]\n            else:\n                dp[h][m] = 0\n    \n    h, m = 0, 0\n    result = []\n    for _ in range(2 * n):\n        k = h + m\n        current_digit = int(A[k])\n        if h < n and m < n:\n            option1 = current_digit * pow10_h[h] + dp[h+1][m]\n            option2 = current_digit * pow10_m[m] + dp[h][m+1]\n            if option1 >= option2:\n                result.append('H')\n                h += 1\n            else:\n                result.append('M')\n                m += 1\n        elif h < n:\n            result.append('H')\n            h += 1\n        else:\n            result.append('M')\n            m += 1\n    \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 417,
        "completion_token_count": 1000,
        "thoughts_token_count": 8192
    }
}