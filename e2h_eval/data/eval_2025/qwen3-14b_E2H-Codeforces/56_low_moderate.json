{
    "start": 1758309276.7050092,
    "end": 1758309510.705389,
    "start-formatted": "2025-09-20 04:14 KST",
    "end-formatted": "2025-09-20 04:18 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\nOkay, let's tackle this problem. So the task is to determine if there's a perfect matching between R spaceships and B bases such that no two connecting lines intersect. And since R and B are up to 10, maybe we can check all possible matchings?\n\nFirst, I need to understand what the constraints are. The problem says that any two paths (from a base to its assigned spaceship) must not intersect. So for any two pairs (spaceship A to base X) and (spaceship B to base Y), the line segments between them must not cross each other.\n\nBut how do I check that? For each possible perfect matching, I need to check that all pairs of line segments in the matching are non-intersecting.\n\nSo the plan is:\n\n1. Generate all possible perfect matchings between the R spaceships and B bases. Since R and B are equal (because it's a perfect matching), but the input may have R != B? Wait, the problem says that the first line has R and B. But for a perfect matching, R must equal B. Wait, the problem says that every base has exactly one guardian and each spaceship has exactly one assigned base. So the number of spaceships R must be equal to the number of bases B. Otherwise, it's impossible. So the first check is if R != B, output No. But looking at the input examples, in the first example it's 3 3, and second is 2 1. So in the second case, R=2, B=1. So the answer is No because you can't have a perfect matching. But the problem says that the input is such that R and B can be up to 10. So the first thing in the code is to check if R != B, then output No.\n\nWait, but the problem statement says that the input is given with R and B. But the problem says that the assignment is a perfect matching. So if R != B, then there's no possible perfect matching. So in that case, the answer is automatically No. So the first step is to check if R != B. If so, output No. Otherwise, proceed.\n\nSo for the cases where R = B, we need to check if there exists a perfect matching (permutation) of spaceships to bases such that all the line segments between them don't cross each other.\n\nNow, the question is how to generate all permutations of the bases and check for each permutation whether the line segments between the i-th spaceship and the i-th base in the permutation do not cross any other line segments.\n\nBut wait, for a permutation, each spaceship is matched to exactly one base, and vice versa. So for each permutation of the bases (since R=B), we can check if the set of line segments between the spaceship i and base perm[i] (for each i) are non-crossing.\n\nBut how do I check if two line segments cross each other?\n\nFirst, I need a function to check if two line segments AB and CD intersect. But since the problem says that no three points are colinear, that might simplify things. Because, if two line segments share an endpoint, they are not considered as crossing? Or is that allowed? Let me check the problem statement.\n\nThe problem says that the paths (straight lines) from a base to its assigned spaceship must not intersect. So if two line segments share a common point (like if two lines meet at a point), that would count as an intersection. But since all points are unique, and no three points are colinear, then any two line segments that share an endpoint would not be overlapping except at the endpoints. But the problem says that the paths shouldn't intersect. So, if two line segments share an endpoint, does that count as an intersection? For example, if two lines connect (A to B) and (B to C), then they share a point. But according to the problem's note, in the first example, connecting in order works. So perhaps the problem considers that two line segments that only touch at endpoints are allowed. Because otherwise, even in the first example, if you have three ships and three bases arranged in a way that their connecting lines share endpoints, but that's probably not the case.\n\nBut the problem says that no three points are on the same line. So for any two line segments, they can't share a point except for their endpoints. So for two line segments AB and CD, they can't share a point unless one of the endpoints is the same. But since all points are unique, the line segments can't share a point except for their endpoints. So for two line segments AB and CD, they either cross each other in their interiors (which is a problem), or they share an endpoint (but that's allowed?), or they don't intersect.\n\nBut the problem says that the paths should not intersect. So if two paths share an endpoint, that's allowed? Like, if two lines are connected to the same",
    "response": "```python\nimport sys\nimport itertools\n\ndef read_input():\n    data = sys.stdin.read().split('\\n')\n    lines = [line.strip() for line in data if line.strip()]\n    R, B = map(int, lines[0].split())\n    spaceships = []\n    for i in range(1, R+1):\n        x, y = map(int, lines[i].split())\n        spaceships.append((x, y))\n    bases = []\n    for i in range(R+1, R+B+1):\n        x, y = map(int, lines[i].split())\n        bases.append((x, y))\n    return R, B, spaceships, bases\n\ndef orientation(p, q, r):\n    val = (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0])\n    if val == 0:\n        return 0  # colinear\n    return 1 if val > 0 else 2  # clock or counterclock wise\n\ndef on_segment(p, q, r):\n    return (min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and\n            min(p[1], r[1]) <= q[1] <= max(p[1], r[1]))\n\ndef segments_intersect(seg1, seg2):\n    p1, q1 = seg1\n    p2, q2 = seg2\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    if o1 != o2 and o3 != o4:\n        return True\n\n    if o1 == 0 and on_segment(p1, p2, q1):\n        return True\n    if o2 == 0 and on_segment(p1, q2, q1):\n        return True\n    if o3 == 0 and on_segment(p2, p1, q2):\n        return True\n    if o4 == 0 and on_segment(p2, q1, q2):\n        return True\n\n    return False\n\ndef check_matching(spaceships, bases, perm):\n    for i in range(len(spaceships)):\n        for j in range(i+1, len(spaceships)):\n            seg1 = (spaceships[i], bases[perm[i]])\n            seg2 = (spaceships[j], bases[perm[j]])\n            if segments_intersect(seg1, seg2):\n                return False\n    return True\n\ndef main():\n    R, B, spaceships, bases = read_input()\n    if R != B:\n        print(\"No\")\n        return\n\n    from itertools import permutations\n    for perm in permutations(range(B)):\n        if check_matching(spaceships, bases, perm):\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport itertools\n\ndef read_input():\n    data = sys.stdin.read().split('\\n')\n    lines = [line.strip() for line in data if line.strip()]\n    R, B = map(int, lines[0].split())\n    spaceships = []\n    for i in range(1, R+1):\n        x, y = map(int, lines[i].split())\n        spaceships.append((x, y))\n    bases = []\n    for i in range(R+1, R+B+1):\n        x, y = map(int, lines[i].split())\n        bases.append((x, y))\n    return R, B, spaceships, bases\n\ndef orientation(p, q, r):\n    val = (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0])\n    if val == 0:\n        return 0  # colinear\n    return 1 if val > 0 else 2  # clock or counterclock wise\n\ndef on_segment(p, q, r):\n    return (min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and\n            min(p[1], r[1]) <= q[1] <= max(p[1], r[1]))\n\ndef segments_intersect(seg1, seg2):\n    p1, q1 = seg1\n    p2, q2 = seg2\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    if o1 != o2 and o3 != o4:\n        return True\n\n    if o1 == 0 and on_segment(p1, p2, q1):\n        return True\n    if o2 == 0 and on_segment(p1, q2, q1):\n        return True\n    if o3 == 0 and on_segment(p2, p1, q2):\n        return True\n    if o4 == 0 and on_segment(p2, q1, q2):\n        return True\n\n    return False\n\ndef check_matching(spaceships, bases, perm):\n    for i in range(len(spaceships)):\n        for j in range(i+1, len(spaceships)):\n            seg1 = (spaceships[i], bases[perm[i]])\n            seg2 = (spaceships[j], bases[perm[j]])\n            if segments_intersect(seg1, seg2):\n                return False\n    return True\n\ndef main():\n    R, B, spaceships, bases = read_input()\n    if R != B:\n        print(\"No\")\n        return\n\n    from itertools import permutations\n    for perm in permutations(range(B)):\n        if check_matching(spaceships, bases, perm):\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 486,
        "completion_token_count": 658,
        "thoughts_token_count": 1024
    }
}