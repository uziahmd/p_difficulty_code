{
    "start": 1758309525.4562852,
    "end": 1758309603.670952,
    "start-formatted": "2025-09-20 04:18 KST",
    "end-formatted": "2025-09-20 04:20 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\nOkay, I need to solve this problem where given a value p, I have to find two things: the minimum number of nodes required to create a p-reachable directed graph, and then among all such graphs with that minimum number of nodes, find the maximum number of unidirectional pairs.\n\nLet me start by understanding the definitions again. \n\nA p-reachable graph has exactly p ordered pairs (u, v) where u < v and both u and v are reachable from each other. Wait, but reachability is mutual here? Or does it mean that there's a path from u to v and from v to u? Because if they are reachable from each other, then they are in the same strongly connected component (SCC). So for each pair (u, v) where u < v, if they are in the same SCC, that contributes 1 to p. So the total p is the number of unordered pairs of nodes in the same SCC, multiplied by 1 (since u < v). Wait, no, because for each unordered pair {u, v}, there's exactly one ordered pair (u, v) where u < v. So the total p is the sum over all SCCs of C(k, 2), where k is the size of the SCC. Because in an SCC, every pair of nodes is mutually reachable. So for each SCC of size k, there are k*(k-1)/2 such ordered pairs (u, v) where u < v and they are mutually reachable.\n\nSo the problem reduces to finding a set of SCCs whose sizes' combinations (sum of C(k_i, 2)) equals exactly p. And we need to find the minimal number of nodes possible for that sum. Then, among those configurations with minimal nodes, find the maximum number of unidirectional pairs.\n\nNow, the first part is to find the minimal number of nodes. Let's think about how to represent p as the sum of C(k_i, 2), with the sum of k_i being as small as possible.\n\nThe minimal number of nodes would be achieved by using as large as possible C(k, 2) terms. Because for example, C(5,2) is 10. If you have to get a sum of 10, using one component of size 5 is better than using smaller components. Because 5 is less than, say, 4 + 2 = 6 nodes (C(4,2) is 6, C(2,2) is 1, sum is 7, which is less than 10. Wait, no, maybe I need to think of how to maximize the sum per node. For example, to get a certain sum of p, the minimal total nodes is achieved by using as many as possible the largest possible C(k,2) values.\n\nWait, the problem is similar to representing p as the sum of combinations of C(k_i, 2) where the sum of k_i is minimized. How can we find that?\n\nThis is similar to the problem of making change with coins, but with denominations being C(k, 2) for various k, and the goal is to minimize the total number of coins (which is the sum of k_i).\n\nBut since the denominations are not fixed, but for any k ≥ 1, C(k, 2) is allowed. But since we want to minimize the sum of k_i, we should use as large as possible C(k, 2) terms. Because for a given value, larger C(k,2) terms contribute more per node. For example, C(k, 2) is k*(k-1)/2. So for a given value, say, x, the optimal way to represent it is to take the largest possible C(k, 2) that is ≤ x, subtract it, and repeat. But this approach may not always be optimal, but perhaps for our purposes, it's the right way.\n\nWait, let's think. Suppose we have to make p. Let's take the largest possible C(k, 2) that is ≤ p. Then subtract it and proceed recursively. But this greedy approach may not always give the minimal sum of k_i. However, perhaps for our problem, this approach is correct. Let's see some examples.\n\nFor example, if p=3. The largest C(k,2) ≤3 is C(3,2)=3. So we take one component of size 3. Sum of nodes is 3. Which is indeed the minimal. Which matches the first sample input.\n\nAnother example: p=4. What is the minimal sum of k_i?\n\nOption 1: Take C(3,2)=3, and then C(2,2)=1. Total sum of nodes is 3+2=5. But another option is to take two components of size 2 and 3? No. Wait, 3+1=4. Wait,",
    "response": "To solve this problem, we need to determine the minimum number of nodes required to create a p-reachable directed graph and then find the maximum number of unidirectional pairs among all such graphs with the minimum number of nodes.\n\n### Approach\n1. **Understanding Reachability**: A p-reachable graph has exactly `p` ordered pairs (u, v) where `u < v` and both nodes are mutually reachable. This translates to finding the sum of combinations of node sizes in strongly connected components (SCCs) that equals `p`.\n\n2. **Greedy Strategy for Minimum Nodes**: To minimize the number of nodes, use the largest possible combinations of the form C(k, 2) (which is k*(k-1)/2) that fit into `p`. This approach ensures that each component contributes maximally to `p` while using the fewest nodes.\n\n3. **Maximizing Unidirectional Pairs**: After determining the minimum number of nodes, maximize the number of unidirectional pairs by considering the structure of the graph. This involves calculating the total possible pairs and subtracting the mutual reachability pairs.\n\n### Solution Code\n```python\nimport sys\nimport math\n\ndef main():\n    p = int(sys.stdin.readline())\n    if p == 0:\n        print(\"0 0\")\n        return\n    \n    # Find the minimal number of nodes\n    nodes = []\n    remaining = p\n    while remaining > 0:\n        # Find the largest k such that k*(k-1)//2 <= remaining\n        k = 1\n        while k*(k-1)//2 <= remaining:\n            k += 1\n        k -= 1\n        nodes.append(k)\n        remaining -= k*(k-1)//2\n    \n    total_nodes = sum(nodes)\n    \n    # Now compute the maximum number of unidirectional pairs\n    # Total possible ordered pairs (u, v) with u != v is total_nodes*(total_nodes - 1)\n    total_pairs = total_nodes * (total_nodes - 1)\n    \n    # Subtract the number of mutual pairs (sum C(k_i, 2) for each component)\n    mutual_pairs = p\n    \n    # Also subtract the number of pairs within the same component (since they are mutual)\n    # Wait, no. The mutual_pairs is exactly the p given. Because the mutual pairs are counted as p.\n    # The unidirectional pairs are those where u can reach v but not vice versa.\n    # So, total_pairs = mutual_pairs + unidirectional_pairs + bidirectional_pairs? No.\n    # Actually, the total number of ordered pairs (u, v) with u != v is total_pairs.\n    # These can be divided into three categories:\n    # 1. u can reach v and v can reach u (mutual, counted in p)\n    # 2. u can reach v but not vice versa (unidirectional)\n    # 3. v can reach u but not vice versa (unidirectional)\n    # However, the mutual pairs are counted once (as (u, v) where u < v), which is p.\n    # But the total number of mutual pairs (including both directions) is 2*p.\n    # Wait, no. For each unordered pair {u, v}, if they are in the same SCC, then (u, v) and (v, u) are both mutual. However, the problem defines p as the count of ordered pairs (u, v) where u < v and they are mutually reachable. So for each such pair, there's one entry in p. Thus, the total number of mutual pairs (in both directions) is 2*p. However, the total number of ordered pairs (u, v) where u != v is total_pairs = n*(n-1). So the number of unidirectional pairs is total_pairs - 2*p.\n\n    # Wait, because for every pair (u, v) where u != v, either:\n    # - they are mutually reachable (so both (u, v) and (v, u) are in mutual pairs)\n    # - or exactly one of (u, v) or (v, u) is unidirectional\n    # - or neither is reachable (but the problem says that the graph is p-reachable, but it's allowed for some pairs to not be reachable at all?)\n\n    # However, the problem does not require that all pairs are reachable. So the total number of unidirectional pairs is the number of ordered pairs (u, v) with u != v where exactly one direction is reachable.\n\n    # But how to compute this?\n\n    # Let me think again. The problem defines unidirectional pairs as (u, v) where u != v, there exists a path from u to v, and no path from v to u. So each such pair is counted once.\n\n    # The total number of ordered pairs (u, v) with u != v is n*(n-1).\n\n    # The number of mutual pairs (i.e., pairs where both directions are reachable) is 2*p. Because for each (u, v) with u < v and mutual, both (u, v) and (v, u) exist. However, the problem counts only the (u, v) with u < v, so p is the count of such pairs. Therefore, the total number of mutual ordered pairs is 2*p.\n\n    # Then, the number of unidirectional pairs is total_pairs - 2*p - (number of pairs that are not reachable in either direction). But since the problem allows for some pairs not to be reachable, how do we account for that?\n\n    # However, the way to maximize the number of unidirectional pairs is to arrange the graph such that as many pairs as possible are unidirectional. But how?\n\n    # The key insight here is that the structure of the graph with minimal nodes is composed of several SCCs. For example, if the minimal node count is achieved by having components of sizes k_1, k_2, ..., then the graph can be structured as a DAG of these components, where edges go from one component to another but not vice versa. In this case, the number of unidirectional pairs is the number of ordered pairs between different components, plus the number of unidirectional pairs within components (but since components are strongly connected, there are none).\n\n    # Wait, within each component, all pairs are mutually reachable, so no unidirectional pairs. Between components, if there's a directed edge from component A to component B, then all pairs (a, b) where a is in A and b is in B are unidirectional (if there's no reverse edge). But if the DAG is arranged such that there's a total order between components, then for any two components A and B, if A comes before B in the DAG, then all pairs (a, b) are unidirectional (from A to B), and (b, a) are not reachable. So for each pair of components, we can have one direction of edges.\n\n    # So the maximum number of unidirectional pairs is achieved when the DAG of components is a linear chain. For example, if there are m components, arranged in a line, then for any two components i and j where i < j, all pairs (a, b) with a in i and b in j contribute to unidirectional pairs.\n\n    # Let's calculate that. Suppose we have components of sizes s_1, s_2, ..., s_m. The total number of ordered pairs between components is sum_{i < j} s_i * s_j * 2? No, because for each pair of components i and j, if there is an edge from i to j, then all pairs (a, b) where a is in i and b in j are unidirectional. If there is also an edge from j to i, then those pairs would be mutual. But to maximize the unidirectional pairs, we should arrange the DAG as a linear order, so that each component has edges to all components that come after it in the order. In this case, for each pair of components (i, j) where i < j, all pairs (a, b) with a in i and b in j are unidirectional. And there are no reverse edges. So the number of unidirectional pairs between components is sum_{i < j} s_i * s_j * 1 (since each such pair (a, b) is unidirectional).\n\n    # Additionally, within each component, there are no unidirectional pairs. So the total unidirectional pairs is sum_{i < j} s_i * s_j.\n\n    # Now, sum_{i < j} s_i * s_j = [ (sum s_i)^2 - sum s_i^2 ] / 2 \n\n    # So the maximum number of unidirectional pairs is (total_nodes^2 - sum_squares) // 2\n\n    # Where sum_squares is the sum of squares of the sizes of the components.\n\n    # Because total_nodes = sum s_i, so sum_{i < j} s_i s_j = (total^2 - sum s_i^2) / 2.\n\n    # Therefore, the maximum number of unidirectional pairs is (total_nodes^2 - sum_squares) // 2.\n\n    # Now, the sum_squares is the sum of k_i^2 for each component in the decomposition of p.\n\n    # For example, if p is decomposed into components of sizes [3], sum_squares is 9. total_nodes is 3. Then the unidirectional pairs would be (9 - 9)/2 = 0, which matches the first sample.\n\n    # Another example: if p is decomposed into components [2, 2], sum_squares is 4 + 4 = 8. total_nodes is 4. Then the unidirectional pairs would be (16 - 8)/2 = 4. But wait, in this case, the components could be arranged in a DAG with two components. The number of unidirectional pairs is 2*2=4 (from first component to second), which matches.\n\n    # So the formula holds. Thus, the maximum number of unidirectional pairs is (total_nodes^2 - sum_squares) // 2.\n\n    # So the steps are:\n\n    # 1. Decompose p into components [k_1, k_2, ...] as per the greedy approach.\n    # 2. Compute sum_squares = sum(k_i^2)\n    # 3. Compute max_unidirectional = (total_nodes^2 - sum_squares) // 2\n\n    sum_squares = sum(k*k for k in nodes)\n    max_unidirectional = (total_nodes * total_nodes - sum_squares) // 2\n    print(f\"{total_nodes} {max_unidirectional}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read as an integer `p`.\n2. **Minimum Nodes Calculation**: Using a greedy approach, decompose `p` into the largest possible combinations of the form C(k, 2) to minimize the total number of nodes.\n3. **Maximum Unidirectional Pairs Calculation**: Calculate the sum of squares of the component sizes and use the derived formula to find the maximum number of unidirectional pairs based on the structure of the graph.\n\nThis approach efficiently determines the minimum number of nodes and the maximum number of unidirectional pairs using mathematical insights and greedy decomposition.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\n\ndef main():\n    p = int(sys.stdin.readline())\n    if p == 0:\n        print(\"0 0\")\n        return\n    \n    # Find the minimal number of nodes\n    nodes = []\n    remaining = p\n    while remaining > 0:\n        # Find the largest k such that k*(k-1)//2 <= remaining\n        k = 1\n        while k*(k-1)//2 <= remaining:\n            k += 1\n        k -= 1\n        nodes.append(k)\n        remaining -= k*(k-1)//2\n    \n    total_nodes = sum(nodes)\n    \n    # Now compute the maximum number of unidirectional pairs\n    # Total possible ordered pairs (u, v) with u != v is total_nodes*(total_nodes - 1)\n    total_pairs = total_nodes * (total_nodes - 1)\n    \n    # Subtract the number of mutual pairs (sum C(k_i, 2) for each component)\n    mutual_pairs = p\n    \n    # Also subtract the number of pairs within the same component (since they are mutual)\n    # Wait, no. The mutual_pairs is exactly the p given. Because the mutual pairs are counted as p.\n    # The unidirectional pairs are those where u can reach v but not vice versa.\n    # So, total_pairs = mutual_pairs + unidirectional_pairs + bidirectional_pairs? No.\n    # Actually, the total number of ordered pairs (u, v) with u != v is total_pairs.\n    # These can be divided into three categories:\n    # 1. u can reach v and v can reach u (mutual, counted in p)\n    # 2. u can reach v but not vice versa (unidirectional)\n    # 3. v can reach u but not vice versa (unidirectional)\n    # However, the mutual pairs are counted once (as (u, v) where u < v), which is p.\n    # But the total number of mutual pairs (including both directions) is 2*p.\n    # Wait, no. For each unordered pair {u, v}, if they are in the same SCC, then (u, v) and (v, u) are both mutual. However, the problem defines p as the count of ordered pairs (u, v) where u < v and they are mutually reachable. So for each such pair, there's one entry in p. Thus, the total number of mutual pairs (in both directions) is 2*p. However, the total number of ordered pairs (u, v) where u != v is total_pairs = n*(n-1). So the number of unidirectional pairs is total_pairs - 2*p.\n\n    # Wait, because for every pair (u, v) where u != v, either:\n    # - they are mutually reachable (so both (u, v) and (v, u) are in mutual pairs)\n    # - or exactly one of (u, v) or (v, u) is unidirectional\n    # - or neither is reachable (but the problem says that the graph is p-reachable, but it's allowed for some pairs to not be reachable at all?)\n\n    # However, the problem does not require that all pairs are reachable. So the total number of unidirectional pairs is the number of ordered pairs (u, v) with u != v where exactly one direction is reachable.\n\n    # But how to compute this?\n\n    # Let me think again. The problem defines unidirectional pairs as (u, v) where u != v, there exists a path from u to v, and no path from v to u. So each such pair is counted once.\n\n    # The total number of ordered pairs (u, v) with u != v is n*(n-1).\n\n    # The number of mutual pairs (i.e., pairs where both directions are reachable) is 2*p. Because for each (u, v) with u < v and mutual, both (u, v) and (v, u) exist. However, the problem counts only the (u, v) with u < v, so p is the count of such pairs. Therefore, the total number of mutual ordered pairs is 2*p.\n\n    # Then, the number of unidirectional pairs is total_pairs - 2*p - (number of pairs that are not reachable in either direction). But since the problem allows for some pairs not to be reachable, how do we account for that?\n\n    # However, the way to maximize the number of unidirectional pairs is to arrange the graph such that as many pairs as possible are unidirectional. But how?\n\n    # The key insight here is that the structure of the graph with minimal nodes is composed of several SCCs. For example, if the minimal node count is achieved by having components of sizes k_1, k_2, ..., then the graph can be structured as a DAG of these components, where edges go from one component to another but not vice versa. In this case, the number of unidirectional pairs is the number of ordered pairs between different components, plus the number of unidirectional pairs within components (but since components are strongly connected, there are none).\n\n    # Wait, within each component, all pairs are mutually reachable, so no unidirectional pairs. Between components, if there's a directed edge from component A to component B, then all pairs (a, b) where a is in A and b is in B are unidirectional (if there's no reverse edge). But if the DAG is arranged such that there's a total order between components, then for any two components A and B, if A comes before B in the DAG, then all pairs (a, b) are unidirectional (from A to B), and (b, a) are not reachable. So for each pair of components, we can have one direction of edges.\n\n    # So the maximum number of unidirectional pairs is achieved when the DAG of components is a linear chain. For example, if there are m components, arranged in a line, then for any two components i and j where i < j, all pairs (a, b) with a in i and b in j contribute to unidirectional pairs.\n\n    # Let's calculate that. Suppose we have components of sizes s_1, s_2, ..., s_m. The total number of ordered pairs between components is sum_{i < j} s_i * s_j * 2? No, because for each pair of components i and j, if there is an edge from i to j, then all pairs (a, b) where a is in i and b in j are unidirectional. If there is also an edge from j to i, then those pairs would be mutual. But to maximize the unidirectional pairs, we should arrange the DAG as a linear order, so that each component has edges to all components that come after it in the order. In this case, for each pair of components (i, j) where i < j, all pairs (a, b) with a in i and b in j are unidirectional. And there are no reverse edges. So the number of unidirectional pairs between components is sum_{i < j} s_i * s_j * 1 (since each such pair (a, b) is unidirectional).\n\n    # Additionally, within each component, there are no unidirectional pairs. So the total unidirectional pairs is sum_{i < j} s_i * s_j.\n\n    # Now, sum_{i < j} s_i * s_j = [ (sum s_i)^2 - sum s_i^2 ] / 2 \n\n    # So the maximum number of unidirectional pairs is (total_nodes^2 - sum_squares) // 2\n\n    # Where sum_squares is the sum of squares of the sizes of the components.\n\n    # Because total_nodes = sum s_i, so sum_{i < j} s_i s_j = (total^2 - sum s_i^2) / 2.\n\n    # Therefore, the maximum number of unidirectional pairs is (total_nodes^2 - sum_squares) // 2.\n\n    # Now, the sum_squares is the sum of k_i^2 for each component in the decomposition of p.\n\n    # For example, if p is decomposed into components of sizes [3], sum_squares is 9. total_nodes is 3. Then the unidirectional pairs would be (9 - 9)/2 = 0, which matches the first sample.\n\n    # Another example: if p is decomposed into components [2, 2], sum_squares is 4 + 4 = 8. total_nodes is 4. Then the unidirectional pairs would be (16 - 8)/2 = 4. But wait, in this case, the components could be arranged in a DAG with two components. The number of unidirectional pairs is 2*2=4 (from first component to second), which matches.\n\n    # So the formula holds. Thus, the maximum number of unidirectional pairs is (total_nodes^2 - sum_squares) // 2.\n\n    # So the steps are:\n\n    # 1. Decompose p into components [k_1, k_2, ...] as per the greedy approach.\n    # 2. Compute sum_squares = sum(k_i^2)\n    # 3. Compute max_unidirectional = (total_nodes^2 - sum_squares) // 2\n\n    sum_squares = sum(k*k for k in nodes)\n    max_unidirectional = (total_nodes * total_nodes - sum_squares) // 2\n    print(f\"{total_nodes} {max_unidirectional}\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 472,
        "completion_token_count": 2431,
        "thoughts_token_count": 1024
    }
}