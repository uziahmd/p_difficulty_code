{
    "start": 1758310734.4921777,
    "end": 1758310772.1175246,
    "start-formatted": "2025-09-20 04:38 KST",
    "end-formatted": "2025-09-20 04:39 KST",
    "gpu": 2,
    "pid": 30,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# TV Game\n\nThere is a new TV game on BerTV. In this game two players get a number A consisting of 2n digits. Before each turn players determine who will make the next move. Each player should make exactly n moves. On it's turn i-th player takes the leftmost digit of A and appends it to his or her number Si. After that this leftmost digit is erased from A. Initially the numbers of both players (S1 and S2) are «empty». Leading zeroes in numbers A, S1, S2 are allowed. In the end of the game the first player gets S1 dollars, and the second gets S2 dollars.One day Homer and Marge came to play the game. They managed to know the number A beforehand. They want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize. Help them.\n\n## Input\nThe first line contains integer n (1 ≤ n ≤ 18). The second line contains integer A consisting of exactly 2n digits. This number can have leading zeroes.\n\n## Output\nOutput the line of 2n characters «H» and «M» — the sequence of moves of Homer and Marge, which gives them maximum possible total prize. Each player must make exactly n moves. If there are several solutions, output any of them.\n\n## Example\n### Input\n['2\\n1234', '2\\n9911']\n\n### Output\n['HHMM', 'HMHM']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\nOkay, let's see. The problem is about Homer and Marge playing a game where they take digits from a number A. The goal is to maximize their total prize, which is the sum of S1 and S2. Each of them takes exactly n moves, and each move they take the leftmost digit of A and add it to their own number. The order of taking digits depends on the sequence of H and M in the output. We need to find the optimal sequence that gives the maximum total.\n\nHmm. So the challenge is to choose, for each step, whether Homer or Marge takes the next digit, such that after all steps, the sum of their numbers is maximized. But how do we model this?\n\nLet me think about the approach. Since n can be up to 18, the total number of steps is 36. But trying all possible combinations would be O(2^36), which is way too big. That's impossible for any brute-force approach.\n\nWait, but maybe there's a dynamic programming approach here. Let's think about the state. The state depends on how many digits have been taken by Homer and Marge so far. For example, at any point, Homer has taken h steps, Marge has taken m steps. Since the total steps is 2n, and h + m = current step count. Also, since each must take exactly n steps, we can model the state as (h, m), and the current position in the string A.\n\nWait, but the current position in A is determined by the number of digits taken so far. Because each move takes the leftmost digit. So if we have taken k digits, then the next digit is A[k], assuming the original string is 0-based. So for example, the initial state is 0 digits taken. Then, after one move, the next digit is A[1], etc.\n\nSo the state can be represented by how many digits each player has taken. Since h and m are such that h + m = k, where k is the number of digits taken so far. Also, since h can't exceed n, and m can't exceed n. So the state can be represented by (h, m), and the current position is h + m. So for each state (h, m), we can decide whether to take the next digit as H or M, provided that h < n or m < n respectively.\n\nThe key is to find the optimal choice at each step that leads to the maximum total sum. However, how do we compute the sum? Because the sum depends on the digits collected by each player. But the sum is the sum of S1 and S2, which are numbers formed by the digits taken by each player. Wait, but the value of S1 and S2 depends on the order in which the digits are added. For example, if Homer takes digits 1 and 2, his number is 12, which is 1*10 + 2. If he takes 2 first and then 1, it's 21. So the order matters.\n\nBut how can we model this in DP? Because the value of the numbers depends on the order of digits taken. So for each state, we need to track not only how many digits each has taken, but also the actual values of S1 and S2. But with n up to 18, the maximum possible value for S1 and S2 is 10^18-1, which is way too big to track in a DP state. So that's impossible.\n\nWait, but the problem says that the total sum S1 + S2 needs to be maximized. Let's think about how adding a digit affects the sum. Suppose the current digit is d. If it's added to Homer's number, then it contributes d multiplied by 10^{n - h - 1}, because Homer will take exactly n digits. For example, if Homer has already taken h digits, then the next digit he takes will be the (h+1)th digit of his number. So the place value is 10^{n - h - 1} multiplied by d. Similarly for Marge.\n\nWait, that's an interesting observation. Because the position of the digit in the final number determines its contribution to the sum. For example, the first digit Homer takes is the most significant digit of his number. So if he takes a digit d at step when he has h digits already, then the contribution of that digit to S1 is d * 10^{n - h - 1} (since he will have n - h digits left to take, so this digit is the (h+1)th digit, which is 10^{n - h - 1} times its value).\n\nSo, the total contribution of each digit is determined by the order in which it's taken. Therefore, for each digit in the original A,",
    "response": "To solve this problem, we need to determine the optimal sequence of moves for Homer and Marge such that the total prize money they receive is maximized. The key insight is to recognize that the contribution of each digit to the total prize depends on its position in the final numbers formed by Homer and Marge.\n\n### Approach\n1. **Dynamic Programming (DP) with Memoization**: We use a recursive approach with memoization to explore all possible sequences of moves efficiently. The state of our DP function is defined by the number of digits each player has taken so far.\n2. **Greedy Strategy**: At each step, we decide whether Homer or Marge should take the next digit based on which choice leads to a higher total prize. This decision is made by evaluating the contribution of the current digit to the total prize if it were taken by either player.\n3. **Memoization**: To avoid recalculating results for the same state, we use memoization to store the results of subproblems.\n\n### Solution Code\n```python\nimport sys\nfrom functools import lru_cache\n\ndef main():\n    n = int(sys.stdin.readline())\n    A = sys.stdin.readline().strip()\n    length = 2 * n\n\n    @lru_cache(maxsize=None)\n    def dp(h, m):\n        if h + m == length:\n            return (0, \"\")\n        current_digit = int(A[h + m])\n        # If Homer can take the next move\n        if h < n:\n            contrib_h = current_digit * (10 ** (n - h - 1))\n            next_h = h + 1\n            res, path = dp(next_h, m)\n            total = contrib_h + res\n            best_total = total\n            best_path = \"H\" + path\n        else:\n            best_total = -1\n            best_path = \"\"\n        # If Marge can take the next move\n        if m < n:\n            contrib_m = current_digit * (10 ** (n - m - 1))\n            next_m = m + 1\n            res, path = dp(h, next_m)\n            total = contrib_m + res\n            if best_total < total:\n                best_total = total\n                best_path = \"M\" + path\n            elif best_total == total:\n                # Choose lexicographically smaller? Or just any, but the problem says any is acceptable\n                best_path = \"M\" + path\n        # In case both are not possible, but since h + m < length, one must be possible\n        return (best_total, best_path)\n\n    total, path = dp(0, 0)\n    print(path)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Dynamic Programming State**: The function `dp(h, m)` computes the maximum total prize starting from the state where Homer has taken `h` digits and Marge has taken `m` digits.\n2. **Contribution Calculation**: For each digit, the contribution to the total prize is calculated based on its position in the final number. This is determined by the number of digits remaining for each player to take.\n3. **Recursive Decision Making**: At each step, the algorithm decides whether Homer or Marge should take the next digit by recursively evaluating the potential total prize from each choice.\n4. **Memoization**: Using `lru_cache`, the results of previously computed states are stored to avoid redundant calculations, ensuring efficiency even for larger values of `n`.\n\nThis approach ensures that we explore all possible sequences of moves efficiently while maximizing the total prize money for Homer and Marge.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom functools import lru_cache\n\ndef main():\n    n = int(sys.stdin.readline())\n    A = sys.stdin.readline().strip()\n    length = 2 * n\n\n    @lru_cache(maxsize=None)\n    def dp(h, m):\n        if h + m == length:\n            return (0, \"\")\n        current_digit = int(A[h + m])\n        # If Homer can take the next move\n        if h < n:\n            contrib_h = current_digit * (10 ** (n - h - 1))\n            next_h = h + 1\n            res, path = dp(next_h, m)\n            total = contrib_h + res\n            best_total = total\n            best_path = \"H\" + path\n        else:\n            best_total = -1\n            best_path = \"\"\n        # If Marge can take the next move\n        if m < n:\n            contrib_m = current_digit * (10 ** (n - m - 1))\n            next_m = m + 1\n            res, path = dp(h, next_m)\n            total = contrib_m + res\n            if best_total < total:\n                best_total = total\n                best_path = \"M\" + path\n            elif best_total == total:\n                # Choose lexicographically smaller? Or just any, but the problem says any is acceptable\n                best_path = \"M\" + path\n        # In case both are not possible, but since h + m < length, one must be possible\n        return (best_total, best_path)\n\n    total, path = dp(0, 0)\n    print(path)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 425,
        "completion_token_count": 747,
        "thoughts_token_count": 1024
    }
}