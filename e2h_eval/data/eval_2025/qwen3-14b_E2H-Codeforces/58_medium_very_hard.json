{
    "start": 1758313866.8798108,
    "end": 1758314874.9221392,
    "start-formatted": "2025-09-20 05:31 KST",
    "end-formatted": "2025-09-20 05:47 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\nOkay, I need to solve this problem where I have to find the minimum number of edges to add to a graph to form an odd-length cycle, and also count the number of ways to do that. Let me think about how to approach this.\n\nFirst, let's understand the problem. The graph is undirected, no loops or parallel edges. We need to find t (minimum edges to add) and w (number of ways to add those edges to form such a cycle).\n\nAn odd-length cycle is a cycle with an odd number of edges (and vertices since it's simple). So, for example, a triangle is a 3-cycle (odd), a pentagon is 5, etc.\n\nThe key here is that if the graph already contains an odd-length cycle, then t is 0 and w is 1? Or wait, maybe not. Wait, the problem says that we need to form a simple cycle of odd length. So if the graph already has such a cycle, then t is 0 and w is the number of such cycles? No, no. Because the question is about adding edges to form such a cycle. But if there's already one, then we don't need to add any edges. So the answer would be t=0 and w=1? Wait, no. Because the problem says \"the number of ways to add t edges in order to form a cycle of odd length\". If t is zero, then the way is to choose any existing cycle of odd length. But wait, the problem requires that the way is to add exactly t edges. So if the graph already contains at least one such cycle, then t is 0 and w is the number of such cycles? Or perhaps not. Because the problem says that the way to add edges must result in forming a cycle. However, if the graph already has such a cycle, then there are multiple possibilities, but the question is about how many ways to add t edges (which is zero) to form such a cycle. But since the existing cycles are already present, perhaps the answer is that when there's already an odd cycle, then t is 0 and w is the number of such possible cycles. But no, because the problem says that the way to add edges is to have exactly t edges added. So if there's already an odd cycle, then you can choose to add zero edges, but how many ways are there? Well, since adding zero edges implies that you have to select a cycle that's already present. But the problem's note says that two ways are considered equal if they have the same set of added edges. So if there are multiple existing cycles, each of them is a different way? Or is the problem considering that any existing cycle is a valid way, and thus the count is the number of existing odd-length cycles?\n\nBut that seems complicated. However, looking at the sample input:\n\nIn the second example input, which is a triangle (3 nodes connected in a cycle), the output is 0 1. So even though there's exactly one cycle (the triangle itself), the answer is 1. So that suggests that when the graph already has an odd cycle, t is 0 and w is 1. But why? Because there's only one way to add zero edges, which is to not add any. But why does the sample output say 1? Because regardless of how many existing cycles there are, the answer is 1? That seems conflicting.\n\nWait, let's look at the second sample input. The input is 3 nodes connected as a triangle. The output is 0 1. So even though there's exactly one cycle (the triangle), the answer is 1. So maybe the problem counts the number of ways to add t edges such that after adding them, the graph contains at least one odd cycle. But in that case, when t is zero, the answer is 1 if the graph already has an odd cycle. But why?\n\nAlternatively, perhaps the problem requires that the added edges themselves form the cycle. For example, when t is zero, the existing graph must contain a cycle of odd length. But the number of ways is not the number of existing cycles, but 1. Because the way to add edges is to add zero edges. So regardless of how many existing cycles there are, the number of ways is 1. Because the way is determined by the set of edges added. Since adding zero edges is only one way. But that contradicts the sample input.\n\nWait, the sample input for the second case is a triangle. The output is 0 1. Which suggests that when the graph already has an odd cycle, the answer is t=0 and w=1. So regardless of how many existing odd cycles there are, the answer is w=1. That seems strange. But why?\n\nAh, perhaps the problem is not about counting the number of existing cycles, but rather about the minimal number of edges to add to create at least one such cycle. So if the graph already contains such a cycle, then the answer is t=0 and w=1, because there's only one way to add zero edges. Because the problem says that two ways are considered the same if they have the same set of added edges. So adding zero edges is only one way. Even though there are multiple existing cycles, the way to add edges is to add none, and that's one way. So the w is 1 in that case.\n\nSo the first thing to check is whether the graph already has an odd-length cycle. If yes, then t=0 and w=1. Otherwise, we need to find the minimal t and count the ways.\n\nSo the problem reduces to:\n\nIf the graph is bipartite, then it doesn't have any odd-length cycles. Otherwise, it does. So first, we need to check if the graph is bipartite. If it's not bipartite, then t=0 and w=1.\n\nWait, but that's not entirely correct. Because the graph may have multiple components, each of which is bipartite. But if the graph is bipartite overall, then there are no odd cycles. So if the graph is bipartite, then we need to add edges to create an odd cycle. Otherwise, t=0.\n\nSo the first step is to check if the graph is bipartite. If it's not bipartite, then answer is t=0, w=1.\n\nBut how to check if the graph is bipartite? For each connected component, perform BFS and check if it's bipartite. If any component is not bipartite, then the entire graph is not bipartite, and thus has an odd cycle.\n\nSo that's the first part. If the graph is not bipartite, then t=0, w=1.\n\nBut what if the graph is bipartite? Then we need to add edges to create an odd cycle.\n\nNow, in a bipartite graph, all cycles are even-length. So adding edges to create an odd cycle.\n\nWhat's the minimal number of edges needed to add to create an odd cycle?\n\nLet's think about the bipartition of a connected component. Suppose a component is bipartite, so its vertices can be divided into two sets A and B, with all edges between A and B.\n\nTo create an odd cycle, we need to connect two nodes in the same partition. Because adding an edge between two nodes in the same partition would create a cycle of length (distance between them + 1). If the distance is even, then adding this edge creates an odd-length cycle.\n\nBut how to find the minimal number of edges to add?\n\nLet's think: the minimal t is 1. Because if there's a connected component which is bipartite, then if there exists at least two nodes in the same partition (say, A) that are not connected by an edge, then adding an edge between them would create a cycle. But what's the length of that cycle?\n\nFor example, suppose there's a tree (which is bipartite). Let's say we have a tree with two nodes in partition A. Adding an edge between them would form a cycle of length 2 (but that's not allowed since the graph is undirected and no loops). Wait, no. Wait, the tree is connected. Suppose the tree has two nodes u and v in the same partition. The path between u and v is of even length (since in a bipartite graph, the distance between two nodes in the same partition is even). So adding an edge between u and v would create a cycle of length (even + 1) = odd. So that's an odd cycle. Thus, adding a single edge between two nodes in the same partition of a bipartition of a connected component would create an odd cycle. Hence, the minimal t is 1.\n\nBut in this case, the minimal t is 1. So the problem reduces to: if the graph is bipartite, then t is 1, and w is the number of possible edges that can be added between nodes in the same partition (i.e., the number of pairs of nodes in the same partition across all connected components, but considering that adding such an edge would create an odd cycle).\n\nWait, but for each connected component, if it's bipartite, then the number of possible edges that can be added between two nodes in the same partition is (size of A choose 2) + (size of B choose 2). But adding any such edge would create an odd cycle. However, if the connected component is already a tree (so no existing edges between same partitions), then adding any such edge would create an odd cycle. However, if the component is not a tree, but still bipartite, then adding an edge between two nodes in the same partition may create an odd cycle. But wait, the component is already bipartitioned, and any existing edges are between A and B. So if there is already an edge between two nodes in A, that would create an odd cycle. But since the component is bipartite, that's not possible. So in a bipartitioned component, all existing edges are between A and B. Therefore, any edge that connects two nodes in the same partition is not present. Hence, adding such an edge would create a cycle. And the length of the cycle would be (distance between the two nodes) + 1. Since the distance between two nodes in the same partition is even, the cycle length is odd.\n\nSo, for the entire graph, if the graph is bipartite, then the minimal t is 1. And the number of ways is the sum over all connected components of (a_i choose 2 + b_i choose 2), where a_i and b_i are the sizes of the two partitions of the connected component. But wait, no. Because adding any such edge would create an odd cycle. However, if the graph has multiple connected components, then adding an edge between two nodes in the same partition of a connected component would create an odd cycle. However, adding an edge between two different connected components would not necessarily create an odd cycle. Wait, no. For example, consider two separate bipartite components. Suppose you connect a node from partition A of component 1 to a node from partition A of component 2. Then, the new edge connects two nodes from the same partition (A) of their respective components. But the combined graph would have a cycle? Not sure.\n\nWait, but in this case, the two components are separate. Adding an edge between two nodes in the same partition of their respective components would create a new connected component. Let's see. Suppose component 1 has partitions A1 and B1, and component 2 has partitions A2 and B2. Suppose we connect a node u in A1 to a node v in A2. Now, the new component's bipartition would be (A1 ∪ B2) and (B1 ∪ A2). Because u is in A1, and v is in A2. The edge between them connects A1 and A2. So the new component's bipartition is possible. But since the original components were bipartitioned, adding this edge would not create an odd cycle. Because the new component is still bipartitioned. Hence, adding an edge between two different components would not create an odd cycle. Therefore, the only way to create an odd cycle is to add an edge within a single connected component, between two nodes in the same partition.\n\nThus, the number of ways to add exactly one edge to create an odd cycle is the sum over all connected components of (a_i choose 2 + b_i choose 2), where a_i and b_i are the sizes of the two partitions of that component.\n\nWait, but in this case, each such edge addition creates exactly one odd cycle. However, if there are multiple such edges, each contributes to the count. So the total number of ways is the sum of (a_i choose 2 + b_i choose 2) for all connected components. But why?\n\nBecause adding any of these edges would create an odd cycle. However, if there are multiple edges that could be added, each is a distinct way. For example, if a component has partitions of size 2 and 3, then there are C(2,2) + C(3,2) = 1 + 3 = 4 possible edges to add. Each of these edges would create an odd cycle.\n\nSo in the case where the graph is bipartite, the answer is t=1 and w is the sum over all connected components of (a_i choose 2 + b_i choose 2). But wait, what if the graph has more than one connected component, and each component is bipartite. Then, adding any of these edges would create an odd cycle. So the total number of ways is the sum of (a_i choose 2 + b_i choose 2) for all components.\n\nBut let's look at the sample input.\n\nFirst sample input:\n\n4 4\n\nEdges are 1-2, 1-3, 4-2, 4-3.\n\nSo the graph is:\n\nVertices 1 connected to 2 and 3.\n\nVertices 4 connected to 2 and 3.\n\nSo the graph is connected. Let's check if it's bipartite.\n\nLet me try to color it. Let's start with vertex 1 as color 0. Then 2 and 3 must be color 1. Then, vertex 4 is connected to 2 and 3, which are color 1. So vertex 4 must be color 0. So the partitions are {1,4} and {2,3}. So sizes are 2 and 2. So the number of possible edges is (2 choose 2) + (2 choose 2) = 1 + 1 = 2. Which matches the first sample output of 1 2. So the answer is t=1 and w=2. Which aligns with the sample.\n\nAnother sample is the third input, which is 3 nodes and 0 edges. The graph is three isolated nodes. Each node is a connected component. Each component is bipartite (since it's a single node, trivially bipartitioned as one set with 1 node and the other with 0). For each component, the number of possible edges is (1 choose 2) + (0 choose 2) = 0 + 0 = 0. But since there are three components, the sum is zero? But the sample output is 3 1. Wait, that's conflicting.\n\nWait, the third sample input is 3 0. So the graph is three nodes with no edges. So the answer is t=3 and w=1. How?\n\nWait, according to our previous logic, the graph is bipartite. So the minimal t is 1. But the sample output says 3 1. So clearly, my previous reasoning is wrong. What's wrong here?\n\nAh, here's the mistake. Let's re-examine the problem. The problem says that the cycle must consist of more than one vertex. So the minimal cycle is of length 3 (triangle). So in the case where the graph is three isolated nodes, how can we create an odd cycle?\n\nWe need to add edges. Let's think. To create a cycle of length 3, we need to add three edges (forming a triangle). But that's the only way. Alternatively, perhaps there's a way to add fewer edges?\n\nNo, because with three nodes, you need three edges to form a cycle. So the minimal number of edges to add is 3. Hence, for this case, t is 3 and w is 1 (only one way: add all three edges). But according to our previous logic, since the graph is bipartite, the minimal t should be 1. So there's a contradiction here.\n\nThis suggests that my earlier reasoning was incorrect. So I need to re-examine the problem.\n\nSo what's wrong here? Let's think again. The problem is that when a connected component is a single node (size 1), then the bipartition is (1,0). So the number of possible edges to add within the same partition is (1 choose 2) + (0 choose 2) = 0. So for each such component, adding an edge within the same partition is impossible. Hence, for the third sample input, all three components are single nodes, and the sum of (a_i choose 2 + b_i choose 2) is 0. Hence, according to our previous logic, the graph is bipartite, so the answer would be t=1 and w=0. But that's not the case. The sample output says t=3, w=1.\n\nSo clearly, there's a mistake in the earlier reasoning. What's the error here?\n\nAh! The earlier reasoning assumed that adding an edge between two nodes in the same partition of a connected component would create an odd cycle. However, this is only true if the component is connected and the two nodes are in the same partition. But for a component that is a single node, adding an edge to another node (but that's not in the same component) would not create a cycle. So the previous approach is incorrect.\n\nSo what's the correct way to approach this?\n\nThe problem is that for a connected component that is bipartite, the minimal number of edges to add to create an odd cycle is 1 if the component has at least two nodes. But if the component is a single node, then adding an edge to another node (from another component) would not form a cycle. Hence, for such cases, we need to consider the number of nodes in the graph.\n\nSo, the problem arises when the graph is bipartite, but there are components with only one node. For example, the third sample input has three components, each with one node. So how can we create an odd cycle?\n\nIn that case, we need to connect three nodes into a cycle. Since each node is in its own component, we need to add edges between them. The minimal number of edges to create a cycle is 3 (forming a triangle). Hence, t=3. The number of ways is 1 (only one possible way to add those edges, since all three edges are required). But how to compute this in general?\n\nSo, the problem is that for the case when the graph is bipartite, the minimal t is not always 1. It depends on the structure of the graph. So, when the graph is bipartite, we need to consider two cases:\n\nCase 1: There exists at least one connected component with at least two nodes. Then, adding a single edge between two nodes in the same partition of that component will create an odd cycle. Hence, t=1.\n\nCase 2: All connected components have size 1. Then, the graph is n isolated nodes. To create a cycle, we need to connect them into a cycle. The minimal number of edges is 3 (for a triangle). So t=3. The number of ways is 1 (only one possible way to choose three nodes and connect them into a cycle, but wait, no. Because the number of ways is the number of possible triangles. However, since the graph has no edges, adding three edges to form a triangle would be one way per triangle. But for n=3, there's only one possible triangle. For n>3, the number of ways is C(n,3) multiplied by 1 (since each triangle can be formed by adding the three edges). But in the third sample input, n=3, m=0. So the answer is 3 and 1.\n\nBut how to generalize this?\n\nSo the overall approach would be:\n\nCheck if the graph is bipartite. If not, output t=0 and w=1.\n\nElse:\n\nIf there exists a connected component with at least two nodes, then t=1 and w is the sum over all components of (a_i choose 2 + b_i choose 2).\n\nOtherwise, all components are single-node. Then, we need to add 3 edges to form a cycle. The minimal t is 3. The number of ways is C(n,3) (since choosing any 3 nodes and connecting them in a triangle). However, the problem says that the added edges must form a cycle. So for each such selection of three nodes, there is exactly one way to add the three edges to form a triangle. So the number of ways is C(n,3).\n\nBut wait, the sample input for the third case is n=3, so C(3,3)=1, which matches the sample output of 3 1.\n\nSo how to handle this?\n\nThus, the steps are:\n\nCheck if the graph is bipartite. If not, output t=0 and w=1.\n\nElse:\n\nCheck if there is any connected component with size >= 2. If yes, then t=1 and w is the sum of (a_i choose 2 + b_i choose 2) for all components.\n\nElse (all components are single nodes):\n\nt is 3 if n >=3. But if n <3, then it's impossible. But according to the problem statement, the graph must have more than one vertex in the cycle. So for n=1, it's impossible. But the input constraints say that n can be 1? Let's check the input constraints.\n\nThe input says that n can be as small as 1? Well, the problem says that the graph can be not connected. But the problem requires that the cycle has more than one vertex. So, for example, if n=1, then it's impossible. But the input for the third sample is n=3, m=0.\n\nBut according to the problem statement, the input is such that the graph is given. So, in code, we need to handle cases where n is 1, but the problem says that the answer must have a cycle with more than one vertex. So, for example, if n=1, then it's impossible. But the problem says that the input is such that it's possible to form a cycle. However, the problem says that the input can be any graph. So, perhaps the code needs to handle these cases.\n\nBut according to the problem statement, the output must be t and w. So, for example, if the graph is n=1, m=0. Then, since there's no way to form a cycle (needs at least two vertices), but the problem says that the graph can be modified. But adding edges to form a cycle requires at least two vertices. So, if n=1, then the answer is impossible. However, the problem says that the input is given and the code must output something. But according to the problem's sample input, for n=3, m=0, the answer is 3 1.\n\nSo, for the case where all components are single nodes (i.e., n >=1, but each component is size 1), then:\n\nif n < 3: it's impossible. But since the problem requires that the answer exists, perhaps the input will not have such cases. Or perhaps the code must handle it.\n\nBut let's proceed.\n\nSo, in the case where all components are single nodes (each component is size 1):\n\nIf n < 3: then you can't form a cycle. But according to the problem statement, the input is valid. However, the problem says that the graph may not be connected. But in the problem statement, the sample input includes n=3, m=0. So, for n=3, the minimal t is 3, and w is 1. For n=2, m=0, then you need to add 2 edges (connecting the two nodes with two edges?), but that would create a loop. But the problem says that you cannot add loops or parallel edges. So for n=2, you can't form a cycle. Because the minimal cycle is of length 3. Hence, you need to add 3 edges. But with n=2, you can't form a cycle. So the answer would be impossible. However, according to the problem statement, the code must output something. So perhaps the input ensures that n >=3 in such cases. Or perhaps the code must handle it.\n\nBut given that the sample input includes n=3, let's proceed under the assumption that in this case, the code needs to compute t=3 and w= C(n,3) if n >=3, else t is something else (but perhaps the problem ensures that n is >=3 in such cases).\n\nSo, putting it all together:\n\nThe algorithm is:\n\nCheck if the graph has an odd-length cycle. If yes, output t=0 and w=1.\n\nElse:\n\nIf there exists at least one connected component with size >= 2:\n\nt = 1\n\nw = sum over all connected components ( (a_i choose 2) + (b_i choose 2) )\n\nElse:\n\nif n < 3:\n\nthen, it's impossible. But according to the problem, perhaps the input will not have such cases. However, for the code, we need to handle it. But the problem says that the answer must be possible. So for example, for n=2, m=0, the answer would be t=3 (but impossible to form a cycle). But this case is not possible as per the problem's constraints?\n\nAlternatively, the code can assume that when all components are single nodes, then n >= 3. But how to handle that?\n\nBut for the code, perhaps we can proceed as follows:\n\nIn the case where all components are single nodes (i.e., n_components = n, each with size 1):\n\nt = 3 if n >= 3, else impossible (but for the code, perhaps we can assume that n >=3 in this case).\n\nw = C(n,3) if n >=3.\n\nBut in the sample input for the third case, n=3, so C(3,3) = 1, which matches the sample.\n\nSo, how to implement this.\n\nNow, the main steps are:\n\n1. Check if the graph is bipartite. If not, output 0 1.\n\nElse:\n\n2. Check if there is at least one connected component with size >=2.\n\n   a. If yes: compute the sum of (a_i choose 2 + b_i choose 2) for each component.\n\n   b. Else: if n >=3, t=3, w=C(n,3). Else, ?\n\nBut how to check if the graph is bipartite.\n\nSo, the code needs to:\n\nFor each connected component, check if it is bipartite. If any component is not bipartite, then the entire graph is not bipartite.\n\nOnce we know the graph is bipartite, then proceed to check the other conditions.\n\nNow, for the code:\n\nImplement Bipartition checking for each connected component.\n\nSo, for each connected component, perform BFS and assign colors. If during BFS, a conflict is found (a node is found with a neighbor having the same color), then the graph is not bipartite.\n\nOnce we have all components, for each component, we can track the size of the two partitions (a_i and b_i).\n\nNow, for the case where the graph is bipartite:\n\nCheck if any component has size >=2.\n\nIf yes:\n\nt = 1\n\nw = sum over all components (a_i * (a_i -1) // 2 + b_i * (b_i -1) // 2 )\n\nElse:\n\nif n >=3:\n\nt = 3\n\nw = n * (n-1) * (n-2) // 6\n\nelse:\n\nt = ... ?\n\nBut for the problem's sample input, the third case is handled correctly.\n\nNow, let's test this approach with the third sample input:\n\nSample input 3 is 3 0. The graph is three isolated nodes. So, each component is size 1. Thus, the code proceeds to the else case. Since n=3 >=3, t=3, w=1. Which matches the sample.\n\nAnother example: n=2, m=0. The graph is two components of size 1. Then, since n=2 <3, the code would have to output something. But in reality, it's impossible to form a cycle. However, the problem may not have such cases. But perhaps the code can assume that the input is valid and that when the graph is bipartite and all components are size 1, then n >=3.\n\nBut in code, we need to handle it. However, the problem says that the answer must exist. So perhaps the code can assume that n >=3 in this case.\n\nNow, let's think about the first sample input. The graph is connected and bipartitioned into {1,4} and {2,3}. The sum is (2C2 + 2C2) = 1+1=2. So t=1, w=2. Which matches the sample.\n\nSecond sample input: 3 nodes connected in a triangle. The graph is not bipartite (since the triangle is an odd cycle). So output is 0 1. Which matches the sample.\n\nAnother example: n=4, m=0. All four nodes are isolated. So, the code checks that the graph is bipartite (each component is a single node). Then, since all components are size 1, and n=4 >=3, t=3 and w=4 choose 3 =4. So the answer would be 3 4.\n\nAnother example: a graph with two components. One is a single node, another is a bipartitioned component of size 2 and 2. Then, the code would check that there is a component with size >=2. So t=1 and w is (2C2 + 2C2) =1+1=2. So adding any of those edges would create an odd cycle.\n\nNow, how to implement this in code.\n\nImplementing Bipartition check:\n\nWe can represent the graph as adjacency lists. For each connected component, perform BFS and assign colors. If during BFS, a conflict is found, the graph is not bipartite.\n\nOnce the Bipartition check is done, for each component, store the sizes of the two partitions (a_i and b_i).\n\nNow, code steps:\n\nRead n and m.\n\nBuild adjacency list.\n\nCheck if the graph is bipartite.\n\nIf not bipartite: output 0 1.\n\nElse:\n\nCheck if there exists any component with size >=2.\n\nHow to check this? For each component, check if the sum of a_i + b_i (the size of the component) is >=2. If any component has size >=2, then yes.\n\nIf yes:\n\nCompute the sum of (a_i choose 2 + b_i choose 2) for all components. That is the w.\n\nt is 1.\n\nElse:\n\nif n >=3:\n\nt=3, w = C(n,3)\n\nelse:\n\nt=... ?\n\nBut for n<3, how to handle?\n\nBut according to the problem statement, the answer must exist. So perhaps the code can assume that in this case, n is >=3. So proceed with that.\n\nNow, code:\n\nImplement Bipartition check.\n\nNow, code in Python:\n\nBut first, handling multiple connected components.\n\nImplement BFS for each unvisited node.\n\nNow, code:\n\nWe can represent colors as a list, where each element is -1 (unvisited), 0 or 1.\n\nInitialize colors as [-1] * (n+1) (assuming nodes are 1-based).\n\nThen, for each node from 1 to n:\n\nif not visited (color is -1), perform BFS.\n\nDuring BFS, assign colors.\n\nIf during BFS, a conflict is found, the graph is not bipartite.\n\nOnce all components are checked, if the graph is bipartite, proceed.\n\nThen, for each component, collect the sizes of the two partitions.\n\nSo, during BFS, for each component, we can track the count of 0 and 1 colors.\n\nOnce we have all components' a_i and b_i, then proceed.\n\nNow, code:\n\nImplement Bipartition check and collect component data.\n\nOnce that is done, check if any component has size >=2 (i.e., a_i + b_i >=2).\n\nIf yes:\n\nsum_w = sum( (a_i * (a_i -1) // 2) + (b_i * (b_i -1) // 2) for all components )\n\nt = 1\n\nw = sum_w\n\nElse:\n\nif n >=3:\n\nt = 3\n\nw = n * (n-1) * (n-2) // 6\n\nelse:\n\nt = ... ?\n\nBut let's proceed.\n\nNow, code:\n\nNow, code for the case when the graph is bipartite.\n\nNow, for example, when all components are size 1 (each node is its own component), then for each component, a_i is 1 and b_i is 0. So (a_i choose 2) is 0, (b_i choose 2) is 0. So sum_w is 0. Hence, in this case, the code proceeds to the else part.\n\nThus, the code can proceed as follows.\n\nNow, implement this.\n\nNow, code:\n\nRead n and m.\n\nadj = [[] for _ in range(n+1)]\n\nfor _ in range(m):\n\n    u, v = map(int, input().split())\n\n    adj[u].append(v)\n\n    adj[v].append(u)\n\ncolors = [-1] * (n+1)\n\nis_bipartite = True\n\ncomponents = []  # list of tuples (a, b) for each component\n\nfor u in range(1, n+1):\n\n    if colors[u] == -1:\n\n        # BFS\n\n        queue = deque()\n\n        queue.append(u)\n\n        colors[u] = 0\n\n        a = 0\n\n        b = 0\n\n        a += 1\n\n        while queue:\n\n            current = queue.popleft()\n\n            for neighbor in adj[current]:\n\n                if colors[neighbor] == -1:\n\n                    colors[neighbor] = 1 - colors[current]\n\n                    if colors[neighbor] == 0:\n\n                        a += 1\n\n                    else:\n\n                        b += 1\n\n                    queue.append(neighbor)\n\n                else:\n\n                    if colors[neighbor] == colors[current]:\n\n                        is_bipartite = False\n\n        # After BFS, add the counts for this component.\n\n        # Wait, initial code for a and b is wrong.\n\n        # Because for the starting node u, which is colored 0, we have a starts at 1, but during BFS, the code increments a and b based on the color of neighbor. But this is incorrect.\n\n        # Let me think again.\n\n        # When initializing for a component:\n\n        # For the first node u, color is 0. So, the count for 0 is 1, and 1 is 0.\n\n        # Then, during BFS, for each neighbor, when colored, we check their color and increment a or b accordingly.\n\n        # So, the code for tracking a and b should be:\n\n        # Initialize a and b as 0.\n\n        # Then, for the starting node, color is 0. So a +=1.\n\n        # Then, for each node processed, we check their color and increment a or b.\n\n        # So during BFS, the code should track the count of 0 and 1 colors.\n\n        # So, let's correct the code:\n\n        # For each component:\n\n        # When starting BFS, the initial node is colored 0.\n\n        # So, a and b are initialized to 0 and 0.\n\n        # Then, a +=1 (for the initial node).\n\n        # Then, during BFS processing, for each node, we check its color and increment a or b.\n\n        # So, the code inside the BFS loop should be:\n\n        # Wait, the code above for the BFS is wrong. Because the code for a and b is not properly tracked.\n\n        # Let me redo the code for processing the component.\n\n        # So, for each component, during BFS, we need to count how many nodes are in color 0 and color 1.\n\n        # So, during the BFS, for each node, when we assign a color, we can increment the respective count.\n\n        # Let me rewrite the code.\n\n        # Let me adjust the code:\n\n        # Initialize a and b for the component.\n\n        a = 0\n\n        b = 0\n\n        queue = deque([u])\n\n        colors[u] = 0\n\n        a += 1\n\n        while queue:\n\n            current = queue.popleft()\n\n            for neighbor in adj[current]:\n\n                if colors[neighbor] == -1:\n\n                    colors[neighbor] = 1 - colors[current]\n\n                    if colors[neighbor] == 0:\n\n                        a +=1\n\n                    else:\n\n                        b +=1\n\n                    queue.append(neighbor)\n\n                else:\n\n                    if colors[neighbor] == colors[current]:\n\n                        is_bipartite = False\n\n        # After processing the component, add (a, b) to components.\n\n        components.append( (a, b) )\n\nWait, but this code would miss the count of the current node's color. For example, when the initial node is colored 0, a is incremented by 1. Then, during processing of its neighbors, their colors are assigned and a or b is incremented accordingly. But during the BFS, the current node's color is already known, but the code doesn't count it again. Wait, no. Because the current node is processed, but the code only counts when the neighbor is colored. However, the initial node is counted once. For example, the initial node is u, colored 0, and a is 1. Then, during BFS, when processing current node, the code processes its neighbors. For each neighbor",
    "response": "To solve this problem, we need to determine the minimum number of edges to add to an undirected graph to form a simple cycle of odd length and the number of ways to achieve this. The solution involves checking if the graph is bipartite and then determining the necessary edges based on the structure of the graph.\n\n### Approach\n1. **Check for Bipartiteness**: A graph that contains an odd-length cycle is not bipartite. If the graph is not bipartite, it already contains an odd-length cycle, so no edges need to be added.\n2. **Component Analysis**: If the graph is bipartite, analyze each connected component:\n   - If any component has at least two nodes, we can add one edge within the same partition to create an odd-length cycle.\n   - If all components are single nodes, we need to form a triangle (3 nodes) by adding three edges.\n\n### Solution Code\n```python\nimport sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n    \n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u = int(input[idx])\n        idx += 1\n        v = int(input[idx])\n        idx += 1\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    colors = [-1] * (n + 1)\n    is_bipartite = True\n    components = []\n    \n    for u in range(1, n + 1):\n        if colors[u] == -1:\n            queue = deque()\n            queue.append(u)\n            colors[u] = 0\n            a = 1\n            b = 0\n            while queue:\n                current = queue.popleft()\n                for neighbor in adj[current]:\n                    if colors[neighbor] == -1:\n                        colors[neighbor] = 1 - colors[current]\n                        if colors[neighbor] == 0:\n                            a += 1\n                        else:\n                            b += 1\n                        queue.append(neighbor)\n                    else:\n                        if colors[neighbor] == colors[current]:\n                            is_bipartite = False\n            components.append((a, b))\n    \n    if not is_bipartite:\n        print(\"0 1\")\n        return\n    \n    has_large_component = False\n    for a, b in components:\n        if a + b >= 2:\n            has_large_component = True\n            break\n    \n    if has_large_component:\n        total_ways = 0\n        for a, b in components:\n            total_ways += (a * (a - 1)) // 2 + (b * (b - 1)) // 2\n        print(f\"1 {total_ways}\")\n    else:\n        if n >= 3:\n            w = n * (n - 1) * (n - 2) // 6\n            print(f\"3 {w}\")\n        else:\n            print(\"0 0\")  # This case should not occur as per problem constraints\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Bipartite Check**: The graph is checked for bipartiteness using BFS. If any conflict is found during BFS, the graph is not bipartite, indicating an existing odd-length cycle.\n2. **Component Analysis**: For each connected component, we track the sizes of the two partitions (colors). If any component has at least two nodes, the minimum edges needed is 1, calculated by summing possible intra-partition edges.\n3. **Single Node Components**: If all components are single nodes, forming a triangle requires adding 3 edges, with the number of ways calculated using combinations.\n\nThis approach efficiently determines the minimum edges and ways to form an odd-length cycle, leveraging graph properties and combinatorial calculations.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n    \n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u = int(input[idx])\n        idx += 1\n        v = int(input[idx])\n        idx += 1\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    colors = [-1] * (n + 1)\n    is_bipartite = True\n    components = []\n    \n    for u in range(1, n + 1):\n        if colors[u] == -1:\n            queue = deque()\n            queue.append(u)\n            colors[u] = 0\n            a = 1\n            b = 0\n            while queue:\n                current = queue.popleft()\n                for neighbor in adj[current]:\n                    if colors[neighbor] == -1:\n                        colors[neighbor] = 1 - colors[current]\n                        if colors[neighbor] == 0:\n                            a += 1\n                        else:\n                            b += 1\n                        queue.append(neighbor)\n                    else:\n                        if colors[neighbor] == colors[current]:\n                            is_bipartite = False\n            components.append((a, b))\n    \n    if not is_bipartite:\n        print(\"0 1\")\n        return\n    \n    has_large_component = False\n    for a, b in components:\n        if a + b >= 2:\n            has_large_component = True\n            break\n    \n    if has_large_component:\n        total_ways = 0\n        for a, b in components:\n            total_ways += (a * (a - 1)) // 2 + (b * (b - 1)) // 2\n        print(f\"1 {total_ways}\")\n    else:\n        if n >= 3:\n            w = n * (n - 1) * (n - 2) // 6\n            print(f\"3 {w}\")\n        else:\n            print(\"0 0\")  # This case should not occur as per problem constraints\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 579,
        "completion_token_count": 831,
        "thoughts_token_count": 8192
    }
}