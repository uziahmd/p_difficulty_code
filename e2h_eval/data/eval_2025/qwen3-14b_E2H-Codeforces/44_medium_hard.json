{
    "start": 1758338780.1207585,
    "end": 1758339052.4086726,
    "start-formatted": "2025-09-20 12:26 KST",
    "end-formatted": "2025-09-20 12:30 KST",
    "gpu": 2,
    "pid": 44,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Polycarp's Practice\n\nPolycarp is practicing his problem solving skill. He has a list of $$$n$$$ problems with difficulties $$$a_1, a_2, \\dots, a_n$$$, respectively. His plan is to practice for exactly $$$k$$$ days. Each day he has to solve at least one problem from his list. Polycarp solves the problems in the order they are given in his list, he cannot skip any problem from his list. He has to solve all $$$n$$$ problems in exactly $$$k$$$ days.Thus, each day Polycarp solves a contiguous sequence of (consecutive) problems from the start of the list. He can't skip problems or solve them multiple times. As a result, in $$$k$$$ days he will solve all the $$$n$$$ problems.The profit of the $$$j$$$-th day of Polycarp's practice is the maximum among all the difficulties of problems Polycarp solves during the $$$j$$$-th day (i.e. if he solves problems with indices from $$$l$$$ to $$$r$$$ during a day, then the profit of the day is $$$\\max\\limits_{l \\le i \\le r}a_i$$$). The total profit of his practice is the sum of the profits over all $$$k$$$ days of his practice.You want to help Polycarp to get the maximum possible total profit over all valid ways to solve problems. Your task is to distribute all $$$n$$$ problems between $$$k$$$ days satisfying the conditions above in such a way, that the total profit is maximum.For example, if $$$n = 8, k = 3$$$ and $$$a = [5, 4, 2, 6, 5, 1, 9, 2]$$$, one of the possible distributions with maximum total profit is: $$$[5, 4, 2], [6, 5], [1, 9, 2]$$$. Here the total profit equals $$$5 + 6 + 9 = 20$$$.\n\n## Input\nThe first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\le k \\le n \\le 2000$$$) — the number of problems and the number of days, respectively.The second line of the input contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le 2000$$$) — difficulties of problems in Polycarp's list, in the order they are placed in the list (i.e. in the order Polycarp will solve them).\n\n## Output\nIn the first line of the output print the maximum possible total profit.In the second line print exactly $$$k$$$ positive integers $$$t_1, t_2, \\dots, t_k$$$ ($$$t_1 + t_2 + \\dots + t_k$$$ must equal $$$n$$$), where $$$t_j$$$ means the number of problems Polycarp will solve during the $$$j$$$-th day in order to achieve the maximum possible total profit of his practice.If there are many possible answers, you may print any of them.\n\n## Example\n### Input\n['8 3\\n5 4 2 6 5 1 9 2', '5 1\\n1 1 1 1 1', '4 2\\n1 2000 2000 2']\n\n### Output\n['20\\n3 2 3', '1\\n5', '4000\\n2 2']\n\n## Note\nThe first example is described in the problem statement.In the second example there is only one possible distribution.In the third example the best answer is to distribute problems in the following way: $$$[1, 2000], [2000, 2]$$$. The total profit of this distribution is $$$2000 + 2000 = 4000$$$.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\nOkay, let's try to figure out how to solve this problem. The task is to split the array of n problems into exactly k days, each day solving consecutive problems starting from the beginning. Each day's profit is the max of the problems solved that day, and we need to maximize the total profit.\n\nHmm. So the key is to find the optimal way to split the array into k segments such that the sum of the maximums of each segment is as large as possible.\n\nFirst, I need to think about dynamic programming here. Because for each position and number of days, there might be some optimal substructure.\n\nLet me think about the DP approach. Let's define dp[i][j] as the maximum total profit for the first i problems divided into j days. Then, the answer would be dp[n][k].\n\nBut how do we transition between states? For dp[i][j], we need to consider all possible positions m where the j-th day starts. Wait, no. For the j-th day, the last segment could be from m+1 to i, where m is the end of the previous j-1 days. So for each i and j, we can look back to m from j-1 to i-1, and then take dp[m][j-1] + max(a[m+1..i]).\n\nBut for n up to 2000 and k up to 2000, this approach would be O(n^2 *k) time. Let's check the complexity. For each i (up to 2000), j (up to 2000), and for each m (up to i), that's O(2000^3) which is 8e10 operations. That's way too slow. So this approach isn't feasible for n=2000.\n\nWait, but maybe there's a way to optimize this. Let's think. For each j, when we compute dp[i][j], we need to find for all possible m < i, the value dp[m][j-1] + max(a[m+1..i]). But computing the max for each m and i is O(n) per step, which makes it O(n^3) overall. Which is definitely not feasible for n=2000.\n\nSo we need a better way. Let's think about the constraints again. Since the splits are contiguous and must start from the beginning, maybe there's a way to precompute the max values for ranges.\n\nAlternatively, perhaps we can find that for each j, when building the dp[i][j], we can find the best m for each i in a more efficient way.\n\nAnother thought: since the splits are contiguous, for the j-th day, the split must be after some m, so that the j-th day is from m+1 to i. So for each j, when considering dp[i][j], we can find the best m in [j-1, i-1] (since each day must have at least one problem, so for j days, the first j-1 days must cover at least j-1 problems, so m can't be less than j-1 - 1? Or maybe m needs to be at least j-1? Let me think. For example, for j days, the first j-1 days must have at least j-1 problems. So for the i-th problem, when considering splitting into j days, the previous j-1 days must have m problems, where m >= j-1. So m can range from j-1 to i-1, because the j-th day must have at least 1 problem (so i - m >= 1 => m <= i-1).\n\nSo for dp[i][j], the recurrence is:\n\ndp[i][j] = max{ dp[m][j-1] + max(a[m+1..i]) }, for m from j-1 to i-1.\n\nBut again, calculating the max for each m and i is expensive. How can we compute this efficiently?\n\nWe can precompute the maximums for ranges. For example, for any interval [l, r], we can have a 2D array max_range[l][r] which holds the maximum value between l and r. This can be precomputed with O(n^2) time and space. For n=2000, that's 4 million entries, which is manageable.\n\nOnce we have this precomputed, then for each m and i, we can get the max in O(1) time. But even with that, the DP transitions would take O(n^2 *k) time. Let's see:\n\nn is 2000, k is 2000. Then O(n^2 *k) would be 2000^3 = 8e10 operations. That's way too slow. So this approach is not feasible.\n\nSo we need to find a smarter way. Let's think again about the problem.\n\nWhat if k is small? Well, in the worst case, k can be up to n. So that doesn't help.\n\nAlternative approach: since each day must consist of consecutive problems, and the splits are from the start, maybe the optimal way is to split the array into k parts where each part's maximum is as large as possible.\n\nBut how to balance that? For example, if there are several large elements, we want to have each of them in separate days. But if there are only a few large elements, we need to split the rest in a way that their max is not too small.\n\nWait, but the problem requires that all the problems are split into exactly k days. So, for example, if k is 1, the answer is the max of the entire array. If k is n, then each day has one problem, so the sum is the sum of all elements.\n\nBut for general cases, how can we model this?\n\nLet me think about the case where k is 2. We need to split the array into two parts. The first part is from 1 to m, and the second from m+1 to n. The total profit is max(a[1..m]) + max(a[m+1..n]). To maximize this, we need to find the m that gives the maximum sum of these two maxima. How can we find this m? Well, for each possible m, compute the two maxima and sum them. But for larger k, this approach isn't directly applicable.\n\nBut maybe there's a way to find that for each j and i, the optimal m is somewhere in a certain range, and we can find it with some optimizations.\n\nAnother idea: For each j, the dp[i][j] can be computed using some properties that allow us to find the optimal m quickly. For example, for a fixed j, when we increase i, can we find a way to compute the max for the current i efficiently?\n\nLet me think. For a fixed j, when we compute dp[i][j], we need to look for m from j-1 to i-1, and for each m, compute dp[m][j-1] + max(a[m+1..i]).\n\nNow, for each i, the max(a[m+1..i]) is the maximum of the subarray from m+1 to i. As m decreases (from i-1 down to j-1), the interval [m+1, i] becomes larger. But how can we track this maximum?\n\nAlternatively, for each i and j, when considering m varying from j-1 to i-1, we can note that the max(a[m+1..i]) increases as m decreases. Because adding elements to the left (as m decreases) can only increase or keep the same maximum. However, the dp[m][j-1] term may vary in any way. So the combination of these two terms is not straightforward.\n\nWait, but maybe for each i and j, the optimal m is somewhere near the position of the maximum element in the current segment. For example, if there's a very large element in the current segment, we might want to split before it, so that it's the max of its own day.\n\nBut I'm not sure how to use this.\n\nLet me think again about the DP approach. Let's see what the constraints are. For n=2000 and k=2000, the DP approach with O(n^2 *k) is impossible. However, for k up to 2000 and n up to 2000, maybe we can find that for each j, the computation for dp[i][j] can be optimized.\n\nWait, but when j is up to n, and for each i >= j (since you can't split into j days if i < j), then for j=1, it's easy: dp[i][1] = max(a[1..i]).\n\nFor j=2, dp[i][2] = max over m from 1 to i-1 of (max(a[1..m]) + max(a[m+1..i])).\n\nBut for j=2, how can we compute this efficiently? For each i, we can precompute the max from 1 to m and from m+1 to i. But even then, for each i, checking all m from 1 to i-1 is O(n^2) for j=2. But for all j up to n, this would be O(n^3) again.\n\nSo, perhaps we need to find another way. Let me think about the problem differently.\n\nAnother observation: since the splits are contiguous and must start from the beginning, the problem is similar to partitioning the array into k segments, and for each segment, take the max. The goal is to maximize the sum of these maxes.\n\nThis seems similar to some classic DP problems. For example, the problem of splitting an array into k parts to maximize the sum of some function of each part.\n\nBut how to compute that efficiently.\n\nLet me think about the DP transitions again. Suppose we have a DP table where dp[i][j] represents the maximum total profit for the first i elements divided into j days.\n\nThen, for dp[i][j], we can look for all possible m in [j-1, i-1], and take dp[m][j-1] + max(a[m+1..i]).\n\nThe problem is the max part. How to compute this efficiently.\n\nAn alternative idea is to precompute for each i and j, the max from m+1 to i. But again, that's O(n^2) space.\n\nBut for each i and j, when considering m from j-1 to i-1, perhaps we can find the maximum in O(1) time by maintaining some data structure.\n\nWait, but for a fixed i, as m decreases (from i-1 to j-1), the interval [m+1, i] expands to the left. So, for each i, the max for [m+1, i] can be maintained incrementally. For example, for m = i-1, the interval is [i, i], which is a[i]. For m = i-2, the interval is [i-1, i], whose max is max(a[i-1], a[i]). And so on. So for each i, as we decrease m from i-1 to j-1, we can keep track of the current max. So for each i and j, we can iterate m from i-1 down to j-1, and compute the max as we go.\n\nThis way, for each i and j, the inner loop (for m) can compute the max in O(1) per step, leading to O(n^2 *k) time overall.\n\nLet me see. For each i and j, the inner loop runs for O(i) steps. So the total time would be O(n^2 *k). For n=2000 and k=2000, this is 2000^3 = 8e10 operations. Which is way too big. So that's not feasible.\n\nBut wait, what is the actual constraint? Let me check the problem statement again. Oh, n and k are up to 2000. So for n=2000, O(n^3) is 8e10 operations. Even with fast code, this is way beyond the time limit. So this approach is not going to work.\n\nWe need a smarter way. Let me think again.\n\nAlternative idea: since each day's profit is the maximum of the segment, and we want to maximize the sum. So, the optimal way is to have as many high-value elements as possible as individual segments. For example, if there are k elements that are higher than all others, then each of them can be in their own day, and the sum would be the sum of those elements. But if there are fewer than k such elements, then we need to split some of the other elements into segments that include those high elements.\n\nBut how to model this? It's not obvious.\n\nAnother observation: For any split into k segments, the sum of the maxima is equal to the sum of the maximums of each segment. Since each segment is a consecutive block, and the segments are non-overlapping and cover the entire array.\n\nSo, for example, if we have a segment that contains a certain maximum, then that maximum contributes to the sum. But if we can split the array in such a way that each of the top k elements is in their own segment, then that would be optimal. However, if there are less than k such elements, then we have to combine some of them.\n\nBut how can we find this?\n\nAlternatively, think about the problem as selecting k-1 split points. For example, in the array, we need to choose k-1 split points such that the sum of the maxima of each segment is maximized.\n\nBut how to find those splits?\n\nLet me think of the problem as follows: For each possible split into k segments, the sum is the sum of the maximums. To maximize this sum, we need to have as many large maxima as possible.\n\nBut how to find those splits?\n\nAnother thought: The maximum sum is achieved when each of the k segments has their maximum as large as possible. However, since the segments are consecutive, the maxima are interdependent.\n\nFor example, suppose there's a peak element in the array. To maximize the sum, we should split the array so that this peak is in its own segment. Then, the segments before and after can be split optimally.\n\nThis suggests that the problem can be approached greedily. But greedy approaches are often tricky. For example, choosing the largest element and splitting around it, then proceeding recursively. However, this might not lead to the optimal solution.\n\nLet me take the example given:\n\nn=8, k=3, a = [5,4,2,6,5,1,9,2]\n\nThe maximum elements are 9, 6, 5, etc. The optimal split is [5,4,2], [6,5], [1,9,2]. The maxima are 5,6,9. Sum 20.\n\nIf we take the largest element (9) and make it a segment, then split the remaining into two segments. The remaining array is [5,4,2,6,5,1,2]. Split into two segments. How? The next largest elements are 6 and 5. So maybe split into [5,4,2,6,5,1] and [2]. But that would give maxima 6 and 2, sum 6+9+2=17, which is worse than the example's 20. So the greedy approach of taking the largest element first may not work.\n\nSo greedy approaches may not be reliable here.\n\nBack to DP. Let's think again. Maybe the constraints are manageable with some optimizations.\n\nLet me calculate the time for the DP approach with the incremental max calculation.\n\nAssume that for each i and j, the inner loop (m) takes O(i) steps, but for each i and j, the inner loop is O(i) steps. But for j up to k and i up to n.\n\nThe total number of operations is sum_{j=1}^k sum_{i=j}^n (i - (j-1)) ). \n\nBut for j=1, it's sum_{i=1}^n (i) = O(n^2). For j=2, sum_{i=2}^n (i-1) = O(n^2). And so on up to j=k. So total time is O(k * n^2). For n=2000 and k=2000, this is O(2000^3) which is 8e10 operations. That's way too slow.\n\nBut perhaps there's a way to reduce the time complexity. Let's think of the following:\n\nThe maximum value of k is n. But for j > n/2, the splits are forced. For example, when j = n, each day has exactly one problem. So for j >= some value, the DP can be filled quickly. However, for general cases, this may not help much.\n\nAlternative approach: Let's think about the problem in terms of the maximums. For each possible split into k segments, the sum is the sum of the maximums. The key is that for each segment, the maximum is the maximum in that segment. So, if we can find a way to select k segments where each segment's maximum is as large as possible, then that's the way to go.\n\nBut how to model this?\n\nAnother idea: Let's consider that for the first j days, the maximum of the first i elements is determined by the way we split. However, I don't see a clear way to model this.\n\nWait, but maybe for each j, the DP[i][j] can be computed using some monotonic queue or other optimization. For example, if we can find that for certain ranges of m, the optimal choice is to take the maximum in a certain way.\n\nAlternatively, think of the problem for fixed j. For example, j is fixed as 2. How to compute dp[i][2] for all i?\n\nFor each i, dp[i][2] = max over m in [1, i-1] of (dp[m][1] + max(a[m+1..i])).\n\nBut dp[m][1] is simply the maximum of the first m elements. Let's call this prefix_max[m]. So for j=2, the problem becomes for each i, find the m in [1, i-1] that maximizes (prefix_max[m] + max(a[m+1..i])).\n\nHow to compute this efficiently for all i?\n\nFor each i, we can consider that the max(a[m+1..i]) is the maximum between a[m+1] and ... a[i]. For a fixed i, as m increases from 1 to i-1, the interval [m+1, i] becomes smaller. The max decreases or stays the same as m increases.\n\nBut combining this with prefix_max[m], which increases as m increases (since prefix_max[m] is the maximum of the first m elements, which is non-decreasing as m increases). So for each i, we need to find the m that balances the trade-off between the increasing prefix_max[m] and the decreasing max(a[m+1..i]).\n\nBut how to find this m quickly?\n\nThis seems like a problem that could be solved with a convex hull trick or some other optimization, but I'm not sure. Alternatively, for each i, we can iterate m from 1 to i-1 and compute the value, but that would be O(n^2) for j=2. Which for j up to k would be O(n^3) again.\n\nSo, this approach isn't helping.\n\nAlternative idea: What if we realize that for the optimal split, each segment's maximum is one of the elements in the array. So, perhaps for each possible split into k segments, the sum is the sum of the maxima, and each of these maxima is a certain element in the array. But again, not sure how to use this.\n\nLet me think of the problem in terms of the number of segments. Suppose that we have k segments. The maximum of each segment is one of the elements in the array. So, for each element a[i], if it is the maximum of its segment, then that contributes a[i] to the total. To maximize the total, we want as many high elements as possible to be the maxima of their respective segments.\n\nBut how to ensure that?\n\nFor example, if there are k elements that are larger than all other elements, then each of them can be the max of their own segment, and the total is the sum of these elements. If there are fewer than k elements, then some of the segments will have their maxima as elements that are not among the top k elements.\n\nSo, perhaps the problem can be reduced to selecting k elements, each as the maximum of their segments, and ensuring that they are placed in such a way that the segments are contiguous.\n\nBut how to find this selection?\n\nThis feels similar to the problem of selecting k elements to maximize their sum, with the condition that each selected element is the maximum in its segment and the segments are non-overlapping and cover the entire array.\n\nBut how to model this?\n\nMaybe the following approach: the optimal solution will include the k largest elements in the array. However, this is not always true. For example, if the array is [5, 4, 6, 3, 7], and k=2. The two largest elements are 7 and 6. If we split into [5,4,6] and [3,7], the sum is 6 +7=13. Alternatively, if we split into [5,4], [6,3,7], the sum is 5 +7=12. Or [5,4,6,3], [7], sum is 6 +7=13. So the optimal is 13. Which includes both 6 and 7. So in this case, the two largest elements are included.\n\nAnother example: array [5, 1, 5], k=2. The two largest elements are 5 and 5. Splitting into [5], [1,5] gives sum 5+5=10. Splitting into [5,1], [5] gives sum 5+5=10. Either way, it's optimal. So including the two largest elements.\n\nAnother example: array [3, 1, 2, 4], k=2. The two largest elements are 4 and 3. If we split into [3,1,2], [4], sum is 3+4=7. Or [3,1], [2,4], sum is 3+4=7. Or [3], [1,2,4], sum 3+4=7. Alternatively, if we split into [3,1,2,4] (but that's only one day). Not allowed. So the maximum sum is 7, which is the sum of the two largest elements. So yes, including the two largest elements.\n\nSo perhaps the optimal strategy is to select the k largest elements and split the array such that each of them is in its own segment. But how to do this?\n\nBut what if there are multiple elements with the same value? Or if the elements are not positioned in a way that allows them to be in separate segments?\n\nFor example, array [5, 5, 5], k=2. The optimal split is [5,5], [5], sum is 5+5=10. Or [5], [5,5], sum is 5+5=10. Or [5], [5], [5] is not allowed since k=2. So the sum is 10, which is the sum of two 5's. So even though there are three 5's, the sum is two of them.\n\nSo the idea is to select the top k elements and ensure that each is in a separate segment. But how to do that when they are not positioned in a way that allows it?\n\nBut how to handle that in the code?\n\nThis suggests that the optimal total profit is the sum of the k largest elements in the array. But this is not necessarily true. Let me think of a counterexample.\n\nTake array [5, 4, 6, 3, 7], k=3. The top 3 elements are 7, 6, 5. If we can split into three segments containing each of them, the sum would be 7+6+5=18. Is that possible? Let's see:\n\nSplit into [5], [4,6], [3,7]. Sum is 5+6+7=18. Yes.\n\nAnother possibility: [5,4,6,3], [7], and [ ]? No, because all must be covered. So the split must be into three segments. For example, [5,4], [6,3], [7]. Sum is 5+6+7=18. Yes.\n\nBut what if the array is [1, 3, 2, 4], k=2. The top two elements are 4 and 3. Can we split into [1,3], [2,4], sum 3+4=7. Or [1], [3,2,4], sum 1+4=5. Or [1,3,2], [4], sum 3+4=7. So the maximum is 7, which is indeed the sum of the two largest elements (4 and 3).\n\nAnother example: array [1, 2, 3, 4, 5], k=3. The top 3 elements are 5,4,3. The optimal split would be [1,2,3], [4], [5], sum 3+4+5=12. Or [1,2], [3,4], [5], sum 2+4+5=11. Or [1], [2,3,4], [5], sum 1+4+5=10. So the first option is better. So sum is 3+4+5=12, which is the sum of the three largest elements.\n\nBut what if the array is [1, 5, 2, 4, 3], k=3. The top three elements are 5,4,3. Can we split into [1,5], [2,4], [3]. Sum is 5+4+3=12. Yes.\n\nAnother example: array [3, 1, 2, 4], k=2. Top two elements are 4 and 3. Split into [3,1,2], [4], sum 3+4=7. Or [3,1], [2,4], sum 3+4=7. Which is indeed the sum of the two largest elements.\n\nSo this seems to hold. But what about when the top elements are not positioned in a way that allows them to be in separate segments?\n\nFor example, array [5, 1, 5], k=2. The top two elements are 5 and 5. Split into [5], [1,5] sum 5+5=10. Or [5,1], [5] sum 5+5=10. So it works.\n\nAnother example: array [5, 1, 2, 3, 4], k=2. The top two elements are 5 and 4. Split into [5], [1,2,3,4] sum 5+4=9. Or [5,1,2,3], [4] sum 5+4=9. Which is the sum of the top two elements.\n\nBut what if the array is [5, 6, 1, 7], k=2. The top two elements are 7 and 6. Can we split into [5,6,1], [7], sum 6+7=13. Or [5,6], [1,7], sum 6+7=13. Which is indeed the sum of the two largest elements.\n\nAnother test case: array [1, 2, 3, 4, 5, 6], k=3. Top three elements are 6,5,4. Split into [1,2,3,4], [5], [6] sum 4+5+6=15. Or [1,2,3], [4,5], [6] sum 3+5+6=14. Or [1,2], [3,4,5], [6] sum 2+5+6=13. So the first option gives the maximum sum of 15, which is the sum of the top three elements.\n\nBut what if the array is [5, 4, 3, 2, 1], k=3. The top three elements are 5,4,3. Split into [5], [4], [3,2,1] sum 5+4+3=12. Which is the sum of the top three elements.\n\nSo in all these examples, the maximum sum is the sum of the k largest elements. Is this always the case?\n\nWait, what if there is a scenario where splitting the array into segments that include some larger elements but not all the top k elements gives a higher sum?\n\nLet me think of an example. Suppose the array is [5, 1, 5, 1, 5], and k=3. The top three elements are 5,5,5. So sum is 15. How to split? [5], [1,5], [1,5] → sum 5+5+5=15. Or [5,1], [5,1], [5] → sum 5+5+5=15. So yes.\n\nAnother example: array [5, 1, 5, 1, 5, 1, 5], k=4. The top four elements are 5,5,5,5. Sum 20. Split into four segments, each containing one 5. Possible.\n\nAnother example: array [10, 1, 2, 3, 4, 5, 6], k=3. The top three elements are 10,6,5. If we split into [10], [1,2,3,4,5], [6], sum is 10+5+6=21. But what if we split into [10,1,2,3], [4,5], [6] → sum is 10+5+6=21. Or [10,1,2], [3,4,5], [6] → same. But what if we split into [10,1], [2,3,4,5], [6] → sum 10+5+6=21. So it's the same as the sum of the top three elements.\n\nBut what if the array is [3, 1, 2, 4], k=2. The top two elements are 4 and 3. Sum is 7. Which is achievable. But what if the array is [3, 1, 4, 2], k=2. Same result.\n\nAnother example: array [4, 3, 2, 1], k=2. The top two elements are 4 and 3. Split into [4], [3,2,1] → sum 4+3=7. Or [4,3], [2,1] → sum 4+2=6. So the optimal is to take the top two elements.\n\nSo this suggests that the maximum total profit is always the sum of the k largest elements in the array. But how to prove this?\n\nWait, but how? Suppose that there is a way to split the array into k segments such that the sum of the maxima is greater than the sum of the k largest elements. How is that possible?\n\nFor example, imagine that there is a segment that includes two large elements, and the maximum of that segment is one of them, but splitting it into two segments would allow both to be counted. But if the sum of the two is greater than the single maximum.\n\nBut that's not possible. For example, suppose you have elements a and b, where a > b. If you have a segment containing both a and b, the maximum is a. If you split into two segments, one containing a and the other containing b, then the sum is a + b, which is larger than a. So this would imply that the sum of the maxima can be increased by splitting. Thus, the optimal strategy is to split the array into segments that each contain one of the top k elements, thereby including all of them in the sum.\n\nAh! This suggests that the maximum sum is indeed the sum of the k largest elements in the array. Because whenever you have a segment that contains multiple of the top elements, you can split it into smaller segments to include more of them in the sum.\n\nThus, the problem reduces to selecting the k largest elements and ensuring that each is in its own segment. But how to split the array to achieve this?\n\nBut wait, what if there are multiple instances of the same value? For example, if the array is [5, 5, 5], and k=2. Then the sum is 5 +5=10, which is the sum of the two largest elements (both 5s).\n\nSo, the conclusion is that the maximum total profit is the sum of the k largest elements in the array. And the way to split is to find positions where each of these elements is in a separate segment.\n\nBut how to find the actual split?\n\nOnce we know that the answer is the sum of the k largest elements, the next task is to find how to split the array into k segments such that each of these k elements is in its own segment, and the segments are contiguous and cover the entire array.\n\nSo, the steps for solving the problem would be:\n\n1. Find the k largest elements in the array. Let's call them the \"important\" elements.\n\n2. Find the positions of these elements in the array. Note that there may be duplicates, so we need to select the earliest or latest occurrences depending on how to split the array.\n\n3. Split the array into k segments such that each of these important elements is in a separate segment. The way to do this is to take the positions of the important elements and split the array at the appropriate points.\n\nFor example, in the sample input:\n\nn=8, k=3, a = [5,4,2,6,5,1,9,2]\n\nThe three largest elements are 9, 6, 5. Wait, but the array has elements 9,6,5,5,4,2, etc. So the three largest elements are 9, 6, 5 (assuming there are three 5's). Wait, the array is [5,4,2,6,5,1,9,2]. The sorted list of elements is [9,6,5,5,4,2,2,1]. So the top three are 9, 6, 5. But there are two 5s. So the three largest elements are 9, 6, 5 (the first 5, or the second?), but the sum is 9 +6 +5 =20, which matches the sample output.\n\nSo the plan is to select the k largest elements, and arrange the splits so that each of them is in their own segment. The way to do this is to find the positions of the k largest elements, and split the array so that each of these elements is in a separate segment.\n\nBut how to select which elements to take when there are duplicates?\n\nFor example, if there are multiple elements with the same value, we need to choose the ones that allow for the splits to be made. For instance, in the array [5, 5, 5], k=2, we need to choose two of the 5's and split the array into segments containing them.\n\nSo the steps would be:\n\n- Sort the array elements in descending order, take the first k elements. Let's say their values are v_1 ≥ v_2 ≥ ... ≥ v_k.\n\n- Now, find the positions of these elements in the original array. However, since there may be duplicates, we need to select the earliest possible positions to allow for splits. Or perhaps the latest? Or any way that allows the splits.\n\nBut how to find the positions of the k largest elements?\n\nLet me think. For example, in the sample array, the three largest elements are 9, 6, and 5. Let's say we choose the 9 (position 7), 6 (position 4), and 5 (position 1). Now, the splits would be: first segment ends at position 1 (includes 5), then the next segment ends at position 4 (includes 6), then the rest. So the segments would be [5], [4,2,6], [5,1,9,2]. The maxima would be 5, 6, 9. Sum 20.\n\nBut in the sample, the optimal split was [5,4,2], [6,5], [1,9,2], which also includes the 9, 6, and 5 (the 5 in the second segment). So the choice of which 5 to include depends on the splits.\n\nSo, the idea is to select the k largest elements, and then split the array so that each of them is in its own segment. To do this, we can collect all the positions of the k largest elements, sort them in increasing order, and then split the array at these positions.\n\nFor example, in the sample, the positions of the three largest elements are 7 (9), 4 (6), and 0 (5, assuming zero-based or 1-based index?), and then we sort them in increasing order. Let's assume 1-based indices.\n\nIn the sample, the positions of the top three elements are 1 (5), 4 (6), and 7 (9). Sorting these gives [1,4,",
    "response": "To solve this problem, we need to split an array of problem difficulties into exactly `k` contiguous segments such that the sum of the maximum values of each segment is maximized. The optimal approach involves selecting the `k` largest elements from the array and ensuring each of these elements is in a separate segment.\n\n### Approach\n1. **Identify Key Elements**: The optimal solution involves selecting the `k` largest elements from the array. This is because each of these elements will contribute their value to the total profit when placed in separate segments.\n2. **Determine Segment Boundaries**: Once the `k` largest elements are identified, determine their positions in the original array. These positions will be used to split the array into segments.\n3. **Construct Segments**: Using the identified positions, construct the segments by ensuring each of the `k` largest elements is in its own segment.\n\n### Solution Code\n```python\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    k = int(input[idx])\n    idx += 1\n    a = list(map(int, input[idx:idx + n]))\n    \n    # To find the k largest elements and their positions\n    # We can use a list of tuples (value, index)\n    elements = []\n    for i in range(n):\n        elements.append((-a[i], i))  # Use negative for max heap simulation\n    \n    # Get the k largest elements\n    elements.sort()\n    selected = []\n    for i in range(k):\n        selected.append(elements[i][1])\n    \n    # Now, sort the selected indices in increasing order\n    selected.sort()\n    \n    # Now, create the splits\n    result = []\n    prev = 0\n    for pos in selected:\n        result.append(pos - prev + 1)\n        prev = pos + 1\n    # The last segment\n    result.append(n - prev + 1)\n    \n    print(sum([a[i] for i in selected]))\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into the number of problems `n`, the number of days `k`, and the list of problem difficulties `a`.\n2. **Identifying Key Elements**: The `k` largest elements are identified using a sorting technique where we sort the elements in descending order based on their values and their indices.\n3. **Sorting Indices**: The indices of the `k` largest elements are sorted to ensure they are processed in the correct order for segment creation.\n4. **Constructing Segments**: Using the sorted indices, we determine the lengths of each segment. Each segment starts immediately after the previous one ends, ensuring that each of the `k` largest elements is in its own segment.\n5. **Output**: The sum of the `k` largest elements is printed as the maximum possible total profit, followed by the lengths of each segment.\n\nThis approach ensures that we maximize the total profit by leveraging the largest elements in the array and efficiently constructing the required segments.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    k = int(input[idx])\n    idx += 1\n    a = list(map(int, input[idx:idx + n]))\n    \n    # To find the k largest elements and their positions\n    # We can use a list of tuples (value, index)\n    elements = []\n    for i in range(n):\n        elements.append((-a[i], i))  # Use negative for max heap simulation\n    \n    # Get the k largest elements\n    elements.sort()\n    selected = []\n    for i in range(k):\n        selected.append(elements[i][1])\n    \n    # Now, sort the selected indices in increasing order\n    selected.sort()\n    \n    # Now, create the splits\n    result = []\n    prev = 0\n    for pos in selected:\n        result.append(pos - prev + 1)\n        prev = pos + 1\n    # The last segment\n    result.append(n - prev + 1)\n    \n    print(sum([a[i] for i in selected]))\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 935,
        "completion_token_count": 655,
        "thoughts_token_count": 8192
    }
}