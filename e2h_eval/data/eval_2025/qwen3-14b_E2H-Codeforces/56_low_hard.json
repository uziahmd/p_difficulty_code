{
    "start": 1758309281.812599,
    "end": 1758309691.2970245,
    "start-formatted": "2025-09-20 04:14 KST",
    "end-formatted": "2025-09-20 04:21 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\nOkay, let's tackle this problem. Hmm. The problem is about determining if there's a perfect matching between R spaceships and B bases such that no two connecting lines intersect. Oh right, and since R and B are up to 10, maybe we can check all possible permutations?\n\nWait, first, the problem says that R and B must be equal for a perfect matching. Oh right, because each base has exactly one guardian and vice versa. So the first check is whether R equals B. If they aren't equal, then immediately output No. But in the input examples, the first case is 3 and 3, and the second is 2 and 1. So the second case would automatically output No. But the sample input shows that the second example's output is No, which aligns with that.\n\nSo the first step is to check if R != B. If so, output No. Otherwise, proceed.\n\nNow, assuming R = B, we need to check if there exists a perfect matching (a bijection between spaceships and bases) such that no two line segments between matched pairs cross each other.\n\nThe challenge here is how to check for such a matching. Since R and B are small (up to 10), perhaps we can generate all possible permutations of assignments and check each one for non-intersecting lines.\n\nBut how do we check if any two line segments intersect? Well, for each permutation (each possible assignment of spaceships to bases), we need to check all pairs of line segments to ensure none cross.\n\nSo the steps would be:\n\n1. Check if R != B. If yes, output No.\n2. Else, generate all possible permutations of the bases (since each spaceship is assigned to exactly one base, and each base is assigned exactly one spaceship).\n   For example, if there are R spaceships and R bases, then for each permutation of the bases, we can pair the i-th spaceship with the permuted base at position i.\n3. For each such permutation, check if all the line segments between the spaceship and base pairs are non-intersecting.\n4. If any permutation satisfies this condition, output Yes. Otherwise, No.\n\nBut how do I check if two line segments intersect?\n\nI need a function that takes two line segments (each defined by two points) and returns True if they intersect, False otherwise. But wait, the problem states that no three points are colinear. So that might simplify things. Also, the problem says that any two paths (segments) should not intersect. So even if two segments just touch at an endpoint, that's allowed? Wait, the problem says \"do not intersect in the galaxy plane (that is, in 2D)\".\n\nBut the note says that in the first example, connecting in order works. So perhaps the segments can share endpoints, but not cross each other. However, since each spaceship is assigned to exactly one base, the line segments are between unique pairs. So for a permutation, each line segment is between a spaceship and a base. So two different segments would be between different pairs. So if two segments share an endpoint, that's allowed? Like if two segments are connected to the same spaceship or base? No, because each spaceship is assigned to exactly one base, and each base is assigned to exactly one spaceship. So each segment is between a unique pair. So two segments can't share a common endpoint. Because each spaceship is connected to exactly one base, and each base is connected to exactly one spaceship. Therefore, any two segments are between distinct pairs of points. Therefore, the only way two segments could intersect is if they cross each other in the middle, not touching endpoints.\n\nBut how to check if two line segments intersect?\n\nWell, the standard computational geometry approach is to check if the two segments intersect. The problem says that no three points are colinear, so we don't have to worry about overlapping lines or colinear points.\n\nSo for two segments AB and CD, they intersect if and only if the orientation of A, B, C is different from the orientation of A, B, D, and the orientation of C, D, A is different from the orientation of C, D, B. Or something like that. Wait, the standard method for checking if two line segments intersect is to use the orientation method.\n\nSo here's the plan:\n\nImplement a function that checks if two line segments (p1, q1) and (p2, q2) intersect. Let me recall the steps:\n\nFirst, check if the segments intersect properly (i.e., not just touching at endpoints). But given that no three points are colinear, the endpoints can't be on the same line. So for our problem, two segments can't share an endpoint, since each point is part of exactly one segment. Therefore, any intersection between two segments would be a proper crossing.\n\nBut the problem says that the paths shouldn't intersect. So even if two segments cross at a point that's not an endpoint, that",
    "response": "To solve this problem, we need to determine if it's possible to assign Rebel spaceships to bases such that each base has exactly one guardian and no two connecting paths intersect. This involves checking all possible permutations of assignments and ensuring that no two line segments between assigned pairs intersect.\n\n### Approach\n1. **Check for Equal Numbers**: First, check if the number of spaceships (R) and bases (B) are equal. If not, immediately return \"No\".\n2. **Generate Permutations**: Generate all permutations of the bases to consider every possible assignment of spaceships to bases.\n3. **Check for Intersections**: For each permutation, check if any two line segments (connecting spaceships to their assigned bases) intersect. This is done using a helper function that checks if two line segments intersect using orientation checks.\n\n### Solution Code\n```python\nimport sys\nimport itertools\n\ndef read_input():\n    data = sys.stdin.read().split('\\n')\n    lines = [line.strip() for line in data if line.strip()]\n    return lines\n\ndef orientation(p, q, r):\n    val = (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0])\n    if val == 0:\n        return 0  # colinear\n    return 1 if val > 0 else 2  # clock or counterclock wise\n\ndef on_segment(p, q, r):\n    return (min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and\n            min(p[1], r[1]) <= q[1] <= max(p[1], r[1]))\n\ndef segments_intersect(seg1, seg2):\n    p1, q1 = seg1\n    p2, q2 = seg2\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    if o1 != o2 and o3 != o4:\n        return True\n\n    if o1 == 0 and on_segment(p1, p2, q1):\n        return True\n    if o2 == 0 and on_segment(p1, q2, q1):\n        return True\n    if o3 == 0 and on_segment(p2, p1, q2):\n        return True\n    if o4 == 0 and on_segment(p2, q1, q2):\n        return True\n\n    return False\n\ndef main():\n    lines = read_input()\n    idx = 0\n    R = int(lines[idx].split()[0])\n    B = int(lines[idx].split()[1])\n    idx += 1\n    rebels = []\n    for _ in range(R):\n        x, y = map(int, lines[idx].split())\n        rebels.append((x, y))\n        idx += 1\n    bases = []\n    for _ in range(B):\n        x, y = map(int, lines[idx].split())\n        bases.append((x, y))\n        idx += 1\n\n    if R != B:\n        print(\"No\")\n        return\n\n    from itertools import permutations\n\n    for perm in permutations(bases):\n        segments = []\n        for i in range(R):\n            seg = (rebels[i], perm[i])\n            segments.append(seg)\n        valid = True\n        for i in range(len(segments)):\n            for j in range(i+1, len(segments)):\n                if segments_intersect(segments[i], segments[j]):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into coordinates for spaceships and bases.\n2. **Orientation Check**: The `orientation` function helps determine the relative orientation of three points, which is crucial for checking segment intersections.\n3. **Segment Intersection Check**: The `segments_intersect` function uses the orientation check to determine if two line segments intersect.\n4. **Permutations and Validation**: All permutations of base assignments are checked. For each permutation, we ensure no two segments intersect, and if a valid permutation is found, \"Yes\" is printed; otherwise, \"No\" is printed after all permutations are checked.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport itertools\n\ndef read_input():\n    data = sys.stdin.read().split('\\n')\n    lines = [line.strip() for line in data if line.strip()]\n    return lines\n\ndef orientation(p, q, r):\n    val = (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0])\n    if val == 0:\n        return 0  # colinear\n    return 1 if val > 0 else 2  # clock or counterclock wise\n\ndef on_segment(p, q, r):\n    return (min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and\n            min(p[1], r[1]) <= q[1] <= max(p[1], r[1]))\n\ndef segments_intersect(seg1, seg2):\n    p1, q1 = seg1\n    p2, q2 = seg2\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    if o1 != o2 and o3 != o4:\n        return True\n\n    if o1 == 0 and on_segment(p1, p2, q1):\n        return True\n    if o2 == 0 and on_segment(p1, q2, q1):\n        return True\n    if o3 == 0 and on_segment(p2, p1, q2):\n        return True\n    if o4 == 0 and on_segment(p2, q1, q2):\n        return True\n\n    return False\n\ndef main():\n    lines = read_input()\n    idx = 0\n    R = int(lines[idx].split()[0])\n    B = int(lines[idx].split()[1])\n    idx += 1\n    rebels = []\n    for _ in range(R):\n        x, y = map(int, lines[idx].split())\n        rebels.append((x, y))\n        idx += 1\n    bases = []\n    for _ in range(B):\n        x, y = map(int, lines[idx].split())\n        bases.append((x, y))\n        idx += 1\n\n    if R != B:\n        print(\"No\")\n        return\n\n    from itertools import permutations\n\n    for perm in permutations(bases):\n        segments = []\n        for i in range(R):\n            seg = (rebels[i], perm[i])\n            segments.append(seg)\n        valid = True\n        for i in range(len(segments)):\n            for j in range(i+1, len(segments)):\n                if segments_intersect(segments[i], segments[j]):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 485,
        "completion_token_count": 954,
        "thoughts_token_count": 1024
    }
}