{
    "start": 1758019568.819557,
    "end": 1758021742.1243122,
    "start-formatted": "2025-09-16 19:46 KST",
    "end-formatted": "2025-09-16 20:22 KST",
    "gpu": 2,
    "pid": 8,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\nOkay, let's see. I need to solve this problem where I have to assign directions to edges in an undirected graph such that the flow is a valid maximum flow. The conditions are that for all vertices except source (1) and sink (n), the incoming flow equals outgoing flow. Also, the source has no incoming edges, and the directed graph must be acyclic.\n\nHmm. The key points here are that the flow is a maximum flow, and we need to assign directions to edges so that the flow is valid and the directed graph is acyclic. But how?\n\nFirst, let me think about the flow conservation. For each vertex except 1 and n, the sum of incoming flows must equal the sum of outgoing flows. So, for each edge, once directed, it contributes to either the outgoing or incoming flow of its endpoints.\n\nBut how do I determine the direction? Well, perhaps I can model this as a directed graph where the flow is already given, and I need to assign directions such that the flow is valid and acyclic.\n\nWait, but the problem says that the flow values are already given. The task is to assign directions. So the flow values are fixed, and we need to find a direction for each edge so that the flow is valid (conservation laws hold, source has no incoming, etc.) and the directed graph has no cycles.\n\nSo the problem reduces to directing the edges in a way that satisfies these constraints.\n\nNow, thinking about the flow conservation. For each node v (not 1 or n), the total flow entering equals the total flow exiting. Which means that the sum of flows on edges directed into v equals the sum of flows on edges directed out of v. Which implies that for each node v (except source and sink), the sum of flows on edges incident to v must be even? Because the sum of incoming and outgoing flows would be the same. Wait, no. Let me think again. For each node v, the total flow entering equals the total leaving. Therefore, the net flow (outgoing - incoming) is zero. But since each edge contributes to exactly one direction, the sum of flows on edges directed away from v minus the sum of flows on edges directed towards v must be zero. Which implies that the total sum of flows on edges incident to v must be even? No, because for example, if there are two edges, each with flow 5. If one is directed into v and the other out, then the net is zero. The total sum is 5+5=10, which is even. But if there's an odd sum, that's impossible. However, the problem says that a solution exists, so we can assume that for each node, the sum of flows on its edges is even? Or maybe not. Wait, the flow is given as a maximum flow. How is that possible?\n\nWait, the original problem says that the given ci's are the flow volumes. So the sum of ci's for edges incident to the source must be equal to the maximum flow value. Similarly, the sink's sum of incoming edges equals the maximum flow. But for other nodes, the sum of incoming equals the sum of outgoing. So for each node v (not source or sink), the sum of all ci's for edges incident to v must be even? Because incoming equals outgoing, so sum_in = sum_out. Sum_in + sum_out = sum of all edges incident to v. Which would be sum_in * 2. Hence, sum of all edges incident to v must be even. But since the problem states that a solution exists, we can assume that this holds.\n\nBut how does that help me? Well, perhaps not directly. Let's think about how to assign directions.\n\nAnother approach: think of the problem as building a directed acyclic graph where the flow is valid. Since the graph must be acyclic, perhaps we can arrange the edges in a topological order. So, if we can assign directions such that all edges go from earlier nodes to later nodes in some topological order, then the graph is acyclic. That's a common approach for ensuring acyclic graphs.\n\nMoreover, the source (node 1) must have no incoming edges. So in the topological order, node 1 must be the first. Similarly, the sink (node n) must be the last, since otherwise there could be edges pointing to it from later nodes, but that's allowed as long as the order is maintained.\n\nWait, but the sink can have incoming edges. So maybe the topological order starts with node 1, then other nodes, and ends with node n. Then, edges are directed from earlier to later in the order. That way, the graph is acyclic.\n\nSo if I can find a topological order where node 1 is first and node n is last, and assign directions according to that order, then the graph is acyclic. Now, how to ensure that the flow conservation holds?\n\nBut how to find such a topological order. Let's think about the flow conservation. For each node v (not 1 or n), the sum of flows on edges going out of v must equal the sum of flows on edges going into v. Which implies that the sum of flows on edges going out of v is equal to half of the sum of all edges incident to v. Because sum_out = sum_in, and sum_out + sum_in = total_sum, so sum_out = total_sum / 2.\n\nBut how to model this? Maybe we can model this as a directed graph where each node has a certain \"excess\" of flow. For example, for each node v, the excess is the total flow on edges incident to v. Then, for the source, the excess is the sum of all flows on edges connected to it. Since the source has no incoming edges, all edges from the source are outgoing. So the sum of outgoing flows from the source is equal to the maximum flow. Similarly for the sink.\n\nBut how to model this in terms of directions. Perhaps, for each node v (other than source and sink), the net flow (sum_out - sum_in) must be zero. But since sum_out - sum_in is zero, then sum_out = sum_in. Which is equivalent to the sum of flows on edges directed out of v equals sum of flows on edges directed into v.\n\nAlternatively, think of each node v (other than source and sink) as having a balance of zero. For the source, the balance is the total flow (since all edges are outgoing), and for the sink, the balance is negative of the total flow (since all edges are incoming).\n\nBut how can we model this as a directed graph? It seems like a flow problem again, but perhaps we can model it as a directed graph with certain constraints.\n\nWait, but the problem is not to compute the flow, but to assign directions to edges given the flow values. So the flow values are fixed, and we need to assign directions to edges such that the flow is valid and the directed graph is acyclic.\n\nLet me think about this in terms of a directed graph. Suppose I have a directed graph where each edge is directed from u to v or v to u. Then, for each node except source and sink, the in-degree flow equals the out-degree flow. Also, the source has no incoming edges, and the graph is acyclic.\n\nHow can I construct such a graph?\n\nAn idea comes to mind: think of the problem as a directed acyclic graph (DAG) where the flow is a valid flow. Since the DAG is acyclic, we can perform a topological sort. Then, for each edge, we can direct it from earlier nodes to later nodes in the topological order. However, the problem is that the flow conservation must be satisfied. How can we ensure that?\n\nAlternatively, perhaps we can model this as a directed graph where each node has a certain \"potential\", and the direction of the edge depends on the potential. For example, if the potential of u is less than that of v, then the edge is directed from u to v. This would make the graph acyclic if the potentials are assigned in a way that there are no cycles. But how to assign potentials such that the flow conservation holds.\n\nWait, for each node v (not source or sink), the sum of flows on edges directed out of v must equal the sum of flows on edges directed into v. Let me denote the sum of flows on edges directed out of v as out_flow[v], and in_flow[v] as the sum of flows on edges directed into v. Then, for each node v (not 1 or n), out_flow[v] = in_flow[v]. Which implies that the total sum of flows on edges incident to v is 2 * out_flow[v]. Therefore, the total sum of flows on edges incident to v must be even. Which the problem says is guaranteed.\n\nBut how to model this. Maybe think of the problem as building a directed graph where each node has a certain \"balance\" of flow. For example, for each node v, the net flow (out_flow[v] - in_flow[v]) must be zero, except for the source and sink.\n\nBut the source's net flow is equal to the maximum flow (since all edges from the source are outgoing, and none are incoming). The sink's net flow is negative of that.\n\nBut again, how to model this.\n\nAnother thought: since the graph must be acyclic, we can arrange the nodes in a topological order. Then, for each edge, we can direct it from the node that appears earlier in the order to the one that appears later. This ensures acyclicity. Now, the problem becomes to find a topological order where:\n\n- The source (node 1) is first.\n\n- The sink (node n) is last.\n\n- For each node v (not source or sink), the sum of flows on edges directed into v equals the sum of flows directed out of v.\n\nBut how to find such a topological order.\n\nAlternatively, think of this as a directed graph where each node has a certain \"excess\" of flow. For example, for node v, the excess is the sum of flows on edges that are directed out of v minus the sum of flows on edges directed into v. For the source, this excess is equal to the total flow (since all edges are outgoing), for the sink, it's -total flow, and for others, it's zero.\n\nBut how to assign directions to edges to satisfy this condition.\n\nThis seems like a problem that can be modeled as a directed graph with flow constraints. However, since the flow values are given, perhaps we can model this as a directed graph where each edge's direction is determined by some property.\n\nWait, here's an idea inspired by the fact that the directed graph must be acyclic. We can model the problem as building a DAG where the flow is valid. To ensure that, we can use a topological order. Let's imagine that the nodes are ordered in a way that allows us to assign directions based on this order.\n\nSuppose we arrange the nodes in a topological order such that the source is first, the sink is last, and for each node, the sum of flows on edges going out of it equals the sum of flows going in. How can we find such an order?\n\nAlternatively, consider that for each node, the difference between the sum of flows of edges directed out and in is equal to the required net flow. For the source, it's the total flow. For others, it's zero. For the sink, it's -total flow.\n\nBut how to model this. Let me think of this as a problem where each node has a certain value (the net flow), and the edges must be directed so that the net flow is satisfied.\n\nBut how?\n\nAlternatively, think of this as a problem of finding a directed graph where for each node, the net flow is as required. Then, the problem reduces to finding such a directed graph that is acyclic.\n\nBut how to find such a graph.\n\nAnother approach: Let's consider that the flow conservation for each node (except source and sink) requires that the sum of flows on edges incident to the node is even. Which is already ensured by the problem statement.\n\nNow, for each node, we can compute the sum of all flows on its edges. Let's call this s(v). For the source, s(1) is the total flow (since all edges are outgoing). For the sink, s(n) is the total flow (since all edges are incoming). For others, s(v) is twice the sum of outgoing flows (since sum of outgoing equals sum of incoming). \n\nBut how to assign directions.\n\nWait, here's an idea. For each node, we can compute the required net outflow. For the source, it's the total flow. For the sink, it's -total flow. For others, it's zero. Then, the problem becomes to assign directions to edges such that the net outflow of each node is as required. This is similar to a flow problem where we have to assign directions to edges so that the net flow is correct. However, since the edges are undirected, and their capacities are fixed (the flow is given), this seems like a problem of finding a directed graph that satisfies the net flow constraints.\n\nBut how to model this. This seems like a problem that can be transformed into a flow network. For example, create a directed graph where each edge can be directed either way, and find a way to assign directions so that the net outflow for each node is correct.\n\nBut how to compute that.\n\nWait, but since the net outflow for each node is fixed, this is equivalent to finding an Eulerian orientation. Wait, no. An Eulerian orientation is when the net outflow for each node is zero (for undirected graphs with even degrees). But here, the net outflow for the source and sink is non-zero. So perhaps this is a variation of that.\n\nIn any case, perhaps we can model this as a directed graph where the net outflow for each node is as required. Once we have that, then we can arrange the directions to form an acyclic graph.\n\nBut how to find such directions.\n\nLet me think of the problem as follows: For each edge, we can choose to direct it from u to v or v to u. Let's represent this choice as variables. The constraints are that for each node, the sum of flows on edges directed out of it minus the sum of flows on edges directed into it equals the required net outflow.\n\nThis is a system of equations, but solving it directly for large n and m is computationally challenging. However, since the problem guarantees that a solution exists, perhaps there's a way to construct the directions greedily.\n\nAnother idea: since the graph is connected, and the solution exists, perhaps we can build a directed tree structure. For example, construct a directed spanning tree rooted at the source, and assign directions accordingly. But I'm not sure how that would handle the flow conservation.\n\nAlternatively, think of the problem as a directed graph where each node has a certain \"potential\" value. For each edge between u and v, if the potential of u is less than that of v, direct the edge from u to v, else from v to u. Then, the directed graph is acyclic if the potentials are assigned in such a way that there are no cycles. But how to assign potentials to satisfy the flow conservation.\n\nBut how to relate the potentials to the flow conservation. For example, for each node v, the sum of flows on edges directed out of v minus the sum of flows directed into v equals the required net outflow. Let's say that for each edge between u and v, if the direction is u→v, then the flow contributes +c to u's outflow and -c to v's outflow. Alternatively, for each edge, the net contribution to the net outflow of u and v depends on the direction.\n\nBut how to model this with potentials. Suppose that the potential of a node is a value such that for any edge between u and v, the direction is chosen based on the potential. For example, if potential[u] < potential[v], then the edge is directed from u to v. Otherwise, from v to u. Now, the question is how to assign potentials so that the net outflow of each node is correct.\n\nBut how?\n\nAlternatively, think of the net outflow for each node as a value. Let's denote for node v, the required net outflow as d(v). For the source, d(1) = total_flow. For the sink, d(n) = -total_flow. For other nodes, d(v) = 0.\n\nThen, for each edge (u, v) with flow c, the direction of the edge will contribute +c to the net outflow of the starting node and -c to the net outflow of the ending node. So, for each edge, the direction choice affects the net outflow of u and v.\n\nBut how can we assign directions to satisfy the net outflow for all nodes?\n\nThis seems like a system of equations. Let me think of it as variables x_e for each edge e, which is +1 if the edge is directed from u to v (as per the input), and -1 if it's directed the other way. Then, for each node v, the sum over all edges incident to v of (x_e * c_e) must equal d(v). However, since the edges are undirected, each edge connects two nodes, and the variable x_e would be +1 or -1 depending on the direction.\n\nBut solving this system for large n and m is impractical. However, the problem says that a solution exists, so perhaps there's a way to model this as a flow problem or something else.\n\nAlternatively, since the net outflow for all nodes except source and sink is zero, maybe we can model this as a directed graph where the edges are directed in such a way that the net flow is satisfied. For example, for each node except source and sink, the net outflow is zero. For the source, it's positive, and for the sink, it's negative.\n\nBut again, how to find such a direction assignment.\n\nLet me think about the following approach: Treat the problem as a directed graph where each edge can be directed either way. We need to assign directions so that the net outflow of each node is as required. Once that is done, we can arrange the directions to form an acyclic graph.\n\nBut how to assign directions to meet the net outflow requirements.\n\nThis seems like a problem that can be solved using a modified DFS or BFS approach. For example, start with the source node. Since it has no incoming edges, all edges connected to it must be directed away from it. Then, for each neighbor, we can process their edges and assign directions based on the flow conservation.\n\nBut how to manage the flow conservation.\n\nLet me think of the following algorithm:\n\n1. Compute the required net outflow for each node. For node 1, it's the total_flow. For node n, it's -total_flow. For others, zero.\n\n2. Perform a traversal of the graph, starting from the source. For each node, track the remaining net outflow that needs to be achieved. Initially, for the source, it's total_flow. For others, zero.\n\n3. For each edge connected to the current node, if the other end hasn't been processed yet, direct the edge from the current node to the other node, subtract the flow from the current node's remaining outflow, and add it to the other node's remaining outflow. Then proceed recursively.\n\nBut how to ensure that this approach works.\n\nFor example, suppose we have a node u with some remaining outflow. When we process an edge from u to v, we subtract c from u's remaining outflow and add c to v's remaining outflow. Then, when we process v, we need to direct edges in a way that balances its remaining outflow.\n\nThis sounds similar to building a directed tree where each node's remaining outflow is passed along the edges.\n\nBut how to handle cycles in this approach. However, the problem requires that the final directed graph is acyclic. So perhaps during this traversal, we can arrange the edges in a way that forms a DAG.\n\nWait, this seems similar to the problem of finding an arborescence or something similar. But I'm not sure.\n\nAlternatively, think of this as building a directed graph where each node's remaining outflow is adjusted as we assign edges. For example, the source has a positive remaining outflow. When we assign an edge from the source to another node, that node now has a positive remaining outflow (which must be balanced by outgoing edges). Then, for that node, we process its edges, assigning directions that transfer the remaining outflow to other nodes.\n\nBut how to ensure that this process terminates and that all nodes' remaining outflow is zero (except the sink).\n\nThis approach might work. Let's try to outline it.\n\nInitialize for each node, the required outflow (d[v]). For source, d[1] = total_flow. For sink, d[n] = -total_flow. For others, d[v] = 0.\n\nWe can perform a BFS or DFS traversal starting from the source. For each node u in the traversal, we look at its adjacent edges. For each edge (u, v), if v hasn't been visited yet, we direct the edge from u to v. Then, subtract c from d[u], and add c to d[v]. Then, we add v to the queue for processing.\n\nThis way, the d[u] for the current node u is being reduced as we direct edges away from it. The idea is that the d[v] represents the amount of outflow that needs to be achieved by node v. For example, when we direct an edge from u to v, we are contributing to v's required outflow. Then, when v is processed, it will direct its edges to other nodes to balance its required outflow.\n\nThis seems promising. Let's think through an example.\n\nTake the first sample input:\n\n3 nodes, 3 edges.\n\nEdges:\n\n3-2 (10)\n\n1-2 (10)\n\n3-1 (5)\n\nThe total_flow is the sum of flows from the source (node 1). The source has edges to 2 (10) and to 3 (5). So total_flow is 10 + 5 = 15. The sink is node 3. So the required outflow for node 1 is 15, node 3 is -15. Others (node 2) has 0.\n\nProcessing starts at node 1. Its d[1] is 15. It has edges to 2 (10) and 3 (5). Suppose we process the edge to 2 first. Direct it from 1 to 2. Subtract 10 from d[1] (now 5), add 10 to d[2] (now 10). Then, process node 2. Its d is 10. It has edges to 1 (already directed), and to 3 (10). Let's process the edge to 3. Direct it from 2 to 3. Subtract 10 from d[2] (now 0), add 10 to d[3] (now -15 + 10 = -5). Then process node 3. Its d is -5. It has edges to 2 (directed from 2 to 3) and to 1 (5). So, what to do next? Well, the remaining d for node 3 is -5. The edge between 3 and 1 is undirected. We need to direct it in a way that adjusts the d values.\n\nBut node 3's d is -5, which means that it needs to have an outflow of -5. So, the net outflow is negative, meaning that it should have more inflow than outflow. How to handle this.\n\nIn this case, the edge between 3 and 1 is currently undirected. We can direct it from 1 to 3 or from 3 to 1. Let's see: if we direct it from 3 to 1, then we subtract c (5) from d[3] and add 5 to d[1]. But d[3] was -5. After subtracting 5, it becomes -10. But that would make it worse. Alternatively, if we direct it from 1 to 3, then we subtract 5 from d[1] (which is 5 now, becomes 0) and add 5 to d[3], making it -5 +5 = 0. That would balance node 3's d to 0. But node 1's d is now 0. So this seems correct.\n\nSo the directions would be:\n\nEdge 1-2: 1 → 2 (0), edge 2-3: 2 → 3 (0), edge 3-1: 1 → 3 (so direction is 1, meaning original edge is 3-1, which is reversed. So for the third edge (3-1), the output is 1 (original direction is 3→1, but we are directing it as 1→3, so output is 1).\n\nWhich matches the first sample output: [1, 0, 1].\n\nWait, the sample output is '1\\n0\\n1'. Let me check. The first edge in input is 3-2 with c=10. The output is 1, which means direction is bi→ai, i.e., 2→3. The second edge is 1-2 with c=10, output is 0, meaning direction ai→bi, i.e., 1→2. Third edge is 3-1 with c=5, output 1 means direction is bi→ai, i.e., 1→3. Which is correct. So the algorithm seems to work.\n\nBut how to handle the case when the node has a negative d. For example, node 3 in this case has d=-5. How do we handle that?\n\nIn the algorithm, when we process node 3, we look at its edges. The only unprocessed edge is between 3 and 1. But node 1 has already been processed. So how to handle that?\n\nAh, the algorithm may need to allow revisiting nodes. However, in this case, the algorithm may not have processed the edge between 3 and 1. So perhaps the algorithm should process all edges, and when a node is processed, it looks at all adjacent edges, including those already processed. But that doesn't make sense.\n\nWait, perhaps the algorithm should be modified to process edges in such a way that whenever a node has a non-zero d, we find an edge to another node (possibly already processed) and adjust the direction accordingly. However, this seems complex.\n\nAlternatively, the initial approach may work if we process the nodes in a certain order. For example, during BFS or DFS traversal, when visiting a node, we process all adjacent edges, and for each edge, if the other end hasn't been visited, we direct it from current to other, and add the other to the queue. However, if the other end has been visited, we may need to adjust the direction based on the d values.\n\nBut this seems complicated.\n\nAlternatively, think of the problem as building a directed graph where each edge is directed from a node with positive d to a node with negative d. For example, when processing a node with positive d, we look for an adjacent edge to a node with negative d and direct it accordingly. However, how to find such edges.\n\nBut how to manage this in practice.\n\nAlternatively, here's a possible approach:\n\nWe can model the problem as a directed graph where each edge is directed from a node with positive d to a node with negative d. However, since the d values are initially set for the source and sink, and others are zero, this might not work directly. However, during the process of assigning directions, the d values change.\n\nLet me think again of the algorithm:\n\nWe can use a queue. Initially, the source is added to the queue. For each node u dequeued, we look at all adjacent edges. For each edge (u, v), if the direction hasn't been decided yet, we decide it based on the current d values. For example, if d[u] > 0, we want to direct the edge from u to v, subtract c from d[u], and add c to d[v]. Then, if d[v] becomes positive, we add it to the queue. If d[v] is negative, we don't add it to the queue. But this may not work for all cases.\n\nWait, but what if d[u] is positive, and we direct the edge from u to v, which makes d[v] positive. Then, we can process v next. But what if d[v] becomes negative? Then, we can't process it further. However, the sink has d[n] = -total_flow, which is negative. So for example, when we reach the sink, we can't process it further, but it's okay.\n\nBut how to handle cases where d[u] is negative. For example, if during processing, a node has d[u] < 0, but there are edges that need to be directed into it. How to handle that.\n\nAlternatively, the algorithm can be modified as follows:\n\nFor each node u in the queue:\n\n   while d[u] != 0:\n\n       find any adjacent edge (u, v) that hasn't been directed yet.\n\n       if d[u] > 0:\n\n           direct the edge from u to v.\n\n           subtract c from d[u], add c to d[v]\n\n           if d[v] > 0:\n\n               add v to the queue.\n\n       else:\n\n           direct the edge from v to u.\n\n           subtract c from d[v], add c to d[u]\n\n           if d[u] > 0:\n\n               add u to the queue.\n\nBut this seems a bit vague. How to implement this.\n\nAlternatively, think of the problem as a directed graph where each edge is processed once. For each edge, we can direct it in a way that helps reduce the d values.\n\nBut I'm not sure. However, this seems similar to the approach used in finding an Eulerian trail. For example, in an Eulerian trail, you can direct edges in a way that balances the degrees.\n\nBut back to the sample example. Let's try applying the algorithm.\n\nInitially, d[1] = 15, d[2] = 0, d[3] = -15.\n\nQueue starts with node 1.\n\nProcess node 1. d[1] = 15.\n\nLook at its edges. Edge to 2 (c=10) and edge to 3 (c=5).\n\nLet's pick edge to 2 first. Since d[1] is positive, direct from 1 to 2. Subtract 10 from d[1] (now 5), add 10 to d[2] (now 10). Now, d[2] is positive, add it to the queue.\n\nNext, process node 2. d[2] is 10.\n\nIts edges are to 1 (already directed), and to 3 (c=10). So pick edge to 3. Direct from 2 to 3. Subtract 10 from d[2] (now 0), add 10 to d[3] (now -5). d[3] is now -5. Since it's negative, we don't add it to the queue.\n\nNow, node 1 has d[1] = 5. It has another edge to 3 (c=5). Process that edge. Since d[1] is positive, direct from 1 to 3. Subtract 5 from d[1] (now 0), add 5 to d[3], making d[3] = -5 +5 = 0. Now, d[3] is zero. So the process ends.\n\nThis gives the correct directions.\n\nThis seems to work. So the algorithm would be:\n\nInitialize d[v] for all nodes. For source, d[1] = total_flow. For sink, d[n] = -total_flow. Others zero.\n\nUse a queue. Add source to the queue.\n\nWhile queue is not empty:\n\n   u = dequeue()\n\n   while d[u] != 0:\n\n       find any edge (u, v) that hasn't been directed yet.\n\n       if d[u] > 0:\n\n           direct edge from u to v.\n\n           d[u] -= c\n\n           d[v] += c\n\n           if d[v] > 0:\n\n               enqueue(v)\n\n       else:\n\n           direct edge from v to u.\n\n           d[v] -= c\n\n           d[u] += c\n\n           if d[u] > 0:\n\n               enqueue(u)\n\nBut how to find an edge (u, v) that hasn't been directed yet. For this, we need to track for each node which edges have been processed. However, for large n and m, this needs to be efficient.\n\nBut how to implement this. For each node u, we can maintain a list of adjacent edges that haven't been processed yet. When we process an edge, we remove it from the list. However, for efficiency, perhaps we can use adjacency lists and track for each edge whether it has been directed.\n\nBut since the edges are undirected, each edge can be represented in both adjacency lists of u and v. However, once directed, we need to mark it as processed.\n\nAlternatively, for each node, keep a pointer to the next edge to process. However, this may not be straightforward.\n\nBut given that the problem allows any valid solution, perhaps the order in which edges are processed doesn't matter as long as the algorithm proceeds correctly.\n\nSo, for the code, here's the plan:\n\n- For each node, maintain an adjacency list. Each entry contains the other node and the flow value, along with the index of the edge (to output the direction later).\n\n- For each edge, track whether it has been directed yet. However, since each edge is processed once, perhaps we can mark it as directed once we process it.\n\nBut how to avoid processing the same edge twice. For example, when processing node u, we look at an edge to v. Once directed, we should not process it again when processing node v.\n\nTo handle this, perhaps for each edge, we can track which direction it has been processed. Alternatively, for each node u, when processing its edges, we can iterate through all adjacent edges and check if they have been processed. If not, process them and mark them as processed.\n\nBut how to do this efficiently.\n\nAn alternative approach is to represent each edge as a pair (u, v, c), and for each edge, once directed, we can mark it as processed. However, since the adjacency list for u and v both contain this edge, when processing node u, we can check if the edge has been processed. If not, process it and mark it as processed.\n\nBut how to track this. For example, for each edge, we can have a boolean array indicating whether it has been processed.\n\nBut with m up to 2e5, this is manageable.\n\nSo, steps for the code:\n\n1. Read n and m.\n\n2. Read m edges. For each, store ai, bi, ci, and their index.\n\n3. Build adjacency lists. For each node, a list of tuples (neighbor, ci, edge_index).\n\n4. Compute the total_flow. For the source (node 1), the total_flow is the sum of all edges connected to it. Wait, no. The total_flow is the value of the maximum flow. However, the problem says that the given ci's are the flow volumes. But how to compute the total_flow?\n\nWait, the maximum flow is the sum of flows leaving the source. Since the flow is a valid maximum flow, the total_flow is the sum of all flows on edges leaving the source. But how to compute it? Since the problem says that the solution exists, and the given ci's are part of the maximum flow.\n\nBut for our purposes, the total_flow is the sum of flows on edges incident to the source. However, since the source has no incoming edges, all edges incident to it are outgoing. Therefore, the total_flow is the sum of ci for edges connected to node 1.\n\nBut how to compute this. For example, in the first sample input, the edges connected to node 1 are 1-2 (10) and 3-1 (5). So total_flow is 10+5=15. Which matches the sample.\n\nSo, for code:\n\nCompute total_flow as sum of ci for all edges where ai == 1 or bi == 1.\n\nBut wait, no. Because the edges are undirected. So for each edge connected to node 1, regardless of the direction, the flow is part of the total_flow. So yes, the sum of all ci for edges connected to node 1 is the total_flow.\n\nOnce we have total_flow, we can set d[1] = total_flow, d[n] = -total_flow, and others to 0.\n\nThen, proceed with the algorithm.\n\nNow, the code steps:\n\nImplement the queue-based approach. For each node in the queue, while d[u] is not zero, find an edge connected to u that hasn't been processed yet, process it, and adjust the d values accordingly.\n\nBut how to find an unprocessed edge for u. One way is to have for each node u, a pointer to the next edge to process. However, for simplicity, perhaps for each node, we can iterate through all edges in the adjacency list, and for each, check if it's processed. If not, process it.\n\nBut for large m, this could be O(m^2) in the worst case. However, given that each edge is processed once, perhaps this is manageable.\n\nAlternatively, for each node, we can maintain a list of unprocessed edges. For example, during the initial setup, for each node u, we have a list of edges. As we process edges, we remove them from the list. This way, for each node, when we process it, we can iterate through its remaining unprocessed edges.\n\nBut how to implement this. For example, for each node u, we can have a list of edges that are unprocessed. When we process an edge between u and v, we remove it from both u's and v's unprocessed lists. However, this may be complex.\n\nAlternatively, for each edge, once it is processed, we mark it as processed. Then, when processing node u, we iterate through all edges in its adjacency list, and if not processed, process it.\n\nBut this would require checking each edge every time, which could be O(m) per edge.\n\nBut given that each edge is processed once, the total number of operations would be O(m).\n\nLet me think. For example",
    "response": "\n\nTo solve this problem, we need to determine the direction of each edge in an undirected graph such that the resulting directed graph forms a valid maximum flow with no cycles. The key constraints are that the flow must be conserved at each vertex (except the source and sink), the source must have no incoming edges, and the directed graph must be acyclic.\n\n### Approach\n1. **Understanding Flow Conservation**: For each vertex (except the source and sink), the sum of incoming flows must equal the sum of outgoing flows. This implies that the total flow through each vertex must be even.\n2. **Topological Sorting**: To ensure the directed graph is acyclic, we can use a topological sort approach. However, instead of explicitly sorting, we use a queue-based approach to process nodes and direct edges while maintaining flow conservation.\n3. **Queue-Based Processing**: Start from the source node and use a queue to process each node. For each node, adjust the flow values of its adjacent edges to maintain the required net outflow, ensuring that the flow conservation constraints are met.\n\n### Solution Code\n```python\nimport sys\nimport threading\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    m = int(input[ptr])\n    ptr += 1\n\n    edges = []\n    adj = [[] for _ in range(n + 1)]\n    for i in range(m):\n        a = int(input[ptr])\n        ptr += 1\n        b = int(input[ptr])\n        ptr += 1\n        c = int(input[ptr])\n        ptr += 1\n        edges.append((a, b, c, i))\n        adj[a].append((b, c, i))\n        adj[b].append((a, c, i))\n\n    # Compute total_flow\n    total_flow = 0\n    for a, b, c, idx in edges:\n        if a == 1 or b == 1:\n            total_flow += c\n\n    d = [0] * (n + 1)\n    d[1] = total_flow\n    d[n] = -total_flow\n\n    processed = [False] * m\n    result = [0] * m\n\n    q = deque()\n    q.append(1)\n\n    while q:\n        u = q.popleft()\n        while d[u] != 0:\n            found = False\n            # Iterate through all adjacent edges\n            for v, c, idx in adj[u]:\n                if not processed[idx]:\n                    # This edge hasn't been processed yet\n                    processed[idx] = True\n                    if d[u] > 0:\n                        # Direct from u to v\n                        result[idx] = 0\n                        d[u] -= c\n                        d[v] += c\n                        if d[v] > 0:\n                            q.append(v)\n                    else:\n                        # Direct from v to u\n                        result[idx] = 1\n                        d[u] += c\n                        d[v] -= c\n                        if d[u] > 0:\n                            q.append(u)\n                    found = True\n                    break\n            if not found:\n                break\n\n    for res in result:\n        print(res)\n\nthreading.Thread(target=main).start()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and stored in an adjacency list along with the edge details.\n2. **Total Flow Calculation**: The total flow from the source is calculated by summing the flows of all edges connected to the source.\n3. **Initialization**: Arrays `d` store the required net outflow for each node. The source has a positive net outflow, the sink has a negative net outflow, and others have zero.\n4. **Queue Processing**: Using a queue, nodes are processed to direct edges such that flow conservation is maintained. Each edge is processed once, and its direction is determined based on the current net outflow values of the nodes involved.\n5. **Edge Direction**: The direction of each edge is stored in the `result` array, which is printed at the end.\n\nThis approach ensures that the resulting directed graph meets all the problem constraints efficiently, handling large inputs within acceptable time limits.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport threading\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    m = int(input[ptr])\n    ptr += 1\n\n    edges = []\n    adj = [[] for _ in range(n + 1)]\n    for i in range(m):\n        a = int(input[ptr])\n        ptr += 1\n        b = int(input[ptr])\n        ptr += 1\n        c = int(input[ptr])\n        ptr += 1\n        edges.append((a, b, c, i))\n        adj[a].append((b, c, i))\n        adj[b].append((a, c, i))\n\n    # Compute total_flow\n    total_flow = 0\n    for a, b, c, idx in edges:\n        if a == 1 or b == 1:\n            total_flow += c\n\n    d = [0] * (n + 1)\n    d[1] = total_flow\n    d[n] = -total_flow\n\n    processed = [False] * m\n    result = [0] * m\n\n    q = deque()\n    q.append(1)\n\n    while q:\n        u = q.popleft()\n        while d[u] != 0:\n            found = False\n            # Iterate through all adjacent edges\n            for v, c, idx in adj[u]:\n                if not processed[idx]:\n                    # This edge hasn't been processed yet\n                    processed[idx] = True\n                    if d[u] > 0:\n                        # Direct from u to v\n                        result[idx] = 0\n                        d[u] -= c\n                        d[v] += c\n                        if d[v] > 0:\n                            q.append(v)\n                    else:\n                        # Direct from v to u\n                        result[idx] = 1\n                        d[u] += c\n                        d[v] -= c\n                        if d[u] > 0:\n                            q.append(u)\n                    found = True\n                    break\n            if not found:\n                break\n\n    for res in result:\n        print(res)\n\nthreading.Thread(target=main).start()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 700,
        "completion_token_count": 885,
        "thoughts_token_count": 8191
    }
}