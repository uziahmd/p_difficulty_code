{
    "start": 1758344086.6114717,
    "end": 1758345111.0039294,
    "start-formatted": "2025-09-20 13:54 KST",
    "end-formatted": "2025-09-20 14:11 KST",
    "gpu": 2,
    "pid": 8,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\nOkay, I need to solve this programming problem. Let's read the problem carefully.\n\nThe problem is about directing edges in an undirected graph such that the flow conditions are satisfied. The given flows on each edge are already determined, and we need to assign directions to them. The constraints are:\n\n1. For each vertex except source (1) and sink (n), the sum of incoming flow equals the sum of outgoing flow. So, the flow is conserved here.\n2. The source (vertex 1) has no incoming edges. All edges connected to it must be directed away from it.\n3. The directed graph must not have cycles.\n\nHmm. How do I approach this?\n\nLet me think about the flow conservation. For each node except source and sink, the total incoming equals outgoing. Since each edge has a flow value, directing it as ai→bi or bi→ai affects the inflow/outflow for the nodes.\n\nBut how can I model this? Well, for each edge, if we assign a direction, it contributes to the net flow of the nodes. For example, if an edge between u and v is directed u→v, then u's outflow increases by c, and v's inflow increases by c.\n\nBut since the flow is maximum, the problem says that the given ci values are part of the maximum flow. So our job is just to assign directions such that the flow conservation holds and the directed graph is acyclic, with source having no incoming edges.\n\nWait, but how to ensure that the directed graph is acyclic? Because if there's a cycle, that would mean that there's a loop where flow is going around, which would imply that the flow conservation is violated? Or maybe not. Because in a cycle, each node's inflow equals outflow. But the problem requires that the directed graph has no cycles. So how can we arrange the directions to avoid cycles?\n\nHmm. So the key is to find a way to direct the edges so that the flow conservation is satisfied and the graph is a DAG (directed acyclic graph). Also, the source (node 1) has no incoming edges.\n\nAn idea comes to mind: perhaps we can model this as a directed graph where the edges are directed in such a way that the flow is a DAG. How?\n\nAnother thought: since the flow is a maximum flow, the residual graph would have certain properties. But I'm not sure how that applies here.\n\nAlternatively, considering that the flow must be acyclic. So maybe we can construct a DAG where the edges are directed in a way that respects the flow conservation. But how?\n\nLet me think about the flow conservation. For each node except source and sink, the total incoming flow equals the total outgoing flow. Which implies that the net flow (outflow - inflow) is zero. Except for the source and sink. The source's net outflow is equal to the total flow, and the sink's net inflow is equal to the total flow.\n\nBut how does this relate to the directions of edges?\n\nLet me think of the problem as assigning directions to edges such that for each node, the sum of flows on edges directed away from the node minus the sum of flows on edges directed towards the node equals the net outflow. For the source, this net outflow is the total flow (which is the sum of all flows leaving the source). For the sink, it's the negative of that. For others, it's zero.\n\nSo for each node v (not 1 or n), the sum of flows on edges directed out of v minus the sum of flows on edges directed into v is zero. Which is equivalent to the sum of flows on edges directed out of v equals the sum of flows on edges directed into v. Which is the same as the inflow equals outflow.\n\nBut how to model this. It seems like a system of equations, but solving that directly might be computationally expensive given the constraints on n and m (up to 2e5).\n\nAlternative approach: think of the problem as building a directed graph where the edges are directed in a way that forms a DAG. Since a DAG can be topologically ordered, perhaps we can assign directions according to a topological order.\n\nWait, if the directed graph is acyclic, then there exists a topological ordering of the nodes. Let's imagine that we arrange the nodes in some topological order. Then, for every edge, we direct it from the earlier node in the order to the later node. But how does that help with the flow conservation?\n\nBut the flow conservation requires that for each node (except source and sink), the sum of flows on incoming edges equals the sum of flows on outgoing edges. However, if the edges are directed according to a topological order, then each node's outgoing edges go to nodes that come after it in the order. So for the flow conservation, perhaps we can model this as some kind of flow balance.\n\nAlternatively, perhaps we can model this as a directed graph where each node (except source and sink) has in-degree and out-degree flows balanced. But again, how to compute that.\n\nWait, here's another thought. Since the flow is a maximum flow, and the given flows are part of that maximum flow, perhaps the directions of the edges must form a DAG where the edges are directed away from the source and towards the sink. But how?\n\nAnother angle: since the directed graph must be acyclic, we can think of it as a DAG. Therefore, there's a topological order. Let's consider building a topological order where the source (node 1) is first, and the sink (node n) is last. Then, for each edge, we direct it from the node that appears earlier in the topological order to the one that appears later. This ensures that there are no cycles.\n\nBut then, how to choose this topological order such that the flow conservation is satisfied?\n\nAlternatively, think of the problem as a directed graph where each node (other than source and sink) has a net outflow of zero. But how to model that.\n\nWait, for each node v (not source or sink), the net outflow (sum of flows on outgoing edges minus sum on incoming edges) must be zero. Let's denote for each node v, the net outflow as net_flow[v]. Then:\n\nnet_flow[1] = total_flow (the maximum flow)\nnet_flow[n] = -total_flow\nnet_flow[v] = 0 for other v.\n\nBut how to compute this? Well, the total_flow is the sum of all flows on edges leaving the source. But how do we know that?\n\nAlternatively, since the original graph is undirected, but the flow is given, perhaps the total_flow can be computed as the sum of flows on edges incident to the source. Wait, no. Because the flow is a valid maximum flow. So for the source, the sum of flows leaving it (outgoing edges) is the total flow. Similarly, the sink has the same sum of incoming flows. For other nodes, the sum of incoming flows equals the sum of outgoing flows.\n\nBut since we have to assign directions to the edges, perhaps we can model the problem as follows:\n\nFor each node v, the net outflow (sum of flows on edges directed out of v minus those directed into v) must be equal to:\n\n- For v = 1: total_flow (since all edges from 1 are directed outwards)\n- For v = n: -total_flow\n- For others: 0\n\nBut how to determine the directions of edges to satisfy these constraints?\n\nThis seems similar to finding a directed graph where the net outflow for each node is as above. But how?\n\nThis looks like a problem of finding a directed graph where for each node, the sum of flows on outgoing edges minus sum of flows on incoming edges equals the required value. Which is essentially a flow conservation problem, but in reverse.\n\nWait, but this is exactly the problem of finding a flow in a graph where the edges have capacities (but here, they are fixed). Wait, no. Because the flow on each edge is fixed. We are to assign directions to edges, which determines the direction of the flow. So for each edge, the flow is fixed (ci) and direction is chosen. So the net outflow for each node is the sum over all edges directed out of it of ci minus the sum over edges directed into it of ci.\n\nSo, the problem reduces to choosing directions for edges such that for each node v:\n\nif v is 1: sum_out - sum_in = total_flow\nif v is n: sum_out - sum_in = -total_flow\nelse: sum_out - sum_in = 0\n\nBut how to compute this?\n\nBut how do I find the total_flow? Well, the total_flow is the sum of flows leaving the source (node 1). But since the edges are undirected, but the flow is given, perhaps the total_flow is determined by the sum of flows on edges incident to the source. But how?\n\nWait, the sum of flows leaving the source (sum_out) is the total_flow. And since the source has no incoming edges, sum_in for the source is zero. So for the source, sum_out - sum_in = total_flow. Which is the net outflow.\n\nBut for the source, the sum of flows on edges directed out of it is the sum of all flows on edges incident to the source. Because all edges connected to the source must be directed away from it (since the source has no incoming edges). Therefore, the total_flow is the sum of all flows on edges connected to the source. Because all edges connected to the source are directed away from it.\n\nWait, but what if there are multiple edges connected to the source? For example, suppose the source has two edges with flows 5 and 10. Then the total_flow is 5+10=15. That's correct because the source sends out 15 units of flow, which must be the same as the amount received by the sink.\n\nSo, the first step is to compute the total_flow. How?\n\nWell, the total_flow is the sum of all flows on edges connected to the source. Because all edges connected to the source are directed away from it, as per the problem's constraints.\n\nBut wait, the problem says that the source has no incoming edges. So all edges connected to the source must be directed away from it. Therefore, for each edge connected to the source, the direction is from source to the other end.\n\nTherefore, the total_flow is the sum of all flows on edges connected to the source. Let me denote this as T.\n\nNow, for other nodes, the net outflow must be zero. For the sink, the net outflow is -T.\n\nSo the problem becomes: assign directions to edges such that for each node v:\n\n- For v=1: net outflow is T\n- For v=n: net outflow is -T\n- For other v: net outflow is 0.\n\nBut how to assign directions to achieve this?\n\nThis seems like a problem of finding a directed graph where the net outflow for each node is as specified. But how?\n\nThis is similar to finding an Eulerian trail, but not exactly. Alternatively, it's like finding a directed graph with given net outflows for each node.\n\nWait, the net outflow for a node is the difference between outflow and inflow. For each node, this is equal to the sum of flows on outgoing edges minus the sum of flows on incoming edges.\n\nLet me think of this as a system of equations. For each node v, the sum of flows on edges directed away from v minus the sum of flows on edges directed towards v equals the required net outflow.\n\nBut how can we model this?\n\nLet me think of each edge as contributing +ci to the net outflow of one node and -ci to the other. For example, if an edge between u and v is directed from u to v, then u's net outflow increases by ci, and v's net outflow decreases by ci (because the flow is coming into v).\n\nSo, for each edge, the direction choice affects the net outflow of two nodes. The problem is to choose directions for all edges such that the net outflow of each node is as required.\n\nThis seems like a problem that can be modeled as a directed graph with certain constraints. How can we find such directions?\n\nLet me think of the net outflow for each node as a variable. For example, the required net outflow for node v is:\n\nrequired[v] = T if v == 1\n\nrequired[v] = -T if v == n\n\nrequired[v] = 0 otherwise.\n\nWe need to assign directions to edges such that for each node, the sum of flows on outgoing edges minus sum of flows on incoming edges equals required[v].\n\nLet me think of the problem as follows: each edge can be considered as contributing to the net outflow of its endpoints. For example, if the edge is directed from u to v, then u's net outflow increases by ci, and v's net outflow decreases by ci. So, for the entire graph, the sum of all required[v] must be zero, which is indeed the case here.\n\nBecause T + (-T) + sum_{others} 0 = 0.\n\nSo the problem is feasible, and the solution exists.\n\nNow, how to model this. One approach is to model this as a directed graph where each edge's direction is chosen such that the net outflow for each node is as required.\n\nThis seems like a problem that can be solved by constructing a directed graph with certain properties. How?\n\nAnother idea: think of the net outflow for each node as the difference between the outflow and inflow. For each node v, the net outflow is required[v]. Let's denote this as d[v].\n\nThen, for each edge between u and v, we can assign a direction such that the contribution to d[u] and d[v] is accounted for. For example, if we direct the edge from u to v, then d[u] += ci and d[v] -= ci. If we direct it from v to u, then d[u] -= ci and d[v] += ci.\n\nSo, the problem reduces to choosing directions for edges such that after all assignments, d[v] equals required[v].\n\nBut how to find such a direction assignment.\n\nThis seems like a problem where we can model it as a directed graph with certain constraints. However, how to compute this efficiently.\n\nLet me think of this as a graph where each edge can be assigned a direction, and we need to find a set of directions that satisfies the required d[v] for each node.\n\nThis is similar to finding an orientation of the edges such that the resulting directed graph has the required net outflow for each node.\n\nThis seems like a problem that can be solved using a spanning tree approach. For example, if we can find a way to assign directions to the edges in the tree, and then handle the rest.\n\nAlternatively, think of the problem as a directed graph where the edges are oriented in such a way that the net outflow for each node is correct. This can be modeled as a system of equations, but solving it for large n and m is not feasible.\n\nAlternative approach: since the required net outflow for each node is known, perhaps we can model this as a directed graph where the edges are directed in such a way that the net outflow is achieved. For example, for each node, the sum of flows on edges directed away from it minus those directed into it is equal to required[v].\n\nThis seems like a problem that can be transformed into a directed graph with certain properties, such as a directed acyclic graph (DAG) as required by the problem.\n\nBut how?\n\nLet me think of the following approach:\n\nWe can model this as a directed graph where each node has a certain \"excess\" of flow that needs to be sent out. For example, for node 1, the excess is T. For node n, it's -T. For others, it's zero.\n\nTo resolve this, we can imagine that each node needs to send out a certain amount of flow. For example, node 1 needs to send out T, and node n needs to receive T. Other nodes need to have their inflow and outflow balanced.\n\nThis seems like a problem of finding a flow in the graph where the required flow is given for each node. However, the edges are undirected, and the flow on each edge is fixed. But the direction is to be determined.\n\nWait, but the flow is already given. So, for each edge, the flow is fixed (ci). We just need to assign directions so that the net outflow for each node is correct.\n\nSo, the problem is similar to finding a directed graph where for each node, the net outflow is required[v], and the flow on each edge is ci, with direction determined.\n\nThis seems like a problem that can be modeled as a directed graph where the edges are directed in such a way that the net outflow is correct. How can we find such a direction?\n\nLet me think of this as a graph where each node has a certain \"balance\" that needs to be achieved. For example, node 1 has a balance of T, node n has -T, others zero.\n\nWe can model this as a directed graph where each edge can be directed either way, and we need to choose directions so that the balances are satisfied.\n\nThis is similar to the problem of orienting edges to make the graph have certain in/out degrees. However, in this case, it's about the net flow (sum of flows on edges directed away minus those directed towards).\n\nAn idea comes to mind: we can model this as a directed graph where each edge's direction is chosen based on the balance of the nodes. For example, we can process the nodes in some order and adjust the directions accordingly.\n\nAlternatively, think of this as a problem of building a directed graph with the required net outflow for each node, and ensuring that the graph is acyclic.\n\nBut how to ensure the acyclic condition? Well, the problem requires that the directed graph has no cycles. So, perhaps we can build a DAG with the required net outflow.\n\nAnother idea: since the directed graph must be acyclic, we can arrange the nodes in a topological order. Let's say that the topological order starts with the source (node 1), ends with the sink (node n), and all edges are directed from earlier nodes to later nodes. Then, the graph is acyclic by construction.\n\nNow, the question is: can we assign directions to edges according to this topological order such that the net outflow for each node is correct?\n\nLet's think about how to compute the net outflow for each node. For example, if we have a topological order, then for each node, all edges that are directed out of it go to nodes that appear later in the order. The net outflow for a node would then be the sum of flows on edges directed out of it minus those directed into it. But since the edges directed into it must come from nodes that appear before it in the order.\n\nBut how to choose the topological order and the directions so that the net outflow is correct.\n\nAlternatively, perhaps the topological order can be determined based on the required net outflow. For example, the source (node 1) must be first, and the sink (node n) must be last. Then, for other nodes, their positions in the topological order can be determined based on their required net outflow.\n\nBut I'm not sure.\n\nLet me think of the following approach:\n\nWe can model the problem as building a DAG where the edges are directed from nodes with positive net outflow to nodes with negative net outflow, but this is vague.\n\nAlternatively, think of the net outflow for each node as a value. For example, node 1 has a positive value (T), node n has a negative value (-T), others have zero. We need to direct edges in such a way that these net outflows are achieved.\n\nThis is similar to a flow problem where each node has a supply/demand. For example, node 1 has a supply of T, node n has a demand of T, and others have zero. Then, the edges can carry flow in either direction, but the flow is fixed (ci). But I'm not sure how this helps.\n\nAlternatively, think of the problem as a directed graph where each edge can carry flow in one direction or the other, and the flow is fixed. The direction of the edge determines whether it contributes to the outflow of the starting node and inflow of the ending node.\n\nBut how to model this as a system of equations.\n\nLet me think of variables. For each edge between u and v, let x be 1 if the direction is u→v, 0 otherwise. Then, for each node v, the sum over all edges adjacent to v of (x * ci) if the edge is directed away from v, minus the sum of ( (1 - x) * ci ) if the edge is directed into v. This should equal the required net outflow for v.\n\nBut this seems complicated to model.\n\nAnother idea: For each node v, the required net outflow is d[v]. Let's consider that the sum of flows on edges directed away from v minus the sum of flows on edges directed into v equals d[v].\n\nBut for each edge between u and v, if we direct it from u to v, then it contributes +ci to u's net outflow and -ci to v's net outflow. If directed from v to u, it contributes -ci to u's net outflow and +ci to v's net outflow.\n\nLet me denote for each edge (u, v), we can choose to add +ci to u and subtract ci from v, or vice versa.\n\nSo, the problem is to choose for each edge whether to add +ci to u and subtract from v, or the opposite, such that for all nodes, the sum of these contributions equals their required d[v].\n\nThis is a system of equations. However, solving this system for large n and m is not trivial.\n\nBut since the problem guarantees that a solution exists, perhaps there's a way to construct the directions greedily.\n\nLet me think of the following approach:\n\nWe can model this as a directed graph where each node has a certain \"balance\" that needs to be achieved. Initially, the balance for each node is d[v]. For each edge, we can choose to direct it in one direction or the other, which adjusts the balance of the two nodes involved.\n\nFor example, suppose we have an edge between u and v. Suppose the current balance of u is B_u and of v is B_v. If we direct the edge from u to v, then B_u decreases by ci (since we added ci to u's outflow, which is part of the net outflow calculation?), or perhaps I need to think differently.\n\nWait, the net outflow for a node is the sum of flows on outgoing edges minus sum of flows on incoming edges. So, when we direct an edge from u to v, it adds ci to the net outflow of u and subtracts ci from the net outflow of v. So, for the balances, initially, the required net outflow for each node is d[v]. For example, if we have an edge between u and v, and we direct it from u to v, then we need to subtract ci from the required balance of u and add ci to the required balance of v. Wait, no.\n\nLet me think again. Suppose the required net outflow for node u is D_u. Initially, D_u is set as required. When we direct an edge from u to v, this contributes +ci to the net outflow of u. So, the remaining balance for u is D_u - ci. Similarly, for v, the net outflow is increased by -ci, so the remaining balance is D_v + ci.\n\nWait, no. Let me rephrase. Let's say that for each node, we have a current balance. Initially, the balance is D[v], which is the required net outflow. As we assign directions to edges, we adjust the balances. For example, when we direct an edge from u to v, this contributes +ci to the net outflow of u. So, the current balance of u must be adjusted by subtracting this contribution. Because once we assign this direction, the net outflow of u is increased by ci, which means that the remaining balance for u is D[u] - ci. Similarly, the net outflow of v is decreased by ci, so the remaining balance for v is D[v] + ci. \n\nWait, maybe I should think of it as the current balance is the amount that still needs to be achieved. For example, initially, the balance for u is D[u]. When we direct an edge from u to v, this contributes +ci to u's net outflow. Since the required net outflow for u is D[u], this means that after this contribution, the remaining balance for u is D[u] - ci. Similarly, for v, the contribution is -ci, so the remaining balance for v is D[v] + ci.\n\nIf I can process edges in such a way that I always reduce the balances to zero, then I have found the correct directions.\n\nSo the idea is to process edges and for each, decide the direction such that it helps reduce the balances of the nodes involved.\n\nBut how to choose which edges to process and which direction to take.\n\nThis sounds similar to the problem of finding an Eulerian trail, where you have to adjust the degrees of nodes. In that case, you can process edges and adjust the degrees accordingly.\n\nLet me think of this as a graph where each node has a certain \"excess\" that needs to be resolved. For example, node 1 has excess T, node n has -T, others zero. We can process edges and direct them in a way that reduces this excess.\n\nLet me think of the following algorithm:\n\n1. Compute the required net outflow for each node, d[v].\n2. Build a graph with these nodes and edges.\n3. Perform a traversal (like DFS or BFS) and for each edge, direct it in a way that reduces the excess of the nodes.\n\nFor example, during traversal, when visiting a node u with excess > 0, find an edge connected to u that leads to another node v. If u has excess > 0, then we can direct the edge from u to v. This will decrease the excess of u by ci and increase the excess of v by ci. If v's excess is negative, then this may help in reducing it.\n\nBut how to implement this.\n\nThis seems similar to the approach used in finding an Eulerian trail. Let me think of it as follows:\n\n- Start with node 1 (source), which has excess T.\n- Traverse edges, directing them in a way that reduces the excess of the current node.\n\nFor example, pick any edge from the current node u. Suppose the other end is v. If the current excess of u is positive, we direct the edge from u to v. This reduces u's excess by ci and increases v's by ci. Now, we move to v and continue the traversal.\n\nThis way, we process edges and adjust the excess of the nodes. Once we reach a node with zero excess, we backtrack.\n\nBut how to ensure that this process covers all edges and that the excesses are properly adjusted.\n\nThis approach may work. Let's think through an example.\n\nTake the first sample input:\n\nn=3, m=3.\n\nEdges:\n\n3-2 with c=10\n\n1-2 with c=10\n\n3-1 with c=5.\n\nThe required net outflow for node 1 is T, which is sum of flows on edges connected to node 1. The edges connected to node 1 are 1-2 (c=10) and 3-1 (c=5). So T = 10 +5 =15.\n\nSo required net outflow for node 1 is 15, node 3 is -15, node 2 is 0.\n\nInitially, the excess for node 1 is 15, node 2 is 0, node 3 is -15.\n\nStart at node 1. Take any edge connected to it. Let's say the edge between 1 and 2. Direct it from 1 to 2. This reduces node 1's excess by 10 (now 5), increases node 2's excess by 10 (now 10). Now, move to node 2.\n\nAt node 2, excess is 10. Take any edge connected to it. The edges are 1-2 (already directed), 2-3 (c=10), and possibly others. Let's take the 2-3 edge. Direct it from 2 to 3. This reduces node 2's excess by 10 (now 0), increases node 3's excess by 10 (from -15 to -5). Now, move to node 3. Its excess is -5.\n\nNow, node 3 has excess -5. We need to find an edge connected to it that can be directed to reduce this excess. The edges connected to 3 are 3-2 (directed from 2 to 3, so already processed?), and 3-1 (c=5). Wait, the third edge is between 3 and 1. So, we have to direct it. Currently, the excess of node 3 is -5. So, if we direct the edge from 3 to 1, that would contribute +5 to node 3's excess (since directing from 3 to 1 adds 5 to node 3's net outflow). But node 3's current excess is -5, so adding 5 would make it zero. However, the source node 1 cannot have incoming edges. So this is not allowed.\n\nAh! Oh right! The source (node 1) cannot have any incoming edges. So all edges connected to node 1 must be directed away from it. So, in this case, the edge between 3 and 1 must be directed from 3 to 1? No, that would be an incoming edge to node 1, which is not allowed. Therefore, the edge between 3 and 1 must be directed from node 1 to node 3. Which was not done yet. But earlier, we had directed the edge between 1 and 2 as 1->2. The edge between 3 and 1 hasn't been processed yet.\n\nSo, back to node 3. Its excess is -5. How to proceed? We need to direct an edge connected to it. The available edges are 3-2 (already directed from 2 to 3), and 3-1. Since node 1 cannot have incoming edges, the edge between 3 and 1 must be directed from 1 to 3. So, we have to direct it from 1 to 3. This contributes +5 to node 1's excess (but node 1's excess was 5 after processing the first edge). Wait, no. If we direct the edge from 1 to 3, then this contributes +5 to node 1's net outflow. But node 1's current excess is 5. So, this would reduce it by 5 (since the required net outflow is 15, and we've already accounted for 10 from the first edge). Wait, I'm getting confused here.\n\nLet me re-calculate the excess after each step.\n\nInitially:\n\nd[1] = 15, d[2] = 0, d[3] = -15.\n\nStep 1: process edge 1-2, direct from 1 to 2. This contributes +10 to node 1's net outflow. Since the required is 15, we subtract this from the excess. So d[1] = 15 -10 =5. For node 2, the net outflow increases by -10 (since the edge is directed from 1 to 2, which contributes -10 to node 2's net outflow). Wait, earlier thinking said that directing from u to v adds +ci to u's net outflow and subtracts ci from v's. So, for node 2, the excess is 0 + (-(-10))? Or wait, no.\n\nOriginal excess for node 2 is 0. After directing the edge from 1 to 2, this adds +10 to node 1's net outflow (so the excess for node 1 decreases by 10), and adds -10 to node 2's net outflow (so the excess for node 2 increases by 10). So node 2's excess becomes 0 + 10 = 10.\n\nThen, we are at node 2 with excess 10.\n\nStep 2: process edge between 2 and 3. Direct it from 2 to 3. This adds +10 to node 2's net outflow (so the excess decreases by 10, becomes 0), and subtracts 10 from node 3's net outflow (so the excess for node 3 increases by 10. Previously, it was -15, now -15 +10 = -5).\n\nNow, node 3 has excess -5. What edges are left? The edge between 3 and 1.\n\nWe need to direct this edge. Since node 1 cannot have incoming edges, the direction must be from 1 to 3. So, we direct it from 1 to 3. This adds +5 to node 1's net outflow (so its excess was 5, now 5 -5 = 0). And subtracts 5 from node 3's net outflow (so its excess was -5, now -5 +5 = 0). Perfect! So now all excesses are zero.\n\nSo the directions are:\n\nEdge 1-2: 1→2 (output 0)\n\nEdge 2-3: 2→3 (output 0?)\n\nWait, the original edges are:\n\nFirst input line: 3 2 10 → edge between 3 and 2.\n\nSecond line: 1 2 10 → edge between 1 and 2.\n\nThird line: 3 1 5 → edge between 3 and 1.\n\nIn the sample output, the answer is 1, 0, 1. Which corresponds to:\n\nFirst edge (3-2) directed from 2 to 3 (original is 3→2, so output 1 (reverse)).\n\nSecond edge (1-2) directed as 1→2 (original is 1→2, output 0).\n\nThird edge (3-1) directed as 1→3 (original is 3→1, output 1).\n\nWhich matches the sample output.\n\nSo this approach seems to work.\n\nSo the algorithm would be:\n\n- For each node, track the excess (required net outflow).\n- Start at node 1.\n- While there are unprocessed edges:\n   - Pick a node u with non-zero excess.\n   - Find an adjacent edge that hasn't been processed yet.\n   - Let v be the other end of the edge.\n   - If u is the source (node 1), then the edge must be directed from u to v (so we can't choose the reverse).\n   - Else, if the excess of u is positive, direct the edge from u to v, which reduces u's excess by ci and increases v's by ci.\n   - Else, direct the edge from v to u, which increases u's excess by ci and decreases v's by ci.\n   - But how to choose which direction to take when the excess is negative?\n\nWait, perhaps the way to proceed is to always process edges from nodes with non-zero excess. For example, when you're at a node u with excess e, you look for an adjacent edge that hasn't been processed yet. Suppose the other end is v. If e is positive, you direct the edge from u to v, which reduces u's excess by ci and increases v's by ci. Then you move to v. If e is negative, you direct the edge from v to u, which increases u's excess by ci (since the edge is directed from v to u, contributing +ci to u's net outflow, which is subtracted from the excess). Wait, no. Let me think again.\n\nIf the current node u has excess e (which is the amount of net outflow still needed). If e is positive, we want to send more outflow from u. So we direct the edge from u to v. This contributes +ci to u's net outflow, so we subtract ci from the excess (since the required is already accounted for). For example, if the required net outflow for u is 15, and we have already contributed 10, the excess is 5. Directing an edge from u to v contributes +ci to the net outflow, so the excess is reduced by ci.\n\nIf the current node u has a negative excess (say, -5), that means that the net outflow for u is currently too low. We need to get more outflow from u. But how? By directing edges into u, which would increase the net outflow of u. Wait, no. If an edge is directed into u, that adds to the inflow of u, thus decreasing the net outflow. Which would make the excess worse. So perhaps when the excess is negative, we need to direct edges away from u. But how?\n\nWait, maybe I should think of the excess as the amount that the node needs to have in its net outflow. For example, if a node's excess is positive, it needs to have more outflow. If it's negative, it needs to have less outflow (i.e., more inflow).\n\nBut how to achieve that by directing edges.\n\nLet me think of the following: whenever we are at a node u with non-zero excess, we look for an adjacent edge that hasn't been processed yet. Let the other end be v. If the excess of u is positive, we direct the edge from u to v. This contributes +ci to the net outflow of u, thus reducing the excess by ci. If the excess is negative, we direct the edge from v to u. This contributes +ci to the net outflow of u (since the edge is directed into u, which is inflow, but wait no: if the edge is directed from v to u, then u's net outflow decreases by ci (because the edge is incoming to u). Wait, no. Let me clarify:\n\nWhen the edge is directed from v to u:\n\n- For node v: net outflow increases by ci → excess for v decreases by ci.\n- For node u: net outflow decreases by ci → excess for u increases by ci.\n\nSo, if the current excess for u is",
    "response": "To solve this problem, we need to direct the edges of an undirected graph such that the resulting directed graph satisfies specific flow conservation constraints and is acyclic. The source vertex (1) must have no incoming edges, and the sink vertex (n) must have all the flow directed towards it.\n\n### Approach\n1. **Calculate Required Net Outflow**: For each node, compute the required net outflow. The source (node 1) should have a net outflow equal to the sum of flows on its incident edges, while the sink (node n) should have a net outflow of the negative of this sum. All other nodes must have zero net outflow.\n2. **Greedy Edge Direction Assignment**: Using a depth-first search (DFS) approach, traverse the graph starting from the source. For each edge encountered, direct it such that it helps reduce the excess (net outflow) of the current node. If the current node has a positive excess, direct the edge away from it; if it has a negative excess, direct the edge towards it.\n\n### Solution Code\n```python\nimport sys\nimport threading\nfrom collections import defaultdict\n\ndef main():\n    sys.setrecursionlimit(1 << 25)\n    n, m = map(int, sys.stdin.readline().split())\n    edges = []\n    adj = defaultdict(list)\n    for i in range(m):\n        a, b, c = map(int, sys.stdin.readline().split())\n        edges.append((a, b, c))\n        adj[a].append((b, i))\n        adj[b].append((a, i))\n    \n    # Compute required net outflow for each node\n    d = [0] * (n + 1)\n    total_flow = 0\n    for i in range(m):\n        a, b, c = edges[i]\n        if a == 1 or b == 1:\n            total_flow += c\n    d[1] = total_flow\n    d[n] = -total_flow\n\n    # We'll track the direction for each edge\n    direction = [0] * m  # 0 means original direction (ai -> bi), 1 means reversed\n\n    # Track which edges have been processed\n    processed = [False] * m\n\n    # To avoid recursion limit issues, use iterative DFS\n    stack = [1]\n    visited = [False] * (n + 1)\n    parent = [0] * (n + 1)\n    edge_index = [0] * (n + 1)  # To track which edge we're processing for each node\n\n    while stack:\n        u = stack[-1]\n        if not visited[u]:\n            visited[u] = True\n        found = False\n        # Iterate through adjacent edges\n        for v, idx in adj[u]:\n            if processed[idx]:\n                continue\n            # Check if this edge is already processed\n            if not processed[idx]:\n                # Decide direction based on d[u]\n                if d[u] > 0:\n                    # Direct from u to v\n                    direction[idx] = 0 if (edges[idx][0] == u and edges[idx][1] == v) else 1\n                    # Update d values\n                    d[u] -= edges[idx][2]\n                    d[v] += edges[idx][2]\n                    processed[idx] = True\n                    stack.append(v)\n                    found = True\n                    break\n                elif d[u] < 0:\n                    # Direct from v to u\n                    direction[idx] = 0 if (edges[idx][0] == v and edges[idx][1] == u) else 1\n                    # Update d values\n                    d[u] += edges[idx][2]\n                    d[v] -= edges[idx][2]\n                    processed[idx] = True\n                    stack.append(v)\n                    found = True\n                    break\n        if not found:\n            stack.pop()\n\n    for di in direction:\n        print(di)\n\nthreading.Thread(target=main).start()\n```\n\n### Explanation\n- **Required Net Outflow Calculation**: The net outflow for the source node is determined by summing the flows of all edges incident to it. The sink node's net outflow is the negative of this sum, and all other nodes have zero net outflow.\n- **Edge Direction Assignment**: Using an iterative DFS approach, we process each edge starting from the source. Depending on the current node's net outflow (positive or negative), we direct the edge to reduce the net outflow towards zero. This ensures that the resulting directed graph meets the flow conservation constraints and is acyclic.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport threading\nfrom collections import defaultdict\n\ndef main():\n    sys.setrecursionlimit(1 << 25)\n    n, m = map(int, sys.stdin.readline().split())\n    edges = []\n    adj = defaultdict(list)\n    for i in range(m):\n        a, b, c = map(int, sys.stdin.readline().split())\n        edges.append((a, b, c))\n        adj[a].append((b, i))\n        adj[b].append((a, i))\n    \n    # Compute required net outflow for each node\n    d = [0] * (n + 1)\n    total_flow = 0\n    for i in range(m):\n        a, b, c = edges[i]\n        if a == 1 or b == 1:\n            total_flow += c\n    d[1] = total_flow\n    d[n] = -total_flow\n\n    # We'll track the direction for each edge\n    direction = [0] * m  # 0 means original direction (ai -> bi), 1 means reversed\n\n    # Track which edges have been processed\n    processed = [False] * m\n\n    # To avoid recursion limit issues, use iterative DFS\n    stack = [1]\n    visited = [False] * (n + 1)\n    parent = [0] * (n + 1)\n    edge_index = [0] * (n + 1)  # To track which edge we're processing for each node\n\n    while stack:\n        u = stack[-1]\n        if not visited[u]:\n            visited[u] = True\n        found = False\n        # Iterate through adjacent edges\n        for v, idx in adj[u]:\n            if processed[idx]:\n                continue\n            # Check if this edge is already processed\n            if not processed[idx]:\n                # Decide direction based on d[u]\n                if d[u] > 0:\n                    # Direct from u to v\n                    direction[idx] = 0 if (edges[idx][0] == u and edges[idx][1] == v) else 1\n                    # Update d values\n                    d[u] -= edges[idx][2]\n                    d[v] += edges[idx][2]\n                    processed[idx] = True\n                    stack.append(v)\n                    found = True\n                    break\n                elif d[u] < 0:\n                    # Direct from v to u\n                    direction[idx] = 0 if (edges[idx][0] == v and edges[idx][1] == u) else 1\n                    # Update d values\n                    d[u] += edges[idx][2]\n                    d[v] -= edges[idx][2]\n                    processed[idx] = True\n                    stack.append(v)\n                    found = True\n                    break\n        if not found:\n            stack.pop()\n\n    for di in direction:\n        print(di)\n\nthreading.Thread(target=main).start()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 701,
        "completion_token_count": 953,
        "thoughts_token_count": 8192
    }
}