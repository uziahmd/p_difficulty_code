{
    "start": 1758310149.665994,
    "end": 1758310245.5975697,
    "start-formatted": "2025-09-20 04:29 KST",
    "end-formatted": "2025-09-20 04:30 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\nOkay, let's try to tackle this problem. So the task is to find two things for a given p: the minimum number of nodes required to create a p-reachable directed graph, and then among all such graphs with that minimum number of nodes, find the maximum number of unidirectional pairs.\n\nFirst, I need to understand what exactly a p-reachable graph is. The definition says that it contains exactly p ordered pairs (u, v) where u < v and u and v are reachable from each other. Oh right, so for each pair u < v, if they can reach each other, that counts towards p. And we need exactly p such pairs.\n\nThe first part is to find the minimal number of nodes needed. Let's think about how to model this. For a graph with n nodes, the maximum possible number of such pairs (u < v that are mutually reachable) would be C(n, 2) if all nodes are in a single strongly connected component (SCC). Because every pair (u, v) with u < v would be mutually reachable. But if we have multiple SCCs, then pairs within the same SCC contribute, but pairs between different SCCs don't contribute because they can't reach each other (assuming the DAG of SCCs is a DAG, which it is).\n\nWait, but the problem says that the graph is directed. So, the structure of the graph can be decomposed into SCCs. The number of ordered pairs (u < v) that are mutually reachable is equal to the sum over each SCC of C(k, 2), where k is the size of the SCC. Because within an SCC, any two distinct nodes are mutually reachable. But if two nodes are in different SCCs, then they can't be mutually reachable if the DAG of SCCs is acyclic. Wait, but if there's a path from A to B and from B to A, then they would be in the same SCC. So the DAG of SCCs is such that there's no cycles between them. So for two nodes in different SCCs, they cannot be mutually reachable. Therefore, the total number of such pairs is the sum of C(k_i, 2) for each SCC of size k_i.\n\nSo our problem reduces to finding a collection of integers k_1, k_2, ..., k_m such that sum_{i} C(k_i, 2) = p, and the sum of k_i (which is the total number of nodes) is minimized. Then, the minimal number of nodes is the minimal sum of k_i's such that the sum of C(k_i, 2) equals p.\n\nBut wait, the problem requires that the graph has exactly p such pairs. So the sum of C(k_i, 2) must be exactly p. Therefore, the first part is to find the minimal n such that there exists a set of integers k_1, k_2, ..., k_m (summing to n) where sum C(k_i, 2) = p.\n\nSo the first step is to find the minimal n where this is possible.\n\nNow, how do we find that?\n\nLet me think about this as an optimization problem. For a given p, find the minimal n where there exists a decomposition of p into sum of C(k_i, 2) terms, and the sum of k_i is as small as possible.\n\nTo minimize the sum of k_i's for a given sum of C(k_i, 2), we should make each term as large as possible. Because C(k, 2) grows quadratically, while the sum of k is linear. For example, using a single term C(k, 2) gives us the maximum possible value for a given k. So, for example, if p is 3, then C(3, 2) is 3. So the minimal n is 3. Which matches the first sample input.\n\nSimilarly, if p is 4, then C(3,2) is 3, and then we need one more. So maybe split into 3 and 2: C(3,2) + C(2,2) = 3 + 1 = 4. Then the total nodes are 3 + 2 =5. But is there a better way? What about using four 2's? C(2,2) is 1, so four of them sum to 4, and the total nodes would be 4*2=8, which is worse than 5. So the minimal n here is 5, which matches the sample's second case (input 4 gives output 5 6).\n\nSo the approach is to find the minimal n by choosing the largest possible C(k, 2) terms, but perhaps with some adjustments.\n\nSo, the first step is to find the minimal n such that the sum of C(k_i, 2) equals p. How to compute that?\n\nLet me think of this as",
    "response": "To solve this problem, we need to determine two key aspects for a given integer $ p $: the minimum number of nodes required to form a $ p $-reachable directed graph and the maximum number of unidirectional pairs in such graphs with the minimum number of nodes.\n\n### Approach\n\n1. **Understanding Reachable Pairs**: A $ p $-reachable graph must have exactly $ p $ ordered pairs $(u, v)$ where $ u < v $ and both $ u $ and $ v $ are mutually reachable. The number of such pairs in a graph can be derived from the sum of combinations $ C(k_i, 2) $ for each strongly connected component (SCC) of size $ k_i $.\n\n2. **Minimizing Nodes**: To minimize the number of nodes, we aim to use the largest possible SCCs because $ C(k, 2) $ grows quadratically with $ k $. This means using fewer, larger SCCs is more efficient than many small ones.\n\n3. **Maximizing Unidirectional Pairs**: Once the minimal number of nodes is determined, the maximum number of unidirectional pairs is calculated by considering all possible ordered pairs and subtracting those that are mutually reachable.\n\n### Solution Code\n\n```python\nimport sys\nimport math\n\ndef main():\n    p = int(sys.stdin.readline())\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    # Find the minimal n\n    # We want to find the minimal sum of k_i such that sum(C(k_i, 2)) = p\n    # We start by trying to use as large as possible components.\n    # We'll greedily take the largest possible k where C(k, 2) <= remaining p\n\n    n = 0\n    remaining_p = p\n    components = []\n\n    while remaining_p > 0:\n        k = 1\n        while (k * (k - 1)) // 2 <= remaining_p:\n            k += 1\n        k -= 1\n        components.append(k)\n        remaining_p -= (k * (k - 1)) // 2\n        n += k\n\n    # Now, find the maximum number of unidirectional pairs\n    # Total possible ordered pairs (u, v) with u != v is total_nodes * (total_nodes - 1)\n    total_nodes = n\n    total_pairs = total_nodes * (total_nodes - 1)\n    mutual_pairs = p\n    unidirectional_pairs = total_pairs - 2 * mutual_pairs\n\n    print(f\"{n} {unidirectional_pairs}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n\n1. **Reading Input**: The input is read as an integer $ p $ which represents the number of mutually reachable pairs required.\n\n2. **Finding Minimum Nodes**: We use a greedy approach to decompose $ p $ into the sum of combinations $ C(k, 2) $. Starting from the largest possible $ k $, we subtract the corresponding value from $ p $ until $ p $ is zero. This ensures the sum of $ k $ values is minimized.\n\n3. **Calculating Unidirectional Pairs**: The total number of ordered pairs (including both directions) in a graph with $ n $ nodes is $ n \\times (n - 1) $. Subtracting twice the number of mutually reachable pairs (since each mutual pair is counted twice in the total) gives the number of unidirectional pairs.\n\nThis approach efficiently computes both the minimal number of nodes and the maximum number of unidirectional pairs for the given $ p $, ensuring optimal performance even for large values of $ p $.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\n\ndef main():\n    p = int(sys.stdin.readline())\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    # Find the minimal n\n    # We want to find the minimal sum of k_i such that sum(C(k_i, 2)) = p\n    # We start by trying to use as large as possible components.\n    # We'll greedily take the largest possible k where C(k, 2) <= remaining p\n\n    n = 0\n    remaining_p = p\n    components = []\n\n    while remaining_p > 0:\n        k = 1\n        while (k * (k - 1)) // 2 <= remaining_p:\n            k += 1\n        k -= 1\n        components.append(k)\n        remaining_p -= (k * (k - 1)) // 2\n        n += k\n\n    # Now, find the maximum number of unidirectional pairs\n    # Total possible ordered pairs (u, v) with u != v is total_nodes * (total_nodes - 1)\n    total_nodes = n\n    total_pairs = total_nodes * (total_nodes - 1)\n    mutual_pairs = p\n    unidirectional_pairs = total_pairs - 2 * mutual_pairs\n\n    print(f\"{n} {unidirectional_pairs}\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 481,
        "completion_token_count": 758,
        "thoughts_token_count": 1024
    }
}