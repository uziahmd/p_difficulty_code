{
    "start": 1758310283.3917904,
    "end": 1758310486.2087836,
    "start-formatted": "2025-09-20 04:31 KST",
    "end-formatted": "2025-09-20 04:34 KST",
    "gpu": 2,
    "pid": 44,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Polycarp's Practice\n\nPolycarp is practicing his problem solving skill. He has a list of $$$n$$$ problems with difficulties $$$a_1, a_2, \\dots, a_n$$$, respectively. His plan is to practice for exactly $$$k$$$ days. Each day he has to solve at least one problem from his list. Polycarp solves the problems in the order they are given in his list, he cannot skip any problem from his list. He has to solve all $$$n$$$ problems in exactly $$$k$$$ days.Thus, each day Polycarp solves a contiguous sequence of (consecutive) problems from the start of the list. He can't skip problems or solve them multiple times. As a result, in $$$k$$$ days he will solve all the $$$n$$$ problems.The profit of the $$$j$$$-th day of Polycarp's practice is the maximum among all the difficulties of problems Polycarp solves during the $$$j$$$-th day (i.e. if he solves problems with indices from $$$l$$$ to $$$r$$$ during a day, then the profit of the day is $$$\\max\\limits_{l \\le i \\le r}a_i$$$). The total profit of his practice is the sum of the profits over all $$$k$$$ days of his practice.You want to help Polycarp to get the maximum possible total profit over all valid ways to solve problems. Your task is to distribute all $$$n$$$ problems between $$$k$$$ days satisfying the conditions above in such a way, that the total profit is maximum.For example, if $$$n = 8, k = 3$$$ and $$$a = [5, 4, 2, 6, 5, 1, 9, 2]$$$, one of the possible distributions with maximum total profit is: $$$[5, 4, 2], [6, 5], [1, 9, 2]$$$. Here the total profit equals $$$5 + 6 + 9 = 20$$$.\n\n## Input\nThe first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\le k \\le n \\le 2000$$$) — the number of problems and the number of days, respectively.The second line of the input contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le 2000$$$) — difficulties of problems in Polycarp's list, in the order they are placed in the list (i.e. in the order Polycarp will solve them).\n\n## Output\nIn the first line of the output print the maximum possible total profit.In the second line print exactly $$$k$$$ positive integers $$$t_1, t_2, \\dots, t_k$$$ ($$$t_1 + t_2 + \\dots + t_k$$$ must equal $$$n$$$), where $$$t_j$$$ means the number of problems Polycarp will solve during the $$$j$$$-th day in order to achieve the maximum possible total profit of his practice.If there are many possible answers, you may print any of them.\n\n## Example\n### Input\n['8 3\\n5 4 2 6 5 1 9 2', '5 1\\n1 1 1 1 1', '4 2\\n1 2000 2000 2']\n\n### Output\n['20\\n3 2 3', '1\\n5', '4000\\n2 2']\n\n## Note\nThe first example is described in the problem statement.In the second example there is only one possible distribution.In the third example the best answer is to distribute problems in the following way: $$$[1, 2000], [2000, 2]$$$. The total profit of this distribution is $$$2000 + 2000 = 4000$$$.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\nOkay, let's see. I need to solve this programming problem. Let me read the problem carefully.\n\nSo the problem is about splitting n problems into exactly k days. Each day, Polycarp solves a contiguous block of problems starting from the beginning. So the first day's problems are the first t1 problems, the second day's are the next t2, etc., and the sum of t's is n. The total profit is the sum of the maximum difficulty of each day's problems. My task is to maximize this total profit and output the maximum value along with the distribution of t's.\n\nHmm. How to approach this?\n\nFirst, I need to find a way to split the array into k parts such that the sum of the maxima of each part is maximized. Since the splitting must be contiguous and in order, this feels like a dynamic programming problem.\n\nLet me think about dynamic programming. Let's define dp[i][j] as the maximum total profit for the first i problems split into j days. Then, the recurrence would be something like:\n\nFor dp[i][j], we can consider all possible m < i where the previous day ends at m. Then dp[i][j] = max(dp[m][j-1] + max(a[m+1..i])) for all m from j-1 to i-1 (since each day must have at least one problem).\n\nBut the problem is that for each i and j, calculating the max for every possible m would take O(n^3) time. For n up to 2000, that would be 2000^3 which is 8e10 operations. That's way too slow. So this approach isn't feasible unless optimized.\n\nWait, but maybe there's a way to optimize this. Let's think about precomputing the maximums for ranges. For example, precompute a 2D array max_range where max_range[l][r] is the maximum of a[l..r]. Then, when considering splitting the first i problems into j days, for each possible m (the end of the previous day), we can get the max of a[m+1..i] quickly.\n\nBut even with that, the DP would be O(k*n^2), which for n=2000 and k=2000 would be 2000*2000^2 = 8e10 operations. That's way too slow. Wait, but k can be up to n. So if n is 2000, that's 2000^3 operations. Which is not feasible.\n\nSo this approach might not work. But maybe there's a way to optimize further. Let me think again.\n\nAlternatively, perhaps the constraints can be handled with some optimizations. For example, for each i and j, the number of possible splits is O(i). But with n=2000 and k=2000, it's still O(n^3). Hmm. Not sure.\n\nWait, but what's the maximum possible value of k? It's n. So when k equals n, each day must have exactly one problem. So the total profit is the sum of all elements. So in that case, the answer is straightforward.\n\nBut for other cases, perhaps we can find a way to optimize. Let's think about the DP approach again. Let's try to find a way to compute the DP efficiently.\n\nAnother thought: For each j, the number of days, the DP[j][i] can be computed based on DP[j-1][m] for m < i. The key is that for each j, we can compute the DP[j] based on DP[j-1].\n\nBut even then, for each i and j, we need to check all possible m's. However, perhaps for each j and i, we can find the best m in a smarter way.\n\nAlternatively, perhaps we can use the fact that when adding a new day, the optimal split for the first i problems into j days would involve taking the maximum between the previous splits and adding the max of the current segment.\n\nBut how?\n\nLet me think about the example given. For the first example, n=8, k=3, and the array [5,4,2,6,5,1,9,2]. The optimal split is [3,2,3], which gives 5 (max of first 3), 6 (max of next 2), 9 (max of next 3). The total is 5+6+9=20.\n\nNow, for the DP approach, let's think about the steps. For dp[i][j], the maximum profit for the first i problems split into j days.\n\nThe base case is dp[0][0] = 0. For j=1, dp[i][1] = max of the first i elements. For j=2, dp[i][2] = max over m from 1 to i-1 of (dp[m][1] + max(a[m+1..i])).\n\nBut for each j, we can compute the dp[i][j] by considering all possible m's. However, for large n and k, this is O(kn^2) time. Let's calculate the numbers. If n is 2000 and k is 2000, then 2000 * 2000^2 = 8e10 operations. That's way too big. So this approach is not feasible for n=2000. So we need a better approach.\n\nWait, but what's the maximum possible value of k? It's up to n. So for n=2000, the worst case is O(kn^2) = 2000^3 = 8e10 operations. That's way too slow. So this approach is not going to work. So I need a better idea.\n\nAlternative approach: Since the problem requires splitting into exactly k days, and each day must have at least one problem, perhaps there's a greedy approach? But I don't see an obvious greedy strategy here. For example, choosing the largest elements as the maxima for each day. However, since the splits are contiguous, the positions matter. For example, if you have a very high value in the middle, you need to split the array so that it's a day's maximum. But how?\n\nAlternatively, think about the problem as selecting k-1 split points. The splits must divide the array into k contiguous parts. The total profit is the sum of the maxima of each part. We need to choose the split points to maximize this sum.\n\nBut how?\n\nAnother thought: The maximum sum is achieved by making sure that each split includes the highest possible elements. For example, if there's a very large element, it's better to have it as the max of its day. But since the splits are contiguous, perhaps we can find the positions where the splits are made to capture the maximum elements.\n\nBut how to model this?\n\nAlternatively, think about the problem as follows. The total sum is the sum of the maxima of each of the k segments. Since each segment is a consecutive block starting from the beginning, the first segment is from 1 to x, the second from x+1 to y, etc. So the first split is after x, the second after y, etc.\n\nBut how to choose these splits.\n\nAnother idea: The problem resembles the problem of partitioning the array into k segments to maximize the sum of segment maxima. This seems similar to some known DP problem, but perhaps with optimizations.\n\nWait, perhaps the DP approach can be optimized with some observations. For example, for the DP[i][j], when considering the splits for the j-th day, the maximum of the last segment (from m+1 to i) can be precomputed. Also, for each i and j, the optimal m is such that the previous j-1 days are optimally split up to m.\n\nBut how to compute this efficiently.\n\nWait, let's think again about the DP recurrence. Let's denote dp[i][j] as the maximum total profit for the first i elements split into j days.\n\nThen, for dp[i][j], we can consider all possible m where the j-th day starts at m+1 and ends at i. So for each possible m (from j-1 to i-1, since each of the previous j-1 days must have at least one element), we can compute dp[m][j-1] + max(a[m+1..i]).\n\nThe key is to compute this efficiently.\n\nBut the problem is that for each i and j, we need to compute the max for ranges ending at i. How can we do this efficiently?\n\nLet's think about precomputing the max for ranges. We can create a 2D array max_range where max_range[l][r] is the maximum of a[l..r]. This can be precomputed in O(n^2) time. For n=2000, this would be 4 million entries, which is acceptable.\n\nOnce we have that, then for any m and i, we can get the max of a[m+1..i] in O(1) time.\n\nSo with that, the DP recurrence would be O(kn^2) time. For n=2000, this is 2000 * 2000^2 = 8e10 operations. Which is way too slow. So this approach is not feasible.\n\nBut maybe there's a way to optimize the DP further. Let's think about the constraints again. For example, for j days, the minimum i is j (each day has one problem). So for j=1, i can be from 1 to n. For j=2, i can be from 2 to n, etc.\n\nBut even with that, the time complexity remains the same.\n\nAlternative idea: For each j, when computing dp[i][j], can we find a way to compute it faster than O(n) per i?\n\nFor example, for a fixed j and varying i, can we find some properties of the optimal m for each i?\n\nAnother thought: For the j-th day, when considering splitting the first i elements into j days, the last day's segment is from m+1 to i. The maximum of this segment is the maximum between the maximum of the segment from m+1 to i-1 and a[i]. So perhaps we can track this as we iterate i.\n\nLet me think. Suppose I'm trying to compute dp[i][j], and I have already computed dp[m][j-1] for all m < i. Now, for each possible m (from j-1 to i-1), I need to compute the maximum of a[m+1 ... i]. How can I compute this efficiently?\n\nIf I can compute the maximums incrementally. For example, for each i and j, as I increase m from j-1 to i-1, the segment [m+1 ... i] is shrinking from the left. So for each i, when I go from m = i-1 down to m = j-1, the maximum can be maintained as we move m leftward.\n\nWait, for example, when considering m from i-1 down to 1, the segment [m+1 ... i] starts as [i] (max is a[i]), then [i-1, i] (max is max(a[i-1], a[i])), then [i-2, i], etc. So if I can keep track of the current maximum as I decrease m, then for each i, j, I can compute the max for all m in O(i) time.\n\nBut how does this help with the DP?\n\nLet me think. For dp[i][j], we can compute for each possible m (the end of the previous j-1 days) the value dp[m][j-1] + max(a[m+1..i]). So for each i and j, we can iterate m from j-1 to i-1, and for each m, compute the max. But if we can compute the max incrementally, then for each i and j, the computation of the max for all m can be done in O(n) time.\n\nWait, for a fixed i and j, when considering m from i-1 down to j-1 (so that m+1 is from i down to j), the max for the segment [m+1..i] can be tracked as follows:\n\nInitialize current_max = a[i]. Then, for m = i-1 down to j-1:\n\ncurrent_max = max(current_max, a[m+1])\n\nWait, no. Because m+1 is the starting index of the segment. For example, when m = i-1, the segment is [i], which is a[i]. When m decreases by 1, the segment becomes [i-1, i], so the max is max(a[i-1], a[i]). So as m decreases, the segment starts at m+1, which is moving leftwards. So for each step, the new element added to the left is a[m+1]. So the current_max can be updated as max(current_max, a[m+1]).\n\nYes! So for a fixed i and j, when considering m from i-1 down to j-1, the max for the segment [m+1..i] can be computed incrementally. So for each i and j, we can compute all possible max values in O(n) time. Thus, the total time complexity would be O(kn^2), but with a better constant factor.\n\nBut even with that, for n=2000 and k=2000, it's still O(8e10) operations. Which is way too slow.\n\nHmm. So this suggests that the DP approach is not feasible for n=2000. What else can be done?\n\nAlternative idea: Since the problem requires exactly k days, and each day must have at least one problem, perhaps there's a way to find the optimal splits using a greedy approach, but I can't see it immediately.\n\nWait, but what if k is small? For example, if k is 1, then the answer is the max of the entire array. For k=2, we need to split the array into two parts. The optimal way is to split between two positions where the sum of the maxima is maximum. But how to find that split?\n\nBut for general k, this seems difficult.\n\nAnother thought: Maybe the maximum total profit is the sum of the top k elements. But this is not necessarily true. For example, in the third sample input: [1, 2000, 2000, 2], k=2. The top two elements are 2000 and 2000. The optimal split is [1,2000], [2000,2], sum 2000+2000=4000. Which is indeed the sum of the top two elements. But if the array was [5, 4, 3, 2, 1], and k=2, the optimal split would be [5], [4,3,2,1], sum 5+4=9, which is the sum of the two largest elements. So maybe in some cases, the optimal sum is the sum of the top k elements. However, in other cases, this may not hold. For example, if the array is [3, 1, 2, 4], and k=2. The top two elements are 4 and 3. The optimal split would be [3,1,2], [4], sum 3+4=7. Alternatively, [3,1], [2,4], sum 3+4=7. Or [3], [1,2,4], sum 3+4=7. All give the same sum. Which is indeed the sum of the top two elements. Another example: [5, 4, 3, 2, 1], k=3. The top three elements are 5,4,3. The optimal split would be [5], [4], [3,2,1], sum 5+4+3=12. Which is indeed the sum of the top three. So maybe in all cases, the maximum total profit is the sum of the top k elements. But wait, what if the array is [2, 1, 3], k=2. The top two elements are 3 and 2. The optimal split is [2,1], [3], sum 2+3=5. Or [2], [1,3], sum 2+3=5. Which is the sum of the top two elements. So yes. Another example: [1,3,2,4], k=2. The top two are 4 and 3. The optimal split is [1,3,2], [4] (sum 3+4=7) or [1,3], [2,4] (sum 3+4=7). So again, sum of top two.\n\nWait, but what if the array is [5, 1, 1, 5], k=2. The top two elements are 5 and 5. The optimal split is [5,1,1], [5], sum 5+5=10. Or [5], [1,1,5], sum 5+5=10. Which is indeed the sum of the two largest elements. However, what if the array is [5, 1, 5, 1], k=2. The same logic applies. Splitting into [5,1,5] and [1], sum 5+5=10. Or [5], [1,5,1], sum 5+5=10. So again, sum of top two.\n\nSo in all these examples, the maximum total profit is the sum of the top k elements. But why is that?\n\nBecause each day's profit is the maximum of that day's segment. So, if we can arrange that each of the k days' segments contains exactly one of the top k elements, then the total profit would be the sum of those top k elements. And since each of those elements is the maximum of their respective segments, this sum would be the maximum possible.\n\nBut is it always possible to arrange the splits such that each of the top k elements is the maximum of their own segment?\n\nWell, the top k elements must be in the array. Let's imagine that we have these top k elements. Since the array is processed in order, the splits would have to be arranged so that each of these elements is in a separate segment. For example, if the top k elements are spread out in the array, then we can split the array into segments so that each of them is the maximum in their segment.\n\nBut how?\n\nFor example, suppose the array is [a_1, a_2, ..., a_n], and the top k elements are at positions p_1 < p_2 < ... < p_k. Then, the splits would be after p_1, after p_2, etc. So that each of these elements is in their own segment. But how to ensure that the splits are made in such a way.\n\nBut in that case, the maximum for each segment would be the element itself. Hence, the total would be the sum of these elements.\n\nBut what if there are multiple elements with the same value? Like, for example, if the array is [5,5,5], k=2. Then, the maximum sum is 5 +5 = 10, which is the sum of the two largest elements.\n\nSo, perhaps the answer is always the sum of the k largest elements. But how can that be? Because in some cases, perhaps splitting in a different way could allow higher sum. Wait, no. Because the maximum of a segment can't be larger than the maximum element in the entire array. So, if you have k segments, each of their maxima can't exceed the top k elements. But if you can select the top k elements, then their sum is the maximum possible.\n\nWait, this seems to suggest that the maximum total profit is the sum of the k largest elements in the array. But then why does the first example have a sum of 5+6+9=20? Let's check the array [5,4,2,6,5,1,9,2]. The top 3 elements are 9,6,5. Sum is 20. Which matches the example's output. So yes. The third example: [1,2000,2000,2], k=2. The top two are 2000 and 2000. Sum 4000. Which matches the sample. The second example input is [1,1,1,1,1], k=5. The sum is 1+1+1+1+1=5. Which matches the sample output.\n\nSo this seems to be a pattern. So why is this the case?\n\nBecause, in order to maximize the sum of the maxima, we need to have each day's maximum as large as possible. The best way to do that is to have each day's maximum be one of the k largest elements. Since each day's maximum can't be larger than the maximum element in the array, and the sum of the k largest elements is the maximum possible sum.\n\nBut how to arrange the splits so that each of the k largest elements is the maximum of its segment. Well, for example, if the k largest elements are in the array, then we can split the array such that each of these elements is in a separate segment. Since the segments are contiguous and in order, we can make sure that each of these elements is the maximum of their own segment.\n\nBut how?\n\nLet me think. Suppose that the k largest elements are in positions p_1 < p_2 < ... < p_k. Then, we can split the array into the first segment ending at p_1, the second segment ending at p_2, etc. But how to ensure that each segment's maximum is the corresponding element.\n\nFor example, take the first example. The top three elements are 9 (position 7), 6 (position 4), 5 (position 1). Wait, but 5 is the first element. But the third largest is 5? Let's see the array [5,4,2,6,5,1,9,2]. The sorted list of elements is [2, 2, 1, 4,5,5,6,9]. So the top three are 9,6,5. So the third largest is 5. So how to split into three segments such that each of these three elements is the maximum of their segments.\n\nIn the example, the split is [5,4,2], [6,5], [1,9,2]. The maxima are 5,6,9. Which are the three largest elements. So yes. So the sum is the sum of the three largest elements.\n\nSo the problem reduces to selecting the k largest elements, and splitting the array into k segments such that each of these elements is the maximum of their segment. How can we do that?\n\nThe way to do this is to split the array such that each of the k largest elements is in a separate segment. Since the segments are contiguous and in order, this can be done by making sure that each of these elements is the first occurrence of a new segment. For example, if the k largest elements are in positions p_1 < p_2 < ... < p_k, then the splits can be made after p_1, after p_2, etc. However, this depends on the positions of the elements.\n\nBut how to find the splits?\n\nAn alternative approach: Find the positions of the k largest elements, and then split the array into k segments such that each of these elements is in a separate segment. For example, the first segment ends at the first occurrence of the largest element, the second segment ends at the first occurrence of the second largest element after that, etc.\n\nBut this is getting complicated. However, if this is indeed the case, then the problem becomes much simpler. The solution would be to find the k largest elements, sum them, and then find a way to split the array into k segments where each of these elements is the maximum of their segment.\n\nBut how to find the splits?\n\nLet me think. For example, take the array [5,4,2,6,5,1,9,2]. The top three elements are 9,6,5. The positions are 7 (9), 4 (6), 1 (5). Wait, but 5 is the first element. So the splits would be:\n\nFirst segment ends at position 1 (5). Second segment ends at position 4 (6). Third segment ends at position 7 (9). The lengths are 1, 3, 4. But that would give the splits [5], [4,2,6,5], [1,9,2]. The maxima are 5, 6, 9. Which is correct. However, the example's solution is [3,2,3], which is different. So there are multiple ways to split, as long as the k largest elements are included as the maxima of their segments.\n\nSo the question is, how to find the splits once we know the k largest elements. But how?\n\nAnother idea: For the k largest elements, we need to ensure that each of them is in a separate segment. To achieve this, we can greedily split the array whenever we encounter one of the k largest elements. For example, we can process the array from left to right, and whenever we encounter one of the k largest elements, we make a split here. However, we have to make sure that exactly k splits are made.\n\nBut how to do this?\n\nAlternatively, the splits can be determined by the positions of the k largest elements. For example, the first split is after the first occurrence of the largest element, the second split after the first occurrence of the second largest element after that, etc.\n\nBut how to find this?\n\nLet me think of an algorithm:\n\n1. Find the k largest elements in the array. Let's say they are stored in a list called 'top_elements'.\n\nBut wait, if there are duplicates, like multiple elements with the same value. For example, if the array is [5,5,5], and k=2. The top two elements are both 5. So, we can split into [5], [5,5], sum 5+5=10.\n\nBut how to find the positions of the elements to split.\n\nAnother approach: We can collect all the elements, sort them in descending order, take the first k elements, then find the positions of these elements in the array. However, if there are duplicates, we need to take exactly k elements. For example, if there are m elements equal to the k-th largest element, we need to select enough of them.\n\nBut this may not be straightforward. However, perhaps we can proceed as follows:\n\nOnce we have the k largest elements, we can collect their indices in the array. Then, we can split the array into segments such that each of these indices is the end of a segment. For example, the first segment ends at the first occurrence of the first largest element, the second segment ends at the first occurrence of the second largest element after that, etc.\n\nBut how to handle the order.\n\nLet me think with the first example. The k=3 largest elements are 9,6,5. Their positions are 7,4,1. But in order, the positions are 1,4,7. So the splits would be after position 1 (length 1), then after position 4 (length 4-1=3?), then after position 7 (length 7-4=3). So the splits are [1], [4-1=3 elements], [7-4=3 elements]. Wait, but the total length would be 1+3+3=7, but the array is of length 8. Oh, perhaps I'm misunderstanding the indices.\n\nWait, the array is 0-based or 1-based? In the problem statement, the array is given as a_1, a_2,..., a_n. So the positions are 1-based. So for the example, the positions of the top elements are 1 (5), 4 (6), 7 (9). So to split into three segments:\n\nFirst segment ends at position 1 (length 1).\n\nSecond segment ends at position 4 (length 4 - 1 = 3 elements: positions 2,3,4).\n\nThird segment ends at position 7 (length 7 - 4 = 3 elements: positions 5,6,7).\n\nBut the remaining element is position 8 (value 2). Oh, but that's not accounted for. So this approach is not correct. Because the total number of elements would be 1+3+3=7, but the array has 8 elements. So what's wrong here?\n\nAh, because the third segment ends at position 7, and the fourth element is position 8. So we need to include it in the third segment. So the third segment would be from position 5 to 8, which is 4 elements. But the maximum of that segment is 9, which is the maximum. So the splits would be:\n\n[1], [2-4], [5-8]. The lengths are 1,3,4. Which gives the sum 5+6+9=20. Which is correct.\n\nSo the problem is that the splits are determined by the positions of the top k elements, but we need to include all elements after the last split.\n\nSo the way to do this is:\n\n- Collect the positions of the k largest elements. Let's call them positions pos_1, pos_2, ..., pos_k, sorted in increasing order.\n\n- Then, the splits are made after pos_1, pos_2, ..., pos_{k-1}, and the last split is after pos_k. However, the last segment includes all elements from pos_k to the end.\n\nBut how to find these positions.\n\nBut how to collect the positions. For example, if there are multiple elements with the same value as the k-th largest, we need to select exactly k elements. For example, if the array is [5,5,5], and k=2, then the two largest elements are the first two 5s. So the positions would be 1 and 2. The splits would be [1], [2,3], which gives maxima 5 and 5.\n\nSo the steps would be:\n\n1. Find the k largest elements in the array.\n\n2. Collect their positions in the array, sorted in increasing order.\n\n3. Split the array into k segments where the first segment ends at pos_1, the second ends at pos_2, etc., and the last segment ends at the end of the array.\n\nBut how to find the k largest elements, considering that there may be duplicates.\n\nSo, for example, if the array is [5,4,2,6,5,1,9,2], the sorted list of elements in descending order is [9,6,5,5,4,2,2,1]. So the top 3 are 9,6,5. But there are two 5's. So how do we choose which ones to take?\n\nWe need to take the first k elements when sorted in descending order, but in case of duplicates, we need to choose the earliest possible positions? Or not?\n\nBut regardless of which positions we choose, as long as they are among the k largest elements, the sum will be the same. However, the splits may vary, but any valid split is acceptable.\n\nSo to find the positions, perhaps we can take the first k elements in the sorted list, and collect their positions. But if there are duplicates, we need to make sure that we take exactly k elements. For example, if the array has more than k elements with the same value as the k-th largest, we can pick any k of them.\n\nBut how to implement this?\n\nOne way is to collect all elements with their indices, sort them in descending order, and take the first k elements. Then, sort these k elements by their indices. Then, the splits are made after each of these indices, except for the last one, which is the end of the array.\n\nWait, let's take the first example again. The sorted elements with indices:\n\n(9,7), (6,4), (5,1), (5,5), (4,2), (2,3), (2,8), (1,6). So the first three are (9,7), (6,4), (5,1). When sorted by indices, they are 1,4,7. So the splits are after 1, after 4, and the rest. So the splits are:\n\nDay 1: 1 element (indices 1).\n\nDay 2: indices 2-4 (elements 4,2,6) → max is 6.\n\nDay 3: indices 5-8 (elements 5,1,9,2) → max is 9. Which gives the correct sum.\n\nBut in this case, the third element in the top k is 5 (index 1), which is the first element. But the day 3's segment includes index 5 (which has value 5), but the maximum of that segment is 9, which is part of the top k elements.\n\nSo the splits are determined by the positions of the top k elements, but they are sorted in increasing order. Then, the splits are made after each of these positions. However, the last split is not needed, since the last segment goes until the end of the array.\n\nWait, but for the k splits, there are k-1 split points. So for example, if the positions are p_1 < p_2 < ... < p_k, then the splits are:\n\nFirst segment ends at p_1.\n\nSecond segment ends at p_2.\n\n...\n\nk-th segment ends at the end of the array.\n\nThus, the lengths are:\n\nt_1 = p_1 - 0 (since the first day starts at 1, ends at p_1. So length p_1).\n\nt_2 = p_2 - p_1.\n\nt_3 = p_3 - p_2.\n\n...\n\nt_k = n - p_{k-1}.\n\nBut this would require that the positions p_1, p_2, ..., p_k are chosen such that they are in increasing order, and the first k elements are the top k.\n\nBut how to collect these positions.\n\nSo the plan is:\n\n- Create a list of (value, index) pairs for all elements.\n\n- Sort this list in descending order of value, then ascending order of index (to handle duplicates properly).\n\n- Take the first k elements from this list.\n\n- Extract their indices and sort them in increasing order.\n\n- Then, the splits are made at these indices.\n\nBut how to handle cases where the same index is selected multiple times. For example, if there are multiple elements with the same value. But since the first k elements are selected, and their indices are sorted, this should not be a problem.\n\nOnce we have the sorted list of indices, we can compute the t_j's.\n\nFor example, for the first example:\n\nsorted_indices = [1,4,7]\n\nt_1 = 1\n\nt_2 = 4-1=3\n\nt_3 = 8-4=4 → but the sample output is [3,2,3]. So this approach would produce a different split, but the sum is the same. However, the sample output is also acceptable.\n\nBut the problem allows any valid split that achieves the maximum sum. So this approach would work.\n\nBut what about the third example: [1,2000,2000,2], k=2. The top two elements are 2000 and 2000. Their indices are 2 and 3. When sorted, they are [2,3]. So the splits would be:\n\nt_1 = 2 (indices 1-2), t_2 = 4-2=2 (indices 3-4). Which gives the split [2,2], which is the sample's answer. Which is correct.\n\nAnother example: [5,1,5,1], k=2. The top two elements are 5 and 5. Their indices are 1 and 3. Sorted, [1,3]. So splits are t_1=1, t_2=4-1=3. The segments are [5], [1,5,1], sum 5+5=10. Which is correct.\n\nBut what if the array is [5, 5, 5], k=2. The top two elements are 5 and 5. Indices 1 and 2. Sorted. So splits are t_1=1, t_2=3-1=2. Segments [5], [5,5]. Sum 5+5=10. Correct.\n\nSo this approach seems to work.\n\nBut how to implement this?\n\nLet me outline the steps for the code:\n\n1. Read n and k.\n\n2. Read the array a as a list.\n\n3. Create a list of tuples (value, index) for each element. Note that indices are 1-based here.\n\n4. Sort this list in descending order of value, and for ties, ascending order of index. This ensures that when values are equal, the earlier indices come first. This is important to avoid selecting the same index multiple times (but since we take the first k elements, and the indices are unique, this is not a problem).\n\n5. Take the first k elements from this sorted list. These are the top k elements.\n\n6. Extract their indices and sort them in increasing order. Let's call this list 'positions'.\n\n7. Now, generate the t_j's:\n\n   - The first t_1 is positions[0].\n\n   - For j from 1 to k-1: t_j = positions[j] - positions[j-1].\n\n   - The last t_k is n - positions[k-1].\n\nWait, no. Let's think:\n\npositions is a list of sorted indices. For example, in the first example, positions is [1,4,7].\n\nThe first segment is from 1 to 1 (length 1).\n\nThe second segment is from ",
    "response": "To solve this problem, we need to maximize the total profit Polycarp can achieve by solving problems over exactly `k` days. Each day, he must solve a contiguous sequence of problems starting from the beginning of the list. The profit for each day is determined by the maximum difficulty of the problems solved that day. Our goal is to find the optimal distribution of problems across the days to maximize this total profit.\n\n### Approach\n1. **Identify Top k Elements**: The maximum total profit can be achieved by ensuring each day's segment includes one of the top `k` elements in terms of difficulty. This is because the maximum value in any segment will contribute directly to the total profit.\n2. **Determine Positions**: Collect the positions of these top `k` elements. Sorting these positions allows us to determine where to split the array to ensure each of these top elements is the maximum in its respective segment.\n3. **Calculate Segments**: Using the sorted positions of the top `k` elements, we can compute the lengths of each segment such that each segment ends at one of these positions, ensuring the maximum value in each segment is one of the top `k` elements.\n\n### Solution Code\n```python\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    k = int(input[idx])\n    idx += 1\n    a = list(map(int, input[idx:idx + n]))\n    \n    # Create list of (value, index) pairs (1-based index)\n    elements = [(a[i], i + 1) for i in range(n)]\n    \n    # Sort by descending value, then ascending index\n    elements.sort(key=lambda x: (-x[0], x[1]))\n    \n    # Take first k elements\n    top_k = elements[:k]\n    \n    # Extract their indices and sort them\n    positions = sorted([pos for (val, pos) in top_k])\n    \n    # Compute the t array\n    t = []\n    prev = 0\n    for pos in positions:\n        t.append(pos - prev)\n        prev = pos\n    # Add the last segment\n    t[-1] = n - positions[-1] + t[-1]\n    \n    # Wait, no. Let's recompute properly:\n    # Reset prev to 0\n    prev = 0\n    t = []\n    for pos in positions:\n        t.append(pos - prev)\n        prev = pos\n    # The last segment is from prev to end\n    t[-1] = n - prev + t[-1]\n    \n    # Wait, no. Correct calculation:\n    # After processing all positions, the last segment is from positions[-1] to n\n    # So the last segment length is n - positions[-1]\n    # But the previous code was incorrect. Let's redo:\n    prev = 0\n    t = []\n    for pos in positions:\n        t.append(pos - prev)\n        prev = pos\n    # Now, the last segment is from prev to n\n    t[-1] = n - prev\n    # Wait no. The first segment is from 0 to positions[0], which is length positions[0]\n    # Then between positions[i-1] and positions[i], the length is positions[i] - positions[i-1]\n    # Finally, the last segment is from positions[-1] to n, which is n - positions[-1]\n    # So the code should be:\n    prev = 0\n    t = []\n    for pos in positions:\n        t.append(pos - prev)\n        prev = pos\n    # Replace the last element with n - prev\n    if len(t) > 0:\n        t[-1] = n - prev\n    \n    print(sum(val for (val, _) in top_k))\n    print(' '.join(map(str, t)))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into the number of problems `n`, the number of days `k`, and the list of problem difficulties.\n2. **Identifying Top Elements**: We create a list of tuples containing each problem's difficulty and its 1-based index. This list is sorted in descending order of difficulty, ensuring that the top `k` elements are selected.\n3. **Calculating Segments**: The positions of these top `k` elements are extracted and sorted. Using these positions, we determine the lengths of each segment such that each segment ends at one of these positions, ensuring the maximum value in each segment is one of the top `k` elements.\n4. **Output**: The sum of the top `k` elements is printed as the maximum total profit, followed by the lengths of each segment that achieves this profit.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    k = int(input[idx])\n    idx += 1\n    a = list(map(int, input[idx:idx + n]))\n    \n    # Create list of (value, index) pairs (1-based index)\n    elements = [(a[i], i + 1) for i in range(n)]\n    \n    # Sort by descending value, then ascending index\n    elements.sort(key=lambda x: (-x[0], x[1]))\n    \n    # Take first k elements\n    top_k = elements[:k]\n    \n    # Extract their indices and sort them\n    positions = sorted([pos for (val, pos) in top_k])\n    \n    # Compute the t array\n    t = []\n    prev = 0\n    for pos in positions:\n        t.append(pos - prev)\n        prev = pos\n    # Add the last segment\n    t[-1] = n - positions[-1] + t[-1]\n    \n    # Wait, no. Let's recompute properly:\n    # Reset prev to 0\n    prev = 0\n    t = []\n    for pos in positions:\n        t.append(pos - prev)\n        prev = pos\n    # The last segment is from prev to end\n    t[-1] = n - prev + t[-1]\n    \n    # Wait, no. Correct calculation:\n    # After processing all positions, the last segment is from positions[-1] to n\n    # So the last segment length is n - positions[-1]\n    # But the previous code was incorrect. Let's redo:\n    prev = 0\n    t = []\n    for pos in positions:\n        t.append(pos - prev)\n        prev = pos\n    # Now, the last segment is from prev to n\n    t[-1] = n - prev\n    # Wait no. The first segment is from 0 to positions[0], which is length positions[0]\n    # Then between positions[i-1] and positions[i], the length is positions[i] - positions[i-1]\n    # Finally, the last segment is from positions[-1] to n, which is n - positions[-1]\n    # So the code should be:\n    prev = 0\n    t = []\n    for pos in positions:\n        t.append(pos - prev)\n        prev = pos\n    # Replace the last element with n - prev\n    if len(t) > 0:\n        t[-1] = n - prev\n    \n    print(sum(val for (val, _) in top_k))\n    print(' '.join(map(str, t)))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 927,
        "completion_token_count": 1009,
        "thoughts_token_count": 8192
    }
}