{
    "start": 1758309542.9497583,
    "end": 1758309760.0642958,
    "start-formatted": "2025-09-20 04:19 KST",
    "end-formatted": "2025-09-20 04:22 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 1,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\nOkay, I need to solve this problem where I have to find the minimum number of edges to add to a graph to form an odd-length cycle, and also count the number of ways to do that. Let's think about how to approach this.\n\nFirst, let's understand the problem. A simple cycle of odd length with each vertex appearing once. So, the cycle must be an odd-length cycle. The question is about adding the least number of edges possible to create such a cycle. Also, count the number of ways to add exactly that number of edges.\n\nHmm. Wait, what's the minimum t? Let's think about the possible scenarios.\n\nIf the graph already contains an odd-length cycle, then t is 0, and w is 1? Or maybe not. Because the problem says that the existing graph might not have any such cycles. So first, we need to check if the graph already has an odd-length cycle. If yes, then t is 0 and w is 1? Or maybe there are multiple ways to form such cycles, but the problem says that the answer is the number of ways to add t edges. But in this case, since the graph already has such a cycle, adding zero edges would be the way. However, the problem says that the existing graph may not have such a cycle. So the first thing is to check whether the graph has any odd-length cycles. If it does, then t is zero and w is 1? Or wait, no. Because the problem says that the existing graph may not have such a cycle. But how do we determine if the graph already has an odd-length cycle?\n\nWait, the problem requires that after adding edges, the graph has a cycle of odd length. But if the original graph already has such a cycle, then t is zero and w is 1? Or perhaps the count of ways is the number of such existing cycles? No, because the problem says that the answer is the number of ways to add t edges. Since t is zero, the way is to not add any edges. But how many such ways are there? Well, there's only one way: not adding any edges. But that seems incorrect. Because the problem says that the existing graph may have multiple odd-length cycles. However, the problem requires that the answer is the number of ways to add t edges. Since t is zero, the way is to not add any edges. However, the question is about forming a cycle of odd length. But if the graph already has such a cycle, then there's at least one such cycle. However, the problem says that the answer for w is the number of ways to add exactly t edges (which is zero) to form such a cycle. But since adding zero edges, the existing cycles are already there. However, the problem says that the answer is the number of ways to add t edges. So if the graph already has an odd-length cycle, then the answer is t=0 and w=1? Or maybe the count is the number of possible such cycles? But the problem says that two ways are considered equal if they have the same set of added edges. So when t=0, the number of ways is 1, because you don't add any edges. But even if there are multiple existing cycles, the way is to not add any edges. So the answer would be t=0 and w=1. But that's not correct according to the sample input.\n\nWait, looking at the sample input:\n\nIn the second example, input is 3 3 with edges forming a triangle. The output is 0 1. Which makes sense. Because the graph already has a cycle of length 3 (odd), so t is 0 and w is 1. So that seems to fit.\n\nSo, the first step is to check if the graph already has an odd-length cycle. If it does, then t=0 and w=1.\n\nBut how do we check if the graph has an odd-length cycle? Well, a graph is bipartite if and only if it doesn't have any odd-length cycles. So if the graph is bipartite, then there are no odd-length cycles. Otherwise, there is at least one.\n\nSo, the problem reduces to:\n\nIf the graph is bipartite, then we need to find the minimum number of edges to add to make it non-bipartite (i.e., introduce an odd-length cycle). Otherwise, the answer is t=0 and w=1.\n\nSo, the first thing is to check if the graph is bipartite. If it's not bipartite, then output t=0 and w=1.\n\nBut if it is bipartite, then we need to find the minimal t and the number of ways to add t edges.\n\nNow, the problem is to find the minimal t when the graph is bipartite.\n\nWhat's the minimal number of edges to add to create an odd-length cycle?\n\nLet me think. Since",
    "response": "To solve this problem, we need to determine the minimum number of edges to add to a given undirected graph to form an odd-length cycle and count the number of ways to achieve this. The solution involves checking if the graph is bipartite and then determining the necessary edges to introduce an odd-length cycle if it is.\n\n### Approach\n1. **Check for Bipartiteness**: A graph is bipartite if it can be colored using two colors such that no two adjacent vertices share the same color. If a graph is not bipartite, it already contains an odd-length cycle.\n2. **Bipartite Graph Handling**: If the graph is bipartite, we need to determine the minimum number of edges to add to create an odd-length cycle. This can be done by finding the smallest connected component with the most vertices in one partition (as per bipartition), and adding an edge between two vertices in the same partition.\n3. **Count Ways**: The number of ways to add these edges is determined by the product of combinations of vertices from the largest partition in each connected component.\n\n### Solution Code\n```python\nimport sys\nimport threading\nfrom collections import deque\n\ndef main():\n    sys.setrecursionlimit(1 << 25)\n    n, m = map(int, sys.stdin.readline().split())\n    edges = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        edges[u-1].append(v-1)\n        edges[v-1].append(u-1)\n\n    is_bipartite = True\n    color = [-1] * n\n    components = []\n    for start in range(n):\n        if color[start] == -1:\n            queue = deque()\n            queue.append(start)\n            color[start] = 0\n            cnt0 = 1\n            cnt1 = 0\n            while queue:\n                u = queue.popleft()\n                for v in edges[u]:\n                    if color[v] == -1:\n                        color[v] = color[u] ^ 1\n                        if color[v] == 0:\n                            cnt0 += 1\n                        else:\n                            cnt1 += 1\n                        queue.append(v)\n                    else:\n                        if color[v] == color[u]:\n                            is_bipartite = False\n            components.append((cnt0, cnt1))\n\n    if not is_bipartite:\n        print(\"0 1\")\n        return\n\n    min_t = float('inf')\n    ways = 0\n    for (a, b) in components:\n        if a == 0 or b == 0:\n            continue\n        size = min(a, b)\n        if size > 0:\n            if min_t > 1:\n                min_t = 1\n                ways = 0\n            if min_t == 1:\n                ways += a * b\n        else:\n            if min_t > 2:\n                min_t = 2\n                ways = 0\n            if min_t == 2:\n                ways += (a + b) * (a + b - 1) // 2\n\n    if min_t == float('inf'):\n        # All components are trees or isolated nodes\n        # Need to connect three nodes\n        min_t = 3\n        ways = 1\n    elif min_t == 1:\n        pass\n    elif min_t == 2:\n        pass\n\n    print(f\"{min_t} {ways}\")\n\nthreading.Thread(target=main).start()\n```\n\n### Explanation\n1. **Bipartite Check**: The graph is checked for bipartiteness using BFS. If any component is not bipartite, it already contains an odd-length cycle.\n2. **Component Analysis**: For each connected component, we count the number of vertices in each partition of the bipartition.\n3. **Edge Calculation**: If the graph is bipartite, the minimum number of edges required to form an odd-length cycle is determined by the smallest number of vertices in either partition of any component. The number of ways to add these edges is calculated based on the product of the sizes of the partitions in each component.\n\nThis approach ensures that we efficiently determine the minimal edges needed and count the valid ways to add them, leveraging properties of bipartite graphs and their components.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport threading\nfrom collections import deque\n\ndef main():\n    sys.setrecursionlimit(1 << 25)\n    n, m = map(int, sys.stdin.readline().split())\n    edges = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        edges[u-1].append(v-1)\n        edges[v-1].append(u-1)\n\n    is_bipartite = True\n    color = [-1] * n\n    components = []\n    for start in range(n):\n        if color[start] == -1:\n            queue = deque()\n            queue.append(start)\n            color[start] = 0\n            cnt0 = 1\n            cnt1 = 0\n            while queue:\n                u = queue.popleft()\n                for v in edges[u]:\n                    if color[v] == -1:\n                        color[v] = color[u] ^ 1\n                        if color[v] == 0:\n                            cnt0 += 1\n                        else:\n                            cnt1 += 1\n                        queue.append(v)\n                    else:\n                        if color[v] == color[u]:\n                            is_bipartite = False\n            components.append((cnt0, cnt1))\n\n    if not is_bipartite:\n        print(\"0 1\")\n        return\n\n    min_t = float('inf')\n    ways = 0\n    for (a, b) in components:\n        if a == 0 or b == 0:\n            continue\n        size = min(a, b)\n        if size > 0:\n            if min_t > 1:\n                min_t = 1\n                ways = 0\n            if min_t == 1:\n                ways += a * b\n        else:\n            if min_t > 2:\n                min_t = 2\n                ways = 0\n            if min_t == 2:\n                ways += (a + b) * (a + b - 1) // 2\n\n    if min_t == float('inf'):\n        # All components are trees or isolated nodes\n        # Need to connect three nodes\n        min_t = 3\n        ways = 1\n    elif min_t == 1:\n        pass\n    elif min_t == 2:\n        pass\n\n    print(f\"{min_t} {ways}\")\n\nthreading.Thread(target=main).start()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 578,
        "completion_token_count": 905,
        "thoughts_token_count": 1024
    }
}