{
    "start": 1758023804.3973026,
    "end": 1758026626.462273,
    "start-formatted": "2025-09-16 20:56 KST",
    "end-formatted": "2025-09-16 21:43 KST",
    "gpu": 2,
    "pid": 9,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Selling Souvenirs\n\nAfter several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.This morning, as usual, Petya will come to the market. Petya has n different souvenirs to sell; ith souvenir is characterised by its weight wi and cost ci. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than m, and total cost is maximum possible.Help Petya to determine maximum possible total cost.\n\n## Input\nThe first line contains two integers n and m (1 ≤ n ≤ 100000, 1 ≤ m ≤ 300000) — the number of Petya's souvenirs and total weight that he can carry to the market.Then n lines follow. ith line contains two integers wi and ci (1 ≤ wi ≤ 3, 1 ≤ ci ≤ 109) — the weight and the cost of ith souvenir.\n\n## Output\nPrint one number — maximum possible total cost of souvenirs that Petya can carry to the market.\n\n## Example\n### Input\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\n### Output\n['0', '3', '10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\nOkay, let's see. I need to solve this problem where Petya wants to maximize the total cost of souvenirs he can carry, given that each souvenir has a weight (either 1, 2, or 3) and a cost. The constraints are n up to 1e5 and m up to 3e5. So a standard knapsack approach won't work here because the m is too big for O(nm) time.\n\nHmm. Since the weights are limited to 1, 2, 3, maybe there's a way to handle each weight category separately and combine them optimally. Let me think about that.\n\nLet me break it down. For each weight category (1, 2, 3), I can sort the items in descending order of cost. Then, for each category, I can precompute the prefix sums. That way, for any number of items taken from that category, I can quickly get the total cost.\n\nBut how do I combine these three categories optimally?\n\nLet me think. Suppose I have x items of weight 1, y items of weight 2, z items of weight 3. The total weight is x*1 + y*2 + z*3 ≤ m. I need to maximize the sum of their costs.\n\nBut considering all possible combinations of x, y, z would be too slow. So perhaps I can iterate over one of the variables and compute the others optimally.\n\nFor example, since the weight 3 items are the heaviest, maybe for each possible number of weight 3 items (up to m//3), I can compute the best combination of weight 1 and 2 items for the remaining weight. But even that might be expensive if done naively.\n\nWait, but the maximum number of weight 3 items is m//3, which for m=3e5 is about 1e5. So if I can process each possible count of weight 3 items, then for each such count, compute the optimal combination of weight 1 and 2 items for the remaining weight, that could be feasible.\n\nBut how to compute the optimal combination of weight 1 and 2 items given a certain capacity?\n\nLet me think about the weight 1 and 2 items. Suppose I have a total capacity of W. How do I choose the number of weight 1 and 2 items to maximize the cost?\n\nLet me denote:\n\nFor weight 1 items, I have a sorted list (descending) with prefix sums. Similarly for weight 2 items.\n\nSuppose I take k items of weight 2. Then the remaining weight is W - 2k. But since each weight 1 item takes 1 unit, I can take min(remaining weight, number of weight 1 items) items. However, since we want maximum cost, we should take as many as possible of the highest value items.\n\nBut how to find the optimal k for the weight 2 items?\n\nAlternatively, for each possible number of weight 2 items, we can compute the maximum number of weight 1 items that fit into the remaining weight. But again, trying all possible k for weight 2 may be O(W) per step, which could be expensive.\n\nBut here's an idea: For the weight 1 and 2 items, we can precompute their prefix sums. Then, for a given total capacity W, the optimal selection can be found by considering taking some number of weight 2 items, and then filling the rest with weight 1 items.\n\nBut how to find the best combination?\n\nLet me think of it as follows. Let's say we have a total capacity of W. Let me denote:\n\n- For weight 2 items, we can take up to t items, where t is min( (W)//2, len(weight2) ). For each possible t, we take t items of weight 2, and then use the remaining W - 2t weight to take as many weight 1 items as possible.\n\nBut since t can be up to (W//2), which for W up to 3e5 could be 1.5e5, and if we do this for each possible t, it would be O(W) per step. However, if we have to do this for each possible count of weight 3 items, that could be O( (m/3) * (m/2) ) = O(m²) which is not feasible for m=3e5.\n\nSo this approach isn't efficient enough. Need a better way.\n\nAlternative idea: For the weight 1 and 2 items, for a given capacity W, we can find the optimal combination of weight 1 and 2 items in O(1) or O(1) per step after some pre-processing.\n\nLet me think about the following. For the weight 2 items, since they are sorted in descending order of cost, the prefix sum array for weight 2 is S2[i] = sum of first i items. Similarly for weight 1 items, S1[i] = sum of first i items.\n\nNow, for a given capacity W, the maximum number of weight 2 items we can take is min( len2, W//2 ), where len2 is the number of weight 2 items. Let's call this max_t. Then, for each possible t from 0 to max_t, the remaining weight is W - 2t. The maximum number of weight 1 items we can take is min( len1, W - 2t ). So the total cost is S2[t] + S1[ min( len1, W - 2t ) ].\n\nBut to find the maximum over all t in 0..max_t, how can we do this efficiently?\n\nIf we can find the optimal t in O(1) or O(log n) time, that would be great.\n\nBut how?\n\nLet me think of the function f(t) = S2[t] + S1[ min( len1, W - 2t ) ]\n\nWe need to find the t that maximizes this function.\n\nBut since S2 is non-decreasing (since the items are sorted in descending order and we take the first t items), and S1 is also non-decreasing. However, as t increases, the term W - 2t decreases, so the S1 term may decrease. So the function f(t) is not necessarily monotonic. So we can't just take the maximum t or something like that.\n\nBut perhaps there's a way to find the optimal t using binary search or some other method.\n\nAlternatively, for a given W, the optimal t is somewhere around (W - s)/2, where s is the number of weight 1 items taken. Not sure.\n\nAlternatively, since the maximum possible t is up to W//2, but for each W, perhaps we can consider that the optimal t is either floor((W - k)/2) for some k, or something like that.\n\nAlternatively, since the weight 1 items are sorted, and the weight 2 items are sorted, perhaps the optimal t is such that when we take t weight 2 items, the remaining weight allows taking as many weight 1 items as possible. But how to find that t?\n\nAnother idea: For a given W, the optimal choice between taking weight 2 items and weight 1 items depends on their value per weight. However, since the items are sorted, we can't just compare per unit value because the items are in groups.\n\nBut perhaps for the weight 2 items, the best way to take as many as possible, but when there's leftover space, we can fill with weight 1 items. However, sometimes, taking one less weight 2 item allows us to take more weight 1 items which might have higher total value.\n\nBut how to find that optimal point?\n\nLet me think of an example. Suppose W is 5. Suppose we have two weight 2 items with values 5 and 4. And weight 1 items with values 3, 3, 3.\n\nIf we take 2 weight 2 items (total weight 4), then we have 1 left for weight 1. Total value is 5+4+3=12.\n\nIf we take 1 weight 2 item (value 5), then 5-2=3 weight left. Take 3 weight 1 items (3*3=9). Total is 5+9=14, which is better.\n\nSo here, taking fewer weight 2 items gives a better result.\n\nThis suggests that we can't just take as many weight 2 items as possible. Hence, the optimal t is somewhere in the range.\n\nBut how to find it quickly?\n\nAn alternative approach is to note that for the weight 1 and 2 items, the optimal selection can be found by considering all possible numbers of weight 2 items up to some limit, but since the number of weight 2 items is up to 1.5e5, and for each possible number of weight 3 items (up to 1e5), this would be O( (1.5e5) * (1e5) ) = 1.5e10 operations, which is way too slow.\n\nSo this approach is not feasible.\n\nWe need a smarter way.\n\nAnother thought: Since the weight of the items is small (only 1, 2, 3), perhaps we can model the problem by grouping the items by their weight and then using a dynamic programming approach tailored to the small weights.\n\nBut even with that, the standard DP approach for knapsack is O(nm), which is not feasible here.\n\nWait, but maybe we can use the fact that the weights are small. For example, for each weight group, we can precompute the best possible selection for each possible weight.\n\nLet me think. Let's separate the items into three groups: w1 (weight 1), w2 (weight 2), w3 (weight 3).\n\nSort each group in descending order of cost. Then compute prefix sums for each group.\n\nThen, for the problem, we can try all possible numbers of items taken from the w3 group. Let's say we take k items from w3. Then, the remaining capacity is m - 3*k. We need to select items from w1 and w2 such that their total weight is <= (m - 3k). How to compute that?\n\nBut how to compute the maximum value for the remaining capacity (call it rem = m - 3k) using the w1 and w2 items?\n\nIf we can compute that quickly, then for each possible k, we can calculate the total value as sum_w3[k] + max_value(rem) for w1 and w2.\n\nThe key is to compute max_value(rem) quickly.\n\nSo how to compute max_value(rem) for the w1 and w2 items?\n\nLet me think again about this part. Let's suppose that we have a capacity of rem. How to select items from w1 and w2 to maximize the value.\n\nLet me denote:\n\nLet a be the number of w2 items taken, and b be the number of w1 items taken. Then 2a + b <= rem. We need to maximize S2[a] + S1[b].\n\nBut how to find the optimal a and b for given rem?\n\nLet me think of this as follows. For each possible a (number of w2 items), the maximum b is min( len1, rem - 2a ). So for each a, the total is S2[a] + S1[ min(len1, rem - 2a) ].\n\nThe question is, how to find the maximum of this over all possible a (from 0 to min( len2, rem//2 )).\n\nBut for each rem, this could be O(len2) time, which could be O(1e5) for each k. And if k ranges up to m//3 (say 1e5), then total time would be O(1e10), which is not feasible.\n\nSo we need a way to compute this maximum for a given rem in O(1) or O(log n) time.\n\nAlternative idea: For each possible rem, the optimal a is either the maximum possible, or some value where 2a is as close as possible to rem - b. But how?\n\nAlternatively, since the items are sorted, perhaps for each possible rem, the optimal a can be found by considering that the best a is either the maximum possible a, or a value such that rem - 2a is as large as possible for the number of w1 items.\n\nWait, here's another idea. Let's imagine that we have a certain amount of rem. We can take as many as possible of the best w2 items and then fill the rest with w1 items. But sometimes, taking one less w2 item allows us to take more w1 items which may be better.\n\nBut how to find the optimal balance between a and b?\n\nLet me think of the following approach: For a given rem, the optimal a is in the vicinity of (rem - x)/2, where x is the number of w1 items. But that's too vague.\n\nAlternatively, for each possible rem, the optimal a can be found by considering that for the best a, the value of S2[a] + S1[rem - 2a] is maximized. But since rem - 2a can be negative, we need to cap it at 0.\n\nBut since S2 and S1 are prefix sums, which are non-decreasing, the function f(a) = S2[a] + S1[ min( len1, rem - 2a ) ] is not necessarily monotonic. However, perhaps there's a way to find the optimal a by checking a few candidates around the point where 2a is equal to rem minus the number of w1 items.\n\nAlternatively, here's a trick: For the given rem, the maximum number of w2 items we can take is a_max = min( len2, rem // 2 ). Let's consider that the optimal a is either a_max, a_max - 1, ..., or some other value. But how many candidates do we need to check?\n\nIf we can find that the optimal a is in the range [a_max - K, a_max], where K is a small constant (like 1000), then for each rem, we can check all a in that range, and pick the best. However, this depends on the data.\n\nBut what if the number of w2 items is large, but the rem is small? Well, in that case, a_max would be small.\n\nBut for example, if rem is 1e5, and a_max is 5e4, checking all possible a in that range is O(5e4) per rem, which again is not feasible.\n\nHmm. So perhaps there's a mathematical way to find the optimal a.\n\nLet me think of the following. For a given rem, the optimal a is such that the marginal gain of taking another w2 item is higher than the loss from not being able to take some w1 items.\n\nBut how to model this.\n\nAlternatively, since the w2 items are sorted in descending order, and the w1 items are also sorted in descending order, the best strategy would be to take as many as possible of the most valuable items. However, since the weight of w2 is 2, and w1 is 1, sometimes it's better to take a w1 item instead of a w2 item.\n\nFor example, if a w2 item has value 3, and two w1 items have values 2 and 2. Then taking the two w1 items gives 4, which is better than the w2's 3.\n\nSo, the optimal selection is to take the best combination of w2 and w1 items, possibly taking some of each.\n\nBut how to find this combination quickly.\n\nAnother Idea: For each possible rem, the optimal selection can be determined by considering the best between taking some number of w2 items and filling the rest with w1 items. However, since the w1 and w2 items are sorted, perhaps for a given rem, the optimal a can be found by considering that the best a is the one where 2a is as close as possible to rem - (some value). \n\nBut I'm stuck. Let's look for hints or similar problems.\n\nWait, this problem is similar to the classic unbounded knapsack problem, but with only two item types. However, in our case, the items are limited in quantity (we have a certain number of items for each weight group). So it's the bounded knapsack problem for two item types.\n\nBut even then, how to compute the maximum for two groups quickly.\n\nAnother Idea: Let me think about the problem of combining weight 1 and 2 items. For each possible total weight, we can precompute the maximum value. However, for rem up to 3e5, and with n up to 1e5, this seems challenging.\n\nBut wait, the weight of the items is small. Let me think of this as follows:\n\nFor the weight 1 and 2 items, we can create a DP array where dp[w] is the maximum value achievable with weight w.\n\nBut with rem up to 3e5, and for each possible k (number of weight 3 items), this would be O(m) time for each k, which is again O(m^2) time, which is not feasible.\n\nBut perhaps there's a smarter way. Let me think about the DP approach for the two groups.\n\nThe maximum capacity for the two groups is up to m. For each possible weight, the maximum value can be computed as follows:\n\nInitialize dp[0] = 0.\n\nFor each weight 1 item, we can do for w from m down to 1: dp[w] = max(dp[w], dp[w-1] + c_i).\n\nSimilarly for weight 2 items: for w from m down to 2: dp[w] = max(dp[w], dp[w-2] + c_i).\n\nBut since we have multiple items for each weight, we need to process them in order. However, for n up to 1e5, this would be O(n * m) time, which is not feasible for m up to 3e5.\n\nBut in our case, the items are grouped by their weights. So for the weight 1 items, we can process all of them in a way that takes advantage of their sorted order.\n\nWait! Because the items are sorted in descending order of cost, perhaps we can use a greedy approach for the weight 1 and 2 items. For example, take as many as possible of the highest value items.\n\nBut earlier example shows that this is not always optimal. However, perhaps when combined with the fact that the items are sorted, there's a way to find the optimal selection.\n\nAnother Idea: For the weight 1 items, since they are sorted, the best way to take as many as possible. Similarly for the weight 2 items. But when combining them, the optimal selection is to take as many as possible of the higher value items, regardless of their weight.\n\nBut how to model this.\n\nAlternatively, for the weight 1 and 2 items, the optimal selection for a given capacity is to take all the top items from both groups, but ensuring that their total weight is within the capacity. However, since the items are sorted, this is equivalent to selecting the items with the highest value per unit weight. But since the items are grouped by weight, perhaps we can compare the next available item from each group and take the one with higher value.\n\nThis sounds like a greedy approach. Let's think about it.\n\nFor example, we have a list of weight 1 items sorted descending, and weight 2 items sorted descending. We need to select items from both lists, choosing the next item with higher value per unit weight. However, since the weight 2 items take 2 units, but have higher value than weight 1 items, it's not straightforward.\n\nBut perhaps, we can simulate this process. For example, for the given capacity, we can iterate through the items, comparing the next available weight 1 and weight 2 items and taking whichever gives a better value.\n\nBut how to implement this efficiently.\n\nBut this seems complicated, especially when you have to consider the remaining capacity.\n\nAlternatively, since the weight 1 items are sorted, and the weight 2 items are sorted, perhaps we can find the optimal number of weight 2 items to take by considering that the best choice is to take as many as possible of the weight 2 items, and then fill the remaining with weight 1 items, or vice versa. But again, this might not be optimal.\n\nBut given the time constraints, perhaps the best way is to proceed with the initial idea of iterating over the number of weight 3 items, and for each, compute the optimal for weight 1 and 2 items by checking a limited number of possibilities for the weight 2 items.\n\nLet me think about this. For each possible k (number of weight 3 items taken), the rem is m - 3*k. Now, for the rem, I need to compute the maximum value from weight 1 and 2 items. Let's assume that the weight 2 items are sorted and have prefix sums S2, and weight 1 items are sorted with prefix sums S1.\n\nThe maximum possible number of weight 2 items for this rem is a_max = min( len2, rem // 2 ). Now, the optimal a could be somewhere near a_max, but perhaps we can check a few possibilities around a_max, like a_max, a_max-1, etc., and also check the possibility of taking as many weight 1 items as possible (i.e., a=0).\n\nBut how many possibilities do we need to check?\n\nWell, if I check all possible a from 0 to a_max, that would be O(a_max) per k. Which is not feasible. However, if I can find that for each rem, the optimal a is either the floor( (rem - x)/2 ), where x is the number of weight 1 items taken, but I don't know x.\n\nAlternatively, since the weight 2 items are sorted, the best a is likely to be in the vicinity of the maximum possible a. So perhaps checking a_max, a_max-1, ..., a_max - 1000 (but not less than 0) would cover all possibilities where the optimal a is not too far from a_max. But this is a heuristic, and may not work for all cases.\n\nBut given the time constraints, perhaps this is the only way to proceed.\n\nLet me think about the sample input.\n\nTake the second example:\n\nInput:\n2 2\n1 3\n2 2\n\nSo n=2, m=2.\n\nThe items are weight 1 (cost 3) and weight 2 (cost 2).\n\nThe optimal is to take the weight 1 item, which gives cost 3. If we take the weight 2 item, it's cost 2. So the answer is 3.\n\nIn this case, for rem = 2 (since k=0, no weight 3 items), a_max is 1 (since 2//2=1). So checking a=1 gives 2, and a=0 gives 3. So the maximum is 3. So checking a_max and a_max-1 (but a_max-1 is 0) covers the optimal.\n\nAnother example: rem =5, and the weight 2 items have values [5,4], weight 1 items have [3,3,3]. The optimal a is 1 (taking one weight 2 item and then 3 weight 1 items for total 5+9=14). Here, a_max is 5//2=2. So checking a=2 (which gives 5+4 + 1*3= 5+4+3=12) and a=1 gives 5+9=14. So checking a_max and a_max-1 is sufficient.\n\nSo perhaps, for each rem, checking a_max, a_max-1, a_max-2, ..., down to a_max - 100 (or until 0) would cover the optimal a. Because for larger a_max, the difference between a and a-1 is small, and the optimal a is likely near a_max.\n\nBut how to determine how many steps to check.\n\nAlternatively, for each rem, we can check all possible a values up to the minimum of a_max and some small number, say 300. This would be O(300) per rem. Given that for each k (number of weight 3 items), this is acceptable.\n\nBut why 300? Well, for example, if the weight 2 items are very valuable, then taking as many as possible is better. However, if there are some high-value weight 1 items, then maybe taking a few less weight 2 items allows taking more weight 1 items. But how many?\n\nAssuming that the worst case is that we need to check up to say 300 possibilities, for each rem, this would be manageable.\n\nSo the plan is:\n\n- Preprocess the weight 1, 2, 3 items by sorting each group in descending order of cost, and compute prefix sums.\n\n- For each possible k (number of weight 3 items taken), from 0 to min( len3, m//3 ), compute the remaining capacity rem = m - 3*k.\n\n- For this rem, compute the maximum value from weight 1 and 2 items by checking for a in the range max(0, a_max - 300) to a_max, where a_max is min( len2, rem // 2 ). For each a in this range, compute the corresponding b = min( len1, rem - 2*a ), and the total value is S2[a] + S1[b]. Take the maximum among all these a's.\n\n- Also, check the case where we take all possible weight 1 items and no weight 2 items (a=0), but this is already covered in the range.\n\nThe question is, what value to choose for the number of checks (like 300). Well, given that the weight of the items is small, and the cost is up to 1e9, even a few hundred checks per k would be manageable.\n\nLet me think about the time complexity. Let's say for each k, we check up to 300 possibilities. The maximum number of k is m//3, which for m=3e5 is 1e5. So total operations are 1e5 * 300 = 3e7, which is acceptable for Python.\n\nBut why would this approach work? Because for any optimal a, it must be that the difference between a and a_max is not too large. For example, if the optimal a is a_max - x, then x is small. But how to justify this?\n\nWell, consider that for each a, the value of S2[a] + S1[rem - 2a] can be viewed as the sum of the first a weight 2 items and the first b weight 1 items, where b is rem - 2a. Since the items are sorted, the first a weight 2 items are the best possible for that count, and similarly for the weight 1 items. So, the function is convex or has a single peak, which allows us to find the optimal a by checking a few candidates around a_max.\n\nBut I'm not sure about this. However, given the time constraints, this approach is worth trying.\n\nSo now, the steps for the code:\n\nFirst, read n and m.\n\nThen, read the n items, and group them by their weight (1, 2, 3).\n\nSort each group in descending order of cost.\n\nCompute prefix sums for each group.\n\nFor example, for weight 1:\n\nsorted_w1 = sorted(w1_items, key=lambda x: -x.cost)\n\nprefix_s1[i] = sum of first i items.\n\nSame for w2 and w3.\n\nOnce that is done, for each possible k in 0 to len_w3 (but ensuring 3*k <= m):\n\nrem = m - 3*k.\n\nNow, for rem, compute the best value from w1 and w2.\n\nTo compute this, we find a_max = min( len_w2, rem // 2 )\n\nThen, iterate a from max(0, a_max - 300) to a_max. For each a in this range, compute the corresponding b = min( len_w1, rem - 2*a ), and total value is s2[a] + s1[b]. Keep track of the maximum.\n\nAlso, need to consider cases where rem is negative (but since k is chosen such that 3*k <= m, rem >=0).\n\nOnce the maximum for this k is found, add it to the s3[k] (the sum of the first k weight 3 items), and keep track of the global maximum.\n\nNow, what about the case where rem is negative? No, because k is chosen up to m//3, so rem is >=0.\n\nBut also, for each k, we need to ensure that k doesn't exceed the number of weight 3 items. So len_w3 is the number of items in the weight 3 group. So k can range from 0 to min( len_w3, m//3 ).\n\nNow, the code steps:\n\nImplement this logic.\n\nBut how to handle the prefix sums.\n\nFor example, for the weight 1 group, the prefix sum array would be of size len_w1 + 1, where prefix_s1[0] = 0, prefix_s1[1] = cost of first item, etc.\n\nSame for the other groups.\n\nNow, code outline:\n\nRead n and m.\n\nw1 = []\nw2 = []\nw3 = []\n\nfor _ in range(n):\n    wi, ci = map(int, input().split())\n    if wi == 1:\n        w1.append(ci)\n    elif wi == 2:\n        w2.append(ci)\n    else:\n        w3.append(ci)\n\nSort each list in descending order.\n\nCompute prefix sums for each.\n\ns1 = [0]\nfor c in sorted(w1, reverse=True):\n    s1.append(s1[-1] + c)\n\nSimilarly for s2 and s3.\n\nThen, for each possible k in 0 to min( len(w3), m//3 ):\n\ncurrent_rem = m - 3*k\n\nif current_rem <0: skip (but k is chosen so this doesn't happen)\n\nthen compute max_val for current_rem from w1 and w2.\n\nmax_val = 0\n\na_max = min( len(w2), current_rem // 2 )\n\nstart_a = max(0, a_max - 300)\n\nfor a in range(start_a, a_max + 1):\n\n    remaining_weight = current_rem - 2*a\n\n    b = min( len(w1), remaining_weight )\n\n    current_val = s2[a] + s1[b]\n\n    if current_val > max_val:\n\n        max_val = current_val\n\nThen, total = s3[k] + max_val\n\nCompare to the global maximum.\n\nBut what if the current_rem is negative? Well, since k is chosen such that 3*k <= m, current_rem is m - 3k >=0.\n\nBut also, when a exceeds len(w2), but we have a_max as min(len(w2), ...), so a is up to len(w2).\n\nSo the code for this part.\n\nNow, the question is: what value to choose for the 300? Well, in practice, during testing, we can choose a value like 300, but perhaps even 200 would be sufficient. But how to choose it?\n\nAlternatively, since the maximum possible a_max is up to m//2 (but m is 3e5, which is 1.5e5). Checking all possible a from 0 to a_max would be O(1.5e5) per k, which is not feasible. So the 300 is a heuristic to reduce the number of checks.\n\nBut why would this work?\n\nWell, suppose that the optimal a is a_max - x, where x is small. For example, if taking one less weight 2 item allows taking two more weight 1 items, which may be better. But if the weight 1 items are not very valuable, then it's better to take as many weight 2 items as possible.\n\nBut how to know?\n\nWell, given that the weight 1 and 2 items are sorted, the first few items are the most valuable. So, for example, if a_max is 1000, and the optimal a is 999, then checking a_max and a_max-1 would find it.\n\nBut if the optimal a is much smaller, like a_max - 1000, then this approach would miss it. However, given that the items are sorted, it's unlikely that skipping a lot of weight 2 items would be better, unless the weight 1 items are extremely valuable.\n\nBut how to handle such cases?\n\nFor example, suppose that the weight 2 items have very low value, and the weight 1 items are very high. For instance, weight 2 items have values 1, 1, 1... and weight 1 items have values 1000, 1000, etc. Then, for a rem of 1000, the optimal is to take 1000 weight 1 items (a=0), which is a_max = 500 (since 1000//2=500). So checking a_max - 500 would be needed. But if we only check up to 300 steps back, we would miss it.\n\nSo this approach would fail in this case.\n\nThus, this suggests that the heuristic is not sufficient.\n\nAlternative Idea: Since the weight 1 items are sorted, for any given a, the maximum number of weight 1 items is rem - 2a. So for the optimal a, the value of a is such that the sum of the first a weight 2 items plus the first (rem - 2a) weight 1 items is maximized.\n\nLet me think of this as a function f(a) = s2[a] + s1[ min( len1, rem - 2a ) ].\n\nWe need to find the maximum of this function over a in 0 <= a <= a_max.\n\nBut since s2[a] is non-decreasing and s1[...] is non-decreasing, but the argument to s1 is decreasing as a increases, the function f(a) could have a single maximum, which could be found using ternary search.\n\nWait, is the function f(a) unimodal? If yes, then ternary search can be used to find the maximum.\n\nWhat's a unimodal function? A function that increases to a certain point and then decreases.\n\nBut in our case, is f(a) unimodal?\n\nLet me think of an example. Suppose that rem is 5, and the weight 2 items have values [5, 4], and weight 1 items have values [3,3,3].\n\nThen:\n\na=0 → rem=5 → take 5 weight 1 items (but there are only 3, so 3*3=9 → total 9.\n\na=1 → rem=5-2=3 → take 3 weight 1 items → total 5 +9=14.\n\na=2 → rem=5-4=1 → take 1 weight 1 item → total 5+4+3=12.\n\nSo f(a) increases from a=0 to a=1, then decreases. So it's unimodal.\n\nAnother example: rem=6, weight 2 items [5,4], weight 1 items [3,3,3,3].\n\na=0 → rem=6 → take 6 weight 1 items (but there are 4, sum 12 → total 12.\n\na=1 → rem=4 → take 4 → sum 5 + 12 = 17.\n\na=2 → rem=6-4=2 → take 2 → sum 5+4 + 6 = 15.\n\nSo again, the function increases then decreases.\n\nAnother example where the function may have multiple peaks?\n\nNot sure. Let's think of a case where the function increases, then decreases, then increases again. Is that possible?\n\nLet's say rem=7, weight 2 items have values [4, 4, 3], weight 1 items have values [5,5,5,5].\n\nFor a=0 → rem=7 → take 7 weight 1 items (but there are 4, sum 20 → total 20.\n\na=1 → rem=5 → take 5 → sum 4 + 20 = 24.\n\na=2 → rem=3 → take 3 → sum 8 + 15 = 23.\n\na=3 → rem=1 → sum 4+4+3 = 11 +5 = 16.\n\nSo the function increases to a=1, then decreases. So no multiple peaks.\n\nAnother example: rem=6, weight 2 items [5, 5, 5], weight 1 items [4,4,4,4].\n\na=0 → take 6 weight 1 items (sum 4*4=16) → total 16.\n\na=1 → rem=4 → take 4 → sum 5 + 16 = 21.\n\na=2 → rem=2 → take 2 → sum 10 + 8 = 18.\n\na=3 → rem=0 → sum 15 + 0 = 15.\n\nSo again, increasing then decreasing.\n\nIt seems that the function is unimodal. Thus, we can apply ternary search to find the maximum a in the range [0, a_max].\n\nIf this is true, then for each rem, we can perform a ternary search on a in [0, a_max], and find the optimal a in O(log a_max) time.\n\nThis would be much more efficient than checking a fixed number of candidates.\n\nSo how to implement ternary search here.\n\nTernary search works on functions that are strictly increasing then decreasing (or vice versa). In our case, the function is unimodal, so ternary search can be applied.\n\nThe steps would be:\n\nlow = 0, high = a_max.\n\nWhile low < high:\n\n   mid1 = low + (high - low) // 3\n\n   mid2 = high - (high - low) // 3\n\n   if f(mid1) <",
    "response": "\n\nTo solve this problem, we need to maximize the total cost of souvenirs Petya can carry given a weight constraint. The souvenirs have weights of 1, 2, or 3, and we need an efficient approach due to the constraints on input size.\n\n### Approach\n1. **Group Items by Weight**: Separate the souvenirs into three groups based on their weights (1, 2, and 3).\n2. **Sort and Precompute Prefix Sums**: For each group, sort the items in descending order of cost and compute prefix sums to quickly calculate the maximum cost for any number of items taken from that group.\n3. **Iterate Over Possible Counts of Weight 3 Items**: For each possible number of weight 3 items that can be taken, compute the remaining weight capacity and determine the optimal combination of weight 1 and 2 items using ternary search on the possible counts of weight 2 items.\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n    \n    w1 = []\n    w2 = []\n    w3 = []\n    \n    for _ in range(n):\n        wi = int(input[idx])\n        idx += 1\n        ci = int(input[idx])\n        idx += 1\n        if wi == 1:\n            w1.append(ci)\n        elif wi == 2:\n            w2.append(ci)\n        else:\n            w3.append(ci)\n    \n    # Sort each group in descending order\n    w1.sort(reverse=True)\n    w2.sort(reverse=True)\n    w3.sort(reverse=True)\n    \n    # Compute prefix sums\n    s1 = [0]\n    for c in w1:\n        s1.append(s1[-1] + c)\n    \n    s2 = [0]\n    for c in w2:\n        s2.append(s2[-1] + c)\n    \n    s3 = [0]\n    for c in w3:\n        s3.append(s3[-1] + c)\n    \n    max_total = 0\n    \n    len_w3 = len(w3)\n    max_k = min(len_w3, m // 3)\n    \n    for k in range(0, max_k + 1):\n        rem = m - 3 * k\n        if rem < 0:\n            continue\n        \n        # Now compute max value from w1 and w2 with rem capacity\n        len_w2 = len(w2)\n        a_max = min(len_w2, rem // 2)\n        \n        # Ternary search on a in [0, a_max]\n        def get_value(a):\n            remaining_weight = rem - 2 * a\n            b = min(len(w1), remaining_weight)\n            return s2[a] + s1[b]\n        \n        low = 0\n        high = a_max\n        best = 0\n        while low <= high:\n            if high - low < 3:\n                for a in range(low, high + 1):\n                    current = get_value(a)\n                    if current > best:\n                        best = current\n                break\n            mid1 = low + (high - low) // 3\n            mid2 = high - (high - low) // 3\n            v1 = get_value(mid1)\n            v2 = get_value(mid2)\n            if v1 < v2:\n                low = mid1 + 1\n            else:\n                high = mid2 - 1\n        \n        current_total = s3[k] + best\n        if current_total > max_total:\n            max_total = current_total\n    \n    print(max_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Grouping and Sorting**: We first group the souvenirs by their weights and sort each group in descending order of cost to prioritize higher-value items.\n2. **Prefix Sums**: Prefix sums are computed for each group to quickly determine the total cost for any number of items taken from that group.\n3. **Iterating Over Weight 3 Items**: For each possible count of weight 3 items, we calculate the remaining capacity and use ternary search to find the optimal combination of weight 1 and 2 items that maximizes the total cost within the remaining capacity.\n4. **Ternary Search**: This technique efficiently narrows down the optimal number of weight 2 items to take, leveraging the unimodal nature of the cost function for this sub-problem.\n\nThis approach ensures we efficiently explore all possible combinations while adhering to the constraints, leading to an optimal solution.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n    \n    w1 = []\n    w2 = []\n    w3 = []\n    \n    for _ in range(n):\n        wi = int(input[idx])\n        idx += 1\n        ci = int(input[idx])\n        idx += 1\n        if wi == 1:\n            w1.append(ci)\n        elif wi == 2:\n            w2.append(ci)\n        else:\n            w3.append(ci)\n    \n    # Sort each group in descending order\n    w1.sort(reverse=True)\n    w2.sort(reverse=True)\n    w3.sort(reverse=True)\n    \n    # Compute prefix sums\n    s1 = [0]\n    for c in w1:\n        s1.append(s1[-1] + c)\n    \n    s2 = [0]\n    for c in w2:\n        s2.append(s2[-1] + c)\n    \n    s3 = [0]\n    for c in w3:\n        s3.append(s3[-1] + c)\n    \n    max_total = 0\n    \n    len_w3 = len(w3)\n    max_k = min(len_w3, m // 3)\n    \n    for k in range(0, max_k + 1):\n        rem = m - 3 * k\n        if rem < 0:\n            continue\n        \n        # Now compute max value from w1 and w2 with rem capacity\n        len_w2 = len(w2)\n        a_max = min(len_w2, rem // 2)\n        \n        # Ternary search on a in [0, a_max]\n        def get_value(a):\n            remaining_weight = rem - 2 * a\n            b = min(len(w1), remaining_weight)\n            return s2[a] + s1[b]\n        \n        low = 0\n        high = a_max\n        best = 0\n        while low <= high:\n            if high - low < 3:\n                for a in range(low, high + 1):\n                    current = get_value(a)\n                    if current > best:\n                        best = current\n                break\n            mid1 = low + (high - low) // 3\n            mid2 = high - (high - low) // 3\n            v1 = get_value(mid1)\n            v2 = get_value(mid2)\n            if v1 < v2:\n                low = mid1 + 1\n            else:\n                high = mid2 - 1\n        \n        current_total = s3[k] + best\n        if current_total > max_total:\n            max_total = current_total\n    \n    print(max_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 482,
        "completion_token_count": 988,
        "thoughts_token_count": 8191
    }
}