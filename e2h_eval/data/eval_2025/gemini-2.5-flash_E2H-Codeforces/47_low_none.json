{
    "start": 1758284861.645349,
    "end": 1758284878.2344668,
    "start-formatted": "2025-09-19 21:27 KST",
    "end-formatted": "2025-09-19 21:27 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "**Thinking Through \"Neko Does Maths\"**\n\nOkay, so I need to write a Python script for this \"Neko Does Maths\" problem. The core of it is finding this non-negative integer `k` that minimizes the least common multiple of `a+k` and `b+k`. If there are ties, I should return the smallest `k`.\n\nLet's break this down. Let `x = a+k` and `y = b+k`.  Minimizing the LCM of `x` and `y` is the goal. I know `lcm(x, y) = (x * y) / gcd(x, y)`. The relationship between `x` and `y` is `y - x = b - a`.\n\nNow, if `d` is the greatest common divisor of `x` and `y`, then `d` must also divide their difference, `b - a`. This is key. The GCD of `a+k` and `b+k` has to be a divisor of `diff = abs(b - a)`.\n\nThe easy case is when `a = b`. Then `diff = 0`.  Here, `x = y = a + k`.  The LCM is just `a+k`. To minimize it, I need the smallest `k`, which is `0`. So, if `a = b`, the answer is trivial.\n\nIf `a != b`, things get interesting. I'll need to iterate through the divisors of `diff`.  Let `g` be a divisor of `diff`. I'm saying `g = gcd(a+k, b+k)`.  This means both `a+k` and `b+k` are multiples of `g`.\nSo,  `a+k = g * m1` and `b+k = g * m2`, for some integers `m1` and `m2`.\nThe relationship `(b+k) - (a+k) = diff`  becomes `g * (m2 - m1) = diff`. This means `m2 - m1 = diff / g`.\n\nTo minimize `lcm`, I'll need to figure out how to calculate `k` for each divisor `g`. I need `k >= 0`. I need `a+k` and `b+k` both to be multiples of `g`. I realized that if `a+k` is a multiple of `g` then since `diff` is a multiple of `g`, so is `b+k`.\nSo I only need to ensure `a+k` is a multiple of `g`, or `a+k = 0 (mod g)`.\nThis translates to finding the smallest non-negative `k` such that `k = -a (mod g)`. Which is the same as `k = (g - (a % g)) % g`. I need to calculate this for each `g` and pick the smallest `k`.\n",
    "response": "```python\nimport sys\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef solve():\n    a, b = map(int, sys.stdin.readline().split())\n\n    if a == b:\n        print(0)\n        return\n\n    diff = abs(b - a)\n\n    min_lcm = float('inf')\n    best_k = 0\n\n    # Find divisors of diff\n    divisors = set()\n    for i in range(1, int(diff**0.5) + 1):\n        if diff % i == 0:\n            divisors.add(i)\n            divisors.add(diff // i)\n\n    for g in sorted(list(divisors)): # Sort divisors to find smallest k first for ties\n        # We need a+k to be a multiple of g.\n        # k = -a (mod g)\n        # Smallest non-negative k is (g - (a % g)) % g\n        current_k = (g - (a % g)) % g\n\n        val_a_plus_k = a + current_k\n        val_b_plus_k = b + current_k\n        \n        # Calculate LCM: lcm(x, y) = (x * y) / gcd(x, y)\n        # To avoid overflow with (x*y) for large x,y, we can use (x // gcd(x,y)) * y\n        # Or check if intermediate products exceed max_int if needed, but python handles large ints.\n        current_lcm = (val_a_plus_k // gcd(val_a_plus_k, val_b_plus_k)) * val_b_plus_k\n\n        if current_lcm < min_lcm:\n            min_lcm = current_lcm\n            best_k = current_k\n        elif current_lcm == min_lcm:\n            # If LCMs are equal, choose the smaller k.\n            # Since we iterate through divisors in increasing order,\n            # and for each g, we find the smallest possible k,\n            # if we encounter an equal LCM, current_k will be larger than previous best_k (or equal if same g).\n            # So, we only update if current_k is smaller, which won't happen if g is increasing.\n            # The problem states \"if there are multiple optimal integers k, he needs to choose the smallest one.\"\n            # This logic implicitly handles that: if we found a minimum_lcm with k_1, and later find\n            # the same minimum_lcm with k_2, we keep k_1 if k_1 < k_2.\n            # Since we iterate through g, and for each g, current_k is unique, if g increases, current_k will also generally increase.\n            # So if current_lcm == min_lcm, current_k will be >= best_k.\n            # Thus, we only update if current_k < best_k, but that implies current_lcm must be strictly smaller.\n            # So, the 'elif' branch is effectively not needed for choosing the smallest k,\n            # as the first k that achieves min_lcm will be the smallest.\n            # However, if we iterate through divisors in a non-sorted manner, this would be important.\n            # With `sorted(list(divisors))`, the first `g` that yields `min_lcm` will also yield the smallest `k`.\n            pass # No need to update best_k if current_lcm == min_lcm\n\n    print(best_k)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef solve():\n    a, b = map(int, sys.stdin.readline().split())\n\n    if a == b:\n        print(0)\n        return\n\n    diff = abs(b - a)\n\n    min_lcm = float('inf')\n    best_k = 0\n\n    # Find divisors of diff\n    divisors = set()\n    for i in range(1, int(diff**0.5) + 1):\n        if diff % i == 0:\n            divisors.add(i)\n            divisors.add(diff // i)\n\n    for g in sorted(list(divisors)): # Sort divisors to find smallest k first for ties\n        # We need a+k to be a multiple of g.\n        # k = -a (mod g)\n        # Smallest non-negative k is (g - (a % g)) % g\n        current_k = (g - (a % g)) % g\n\n        val_a_plus_k = a + current_k\n        val_b_plus_k = b + current_k\n        \n        # Calculate LCM: lcm(x, y) = (x * y) / gcd(x, y)\n        # To avoid overflow with (x*y) for large x,y, we can use (x // gcd(x,y)) * y\n        # Or check if intermediate products exceed max_int if needed, but python handles large ints.\n        current_lcm = (val_a_plus_k // gcd(val_a_plus_k, val_b_plus_k)) * val_b_plus_k\n\n        if current_lcm < min_lcm:\n            min_lcm = current_lcm\n            best_k = current_k\n        elif current_lcm == min_lcm:\n            # If LCMs are equal, choose the smaller k.\n            # Since we iterate through divisors in increasing order,\n            # and for each g, we find the smallest possible k,\n            # if we encounter an equal LCM, current_k will be larger than previous best_k (or equal if same g).\n            # So, we only update if current_k is smaller, which won't happen if g is increasing.\n            # The problem states \"if there are multiple optimal integers k, he needs to choose the smallest one.\"\n            # This logic implicitly handles that: if we found a minimum_lcm with k_1, and later find\n            # the same minimum_lcm with k_2, we keep k_1 if k_1 < k_2.\n            # Since we iterate through g, and for each g, current_k is unique, if g increases, current_k will also generally increase.\n            # So if current_lcm == min_lcm, current_k will be >= best_k.\n            # Thus, we only update if current_k < best_k, but that implies current_lcm must be strictly smaller.\n            # So, the 'elif' branch is effectively not needed for choosing the smallest k,\n            # as the first k that achieves min_lcm will be the smallest.\n            # However, if we iterate through divisors in a non-sorted manner, this would be important.\n            # With `sorted(list(divisors))`, the first `g` that yields `min_lcm` will also yield the smallest `k`.\n            pass # No need to update best_k if current_lcm == min_lcm\n\n    print(best_k)\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 412,
        "completion_token_count": 831,
        "thoughts_token_count": 830
    }
}