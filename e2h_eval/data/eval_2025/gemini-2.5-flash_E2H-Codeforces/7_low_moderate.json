{
    "start": 1758009329.6149814,
    "end": 1758009379.9892716,
    "start-formatted": "2025-09-16 16:55 KST",
    "end-formatted": "2025-09-16 16:56 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "**Analyzing the Snowflake Structure for the Rudolf Problem**\n\nOkay, I'm diving into this \"Rudolf and Snowflakes (hard version)\" problem, and the first thing that's hitting me is the need to really understand the structure of these snowflakes. The problem asks for a Python script, so let's break this down systematically.\n\nIt's all about how these snowflakes are *built*.  We start with a center vertex. That's the core. Then, we connect the center to `k` new vertices, where `k` has to be greater than 1.  Alright, that gives us `1 + k` vertices. These new vertices are all degree 1 – they're only connected to the center.\n\nNow, *this* is where the interesting part begins.  Each of these degree-1 vertices has to be connected to `k` *more* new vertices.  This step has to happen at least once. If we go through this process a single time, we'll have `1 + k + k^2` vertices. Those new vertices are also degree 1.\n\nSo, it's a recursive process.  Each subsequent layer adds `k` new vertices for each degree-1 vertex in the previous layer. The total number of vertices becomes a sum:  `1 + k + k^2 + k^3 + ... + k^d`, where `d` represents the depth, or the number of times we've expanded after the initial layer.\n\nThat's a geometric series. We can express that sum as `(k^(d+1) - 1) / (k - 1)`.\n\nThe crucial detail is that the problem explicitly states that this recursive step *must* happen at least once. If we interpret it correctly, it suggests that d has to be at least 1. If we interpret that \"this step\" means \"Each vertex that is connected to only one other vertex is connected by edges to `k` more new vertices\", then d is at least 1, the step is executed, and d equals 2.  It seems d must always be at least 2.\n\nSo, the key challenge is figuring out a Python script that can efficiently calculate this geometric series sum and figure out which of these snowflake formations are possible with the given constraints of the problem. This will drive the logic of the code. We need to be careful with the bounds and how we handle potential overflows when computing these sums.\n",
    "response": "The problem asks us to determine if a given number of vertices `n` can form a snowflake structure. A snowflake is defined by a central vertex, which is connected to `k` new vertices (`k > 1`). Then, each vertex connected to only one other vertex is connected to `k` more new vertices. This latter step must be performed at least once.\n\nLet's analyze the number of vertices:\n1.  **Initial:** 1 central vertex.\n2.  **First layer:** The central vertex is connected to `k` new vertices. Total vertices: `1 + k`. At this point, the `k` new vertices are connected to only one other vertex (the center).\n3.  **Second layer:** Each of the `k` vertices from the first layer (which have degree 1) is connected to `k` new vertices. This adds `k * k = k^2` new vertices. Total vertices: `1 + k + k^2`. The `k^2` new vertices now have degree 1.\n4.  **Third layer:** Each of the `k^2` vertices from the second layer is connected to `k` new vertices. This adds `k^2 * k = k^3` new vertices. Total vertices: `1 + k + k^2 + k^3`.\n\nThis pattern continues. If the process of adding new layers (after the initial `k` vertices are added) is performed `d-1` times, where `d` is the total number of layers of branches, the total number of vertices will be `1 + k + k^2 + ... + k^d`.\nThis is a geometric series sum: `N = (k^(d+1) - 1) / (k - 1)`.\n\nThe problem states `k > 1`.\nThe rule \"This step should be done at least once\" refers to the step where vertices connected to only one other vertex are branched out. This means we must have at least a second layer of branches. So, `d` must be at least 2.\n\nTherefore, we are looking for `n` such that `n = 1 + k + k^2 + ... + k^d` for some integers `k > 1` and `d >= 2`.\n\n**Case 1: `d = 2`**\n`n = 1 + k + k^2`.\nThis is a quadratic equation in `k`: `k^2 + k + (1 - n) = 0`.\nUsing the quadratic formula, `k = (-1 ± sqrt(1 - 4(1 - n))) / 2 = (-1 ± sqrt(4n - 3)) / 2`.\nFor `k` to be an integer greater than 1, `4n - 3` must be a perfect square, say `m^2`.\nSo, `m = sqrt(4n - 3)`. Then `k = (-1 + m) / 2`.\nWe need `m` to be an integer, `m > 0`.\nAlso, `k > 1` implies `(-1 + m) / 2 > 1`, so `-1 + m > 2`, which means `m > 3`.\nSince `m` and `k` must have the same parity (both odd or both even), and `-1` is odd, `m` must be odd. If `m` is odd, then `m-1` is even, so `k` will be an integer.\nThus, for `d=2`, we check if `4n - 3` is a perfect square `m^2` where `m` is an odd integer greater than 3.\n\n**Case 2: `d >= 3`**\n`n = 1 + k + k^2 + ... + k^d`.\nSince `k > 1`, `k^d < n`. This means `k < n^(1/d)`.\nAlso, `n = (k^(d+1) - 1) / (k - 1)`.\nSince `k >= 2` and `d >= 3`:\n`n > k^d`.\n`n = 1 + k + ... + k^d > k^d`.\n`n = 1 + k + ... + k^d < k^d + k^d + ... + k^d` (`d+1` terms)\n`n < (d+1)k^d`.\nMore precisely, `n = (k^(d+1) - 1) / (k - 1)`.\nFor `k=2`, `n = 2^(d+1) - 1`. If `n` is of this form, then `k=2` is a solution.\nFor `k >= 3`, `n = (k^(d+1) - 1) / (k - 1)`.\nWe know `k < n^(1/d)`.\nSince `d >= 3`, the maximum possible value for `d` is `log_2(n)`. For `n = 10^18`, `log_2(10^18)` is approximately `18 * log_2(10) approx 18 * 3.32 approx 59.79`. So `d` can go up to about 59.\nWe can iterate `d` from 3 up to around 60. For each `d`, we need to find an integer `k > 1` such that `n = (k^(d+1) - 1) / (k - 1)`.\nThis equation can be rewritten as `n(k-1) = k^(d+1) - 1`.\n`nk - n = k^(d+1) - 1`.\n`k^(d+1) - nk + (n - 1) = 0`.\nThis is a polynomial equation in `k`. For a fixed `d`, we need to find an integer root `k > 1`.\nWe can use binary search for `k`.\nFor a fixed `d`, `f(k) = 1 + k + ... + k^d` is an increasing function of `k`.\nThe lower bound for `k` is 2.\nThe upper bound for `k` can be estimated. Since `k^d < n`, `k < n^(1/d)`.\nFor `n = 10^18`:\nIf `d=3`, `k < (10^18)^(1/3) = 10^6`.\nIf `d=4`, `k < (10^18)^(1/4) = 10^(4.5) approx 31622`.\n...\nIf `d=59`, `k < (10^18)^(1/59) approx 10^(0.305) approx 2.01`. So `k` can only be 2.\nIf `d=60`, `k < (10^18)^(1/60) = 10^(0.3) approx 1.99`. No `k > 1` possible.\nSo, `d` ranges from 3 up to 59.\nThe maximum value for `k` is `10^6`. Binary search for `k` in the range `[2, 10^6]` will be efficient enough.\n\n**Algorithm:**\n1.  Handle `n < 7` as \"NO\" (the smallest snowflake has `1+2+2^2 = 7` vertices for `k=2, d=2`).\n2.  **Check `d=2` case:**\n    Calculate `val = 4n - 3`.\n    If `val` is a perfect square `m^2` (i.e., `m = int(sqrt(val))` and `m*m == val`), then check if `m` is odd and `m > 3`. If both conditions are met, then `k = (-1 + m) / 2` is an integer `k > 1`, and `n` is a snowflake. Return \"YES\".\n3.  **Check `d >= 3` cases:**\n    Iterate `d` from 3 up to 59 (or `log_2(n)` approximately).\n    For each `d`, perform a binary search for `k` in the range `[2, 10^6 + 7]` (a slightly generous upper bound for `k` when `d=3`).\n    In the binary search:\n    *   `low = 2`, `high = max_k_for_d` (e.g., `10^6 + 7`).\n    *   `mid = (low + high) // 2`.\n    *   Calculate `current_n = 1 + mid + mid^2 + ... + mid^d`. This sum can be computed efficiently by iteratively multiplying by `mid` and adding. Be careful of overflow if `mid^d` exceeds `n` or `10^18`.\n        A safer way to compute `current_n` is to check `mid` against `n^(1/d)`. If `mid > n^(1/d)`, then `mid^d > n`, so `current_n > n`.\n        Alternatively, compute `current_n` term by term. `curr_sum = 1`, `term = 1`. For `i` from 1 to `d`: `term *= mid`. If `term` overflows or `curr_sum + term` overflows or exceeds `n`, then `current_n` is too large.\n        If `current_n == n`, we found a solution. Return \"YES\".\n        If `current_n < n`, try larger `k`: `low = mid + 1`.\n        If `current_n > n`, try smaller `k`: `high = mid - 1`.\n    If no `k` is found for any `d`, return \"NO\".\n\n**Optimization for `current_n` calculation:**\nInstead of `1 + k + ... + k^d`, we can use `(k^(d+1) - 1) / (k - 1)`.\n`k^(d+1)` can be very large. We need to check for overflow.\n`power = 1`\n`curr_sum = 1`\nFor `i` from 1 to `d`:\n  If `n // k < power` (i.e., `power * k` would overflow `n` or be larger than `n`'s scale), then `curr_sum` will definitely exceed `n`. Break.\n  `power *= k`\n  If `n - curr_sum < power` (i.e., `curr_sum + power` would exceed `n`), then `curr_sum` will definitely exceed `n`. Break.\n  `curr_sum += power`\nThis computes `curr_sum` safely.\n\n**Example Walkthrough for `n=13`:**\n1.  `n=13 >= 7`.\n2.  **`d=2` check:**\n    `val = 4*13 - 3 = 52 - 3 = 49`.\n    `m = int(sqrt(49)) = 7`.\n    `m*m == 49` is true.\n    `m=7` is odd and `m > 3`. Conditions met.\n    `k = (-1 + 7) / 2 = 3`.\n    So `n=13` is `1 + 3 + 3^2`. Return \"YES\".\n\n**Example Walkthrough for `n=10^18`:**\n1.  `n=10^18 >= 7`.\n2.  **`d=2` check:**\n    `val = 4*10^18 - 3`.\n    `sqrt(4*10^18 - 3) approx sqrt(4*10^18) = 2*10^9`.\n    `m = int(sqrt(4*10^18 - 3))`.\n    Let's check `m*m == 4*10^18 - 3`.\n    `m = 1999999999.99999999925...`\n    `int(m)` would be `1999999999`. Let's call it `m_int`.\n    `m_int * m_int = 3999999996000000001`.\n    `4*10^18 - 3 = 3999999999999999997`.\n    They are not equal. So `4*10^18 - 3` is not a perfect square. `d=2` fails.\n3.  **`d >= 3` check:**\n    Iterate `d` from 3 to 59.\n    For each `d`, binary search for `k`.\n    `k_max_search = int(n**(1/d)) + 2` (a slightly larger upper bound than `n**(1/d)` to account for precision issues and `+2` for safety).\n    For `d=3`, `k_max_search = int((10^18)^(1/3)) + 2 = 10^6 + 2`.\n    Binary search for `k` in `[2, 10^6+2]`.\n    Inside binary search, calculate `current_n = 1 + k + ... + k^d`.\n    For `n=10^18`, no such `k, d` exist. Eventually, it will return \"NO\".\n\n```python\nimport math\n\ndef solve():\n    n = int(input())\n\n    if n < 7: # Smallest snowflake is 1 + 2 + 2^2 = 7 for k=2, d=2\n        print(\"NO\")\n        return\n\n    # Case 1: d = 2 (n = 1 + k + k^2)\n    # k^2 + k + (1 - n) = 0\n    # k = (-1 + sqrt(1 - 4(1 - n))) / 2\n    # k = (-1 + sqrt(4n - 3)) / 2\n    \n    val = 4 * n - 3\n    \n    # Check if val is a perfect square\n    m = int(math.isqrt(val)) # math.isqrt is efficient for large integers\n    \n    if m * m == val:\n        # For k to be an integer, -1 + m must be even, so m must be odd.\n        # For k > 1, (-1 + m) / 2 > 1 => -1 + m > 2 => m > 3.\n        if m % 2 == 1 and m > 3:\n            # k = (m - 1) // 2\n            # No need to explicitly calculate k, just checking m is sufficient.\n            print(\"YES\")\n            return\n\n    # Case 2: d >= 3 (n = 1 + k + k^2 + ... + k^d)\n    # Max d for n = 10^18 is around log_2(10^18) approx 59.79. So d up to 59.\n    # Max k for d=3, n=10^18 is k < (10^18)^(1/3) = 10^6.\n    \n    # Iterate d from 3 up to 59\n    for d in range(3, 60): # d cannot be 60 because 2^60-1 > 10^18\n        low = 2\n        # Upper bound for k: k^d < n => k < n^(1/d).\n        # A safe upper bound for k for n=10^18 and d=3 is 10^6.\n        # For larger d, k_upper decreases. We can use a fixed large enough value.\n        # For d=3, k_upper approx 10^6. For d=59, k_upper approx 2.\n        # A general upper bound for k for n=10^18 is 10^6 + 7 (or even 2*10^6)\n        # We can also calculate it more precisely: high = int(n**(1/d)) + 2.\n        # However, n**(1/d) might have precision issues for large n.\n        # A simpler approach is to use a sufficiently large constant upper bound\n        # and let the `current_sum` check handle overflow/too large values.\n        high = 2 * 10**6 # A safe upper bound for k for n <= 10^18, d >= 3\n                         # (e.g. for d=3, k approx 10^6)\n\n        # Optimization: if 2^d > n, then no k>=2 can satisfy n = 1+k+...+k^d\n        # This is implicitly handled by the binary search range and sum calculation.\n        # For d=59, 2^59 is already close to 10^18.\n        # For d=60, 2^60 is > 10^18, so k=2 won't work.\n        # So iterating up to d=59 is correct.\n\n        # Binary search for k\n        while low <= high:\n            mid = (low + high) // 2\n            if mid < 2: # k must be > 1\n                low = 2\n                continue\n\n            current_sum = 1\n            term = 1\n            possible = True # Flag to check if current_sum will exceed n\n            \n            for _ in range(d):\n                # Check for overflow before multiplication\n                # If term * mid > n, then current_sum will definitely be > n\n                # This check ensures term doesn't overflow and current_sum doesn't exceed n\n                if n // mid < term: # Equivalent to term * mid > n\n                    possible = False\n                    break\n                term *= mid\n                \n                # Check for overflow before addition\n                if n - current_sum < term: # Equivalent to current_sum + term > n\n                    possible = False\n                    break\n                current_sum += term\n            \n            if not possible: # current_sum would exceed n\n                high = mid - 1\n            elif current_sum == n:\n                print(\"YES\")\n                return\n            elif current_sum < n:\n                low = mid + 1\n            else: # current_sum > n\n                high = mid - 1\n                \n    print(\"NO\")\n\n\nnum_test_cases = int(input())\nfor _ in range(num_test_cases):\n    solve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef solve():\n    n = int(input())\n\n    if n < 7: # Smallest snowflake is 1 + 2 + 2^2 = 7 for k=2, d=2\n        print(\"NO\")\n        return\n\n    # Case 1: d = 2 (n = 1 + k + k^2)\n    # k^2 + k + (1 - n) = 0\n    # k = (-1 + sqrt(1 - 4(1 - n))) / 2\n    # k = (-1 + sqrt(4n - 3)) / 2\n    \n    val = 4 * n - 3\n    \n    # Check if val is a perfect square\n    m = int(math.isqrt(val)) # math.isqrt is efficient for large integers\n    \n    if m * m == val:\n        # For k to be an integer, -1 + m must be even, so m must be odd.\n        # For k > 1, (-1 + m) / 2 > 1 => -1 + m > 2 => m > 3.\n        if m % 2 == 1 and m > 3:\n            # k = (m - 1) // 2\n            # No need to explicitly calculate k, just checking m is sufficient.\n            print(\"YES\")\n            return\n\n    # Case 2: d >= 3 (n = 1 + k + k^2 + ... + k^d)\n    # Max d for n = 10^18 is around log_2(10^18) approx 59.79. So d up to 59.\n    # Max k for d=3, n=10^18 is k < (10^18)^(1/3) = 10^6.\n    \n    # Iterate d from 3 up to 59\n    for d in range(3, 60): # d cannot be 60 because 2^60-1 > 10^18\n        low = 2\n        # Upper bound for k: k^d < n => k < n^(1/d).\n        # A safe upper bound for k for n=10^18 and d=3 is 10^6.\n        # For larger d, k_upper decreases. We can use a fixed large enough value.\n        # For d=3, k_upper approx 10^6. For d=59, k_upper approx 2.\n        # A general upper bound for k for n=10^18 is 10^6 + 7 (or even 2*10^6)\n        # We can also calculate it more precisely: high = int(n**(1/d)) + 2.\n        # However, n**(1/d) might have precision issues for large n.\n        # A simpler approach is to use a sufficiently large constant upper bound\n        # and let the `current_sum` check handle overflow/too large values.\n        high = 2 * 10**6 # A safe upper bound for k for n <= 10^18, d >= 3\n                         # (e.g. for d=3, k approx 10^6)\n\n        # Optimization: if 2^d > n, then no k>=2 can satisfy n = 1+k+...+k^d\n        # This is implicitly handled by the binary search range and sum calculation.\n        # For d=59, 2^59 is already close to 10^18.\n        # For d=60, 2^60 is > 10^18, so k=2 won't work.\n        # So iterating up to d=59 is correct.\n\n        # Binary search for k\n        while low <= high:\n            mid = (low + high) // 2\n            if mid < 2: # k must be > 1\n                low = 2\n                continue\n\n            current_sum = 1\n            term = 1\n            possible = True # Flag to check if current_sum will exceed n\n            \n            for _ in range(d):\n                # Check for overflow before multiplication\n                # If term * mid > n, then current_sum will definitely be > n\n                # This check ensures term doesn't overflow and current_sum doesn't exceed n\n                if n // mid < term: # Equivalent to term * mid > n\n                    possible = False\n                    break\n                term *= mid\n                \n                # Check for overflow before addition\n                if n - current_sum < term: # Equivalent to current_sum + term > n\n                    possible = False\n                    break\n                current_sum += term\n            \n            if not possible: # current_sum would exceed n\n                high = mid - 1\n            elif current_sum == n:\n                print(\"YES\")\n                return\n            elif current_sum < n:\n                low = mid + 1\n            else: # current_sum > n\n                high = mid - 1\n                \n    print(\"NO\")\n\n\nnum_test_cases = int(input())\nfor _ in range(num_test_cases):\n    solve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 569,
        "completion_token_count": 4296,
        "thoughts_token_count": 764
    }
}