{
    "start": 1758015865.7212996,
    "end": 1758015887.6792583,
    "start-formatted": "2025-09-16 18:44 KST",
    "end-formatted": "2025-09-16 18:44 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "",
    "response": "```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    vouchers = []\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        vouchers.append((l, r, cost))\n\n    vouchers.sort()\n\n    min_cost = float('inf')\n    \n    # max_coord = 2 * 10**5\n    # The maximum possible r is 2 * 10^5.\n    # The maximum possible l is 2 * 10^5.\n    # The maximum possible duration is 2 * 10^5.\n    # The sum of durations is x, which can be up to 2 * 10^5.\n    # So, we need to store costs for durations up to x.\n    # The maximum coordinate for l and r is 2 * 10^5.\n    # We need to store minimum costs for a given duration ending at a specific day.\n    # Or minimum costs for a given duration starting at a specific day.\n\n    # Option 1: Iterate through all pairs (N^2) - too slow (2*10^5)^2 = 4*10^10\n    # Option 2: Sort and use a data structure.\n\n    # Let's group vouchers by their start day `l`.\n    # `vouchers_by_start[l]` will contain a list of (r, cost) for vouchers starting on day `l`.\n    vouchers_by_start = [[] for _ in range(2 * 10**5 + 2)]\n    for l, r, cost in vouchers:\n        vouchers_by_start[l].append((r, cost))\n\n    # `min_cost_for_duration_ending_on_day[duration][day]`\n    # This would be too large.\n    # Instead, let's keep track of `min_cost_for_duration[duration]`\n    # and update it as we sweep through days.\n\n    # `min_cost_for_len[duration]` stores the minimum cost of a single voucher\n    # with that `duration` seen so far.\n    # Initialize with infinity.\n    min_cost_for_len = [float('inf')] * (x + 1)\n\n    # `events` list to store (day, type, voucher_index)\n    # type 0: start of voucher\n    # type 1: end of voucher\n    events = []\n    for i, (l, r, cost) in enumerate(vouchers):\n        events.append((l, 0, i)) # Start event\n        events.append((r, 1, i)) # End event (processed after all starts on the same day)\n\n    # Sort events primarily by day, then by type (start before end)\n    events.sort()\n\n    # The max possible day is 2 * 10^5.\n    # We need to store min_cost_for_duration for vouchers ending on a specific day.\n    # `min_cost_ending_on_day[day]` will store a dictionary or list of (duration, cost)\n    # This is also too complex.\n\n    # Let's iterate through all possible split points.\n    # We need to find two vouchers (l1, r1, c1) and (l2, r2, c2) such that:\n    # 1. r1 < l2 OR r2 < l1 (disjoint)\n    # 2. (r1 - l1 + 1) + (r2 - l2 + 1) == x\n    # 3. c1 + c2 is minimized.\n\n    # One approach: Iterate through all vouchers (l1, r1, c1).\n    # For each voucher, calculate its duration d1 = r1 - l1 + 1.\n    # We need a second voucher with duration d2 = x - d1.\n    # The second voucher must satisfy r1 < l2 OR r2 < l1.\n\n    # If r1 < l2:\n    # We need to find a voucher (l2, r2, c2) such that l2 > r1 and r2 - l2 + 1 = x - d1.\n    # To do this efficiently, we can precompute, for each day `s` and duration `d`,\n    # the minimum cost of a voucher that starts on or after `s` and has duration `d`.\n    # This is still too complex.\n\n    # Let's try iterating through the vouchers sorted by `l`.\n    # We can maintain a data structure that stores minimum costs for available durations.\n\n    # `min_cost_for_duration_ending_before_day[duration]`\n    # This array will store the minimum cost of a voucher with `duration`\n    # that has ended *before* the current `l` we are considering.\n    # The index `d` stores the minimum cost for a voucher of length `d`.\n    min_cost_for_duration_ending_before_day = [float('inf')] * (x + 1)\n\n    # We can iterate through days from 1 to 2*10^5.\n    # For each day `d`:\n    # 1. Update `min_cost_for_duration_ending_before_day` with vouchers that end on `d-1`.\n    # 2. Consider vouchers that start on `d`. For each such voucher `v_curr = (l_curr, r_curr, cost_curr)`:\n    #    a. Calculate its duration `d_curr = r_curr - l_curr + 1`.\n    #    b. If `d_curr < x`:\n    #       i. The required duration for the second voucher is `d_req = x - d_curr`.\n    #       ii. If `min_cost_for_duration_ending_before_day[d_req]` is not infinity,\n    #           we can form a pair: `cost_curr + min_cost_for_duration_ending_before_day[d_req]`.\n    #           Update `min_cost`.\n    # This covers the `r_prev < l_curr` condition.\n\n    # To handle `r_curr < l_prev` efficiently, we can do another pass or\n    # consider all vouchers in one pass.\n\n    # Let's process vouchers sorted by their start day `l`.\n    # `vouchers_by_l[l]` stores list of (r, cost) for vouchers starting on day `l`.\n    # `vouchers_by_r[r]` stores list of (l, cost) for vouchers ending on day `r`.\n\n    max_coord = 2 * 10**5 + 1\n    vouchers_by_l = [[] for _ in range(max_coord + 1)]\n    vouchers_by_r = [[] for _ in range(max_coord + 1)]\n\n    for l, r, cost in vouchers:\n        vouchers_by_l[l].append((r, cost))\n        vouchers_by_r[r].append((l, cost))\n\n    current_min_cost_for_duration = [float('inf')] * (x + 1) # min cost for a voucher of specific duration ending *before or on* current day\n\n    ans = float('inf')\n\n    # Iterate through days from 1 to max_coord\n    for day in range(1, max_coord + 1):\n        # Phase 1: Update `current_min_cost_for_duration` with vouchers ending on `day - 1`.\n        # These vouchers are now \"available\" to be paired with vouchers starting on `day` or later.\n        if day > 1:\n            for l_prev, cost_prev in vouchers_by_r[day - 1]:\n                duration_prev = (day - 1) - l_prev + 1\n                if duration_prev <= x:\n                    current_min_cost_for_duration[duration_prev] = min(\n                        current_min_cost_for_duration[duration_prev], cost_prev\n                    )\n\n        # Phase 2: Consider vouchers starting on `day`.\n        for r_curr, cost_curr in vouchers_by_l[day]:\n            duration_curr = r_curr - day + 1\n            if duration_curr < x: # If duration_curr == x, then d_req = 0, which is not possible for a voucher.\n                required_duration = x - duration_curr\n                if required_duration > 0 and required_duration <= x:\n                    if current_min_cost_for_duration[required_duration] != float('inf'):\n                        ans = min(ans, cost_curr + current_min_cost_for_duration[required_duration])\n\n    if ans == float('inf'):\n        print(-1)\n    else:\n        print(ans)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    vouchers = []\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        vouchers.append((l, r, cost))\n\n    vouchers.sort()\n\n    min_cost = float('inf')\n    \n    # max_coord = 2 * 10**5\n    # The maximum possible r is 2 * 10^5.\n    # The maximum possible l is 2 * 10^5.\n    # The maximum possible duration is 2 * 10^5.\n    # The sum of durations is x, which can be up to 2 * 10^5.\n    # So, we need to store costs for durations up to x.\n    # The maximum coordinate for l and r is 2 * 10^5.\n    # We need to store minimum costs for a given duration ending at a specific day.\n    # Or minimum costs for a given duration starting at a specific day.\n\n    # Option 1: Iterate through all pairs (N^2) - too slow (2*10^5)^2 = 4*10^10\n    # Option 2: Sort and use a data structure.\n\n    # Let's group vouchers by their start day `l`.\n    # `vouchers_by_start[l]` will contain a list of (r, cost) for vouchers starting on day `l`.\n    vouchers_by_start = [[] for _ in range(2 * 10**5 + 2)]\n    for l, r, cost in vouchers:\n        vouchers_by_start[l].append((r, cost))\n\n    # `min_cost_for_duration_ending_on_day[duration][day]`\n    # This would be too large.\n    # Instead, let's keep track of `min_cost_for_duration[duration]`\n    # and update it as we sweep through days.\n\n    # `min_cost_for_len[duration]` stores the minimum cost of a single voucher\n    # with that `duration` seen so far.\n    # Initialize with infinity.\n    min_cost_for_len = [float('inf')] * (x + 1)\n\n    # `events` list to store (day, type, voucher_index)\n    # type 0: start of voucher\n    # type 1: end of voucher\n    events = []\n    for i, (l, r, cost) in enumerate(vouchers):\n        events.append((l, 0, i)) # Start event\n        events.append((r, 1, i)) # End event (processed after all starts on the same day)\n\n    # Sort events primarily by day, then by type (start before end)\n    events.sort()\n\n    # The max possible day is 2 * 10^5.\n    # We need to store min_cost_for_duration for vouchers ending on a specific day.\n    # `min_cost_ending_on_day[day]` will store a dictionary or list of (duration, cost)\n    # This is also too complex.\n\n    # Let's iterate through all possible split points.\n    # We need to find two vouchers (l1, r1, c1) and (l2, r2, c2) such that:\n    # 1. r1 < l2 OR r2 < l1 (disjoint)\n    # 2. (r1 - l1 + 1) + (r2 - l2 + 1) == x\n    # 3. c1 + c2 is minimized.\n\n    # One approach: Iterate through all vouchers (l1, r1, c1).\n    # For each voucher, calculate its duration d1 = r1 - l1 + 1.\n    # We need a second voucher with duration d2 = x - d1.\n    # The second voucher must satisfy r1 < l2 OR r2 < l1.\n\n    # If r1 < l2:\n    # We need to find a voucher (l2, r2, c2) such that l2 > r1 and r2 - l2 + 1 = x - d1.\n    # To do this efficiently, we can precompute, for each day `s` and duration `d`,\n    # the minimum cost of a voucher that starts on or after `s` and has duration `d`.\n    # This is still too complex.\n\n    # Let's try iterating through the vouchers sorted by `l`.\n    # We can maintain a data structure that stores minimum costs for available durations.\n\n    # `min_cost_for_duration_ending_before_day[duration]`\n    # This array will store the minimum cost of a voucher with `duration`\n    # that has ended *before* the current `l` we are considering.\n    # The index `d` stores the minimum cost for a voucher of length `d`.\n    min_cost_for_duration_ending_before_day = [float('inf')] * (x + 1)\n\n    # We can iterate through days from 1 to 2*10^5.\n    # For each day `d`:\n    # 1. Update `min_cost_for_duration_ending_before_day` with vouchers that end on `d-1`.\n    # 2. Consider vouchers that start on `d`. For each such voucher `v_curr = (l_curr, r_curr, cost_curr)`:\n    #    a. Calculate its duration `d_curr = r_curr - l_curr + 1`.\n    #    b. If `d_curr < x`:\n    #       i. The required duration for the second voucher is `d_req = x - d_curr`.\n    #       ii. If `min_cost_for_duration_ending_before_day[d_req]` is not infinity,\n    #           we can form a pair: `cost_curr + min_cost_for_duration_ending_before_day[d_req]`.\n    #           Update `min_cost`.\n    # This covers the `r_prev < l_curr` condition.\n\n    # To handle `r_curr < l_prev` efficiently, we can do another pass or\n    # consider all vouchers in one pass.\n\n    # Let's process vouchers sorted by their start day `l`.\n    # `vouchers_by_l[l]` stores list of (r, cost) for vouchers starting on day `l`.\n    # `vouchers_by_r[r]` stores list of (l, cost) for vouchers ending on day `r`.\n\n    max_coord = 2 * 10**5 + 1\n    vouchers_by_l = [[] for _ in range(max_coord + 1)]\n    vouchers_by_r = [[] for _ in range(max_coord + 1)]\n\n    for l, r, cost in vouchers:\n        vouchers_by_l[l].append((r, cost))\n        vouchers_by_r[r].append((l, cost))\n\n    current_min_cost_for_duration = [float('inf')] * (x + 1) # min cost for a voucher of specific duration ending *before or on* current day\n\n    ans = float('inf')\n\n    # Iterate through days from 1 to max_coord\n    for day in range(1, max_coord + 1):\n        # Phase 1: Update `current_min_cost_for_duration` with vouchers ending on `day - 1`.\n        # These vouchers are now \"available\" to be paired with vouchers starting on `day` or later.\n        if day > 1:\n            for l_prev, cost_prev in vouchers_by_r[day - 1]:\n                duration_prev = (day - 1) - l_prev + 1\n                if duration_prev <= x:\n                    current_min_cost_for_duration[duration_prev] = min(\n                        current_min_cost_for_duration[duration_prev], cost_prev\n                    )\n\n        # Phase 2: Consider vouchers starting on `day`.\n        for r_curr, cost_curr in vouchers_by_l[day]:\n            duration_curr = r_curr - day + 1\n            if duration_curr < x: # If duration_curr == x, then d_req = 0, which is not possible for a voucher.\n                required_duration = x - duration_curr\n                if required_duration > 0 and required_duration <= x:\n                    if current_min_cost_for_duration[required_duration] != float('inf'):\n                        ans = min(ans, cost_curr + current_min_cost_for_duration[required_duration])\n\n    if ans == float('inf'):\n        print(-1)\n    else:\n        print(ans)\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 789,
        "completion_token_count": 2051,
        "thoughts_token_count": 0
    }
}