{
    "start": 1758294875.5084472,
    "end": 1758295009.318989,
    "start-formatted": "2025-09-20 00:14 KST",
    "end-formatted": "2025-09-20 00:16 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "**Alright, here's my breakdown of this problem, thinking through the logic step-by-step.**\n\nFirst things first, the goal is to figure out the minimum number of edges, `t`, needed to make an odd-length cycle in a graph and the number of ways, `w`, we can do this. The constraints are straightforward: no loops, no parallel edges, and the new edges must connect existing vertices.\n\n**Understanding the Core Concept: Bipartite Graphs and Odd Cycles**\n\nA key insight is that a graph *has* an odd-length cycle if and only if it's *not* bipartite. If the graph already contains an odd cycle, the answer is simple: `t = 0` and `w = 1`.  So, the very first step is to check if the graph is bipartite using Breadth-First Search (BFS) or Depth-First Search (DFS) with 2-coloring.\n\n**Scenario 1: The Graph is Already Non-Bipartite (t = 0)**\n\nIf the graph is not bipartite, it has at least one odd cycle. Therefore, `t = 0` and `w = 1` because we are looking for *a* cycle, so picking one is enough. The program outputs \"0 1\".\n\n**Scenario 2: The Graph is Bipartite**\n\nIf the graph *is* bipartite, we need to add edges to create an odd cycle. A bipartite graph can be colored with two colors, let's say 0 and 1, such that no adjacent vertices share the same color. To make an odd cycle, we need to \"break\" this bipartiteness. This means connecting two vertices of the *same* color.\n\n**Case 2.1: Can we make t = 1?**\nIf we add a single edge `(u, v)`, and `u` and `v` are the same color, this guarantees an odd cycle. The edge *itself* and the path between *u* and *v* in the original bipartite graph create an odd cycle. If two vertices `u` and `v` are in the same component and have the same color, this edge adds an odd cycle. We need to sum the number of such pairs over all components. This gives us the number of ways `w` to add this one edge. Specifically, `t = 1` and `w = sum(C0_i * (C0_i - 1) / 2 + C1_i * (C1_i - 1) / 2)` for each component `i`, where `C0_i` and `C1_i` are the number of vertices of each color in that component.\n\n**Case 2.2: t = 1 is not possible**\nIf we cannot add a single edge to create an odd cycle (meaning we couldn't connect two vertices of the same color *within* a component),  it means every connected component has at most one vertex of each color (or is a path of length at most 1). In other words, every component is either an isolated vertex or an edge. This requires us to add at least two edges (t = 2).\n\n**Case 2.2 Continued: To make t = 2**\nIf every component is at most an edge, the only way to create an odd cycle with two edges is to connect three vertices `A`, `B`, and `C` such that `A-B`, `B-C`, and `C-A` form an odd cycle. Since the original edges must connect vertices of different colors, the edges to be added are `(A, B)` and `(B, C)`. If `A-C` is an existing edge, and we can find a vertex `B` such that `A` and `B` are in different components, and both have color 0, `B` and `C` are in the same component (the merge), `B` has color 0 and `C` has color 1, then this will work. This also indicates `w > 0`. The value of w needs more thought, since it's the number of unique combinations possible.  I think, in this case, the `w` is the number of triangles that can be completed.\n\n**Let's Summarize the algorithm:**\n\n1.  **Check for Bipartiteness:**  Use BFS or DFS with 2-coloring. If non-bipartite, output \"0 1\".\n2.  **Calculate w_1:** if Bipartite. If w_1 > 0, we can add one edge.\n3.  **T=1 Case:** If possible,  find the components with at least two vertices of the same color, and use `w = sum(",
    "response": "The problem asks us to find the minimum number of edges `t` that must be added to a given undirected graph to form a simple cycle of odd length, and `w`, the number of ways to do so. We cannot add loops or parallel edges.\n\nFirst, let's understand the properties of odd cycles and bipartite graphs. A graph contains an odd-length cycle if and only if it is not bipartite. If a graph is bipartite, all its cycles are of even length. If it is not bipartite, it must contain at least one odd-length cycle.\n\nWe can determine if a graph is bipartite using a 2-coloring algorithm (e.g., BFS or DFS). We assign an arbitrary color (say, 0) to a starting vertex. Then, all its neighbors must be assigned color 1, their neighbors color 0, and so on. If we ever try to assign a color to a vertex that already has a different color, or if an edge connects two vertices of the same color, the graph is not bipartite.\n\nLet's analyze the problem based on whether the initial graph is bipartite:\n\n**Case 1: The graph already contains an odd-length cycle.**\nIf the graph is not bipartite, it already has an odd-length cycle. In this case, `t = 0`. There is 1 way to add 0 edges.\nSo, if the graph is not bipartite, the answer is `0 1`.\n\n**Case 2: The graph is bipartite.**\nIf the graph is bipartite, all existing cycles are of even length. To form an odd-length cycle, we must add at least one edge, so `t >= 1`.\nLet's consider possible values for `t`.\n\n**Subcase 2.1: `t = 1`**\nTo form an odd-length cycle by adding a single edge `(u, v)`, `u` and `v` must be in the same connected component and have the same color.\nIn a bipartite graph, if `u` and `v` are in the same connected component and have the same color, any path between them in the original graph must have an even length. Adding the edge `(u, v)` creates a cycle `u - path - v - u` of length `(even + 1)`, which is odd.\nSince the graph is bipartite, any existing edge connects vertices of different colors. Thus, if `u` and `v` have the same color, `(u, v)` cannot be an existing edge, so adding it is always valid (not a parallel edge).\n\nTo count the number of ways (`w`) for `t=1`:\n1.  Perform a 2-coloring of each connected component of the graph.\n2.  For each connected component `i`, count the number of vertices colored 0 (`C0_i`) and the number of vertices colored 1 (`C1_i`).\n3.  The number of ways to choose two distinct vertices of the same color within component `i` is `C0_i * (C0_i - 1) / 2` (for color 0) plus `C1_i * (C1_i - 1) / 2` (for color 1).\n4.  Sum these counts over all connected components: `w_1 = sum(C0_i * (C0_i - 1) / 2 + C1_i * (C1_i - 1) / 2)`.\n\nIf `w_1 > 0`, then `t = 1` and `w = w_1`. Output `1 w_1`.\n\n**Subcase 2.2: `t = 2`**\nIf `w_1 = 0`, it means that for every connected component `i`, `C0_i * (C0_i - 1) / 2 = 0` AND `C1_i * (C1_i - 1) / 2 = 0`. This implies `C0_i <= 1` AND `C1_i <= 1`.\nIn other words, every connected component consists of at most two vertices. This means each component is either:\n    *   An isolated vertex (e.g., `{v}`, with `C0=1, C1=0` or `C0=0, C1=1`).\n    *   A single edge (e.g., `{u, v}` with an edge `(u, v)`, where `u` has color 0 and `v` has color 1, so `C0=1, C1=1`).\nIn this scenario, `t` must be at least 2.\n\nTo form an odd cycle with `t=2` edges, we can create a triangle. We need to find three distinct vertices `A, B, C` such that one edge, say `(A, C)`, already exists, and we add two edges `(A, B)` and `(B, C)`.\nSince `(A, C)` is an existing edge in a bipartite graph, `A` and `C` must have different colors. Let `A` be color 0 and `C` be color 1.\nFor the cycle `A-B-C-A` to be odd, it has length 3, which is odd.\nWe need to choose `B` such that:\n1.  `B` is not `A` or `C`.\n2.  Adding `(A, B)` and `(B, C)` is valid (i.e., these edges don't already exist and are not loops).\n3.  `A`, `B`, `C` must be connected by these edges.\n\nConsider the colors: `A` (color 0), `C` (color 1).\nIf we pick `B` to be color 0:\n    *   `A` (0) and `B` (0) have the same color.\n    *   `B` (0) and `C` (1) have different colors.\n    Since `t=1` was not possible, `A` and `B` must be in different connected components. Adding `(A, B)` is valid.\n    Since `B` and `C` have different colors, `(B, C)` is not an existing edge if `B` and `C` are in different components. If they are in the same component, then `(B, C)` could be an existing edge. But `t=1` implies `C0_i <= 1` and `C1_i <= 1` for any component `i`. So `B` and `C` cannot be in the same component.\n    Thus, adding `(B, C)` is also valid.\nThe number of ways to pick such `A, B, C` is as follows:\n    *   Choose an existing edge `(A, C)`: `m` ways. (Let `A` be color 0, `C` be color 1).\n    *   Choose a vertex `B` of color 0 such that `B` is not `A` and `B` is not in the same component as `A`.\n    The total number of vertices `N`. The number of vertices of color 0 is `N_0`. The number of vertices of color 1 is `N_1`.\n    Since `t=1` is not possible, all components are isolated vertices or single edges.\n    So, all `N_0` vertices are either isolated or part of an edge.\n    For each existing edge `(A, C)` where `A` is color 0 and `C` is color 1:\n        We need to pick `B` (color 0) such that `B != A` and `B` is not in the same component as `A`.\n        Since `A` is part of an edge component `{A, C}`, `B` cannot be `C`.\n        The number of available vertices for `B` is `N_0 - 1` (all vertices of color 0 except `A`).\n        So, for each edge `(A, C)`, there are `N_0 - 1` choices for `B`.\n        Thus, `w_2 = m * (N_0 - 1)`.\nThis counts pairs `(A, B)` and `(B, C)` where `A` is color 0, `C` is color 1, `B` is color 0.\nWe could also choose `B` to be color 1:\n    *   `A` (0) and `B` (1) have different colors.\n    *   `B` (1) and `C` (1) have the same color.\n    Similar logic applies. The number of choices for `B` (color 1) is `N_1 - 1` (all vertices of color 1 except `C`).\n    So, `w_2 += m * (N_1 - 1)`.\nTotal `w_2 = m * (N_0 - 1 + N_1 - 1) = m * (N - 2)`.\nThis counts the number of ways to choose `A, B, C` and add `(A, B), (B, C)`.\nThis is the number of ways to add 2 edges. So `t=2`, `w = m * (N - 2)`. Output `2 m * (N - 2)`.\nNote that `N_0` and `N_1` are global counts over all vertices in the graph.\n\n**Subcase 2.3: `t = 3`**\nWhat if `m * (N - 2) = 0`?\nThis happens if `m = 0` (no edges) or `N - 2 = 0` (i.e., `N=2`).\nIf `N=2` and `m=0`, we have two isolated vertices. `N_0=2, N_1=0`. `w_1=1` (add edge between them). This is handled by `t=1`.\nIf `N=2` and `m=1`, we have an edge. `N_0=1, N_1=1`. `w_1=0`. `m*(N-2) = 1*(2-2) = 0`.\nSo if `N=2, m=1`, then `t=2` is not possible using the triangle method.\nIn this case, we have two vertices `u, v` connected by an edge. To form an odd cycle, we need to add a third vertex `w`.\nWe need to add edges `(u, w)` and `(v, w)`. This makes a triangle `u-v-w-u`. This requires 3 vertices.\nIf `N=2`, we only have 2 vertices. We cannot add a third vertex.\nThis implies that if `N=2`, we can never form an odd cycle. But the problem states \"consisting of more than one vertex\". A cycle must have at least 3 vertices to be odd. A 2-vertex cycle (two parallel edges) is not allowed.\nSo if `N=2`, `t` is effectively infinity. However, the problem implies a solution always exists. This means `N >= 3`.\n\nSo, `m * (N - 2) = 0` implies `m = 0`.\nIf `m = 0`: The graph consists of `N` isolated vertices.\n    All `N` vertices can be assigned color 0. So `N_0 = N`, `N_1 = 0`.\n    `w_1 = N * (N - 1) / 2`.\n    If `N >= 2`, then `w_1 > 0`, so `t=1`. This is handled by Subcase 2.1.\n    The only case `w_1 = 0` is if `N < 2`, i.e., `N=0` or `N=1`. But `N` is at least 1.\n    If `N=1`, `w_1 = 0`. In this case, we cannot form a cycle of more than one vertex. The problem statement guarantees a cycle of more than one vertex. So `N` must be at least 2.\n    If `N=2, m=0`, then `C0=2, C1=0`. `w_1 = 2*(2-1)/2 = 1`. `t=1, w=1`. (Add edge between the two vertices).\n    So, the condition `w_1 = 0` implies that all components are isolated vertices or single edges, AND for each component, `C0_i <= 1` AND `C1_i <= 1`. This leads to `N_0 <= 1` or `N_1 <= 1` overall.\n    This means the graph is essentially a collection of isolated vertices and single edges, such that `N_0 <= 1` and `N_1 <= 1` for each component.\n    This means if `N_0 > 1` (or `N_1 > 1`), then `w_1 > 0`.\n    So `w_1 = 0` implies `N_0 <= 1` and `N_1 <= 1` for all components.\n    This means all components are either `C0=1, C1=0` (isolated vertex) or `C0=0, C1=1` (isolated vertex) or `C0=1, C1=1` (single edge).\n    This implies that the total number of vertices `N` is `N_iso + 2 * N_edge`.\n    If `w_1 = 0`, then `N_0 <= 1` and `N_1 <= 1` for ALL components implies that overall `N_0 <= N_iso` and `N_1 <= N_iso`.\n    If `N_0 >= 2` (or `N_1 >= 2`), then `w_1 > 0`.\n    So `w_1 = 0` means `N_0 < 2` AND `N_1 < 2` for the entire graph.\n    This means `N_0` is 0 or 1, and `N_1` is 0 or 1.\n    This is only possible if `N <= 2`.\n    If `N=1`, cannot form a cycle.\n    If `N=2, m=0`, `N_0=2, N_1=0` (or vice versa). `w_1=1`. `t=1`.\n    If `N=2, m=1`, `N_0=1, N_1=1`. `w_1=0`. `m*(N-2)=0`.\n    So, if `N=2, m=1`, then `t=2` is not possible by adding edges `(A, B)` and `(B, C)`.\n    In this case (`N=2, m=1`), we have vertices `u, v` and an edge `(u, v)`. We cannot add a third vertex. We cannot form an odd cycle. This scenario contradicts the problem's implicit guarantee that a solution exists.\n    This suggests that `N` must be at least 3 for `t=2` to be possible, or `N` must be at least 3 overall.\n    The problem constraints are `2 <= N <= 10^5`.\n    So `N=2` is possible. If `N=2, m=1`, this is `1 2` in the example. The output is `3 1`. This is confusing.\n\nLet's re-read the example `3 0`. Output `3 1`.\n`N=3, M=0`. Graph has 3 isolated vertices. Let them be `1, 2, 3`.\nColor all of them 0. `C0=3, C1=0`.\n`w_1 = 3*(3-1)/2 = 3`. So `t=1, w=3`. (Add `(1,2)` or `(1,3)` or `(2,3)`).\nThis example output `3 1` contradicts my logic of `t=1, w=3`.\n\nAh, the problem states \"simple cycle of an odd length, consisting of more than one vertex\".\nMy interpretation of `t=1` is correct. Adding an edge between two isolated vertices forms a cycle of length 3 if we consider the third vertex. No.\nIf `N=3, M=0`, vertices `1, 2, 3`.\nAdd edge `(1, 2)`. Now we have `1-2` and `3` isolated. This is not a cycle.\nTo form a cycle, we need to add edges `(1, 2)`, `(2, 3)`, `(3, 1)`. This is `t=3`.\nThere is only 1 way to add these 3 edges. So `t=3, w=1`. This matches the example.\n\nThis means my understanding of \"forming a cycle\" is different from the problem.\n\"form a simple cycle of an odd length\" does not mean \"make the graph non-bipartite\".\nIt means \"add edges such that the resulting graph contains an odd cycle *using only the added edges and some existing edges*\".\nAnd the cycle must be *simple*.\n\nLet's re-evaluate based on the example `3 0` -> `3 1`.\nIf `N=3, M=0`, we have three isolated vertices `v1, v2, v3`.\nTo form an odd cycle, the smallest is a triangle `v1-v2-v3-v1`. This requires adding three edges `(v1, v2), (v2, v3), (v3, v1)`. So `t=3`. There is only 1 way to choose these 3 edges. So `w=1`. This matches.\n\nThis implies that if `t=1`, the added edge `(u, v)` must close an odd cycle *with existing paths*.\nIf the graph is bipartite and `t=1` is possible:\n  Add an edge `(u, v)` where `u, v` are in the same component and have the same color.\n  This creates an odd cycle `u - path - v - u`. This cycle uses one added edge and existing edges.\n  This is still valid. So `t=1` for this case is still correct.\n\nWhat about `N=4, M=4` example?\nEdges: `(1,2), (1,3), (4,2), (4,3)`.\nThis graph is:\n1 -- 2\n|    |\n3 -- 4\nThis is a cycle `1-2-4-3-1` of length 4 (even).\nLet's color it:\n1 (0) -> 2 (1)\n1 (0) -> 3 (1)\n4 (0) -> 2 (1)\n4 (0) -> 3 (1)\nThis graph is bipartite. `V0 = {1, 4}`, `V1 = {2, 3}`.\n`C0=2, C1=2` for the single connected component.\n`w_1 = C0*(C0-1)/2 + C1*(C1-1)/2 = 2*(1)/2 + 2*(1)/2 = 1 + 1 = 2`.\nSo `t=1, w=2`.\nThe output for this example is `1 2`. This matches my `t=1` logic.\nThe two ways are:\n1.  Add `(1, 4)`. `1` and `4` are both color 0. This forms `1-2-4-1` (length 3) and `1-3-4-1` (length 3).\n2.  Add `(2, 3)`. `2` and `3` are both color 1. This forms `2-1-3-2` (length 3) and `2-4-3-2` (length 3).\n\nSo my `t=1` logic is correct. The issue is when `w_1 = 0`.\n`w_1 = 0` implies that for every component, `C0_i <= 1` AND `C1_i <= 1`.\nThis means every component is either an isolated vertex or a single edge.\n\nIf `w_1 = 0`, then `t` must be at least 2.\nConsider `t=2`.\nThe strategy was to pick `A, B, C` such that `(A, C)` is an existing edge, and add `(A, B)` and `(B, C)`.\nLet `A` be color 0, `C` color 1 (due to existing edge `(A, C)`).\nWe need to pick `B` (not `A` or `C`).\nIf `B` is color 0: add `(A, B)` and `(B, C)`. This forms a triangle `A-B-C-A`.\n  `A` (0) and `B` (0) must be in different components (since `w_1=0`).\n  `B` (0) and `C` (1) must be in different components (since `w_1=0` and `B` is not `A` or `C`).\n  This means `A, B, C` are all in different components.\n  Number of ways: `m * (N_0 - 1)` (if `A` is color 0) + `m * (N_1 - 1)` (if `A` is color 1).\n  This simplifies to `m * (N_0 - 1 + N_1 - 1) = m * (N - 2)`.\n  If this `m * (N - 2) > 0`, then `t=2, w=m*(N-2)`.\n\nLet's check example `3 3` -> `0 1`.\nEdges: `(1,2), (2,3), (3,1)`. This is a triangle `1-2-3-1`. Length 3 (odd).\nThe graph already contains an odd cycle. So `t=0, w=1`. This matches.\n\nSo, the logic so far seems to be:\n1.  Check if graph is bipartite.\n    *   If not bipartite: `t=0, w=1`.\n    *   If bipartite: Proceed to `t=1` check.\n2.  Calculate `w_1` (number of ways to add 1 edge to form an odd cycle).\n    *   If `w_1 > 0`: `t=1, w=w_1`.\n    *   If `w_1 = 0`: Proceed to `t=2` check.\n3.  Calculate `w_2` (number of ways to add 2 edges to form an odd cycle).\n    This case only happens if `w_1 = 0`. This implies all components are isolated vertices or single edges.\n    `w_2 = m * (N - 2)`.\n    *   If `w_2 > 0`: `t=2, w=w_2`.\n    *   If `w_2 = 0`: Proceed to `t=3` check.\n\nWhen is `w_2 = 0`?\n`m * (N - 2) = 0` means either `m = 0` or `N = 2`.\n    *   If `m = 0`: The graph has `N` isolated vertices.\n        Since `w_1 = 0`, this implies `N_0 <= 1` and `N_1 <= 1`.\n        If `m=0`, all vertices can be colored 0. So `N_0=N, N_1=0`.\n        `w_1 = N * (N - 1) / 2`. For `w_1` to be 0, `N < 2`.\n        So if `m=0` and `w_1=0`, it implies `N=1`. But `N>=2`.\n        So `m=0` implies `w_1 > 0` if `N>=2`.\n        This means `w_1=0` and `m=0` cannot happen simultaneously if `N>=2`.\n        Therefore, if `w_1=0`, it must be that `m > 0`.\n    *   If `N = 2`:\n        If `m=0` (two isolated vertices): `N_0=2, N_1=0`. `w_1 = 1`. `t=1, w=1`.\n        If `m=1` (one edge `(1,2)`): `N_0=1, N_1=1`. `w_1 = 0`.\n            In this case, `w_2 = m * (N - 2) = 1 * (2 - 2) = 0`.\n            So if `N=2, m=1`, then `t=1` and `t=2` are not possible.\n            This case (`N=2, m=1`) must be `t=3`.\n\n**Subcase 2.3: `t = 3`**\nThis case occurs when `w_1 = 0` AND `w_2 = 0`.\nAs analyzed above, this means `N=2, m=1`.\nGraph: `v1 - v2`.\nTo form an odd cycle, we need at least 3 vertices. We only have 2.\nThis implies we must add a new vertex. But the problem says \"add edges to the *given* graph\". We cannot add new vertices.\nSo, if `N=2, m=1`, it is impossible to form an odd cycle.\nHowever, the example `3 0` -> `3 1` suggests `t=3` is possible.\n`N=3, M=0`. `N_0=3, N_1=0`. `w_1 = 3*(2)/2 = 3`. So `t=1, w=3`.\nThe example output for `3 0` is `3 1`. This is the crucial discrepancy.\n\nLet's re-read the problem very carefully: \"You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex).\"\n\nThe specific wording \"form a simple cycle of an odd length\" when `M=0, N=3` means adding `(1,2), (2,3), (3,1)`. This results in `t=3`.\nMy `t=1` logic for `N=3, M=0` was: \"add `(1,2)`\". This is not a cycle. It's just an edge.\nThe odd cycle must be present in the *resulting* graph.\nSo if `M=0`, we must add at least 3 edges to form a triangle.\nNumber of ways to choose 3 vertices out of `N` and form a triangle is `N C 3`. For `N=3`, it's `3 C 3 = 1`.\nSo if `M=0`, `t=3`, `w = N*(N-1)*(N-2)/6`. This matches `3 0` -> `3 1`.\n\nSo the revised logic for `t` and `w`:\n\n**Algorithm:**\n\n1.  **Check for existing odd cycle (`t=0`):**\n    Perform a 2-coloring (BFS/DFS) on the graph.\n    `colors = array of size N+1, initialized to -1`\n    `is_bipartite = True`\n    `component_info = list of (C0, C1) for each component`\n    `visited = array of size N+1, initialized to False`\n    For `i` from 1 to `N`:\n        If `not visited[i]`:\n            `current_C0 = 0`, `current_C1 = 0`\n            `q = deque([(i, 0)])` (vertex, color)\n            `visited[i] = True`\n            `colors[i] = 0`\n            `current_C0 = 1`\n            While `q`:\n                `u, c = q.popleft()`\n                For each neighbor `v` of `u`:\n                    If `colors[v] == -1`: (unvisited)\n                        `colors[v] = 1 - c`\n                        `visited[v] = True`\n                        If `1 - c == 0`: `current_C0 += 1`\n                        Else: `current_C1 += 1`\n                        `q.append((v, 1 - c))`\n                    Else if `colors[v] == c`: (conflict: edge connects same colors)\n                        `is_bipartite = False`\n                        Break (from inner loop)\n                If `not is_bipartite`: Break (from outer loop)\n            If `is_bipartite`: `component_info.append((current_C0, current_C1))`\n\n    If `not is_bipartite`:\n        Print `0 1` and exit.\n\n2.  **Check for `t=1`:**\n    `w1 = 0`\n    For each `(C0, C1)` in `component_info`:\n        `w1 += C0 * (C0 - 1) // 2`\n        `w1 += C1 * (C1 - 1) // 2`\n    If `w1 > 0`:\n        Print `1 w1` and exit.\n\n3.  **Check for `t=2`:**\n    This implies `w1 = 0`.\n    `N_total = N` (total vertices)\n    `M_total = m` (total existing edges)\n    `w2 = M_total * (N_total - 2)`\n    If `w2 > 0`:\n        Print `2 w2` and exit.\n\n4.  **`t=3` (Only case left is `w1=0` and `w2=0`)**\n    This means either `M_total = 0` or `N_total = 2`.\n    If `N_total = 2`:\n        We must have `M_total = 1` for `w1=0`. (If `M_total=0`, `w1=1`).\n        Graph is `v1-v2`. Cannot form an odd cycle with 2 vertices.\n        This scenario `N=2, M=1` would mean `t` is impossible.\n        But problem implies a solution. This implies `N>=3` when `t=3`.\n        The problem constraints `N >= 2`.\n        If `N=2, M=1`, the problem cannot be solved. This contradicts the problem statement.\n        The only way to interpret `N=2, M=1` is that it's an invalid input for this problem.\n        Let's assume `N>=3` for this `t=3` case.\n    If `M_total = 0`: (This is the case from `3 0` example)\n        `w3 = N_total * (N_total - 1) * (N_total - 2) // 6` (number of ways to choose 3 vertices and form a triangle).\n        Print `3 w3` and exit.\n\nThis revised logic matches all examples.\nThe `N=2, M=1` case: `1-2`. `is_bipartite=True`. `component_info=[(1,1)]`. `w1=0`. `w2 = 1*(2-2)=0`.\nThen it falls to `t=3` case. `M_total=1`. Not `M_total=0`.\nThis implies that `N=2, M=1` is not handled by `t=3` logic.\nThis means my interpretation of \"when `w1=0` and `w2=0`\" is not quite right.\nIf `w1=0` and `w2=0` *and* `M_total > 0`, it means `N_total = 2`.\nIn this specific scenario (`N=2, M=1`), it is impossible to form an odd cycle.\nThe problem statement guarantees a solution.\n\"consisting of more than one vertex\" means the cycle length is `>= 3`. (A cycle of length 2 would be parallel edges, which are forbidden).\nSo, if `N=2, M=1`, it's impossible. This implies such an input will not be given, or `N` is always `>=3` when `M>0` and `w1=0`.\n\nLet's check the constraints: `N` up to `10^5`.\nThe calculation `N*(N-1)*(N-2)/6` can be large, use 64-bit integer (Python handles large integers automatically).\n\nFinal check on the `t=2` logic when `w1=0`:\n`w1=0` means every component is either an isolated vertex or a single edge.\nWe want to add 2 edges `(X, Y)` and `(Y, Z)` such that `(X, Z)` is an existing edge.\nLet `(X, Z)` be an existing edge. `X` is color 0, `Z` is color 1.\nWe need to pick a vertex `Y` (distinct from `X, Z`).\nIf `Y` is color 0: add `(X, Y)` and `(Y, Z)`.\n  `X` (0) and `Y` (0) are in different components (because `w1=0`).\n  `Y` (0) and `Z` (1) are in different components (because `w1=0`).\n  So `X, Y, Z` are all in different components.\n  Number of choices for `Y` (color 0) is `N_0 - 1` (total color 0 vertices minus `X`).\nIf `Y` is color 1: add `(X, Y)` and `(Y, Z)`.\n  `X` (0) and `Y` (1) are in different components.\n  `Y` (1) and `Z` (1) are in different components.\n  Number of choices for `Y` (color 1) is `N_1 - 1` (total color 1 vertices minus `Z`).\nTotal `w2 = m * ((N_0 - 1) + (N_1 - 1)) = m * (N - 2)`. This seems robust.\n\nThe only way `w2=0` is if `m=0` or `N=2`.\nIf `m=0`: This implies `N` isolated vertices. `w1 = N*(N-1)/2`.\n    If `N=1`, `w1=0`. But cannot form cycle.\n    If `N>=2`, `w1>0`. So `t=1`.\n    The only way `m=0` and `w1=0` is if `N<2`, which contradicts `N>=2`.\n    So if `m=0`, we always have `t=1` unless `N<2`.\n    Except for `N=3, M=0` example. Here `w1=3`. But output is `3 1`.\n    This implies my `t=1` logic \"add an edge `(u,v)` where `u,v` are in same component and same color\" is not what the problem means for `M=0`.\n    If `M=0`, *no* vertices are in the same component. All are isolated.\n    So, `w1` must be 0 if `M=0`.\n    My BFS/DFS for `M=0` and `N=3` would assign all `1,2,3` to color 0.\n    `component_info` would be `[(3,0)]`. `w1 = 3*(3-1)/2 = 3`.\n    This means my BFS/DFS coloring of `M=0` is not right for the problem's definition.\n    If `M=0`, vertices are isolated. There are no paths.\n    So `u` and `v` are *never* in the same component.\n    Therefore, if `M=0`, `w1` must be 0.\n\nRevised understanding for `M=0`:\nIf `M=0`, all `N` vertices are isolated.\nAny two vertices `u, v` are in *different* components.\nSo, `t=1` is impossible, because we cannot find `u, v` of same color *in the same component*.\nThus, if `M=0`, `t >= 2`.\nThe minimum is `t=3` (forming a triangle).\nNumber of ways to choose 3 vertices out of `N` is `N*(N-1)*(N-2)/6`.\nSo if `M=0`: `t=3, w = N*(N-1)*(N-2)/6`. This matches `3 0` -> `3 1`.\n\nFinal Algorithm Structure:\n\n1.  **If `M == 0`:**\n    Print `3 N*(N-1)*(N-2)//6` and exit.\n    (This covers the `3 0` example)\n\n2.  **General case (`M > 0`):**\n    Perform a 2-coloring (BFS/DFS) on the graph.\n    `colors = array of size N+1, initialized to -1`\n    `is_bipartite = True`\n    `component_info = list of (C0, C1) for each component`\n    `visited = array of size N+1, initialized to False`\n    `N0_total = 0`, `N1_total = 0` (Total count of colors across all components)\n\n    For `i` from 1 to `N`:\n        If `not visited[i]`:\n            `current_C0 = 0`, `current_C1 = 0`\n            `q = deque([(i, 0)])`\n            `visited[i] = True`\n            `colors[i] = 0`\n            `current_C0 = 1`\n            While `q`:\n                `u, c = q.popleft()`\n                For each neighbor `v` of `u`:\n                    If `colors[v] == -1`:\n                        `colors[v] = 1 - c`\n                        `visited[v] = True`\n                        If `1 - c == 0`: `current_C0 += 1`\n                        Else: `current_C1 += 1`\n                        `q.append((v, 1 - c))`\n                    Else if `colors[v] == c`:\n                        `is_bipartite = False`\n                        Break\n                If `not is_bipartite`: Break\n            If `not is_bipartite`: Break\n            `component_info.append((current_C0, current_C1))`\n            `N0_total += current_C0`\n            `N1_total += current_C1`\n\n    If `not is_bipartite`:\n        Print `0 1` and exit.\n\n    `w1 = 0`\n    For each `(C0, C1)` in `component_info`:\n        `w1 += C0 * (C0 - 1) // 2`\n        `w1 += C1 * (C1 - 1) // 2`\n\n    If `w1 > 0`:\n        Print `1 w1` and exit.\n\n    `w2 = M * (N - 2)`\n    Print `2 w2` and exit.\n\nThis covers all examples and edge cases (`M=0` now correctly handled).\nThe `N=2, M=1` case: `1-2`.\n`M=1 > 0`.\nBFS: `1` gets color 0, `2` gets color 1. `is_bipartite=True`. `component_info = [(1,1)]`. `N0_total=1, N1_total=1`.\n`w1 = 1*(0)/2 + 1*(0)/2 = 0`.\nThen `w2 = M * (N - 2) = 1 * (2 - 2) = 0`.\nThis implies it falls through to `t=3`. But `t=3` requires `M=0`.\nThis means if `N=2, M=1`, it is impossible to form an odd cycle.\nThis is a problem for the judge system. The problem statement implies a solution always exists.\nThe only way `N=2, M=1` is not problematic is if `N` is always `>=3` when `M>0` and `w1=0`.\nLet's assume the problem constraints or test cases guarantee `N>=3` when `M>0` and `w1=0`.\nIn that case, `N-2 >= 1`, so `w2 = M*(N-2)` will be `>0` since `M>0`.\nSo `t=2` will always be found if `w1=0` and `M>0`.\nThis means the `t=3` case only applies when `M=0`.\n\nThis refined logic seems sound.\n\n```python\nimport sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    if m == 0:\n        # If there are no edges, the only way to form a cycle is to add 3 edges for a triangle.\n        # This requires at least 3 vertices.\n        # Number of ways to choose 3 vertices out of N is N C 3.\n        if n < 3:\n            # If N < 3, it's impossible to form a cycle of more than one vertex.\n            # The problem statement implies a solution always exists.\n            # This case should not be reached based on problem constraints/guarantees.\n            # For competitive programming, assume N >= 3 if m=0 for t=3.\n            pass # Or raise an error/handle as impossible if allowed.\n        t = 3\n        w = n * (n - 1) * (n - 2) // 6\n        print(t, w)\n        return\n\n    adj = [[] for _ in range(n + 1)]\n    edges = [] # Store edges for later use if needed, though not explicitly used in this logic\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n        edges.append((u, v)) # Not strictly needed for this solution logic\n\n    colors = [-1] * (n + 1) # -1: uncolored, 0: color 0, 1: color 1\n    visited = [False] * (n + 1)\n    is_bipartite = True\n    component_info = [] # Stores (C0, C1) for each component\n    n0_total = 0\n    n1_total = 0\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            current_c0 = 0\n            current_c1 = 0\n            q = deque([(i, 0)]) # (vertex, color)\n            visited[i] = True\n            colors[i] = 0\n            current_c0 += 1\n\n            component_vertices = []\n            component_vertices.append(i)\n\n            head = 0\n            while head < len(q): # Using a list as a deque for performance on some systems, but deque is fine\n                u, c = q[head]\n                head += 1\n                \n                for v in adj[u]:\n                    if colors[v] == -1:\n                        colors[v] = 1 - c\n                        visited[v] = True\n                        if 1 - c == 0:\n                            current_c0 += 1\n                        else:\n                            current_c1 += 1\n                        q.append((v, 1 - c))\n                    elif colors[v] == c:\n                        is_bipartite = False\n                        # No need to break out of all loops immediately, \n                        # just mark it and continue coloring to get C0/C1 counts for current component\n                        # which might be useful if we need to count specific odd cycles\n                        # but for simple bipartite check, we can break.\n                        # For this problem, we need C0/C1 for t=1 even if not bipartite,\n                        # but if not bipartite, t=0, so we just need the flag.\n                        # So it's fine to break early.\n                        break\n                if not is_bipartite:\n                    break # Break from inner while loop\n\n            if not is_bipartite:\n                break # Break from outer for loop\n\n            component_info.append((current_c0, current_c1))\n            n0_total += current_c0\n            n1_total += current_c1\n\n\n    if not is_bipartite:\n        # Graph already contains an odd-length cycle\n        print(0, 1)\n        return\n\n    # Graph is bipartite. Check for t=1.\n    # We need to add an edge (u, v) where u and v are in the same component and have the same color.\n    w1 = 0\n    for c0, c1 in component_info:\n        w1 += c0 * (c0 - 1) // 2\n        w1 += c1 * (c1 - 1) // 2\n\n    if w1 > 0:\n        print(1, w1)\n        return\n\n    # Graph is bipartite, and t=1 is not possible.\n    # This means for every component, C0 <= 1 and C1 <= 1.\n    # So every component is either an isolated vertex or a single edge.\n    # Check for t=2.\n    # We can form a triangle (A,B,C) where (A,C) is an existing edge,\n    # and we add (A,B) and (B,C).\n    # A and C must have different colors (because (A,C) is an existing edge in a bipartite graph).\n    # Let A be color 0, C be color 1.\n    # We pick a third vertex B.\n    # If B is color 0, we add (A,B) and (B,C). Cycle A-B-C-A is odd.\n    #   (A,B) connects same colors (0,0). (B,C) connects different colors (0,1).\n    #   Since w1=0, A and B must be in different components.\n    #   Since w1=0, B and C must be in different components.\n    #   Number of choices for B (color 0) is n0_total - 1 (all color 0 vertices except A).\n    # If B is color 1, we add (A,B) and (B,C). Cycle A-B-C-A is odd.\n    #   (A,B) connects different colors (0,1). (B,C) connects same colors (1,1).\n    #   Since w1=0, B and C must be in different components.\n    #   Since w1=0, A and B must be in different components.\n    #   Number of choices for B (color 1) is n1_total - 1 (all color 1 vertices except C).\n    # Total ways to choose B is (n0_total - 1) + (n1_total - 1) = N - 2.\n    # For each of the M existing edges, we can apply this.\n    # So w2 = M * (N - 2).\n\n    # Note: If N=2, then N-2=0, so w2=0.\n    # If N=2, M=1, graph is 1-2. w1=0. w2=0.\n    # This implies t=3. But with 2 vertices, cannot form a triangle.\n    # This specific case (N=2, M=1) seems to be impossible based on logic.\n    # The problem implies a solution always exists.\n    # So we assume N >= 3 if M > 0 and w1 = 0.\n    # In this case (N >= 3 and M > 0), N-2 >= 1, so w2 > 0.\n    \n    t = 2\n    w = m * (n - 2)\n    print(t, w)\n\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    if m == 0:\n        # If there are no edges, the only way to form a cycle is to add 3 edges for a triangle.\n        # This requires at least 3 vertices.\n        # Number of ways to choose 3 vertices out of N is N C 3.\n        if n < 3:\n            # If N < 3, it's impossible to form a cycle of more than one vertex.\n            # The problem statement implies a solution always exists.\n            # This case should not be reached based on problem constraints/guarantees.\n            # For competitive programming, assume N >= 3 if m=0 for t=3.\n            pass # Or raise an error/handle as impossible if allowed.\n        t = 3\n        w = n * (n - 1) * (n - 2) // 6\n        print(t, w)\n        return\n\n    adj = [[] for _ in range(n + 1)]\n    edges = [] # Store edges for later use if needed, though not explicitly used in this logic\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n        edges.append((u, v)) # Not strictly needed for this solution logic\n\n    colors = [-1] * (n + 1) # -1: uncolored, 0: color 0, 1: color 1\n    visited = [False] * (n + 1)\n    is_bipartite = True\n    component_info = [] # Stores (C0, C1) for each component\n    n0_total = 0\n    n1_total = 0\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            current_c0 = 0\n            current_c1 = 0\n            q = deque([(i, 0)]) # (vertex, color)\n            visited[i] = True\n            colors[i] = 0\n            current_c0 += 1\n\n            component_vertices = []\n            component_vertices.append(i)\n\n            head = 0\n            while head < len(q): # Using a list as a deque for performance on some systems, but deque is fine\n                u, c = q[head]\n                head += 1\n                \n                for v in adj[u]:\n                    if colors[v] == -1:\n                        colors[v] = 1 - c\n                        visited[v] = True\n                        if 1 - c == 0:\n                            current_c0 += 1\n                        else:\n                            current_c1 += 1\n                        q.append((v, 1 - c))\n                    elif colors[v] == c:\n                        is_bipartite = False\n                        # No need to break out of all loops immediately, \n                        # just mark it and continue coloring to get C0/C1 counts for current component\n                        # which might be useful if we need to count specific odd cycles\n                        # but for simple bipartite check, we can break.\n                        # For this problem, we need C0/C1 for t=1 even if not bipartite,\n                        # but if not bipartite, t=0, so we just need the flag.\n                        # So it's fine to break early.\n                        break\n                if not is_bipartite:\n                    break # Break from inner while loop\n\n            if not is_bipartite:\n                break # Break from outer for loop\n\n            component_info.append((current_c0, current_c1))\n            n0_total += current_c0\n            n1_total += current_c1\n\n\n    if not is_bipartite:\n        # Graph already contains an odd-length cycle\n        print(0, 1)\n        return\n\n    # Graph is bipartite. Check for t=1.\n    # We need to add an edge (u, v) where u and v are in the same component and have the same color.\n    w1 = 0\n    for c0, c1 in component_info:\n        w1 += c0 * (c0 - 1) // 2\n        w1 += c1 * (c1 - 1) // 2\n\n    if w1 > 0:\n        print(1, w1)\n        return\n\n    # Graph is bipartite, and t=1 is not possible.\n    # This means for every component, C0 <= 1 and C1 <= 1.\n    # So every component is either an isolated vertex or a single edge.\n    # Check for t=2.\n    # We can form a triangle (A,B,C) where (A,C) is an existing edge,\n    # and we add (A,B) and (B,C).\n    # A and C must have different colors (because (A,C) is an existing edge in a bipartite graph).\n    # Let A be color 0, C be color 1.\n    # We pick a third vertex B.\n    # If B is color 0, we add (A,B) and (B,C). Cycle A-B-C-A is odd.\n    #   (A,B) connects same colors (0,0). (B,C) connects different colors (0,1).\n    #   Since w1=0, A and B must be in different components.\n    #   Since w1=0, B and C must be in different components.\n    #   Number of choices for B (color 0) is n0_total - 1 (all color 0 vertices except A).\n    # If B is color 1, we add (A,B) and (B,C). Cycle A-B-C-A is odd.\n    #   (A,B) connects different colors (0,1). (B,C) connects same colors (1,1).\n    #   Since w1=0, B and C must be in different components.\n    #   Since w1=0, A and B must be in different components.\n    #   Number of choices for B (color 1) is n1_total - 1 (all color 1 vertices except C).\n    # Total ways to choose B is (n0_total - 1) + (n1_total - 1) = N - 2.\n    # For each of the M existing edges, we can apply this.\n    # So w2 = M * (N - 2).\n\n    # Note: If N=2, then N-2=0, so w2=0.\n    # If N=2, M=1, graph is 1-2. w1=0. w2=0.\n    # This implies t=3. But with 2 vertices, cannot form a triangle.\n    # This specific case (N=2, M=1) seems to be impossible based on logic.\n    # The problem implies a solution always exists.\n    # So we assume N >= 3 if M > 0 and w1 = 0.\n    # In this case (N >= 3 and M > 0), N-2 >= 1, so w2 > 0.\n    \n    t = 2\n    w = m * (n - 2)\n    print(t, w)\n\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 604,
        "completion_token_count": 11147,
        "thoughts_token_count": 6803
    }
}