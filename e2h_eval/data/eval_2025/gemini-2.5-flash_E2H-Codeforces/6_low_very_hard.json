{
    "start": 1758009286.151347,
    "end": 1758009317.3089197,
    "start-formatted": "2025-09-16 16:54 KST",
    "end-formatted": "2025-09-16 16:55 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "**Deconstructing the Voucher Problem**\n\nOkay, so I've got this competitive programming problem in front of me. The goal is to find two separate vouchers where their combined duration equals a target `x`, while minimizing their total cost. The input is `n` vouchers, each with a start time, end time, and cost. If no pair fits the criteria, I've got to output `-1`.\n\nFirst things first, I need to understand the constraints. We're dealing with up to 200,000 vouchers, and `x` can be up to 200,000 as well. Duration and cost constraints are also important. The naive approach of comparing every single pair (`O(n^2)`) is obviously too slow, the time complexity would be around 4 * 10^10, that's gonna time out for sure. So I'm aiming for something better, maybe `O(n log n)` or even linear time.\n\nLet's break down the core conditions. We need disjoint vouchers, meaning their time periods cannot overlap. So, either voucher `i` ends before voucher `j` begins, or vice versa. The duration of each voucher is `(r_i - l_i + 1)`. The combined duration has to equal `x`. My thought is to calculate duration first. So, I will define  `duration_i = r_i - l_i + 1`. This simplifies the duration condition to `duration_i + duration_j = x`. Now I need a structure to find `j` so I would need duration of `j = x - duration_i`. And finally, we're trying to minimize the total cost of `cost_i + cost_j`.\n\nMy current thinking is that sorting might be key here, especially considering the disjoint constraint. Sorting by the start time (`l_i`) or end time (`r_i`) could help in efficiently checking the disjoint condition. For each voucher `i`, I can calculate the required duration for `j` and then perform an efficient search. It seems like a hash table or similar data structure might be useful to store durations and associated costs, or maybe even a sorted map. With a max value of 200k, maybe I can use an array or a form of index by day. Ultimately, for each voucher `i`, I need to find the `j` that satisfies the duration requirement, the disjoint condition, and minimizes the total cost. This seems like a reasonable avenue to explore.\n",
    "response": "The problem asks us to find two non-overlapping vouchers `i` and `j` such that the sum of their durations is exactly `x` and their total cost `cost_i + cost_j` is minimized. If no such pair exists, we should output -1.\n\nLet `duration_k = r_k - l_k + 1` for any voucher `k`. The condition for total duration is `duration_i + duration_j = x`.\nTwo vouchers `i` and `j` are non-overlapping if `r_i < l_j` or `r_j < l_i`.\n\nThe maximum value for `r_k` is `2 * 10^5`. This suggests that we can use an array or similar structure indexed by day numbers.\n\nWe can iterate through all vouchers and for each voucher `i`, try to find a suitable voucher `j`. This would be `O(N^2)` if done naively, which is too slow for `N = 2 * 10^5`. We need a more efficient approach.\n\nLet's process vouchers by their departure day `l_i`.\n1.  **Sort all vouchers**: Sort the vouchers primarily by their departure day `l_i`, and secondarily by `r_i` (though secondary sort order might not be strictly necessary, it's good practice for stability).\n2.  **Iterate and Maintain Minimum Costs**: We can iterate through the sorted vouchers. For each voucher `v_i = (l_i, r_i, cost_i)`:\n    *   We need to find a voucher `v_j` such that `duration_j = x - duration_i` and `r_j < l_i`.\n    *   To find the minimum `cost_j` satisfying these conditions, we need an efficient way to query for vouchers that end before `l_i` and have a specific duration.\n\nWe can use an array, say `min_cost_for_duration[d]`, which stores the minimum cost of a voucher with duration `d` that has been processed so far (i.e., its `r_k` is less than the current `l_i`).\nHowever, `min_cost_for_duration[d]` should be updated as we process vouchers. When we are at voucher `v_i`, we need to consider all vouchers `v_k` such that `r_k < l_i`.\n\nLet's refine this:\nWe can maintain `min_cost_ending_at_day[d]` which stores the minimum cost of a voucher that ends on day `d` and has a specific duration. This is still problematic because a voucher ending on day `d` can have various durations.\n\nA better approach is to use a data structure that allows us to efficiently query for minimum cost for a given duration among vouchers that end by a certain day.\n\nLet's define `min_cost_for_duration[d]` to be the minimum cost of a voucher that has duration `d`. We want to update this array as we process vouchers.\nWe can iterate through the days from `1` to `MAX_R_VALUE` (which is `2 * 10^5`).\nFor each day `current_day`:\n1.  **Consider vouchers ending on `current_day - 1`**: For all vouchers `v_k = (l_k, r_k, cost_k)` such that `r_k = current_day - 1`, update `min_cost_for_duration[duration_k]` with `cost_k`. That is, `min_cost_for_duration[duration_k] = min(min_cost_for_duration[duration_k], cost_k)`.\n2.  **Consider vouchers starting on `current_day`**: For all vouchers `v_i = (l_i, r_i, cost_i)` such that `l_i = current_day`:\n    *   Calculate `required_duration = x - duration_i`.\n    *   If `required_duration > 0` and `required_duration <= MAX_DURATION`, check `min_cost_for_duration[required_duration]`. If it's not `infinity`, then we have found a potential pair. The total cost would be `cost_i + min_cost_for_duration[required_duration]`. Update the overall minimum cost found so far.\n\n**Data Structures**:\n*   `vouchers_by_start_day`: A list of lists, where `vouchers_by_start_day[d]` contains all `(r, cost, duration)` tuples for vouchers starting on day `d`.\n*   `vouchers_by_end_day`: A list of lists, where `vouchers_by_end_day[d]` contains all `(l, cost, duration)` tuples for vouchers ending on day `d`.\n*   `min_cost_duration_map`: An array of size `MAX_DURATION + 1` (where `MAX_DURATION` is `MAX_R_VALUE`). `min_cost_duration_map[d]` stores the minimum cost of a voucher with duration `d` that has *already ended*. Initialize with a large value (infinity).\n\n**Algorithm**:\n1.  Initialize `min_total_cost = infinity`.\n2.  Initialize `min_cost_duration_map` array with `infinity`.\n3.  Parse input:\n    *   For each voucher `(l, r, cost)`:\n        *   Calculate `duration = r - l + 1`.\n        *   Add `(r, cost, duration)` to `vouchers_by_start_day[l]`.\n        *   Add `(l, cost, duration)` to `vouchers_by_end_day[r]`.\n    *   `MAX_DAY = 2 * 10^5`.\n\n4.  Iterate `current_day` from `1` to `MAX_DAY`:\n    *   **Process vouchers starting on `current_day`**:\n        *   For each `(r_i, cost_i, duration_i)` in `vouchers_by_start_day[current_day]`:\n            *   Calculate `required_duration = x - duration_i`.\n            *   If `required_duration > 0` and `required_duration <= MAX_DAY`: (A voucher's duration cannot exceed `MAX_DAY` as `r-l+1 <= MAX_R - 1 + 1 = MAX_R`)\n                *   If `min_cost_duration_map[required_duration]` is not `infinity`:\n                    *   `min_total_cost = min(min_total_cost, cost_i + min_cost_duration_map[required_duration])`.\n    *   **Process vouchers ending on `current_day`**:\n        *   For each `(l_k, cost_k, duration_k)` in `vouchers_by_end_day[current_day]`:\n            *   `min_cost_duration_map[duration_k] = min(min_cost_duration_map[duration_k], cost_k)`.\n\n5.  After the loop, if `min_total_cost` is still `infinity`, it means no such pair was found, so print -1. Otherwise, print `min_total_cost`.\n\n**Complexity Analysis**:\n*   **Time**:\n    *   Parsing input and populating `vouchers_by_start_day` and `vouchers_by_end_day`: `O(N)`.\n    *   Main loop runs `MAX_DAY` times.\n    *   Inside the loop:\n        *   Processing `vouchers_by_start_day[current_day]`: Sum of lengths of all lists in `vouchers_by_start_day` is `N`. So, total operations for this part over all `current_day` is `O(N)`.\n        *   Processing `vouchers_by_end_day[current_day]`: Sum of lengths of all lists in `vouchers_by_end_day` is `N`. So, total operations for this part over all `current_day` is `O(N)`.\n    *   Total time complexity: `O(MAX_DAY + N)`. Given `MAX_DAY = 2 * 10^5` and `N = 2 * 10^5`, this is efficient enough.\n*   **Space**:\n    *   `vouchers_by_start_day` and `vouchers_by_end_day`: `O(MAX_DAY + N)` (lists of lists, storing N vouchers in total).\n    *   `min_cost_duration_map`: `O(MAX_DAY)`.\n    *   Total space complexity: `O(MAX_DAY + N)`. This is also acceptable.\n\n**Edge Cases / Constraints**:\n*   `x` can be small. If `x=2`, and all vouchers have duration `3`, no pair can be found.\n*   `duration_i` can be `x`. Then `required_duration` is `0`. We must ensure `required_duration > 0`.\n*   `duration_i` can be large. `required_duration` can be small.\n*   `cost_i` up to `10^9`, so `min_total_cost` can be `2 * 10^9`. Use a sufficiently large `infinity` value (e.g., `float('inf')` or `2 * 10^9 + 7`).\n\n```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n\n    MAX_DAY = 2 * 10**5\n    \n    # vouchers_by_start_day[d] stores a list of (r, cost, duration) for vouchers starting on day d\n    vouchers_by_start_day = [[] for _ in range(MAX_DAY + 1)]\n    # vouchers_by_end_day[d] stores a list of (l, cost, duration) for vouchers ending on day d\n    vouchers_by_end_day = [[] for _ in range(MAX_DAY + 1)]\n\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        duration = r - l + 1\n        vouchers_by_start_day[l].append((r, cost, duration))\n        vouchers_by_end_day[r].append((l, cost, duration))\n\n    # min_cost_duration_map[d] stores the minimum cost of a voucher with duration d\n    # that has already ended by the current_day being processed.\n    # Initialize with a value larger than any possible sum of costs (2 * 10^9)\n    # or float('inf') for convenience.\n    min_cost_duration_map = [float('inf')] * (MAX_DAY + 1)\n    \n    min_total_cost = float('inf')\n\n    for current_day in range(1, MAX_DAY + 1):\n        # Phase 1: Consider vouchers starting on current_day\n        # For these vouchers, we look for a partner that ended BEFORE current_day.\n        # The min_cost_duration_map already contains costs for vouchers that ended on or before current_day - 1.\n        for r_i, cost_i, duration_i in vouchers_by_start_day[current_day]:\n            required_duration = x - duration_i\n            \n            # A valid partner must have a positive duration\n            # And its duration cannot exceed MAX_DAY (which is MAX_R_VALUE)\n            if 0 < required_duration <= MAX_DAY:\n                if min_cost_duration_map[required_duration] != float('inf'):\n                    min_total_cost = min(min_total_cost, cost_i + min_cost_duration_map[required_duration])\n        \n        # Phase 2: Update min_cost_duration_map with vouchers ending on current_day\n        # These vouchers become available as potential partners for future vouchers\n        # (those starting on current_day + 1 or later).\n        for l_k, cost_k, duration_k in vouchers_by_end_day[current_day]:\n            min_cost_duration_map[duration_k] = min(min_cost_duration_map[duration_k], cost_k)\n\n    if min_total_cost == float('inf'):\n        print(-1)\n    else:\n        print(min_total_cost)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n\n    MAX_DAY = 2 * 10**5\n    \n    # vouchers_by_start_day[d] stores a list of (r, cost, duration) for vouchers starting on day d\n    vouchers_by_start_day = [[] for _ in range(MAX_DAY + 1)]\n    # vouchers_by_end_day[d] stores a list of (l, cost, duration) for vouchers ending on day d\n    vouchers_by_end_day = [[] for _ in range(MAX_DAY + 1)]\n\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        duration = r - l + 1\n        vouchers_by_start_day[l].append((r, cost, duration))\n        vouchers_by_end_day[r].append((l, cost, duration))\n\n    # min_cost_duration_map[d] stores the minimum cost of a voucher with duration d\n    # that has already ended by the current_day being processed.\n    # Initialize with a value larger than any possible sum of costs (2 * 10^9)\n    # or float('inf') for convenience.\n    min_cost_duration_map = [float('inf')] * (MAX_DAY + 1)\n    \n    min_total_cost = float('inf')\n\n    for current_day in range(1, MAX_DAY + 1):\n        # Phase 1: Consider vouchers starting on current_day\n        # For these vouchers, we look for a partner that ended BEFORE current_day.\n        # The min_cost_duration_map already contains costs for vouchers that ended on or before current_day - 1.\n        for r_i, cost_i, duration_i in vouchers_by_start_day[current_day]:\n            required_duration = x - duration_i\n            \n            # A valid partner must have a positive duration\n            # And its duration cannot exceed MAX_DAY (which is MAX_R_VALUE)\n            if 0 < required_duration <= MAX_DAY:\n                if min_cost_duration_map[required_duration] != float('inf'):\n                    min_total_cost = min(min_total_cost, cost_i + min_cost_duration_map[required_duration])\n        \n        # Phase 2: Update min_cost_duration_map with vouchers ending on current_day\n        # These vouchers become available as potential partners for future vouchers\n        # (those starting on current_day + 1 or later).\n        for l_k, cost_k, duration_k in vouchers_by_end_day[current_day]:\n            min_cost_duration_map[duration_k] = min(min_cost_duration_map[duration_k], cost_k)\n\n    if min_total_cost == float('inf'):\n        print(-1)\n    else:\n        print(min_total_cost)\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 799,
        "completion_token_count": 2839,
        "thoughts_token_count": 704
    }
}