{
    "start": 1758284862.843437,
    "end": 1758284899.0373175,
    "start-formatted": "2025-09-19 21:27 KST",
    "end-formatted": "2025-09-19 21:28 KST",
    "gpu": 2,
    "pid": 57,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Olympiad\n\nA boy named Vasya has taken part in an Olympiad. His teacher knows that in total Vasya got at least x points for both tours of the Olympiad. The teacher has the results of the first and the second tour of the Olympiad but the problem is, the results have only points, no names. The teacher has to know Vasya's chances.Help Vasya's teacher, find two numbers — the best and the worst place Vasya could have won. Note that the total results' table sorts the participants by the sum of points for both tours (the first place has the participant who has got the most points). If two or more participants have got the same number of points, it's up to the jury to assign places to them according to their choice. It is guaranteed that each participant of the Olympiad participated in both tours of the Olympiad.\n\n## Input\nThe first line contains two space-separated integers n, x (1 ≤ n ≤ 105; 0 ≤ x ≤ 2·105) — the number of Olympiad participants and the minimum number of points Vasya earned.The second line contains n space-separated integers: a1, a2, ..., an (0 ≤ ai ≤ 105) — the participants' points in the first tour.The third line contains n space-separated integers: b1, b2, ..., bn (0 ≤ bi ≤ 105) — the participants' points in the second tour.The participants' points are given in the arbitrary order. It is guaranteed that Vasya was present in the Olympiad — there are two integers i, j (1 ≤ i, j ≤ n) such, that ai + bj ≥ x.\n\n## Output\nPrint two space-separated integers — the best and the worst place Vasya could have got on the Olympiad.\n\n## Example\n### Input\n['5 2\\n1 1 1 1 1\\n1 1 1 1 1', '6 7\\n4 3 5 6 4 4\\n8 6 0 4 3 4']\n\n### Output\n['1 5', '1 5']\n\n## Note\nIn the first text sample all 5 participants earn 2 points each in any case. Depending on the jury's decision, Vasya can get the first (the best) as well as the last (the worst) fifth place.In the second test sample in the best case scenario Vasya wins again: he can win 12 points and become the absolute winner if the total results' table looks like that — {4:8, 6:4, 3:6, 4:4, 4:3, 5:0}.In this table all participants are sorted by decreasing points and we can see how much a participant earned in the first and in the second tour.In the worst case scenario Vasya can get the fifth place if the table looks like that — {4:8, 4:6, 6:4, 5:4, 4:3, 3:0}, and he earned 4 and 3 points in the first and second tours, correspondingly.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "**Optimizing Vasya's Olympiad Rank: A Deep Dive**\n\nOkay, so I'm tackling this Olympiad ranking problem. The core of it is figuring out the *best* and *worst* possible ranks for Vasya, given his minimum total score and everyone else's scores from two tours. The input gives me `n` participants, the minimum score `x`, and two lists of scores, `a` and `b`, representing the points for each participant in the two tours. The tricky part is the scores aren't paired yet.\n\nMy first thought is, this is a sorting and combination problem with a constraint.  I've got to find the optimal pairings of scores to either maximize or minimize Vasya's final rank.  The scoring is pretty straightforward: rank is determined by total score, ties are handled arbitrarily by the judges.\n\nLet's break down what \"best\" and \"worst\" actually mean. For the **best rank**, I need Vasya's total score to be as high as possible, and everyone else's to be as low as possible. If Vasya has, say, `S` points, and `p` people are ahead of him (strictly), his best rank is `p+1`. I need to minimize that `p`.  Conversely, for the **worst rank**, I want Vasya's score to be as *low* as possible (while still meeting the `x` threshold), and everyone else's score as high as possible. If he gets `S` points and there are `p` people strictly better than him and `k` people are tied with him, then the worst rank is `p + k + 1`.  I need to maximize *this* value.\n\nSo, to find the **best rank**: I want Vasya's score as high as possible.  I'll start by assigning him the highest score from the first tour and the highest from the second tour. That maximizes Vasya's potential score!  However, there's a catch: the problem states that Vasya needs to achieve at least `x` total points. If that combination gives me less than `x`, I have to adjust, and the problem guarantees a valid pairing. I'll need to figure out the minimal adjustment to make Vasya reach `x` and then optimize the rest. It seems the guaranteed valid combination helps a lot.\n\nNow, I'm thinking about how this \"optimization\" will influence other people's score. I see this as a combinatorial process to select two values that satisfy the condition and minimize the ranks. The more people with scores better or equal than Vasya the worse his rank will be.\n",
    "response": "```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    a.sort()\n    b.sort()\n\n    # Calculate best rank\n    # To maximize Vasya's score, he takes the largest a_i and largest b_j.\n    # To minimize other participants' scores, we pair the remaining largest a_i with smallest b_j, etc.\n    # The crucial part for best rank is to make Vasya's score as high as possible\n    # and other scores as low as possible.\n    # Vasya's best rank is 1 if he can achieve the highest total score,\n    # or if he has a score S and everyone else has score <= S.\n    # We want to count how many participants *must* have a score strictly greater than Vasya's.\n    # If Vasya takes a[i] and b[j], then his score is a[i] + b[j].\n    # The remaining n-1 scores are formed by pairing the remaining elements.\n    # To minimize the number of people strictly better than Vasya,\n    # we should maximize Vasya's score and minimize other people's scores.\n    # A simple way to do this is to take the largest a_i and largest b_j for Vasya.\n    # Let Vasya's score be S_V = a[n-1] + b[n-1].\n    # Then we pair (a[0], b[0]), (a[1], b[1]), ..., (a[n-2], b[n-2]) for others.\n    # However, this specific pairing strategy is not what we need for best rank.\n    # We need to find *any* pairing that gives Vasya the highest possible score >= x,\n    # and then count how many *other* people *must* score higher than him.\n    # This can be simplified: what is the maximum possible score Vasya can achieve?\n    # It's max(a_i + b_j) such that a_i + b_j >= x.\n    # This is a[n-1] + b[n-1]. Let this be S_max.\n    # If Vasya gets S_max, can anyone else get strictly more than S_max? No.\n    # Can anyone else get S_max? Yes, if there are other pairs summing to S_max.\n    # But for best rank, if Vasya has S_max, he can always be assigned 1st place\n    # among those with S_max points. So, best rank is always 1.\n    # The guarantee \"there are two integers i, j (1 <= i, j <= n) such, that ai + bj >= x\"\n    # means Vasya can always achieve a score of at least x.\n    # Since he can pick the highest a_i and highest b_j, his score can be a[n-1] + b[n-1].\n    # No one can score more than a[n-1] + b[n-1]. So, Vasya can always be 1st.\n    best_rank = 1\n\n    # Calculate worst rank\n    # To maximize Vasya's worst rank, we want his score to be as low as possible (but >= x),\n    # and as many other people as possible to score higher than or equal to him.\n    # We use a greedy approach. Sort 'a' in ascending order and 'b' in descending order.\n    # This pairing (a[i], b[n-1-i]) tends to equalize scores.\n    # For example, (smallest a, largest b), (second smallest a, second largest b), etc.\n    # This strategy maximizes the number of people who score high.\n    # The problem is that Vasya is one of the participants. We don't know which pair is Vasya's.\n    # We want to find a matching between 'a' and 'b' such that:\n    # 1. One pair (a_vasya, b_vasya) has sum S_vasya >= x.\n    # 2. The number of other pairs (a_k, b_k) with sum S_k >= S_vasya is maximized.\n\n    # Let's sort 'a' in ascending order.\n    # Let's sort 'b' in ascending order.\n    # We iterate through possible scores Vasya could have.\n    # Vasya's score will be a[i] + b[j].\n    # To maximize his worst rank, we assume he gets the lowest possible score S_V >= x.\n    # Let's try to match a[i] with b[j] for Vasya.\n    # If Vasya takes a[i] and b[j], his score is S = a[i] + b[j].\n    # We need to count how many other participants can score >= S.\n    # The remaining scores are from a[:i] + a[i+1:] and b[:j] + b[j+1:].\n    # This is complex because the remaining elements are not contiguous.\n\n    # A simpler approach for worst rank:\n    # We want to find a permutation of 'b' (let's call it 'b_perm') such that\n    # Vasya's score `a[i] + b_perm[i]` is minimal (but >= x) for some `i`,\n    # AND the number of `k` such that `a[k] + b_perm[k] >= a[i] + b_perm[i]` is maximal.\n    # Consider sorting `a` ascendingly. `a_0, a_1, ..., a_{n-1}`.\n    # Consider sorting `b` descendingly. `b'_{n-1}, b'_{n-2}, ..., b'_0`.\n    # If we pair `(a_i, b'_{n-1-i})`, this strategy tends to create high scores for many people.\n    # E.g., `a_0 + b'_{n-1}`, `a_1 + b'_{n-2}`, ..., `a_{n-1} + b'_0`.\n    # This is a fixed set of `n` sums. Vasya is one of them.\n    # Which one is Vasya? He is the one whose sum `S_V` is minimal among these sums,\n    # but still `S_V >= x`.\n    # We can iterate through each `a_i` and try to match it with `b_j` to form Vasya's score.\n    # For a fixed `a_i` as Vasya's first tour score:\n    # To make Vasya's score `S_V` as low as possible but `S_V >= x`,\n    # he should pick `b_j` such that `a_i + b_j` is minimal and `>= x`.\n    # This `b_j` can be found using binary search (bisect_left) on sorted `b`.\n    # Let `b_target = x - a_i`. We need `b_j >= b_target`.\n    # `b_idx = bisect_left(b, b_target)`. If `b_idx == n`, no such `b_j` exists for this `a_i`.\n    # Otherwise, `b[b_idx]` is the smallest `b_j` that satisfies `a_i + b_j >= x`.\n    # So, `S_V = a_i + b[b_idx]`.\n    # Now, with this `S_V`, we need to count how many other participants can score `>= S_V`.\n    # This is the tricky part. We must use a different `a_k` and `b_l` for others.\n\n    # Let's consider the problem from a different angle for worst rank.\n    # We want to find a matching `(a_i, b_{p_i})` for all `i` (where `p` is a permutation)\n    # such that for some `k`, `a_k + b_{p_k} >= x`, and the number of `j` where\n    # `a_j + b_{p_j} >= a_k + b_{p_k}` is maximized.\n    # This is equivalent to finding a matching that maximizes the number of pairs `(a_i, b_j)`\n    # that sum to at least `S` for some `S`, where `S` is Vasya's score.\n    # And `S` should be the smallest possible score Vasya can get in this matching.\n\n    # Consider the problem of finding the maximum number of pairs `(a_i, b_j)`\n    # such that `a_i + b_j >= K` for a given `K`.\n    # Sort `a` ascending. Sort `b` descending.\n    # Use two pointers: `ptr_a` for `a` (starts at 0), `ptr_b` for `b` (starts at 0).\n    # If `a[ptr_a] + b[ptr_b] >= K`, then we can form a pair. Increment `ptr_a` and `ptr_b`. Count this.\n    # If `a[ptr_a] + b[ptr_b] < K`, `a[ptr_a]` is too small to pair with `b[ptr_b]`.\n    # Since `b` is sorted descending, `b[ptr_b]` is the largest available `b`.\n    # So `a[ptr_a]` cannot form a sum `>= K` with any remaining `b`.\n    # We must discard `a[ptr_a]` (it will be paired with some other `b` that results in < K).\n    # Increment `ptr_a`.\n    # This greedy strategy counts the maximum number of pairs that sum to at least `K`.\n\n    # Let's apply this for worst rank.\n    # We want to find the smallest `S` (Vasya's score) such that:\n    # 1. `S >= x`\n    # 2. The maximum number of pairs that sum to at least `S` is `k`.\n    # 3. Vasya is one of these `k` pairs.\n    # The worst rank will be `k`.\n    # This means we are looking for the smallest `S >= x` such that\n    # `count_pairs_ge_S(a, b) = k` and `k` is maximized.\n    # The function `count_pairs_ge_S(a, b)` is monotonically non-increasing with `S`.\n    # So, we can binary search for `S`.\n    # The possible values for `S` range from `x` to `2 * 10^5` (max `a_i + b_j`).\n    # Let `check(S)` be the function that returns the maximum number of pairs `(a_i, b_j)`\n    # that can be formed such that `a_i + b_j >= S`.\n\n    # `a` is sorted ascending. `b` is sorted ascending.\n    # To count pairs for `check(S)`:\n    # We want to use `a_i` and `b_j` to make `a_i + b_j >= S`.\n    # Use two pointers: `i` for `a` (from left, 0) and `j` for `b` (from right, n-1).\n    # `count = 0`\n    # While `i < n` and `j >= 0`:\n    #   If `a[i] + b[j] >= S`:\n    #     We can form a pair `(a[i], b[j])`. Increment `count`.\n    #     Move to next `a` (smaller `a_i` might still pair with `b_j` or smaller `b_k` to form sum >= S).\n    #     Move to previous `b` (larger `b_j` might still pair with `a_i` or larger `a_k`).\n    #     To maximize pairs, we should use `a[i]` and `b[j]` and then consider `a[i+1]` and `b[j-1]`.\n    #     This is the standard greedy matching for maximum pairs >= S.\n    #     `i += 1`\n    #     `j -= 1`\n    #   Else (`a[i] + b[j] < S`):\n    #     `a[i]` is too small to pair with `b[j]` (the largest remaining `b`) to reach `S`.\n    #     So `a[i]` cannot be part of a pair summing to `>= S` using any remaining `b`.\n    #     We must discard `a[i]` for this purpose.\n    #     `i += 1`\n    # Return `count`.\n\n    def count_ge_S(current_S):\n        # a is sorted ascending, b is sorted ascending\n        # We want to find max number of pairs (a_i, b_j) such that a_i + b_j >= current_S\n        # Use two pointers: one for 'a' from left, one for 'b' from right\n        # This is a common greedy strategy for this type of problem.\n        count = 0\n        left_a = 0\n        right_b = n - 1\n        while left_a < n and right_b >= 0:\n            if a[left_a] + b[right_b] >= current_S:\n                # Found a valid pair. Use a[left_a] and b[right_b].\n                # Move both pointers inwards.\n                count += 1\n                left_a += 1\n                right_b -= 1\n            else:\n                # a[left_a] is too small to pair with b[right_b] (the largest available b)\n                # to reach current_S. So a[left_a] cannot form a valid pair with any\n                # remaining b. Discard a[left_a].\n                left_a += 1\n        return count\n\n    # Binary search for the smallest S (Vasya's score) >= x that maximizes count_ge_S(S).\n    # The range for S is [x, 2 * 10^5 + 1]\n    # We want to find the smallest S_vasya >= x such that count_ge_S(S_vasya) is maximized.\n    # The function count_ge_S(S) is non-increasing.\n    # We want to find `S_0` such that `count_ge_S(S_0)` is maximal, and `S_0 >= x`.\n    # If there are multiple `S` values that give the same maximal count, we pick the smallest `S`.\n\n    # Binary search over the possible values of Vasya's score `S`.\n    # `low` = `x`, `high` = `2 * 10^5` (max possible sum) + 1.\n    # We are looking for the smallest `S` in `[x, 2*10^5]` that maximizes `count_ge_S(S)`.\n    # This is slightly tricky. We need to find the `S` that gives the maximum count.\n    # Then, among all `S` values that give this maximum count, we pick the smallest `S`.\n\n    # First, find the maximum possible count.\n    # The maximum count is `n`. This happens when `S` is very small (e.g., 0).\n    # The minimum count is `0`.\n    # We can binary search for the *value* of the count.\n    # Let `max_possible_count = count_ge_S(x)`. This is the count for the lowest possible Vasya score.\n    # This is a good candidate for the worst rank.\n    # The problem asks for the worst place Vasya *could* have won.\n    # This means we fix a matching that maximizes the number of people scoring >= Vasya.\n    # Vasya's score must be >= x.\n    # The `check(S)` function counts how many people can score >= S.\n    # We want to find the minimal Vasya's score `S_V >= x` such that `count_ge_S(S_V)` is maximized.\n    # And the answer is `count_ge_S(S_V)`.\n\n    # Let's re-evaluate the worst rank strategy.\n    # We want to maximize the number of people who score >= Vasya.\n    # This means we want Vasya's score to be as low as possible (but >= x).\n    # If Vasya's score is `S`, then the number of people who score `P >= S` is `count_ge_S(S)`.\n    # We need to find the `S` that maximizes this `count_ge_S(S)` while `S >= x`.\n    # Since `count_ge_S(S)` is non-increasing, to maximize it, we should pick the smallest possible `S`.\n    # The smallest possible `S` is `x`.\n    # So, Vasya's worst rank is `count_ge_S(x)`.\n    # This is because if Vasya gets score `S_V = x`, then `count_ge_S(x)` participants (including Vasya)\n    # can get at least `x` points. Vasya could be the last among them.\n    # Any score `S_V > x` would result in `count_ge_S(S_V) <= count_ge_S(x)`.\n    # So, taking `S_V = x` maximizes the number of people who score at least `S_V`.\n    # The problem guarantees that Vasya can score at least `x`.\n    # So, `count_ge_S(x)` is the maximum possible number of people who can score at least `x`.\n    # Vasya is one of these people, and the jury can place him last among them.\n    # Thus, his worst rank is `count_ge_S(x)`.\n    \n    worst_rank = count_ge_S(x)\n\n    sys.stdout.write(f\"{best_rank} {worst_rank}\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    a.sort()\n    b.sort()\n\n    # Calculate best rank\n    # To maximize Vasya's score, he takes the largest a_i and largest b_j.\n    # To minimize other participants' scores, we pair the remaining largest a_i with smallest b_j, etc.\n    # The crucial part for best rank is to make Vasya's score as high as possible\n    # and other scores as low as possible.\n    # Vasya's best rank is 1 if he can achieve the highest total score,\n    # or if he has a score S and everyone else has score <= S.\n    # We want to count how many participants *must* have a score strictly greater than Vasya's.\n    # If Vasya takes a[i] and b[j], then his score is a[i] + b[j].\n    # The remaining n-1 scores are formed by pairing the remaining elements.\n    # To minimize the number of people strictly better than Vasya,\n    # we should maximize Vasya's score and minimize other people's scores.\n    # A simple way to do this is to take the largest a_i and largest b_j for Vasya.\n    # Let Vasya's score be S_V = a[n-1] + b[n-1].\n    # Then we pair (a[0], b[0]), (a[1], b[1]), ..., (a[n-2], b[n-2]) for others.\n    # However, this specific pairing strategy is not what we need for best rank.\n    # We need to find *any* pairing that gives Vasya the highest possible score >= x,\n    # and then count how many *other* people *must* score higher than him.\n    # This can be simplified: what is the maximum possible score Vasya can achieve?\n    # It's max(a_i + b_j) such that a_i + b_j >= x.\n    # This is a[n-1] + b[n-1]. Let this be S_max.\n    # If Vasya gets S_max, can anyone else get strictly more than S_max? No.\n    # Can anyone else get S_max? Yes, if there are other pairs summing to S_max.\n    # But for best rank, if Vasya has S_max, he can always be assigned 1st place\n    # among those with S_max points. So, best rank is always 1.\n    # The guarantee \"there are two integers i, j (1 <= i, j <= n) such, that ai + bj >= x\"\n    # means Vasya can always achieve a score of at least x.\n    # Since he can pick the highest a_i and highest b_j, his score can be a[n-1] + b[n-1].\n    # No one can score more than a[n-1] + b[n-1]. So, Vasya can always be 1st.\n    best_rank = 1\n\n    # Calculate worst rank\n    # To maximize Vasya's worst rank, we want his score to be as low as possible (but >= x),\n    # and as many other people as possible to score higher than or equal to him.\n    # We use a greedy approach. Sort 'a' in ascending order and 'b' in descending order.\n    # This pairing (a[i], b[n-1-i]) tends to equalize scores.\n    # For example, (smallest a, largest b), (second smallest a, second largest b), etc.\n    # This strategy maximizes the number of people who score high.\n    # The problem is that Vasya is one of the participants. We don't know which pair is Vasya's.\n    # We want to find a matching between 'a' and 'b' such that:\n    # 1. One pair (a_vasya, b_vasya) has sum S_vasya >= x.\n    # 2. The number of other pairs (a_k, b_k) with sum S_k >= S_vasya is maximized.\n\n    # Let's sort 'a' in ascending order.\n    # Let's sort 'b' in ascending order.\n    # We iterate through possible scores Vasya could have.\n    # Vasya's score will be a[i] + b[j].\n    # To maximize his worst rank, we assume he gets the lowest possible score S_V >= x.\n    # Let's try to match a[i] with b[j] for Vasya.\n    # If Vasya takes a[i] and b[j], his score is S = a[i] + b[j].\n    # We need to count how many other participants can score >= S.\n    # The remaining scores are from a[:i] + a[i+1:] and b[:j] + b[j+1:].\n    # This is complex because the remaining elements are not contiguous.\n\n    # A simpler approach for worst rank:\n    # We want to find a permutation of 'b' (let's call it 'b_perm') such that\n    # Vasya's score `a[i] + b_perm[i]` is minimal (but >= x) for some `i`,\n    # AND the number of `k` such that `a[k] + b_perm[k] >= a[i] + b_perm[i]` is maximal.\n    # Consider sorting `a` ascendingly. `a_0, a_1, ..., a_{n-1}`.\n    # Consider sorting `b` descendingly. `b'_{n-1}, b'_{n-2}, ..., b'_0`.\n    # If we pair `(a_i, b'_{n-1-i})`, this strategy tends to create high scores for many people.\n    # E.g., `a_0 + b'_{n-1}`, `a_1 + b'_{n-2}`, ..., `a_{n-1} + b'_0`.\n    # This is a fixed set of `n` sums. Vasya is one of them.\n    # Which one is Vasya? He is the one whose sum `S_V` is minimal among these sums,\n    # but still `S_V >= x`.\n    # We can iterate through each `a_i` and try to match it with `b_j` to form Vasya's score.\n    # For a fixed `a_i` as Vasya's first tour score:\n    # To make Vasya's score `S_V` as low as possible but `S_V >= x`,\n    # he should pick `b_j` such that `a_i + b_j` is minimal and `>= x`.\n    # This `b_j` can be found using binary search (bisect_left) on sorted `b`.\n    # Let `b_target = x - a_i`. We need `b_j >= b_target`.\n    # `b_idx = bisect_left(b, b_target)`. If `b_idx == n`, no such `b_j` exists for this `a_i`.\n    # Otherwise, `b[b_idx]` is the smallest `b_j` that satisfies `a_i + b_j >= x`.\n    # So, `S_V = a_i + b[b_idx]`.\n    # Now, with this `S_V`, we need to count how many other participants can score `>= S_V`.\n    # This is the tricky part. We must use a different `a_k` and `b_l` for others.\n\n    # Let's consider the problem from a different angle for worst rank.\n    # We want to find a matching `(a_i, b_{p_i})` for all `i` (where `p` is a permutation)\n    # such that for some `k`, `a_k + b_{p_k} >= x`, and the number of `j` where\n    # `a_j + b_{p_j} >= a_k + b_{p_k}` is maximized.\n    # This is equivalent to finding a matching that maximizes the number of pairs `(a_i, b_j)`\n    # that sum to at least `S` for some `S`, where `S` is Vasya's score.\n    # And `S` should be the smallest possible score Vasya can get in this matching.\n\n    # Consider the problem of finding the maximum number of pairs `(a_i, b_j)`\n    # such that `a_i + b_j >= K` for a given `K`.\n    # Sort `a` ascending. Sort `b` descending.\n    # Use two pointers: `ptr_a` for `a` (starts at 0), `ptr_b` for `b` (starts at 0).\n    # If `a[ptr_a] + b[ptr_b] >= K`, then we can form a pair. Increment `ptr_a` and `ptr_b`. Count this.\n    # If `a[ptr_a] + b[ptr_b] < K`, `a[ptr_a]` is too small to pair with `b[ptr_b]`.\n    # Since `b` is sorted descending, `b[ptr_b]` is the largest available `b`.\n    # So `a[ptr_a]` cannot form a sum `>= K` with any remaining `b`.\n    # We must discard `a[ptr_a]` (it will be paired with some other `b` that results in < K).\n    # Increment `ptr_a`.\n    # This greedy strategy counts the maximum number of pairs that sum to at least `K`.\n\n    # Let's apply this for worst rank.\n    # We want to find the smallest `S` (Vasya's score) such that:\n    # 1. `S >= x`\n    # 2. The maximum number of pairs that sum to at least `S` is `k`.\n    # 3. Vasya is one of these `k` pairs.\n    # The worst rank will be `k`.\n    # This means we are looking for the smallest `S >= x` such that\n    # `count_pairs_ge_S(a, b) = k` and `k` is maximized.\n    # The function `count_pairs_ge_S(a, b)` is monotonically non-increasing with `S`.\n    # So, we can binary search for `S`.\n    # The possible values for `S` range from `x` to `2 * 10^5` (max `a_i + b_j`).\n    # Let `check(S)` be the function that returns the maximum number of pairs `(a_i, b_j)`\n    # that can be formed such that `a_i + b_j >= S`.\n\n    # `a` is sorted ascending. `b` is sorted ascending.\n    # To count pairs for `check(S)`:\n    # We want to use `a_i` and `b_j` to make `a_i + b_j >= S`.\n    # Use two pointers: `i` for `a` (from left, 0) and `j` for `b` (from right, n-1).\n    # `count = 0`\n    # While `i < n` and `j >= 0`:\n    #   If `a[i] + b[j] >= S`:\n    #     We can form a pair `(a[i], b[j])`. Increment `count`.\n    #     Move to next `a` (smaller `a_i` might still pair with `b_j` or smaller `b_k` to form sum >= S).\n    #     Move to previous `b` (larger `b_j` might still pair with `a_i` or larger `a_k`).\n    #     To maximize pairs, we should use `a[i]` and `b[j]` and then consider `a[i+1]` and `b[j-1]`.\n    #     This is the standard greedy matching for maximum pairs >= S.\n    #     `i += 1`\n    #     `j -= 1`\n    #   Else (`a[i] + b[j] < S`):\n    #     `a[i]` is too small to pair with `b[j]` (the largest remaining `b`) to reach `S`.\n    #     So `a[i]` cannot be part of a pair summing to `>= S` using any remaining `b`.\n    #     We must discard `a[i]` for this purpose.\n    #     `i += 1`\n    # Return `count`.\n\n    def count_ge_S(current_S):\n        # a is sorted ascending, b is sorted ascending\n        # We want to find max number of pairs (a_i, b_j) such that a_i + b_j >= current_S\n        # Use two pointers: one for 'a' from left, one for 'b' from right\n        # This is a common greedy strategy for this type of problem.\n        count = 0\n        left_a = 0\n        right_b = n - 1\n        while left_a < n and right_b >= 0:\n            if a[left_a] + b[right_b] >= current_S:\n                # Found a valid pair. Use a[left_a] and b[right_b].\n                # Move both pointers inwards.\n                count += 1\n                left_a += 1\n                right_b -= 1\n            else:\n                # a[left_a] is too small to pair with b[right_b] (the largest available b)\n                # to reach current_S. So a[left_a] cannot form a valid pair with any\n                # remaining b. Discard a[left_a].\n                left_a += 1\n        return count\n\n    # Binary search for the smallest S (Vasya's score) >= x that maximizes count_ge_S(S).\n    # The range for S is [x, 2 * 10^5 + 1]\n    # We want to find the smallest S_vasya >= x such that count_ge_S(S_vasya) is maximized.\n    # The function count_ge_S(S) is non-increasing.\n    # We want to find `S_0` such that `count_ge_S(S_0)` is maximal, and `S_0 >= x`.\n    # If there are multiple `S` values that give the same maximal count, we pick the smallest `S`.\n\n    # Binary search over the possible values of Vasya's score `S`.\n    # `low` = `x`, `high` = `2 * 10^5` (max possible sum) + 1.\n    # We are looking for the smallest `S` in `[x, 2*10^5]` that maximizes `count_ge_S(S)`.\n    # This is slightly tricky. We need to find the `S` that gives the maximum count.\n    # Then, among all `S` values that give this maximum count, we pick the smallest `S`.\n\n    # First, find the maximum possible count.\n    # The maximum count is `n`. This happens when `S` is very small (e.g., 0).\n    # The minimum count is `0`.\n    # We can binary search for the *value* of the count.\n    # Let `max_possible_count = count_ge_S(x)`. This is the count for the lowest possible Vasya score.\n    # This is a good candidate for the worst rank.\n    # The problem asks for the worst place Vasya *could* have won.\n    # This means we fix a matching that maximizes the number of people scoring >= Vasya.\n    # Vasya's score must be >= x.\n    # The `check(S)` function counts how many people can score >= S.\n    # We want to find the minimal Vasya's score `S_V >= x` such that `count_ge_S(S_V)` is maximized.\n    # And the answer is `count_ge_S(S_V)`.\n\n    # Let's re-evaluate the worst rank strategy.\n    # We want to maximize the number of people who score >= Vasya.\n    # This means we want Vasya's score to be as low as possible (but >= x).\n    # If Vasya's score is `S`, then the number of people who score `P >= S` is `count_ge_S(S)`.\n    # We need to find the `S` that maximizes this `count_ge_S(S)` while `S >= x`.\n    # Since `count_ge_S(S)` is non-increasing, to maximize it, we should pick the smallest possible `S`.\n    # The smallest possible `S` is `x`.\n    # So, Vasya's worst rank is `count_ge_S(x)`.\n    # This is because if Vasya gets score `S_V = x`, then `count_ge_S(x)` participants (including Vasya)\n    # can get at least `x` points. Vasya could be the last among them.\n    # Any score `S_V > x` would result in `count_ge_S(S_V) <= count_ge_S(x)`.\n    # So, taking `S_V = x` maximizes the number of people who score at least `S_V`.\n    # The problem guarantees that Vasya can score at least `x`.\n    # So, `count_ge_S(x)` is the maximum possible number of people who can score at least `x`.\n    # Vasya is one of these people, and the jury can place him last among them.\n    # Thus, his worst rank is `count_ge_S(x)`.\n    \n    worst_rank = count_ge_S(x)\n\n    sys.stdout.write(f\"{best_rank} {worst_rank}\\n\")\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 872,
        "completion_token_count": 4212,
        "thoughts_token_count": 786
    }
}