{
    "start": 1758294828.312328,
    "end": 1758294940.1197557,
    "start-formatted": "2025-09-20 00:13 KST",
    "end-formatted": "2025-09-20 00:15 KST",
    "gpu": 2,
    "pid": 44,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Polycarp's Practice\n\nPolycarp is practicing his problem solving skill. He has a list of $$$n$$$ problems with difficulties $$$a_1, a_2, \\dots, a_n$$$, respectively. His plan is to practice for exactly $$$k$$$ days. Each day he has to solve at least one problem from his list. Polycarp solves the problems in the order they are given in his list, he cannot skip any problem from his list. He has to solve all $$$n$$$ problems in exactly $$$k$$$ days.Thus, each day Polycarp solves a contiguous sequence of (consecutive) problems from the start of the list. He can't skip problems or solve them multiple times. As a result, in $$$k$$$ days he will solve all the $$$n$$$ problems.The profit of the $$$j$$$-th day of Polycarp's practice is the maximum among all the difficulties of problems Polycarp solves during the $$$j$$$-th day (i.e. if he solves problems with indices from $$$l$$$ to $$$r$$$ during a day, then the profit of the day is $$$\\max\\limits_{l \\le i \\le r}a_i$$$). The total profit of his practice is the sum of the profits over all $$$k$$$ days of his practice.You want to help Polycarp to get the maximum possible total profit over all valid ways to solve problems. Your task is to distribute all $$$n$$$ problems between $$$k$$$ days satisfying the conditions above in such a way, that the total profit is maximum.For example, if $$$n = 8, k = 3$$$ and $$$a = [5, 4, 2, 6, 5, 1, 9, 2]$$$, one of the possible distributions with maximum total profit is: $$$[5, 4, 2], [6, 5], [1, 9, 2]$$$. Here the total profit equals $$$5 + 6 + 9 = 20$$$.\n\n## Input\nThe first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\le k \\le n \\le 2000$$$) — the number of problems and the number of days, respectively.The second line of the input contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le 2000$$$) — difficulties of problems in Polycarp's list, in the order they are placed in the list (i.e. in the order Polycarp will solve them).\n\n## Output\nIn the first line of the output print the maximum possible total profit.In the second line print exactly $$$k$$$ positive integers $$$t_1, t_2, \\dots, t_k$$$ ($$$t_1 + t_2 + \\dots + t_k$$$ must equal $$$n$$$), where $$$t_j$$$ means the number of problems Polycarp will solve during the $$$j$$$-th day in order to achieve the maximum possible total profit of his practice.If there are many possible answers, you may print any of them.\n\n## Example\n### Input\n['8 3\\n5 4 2 6 5 1 9 2', '5 1\\n1 1 1 1 1', '4 2\\n1 2000 2000 2']\n\n### Output\n['20\\n3 2 3', '1\\n5', '4000\\n2 2']\n\n## Note\nThe first example is described in the problem statement.In the second example there is only one possible distribution.In the third example the best answer is to distribute problems in the following way: $$$[1, 2000], [2000, 2]$$$. The total profit of this distribution is $$$2000 + 2000 = 4000$$$.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "**Maximizing Profit in Problem Solving:**\n\nOkay, so I'm tackling this competitive programming problem. The goal is to maximize the total profit from solving a set of problems over a certain number of days. Each day, I can only solve a contiguous set of problems, and the profit for a day is the maximum difficulty of problems solved that day.  The key insight here is that to get the highest total profit, I want to make sure the largest-difficulty problems are the maximums for their own segments.\n\nMy plan is: first, I'll identify the *k* largest difficulty values in the entire list of problems, even if there are duplicates.  The sum of these *k* values will be the theoretical maximum profit, since each of these values *must* be part of *some* segment.  Then I need to figure out the specific partitioning.\n\nThe trick is to find where to \"cut\" the problem list into the daily segments. I'll need to sort these *k* largest values by their original index in the array. Then, I can make cuts between the values that will be maximum values in each of their own respective segments. The cutting points create the partition of problem into segments for each day. The first segment starts at the beginning, ending at the first of the cut points.  The remaining segments follow suit, and the last segment goes to the end of the array. The segment length from each of the cut points gives the answer.  This ensures that I get the largest problems to be the profit-makers for their corresponding days. \n\nThis approach should be efficient since sorting is the only bottleneck. The rest of the steps only need a simple linear scan or constant-time operations. This will scale well to larger input sizes too.\n",
    "response": "```python\nimport sys\n\ndef solve():\n    n, k = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    # Step 1: Create (value, original_index) pairs\n    # This associates each problem's difficulty with its original position.\n    indexed_problems = []\n    for i in range(n):\n        indexed_problems.append((a[i], i))\n\n    # Step 2: Sort these pairs by value in descending order.\n    # This helps identify the k largest problem difficulties.\n    # If difficulties are equal, the original index can be used as a tie-breaker,\n    # but for total profit, any order of equal difficulties works.\n    indexed_problems.sort(key=lambda x: x[0], reverse=True)\n\n    # Step 3: Take the top k elements.\n    # These k problems will contribute their difficulties to the total profit.\n    top_k_problems = indexed_problems[:k]\n\n    # Step 4: Calculate the maximum total profit.\n    # This is the sum of difficulties of these k problems.\n    max_total_profit = sum(p[0] for p in top_k_problems)\n    print(max_total_profit)\n\n    # Step 5: Extract the original indices of these k problems.\n    # These indices mark the positions of the problems chosen to be segment maximums.\n    split_indices = [p[1] for p in top_k_problems]\n\n    # Step 6: Sort these indices in ascending order.\n    # This is crucial for defining the contiguous segments from left to right.\n    split_indices.sort()\n\n    # Step 7: Calculate segment lengths (t_j).\n    # We need to make k segments. This means we need k-1 \"cut points\".\n    # The sorted `split_indices` (s_1, s_2, ..., s_k) will define these cuts.\n    # The idea is that each of these s_i will be included in one of the k segments,\n    # and will be the maximum of that segment.\n    # We can define the first k-1 segments to end at s_1, s_2, ..., s_{k-1} respectively.\n    # The last segment will then cover all problems from s_{k-1}+1 to n-1.\n\n    segment_lengths = []\n    last_end_idx = -1  # Represents the index of the last problem solved in the previous day.\n                       # For the first day, problems start at index 0, so effectively -1.\n\n    # Iterate through the first k-1 sorted indices to define the first k-1 segments.\n    for i in range(k - 1):\n        current_split_idx = split_indices[i]\n        # The current segment starts at `last_end_idx + 1` and ends at `current_split_idx`.\n        # Its length is `current_split_idx - (last_end_idx + 1) + 1`.\n        segment_length = current_split_idx - last_end_idx\n        segment_lengths.append(segment_length)\n        last_end_idx = current_split_idx # Update for the next segment's start.\n\n    # The last (k-th) segment covers all remaining problems.\n    # It starts at `last_end_idx + 1` and goes up to `n-1`.\n    # Its length is `(n-1) - (last_end_idx + 1) + 1`, which simplifies to `n - (last_end_idx + 1)`.\n    segment_lengths.append(n - (last_end_idx + 1))\n\n    # Print the calculated segment lengths.\n    print(*(segment_lengths))\n\nif __name__ == '__main__':\n    solve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, k = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    # Step 1: Create (value, original_index) pairs\n    # This associates each problem's difficulty with its original position.\n    indexed_problems = []\n    for i in range(n):\n        indexed_problems.append((a[i], i))\n\n    # Step 2: Sort these pairs by value in descending order.\n    # This helps identify the k largest problem difficulties.\n    # If difficulties are equal, the original index can be used as a tie-breaker,\n    # but for total profit, any order of equal difficulties works.\n    indexed_problems.sort(key=lambda x: x[0], reverse=True)\n\n    # Step 3: Take the top k elements.\n    # These k problems will contribute their difficulties to the total profit.\n    top_k_problems = indexed_problems[:k]\n\n    # Step 4: Calculate the maximum total profit.\n    # This is the sum of difficulties of these k problems.\n    max_total_profit = sum(p[0] for p in top_k_problems)\n    print(max_total_profit)\n\n    # Step 5: Extract the original indices of these k problems.\n    # These indices mark the positions of the problems chosen to be segment maximums.\n    split_indices = [p[1] for p in top_k_problems]\n\n    # Step 6: Sort these indices in ascending order.\n    # This is crucial for defining the contiguous segments from left to right.\n    split_indices.sort()\n\n    # Step 7: Calculate segment lengths (t_j).\n    # We need to make k segments. This means we need k-1 \"cut points\".\n    # The sorted `split_indices` (s_1, s_2, ..., s_k) will define these cuts.\n    # The idea is that each of these s_i will be included in one of the k segments,\n    # and will be the maximum of that segment.\n    # We can define the first k-1 segments to end at s_1, s_2, ..., s_{k-1} respectively.\n    # The last segment will then cover all problems from s_{k-1}+1 to n-1.\n\n    segment_lengths = []\n    last_end_idx = -1  # Represents the index of the last problem solved in the previous day.\n                       # For the first day, problems start at index 0, so effectively -1.\n\n    # Iterate through the first k-1 sorted indices to define the first k-1 segments.\n    for i in range(k - 1):\n        current_split_idx = split_indices[i]\n        # The current segment starts at `last_end_idx + 1` and ends at `current_split_idx`.\n        # Its length is `current_split_idx - (last_end_idx + 1) + 1`.\n        segment_length = current_split_idx - last_end_idx\n        segment_lengths.append(segment_length)\n        last_end_idx = current_split_idx # Update for the next segment's start.\n\n    # The last (k-th) segment covers all remaining problems.\n    # It starts at `last_end_idx + 1` and goes up to `n-1`.\n    # Its length is `(n-1) - (last_end_idx + 1) + 1`, which simplifies to `n - (last_end_idx + 1)`.\n    segment_lengths.append(n - (last_end_idx + 1))\n\n    # Print the calculated segment lengths.\n    print(*(segment_lengths))\n\nif __name__ == '__main__':\n    solve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 963,
        "completion_token_count": 883,
        "thoughts_token_count": 8193
    }
}