{
    "start": 1758284970.8034253,
    "end": 1758284997.9837072,
    "start-formatted": "2025-09-19 21:29 KST",
    "end-formatted": "2025-09-19 21:29 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "**Deconstructing a Tricky Competitive Programming Problem**\n\nOkay, I'm diving into this competitive programming problem. The goal is to figure out the minimal number of nodes (`N`) needed to build a directed graph that satisfies a \"p-reachable\" condition, and then maximize the unidirectional pairs within that graph. Let's break down this \"p-reachable\" concept first.\n\nThe problem defines \"p-reachable\" as the number of ordered pairs (u, v) where u < v and u and v are mutually reachable. Essentially, we are looking at undirected pairs within strongly connected components (SCCs). If nodes 'u' and 'v' are in the same SCC, there exists a path from 'u' to 'v' and vice versa. Importantly, the constraint 'u < v' seems to indicate we are only counting *unordered* pairs of nodes within the SCC.\n\nNow, consider an SCC of size `k`. Any two nodes within this SCC are mutually reachable. The number of such *unordered* pairs is `k * (k - 1) / 2`. So, we've essentially established that `p` is the sum of these pairwise counts across all the SCCs in our graph.\n\nTherefore, if the graph has `m` SCCs with sizes `k_1, k_2, ..., k_m`, then `p = sum(k_i * (k_i - 1) / 2)`. And the total number of nodes `N = sum(k_i)`.\n\nTo minimize `N` for a given `p`, the key insight is to make the `k_i` values as large as possible. This makes sense from a graph theory perspective.\n",
    "response": "The problem asks us to find two values:\n1. The minimum number of nodes `N` required to create a `p`-reachable directed graph.\n2. Among all `p`-reachable directed graphs with `N` nodes, the maximum number of unidirectional pairs.\n\nLet's analyze the definitions:\n- An ordered pair `(u, v)` is **unidirectional** if `u != v`, there is a path from `u` to `v`, and no path from `v` to `u`.\n- A directed graph is **`p`-reachable** if it contains exactly `p` ordered pairs `(u, v)` such that `u < v` and `u` and `v` are reachable from each other.\n\n**Part 1: Minimum number of nodes `N` for a given `p`**\n\nThe condition \"u and v are reachable from each other\" means `u` and `v` belong to the same Strongly Connected Component (SCC). The condition `u < v` implies we are counting unordered pairs of distinct nodes within an SCC.\nIf an SCC has `k` nodes, it contributes `k * (k - 1) / 2` to the total `p` count.\nLet the graph have `m` SCCs with sizes `k_1, k_2, ..., k_m`. The total number of nodes is `N = k_1 + k_2 + ... + k_m`. The total `p` value is `p = sum_{i=1 to m} k_i * (k_i - 1) / 2`.\n\nTo minimize `N` for a given `p`, we should try to make the `k_i` values as large as possible. This is because the function `f(k) = k * (k - 1) / 2` grows quadratically, while `N` grows linearly. A single large SCC is more efficient in generating `p` than many small SCCs.\nFor example, if we need `p=3`:\n- One SCC of size `k=3` gives `3 * 2 / 2 = 3`. `N = 3`.\n- Three SCCs of size `k=2` give `3 * (2 * 1 / 2) = 3`. `N = 2+2+2 = 6`.\nThe first option uses fewer nodes.\n\nSo, to minimize `N`, we should use the largest possible SCC size `k` such that `k * (k - 1) / 2 <= p`. Let this `k` be `k_max`.\nThe remaining `p_rem = p - k_max * (k_max - 1) / 2` must be generated by other SCCs. We recursively apply the same logic to `p_rem`.\nThis greedy approach works: we always pick the largest possible `k` that fits the remaining `p`.\n\nLet `f(k) = k * (k - 1) / 2`.\nWe can precompute `f(k)` for `k` up to a certain limit. Since `p <= 2 * 10^5`, `k * (k - 1) / 2` is approximately `k^2 / 2`. So `k^2 / 2 <= 2 * 10^5` implies `k^2 <= 4 * 10^5`, so `k <= sqrt(4 * 10^5) = sqrt(40 * 10^4) = 200 * sqrt(10) approx 200 * 3.16 = 632`. A maximum `k` of around 633 is sufficient.\n\nAlgorithm to find minimum `N`:\n1. Initialize `min_N = 0`.\n2. While `p > 0`:\n   a. Find the largest integer `k` such that `k * (k - 1) / 2 <= p`.\n   b. Add `k` to `min_N`.\n   c. Subtract `k * (k - 1) / 2` from `p`.\n3. The final `min_N` is the minimum number of nodes.\n\n**Part 2: Maximum number of unidirectional pairs for `min_N` nodes**\n\nA unidirectional pair `(u, v)` means `u` can reach `v`, but `v` cannot reach `u`. This implies `u` and `v` are in different SCCs, and there's a path from `u`'s SCC to `v`'s SCC.\nConsider a graph with `N` nodes and `m` SCCs of sizes `k_1, k_2, ..., k_m`. The total number of nodes `N = sum k_i`.\nTo maximize unidirectional pairs, we want to arrange these `m` SCCs in a way that creates paths between them in one direction. A common structure for this is a \"chain\" or \"line\" of SCCs.\nIf we have SCCs `S_1, S_2, ..., S_m` and add edges such that there is a path from `S_i` to `S_j` if and only if `i < j`. This can be achieved by adding an edge from any node in `S_i` to any node in `S_{i+1}` for all `i=1, ..., m-1`.\nIn such a structure, for any `u` in `S_i` and `v` in `S_j`:\n- If `i < j`: `u` can reach `v` (via `S_i -> ... -> S_j`), but `v` cannot reach `u` (since there are no paths from `S_j` to `S_i`). These are unidirectional pairs.\n- If `i = j`: `u` and `v` are in the same SCC, so they are reachable from each other. Not unidirectional.\n- If `i > j`: `u` cannot reach `v`. Not unidirectional.\n\nThe number of unidirectional pairs in this chain structure is `sum_{1 <= i < j <= m} (k_i * k_j)`. This is the total number of pairs of nodes `(u, v)` where `u` is in an earlier SCC and `v` is in a later SCC.\nThis sum can be rewritten as:\n`sum_{1 <= i < j <= m} (k_i * k_j) = (k_1 + k_2 + ... + k_m)^2 - (k_1^2 + k_2^2 + ... + k_m^2)`\n`= (N^2 - sum k_i^2) / 2`.\n\nThe values `k_i` are determined by the greedy algorithm for `min_N`. Let these `k_i` values be `k_1, k_2, ..., k_m`.\nThe maximum number of unidirectional pairs is `(N^2 - sum_{i=1 to m} k_i^2) / 2`.\n\n**Example Walkthrough (p=3)**\n1. `p = 3`.\n2. Largest `k` such that `k * (k - 1) / 2 <= 3`:\n   `k=1: 0`\n   `k=2: 1`\n   `k=3: 3`\n   So, `k_max = 3`.\n3. `min_N = 0 + 3 = 3`.\n4. `p = 3 - (3 * 2 / 2) = 0`.\n5. `p` is `0`, so stop.\nMinimum nodes `N = 3`. The SCC sizes are `[3]`.\nMaximum unidirectional pairs: `(N^2 - sum k_i^2) / 2 = (3^2 - 3^2) / 2 = (9 - 9) / 2 = 0`.\nOutput: `3 0`. (Matches example)\n\n**Example Walkthrough (p=4)**\n1. `p = 4`.\n2. Largest `k` such that `k * (k - 1) / 2 <= 4`:\n   `k=3: 3`. So, `k_max = 3`.\n3. `min_N = 0 + 3 = 3`.\n4. `p = 4 - 3 = 1`.\n5. `p = 1`. Largest `k` such that `k * (k - 1) / 2 <= 1`:\n   `k=2: 1`. So, `k_max = 2`.\n6. `min_N = 3 + 2 = 5`.\n7. `p = 1 - 1 = 0`.\n8. `p` is `0`, so stop.\nMinimum nodes `N = 5`. The SCC sizes are `[3, 2]`.\nMaximum unidirectional pairs: `(N^2 - sum k_i^2) / 2 = (5^2 - (3^2 + 2^2)) / 2 = (25 - (9 + 4)) / 2 = (25 - 13) / 2 = 12 / 2 = 6`.\nOutput: `5 6`. (Matches example)\n\n**Example Walkthrough (p=0)**\n1. `p = 0`.\n2. `p` is `0`, so stop.\nMinimum nodes `N = 0`. The list of SCC sizes is empty.\nMaximum unidirectional pairs: `(0^2 - 0) / 2 = 0`.\nOutput: `0 0`. (Matches example)\n\n**Implementation Details:**\n- Precompute `f(k) = k * (k - 1) / 2` values. A list `triangular_numbers` can store these.\n- For finding `k_max`, we can use `bisect_right` on the `triangular_numbers` list, or simply iterate downwards from `k=633` (or `k=1` upwards) to find the largest `k`. Since `k` is small, a simple loop is fine.\n- The maximum `p` is `2 * 10^5`. Maximum `N` would be for `p = 2 * 10^5` using `k=2` repeatedly. `2 * 10^5` pairs, each `k=2` gives 1 pair. So `2 * 10^5` SCCs of size 2. `N = 4 * 10^5`.\n- `N^2` could be up to `(4 * 10^5)^2 = 16 * 10^{10}`, which fits in a 64-bit integer. Python handles large integers automatically.\n\n```python\nimport math\n\ndef solve():\n    p = int(input())\n\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    # Precompute triangular numbers k*(k-1)/2\n    # Max p = 2 * 10^5.\n    # k*(k-1)/2 approx k^2/2. So k^2 approx 4 * 10^5.\n    # k approx sqrt(4 * 10^5) = 200 * sqrt(10) approx 632.\n    # Let's go up to 633 or 634 to be safe.\n    max_k_val = 634 # k=633 gives 633*632/2 = 199656. k=634 gives 634*633/2 = 200961.\n    \n    triangular_numbers = [0] * (max_k_val + 1)\n    for k in range(1, max_k_val + 1):\n        triangular_numbers[k] = k * (k - 1) // 2\n    \n    min_N = 0\n    scc_sizes_squared_sum = 0\n    \n    remaining_p = p\n    \n    while remaining_p > 0:\n        # Find the largest k such that k*(k-1)/2 <= remaining_p\n        # We can iterate backwards from max_k_val, or use binary search\n        # Since max_k_val is small, a linear scan is efficient enough.\n        current_k = 0\n        for k_idx in range(1, max_k_val + 1):\n            if triangular_numbers[k_idx] <= remaining_p:\n                current_k = k_idx\n            else:\n                break # triangular_numbers are strictly increasing\n        \n        # If no k >= 2 found, it means remaining_p is 0 or 1.\n        # If remaining_p is 1, current_k would be 2 (2*(2-1)/2 = 1).\n        # If remaining_p is 0, loop won't run.\n        # This means current_k will always be >= 2 if remaining_p > 0.\n        # Except if remaining_p is 0, then the loop condition remaining_p > 0 will fail.\n        # If remaining_p is 1, current_k will be 2.\n        \n        min_N += current_k\n        scc_sizes_squared_sum += current_k * current_k\n        remaining_p -= triangular_numbers[current_k]\n\n    # Calculate max unidirectional pairs\n    # Formula: (N^2 - sum(k_i^2)) / 2\n    max_unidirectional_pairs = (min_N * min_N - scc_sizes_squared_sum) // 2\n    \n    print(min_N, max_unidirectional_pairs)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef solve():\n    p = int(input())\n\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    # Precompute triangular numbers k*(k-1)/2\n    # Max p = 2 * 10^5.\n    # k*(k-1)/2 approx k^2/2. So k^2 approx 4 * 10^5.\n    # k approx sqrt(4 * 10^5) = 200 * sqrt(10) approx 632.\n    # Let's go up to 633 or 634 to be safe.\n    max_k_val = 634 # k=633 gives 633*632/2 = 199656. k=634 gives 634*633/2 = 200961.\n    \n    triangular_numbers = [0] * (max_k_val + 1)\n    for k in range(1, max_k_val + 1):\n        triangular_numbers[k] = k * (k - 1) // 2\n    \n    min_N = 0\n    scc_sizes_squared_sum = 0\n    \n    remaining_p = p\n    \n    while remaining_p > 0:\n        # Find the largest k such that k*(k-1)/2 <= remaining_p\n        # We can iterate backwards from max_k_val, or use binary search\n        # Since max_k_val is small, a linear scan is efficient enough.\n        current_k = 0\n        for k_idx in range(1, max_k_val + 1):\n            if triangular_numbers[k_idx] <= remaining_p:\n                current_k = k_idx\n            else:\n                break # triangular_numbers are strictly increasing\n        \n        # If no k >= 2 found, it means remaining_p is 0 or 1.\n        # If remaining_p is 1, current_k would be 2 (2*(2-1)/2 = 1).\n        # If remaining_p is 0, loop won't run.\n        # This means current_k will always be >= 2 if remaining_p > 0.\n        # Except if remaining_p is 0, then the loop condition remaining_p > 0 will fail.\n        # If remaining_p is 1, current_k will be 2.\n        \n        min_N += current_k\n        scc_sizes_squared_sum += current_k * current_k\n        remaining_p -= triangular_numbers[current_k]\n\n    # Calculate max unidirectional pairs\n    # Formula: (N^2 - sum(k_i^2)) / 2\n    max_unidirectional_pairs = (min_N * min_N - scc_sizes_squared_sum) // 2\n    \n    print(min_N, max_unidirectional_pairs)\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 473,
        "completion_token_count": 3111,
        "thoughts_token_count": 793
    }
}