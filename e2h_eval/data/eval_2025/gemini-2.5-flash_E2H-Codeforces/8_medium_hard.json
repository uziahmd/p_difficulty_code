{
    "start": 1758011815.3463533,
    "end": 1758012108.6209154,
    "start-formatted": "2025-09-16 17:36 KST",
    "end-formatted": "2025-09-16 17:41 KST",
    "gpu": 2,
    "pid": 8,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "**Okay, let's break down this \"Flawed Flow\" problem, I think I've got a solid plan forming.** The core of the issue is to direct the flow across a network while adhering to several conditions: flow conservation, no cycles, and the specific behavior of the source and sink.  It's like playing a puzzle where you have to direct water through a network of pipes, ensuring each junction (except the source and sink) maintains the same inflow and outflow, and there are no circular paths.\n\n**Here's the approach I'm considering:**\n\n*   **Understanding the Graph Structure:** The key is to recognize that the \"no cycles\" condition is incredibly powerful. It means that there must be a topological ordering to the vertices. Think of it as a river that flows from its source to its end without any loops.\n*   **Source and Sink Behavior:** The source (vertex 1) has no incoming flow, and the sink (vertex n) doesn't explicitly need to conserve flow - it simply needs to be the destination of all the flow. This difference is key. For all vertices *except* the sink (n), the sum of incoming flow must equal the sum of outgoing flow.\n\n*   **Topological Sort as the Solution:** I'm leaning heavily towards using a Depth-First Search (DFS) or a similar graph traversal that implicitly captures a topological order to figure out how to direct the flow. DFS is great because it naturally avoids cycles. It creates a \"tree\" of edges.\n*   **Balance the vertices**: The key is to make sure that each node in the graph, other than the source and sink, has an equal amount of incoming and outgoing flow (this is called flow conservation).\n*   **DFS Traversal and Balance Adjustment:** I'll run a Depth-First Search (DFS) starting from some arbitrary vertex (let's say 1). Each edge will have a direction assigned to it.\n    *   During the DFS, I'll keep track of the \"balance\" at each node. This \"balance\" will represent the net flow imbalance (inflow - outflow).\n    *   I'll direct an edge `u -> v` to increase `u`'s flow out (increase the balance), or decrease `u`'s flow in. The reverse is also true.\n    *   When the DFS explores a new subtree, the balance of that subtree is computed as the net sum. If there's an imbalance, I'll direct the edge between the parent and child to correct the balance.\n*   **No Cycle Guarantee:** The nature of DFS ensures no cycles. By exploring new nodes recursively, you're building a path (acyclic).\n\n*   **Implementation:** I'll use a `visited` array to keep track of visited nodes. The edges are stored using the common adj list.\n*  To resolve edges, when the DFS returns from traversing the child sub-tree, I will check the remaining value of the balance of the sub-tree. If the value is not zero, I must direct the edge.\n\nIt seems like this combination of understanding the graph, prioritizing the no-cycle rule, and using a DFS with balance tracking will lead to a solution!\n",
    "response": "The problem asks us to direct each edge `(a_i, b_i)` with a given flow volume `c_i` such that:\n1.  For any vertex `v` (1 < `v` < `n`), the sum of incoming flow equals the sum of outgoing flow (flow conservation).\n2.  Vertex 1 (source) has no incoming edges.\n3.  The resulting directed graph does not have cycles.\n4.  Vertex `n` (sink) is implicitly the termination point for all flow.\n\nWe need to output `0` if the `i`-th edge is directed `a_i -> b_i` and `1` if `b_i -> a_i`. A solution is guaranteed to exist.\n\nThe \"no cycles\" condition is very strong. It implies that the resulting graph must be a Directed Acyclic Graph (DAG). In a DAG, there exists a topological ordering of vertices. Since vertex 1 has no incoming edges, it must be the first in some topological ordering.\n\nThis problem can be solved using a Depth First Search (DFS) approach, which naturally helps in constructing a DAG and managing flow conservation.\n\n**Algorithm:**\n\n1.  **Data Structures:**\n    *   `adj`: An adjacency list where `adj[u]` stores tuples `(v, c, edge_idx)` for each neighbor `v` of `u` with flow `c` and original input index `edge_idx`.\n    *   `ans`: An array of size `m` to store the direction for each edge. `ans[edge_idx] = 0` for `u -> v`, `ans[edge_idx] = 1` for `v -> u`.\n    *   `current_balance`: An array of size `n+1` (1-indexed) to store the net flow *out* of each vertex `v`. Initially, all `current_balance[v]` are 0. When an edge `u -> v` with flow `c` is directed, `current_balance[u]` increases by `c`, and `current_balance[v]` decreases by `c`.\n    *   `visited`: A boolean array or set to keep track of visited vertices during DFS.\n\n2.  **DFS Function `dfs(u, p)`:**\n    *   `u`: The current vertex being visited.\n    *   `p`: The parent of `u` in the DFS tree (used to avoid going back immediately).\n\n    The `dfs` function works as follows:\n    *   Mark `u` as `visited`.\n    *   Iterate through each neighbor `v` of `u` via edge `(u, v)` with flow `c` and index `idx`:\n        *   **Skip parent:** If `v` is `p`, continue to the next neighbor (this edge has already been processed from `p`'s perspective).\n        *   **Visited `v` (back-edge/cross-edge):** If `v` is already `visited`:\n            *   To ensure no cycles, any edge connecting two already visited nodes must be directed from the node visited later to the node visited earlier in the DFS tree. In our DFS, `u` is being processed, and `v` was visited earlier. So, we must direct `u -> v`.\n            *   Set `ans[idx] = 0`.\n            *   Update `current_balance`: `current_balance[u] += c`, `current_balance[v] -= c`.\n        *   **Unvisited `v` (tree-edge):** If `v` is not `visited`:\n            *   Recursively call `dfs(v, u)`.\n            *   **After `dfs(v, u)` returns:** At this point, all edges in the subtree rooted at `v` (except `(u, v)`) have been directed, and `current_balance[v]` reflects the net flow *out* of `v` from its subtree.\n            *   **Flow Conservation for `v` (if `v` is not the sink `n`):**\n                *   If `v` is not the sink (`v != n`): The net flow out of `v` must eventually be 0.\n                    *   If `current_balance[v] > 0` (net outgoing flow from `v`'s subtree): `v` needs `current_balance[v]` incoming flow to balance. So, direct `u -> v`.\n                        *   Set `ans[idx] = 0`.\n                        *   Update `current_balance`: `current_balance[u] += c`, `current_balance[v] -= c`.\n                    *   If `current_balance[v] < 0` (net incoming flow to `v`'s subtree): `v` needs `abs(current_balance[v])` outgoing flow to balance. So, direct `v -> u`.\n                        *   Set `ans[idx] = 1`.\n                        *   Update `current_balance`: `current_balance[u] -= c`, `current_balance[v] += c`.\n                    *   (Note: `current_balance[v]` cannot be 0 here if `v` is not `n` and `c > 0`, because `v` is part of a flow path. The problem guarantees a solution exists, implying such a balance can always be achieved.)\n                *   If `v` is the sink (`v == n`): We don't need to balance `n`. All flow should terminate at `n`. So, direct `u -> n`.\n                    *   Set `ans[idx] = 0`.\n                    *   Update `current_balance`: `current_balance[u] += c`, `current_balance[v] -= c`.\n\n3.  **Initiate DFS:** Start the DFS from the source `1` with no parent: `dfs(1, 0)`.\n    *   The source `1` has no incoming edges. The logic above ensures that any edge `(u, v)` where `u` is `1` and `v` is a child in the DFS tree will be directed `1 -> v` if `v` is not `n` and `current_balance[v]` is positive, or `v -> 1` if `current_balance[v]` is negative. However, the problem states `1` has no incoming edges. This means all edges connected to `1` must be directed `1 -> x`. Our DFS logic needs to ensure this.\n    *   The `dfs` function determines direction for edge `(u, v)` *after* `dfs(v, u)` returns. This means edges are directed \"upwards\" in the DFS tree.\n    *   For an edge `(u, v)` where `u` is the parent of `v` in the DFS tree: The direction is decided based on `current_balance[v]`.\n    *   For the source `1`, its `current_balance[1]` will accumulate the total flow `F` (sum of all `c_i` for edges `1 -> x`).\n\nLet's refine the DFS for the special case of `v=n` and `u=1`.\nThe logic `if v == n: ans[idx] = 0` is crucial. It ensures all edges directly connected to `n` are `x -> n`.\nFor `u=1`, all its edges `1 -> x` will be directed `1 -> x` if `x != n` and `current_balance[x]` is positive (needs incoming flow), or `x -> 1` if `current_balance[x]` is negative (needs outgoing flow). This `x -> 1` is exactly what we want to avoid.\n\n**Revised DFS Logic for Tree Edges:**\nThe key is to think about what `current_balance[v]` means. Let it be the *net flow required to exit `v` via `(u,v)`* to balance `v` and its subtree.\nInitialize `current_balance[v] = 0`.\nWhen `dfs(v, u)` returns, `current_balance[v]` is the sum of flows of edges *within `v`'s subtree* that are directed *out* of `v` minus flows directed *into* `v`.\nFor `1 < v < n`, we need `current_balance[v]` to be zero *after* considering edge `(u, v)`.\nSo, if `current_balance[v] > 0`, it means `v` has a net outgoing flow from its subtree. To balance it to 0, `(u, v)` must bring `current_balance[v]` into `v`. So `u -> v`.\nIf `current_balance[v] < 0`, it means `v` has a net incoming flow from its subtree. To balance it to 0, `(u, v)` must take `abs(current_balance[v])` flow out of `v`. So `v -> u`.\n\nThe total flow `F` is `current_balance[1]` (net outgoing from source) and `-current_balance[n]` (net incoming to sink).\n\nA simpler way to handle `1` and `n` for tree edges:\nWhen `dfs(v, u)` returns for an edge `(u, v)`:\n*   If `v == n`: All flow must go `u -> n`. So `ans[idx] = 0`. `current_balance[u] += c`, `current_balance[v] -= c`.\n*   If `u == 1`: All flow must go `1 -> v`. So `ans[idx] = 0`. `current_balance[u] += c`, `current_balance[v] -= c`.\n*   If `u != 1` and `v != n`: Use the balancing logic:\n    *   If `current_balance[v] > 0`: `ans[idx] = 0` (`u -> v`). `current_balance[u] += c`, `current_balance[v] -= c`.\n    *   Else (`current_balance[v] <= 0`): `ans[idx] = 1` (`v -> u`). `current_balance[u] -= c`, `current_balance[v] += c`.\n\nThis revised logic correctly handles the source and sink constraints for tree edges. For back-edges, the `u -> v` direction (deeper to shallower in DFS tree) is always chosen to avoid cycles, and `current_balance` is updated accordingly.\n\n**Example Walkthrough (First Example):**\n`3 3`\n`3 2 10` (edge 0)\n`1 2 10` (edge 1)\n`3 1 5`  (edge 2)\n\n`n=3, m=3`. Source `1`, Sink `3`.\n`adj`:\n`1: [(2, 10, 1), (3, 5, 2)]`\n`2: [(3, 10, 0), (1, 10, 1)]`\n`3: [(2, 10, 0), (1, 5, 2)]`\n\n`current_balance = [0,0,0,0]`\n`ans = [?, ?, ?]`\n`visited = [F,F,F,F]`\n\n`dfs(1, 0)`:\n  `visited[1] = T`\n  Neighbors of 1:\n  1. `(2, 10, 1)`: `v=2` is not visited. Call `dfs(2, 1)`.\n     `dfs(2, 1)`:\n       `visited[2] = T`\n       Neighbors of 2:\n       1. `(3, 10, 0)`: `v=3` is not visited. Call `dfs(3, 2)`.\n          `dfs(3, 2)`:\n            `visited[3] = T`\n            Neighbors of 3:\n            1. `(2, 10, 0)`: `v=2` is parent. Skip.\n            2. `(1, 5, 2)`: `v=1` is visited. (Back-edge)\n               `ans[2] = 0` (3 -> 1)\n               `current_balance[3] += 5` (`current_balance = [0,0,0,5]`)\n               `current_balance[1] -= 5` (`current_balance = [0,-5,0,5]`)\n            `dfs(3, 2)` returns.\n       Back in `dfs(2, 1)` for edge `(2, 3)` (idx 0):\n       `v=3` (sink). Rule: `u -> n`.\n       `ans[0] = 0` (2 -> 3)\n       `current_balance[2] += 10` (`current_balance = [0,-5,10,5]`)\n       `current_balance[3] -= 10` (`current_balance = [0,-5,10,-5]`)\n       `dfs(2, 1)` returns.\n  Back in `dfs(1, 0)` for edge `(1, 2)` (idx 1):\n  `v=2` is not sink, `u=1` is source. Rule: `1 -> v`.\n  `ans[1] = 0` (1 -> 2)\n  `current_balance[1] += 10` (`current_balance = [0,5,10,-5]`)\n  `current_balance[2] -= 10` (`current_balance = [0,5,0,-5]`)\n  Neighbors of 1 (cont.):\n  2. `(3, 5, 2)`: `v=3` is visited. (Back-edge)\n     `ans[2]` is already 0 (3->1). This is fine, we just update balance.\n     `ans[2] = 0` (3 -> 1)\n     `current_balance[1] += 5` (`current_balance = [0,10,0,-5]`)\n     `current_balance[3] -= 5` (`current_balance = [0,10,0,-10]`)\n  `dfs(1, 0)` returns.\n\nFinal `ans`:\n`ans[0] = 0` (2 -> 3)\n`ans[1] = 0` (1 -> 2)\n`ans[2] = 0` (3 -> 1)\n\nThis gives:\n`1 -> 2` (10)\n`2 -> 3` (10)\n`3 -> 1` (5)\n\nLet's check conditions:\n1. `1 < v < n`: Only `v=2`.\n   `in_flow[2]`: From `1 -> 2` (10)\n   `out_flow[2]`: From `2 -> 3` (10)\n   `in_flow[2] = out_flow[2] = 10`. OK.\n2. `in_flow[1] = 0`: From `3 -> 1` (5). This is NOT 0. My logic for `u=1` needs adjustment.\n\nThe problem states \"vertex with number 1 has no incoming edges\". This means **all edges incident to 1 must be directed out of 1**.\nSimilarly, for `n`, it is the sink. All flow must go into `n`. So **all edges incident to `n` must be directed into `n`**.\n\nLet's use a simpler DFS strategy:\n`dfs(u, p_edge_idx)`:\n  `visited[u] = True`\n  For each edge `(u, v)` with flow `c` and original index `idx`:\n    If `idx == p_edge_idx`: continue\n    If `visited[v]`:\n      // `v` is already visited. It's a back-edge.\n      // To avoid cycles, direct `u -> v` (from current node to already visited node).\n      `ans[idx] = 0` // `u -> v`\n      `current_balance[u] += c`\n      `current_balance[v] -= c`\n    Else: // `v` is unvisited\n      `dfs(v, idx)`\n      // After `dfs(v, idx)` returns, `current_balance[v]` is the net flow out of `v` from its subtree.\n      // Now decide direction of `(u, v)` (edge `idx`).\n      // If `v` is not `n` and `current_balance[v]` is positive (net outgoing flow from `v`'s subtree):\n      //   `v` needs incoming flow to balance. Direct `u -> v`.\n      //   `ans[idx] = 0` (`u -> v`)\n      //   `current_balance[u] += c`\n      //   `current_balance[v] -= c`\n      // Else (`v` is `n` OR `current_balance[v]` is zero/negative):\n      //   `v` needs outgoing flow to balance (or is `n` and receives flow). Direct `v -> u`.\n      //   `ans[idx] = 1` (`v -> u`)\n      //   `current_balance[u] -= c`\n      //   `current_balance[v] += c`\n\nThis logic will make `current_balance[v]` for `1 < v < n` eventually zero.\nAnd for `v=n`, `current_balance[n]` will accumulate a negative value (net incoming flow).\nWhat about `v=1`? `current_balance[1]` will accumulate a positive value (net outgoing flow).\n\nLet's re-run Example 1 with this refined logic:\n`dfs(1, -1)`: (using -1 for no parent edge)\n  `visited[1] = T`\n  Neighbors of 1:\n  1. `(2, 10, 1)`: `v=2` is not visited. Call `dfs(2, 1)`.\n     `dfs(2, 1)`:\n       `visited[2] = T`\n       Neighbors of 2:\n       1. `(3, 10, 0)`: `v=3` is not visited. Call `dfs(3, 0)`.\n          `dfs(3, 0)`:\n            `visited[3] = T`\n            Neighbors of 3:\n            1. `(2, 10, 0)`: `idx=0` is parent edge. Skip.\n            2. `(1, 5, 2)`: `v=1` is visited. (Back-edge)\n               `ans[2] = 0` (3 -> 1)\n               `current_balance[3] += 5` (`current_balance = [0,0,0,5]`)\n               `current_balance[1] -= 5` (`current_balance = [0,-5,0,5]`)\n            `dfs(3, 0)` returns.\n       Back in `dfs(2, 1)` for edge `(2, 3)` (idx 0):\n       `v=3` (sink). Rule: `v` is `n` OR `current_balance[v]` is <= 0.\n       `current_balance[3]=5` (positive). But `v=3` is sink. So `v -> u` rule applies.\n       `ans[0] = 1` (3 -> 2)\n       `current_balance[2] -= 10` (`current_balance = [0,-5,-10,5]`)\n       `current_balance[3] += 10` (`current_balance = [0,-5,-10,15]`)\n       `dfs(2, 1)` returns.\n  Back in `dfs(1, -1)` for edge `(1, 2)` (idx 1):\n  `v=2` is not sink. `current_balance[2] = -10` (negative). Rule: `v -> u`.\n  `ans[1] = 1` (2 -> 1)\n  `current_balance[1] -= 10` (`current_balance = [0,-15,-10,15]`)\n  `current_balance[2] += 10` (`current_balance = [0,-15,0,15]`)\n  Neighbors of 1 (cont.):\n  2. `(3, 5, 2)`: `v=3` is visited. (Back-edge)\n     `ans[2]` is already 0 (3->1).\n     `current_balance[1] += 5` (`current_balance = [0,-10,0,15]`)\n     `current_balance[3] -= 5` (`current_balance = [0,-10,0,10]`)\n  `dfs(1, -1)` returns.\n\nFinal `ans`:\n`ans[0] = 1` (3 -> 2)\n`ans[1] = 1` (2 -> 1)\n`ans[2] = 0` (3 -> 1)\n\nThis gives:\n`3 -> 2` (10)\n`2 -> 1` (10)\n`3 -> 1` (5)\n\nCheck conditions:\n1. `1 < v < n`: Only `v=2`.\n   `in_flow[2]`: From `3 -> 2` (10)\n   `out_flow[2]`: From `2 -> 1` (10)\n   `in_flow[2] = out_flow[2] = 10`. OK.\n2. `in_flow[1] = 0`:\n   `in_flow[1]`: From `2 -> 1` (10), From `3 -> 1` (5). Total `15`. This is NOT 0.\n\nThe issue is that for `v=1` and `v=n`, the `current_balance` logic for tree edges is not directly applicable.\nThe problem statement \"vertex with number 1 has no incoming edges\" is paramount. This means any edge `(1, x)` must be directed `1 -> x`.\nSimilarly, for `n`, any edge `(x, n)` must be directed `x -> n`.\n\nThe \"no cycles\" condition is handled by the DFS tree. A tree is a DAG. Back-edges `u -> v` (where `v` is an ancestor of `u`) always go \"forward\" in a topological sense.\n\nLet's try a different DFS structure where we explicitly direct edges based on source/sink properties first, then balance.\n\n**Corrected DFS Strategy:**\n\n`dfs(u, p_edge_idx)`:\n  `visited[u] = True`\n  For each edge `(u, v)` with flow `c` and original index `idx`:\n    If `idx == p_edge_idx`: continue\n    If `visited[v]`: // `v` is an ancestor or in an already processed branch\n      // Direct `u -> v` to avoid cycles.\n      `ans[idx] = 0` // `u -> v`\n      `current_balance[u] += c`\n      `current_balance[v] -= c`\n    Else: // `v` is unvisited (tree edge)\n      `dfs(v, idx)`\n      // After `dfs(v, idx)` returns, `current_balance[v]` is the net flow out of `v` from its subtree.\n      // Decide direction for `(u, v)` (edge `idx`):\n      // 1. If `u` is source (1): All edges from source must be outgoing.\n      //    `ans[idx] = 0` (`1 -> v`)\n      //    `current_balance[u] += c`\n      //    `current_balance[v] -= c`\n      // 2. If `v` is sink (n): All edges to sink must be incoming.\n      //    `ans[idx] = 0` (`u -> n`)\n      //    `current_balance[u] += c`\n      //    `current_balance[v] -= c`\n      // 3. Otherwise (`u != 1` and `v != n`): Balance `v`.\n      //    If `current_balance[v] > 0` (net outgoing from `v`'s subtree): `v` needs incoming flow.\n      //      `ans[idx] = 0` (`u -> v`)\n      //      `current_balance[u] += c`\n      //      `current_balance[v] -= c`\n      //    Else (`current_balance[v] <= 0`): `v` needs outgoing flow.\n      //      `ans[idx] = 1` (`v -> u`)\n      //      `current_balance[u] -= c`\n      //      `current_balance[v] += c`\n\nThis logic seems more robust. Let's trace Example 1 again.\n`dfs(1, -1)`:\n  `visited[1] = T`\n  Neighbors of 1:\n  1. `(2, 10, 1)`: `v=2` is not visited. Call `dfs(2, 1)`.\n     `dfs(2, 1)`:\n       `visited[2] = T`\n       Neighbors of 2:\n       1. `(3, 10, 0)`: `v=3` is not visited. Call `dfs(3, 0)`.\n          `dfs(3, 0)`:\n            `visited[3] = T`\n            Neighbors of 3:\n            1. `(2, 10, 0)`: `idx=0` is parent edge. Skip.\n            2. `(1, 5, 2)`: `v=1` is visited. (Back-edge)\n               `ans[2] = 0` (3 -> 1)\n               `current_balance[3] += 5` (`current_balance = [0,0,0,5]`)\n               `current_balance[1] -= 5` (`current_balance = [0,-5,0,5]`)\n            `dfs(3, 0)` returns.\n       Back in `dfs(2, 1)` for edge `(2, 3)` (idx 0):\n       `u=2`, `v=3`. `v` is sink (`n`).\n       `ans[0] = 0` (2 -> 3)\n       `current_balance[2] += 10` (`current_balance = [0,-5,10,5]`)\n       `current_balance[3] -= 10` (`current_balance = [0,-5,10,-5]`)\n       `dfs(2, 1)` returns.\n  Back in `dfs(1, -1)` for edge `(1, 2)` (idx 1):\n  `u=1`, `v=2`. `u` is source (`1`).\n  `ans[1] = 0` (1 -> 2)\n  `current_balance[1] += 10` (`current_balance = [0,5,10,-5]`)\n  `current_balance[2] -= 10` (`current_balance = [0,5,0,-5]`)\n  Neighbors of 1 (cont.):\n  2. `(3, 5, 2)`: `v=3` is visited. (Back-edge)\n     `ans[2]` is already 0 (3->1).\n     `current_balance[1] += 5` (`current_balance = [0,10,0,-5]`)\n     `current_balance[3] -= 5` (`current_balance = [0,10,0,-10]`)\n  `dfs(1, -1)` returns.\n\nFinal `ans`:\n`ans[0] = 0` (2 -> 3)\n`ans[1] = 0` (1 -> 2)\n`ans[2] = 0` (3 -> 1)\n\nThis still gives `3 -> 1` which is incoming to source. The issue is with back-edges.\nThe problem statement \"vertex with number 1 has no incoming edges\" means *globally*, not just for tree edges.\nThe \"no cycles\" condition implies a topological sort. Any edge `u -> v` must have `u` appear before `v` in the topological sort.\nThe source `1` must be the first, and sink `n` must be the last.\n\nThis problem is a classic application of a specific type of DFS. The `current_balance[v]` is the \"excess flow\" that has accumulated at `v` from its children in the DFS tree. This excess needs to be passed up to the parent `u`.\n\nLet `current_balance[v]` be the sum of flow volumes that are currently directed *out* of `v` minus sum of flow volumes directed *into* `v` for all edges connected to `v` *except* the edge connecting `v` to its parent in the DFS tree.\nInitialize `current_balance[v] = 0` for all `v`.\n\n`dfs(u, p)`: // `p` is the actual parent vertex, not edge index\n  `visited[u] = True`\n  For each edge `(u, v)` with flow `c` and original index `idx`:\n    If `v == p`: continue // Skip parent\n    If `visited[v]`: // `v` is visited, so `(u,v)` is a back-edge or cross-edge\n      // To satisfy no cycles, flow must go from `u` to `v` (from deeper to shallower in DFS tree).\n      `ans[idx] = 0` // `u -> v`\n      `current_balance[u] += c`\n      `current_balance[v] -= c`\n    Else: // `v` is unvisited (tree edge)\n      `dfs(v, u)`\n      // After `dfs(v, u)` returns, `current_balance[v]` is the net flow out of `v` from its children and back-edges in its subtree.\n      // Now decide direction of `(u, v)` (edge `idx`).\n      // For any node `v` (1 < `v` < `n`), `current_balance[v]` must ultimately be 0.\n      // If `v` is not `n`:\n      //   If `current_balance[v] > 0` (net outgoing flow from `v`'s subtree): `v` needs incoming flow. Direct `u -> v`.\n      //     `ans[idx] = 0` (`u -> v`)\n      //     `current_balance[u] += c`\n      //     `current_balance[v] -= c`\n      //   Else (`current_balance[v] <= 0`): `v` needs outgoing flow. Direct `v -> u`.\n      //     `ans[idx] = 1` (`v -> u`)\n      //     `current_balance[u] -= c`\n      //     `current_balance[v] += c`\n      // If `v` is `n`: It's the sink. All flow must go into `n`.\n      //   `ans[idx] = 0` (`u -> n`)\n      //   `current_balance[u] += c`\n      //   `current_balance[v] -= c`\n\nStart `dfs(1, 0)` (0 is a dummy parent).\n\nExample 1 again, with `dfs(u, p)`:\n`dfs(1, 0)`:\n  `visited[1] = T`\n  Neighbors of 1:\n  1. `(2, 10, 1)`: `v=2` is not visited. Call `dfs(2, 1)`.\n     `dfs(2, 1)`:\n       `visited[2] = T`\n       Neighbors of 2:\n       1. `(3, 10, 0)`: `v=3` is not visited. Call `dfs(3, 2)`.\n          `dfs(3, 2)`:\n            `visited[3] = T`\n            Neighbors of 3:\n            1. `(2, 10, 0)`: `v=2` is parent. Skip.\n            2. `(1, 5, 2)`: `v=1` is visited. (Back-edge)\n               `ans[2] = 0` (3 -> 1)\n               `current_balance[3] += 5` (`current_balance = [0,0,0,5]`)\n               `current_balance[1] -= 5` (`current_balance = [0,-5,0,5]`)\n            `dfs(3, 2)` returns.\n       Back in `dfs(2, 1)` for edge `(2, 3)` (idx 0):\n       `u=2`, `v=3`. `v` is `n`.\n       `ans[0] = 0` (2 -> 3)\n       `current_balance[2] += 10` (`current_balance = [0,-5,10,5]`)\n       `current_balance[3] -= 10` (`current_balance = [0,-5,10,-5]`)\n       `dfs(2, 1)` returns.\n  Back in `dfs(1, 0)` for edge `(1, 2)` (idx 1):\n  `u=1`, `v=2`. `v` is not `n`. `current_balance[2] = 0`.\n  Rule: `current_balance[v] <= 0`. So `v -> u`.\n  `ans[1] = 1` (2 -> 1)\n  `current_balance[1] -= 10` (`current_balance = [0,-15,0,-5]`)\n  `current_balance[2] += 10` (`current_balance = [0,-15,10,-5]`)\n  Neighbors of 1 (cont.):\n  2. `(3, 5, 2)`: `v=3` is visited. (Back-edge)\n     `ans[2]` is already 0 (3->1).\n     `current_balance[1] += 5` (`current_balance = [0,-10,10,-5]`)\n     `current_balance[3] -= 5` (`current_balance = [0,-10,10,-10]`)\n  `dfs(1, 0)` returns.\n\nFinal `ans`:\n`ans[0] = 0` (2 -> 3)\n`ans[1] = 1` (2 -> 1)\n`ans[2] = 0` (3 -> 1)\n\nThis is the same output as the previous attempt, which had `in_flow[1] != 0`.\nThe example output for the first case is:\n`1` (3 -> 2)\n`0` (1 -> 2)\n`1` (1 -> 3)\n\nThis means:\n`3 -> 2` (10)\n`1 -> 2` (10)\n`1 -> 3` (5)\n\nLet's check this example output:\n1. `1 < v < n`: Only `v=2`.\n   `in_flow[2]`: From `3 -> 2` (10), From `1 -> 2` (10). Total `20`.\n   `out_flow[2]`: None. This violates flow conservation `in_flow[2] = out_flow[2]`.\n   The example output is incorrect based on my understanding of flow conservation for intermediate nodes.\n   Ah, the example output is:\n   `1` for edge `(3,2,10)` means `2 -> 3`\n   `0` for edge `(1,2,10)` means `1 -> 2`\n   `1` for edge `(3,1,5)` means `1 -> 3`\n\n   So the example output means:\n   `2 -> 3` (10)\n   `1 -> 2` (10)\n   `1 -> 3` (5)\n\n   Let's check this:\n   `in_flow[1] = 0`. OK.\n   `v=2`: `in_flow[2]` (from `1->2`) = 10. `out_flow[2]` (to `2->3`) = 10. OK.\n   `v=3`: `in_flow[3]` (from `2->3`) = 10, (from `1->3`) = 5. Total 15. `out_flow[3]` = 0. OK (sink).\n   No cycles: `1 -> 2 -> 3`, `1 -> 3`. This is a DAG. OK.\n\nThe example output is valid. My DFS logic is not producing this. The crucial difference is that my DFS logic for `current_balance[v] <= 0` directs `v -> u`. The example output has `1 -> 2` and `2 -> 3`. So, `current_balance[2]` must have been positive (or `v` was `n`).\n\nThe issue is that `current_balance[v]` is the net flow *out* of `v` accumulated from its children. If `current_balance[v]` is positive, it means `v` has an excess of outgoing flow from its subtree, which needs to be balanced by an incoming flow from `u`. So `u -> v`.\nIf `current_balance[v]` is negative, it means `v` has an excess of incoming flow to its subtree, which needs to be balanced by an outgoing flow to `u`. So `v -> u`.\n\nThe only way the example output `1 -> 2` and `2 -> 3` can happen is if `current_balance[2]` was positive (or 0) when `dfs(1,0)` processes edge `(1,2)`, and `current_balance[3]` was positive (or 0) when `dfs(2,1)` processes edge `(2,3)`.\n\nThis implies that the `current_balance` should always be non-negative for intermediate nodes to force flow \"forward\".\nThe problem states \"a solution always exists.\" This is a strong hint.\nThe `current_balance[v]` should represent the total flow that *must* exit `v` via its parent edge.\n\nLet's use `flow_to_parent[v]`.\n`dfs(u, p)`:\n  `visited[u] = True`\n  `flow_to_parent[u] = 0` // Initialize flow to be passed up from `u`\n\n  For each edge `(u, v)` with flow `c` and original index `idx`:\n    If `v == p`: continue\n    If `visited[v]`: // Back-edge or cross-edge\n      // To avoid cycles, direct `u -> v`.\n      `ans[idx] = 0` // `u -> v`\n      `flow_to_parent[u] += c` // `u` sends flow out\n    Else: // Tree edge\n      `dfs(v, u)`\n      // After `dfs(v, u)` returns, `flow_to_parent[v]` is the required net flow out of `v` (from its subtree) that needs to go to `u`.\n      // If `v` is the sink `n`: All flow must go into `n`.\n      //   `ans[idx] = 0` (`u -> n`)\n      //   `flow_to_parent[u] += c`\n      // Else (`v` is not `n`):\n      //   If `flow_to_parent[v] > 0`: `v` has a net outgoing flow. It needs `flow_to_parent[v]` incoming flow.\n      //     This must be balanced by the edge `(u, v)`. If `c >= flow_to_parent[v]`, we can direct `u -> v`.\n      //     This is not quite right. `flow_to_parent[v]` is the *net* flow.\n      //     If `flow_to_parent[v]` is positive, it means `v` has a net outgoing flow.\n      //     To balance `v` to 0, `v` needs `flow_to_parent[v]` incoming flow. This must come from `u`.\n      //     So, `ans[idx] = 0` (`u -> v`).\n      //     `flow_to_parent[u] += c`.\n      //     `flow_to_parent[v] -= c`. (This means `v` has now received `c` flow, reducing its outgoing requirement).\n      //   Else (`flow_to_parent[v] <= 0`): `v` has a net incoming flow, or is balanced.\n      //     `v` needs to send `abs(flow_to_parent[v])` flow out. This must go to `u`.\n      //     So, `ans[idx] = 1` (`v -> u`).\n      //     `flow_to_parent[u] -= c`.\n      //     `flow_to_parent[v] += c`.\n\nThis is almost the same as the `current_balance` logic. The key insight from problems like this is usually that the source and sink are special.\nThe total flow `F` is `sum(c_i)` for all `(1, x)` edges.\nThe total flow into `n` is `sum(c_i)` for all `(x, n)` edges.\nThese two sums must be equal.\n\nThe specific solution for this problem type often involves a DFS that calculates the net flow *out* of each subtree.\nFor `v` (1 < `v` < `n`), the net flow out of `v` must be 0.\nFor `1`, net flow out is `F`. For `n`, net flow in is `F`.\n\nLet `balance[v]` be the sum of flows directed *out* of `v` minus sum of flows directed *into* `v`.\nInitialize `balance[v] = 0`.\n\n`dfs(u, p)`:\n  `visited[u] = True`\n  For each edge `(u, v)` with flow `c` and original index `idx`:\n    If `v == p`: continue\n    If `visited[v]`: // Back-edge\n      `ans[idx] = 0` // `u -> v`\n      `balance[u] += c`\n      `balance[v] -= c`\n    Else: // Tree edge\n      `dfs(v, u)`\n      // After `dfs(v, u)` returns, `balance[v]` is the net flow out of `v` from its subtree.\n      // If `v` is the sink `n`, all flow must go into it. So `u -> n`.\n      // If `u` is the source `1`, all flow must go out of it. So `1 -> v`.\n      // If `v` is not `n` and `balance[v]` is positive, `v` has a net outgoing flow. It needs incoming flow. So `u -> v`.\n      // Else (`v` is not `n` and `balance[v]` is negative or zero), `v` has a net incoming flow or is balanced. It needs outgoing flow. So `v -> u`.\n\n      If `v == n`:\n        `ans[idx] = 0` (`u -> n`)\n        `balance[u] += c`\n        `balance[v] -= c`\n      Else: // `v` is not `n`\n        If `balance[v] > 0`: // `v` has excess outgoing flow, needs incoming\n          `ans[idx] = 0` (`u -> v`)\n          `balance[u] += c`\n          `balance[v] -= c`\n        Else: // `v` has excess incoming flow (or balanced), needs outgoing\n          `ans[idx] = 1` (`v -> u`)\n          `balance[u] -= c`\n          `balance[v] += c`\n\nStart `dfs(1, 0)`.\nThis is exactly the last logic I tried, which failed for Example 1.\nThe key must be that the source condition `in_flow[1]=0` and sink condition `out_flow[n]=0` (implied by no cycles and flow conservation) should be handled *after* the DFS, or by modifying the `balance` for `1` and `n`.\n\nLet's consider the total flow `F`. For `1 < v < n`, we want `balance[v] = 0`.\nFor `v=1`, we want `balance[1] = F`. For `v=n`, we want `balance[n] = -F`.\nThe `current_balance` calculation in DFS correctly calculates `balance[v]` for `v` not equal to `1` or `n`.\nFor `1`, it calculates `balance[1] = F`. For `n`, it calculates `balance[n] = -F`.\nThe example output for the first case:\n`2 -> 3` (10)\n`1 -> 2` (10)\n`1 -> 3` (5)\n\nThis means `balance[1] = 10+5 = 15`. `balance[2] = 10-10 = 0`. `balance[3] = -10-5 = -15`.\nMy DFS produced `balance[1] = -10`, `balance[2] = 10`, `balance[3] = -10`. This is not correct.\n\nThe issue with my DFS is how back-edges affect the source/sink conditions.\nConsider edge `(3, 1, 5)` in example 1. It's a back-edge `3 -> 1` in my DFS.\nThe example output directs it `1 -> 3`. This is `u -> v` where `u` is the source.\n\nThe problem states \"vertex with number 1 has no incoming edges\". This must be true for *all* edges, including back-edges.\nSo, if `v == 1` and `u` is not `1`, then the edge `(u, 1)` must be directed `u -> 1` (to satisfy `current_balance[1] <= 0` if `1` is not parent), which means `1` has incoming flow. This is problematic.\n\nThe only way for `1` to have no incoming edges and `n` to have no outgoing edges (and no cycles) is that `1` is the source and `n` is the sink of a DAG.\nThis implies a topological ordering. The DFS structure naturally finds such an ordering.\n\nThe \"no cycles\" condition is the strongest. The standard way to resolve edges in a DFS to avoid cycles is:\n1. Tree edges: `u -> v` (from parent to child).\n2. Back edges: `u -> v` (from child to ancestor).\n\nIf we adopt this, then for each edge `(u, v)`:\nIf `v` is unvisited, it's a tree edge, direct `u -> v`.\nIf `v` is visited:\n  If `v` is an ancestor of `u` (back-edge), direct `u -> v`.\n  If `v` is in a different subtree (cross-edge), direct `u -> v`.\n\nSo, always `u -> v` if `v` is unvisited or `v` is visited.\nThis means all edges are directed in the order they are first encountered in the DFS.\nThis guarantees a DAG.\nThen, we adjust the `balance` based on this.\n\n`dfs(u, p)`:\n  `visited[u] = True`\n  For each edge `(u, v)` with flow `c` and original index `idx`:\n    If `idx` is already decided (e.g. `ans[idx]` is not `?`): continue\n    If `v == p`: // Parent edge, direction will be decided by parent.\n        // This is not correct. `p` is vertex, not edge index.\n        // If `v` is parent, we don't process this edge from `u`'s side.\n        continue\n    If `visited[v]`: // Back-edge or Cross-edge\n      `ans[idx] = 0` // `u -> v`\n    Else: // Tree edge\n      `dfs(v, u)`\n      `ans[idx] = 0` // `u -> v`\n\nThis simple DFS directs all edges `u -> v` if `u` is visited before `v`. This creates a DAG.\nAfter all edges are directed, we can calculate `in_flow[v]` and `out_flow[v]`.\nThen, for `1 < v < n`, if `in_flow[v] != out_flow[v]`, we need to flip some edges.\nThis is a standard problem: given a graph with initial edge directions and values, flip minimum edges to satisfy flow conservation. This is a min-cost max-flow problem or a demand flow problem.\n\nThe problem must be simpler, given the constraints.\nThe crucial part is that `current_balance[v]` for `1 < v < n` must be zero.\nThe total flow `F` is not given, but `F = balance[1] = -balance[n]`.\n\nLet's use the provided solution for this problem which usually involves processing nodes from leaves up in the DFS tree.\nThe logic for tree edges:\nWhen `dfs(v, u)` returns, `current_balance[v]` is the net flow *out* of `v` from its subtree.\nIf `v` is not `n`:\n  If `current_balance[v] > 0`: `v` has a net outgoing flow. To balance, `u -> v`.\n  Else (`current_balance[v] <= 0`): `v` has a net incoming flow. To balance, `v -> u`.\nIf `v` is `n`: Always `u -> n`.\n\nThis is the logic that failed for Example 1. The problem is that the `(1,x)` edges must be `1->x` and `(x,n)` edges must be `x->n`.\nMy logic for `v=n` forces `u -> n`. This is good.\nMy logic for `u=1` and `v!=n` can result in `v -> 1` if `current_balance[v]` is `0` or negative. This is bad.\n\nThe condition `vertex with number 1 has no incoming edges` implies that for any edge `(1, x)`, it must be directed `1 -> x`.\nThe condition that `n` is the sink implies that for any edge `(x, n)`, it must be directed `x -> n`.\n\nLet's modify the DFS:\n`dfs(u, p)`:\n  `visited[u] = True`\n  For each edge `(u, v)` with flow `c` and original index `idx`:\n    If `v == p`: continue\n    If `ans[idx]` is already set: continue // This edge has been processed as a back-edge from `v`'s perspective\n    If `v == n`: // Edge to sink\n      `ans[idx] = 0` (`u -> n`)\n      `current_balance[u] += c`\n      `current_balance[v] -= c`\n    Else if `u == 1`: // Edge from source\n      `ans[idx] = 0` (`1 -> v`)\n      `current_balance[u] += c`\n      `current_balance[v] -= c`\n    Else if `visited[v]`: // Back-edge (u,v) where v is not n and u is not 1\n      `ans[idx] = 0` (`u -> v`) // To avoid cycle\n      `current_balance[u] += c`\n      `current_balance[v] -= c`\n    Else: // Tree-edge (u,v) where u!=1, v!=n\n      `dfs(v, u)`\n      // After `dfs(v, u)` returns, `current_balance[v]` is the net flow out of `v` from its subtree.\n      If `current_balance[v] > 0`: // `v` needs incoming flow\n        `ans[idx] = 0` (`u -> v`)\n        `current_balance[u] += c`\n        `current_balance[v] -= c`\n      Else: // `v` needs outgoing flow\n        `ans[idx] = 1` (`v -> u`)\n        `current_balance[u] -= c`\n        `current_balance[v] += c`\n\nThis logic ensures `1 -> x` and `x -> n`.\nLet's try Example 1 again.\n`dfs(1, 0)`:\n  `visited[1] = T`\n  Neighbors of 1:\n  1. `(2, 10, 1)`: `u=1`. Rule: `u=1`.\n     `ans[1] = 0` (1 -> 2)\n     `current_balance[1] += 10` (`current_balance = [0,10,0,0]`)\n     `current_balance[2] -= 10` (`current_balance = [0,10,-10,0]`)\n     `dfs(2, 1)` is NOT called yet. This is wrong.\n     We must call DFS on unvisited nodes. The order of `if` conditions matters.\n\nThe standard DFS for this problem is:\n1. Mark `u` visited.\n2. For each neighbor `v` of `u` (via edge `(u,v)` with flow `c`, index `idx`):\n   a. If `v == p`: continue.\n   b. If `visited[v]`: (Back-edge or cross-edge)\n      If `ans[idx]` is not set:\n         `ans[idx] = 0` (`u -> v`)\n         `current_balance[u] += c`\n         `current_balance[v] -= c`\n   c. Else (`v` unvisited, tree edge):\n      `dfs(v, u)`\n      // After `dfs(v, u)` returns, `current_balance[v]` is net flow out of `v`'s subtree.\n      // Now decide direction of `(u, v)` (edge `idx`).\n      // If `v` is the sink `n`: All flow must go `u -> n`.\n      // Else (`v` is not `n`): Balance `v`.\n      //   If `current_balance[v] > 0`: `v` needs incoming. `u -> v`.\n      //   Else (`current_balance[v] <= 0`): `v` needs outgoing. `v -> u`.\n\n      If `v == n`:\n        `ans[idx] = 0` (`u -> n`)\n        `current_balance[u] += c`\n        `current_balance[v] -= c`\n      Else: // `v` is not `n`\n        If `current_balance[v] > 0`:\n          `ans[idx] = 0` (`u -> v`)\n          `current_balance[u] += c`\n          `current_balance[v] -= c`\n        Else:\n          `ans[idx] = 1` (`v -> u`)\n          `current_balance[u] -= c`\n          `current_balance[v] += c`\n\nExample 1 with this logic:\n`dfs(1, 0)`:\n  `visited[1] = T`\n  Neighbors of 1:\n  1. `(2, 10, 1)`: `v=2` is not visited. Call `dfs(2, 1)`.\n     `dfs(2, 1)`:\n       `visited[2] = T`\n       Neighbors of 2:\n       1. `(3, 10, 0)`: `v=3` is not visited. Call `dfs(3, 2)`.\n          `dfs(3, 2)`:\n            `visited[3] = T`\n            Neighbors of 3:\n            1. `(2, 10, 0)`: `v=2` is parent. Skip.\n            2. `(1, 5, 2)`: `v=1` is visited. (`ans[2]` not set)\n               `ans[2] = 0` (3 -> 1)\n               `current_balance[3] += 5` (`current_balance = [0,0,0,5]`)\n               `current_balance[1] -= 5` (`current_balance = [0,-5,0,5]`)\n            `dfs(3, 2)` returns.\n       Back in `dfs(2, 1)` for edge `(2, 3)` (idx 0):\n       `v=3` (sink).\n       `ans[0] = 0` (2 -> 3)\n       `current_balance[2] += 10` (`current_balance = [0,-5,10,5]`)\n       `current_balance[3] -= 10` (`current_balance = [0,-5,10,-5]`)\n       `dfs(2, 1)` returns.\n  Back in `dfs(1, 0)` for edge `(1, 2)` (idx 1):\n  `v=2` is not sink. `current_balance[2] = 0`. Rule: `current_balance[v] <= 0`.\n  `ans[1] = 1` (2 -> 1)\n  `current_balance[1] -= 10` (`current_balance = [0,-15,0,-5]`)\n  `current_balance[2] += 10` (`current_balance = [0,-15,10,-5]`)\n  Neighbors of 1 (cont.):\n  2. `(3, 5, 2)`: `v=3` is visited. `ans[2]` is already 0. Skip.\n  `dfs(1, 0)` returns.\n\nThis still produces `2 -> 1` and `3 -> 1`. The example output has `1 -> 2` and `1 -> 3`.\nThe problem states \"vertex with number 1 has no incoming edges\". This is the key.\nThe only way `1` has no incoming edges is if all edges incident to `1` are directed *out* of `1`.\nSo, for any edge `(1, x)` (where `x != 1`), it must be `1 -> x`.\nThis is a fixed direction.\n\nLet's modify the DFS:\n`dfs(u, p)`:\n  `visited[u] = True`\n  For each edge `(u, v)` with flow `c` and original index `idx`:\n    If `v == p`: continue\n    If `ans[idx]` is already set: continue // This edge has been processed as a back-edge from `v`'s perspective\n\n    If `u == 1`: // Edge from source, must be outgoing\n      `ans[idx] = 0` (`1 -> v`)\n      `current_balance[u] += c`\n      `current_balance[v] -= c`\n      // If `v` is unvisited, we must still recurse.\n      If not `visited[v]`:\n        `dfs(v, u)`\n    Else if `v == n`: // Edge to sink, must be incoming\n      `ans[idx] = 0` (`u -> n`)\n      `current_balance[u] += c`\n      `current_balance[v] -= c`\n      // If `u` is unvisited, this won't be called. If `v` is unvisited, `u` must have been visited.\n      // This case is for `u` is parent of `n` in DFS tree, or `u` is a back-edge to `n`.\n    Else if `visited[v]`: // Back-edge or Cross-edge (u,v), where u!=1, v!=n\n      `ans[idx] = 0` (`u -> v`) // To avoid cycle\n      `current_balance[u] += c`\n      `current_balance[v] -= c`\n    Else: // Tree-edge (u,v), where u!=1, v!=n, v unvisited\n      `dfs(v, u)`\n      // After `dfs(v, u)` returns, `current_balance[v]` is the net flow out of `v` from its subtree.\n      If `current_balance[v] > 0`: // `v` needs incoming flow\n        `ans[idx] = 0` (`u -> v`)\n        `current_balance[u] += c`\n        `current_balance[v] -= c`\n      Else: // `v` needs outgoing flow\n        `ans[idx] = 1` (`v -> u`)\n        `current_balance[u] -= c`\n        `current_balance[v] += c`\n\nThis logic for `u==1` and `v==n` should be applied when processing the edge, not after `dfs(v,u)` returns.\nThe `u==1` and `v==n` conditions should take precedence.\n\nCorrected DFS logic:\n`dfs(u, p)`:\n  `visited[u] = True`\n  For each edge `(u, v)` with flow `c` and original index `idx`:\n    If `v == p`: continue\n    If `ans[idx]` is already set: continue\n\n    If `u == 1`: // Source edge\n      `ans[idx] = 0` (`1 -> v`)\n      `current_balance[u] += c`\n      `current_balance[v] -= c`\n      If not `visited[v]`: `dfs(v, u)`\n    Else if `v == n`: // Sink edge\n      `ans[idx] = 0` (`u -> n`)\n      `current_balance[u] += c`\n      `current_balance[v] -= c`\n      If not `visited[v]`: `dfs(v, u)`\n    Else if `visited[v]`: // Back-edge or Cross-edge (u,v)\n      `ans[idx] = 0` (`u -> v`)\n      `current_balance[u] += c`\n      `current_balance[v] -= c`\n    Else: // Tree-edge (u,v), u!=1, v!=n\n      `dfs(v, u)`\n      // After `dfs(v, u)` returns, `current_balance[v]` is the net flow out of `v` from its subtree.\n      If `current_balance[v] > 0`: // `v` needs incoming flow\n        `ans[idx] = 0` (`u -> v`)\n        `current_balance[u] += c`\n        `current_balance[v] -= c`\n      Else: // `v` needs outgoing flow\n        `ans[idx] = 1` (`v -> u`)\n        `current_balance[u] -= c`\n        `current_balance[v] += c`\n\nLet's test this logic with Example 1:\n`dfs(1, 0)`:\n  `visited[1] = T`\n  Neighbors of 1:\n  1. `(2, 10, 1)`: `u=1`. Rule: `u=1`.\n     `ans[1] = 0` (1 -> 2)\n     `current_balance[1] += 10` (`current_balance = [0,10,0,0]`)\n     `current_balance[2] -= 10` (`current_balance = [0,10,-10,0]`)\n     `v=2` is not visited. Call `dfs(2, 1)`.\n     `dfs(2, 1)`:\n       `visited[2] = T`\n       Neighbors of 2:\n       1. `(3, 10, 0)`: `u=2`, `v=3`. `v=n`. Rule: `v=n`.\n          `ans[0] = 0` (2 -> 3)\n          `current_balance[2] += 10` (`current_balance = [0,10,0,0]`)\n          `current_balance[3] -= 10` (`current_balance = [0,10,0,-10]`)\n          `v=3` is not visited (it is now). Call `dfs(3, 2)`.\n          `dfs(3, 2)`:\n            `visited[3] = T`\n            Neighbors of 3:\n            1. `(2, 10, 0)`: `v=2` is parent. Skip.\n            2. `(1, 5, 2)`: `u=3`, `v=1`. `v` is visited. `ans[2]` not set. Back-edge.\n               `ans[2] = 0` (3 -> 1)\n               `current_balance[3] += 5` (`current_balance = [0,10,0,-5]`)\n               `current_balance[1] -= 5` (`current_balance = [0,5,0,-5]`)\n            `dfs(3, 2)` returns.\n       Back in `dfs(2, 1)` (after `dfs(3,2)` completed for edge (2,3)).\n       `dfs(2,1)` continues processing neighbors of 2. No more neighbors.\n       `dfs(2,1)` returns.\n  Back in `dfs(1, 0)` (after `dfs(2,1)` completed for edge (1,2)).\n  Neighbors of 1 (cont.):\n  2. `(3, 5, 2)`: `u=1`, `v=3`. `ans[2]` is already 0 (3->1). Skip.\n  `dfs(1, 0)` returns.\n\nFinal `ans`:\n`ans[0] = 0` (2 -> 3)\n`ans[1] = 0` (1 -> 2)\n`ans[2] = 0` (3 -> 1)\n\nThis is still `3 -> 1`. The example output is `1 -> 3`.\nThe problem with `ans[idx]` being set for `(3,1,5)` as `3 -> 1` is that `u=3` and `v=1`. `v=1` is visited. It's a back-edge.\nThe \"no incoming edges for vertex 1\" must be respected.\nThis means `(3,1)` must be directed `1 -> 3`.\n\nThis implies a modification to the back-edge rule:\nIf `v == 1`: `ans[idx] = 1` (`v -> u`, i.e., `1 -> u`).\nIf `u == n`: `ans[idx] = 0` (`u -> v`, i.e., `n -> v`). (This would be an outgoing edge from `n`, which is not allowed.)\n\nThe solution from competitive programming problems with similar structure (e.g., Codeforces 700C) uses a DFS.\nThe `current_balance[v]` is the net flow *out* of `v` from its subtree.\nWhen `dfs(v, u)` returns for an edge `(u, v)`:\nIf `v == n`: `u -> n`\nElse if `current_balance[v] > 0`: `u -> v`\nElse: `v -> u`\n\nThis is the logic that failed. The problem is simple: the solution must be a DAG. All edges connected to 1 must be outgoing. All edges connected to N must be incoming.\n\nThe `current_balance` logic for tree edges is correct for intermediate nodes.\nThe source and sink conditions have to override.\nA possible approach:\n1. Initialize `ans` to -1 (undecided).\n2. For each edge `(u, v)` with flow `c`, if `u=1` or `v=1`:\n   If `u=1`: `ans[idx] = 0` (`1 -> v`). Update `current_balance`.\n   If `v=1`: `ans[idx] = 1` (`1 -> u`). Update `current_balance`.\n   (This handles all edges connected to 1).\n3. For each edge `(u, v)` with flow `c`, if `u=n` or `v=n`:\n   If `u=n`: `ans[idx] = 1` (`v -> n`). Update `current_balance`.\n   If `v=n`: `ans[idx] = 0` (`u -> n`). Update `current_balance`.\n   (This handles all edges connected to `n`).\n   *This is tricky if an edge connects 1 and n directly.*\n   If `(1, n)` edge: `ans[idx]=0` (`1 -> n`).\n\nThis pre-processing handles source/sink edges. Then run DFS on remaining undirected edges.\nThis is too complex. The single DFS should work.\n\nFinal attempt at the logic, matching the example output.\nThe example output `1 -> 2`, `2 -> 3`, `1 -> 3` means:\n`balance[1]` = 10 (to 2) + 5 (to 3) = 15\n`balance[2]` = 10 (from 1) - 10 (to 3) = 0\n`balance[3]` = -10 (from 2) - 5 (from 1) = -15\n\nThis implies that the `current_balance` for non-sink nodes `v` must be positive to direct `u -> v`.\nAnd the `current_balance` for non-source nodes `u` must be negative to direct `v -> u`.\n\nThe solution must be:\n`dfs(u, p)`:\n  `visited[u] = True`\n  `current_balance[u] = 0` // This is the net flow *out* of `u` from its children's subtrees.\n\n  For each edge `(u, v)` with flow `c` and original index `idx`:\n    If `v == p`: continue\n    If `ans[idx]` is already set: continue // This edge has been processed as a back-edge from `v`'s perspective\n\n    If not `visited[v]`: // Tree-edge\n      `dfs(v, u)`\n      // After `dfs(v, u)` returns, `current_balance[v]` is the net flow out of `v` from its subtree.\n      // Now decide direction of `(u, v)` (edge `idx`).\n      // If `v` is the sink `n`: All flow must go `u -> n`.\n      // Else (`v` is not `n`): Balance `v`.\n      //   If `current_balance[v] > 0`: `v` has a net outgoing flow. It needs incoming flow. So `u -> v`.\n      //   Else (`current_balance[v] <= 0`): `v` has a net incoming flow. It needs outgoing flow. So `v -> u`.\n\n      If `v == n`:\n        `ans[idx] = 0` (`u -> n`)\n        `current_balance[u] += c`\n      Else: // `v` is not `n`\n        If `current_balance[v] > 0`:\n          `ans[idx] = 0` (`u -> v`)\n          `current_balance[u] += c`\n        Else:\n          `ans[idx] = 1` (`v -> u`)\n          `current_balance[u] -= c`\n    Else: // `v` is visited (Back-edge or Cross-edge)\n      // If `v` is `1`, edge must be `1 -> u`.\n      // If `u` is `n`, edge must be `v -> n`.\n      // Otherwise, direct `u -> v` to avoid cycle.\n\n      If `v == 1`: // Back-edge to source. Must be `1 -> u`.\n        `ans[idx] = 1` (`v -> u`)\n        `current_balance[u] -= c`\n      Else if `u == n`: // Back-edge from sink. Must be `v -> n`.\n        `ans[idx] = 0` (`v -> u`) // Error in thought. `u` is `n`. `v -> n` is `ans[idx]=0` if edge is `(v,n)`.\n                                 // If edge is `(n,v)`, then `ans[idx]=1` (`v -> n`).\n                                 // The edge is `(u,v)`. If `u=n`, then `n->v` is `ans[idx]=0`. But `n` can't have outgoing.\n                                 // So this must be `v -> n` for edge `(u,v)`.\n                                 // If `u=n`, `v` is visited, it must be `v -> n`.\n                                 // `ans[idx] = 1` (`v -> n`)\n                                 // `current_balance[u] -= c`\n      Else: // Standard back-edge. `u -> v` to avoid cycle.\n        `ans[idx] = 0` (`u -> v`)\n        `current_balance[u] += c`\n\nThis is getting overly complicated. The key must be simpler.\nThe `current_balance[v]` should be the sum of flow *exiting* `v` via `(u,v)`.\nWhen `dfs(v, u)` returns, `current_balance[v]` is the *net flow that needs to be passed up to `u`* from `v`'s subtree.\nIf `v=n`, all flow should terminate at `n`. So `current_balance[n]` should be 0.\nIf `v` (1 < `v` < `n`) needs to be balanced, `current_balance[v]` should be 0.\nIf `current_balance[v]` is positive, it means `v` has an excess of outgoing flow from its subtree. This flow must be balanced by an incoming flow from `u`. So `u -> v`.\nIf `current_balance[v]` is negative, it means `v` has an excess of incoming flow to its subtree. This flow must be balanced by an outgoing flow to `u`. So `v -> u`.\n\nThis is the standard formulation.\nThe `current_balance` for `1` will be the total flow `F`.\nThe `current_balance` for `n` will be 0. Because any flow into `n` is just terminating.\nSo `current_balance[v]` for `v != 1` should be 0.\n\nFinal approach based on a common solution for similar problems:\n`dfs(u, p)`:\n  `visited[u] = True`\n  `current_balance[u] = 0` // This is the net flow *out* of `u` that will be passed to `p`.\n\n  For each edge `(u, v)` with flow `c` and original index `idx`:\n    If `v == p`: continue\n    If `visited[v]`: // Back-edge or Cross-edge\n      // If `v` is an ancestor of `u`, `u -> v` avoids a cycle.\n      // If `v` is in another processed branch, `u -> v` avoids a cycle `v -> ... -> u -> v`.\n      // The only exception is if `v` is the source (1). Edges into `1` are forbidden.\n      // So, if `v == 1`, we must direct `1 -> u`.\n      If `v == 1`:\n        `ans[idx] = 1` (`1 -> u`)\n        `current_balance[u] -= c`\n      Else:\n        `ans[idx] = 0` (`u -> v`)\n        `current_balance[u] += c`\n    Else: // Tree-edge\n      `dfs(v, u)`\n      // After `dfs(v, u)` returns, `current_balance[v]` is the net flow out of `v` from its subtree.\n      // Now decide direction of `(u, v)` (edge `idx`).\n      // If `v` is the sink `n`: All flow must go `u -> n`.\n      // Else (`v` is not `n`): Balance `v`.\n      //   If `current_balance[v] > 0`: `v` has a net outgoing flow. It needs incoming flow. So `u -> v`.\n      //   Else (`current_balance[v] <= 0`): `v` has a net incoming flow. It needs outgoing flow. So `v -> u`.\n\n      If `v == n`:\n        `ans[idx] = 0` (`u -> n`)\n        `current_balance[u] += c`\n      Else: // `v` is not `n`\n        If `current_balance[v] > 0`:\n          `ans[idx] = 0` (`u -> v`)\n          `current_balance[u] += c`\n        Else:\n          `ans[idx] = 1` (`v -> u`)\n          `current_balance[u] -= c`\n\nThis logic is what matches the example output for the first test case.\nExample 1:\n`dfs(1, 0)`:\n  `visited[1] = T`, `current_balance[1] = 0`\n  Neighbors of 1:\n  1. `(2, 10, 1)`: `v=2` is not visited. Call `dfs(2, 1)`.\n     `dfs(2, 1)`:\n       `visited[2] = T`, `current_balance[2] = 0`\n       Neighbors of 2:\n       1. `(3, 10, 0)`: `v=3` is not visited. Call `dfs(3, 2)`.\n          `dfs(3, 2)`:\n            `visited[3] = T`, `current_balance[3] = 0`\n            Neighbors of 3:\n            1. `(2, 10, 0)`: `v=2` is parent. Skip.\n            2. `(1, 5, 2)`: `v=1` is visited. Back-edge. `v==1`.\n               `ans[2] = 1` (1 -> 3)\n               `current_balance[3] -= 5` (`current_balance = [0,0,0,-5]`)\n            `dfs(3, 2)` returns.\n       Back in `dfs(2, 1)` for edge `(2, 3)` (idx 0):\n       `v=3` is sink (`n`).\n       `ans[0] = 0` (2 -> 3)\n       `current_balance[2] += 10` (`current_balance = [0,0,10,-5]`)\n       `dfs(2, 1)` returns.\n  Back in `dfs(1, 0)` for edge `(1, 2)` (idx 1):\n  `v=2` is not sink. `current_balance[2] = 10` (positive).\n  `ans[1] = 0` (1 -> 2)\n  `current_balance[1] += 10` (`current_balance = [0,10,10,-5]`)\n  Neighbors of 1 (cont.):\n  2. `(3, 5, 2)`: `v=3` is visited. `ans[2]` is already 1. Skip.\n  `dfs(1, 0)` returns.\n\nFinal `ans`:\n`ans[0] = 0` (2 -> 3)\n`ans[1] = 0` (1 -> 2)\n`ans[2] = 1` (1 -> 3)\n\nThis matches the example output! This is the correct logic.\n\n```python\nimport sys\n\nsys.setrecursionlimit(2 * 10**5 + 500) # Increase recursion limit for deep DFS\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    edges_input = []\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n        edges_input.append((u, v, c))\n\n    ans = [-1] * m\n    visited = [False] * (n + 1)\n    current_balance = [0] * (n + 1) # Represents net flow OUT of a node from its subtree\n\n    def dfs(u, p):\n        visited[u] = True\n        \n        # current_balance[u] will accumulate the net flow out of u\n        # from its children's subtrees and back-edges.\n        # This value will be passed up to u's parent.\n\n        for v, c, idx in adj[u]:\n            if v == p:\n                continue\n\n            if ans[idx] != -1: # Edge already directed (e.g., from v's DFS call or another back-edge)\n                continue\n\n            if visited[v]: # (u,v) is a back-edge or cross-edge\n                # To avoid cycles, flow must go from 'deeper' node to 'shallower' node in DFS tree.\n                # 'u' is visited later than 'v'. So, 'u -> v'.\n                # Exception: If 'v' is the source (1), it cannot have incoming edges.\n                # So, if 'v == 1', the edge must be '1 -> u'.\n                if v == 1:\n                    ans[idx] = 1 # v -> u (1 -> u)\n                    current_balance[u] -= c # u receives flow\n                else:\n                    ans[idx] = 0 # u -> v\n                    current_balance[u] += c # u sends flow\n            else: # (u,v) is a tree edge\n                dfs(v, u) # Recurse on child 'v'\n                \n                # After dfs(v,u) returns, current_balance[v] holds the net flow out of 'v'\n                # from its subtree (excluding the (u,v) edge).\n                # Now, we decide the direction of (u,v) to balance 'v'.\n                \n                if v == n: # If 'v' is the sink, all flow must go into it.\n                    ans[idx] = 0 # u -> n\n                    current_balance[u] += c # u sends flow\n                else: # 'v' is an intermediate node (1 < v < n). It must be balanced (net flow = 0).\n                    if current_balance[v] > 0: # 'v' has a net outgoing flow from its subtree.\n                                               # It needs incoming flow to balance. So, u -> v.\n                        ans[idx] = 0 # u -> v\n                        current_balance[u] += c # u sends flow\n                    else: # 'v' has a net incoming flow from its subtree (or is balanced to 0).\n                          # It needs outgoing flow to balance. So, v -> u.\n                        ans[idx] = 1 # v -> u\n                        current_balance[u] -= c # u receives flow\n\n    dfs(1, 0) # Start DFS from source (vertex 1), with dummy parent 0\n\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + '\\n')\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\nsys.setrecursionlimit(2 * 10**5 + 500) # Increase recursion limit for deep DFS\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    edges_input = []\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n        edges_input.append((u, v, c))\n\n    ans = [-1] * m\n    visited = [False] * (n + 1)\n    current_balance = [0] * (n + 1) # Represents net flow OUT of a node from its subtree\n\n    def dfs(u, p):\n        visited[u] = True\n        \n        # current_balance[u] will accumulate the net flow out of u\n        # from its children's subtrees and back-edges.\n        # This value will be passed up to u's parent.\n\n        for v, c, idx in adj[u]:\n            if v == p:\n                continue\n\n            if ans[idx] != -1: # Edge already directed (e.g., from v's DFS call or another back-edge)\n                continue\n\n            if visited[v]: # (u,v) is a back-edge or cross-edge\n                # To avoid cycles, flow must go from 'deeper' node to 'shallower' node in DFS tree.\n                # 'u' is visited later than 'v'. So, 'u -> v'.\n                # Exception: If 'v' is the source (1), it cannot have incoming edges.\n                # So, if 'v == 1', the edge must be '1 -> u'.\n                if v == 1:\n                    ans[idx] = 1 # v -> u (1 -> u)\n                    current_balance[u] -= c # u receives flow\n                else:\n                    ans[idx] = 0 # u -> v\n                    current_balance[u] += c # u sends flow\n            else: # (u,v) is a tree edge\n                dfs(v, u) # Recurse on child 'v'\n                \n                # After dfs(v,u) returns, current_balance[v] holds the net flow out of 'v'\n                # from its subtree (excluding the (u,v) edge).\n                # Now, we decide the direction of (u,v) to balance 'v'.\n                \n                if v == n: # If 'v' is the sink, all flow must go into it.\n                    ans[idx] = 0 # u -> n\n                    current_balance[u] += c # u sends flow\n                else: # 'v' is an intermediate node (1 < v < n). It must be balanced (net flow = 0).\n                    if current_balance[v] > 0: # 'v' has a net outgoing flow from its subtree.\n                                               # It needs incoming flow to balance. So, u -> v.\n                        ans[idx] = 0 # u -> v\n                        current_balance[u] += c # u sends flow\n                    else: # 'v' has a net incoming flow from its subtree (or is balanced to 0).\n                          # It needs outgoing flow to balance. So, v -> u.\n                        ans[idx] = 1 # v -> u\n                        current_balance[u] -= c # u receives flow\n\n    dfs(1, 0) # Start DFS from source (vertex 1), with dummy parent 0\n\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + '\\n')\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 745,
        "completion_token_count": 19339,
        "thoughts_token_count": 6688
    }
}