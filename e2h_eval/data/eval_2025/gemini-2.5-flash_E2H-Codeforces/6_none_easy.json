{
    "start": 1758011280.6276798,
    "end": 1758011294.7710452,
    "start-formatted": "2025-09-16 17:28 KST",
    "end-formatted": "2025-09-16 17:28 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "",
    "response": "```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    vouchers = []\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        vouchers.append((l, r, cost))\n\n    min_total_cost = float('inf')\n\n    # Group vouchers by duration\n    # duration_to_vouchers[duration] = [(l, r, cost), ...]\n    duration_to_vouchers = [[] for _ in range(200001)]\n    for l, r, cost in vouchers:\n        duration = r - l + 1\n        duration_to_vouchers[duration].append((l, r, cost))\n\n    # Sort vouchers within each duration group by their start day for efficient searching\n    for i in range(len(duration_to_vouchers)):\n        duration_to_vouchers[i].sort()\n\n    # Iterate through all possible durations for the first voucher\n    for d1 in range(1, x):\n        d2 = x - d1\n        if d2 <= 0 or d2 > 200000:\n            continue\n\n        vouchers1 = duration_to_vouchers[d1]\n        vouchers2 = duration_to_vouchers[d2]\n\n        if not vouchers1 or not vouchers2:\n            continue\n\n        # Create a list of (r, cost) for vouchers2, sorted by r\n        # This allows us to efficiently query minimum cost for vouchers ending before a certain day\n        vouchers2_sorted_by_r = sorted([(r, cost) for _, r, cost in vouchers2])\n\n        # Precompute minimum costs for vouchers ending by a certain day\n        # min_cost_at_r[r_val] = minimum cost of a voucher from vouchers2 that ends at or before r_val\n        max_coord = 200000\n        min_cost_ending_by = [float('inf')] * (max_coord + 1)\n        \n        current_min_cost = float('inf')\n        ptr = 0\n        for r_val in range(1, max_coord + 1):\n            while ptr < len(vouchers2_sorted_by_r) and vouchers2_sorted_by_r[ptr][0] == r_val:\n                current_min_cost = min(current_min_cost, vouchers2_sorted_by_r[ptr][1])\n                ptr += 1\n            min_cost_ending_by[r_val] = current_min_cost\n        \n        # Now iterate through vouchers1 and find a disjoint voucher from vouchers2\n        for l1, r1, cost1 in vouchers1:\n            # We need a voucher (l2, r2, cost2) from vouchers2 such that r1 < l2 or r2 < l1\n            # Case 1: r1 < l2 (voucher1 ends before voucher2 starts)\n            # The earliest l2 can be is r1 + 1. So we need a voucher (l2, r2, cost2) from vouchers2\n            # such that l2 >= r1 + 1.\n            # This doesn't directly use the min_cost_ending_by array.\n\n            # Case 2: r2 < l1 (voucher2 ends before voucher1 starts)\n            # We need a voucher (l2, r2, cost2) from vouchers2 such that r2 < l1.\n            # The maximum r2 can be is l1 - 1.\n            if l1 - 1 >= 1:\n                cost2_candidate = min_cost_ending_by[l1 - 1]\n                if cost2_candidate != float('inf'):\n                    min_total_cost = min(min_total_cost, cost1 + cost2_candidate)\n            \n            # The problem statement says \"ri < lj OR rj < li\".\n            # The current approach only considers r2 < l1.\n            # Let's consider the other case: r1 < l2.\n            # This means the second voucher must start *after* the first one ends.\n            # We need to find a voucher (l2, r2, cost2) from vouchers2 such that l2 > r1.\n            # This requires iterating through vouchers2 or using a different data structure.\n\n            # Let's rebuild the min_cost_ending_by for the other direction.\n            # min_cost_starting_after[l_val] = minimum cost of a voucher from vouchers2 that starts at or after l_val\n            \n            # For the r1 < l2 case:\n            # We need to find a voucher (l2, r2, cost2) from vouchers2 such that l2 >= r1 + 1.\n            # This means we need to find min cost of vouchers from vouchers2 that start at or after r1 + 1.\n            \n            # To handle this efficiently, we can use a segment tree or similar structure.\n            # Or, iterate through vouchers2 and filter.\n            # A simpler way is to sort all vouchers by start time and then iterate.\n            # But we've grouped by duration, which is good.\n\n            # Let's consider the structure:\n            # For each voucher (l1, r1, cost1) with duration d1:\n            #   We need to find (l2, r2, cost2) with duration d2=x-d1 such that:\n            #     1. r1 < l2  (l2 >= r1 + 1)\n            #     2. r2 < l1  (r2 <= l1 - 1)\n\n            # The `min_cost_ending_by` array handles case 2 efficiently.\n            # For case 1, we need to find min cost of (l2, r2, cost2) from vouchers2 where l2 >= r1 + 1.\n            # This is essentially a range minimum query on start times.\n            # Let's create `min_cost_starting_at_or_after[l_val]`\n            \n            # This can be built by iterating backwards.\n            min_cost_starting_at_or_after = [float('inf')] * (max_coord + 2)\n            vouchers2_sorted_by_l = sorted([(l, cost) for l, _, cost in vouchers2])\n            \n            current_min_cost_for_start = float('inf')\n            ptr_l = len(vouchers2_sorted_by_l) - 1\n            for l_val in range(max_coord, 0, -1):\n                while ptr_l >= 0 and vouchers2_sorted_by_l[ptr_l][0] == l_val:\n                    current_min_cost_for_start = min(current_min_cost_for_start, vouchers2_sorted_by_l[ptr_l][1])\n                    ptr_l -= 1\n                min_cost_starting_at_or_after[l_val] = current_min_cost_for_start\n\n            if r1 + 1 <= max_coord:\n                cost2_candidate_start = min_cost_starting_at_or_after[r1 + 1]\n                if cost2_candidate_start != float('inf'):\n                    min_total_cost = min(min_total_cost, cost1 + cost2_candidate_start)\n\n    if min_total_cost == float('inf'):\n        sys.stdout.write(\"-1\\n\")\n    else:\n        sys.stdout.write(str(min_total_cost) + \"\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    vouchers = []\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        vouchers.append((l, r, cost))\n\n    min_total_cost = float('inf')\n\n    # Group vouchers by duration\n    # duration_to_vouchers[duration] = [(l, r, cost), ...]\n    duration_to_vouchers = [[] for _ in range(200001)]\n    for l, r, cost in vouchers:\n        duration = r - l + 1\n        duration_to_vouchers[duration].append((l, r, cost))\n\n    # Sort vouchers within each duration group by their start day for efficient searching\n    for i in range(len(duration_to_vouchers)):\n        duration_to_vouchers[i].sort()\n\n    # Iterate through all possible durations for the first voucher\n    for d1 in range(1, x):\n        d2 = x - d1\n        if d2 <= 0 or d2 > 200000:\n            continue\n\n        vouchers1 = duration_to_vouchers[d1]\n        vouchers2 = duration_to_vouchers[d2]\n\n        if not vouchers1 or not vouchers2:\n            continue\n\n        # Create a list of (r, cost) for vouchers2, sorted by r\n        # This allows us to efficiently query minimum cost for vouchers ending before a certain day\n        vouchers2_sorted_by_r = sorted([(r, cost) for _, r, cost in vouchers2])\n\n        # Precompute minimum costs for vouchers ending by a certain day\n        # min_cost_at_r[r_val] = minimum cost of a voucher from vouchers2 that ends at or before r_val\n        max_coord = 200000\n        min_cost_ending_by = [float('inf')] * (max_coord + 1)\n        \n        current_min_cost = float('inf')\n        ptr = 0\n        for r_val in range(1, max_coord + 1):\n            while ptr < len(vouchers2_sorted_by_r) and vouchers2_sorted_by_r[ptr][0] == r_val:\n                current_min_cost = min(current_min_cost, vouchers2_sorted_by_r[ptr][1])\n                ptr += 1\n            min_cost_ending_by[r_val] = current_min_cost\n        \n        # Now iterate through vouchers1 and find a disjoint voucher from vouchers2\n        for l1, r1, cost1 in vouchers1:\n            # We need a voucher (l2, r2, cost2) from vouchers2 such that r1 < l2 or r2 < l1\n            # Case 1: r1 < l2 (voucher1 ends before voucher2 starts)\n            # The earliest l2 can be is r1 + 1. So we need a voucher (l2, r2, cost2) from vouchers2\n            # such that l2 >= r1 + 1.\n            # This doesn't directly use the min_cost_ending_by array.\n\n            # Case 2: r2 < l1 (voucher2 ends before voucher1 starts)\n            # We need a voucher (l2, r2, cost2) from vouchers2 such that r2 < l1.\n            # The maximum r2 can be is l1 - 1.\n            if l1 - 1 >= 1:\n                cost2_candidate = min_cost_ending_by[l1 - 1]\n                if cost2_candidate != float('inf'):\n                    min_total_cost = min(min_total_cost, cost1 + cost2_candidate)\n            \n            # The problem statement says \"ri < lj OR rj < li\".\n            # The current approach only considers r2 < l1.\n            # Let's consider the other case: r1 < l2.\n            # This means the second voucher must start *after* the first one ends.\n            # We need to find a voucher (l2, r2, cost2) from vouchers2 such that l2 > r1.\n            # This requires iterating through vouchers2 or using a different data structure.\n\n            # Let's rebuild the min_cost_ending_by for the other direction.\n            # min_cost_starting_after[l_val] = minimum cost of a voucher from vouchers2 that starts at or after l_val\n            \n            # For the r1 < l2 case:\n            # We need to find a voucher (l2, r2, cost2) from vouchers2 such that l2 >= r1 + 1.\n            # This means we need to find min cost of vouchers from vouchers2 that start at or after r1 + 1.\n            \n            # To handle this efficiently, we can use a segment tree or similar structure.\n            # Or, iterate through vouchers2 and filter.\n            # A simpler way is to sort all vouchers by start time and then iterate.\n            # But we've grouped by duration, which is good.\n\n            # Let's consider the structure:\n            # For each voucher (l1, r1, cost1) with duration d1:\n            #   We need to find (l2, r2, cost2) with duration d2=x-d1 such that:\n            #     1. r1 < l2  (l2 >= r1 + 1)\n            #     2. r2 < l1  (r2 <= l1 - 1)\n\n            # The `min_cost_ending_by` array handles case 2 efficiently.\n            # For case 1, we need to find min cost of (l2, r2, cost2) from vouchers2 where l2 >= r1 + 1.\n            # This is essentially a range minimum query on start times.\n            # Let's create `min_cost_starting_at_or_after[l_val]`\n            \n            # This can be built by iterating backwards.\n            min_cost_starting_at_or_after = [float('inf')] * (max_coord + 2)\n            vouchers2_sorted_by_l = sorted([(l, cost) for l, _, cost in vouchers2])\n            \n            current_min_cost_for_start = float('inf')\n            ptr_l = len(vouchers2_sorted_by_l) - 1\n            for l_val in range(max_coord, 0, -1):\n                while ptr_l >= 0 and vouchers2_sorted_by_l[ptr_l][0] == l_val:\n                    current_min_cost_for_start = min(current_min_cost_for_start, vouchers2_sorted_by_l[ptr_l][1])\n                    ptr_l -= 1\n                min_cost_starting_at_or_after[l_val] = current_min_cost_for_start\n\n            if r1 + 1 <= max_coord:\n                cost2_candidate_start = min_cost_starting_at_or_after[r1 + 1]\n                if cost2_candidate_start != float('inf'):\n                    min_total_cost = min(min_total_cost, cost1 + cost2_candidate_start)\n\n    if min_total_cost == float('inf'):\n        sys.stdout.write(\"-1\\n\")\n    else:\n        sys.stdout.write(str(min_total_cost) + \"\\n\")\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 798,
        "completion_token_count": 1760,
        "thoughts_token_count": 0
    }
}