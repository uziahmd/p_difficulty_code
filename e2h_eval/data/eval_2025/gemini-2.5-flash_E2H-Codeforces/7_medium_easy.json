{
    "start": 1758015870.9144962,
    "end": 1758015962.4219022,
    "start-formatted": "2025-09-16 18:44 KST",
    "end-formatted": "2025-09-16 18:46 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "**Okay, here's my plan to tackle the Rudolf and Snowflakes problem, hard version.**  I'm dealing with snowflake structures, specifically figuring out if a given number of vertices (`n`) can form a snowflake.  Here's the breakdown of my thinking:\n\n1.  **Understand the Snowflake Structure:** A snowflake starts with a center vertex, then branches out.  Each branch can sprout more branches, following the problem's rules.  We have 'k' branches at each level.\n\n2.  **Formulate the Math:** The number of vertices increases geometrically.  So, the total vertices `n` can be represented as:  `n = 1 + k + k^2 + ... + k^m`, where `k > 1` (must have at least one branch) and `m >= 2` (it must have at least one branching). This is the sum of a geometric series, which simplifies to `n = (k^(m+1) - 1) / (k - 1)`.\n\n3.  **The Challenge:** I'm given `n` and need to determine if suitable integer values for `k` and `m` exist.  Since `n` can be huge (up to 10^18), I need an efficient approach.\n\n4.  **Simplify and Analyze Constraints:**\n\n    *   `k > 1` (a branch must have at least one branch).\n    *   `m >= 2` (branch must have branch).\n    *   `n <= 10^18` (huge value).\n5.  **Start with the Simplest Case (m = 2):**  If `m = 2`, I get `n = 1 + k + k^2`. This is a quadratic equation. Rearranging, I get `k^2 + k + (1 - n) = 0`. I can solve for `k` using the quadratic formula, `k = (-1 ± sqrt(4n - 3)) / 2`.  If `k` has a integer value then the result is Yes.\n\n    *   For `k` to be an integer, `4n - 3` must be a perfect square, and the result `k` must be greater than `1`.\n    *   This is a manageable case - I can check if `4n - 3` is a square and calculate `k`.\n\n6.  **Handle the General Case (m > 2):** When `m` is greater than 2, I have `n = (k^(m+1) - 1) / (k - 1)`. This is trickier because it's hard to solve directly.  I need to find `k` such that `k^m < n`.\n\n    *   I know `k` will be small relative to `n^(1/m)`\n    *   The highest possible `m` is roughly `60`, since that's when `2^m` becomes about 10^18.\n    *   I'll iterate through possible values of `m` from 3 up to 59 to find `k`.\n\n    *   **I'll use binary search for `k`:** For a fixed `m`, I'll use binary search within a valid range to find `k` in range `[2, floor(n**(1/m))]`\n\n7.  **Implementation Details:**\n\n    *   **Binary Search Upper Bound:** For each `m`, the binary search must be optimized.  I need a good upper bound for `k`. The correct upper bound should be `int(n**(1/m))`.\n    *   **Preventing Overflow:** When dealing with potentially large values (`k^(m+1)`), I must be very careful of integer overflow when computing and comparing. I will calculate `current_n` in loop.\n    *   **Efficiency:** I aim for a solution that is fast enough, given the constraints.  The combination of iterating over a range of `m` and using binary search seems like the most effective strategy.\n\n8.  **Algorithm in Detail:**\n\n    *   **Handle Small Values of `n`:** If `n` is small (like 1, 2, 3, etc.), I can directly return \"NO.\"\n\n    *   **Case `m=2` (quadratic case):**\n        *   Calculate `D = 4 * n - 3`\n        *   If `D` is not a perfect square (`S*S == D`) that produce a integer and odd `S`, the `k = (S-1)//2` is valid and the function should return YES.\n\n    *   **Cases `m >= 3",
    "response": "The problem asks us to determine if a given number of vertices `n` can form a \"snowflake\" graph. A snowflake is defined by two parameters: `k` (an integer `k > 1`) and `m` (an integer `m >= 2`). The total number of vertices `n` in such a snowflake is given by the sum of a geometric series:\n`n = 1 + k + k^2 + ... + k^m`\n\nThis sum can be expressed as `n = (k^(m+1) - 1) / (k - 1)`.\nWe are given `n` (up to `10^18`) and need to check if there exist integers `k > 1` and `m >= 2` that satisfy this equation.\n\nLet's break down the problem into cases based on `m`:\n\n**1. Case `m = 2`:**\nThe formula becomes `n = 1 + k + k^2`.\nThis is a quadratic equation in `k`: `k^2 + k + (1 - n) = 0`.\nUsing the quadratic formula, `k = (-1 ± sqrt(1 - 4 * (1 - n))) / 2 = (-1 ± sqrt(4n - 3)) / 2`.\nFor `k` to be a valid integer:\n- `4n - 3` must be a perfect square. Let `S = sqrt(4n - 3)`.\n- Since `k > 0`, we must use the positive root: `k = (-1 + S) / 2`.\n- `S` must be an integer, and `S` must be odd so that `S - 1` is even, making `k` an integer.\n- `k > 1` implies `(-1 + S) / 2 > 1`, which means `-1 + S > 2`, so `S > 3`.\n\nSo, for `m=2`, we check if `D = 4n - 3` is a perfect square `S^2` such that `S` is odd and `S > 3`. If these conditions hold, then `k = (S - 1) // 2` is a valid `k`, and `n` is a snowflake number.\n\n**2. Case `m >= 3`:**\nFor `m >= 3`, `n = 1 + k + k^2 + ... + k^m`.\nWe can observe some bounds:\n- Since `k > 1`, the smallest possible `k` is 2.\n- If `k=2`, `n = 1 + 2 + ... + 2^m = 2^(m+1) - 1`.\n- Given `n <= 10^18`, we have `2^(m+1) - 1 <= 10^18`, which implies `2^(m+1) <= 10^18 + 1`.\n- Taking `log2` on both sides: `m+1 <= log2(10^18 + 1)`.\n- `log2(10^18)` is approximately `18 * log2(10) approx 18 * 3.3219 approx 59.79`.\n- So, `m+1` can be at most `59`, which means `m` can be at most `58`. (A slightly more precise calculation shows `m` can go up to `59` for `n` values close to `2^60-1`). We can iterate `m` from `3` up to `59`.\n\nFor each fixed `m` in this range, we need to find if there exists an integer `k > 1` such that `1 + k + ... + k^m = n`.\nThe function `f(k) = 1 + k + ... + k^m` is strictly increasing for `k > 1`. This allows us to use binary search for `k`.\n\nWhat are the bounds for `k`?\n- Lower bound for `k` is `2`.\n- Upper bound for `k`: We know `k^m < n`. So `k < n^(1/m)`.\n  - For `m=3`, `k < (10^18)^(1/3) = 10^6`.\n  - For `m=59`, `k < (10^18)^(1/59) approx 2.01`. So `k` can only be `2`.\nA safe upper bound for `k` in binary search can be `10^6 + 7` (or `2 * 10^6` to be extra safe, though `10^6` is sufficient for `m=3`). A tighter upper bound for `k` for a given `m` is `int(n**(1/m)) + 2`.\n\n**Binary Search for `k` (for `m >= 3`):**\nFor each `m` from `3` to `59`:\n  - Set `low = 2`, `high = min(int(n**(1/m)) + 2, 2 * 10**6)` (the `2*10**6` is a loose but safe constant upper bound for `k` across all `m >= 3`).\n  - While `low <= high`:\n    - `mid_k = (low + high) // 2`.\n    - If `mid_k < 2`, set `low = 2` and continue (ensuring `k > 1`).\n    - Calculate `current_sum = 1 + mid_k + mid_k^2 + ... + mid_k^m`.\n      - This calculation must be done carefully to prevent intermediate overflows, as `mid_k^m` can be up to `(10^6)^3 = 10^18`.\n      - We can compute it iteratively: `current_sum = 1`, `current_term = 1`. For `i` from `1` to `m`:\n        - Check for `current_term * mid_k` overflow: if `mid_k > n // current_term`, then `current_term * mid_k` would exceed `n`. Mark as overflow.\n        - `current_term *= mid_k`.\n        - Check for `current_sum + current_term` overflow: if `current_sum > n - current_term`, then `current_sum + current_term` would exceed `n`. Mark as overflow.\n        - `current_sum += current_term`.\n      - If an overflow is detected during the sum calculation, it means `mid_k` is too large, so `current_sum` is effectively greater than `n`.\n    - Compare `current_sum` with `n`:\n      - If `current_sum == n`, we found a solution. Return \"YES\".\n      - If `current_sum < n`, `mid_k` is too small. Set `low = mid_k + 1`.\n      - If `current_sum > n` (or overflow occurred), `mid_k` is too large. Set `high = mid_k - 1`.\n  - If the binary search finishes without finding a `k` for the current `m`, continue to the next `m`.\n\nIf no solution is found after checking all `m` values, return \"NO\".\n\n**Edge cases:**\n- `n=1, 2, 3, 4, 5, 6`: The smallest snowflake has `k=2, m=2`, which gives `1+2+2^2 = 7`. So for `n < 7`, the answer is \"NO\".\n\n**Example walkthrough for `n=13`:**\n1. `n=13 >= 7`, so proceed.\n2. `m=2` case:\n   `D = 4 * 13 - 3 = 52 - 3 = 49`.\n   `S = int(49**0.5) = 7`.\n   `S * S == D` (7*7 == 49) is true.\n   `S % 2 == 1` (7 is odd) is true.\n   `S > 3` (7 > 3) is true.\n   `k = (S - 1) // 2 = (7 - 1) // 2 = 3`.\n   `k > 1` (3 > 1) is true.\n   Conditions met. Return \"YES\".\n\n**Example walkthrough for `n=15`:**\n1. `n=15 >= 7`, so proceed.\n2. `m=2` case:\n   `D = 4 * 15 - 3 = 60 - 3 = 57`.\n   `S = int(57**0.5) = 7`.\n   `S * S == D` (7*7 == 49) is false. `57` is not a perfect square.\n   No solution for `m=2`.\n3. `m >= 3` cases:\n   Iterate `m` from `3` to `59`.\n   - For `m=3`:\n     `low = 2`, `high = min(int(15**(1/3)) + 2, 2 * 10**6) = min(2+2, 2*10**6) = 4`.\n     Binary search for `k` in `[2, 4]`:\n       - `mid_k = (2+4)//2 = 3`.\n       - `current_sum` for `k=3, m=3`: `1+3+3^2+3^3 = 1+3+9+27 = 40`.\n       - `40 > 15`, so `high = 3 - 1 = 2`.\n       - `low = 2, high = 2`.\n       - `mid_k = (2+2)//2 = 2`.\n       - `current_sum` for `k=2, m=3`: `1+2+2^2+2^3 = 1+2+4+8 = 15`.\n       - `15 == n`. Return \"YES\".\n\n**Complexity:**\n- `m=2` check: `O(log n)` (for `sqrt`).\n- `m >= 3` check:\n  - Outer loop for `m`: `log n` iterations (approx `60`).\n  - Inner binary search for `k`: `log(max_k)` iterations (approx `log(10^6) = 20`).\n  - Inside binary search, sum calculation: `m` iterations (approx `60`).\n  - Total: `O(log n * log(max_k) * log n) = O((log n)^3)`.\n  - With `n=10^18`, `log n` is about `60`. So `60^3 = 216,000` operations, which is very efficient.\n\n```python\nimport sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n\n    if n < 7: # Smallest snowflake is 1+2+2^2 = 7\n        sys.stdout.write(\"NO\\n\")\n        return\n\n    # Case m = 2: n = 1 + k + k^2\n    # k^2 + k + (1 - n) = 0\n    # Discriminant D = 1 - 4(1-n) = 1 - 4 + 4n = 4n - 3\n    # k = (-1 + sqrt(4n - 3)) / 2\n    \n    D = 4 * n - 3\n    s_float = D**0.5\n    s_int = int(s_float)\n\n    if s_int * s_int == D: # Check if D is a perfect square\n        if (s_int - 1) % 2 == 0: # Check if s_int is odd (so s_int - 1 is even)\n            k_val = (s_int - 1) // 2\n            if k_val > 1: # k must be greater than 1\n                sys.stdout.write(\"YES\\n\")\n                return\n\n    # Case m >= 3: n = 1 + k + k^2 + ... + k^m\n    # Iterate m from 3 up to around 59 (since 2^60 > 10^18)\n    # For each m, binary search for k\n    \n    # Upper bound for m: 2^m < n => m < log2(n)\n    # log2(10^18) approx 59.79. So m up to 59 is sufficient.\n    for m in range(3, 61): # m can be up to 59. Max 60 for range is fine.\n        # Binary search for k\n        # k^m < n => k < n^(1/m)\n        # For m=3, k_max approx 10^6. For m=59, k_max approx 2.\n        # A safe upper bound for k in binary search is 2 * 10^6\n        # A tighter upper bound for k is int(n**(1/m)) + 2 to account for float precision\n        low_k = 2\n        high_k = int(n**(1/m)) + 2 # Add 2 for safety due to float precision\n        high_k = min(high_k, 2 * 10**6) # Cap high_k to a reasonable constant maximum\n\n        while low_k <= high_k:\n            mid_k = (low_k + high_k) // 2\n\n            if mid_k < 2: # k must be > 1\n                low_k = 2\n                continue\n\n            current_sum = 1\n            current_term = 1\n            overflow = False\n\n            for _ in range(m):\n                # Check for overflow before multiplication\n                # current_term * mid_k > n\n                if mid_k > n // current_term: \n                    overflow = True\n                    break\n                current_term *= mid_k\n\n                # Check for overflow before addition\n                # current_sum + current_term > n\n                if current_sum > n - current_term:\n                    overflow = True\n                    break\n                current_sum += current_term\n            \n            if overflow or current_sum > n:\n                high_k = mid_k - 1\n            elif current_sum == n:\n                sys.stdout.write(\"YES\\n\")\n                return\n            else: # current_sum < n\n                low_k = mid_k + 1\n    \n    sys.stdout.write(\"NO\\n\")\n\n\nnum_test_cases = int(sys.stdin.readline())\nfor _ in range(num_test_cases):\n    solve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n\n    if n < 7: # Smallest snowflake is 1+2+2^2 = 7\n        sys.stdout.write(\"NO\\n\")\n        return\n\n    # Case m = 2: n = 1 + k + k^2\n    # k^2 + k + (1 - n) = 0\n    # Discriminant D = 1 - 4(1-n) = 1 - 4 + 4n = 4n - 3\n    # k = (-1 + sqrt(4n - 3)) / 2\n    \n    D = 4 * n - 3\n    s_float = D**0.5\n    s_int = int(s_float)\n\n    if s_int * s_int == D: # Check if D is a perfect square\n        if (s_int - 1) % 2 == 0: # Check if s_int is odd (so s_int - 1 is even)\n            k_val = (s_int - 1) // 2\n            if k_val > 1: # k must be greater than 1\n                sys.stdout.write(\"YES\\n\")\n                return\n\n    # Case m >= 3: n = 1 + k + k^2 + ... + k^m\n    # Iterate m from 3 up to around 59 (since 2^60 > 10^18)\n    # For each m, binary search for k\n    \n    # Upper bound for m: 2^m < n => m < log2(n)\n    # log2(10^18) approx 59.79. So m up to 59 is sufficient.\n    for m in range(3, 61): # m can be up to 59. Max 60 for range is fine.\n        # Binary search for k\n        # k^m < n => k < n^(1/m)\n        # For m=3, k_max approx 10^6. For m=59, k_max approx 2.\n        # A safe upper bound for k in binary search is 2 * 10^6\n        # A tighter upper bound for k is int(n**(1/m)) + 2 to account for float precision\n        low_k = 2\n        high_k = int(n**(1/m)) + 2 # Add 2 for safety due to float precision\n        high_k = min(high_k, 2 * 10**6) # Cap high_k to a reasonable constant maximum\n\n        while low_k <= high_k:\n            mid_k = (low_k + high_k) // 2\n\n            if mid_k < 2: # k must be > 1\n                low_k = 2\n                continue\n\n            current_sum = 1\n            current_term = 1\n            overflow = False\n\n            for _ in range(m):\n                # Check for overflow before multiplication\n                # current_term * mid_k > n\n                if mid_k > n // current_term: \n                    overflow = True\n                    break\n                current_term *= mid_k\n\n                # Check for overflow before addition\n                # current_sum + current_term > n\n                if current_sum > n - current_term:\n                    overflow = True\n                    break\n                current_sum += current_term\n            \n            if overflow or current_sum > n:\n                high_k = mid_k - 1\n            elif current_sum == n:\n                sys.stdout.write(\"YES\\n\")\n                return\n            else: # current_sum < n\n                low_k = mid_k + 1\n    \n    sys.stdout.write(\"NO\\n\")\n\n\nnum_test_cases = int(sys.stdin.readline())\nfor _ in range(num_test_cases):\n    solve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 568,
        "completion_token_count": 3422,
        "thoughts_token_count": 6581
    }
}