{
    "start": 1758009326.4278402,
    "end": 1758009379.0681338,
    "start-formatted": "2025-09-16 16:55 KST",
    "end-formatted": "2025-09-16 16:56 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "**Analyzing the Snowflake Structure for the Rudolf Problem**\n\nOkay, I'm diving into this \"Rudolf and Snowflakes (hard version)\" problem, and my initial thought process is focusing on breaking down the snowflake's structure. It's clear that I need a Python script to do this effectively, so let's outline the core logic.\n\nFirst, I'm visualizing the snowflake's build-up. There's a central vertex, and then it branches out in layers. The problem specifies a connection to 'k' new vertices from the center. Now, each of those initial 'k' vertices is only connected to the center at the moment, which means the rule about connecting single-connected vertices to more vertices will be applied at least once.\n\nLet's trace the vertex count: starting with the center (Level 0, 1 vertex), we have 'k' vertices in Level 1. Then, applying the branching rule once, we get 'k' vertices connected to each Level 1 vertex, adding k*k = k^2 vertices in Level 2. So, with one branching step, we have 1 + k + k^2 vertices.  This forms the basis.\n\nNow, I generalize: applying the rule 'm' times results in `m+1` layers, including the central vertex. The total number of vertices becomes a geometric series: `1 + k + k^2 + ... + k^m`, which sums to `(k^(m+1) - 1) / (k - 1)`.\n\nEssentially, I need to take the input `n` (the total number of vertices) and figure out if I can find valid integer values for `k` (greater than 1) and `m` (greater than or equal to 1) that satisfy this equation. That will be the core of the problem. This is a crucial first step; from here, I can start thinking about how to efficiently search for the right `k` and `m` values.\n",
    "response": "The problem asks us to determine if a given number of vertices `n` can form a \"snowflake\" graph. A snowflake is defined by a parameter `k > 1` and a number of expansion steps `m >= 1`.\n\nLet's analyze the structure of a snowflake:\n1.  **Initial vertex:** 1 vertex (the center).\n2.  **First layer:** The center is connected to `k` new vertices. Total vertices: `1 + k`.\n3.  **Expansion step:** Each vertex that is connected to only one other vertex is connected to `k` more new vertices. This step must be done at least once.\n\nLet's trace the total number of vertices `n` based on the number of times the expansion step (rule 3) is applied. Let `m` be the number of times this step is applied. `m` must be at least 1.\n\n*   **If `m = 1`:**\n    *   Initial vertex: 1\n    *   Level 1 vertices: `k` (connected to the center). These `k` vertices are currently connected to only one other vertex.\n    *   Applying rule 3 once: Each of the `k` Level 1 vertices is connected to `k` new vertices. This adds `k * k = k^2` Level 2 vertices.\n    *   Total vertices `n = 1 + k + k^2`.\n\n*   **If `m = 2`:**\n    *   After `m=1` (as above): `1 + k + k^2` vertices. The `k^2` Level 2 vertices are currently connected to only one other vertex.\n    *   Applying rule 3 a second time: Each of the `k^2` Level 2 vertices is connected to `k` new vertices. This adds `k^2 * k = k^3` Level 3 vertices.\n    *   Total vertices `n = 1 + k + k^2 + k^3`.\n\nIn general, if the expansion step is applied `m` times, the total number of vertices `n` will be the sum of a geometric series:\n`n = 1 + k + k^2 + ... + k^m`\n\nThis sum can be expressed as `n = (k^(m+1) - 1) / (k - 1)`.\n\nWe are given `n` (`1 <= n <= 10^18`) and need to check if there exist integers `k > 1` and `m >= 1` satisfying this equation.\n\nThere are two main cases to consider:\n\n**Case 1: `m = 1`**\nIf `m = 1`, then `n = 1 + k + k^2`.\nThis is a quadratic equation in `k`: `k^2 + k + (1 - n) = 0`.\nUsing the quadratic formula, `k = (-1 ± sqrt(1 - 4 * 1 * (1 - n))) / 2`\n`k = (-1 ± sqrt(1 - 4 + 4n)) / 2`\n`k = (-1 ± sqrt(4n - 3)) / 2`\n\nFor `k` to be a valid integer greater than 1:\n1.  `4n - 3` must be a perfect square. Let `sqrt(4n - 3) = S`.\n2.  `S` must be an integer.\n3.  `(-1 + S) / 2` must be an integer. This implies `S` must be odd (so `S-1` is even).\n4.  `(-1 + S) / 2 > 1`, which means `S - 1 > 2`, so `S > 3`.\n\nWe can check this by calculating `S = floor(sqrt(4n - 3))`. If `S * S == 4n - 3` and `S > 3` and `S` is odd, then `k = (S - 1) / 2` is a valid solution.\n\n**Case 2: `m >= 2`**\nIf `m >= 2`, then `n = 1 + k + ... + k^m`.\nSince `k > 1` and `m >= 2`:\n`n = 1 + k + k^2 + ... + k^m`\n`n > k^m`\n`n > k^2` (since `m >= 2`)\n\nFrom `n > k^m`, we have `k < n^(1/m)`.\nSince `m >= 2`, `k < n^(1/2)`. The maximum value for `k` would be `sqrt(10^18) = 10^9`.\nFrom `n > k^2`, we have `k < sqrt(n)`.\nThe minimum value for `k` is 2.\n\nWe can iterate through possible values of `m` starting from 2.\nWhat is the maximum possible value for `m`?\nIf `k = 2`, then `n = 1 + 2 + ... + 2^m = 2^(m+1) - 1`.\nSince `n <= 10^18`, `2^(m+1) - 1 <= 10^18`.\n`2^(m+1) <= 10^18 + 1`.\n`m+1 <= log2(10^18 + 1)`.\n`log2(10^18) = 18 * log2(10) approx 18 * 3.32 = 59.79`.\nSo `m+1` can be at most around 60. This means `m` can be at most around 59.\nThis range for `m` (from 2 to ~59) is very small.\n\nFor each `m` in this range:\nWe need to find if there exists an integer `k > 1` such that `n = (k^(m+1) - 1) / (k - 1)`.\nThis equation can be rewritten as `n * (k - 1) = k^(m+1) - 1`.\nOr, `n = 1 + k + k^2 + ... + k^m`.\nWe can use binary search to find `k` for a fixed `m`.\nThe lower bound for `k` is `2`.\nThe upper bound for `k` is `n^(1/m) + 2` (a bit more than `n^(1/m)` to be safe, since `1+k+...+k^m` is slightly larger than `k^m`).\nA loose upper bound for `k` is `10^9` (for `m=2`). A tighter one is `n^(1/m)`.\nFor `m=2`, `k` goes up to `10^9`.\nFor `m=59`, `k` can only be `2` (since `2^59` is already large).\n\n**Binary Search for `k`:**\nFor a fixed `m` (from 2 to approx 59):\nSet `low = 2`, `high = min(int(n**(1/m)) + 2, 10**9 + 7)` (use a slightly larger upper bound for safety, but `10^9+7` is sufficient for `m=2`).\nWhile `low <= high`:\n  `mid = (low + high) // 2`\n  If `mid <= 1`, continue to `low = mid + 1`. (We need `k > 1`).\n  Calculate `current_sum = 1 + mid + mid^2 + ... + mid^m`.\n  Be careful about overflow when calculating `mid^p`. `mid^m` can be up to `(10^9)^2 = 10^18` for `m=2`.\n  If `mid` is large, `mid^m` can exceed `n` very quickly.\n  A safer way to compute `current_sum`:\n  `term = 1`\n  `current_sum = 1`\n  For `i` from 1 to `m`:\n    If `term > n / mid`: (Check for `term * mid` overflow before multiplication)\n      `current_sum = n + 1` (simulate overflow to exceed `n`)\n      break\n    `term *= mid`\n    `current_sum += term`\n    If `current_sum > n`: (Check for `current_sum` overflow or exceeding `n`)\n      break\n\n  If `current_sum == n`:\n    Return \"YES\" (found a valid `k` for this `m`).\n  If `current_sum < n`:\n    `low = mid + 1` (need a larger `k`)\n  If `current_sum > n`:\n    `high = mid - 1` (need a smaller `k`)\n\nIf no `k` is found for any `m` (and no solution for `m=1`), then return \"NO\".\n\n**Summary of algorithm:**\n\n1.  Handle `n < 7`: Smallest snowflake `1+2+2^2 = 7`. So `n=1,2,3,4,5,6` are impossible. Output \"NO\". (This check covers `n=1,2,3,6` from example).\n    *   Actually, `1+k+k^2` with `k=2` is `7`. `1+k` is not a snowflake. So the smallest `n` is `7`.\n    *   The example output for `n=13` is YES. `13 = 1+3+3^2`. Here `k=3, m=2`.\n    *   The example output for `n=15` is YES. `15 = 1+2+2^2+2^3`. Here `k=2, m=3`.\n    *   This means my `m` definition is `1` for `1+k+k^2`.\n    *   The problem states: \"This step should be done at least once.\" This refers to rule 3.\n    *   If rule 3 is done once, `n = 1 + k + k^2`.\n    *   If rule 3 is done twice, `n = 1 + k + k^2 + k^3`.\n    *   So my `m` corresponds to the highest power of `k` in the sum. `m` is the number of times rule 3 is applied.\n    *   The smallest `n` is for `k=2, m=1`, which is `1+2+2^2 = 7`.\n    *   So for `n < 7`, it's always \"NO\".\n\n2.  **Check for `m=1`:**\n    Calculate `S = floor(sqrt(4n - 3))`.\n    If `S * S == 4n - 3` and `S > 3` and `S % 2 == 1`:\n        `k = (S - 1) / 2`.\n        If such `k` exists, print \"YES\" and return.\n\n3.  **Check for `m >= 2`:**\n    Iterate `m` from `2` up to `60` (or `log2(n)` approximately).\n    For each `m`:\n        Perform binary search for `k` in range `[2, min(int(n**(1/m)) + 2, 10**9 + 7)]`.\n        Inside binary search:\n            Calculate `current_sum = 1 + k + k^2 + ... + k^m`.\n            Be careful with potential `k^p` overflow. Stop adding terms if `current_sum` exceeds `n`.\n            If `current_sum == n`, print \"YES\" and return.\n            Adjust binary search bounds.\n\n4.  If no solution found after all checks, print \"NO\".\n\n**Edge cases:**\n*   `n=1,2,3,4,5,6`: Output \"NO\" (as `1+k+k^2` for `k=2` is `7`).\n*   `n=13`: `m=1` check: `4*13-3 = 49`. `S=7`. `S*S=49`, `S=7 > 3`, `S` is odd. `k=(7-1)/2 = 3`. Valid. Output \"YES\".\n*   `n=15`: `m=1` check: `4*15-3 = 57`. Not a perfect square.\n    `m=2` check: Binary search for `k` for `n = 1+k+k^2+k^3`.\n        `k=2`: `1+2+4+8 = 15`. Found! Output \"YES\".\n\n**Python implementation details:**\n*   Use `math.isqrt` for integer square root.\n*   The `pow` function can handle large exponents, but `sum(k**i for i in range(m+1))` can be slow or overflow for intermediate `k**i` if not careful. The iterative sum with overflow checks is better.\n*   The upper bound for `k` in binary search for `m >= 2` can be `n^(1/m)`. `n^(1/m)` for `n=10^18, m=2` is `10^9`. For `n=10^18, m=59`, `k` would be `~2`.\n    The `min(int(n**(1/m)) + 2, 2 * 10**9)` is a good practical upper bound for `k` that covers all cases. `2 * 10**9` is sufficiently large. `10**9 + 7` is also fine.\n\nLet's refine the binary search `current_sum` calculation to be robust against overflow and efficiency:\n\n```python\ndef check_sum(k, m, n):\n    current_sum = 1\n    term = 1\n    for _ in range(m): # Iterate m times to get k^m\n        # Check for overflow before multiplying term by k\n        # If term > n / k, then term * k will definitely exceed n (or overflow)\n        # We can use n // k to be safe, since n is max 10^18 and k is max 10^9\n        if k > 1 and term > n // k:\n            return n + 1 # Indicate sum is too large without actual overflow\n        term *= k\n        # Check for overflow before adding term to current_sum\n        if current_sum > n - term: # current_sum + term > n\n            return n + 1 # Indicate sum is too large\n        current_sum += term\n    return current_sum\n```\nThis `check_sum` function is robust.\n\nFinal check on `n < 7` logic:\n`n = 1 + k + ... + k^m`.\nSmallest `k` is 2. Smallest `m` is 1.\nSo smallest `n` is `1 + 2 + 2^2 = 7`.\nThus, `n` values `1, 2, 3, 4, 5, 6` are impossible.\n\n```python\nimport sys\nimport math\n\ndef solve():\n    n = int(sys.stdin.readline())\n\n    if n < 7: # Smallest snowflake is 1+2+2^2 = 7\n        sys.stdout.write(\"NO\\n\")\n        return\n\n    # Case 1: m = 1 (n = 1 + k + k^2)\n    # k^2 + k + (1 - n) = 0\n    # Discriminant D = 1 - 4 * (1 - n) = 1 - 4 + 4n = 4n - 3\n    # k = (-1 + sqrt(4n - 3)) / 2\n    \n    discriminant = 4 * n - 3\n    s = math.isqrt(discriminant) # Integer square root\n\n    if s * s == discriminant: # Check if 4n - 3 is a perfect square\n        if (s - 1) % 2 == 0: # Check if s - 1 is even, so k is an integer\n            k_val = (s - 1) // 2\n            if k_val > 1: # k must be greater than 1\n                sys.stdout.write(\"YES\\n\")\n                return\n\n    # Case 2: m >= 2 (n = 1 + k + ... + k^m)\n    # Iterate m from 2 up to max_m.\n    # max_m is around 60 because 2^60 is roughly 10^18.\n    # For k=2, n = 2^(m+1) - 1. So m+1 approx log2(n).\n    max_m = 60 \n\n    for m in range(2, max_m + 1):\n        # Binary search for k\n        # k must be > 1.\n        # k^m < n => k < n^(1/m)\n        # Upper bound for k: n^(1/m) can be up to 10^9 for m=2, n=10^18.\n        # Add a small buffer to the upper bound.\n        low = 2\n        high = int(n**(1/m)) + 2 # A safe upper bound for k\n\n        # To avoid high being too large when n**(1/m) is small (e.g. n=7, m=3, n**(1/m) is 1),\n        # ensure high is at least 2.\n        # Also, high should not exceed a reasonable max (e.g., k=10^9 for m=2)\n        high = min(high, 2 * 10**9) # Cap high to prevent excessive values\n\n        found_k_for_m = False\n        while low <= high:\n            k = (low + high) // 2\n            \n            if k <= 1: # k must be > 1\n                low = k + 1\n                continue\n\n            current_sum = 1\n            term = 1\n            possible_overflow = False\n\n            for _ in range(m): # Add k, k^2, ..., k^m\n                # Check for term * k overflow or exceeding n\n                # If term is already very large, term * k will be even larger\n                # A safe check: if term > n / k, then term * k > n\n                # This check ensures term * k does not overflow if n is max 10^18 and k is max 10^9\n                if k > 1 and term > n // k: # Use n // k for integer division\n                    possible_overflow = True\n                    break\n                term *= k\n                \n                # Check for current_sum + term overflow or exceeding n\n                if current_sum > n - term: # equivalent to current_sum + term > n\n                    possible_overflow = True\n                    break\n                current_sum += term\n            \n            if possible_overflow:\n                # The sum is too large, need a smaller k\n                high = k - 1\n            elif current_sum == n:\n                found_k_for_m = True\n                break\n            elif current_sum < n:\n                # Sum is too small, need a larger k\n                low = k + 1\n            else: # current_sum > n\n                # Sum is too large, need a smaller k\n                high = k - 1\n        \n        if found_k_for_m:\n            sys.stdout.write(\"YES\\n\")\n            return\n\n    sys.stdout.write(\"NO\\n\")\n\n\nnum_test_cases = int(sys.stdin.readline())\nfor _ in range(num_test_cases):\n    solve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\n\ndef solve():\n    n = int(sys.stdin.readline())\n\n    if n < 7: # Smallest snowflake is 1+2+2^2 = 7\n        sys.stdout.write(\"NO\\n\")\n        return\n\n    # Case 1: m = 1 (n = 1 + k + k^2)\n    # k^2 + k + (1 - n) = 0\n    # Discriminant D = 1 - 4 * (1 - n) = 1 - 4 + 4n = 4n - 3\n    # k = (-1 + sqrt(4n - 3)) / 2\n    \n    discriminant = 4 * n - 3\n    s = math.isqrt(discriminant) # Integer square root\n\n    if s * s == discriminant: # Check if 4n - 3 is a perfect square\n        if (s - 1) % 2 == 0: # Check if s - 1 is even, so k is an integer\n            k_val = (s - 1) // 2\n            if k_val > 1: # k must be greater than 1\n                sys.stdout.write(\"YES\\n\")\n                return\n\n    # Case 2: m >= 2 (n = 1 + k + ... + k^m)\n    # Iterate m from 2 up to max_m.\n    # max_m is around 60 because 2^60 is roughly 10^18.\n    # For k=2, n = 2^(m+1) - 1. So m+1 approx log2(n).\n    max_m = 60 \n\n    for m in range(2, max_m + 1):\n        # Binary search for k\n        # k must be > 1.\n        # k^m < n => k < n^(1/m)\n        # Upper bound for k: n^(1/m) can be up to 10^9 for m=2, n=10^18.\n        # Add a small buffer to the upper bound.\n        low = 2\n        high = int(n**(1/m)) + 2 # A safe upper bound for k\n\n        # To avoid high being too large when n**(1/m) is small (e.g. n=7, m=3, n**(1/m) is 1),\n        # ensure high is at least 2.\n        # Also, high should not exceed a reasonable max (e.g., k=10^9 for m=2)\n        high = min(high, 2 * 10**9) # Cap high to prevent excessive values\n\n        found_k_for_m = False\n        while low <= high:\n            k = (low + high) // 2\n            \n            if k <= 1: # k must be > 1\n                low = k + 1\n                continue\n\n            current_sum = 1\n            term = 1\n            possible_overflow = False\n\n            for _ in range(m): # Add k, k^2, ..., k^m\n                # Check for term * k overflow or exceeding n\n                # If term is already very large, term * k will be even larger\n                # A safe check: if term > n / k, then term * k > n\n                # This check ensures term * k does not overflow if n is max 10^18 and k is max 10^9\n                if k > 1 and term > n // k: # Use n // k for integer division\n                    possible_overflow = True\n                    break\n                term *= k\n                \n                # Check for current_sum + term overflow or exceeding n\n                if current_sum > n - term: # equivalent to current_sum + term > n\n                    possible_overflow = True\n                    break\n                current_sum += term\n            \n            if possible_overflow:\n                # The sum is too large, need a smaller k\n                high = k - 1\n            elif current_sum == n:\n                found_k_for_m = True\n                break\n            elif current_sum < n:\n                # Sum is too small, need a larger k\n                low = k + 1\n            else: # current_sum > n\n                # Sum is too large, need a smaller k\n                high = k - 1\n        \n        if found_k_for_m:\n            sys.stdout.write(\"YES\\n\")\n            return\n\n    sys.stdout.write(\"NO\\n\")\n\n\nnum_test_cases = int(sys.stdin.readline())\nfor _ in range(num_test_cases):\n    solve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 569,
        "completion_token_count": 4561,
        "thoughts_token_count": 819
    }
}