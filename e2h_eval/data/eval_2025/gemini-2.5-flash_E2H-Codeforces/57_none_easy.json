{
    "start": 1758293708.9420373,
    "end": 1758293735.9554381,
    "start-formatted": "2025-09-19 23:55 KST",
    "end-formatted": "2025-09-19 23:55 KST",
    "gpu": 2,
    "pid": 57,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Olympiad\n\nA boy named Vasya has taken part in an Olympiad. His teacher knows that in total Vasya got at least x points for both tours of the Olympiad. The teacher has the results of the first and the second tour of the Olympiad but the problem is, the results have only points, no names. The teacher has to know Vasya's chances.Help Vasya's teacher, find two numbers — the best and the worst place Vasya could have won. Note that the total results' table sorts the participants by the sum of points for both tours (the first place has the participant who has got the most points). If two or more participants have got the same number of points, it's up to the jury to assign places to them according to their choice. It is guaranteed that each participant of the Olympiad participated in both tours of the Olympiad.\n\n## Input\nThe first line contains two space-separated integers n, x (1 ≤ n ≤ 105; 0 ≤ x ≤ 2·105) — the number of Olympiad participants and the minimum number of points Vasya earned.The second line contains n space-separated integers: a1, a2, ..., an (0 ≤ ai ≤ 105) — the participants' points in the first tour.The third line contains n space-separated integers: b1, b2, ..., bn (0 ≤ bi ≤ 105) — the participants' points in the second tour.The participants' points are given in the arbitrary order. It is guaranteed that Vasya was present in the Olympiad — there are two integers i, j (1 ≤ i, j ≤ n) such, that ai + bj ≥ x.\n\n## Output\nPrint two space-separated integers — the best and the worst place Vasya could have got on the Olympiad.\n\n## Example\n### Input\n['5 2\\n1 1 1 1 1\\n1 1 1 1 1', '6 7\\n4 3 5 6 4 4\\n8 6 0 4 3 4']\n\n### Output\n['1 5', '1 5']\n\n## Note\nIn the first text sample all 5 participants earn 2 points each in any case. Depending on the jury's decision, Vasya can get the first (the best) as well as the last (the worst) fifth place.In the second test sample in the best case scenario Vasya wins again: he can win 12 points and become the absolute winner if the total results' table looks like that — {4:8, 6:4, 3:6, 4:4, 4:3, 5:0}.In this table all participants are sorted by decreasing points and we can see how much a participant earned in the first and in the second tour.In the worst case scenario Vasya can get the fifth place if the table looks like that — {4:8, 4:6, 6:4, 5:4, 4:3, 3:0}, and he earned 4 and 3 points in the first and second tours, correspondingly.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "",
    "response": "```python\ndef solve():\n    n, x = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n\n    a.sort()\n    b.sort()\n\n    # Calculate best possible rank\n    # Vasya wants to maximize his score and be better than others.\n    # To maximize his score, he should take the highest possible score from 'a' and 'b' that sum up to at least x.\n    # The problem statement guarantees that such a pair exists.\n    # To find the best rank, we need to count how many other participants *could* score strictly higher than Vasya.\n    # If Vasya scores S_vasya, and another participant scores S_other,\n    # Vasya's rank is 1 + (number of participants with S_other > S_vasya)\n    #\n    # However, the problem statement says \"the first place has the participant who has got the most points\".\n    # \"If two or more participants have got the same number of points, it's up to the jury to assign places to them according to their choice.\"\n    # This means for the best rank, Vasya can always be assigned 1st place among those with the maximum score.\n    # So, we want to maximize Vasya's score.\n    # Vasya can pick any a_i and b_j such that a_i + b_j >= x.\n    # The maximum possible score Vasya can achieve is a[n-1] + b[n-1].\n    # Let S_max_vasya = a[n-1] + b[n-1].\n    #\n    # To find the best rank:\n    # Vasya wants to achieve the highest possible score.\n    # He can pick a_i and b_j such that a_i + b_j >= x.\n    # The maximum possible score he can get is a[n-1] + b[n-1].\n    # Let this be S_V_max = a[n-1] + b[n-1].\n    #\n    # We need to count how many *other* participants can achieve a score strictly greater than S_V_max.\n    # This is impossible, as S_V_max is the absolute maximum possible sum from any pair.\n    # So, the number of people with strictly greater score is 0.\n    #\n    # What if others can achieve the same score as Vasya?\n    # For best rank, if Vasya is tied for the highest score, he can be placed 1st.\n    #\n    # So, the best rank is always 1.\n    # This is because Vasya can choose the largest a_i and largest b_j.\n    # This (a[n-1], b[n-1]) pair will give him the maximum possible total score among all participants.\n    # Since he has the highest possible score, he can be assigned 1st place.\n    best_rank = 1\n\n    # Calculate worst possible rank\n    # Vasya wants to minimize his score (but still >= x) and have as many people as possible score higher or equal.\n    # We need to find a pairing of (a, b) for all participants (including Vasya) such that:\n    # 1. Vasya's score (a_vasya + b_vasya) is minimized, but >= x.\n    # 2. As many other participants as possible get a score >= Vasya's score.\n    #\n    # Let's consider a fixed score S_vasya that Vasya could achieve (S_vasya >= x).\n    # To maximize Vasya's rank (make it worse), we want to count how many other participants can get a score\n    # greater than or equal to S_vasya.\n    #\n    # We need to find a pairing for all n participants.\n    # This is a maximum bipartite matching problem, but simpler.\n    # We want to find a pairing (a_i, b_j) for each participant such that the number of pairs (a_k, b_l)\n    # with a_k + b_l >= S_threshold is maximized.\n    #\n    # Let's fix Vasya's score to be some a_i + b_j >= x.\n    # To maximize his rank, we want to find a pairing for the remaining n-1 participants\n    # such that as many as possible get a score >= Vasya's chosen score.\n    #\n    # A greedy approach for worst rank:\n    # Sort 'a' in ascending order.\n    # Sort 'b' in ascending order.\n    #\n    # We want to count how many participants can score >= Vasya's score.\n    # Vasya's actual score is not fixed. It's one (a_i, b_j) pair.\n    #\n    # Consider a fixed participant 'p' (not Vasya).\n    # What's the minimum score 'p' can get, such that Vasya gets a score >= x?\n    #\n    # Let's try to find a pairing for all participants that maximizes the number of people\n    # with a high score.\n    #\n    # We want to find a permutation of 'b' (say, b') such that for each i, a[i] is paired with b'[i].\n    # And Vasya is one of these (a[i], b'[i]) pairs.\n    #\n    # For the worst rank, we want to count how many pairs (a_i, b_j) can be formed such that their sum\n    # is greater than or equal to some threshold S_vasya.\n    #\n    # The key insight for worst rank is to realize that Vasya's specific (a_i, b_j) pair is not known.\n    # We need to find the maximum number of participants (including Vasya) who can achieve a score >= S for some S.\n    #\n    # Let's sort 'a' and 'b'.\n    # We want to pair a_i with b_j such that a_i + b_j >= x.\n    #\n    # The problem asks for the maximum possible value of (1 + count of people with score > Vasya's score)\n    # or (1 + count of people with score >= Vasya's score) if jury puts Vasya last among ties.\n    # The latter is what \"worst place\" implies.\n    #\n    # Consider the problem of counting how many pairs (a_i, b_j) can be formed such that a_i + b_j >= K.\n    # This can be done by sorting 'a' and 'b'.\n    # Iterate through sorted 'a'. For each a_i, find the smallest b_j such that a_i + b_j >= K.\n    # All b_k >= b_j will also satisfy this.\n    #\n    # For worst rank, we need to find a permutation of 'b' (say b_perm) such that\n    # for each i, the participant gets score a[i] + b_perm[i].\n    # One of these (a[i], b_perm[i]) pairs is Vasya's.\n    # We want to maximize the number of people who score >= Vasya's score.\n    #\n    # This is equivalent to finding the maximum k such that there exists a pairing of k participants\n    # (a_i, b_j) where a_i + b_j >= x.\n    #\n    # Let's use a two-pointer approach to count the maximum number of pairs (a_i, b_j) such that a_i + b_j >= x.\n    # Sort 'a' and 'b' (they are already sorted).\n    # Initialize count = 0.\n    # Pointer 'i' for 'a' starts at 0 (smallest a_i).\n    # Pointer 'j' for 'b' starts at n-1 (largest b_j).\n    #\n    # While i < n and j >= 0:\n    #   If a[i] + b[j] >= x:\n    #     We can form a valid pair. We want to maximize such pairs.\n    #     To do this, we pair the smallest remaining 'a' with the largest remaining 'b'.\n    #     This leaves smaller 'b's for larger 'a's, or vice versa, maximizing chances for other pairs.\n    #     So, we increment count, move 'i' forward, and move 'j' backward.\n    #   Else (a[i] + b[j] < x):\n    #     The current a[i] is too small to pair with b[j] to reach 'x'.\n    #     Since 'b' is sorted, b[j] is the largest available. No other b_k < b[j] will work with a[i].\n    #     So, a[i] cannot form a pair >= x with any remaining b_k.\n    #     We must discard a[i] and try with the next a[i+1].\n    #     (Wait, this logic is flawed. We are trying to maximize the number of pairs.\n    #     If a[i] + b[j] < x, it means a[i] is too small for b[j].\n    #     But maybe a[i] can be paired with a larger b_k if we were to pick one, but we are using largest b_j.\n    #     This means a[i] cannot be paired with *any* b_k to reach x if b_k <= b[j].\n    #     So we must increment i.\n    #     The standard two-pointer for counting pairs (a_i, b_j) with sum >= X is:\n    #     Sort a and b.\n    #     Left pointer 'l' for 'a' at 0. Right pointer 'r' for 'b' at n-1.\n    #     Count = 0.\n    #     While l < n and r >= 0:\n    #       If a[l] + b[r] >= x:\n    #         This pair works. We can use it. We increment count.\n    #         We must use a[l] and b[r]. So l++ and r--.\n    #       Else (a[l] + b[r] < x):\n    #         a[l] is too small to make x even with the largest available b[r].\n    #         So a[l] cannot be paired with any b_k to make x.\n    #         We must discard a[l]. So l++.\n    # This counts the maximum number of pairs (a_i, b_j) such that a_i + b_j >= x.\n    # This maximum number of pairs is exactly the worst rank.\n    # Why? Because we can arrange the pairings such that these 'count' participants all score >= x.\n    # Vasya is one of them. The jury can place Vasya last among these 'count' participants.\n    # The remaining n - count participants will score < x.\n    # So, Vasya's worst rank is 'count'.\n    #\n    # Example: a = [1,1,1,1,1], b = [1,1,1,1,1], x = 2\n    # a.sort() -> [1,1,1,1,1]\n    # b.sort() -> [1,1,1,1,1]\n    # l=0, r=4, count=0\n    # Iter 1: a[0]+b[4] = 1+1 = 2 >= x. count=1, l=1, r=3\n    # Iter 2: a[1]+b[3] = 1+1 = 2 >= x. count=2, l=2, r=2\n    # Iter 3: a[2]+b[2] = 1+1 = 2 >= x. count=3, l=3, r=1\n    # Iter 4: a[3]+b[1] = 1+1 = 2 >= x. count=4, l=4, r=0\n    # Iter 5: a[4]+b[0] = 1+1 = 2 >= x. count=5, l=5, r=-1\n    # Loop ends. count = 5. Worst rank = 5. Correct for example 1.\n    #\n    # Example 2: n=6, x=7\n    # a = [4, 3, 5, 6, 4, 4] -> sorted: [3, 4, 4, 4, 5, 6]\n    # b = [8, 6, 0, 4, 3, 4] -> sorted: [0, 3, 4, 4, 6, 8]\n    #\n    # l=0, r=5, count=0\n    # Iter 1: a[0]+b[5] = 3+8 = 11 >= 7. count=1, l=1, r=4 (pair: (3,8))\n    # Iter 2: a[1]+b[4] = 4+6 = 10 >= 7. count=2, l=2, r=3 (pair: (4,6))\n    # Iter 3: a[2]+b[3] = 4+4 = 8 >= 7. count=3, l=3, r=2 (pair: (4,4))\n    # Iter 4: a[3]+b[2] = 4+4 = 8 >= 7. count=4, l=4, r=1 (pair: (4,4))\n    # Iter 5: a[4]+b[1] = 5+3 = 8 >= 7. count=5, l=5, r=0 (pair: (5,3))\n    # Iter 6: a[5]+b[0] = 6+0 = 6 < 7. l=6.\n    # Loop ends. count = 5. Worst rank = 5. Correct for example 2.\n\n    worst_rank = 0\n    l = 0\n    r = n - 1\n    while l < n and r >= 0:\n        if a[l] + b[r] >= x:\n            worst_rank += 1\n            l += 1\n            r -= 1\n        else:\n            # a[l] is too small to make x even with largest available b[r].\n            # It cannot be paired with any other b_k (since b_k <= b[r]).\n            # So, a[l] cannot form a valid pair >= x. We discard it.\n            l += 1\n\n    print(best_rank, worst_rank)\n\nsolve()\n```",
    "ground_truth": "N/A",
    "extracted_answer": "def solve():\n    n, x = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n\n    a.sort()\n    b.sort()\n\n    # Calculate best possible rank\n    # Vasya wants to maximize his score and be better than others.\n    # To maximize his score, he should take the highest possible score from 'a' and 'b' that sum up to at least x.\n    # The problem statement guarantees that such a pair exists.\n    # To find the best rank, we need to count how many other participants *could* score strictly higher than Vasya.\n    # If Vasya scores S_vasya, and another participant scores S_other,\n    # Vasya's rank is 1 + (number of participants with S_other > S_vasya)\n    #\n    # However, the problem statement says \"the first place has the participant who has got the most points\".\n    # \"If two or more participants have got the same number of points, it's up to the jury to assign places to them according to their choice.\"\n    # This means for the best rank, Vasya can always be assigned 1st place among those with the maximum score.\n    # So, we want to maximize Vasya's score.\n    # Vasya can pick any a_i and b_j such that a_i + b_j >= x.\n    # The maximum possible score Vasya can achieve is a[n-1] + b[n-1].\n    # Let S_max_vasya = a[n-1] + b[n-1].\n    #\n    # To find the best rank:\n    # Vasya wants to achieve the highest possible score.\n    # He can pick a_i and b_j such that a_i + b_j >= x.\n    # The maximum possible score he can get is a[n-1] + b[n-1].\n    # Let this be S_V_max = a[n-1] + b[n-1].\n    #\n    # We need to count how many *other* participants can achieve a score strictly greater than S_V_max.\n    # This is impossible, as S_V_max is the absolute maximum possible sum from any pair.\n    # So, the number of people with strictly greater score is 0.\n    #\n    # What if others can achieve the same score as Vasya?\n    # For best rank, if Vasya is tied for the highest score, he can be placed 1st.\n    #\n    # So, the best rank is always 1.\n    # This is because Vasya can choose the largest a_i and largest b_j.\n    # This (a[n-1], b[n-1]) pair will give him the maximum possible total score among all participants.\n    # Since he has the highest possible score, he can be assigned 1st place.\n    best_rank = 1\n\n    # Calculate worst possible rank\n    # Vasya wants to minimize his score (but still >= x) and have as many people as possible score higher or equal.\n    # We need to find a pairing of (a, b) for all participants (including Vasya) such that:\n    # 1. Vasya's score (a_vasya + b_vasya) is minimized, but >= x.\n    # 2. As many other participants as possible get a score >= Vasya's score.\n    #\n    # Let's consider a fixed score S_vasya that Vasya could achieve (S_vasya >= x).\n    # To maximize Vasya's rank (make it worse), we want to count how many other participants can get a score\n    # greater than or equal to S_vasya.\n    #\n    # We need to find a pairing for all n participants.\n    # This is a maximum bipartite matching problem, but simpler.\n    # We want to find a pairing (a_i, b_j) for each participant such that the number of pairs (a_k, b_l)\n    # with a_k + b_l >= S_threshold is maximized.\n    #\n    # Let's fix Vasya's score to be some a_i + b_j >= x.\n    # To maximize his rank, we want to find a pairing for the remaining n-1 participants\n    # such that as many as possible get a score >= Vasya's chosen score.\n    #\n    # A greedy approach for worst rank:\n    # Sort 'a' in ascending order.\n    # Sort 'b' in ascending order.\n    #\n    # We want to count how many participants can score >= Vasya's score.\n    # Vasya's actual score is not fixed. It's one (a_i, b_j) pair.\n    #\n    # Consider a fixed participant 'p' (not Vasya).\n    # What's the minimum score 'p' can get, such that Vasya gets a score >= x?\n    #\n    # Let's try to find a pairing for all participants that maximizes the number of people\n    # with a high score.\n    #\n    # We want to find a permutation of 'b' (say, b') such that for each i, a[i] is paired with b'[i].\n    # And Vasya is one of these (a[i], b'[i]) pairs.\n    #\n    # For the worst rank, we want to count how many pairs (a_i, b_j) can be formed such that their sum\n    # is greater than or equal to some threshold S_vasya.\n    #\n    # The key insight for worst rank is to realize that Vasya's specific (a_i, b_j) pair is not known.\n    # We need to find the maximum number of participants (including Vasya) who can achieve a score >= S for some S.\n    #\n    # Let's sort 'a' and 'b'.\n    # We want to pair a_i with b_j such that a_i + b_j >= x.\n    #\n    # The problem asks for the maximum possible value of (1 + count of people with score > Vasya's score)\n    # or (1 + count of people with score >= Vasya's score) if jury puts Vasya last among ties.\n    # The latter is what \"worst place\" implies.\n    #\n    # Consider the problem of counting how many pairs (a_i, b_j) can be formed such that a_i + b_j >= K.\n    # This can be done by sorting 'a' and 'b'.\n    # Iterate through sorted 'a'. For each a_i, find the smallest b_j such that a_i + b_j >= K.\n    # All b_k >= b_j will also satisfy this.\n    #\n    # For worst rank, we need to find a permutation of 'b' (say b_perm) such that\n    # for each i, the participant gets score a[i] + b_perm[i].\n    # One of these (a[i], b_perm[i]) pairs is Vasya's.\n    # We want to maximize the number of people who score >= Vasya's score.\n    #\n    # This is equivalent to finding the maximum k such that there exists a pairing of k participants\n    # (a_i, b_j) where a_i + b_j >= x.\n    #\n    # Let's use a two-pointer approach to count the maximum number of pairs (a_i, b_j) such that a_i + b_j >= x.\n    # Sort 'a' and 'b' (they are already sorted).\n    # Initialize count = 0.\n    # Pointer 'i' for 'a' starts at 0 (smallest a_i).\n    # Pointer 'j' for 'b' starts at n-1 (largest b_j).\n    #\n    # While i < n and j >= 0:\n    #   If a[i] + b[j] >= x:\n    #     We can form a valid pair. We want to maximize such pairs.\n    #     To do this, we pair the smallest remaining 'a' with the largest remaining 'b'.\n    #     This leaves smaller 'b's for larger 'a's, or vice versa, maximizing chances for other pairs.\n    #     So, we increment count, move 'i' forward, and move 'j' backward.\n    #   Else (a[i] + b[j] < x):\n    #     The current a[i] is too small to pair with b[j] to reach 'x'.\n    #     Since 'b' is sorted, b[j] is the largest available. No other b_k < b[j] will work with a[i].\n    #     So, a[i] cannot form a pair >= x with any remaining b_k.\n    #     We must discard a[i] and try with the next a[i+1].\n    #     (Wait, this logic is flawed. We are trying to maximize the number of pairs.\n    #     If a[i] + b[j] < x, it means a[i] is too small for b[j].\n    #     But maybe a[i] can be paired with a larger b_k if we were to pick one, but we are using largest b_j.\n    #     This means a[i] cannot be paired with *any* b_k to reach x if b_k <= b[j].\n    #     So we must increment i.\n    #     The standard two-pointer for counting pairs (a_i, b_j) with sum >= X is:\n    #     Sort a and b.\n    #     Left pointer 'l' for 'a' at 0. Right pointer 'r' for 'b' at n-1.\n    #     Count = 0.\n    #     While l < n and r >= 0:\n    #       If a[l] + b[r] >= x:\n    #         This pair works. We can use it. We increment count.\n    #         We must use a[l] and b[r]. So l++ and r--.\n    #       Else (a[l] + b[r] < x):\n    #         a[l] is too small to make x even with the largest available b[r].\n    #         So a[l] cannot be paired with any b_k to make x.\n    #         We must discard a[l]. So l++.\n    # This counts the maximum number of pairs (a_i, b_j) such that a_i + b_j >= x.\n    # This maximum number of pairs is exactly the worst rank.\n    # Why? Because we can arrange the pairings such that these 'count' participants all score >= x.\n    # Vasya is one of them. The jury can place Vasya last among these 'count' participants.\n    # The remaining n - count participants will score < x.\n    # So, Vasya's worst rank is 'count'.\n    #\n    # Example: a = [1,1,1,1,1], b = [1,1,1,1,1], x = 2\n    # a.sort() -> [1,1,1,1,1]\n    # b.sort() -> [1,1,1,1,1]\n    # l=0, r=4, count=0\n    # Iter 1: a[0]+b[4] = 1+1 = 2 >= x. count=1, l=1, r=3\n    # Iter 2: a[1]+b[3] = 1+1 = 2 >= x. count=2, l=2, r=2\n    # Iter 3: a[2]+b[2] = 1+1 = 2 >= x. count=3, l=3, r=1\n    # Iter 4: a[3]+b[1] = 1+1 = 2 >= x. count=4, l=4, r=0\n    # Iter 5: a[4]+b[0] = 1+1 = 2 >= x. count=5, l=5, r=-1\n    # Loop ends. count = 5. Worst rank = 5. Correct for example 1.\n    #\n    # Example 2: n=6, x=7\n    # a = [4, 3, 5, 6, 4, 4] -> sorted: [3, 4, 4, 4, 5, 6]\n    # b = [8, 6, 0, 4, 3, 4] -> sorted: [0, 3, 4, 4, 6, 8]\n    #\n    # l=0, r=5, count=0\n    # Iter 1: a[0]+b[5] = 3+8 = 11 >= 7. count=1, l=1, r=4 (pair: (3,8))\n    # Iter 2: a[1]+b[4] = 4+6 = 10 >= 7. count=2, l=2, r=3 (pair: (4,6))\n    # Iter 3: a[2]+b[3] = 4+4 = 8 >= 7. count=3, l=3, r=2 (pair: (4,4))\n    # Iter 4: a[3]+b[2] = 4+4 = 8 >= 7. count=4, l=4, r=1 (pair: (4,4))\n    # Iter 5: a[4]+b[1] = 5+3 = 8 >= 7. count=5, l=5, r=0 (pair: (5,3))\n    # Iter 6: a[5]+b[0] = 6+0 = 6 < 7. l=6.\n    # Loop ends. count = 5. Worst rank = 5. Correct for example 2.\n\n    worst_rank = 0\n    l = 0\n    r = n - 1\n    while l < n and r >= 0:\n        if a[l] + b[r] >= x:\n            worst_rank += 1\n            l += 1\n            r -= 1\n        else:\n            # a[l] is too small to make x even with largest available b[r].\n            # It cannot be paired with any other b_k (since b_k <= b[r]).\n            # So, a[l] cannot form a valid pair >= x. We discard it.\n            l += 1\n\n    print(best_rank, worst_rank)\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 872,
        "completion_token_count": 3411,
        "thoughts_token_count": 0
    }
}