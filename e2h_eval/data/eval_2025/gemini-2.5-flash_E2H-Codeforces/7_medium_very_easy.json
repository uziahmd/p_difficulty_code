{
    "start": 1758015866.8635798,
    "end": 1758015940.7165494,
    "start-formatted": "2025-09-16 18:44 KST",
    "end-formatted": "2025-09-16 18:45 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "**Alright, here's my breakdown of this \"Rudolf and Snowflakes\" problem.** I'm tasked with writing a Python script to determine if a given number `n` can be represented as the sum of a geometric series.  Specifically, `n = 1 + k + k^2 + ... + k^m`, where `k > 1` and `m >= 2`.\n\nFirst, I need to understand the underlying mathematical structure.  The problem boils down to finding appropriate values of `k` and `m`.  I know that for `m=2`, I can solve a quadratic equation to find `k`.  This is a special case. I'll need to check if `4n - 3` is a perfect square. If it is, then I can compute `k` and verify it's greater than 1.\n\nFor cases where `m >= 3`, things get trickier.  I've got a geometric series formula to work with: `n = (k^(m+1) - 1) / (k - 1)`. Since I'm given an upper bound of `10^18` for `n`, I realize I can't naively iterate through all values of `k` and `m`. That would be computationally prohibitive.  So, I need to be smart about it.\n\nI'll start by checking if there's a practical upper bound for the value of `m`. I know that if `k=2`, I can make the largest `m` that meets the condition. So, I will set `m` by computing how large `2^m` can be while still remaining smaller than n. I can iteratively find it.  And from this I am going to guess what the upperbound of `m` would be. I will iterate `m` from 3 up to that value.\n\nFor each `m`, I can use binary search to try to identify a feasible `k`. I understand that `k` has to be smaller than the `n^(1/m)`, but I need to do this carefully, managing overflows as the sums and powers can grow very large very quickly. So, I will make sure the range of `k` that I will binary search is from 2 up to this upperbound. And in the binary search, I'll calculate the sum, carefully, checking for overflow before any multiplication. If I find a `k` such that the sum is equal to `n`, then I can say \"YES\". If I never find such `k` after searching the entire range of values, then the answer is \"NO\".\n\nThe key will be the overflow handling during the sum calculation. This should be a very efficient and accurate way to determine if there exists a k and m to satisfy the input n. The quadratic equation will work as a test case for a value of m equal to 2.\n",
    "response": "A snowflake is defined as an undirected graph with `n` vertices. The construction rules imply that the number of vertices `n` must be of the form `1 + k + k^2 + ... + k^m` for some integer `k > 1` and `m >= 2`.\nThis is a geometric series sum: `n = (k^(m+1) - 1) / (k - 1)`.\n\nWe need to check if a given `n` (up to `10^18`) can be represented in this form.\n\nLet's analyze the possible values of `m` and `k`:\n\n1.  **Case `m = 2`:**\n    The number of vertices is `n = 1 + k + k^2`.\n    This can be rewritten as a quadratic equation in `k`: `k^2 + k + (1 - n) = 0`.\n    Using the quadratic formula, `k = (-1 ± sqrt(1 - 4(1 - n))) / 2 = (-1 ± sqrt(4n - 3)) / 2`.\n    For `k` to be a valid integer greater than 1:\n    *   `4n - 3` must be a perfect square. Let `4n - 3 = x^2` for some integer `x`.\n    *   Since `k > 1`, we must take the positive root: `k = (-1 + x) / 2`.\n    *   For `k` to be an integer, `x` must be odd (so `x-1` is even). Note that `4n-3` is always odd, so `x^2` must be odd, which implies `x` must be odd. This condition is automatically satisfied.\n    *   For `k > 1`, we need `(-1 + x) / 2 > 1`, which means `-1 + x > 2`, or `x > 3`.\n    So, for `m=2`, we check if `4n - 3` is a perfect square `x^2` where `x > 3`.\n\n2.  **Case `m >= 3`:**\n    For a fixed `m`, `n = 1 + k + ... + k^m`.\n    The sum `S_m(k) = 1 + k + ... + k^m` is monotonically increasing with `k`. This allows us to use binary search for `k`.\n    What are the bounds for `m` and `k`?\n    *   **Maximum `m`:** If `k = 2`, then `n = 2^(m+1) - 1`. Since `n <= 10^18`, `2^(m+1) - 1 <= 10^18`, so `2^(m+1) <= 10^18 + 1`. Taking `log2` on both sides, `m+1 <= log2(10^18 + 1) approx 59.79`. Thus, `m+1` can be at most 59, meaning `m` can be at most 58. So we only need to iterate `m` from 3 up to around 58-60.\n    *   **Maximum `k`:** For a fixed `m`, `n = 1 + k + ... + k^m > k^m`. So `k < n^(1/m)`.\n        For `m=3`, `k < (10^18)^(1/3) = 10^6`.\n        For `m=58`, `k < (10^18)^(1/58) approx 2.0`.\n        The maximum `k` we need to search for is `10^6 + 2` (a small buffer for floating point precision).\n\n**Algorithm:**\n\n1.  **Function `solve()`:**\n    *   Read `n`.\n    *   **Check `m=2`:**\n        *   Calculate `val = 4 * n - 3`.\n        *   Calculate `x = int(val**0.5)`.\n        *   If `x * x == val` and `x > 3`: print \"YES\" and return.\n    *   **Check `m >= 3`:**\n        *   Iterate `m` from 3 up to 60 (a safe upper bound for `m`).\n        *   For each `m`, perform a binary search for `k` in the range `[2, int(n**(1/m)) + 2]`. The upper bound `int(n**(1/m)) + 2` is a safe estimate for `k`.\n            *   Let `low = 2`, `high = min(2 * 10**9, int(n**(1/m)) + 2)`. (The `min` with `2*10^9` is a rough practical upper bound for `k` to prevent `high` from being excessively large for small `m` if `n**(1/m)` is imprecise, though `int(n**(1/m))+2` should be fine. `k` cannot exceed `2*10^9` if `m=2` and `n=10^18`, because `(2*10^9)^2 = 4*10^18` which already exceeds `n`.)\n            *   Inside the binary search loop:\n                *   `mid = (low + high) // 2`.\n                *   If `mid < 2`, set `low = 2` and continue (ensure `k > 1`).\n                *   Calculate `current_sum = 1 + mid + mid^2 + ... + mid^m`.\n                    *   This sum needs to be calculated carefully to prevent overflow. We can check `term * mid` against `n` before multiplication. If `term * mid` would exceed `n`, then `current_sum` will definitely exceed `n`.\n                    *   A helper function `calculate_sum(k_val, m_val, n_target)` can do this:\n                        ```python\n                        def calculate_sum(k_val, m_val, n_target):\n                            current_sum = 0\n                            term = 1\n                            for _ in range(m_val + 1):\n                                current_sum += term\n                                if current_sum > n_target:\n                                    return n_target + 1 # signal too large\n                                if _ < m_val: # Avoid multiplying on last iteration\n                                    if k_val > n_target // term: # check for overflow before term * k_val\n                                        return n_target + 1 # signal too large\n                                    term *= k_val\n                            return current_sum\n                        ```\n                *   Compare `current_sum` with `n`:\n                    *   If `current_sum == n`: print \"YES\" and return.\n                    *   If `current_sum < n`: `low = mid + 1`.\n                    *   If `current_sum > n`: `high = mid - 1`.\n    *   If no `k, m` pair is found after all checks: print \"NO\".\n\nThe maximum value of `k` for `m=3` is `10^6`. The maximum `m` is around 60. The binary search takes `log(10^6)` steps, which is about 20 steps. So, the total operations for `m >= 3` is roughly `60 * 20 * (m operations for sum) = 60 * 20 * 60 = 72000`, which is very efficient for `10^4` test cases.\n\n```python\nimport math\n\ndef calculate_sum(k_val, m_val, n_target):\n    current_sum = 0\n    term = 1\n    for _ in range(m_val + 1):\n        current_sum += term\n        if current_sum > n_target: # Sum already exceeded n_target\n            return n_target + 1\n        \n        if _ < m_val: # If not the last term\n            # Check for overflow before multiplying term * k_val\n            # If term > n_target // k_val, then term * k_val would exceed n_target\n            # This is a safe check for k_val * term potentially exceeding n_target\n            # before it's even added to current_sum.\n            # Since current_sum is already checked against n_target,\n            # this check specifically targets the size of the next 'term'\n            # relative to n_target.\n            if k_val > 0 and term > n_target // k_val:\n                return n_target + 1\n            term *= k_val\n    return current_sum\n\ndef solve():\n    n = int(input())\n\n    # Case m = 2: n = 1 + k + k^2\n    # k^2 + k + (1 - n) = 0\n    # Discriminant D = 1 - 4(1 - n) = 4n - 3\n    # k = (-1 + sqrt(D)) / 2\n    val = 4 * n - 3\n    if val >= 0: # Ensure D is non-negative\n        x = int(math.isqrt(val)) # Use math.isqrt for integer square root\n        if x * x == val: # Check if val is a perfect square\n            # For k to be an integer, x must be odd (which is true if 4n-3 is a perfect square)\n            # For k > 1, we need (-1 + x) / 2 > 1 => -1 + x > 2 => x > 3\n            if x > 3:\n                print(\"YES\")\n                return\n\n    # Case m >= 3: n = 1 + k + k^2 + ... + k^m\n    # Iterate m from 3 up to a reasonable limit (~60 for n=10^18, k=2)\n    # The maximum m for k=2 and n=10^18 is when 2^(m+1)-1 = 10^18, so m+1 approx 59.79, m approx 58.\n    # We can iterate m up to 60 for safety.\n    for m in range(3, 61):\n        # Binary search for k\n        low = 2\n        # Upper bound for k: k^m < n => k < n^(1/m)\n        # Add a small buffer for precision and to cover edge cases.\n        # min(2 * 10**9, ...) is a practical upper limit for k if m=2 (not this loop),\n        # but for m >= 3, n**(1/m) will be much smaller.\n        # For m=3, k approx 10^6. For m=60, k approx 2.\n        high = int(n**(1/m)) + 2 # Safe upper bound for k\n\n        # Ensure high is not too small (e.g., if n is very small and n**(1/m) is < 2)\n        high = max(high, 2) \n        \n        while low <= high:\n            k = (low + high) // 2\n            \n            if k < 2: # k must be > 1\n                low = 2\n                continue\n\n            current_sum = calculate_sum(k, m, n)\n\n            if current_sum == n:\n                print(\"YES\")\n                return\n            elif current_sum < n:\n                low = k + 1\n            else: # current_sum > n (or overflowed)\n                high = k - 1\n    \n    print(\"NO\")\n\n\nnum_test_cases = int(input())\nfor _ in range(num_test_cases):\n    solve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef calculate_sum(k_val, m_val, n_target):\n    current_sum = 0\n    term = 1\n    for _ in range(m_val + 1):\n        current_sum += term\n        if current_sum > n_target: # Sum already exceeded n_target\n            return n_target + 1\n        \n        if _ < m_val: # If not the last term\n            # Check for overflow before multiplying term * k_val\n            # If term > n_target // k_val, then term * k_val would exceed n_target\n            # This is a safe check for k_val * term potentially exceeding n_target\n            # before it's even added to current_sum.\n            # Since current_sum is already checked against n_target,\n            # this check specifically targets the size of the next 'term'\n            # relative to n_target.\n            if k_val > 0 and term > n_target // k_val:\n                return n_target + 1\n            term *= k_val\n    return current_sum\n\ndef solve():\n    n = int(input())\n\n    # Case m = 2: n = 1 + k + k^2\n    # k^2 + k + (1 - n) = 0\n    # Discriminant D = 1 - 4(1 - n) = 4n - 3\n    # k = (-1 + sqrt(D)) / 2\n    val = 4 * n - 3\n    if val >= 0: # Ensure D is non-negative\n        x = int(math.isqrt(val)) # Use math.isqrt for integer square root\n        if x * x == val: # Check if val is a perfect square\n            # For k to be an integer, x must be odd (which is true if 4n-3 is a perfect square)\n            # For k > 1, we need (-1 + x) / 2 > 1 => -1 + x > 2 => x > 3\n            if x > 3:\n                print(\"YES\")\n                return\n\n    # Case m >= 3: n = 1 + k + k^2 + ... + k^m\n    # Iterate m from 3 up to a reasonable limit (~60 for n=10^18, k=2)\n    # The maximum m for k=2 and n=10^18 is when 2^(m+1)-1 = 10^18, so m+1 approx 59.79, m approx 58.\n    # We can iterate m up to 60 for safety.\n    for m in range(3, 61):\n        # Binary search for k\n        low = 2\n        # Upper bound for k: k^m < n => k < n^(1/m)\n        # Add a small buffer for precision and to cover edge cases.\n        # min(2 * 10**9, ...) is a practical upper limit for k if m=2 (not this loop),\n        # but for m >= 3, n**(1/m) will be much smaller.\n        # For m=3, k approx 10^6. For m=60, k approx 2.\n        high = int(n**(1/m)) + 2 # Safe upper bound for k\n\n        # Ensure high is not too small (e.g., if n is very small and n**(1/m) is < 2)\n        high = max(high, 2) \n        \n        while low <= high:\n            k = (low + high) // 2\n            \n            if k < 2: # k must be > 1\n                low = 2\n                continue\n\n            current_sum = calculate_sum(k, m, n)\n\n            if current_sum == n:\n                print(\"YES\")\n                return\n            elif current_sum < n:\n                low = k + 1\n            else: # current_sum > n (or overflowed)\n                high = k - 1\n    \n    print(\"NO\")\n\n\nnum_test_cases = int(input())\nfor _ in range(num_test_cases):\n    solve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 569,
        "completion_token_count": 2707,
        "thoughts_token_count": 5400
    }
}