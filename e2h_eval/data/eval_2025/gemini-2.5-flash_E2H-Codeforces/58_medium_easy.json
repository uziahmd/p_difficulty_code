{
    "start": 1758294833.729521,
    "end": 1758294918.1547763,
    "start-formatted": "2025-09-20 00:13 KST",
    "end-formatted": "2025-09-20 00:15 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "**The Quest for the Minimal Odd Cycle**\n\nAlright, let's break this down. The core problem is finding the fewest edges, *t*, needed to transform a given graph into one containing an odd-length cycle, and then count how many distinct ways, *w*, we can achieve this.  The graph is built with n vertices and m edges.\n\nFirst, I need to check for a crucial condition: **does the graph already have an odd cycle?**  If so, my work is done: *t* is 0, and *w* is 1 (the existing cycle is the only way). I'll use a Breadth-First Search (BFS) or Depth-First Search (DFS) with 2-coloring to detect this. If a conflict arises during 2-coloring, I've got my odd cycle.\n\nIf the initial graph is bipartite (no odd cycles), things get more interesting.  The key insight here is that adding a single edge, *t* = 1, can create an odd cycle only if it connects two vertices within the *same* connected component that have the *same* color in the 2-coloring. I'll need to calculate, for each connected component, the number of ways to do this. This is the sum, for each component, of *A* * (*A* - 1)/2 + *B* * (*B* - 1)/2, where *A* and *B* are the sizes of the two color sets within the component. If this calculation yields a value greater than 0, *t* is 1, and that value is *w*.\n\nIf no single edge can create an odd cycle, it implies the graph's connected components are just isolated vertices or single edges. We must add at least 2 more edges to generate an odd cycle. It's time to refine strategy.\n\nIf *t* = 1 fails, it means that for every connected component, either there is only one vertex in the same partition or both partition sets have only one vertex.  So all connected components must be either isolated vertices or single edges. The next test is to try *t* = 2, because we can add two edges to create an odd cycle. A new odd cycle with two edges requires adding two edges that create new connection paths that have odd lengths.\n\nIf *t* = 2 can not work, the final stage is to try *t* = 3. This should always be a solution to the problem, as it should be always possible to construct an odd cycle by adding 3 edges when *t* = 1 and *t* = 2 does not yield a cycle. We also have to calculate how many possible ways to achieve that odd cycle. This count will represent *w*. The final goal is to determine the optimal solution, in terms of *t* (minimum edges) and *w* (number of ways), where *t* can vary from 0 to 3 depending on the structure of the input graph.\n",
    "response": "The problem asks us to find the minimum number of edges `t` to add to a given undirected graph to form a simple cycle of odd length, and `w` the number of ways to do so. The graph is initially without loops or parallel edges.\n\nA graph contains an odd-length cycle if and only if it is not bipartite. This is the key property we will use.\n\nWe can categorize the solution based on the value of `t`:\n\n**Step 1: Check if the graph already contains an odd-length cycle (t = 0).**\nWe can use a 2-coloring algorithm (BFS or DFS) to check if the graph is bipartite.\n1.  Initialize `color[v] = -1` for all vertices `v`.\n2.  For each unvisited vertex `s`:\n    a.  Start a traversal (e.g., BFS) from `s`. Assign `color[s] = 0`.\n    b.  Maintain a queue. Add `s` to the queue.\n    c.  While the queue is not empty:\n        i.  Dequeue `u`.\n        ii. For each neighbor `v` of `u`:\n            -   If `v` is unvisited (`color[v] == -1`): Assign `color[v] = 1 - color[u]`, enqueue `v`.\n            -   If `v` is visited and `color[v] == color[u]`: An odd-length cycle is found. The graph is not bipartite. In this case, `t = 0` and `w = 1`. We can immediately print `0 1` and exit.\n            -   If `v` is visited and `color[v] != color[u]`: Continue.\n3.  If the traversal completes for all connected components without finding any conflicts, the graph is bipartite. Proceed to Step 2.\n\n**Step 2: If the graph is bipartite, try to form an odd cycle by adding t = 1 edge.**\nSince the graph is bipartite, each connected component can be 2-colored. Let's say we partition the vertices of each component `C_i` into two sets `A_i` and `B_i` based on their colors (e.g., color 0 and color 1). All edges in `C_i` connect a vertex in `A_i` to a vertex in `B_i`.\nAdding a single edge `(u, v)` creates an odd cycle if and only if `u` and `v` are in the same connected component and have the same color (i.e., both in `A_i` or both in `B_i` for some `i`).\nThe number of ways to choose two distinct vertices from `A_i` is `|A_i| * (|A_i| - 1) / 2`.\nThe number of ways to choose two distinct vertices from `B_i` is `|B_i| * (|B_i| - 1) / 2`.\nLet `w_1` be the total number of such pairs across all connected components.\n`w_1 = sum( (|A_i| * (|A_i| - 1) / 2) + (|B_i| * (|B_i| - 1) / 2) )` for all components `C_i`.\nIf `w_1 > 0`, then `t = 1` and `w = w_1`. Print `1 w_1` and exit.\n\n**Step 3: If t = 1 is not possible, try to form an odd cycle by adding t = 2 edges.**\nIf `w_1 = 0`, it means that for every connected component `C_i`, either `|A_i| < 2` or `|B_i| < 2`. This implies that every connected component is either an isolated vertex (`K_1`) or an isolated edge (`K_2`).\nLet `num_isolated_vertices` be the count of `K_1` components.\nLet `num_isolated_edges` be the count of `K_2` components.\n\nTo form an odd cycle with two added edges, the simplest way is to pick an isolated vertex `u` (from a `K_1` component) and an isolated edge `(v, w)` (from a `K_2` component). We can then add edges `(u, v)` and `(u, w)`. This forms a triangle `u-v-w-u`, which is an odd cycle of length 3.\nThe number of ways to do this is `num_isolated_vertices * num_isolated_edges`.\nIf `num_isolated_vertices > 0` and `num_isolated_edges > 0`, then `t = 2` and `w = num_isolated_vertices * num_isolated_edges`. Print `2 w` and exit.\n\n**Step 4: If t = 2 is not possible, t must be 3.**\nIf `t=1` and `t=2` are not possible, it means:\n-   All components are `K_1` or `K_2`.\n-   Either `num_isolated_vertices = 0` or `num_isolated_edges = 0`.\n\nCase 4.1: `num_isolated_vertices >= 3` and `num_isolated_edges = 0`.\nAll components are isolated vertices. We need to pick three distinct isolated vertices `u, v, w` and add edges `(u, v), (v, w), (w, u)` to form a triangle.\nThe number of ways is `C(num_isolated_vertices, 3) = num_isolated_vertices * (num_isolated_vertices - 1) * (num_isolated_vertices - 2) / 6`.\nThis is `t = 3`.\n\nCase 4.2: `num_isolated_vertices = 0` and `num_isolated_edges >= 3`.\nAll components are isolated edges. We need to pick three distinct isolated edges `(u_1, v_1), (u_2, v_2), (u_3, v_3)`. For each edge, we can choose one of its endpoints. For example, we can pick `u_1, u_2, u_3` and add edges `(u_1, u_2), (u_2, u_3), (u_3, u_1)` to form a triangle.\nThere are `C(num_isolated_edges, 3)` ways to choose three edges. For each chosen edge `(u_i, v_i)`, there are 2 choices for which endpoint to use (e.g., `u_i` or `v_i`). So, `2^3 = 8` ways to pick the endpoints for a specific set of three edges.\nThe total number of ways is `C(num_isolated_edges, 3) * 8`.\nThis is `t = 3`.\n\nCase 4.3: `num_isolated_vertices >= 1` and `num_isolated_edges >= 2`.\nThis scenario is covered by `t=2` if `num_isolated_vertices > 0` and `num_isolated_edges > 0`. So this case is not reachable here.\n\nTherefore, if `t=1` and `t=2` are not possible, `t=3`. The number of ways `w` is calculated based on the available `K_1` and `K_2` components.\nIf `num_isolated_vertices >= 3`: `w += C(num_isolated_vertices, 3)`.\nIf `num_isolated_edges >= 3`: `w += C(num_isolated_edges, 3) * 8`.\nIf `num_isolated_vertices >= 1` and `num_isolated_edges >= 2`: `w += num_isolated_vertices * C(num_isolated_edges, 2) * 4`. (Pick 1 `K_1`, 2 `K_2`s. For each `K_2`, 2 choices of endpoint. Total `1 * C(N_e, 2) * 2 * 2`).\nIf `num_isolated_vertices >= 2` and `num_isolated_edges >= 1`: `w += C(num_isolated_vertices, 2) * num_isolated_edges * 2`. (Pick 2 `K_1`s, 1 `K_2`. For `K_2`, 2 choices of endpoint. Total `C(N_v, 2) * 1 * 2`).\n\nThis can be generalized. If `t=3`, we need to pick 3 vertices `x, y, z` that are not already connected, and add `(x,y), (y,z), (z,x)`.\nThe total number of vertices in `K_1` or `K_2` components is `n`.\nLet `N_v = num_isolated_vertices`.\nLet `N_e = num_isolated_edges`.\nThe number of ways to choose 3 vertices `x, y, z` such that they are not connected by existing edges is:\n`C(N_v, 3)` (all three are isolated vertices)\n`+ C(N_v, 2) * N_e * 2` (two isolated vertices, one endpoint from an isolated edge)\n`+ N_v * C(N_e, 2) * 4` (one isolated vertex, two endpoints from two isolated edges)\n`+ C(N_e, 3) * 8` (three endpoints from three isolated edges)\nSumming these up gives `w` for `t=3`.\n\n**Implementation details:**\n-   Use an adjacency list for the graph.\n-   Use `collections.deque` for BFS.\n-   Keep track of `visited` vertices to handle disconnected components.\n-   Store `color` for each vertex.\n-   Store `component_id` for each vertex to group vertices into components.\n-   During BFS, for each component, count `size_A` and `size_B`.\n\n**Example Walkthrough:**\nInput: `4 4`, edges `(1,2), (1,3), (4,2), (4,3)`\n1.  BFS for 2-coloring:\n    -   Start at 1, `color[1]=0`.\n    -   Neighbors of 1: 2, 3. `color[2]=1, color[3]=1`.\n    -   Neighbors of 2: 1, 4. `color[1]!=color[2]`. `color[4]=0`.\n    -   Neighbors of 3: 1, 4. `color[1]!=color[3]`. `color[4]==color[3]` is `0==1` which is false. `color[4]!=color[3]`.\n    -   Neighbors of 4: 2, 3. `color[2]!=color[4]`. `color[3]!=color[4]`.\n    All vertices colored without conflict: `color[1]=0, color[2]=1, color[3]=1, color[4]=0`.\n    This graph is bipartite. `t=0` is not possible.\n2.  Calculate `w_1` for `t=1`:\n    One component: `{1,2,3,4}`.\n    `A = {1, 4}` (`color=0`), `B = {2, 3}` (`color=1`).\n    `|A|=2, |B|=2`.\n    Ways from `A`: `2 * (2-1) / 2 = 1` (edge `(1,4)`).\n    Ways from `B`: `2 * (2-1) / 2 = 1` (edge `(2,3)`).\n    Total `w_1 = 1 + 1 = 2`.\n    Since `w_1 > 0`, `t = 1` and `w = 2`.\n    Output: `1 2`.\n\nInput: `3 3`, edges `(1,2), (2,3), (3,1)`\n1.  BFS for 2-coloring:\n    -   Start at 1, `color[1]=0`.\n    -   Neighbors of 1: 2, 3. `color[2]=1, color[3]=1`.\n    -   Neighbors of 2: 1, 3. `color[1]!=color[2]`. `color[3]==color[2]` is `1==1`. Conflict! Odd cycle `1-2-3-1` found.\n    Output: `0 1`.\n\nInput: `3 0`\n1.  BFS for 2-coloring:\n    -   Start at 1, `color[1]=0`. Component `{1}`. `A={1}, B={}`.\n    -   Start at 2, `color[2]=0`. Component `{2}`. `A={2}, B={}`.\n    -   Start at 3, `color[3]=0`. Component `{3}`. `A={3}, B={}`.\n    Graph is bipartite. `t=0` is not possible.\n2.  Calculate `w_1` for `t=1`:\n    Component 1: `|A|=1, |B|=0`. Ways = `1*(0)/2 + 0*( -1)/2 = 0`.\n    Component 2: `|A|=1, |B|=0`. Ways = `0`.\n    Component 3: `|A|=1, |B|=0`. Ways = `0`.\n    Total `w_1 = 0`. `t=1` is not possible.\n3.  Calculate for `t=2`:\n    `num_isolated_vertices = 3` (components are `{1}, {2}, {3}`).\n    `num_isolated_edges = 0`.\n    Since `num_isolated_edges = 0`, `num_isolated_vertices * num_isolated_edges = 0`. `t=2` is not possible.\n4.  `t=3`.\n    `num_isolated_vertices = 3`. `num_isolated_edges = 0`.\n    We use the `C(num_isolated_vertices, 3)` formula: `C(3,3) = 3*2*1 / 6 = 1`.\n    Output: `3 1`.\n\n```python\nimport sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n\n    color = [-1] * (n + 1)\n    visited = [False] * (n + 1)\n    \n    # Stores (size of color 0 partition, size of color 1 partition) for each component\n    bipartite_components_info = [] \n    \n    # Counts for t=2 and t=3 cases\n    num_isolated_vertices = 0\n    num_isolated_edges = 0\n\n    has_odd_cycle = False\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            q = deque()\n            q.append(i)\n            color[i] = 0\n            visited[i] = True\n            \n            current_component_size_0 = 0\n            current_component_size_1 = 0\n            \n            # Track if the current component is just an isolated vertex or an isolated edge\n            is_isolated_vertex = True\n            is_isolated_edge = False\n            \n            component_nodes = 0\n            component_edges = 0\n            \n            q_bfs_nodes = deque()\n            q_bfs_nodes.append(i)\n            bfs_visited_local = [False] * (n + 1) # Use a local visited for BFS to count edges\n            bfs_visited_local[i] = True\n\n            head = 0\n            bfs_q_list = [i] # Use list as queue for counting nodes/edges\n            \n            while head < len(bfs_q_list):\n                u = bfs_q_list[head]\n                head += 1\n                component_nodes += 1\n                \n                for v in adj[u]:\n                    component_edges += 1\n                    if not bfs_visited_local[v]:\n                        bfs_visited_local[v] = True\n                        bfs_q_list.append(v)\n            \n            component_edges //= 2 # Each edge counted twice\n\n            # If component_nodes is 1 and component_edges is 0, it's an isolated vertex\n            if component_nodes == 1 and component_edges == 0:\n                num_isolated_vertices += 1\n                \n            # If component_nodes is 2 and component_edges is 1, it's an isolated edge\n            elif component_nodes == 2 and component_edges == 1:\n                num_isolated_edges += 1\n            \n            # Now run BFS for 2-coloring\n            q_coloring = deque()\n            q_coloring.append(i)\n            \n            while q_coloring:\n                u = q_coloring.popleft()\n                \n                if color[u] == 0:\n                    current_component_size_0 += 1\n                else:\n                    current_component_size_1 += 1\n                \n                for v in adj[u]:\n                    if color[v] == -1: # Unvisited\n                        color[v] = 1 - color[u]\n                        visited[v] = True\n                        q_coloring.append(v)\n                    elif color[v] == color[u]: # Conflict: odd cycle found\n                        has_odd_cycle = True\n                        # No need to continue coloring this component or other components\n                        # The graph is not bipartite\n                        break\n                if has_odd_cycle:\n                    break\n            \n            if has_odd_cycle:\n                break # Exit outer loop if odd cycle found\n            \n            bipartite_components_info.append((current_component_size_0, current_component_size_1))\n\n    if has_odd_cycle:\n        print(\"0 1\")\n        return\n\n    # Case t=1: Add one edge within a component to connect two vertices of the same color\n    ways_t1 = 0\n    for s0, s1 in bipartite_components_info:\n        ways_t1 += s0 * (s0 - 1) // 2\n        ways_t1 += s1 * (s1 - 1) // 2\n    \n    if ways_t1 > 0:\n        print(f\"1 {ways_t1}\")\n        return\n\n    # Case t=2: Graph is bipartite, and no component has >=2 vertices of same color partition\n    # This means all components are K1 (isolated vertex) or K2 (isolated edge)\n    # To form an odd cycle with 2 edges: pick an isolated vertex (u) and an isolated edge (v-w).\n    # Add (u,v) and (u,w) to form a triangle u-v-w-u.\n    ways_t2 = num_isolated_vertices * num_isolated_edges\n    \n    if ways_t2 > 0:\n        print(f\"2 {ways_t2}\")\n        return\n\n    # Case t=3: If t=1 and t=2 are not possible, then t must be 3.\n    # This implies either num_isolated_vertices is 0 or num_isolated_edges is 0.\n    # We need to pick 3 vertices x,y,z such that no two are connected, and add (x,y), (y,z), (z,x).\n    # The total number of ways is the sum of ways to choose 3 such vertices from the K1 and K2 components.\n    \n    ways_t3 = 0\n    \n    # 1. Choose 3 isolated vertices: u, v, w\n    # (u,v), (v,w), (w,u)\n    if num_isolated_vertices >= 3:\n        ways_t3 += num_isolated_vertices * (num_isolated_vertices - 1) * (num_isolated_vertices - 2) // 6\n    \n    # 2. Choose 2 isolated vertices (u, v) and 1 endpoint from an isolated edge (x-y)\n    # Add (u,x), (v,x), (u,v)\n    if num_isolated_vertices >= 2 and num_isolated_edges >= 1:\n        ways_t3 += (num_isolated_vertices * (num_isolated_vertices - 1) // 2) * num_isolated_edges * 2 # *2 for choosing x or y from x-y\n    \n    # 3. Choose 1 isolated vertex (u) and 2 endpoints from two isolated edges (v1-w1, v2-w2)\n    # Add (u,v1), (v1,v2), (v2,u)\n    if num_isolated_vertices >= 1 and num_isolated_edges >= 2:\n        ways_t3 += num_isolated_vertices * (num_isolated_edges * (num_isolated_edges - 1) // 2) * 4 # *4 for choosing v1/w1 and v2/w2\n    \n    # 4. Choose 3 endpoints from three isolated edges (u1-v1, u2-v2, u3-v3)\n    # Add (u1,u2), (u2,u3), (u3,u1)\n    if num_isolated_edges >= 3:\n        ways_t3 += (num_isolated_edges * (num_isolated_edges - 1) * (num_isolated_edges - 2) // 6) * 8 # *8 for choosing u_i/v_i for each edge\n\n    print(f\"3 {ways_t3}\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n\n    color = [-1] * (n + 1)\n    visited = [False] * (n + 1)\n    \n    # Stores (size of color 0 partition, size of color 1 partition) for each component\n    bipartite_components_info = [] \n    \n    # Counts for t=2 and t=3 cases\n    num_isolated_vertices = 0\n    num_isolated_edges = 0\n\n    has_odd_cycle = False\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            q = deque()\n            q.append(i)\n            color[i] = 0\n            visited[i] = True\n            \n            current_component_size_0 = 0\n            current_component_size_1 = 0\n            \n            # Track if the current component is just an isolated vertex or an isolated edge\n            is_isolated_vertex = True\n            is_isolated_edge = False\n            \n            component_nodes = 0\n            component_edges = 0\n            \n            q_bfs_nodes = deque()\n            q_bfs_nodes.append(i)\n            bfs_visited_local = [False] * (n + 1) # Use a local visited for BFS to count edges\n            bfs_visited_local[i] = True\n\n            head = 0\n            bfs_q_list = [i] # Use list as queue for counting nodes/edges\n            \n            while head < len(bfs_q_list):\n                u = bfs_q_list[head]\n                head += 1\n                component_nodes += 1\n                \n                for v in adj[u]:\n                    component_edges += 1\n                    if not bfs_visited_local[v]:\n                        bfs_visited_local[v] = True\n                        bfs_q_list.append(v)\n            \n            component_edges //= 2 # Each edge counted twice\n\n            # If component_nodes is 1 and component_edges is 0, it's an isolated vertex\n            if component_nodes == 1 and component_edges == 0:\n                num_isolated_vertices += 1\n                \n            # If component_nodes is 2 and component_edges is 1, it's an isolated edge\n            elif component_nodes == 2 and component_edges == 1:\n                num_isolated_edges += 1\n            \n            # Now run BFS for 2-coloring\n            q_coloring = deque()\n            q_coloring.append(i)\n            \n            while q_coloring:\n                u = q_coloring.popleft()\n                \n                if color[u] == 0:\n                    current_component_size_0 += 1\n                else:\n                    current_component_size_1 += 1\n                \n                for v in adj[u]:\n                    if color[v] == -1: # Unvisited\n                        color[v] = 1 - color[u]\n                        visited[v] = True\n                        q_coloring.append(v)\n                    elif color[v] == color[u]: # Conflict: odd cycle found\n                        has_odd_cycle = True\n                        # No need to continue coloring this component or other components\n                        # The graph is not bipartite\n                        break\n                if has_odd_cycle:\n                    break\n            \n            if has_odd_cycle:\n                break # Exit outer loop if odd cycle found\n            \n            bipartite_components_info.append((current_component_size_0, current_component_size_1))\n\n    if has_odd_cycle:\n        print(\"0 1\")\n        return\n\n    # Case t=1: Add one edge within a component to connect two vertices of the same color\n    ways_t1 = 0\n    for s0, s1 in bipartite_components_info:\n        ways_t1 += s0 * (s0 - 1) // 2\n        ways_t1 += s1 * (s1 - 1) // 2\n    \n    if ways_t1 > 0:\n        print(f\"1 {ways_t1}\")\n        return\n\n    # Case t=2: Graph is bipartite, and no component has >=2 vertices of same color partition\n    # This means all components are K1 (isolated vertex) or K2 (isolated edge)\n    # To form an odd cycle with 2 edges: pick an isolated vertex (u) and an isolated edge (v-w).\n    # Add (u,v) and (u,w) to form a triangle u-v-w-u.\n    ways_t2 = num_isolated_vertices * num_isolated_edges\n    \n    if ways_t2 > 0:\n        print(f\"2 {ways_t2}\")\n        return\n\n    # Case t=3: If t=1 and t=2 are not possible, then t must be 3.\n    # This implies either num_isolated_vertices is 0 or num_isolated_edges is 0.\n    # We need to pick 3 vertices x,y,z such that no two are connected, and add (x,y), (y,z), (z,x).\n    # The total number of ways is the sum of ways to choose 3 such vertices from the K1 and K2 components.\n    \n    ways_t3 = 0\n    \n    # 1. Choose 3 isolated vertices: u, v, w\n    # (u,v), (v,w), (w,u)\n    if num_isolated_vertices >= 3:\n        ways_t3 += num_isolated_vertices * (num_isolated_vertices - 1) * (num_isolated_vertices - 2) // 6\n    \n    # 2. Choose 2 isolated vertices (u, v) and 1 endpoint from an isolated edge (x-y)\n    # Add (u,x), (v,x), (u,v)\n    if num_isolated_vertices >= 2 and num_isolated_edges >= 1:\n        ways_t3 += (num_isolated_vertices * (num_isolated_vertices - 1) // 2) * num_isolated_edges * 2 # *2 for choosing x or y from x-y\n    \n    # 3. Choose 1 isolated vertex (u) and 2 endpoints from two isolated edges (v1-w1, v2-w2)\n    # Add (u,v1), (v1,v2), (v2,u)\n    if num_isolated_vertices >= 1 and num_isolated_edges >= 2:\n        ways_t3 += num_isolated_vertices * (num_isolated_edges * (num_isolated_edges - 1) // 2) * 4 # *4 for choosing v1/w1 and v2/w2\n    \n    # 4. Choose 3 endpoints from three isolated edges (u1-v1, u2-v2, u3-v3)\n    # Add (u1,u2), (u2,u3), (u3,u1)\n    if num_isolated_edges >= 3:\n        ways_t3 += (num_isolated_edges * (num_isolated_edges - 1) * (num_isolated_edges - 2) // 6) * 8 # *8 for choosing u_i/v_i for each edge\n\n    print(f\"3 {ways_t3}\")\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 603,
        "completion_token_count": 5069,
        "thoughts_token_count": 7043
    }
}