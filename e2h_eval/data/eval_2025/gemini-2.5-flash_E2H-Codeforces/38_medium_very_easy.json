{
    "start": 1758294887.8346531,
    "end": 1758294952.8849971,
    "start-formatted": "2025-09-20 00:14 KST",
    "end-formatted": "2025-09-20 00:15 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "**Unveiling the Secrets of Reachable Graphs: My Journey Through a Competitive Programming Challenge**\n\nMy task is to decipher two elusive values: the minimum node count, `n`, required to fashion a `p`-reachable directed graph, and, among those minimal graphs, the maximum count of unidirectional pairs. Let's start breaking it down, shall we?\n\nFirstly, a unidirectional pair signifies two distinct nodes, `u` and `v`, where a path exists from `u` to `v` but not the reverse. A graph is `p`-reachable if exactly `p` ordered pairs, `(u, v)`, exist with `u < v` and where both nodes are mutually reachable. In simpler terms, these pairs are within the same strongly connected component (SCC).\n\nMy intuition leads me to focus on the sizes of these SCCs. Within a size-`k` SCC, there are `k * (k - 1) / 2` pairs of nodes where `u < v` and both are reachable from each other. My goal: to distribute `p` such pairs across the largest SCCs possible to minimize the overall node count. Since `k * (k - 1) / 2` grows rapidly with `k`, using the largest SCCs available for a given `p` is optimal.\n\nI then concoct a greedy strategy: iteratively find the largest `k` where `k * (k - 1) / 2` is less than or equal to the remaining `p`. Add `k` to the total nodes `n`, and subtract the `f(k)` pairs from the remaining `p`. I repeat this process until `p` reaches zero, ensuring that my algorithm is not caught in an infinite loop due to `p=0`.\n\nThus, I've solved the first part! Now, the grand finale: maximizing unidirectional pairs. I'm imagining the SCCs as blocks, trying to maximize the number of pairs between them.\n\nThe most efficient design involves a linear arrangement of SCCs. If there's a path `u -> v`, from an earlier SCC to a later one, `u != v` and there is no path `v -> u`. For `m` SCCs with sizes `k1, k2, ... km`, the maximum number of unidirectional pairs then can be formulated as `n^2 - (n + 2*p)`. This formula comes from realizing that we need to exclude the pairs which reside in the same SCC to get the count of unidirectional pairs.\n\nI am now confident in my strategy: I've cracked the code to building the smallest `p`-reachable graph and maximized its unidirectional charm.\n",
    "response": "The problem asks us to find two values for a given integer `p`:\n1. The minimum number of nodes `n` required to create a `p`-reachable directed graph.\n2. Among all such `p`-reachable directed graphs with the minimum number of nodes, the maximum number of unidirectional pairs of nodes.\n\nLet's define the terms:\n- A graph is `p`-reachable if it contains exactly `p` ordered pairs of nodes `(u, v)` such that `u < v` and `u` and `v` are reachable from each other.\n- An ordered pair `(u, v)` is unidirectional if `u \\neq v`, there exists a path from `u` to `v`, and there are no paths from `v` to `u`.\n\n**Part 1: Minimum number of nodes `n`**\n\nThe condition \"reachable from each other\" means `u` and `v` belong to the same strongly connected component (SCC).\nIf an SCC has `k` nodes, any two distinct nodes `u, v` within this SCC are reachable from each other. The number of ordered pairs `(u, v)` such that `u < v` and `u, v` are in this SCC is `k * (k - 1) / 2`. Let `f(k) = k * (k - 1) / 2`.\nIf a graph has multiple SCCs of sizes `k_1, k_2, ..., k_m`, the total number of `(u, v)` pairs satisfying the `p`-reachable condition is `sum(f(k_i))`. Nodes in different SCCs cannot be reachable from each other.\nWe need `sum(f(k_i)) = p` and we want to minimize `n = sum(k_i)`.\n\nThe function `f(k)` is increasing and convex for `k \\ge 1`. To minimize `sum(k_i)` for a fixed `sum(f(k_i))`, we should use as few SCCs as possible, and make them as large as possible. This suggests a greedy approach:\n1. Initialize `n = 0`.\n2. While `p > 0`:\n   a. Find the largest integer `k` such that `f(k) = k * (k - 1) / 2 \\le p`. This `k` can be found using the quadratic formula: `k^2 - k - 2p \\le 0`, so `k \\le (1 + \\sqrt{1 + 8p}) / 2`. Thus, `k = \\lfloor (1 + \\sqrt{1 + 8p}) / 2 \\rfloor`.\n   b. Add `k` to `n`.\n   c. Subtract `f(k)` from `p`.\n   d. If `p` becomes 0, stop. Note that if `p=0` initially, `k=1` is chosen, `f(1)=0`, `n=1`, `p` remains `0`. The loop condition `p > 0` handles this correctly, resulting in `n=0` for `p=0`. For `p>0`, `k` will be at least 2.\n\nExample: `p = 4`\n- `n = 0`. `p = 4`.\n- `k = \\lfloor (1 + \\sqrt{1 + 8 \\cdot 4}) / 2 \\rfloor = \\lfloor (1 + \\sqrt{33}) / 2 \\rfloor = \\lfloor (1 + 5.74...) / 2 \\rfloor = \\lfloor 3.37... \\rfloor = 3`.\n- `n = 0 + 3 = 3`.\n- `p = 4 - f(3) = 4 - (3 * 2 / 2) = 4 - 3 = 1`.\n- `k = \\lfloor (1 + \\sqrt{1 + 8 \\cdot 1}) / 2 \\rfloor = \\lfloor (1 + \\sqrt{9}) / 2 \\rfloor = \\lfloor (1 + 3) / 2 \\rfloor = \\lfloor 2 \\rfloor = 2`.\n- `n = 3 + 2 = 5`.\n- `p = 1 - f(2) = 1 - (2 * 1 / 2) = 1 - 1 = 0`.\n- `p = 0`, stop. Minimum nodes `n = 5`.\n\n**Part 2: Maximum number of unidirectional pairs**\n\nLet `n` be the minimum number of nodes found in Part 1. Let the SCCs have sizes `k_1, k_2, ..., k_m`.\nWe have `sum(k_i) = n` and `sum(k_i * (k_i - 1) / 2) = p`.\nThis second equation can be rewritten:\n`sum(k_i^2 - k_i) / 2 = p`\n`sum(k_i^2) - sum(k_i) = 2p`\n`sum(k_i^2) - n = 2p`\n`sum(k_i^2) = 2p + n`.\n\nTo maximize unidirectional pairs, we should arrange the SCCs in a linear chain in the condensation graph. For example, `SCC_1 -> SCC_2 -> ... -> SCC_m`. This means we add edges such that there is a path from any node in `SCC_i` to any node in `SCC_j` if `i < j`, but no path from `SCC_j` to `SCC_i`.\nIn such a configuration:\n- For any `u, v` within the same SCC, they are reachable from each other, so `(u, v)` is not unidirectional. There are `sum(k_i * (k_i - 1))` such ordered pairs.\n- For any `u \\in SCC_i` and `v \\in SCC_j` with `i < j`: there is a path `u -> v`, but no path `v -> u`. So `(u, v)` is a unidirectional pair.\n- For any `u \\in SCC_i` and `v \\in SCC_j` with `i > j`: there is a path `v -> u`, but no path `u -> v`. So `(u, v)` is NOT a unidirectional pair, but `(v, u)` IS a unidirectional pair.\n\nThe total number of distinct ordered pairs of nodes `(u, v)` with `u \\neq v` is `n * (n - 1)`.\nThe number of ordered pairs `(u, v)` such that `u` and `v` are in the same SCC is `sum(k_i * (k_i - 1)) = sum(k_i^2 - k_i) = sum(k_i^2) - n = (2p + n) - n = 2p`. These pairs are not unidirectional.\nThe remaining `n * (n - 1) - 2p` pairs are `(u, v)` where `u` and `v` are in different SCCs.\nFor each such pair `{u, v}`, exactly one of `(u, v)` or `(v, u)` will be unidirectional in a chain-like condensation graph.\nTherefore, the total number of unidirectional pairs is `n * (n - 1) - 2p`.\n\nLet's check the examples:\n- `p = 3`:\n  - Min `n = 3`. (One SCC of size 3)\n  - Unidirectional pairs = `3 * (3 - 1) - 2 * 3 = 3 * 2 - 6 = 6 - 6 = 0`.\n  - Output: `3 0`. Matches.\n\n- `p = 4`:\n  - Min `n = 5`. (SCCs of sizes 3 and 2)\n  - Unidirectional pairs = `5 * (5 - 1) - 2 * 4 = 5 * 4 - 8 = 20 - 8 = 12`.\n  - Output: `5 6`. My result `12` does not match the example `6`.\n\nLet's re-examine the example output for `p=4`. If `n=5` and unidirectional pairs is `6`.\nMy formula `n*(n-1) - 2p` gives `12`.\nThe only way to get `6` unidirectional pairs with `n=5` and `p=4` is if the total number of pairs `(u,v)` with `u!=v` and `u,v` in different SCCs is `6`.\nTotal ordered pairs `(u,v)` with `u!=v` is `n(n-1) = 5*4 = 20`.\nPairs where `u,v` are in same SCC (ordered, `u!=v`) is `2p = 2*4 = 8`.\nPairs where `u,v` are in different SCCs (ordered, `u!=v`) is `20 - 8 = 12`.\nIf these `12` pairs generate `6` unidirectional pairs, it means for each `{u,v}` where `u,v` are in different SCCs, only one of `(u,v)` or `(v,u)` is counted as unidirectional. This is exactly what my formula `n*(n-1)-2p` calculates.\n\nThe problem statement for `p`-reachable: \"ordered pairs of nodes `(u, v)` such that `u < v` and `u` and `v` are reachable from each other.\" This is `p`.\nThis means `p` is the count of unordered pairs `{u,v}` from the same SCC.\nThe total number of distinct pairs of nodes `{u,v}` with `u!=v` is `n(n-1)/2`.\nThe number of unordered pairs `{u,v}` where `u,v` are in the same SCC is `p`.\nThe number of unordered pairs `{u,v}` where `u,v` are in different SCCs is `n(n-1)/2 - p`.\nFor each such unordered pair `{u,v}` where `u,v` are in different SCCs, we can make exactly one of `(u,v)` or `(v,u)` unidirectional. For example, if `u` is in `SCC_i` and `v` in `SCC_j`, and we order SCCs as `SCC_1 -> ... -> SCC_m`, then if `i < j`, `(u,v)` is unidirectional. If `i > j`, `(v,u)` is unidirectional.\nSo, the maximum number of unidirectional pairs is `n(n-1)/2 - p`.\n\nLet's re-test with this new formula:\n- `p = 3`:\n  - `n = 3`.\n  - Unidirectional pairs = `3 * (3 - 1) / 2 - 3 = 3 * 2 / 2 - 3 = 3 - 3 = 0`.\n  - Output: `3 0`. Matches.\n\n- `p = 4`:\n  - `n = 5`.\n  - Unidirectional pairs = `5 * (5 - 1) / 2 - 4 = 5 * 4 / 2 - 4 = 10 - 4 = 6`.\n  - Output: `5 6`. Matches!\n\nThis formula `n(n-1)/2 - p` is correct. The previous formula `n(n-1) - 2p` was counting both `(u,v)` and `(v,u)` as unidirectional if `u` and `v` were in different SCCs and `u`'s SCC could reach `v`'s SCC. The problem asks for \"number of unidirectional pairs of nodes `(u, v)`\", which implies counting each `(u,v)` pair only once. My interpretation of `n^2 - sum(k_i^2)` was counting `(u,v)` and `(v,u)` as distinct if they were unidirectional in opposite directions. The corrected formula `n(n-1)/2 - p` counts unordered pairs of nodes that are in different SCCs, and then implicitly says each such pair `{u,v}` can contribute one unidirectional pair `(u,v)` or `(v,u)`.\n\nFinal Algorithm:\n1. Initialize `n = 0`.\n2. Read `p`.\n3. If `p == 0`, print `0 0` and exit.\n4. Loop while `p > 0`:\n   a. Calculate `k = int((1 + (1 + 8 * p)**0.5) / 2)`.\n   b. Add `k` to `n`.\n   c. Subtract `k * (k - 1) / 2` from `p`.\n5. Calculate `unidirectional_pairs = n * (n - 1) / 2 - (original_p)`.\n   (Store original `p` because `p` is modified in the loop).\n6. Print `n` and `unidirectional_pairs`.\n\nConsider `p=0` case:\n`p=0`, print `0 0`. Correct.\n\n```python\nimport math\n\ndef solve():\n    p = int(input())\n\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    original_p = p\n    min_nodes = 0\n\n    while p > 0:\n        # Find the largest k such that k * (k - 1) / 2 <= p\n        # k^2 - k - 2p <= 0\n        # Roots are (1 +/- sqrt(1 + 8p)) / 2\n        # We need k <= (1 + sqrt(1 + 8p)) / 2\n        k = int((1 + math.isqrt(1 + 8 * p)) / 2)\n        \n        # In case k*(k-1)/2 is exactly p, k will be correct.\n        # If p is small, e.g. p=1, k=2. f(2)=1.\n        # If p=0, k=1. f(1)=0. This case is handled by p>0 loop condition.\n\n        min_nodes += k\n        p -= k * (k - 1) // 2\n\n    # Calculate maximum unidirectional pairs\n    # Total distinct pairs of nodes {u,v} is n*(n-1)/2\n    # Number of pairs {u,v} in same SCC is original_p\n    # Number of pairs {u,v} in different SCCs is n*(n-1)/2 - original_p\n    # Each such pair {u,v} can form exactly one unidirectional pair (u,v) or (v,u)\n    max_unidirectional_pairs = min_nodes * (min_nodes - 1) // 2 - original_p\n\n    print(min_nodes, max_unidirectional_pairs)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef solve():\n    p = int(input())\n\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    original_p = p\n    min_nodes = 0\n\n    while p > 0:\n        # Find the largest k such that k * (k - 1) / 2 <= p\n        # k^2 - k - 2p <= 0\n        # Roots are (1 +/- sqrt(1 + 8p)) / 2\n        # We need k <= (1 + sqrt(1 + 8p)) / 2\n        k = int((1 + math.isqrt(1 + 8 * p)) / 2)\n        \n        # In case k*(k-1)/2 is exactly p, k will be correct.\n        # If p is small, e.g. p=1, k=2. f(2)=1.\n        # If p=0, k=1. f(1)=0. This case is handled by p>0 loop condition.\n\n        min_nodes += k\n        p -= k * (k - 1) // 2\n\n    # Calculate maximum unidirectional pairs\n    # Total distinct pairs of nodes {u,v} is n*(n-1)/2\n    # Number of pairs {u,v} in same SCC is original_p\n    # Number of pairs {u,v} in different SCCs is n*(n-1)/2 - original_p\n    # Each such pair {u,v} can form exactly one unidirectional pair (u,v) or (v,u)\n    max_unidirectional_pairs = min_nodes * (min_nodes - 1) // 2 - original_p\n\n    print(min_nodes, max_unidirectional_pairs)\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 483,
        "completion_token_count": 3381,
        "thoughts_token_count": 6634
    }
}