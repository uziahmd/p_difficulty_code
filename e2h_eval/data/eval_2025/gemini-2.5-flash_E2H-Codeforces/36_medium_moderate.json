{
    "start": 1758294691.916688,
    "end": 1758294777.0204384,
    "start-formatted": "2025-09-20 00:11 KST",
    "end-formatted": "2025-09-20 00:12 KST",
    "gpu": 2,
    "pid": 36,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Radio Towers\n\nThere are $$$n + 2$$$ towns located on a coordinate line, numbered from $$$0$$$ to $$$n + 1$$$. The $$$i$$$-th town is located at the point $$$i$$$.You build a radio tower in each of the towns $$$1, 2, \\dots, n$$$ with probability $$$\\frac{1}{2}$$$ (these events are independent). After that, you want to set the signal power on each tower to some integer from $$$1$$$ to $$$n$$$ (signal powers are not necessarily the same, but also not necessarily different). The signal from a tower located in a town $$$i$$$ with signal power $$$p$$$ reaches every city $$$c$$$ such that $$$|c - i| < p$$$.After building the towers, you want to choose signal powers in such a way that:  towns $$$0$$$ and $$$n + 1$$$ don't get any signal from the radio towers;  towns $$$1, 2, \\dots, n$$$ get signal from exactly one radio tower each. For example, if $$$n = 5$$$, and you have built the towers in towns $$$2$$$, $$$4$$$ and $$$5$$$, you may set the signal power of the tower in town $$$2$$$ to $$$2$$$, and the signal power of the towers in towns $$$4$$$ and $$$5$$$ to $$$1$$$. That way, towns $$$0$$$ and $$$n + 1$$$ don't get the signal from any tower, towns $$$1$$$, $$$2$$$ and $$$3$$$ get the signal from the tower in town $$$2$$$, town $$$4$$$ gets the signal from the tower in town $$$4$$$, and town $$$5$$$ gets the signal from the tower in town $$$5$$$.Calculate the probability that, after building the towers, you will have a way to set signal powers to meet all constraints.\n\n## Input\nThe first (and only) line of the input contains one integer $$$n$$$ ($$$1 \\le n \\le 2 \\cdot 10^5$$$).\n\n## Output\nPrint one integer â€” the probability that there will be a way to set signal powers so that all constraints are met, taken modulo $$$998244353$$$.Formally, the probability can be expressed as an irreducible fraction $$$\\frac{x}{y}$$$. You have to print the value of $$$x \\cdot y^{-1} \\bmod 998244353$$$, where $$$y^{-1}$$$ is an integer such that $$$y \\cdot y^{-1} \\bmod 998244353 = 1$$$.\n\n## Example\n### Input\n['2', '3', '5', '200000']\n\n### Output\n['748683265', '748683265', '842268673', '202370013']\n\n## Note\nThe real answer for the first example is $$$\\frac{1}{4}$$$:  with probability $$$\\frac{1}{4}$$$, the towers are built in both towns $$$1$$$ and $$$2$$$, so we can set their signal powers to $$$1$$$. The real answer for the second example is $$$\\frac{1}{4}$$$:   with probability $$$\\frac{1}{8}$$$, the towers are built in towns $$$1$$$, $$$2$$$ and $$$3$$$, so we can set their signal powers to $$$1$$$;  with probability $$$\\frac{1}{8}$$$, only one tower in town $$$2$$$ is built, and we can set its signal power to $$$2$$$. The real answer for the third example is $$$\\frac{5}{32}$$$. Note that even though the previous explanations used equal signal powers for all towers, it is not necessarily so. For example, if $$$n = 5$$$ and the towers are built in towns $$$2$$$, $$$4$$$ and $$$5$$$, you may set the signal power of the tower in town $$$2$$$ to $$$2$$$, and the signal power of the towers in towns $$$4$$$ and $$$5$$$ to $$$1$$$.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "**Alright, here's my breakdown of this signal power problem:**\n\nI'm being asked to calculate the probability of finding a valid power assignment for signals between towns. It's a modulo problem, which is a common hint towards working with large numbers and using efficient algorithms. The problem involves towns arranged linearly, with towers possibly built in some of them. Each tower, if present, can transmit a signal to nearby towns, determined by its power level.\n\nThe core constraints are: the edge towns (0 and n+1) receive no signal, and each of the middle towns (1 to n) must receive a signal from *exactly* one tower. The tricky part is figuring out what constitutes a \"valid assignment\" of signal powers.\n\nI've realized that the power of a tower is limited by its position: it can't transmit beyond the edge of the line or back into the starting town. The power of a tower at a town `i` is constrained to be between 1 and min(i, n+1-i).\n\nI've been analyzing the nature of the \"exactly one tower\" condition. It means the coverage ranges of towers must form a perfect partition of the middle towns. It is like covering the towns 1 to n with non-overlapping intervals, and for each town, there is exactly one tower covering it.\n\nThis led me to the insight that the power assignments create intervals, and for a set of towers to be valid, these intervals need to completely cover the range 1 to n without overlaps. This also means that for the chosen set of towers, each middle town must have one and only one power to reach it.\n\nFor this partition to exist, the intervals formed by the power assignments must \"stitch\" together to cover the full range of towns. The most interesting property is that an interval's left and right endpoints must have the same parity (either both odd or both even).\n\nThe key insight is that the set of towns with towers *must* be precisely the set of \"centers\" of the non-overlapping intervals. If there's a tower at a town that's *not* the center of an interval, it can't effectively contribute to the partitioning without violating the \"one tower per town\" rule. This also leads to the conclusion that if any tower does not meet this condition, then this specific tower configuration is not valid, and it is eliminated from the total count.\n\nI'm now thinking this can be formulated using dynamic programming. I'm imagining building up valid partitions from smaller sub-problems. Let `dp[k]` represent the number of valid ways to partition towns 1 to k. To calculate `dp[k]`, I need to consider all possible intervals ending at town k.\nThe core of my approach is to figure out whether the towers configuration is valid. This has led me to identify the exact subset of possible valid tower configurations.\nI'll use dynamic programming to count the valid tower configurations.",
    "response": "The problem asks us to calculate the probability that, after building radio towers in towns $1, \\dots, n$ with probability $1/2$ each, there exists a way to set signal powers such that:\n1. Towns $0$ and $n+1$ receive no signal.\n2. Towns $1, \\dots, n$ receive signal from exactly one tower each.\n\nLet's denote the set of towns where towers are built as $S \\subseteq \\{1, \\dots, n\\}$.\nIf a tower is built in town $i \\in S$ and assigned signal power $p_i$, it covers towns $c$ such that $|c - i| < p_i$. This means it covers the integers in the interval $(i-p_i, i+p_i)$, which is $[i-p_i+1, i+p_i-1]$.\n\nThe first constraint implies that for any tower at $i$ with power $p_i$:\n- Town $0$ is not covered: $i-p_i+1 > 0 \\implies p_i \\le i$.\n- Town $n+1$ is not covered: $i+p_i-1 < n+1 \\implies p_i \\le n+1-i$.\nSo, for any tower at $i \\in S$, its power $p_i$ must satisfy $1 \\le p_i \\le \\min(i, n+1-i)$.\n\nThe second constraint implies that the intervals $[i-p_i+1, i+p_i-1]$ for all $i \\in S$ must form a partition of the set $\\{1, \\dots, n\\}$. That is, they must be disjoint and their union must be $\\{1, \\dots, n\\}$.\n\nLet's consider an interval $[L, R]$ covered by a single tower at $i$ with power $p_i$.\nThen $L = i-p_i+1$ and $R = i+p_i-1$.\nFrom these equations, we can find $i$ and $p_i$:\nAdding them: $L+R = 2i \\implies i = (L+R)/2$. This implies $L$ and $R$ must have the same parity for $i$ to be an integer.\nSubtracting them: $R-L = 2p_i-2 \\implies p_i = (R-L+2)/2$.\nSince $p_i \\ge 1$, we must have $R-L+2 \\ge 2 \\implies R-L \\ge 0 \\implies R \\ge L$.\n\nThe conditions for a valid partition of $\\{1, \\dots, n\\}$ into segments $[L_k, R_k]$ become:\n1. For each segment $[L_k, R_k]$, its center $i_k = (L_k+R_k)/2$ must be an integer. This means $L_k$ and $R_k$ must have the same parity.\n2. The set of centers $S' = \\{i_k \\mid \\text{for all segments}\\}$ must be exactly the set $S$ of towns where towers are built. If there is a tower at $j \\in S$ but $j \\notin S'$, it would have to cover some town $c \\in \\{1, \\dots, n\\}$, causing $c$ to be covered by two towers, or it would cover town $0$ or $n+1$, which are forbidden. Conversely, if $i_k \\notin S$, then the segment $[L_k, R_k]$ cannot be covered.\n3. For each $i_k \\in S$, the power $p_{i_k} = (R_k-L_k+2)/2$ must satisfy $1 \\le p_{i_k} \\le \\min(i_k, n+1-i_k)$.\n   - $p_{i_k} \\le i_k \\implies (R_k-L_k+2)/2 \\le (L_k+R_k)/2 \\implies R_k-L_k+2 \\le L_k+R_k \\implies 2 \\le 2L_k \\implies L_k \\ge 1$. This is always true for segments partitioning $\\{1, \\dots, n\\}$.\n   - $p_{i_k} \\le n+1-i_k \\implies (R_k-L_k+2)/2 \\le n+1-(L_k+R_k)/2 \\implies R_k-L_k+2 \\le 2n+2-L_k-R_k \\implies 2R_k \\le 2n \\implies R_k \\le n$. This is also always true for segments partitioning $\\{1, \\dots, n\\}$.\n\nSo, a set $S$ of towers is valid if and only if there exists a partition of $\\{1, \\dots, n\\}$ into segments $[L_k, R_k]$ such that $L_k$ and $R_k$ have the same parity, and $S$ is precisely the set of centers $i_k = (L_k+R_k)/2$.\n\nLet $dp[k]$ be the number of ways to partition the towns $\\{1, \\dots, k\\}$ into such segments.\nBase case: $dp[0] = 1$ (the empty set of towns can be partitioned in one way, by no segments).\nFor $k \\ge 1$, to partition $\\{1, \\dots, k\\}$, the last segment must be $[j, k]$ for some $j \\in \\{1, \\dots, k\\}$.\nFor this segment $[j, k]$ to be valid:\n- $j$ and $k$ must have the same parity.\n- The towns $\\{1, \\dots, j-1\\}$ must be partitionable in a valid way. The number of ways for this is $dp[j-1]$.\nThe center of $[j, k]$ is $(j+k)/2$. This town must have a tower, and no other towns in $S$ should be in $\\{j, \\dots, k\\}$ (except $(j+k)/2$).\nThus, $dp[k] = \\sum_{j=1, j \\equiv k \\pmod 2}^{k} dp[j-1]$.\n\nLet's compute $dp[k]$ for small $k$:\n- $dp[0] = 1$\n- $dp[1]$: $k=1$. $j$ must be $1$ ($1 \\equiv 1 \\pmod 2$). $dp[1] = dp[0] = 1$.\n- $dp[2]$: $k=2$. $j$ must be $2$ ($2 \\equiv 2 \\pmod 2$). $dp[2] = dp[1] = 1$.\n- $dp[3]$: $k=3$. $j$ can be $1$ ($1 \\equiv 3 \\pmod 2$) or $3$ ($3 \\equiv 3 \\pmod 2$). $dp[3] = dp[0] + dp[2] = 1+1 = 2$.\n- $dp[4]$: $k=4$. $j$ can be $2$ ($2 \\equiv 4 \\pmod 2$) or $4$ ($4 \\equiv 4 \\pmod 2$). $dp[4] = dp[1] + dp[3] = 1+2 = 3$.\n- $dp[5]$: $k=5$. $j$ can be $1, 3, 5$. $dp[5] = dp[0] + dp[2] + dp[4] = 1+1+3 = 5$.\n- $dp[6]$: $k=6$. $j$ can be $2, 4, 6$. $dp[6] = dp[1] + dp[3] + dp[5] = 1+2+5 = 8$.\n\nWe observe that $dp[k]$ values are Fibonacci numbers: $F_0=0, F_1=1, F_2=1, F_3=2, F_4=3, F_5=5, F_6=8, \\dots$.\nSpecifically, $dp[k] = F_{k+1}$.\nThe recurrence relation for Fibonacci numbers is $F_k = F_{k-1} + F_{k-2}$.\nOur recurrence is $dp[k] = \\sum_{j=1, j \\equiv k \\pmod 2}^{k} dp[j-1]$.\nIf $k$ is odd, $j$ is odd. $dp[k] = dp[0] + dp[2] + \\dots + dp[k-1]$.\nIf $k$ is even, $j$ is even. $dp[k] = dp[1] + dp[3] + \\dots + dp[k-1]$.\nNotice that $dp[k] = dp[k-2] + dp[k-1]$ for $k \\ge 2$.\nFor example, if $k$ is odd: $dp[k] = dp[0] + dp[2] + \\dots + dp[k-1]$.\n$dp[k-2] = dp[0] + dp[2] + \\dots + dp[k-3]$.\n$dp[k-1]$ (since $k-1$ is even) $= dp[1] + dp[3] + \\dots + dp[k-2]$.\nThis doesn't directly show $dp[k] = dp[k-1] + dp[k-2]$.\nLet's use the definition:\n$dp[k] = dp[k-1 \\text{ if } k \\text{ has same parity as } 1] + dp[k-3 \\text{ if } k \\text{ has same parity as } 3] + \\dots$\n$dp[k] = dp[k-1]$ (if $k$ and $k-1$ have same parity, i.e., $k-1$ is the largest $j-1$ in the sum) $+ \\sum_{j'=1, j' \\equiv k-2 \\pmod 2}^{k-2} dp[j'-1]$.\nThe sum is $dp[k-2]$. So $dp[k] = dp[k-1] + dp[k-2]$. This holds for $k \\ge 2$.\nWith $dp[0]=1=F_1$ and $dp[1]=1=F_2$, we have $dp[k]=F_{k+1}$.\n\nThe number of valid tower configurations $S$ is $dp[n] = F_{n+1}$.\nEach tower configuration $S$ occurs with probability $(1/2)^{|S|} (1/2)^{n-|S|} = (1/2)^n$.\nSo, the total probability is $F_{n+1} \\cdot (1/2)^n$.\nWe need to compute this modulo $998244353$.\nThis requires calculating $F_{n+1}$ and $2^{-n} \\pmod{998244353}$.\n\n$F_{n+1}$ can be computed using matrix exponentiation in $O(\\log n)$ time.\nThe matrix is $\\begin{pmatrix} 1 & 1 \\\\ 1 & 0 \\end{pmatrix}$.\n$\\begin{pmatrix} F_{k+1} \\\\ F_k \\end{pmatrix} = \\begin{pmatrix} 1 & 1 \\\\ 1 & 0 \\end{pmatrix}^{k} \\begin{pmatrix} F_1 \\\\ F_0 \\end{pmatrix} = \\begin{pmatrix} 1 & 1 \\\\ 1 & 0 \\end{pmatrix}^{k} \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}$.\nSo $F_{n+1}$ is the top-left element of $\\begin{pmatrix} 1 & 1 \\\\ 1 & 0 \\end{pmatrix}^n$.\n\n$2^{-n} \\pmod{998244353}$ can be computed using modular exponentiation: $pow(2, -n, MOD) = pow(2, MOD-1-n, MOD)$.\n\nThe modulus is $998244353$, which is a prime number.\n\nExample for $n=2$:\n$dp[2] = F_3 = 2$.\nProbability $= 2 \\cdot (1/2)^2 = 2/4 = 1/2$.\nModulo: $2 \\cdot 2^{-2} \\pmod{998244353} = 2 \\cdot (2^{-1})^2 \\pmod{998244353}$.\n$2^{-1} \\pmod{998244353} = (998244353+1)/2 = 499122177$.\n$2 \\cdot 499122177^2 \\pmod{998244353} = 2 \\cdot 249122851167732209 \\pmod{998244353}$.\n$2 \\cdot 249122851167732209 \\equiv 2 \\cdot 499122177 \\pmod{998244353} \\equiv 998244354 \\pmod{998244353} \\equiv 1 \\pmod{998244353}$.\nThe example output for $n=2$ is $748683265$. This is incorrect.\nThe example output for $n=2$ is $748683265$. This is $(1/4) \\pmod{998244353}$.\n$4^{-1} \\pmod{998244353} = 249561089$.\nMy calculation for $n=2$ is $1/2$. The example output implies $F_3=1$.\nLet's recheck the example. If $n=2$, towns $1,2$.\nPossible tower configurations:\n1. No towers (prob $1/4$). $S=\\emptyset$. Cannot partition $\\{1,2\\}$. Invalid.\n2. Tower at $1$ only (prob $1/4$). $S=\\{1\\}$.\n   If $p_1=1$, covers $[1,1]$. Town $2$ not covered. Invalid.\n3. Tower at $2$ only (prob $1/4$). $S=\\{2\\}$.\n   If $p_2=1$, covers $[2,2]$. Town $1$ not covered. Invalid.\n   If $p_2=2$, covers $[1,3]$. Valid.\n   This is a valid configuration.\n4. Towers at $1,2$ (prob $1/4$). $S=\\{1,2\\}$.\n   If $p_1=1$, covers $[1,1]$. If $p_2=1$, covers $[2,2]$. Valid.\nTotal valid configurations: $S=\\{2\\}$ and $S=\\{1,2\\}$.\nTotal probability: $1/4 + 1/4 = 1/2$.\nThe example output for $n=2$ is $748683265$, which is $1/4 \\pmod{998244353}$. This suggests only one valid configuration.\nWhat did I misunderstand?\n\n\"The real answer for the first example is $1/4$: with probability $1/4$, the towers are built in both towns $1$ and $2$, so we can set their signal powers to $1$.\"\nThis implies only $S=\\{1,2\\}$ is valid. Why is $S=\\{2\\}$ not valid?\nFor $S=\\{2\\}$, $p_2=2$ covers $[1,3]$. This covers towns $1,2$ and avoids $0, n+1$.\nThe problem states: \"towns $1, 2, \\dots, n$ get signal from exactly one radio tower each\".\nIn $S=\\{2\\}$ with $p_2=2$, town $1$ gets signal from tower $2$. Town $2$ gets signal from tower $2$.\nThis is valid.\n\nIs it possible that the example output for $n=2$ is incorrect, or I am misinterpreting it?\nLet's check $n=3$.\n$dp[3] = F_4 = 3$.\nProbability $= 3 \\cdot (1/2)^3 = 3/8$.\nModulo: $3 \\cdot (2^{-1})^3 \\pmod{998244353} = 3 \\cdot 499122177^3 \\pmod{998244353}$.\n$499122177^3 \\equiv 499122177 \\cdot (499122177^2) \\equiv 499122177 \\cdot (2^{-2}) \\equiv 499122177 \\cdot (1/4) \\pmod{998244353}$.\n$3 \\cdot (1/8) \\pmod{998244353} = 3 \\cdot 124780544 \\pmod{998244353} = 374341632 \\pmod{998244353}$.\nThe example output for $n=3$ is $748683265$. This is $1/4 \\pmod{998244353}$.\nThis suggests $F_4=2$.\nFibonacci sequence: $F_0=0, F_1=1, F_2=1, F_3=2, F_4=3, F_5=5, \\dots$\nIt seems the example output uses $F_{n}$ instead of $F_{n+1}$.\nIf $dp[k] = F_k$: $dp[0]=F_0=0$. This would mean $dp[0]$ is not $1$.\nIf $dp[0]=1, dp[1]=1, dp[2]=2, dp[3]=3, \\dots$ this is $F_{k+1}$ starting from $F_1$.\nMy $dp[k]$ sequence matches $F_{k+1}$.\nThe example output for $n=2$ is $1/4$. This suggests $F_2=1$ valid configurations.\nThe example output for $n=3$ is $1/4$. This suggests $F_3=2$ valid configurations.\nThe example output for $n=5$ is $5/32$. This suggests $F_5=5$ valid configurations.\nThis pattern (if $n=2 \\Rightarrow F_2=1$, $n=3 \\Rightarrow F_3=2$, $n=5 \\Rightarrow F_5=5$) matches $F_n$.\nSo the number of ways is $F_n$.\nThis means $dp[k] = F_k$.\nIf $dp[k] = F_k$, then $dp[0]=F_0=0$. But $dp[0]$ must be 1.\nThis is a common issue with Fibonacci indexing. Let's use $F_1=1, F_2=1, F_3=2, \\dots$.\nThen $dp[k] = F_k$ for $k \\ge 1$, and $dp[0]=1$.\n$dp[k] = \\sum_{j=1, j \\equiv k \\pmod 2}^{k} dp[j-1]$.\n$dp[1] = dp[0] = 1$. (Matches $F_1$)\n$dp[2] = dp[1] = 1$. (Matches $F_2$)\n$dp[3] = dp[0] + dp[2] = 1+1=2$. (Matches $F_3$)\n$dp[4] = dp[1] + dp[3] = 1+2=3$. (Matches $F_4$)\n$dp[5] = dp[0] + dp[2] + dp[4] = 1+1+3=5$. (Matches $F_5$)\nThis sequence $1,1,2,3,5,\\dots$ for $k=1,2,3,4,5,\\dots$ means $dp[k]=F_k$.\nSo the number of ways is $F_n$.\nThe final probability is $F_n \\cdot (2^{-n}) \\pmod{998244353}$.\n$F_n$ can be computed using matrix exponentiation.\n$\\begin{pmatrix} F_k \\\\ F_{k-1} \\end{pmatrix} = \\begin{pmatrix} 1 & 1 \\\\ 1 & 0 \\end{pmatrix}^{k-1} \\begin{pmatrix} F_1 \\\\ F_0 \\end{pmatrix} = \\begin{pmatrix} 1 & 1 \\\\ 1 & 0 \\end{pmatrix}^{k-1} \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}$.\nSo $F_n$ is the top-left element of $\\begin{pmatrix} 1 & 1 \\\\ 1 & 0 \\end{pmatrix}^{n-1}$.\nThis is valid for $n \\ge 1$. For $n=1$, $F_1=1$. $\\begin{pmatrix} 1 & 1 \\\\ 1 & 0 \\end{pmatrix}^{0} = \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix}$. Top-left is $1$. Correct.\nFor $n=0$, $F_0=0$. This case is not in the problem constraints.\n\nThe maximum $n$ is $2 \\cdot 10^5$. Matrix exponentiation is efficient enough.\n\n```python\nMOD = 998244353\n\ndef matrix_mult(A, B):\n    C = [[0, 0], [0, 0]]\n    for i in range(2):\n        for j in range(2):\n            for k in range(2):\n                C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % MOD\n    return C\n\ndef matrix_pow(A, p):\n    res = [[1, 0], [0, 1]] # Identity matrix\n    A_copy = A\n    while p > 0:\n        if p % 2 == 1:\n            res = matrix_mult(res, A_copy)\n        A_copy = matrix_mult(A_copy, A_copy)\n        p //= 2\n    return res\n\ndef fibonacci(n):\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    \n    # Calculate F_n using matrix exponentiation\n    # [F_k, F_{k-1}] = [[1, 1], [1, 0]]^(k-1) * [F_1, F_0]\n    # For F_n, we need to raise to the power n-1\n    T = [[1, 1], [1, 0]]\n    T_pow_n_minus_1 = matrix_pow(T, n - 1)\n    \n    # F_n = T_pow_n_minus_1[0][0] * F_1 + T_pow_n_minus_1[0][1] * F_0\n    # F_n = T_pow_n_minus_1[0][0] * 1 + T_pow_n_minus_1[0][1] * 0\n    return T_pow_n_minus_1[0][0]\n\ndef mod_inv(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef solve():\n    n = int(input())\n\n    if n == 0: # Though constraints say 1 <= n, good to handle\n        print(0) # F_0 = 0\n        return\n\n    # Calculate F_n\n    fib_n = fibonacci(n)\n\n    # Calculate 2^(-n) mod MOD\n    two_pow_n_inv = mod_inv(pow(2, n, MOD), MOD)\n\n    # Result is F_n * 2^(-n) mod MOD\n    ans = (fib_n * two_pow_n_inv) % MOD\n    print(ans)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "MOD = 998244353\n\ndef matrix_mult(A, B):\n    C = [[0, 0], [0, 0]]\n    for i in range(2):\n        for j in range(2):\n            for k in range(2):\n                C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % MOD\n    return C\n\ndef matrix_pow(A, p):\n    res = [[1, 0], [0, 1]] # Identity matrix\n    A_copy = A\n    while p > 0:\n        if p % 2 == 1:\n            res = matrix_mult(res, A_copy)\n        A_copy = matrix_mult(A_copy, A_copy)\n        p //= 2\n    return res\n\ndef fibonacci(n):\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    \n    # Calculate F_n using matrix exponentiation\n    # [F_k, F_{k-1}] = [[1, 1], [1, 0]]^(k-1) * [F_1, F_0]\n    # For F_n, we need to raise to the power n-1\n    T = [[1, 1], [1, 0]]\n    T_pow_n_minus_1 = matrix_pow(T, n - 1)\n    \n    # F_n = T_pow_n_minus_1[0][0] * F_1 + T_pow_n_minus_1[0][1] * F_0\n    # F_n = T_pow_n_minus_1[0][0] * 1 + T_pow_n_minus_1[0][1] * 0\n    return T_pow_n_minus_1[0][0]\n\ndef mod_inv(n, mod):\n    return pow(n, mod - 2, mod)\n\ndef solve():\n    n = int(input())\n\n    if n == 0: # Though constraints say 1 <= n, good to handle\n        print(0) # F_0 = 0\n        return\n\n    # Calculate F_n\n    fib_n = fibonacci(n)\n\n    # Calculate 2^(-n) mod MOD\n    two_pow_n_inv = mod_inv(pow(2, n, MOD), MOD)\n\n    # Result is F_n * 2^(-n) mod MOD\n    ans = (fib_n * two_pow_n_inv) % MOD\n    print(ans)\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 1028,
        "completion_token_count": 5610,
        "thoughts_token_count": 6472
    }
}