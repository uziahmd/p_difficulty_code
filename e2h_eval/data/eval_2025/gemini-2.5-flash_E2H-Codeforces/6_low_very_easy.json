{
    "start": 1758009286.1478598,
    "end": 1758009326.4270399,
    "start-formatted": "2025-09-16 16:54 KST",
    "end-formatted": "2025-09-16 16:55 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "**Problem-Solving Approach for Leha's Voucher Problem**\n\nOkay, so I'm tackling Leha's voucher problem, and it's a classic competitive programming scenario. I need to write a Python script to find the optimal pair of vouchers. The problem is fairly well-defined: I'm given `n` vouchers, a target duration `x`, and for each voucher, a start time, end time, and cost. The objective is to pick two non-intersecting vouchers whose durations sum to `x` while minimizing their total cost. If no such pair exists, I have to output -1.\n\nMy initial thought is that the brute-force approach, checking every possible pair, is a total non-starter. With `n` up to 2 * 10^5, that's an O(N^2) complexity, and that's going to be way too slow. So, I need a more efficient strategy.\n\nThe constraints on `n`, `x`, `li`, and `ri` being up to 2 * 10^5 give me a clue. I'm thinking I can likely get away with something like O(N log N) or, possibly, even O(N * MaxCoord) where MaxCoord is the maximum value of the coordinates. That might be the right way to optimize it.\n\nI've broken down the key components. For a given voucher `i`, with duration `d_i`, I'm looking for a second voucher `j` such that `d_j = x - d_i`. I need to minimize the total cost of `cost_i + cost_j`. The non-intersection condition is essential.  Vouchers intersect if their time intervals overlap. To ensure no intersection, either `ri < lj` or `rj < li`. I can rephrase this: Voucher `j` must either start after voucher `i` ends (`ri < lj`) or end before `i` begins (`rj < li`).\n\nI'm starting to visualize a possible solution strategy.  I'm thinking about iterating through each voucher `i`. For each one, I can effectively \"search\" for a suitable `j`. The constraint `duration_i + duration_j = x` guides this search. Perhaps using some data structure that's indexed by day numbers might be useful to find potential vouchers that meet the non-intersection criterion. I can store this information and then perform efficient lookups. That might work.\n",
    "response": "The problem asks us to find two distinct, non-overlapping vouchers whose total duration is exactly `x` and whose total cost is minimized. If no such pair exists, we should output -1.\n\nLet's denote a voucher by `(l, r, cost)`. Its duration is `d = r - l + 1`.\nTwo vouchers `(l1, r1, cost1)` and `(l2, r2, cost2)` are non-overlapping if `r1 < l2` or `r2 < l1`.\n\nThe constraints on `n`, `x`, `l`, `r` are up to `2 * 10^5`. This suggests a solution better than O(N^2), likely O(N log N) or O(N * MaxCoord).\n\n**Algorithm Idea:**\n\n1.  **Categorize Vouchers by Duration:**\n    We need `d1 + d2 = x`. This means for a voucher with duration `d1`, we are looking for a voucher with duration `d2 = x - d1`.\n    It's efficient to group vouchers by their durations. We can use a list of lists (or a dictionary where keys are durations) to store vouchers. `vouchers_by_duration[d]` would store all vouchers with duration `d`.\n    Each entry in `vouchers_by_duration[d]` should be `(l, r, cost)`.\n\n2.  **Iterate and Find Pairs:**\n    We can iterate through all possible durations `d1` from `1` up to `x - 1`.\n    For each `d1`, the required duration for the second voucher is `d2 = x - d1`.\n    If `d2 <= 0` (or `d2 > max_possible_duration`), we can skip this `d1`.\n\n    For a given pair of durations `(d1, d2)`:\n    We need to find a voucher `v1 = (l1, r1, cost1)` from `vouchers_by_duration[d1]` and a voucher `v2 = (l2, r2, cost2)` from `vouchers_by_duration[d2]` such that they are non-overlapping and `cost1 + cost2` is minimized.\n\n3.  **Efficiently Finding Non-overlapping Vouchers:**\n    The non-overlapping condition `r1 < l2` or `r2 < l1` is key.\n    Let's process vouchers sorted by their start times (`l`).\n\n    We can maintain an array, say `min_cost_ending_at[day]`, which stores the minimum cost of a voucher that *ends* on or before `day`. This array can be initialized with infinity and then updated.\n    `min_cost_ending_at[day] = min(min_cost_ending_at[day-1], min_cost_of_any_voucher_ending_exactly_on_day)`\n\n    A more effective approach is to iterate through all possible `r` values (end days). For each `r`, we want to find the best `l` such that `r < l`.\n\n    Let's use a sweep-line approach or an array that tracks minimum costs for available durations.\n    We can iterate through the days from `1` to `MAX_COORD` (which is `2 * 10^5`).\n    For each day `k`:\n    *   **Update minimum costs for vouchers ending on day `k-1`:** We need to know the minimum cost for any voucher of duration `d` that ends *before* day `k`. Let's say `min_cost_before[d]` stores the minimum cost of a voucher with duration `d` that ends at `k-1` or earlier.\n    *   **Process vouchers starting on day `k`:** For each voucher `(l, r, cost)` that starts on day `k`:\n        Its duration `d = r - l + 1`.\n        We need a second voucher with duration `d_other = x - d`.\n        If `d_other > 0` and `d_other <= MAX_DURATION`, we can check if there's any `v_other` with duration `d_other` that ends before `l`. The minimal cost for such a `v_other` would be `min_cost_before[d_other]`. If such a `v_other` exists, we can update our overall minimum total cost: `min_total_cost = min(min_total_cost, cost + min_cost_before[d_other])`.\n    *   **Update minimum costs for vouchers ending on day `k`:** After processing all vouchers starting on day `k`, we update `min_cost_before[d]` for all vouchers `(l, r, cost)` that end on day `k`. This means for each such voucher, `min_cost_ending_at_day[r][d] = min(min_cost_ending_at_day[r][d], cost)`.\n\nThis can be simplified. We need to find `min_cost_of_voucher_with_duration_D_ending_before_day_K`.\nLet `dp[d]` be the minimum cost of a voucher with duration `d` encountered *so far* (i.e., ending at or before the current day being processed). Initialize `dp` with infinity.\n\nWe can iterate through days `k` from `1` to `MAX_COORD`.\nFor each day `k`:\n1.  For all vouchers `(l, r, cost)` that *start* on day `k`:\n    a.  Calculate its duration `d = r - l + 1`.\n    b.  Calculate the required duration for the second voucher: `d_other = x - d`.\n    c.  If `d_other > 0` and `d_other <= MAX_DURATION` (which is `MAX_COORD`):\n        If `dp[d_other]` is not infinity, it means we have previously encountered a voucher with duration `d_other` that ends *before* day `k`. We can form a pair: `cost + dp[d_other]`. Update `min_total_cost = min(min_total_cost, cost + dp[d_other])`.\n2.  For all vouchers `(l, r, cost)` that *end* on day `k`:\n    a.  Calculate its duration `d = r - l + 1`.\n    b.  Update `dp[d] = min(dp[d], cost)`. This means we've found a voucher with duration `d` ending on day `k` with cost `cost`. This `dp[d]` value will be available for vouchers starting on `k+1` or later.\n\nTo implement this, we need to efficiently retrieve vouchers starting/ending on a given day. We can pre-process the input vouchers into two lists of lists:\n- `vouchers_starting_on[k]`: stores `(r, cost, duration)` for vouchers starting on day `k`.\n- `vouchers_ending_on[k]`: stores `(l, cost, duration)` for vouchers ending on day `k`.\n\n**Detailed Steps:**\n\n1.  **Initialization:**\n    *   `MAX_COORD = 2 * 10^5`\n    *   `vouchers_starting_on = [[] for _ in range(MAX_COORD + 1)]`\n    *   `vouchers_ending_on = [[] for _ in range(MAX_COORD + 1)]`\n    *   `min_cost_for_duration = [float('inf')] * (MAX_COORD + 1)` (This `dp` array will store `min_cost_of_voucher_with_duration_D_ending_before_current_day`)\n    *   `min_total_cost = float('inf')`\n\n2.  **Populate `vouchers_starting_on` and `vouchers_ending_on`:**\n    For each input voucher `(l, r, cost)`:\n    *   `duration = r - l + 1`\n    *   `vouchers_starting_on[l].append((r, cost, duration))`\n    *   `vouchers_ending_on[r].append((l, cost, duration))`\n\n3.  **Sweep Line:**\n    For `k` from `1` to `MAX_COORD`:\n    *   **Process vouchers ending on day `k-1` (or earlier to be precise, this step updates `min_cost_for_duration` to be ready for vouchers starting on day `k`):**\n        For each voucher `(l, cost, duration)` in `vouchers_ending_on[k-1]`:\n        *   `min_cost_for_duration[duration] = min(min_cost_for_duration[duration], cost)`\n        *(Correction: This update should happen AFTER processing vouchers starting on day `k`, so `min_cost_for_duration` reflects vouchers ending strictly before `k` when we process starting vouchers for `k`)*\n\n    *   **Process vouchers starting on day `k`:**\n        For each voucher `(r, cost, duration)` in `vouchers_starting_on[k]`:\n        *   `d_other = x - duration`\n        *   If `1 <= d_other <= MAX_COORD`:\n            *   If `min_cost_for_duration[d_other]` is not `inf`:\n                *   `min_total_cost = min(min_total_cost, cost + min_cost_for_duration[d_other])`\n\n    *   **Update `min_cost_for_duration` for vouchers ending on day `k`:**\n        For each voucher `(l, cost, duration)` in `vouchers_ending_on[k]`:\n        *   `min_cost_for_duration[duration] = min(min_cost_for_duration[duration], cost)`\n\n4.  **Output:**\n    If `min_total_cost` is `float('inf')`, print `-1`.\n    Otherwise, print `min_total_cost`.\n\n**Example walk-through (First Sample):**\nn=4, x=5\nVouchers: (1,3,4), (1,2,5), (5,6,1), (1,2,4)\n\nPre-processing:\n(1,3,4) -> dur=3. start[1]: (3,4,3). end[3]: (1,4,3)\n(1,2,5) -> dur=2. start[1]: (2,5,2). end[2]: (1,5,2)\n(5,6,1) -> dur=2. start[5]: (6,1,2). end[6]: (5,1,2)\n(1,2,4) -> dur=2. start[1]: (2,4,2). end[2]: (1,4,2)\n\n`vouchers_starting_on`:\n1: [(3,4,3), (2,5,2), (2,4,2)]\n5: [(6,1,2)]\n\n`vouchers_ending_on`:\n2: [(1,5,2), (1,4,2)]\n3: [(1,4,3)]\n6: [(5,1,2)]\n\n`min_cost_for_duration = [inf, inf, ..., inf]`\n`min_total_cost = inf`\n\nDay `k=1`:\n  *   Process vouchers starting on day 1:\n      *   (3,4,3): dur=3. `d_other = 5-3=2`. `min_cost_for_duration[2]` is inf. No update.\n      *   (2,5,2): dur=2. `d_other = 5-2=3`. `min_cost_for_duration[3]` is inf. No update.\n      *   (2,4,2): dur=2. `d_other = 5-2=3`. `min_cost_for_duration[3]` is inf. No update.\n  *   Update `min_cost_for_duration` for vouchers ending on day 1: None.\n  `min_cost_for_duration` is still all inf.\n\nDay `k=2`:\n  *   Process vouchers starting on day 2: None.\n  *   Update `min_cost_for_duration` for vouchers ending on day 2:\n      *   (1,5,2): dur=2. `min_cost_for_duration[2] = min(inf, 5) = 5`.\n      *   (1,4,2): dur=2. `min_cost_for_duration[2] = min(5, 4) = 4`.\n  `min_cost_for_duration`: [inf, inf, 4, inf, ...]\n\nDay `k=3`:\n  *   Process vouchers starting on day 3: None.\n  *   Update `min_cost_for_duration` for vouchers ending on day 3:\n      *   (1,4,3): dur=3. `min_cost_for_duration[3] = min(inf, 4) = 4`.\n  `min_cost_for_duration`: [inf, inf, 4, 4, ...]\n\nDay `k=4`:\n  *   Process vouchers starting on day 4: None.\n  *   Update `min_cost_for_duration` for vouchers ending on day 4: None.\n  `min_cost_for_duration`: [inf, inf, 4, 4, ...]\n\nDay `k=5`:\n  *   Process vouchers starting on day 5:\n      *   (6,1,2): dur=2. `d_other = 5-2=3`. `min_cost_for_duration[3]` is 4.\n          `min_total_cost = min(inf, 1 + 4) = 5`.\n  *   Update `min_cost_for_duration` for vouchers ending on day 5: None.\n  `min_total_cost = 5`.\n\n... (Continue up to MAX_COORD)\n\nFinal `min_total_cost = 5`. Output 5. This matches the example.\n\n**Complexity:**\n- Pre-processing: O(N) to populate lists.\n- Sweep line: `MAX_COORD` iterations.\n    - Inside loop: Iterating through `vouchers_starting_on[k]` and `vouchers_ending_on[k]`. The total number of elements across all `k` in these lists is O(N).\n    - `min_cost_for_duration` array access is O(1).\n- Total time complexity: O(N + MAX_COORD).\n- Space complexity: O(N + MAX_COORD) for storing vouchers and `min_cost_for_duration` array.\n\nGiven `N, X, L, R <= 2 * 10^5`, this solution is efficient enough.\n\n```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n\n    MAX_COORD = 2 * 10**5\n\n    # vouchers_starting_on[k] stores (r, cost, duration) for vouchers starting on day k\n    vouchers_starting_on = [[] for _ in range(MAX_COORD + 1)]\n    # vouchers_ending_on[k] stores (l, cost, duration) for vouchers ending on day k\n    vouchers_ending_on = [[] for _ in range(MAX_COORD + 1)]\n\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        duration = r - l + 1\n        vouchers_starting_on[l].append((r, cost, duration))\n        vouchers_ending_on[r].append((l, cost, duration))\n\n    # min_cost_for_duration[d] stores the minimum cost of a voucher\n    # with duration 'd' that has ended *before* the current day 'k' being processed.\n    # More precisely, it stores the minimum cost of a voucher with duration 'd'\n    # that has ended at day 'k-1' or earlier.\n    min_cost_for_duration = [float('inf')] * (MAX_COORD + 1)\n    min_total_cost = float('inf')\n\n    # Sweep through days from 1 to MAX_COORD\n    for k in range(1, MAX_COORD + 1):\n        # Step 1: Process vouchers that start on day 'k'.\n        # For these vouchers, we look for a complementary voucher that ended strictly before 'k'.\n        for r, cost, duration in vouchers_starting_on[k]:\n            d_other = x - duration\n            if 1 <= d_other <= MAX_COORD:\n                if min_cost_for_duration[d_other] != float('inf'):\n                    min_total_cost = min(min_total_cost, cost + min_cost_for_duration[d_other])\n        \n        # Step 2: Update min_cost_for_duration with vouchers that end on day 'k'.\n        # These vouchers will be available for future starting vouchers (starting on day k+1 or later).\n        for l, cost, duration in vouchers_ending_on[k]:\n            min_cost_for_duration[duration] = min(min_cost_for_duration[duration], cost)\n\n    if min_total_cost == float('inf'):\n        sys.stdout.write(\"-1\\n\")\n    else:\n        sys.stdout.write(str(min_total_cost) + \"\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n\n    MAX_COORD = 2 * 10**5\n\n    # vouchers_starting_on[k] stores (r, cost, duration) for vouchers starting on day k\n    vouchers_starting_on = [[] for _ in range(MAX_COORD + 1)]\n    # vouchers_ending_on[k] stores (l, cost, duration) for vouchers ending on day k\n    vouchers_ending_on = [[] for _ in range(MAX_COORD + 1)]\n\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        duration = r - l + 1\n        vouchers_starting_on[l].append((r, cost, duration))\n        vouchers_ending_on[r].append((l, cost, duration))\n\n    # min_cost_for_duration[d] stores the minimum cost of a voucher\n    # with duration 'd' that has ended *before* the current day 'k' being processed.\n    # More precisely, it stores the minimum cost of a voucher with duration 'd'\n    # that has ended at day 'k-1' or earlier.\n    min_cost_for_duration = [float('inf')] * (MAX_COORD + 1)\n    min_total_cost = float('inf')\n\n    # Sweep through days from 1 to MAX_COORD\n    for k in range(1, MAX_COORD + 1):\n        # Step 1: Process vouchers that start on day 'k'.\n        # For these vouchers, we look for a complementary voucher that ended strictly before 'k'.\n        for r, cost, duration in vouchers_starting_on[k]:\n            d_other = x - duration\n            if 1 <= d_other <= MAX_COORD:\n                if min_cost_for_duration[d_other] != float('inf'):\n                    min_total_cost = min(min_total_cost, cost + min_cost_for_duration[d_other])\n        \n        # Step 2: Update min_cost_for_duration with vouchers that end on day 'k'.\n        # These vouchers will be available for future starting vouchers (starting on day k+1 or later).\n        for l, cost, duration in vouchers_ending_on[k]:\n            min_cost_for_duration[duration] = min(min_cost_for_duration[duration], cost)\n\n    if min_total_cost == float('inf'):\n        sys.stdout.write(\"-1\\n\")\n    else:\n        sys.stdout.write(str(min_total_cost) + \"\\n\")\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 799,
        "completion_token_count": 4029,
        "thoughts_token_count": 714
    }
}