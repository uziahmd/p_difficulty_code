{
    "start": 1758294769.9440255,
    "end": 1758294861.9381802,
    "start-formatted": "2025-09-20 00:12 KST",
    "end-formatted": "2025-09-20 00:14 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "**Understanding the LCM Minimization Problem**\n\nAlright, I'm tasked with writing a Python script to find the smallest non-negative integer 'k' that minimizes the least common multiple (LCM) of `a+k` and `b+k`. The goal is to get the script to return the smallest 'k' if there are multiple values that result in the same minimum LCM.\n\nI see that `lcm(a+k, b+k)` can be rewritten as `(x * y) / gcd(x, y)`, where `x = a+k` and `y = b+k`. The key here is the greatest common divisor (GCD) of `x` and `y`, which is the variable `g`. Let `d = |b - a|`. I've realized that the GCD `g` must be a divisor of `d`. This means I need to iterate through all divisors of `d`.\n\nFor a given divisor 'g' of 'd', I'm seeking the 'k' where `a+k` and `b+k` are multiples of 'g', and their GCD is precisely 'g'. This is crucial for minimizing the LCM, as `lcm(x, y) = (x*y)/g`. If the GCD is greater than 'g' (e.g., a multiple of 'g', but not equal), the `lcm(x, y)` will be smaller for the larger `g`.\n\n**Finding the Optimal 'k' for Each 'g'**\n\nWith a fixed divisor 'g', I know that `a+k` must be a multiple of 'g'. I need to find the smallest non-negative 'k', called `k_base`, for which this is true. I can compute this as `(g - (a % g)) % g`. Then, I have the smallest number where `a+k` is a multiple of 'g', let's say `a + k_base = A_g * g`. I want to find the smallest non-negative integer `m` such that for `k_opt = k_base + m * g`\n\nI need to make sure `gcd(A_g + m, d/g) = 1` which is equal to `gcd(a+k)/g, (b+k)/g) = 1`. This reduces to finding the smallest `m >= 0`. To do this, I need to find `X_opt = smallest X >= A_g such that gcd(X, D_g) = 1` and `k_opt` will be this number minus `A_g`.\n\nFor each divisor `g`, I need to solve this. Finding `k`.\n\n**The Optimization Challenge**\n\nMy concern is how to efficiently find the optimal `X` when testing `gcd(X, D_g) = 1`.  I'm trying to figure out how many values I might need to iterate through to find an `X`.\nI'm struggling to find a method that avoids checking values of X. I could precompute prime factors of `D_g` and iterate `m = 0, 1, 2, ...`.\n\nI've made progress by figuring out how to reduce the range of values I need to check. It seems the best strategy is to iterate through `start_X` up to `rad(D_g)`, where `rad` represents the radical of the divisors.\n",
    "response": "The problem asks us to find the smallest non-negative integer `k` such that `lcm(a+k, b+k)` is minimized. If there are multiple optimal `k` values, we choose the smallest one.\n\nLet `x = a+k` and `y = b+k`. We want to minimize `lcm(x, y)`.\nWe know that `lcm(x, y) = (x * y) / gcd(x, y)`.\n\nLet `g = gcd(x, y) = gcd(a+k, b+k)`.\nSince `g` divides both `a+k` and `b+k`, it must also divide their difference: `(b+k) - (a+k) = b - a`.\nLet `d = |b - a|`. Thus, `g` must be a divisor of `d`.\n\nWithout loss of generality, assume `a <= b`. Then `d = b - a`.\nOur strategy will be to iterate through all possible values for `g`, which are the divisors of `d`. For each `g`, we find the `k` that satisfies the conditions and minimizes `lcm(a+k, b+k)` for that specific `g`. Then we compare the results across all `g` to find the global minimum.\n\nFor a fixed divisor `g` of `d`:\n1.  We need `a+k` and `b+k` to be multiples of `g`.\n    Let `a+k = Xg` and `b+k = Yg` for some integers `X, Y`.\n2.  For `gcd(a+k, b+k)` to be exactly `g`, we must have `gcd(Xg, Yg) = g`, which implies `gcd(X, Y) = 1`.\n3.  From `b+k - (a+k) = d`, we have `Yg - Xg = d`, so `(Y-X)g = d`. This means `Y - X = d/g`.\n    Let `D_g = d/g`. Then `Y = X + D_g`.\n    The condition `gcd(X, Y) = 1` becomes `gcd(X, X + D_g) = 1`, which simplifies to `gcd(X, D_g) = 1`.\n\nSo, for a given `g` (a divisor of `d`), we need to find `k` such that:\n*   `a+k = Xg` for some integer `X`.\n*   `gcd(X, D_g) = 1`.\n*   `k >= 0`.\n\nFrom `a+k = Xg`, we have `k = Xg - a`.\nSince `k >= 0`, we must have `Xg - a >= 0`, or `Xg >= a`. This means `X >= a/g`.\nSince `X` must be an integer, `X >= ceil(a/g)`. Let `start_X = (a + g - 1) // g`.\n\nFor each `g`, we need to find the smallest integer `X_opt >= start_X` such that `gcd(X_opt, D_g) = 1`.\nOnce `X_opt` is found, the corresponding `k` is `k_g = X_opt * g - a`.\nThe `lcm` value for this `g` and `k_g` will be `(X_opt * g) * ((X_opt + D_g) * g) / g = X_opt * (X_opt + D_g) * g`.\n\nTo find `X_opt`:\nLet `P_D` be the set of distinct prime factors of `D_g`. We need `X` such that `X % p != 0` for all `p \\in P_D`.\nWe can iterate `X` starting from `start_X` and check `gcd(X, D_g) == 1`.\nHow many values of `X` do we need to check? The maximum gap between two consecutive integers coprime to `M` is `rad(M)` (the product of distinct prime factors of `M`).\nThe maximum `rad(M)` for `M <= 10^9` is about `2.2 * 10^8`. Iterating up to this value is too slow.\n\nHowever, the problem statement implies that `k` should not be excessively large. Also, `lcm` is typically minimized when `g` is large.\nThe `lcm` expression is `X_opt * (X_opt + D_g) * g`.\nRoughly, `X_opt` is around `a/g` and `D_g` is `d/g`.\nSo `lcm` is approximately `(a/g) * (a/g + d/g) * g = (a/g) * ((a+d)/g) * g = a(a+d)/g`.\nTo minimize `a(a+d)/g`, we should maximize `g`. This suggests we should prioritize larger divisors of `d`.\n\nThe key insight for competitive programming problems of this type is that the optimal `k` is usually small, or the number of `X` values we need to check is small.\nThe number of distinct prime factors of `D_g` is at most 9 for `D_g <= 10^9`.\nLet `P_D = {p_1, p_2, ..., p_r}` be the set of distinct prime factors of `D_g`.\nWe need `X \\not\\equiv 0 \\pmod{p_i}` for all `i`.\nWe can iterate `X` from `start_X` and check this condition.\nWhat is the maximum `m = X_opt - start_X` that we might encounter?\nIt turns out that `m` is usually small. A common bound for `m` in similar problems is around `2 * sqrt(max_val)` or a small constant.\nFor `a, b <= 10^9`, `d <= 10^9`.\nThe maximum number of divisors `d` for `N <= 10^9` is 1344 (for `735134400`).\nIf we iterate `X` for a small constant number of steps, say `C`, for each divisor `g`, the total complexity would be `num_divisors * C * log(D_g)` (for GCD and prime factorization).\nA safe upper bound for `m` is around `2 * sqrt(a)`. This is because if `X` is very large, `X * (X+D_g) * g` will be large.\nFor `a,b <= 10^9`, `a+k` could be `10^9`. `k` can be small, say `0` to `2*10^5`.\nIf `k` is small, `a+k` and `b+k` are close to `a` and `b`.\nThe maximum value for `k` in the example is 2.\n\nLet's try a reasonable bound for the search of `X_opt`. A bound like `2 * 10^5` (or `2 * 10^6` to be safe) for `m = X - start_X` should be sufficient. This means `X` is checked in the range `[start_X, start_X + MAX_M]`.\nThe `gcd` function is efficient (`log`).\nThe number of divisors is at most 1344.\n`1344 * 2*10^5 * log(10^9)` is too large.\n`1344 * 2*10^5 * 30` is roughly `8 * 10^9`.\n\nThe key constraint for `X_opt` is that `X_opt * (X_opt + D_g) * g` must be minimized.\nIf `X_opt` is much larger than `start_X`, then `k` is large, and `a+k` and `b+k` are much larger than `a` and `b`. This would make `lcm` large.\nSo, `X_opt` should be very close to `start_X`.\nThe range `[start_X, start_X + MAX_M]` for `X_opt` is usually enough, where `MAX_M` is a small constant, often `2 * 10^5` is used in competitive programming for `10^9` inputs.\nLet's analyze the `lcm` function `f(X) = X * (X + D_g) * g`. This is a quadratic in `X`, increasing for `X > 0`. So we want the smallest possible `X`.\nThe smallest `X` is `start_X`. If `gcd(start_X, D_g) == 1`, then `X_opt = start_X`.\nOtherwise, we check `start_X+1`, `start_X+2`, etc.\nThe critical observation is that `gcd(X, D_g)` is only affected by the prime factors of `D_g`. There are at most 9 distinct prime factors for `D_g <= 10^9`.\nWe need `X \\pmod{p_i} \\ne 0` for all `p_i \\in P_D`.\n\nLet's bound `MAX_M` more carefully.\nIf `D_g = 1`, `gcd(X, 1) = 1` for all `X`. So `X_opt = start_X`. `m=0`.\nIf `D_g` is prime, `p`. We need `X \\not\\equiv 0 \\pmod p`.\nIf `start_X \\pmod p \\ne 0`, `X_opt = start_X`. `m=0`.\nIf `start_X \\pmod p = 0`, `X_opt = start_X + 1`. `m=1`. (Because `start_X+1 \\pmod p \\ne 0` if `p>1`).\nSo for prime `D_g`, `m` is at most 1.\n\nThe `k` value `X_opt * g - a` should be as small as possible.\nThe `lcm` value `X_opt * (X_opt + D_g) * g` must be minimized.\nThe maximum value of `a, b` is `10^9`.\nThe maximum value of `d` is `10^9 - 1`.\nThe number of divisors `d` for `N <= 10^9` is at most 1344.\nThe maximum `k` for which `lcm` is minimal is usually small. A bound of `2*10^5` for `k` (or `m`) is a common heuristic.\nLet's set a search limit for `X` to `start_X + 2*10^5`.\nThis means for each `g`, we check at most `2*10^5` values of `X`.\n`1344 * 2*10^5 * log(D_g)` is still too slow.\n`log(D_g)` comes from `gcd`. We don't need `gcd` if we have prime factors.\nWe can precompute prime factors of `D_g`. For each `X`, check divisibility by `p_i`.\n`1344 * 2*10^5 * 9` is roughly `2.4 * 10^9`. Still too slow.\n\nThe crucial observation is that `a+k` and `b+k` should be small.\nThe `lcm` is `(a+k)(b+k)/g`.\nIf `k` is large, `a+k` and `b+k` are large, so `lcm` is large.\nTherefore, the optimal `k` must be relatively small.\nA reasonable bound for `k` to check is `2 * 10^5`.\nSo `a+k` is at most `10^9 + 2*10^5`.\nFor each `g`, we iterate `k` from `k_base = (g - (a % g)) % g` up to `k_base + C*g` where `C` is a small constant, or up to `2*10^5`.\nThen `X = (a+k)/g`. We need `gcd(X, d/g) = 1`.\nSo we iterate `k` from `0` to `2 * 10^5`.\nFor each such `k`:\n1. Calculate `val_a = a+k`, `val_b = b+k`.\n2. Calculate `current_gcd = gcd(val_a, val_b)`.\n3. Calculate `current_lcm = (val_a // current_gcd) * val_b`. (Using `val_a // current_gcd` to prevent overflow if `val_a * val_b` exceeds `2^63-1`, although Python integers handle arbitrary size).\n4. If `current_lcm` is less than `min_lcm`, update `min_lcm` and `ans_k`.\n5. If `current_lcm` is equal to `min_lcm`, update `ans_k` to `min(ans_k, k)`.\n\nThe maximum `k` to check is `2 * 10^5`.\nThis approach would be `2*10^5 * log(max(a,b))`.\n`2*10^5 * 30` is `6 * 10^6`, which is perfectly fine.\nThis is the standard approach for problems where the optimal `k` is small.\n\nWhy is `k` small?\nConsider `lcm(A, B) = A*B/gcd(A,B)`.\nIf `k` is very large, `A = a+k` and `B = b+k` are very large.\n`gcd(A,B)` divides `B-A = b-a`. So `gcd(A,B)` is at most `b-a`.\nThen `lcm(A,B)` is approximately `(a+k)(b+k)/(b-a)`. This grows quadratically with `k`.\nSo `k` must be small to minimize `lcm`.\nA bound of `2 * 10^5` for `k` is common. Let's try `2 * 10^5` as the limit for `k`.\n\nFinal Algorithm:\n1. Initialize `min_lcm = infinity` and `ans_k = 0`.\n2. Handle the case `a=b`: If `a=b`, then `d=0`. `gcd(a+k, a+k) = a+k`. `lcm(a+k, a+k) = a+k`.\n   To minimize `a+k`, we choose smallest `k >= 0`, so `k=0`. `lcm(a,a)=a`. Output `0`.\n3. If `a != b`:\n   Iterate `k` from `0` up to a certain limit (e.g., `2 * 10^5`).\n   For each `k`:\n     `val_a = a + k`\n     `val_b = b + k`\n     `current_gcd = gcd(val_a, val_b)`\n     `current_lcm = (val_a // current_gcd) * val_b`\n     If `current_lcm < min_lcm`:\n       `min_lcm = current_lcm`\n       `ans_k = k`\n     Else if `current_lcm == min_lcm`:\n       `ans_k = min(ans_k, k)` (This is implicitly handled if we iterate `k` in increasing order, as the first `k` found for a `min_lcm` will be the smallest.)\n4. Additionally, iterate through divisors `g` of `d = |b-a|`. This covers cases where `k` might be large but `g` is also large, leading to a small `lcm`.\n   For each divisor `g` of `d`:\n     `D_g = d // g`\n     `start_X = (a + g - 1) // g`\n     We need to find smallest `X >= start_X` such that `gcd(X, D_g) == 1`.\n     Iterate `X_candidate` from `start_X` up to `start_X + 2*10^5` (or some other small constant like `2*10^5` to be safe).\n     If `gcd(X_candidate, D_g) == 1`:\n       `current_k = X_candidate * g - a`\n       If `current_k < 0`, continue (we need non-negative `k`).\n       `current_lcm = X_candidate * (X_candidate + D_g) * g`\n       If `current_lcm < min_lcm`:\n         `min_lcm = current_lcm`\n         `ans_k = current_k`\n       Else if `current_lcm == min_lcm`:\n         `ans_k = min(ans_k, current_k)`\n       Break from inner loop (found smallest `X` for this `g`, so this `k` is optimal for this `g`).\n\nThe two approaches (iterating `k` directly, and iterating `g` then `X`) are complementary. The direct `k` iteration is good when `k` is small. The `g` iteration is good when `g` is large, because `lcm` is roughly `a(a+d)/g`. If `g` is large, `X_opt` is close to `a/g`, and `k = X_opt * g - a` can still be small.\n\nThe maximum value of `a, b` is `10^9`. `d = |b-a|` can be `10^9 - 1`.\nWe need a `gcd` function. `math.gcd` is available.\nWe need a function to find divisors.\nTo find divisors of `d`: Iterate `i` from `1` to `sqrt(d)`. If `i` divides `d`, then `i` and `d/i` are divisors.\n\nLet's combine the two approaches. The `k` iteration covers `k` up to `2*10^5`.\nThe `g` iteration covers all divisors. For each `g`, it finds the smallest `X_opt`.\n`k_g = X_opt * g - a`. This `k_g` can be large.\nBut if `k_g` is large, then `X_opt * g` is much larger than `a`.\nThis means `X_opt` is much larger than `a/g`.\nIf `X_opt` is much larger than `a/g`, then `X_opt * (X_opt + D_g) * g` will be large.\nSo, the `X_opt` found by iterating `X` from `start_X` for a small number of steps (say `MAX_M = 2*10^5`) will cover the cases where `k` is small.\nThe `k` values generated by the `g` loop are `X_opt * g - a`.\nIf `X_opt - start_X` is small (within `MAX_M`), then `k_g` can be up to `start_X * g - a + MAX_M * g = (a+g-1)//g * g - a + MAX_M * g`.\nThis is roughly `a - a + MAX_M * g = MAX_M * g`.\nIf `g` is large (e.g., `g = d = 10^9`), then `k_g` could be `MAX_M * 10^9`, which is huge.\nThis implies we only need to iterate `X_candidate` for a small range *if `g` is small*.\nIf `g` is large, `start_X = (a+g-1)//g` is small. `D_g = d//g` is small.\nSo the number of `X_candidate` values to check to find `X_opt` is small.\nExample: `g = d`. Then `D_g = 1`. `gcd(X, 1) = 1` always. So `X_opt = start_X`.\n`k = start_X * d - a`. This `k` can be large.\nThe `k` values generated by the `g` loop should be considered completely, not just for small `k`.\nThe `k` iteration up to `2*10^5` is a fallback for cases where `g` is small and `k` is small.\n\nCorrected Algorithm:\n1. Initialize `min_lcm = infinity` and `ans_k = 0`.\n2. If `a=b`: `ans_k = 0`. `min_lcm = a`. (This is handled by the loop if `a=b`, `d=0`. `g` loop won't run. `k` loop for `k=0` will set `min_lcm = a` and `ans_k = 0`.)\n3. Calculate `d = abs(b-a)`.\n4. Find all divisors of `d`. Store them in a list `divs`.\n   For `i` from `1` to `int(d**0.5)`:\n     If `d % i == 0`:\n       `divs.append(i)`\n       If `i * i != d`: `divs.append(d // i)`\n5. Sort `divs` (not strictly necessary, but good practice).\n6. Iterate through each `g` in `divs`:\n   `D_g = d // g`\n   `start_X = (a + g - 1) // g`\n   `X_opt = -1`\n   We need to find smallest `X_candidate >= start_X` such that `gcd(X_candidate, D_g) == 1`.\n   Iterate `X_candidate` from `start_X` up to `start_X + 2*10^5` (or some other reasonable limit, `2*10^5` is often chosen as a safe upper bound for such problems).\n   If `gcd(X_candidate, D_g) == 1`:\n     `X_opt = X_candidate`\n     Break\n   If `X_opt == -1`: This means no `X_candidate` was found in the limit. This implies `k` is very large, leading to a large `lcm`. This case should not happen for the true minimum `lcm`. The range `2*10^5` is usually sufficient.\n   `current_k = X_opt * g - a`\n   `current_lcm = X_opt * (X_opt + D_g) * g`\n   If `current_lcm < min_lcm`:\n     `min_lcm = current_lcm`\n     `ans_k = current_k`\n   Else if `current_lcm == min_lcm`:\n     `ans_k = min(ans_k, current_k)`\n\nThis combined approach covers all necessary cases. The upper bound `2*10^5` for `X_candidate - start_X` is a heuristic. It's based on the idea that if `X_opt` is much larger than `start_X`, the `lcm` will be large. It's the `k` values that are small that are of interest for the direct `k` iteration. The `g` iteration will find the optimal `k` even if `k` is large, as long as `X_opt - start_X` is within the search bound.\n\nLet's test the `2*10^5` bound.\n`a=1, b=10^9`. `d = 10^9 - 1`.\n`g=1`: `D_g = 10^9 - 1`. `start_X = 1`. We need smallest `X >= 1` coprime to `10^9 - 1`.\n`10^9 - 1 = 999999999 = 3^2 * 7 * 11 * 13 * 37 * 101 * 9901`.\n`X=1` is coprime to `D_g`. So `X_opt=1`. `k = 1*1 - 1 = 0`. `lcm = 1 * (1 + D_g) * 1 = 10^9`.\nThis seems like a good candidate.\nThe number of divisors for `10^9-1` is `(2+1)(1+1)...(1+1) = 3 * 2^6 = 192`.\nFor each of these 192 divisors, we check up to `2*10^5` values.\n`192 * 2*10^5 * log(10^9)` operations (for gcd) is `192 * 2*10^5 * 30` which is roughly `1.15 * 10^9`. This is too slow.\n\nThe constraint `k >= 0` is important. `X_opt * g - a >= 0`.\nThe `gcd` calculation is `gcd(X_candidate, D_g)`. `D_g` can be `10^9`.\nThe number of distinct prime factors of `D_g` is small (at most 9).\nInstead of `gcd(X_candidate, D_g) == 1`, we can factor `D_g` into `p_1, ..., p_r` and check `X_candidate % p_i != 0` for all `i`.\nThis would be `192 * 2*10^5 * 9` which is `3.4 * 10^8`. This might be acceptable in Python if the constant factor is small.\n\nLet's re-verify the `2*10^5` bound for `X - start_X`.\nThe problem note says `k=2` for `6, 10`.\n`d=4`. Divisors: `1, 2, 4`.\n`g=1`: `D_g=4`. `start_X = 6`. `X_opt=7`. `k=1`. `lcm=77`.\n`g=2`: `D_g=2`. `start_X = 3`. `X_opt=3`. `k=0`. `lcm=30`.\n`g=4`: `D_g=1`. `start_X = 2`. `X_opt=2`. `k=2`. `lcm=24`.\nAll `X_opt - start_X` are small (0 or 1).\n\nExample `21, 31`. `d=10`. Divisors: `1, 2, 5, 10`.\n`a=21, b=31`.\n`g=1`: `D_g=10`. `start_X = 21`. `X_opt=21` (gcd(21,10)=1). `k=0`. `lcm = 21*(21+10)*1 = 21*31=651`.\n`g=2`: `D_g=5`. `start_X = (21+2-1)//2 = 11`. `X_opt=11` (gcd(11,5)=1). `k=11*2-21=1`. `lcm = 11*(11+5)*2 = 11*16*2=352`.\n`g=5`: `D_g=2`. `start_X = (21+5-1)//5 = 5`. `X_opt=5` (gcd(5,2)=1). `k=5*5-21=4`. `lcm = 5*(5+2)*5 = 5*7*5=175`.\n`g=10`: `D_g=1`. `start_X = (21+10-1)//10 = 3`. `X_opt=3` (gcd(3,1)=1). `k=3*10-21=9`. `lcm = 3*(3+1)*10 = 3*4*10=120`.\nMin `lcm=120` for `k=9`. This matches example. All `X_opt - start_X` are 0.\n\nExample `5, 10`. `d=5`. Divisors: `1, 5`.\n`a=5, b=10`.\n`g=1`: `D_g=5`. `start_X = 5`. `X_opt=6` (gcd(6,5)=1). `k=6*1-5=1`. `lcm = 6*(6+5)*1 = 6*11=66`.\n`g=5`: `D_g=1`. `start_X = (5+5-1)//5 = 1`. `X_opt=1` (gcd(1,1)=1). `k=1*5-5=0`. `lcm = 1*(1+1)*5 = 1*2*5=10`.\nMin `lcm=10` for `k=0`. This matches example. `X_opt - start_X` are 1 and 0.\n\nIt seems `X_opt - start_X` is indeed very small for the optimal `k`.\nSo the bound `2*10^5` for `X_candidate - start_X` is likely overly generous and `X_opt` is found very quickly.\nThe problem is hard because this insight is crucial. A small constant for the search range of `X_candidate` is sufficient.\n\n```python\nimport math\n\ndef gcd(a, b):\n    return math.gcd(a, b)\n\ndef solve():\n    a, b = map(int, input().split())\n\n    # Ensure a <= b for simplicity, swap if not\n    if a > b:\n        a, b = b, a\n\n    min_lcm_val = float('inf')\n    ans_k = 0\n\n    # Case 1: a == b\n    # If a == b, then gcd(a+k, b+k) = a+k. lcm(a+k, b+k) = a+k.\n    # To minimize a+k, choose smallest k >= 0, so k=0.\n    # lcm(a,a) = a.\n    # This case is handled by the general logic, but explicitly setting it can be good.\n    if a == b:\n        print(0)\n        return\n\n    d = b - a\n\n    # Find all divisors of d\n    divs = []\n    for i in range(1, int(d**0.5) + 1):\n        if d % i == 0:\n            divs.append(i)\n            if i * i != d:\n                divs.append(d // i)\n\n    # Iterate through each possible gcd value 'g' (divisor of d)\n    for g in divs:\n        D_g = d // g  # This is (b-a)/g\n\n        # We need a+k = X * g, so X = (a+k)/g\n        # We need X * g >= a, so X >= a/g. Smallest integer X is ceil(a/g)\n        start_X = (a + g - 1) // g\n\n        # We are looking for the smallest X_opt >= start_X such that gcd(X_opt, D_g) == 1\n        # The search range for X_candidate - start_X is typically small for optimal k.\n        # A bound like 2 * 10^5 is a heuristic that works for many such problems.\n        # For this problem, it seems the optimal X_opt is very close to start_X.\n        # Let's try a modest search bound, e.g., 2 * 10^5.\n        # If D_g is 1, gcd(X, 1) is always 1, so X_opt = start_X.\n        # If D_g has few small prime factors, X_opt is also quickly found.\n        \n        # Max number of iterations for X_candidate search.\n        # In competitive programming, 2e5 is a common heuristic for this type of problem.\n        # The actual required iterations for optimal k are much smaller in practice.\n        MAX_X_SEARCH_OFFSET = 2 * 10**5 \n\n        X_opt = -1\n        for offset in range(MAX_X_SEARCH_OFFSET + 1):\n            X_candidate = start_X + offset\n            if gcd(X_candidate, D_g) == 1:\n                X_opt = X_candidate\n                break\n        \n        # If X_opt was not found within the search limit, it means k would be very large\n        # and likely not optimal. Skip this g.\n        if X_opt == -1:\n            continue\n\n        current_k = X_opt * g - a\n        \n        # current_k must be non-negative.\n        # If a+k is X_opt*g, and X_opt*g < a, then k would be negative.\n        # This is handled by start_X = ceil(a/g), so X_opt*g >= a is guaranteed.\n        # Therefore, current_k >= 0 is always true.\n\n        # Calculate lcm: lcm(a+k, b+k) = (a+k)(b+k)/g\n        # a+k = X_opt * g\n        # b+k = (X_opt + D_g) * g\n        # lcm = (X_opt * g) * ((X_opt + D_g) * g) / g = X_opt * (X_opt + D_g) * g\n        current_lcm = X_opt * (X_opt + D_g) * g\n\n        if current_lcm < min_lcm_val:\n            min_lcm_val = current_lcm\n            ans_k = current_k\n        elif current_lcm == min_lcm_val:\n            ans_k = min(ans_k, current_k) # Choose smallest k if lcm values are equal\n\n    print(ans_k)\n\n# Read input and call solve for each test case\n# The problem statement implies single line input, but example shows multiple lines.\n# Assuming standard competitive programming setup where solve() is called once for each test case.\n# If multiple test cases are given in a single run, standard input needs to be read line by line.\n# For this problem, it's a single line input.\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef gcd(a, b):\n    return math.gcd(a, b)\n\ndef solve():\n    a, b = map(int, input().split())\n\n    # Ensure a <= b for simplicity, swap if not\n    if a > b:\n        a, b = b, a\n\n    min_lcm_val = float('inf')\n    ans_k = 0\n\n    # Case 1: a == b\n    # If a == b, then gcd(a+k, b+k) = a+k. lcm(a+k, b+k) = a+k.\n    # To minimize a+k, choose smallest k >= 0, so k=0.\n    # lcm(a,a) = a.\n    # This case is handled by the general logic, but explicitly setting it can be good.\n    if a == b:\n        print(0)\n        return\n\n    d = b - a\n\n    # Find all divisors of d\n    divs = []\n    for i in range(1, int(d**0.5) + 1):\n        if d % i == 0:\n            divs.append(i)\n            if i * i != d:\n                divs.append(d // i)\n\n    # Iterate through each possible gcd value 'g' (divisor of d)\n    for g in divs:\n        D_g = d // g  # This is (b-a)/g\n\n        # We need a+k = X * g, so X = (a+k)/g\n        # We need X * g >= a, so X >= a/g. Smallest integer X is ceil(a/g)\n        start_X = (a + g - 1) // g\n\n        # We are looking for the smallest X_opt >= start_X such that gcd(X_opt, D_g) == 1\n        # The search range for X_candidate - start_X is typically small for optimal k.\n        # A bound like 2 * 10^5 is a heuristic that works for many such problems.\n        # For this problem, it seems the optimal X_opt is very close to start_X.\n        # Let's try a modest search bound, e.g., 2 * 10^5.\n        # If D_g is 1, gcd(X, 1) is always 1, so X_opt = start_X.\n        # If D_g has few small prime factors, X_opt is also quickly found.\n        \n        # Max number of iterations for X_candidate search.\n        # In competitive programming, 2e5 is a common heuristic for this type of problem.\n        # The actual required iterations for optimal k are much smaller in practice.\n        MAX_X_SEARCH_OFFSET = 2 * 10**5 \n\n        X_opt = -1\n        for offset in range(MAX_X_SEARCH_OFFSET + 1):\n            X_candidate = start_X + offset\n            if gcd(X_candidate, D_g) == 1:\n                X_opt = X_candidate\n                break\n        \n        # If X_opt was not found within the search limit, it means k would be very large\n        # and likely not optimal. Skip this g.\n        if X_opt == -1:\n            continue\n\n        current_k = X_opt * g - a\n        \n        # current_k must be non-negative.\n        # If a+k is X_opt*g, and X_opt*g < a, then k would be negative.\n        # This is handled by start_X = ceil(a/g), so X_opt*g >= a is guaranteed.\n        # Therefore, current_k >= 0 is always true.\n\n        # Calculate lcm: lcm(a+k, b+k) = (a+k)(b+k)/g\n        # a+k = X_opt * g\n        # b+k = (X_opt + D_g) * g\n        # lcm = (X_opt * g) * ((X_opt + D_g) * g) / g = X_opt * (X_opt + D_g) * g\n        current_lcm = X_opt * (X_opt + D_g) * g\n\n        if current_lcm < min_lcm_val:\n            min_lcm_val = current_lcm\n            ans_k = current_k\n        elif current_lcm == min_lcm_val:\n            ans_k = min(ans_k, current_k) # Choose smallest k if lcm values are equal\n\n    print(ans_k)\n\n# Read input and call solve for each test case\n# The problem statement implies single line input, but example shows multiple lines.\n# Assuming standard competitive programming setup where solve() is called once for each test case.\n# If multiple test cases are given in a single run, standard input needs to be read line by line.\n# For this problem, it's a single line input.\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 422,
        "completion_token_count": 8046,
        "thoughts_token_count": 7040
    }
}