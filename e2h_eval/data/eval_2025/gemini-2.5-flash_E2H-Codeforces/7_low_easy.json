{
    "start": 1758009302.9268649,
    "end": 1758009357.510495,
    "start-formatted": "2025-09-16 16:55 KST",
    "end-formatted": "2025-09-16 16:55 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "**Thinking Through the Snowflake Problem**\n\nOkay, so I need to create a Python script to tackle this \"Rudolf and Snowflakes (hard version)\" problem. Let's start by breaking down the snowflake construction rules, since that's clearly the core of the problem.\n\nInitially, we have a single central vertex. The first expansion connects this center to `k` new vertices (where `k` is greater than 1).  Now comes the crucial part: the subsequent expansion.  It states, \"Each vertex that is connected to only one other vertex is connected by edges to `k` more new vertices.\" I need to be precise here. It says this step *should* be done at least once. I initially thought it meant it had to be *repeated* at least once, but it's more about the nature of the expansion itself.  Essentially, it's about adding layers.\n\nLet's use a variable, `d`, to represent the \"depth\" of the snowflake, meaning how many times this expansion rule is applied. Let's trace the number of vertices based on this depth, noting that the *initial* connection creates the first layer.\n\n*   When `d = 0`, we have the initial state (the center).  *Then* comes the initial expansion (`k` vertices). So now, with `d=0` we're at `1 + k` vertices.\n\n*   When `d = 1`, each of the initial `k` vertices adds `k` new vertices, making `k^2` new vertices.  This brings the total to `1 + k + k^2`.\n\n*   When `d = 2`, each of those `k^2` vertices will then connect to `k` more, adding `k^3` new vertices. The total is now `1 + k + k^2 + k^3`.\n\nThis clearly reveals a pattern, which seems to follow a geometric series.  If the expansion step is applied `d` times, the total number of vertices, let's call it `N`, will be calculated as `N = 1 + k + k^2 + ... + k^(d)`. This sums to `N = (k^(d+1) - 1)/(k - 1)`.\n\nSo, the key is to determine how to relate this structure to the hard version problem. The hard version likely involves this snowflake structure in a more complex scenario.\n",
    "response": "The problem asks us to determine if a given number `n` can be the total number of vertices in a \"snowflake\" graph. A snowflake is constructed with a parameter `k > 1`.\n\nLet's analyze the construction rules:\n1.  **Initially:** 1 vertex (the center).\n2.  **First expansion:** The center is connected to `k` new vertices.\n    *   Total vertices: `1 + k`.\n    *   These `k` new vertices are currently connected to only one other vertex (the center).\n3.  **Subsequent expansions:** \"Each vertex that is connected to only one other vertex is connected by edges to `k` more new vertices. This step should be done at least once.\"\n\nLet `d` be the number of times this \"subsequent expansion\" step is applied. The problem states it must be done at least once, so `d >= 1`.\n\nLet's count the total vertices based on `d`:\n*   **d = 1:** (This corresponds to the example image with `k=4`)\n    *   Initial: 1 vertex.\n    *   Connect center to `k` new vertices: `1 + k` vertices.\n    *   Apply the \"subsequent expansion\" rule once: Each of the `k` vertices (which are connected to only one other vertex) is connected to `k` new vertices. This adds `k * k = k^2` new vertices.\n    *   Total vertices: `1 + k + k^2`.\n*   **d = 2:**\n    *   Initial: 1 vertex.\n    *   Connect center to `k` new vertices: `1 + k` vertices.\n    *   Apply rule once: `k^2` new vertices added. Total `1 + k + k^2`.\n    *   Apply rule a second time: The `k^2` vertices added in the previous step are now the ones connected to only one other vertex. Each of them is connected to `k` new vertices. This adds `k^2 * k = k^3` new vertices.\n    *   Total vertices: `1 + k + k^2 + k^3`.\n\nIn general, if the \"subsequent expansion\" step is applied `d` times, the total number of vertices `N` will be the sum of a geometric series:\n`N = 1 + k + k^2 + ... + k^(d+1)`\n\nThis sum can be written as `(k^(d+2) - 1) / (k - 1)`.\nSince `d >= 1`, the minimum power of `k` in the sum is `k^2`, and the minimum number of terms is 3. So, `d+1 >= 2`.\nLet `m = d+1`. Then `m >= 2`.\nSo, `N = 1 + k + k^2 + ... + k^m`, where `m >= 2`.\n\nWe need to check if for a given `n`, there exist integers `k > 1` and `m >= 2` such that `n = 1 + k + ... + k^m`.\n\n**Case 1: `m = 2`**\n`n = 1 + k + k^2`\nThis is a quadratic equation for `k`: `k^2 + k + (1 - n) = 0`.\nUsing the quadratic formula, `k = (-1 ± sqrt(1 - 4 * (1 - n))) / 2 = (-1 ± sqrt(1 - 4 + 4n)) / 2 = (-1 ± sqrt(4n - 3)) / 2`.\nFor `k` to be a valid integer greater than 1:\n1.  `4n - 3` must be a perfect square. Let `4n - 3 = S^2` for some integer `S`.\n2.  `S` must be positive.\n3.  `k = (-1 + S) / 2` must be an integer. This implies `S` must be odd. If `S` is odd, then `-1 + S` is even, so `k` is an integer.\n4.  `k > 1`. So `(-1 + S) / 2 > 1`, which means `-1 + S > 2`, so `S > 3`.\n\nWe can check this for `n` up to `10^18`. Calculate `val = 4n - 3`. If `val` is a perfect square `S^2` and `S > 3`, then `k = (-1 + S) / 2` is a candidate. We must verify `k > 1`.\nExample: `n = 13`. `4 * 13 - 3 = 52 - 3 = 49`. `S = 7`. `S > 3` is true. `k = (-1 + 7) / 2 = 3`. `k=3 > 1` is true. So `n=13` is a YES (with `k=3, m=2`).\n\n**Case 2: `m >= 3`**\n`n = 1 + k + k^2 + ... + k^m`.\nSince `k > 1`, we have:\n`k^m < n` (because `n = k^m + k^(m-1) + ... + k + 1`)\n`k^m < n < 1 + k + k^2 + ... + k^m + k^(m+1) + ...` (an infinite series)\n`n < sum_{i=0 to infinity} k^i = 1 / (1 - k)` (This is wrong, it should be `k^m < n < k^m * (1 + 1/k + 1/k^2 + ...) = k^m * (1/(1-1/k)) = k^m * (k/(k-1))`).\nSo `k^m < n < k^m * (k / (k-1))`.\nSince `k >= 2`, `k/(k-1)` is at most `2/(2-1) = 2`.\nSo `k^m < n < 2 * k^m`.\nThis implies `k < n^(1/m)`. Also, `k^m < n` means `k < n^(1/m)`.\nAnd `n < 2 * k^m` means `(n/2)^(1/m) < k`.\nCombining these, `(n/2)^(1/m) < k < n^(1/m)`.\n\nThe maximum value of `n` is `10^18`.\nIf `m = 3`, `k` is roughly `n^(1/3)`. For `n=10^18`, `k` is roughly `(10^18)^(1/3) = 10^6`.\nIf `m = 60`, `k` is roughly `n^(1/60)`. For `n=10^18`, `k` is roughly `(10^18)^(1/60) = (10^3)^(1/10) approx 2`.\nSince `k >= 2`, `m` can be at most `log_2(n)`. For `n=10^18`, `log_2(10^18) approx 18 * log_2(10) approx 18 * 3.32 approx 59.79`. So `m` can go up to `59`.\n\nWe can iterate `m` from `3` up to `59`. For each `m`:\nWe need to find an integer `k` such that `k^m + k^(m-1) + ... + k + 1 = n`.\nWe know `(n/2)^(1/m) < k < n^(1/m)`.\nWe can use binary search to find `k` in this range.\nThe lower bound for `k` can be `2`. The upper bound for `k` can be `floor(n^(1/m)) + 2` (adding a small buffer for floating point inaccuracies).\nFor `m=3`, `k` can be up to `10^6`.\nFor `m=59`, `k` can be `2`.\n\n**Binary Search for `k`:**\nFor a fixed `m` (from `3` to `59`):\n*   Set `low = 2`, `high = int(n**(1/m)) + 2`. (A slightly tighter upper bound `min(high, int(n**(1/m) * 2))` might be used, but `n**(1/m) + 2` is safe enough for `k^m < n < 2k^m`).\n*   While `low <= high`:\n    *   `mid = (low + high) // 2`\n    *   Calculate `current_sum = 1 + mid + mid^2 + ... + mid^m`. Be careful about overflow when calculating `mid^j`. Since `n <= 10^18`, `current_sum` can reach `10^18`.\n        *   A safe way to calculate `current_sum` without overflow is to add terms iteratively: `s = 1`, `p = 1`. For `j` from `1` to `m`: `p *= mid`. If `p` becomes `> n` (or `> n - s` to be precise, to avoid `s + p` overflow), then `current_sum` will be `> n`. Otherwise `s += p`.\n    *   If `current_sum == n`, we found a valid `k` (which is `mid`). Return \"YES\".\n    *   If `current_sum < n`, `mid` is too small, so `low = mid + 1`.\n    *   If `current_sum > n`, `mid` is too large, so `high = mid - 1`.\n\nIf after checking all `m` from `3` to `59` and the `m=2` case, no such `k` is found, then `n` is a \"NO\".\n\n**Edge Cases:**\n*   `n = 1, 2, 3, 4, 5, 6`.\n    *   `n=1`: `k=0` for `1+k+k^2...` or `k=1` for `1+k`. Neither satisfies `k > 1`. NO.\n    *   `n=2`: No `k > 1` satisfies `1+k+...+k^m = 2`. NO.\n    *   `n=3`: No `k > 1` satisfies `1+k+...+k^m = 3`. Smallest sum for `k=2, m=2` is `1+2+4=7`. NO.\n    *   `n=6`: Smallest sum for `k=2, m=2` is `7`. NO.\n    *   `n=13`: `k=3, m=2`. `1+3+3^2 = 1+3+9=13`. YES.\n    *   `n=15`: `k=2, m=3`. `1+2+2^2+2^3 = 1+2+4+8=15`. YES.\n\n**Algorithm Summary:**\n1.  Read `t`.\n2.  For each test case `n`:\n    a.  **Check `m = 2` case:**\n        *   Calculate `val = 4 * n - 3`.\n        *   If `val < 0`, no solution.\n        *   Calculate `S = int(val**0.5)`.\n        *   If `S * S == val` (perfect square check) AND `S > 3` (ensures `k > 1`) AND `(S - 1) % 2 == 0` (ensures `k` is integer), then print \"YES\" and continue to next test case.\n    b.  **Check `m >= 3` cases:**\n        *   Iterate `m` from `3` to `59` (inclusive).\n        *   For each `m`, perform binary search for `k`:\n            *   `low = 2`, `high = int(n**(1/m)) + 2`. (Upper bound `high` can be `10^6` for `m=3`, and `2` for `m=59`. `int(n**(1/m))` is a good heuristic for the actual `k`, add a small buffer for safety.)\n            *   While `low <= high`:\n                *   `mid = (low + high) // 2`.\n                *   Calculate `current_sum = 0`, `power_k = 1`.\n                *   For `j` from `0` to `m`:\n                    *   `current_sum += power_k`.\n                    *   If `j < m`:\n                        *   Check for overflow: `if power_k > n // mid` (or `n / mid` for float division) means `power_k * mid` would exceed `n`. Since `current_sum` will also exceed `n`, we can break early.\n                        *   `power_k *= mid`.\n                *   If `current_sum == n`, print \"YES\" and break from both loops (inner and outer `m` loop).\n                *   If `current_sum < n`, `low = mid + 1`.\n                *   If `current_sum > n`, `high = mid - 1`.\n    c.  If no \"YES\" was printed after checking all `m` values, print \"NO\".\n\n**Implementation Details:**\n*   `n**(1/m)` uses floating point. `int(n**(1/m))` might be off by 1 for large `n` or specific `m`. Adding `+2` to `high` is a common safe margin. For example, `(10^18)^(1/3)` is `10^6`. `(10^18-1)^(1/3)` is slightly less than `10^6`. `int(n**(1/m))` might give `10^6-1`.\n*   The `power_k > n // mid` check is crucial to prevent `power_k * mid` from overflowing `10^18` before it's compared to `n`. `n // mid` will give `0` if `mid > n`, which is fine. This check correctly handles cases where `power_k * mid` would exceed `n`, implying `current_sum` will also exceed `n`.\n\n```python\nimport sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n\n    # Case m = 2: n = 1 + k + k^2\n    # k^2 + k + (1 - n) = 0\n    # k = (-1 + sqrt(1 - 4*(1-n))) / 2 = (-1 + sqrt(4n - 3)) / 2\n    \n    # Check if 4n - 3 is a perfect square S^2\n    val = 4 * n - 3\n    if val >= 0:\n        S = int(val**0.5)\n        if S * S == val:\n            # Check if k = (-1 + S) / 2 is an integer > 1\n            if (S - 1) % 2 == 0: # S must be odd for k to be integer\n                k_val = (S - 1) // 2\n                if k_val > 1:\n                    sys.stdout.write(\"YES\\n\")\n                    return\n\n    # Case m >= 3: n = 1 + k + k^2 + ... + k^m\n    # Iterate m from 3 up to max_m (approx log2(n))\n    # For n = 10^18, max_m is around 59 (since 2^59 < 10^18 < 2^60)\n    # We need k >= 2.\n    # k^m < n implies k < n^(1/m)\n    # n < k^m * (k / (k-1)) implies k > (n * (k-1) / k)^(1/m) which is roughly (n/2)^(1/m)\n    # So k is in range [2, n^(1/m)]\n    \n    # max_m for n=10^18 is around 59\n    # If k=2, 1+2+...+2^m = 2^(m+1) - 1.\n    # 2^(m+1) - 1 <= 10^18 => 2^(m+1) <= 10^18 + 1\n    # m+1 <= log2(10^18+1) approx 59.79. So m+1 <= 59 => m <= 58.\n    # So m goes from 3 up to 58.\n    \n    for m in range(3, 60): # m up to 59 for safety, max k=2 for m=58\n        # Binary search for k\n        low = 2\n        # Upper bound for k: n^(1/m) + a small buffer\n        # For n=10^18, m=3, k can be up to 10^6.\n        # For n=10^18, m=59, k can only be 2.\n        # min(int(n**(1/m)) + 2, 10**6 + 2) is a safe upper bound.\n        # 10**6 + 2 is sufficient for m=3.\n        # For larger m, n**(1/m) will be smaller.\n        high = int(n**(1/m)) + 2 \n        # Cap high to avoid excessively large ranges, though n**(1/m) usually handles this.\n        # For m=3, n=10^18, high ~ 10^6\n        # For m=59, n=10^18, high ~ 2\n        \n        # Make sure high is at least low\n        high = max(low, high)\n\n        while low <= high:\n            k_mid = (low + high) // 2\n            \n            if k_mid < 2: # k must be > 1\n                low = 2\n                continue\n\n            current_sum = 0\n            power_k = 1 # k^0\n            \n            # Calculate 1 + k_mid + k_mid^2 + ... + k_mid^m\n            # Check for overflow during calculation\n            overflow = False\n            for _ in range(m + 1): # loop m+1 times for k^0 to k^m\n                current_sum += power_k\n                if current_sum > n: # current_sum already too large\n                    overflow = True\n                    break\n                \n                # Prepare power_k for next iteration (k_mid^j)\n                if _ < m: # Don't calculate k^(m+1)\n                    # Check for overflow before multiplying power_k by k_mid\n                    # power_k * k_mid > n\n                    # power_k > n / k_mid\n                    if power_k > n // k_mid:\n                        overflow = True\n                        break\n                    power_k *= k_mid\n            \n            if overflow:\n                high = k_mid - 1 # k_mid is too large\n            elif current_sum == n:\n                sys.stdout.write(\"YES\\n\")\n                return\n            elif current_sum < n:\n                low = k_mid + 1 # k_mid is too small\n            else: # current_sum > n\n                high = k_mid - 1 # k_mid is too large\n\n    sys.stdout.write(\"NO\\n\")\n\n\nnum_test_cases = int(sys.stdin.readline())\nfor _ in range(num_test_cases):\n    solve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n\n    # Case m = 2: n = 1 + k + k^2\n    # k^2 + k + (1 - n) = 0\n    # k = (-1 + sqrt(1 - 4*(1-n))) / 2 = (-1 + sqrt(4n - 3)) / 2\n    \n    # Check if 4n - 3 is a perfect square S^2\n    val = 4 * n - 3\n    if val >= 0:\n        S = int(val**0.5)\n        if S * S == val:\n            # Check if k = (-1 + S) / 2 is an integer > 1\n            if (S - 1) % 2 == 0: # S must be odd for k to be integer\n                k_val = (S - 1) // 2\n                if k_val > 1:\n                    sys.stdout.write(\"YES\\n\")\n                    return\n\n    # Case m >= 3: n = 1 + k + k^2 + ... + k^m\n    # Iterate m from 3 up to max_m (approx log2(n))\n    # For n = 10^18, max_m is around 59 (since 2^59 < 10^18 < 2^60)\n    # We need k >= 2.\n    # k^m < n implies k < n^(1/m)\n    # n < k^m * (k / (k-1)) implies k > (n * (k-1) / k)^(1/m) which is roughly (n/2)^(1/m)\n    # So k is in range [2, n^(1/m)]\n    \n    # max_m for n=10^18 is around 59\n    # If k=2, 1+2+...+2^m = 2^(m+1) - 1.\n    # 2^(m+1) - 1 <= 10^18 => 2^(m+1) <= 10^18 + 1\n    # m+1 <= log2(10^18+1) approx 59.79. So m+1 <= 59 => m <= 58.\n    # So m goes from 3 up to 58.\n    \n    for m in range(3, 60): # m up to 59 for safety, max k=2 for m=58\n        # Binary search for k\n        low = 2\n        # Upper bound for k: n^(1/m) + a small buffer\n        # For n=10^18, m=3, k can be up to 10^6.\n        # For n=10^18, m=59, k can only be 2.\n        # min(int(n**(1/m)) + 2, 10**6 + 2) is a safe upper bound.\n        # 10**6 + 2 is sufficient for m=3.\n        # For larger m, n**(1/m) will be smaller.\n        high = int(n**(1/m)) + 2 \n        # Cap high to avoid excessively large ranges, though n**(1/m) usually handles this.\n        # For m=3, n=10^18, high ~ 10^6\n        # For m=59, n=10^18, high ~ 2\n        \n        # Make sure high is at least low\n        high = max(low, high)\n\n        while low <= high:\n            k_mid = (low + high) // 2\n            \n            if k_mid < 2: # k must be > 1\n                low = 2\n                continue\n\n            current_sum = 0\n            power_k = 1 # k^0\n            \n            # Calculate 1 + k_mid + k_mid^2 + ... + k_mid^m\n            # Check for overflow during calculation\n            overflow = False\n            for _ in range(m + 1): # loop m+1 times for k^0 to k^m\n                current_sum += power_k\n                if current_sum > n: # current_sum already too large\n                    overflow = True\n                    break\n                \n                # Prepare power_k for next iteration (k_mid^j)\n                if _ < m: # Don't calculate k^(m+1)\n                    # Check for overflow before multiplying power_k by k_mid\n                    # power_k * k_mid > n\n                    # power_k > n / k_mid\n                    if power_k > n // k_mid:\n                        overflow = True\n                        break\n                    power_k *= k_mid\n            \n            if overflow:\n                high = k_mid - 1 # k_mid is too large\n            elif current_sum == n:\n                sys.stdout.write(\"YES\\n\")\n                return\n            elif current_sum < n:\n                low = k_mid + 1 # k_mid is too small\n            else: # current_sum > n\n                high = k_mid - 1 # k_mid is too large\n\n    sys.stdout.write(\"NO\\n\")\n\n\nnum_test_cases = int(sys.stdin.readline())\nfor _ in range(num_test_cases):\n    solve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 568,
        "completion_token_count": 4597,
        "thoughts_token_count": 783
    }
}