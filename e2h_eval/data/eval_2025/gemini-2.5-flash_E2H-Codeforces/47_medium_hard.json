{
    "start": 1758294759.8673491,
    "end": 1758294830.4980707,
    "start-formatted": "2025-09-20 00:12 KST",
    "end-formatted": "2025-09-20 00:13 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "**The Puzzle of the Minimal LCM**\n\nOkay, here's the deal: I'm staring at a competitive programming problem. The goal is to find this non-negative integer, *k*, that makes the least common multiple (LCM) of *a* + *k* and *b* + *k* as small as possible. If there's a tie, smallest *k* wins.\n\nLet's call *a* + *k* \"x\" and *b* + *k* \"y\".  My brain immediately goes to the LCM formula: `lcm(x, y) = (x * y) / gcd(x, y)`. The plan is to minimize this.  Let's name `gcd(x, y)` as \"d\". I notice that since `x = a + k` and `y = b + k`, the difference `y - x` is simply `b - a`.  The crucial point is that \"d\" has to divide `y - x`, meaning it also has to divide `b - a`.\n\nLet's assume *a* is the smaller number and calculate the absolute difference, which is `diff = b - a`. The value \"d\" must be a divisor of `diff`.  Now, for each divisor \"d\", my challenge is to find the suitable *k* where the `gcd(a+k, b+k)` equals \"d\". This means `a + k` and `b + k` must both be multiples of \"d\".\n\nTo get `a+k` a multiple of `d`, I can express it as `a + k = m * d`.  This means `k = m * d - a`.  Since *k* has to be non-negative, I have to find the smallest multiple of `d` that is bigger than or equal to `a`.  This is `ceil(a/d) * d`. The `k` that'll make `a+k` a multiple of `d` is given by `(-a % d + d) % d`.\n\nNow I have a *k*, but I need to make sure that `gcd(a+k, b-a) = d`, to check if the `gcd(a+k, b+k)` can equals \"d\". I now need to find a `j` where `a+k + j *d` is coprime with `b-a`.\nLet `M_0` equals `(a+k0)/d` and `D_0` equals `(b-a)/d`. So the problem boils down to finding a small `j` such that `gcd(M_0 + j, D_0) = 1`.\n\nThe *j* can be found by prime factorization and iterating.\nThe algorithm is:\n1.  Calculate diff. If diff is 0, k=0 is the answer.\n2.  Find all divisors of diff.\n3.  For each divisor, calculate k0. Then calculate the required j to obtain an appropriate k_cand.\n4. Calculate and save the minimal LCM and the relevant K value.\nI'm hoping this'll give me the *k* I'm looking for and solve this puzzle!\n",
    "response": "The problem asks us to find the smallest non-negative integer `k` such that `lcm(a+k, b+k)` is minimized. If there are multiple optimal `k` values, we choose the smallest one.\n\nLet `x = a+k` and `y = b+k`. We want to minimize `lcm(x, y)`.\nWe know `lcm(x, y) = (x * y) / gcd(x, y)`.\nLet `d = gcd(x, y)`.\nSince `d` divides both `x` and `y`, `d` must also divide their difference `y - x`.\n`y - x = (b+k) - (a+k) = b - a`.\nLet `diff = abs(b - a)`. Then `d` must be a divisor of `diff`.\n\n**Base Case:**\nIf `a = b`, then `diff = 0`. In this case, `lcm(a+k, b+k) = lcm(a+k, a+k) = a+k`. To minimize `a+k`, we should choose the smallest non-negative `k`, which is `k=0`. The `lcm` would be `a`.\n\n**General Case (a != b):**\nWe iterate through all possible values of `d`, which must be divisors of `diff`.\nFor each divisor `d` of `diff`:\n1. We need `a+k` to be a multiple of `d`, and `b+k` to be a multiple of `d`.\n   The condition `a+k \\equiv 0 \\pmod d` implies `k \\equiv -a \\pmod d`.\n   The smallest non-negative `k` satisfying this is `k_0 = (-a % d + d) % d`.\n2. With this `k_0`, let `x_0 = a+k_0` and `y_0 = b+k_0`.\n   We know `x_0` is a multiple of `d`.\n   Also, `y_0 = b+k_0 = (a+diff)+k_0 = (a+k_0)+diff = x_0+diff`.\n   Since `diff` is a multiple of `d` (because `d` is a divisor of `diff`), `y_0` is also a multiple of `d`.\n   So, `d` is a common divisor of `x_0` and `y_0`. Thus `gcd(x_0, y_0)` is at least `d`.\n3. We want `gcd(x, y)` to be exactly `d`.\n   `gcd(x, y) = gcd(x, y-x) = gcd(x, diff)`.\n   So we need `gcd(a+k, diff) = d`.\n   Let `a+k = d \\cdot M` and `diff = d \\cdot D`.\n   Then `gcd(d \\cdot M, d \\cdot D) = d \\cdot gcd(M, D)`.\n   For this to be `d`, we need `gcd(M, D) = 1`.\n   `M = (a+k)/d` and `D = diff/d`.\n   So, for a given `d`, we need to find the smallest `k \\ge 0` such that:\n   a. `k \\equiv -a \\pmod d`\n   b. `gcd((a+k)/d, diff/d) = 1`\n\nLet `k_0 = (-a % d + d) % d` be the smallest non-negative `k` satisfying condition (a).\nLet `M_0 = (a+k_0) // d` and `D_0 = diff // d`.\nWe need to find the smallest non-negative integer `j` such that `gcd(M_0 + j, D_0) = 1`.\nThe actual `k` value for this `d` will be `k_cand = k_0 + j*d`.\nThe corresponding `lcm` value will be `lcm(a+k_cand, b+k_cand) = ((a+k_cand) * (b+k_cand)) / d`.\nSubstituting `a+k_cand = d * (M_0+j)` and `b+k_cand = d * (M_0+j) + diff = d * (M_0+j) + d * D_0 = d * ((M_0+j) + D_0)`:\n`lcm = (d * (M_0+j) * d * ((M_0+j) + D_0)) / d = d * (M_0+j) * ((M_0+j) + D_0)`.\n\n**Algorithm:**\n1. Initialize `min_lcm = infinity` and `best_k = 0`.\n2. If `a == b`, print `0` and exit.\n3. Calculate `diff = abs(b-a)`.\n4. Find all divisors `d` of `diff`.\n   We can do this by iterating `i` from `1` up to `sqrt(diff)`. If `i` divides `diff`, then both `i` and `diff/i` are divisors.\n5. For each divisor `d` (including both `i` and `diff/i` from step 4):\n   a. Calculate `k_base = (-a % d + d) % d`. This is the smallest non-negative `k` such that `a+k` is a multiple of `d`.\n   b. Calculate `M_base = (a+k_base) // d` and `D_val = diff // d`.\n   c. Find the smallest non-negative `j` such that `gcd(M_base + j, D_val) = 1`.\n      To do this efficiently:\n      i. Get the distinct prime factors of `D_val`. Let them be `p_1, p_2, ..., p_s`.\n      ii. Iterate `j = 0, 1, 2, ...`. For each `j`, check if `M_base + j` is divisible by any `p_i`.\n         If `(M_base + j) % p_i != 0` for all `i=1...s`, then `gcd(M_base + j, D_val) = 1`.\n         A known result states that the maximum `j` we need to check is bounded by the largest prime factor of `D_val`. However, this bound can be large. A tighter bound for practical purposes is often `~2 * max_prime_factor(D_val)` or simply a small constant like `30000` (which is roughly `sqrt(10^9)`). For `D_val` up to `10^9`, the number of distinct prime factors is at most 9. The largest prime factor can be `10^9`.\n         However, the values of `j` are typically very small. For `D_val > 1`, `j` is often `0` or `1`. In the worst case, `j` could be `~30`. Let's iterate `j` up to a small constant like `200` to be safe. This should cover almost all cases.\n         (A more robust approach for finding `j` would be to use prime factors of `D_val`. If `D_val=1`, then `gcd(M_base+j, 1)=1` for any `j`, so `j=0` is optimal. If `D_val > 1`, get prime factors `P = {p_1, ..., p_s}`. Iterate `j=0, 1, ...`. For each `j`, check if `(M_base+j) % p_i == 0` for any `p_i \\in P`. If not, this `j` is valid. The maximum number of `j` values to check is small, practically usually less than 100.)\n   d. Calculate `current_k = k_base + j*d`.\n   e. Calculate `current_lcm = d * (M_base + j) * ((M_base + j) + D_val)`.\n   f. If `current_lcm < min_lcm`:\n      `min_lcm = current_lcm`\n      `best_k = current_k`\n   g. If `current_lcm == min_lcm` and `current_k < best_k`:\n      `best_k = current_k`\n6. Print `best_k`.\n\n**Example walk-through: a=6, b=10**\n1. `diff = abs(10-6) = 4`.\n2. Divisors of `4`: `1, 2, 4`.\n3. Initialize `min_lcm = infinity`, `best_k = 0`.\n\n**Case d = 1:**\n   a. `k_base = (-6 % 1 + 1) % 1 = 0`.\n   b. `M_base = (6+0)//1 = 6`. `D_val = 4//1 = 4`.\n   c. Prime factors of `D_val=4`: `{2}`.\n      `j=0`: `M_base+j = 6`. `6 % 2 == 0`. Not coprime.\n      `j=1`: `M_base+j = 7`. `7 % 2 != 0`. Coprime. Smallest `j=1`.\n   d. `current_k = k_base + j*d = 0 + 1*1 = 1`.\n   e. `current_lcm = 1 * (6+1) * ((6+1)+4) = 1 * 7 * 11 = 77`.\n   f. `min_lcm = 77`, `best_k = 1`.\n\n**Case d = 2:**\n   a. `k_base = (-6 % 2 + 2) % 2 = 0`.\n   b. `M_base = (6+0)//2 = 3`. `D_val = 4//2 = 2`.\n   c. Prime factors of `D_val=2`: `{2}`.\n      `j=0`: `M_base+j = 3`. `3 % 2 != 0`. Coprime. Smallest `j=0`.\n   d. `current_k = k_base + j*d = 0 + 0*2 = 0`.\n   e. `current_lcm = 2 * (3+0) * ((3+0)+2) = 2 * 3 * 5 = 30`.\n   f. `current_lcm=30 < min_lcm=77`. Update `min_lcm = 30`, `best_k = 0`.\n\n**Case d = 4:**\n   a. `k_base = (-6 % 4 + 4) % 4 = 2`. (`-6 \\equiv 2 \\pmod 4`).\n   b. `M_base = (6+2)//4 = 2`. `D_val = 4//4 = 1`.\n   c. Prime factors of `D_val=1`: `{}` (empty set). Any integer is coprime to 1.\n      `j=0`: `M_base+j = 2`. `gcd(2,1)=1`. Coprime. Smallest `j=0`.\n   d. `current_k = k_base + j*d = 2 + 0*4 = 2`.\n   e. `current_lcm = 4 * (2+0) * ((2+0)+1) = 4 * 2 * 3 = 24`.\n   f. `current_lcm=24 < min_lcm=30`. Update `min_lcm = 24`, `best_k = 2`.\n\nFinal result: `best_k = 2`. This matches the example.\n\n**Constraints:** `a, b <= 10^9`.\n`diff` can be up to `10^9`.\nNumber of divisors of `diff` can be up to `~1344` for numbers around `10^9`.\nFor each divisor `d`:\n  - `k_base`, `M_base`, `D_val` calculation is `O(1)`.\n  - Finding prime factors of `D_val`: `get_prime_factors(D_val)` takes `O(sqrt(D_val))` time in worst case. `sqrt(10^9) approx 31622`. This will be too slow if done for every `d`.\n    Optimization: `D_val = diff // d`. We only need prime factors of `diff` (which can be precomputed once) to check for `D_val`.\n    Let `P_diff` be the distinct prime factors of `diff`. Then `P_D_val` is a subset of `P_diff`.\n    `get_prime_factors(diff)` once: `O(sqrt(diff))`.\n    The number of distinct prime factors of `diff` is at most 9.\n  - Iterating `j`: We iterate `j=0, 1, ...` and check `M_base+j` against the prime factors of `D_val`.\n    The maximum `j` to check is small. For `D_val` up to `10^9`, the largest prime factor can be `10^9`. However, the practical bound for `j` is much smaller. A safe upper bound for `j` is around `200` for competitive programming. `200 * 9` operations is fast.\nTotal time complexity: `O(sqrt(diff) + tau(diff) * (log(diff) + J * S))`, where `J` is the max `j` (e.g., 200), `S` is max number of distinct prime factors (9). This is efficient enough.\n\n```python\nimport math\n\n# Function to calculate GCD\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\n# Function to find distinct prime factors of a number\ndef get_distinct_prime_factors(n):\n    factors = set()\n    d = 2\n    temp = n\n    while d * d <= temp:\n        if temp % d == 0:\n            factors.add(d)\n            while temp % d == 0:\n                temp //= d\n        d += 1\n    if temp > 1:\n        factors.add(temp)\n    return list(factors)\n\ndef solve():\n    a, b = map(int, input().split())\n\n    if a == b:\n        print(0)\n        return\n\n    diff = abs(b - a)\n\n    # Find all divisors of diff\n    divisors = set()\n    for i in range(1, int(math.sqrt(diff)) + 1):\n        if diff % i == 0:\n            divisors.add(i)\n            divisors.add(diff // i)\n    \n    # Precompute distinct prime factors of diff.\n    # This helps in quickly checking gcd(M_base + j, D_val) = 1.\n    # Note: D_val = diff // d, so its prime factors are a subset of diff's prime factors.\n    prime_factors_of_diff = get_distinct_prime_factors(diff)\n\n    min_lcm = float('inf')\n    best_k = 0\n\n    for d in divisors:\n        # k_base is the smallest non-negative k such that a+k is a multiple of d\n        # a+k = m*d => k = m*d - a\n        # k >= 0 => m*d >= a\n        # Smallest m*d >= a is ceil(a/d)*d.\n        # So a+k_base = ((a + d - 1) // d) * d\n        # k_base = ((a + d - 1) // d) * d - a\n        # Or simply, k_base = (-a % d + d) % d\n        k_base = (d - (a % d)) % d # This handles a % d == 0 correctly too\n\n        M_base = (a + k_base) // d\n        D_val = diff // d\n\n        # Find smallest j >= 0 such that gcd(M_base + j, D_val) == 1\n        j = 0\n        \n        # Optimization: if D_val is 1, gcd is always 1, so j=0\n        if D_val == 1:\n            j = 0\n        else:\n            # We need to check if M_base + j is coprime to D_val.\n            # It's enough to check divisibility by prime factors of D_val.\n            # Prime factors of D_val are a subset of prime_factors_of_diff.\n            # Filter prime factors of diff to only include those that divide D_val.\n            current_D_val_prime_factors = [p for p in prime_factors_of_diff if D_val % p == 0]\n\n            while True:\n                is_coprime = True\n                for p in current_D_val_prime_factors:\n                    if (M_base + j) % p == 0:\n                        is_coprime = False\n                        break\n                if is_coprime:\n                    break\n                j += 1\n                # A practical upper bound for j to prevent infinite loops in edge cases\n                # The maximum gap between numbers coprime to N is related to its largest prime factor.\n                # For numbers up to 10^9, this can be large, but for typical cases, j is small.\n                # A safe practical limit for j in competitive programming is often around 100-200.\n                # If j exceeds this, it's likely an issue with the bound or the problem structure.\n                # But typically, it's very small (0 or 1 for most cases).\n                if j > 200: # Heuristic bound\n                    # This case should ideally not be reached if the problem guarantees a solution\n                    # within reasonable j. If it is reached, it implies a very large gap\n                    # or an error in logic. For competitive programming, this bound is usually safe.\n                    # For this problem, max j is indeed small.\n                    break \n\n        current_k = k_base + j * d\n        \n        # Calculate LCM: d * (M_base + j) * ((M_base + j) + D_val)\n        val1 = M_base + j\n        val2 = val1 + D_val\n        current_lcm = d * val1 * val2\n\n        # Update min_lcm and best_k\n        if current_lcm < min_lcm:\n            min_lcm = current_lcm\n            best_k = current_k\n        elif current_lcm == min_lcm:\n            best_k = min(best_k, current_k)\n\n    print(best_k)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\n# Function to calculate GCD\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\n# Function to find distinct prime factors of a number\ndef get_distinct_prime_factors(n):\n    factors = set()\n    d = 2\n    temp = n\n    while d * d <= temp:\n        if temp % d == 0:\n            factors.add(d)\n            while temp % d == 0:\n                temp //= d\n        d += 1\n    if temp > 1:\n        factors.add(temp)\n    return list(factors)\n\ndef solve():\n    a, b = map(int, input().split())\n\n    if a == b:\n        print(0)\n        return\n\n    diff = abs(b - a)\n\n    # Find all divisors of diff\n    divisors = set()\n    for i in range(1, int(math.sqrt(diff)) + 1):\n        if diff % i == 0:\n            divisors.add(i)\n            divisors.add(diff // i)\n    \n    # Precompute distinct prime factors of diff.\n    # This helps in quickly checking gcd(M_base + j, D_val) = 1.\n    # Note: D_val = diff // d, so its prime factors are a subset of diff's prime factors.\n    prime_factors_of_diff = get_distinct_prime_factors(diff)\n\n    min_lcm = float('inf')\n    best_k = 0\n\n    for d in divisors:\n        # k_base is the smallest non-negative k such that a+k is a multiple of d\n        # a+k = m*d => k = m*d - a\n        # k >= 0 => m*d >= a\n        # Smallest m*d >= a is ceil(a/d)*d.\n        # So a+k_base = ((a + d - 1) // d) * d\n        # k_base = ((a + d - 1) // d) * d - a\n        # Or simply, k_base = (-a % d + d) % d\n        k_base = (d - (a % d)) % d # This handles a % d == 0 correctly too\n\n        M_base = (a + k_base) // d\n        D_val = diff // d\n\n        # Find smallest j >= 0 such that gcd(M_base + j, D_val) == 1\n        j = 0\n        \n        # Optimization: if D_val is 1, gcd is always 1, so j=0\n        if D_val == 1:\n            j = 0\n        else:\n            # We need to check if M_base + j is coprime to D_val.\n            # It's enough to check divisibility by prime factors of D_val.\n            # Prime factors of D_val are a subset of prime_factors_of_diff.\n            # Filter prime factors of diff to only include those that divide D_val.\n            current_D_val_prime_factors = [p for p in prime_factors_of_diff if D_val % p == 0]\n\n            while True:\n                is_coprime = True\n                for p in current_D_val_prime_factors:\n                    if (M_base + j) % p == 0:\n                        is_coprime = False\n                        break\n                if is_coprime:\n                    break\n                j += 1\n                # A practical upper bound for j to prevent infinite loops in edge cases\n                # The maximum gap between numbers coprime to N is related to its largest prime factor.\n                # For numbers up to 10^9, this can be large, but for typical cases, j is small.\n                # A safe practical limit for j in competitive programming is often around 100-200.\n                # If j exceeds this, it's likely an issue with the bound or the problem structure.\n                # But typically, it's very small (0 or 1 for most cases).\n                if j > 200: # Heuristic bound\n                    # This case should ideally not be reached if the problem guarantees a solution\n                    # within reasonable j. If it is reached, it implies a very large gap\n                    # or an error in logic. For competitive programming, this bound is usually safe.\n                    # For this problem, max j is indeed small.\n                    break \n\n        current_k = k_base + j * d\n        \n        # Calculate LCM: d * (M_base + j) * ((M_base + j) + D_val)\n        val1 = M_base + j\n        val2 = val1 + D_val\n        current_lcm = d * val1 * val2\n\n        # Update min_lcm and best_k\n        if current_lcm < min_lcm:\n            min_lcm = current_lcm\n            best_k = current_k\n        elif current_lcm == min_lcm:\n            best_k = min(best_k, current_k)\n\n    print(best_k)\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 421,
        "completion_token_count": 4402,
        "thoughts_token_count": 6775
    }
}