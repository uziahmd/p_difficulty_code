{
    "start": 1758293690.9382145,
    "end": 1758293709.305399,
    "start-formatted": "2025-09-19 23:54 KST",
    "end-formatted": "2025-09-19 23:55 KST",
    "gpu": 2,
    "pid": 57,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Olympiad\n\nA boy named Vasya has taken part in an Olympiad. His teacher knows that in total Vasya got at least x points for both tours of the Olympiad. The teacher has the results of the first and the second tour of the Olympiad but the problem is, the results have only points, no names. The teacher has to know Vasya's chances.Help Vasya's teacher, find two numbers — the best and the worst place Vasya could have won. Note that the total results' table sorts the participants by the sum of points for both tours (the first place has the participant who has got the most points). If two or more participants have got the same number of points, it's up to the jury to assign places to them according to their choice. It is guaranteed that each participant of the Olympiad participated in both tours of the Olympiad.\n\n## Input\nThe first line contains two space-separated integers n, x (1 ≤ n ≤ 105; 0 ≤ x ≤ 2·105) — the number of Olympiad participants and the minimum number of points Vasya earned.The second line contains n space-separated integers: a1, a2, ..., an (0 ≤ ai ≤ 105) — the participants' points in the first tour.The third line contains n space-separated integers: b1, b2, ..., bn (0 ≤ bi ≤ 105) — the participants' points in the second tour.The participants' points are given in the arbitrary order. It is guaranteed that Vasya was present in the Olympiad — there are two integers i, j (1 ≤ i, j ≤ n) such, that ai + bj ≥ x.\n\n## Output\nPrint two space-separated integers — the best and the worst place Vasya could have got on the Olympiad.\n\n## Example\n### Input\n['5 2\\n1 1 1 1 1\\n1 1 1 1 1', '6 7\\n4 3 5 6 4 4\\n8 6 0 4 3 4']\n\n### Output\n['1 5', '1 5']\n\n## Note\nIn the first text sample all 5 participants earn 2 points each in any case. Depending on the jury's decision, Vasya can get the first (the best) as well as the last (the worst) fifth place.In the second test sample in the best case scenario Vasya wins again: he can win 12 points and become the absolute winner if the total results' table looks like that — {4:8, 6:4, 3:6, 4:4, 4:3, 5:0}.In this table all participants are sorted by decreasing points and we can see how much a participant earned in the first and in the second tour.In the worst case scenario Vasya can get the fifth place if the table looks like that — {4:8, 4:6, 6:4, 5:4, 4:3, 3:0}, and he earned 4 and 3 points in the first and second tours, correspondingly.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "",
    "response": "```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    a.sort()\n    b.sort()\n\n    # Calculate best possible rank\n    # To get the best rank, Vasya wants to maximize his score\n    # and minimize scores of others.\n    # Vasya takes the highest possible score he can get (a[i] + b[j] >= x).\n    # Other participants are assigned pairs to minimize their scores,\n    # specifically to maximize the number of people Vasya can beat.\n\n    # Vasya's best score: Find the maximum a_i + b_j >= x.\n    # The problem guarantees such a pair exists.\n    # Since we only need to count people with strictly higher scores,\n    # Vasya's exact maximum score doesn't matter as much as\n    # how many people can achieve a higher score.\n    # To find the best rank, we want to maximize Vasya's score.\n    # Vasya can pick any a_i and any b_j such that a_i + b_j >= x.\n    # The highest possible score is a[n-1] + b[n-1].\n    # Let Vasya's score be V_score.\n    # Vasya's best rank is 1 + (number of participants who can achieve > V_score).\n    # If Vasya gets the maximum possible score (a[n-1] + b[n-1]),\n    # then no one can get a higher score. So his rank is 1.\n    # This is true because if Vasya can achieve a[n-1] + b[n-1] and it's >= x,\n    # then he is guaranteed to be 1st.\n    # The problem statement: \"the first place has the participant who has got the most points\".\n    # If multiple people have the same max score, Vasya can be 1st.\n    # So, the best rank is always 1.\n    best_rank = 1\n\n    # Calculate worst possible rank\n    # To get the worst rank, Vasya wants to minimize his score (while >= x)\n    # and maximize scores of others.\n    # Vasya takes the smallest possible score he can get (a_i + b_j >= x).\n    # Other participants are assigned pairs to maximize their scores.\n    # We need to count how many participants can achieve a score >= Vasya's score.\n\n    # The strategy for worst rank:\n    # 1. Vasya gets some score S_V (a_i + b_j >= x).\n    # 2. The remaining n-1 'a' values and n-1 'b' values are paired up to maximize their scores.\n    # 3. We count how many people can get a score strictly greater than S_V,\n    #    and how many can get a score equal to S_V.\n    #    Vasya's worst rank = 1 + (count of people with score > S_V) + (count of people with score == S_V).\n\n    # This is tricky because Vasya's score S_V depends on which a_i and b_j he takes,\n    # and these choices affect the remaining pools for others.\n    # A simpler approach for the worst rank:\n    # Vasya is one of the participants.\n    # We want to find the maximum number of participants who can achieve a score >= Vasya's chosen score S_V.\n    # Vasya's chosen score S_V must be >= x.\n    #\n    # Let's consider a fixed score S_k. How many participants can achieve at least S_k?\n    # To maximize this count, we use a greedy approach.\n    # Sort 'a' in ascending order and 'b' in ascending order.\n    # Iterate through 'a' from largest to smallest (a[n-1] down to a[0]).\n    # For each a[i], find the smallest b[j] such that a[i] + b[j] >= S_k.\n    # This is a two-pointer approach.\n    #\n    # We are looking for the maximum possible rank. This means we want to maximize the number of people\n    # who can get a score at least as good as Vasya's.\n    # Let's count how many pairs (a_i, b_j) can be formed such that a_i + b_j >= x.\n    # This count will be the maximum possible number of people who can satisfy the condition.\n    #\n    # To count the maximum number of pairs (a_i, b_j) such that a_i + b_j >= x:\n    # Sort 'a' in ascending order. Sort 'b' in descending order.\n    # Use two pointers: `ptr_a` for `a` (from left) and `ptr_b` for `b` (from left).\n    # If a[ptr_a] + b[ptr_b] >= x, then we can form a valid pair. Increment count, move both pointers.\n    # If a[ptr_a] + b[ptr_b] < x, then a[ptr_a] is too small to pair with b[ptr_b].\n    # To potentially satisfy the condition, we must increase a[ptr_a]. So, increment ptr_a.\n    # This approach counts the maximum number of *disjoint* pairs.\n\n    # Example: a = [1, 2, 3], b = [4, 5, 6], x = 7\n    # a_sorted = [1, 2, 3]\n    # b_sorted_desc = [6, 5, 4]\n    # ptr_a = 0, ptr_b = 0, count = 0\n    # a[0] + b[0] = 1 + 6 = 7 >= 7. count = 1. ptr_a = 1, ptr_b = 1.\n    # a[1] + b[1] = 2 + 5 = 7 >= 7. count = 2. ptr_a = 2, ptr_b = 2.\n    # a[2] + b[2] = 3 + 4 = 7 >= 7. count = 3. ptr_a = 3, ptr_b = 3.\n    # Loop ends. Max count = 3.\n\n    # This count represents the maximum number of participants who can achieve a total score >= x.\n    # Vasya is one of these participants.\n    # If there are `k` such pairs, it means `k` participants can potentially achieve a score >= x.\n    # If Vasya is one of them, and all `k` participants get scores >= x,\n    # and the remaining `n-k` participants get scores < x,\n    # then Vasya could be ranked `k`.\n    # This is the maximum possible rank Vasya could get, because at most `k` people can satisfy the condition.\n\n    a_copy = sorted(a)\n    b_copy = sorted(b, reverse=True)\n\n    ptr_a = 0\n    ptr_b = 0\n    count_valid_pairs = 0\n\n    while ptr_a < n and ptr_b < n:\n        if a_copy[ptr_a] + b_copy[ptr_b] >= x:\n            count_valid_pairs += 1\n            ptr_a += 1\n            ptr_b += 1\n        else:\n            # a_copy[ptr_a] is too small with b_copy[ptr_b].\n            # Since b_copy is sorted descending, b_copy[ptr_b] is the largest available b for a_copy[ptr_a].\n            # If a_copy[ptr_a] + b_copy[ptr_b] < x, then a_copy[ptr_a] cannot form a valid pair with any remaining b_copy values.\n            # No, this logic is incorrect. We need to find *some* b_j for a_i.\n            # If a_copy[ptr_a] + b_copy[ptr_b] < x, it means a_copy[ptr_a] is too small to pair with b_copy[ptr_b].\n            # We should try a larger 'a' value. So increment ptr_a.\n            # This is correct for maximizing pairs.\n            ptr_a += 1\n\n    worst_rank = count_valid_pairs\n\n    sys.stdout.write(f\"{best_rank} {worst_rank}\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    a.sort()\n    b.sort()\n\n    # Calculate best possible rank\n    # To get the best rank, Vasya wants to maximize his score\n    # and minimize scores of others.\n    # Vasya takes the highest possible score he can get (a[i] + b[j] >= x).\n    # Other participants are assigned pairs to minimize their scores,\n    # specifically to maximize the number of people Vasya can beat.\n\n    # Vasya's best score: Find the maximum a_i + b_j >= x.\n    # The problem guarantees such a pair exists.\n    # Since we only need to count people with strictly higher scores,\n    # Vasya's exact maximum score doesn't matter as much as\n    # how many people can achieve a higher score.\n    # To find the best rank, we want to maximize Vasya's score.\n    # Vasya can pick any a_i and any b_j such that a_i + b_j >= x.\n    # The highest possible score is a[n-1] + b[n-1].\n    # Let Vasya's score be V_score.\n    # Vasya's best rank is 1 + (number of participants who can achieve > V_score).\n    # If Vasya gets the maximum possible score (a[n-1] + b[n-1]),\n    # then no one can get a higher score. So his rank is 1.\n    # This is true because if Vasya can achieve a[n-1] + b[n-1] and it's >= x,\n    # then he is guaranteed to be 1st.\n    # The problem statement: \"the first place has the participant who has got the most points\".\n    # If multiple people have the same max score, Vasya can be 1st.\n    # So, the best rank is always 1.\n    best_rank = 1\n\n    # Calculate worst possible rank\n    # To get the worst rank, Vasya wants to minimize his score (while >= x)\n    # and maximize scores of others.\n    # Vasya takes the smallest possible score he can get (a_i + b_j >= x).\n    # Other participants are assigned pairs to maximize their scores.\n    # We need to count how many participants can achieve a score >= Vasya's score.\n\n    # The strategy for worst rank:\n    # 1. Vasya gets some score S_V (a_i + b_j >= x).\n    # 2. The remaining n-1 'a' values and n-1 'b' values are paired up to maximize their scores.\n    # 3. We count how many people can get a score strictly greater than S_V,\n    #    and how many can get a score equal to S_V.\n    #    Vasya's worst rank = 1 + (count of people with score > S_V) + (count of people with score == S_V).\n\n    # This is tricky because Vasya's score S_V depends on which a_i and b_j he takes,\n    # and these choices affect the remaining pools for others.\n    # A simpler approach for the worst rank:\n    # Vasya is one of the participants.\n    # We want to find the maximum number of participants who can achieve a score >= Vasya's chosen score S_V.\n    # Vasya's chosen score S_V must be >= x.\n    #\n    # Let's consider a fixed score S_k. How many participants can achieve at least S_k?\n    # To maximize this count, we use a greedy approach.\n    # Sort 'a' in ascending order and 'b' in ascending order.\n    # Iterate through 'a' from largest to smallest (a[n-1] down to a[0]).\n    # For each a[i], find the smallest b[j] such that a[i] + b[j] >= S_k.\n    # This is a two-pointer approach.\n    #\n    # We are looking for the maximum possible rank. This means we want to maximize the number of people\n    # who can get a score at least as good as Vasya's.\n    # Let's count how many pairs (a_i, b_j) can be formed such that a_i + b_j >= x.\n    # This count will be the maximum possible number of people who can satisfy the condition.\n    #\n    # To count the maximum number of pairs (a_i, b_j) such that a_i + b_j >= x:\n    # Sort 'a' in ascending order. Sort 'b' in descending order.\n    # Use two pointers: `ptr_a` for `a` (from left) and `ptr_b` for `b` (from left).\n    # If a[ptr_a] + b[ptr_b] >= x, then we can form a valid pair. Increment count, move both pointers.\n    # If a[ptr_a] + b[ptr_b] < x, then a[ptr_a] is too small to pair with b[ptr_b].\n    # To potentially satisfy the condition, we must increase a[ptr_a]. So, increment ptr_a.\n    # This approach counts the maximum number of *disjoint* pairs.\n\n    # Example: a = [1, 2, 3], b = [4, 5, 6], x = 7\n    # a_sorted = [1, 2, 3]\n    # b_sorted_desc = [6, 5, 4]\n    # ptr_a = 0, ptr_b = 0, count = 0\n    # a[0] + b[0] = 1 + 6 = 7 >= 7. count = 1. ptr_a = 1, ptr_b = 1.\n    # a[1] + b[1] = 2 + 5 = 7 >= 7. count = 2. ptr_a = 2, ptr_b = 2.\n    # a[2] + b[2] = 3 + 4 = 7 >= 7. count = 3. ptr_a = 3, ptr_b = 3.\n    # Loop ends. Max count = 3.\n\n    # This count represents the maximum number of participants who can achieve a total score >= x.\n    # Vasya is one of these participants.\n    # If there are `k` such pairs, it means `k` participants can potentially achieve a score >= x.\n    # If Vasya is one of them, and all `k` participants get scores >= x,\n    # and the remaining `n-k` participants get scores < x,\n    # then Vasya could be ranked `k`.\n    # This is the maximum possible rank Vasya could get, because at most `k` people can satisfy the condition.\n\n    a_copy = sorted(a)\n    b_copy = sorted(b, reverse=True)\n\n    ptr_a = 0\n    ptr_b = 0\n    count_valid_pairs = 0\n\n    while ptr_a < n and ptr_b < n:\n        if a_copy[ptr_a] + b_copy[ptr_b] >= x:\n            count_valid_pairs += 1\n            ptr_a += 1\n            ptr_b += 1\n        else:\n            # a_copy[ptr_a] is too small with b_copy[ptr_b].\n            # Since b_copy is sorted descending, b_copy[ptr_b] is the largest available b for a_copy[ptr_a].\n            # If a_copy[ptr_a] + b_copy[ptr_b] < x, then a_copy[ptr_a] cannot form a valid pair with any remaining b_copy values.\n            # No, this logic is incorrect. We need to find *some* b_j for a_i.\n            # If a_copy[ptr_a] + b_copy[ptr_b] < x, it means a_copy[ptr_a] is too small to pair with b_copy[ptr_b].\n            # We should try a larger 'a' value. So increment ptr_a.\n            # This is correct for maximizing pairs.\n            ptr_a += 1\n\n    worst_rank = count_valid_pairs\n\n    sys.stdout.write(f\"{best_rank} {worst_rank}\\n\")\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 873,
        "completion_token_count": 1998,
        "thoughts_token_count": 0
    }
}