{
    "start": 1758011924.0303712,
    "end": 1758012014.0341244,
    "start-formatted": "2025-09-16 17:38 KST",
    "end-formatted": "2025-09-16 17:40 KST",
    "gpu": 2,
    "pid": 8,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "**Initial Thoughts on \"Flawed Flow\" Problem**\n\nOkay, so I've got this \"Flawed Flow\" problem, and I need a Python solution. The core of this problem seems to be about directing flows on a graph while ensuring flow conservation at internal nodes, acyclicity, and satisfying source/sink conditions. I'm thinking, this hints strongly towards a flow network structure, but the acyclicity constraint is a key twist. It implies a topological ordering is crucial.\n\n**Problem Breakdown & Key Constraints:**\n\nThe input gives us a graph with undirected edges, each with a flow capacity. The goal is to orient these edges, so the directed graph meets these conditions:\n*   **Flow conservation:** At internal vertices, the total incoming flow equals the total outgoing flow.\n*   **Source:** Vertex 1 has only outgoing edges (no incoming flow).\n*   **Sink:** Vertex n has only incoming edges (no outgoing flow).\n*   **Acyclicity:** The resulting directed graph contains no cycles.\n\nThe constraints on `n` and `m` (up to 2 \\* 10^5) suggest an O(N + M) or O((N + M)log(N + M)) solution. I need to avoid O(N^2) or O(N \\* M) complexity.\n\n**Thinking Through the Solution Approach:**\n\nA key insight is that the acyclicity condition implies a topological ordering. If I can find a topological ordering, I can likely direct the edges from earlier nodes in the order to later nodes, guaranteeing acyclicity. The flow conservation at internal nodes is critical, and I think I'll need to keep track of flow balances or imbalances at each node.\n\n**Potential Strategies:**\n\n*   **Topological Sort-based Approach:**  Since the graph must be acyclic, a topological sort sounds promising. The idea is to find a valid ordering of nodes (1,2,..,n) and direct edges in the order such as `i < j`. I'll need to somehow ensure the flow balance is met at internal nodes in this process.\n*   **Greedy Approach with Balance Management:** Maintain a \"balance\" value for each node, representing the difference between incoming and outgoing flow. At each step, direct an edge to bring a node's balance closer to 0 (for internal nodes). This approach feels a bit delicate, especially with acyclicity.\n*   **DFS/BFS Traversal:** Maybe a DFS or BFS from the source (vertex 1) could help. However, I need to be *very* careful to avoid cycles.\n\n**Key Questions and Challenges:**\n\n*   How to efficiently determine the direction of each edge while ensuring acyclicity?\n*   How to manage the flow balance at each node effectively?\n*   The hint that a solution always exists suggests a hidden structure that I can exploit.\n\n**Going Deeper:**\n\nI should focus on maintaining a `net_flow` balance at each vertex: `in_flow - out_flow`. I need to make this equal to 0 for internal nodes, less than 0 for vertex 1, and greater than 0 for vertex `n`. The key insight is that the sum of the total capacity for an internal node must be an even number. I need a process to \"balance\" nodes.\n\nThe guaranteed solution might come from ensuring nodes have even capacity, and directing flow so that incoming edges' capacities equal the sum of outgoing ones. I'm going to test some sort of queue to direct edges. A topological sort seems more efficient here.\n",
    "response": "The problem asks us to direct each edge $(a_i, b_i)$ with a given flow volume $c_i$ such that:\n1. For any internal vertex $v$ ($1 < v < n$), the sum of incoming flow volumes equals the sum of outgoing flow volumes.\n2. Vertex 1 (source) has no incoming edges.\n3. The resulting directed graph has no cycles.\n\nWe are guaranteed that a solution always exists.\n\nLet's define `current_balance[v]` for each vertex $v$ as the sum of incoming flow volumes minus the sum of outgoing flow volumes.\nThe conditions translate to:\n1. `current_balance[v] = 0` for $1 < v < n$.\n2. `current_balance[1] < 0` (all flow leaves 1, so incoming flow is 0, outgoing is positive).\n3. `current_balance[n] > 0` (all flow enters n, so incoming flow is positive, outgoing is 0).\n\nThe acyclicity condition is crucial. A common way to ensure acyclicity in flow problems is to process nodes in a topological order or a reverse topological order. Since we don't have a fixed direction for edges yet, we can't directly compute a topological sort. However, the problem structure (source 1, sink n, internal nodes balancing flow) suggests that a traversal from either source or sink, or a process that resolves nodes' balances, might work.\n\nConsider the total flow `F` from source to sink.\nFor vertex 1, all its incident edges must be directed away from it. So, `current_balance[1]` will be `- (sum of all c_i incident to 1)`. Let this sum be `S_1`. So `current_balance[1] = -S_1`. Thus, `F = S_1`.\nFor vertex n, all its incident edges must be directed towards it. So, `current_balance[n]` will be `+ (sum of all c_i incident to n)`. Let this sum be `S_n`. So `current_balance[n] = S_n`. Thus, `F = S_n`.\nThis implies `S_1 = S_n = F`.\n\nFor any internal vertex $v$ ($1 < v < n$), let `S_v` be the sum of flow volumes of all edges incident to $v$. We need `incoming_flow[v] = outgoing_flow[v]`. Since `incoming_flow[v] + outgoing_flow[v] = S_v`, this implies `2 * incoming_flow[v] = S_v`. Therefore, `S_v` must be an even number, and `incoming_flow[v] = outgoing_flow[v] = S_v / 2`.\n\nThis suggests a strategy:\nWe want to achieve `current_balance[v] = S_v / 2` (as incoming flow) for $1 < v < n$.\nFor $v=1$, we want `current_balance[1] = 0` (as incoming flow, effectively means 0 incoming).\nFor $v=n$, we want `current_balance[n] = S_n` (as incoming flow, effectively means all incident flow is incoming).\n\nLet's maintain `current_incoming_flow[v]` for each vertex $v$, initialized to 0.\nWhen we direct an edge $(u, v)$ with flow $c$ as $u \\to v$:\n- `current_incoming_flow[v]` increases by $c$.\n- `current_incoming_flow[u]` is unaffected (since it's an outgoing edge for $u$).\nWe need to reach `current_incoming_flow[v] = S_v / 2` for $1 < v < n$, `current_incoming_flow[1] = 0`, and `current_incoming_flow[n] = S_n$.\n\nThe acyclicity condition is satisfied by a specific type of traversal. We can use a queue (like in Kahn's algorithm for topological sort) to process vertices.\nInitialize `current_incoming_flow[v] = 0` for all $v$.\nInitialize `ans[edge_idx]` to -1 (undecided direction).\nStore edges in an adjacency list `adj[v]` as `(neighbor, flow_c, edge_idx)`.\nAlso, store the total incident flow `S_v` for each vertex $v$.\n\nThe algorithm:\n1. Initialize `current_incoming_flow[v] = 0` for all $v$.\n2. Initialize `ans` array to store directions (0 for $a_i \\to b_i$, 1 for $b_i \\to a_i$).\n3. Create a queue `Q`. Add vertex $n$ (the sink) to `Q`. This is because we want all flow into $n$, so we will process edges incident to $n$ to direct them towards $n$.\n4. While `Q` is not empty:\n   a. Dequeue a vertex `u`.\n   b. Iterate through all edges `(u, v)` with flow `c` (original edge index `idx`) that are still undirected (`ans[idx] == -1`):\n      i. If `u` is the source (vertex 1): All edges from `u` must be outgoing. So, direct `u -> v`. Set `ans[idx] = 0` if original edge was `(u, v)`, or `ans[idx] = 1` if original edge was `(v, u)`. Update `current_incoming_flow[v] += c`. If `v` is an internal node (`1 < v < n`) and `current_incoming_flow[v]` has now reached `S_v / 2`, enqueue `v`.\n      ii. If `u` is the sink (vertex n): All edges to `u` must be incoming. So, direct `v -> u`. Set `ans[idx] = 0` if original edge was `(v, u)`, or `ans[idx] = 1` if original edge was `(u, v)`. Update `current_incoming_flow[u] += c`. (Note: $n$ is special, its `current_incoming_flow` will accumulate up to `S_n`). If `v` is an internal node (`1 < v < n`) and `current_incoming_flow[v]` has now reached `S_v / 2`, enqueue `v`.\n      iii. If `u` is an internal vertex (`1 < u < n`):\n          If `current_incoming_flow[u] < S_u / 2`: We need more incoming flow for `u`. Direct `v -> u`. Set `ans[idx] = 0` if original edge was `(v, u)`, or `ans[idx] = 1` if original edge was `(u, v)`. Update `current_incoming_flow[u] += c`. If `current_incoming_flow[u]` now reaches `S_u / 2`, enqueue `u`.\n          If `current_incoming_flow[u] == S_u / 2`: We have enough incoming flow for `u`. All remaining undirected edges incident to `u` must be outgoing. Direct `u -> v`. Set `ans[idx] = 0` if original edge was `(u, v)`, or `ans[idx] = 1` if original edge was `(v, u)`. Update `current_incoming_flow[v] += c`. If `v` is an internal node (`1 < v < n`) and `current_incoming_flow[v]` has now reached `S_v / 2`, enqueue `v`.\n\nThis logic is a bit complex due to the two-way nature of edges and how `ans` is stored. A simpler approach for internal nodes:\nFor internal nodes `v` ($1 < v < n$), we need `incoming_flow[v] = S_v / 2`.\nWe can use a queue of nodes that are \"ready\" to be processed. A node `v` is ready if its `current_incoming_flow[v]` has reached `S_v / 2`.\nStart the queue with node `1` (source). Node 1 needs 0 incoming flow, which it already has.\nWhen we process `u` from the queue:\n  For every undirected edge `(u, v)` with flow `c` (original index `idx`):\n    We must direct `u -> v`. Set `ans[idx]` to 0 if original edge was `(u, v)`, or 1 if original edge was `(v, u)`.\n    Update `current_incoming_flow[v] += c`.\n    If `v` is an internal node (`1 < v < n`) and `current_incoming_flow[v] == S_v / 2`, enqueue `v`.\n\nThis ensures that all edges from a processed node `u` are directed outwards. This naturally creates a DAG because we essentially perform a traversal where nodes are processed once their incoming flow requirement (0 for source, `S_v/2` for internal) is met. The sink `n` will naturally accumulate all its `S_n` incoming flow.\n\nLet's refine the algorithm with this simpler logic:\n1. Read $N, M$. Store edges as `(u, v, c, original_idx)` in an adjacency list `adj`.\n2. Calculate `S_v` (total flow incident to $v$) for all $v$.\n3. Initialize `current_incoming_flow[v] = 0` for all $v$.\n4. Initialize `ans[original_idx]` array of size `M` to store directions.\n5. Create a queue `Q`.\n6. Enqueue vertex 1 (source). `current_incoming_flow[1]` is already 0, which is its requirement.\n7. While `Q` is not empty:\n   a. Dequeue vertex `u`.\n   b. Iterate through all neighbors `v` of `u` via an edge `(u, v)` with flow `c` and original index `idx`.\n      i. If `ans[idx]` is already set (meaning this edge was directed when processing `v`), skip it.\n      ii. Otherwise, direct the edge `u -> v`.\n          If the original edge was `(u, v)`, set `ans[idx] = 0`.\n          If the original edge was `(v, u)`, set `ans[idx] = 1`.\n          (The direction `u -> v` means `u` is the source of flow, `v` is the destination).\n      iii. Update `current_incoming_flow[v] += c`.\n      iv. If `v` is an internal node (`1 < v < n`) and `current_incoming_flow[v] == S_v / 2`, enqueue `v`.\n\nThis algorithm ensures:\n- Node 1 has no incoming edges because it's the first node enqueued and all edges incident to it are directed outwards.\n- Internal nodes `v` ($1 < v < n$) will have `current_incoming_flow[v] = S_v / 2` by the time they are enqueued. Any edges processed from `v` will be directed outwards, ensuring `outgoing_flow[v] = S_v / 2`. Thus, `incoming_flow[v] = outgoing_flow[v]`.\n- Node `n` will accumulate all incoming flow `S_n` because it's never enqueued (its target `current_incoming_flow` is `S_n`, not `S_n/2`). All edges incident to `n` that are not yet directed when another node `u` is processed will be directed `u -> n`.\n- Acyclicity is guaranteed because edges are only directed from an already processed node `u` (whose incoming flow requirement is met) to an unprocessed node `v` (whose incoming flow requirement is not yet met). This forms a topological ordering.\n\nExample walk-through:\nInput:\n3 3\n3 2 10 (idx 0)\n1 2 10 (idx 1)\n3 1 5  (idx 2)\n\n1. `adj`:\n   1: [(2, 10, 1), (3, 5, 2)]\n   2: [(3, 10, 0), (1, 10, 1)]\n   3: [(2, 10, 0), (1, 5, 2)]\n2. `S`:\n   `S_1 = 10 + 5 = 15`\n   `S_2 = 10 + 10 = 20`\n   `S_3 = 10 + 5 = 15`\n3. `current_incoming_flow = [0, 0, 0, 0]` (for nodes 0-3, use 1-indexed)\n4. `ans = [-1, -1, -1]`\n5. `Q = [1]`\n\nLoop:\n- Dequeue `u = 1`.\n  - Edge `(1, 2, 10, 1)`: `ans[1]` is -1. Direct `1 -> 2`. `ans[1] = 0`. `current_incoming_flow[2] += 10`. `current_incoming_flow[2]` is now 10. `S_2/2 = 20/2 = 10`. Since `1 < 2 < 3` and `current_incoming_flow[2] == S_2/2`, enqueue 2. `Q = [2]`.\n  - Edge `(1, 3, 5, 2)`: `ans[2]` is -1. Direct `1 -> 3`. `ans[2] = 0`. `current_incoming_flow[3] += 5`. `current_incoming_flow[3]` is now 5. `3` is the sink, so don't enqueue. `Q = [2]`.\n\n- Dequeue `u = 2`.\n  - Edge `(2, 3, 10, 0)`: `ans[0]` is -1. Direct `2 -> 3`. `ans[0] = 0`. `current_incoming_flow[3] += 10`. `current_incoming_flow[3]` is now `5 + 10 = 15`. `3` is the sink. `Q = []`.\n  - Edge `(2, 1, 10, 1)`: `ans[1]` is 0. Already directed. Skip.\n\nQueue is empty.\nFinal `ans`: `[0, 0, 0]`\nThis means:\nEdge 0 (3,2,10) -> 3->2 (original was 3,2, directed 2->3, so 0)\nEdge 1 (1,2,10) -> 1->2 (original was 1,2, directed 1->2, so 0)\nEdge 2 (3,1,5) -> 3->1 (original was 3,1, directed 1->3, so 0)\n\nWait, the example output for the first case is `1\\n0\\n1`. My output `0\\n0\\n0` is different. Let's recheck my logic for `ans[idx]`.\nIf original edge is `(a_i, b_i)` and we direct `u -> v`:\n- If `u = a_i, v = b_i`: `ans[idx] = 0`.\n- If `u = b_i, v = a_i`: `ans[idx] = 1`.\n\nLet's retrace the example with `ans` logic:\nInput:\n0: (3, 2, 10)\n1: (1, 2, 10)\n2: (3, 1, 5)\n\n`adj`:\n1: [(2, 10, 1, '1_2'), (3, 5, 2, '1_3')] # (neighbor, flow, original_idx, original_pair_str)\n2: [(3, 10, 0, '3_2'), (1, 10, 1, '1_2')]\n3: [(2, 10, 0, '3_2'), (1, 5, 2, '1_3')]\n\n`Q = [1]`\n- Dequeue `u = 1`.\n  - Edge with `v=2`, `c=10`, `idx=1`: Original edge was `(1, 2)`. We direct `1 -> 2`. This matches `(u, v)`. So `ans[1] = 0`. `current_incoming_flow[2] = 10`. `S_2/2=10`. Enqueue 2. `Q = [2]`.\n  - Edge with `v=3`, `c=5`, `idx=2`: Original edge was `(3, 1)`. We direct `1 -> 3`. This means `u=1, v=3`, original was `(3,1)`. So we need to set `ans[2]=1` (flow `3 -> 1` is now `1 -> 3`). `current_incoming_flow[3] = 5`. `3` is sink, don't enqueue. `Q = [2]`.\n\n- Dequeue `u = 2`.\n  - Edge with `v=3`, `c=10`, `idx=0`: Original edge was `(3, 2)`. We direct `2 -> 3`. This means `u=2, v=3`, original was `(3,2)`. So we need to set `ans[0]=1` (flow `3 -> 2` is now `2 -> 3`). `current_incoming_flow[3] = 5 + 10 = 15`. `3` is sink. `Q = []`.\n  - Edge with `v=1`, `c=10`, `idx=1`: `ans[1]` is 0. Already directed. Skip.\n\nFinal `ans`: `[1, 0, 1]`. This matches the example output!\n\nThe crucial part is correctly setting `ans[idx]` based on the original `(a_i, b_i)` and the determined `u -> v` direction.\nIf original edge is `(a_i, b_i)` and we determine flow `u -> v`:\n- If `u = a_i` and `v = b_i`, then `ans[idx] = 0`.\n- If `u = b_i` and `v = a_i`, then `ans[idx] = 1`.\n\nTo implement this, it's better to store `(neighbor, flow, original_idx, is_reversed_in_adj_list)` in `adj`.\n`is_reversed_in_adj_list` would be true if `(neighbor, u)` was the original edge and we added `(u, neighbor)` to `adj[u]`.\n\nLet's use a simpler adjacency list `adj[u]` stores tuples `(v, c, original_idx)`.\nAnd `original_edges` stores `(a_i, b_i)` for each `original_idx`.\n\nRevised algorithm:\n1. Read $N, M$. Store `original_edges[idx] = (a_i, b_i)` for each edge.\n2. Build adjacency list `adj[u]` storing `(v, c, original_idx)` for each edge `(u, v)` with flow `c`.\n3. Calculate `S_v` (total flow incident to $v$) for all $v$.\n4. Initialize `current_incoming_flow[v] = 0` for all $v$.\n5. Initialize `ans[original_idx]` array of size `M` to -1.\n6. Create a queue `Q`.\n7. Enqueue vertex 1.\n8. While `Q` is not empty:\n   a. Dequeue vertex `u`.\n   b. For each `(v, c, idx)` in `adj[u]`:\n      i. If `ans[idx]` is not -1, continue (edge already directed).\n      ii. Determine direction `u -> v`.\n          Let `(orig_u, orig_v) = original_edges[idx]`.\n          If `orig_u == u` and `orig_v == v`, set `ans[idx] = 0`.\n          Else (meaning `orig_u == v` and `orig_v == u`), set `ans[idx] = 1`.\n      iii. `current_incoming_flow[v] += c`.\n      iv. If `v` is an internal node (`1 < v < n`) and `current_incoming_flow[v] == S_v / 2`, enqueue `v`.\n\nThis approach is `O(N+M)` because each vertex is enqueued/dequeued at most once, and each edge is processed at most twice (once from each endpoint, but only directed once).\n\n```python\nimport sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    # Store original edges to determine output direction\n    original_edges = []\n    \n    # Adjacency list: adj[u] = list of (v, flow_c, original_edge_idx)\n    adj = [[] for _ in range(n + 1)]\n    \n    # Sum of flow for all edges incident to a vertex\n    S = [0] * (n + 1)\n\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        original_edges.append((u, v))\n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n        S[u] += c\n        S[v] += c\n\n    # current_incoming_flow[v] stores the sum of flow volumes for edges directed INTO v\n    current_incoming_flow = [0] * (n + 1)\n    \n    # ans[i] stores the direction for the i-th edge\n    # 0 if original_edges[i] (a,b) is directed a -> b\n    # 1 if original_edges[i] (a,b) is directed b -> a\n    ans = [-1] * m\n\n    q = deque()\n    \n    # Start with source (vertex 1). It needs 0 incoming flow, which it currently has.\n    q.append(1)\n\n    while q:\n        u = q.popleft()\n\n        # Iterate through all neighbors of u\n        # We process edges from u, directing them u -> v\n        for v, c, edge_idx in adj[u]:\n            # If this edge has already been directed, skip it\n            if ans[edge_idx] != -1:\n                continue\n\n            # Direct the edge u -> v\n            # Determine if original edge was (u,v) or (v,u)\n            orig_u, orig_v = original_edges[edge_idx]\n            if orig_u == u and orig_v == v:\n                ans[edge_idx] = 0 # Flow a -> b\n            else: # orig_u == v and orig_v == u\n                ans[edge_idx] = 1 # Flow b -> a\n\n            # Update incoming flow for v\n            current_incoming_flow[v] += c\n\n            # If v is an internal node (not 1 or n) and its incoming flow requirement is met\n            # Enqueue v to process its outgoing edges\n            if 1 < v < n and current_incoming_flow[v] == S[v] // 2:\n                q.append(v)\n\n    # Print results\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + '\\n')\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    # Store original edges to determine output direction\n    original_edges = []\n    \n    # Adjacency list: adj[u] = list of (v, flow_c, original_edge_idx)\n    adj = [[] for _ in range(n + 1)]\n    \n    # Sum of flow for all edges incident to a vertex\n    S = [0] * (n + 1)\n\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        original_edges.append((u, v))\n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n        S[u] += c\n        S[v] += c\n\n    # current_incoming_flow[v] stores the sum of flow volumes for edges directed INTO v\n    current_incoming_flow = [0] * (n + 1)\n    \n    # ans[i] stores the direction for the i-th edge\n    # 0 if original_edges[i] (a,b) is directed a -> b\n    # 1 if original_edges[i] (a,b) is directed b -> a\n    ans = [-1] * m\n\n    q = deque()\n    \n    # Start with source (vertex 1). It needs 0 incoming flow, which it currently has.\n    q.append(1)\n\n    while q:\n        u = q.popleft()\n\n        # Iterate through all neighbors of u\n        # We process edges from u, directing them u -> v\n        for v, c, edge_idx in adj[u]:\n            # If this edge has already been directed, skip it\n            if ans[edge_idx] != -1:\n                continue\n\n            # Direct the edge u -> v\n            # Determine if original edge was (u,v) or (v,u)\n            orig_u, orig_v = original_edges[edge_idx]\n            if orig_u == u and orig_v == v:\n                ans[edge_idx] = 0 # Flow a -> b\n            else: # orig_u == v and orig_v == u\n                ans[edge_idx] = 1 # Flow b -> a\n\n            # Update incoming flow for v\n            current_incoming_flow[v] += c\n\n            # If v is an internal node (not 1 or n) and its incoming flow requirement is met\n            # Enqueue v to process its outgoing edges\n            if 1 < v < n and current_incoming_flow[v] == S[v] // 2:\n                q.append(v)\n\n    # Print results\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + '\\n')\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 736,
        "completion_token_count": 5446,
        "thoughts_token_count": 6004
    }
}