{
    "start": 1758284892.8996832,
    "end": 1758284957.6198227,
    "start-formatted": "2025-09-19 21:28 KST",
    "end-formatted": "2025-09-19 21:29 KST",
    "gpu": 2,
    "pid": 44,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Polycarp's Practice\n\nPolycarp is practicing his problem solving skill. He has a list of $$$n$$$ problems with difficulties $$$a_1, a_2, \\dots, a_n$$$, respectively. His plan is to practice for exactly $$$k$$$ days. Each day he has to solve at least one problem from his list. Polycarp solves the problems in the order they are given in his list, he cannot skip any problem from his list. He has to solve all $$$n$$$ problems in exactly $$$k$$$ days.Thus, each day Polycarp solves a contiguous sequence of (consecutive) problems from the start of the list. He can't skip problems or solve them multiple times. As a result, in $$$k$$$ days he will solve all the $$$n$$$ problems.The profit of the $$$j$$$-th day of Polycarp's practice is the maximum among all the difficulties of problems Polycarp solves during the $$$j$$$-th day (i.e. if he solves problems with indices from $$$l$$$ to $$$r$$$ during a day, then the profit of the day is $$$\\max\\limits_{l \\le i \\le r}a_i$$$). The total profit of his practice is the sum of the profits over all $$$k$$$ days of his practice.You want to help Polycarp to get the maximum possible total profit over all valid ways to solve problems. Your task is to distribute all $$$n$$$ problems between $$$k$$$ days satisfying the conditions above in such a way, that the total profit is maximum.For example, if $$$n = 8, k = 3$$$ and $$$a = [5, 4, 2, 6, 5, 1, 9, 2]$$$, one of the possible distributions with maximum total profit is: $$$[5, 4, 2], [6, 5], [1, 9, 2]$$$. Here the total profit equals $$$5 + 6 + 9 = 20$$$.\n\n## Input\nThe first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\le k \\le n \\le 2000$$$) — the number of problems and the number of days, respectively.The second line of the input contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le 2000$$$) — difficulties of problems in Polycarp's list, in the order they are placed in the list (i.e. in the order Polycarp will solve them).\n\n## Output\nIn the first line of the output print the maximum possible total profit.In the second line print exactly $$$k$$$ positive integers $$$t_1, t_2, \\dots, t_k$$$ ($$$t_1 + t_2 + \\dots + t_k$$$ must equal $$$n$$$), where $$$t_j$$$ means the number of problems Polycarp will solve during the $$$j$$$-th day in order to achieve the maximum possible total profit of his practice.If there are many possible answers, you may print any of them.\n\n## Example\n### Input\n['8 3\\n5 4 2 6 5 1 9 2', '5 1\\n1 1 1 1 1', '4 2\\n1 2000 2000 2']\n\n### Output\n['20\\n3 2 3', '1\\n5', '4000\\n2 2']\n\n## Note\nThe first example is described in the problem statement.In the second example there is only one possible distribution.In the third example the best answer is to distribute problems in the following way: $$$[1, 2000], [2000, 2]$$$. The total profit of this distribution is $$$2000 + 2000 = 4000$$$.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "**Thinking Through \"Polycarp's Practice\"**\n\nOkay, so I've got this \"Polycarp's Practice\" problem, and I need to come up with a Python solution. The core of it seems straightforward: maximize the total profit by optimally dividing the problems across days.\n\nLet me break it down. I have `n` problems and `k` days. Each day, I tackle a contiguous chunk of problems, and the profit for that day is simply the maximum difficulty of the problems solved that day. The overall goal is to maximize the sum of these daily profits.\n\nI get it now. To maximize the total profit, I have to ensure that the largest problems contribute maximally. Since the daily profit is determined by the highest difficulty within a set, it makes sense to try and assign the hardest problems as the daily \"maximums.\"\n\nThe key insight is this: If I pick the `k` largest difficulties and assign each to a day as its maximum, I can maximize the total profit. The other problems will be solved, but their contribution will be indirect. I can see this can be achieved by making the largest values the maximum values for the particular days. So now the problem is transformed into an index management problem.\n\nMy plan:\n1.  Identify the `k` largest problems.\n2.  Find the *original indices* of these values in the input array.\n3.  Use these indices to determine how to split the problems into `k` days.\n\nTo keep track of original indices during sorting, I think the best way to do this is with pairs of (difficulty, original index). I'll sort these pairs by difficulty in descending order. This keeps everything together and avoids getting lost when sorting. This helps keep track of the day boundaries.\n\nNow, how will I partition? The indices of the *largest* difficulties will separate the days. The numbers between them are the solved problems for that particular day.\n\nOkay, let's write some code...\n",
    "response": "The problem asks us to partition `n` problems, given as a list of difficulties `a_1, ..., a_n`, into `k` contiguous segments. Each segment represents problems solved on one day. The profit for a day is the maximum difficulty among problems solved that day. We want to maximize the total profit (sum of daily profits) and output this maximum profit, along with the number of problems solved each day.\n\n**Key Insight:**\nTo maximize the sum of `k` daily profits, we should try to make the `k` largest problem difficulties in the entire list `a` be the maximums for each of the `k` days. If we can achieve this, the total profit will be the sum of these `k` largest difficulties. This is the maximum possible profit because any other choice of daily maximums would involve at least one difficulty smaller than one of these `k` largest, resulting in a smaller or equal sum.\n\n**Algorithm:**\n\n1.  **Identify the `k` largest difficulties:**\n    *   Create pairs of `(difficulty, original_index)` for each problem to preserve their original positions.\n    *   Sort these pairs in descending order based on difficulty.\n    *   Take the top `k` pairs from this sorted list. These `k` difficulties will be our daily maximums.\n    *   Calculate the sum of these `k` difficulties to get the maximum possible total profit.\n\n2.  **Determine the daily partitions:**\n    *   From the `k` selected pairs, extract their original indices.\n    *   Sort these `k` indices in ascending order. These sorted indices represent the positions in the original problem list where a new day's practice *must* start (because the problem at this index is one of our chosen daily maximums).\n    *   Let these sorted indices be `idx_1, idx_2, ..., idx_k`.\n    *   The first day will solve problems from index `0` up to `idx_1`. The number of problems is `idx_1 + 1`.\n    *   The `j`-th day (for `1 < j <= k`) will solve problems from `idx_{j-1} + 1` up to `idx_j`. The number of problems is `idx_j - (idx_{j-1} + 1) + 1 = idx_j - idx_{j-1}`.\n    *   The last day (`k`-th day) will solve problems from `idx_k + 1` up to `n-1`. The number of problems is `n - (idx_k + 1)`.\n\n    *Correction to partitioning logic*: The `k` chosen problems must *be* the maximums. This means each of them must fall into a *different* day. We can use their indices to define the split points.\n    If we have `k` split points, we define `k` segments.\n    The `k` chosen problems are `a[p_1], a[p_2], ..., a[p_k]` where `p_1 < p_2 < ... < p_k` are their original indices.\n    We need to make `a[p_1]` the max of the first day, `a[p_2]` the max of the second day, ..., `a[p_k]` the max of the `k`-th day.\n    This implies that the first day must end *at or after* `p_1`.\n    The second day must end *at or after* `p_2` but *before or at* the start of the third day.\n    To ensure each of these `k` problems is the maximum for its respective day, we can simply make the split points directly after `k-1` of these `k` problems.\n    Specifically, we can make the split points just after `p_1`, `p_2`, ..., `p_{k-1}`.\n    *   Day 1: problems `0` to `p_1`. Length `p_1 + 1`.\n    *   Day 2: problems `p_1 + 1` to `p_2`. Length `p_2 - p_1`.\n    *   ...\n    *   Day `j`: problems `p_{j-1} + 1` to `p_j`. Length `p_j - p_{j-1}`.\n    *   ...\n    *   Day `k`: problems `p_{k-1} + 1` to `n-1`. Length `n - (p_{k-1} + 1)`.\n\n    This strategy guarantees that `a[p_j]` is included in day `j`'s problems. Since `a[p_j]` is one of the `k` largest overall, and the other problems in day `j` are not among the `k` largest (unless they are duplicates of the `k` largest, in which case `a[p_j]` is still a maximum), `a[p_j]` will be the maximum for day `j`.\n\n**Example Walkthrough:**\n`n = 8, k = 3, a = [5, 4, 2, 6, 5, 1, 9, 2]`\n\n1.  **Pairs (difficulty, index):**\n    `[(5,0), (4,1), (2,2), (6,3), (5,4), (1,5), (9,6), (2,7)]`\n\n2.  **Sort by difficulty (descending), then index (ascending for ties):**\n    `[(9,6), (6,3), (5,0), (5,4), (4,1), (2,2), (2,7), (1,5)]`\n\n3.  **Top `k=3` difficulties:**\n    `[(9,6), (6,3), (5,0)]`\n    Total profit = `9 + 6 + 5 = 20`.\n\n4.  **Extract and sort indices:**\n    Indices are `6, 3, 0`. Sorted: `[0, 3, 6]`. Let these be `p_0, p_1, p_2`.\n\n5.  **Calculate lengths of segments:**\n    *   Day 1: problems from index `0` up to `p_0`. Length `p_0 + 1 = 0 + 1 = 1`. This is wrong. The example output is `3 2 3`.\n    *   The `k` indices `p_1, ..., p_k` are the *positions* of the chosen maximums. We need to find `k-1` split points.\n    *   The crucial point is that we need to *include* each of the `k` largest values in one of the `k` days, and make it the maximum for that day.\n    *   Let the sorted indices of the `k` largest elements be `s_1, s_2, ..., s_k`.\n    *   The split points will be `s_1, s_2, ..., s_{k-1}`.\n    *   Day 1: problems `0` to `s_1`. Length `s_1 + 1`.\n    *   Day 2: problems `s_1 + 1` to `s_2`. Length `s_2 - s_1`.\n    *   ...\n    *   Day `k-1`: problems `s_{k-2} + 1` to `s_{k-1}`. Length `s_{k-1} - s_{k-2}`.\n    *   Day `k`: problems `s_{k-1} + 1` to `n-1`. Length `n - (s_{k-1} + 1)`.\n\n    Let's re-try with `s_1, s_2, ..., s_k` as the 0-indexed positions of the `k` largest values: `0, 3, 6`.\n    We need `k-1 = 2` split points. These will be `s_1` and `s_2`.\n    *   Split point 1: after index `s_1 = 3`.\n    *   Split point 2: after index `s_2 = 6`.\n\n    *   Day 1: problems `a[0]` to `a[3]`. This segment is `[5, 4, 2, 6]`. Length `3 - 0 + 1 = 4`. Max is `6`.\n    *   Day 2: problems `a[4]` to `a[6]`. This segment is `[5, 1, 9]`. Length `6 - 4 + 1 = 3`. Max is `9`.\n    *   Day 3: problems `a[7]` to `a[7]`. This segment is `[2]`. Length `7 - 7 + 1 = 1`. Max is `2`.\n    Total profit `6 + 9 + 2 = 17`. This is not `20`.\n\n    The issue is how the split points are chosen. The `k` largest values are `a[0]=5, a[3]=6, a[6]=9`.\n    We need `k-1` split points.\n    The split points must be chosen such that each of `a[0], a[3], a[6]` is the maximum of *some* day.\n    The simplest way to do this is to ensure that `a[0]` is in day 1, `a[3]` is in day 2, `a[6]` is in day 3.\n    The first day ends at index `p_1 - 1`.\n    The second day ends at index `p_2 - 1`.\n    ...\n    The `k-1`-th day ends at index `p_{k-1} - 1`.\n    The `k`-th day ends at index `n-1`.\n\n    Let the sorted indices of the `k` largest values be `pos_0, pos_1, ..., pos_{k-1}`.\n    For `k=3`, `pos = [0, 3, 6]`.\n    The split points are *after* `pos_0`, *after* `pos_1`.\n    *   Day 1: problems `0` to `pos_0`. Length `pos_0 + 1`. This is `a[0]`. Length `1`.\n    *   Day 2: problems `pos_0 + 1` to `pos_1`. Length `pos_1 - pos_0`. This is `a[1], a[2], a[3]`. Length `3`.\n    *   Day 3: problems `pos_1 + 1` to `n-1`. Length `n - (pos_1 + 1)`. This is `a[4], a[5], a[6], a[7]`. Length `4`.\n    Lengths: `1, 3, 4`. Total profit `5 + 6 + 9 = 20`. This is correct!\n\n    So, the final strategy for lengths:\n    1.  Get the `k` largest values and their original indices.\n    2.  Sum these `k` values for the total profit.\n    3.  Collect the `k` original indices and sort them: `p_0, p_1, ..., p_{k-1}`.\n    4.  The lengths of the segments are:\n        *   `t_1 = p_0 + 1`\n        *   `t_2 = p_1 - p_0`\n        *   ...\n        *   `t_j = p_{j-1} - p_{j-2}` for `j` from `2` to `k-1`.\n        *   `t_k = n - p_{k-1}` (This is `n - (p_{k-1} + 1) + 1`).\n\n    Let's re-apply to `n = 8, k = 3, a = [5, 4, 2, 6, 5, 1, 9, 2]`\n    Sorted indices of `k` largest values: `p = [0, 3, 6]`\n    *   `t_1 = p_0 + 1 = 0 + 1 = 1`\n    *   `t_2 = p_1 - p_0 = 3 - 0 = 3`\n    *   `t_3 = n - p_2 = 8 - 6 = 2`\n    Lengths: `[1, 3, 2]`. Total profit `20`.\n    This is different from example output `[3, 2, 3]`. Both yield 20. The problem states \"If there are many possible answers, you may print any of them.\" So this is a valid solution.\n\n    Let's check the example output `[3, 2, 3]` to see which indices it uses for the maximums.\n    `[5, 4, 2]`, `[6, 5]`, `[1, 9, 2]`\n    Maxes: `5` (from `a[0]`), `6` (from `a[3]`), `9` (from `a[6]`).\n    The chosen maximums are the same. This confirms the strategy of picking the `k` largest values.\n    The split points for `[3, 2, 3]` are:\n    *   Day 1: `a[0], a[1], a[2]`. Length 3. Max `a[0]=5`.\n    *   Day 2: `a[3], a[4]`. Length 2. Max `a[3]=6`.\n    *   Day 3: `a[5], a[6], a[7]`. Length 3. Max `a[6]=9`.\n    The indices of the maximums are `0, 3, 6`.\n\n    My strategy for lengths:\n    `t_1 = p_0 + 1`\n    `t_j = p_{j-1} - p_{j-2}` for `j` from `2` to `k-1`\n    `t_k = n - p_{k-1}`\n\n    This results in `[1, 3, 2]` for the example. This is correct.\n\n    One final check for edge cases:\n    *   `k = n`: Each day solves 1 problem. `p = [0, 1, ..., n-1]`.\n        `t_1 = 0+1 = 1`.\n        `t_j = (j-1) - (j-2) = 1` for `j=2...n-1`.\n        `t_n = n - (n-1) = 1`. All `t_j` are 1. Correct.\n    *   `k = 1`: `p = [idx_of_max_val]`.\n        `t_1 = n - p_0` (this formula is wrong for `k=1`, as `p_{k-1}` would be `p_0`).\n        If `k=1`, there's only one day, so `t_1 = n`.\n        The general formula `t_k = n - p_{k-1}` works if `k-1` is the last index of `p`.\n        The formula needs to be:\n        `t_1 = p_0 + 1`\n        `t_j = p_{j-1} - p_{j-2}` for `j` from `2` to `k-1`\n        `t_k = n - (sum of previous lengths)` or `n - (p_{k-1} + 1) + (p_{k-1} + 1 - (p_{k-2} + 1))`\n        No, it's simpler. The split points are `p_0, p_1, ..., p_{k-2}`.\n        The first segment is `0` to `p_0`. Length `p_0 + 1`.\n        The second segment is `p_0 + 1` to `p_1`. Length `p_1 - p_0`.\n        ...\n        The `k-1`-th segment is `p_{k-3} + 1` to `p_{k-2}`. Length `p_{k-2} - p_{k-3}`.\n        The `k`-th segment is `p_{k-2} + 1` to `n-1`. Length `n - (p_{k-2} + 1)`.\n\n    Let's use `current_idx` to track the start of the current segment.\n    `current_idx = 0`\n    `lengths = []`\n    For `i` from `0` to `k-2`:\n        `end_of_segment = p_i` (This makes `p_i` the last problem of the current day)\n        `length = end_of_segment - current_idx + 1`\n        `lengths.append(length)`\n        `current_idx = end_of_segment + 1`\n    For the last segment (day `k`):\n        `length = n - current_idx`\n        `lengths.append(length)`\n\n    Let's apply this to `n = 8, k = 3, p = [0, 3, 6]`\n    `current_idx = 0`, `lengths = []`\n    `i = 0` (`p_0 = 0`):\n        `end_of_segment = 0`\n        `length = 0 - 0 + 1 = 1`\n        `lengths = [1]`\n        `current_idx = 0 + 1 = 1`\n    `i = 1` (`p_1 = 3`):\n        `end_of_segment = 3`\n        `length = 3 - 1 + 1 = 3`\n        `lengths = [1, 3]`\n        `current_idx = 3 + 1 = 4`\n    Loop ends (since `i` goes up to `k-2 = 1`).\n    Last segment:\n        `length = n - current_idx = 8 - 4 = 4`\n        `lengths = [1, 3, 4]`\n\n    This is `[1, 3, 4]`. Total profit `5+6+9 = 20`. This is also a valid answer.\n    The example output `[3, 2, 3]` uses split points after indices `2` and `4`.\n    `[5, 4, 2]` (max 5 at `a[0]`)\n    `[6, 5]` (max 6 at `a[3]`)\n    `[1, 9, 2]` (max 9 at `a[6]`)\n\n    This implies that the split points are not necessarily *at* the indices `p_i`.\n    The crucial part is that `p_i` is *contained* in the `i`-th day's problems (or `(i+1)`-th day if 0-indexed).\n    And the `k` largest values are `a[p_0], a[p_1], ..., a[p_{k-1}]`.\n\n    My first strategy for lengths `t_1 = p_0 + 1`, `t_j = p_{j-1} - p_{j-2}`, `t_k = n - p_{k-1}` was:\n    For `p = [0, 3, 6]`\n    `t_1 = 0 + 1 = 1`\n    `t_2 = 3 - 0 = 3`\n    `t_3 = 8 - 6 = 2`\n    Result `[1, 3, 2]`. This is simpler and valid. Let's stick with this.\n\n    **Implementation Details:**\n    *   Read `n, k`.\n    *   Read `a`.\n    *   Create `indexed_a = [(a[i], i) for i in range(n)]`.\n    *   Sort `indexed_a` by difficulty descending: `indexed_a.sort(key=lambda x: x[0], reverse=True)`.\n    *   Take the top `k` elements: `top_k_problems = indexed_a[:k]`.\n    *   Calculate `total_profit = sum(p[0] for p in top_k_problems)`.\n    *   Extract indices: `split_indices = sorted([p[1] for p in top_k_problems])`.\n    *   Calculate `t_j` values:\n        *   `t = []`\n        *   `t.append(split_indices[0] + 1)`\n        *   For `i` from `1` to `k-1`: `t.append(split_indices[i] - split_indices[i-1])`\n        *   The last day's length is `n - split_indices[k-1]`. This is incorrect.\n        *   The sum of `t` must be `n`.\n        *   Let's check `sum(t_j)`: `(p_0+1) + (p_1-p_0) + ... + (p_{k-1}-p_{k-2})`. This sum is `p_{k-1} + 1`. This is not `n`.\n        *   The last segment must cover the remaining problems.\n        *   The `k-1` split points are *after* `p_0, p_1, ..., p_{k-2}`.\n        *   Day 1: `0` to `p_0`. Length `p_0 + 1`.\n        *   Day 2: `p_0 + 1` to `p_1`. Length `p_1 - p_0`.\n        *   ...\n        *   Day `k-1`: `p_{k-3} + 1` to `p_{k-2}`. Length `p_{k-2} - p_{k-3}`.\n        *   Day `k`: `p_{k-2} + 1` to `n-1`. Length `n - (p_{k-2} + 1)`.\n\n        This is the method I derived before that gave `[1, 3, 4]` for the example. Let's use this.\n\n    ```python\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    # 1. Identify the k largest difficulties and their original indices\n    indexed_a = []\n    for i in range(n):\n        indexed_a.append((a[i], i))\n\n    # Sort by difficulty in descending order\n    indexed_a.sort(key=lambda x: x[0], reverse=True)\n\n    # Take the top k problems\n    top_k_problems = indexed_a[:k]\n\n    # Calculate total profit\n    total_profit = sum(p[0] for p in top_k_problems)\n\n    # Extract and sort the original indices of these k problems\n    split_indices = sorted([p[1] for p in top_k_problems])\n\n    # 2. Determine the daily partitions (lengths of segments)\n    day_lengths = []\n    current_problem_idx = 0\n    \n    # Iterate through the first k-1 split points\n    # These define the end of the first k-1 days\n    for i in range(k - 1):\n        # The current day ends at split_indices[i]\n        # So, problems from current_problem_idx to split_indices[i] are solved\n        length = split_indices[i] - current_problem_idx + 1\n        day_lengths.append(length)\n        # The next day starts after this split point\n        current_problem_idx = split_indices[i] + 1\n    \n    # The last day solves all remaining problems\n    length = n - current_problem_idx\n    day_lengths.append(length)\n\n    print(total_profit)\n    print(*day_lengths)\n\n    ```\nLet's test with the provided examples:\n\n**Example 1:**\nInput:\n8 3\n5 4 2 6 5 1 9 2\nOutput:\n20\n3 2 3\n\nMy code's output with `n=8, k=3, a=[5, 4, 2, 6, 5, 1, 9, 2]`:\n`indexed_a`: `[(5,0), (4,1), (2,2), (6,3), (5,4), (1,5), (9,6), (2,7)]`\nSorted by difficulty (desc): `[(9,6), (6,3), (5,0), (5,4), (4,1), (2,2), (2,7), (1,5)]`\n`top_k_problems` (k=3): `[(9,6), (6,3), (5,0)]`\n`total_profit`: `9 + 6 + 5 = 20`\n`split_indices` (sorted original indices): `[0, 3, 6]`\n\n`day_lengths` calculation:\n`current_problem_idx = 0`\n`i = 0` (for `split_indices[0] = 0`):\n  `length = 0 - 0 + 1 = 1`\n  `day_lengths = [1]`\n  `current_problem_idx = 0 + 1 = 1`\n`i = 1` (for `split_indices[1] = 3`):\n  `length = 3 - 1 + 1 = 3`\n  `day_lengths = [1, 3]`\n  `current_problem_idx = 3 + 1 = 4`\nLoop finishes (`k-1 = 2`).\nLast day:\n  `length = n - current_problem_idx = 8 - 4 = 4`\n  `day_lengths = [1, 3, 4]`\n\nOutput:\n20\n1 3 4\n\nThis output `1 3 4` is different from the example `3 2 3`, but it's a valid solution as it yields the maximum profit. The problem states \"If there are many possible answers, you may print any of them.\"\n\n**Example 2:**\nInput:\n5 1\n1 1 1 1 1\nOutput:\n1\n5\n\nMy code's output:\n`n=5, k=1, a=[1,1,1,1,1]`\n`indexed_a`: `[(1,0), (1,1), (1,2), (1,3), (1,4)]`\nSorted (desc): `[(1,0), (1,1), (1,2), (1,3), (1,4)]` (order of ties doesn't matter for top k)\n`top_k_problems` (k=1): `[(1,0)]`\n`total_profit`: `1`\n`split_indices`: `[0]`\n\n`day_lengths` calculation:\n`current_problem_idx = 0`\nLoop `for i in range(k-1)`: `range(0)` is empty. Loop doesn't run.\nLast day:\n  `length = n - current_problem_idx = 5 - 0 = 5`\n  `day_lengths = [5]`\n\nOutput:\n1\n5\nMatches example.\n\n**Example 3:**\nInput:\n4 2\n1 2000 2000 2\nOutput:\n4000\n2 2\n\nMy code's output:\n`n=4, k=2, a=[1, 2000, 2000, 2]`\n`indexed_a`: `[(1,0), (2000,1), (2000,2), (2,3)]`\nSorted (desc): `[(2000,1), (2000,2), (2,3), (1,0)]`\n`top_k_problems` (k=2): `[(2000,1), (2000,2)]`\n`total_profit`: `2000 + 2000 = 4000`\n`split_indices`: `[1, 2]`\n\n`day_lengths` calculation:\n`current_problem_idx = 0`\n`i = 0` (for `split_indices[0] = 1`):\n  `length = 1 - 0 + 1 = 2`\n  `day_lengths = [2]`\n  `current_problem_idx = 1 + 1 = 2`\nLoop finishes (`k-1 = 1`).\nLast day:\n  `length = n - current_problem_idx = 4 - 2 = 2`\n  `day_lengths = [2, 2]`\n\nOutput:\n4000\n2 2\nMatches example.\n\nThe logic seems solid and handles edge cases correctly.\n\nFinal check on constraints: `1 <= k <= n <= 2000`. `a_i <= 2000`.\nSorting `n` elements takes `O(N log N)`. Summing `k` elements is `O(K)`. Sorting `k` indices is `O(K log K)`. Calculating lengths is `O(K)`. All these operations are efficient enough for `N=2000`.\n\n```python\nimport sys\n\ndef solve():\n    n, k = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    # Step 1: Identify the k largest difficulties and their original indices\n    # Create a list of (difficulty, original_index) pairs\n    indexed_a = []\n    for i in range(n):\n        indexed_a.append((a[i], i))\n\n    # Sort the problems by difficulty in descending order.\n    # If difficulties are equal, the order of indices doesn't strictly matter\n    # for selecting the top k, but a consistent sort (e.g., by index ascending)\n    # can make the choice deterministic. Python's sort is stable, so original\n    # relative order is preserved for equal elements.\n    indexed_a.sort(key=lambda x: x[0], reverse=True)\n\n    # Take the top k problems based on difficulty\n    top_k_problems = indexed_a[:k]\n\n    # Calculate the maximum possible total profit\n    total_profit = sum(p[0] for p in top_k_problems)\n\n    # Extract the original indices of these k problems and sort them in ascending order\n    # These sorted indices will define the split points for our days\n    split_indices = sorted([p[1] for p in top_k_problems])\n\n    # Step 2: Determine the daily partitions (number of problems solved each day)\n    day_lengths = []\n    current_problem_idx = 0 # Tracks the starting index of the current day's problems\n\n    # We need k days. The first k-1 split_indices will mark the end of the first k-1 days.\n    # The last day will cover all remaining problems up to n-1.\n    for i in range(k - 1):\n        # The current day (day i+1) will solve problems from current_problem_idx\n        # up to and including split_indices[i].\n        length = split_indices[i] - current_problem_idx + 1\n        day_lengths.append(length)\n        \n        # The next day will start immediately after this split point.\n        current_problem_idx = split_indices[i] + 1\n    \n    # The last day (day k) solves all problems from current_problem_idx to n-1.\n    length_last_day = n - current_problem_idx\n    day_lengths.append(length_last_day)\n\n    # Print the results\n    sys.stdout.write(str(total_profit) + \"\\n\")\n    sys.stdout.write(\" \".join(map(str, day_lengths)) + \"\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, k = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    # Step 1: Identify the k largest difficulties and their original indices\n    # Create a list of (difficulty, original_index) pairs\n    indexed_a = []\n    for i in range(n):\n        indexed_a.append((a[i], i))\n\n    # Sort the problems by difficulty in descending order.\n    # If difficulties are equal, the order of indices doesn't strictly matter\n    # for selecting the top k, but a consistent sort (e.g., by index ascending)\n    # can make the choice deterministic. Python's sort is stable, so original\n    # relative order is preserved for equal elements.\n    indexed_a.sort(key=lambda x: x[0], reverse=True)\n\n    # Take the top k problems based on difficulty\n    top_k_problems = indexed_a[:k]\n\n    # Calculate the maximum possible total profit\n    total_profit = sum(p[0] for p in top_k_problems)\n\n    # Extract the original indices of these k problems and sort them in ascending order\n    # These sorted indices will define the split points for our days\n    split_indices = sorted([p[1] for p in top_k_problems])\n\n    # Step 2: Determine the daily partitions (number of problems solved each day)\n    day_lengths = []\n    current_problem_idx = 0 # Tracks the starting index of the current day's problems\n\n    # We need k days. The first k-1 split_indices will mark the end of the first k-1 days.\n    # The last day will cover all remaining problems up to n-1.\n    for i in range(k - 1):\n        # The current day (day i+1) will solve problems from current_problem_idx\n        # up to and including split_indices[i].\n        length = split_indices[i] - current_problem_idx + 1\n        day_lengths.append(length)\n        \n        # The next day will start immediately after this split point.\n        current_problem_idx = split_indices[i] + 1\n    \n    # The last day (day k) solves all problems from current_problem_idx to n-1.\n    length_last_day = n - current_problem_idx\n    day_lengths.append(length_last_day)\n\n    # Print the results\n    sys.stdout.write(str(total_profit) + \"\\n\")\n    sys.stdout.write(\" \".join(map(str, day_lengths)) + \"\\n\")\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 972,
        "completion_token_count": 7418,
        "thoughts_token_count": 809
    }
}