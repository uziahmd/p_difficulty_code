{
    "start": 1758009357.511284,
    "end": 1758009618.4710264,
    "start-formatted": "2025-09-16 16:55 KST",
    "end-formatted": "2025-09-16 17:00 KST",
    "gpu": 2,
    "pid": 8,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "**Let's crack this \"Flawed Flow\" problem!**\n\nOkay, so I'm looking at this competitive programming problem and my immediate thought is, \"This seems solvable, but the 'no cycles' condition is the key.\" We've got `n` vertices, `m` edges, and each edge has a capacity `ci`. The goal is to direct the flow on each edge, either from `ai` to `bi` (0) or `bi` to `ai` (1), and we *know* there are no cycles. This is huge!\n\nThinking about flow conservation, especially for intermediate vertices, makes me realize that at each vertex, what flows in must eventually flow out. The source (1) has no incoming flow, and the sink (n), by problem definition, receives all the flow.  We don't need to calculate the maximum flow itself, just *direct* it correctly. The no-cycle condition gives us a very important hint.\n\nSince there are no cycles, we have a DAG, and the edges must be directed in accordance with a topological order. This order suggests flow typically moves from earlier-discovered to later-discovered vertices. So, to construct this DAG, my initial thought is, let's try a BFS. Running BFS from the source (1) will give us a \"distance\" (`dist`) for each vertex from the source. The idea is this: if `dist[u] < dist[v]`, we direct the flow `u -> v`. This strategy should naturally avoid cycles. This seems like a promising direction to explore for a Python solution.\n",
    "response": "The problem asks us to direct the flow for each edge in an undirected graph, given its volume `ci`, such that several conditions are met:\n1.  For any intermediate vertex `v` (1 < `v` < `n`), the sum of incoming flow equals the sum of outgoing flow.\n2.  Vertex 1 (source) has no incoming edges.\n3.  The resulting directed graph is acyclic.\n4.  The total flow is the correct maximum flow (this is guaranteed by \"a solution always exists\" and \"resulting flow should be correct maximum flow\").\n\nThe crucial condition is that the resulting graph must be a Directed Acyclic Graph (DAG). This suggests that we can find a topological ordering of vertices. A common way to achieve this in flow problems is to use a Breadth-First Search (BFS) or Depth-First Search (DFS) starting from the source to assign \"levels\" or \"distances\" to vertices.\n\nLet's consider a BFS starting from the source vertex (vertex 1). This will assign a shortest path distance `dist[u]` to each vertex `u` from the source. Since the graph is connected, all vertices will be reached.\n\nIf we direct an edge `(u, v)` (with flow `c`) as `u -> v` if `dist[u] < dist[v]`, and `v -> u` if `dist[v] < dist[u]`, this approach naturally creates a DAG. An edge `(u, v)` where `dist[u] == dist[v]` would be a cross-edge in the BFS tree. If we direct it arbitrarily, it could potentially create a cycle or violate flow conservation. However, the problem statement guarantees a solution exists, and for a max-flow setting with no cycles, a common strategy is to direct edges such that flow always moves from a \"lower level\" to a \"higher level\" in some sense.\n\nA simpler approach that satisfies the \"no cycles\" condition and helps with flow conservation is to use a DFS (or BFS) from vertex 1 to establish a parent-child relationship in a spanning tree. Then, any edge `(u, v)` can be directed based on this tree. However, the flow conservation at intermediate nodes is still tricky.\n\nLet's focus on the flow conservation property. For each vertex `v` (1 < `v` < `n`), the net flow must be zero. This means `sum(incoming_flow) - sum(outgoing_flow) = 0`.\nThe source (vertex 1) has no incoming edges. All its connected edges must be outgoing.\nThe sink (vertex `n`) is the destination. In a max-flow DAG, all flow eventually reaches the sink. This implies that all edges connected to `n` must be incoming.\n\nThis observation about the sink (`n`) is key. If all edges connected to `n` are incoming, then the total flow `C` is the sum of `ci` for edges incident to `n`.\nFor any other vertex `v != n`, we need to ensure flow conservation.\n\nConsider a DFS starting from `n` (the sink) in reverse, or rather, a DFS where we try to direct edges *towards* `n`. This is a bit counter-intuitive for max-flow, but it's about *balancing* flows.\n\nLet's maintain for each vertex `u` a `current_balance[u]`. Initially, `current_balance[u] = 0` for all `u`.\nWe can process vertices in a specific order. A DFS from vertex 1 is a good candidate for this.\n\nLet's try a DFS from vertex 1. When we traverse an edge `(u, v)` (where `v` is a child of `u` in the DFS tree), we need to decide its direction.\nThe problem statement implies that the total flow *leaving* the source (vertex 1) eventually *reaches* the sink (vertex `n`).\nLet's calculate the total flow `C` entering the sink. This is the sum of `ci` for all edges connected to `n`. For these edges, they must be directed towards `n`.\n\nAlgorithm:\n1.  Represent the graph using an adjacency list. Store `(neighbor, flow_volume, edge_index)` for each edge.\n2.  Initialize `ans` array of size `m` to store directions.\n3.  Initialize `visited` array for DFS.\n4.  Initialize `balance` array of size `n+1` to all zeros. This `balance[u]` will represent `sum(incoming_flow) - sum(outgoing_flow)` for vertex `u`.\n5.  Perform a DFS starting from vertex 1. The DFS function `dfs(u, parent)` will work as follows:\n    *   Mark `u` as visited.\n    *   For each neighbor `v` of `u` with edge `(u, v)` and flow `c` (original edge index `idx`):\n        *   If `v` is `parent`, skip.\n        *   If `v` is `n` (the sink):\n            *   The edge `(u, n)` must be directed `u -> n` to contribute to the sink's incoming flow.\n            *   Set `ans[idx] = 0` if `a_original == u` (meaning `u -> n`), else `ans[idx] = 1` (meaning `n -> u`, which is `u -> n` if `u` was `b_original`).\n            *   Add `c` to `balance[n]`.\n            *   Subtract `c` from `balance[u]`.\n            *   This is problematic. The balance should be handled after the DFS returns.\n\nLet's rethink. The \"no cycles\" condition is strong. If we run a DFS from source 1, we can establish a DFS tree.\nFlow should generally go from parent to child in the DFS tree, or from a vertex to an already visited vertex (back-edge or forward-edge).\nFor flow conservation, we can use a post-order traversal (or processing after all children are visited) in DFS.\n\nCorrected Algorithm:\n1.  Store edges: `adj[u]` will contain `(v, flow_volume, edge_index, original_u, original_v)`. `original_u` and `original_v` are needed to determine if `a_i` or `b_i` from input corresponds to `u` or `v`.\n2.  `ans = [-1] * m`\n3.  `visited = [False] * (n + 1)`\n4.  `flow_at_node = [0] * (n + 1)`: This will store the net flow *out* of a subtree rooted at `u` (excluding flow on edges going up to parent).\n5.  `dfs(u, p)`:\n    *   `visited[u] = True`\n    *   `current_out_flow = 0` (sum of flows on edges `u -> v` where `v` is a child in DFS tree)\n    *   For each edge `(v, c, idx, original_u, original_v)` in `adj[u]`:\n        *   If `v == p`, continue.\n        *   If `visited[v]`, continue (this is a back-edge or cross-edge, handled by the other end of the edge).\n        *   `dfs(v, u)`: Recursively call DFS for child `v`.\n        *   After `dfs(v, u)` returns, `flow_at_node[v]` contains the net flow that needs to leave the subtree rooted at `v` and go towards `u`.\n        *   If `flow_at_node[v] > 0`: This means there's a net flow of `flow_at_node[v]` that must come *out* of `v`'s subtree and go towards `u`. So, the edge `(u, v)` must be directed `u <- v`.\n            *   If `original_u == v`, set `ans[idx] = 0` (flow `v -> u`).\n            *   Else (`original_v == v`), set `ans[idx] = 1` (flow `v -> u`).\n            *   Add `flow_at_node[v]` to `flow_at_node[u]`.\n        *   Else (`flow_at_node[v] <= 0`): This means there's a net flow of `abs(flow_at_node[v])` that must come *into* `v`'s subtree from `u`. So, the edge `(u, v)` must be directed `u -> v`.\n            *   If `original_u == u`, set `ans[idx] = 0` (flow `u -> v`).\n            *   Else (`original_v == u`), set `ans[idx] = 1` (flow `u -> v`).\n            *   Subtract `c` from `flow_at_node[u]`. (Wait, this is wrong. `flow_at_node[v]` is the net flow *out* of `v`'s subtree. If it's negative, it means `abs(flow_at_node[v])` must come *into* `v`'s subtree from `u`. So `u` sends flow `abs(flow_at_node[v])` to `v`. The edge `(u,v)` must carry `c` flow. So, `u` sends `c` to `v`.)\n            *   Let's simplify: `flow_at_node[u]` accumulates the net flow that *must pass upwards* through `u` to its parent.\n            *   If edge `(u, v)` is directed `u -> v`: `flow_at_node[u]` decreases by `c`.\n            *   If edge `(u, v)` is directed `v -> u`: `flow_at_node[u]` increases by `c`.\n\nRevised DFS logic:\nThe `flow_at_node[u]` should represent the total flow that *must exit* the subtree rooted at `u` (including `u` itself) and go towards its parent `p`.\nWhen `dfs(u, p)` returns, `flow_at_node[u]` should be the balance of all flows within `u`'s subtree, plus the flow through edges connecting `u` to its children.\n\nLet's define `flow_at_node[u]` as the *required outgoing flow* from `u` to `p` (its parent in DFS tree).\nInitialize `flow_at_node[n] = 0` (sink doesn't need to send flow up).\nFor all other nodes `u != n`, `flow_at_node[u]` is initially 0.\n\n`dfs(u, p)`:\n1.  `visited[u] = True`\n2.  For each neighbor `v` of `u` with edge `(u, v)` flow `c` and original index `idx`:\n    *   If `v == p`, continue.\n    *   If `visited[v]`: This is a back-edge or cross-edge. It means `v` is an ancestor or already processed node.\n        *   If `u == 1` (source) and `v == n` (sink): This is a direct edge `1 -> n`. Direct `1 -> n`. `ans[idx] = 0` if `original_u == 1`, else `ans[idx] = 1`.\n        *   Otherwise, this edge `(u, v)` must be directed `u -> v` to satisfy the no-cycle condition and flow conservation (flow generally moves away from source).\n        *   So, `u -> v`. `ans[idx] = 0` if `original_u == u`, else `ans[idx] = 1`.\n        *   `flow_at_node[u] -= c` (flow leaves `u`).\n    *   Else (`v` is not visited, so `v` is a child in DFS tree):\n        *   `dfs(v, u)`: Recursively call DFS for child `v`.\n        *   After `dfs(v, u)` returns, `flow_at_node[v]` contains the net flow that `v`'s subtree needs to send upwards towards `u`.\n        *   If `flow_at_node[v] > 0`: This means `v`'s subtree has an excess of `flow_at_node[v]` that needs to go up to `u`. So, the edge `(u, v)` must be directed `v -> u`.\n            *   If `original_u == v`, set `ans[idx] = 0` (flow `v -> u`).\n            *   Else (`original_v == v`), set `ans[idx] = 1` (flow `v -> u`).\n            *   `flow_at_node[u] += c` (flow enters `u` from `v`).\n        *   Else (`flow_at_node[v] <= 0`): This means `v`'s subtree has a deficit of `abs(flow_at_node[v])` that needs to come from `u`. So, the edge `(u, v)` must be directed `u -> v`.\n            *   If `original_u == u`, set `ans[idx] = 0` (flow `u -> v`).\n            *   Else (`original_v == u`), set `ans[idx] = 1` (flow `u -> v`).\n            *   `flow_at_node[u] -= c` (flow leaves `u` for `v`).\n\nThis DFS strategy is commonly used for problems involving flow in trees or finding a feasible circulation.\nThe base case for `flow_at_node[u]` for a leaf `u` (that is not `n`) would be 0, meaning it needs to send 0 flow up.\nThe source `1` has no incoming edges, so `flow_at_node[1]` will be the total flow leaving the source.\nThe sink `n` should have `flow_at_node[n]` representing the total flow entering it.\n\nLet's refine `flow_at_node[u]` to be the `net_flow_out_of_u_to_parent`.\nInitialize `flow_at_node = [0] * (n + 1)`.\n`dfs(u, p)`:\n1.  `visited[u] = True`\n2.  `current_node_balance = 0` (sum of flows `u -> child` minus `child -> u` for tree edges)\n3.  For each edge `(v, c, idx, original_u_edge, original_v_edge)` in `adj[u]`:\n    *   If `v == p`, continue.\n    *   If `visited[v]`: (This is a cross-edge or back-edge)\n        *   We need to direct this edge. To avoid cycles and satisfy flow from source to sink, we generally direct from lower DFS discovery time to higher. Since `v` is already visited, it means `v` was visited *before* `u` (or `v` is an ancestor).\n        *   Direct `u -> v`.\n        *   If `original_u_edge == u`, `ans[idx] = 0`. Else, `ans[idx] = 1`.\n        *   `current_node_balance -= c` (flow leaves `u`).\n    *   Else (`v` is not visited, `v` is a child in DFS tree):\n        *   `dfs(v, u)`\n        *   The value `flow_at_node[v]` now holds the net flow that needs to go from `v`'s subtree towards `u`.\n        *   If `flow_at_node[v] > 0`: This means flow `v -> u`.\n            *   If `original_u_edge == v`, `ans[idx] = 0`. Else, `ans[idx] = 1`.\n            *   `current_node_balance += c` (flow enters `u` from `v`).\n        *   Else (`flow_at_node[v] <= 0`): This means flow `u -> v`.\n            *   If `original_u_edge == u`, `ans[idx] = 0`. Else, `ans[idx] = 1`.\n            *   `current_node_balance -= c` (flow leaves `u` for `v`).\n\n4.  After processing all neighbors:\n    *   If `u == n` (sink): All flow must enter `n`. So, `current_node_balance` should be 0.\n    *   If `u == 1` (source): All flow must leave `1`. So, `current_node_balance` should be 0.\n    *   For `1 < u < n`: `current_node_balance` must be 0.\n    *   This logic for `current_node_balance` is for internal flow. The `flow_at_node[u]` is for the flow passing through edge `(u, p)`.\n    *   `flow_at_node[u] = current_node_balance`. This value is then used by the parent `p`.\n\nThis seems like the correct approach. The `flow_at_node[u]` will represent the net flow *out* of the component formed by `u` and its visited children, *upwards* towards `p`.\nFor an intermediate node `u` (1 < `u` < `n`), the sum of incoming flows must equal outgoing flows. This means `flow_at_node[u]` must be 0 for it to be balanced.\nIf `u` is the source (1), it has no incoming flow, so `flow_at_node[1]` will be the total flow leaving the source.\nIf `u` is the sink (`n`), it has no outgoing flow (to its children), so `flow_at_node[n]` should be the total flow entering the sink.\n\nThe problem states \"vertex with number 1 has no incoming edges\". This is very specific.\nThe problem also states \"for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges\".\n\nThis implies that `flow_at_node[u]` should be 0 for `1 < u < n`.\nAnd `flow_at_node[1]` should be the total flow, and `flow_at_node[n]` should be negative total flow (meaning flow enters `n`).\n\nLet's adjust `flow_at_node[u]` to be the *net flow required to enter `u` from its parent* to balance its subtree.\nInitialize `flow_at_node = [0] * (n + 1)`.\n`dfs(u, p)`:\n1.  `visited[u] = True`\n2.  For each edge `(v, c, idx, original_u_edge, original_v_edge)` in `adj[u]`:\n    *   If `v == p`, continue.\n    *   If `visited[v]`: (Cross-edge or back-edge)\n        *   To maintain acyclicity and flow from source to sink: direct `u -> v`.\n        *   If `original_u_edge == u`, `ans[idx] = 0`. Else, `ans[idx] = 1`.\n        *   `flow_at_node[u] -= c` (flow leaves `u`).\n    *   Else (`v` is not visited, `v` is a child in DFS tree):\n        *   `dfs(v, u)`\n        *   After `dfs(v, u)` returns, `flow_at_node[v]` holds the net flow that needs to enter `v` from `u` to balance `v`'s subtree.\n        *   If `flow_at_node[v] > 0`: `u` must send `flow_at_node[v]` to `v`. The edge `(u, v)` must be `u -> v`.\n            *   If `original_u_edge == u`, `ans[idx] = 0`. Else, `ans[idx] = 1`.\n            *   `flow_at_node[u] -= c` (flow leaves `u`).\n        *   Else (`flow_at_node[v] <= 0`): `v`'s subtree has an excess of `abs(flow_at_node[v])` that needs to go to `u`. The edge `(u, v)` must be `v -> u`.\n            *   If `original_u_edge == v`, `ans[idx] = 0`. Else, `ans[idx] = 1`.\n            *   `flow_at_node[u] += c` (flow enters `u` from `v`).\n\n3.  After processing all neighbors:\n    *   If `u == 1` (source): `flow_at_node[1]` should be the total flow leaving the source. But it has no parent to send to. This value will be the total flow.\n    *   If `u == n` (sink): `flow_at_node[n]` should be the total flow entering the sink. It has no parent to send to. This value will be the negative of total flow.\n    *   For `1 < u < n`: `flow_at_node[u]` should be 0, as flow must balance.\n\nThis looks like the correct approach. The `flow_at_node[u]` accumulates the net flow that `u` needs to receive from its parent `p` to balance `u` and its subtree.\nWhen `dfs(1, 0)` completes, `flow_at_node[1]` will be the total flow leaving source. `flow_at_node[n]` will be the total flow entering sink (which is negative of `flow_at_node[1]`). For other nodes, `flow_at_node[u]` should be 0.\nThe problem guarantees a solution exists, so this balancing will work out.\n\nLet's trace an example:\n3 3\n3 2 10 (idx 0)\n1 2 10 (idx 1)\n3 1 5 (idx 2)\n\nn=3, m=3. Source=1, Sink=3.\nAdj list:\n1: [(2, 10, 1, 1, 2), (3, 5, 2, 3, 1)]\n2: [(3, 10, 0, 3, 2), (1, 10, 1, 1, 2)]\n3: [(2, 10, 0, 3, 2), (1, 5, 2, 3, 1)]\n\n`ans = [-1, -1, -1]`\n`visited = [F,F,F,F]`\n`flow_at_node = [0,0,0,0]`\n\n`dfs(1, 0)`:\n  `visited[1] = True`\n  Neighbors of 1:\n  1. `(2, 10, 1, 1, 2)`: `v=2`. Not visited. `p=0`.\n     `dfs(2, 1)`:\n       `visited[2] = True`\n       Neighbors of 2:\n       1. `(3, 10, 0, 3, 2)`: `v=3`. Not visited. `p=1`.\n          `dfs(3, 2)`:\n            `visited[3] = True`\n            Neighbors of 3:\n            1. `(2, 10, 0, 3, 2)`: `v=2`. `v==p` is false. `visited[2]` is True. This is a back-edge.\n               Direct `3 -> 2`. `original_u_edge = 3`. `ans[0] = 0`.\n               `flow_at_node[3] -= 10`. `flow_at_node = [0,0,0,-10]`\n            2. `(1, 5, 2, 3, 1)`: `v=1`. `v==p` is false. `visited[1]` is True. This is a back-edge.\n               Direct `3 -> 1`. `original_u_edge = 3`. `ans[2] = 0`.\n               `flow_at_node[3] -= 5`. `flow_at_node = [0,0,0,-15]`\n            `dfs(3, 2)` returns. `flow_at_node[3] = -15`.\n       Back in `dfs(2, 1)` for neighbor `v=3`: `flow_at_node[3] = -15`. This means `3`'s subtree has an excess of 15 flow that needs to go to `2`. So, edge `(2, 3)` must be `3 -> 2`.\n       `original_u_edge = 3` (for edge 0). `ans[0] = 0` (flow `3 -> 2`).\n       `flow_at_node[2] += 10` (flow enters `2` from `3`). `flow_at_node = [0,0,10,-15]`\n       2. `(1, 10, 1, 1, 2)`: `v=1`. `v==p` is True. Skip.\n       `dfs(2, 1)` returns. `flow_at_node[2] = 10`.\n  Back in `dfs(1, 0)` for neighbor `v=2`: `flow_at_node[2] = 10`. This means `2`'s subtree has an excess of 10 flow that needs to go to `1`. So, edge `(1, 2)` must be `2 -> 1`.\n  `original_u_edge = 1` (for edge 1). `ans[1] = 1` (flow `2 -> 1`).\n  `flow_at_node[1] += 10` (flow enters `1` from `2`). `flow_at_node = [0,10,10,-15]`\n  2. `(3, 5, 2, 3, 1)`: `v=3`. `visited[3]` is True. This is a back-edge.\n     Direct `1 -> 3`. `original_u_edge = 3`. `ans[2] = 1` (flow `1 -> 3`). (Wait, `original_u_edge` is for `3`, `original_v_edge` is for `1`. If original edge was `3 1`, then `u=1, v=3`. `original_u_edge` is `3`, `original_v_edge` is `1`. So `original_u_edge != u`. So `ans[2] = 1` means `1 -> 3`).\n     `flow_at_node[1] -= 5` (flow leaves `1`). `flow_at_node = [0,5,10,-15]`\n`dfs(1, 0)` returns.\n\nFinal `ans`: `[0, 1, 1]`\nExample output: `1\\n0\\n1` (which is `[1, 0, 1]`)\nMy output: `[0, 1, 1]`\n\nMy output for edge 0 (`3 2 10`): `0` means `3 -> 2`.\nMy output for edge 1 (`1 2 10`): `1` means `2 -> 1`.\nMy output for edge 2 (`3 1 5`): `1` means `1 -> 3`.\n\nLet's check the example's output:\nEdge 0 (`3 2 10`): `1` means `2 -> 3`.\nEdge 1 (`1 2 10`): `0` means `1 -> 2`.\nEdge 2 (`3 1 5`): `1` means `1 -> 3`.\n\nExample's flow:\n`1 -> 2` (10 units)\n`2 -> 3` (10 units)\n`1 -> 3` (5 units)\n\nCheck conditions for example's output:\n1.  Source 1: Outgoing `1->2` (10), `1->3` (5). Total 15. No incoming. OK.\n2.  Sink 3: Incoming `2->3` (10), `1->3` (5). Total 15. No outgoing. OK.\n3.  Intermediate 2: Incoming `1->2` (10). Outgoing `2->3` (10). Balance = 0. OK.\n4.  No cycles: `1 -> 2 -> 3`. `1 -> 3`. This is a DAG. OK.\n\nMy logic seems to have produced a different valid solution.\nMy solution:\n`3 -> 2` (10 units)\n`2 -> 1` (10 units)\n`1 -> 3` (5 units)\n\nCheck my solution:\n1.  Source 1: Incoming `2->1` (10). Outgoing `1->3` (5). Balance `10 - 5 = 5 != 0`. This violates flow conservation for the source (no incoming edges).\nThe condition \"vertex with number 1 has no incoming edges\" means that `flow_at_node[1]` must be negative (flow leaves 1).\nThe condition \"for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges\" means `flow_at_node[v]` must be 0 for `1 < v < n`.\n\nMy definition of `flow_at_node[u]` was \"net flow required to enter `u` from its parent to balance its subtree\".\nIf `flow_at_node[u]` is positive, it means `u` needs `flow_at_node[u]` from parent. So parent sends to `u`.\nIf `flow_at_node[u]` is negative, it means `u` has `abs(flow_at_node[u])` to send to parent. So `u` sends to parent.\n\nLet's re-evaluate the `flow_at_node` meaning.\n`flow_at_node[u]` = `sum(flow_from_children_to_u) - sum(flow_from_u_to_children_and_cross_edges)`.\nThis value represents the net flow that `u` needs to receive from its parent `p` to satisfy conservation *within its subtree*.\nSo, if `flow_at_node[u] > 0`, `u` needs `flow_at_node[u]` from `p`. Edge `(p, u)` is `p -> u`.\nIf `flow_at_node[u] < 0`, `u` has `abs(flow_at_node[u])` to send to `p`. Edge `(p, u)` is `u -> p`.\nIf `flow_at_node[u] == 0`, `u` is balanced internally.\n\nSpecial cases:\n*   Source `1`: It cannot receive from parent (`p=0`). So `flow_at_node[1]` must be 0.\n*   Sink `n`: It doesn't send flow to parent (`p` is some node). It must receive all flow. So `flow_at_node[n]` must be the total flow volume.\n\nThis implies that the `flow_at_node[u]` should be initialized based on these conditions.\nFor `u == n`, `flow_at_node[n]` should be the total flow that needs to enter `n`. This is the sum of `c_i` for edges connected to `n`.\nNo, that's not right. The `flow_at_node[u]` is what is *passed up* to the parent.\nThe total flow is not given. We only have `c_i` for each edge.\n\nLet's use a simpler definition for `flow_at_node[u]`: it's the sum of flows on edges from `u` to its children (in DFS tree) minus flows from children to `u`, plus flows on cross-edges/back-edges. This is the net flow *leaving* `u` in its local context.\n\nFinal attempt at DFS logic:\n`adj`: `u -> [(v, c, idx, original_u, original_v)]`\n`ans = [-1] * m`\n`visited = [False] * (n + 1)`\n`net_flow_out = [0] * (n + 1)` (This will store the net flow *out* of `u` into its parent `p`)\n\n`dfs(u, p)`:\n1.  `visited[u] = True`\n2.  For each edge `(v, c, idx, original_u_edge, original_v_edge)` in `adj[u]`:\n    *   If `v == p`, continue.\n    *   If `visited[v]`: // This is a back-edge or cross-edge\n        *   If `u == 1` and `v == n`: This is a direct `1 -> n` path. Direct `1 -> n`.\n            *   If `original_u_edge == u`, `ans[idx] = 0`. Else, `ans[idx] = 1`.\n            *   `net_flow_out[u] += c` (flow leaves `u` towards `v`).\n        *   Else if `u == n` and `v == 1`: This is a direct `n -> 1` path. This is impossible given `1` has no incoming. So this edge must be `1 -> n`.\n            *   If `original_u_edge == v`, `ans[idx] = 0`. Else, `ans[idx] = 1`. (This means `v -> u`, i.e., `1 -> n`)\n            *   `net_flow_out[u] -= c` (flow enters `u` from `v`).\n        *   Else: (General back/cross-edge `u` to `v` where `v` is already visited)\n            *   To ensure no cycles, we need to direct from \"earlier\" to \"later\" in DFS tree. Since `v` is visited, it's \"earlier\". So `v -> u` is a back-edge, `u -> v` is a forward/cross-edge.\n            *   We will direct `u -> v`. This is a heuristic that usually works for DAGs.\n            *   If `original_u_edge == u`, `ans[idx] = 0`. Else, `ans[idx] = 1`.\n            *   `net_flow_out[u] += c` (flow leaves `u` towards `v`).\n    *   Else (`v` is not visited, so `v` is a child in DFS tree):\n        *   `dfs(v, u)`\n        *   After `dfs(v, u)` returns, `net_flow_out[v]` holds the net flow that `v`'s subtree is sending *out* through `v` towards `u`.\n        *   If `net_flow_out[v] > 0`: This means flow `v -> u`.\n            *   If `original_u_edge == v`, `ans[idx] = 0`. Else, `ans[idx] = 1`.\n            *   `net_flow_out[u] += c` (flow enters `u` from `v`).\n        *   Else (`net_flow_out[v] <= 0`): This means flow `u -> v`.\n            *   If `original_u_edge == u`, `ans[idx] = 0`. Else, `ans[idx] = 1`.\n            *   `net_flow_out[u] -= c` (flow leaves `u` for `v`).\n\n3.  After processing all neighbors:\n    *   If `u == n` (sink): All flow must enter `n`. So, `net_flow_out[n]` should be 0. (Actually, it's the sum of all incoming flows to `n` from its children, minus any outgoing flows to children. It should be the total flow that has entered `n`.)\n    *   If `u == 1` (source): All flow must leave `1`. `net_flow_out[1]` represents the total flow leaving the source.\n\nThe problem constraints `1 < v < n`, `vertex 1 has no incoming edges`.\nThis implies that `net_flow_out[u]` for `1 < u < n` must be 0.\nAnd `net_flow_out[1]` must be the total flow (positive).\nAnd `net_flow_out[n]` must be the negative of total flow (meaning total flow enters `n`).\n\nLet's adjust `net_flow_out[u]` to be `sum(outgoing_flow) - sum(incoming_flow)` for `u` and its subtree, excluding the parent edge.\n`dfs(u, p)`:\n1.  `visited[u] = True`\n2.  `current_balance_for_u = 0` (local balance for `u` and its children)\n3.  For each edge `(v, c, idx, original_u_edge, original_v_edge)` in `adj[u]`:\n    *   If `v == p`, continue.\n    *   If `visited[v]`: // This is a back-edge or cross-edge.\n        *   We need to direct `u -> v` to maintain DAG property (flow away from source).\n        *   If `original_u_edge == u`, `ans[idx] = 0`. Else, `ans[idx] = 1`.\n        *   `current_balance_for_u += c` (flow leaves `u`).\n    *   Else (`v` is not visited, `v` is a child in DFS tree):\n        *   `dfs(v, u)`\n        *   `current_balance_for_u += net_flow_out[v]` (flow from `v`'s subtree contributes to `u`'s balance)\n        *   If `net_flow_out[v] > 0`: This means flow `v -> u`.\n            *   If `original_u_edge == v`, `ans[idx] = 0`. Else, `ans[idx] = 1`.\n        *   Else (`net_flow_out[v] <= 0`): This means flow `u -> v`.\n            *   If `original_u_edge == u`, `ans[idx] = 0`. Else, `ans[idx] = 1`.\n            \n4.  After processing all neighbors:\n    *   If `u == n`: `net_flow_out[n] = current_balance_for_u - total_flow_entering_n`. (This is where it gets complex without knowing total flow).\n    *   A simpler way: `net_flow_out[u]` is the net flow that *must pass upwards* through `u` to its parent.\n    *   For `u == n` (sink): All flow must eventually reach `n`. So, `n` will have `current_balance_for_u` as the sum of all flows that entered its subtree. This must be `0` if `n` itself is not contributing to any \"upward\" flow.\n    *   For `u != n`: `net_flow_out[u] = current_balance_for_u`.\n\nLet's initialize `net_flow_out[u]` to `c` if `u=n` for some edge `(u,v,c)` and `v=n`.\nNo, this is not how it works. `net_flow_out[u]` is the aggregate flow for `u` and its children.\n\nThe solution must be simpler. The \"no cycles\" condition is the most restrictive.\nA DFS from source 1 naturally builds a DAG by directing tree edges `parent -> child` and back-edges `child -> ancestor`. What about cross-edges? Direct from earlier visited to later visited.\n\nLet's use the provided solution structure from similar problems:\nThe `net_flow_out[u]` value for a node `u` (that is not the sink `n`) should effectively be zero after all its children have been processed, if it's an intermediate node. If it's the source `1`, it will have a net positive flow equal to the total flow.\n\n`dfs(u, p)`:\n1.  `visited[u] = True`\n2.  `flow_deficit = 0` (This will track `sum(incoming_flow) - sum(outgoing_flow)` for `u` and its subtree, *excluding* the edge to `p`)\n3.  For each edge `(v, c, idx, original_u_edge, original_v_edge)` in `adj[u]`:\n    *   If `v == p`, continue.\n    *   If `visited[v]`: // `v` is an already visited node (back-edge or cross-edge).\n        *   Since `v` was visited, it's \"earlier\" in the DFS order. To avoid cycles, we must direct `u -> v`.\n        *   If `original_u_edge == u`, `ans[idx] = 0`. Else, `ans[idx] = 1`.\n        *   `flow_deficit += c` (flow leaves `u`).\n    *   Else (`v` is not visited, `v` is a child in DFS tree):\n        *   `dfs(v, u)`\n        *   `flow_deficit += flow_deficit_from_subtree[v]` (add the deficit from `v`'s subtree)\n        *   If `flow_deficit_from_subtree[v] > 0`: This means `v`'s subtree has an excess flow of `flow_deficit_from_subtree[v]` that needs to flow *up* to `u`. So, edge `(u, v)` must be directed `v -> u`.\n            *   If `original_u_edge == v`, `ans[idx] = 0`. Else, `ans[idx] = 1`.\n        *   Else (`flow_deficit_from_subtree[v] <= 0`): This means `v`'s subtree has a deficit of `abs(flow_deficit_from_subtree[v])` that needs to flow *down* from `u`. So, edge `(u, v)` must be directed `u -> v`.\n            *   If `original_u_edge == u`, `ans[idx] = 0`. Else, `ans[idx] = 1`.\n\n4.  After processing all neighbors:\n    *   `flow_deficit_from_subtree[u] = current_balance_for_u`.\n    *   Special case for sink `n`: If `u == n`, `flow_deficit_from_subtree[n]` should be the total flow.\n    *   Special case for source `1`: If `u == 1`, `flow_deficit_from_subtree[1]` should be the total flow.\n\nThis `flow_deficit` variable logic is still a bit confusing. Let's use `current_excess_flow_out_of_subtree`.\nInitialize `current_excess_flow_out_of_subtree = [0] * (n + 1)`.\n`dfs(u, p)`:\n1.  `visited[u] = True`\n2.  For each edge `(v, c, idx, original_u_edge, original_v_edge)` in `adj[u]`:\n    *   If `v == p`, continue.\n    *   If `visited[v]`: // `v` is an already visited node.\n        *   Direct `u -> v` to maintain DAG property.\n        *   If `original_u_edge == u`, `ans[idx] = 0`. Else, `ans[idx] = 1`.\n        *   `current_excess_flow_out_of_subtree[u] += c` (flow leaves `u`).\n    *   Else (`v` is not visited, `v` is a child in DFS tree):\n        *   `dfs(v, u)`\n        *   If `current_excess_flow_out_of_subtree[v] > 0`: This means `v`'s subtree has an excess flow of `current_excess_flow_out_of_subtree[v]` that needs to flow *up* to `u`. So, edge `(u, v)` must be directed `v -> u`.\n            *   If `original_u_edge == v`, `ans[idx] = 0`. Else, `ans[idx] = 1`.\n            *   `current_excess_flow_out_of_subtree[u] -= c` (flow enters `u` from `v`).\n        *   Else (`current_excess_flow_out_of_subtree[v] <= 0`): This means `v`'s subtree has a deficit of `abs(current_excess_flow_out_of_subtree[v])` that needs to flow *down* from `u`. So, edge `(u, v)` must be directed `u -> v`.\n            *   If `original_u_edge == u`, `ans[idx] = 0`. Else, `ans[idx] = 1`.\n            *   `current_excess_flow_out_of_subtree[u] += c` (flow leaves `u` for `v`).\n\n3.  After processing all neighbors:\n    *   If `u == n`: The sink `n` must receive all flow. So, all flow should enter `n`. This means `current_excess_flow_out_of_subtree[n]` should be 0.\n    *   This is the key: `current_excess_flow_out_of_subtree[n]` should be zero.\n    *   For `u != n`: `current_excess_flow_out_of_subtree[u]` will be the net flow that needs to go to `p`.\n\nLet's re-examine `current_excess_flow_out_of_subtree[u]`. It should be `sum(outgoing) - sum(incoming)` from `u` to its children/cross-edges.\nIf `u == n`, this sum should be 0.\nIf `u == 1`, this sum should be the total flow.\nFor `1 < u < n`, this sum should be 0.\n\nMy DFS must be structured to enforce these conditions.\nThe problem statement: \"vertex with number 1 has no incoming edges\".\n\"for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges\".\n\nThis means all intermediate nodes must have a net flow of zero. The source must have a net positive flow, and the sink must have a net negative flow (equal to total flow).\n\nSo, `current_excess_flow_out_of_subtree[u]` must be 0 for `1 < u < n`.\nFor `u = n`, `current_excess_flow_out_of_subtree[n]` should represent the total flow *entering* `n`.\nFor `u = 1`, `current_excess_flow_out_of_subtree[1]` should represent the total flow *leaving* `1`.\n\nLet `dfs(u, p)` return the net flow that `u` needs to receive from its parent `p` to balance itself and its subtree.\n`dfs(u, p)`:\n1.  `visited[u] = True`\n2.  `net_flow_needed_from_parent = 0`\n3.  For each edge `(v, c, idx, original_u_edge, original_v_edge)` in `adj[u]`:\n    *   If `v == p`, continue.\n    *   If `visited[v]`: // Back-edge or cross-edge\n        *   Direct `u -> v`. (Flow leaves `u`).\n        *   If `original_u_edge == u`, `ans[idx] = 0`. Else, `ans[idx] = 1`.\n        *   `net_flow_needed_from_parent += c` (This flow leaves `u`, so `u` needs more from parent).\n    *   Else (`v` is not visited, `v` is a child in DFS tree):\n        *   `child_needs = dfs(v, u)`\n        *   If `child_needs > 0`: `u` must send `child_needs` to `v`. Edge `(u, v)` is `u -> v`.\n            *   If `original_u_edge == u`, `ans[idx] = 0`. Else, `ans[idx] = 1`.\n            *   `net_flow_needed_from_parent += c` (This flow leaves `u`).\n        *   Else (`child_needs <= 0`): `v` has `abs(child_needs)` to send to `u`. Edge `(u, v)` is `v -> u`.\n            *   If `original_u_edge == v`, `ans[idx] = 0`. Else, `ans[idx] = 1`.\n            *   `net_flow_needed_from_parent -= c` (This flow enters `u`).\n\n4.  After processing all neighbors:\n    *   If `u == n`: The sink `n` should effectively not need any flow from its parent. It must consume all flow. So the `net_flow_needed_from_parent` for `n` should be 0.\n        *   Return `0`.\n    *   If `u == 1`: The source `1` has no parent. It provides flow. The `net_flow_needed_from_parent` will be the total flow that `1` sends out.\n        *   Return `net_flow_needed_from_parent`.\n    *   For `1 < u < n`: Intermediate nodes must balance. `net_flow_needed_from_parent` for `u` should be 0.\n        *   Return `net_flow_needed_from_parent`.\n\nThis looks promising. The `net_flow_needed_from_parent` is `sum(outgoing_flow) - sum(incoming_flow)` for `u` and its subtree.\nFor `u = n`, this sum must be 0. So, if it's not 0, we need to adjust it.\nLet's initialize `net_flow_needed_from_parent[u]` for `u != n` to 0. For `u = n`, it's the sum of flows on edges incident to `n`.\n\nFinal algorithm:\n1.  Store edges: `adj[u]` will contain `(v, flow_volume, edge_index, original_u, original_v)`.\n2.  `ans = [-1] * m`\n3.  `visited = [False] * (n + 1)`\n4.  `flow_balance = [0] * (n + 1)`: This will track `sum(outgoing_flow) - sum(incoming_flow)` for `u` and its subtree, *excluding* the edge to `p`.\n    *   Initialize `flow_balance[n]` by summing all `ci` for edges connected to `n`. This is the total flow *entering* `n`. So, `flow_balance[n] = - (total flow into n)`.\n    *   No, this is not right. The flow `ci` is given for *undirected* edges. We don't know which direction is into `n` yet.\n\nThe simplest approach that works for competitive programming problems is often a DFS that prioritizes tree edges and then handles back/cross edges.\nThe key conditions are:\n1. DAG (DFS from source generally gives this).\n2. Flow conservation for `1 < v < n`.\n3. Source 1 has no incoming.\n\nLet's use a `current_flow_sum` that gets updated as we make decisions.\n`dfs(u, p)`:\n1.  `visited[u] = True`\n2.  `current_node_flow_out = 0` (sum of flow directed *out* of `u` to its children/cross-edges, minus flow directed *into* `u` from children/cross-edges)\n3.  For each edge `(v, c, idx, original_u_edge, original_v_edge)` in `adj[u]`:\n    *   If `v == p`, continue.\n    *   If `visited[v]`: // `v` is an already visited node (back-edge or cross-edge).\n        *   If `ans[idx]` is already set, this edge was handled from `v`'s DFS call. Skip.\n        *   Direct `u -> v` to maintain DAG property.\n        *   If `original_u_edge == u`, `ans[idx] = 0`. Else, `ans[idx] = 1`.\n        *   `current_node_flow_out += c`.\n    *   Else (`v` is not visited, `v` is a child in DFS tree):\n        *   `child_flow_out = dfs(v, u)`\n        *   If `child_flow_out > 0`: This means `v`'s subtree has an excess `child_flow_out` that needs to flow *up* to `u`. So, edge `(u, v)` must be directed `v -> u`.\n            *   If `original_u_edge == v`, `ans[idx] = 0`. Else, `ans[idx] = 1`.\n            *   `current_node_flow_out -= c`. (Flow enters `u`).\n        *   Else (`child_flow_out <= 0`): This means `v`'s subtree has a deficit `abs(child_flow_out)` that needs to flow *down* from `u`. So, edge `(u, v)` must be directed `u -> v`.\n            *   If `original_u_edge == u`, `ans[idx] = 0`. Else, `ans[idx] = 1`.\n            *   `current_node_flow_out += c`. (Flow leaves `u`).\n\n4.  After processing all neighbors:\n    *   If `u == n`: The sink `n` must absorb all flow. It doesn't send any flow up to its parent `p`. So, `current_node_flow_out` must be 0 relative to `p`.\n        *   Return `0`.\n    *   For `u != n`: `current_node_flow_out` will be the net flow that `u` (and its subtree) sends *out* to its parent `p`.\n        *   Return `current_node_flow_out`.\n\nThis revised `dfs` returns the net flow *out* of the subtree rooted at `u` (including `u` itself) that must pass through the edge `(u, p)`.\nWhen `dfs(1, 0)` completes, `current_node_flow_out` for `u=1` will be the total max flow.\nFor any `1 < u < n`, its `current_node_flow_out` must be 0.\nLet's trace the example with this logic:\n3 3\n3 2 10 (idx 0)\n1 2 10 (idx 1)\n3 1 5 (idx 2)\n\n`adj`:\n1: [(2, 10, 1, 1, 2), (3, 5, 2, 3, 1)]\n2: [(3, 10, 0, 3, 2), (1, 10, 1, 1, 2)]\n3: [(2, 10, 0, 3, 2), (1, 5, 2, 3, 1)]\n\n`ans = [-1,-1,-1]`\n`visited = [F,F,F,F]`\n\n`dfs(1, 0)`:\n  `visited[1] = True`\n  `current_node_flow_out = 0`\n  Neighbors of 1:\n  1. `(2, 10, 1, 1, 2)`: `v=2`. Not visited. `p=0`.\n     `child_flow_out = dfs(2, 1)`:\n       `visited[2] = True`\n       `current_node_flow_out_2 = 0`\n       Neighbors of 2:\n       1. `(3, 10, 0, 3, 2)`: `v=3`. Not visited. `p=1`.\n          `child_flow_out_3 = dfs(3, 2)`:\n            `visited[3] = True`\n            `current_node_flow_out_3 = 0`\n            Neighbors of 3:\n            1. `(2, 10, 0, 3, 2)`: `v=2`. `v==p` is false. `visited[2]` is True. `ans[0]` is `-1`.\n               Direct `3 -> 2`. `original_u_edge = 3`. `ans[0] = 0`.\n               `current_node_flow_out_3 += 10`. (`current_node_flow_out_3 = 10`)\n            2. `(1, 5, 2, 3, 1)`: `v=1`. `v==p` is false. `visited[1]` is True. `ans[2]` is `-1`.\n               Direct `3 -> 1`. `original_u_edge = 3`. `ans[2] = 0`.\n               `current_node_flow_out_3 += 5`. (`current_node_flow_out_3 = 15`)\n            Return `0` (because `u=3` is sink).\n          `child_flow_out_3` is `0`.\n          `child_flow_out_3 <= 0` is true. So edge `(2, 3)` is directed `2 -> 3`.\n          `original_u_edge = 3` (for edge 0). `ans[0]` is already `0` (from `dfs(3,2)`). This is a problem. An edge should be directed only once.\n\nThe issue is with `visited[v]` condition. If `visited[v]` and `ans[idx]` is not set, it means `v` has been visited, and this edge is a cross-edge or back-edge relative to `u`. If `ans[idx]` *is* set, it means the other end (`v`) already processed this edge.\n\nCorrected `visited[v]` part:\nWhen `visited[v]` is true, this means `v` is an ancestor of `u` (back-edge) or `v` is in a different subtree (cross-edge).\nIn either case, to maintain acyclicity and flow from source to sink, we should direct `u -> v` if `v` was visited \"earlier\" than `u`. This is generally true for DFS.\nHowever, if `v` is an ancestor, `u -> v` would create a cycle. So it must be `v -> u`.\nIf `v` is a cross-edge, either direction could work.\n\nThe crucial part is that the problem guarantees a solution exists and implies a max-flow.\nThe example output uses `1->2`, `2->3`, `1->3`. This means flow is always increasing \"level\".\nThis suggests a BFS-like approach might be better, or a DFS that strictly directs `parent -> child` and then resolves other edges.\n\nLet's use the provided example output as the reference.\n`1 -> 2` (10 units)\n`2 -> 3` (10 units)\n`1 -> 3` (5 units)\n\nThis implies that for any edge `(u, v)`:\nIf `u=1`, `v=2`, it's `1->2`.\nIf `u=1`, `v=3`, it's `1->3`.\nIf `u=2`, `v=3`, it's `2->3`.\n\nThis looks like a simple level-based direction. If we do a BFS from `1`, let `dist[u]` be the distance.\nFor an edge `(u, v)`:\nIf `dist[u] < dist[v]`, direct `u -> v`.\nIf `dist[v] < dist[u]`, direct `v -> u`.\nIf `dist[u] == dist[v]`, this is a cross-edge. This is the tricky part. If we allow this, it might create cycles or violate flow conservation.\n\nHowever, the problem states \"the obtained directed graph does not have cycles\".\nIf we use a BFS from `1`, and only direct edges `u -> v` if `dist[u] < dist[v]`, then we get a DAG.\nWhat about `dist[u] == dist[v]`? If such an edge exists, it's a cross-edge. Directing it arbitrarily might create a cycle.\n\nThe most robust way to guarantee a DAG is to use a topological sort. But we don't have the directions yet.\nThe DFS with `flow_out` logic is the standard way to solve such problems. The issue is how to handle `visited[v]` and `ans[idx]` conditions.\n\nThe standard solution for this problem type is to use a DFS that determines the net flow leaving a subtree.\nThe `visited[v]` check in the DFS should be `if visited[v] and ans[idx] == -1`. If `ans[idx]` is already set, it means the edge was processed when `v` was the current node. This happens for tree edges.\n\nLet's dry run the DFS one last time.\n`dfs(u, p)`:\n1.  `visited[u] = True`\n2.  `current_flow_balance = 0` (this is `sum(flow_out) - sum(flow_in)` for `u` and its children)\n3.  For each edge `(v, c, idx, original_u_edge, original_v_edge)` in `adj[u]`:\n    *   If `v == p`, continue.\n    *   If `ans[idx] != -1`: // Edge already directed by `v`'s call (tree edge)\n        *   Continue.\n    *   If `visited[v]`: // `v` is visited, but this edge is not yet directed. This must be a cross-edge.\n        *   Direct `u -> v` (flow leaves `u`). This ensures DAG property.\n        *   If `original_u_edge == u`, `ans[idx] = 0`. Else, `ans[idx] = 1`.\n        *   `current_flow_balance += c`.\n    *   Else (`v` is not visited, `v` is a child in DFS tree):\n        *   `child_balance = dfs(v, u)`\n        *   If `child_balance > 0`: This means `v`'s subtree has an excess `child_balance` that needs to flow *up* to `u`. So, edge `(u, v)` must be directed `v -> u`.\n            *   If `original_u_edge == v`, `ans[idx] = 0`. Else, `ans[idx] = 1`.\n            *   `current_flow_balance -= c`. (Flow enters `u`).\n        *   Else (`child_balance <= 0`): This means `v`'s subtree has a deficit `abs(child_balance)` that needs to flow *down* from `u`. So, edge `(u, v)` must be directed `u -> v`.\n            *   If `original_u_edge == u`, `ans[idx] = 0`. Else, `ans[idx] = 1`.\n            *   `current_flow_balance += c`. (Flow leaves `u`).\n\n4.  After processing all neighbors:\n    *   If `u == n`: The sink `n` must absorb all flow. It should not send any net flow up to its parent.\n        *   Return `0`.\n    *   For `u != n`: `current_flow_balance` is the net flow that `u` (and its subtree) sends *out* to its parent `p`.\n        *   Return `current_flow_balance`.\n\nLet's dry run example 1 again with this refined logic:\n3 3\n3 2 10 (idx 0)\n1 2 10 (idx 1)\n3 1 5 (idx 2)\n\n`adj`:\n1: [(2, 10, 1, 1, 2), (3, 5, 2, 3, 1)]\n2: [(3, 10, 0, 3, 2), (1, 10, 1, 1, 2)]\n3: [(2, 10, 0, 3, 2), (1, 5, 2, 3, 1)]\n\n`ans = [-1,-1,-1]`\n`visited = [F,F,F,F]`\n\n`dfs(1, 0)`:\n  `visited[1] = True`\n  `current_flow_balance_1 = 0`\n  Neighbors of 1:\n  1. `(2, 10, 1, 1, 2)`: `v=2`. `p=0`. `ans[1]` is `-1`. Not visited.\n     `child_balance_2 = dfs(2, 1)`:\n       `visited[2] = True`\n       `current_flow_balance_2 = 0`\n       Neighbors of 2:\n       1. `(3, 10, 0, 3, 2)`: `v=3`. `p=1`. `ans[0]` is `-1`. Not visited.\n          `child_balance_3 = dfs(3, 2)`:\n            `visited[3] = True`\n            `current_flow_balance_3 = 0`\n            Neighbors of 3:\n            1. `(2, 10, 0, 3, 2)`: `v=2`. `p=2`. `ans[0]` is `-1`. `visited[2]` is True. This is a cross-edge.\n               Direct `3 -> 2`. `original_u_edge = 3`. `ans[0] = 0`.\n               `current_flow_balance_3 += 10`. (`current_flow_balance_3 = 10`)\n            2. `(1, 5, 2, 3, 1)`: `v=1`. `p=2`. `ans[2]` is `-1`. `visited[1]` is True. This is a cross-edge.\n               Direct `3 -> 1`. `original_u_edge = 3`. `ans[2] = 0`.\n               `current_flow_balance_3 += 5`. (`current_flow_balance_3 = 15`)\n            Return `0` (because `u=3` is sink).\n          `child_balance_3` is `0`.\n          `child_balance_3 <= 0` is true. So edge `(2, 3)` is directed `2 -> 3`.\n          `original_u_edge = 3` (for edge 0). `ans[0]` is already `0`. This is the issue. The edge `(3,2)` was directed `3->2` from `dfs(3,2)`. Now `dfs(2,1)` wants to direct `2->3`. This is a conflict.\n\nThe `visited[v]` check should be `if visited[v] and ans[idx] == -1 and v != n`.\nThe rule for cross-edges and back-edges must be consistent.\nIf `v` is visited, and `ans[idx]` is `-1`, it implies `u` is visiting `v` as a non-tree edge for the first time.\nIf `v` is an ancestor of `u` (back-edge), we must direct `v -> u` to avoid a cycle.\nIf `v` is in a different subtree (cross-edge), we can direct `u -> v` or `v -> u`.\n\nThe problem is that the DFS order might not align with the \"levels\" of the max-flow.\nThe example output implies `1 -> 2 -> 3` and `1 -> 3`. This is a DAG where `1` is level 0, `2` is level 1, `3` is level 2.\nThis means flow goes from lower level to higher level.\nLet's use a BFS from source `1` to assign levels.\n`dist = [-1] * (n + 1)`\n`q = collections.deque([1])`\n`dist[1] = 0`\nWhile `q`: `u = q.popleft()`. For `(v, c, idx, ou, ov)` in `adj[u]`: if `dist[v] == -1`: `dist[v] = dist[u] + 1`; `q.append(v)`.\n\nAfter BFS, `dist` array is set. Now direct edges.\nFor each edge `(u, v, c, idx)`:\nIf `dist[u] < dist[v]`: `u -> v`. `ans[idx] = 0` if `original_u == u`, else `ans[idx] = 1`.\nIf `dist[v] < dist[u]`: `v -> u`. `ans[idx] = 0` if `original_u == v`, else `ans[idx] = 1`.\nIf `dist[u] == dist[v]`: This is a cross-edge. This is the problematic part.\nThe problem statement says \"a solution always exists.\" This might mean there are no cross-edges with `dist[u] == dist[v]` in the max-flow graph. Or, if there are, they must be directed in a specific way.\n\nIf there are no cross-edges with `dist[u] == dist[v]`, then BFS levels are sufficient.\nHowever, for a general undirected graph, `dist[u] == dist[v]` is possible.\nThe \"no cycles\" condition is the strongest. The problem implies a single source and single sink.\nA common property of max-flow graphs (residual graphs) is that there are no cycles of positive capacity edges.\n\nThe most robust approach for flow conservation and DAG is the DFS with `current_flow_balance` returning from children.\nThe conflict in the dry run (`ans[0]` was set to `0` from `dfs(3,2)` and then tried to be set to `1` from `dfs(2,1)`) means that the check `if ans[idx] != -1` should be at the very top of the loop.\n\nRevised DFS structure:\n`dfs(u, p)`:\n1.  `visited[u] = True`\n2.  `current_flow_balance = 0`\n3.  For each edge `(v, c, idx, original_u_edge, original_v_edge)` in `adj[u]`:\n    *   If `ans[idx] != -1`: // Edge already directed by the other endpoint's DFS call.\n        *   Continue.\n    *   If `v == p`, continue. // This ensures we don't go back up the DFS tree immediately.\n    *   If `visited[v]`: // `v` is visited, but this edge is not yet directed. This must be a cross-edge.\n        *   Direct `u -> v` (flow leaves `u`). This ensures DAG property (flow from earlier visited to later visited).\n        *   If `original_u_edge == u`, `ans[idx] = 0`. Else, `ans[idx] = 1`.\n        *   `current_flow_balance += c`.\n    *   Else (`v` is not visited, `v` is a child in DFS tree):\n        *   `child_balance = dfs(v, u)`\n        *   If `child_balance > 0`: This means `v`'s subtree has an excess `child_balance` that needs to flow *up* to `u`. So, edge `(u, v)` must be directed `v -> u`.\n            *   If `original_u_edge == v`, `ans[idx] = 0`. Else, `ans[idx] = 1`.\n            *   `current_flow_balance -= c`. (Flow enters `u`).\n        *   Else (`child_balance <= 0`): This means `v`'s subtree has a deficit `abs(child_balance)` that needs to flow *down* from `u`. So, edge `(u, v)` must be directed `u -> v`.\n            *   If `original_u_edge == u`, `ans[idx] = 0`. Else, `ans[idx] = 1`.\n            *   `current_flow_balance += c`. (Flow leaves `u`).\n\n4.  After processing all neighbors:\n    *   If `u == n`: Return `0`. (Sink absorbs flow, doesn't send net flow upwards).\n    *   Else: Return `current_flow_balance`. (Net flow `u` sends upwards to `p`).\n\nDry run example 1 with this:\n3 3\n3 2 10 (idx 0)\n1 2 10 (idx 1)\n3 1 5 (idx 2)\n\n`dfs(1, 0)`:\n  `visited[1] = T`, `cb1=0`\n  Neighbors of 1:\n  1. `(2, 10, 1, 1, 2)`: `v=2`. `ans[1]` is `-1`. Not visited.\n     `child_balance_2 = dfs(2, 1)`:\n       `visited[2] = T`, `cb2=0`\n       Neighbors of 2:\n       1. `(3, 10, 0, 3, 2)`: `v=3`. `ans[0]` is `-1`. Not visited.\n          `child_balance_3 = dfs(3, 2)`:\n            `visited[3] = T`, `cb3=0`\n            Neighbors of 3:\n            1. `(2, 10, 0, 3, 2)`: `v=2`. `ans[0]` is `-1`. `v!=p`. `visited[2]` is T. Cross-edge.\n               Direct `3 -> 2`. `original_u_edge = 3`. `ans[0] = 0`.\n               `cb3 += 10`. (`cb3 = 10`)\n            2. `(1, 5, 2, 3, 1)`: `v=1`. `ans[2]` is `-1`. `v!=p`. `visited[1]` is T. Cross-edge.\n               Direct `3 -> 1`. `original_u_edge = 3`. `ans[2] = 0`.\n               `cb3 += 5`. (`cb3 = 15`)\n            Return `0` (because `u=3` is sink).\n          `child_balance_3` is `0`.\n          `child_balance_3 <= 0` is true. So edge `(2, 3)` is directed `2 -> 3`.\n          `original_u_edge = 3` (for edge 0). `ans[0]` is `0`. This is the issue. `ans[0]` is already set to `0` for `3->2`. Now it wants `2->3`. This is a direct conflict.\n\nThe problem is that `ans[idx]` is set *when an edge is first encountered as a cross-edge*.\nBut a cross-edge from `u` to `v` might be a tree edge from `v` to `u` when `v` is visited.\n\nThe logic for `visited[v]` should be:\nIf `visited[v]` and `ans[idx] == -1`: (This is a cross-edge or back-edge)\n  If `u == n`: This edge must be incoming to `n`. So `v -> n`.\n    If `original_u_edge == v`, `ans[idx] = 0`. Else, `ans[idx] = 1`.\n    `current_flow_balance -= c`.\n  Else if `v == n`: This edge must be outgoing from `u` to `n`. So `u -> n`.\n    If `original_u_edge == u`, `ans[idx] = 0`. Else, `ans[idx] = 1`.\n    `current_flow_balance += c`.\n  Else: (General cross-edge `u` to `v` where neither is source/sink)\n    Direct `u -> v`.\n    If `original_u_edge == u`, `ans[idx] = 0`. Else, `ans[idx] = 1`.\n    `current_flow_balance += c`.\n\nLet's trace the example with this logic for `visited[v]` and `ans[idx] == -1`:\n`dfs(3,2)`:\n  `visited[3]=T`, `cb3=0`\n  Neighbors of 3:\n  1. `(2, 10, 0, 3, 2)`: `v=2`. `ans[0]==-1`. `v!=p`. `visited[2]` is T. `u=3` is `n`.\n     Edge `v -> n` means `2 -> 3`.\n     `original_u_edge = 3`. `original_u_edge != v`. So `ans[0] = 1`. (flow `2 -> 3`).\n     `cb3 -= 10`. (`cb3 = -10`)\n  2. `(1, 5, 2, 3, 1)`: `v=1`. `ans[2]==-1`. `v!=p`. `visited[1]` is T. `u=3` is `n`.\n     Edge `v -> n` means `1 -> 3`.\n     `original_u_edge = 3`. `original_u_edge != v`. So `ans[2] = 1`. (flow `1 -> 3`).\n     `cb3 -= 5`. (`cb3 = -15`)\n  Return `0` (because `u=3` is sink).\n\nNow back to `dfs(2,1)`:\n  `child_balance_3` is `0`.\n  `child_balance_3 <= 0` is true. So edge `(2, 3)` is directed `2 -> 3`.\n  `original_u_edge = 3` (for edge 0). `ans[0]` is `1`. This is consistent with `2->3`.\n  `cb2 += 10`. (`cb2 = 10`). (Flow leaves `2` for `3`).\n  Wait, if `child_balance_3 <= 0` and edge is `u -> v`, means `u` sends flow to `v`. So `cb2 += c`.\n  This is `cb2 += 10`.\n\n  Neighbors of 2:\n  1. `(3, 10, 0, 3, 2)`: This was processed. `ans[0]` is 1.\n  2. `(1, 10, 1, 1, 2)`: `v=1`. `ans[1]` is `-1`. `v!=p`. `visited[1]` is T. `u=2` not `n`. `v=1` not `n`. General cross-edge.\n     Direct `2 -> 1`.\n     `original_u_edge = 1`. `original_u_edge == u`. `ans[1] = 0`.\n     `cb2 += 10`. (`cb2 = 20`)\n  Return `cb2 = 20`.\n\nBack to `dfs(1,0)`:\n  `child_balance_2` is `20`.\n  `child_balance_2 > 0` is true. So edge `(1, 2)` is directed `2 -> 1`.\n  `original_u_edge = 1` (for edge 1). `original_u_edge == v`. `ans[1] = 1`.\n  `cb1 -= 10`. (`cb1 = -10`)\n\n  Neighbors of 1:\n  1. `(2, 10, 1, 1, 2)`: Processed. `ans[1]` is 1.\n  2. `(3, 5, 2, 3, 1)`: `v=3`. `ans[2]` is `1`. Processed.\n  Return `cb1 = -10`.\n\nFinal `ans`: `[1, 1, 1]`\nThis means:\nEdge 0 (`3 2 10`): `1` means `2 -> 3`.\nEdge 1 (`1 2 10`): `1` means `2 -> 1`.\nEdge 2 (`3 1 5`): `1` means `1 -> 3`.\n\nFlows:\n`2 -> 3` (10 units)\n`2 -> 1` (10 units)\n`1 -> 3` (5 units)\n\nCheck conditions for my output:\n1. Source 1: Incoming `2->1` (10). Outgoing `1->3` (5). Balance `10-5 = 5 != 0`. This is still violating \"no incoming edges for 1\".\n\nThe problem is that `current_flow_balance` represents `sum(outgoing) - sum(incoming)` *within* the subtree.\nFor `u=1`, this should be `total_flow`.\nFor `u=n`, this should be `0`.\nFor `1<u<n`, this should be `0`.\n\nThe condition \"vertex with number 1 has no incoming edges\" means that `current_flow_balance` for `1` will be the total flow leaving `1`.\nThe condition \"for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges\" means `current_flow_balance` will be 0 for `1 < v < n`.\n\nThe sink `n` must absorb all flow. It doesn't send any flow up. So its `current_flow_balance` (which is `sum(outgoing) - sum(incoming)` from its children) must be 0.\n\nThe issue is how `current_flow_balance` is defined and used.\nIt should be: `current_flow_balance = sum(flow_out_to_children) - sum(flow_in_from_children)`.\nWhen `dfs(u,p)` returns, it returns this `current_flow_balance`.\nIf `current_flow_balance > 0`, `u` sends `current_flow_balance` to `p`.\nIf `current_flow_balance < 0`, `p` sends `abs(current_flow_balance)` to `u`.\n\nThe logic for `visited[v]` and `ans[idx] == -1` must be:\nIf `v == n`: The edge `(u, n)` must be `u -> n`.\n  `ans[idx] = 0` if `original_u_edge == u`, else `ans[idx] = 1`.\n  `current_flow_balance += c`.\nElse: (General cross-edge `u` to `v`)\n  Direct `u -> v`.\n  `ans[idx] = 0` if `original_u_edge == u`, else `ans[idx] = 1`.\n  `current_flow_balance += c`.\n\nThis ensures that all edges to `n` are incoming.\nLet's try example 1 again with this:\n`dfs(3,2)`:\n  `visited[3]=T`, `cb3=0`\n  Neighbors of 3:\n  1. `(2, 10, 0, 3, 2)`: `v=2`. `ans[0]==-1`. `v!=p`. `visited[2]` is T. `v=2` is not `n`. `u=3` is `n`.\n     Edge `(3,2)` must be `3 -> 2` (as per general cross-edge rule `u -> v`).\n     `original_u_edge = 3`. `ans[0] = 0`.\n     `cb3 += 10`. (`cb3 = 10`)\n  2. `(1, 5, 2, 3, 1)`: `v=1`. `ans[2]==-1`. `v!=p`. `visited[1]` is T. `v=1` is not `n`. `u=3` is `n`.\n     Edge `(3,1)` must be `3 -> 1`.\n     `original_u_edge = 3`. `ans[2] = 0`.\n     `cb3 += 5`. (`cb3 = 15`)\n  Return `0` (because `u=3` is sink).\n\nBack to `dfs(2,1)`:\n  `child_balance_3` is `0`.\n  `child_balance_3 <= 0` is true. So edge `(2, 3)` is directed `2 -> 3`.\n  `original_u_edge = 3` (for edge 0). `ans[0]` is `0`. This is a conflict.\n\nThe problem is that the `visited[v]` check and `ans[idx] != -1` check are not robust enough.\nThe simplest way to handle this is to use `parent` for visited check.\n`dfs(u, p)`:\n1. `visited[u] = True`\n2. `current_flow_balance = 0`\n3. For `(v, c, idx, original_u_edge, original_v_edge)` in `adj[u]`:\n    * If `v == p`, continue.\n    * If `visited[v]`: (This is a cross-edge or back-edge. It's already been visited, so `v` is \"earlier\" than `u` in DFS discovery time, or an ancestor.)\n        * If `ans[idx] == -1`: // This edge hasn't been directed yet.\n            * Direct `u -> v`. (Flow leaves `u`). This is a common heuristic for DAGs.\n            * If `original_u_edge == u`, `ans[idx] = 0`. Else, `ans[idx] = 1`.\n            * `current_flow_balance += c`.\n        * Else: // Edge already directed by `v`'s DFS call.\n            * Continue.\n    * Else (`v` is not visited, `v` is a child in DFS tree):\n        * `child_balance = dfs(v, u)`\n        * If `child_balance > 0`: `v` has excess flow, so `v -> u`.\n            * If `original_u_edge == v`, `ans[idx] = 0`. Else, `ans[idx] = 1`.\n            * `current_flow_balance -= c`. (Flow enters `u`).\n        * Else (`child_balance <= 0`): `u` sends flow to `v`, so `u -> v`.\n            * If `original_u_edge == u`, `ans[idx] = 0`. Else, `ans[idx] = 1`.\n            * `current_flow_balance += c`. (Flow leaves `u`).\n\n4. Return `0` if `u == n`, else `current_flow_balance`.\n\nThis is the standard DFS approach. Let's trace with example 1:\n`dfs(1, 0)`:\n  `visited[1]=T`, `cb1=0`\n  Neighbors of 1:\n  1. `(2, 10, 1, 1, 2)`: `v=2`. `v!=p`. Not visited.\n     `child_balance_2 = dfs(2, 1)`:\n       `visited[2]=T`, `cb2=0`\n       Neighbors of 2:\n       1. `(3, 10, 0, 3, 2)`: `v=3`. `v!=p`. Not visited.\n          `child_balance_3 = dfs(3, 2)`:\n            `visited[3]=T`, `cb3=0`\n            Neighbors of 3:\n            1. `(2, 10, 0, 3, 2)`: `v=2`. `v!=p`. `visited[2]=T`. `ans[0]==-1`. Cross-edge.\n               Direct `3 -> 2`. `original_u_edge=3`. `ans[0]=0`.\n               `cb3 += 10`. (`cb3 = 10`)\n            2. `(1, 5, 2, 3, 1)`: `v=1`. `v!=p`. `visited[1]=T`. `ans[2]==-1`. Cross-edge.\n               Direct `3 -> 1`. `original_u_edge=3`. `ans[2]=0`.\n               `cb3 += 5`. (`cb3 = 15`)\n            Return `0` (because `u=3` is sink).\n          `child_balance_3` is `0`.\n          `child_balance_3 <= 0` is true. `u=2` sends flow to `v=3`. Edge `(2, 3)` is `2 -> 3`.\n          `original_u_edge=3` (for edge 0). `ans[0]` is `0`. This is the issue. `ans[0]` is already `0` for `3->2`. Now it wants `2->3`.\n\nThis means the `ans[idx] == -1` check for cross-edges is critical. If `ans[idx]` is already set, it means the other side of the edge has already directed it.\nSo, the `if ans[idx] != -1` check must be the first thing inside the loop.\n\nFinal logic:\n`dfs(u, p)`:\n1.  `visited[u] = True`\n2.  `current_flow_balance = 0`\n3.  For each edge `(v, c, idx, original_u_edge, original_v_edge)` in `adj[u]`:\n    *   If `ans[idx] != -1`: // Edge already directed.\n        *   Continue.\n    *   If `v == p`, continue.\n    *   If `visited[v]`: // `v` is visited, but this edge is not yet directed. This must be a cross-edge.\n        *   Direct `u -> v`. (Flow leaves `u`).\n        *   If `original_u_edge == u`, `ans[idx] = 0`. Else, `ans[idx] = 1`.\n        *   `current_flow_balance += c`.\n    *   Else (`v` is not visited, `v` is a child in DFS tree):\n        *   `child_balance = dfs(v, u)`\n        *   If `child_balance > 0`: `v` has excess flow, so `v -> u`.\n            *   If `original_u_edge == v`, `ans[idx] = 0`. Else, `ans[idx] = 1`.\n            *   `current_flow_balance -= c`. (Flow enters `u`).\n        *   Else (`child_balance <= 0`): `u` sends flow to `v`, so `u -> v`.\n            *   If `original_u_edge == u`, `ans[idx] = 0`. Else, `ans[idx] = 1`.\n            *   `current_flow_balance += c`. (Flow leaves `u`).\n\n4.  Return `0` if `u == n`, else `current_flow_balance`.\n\nThis is the standard approach. The example output is just one of many solutions.\nThe dry run for example 1:\n`dfs(1, 0)`:\n  `visited[1]=T`, `cb1=0`\n  Neighbors of 1:\n  1. `(2, 10, 1, 1, 2)`: `v=2`. `ans[1]==-1`. `v!=p`. Not visited.\n     `child_balance_2 = dfs(2, 1)`:\n       `visited[2]=T`, `cb2=0`\n       Neighbors of 2:\n       1. `(3, 10, 0, 3, 2)`: `v=3`. `ans[0]==-1`. `v!=p`. Not visited.\n          `child_balance_3 = dfs(3, 2)`:\n            `visited[3]=T`, `cb3=0`\n            Neighbors of 3:\n            1. `(2, 10, 0, 3, 2)`: `v=2`. `ans[0]==-1`. `v!=p`. `visited[2]=T`. Cross-edge.\n               Direct `3 -> 2`. `original_u_edge=3`. `ans[0]=0`.\n               `cb3 += 10`. (`cb3 = 10`)\n            2. `(1, 5, 2, 3, 1)`: `v=1`. `ans[2]==-1`. `v!=p`. `visited[1]=T`. Cross-edge.\n               Direct `3 -> 1`. `original_u_edge=3`. `ans[2]=0`.\n               `cb3 += 5`. (`cb3 = 15`)\n            Return `0` (because `u=3` is sink).\n          `child_balance_3` is `0`.\n          `child_balance_3 <= 0` is true. `u=2` sends flow to `v=3`. Edge `(2, 3)` is `2 -> 3`.\n          `original_u_edge=3` (for edge 0). `ans[0]` is already `0`. This is the problem.\n          The edge `(3,2)` was directed `3->2` from `dfs(3,2)`. Now `dfs(2,1)` wants to direct `2->3`.\n\nThe problem is that the `ans[idx]` check is not enough for the `visited[v]` case.\nIf `visited[v]` and `ans[idx] == -1` then it's a cross-edge *from `u`'s perspective*.\nIf `visited[v]` and `ans[idx] != -1` then `v` already processed this edge as a child-parent edge.\n\nThe issue is that for a cross-edge `(u,v)` where `u` is visiting `v`, `v` might be an ancestor or in another subtree.\nIf `v` is an ancestor, `u -> v` forms a cycle. So it must be `v -> u`.\nIf `v` is a cross-edge, `u -> v` is fine.\n\nThe standard solution for this is to use `parent` array to distinguish back-edges from cross-edges.\nHowever, the problem says \"no cycles\". The simplest way to achieve this is always direct `u -> v` if `v` is visited, and `u` is the first to visit it.\n\nThe example output's directions are consistent with BFS levels.\n`dist[1]=0, dist[2]=1, dist[3]=1` (from 1)\nEdge `(3,2,10)`: `dist[3]=1, dist[2]=1`. `dist[u]==dist[v]`. Example says `2->3`.\nEdge `(1,2,10)`: `dist[1]=0, dist[2]=1`. `dist[1]<dist[2]`. Example says `1->2`.\nEdge `(3,1,5)`: `dist[3]=1, dist[1]=0`. `dist[1]<dist[3]`. Example says `1->3`.\n\nThe only problematic part is `dist[u] == dist[v]`. For `(2,3)`, `dist[2]=1, dist[3]=1`. The example output directs `2->3`.\nThis suggests a specific rule for `dist[u] == dist[v]` edges.\nThe rule could be: if `dist[u] == dist[v]`, direct `u -> v` if `u < v`, else `v -> u`.\nFor `(2,3)`: `dist[2]==dist[3]`. `2 < 3`. So `2 -> 3`. This matches example.\n\nThis BFS + tie-breaking rule seems much simpler and satisfies the DAG condition.\nLet's try this for example 1:\nBFS from 1:\n`dist = [-1,-1,-1,-1]`\n`q = deque([1])`\n`dist[1]=0`\nPop 1. Neighbors:\n  2: `dist[2]=-1`. `dist[2]=dist[1]+1=1`. `q.append(2)`.\n  3: `dist[3]=-1`. `dist[3]=dist[1]+1=1`. `q.append(3)`.\nPop 2. Neighbors:\n  3: `dist[3]=1`. Already visited. Skip.\n  1: `dist[1]=0`. Already visited. Skip.\nPop 3. Neighbors:\n  2: `dist[2]=1`. Already visited. Skip.\n  1: `dist[1]=0`. Already visited. Skip.\n\nFinal `dist`: `[0,0,1,1]` (index 0 unused, index 1 is vertex 1).\nCorrected `dist`: `[X, 0, 1, 1]` (X for 0-index, 1-indexed vertices)\n\nEdges:\n0. `(3, 2, 10)`: `dist[3]=1`, `dist[2]=1`. `dist[3]==dist[2]`. Tie-break: `2 < 3`, so `2 -> 3`.\n   `original_u=3, original_v=2`. Flow `2 -> 3`. `ans[0]=1`.\n1. `(1, 2, 10)`: `dist[1]=0`, `dist[2]=1`. `dist[1]<dist[2]`. So `1 -> 2`.\n   `original_u=1, original_v=2`. Flow `1 -> 2`. `ans[1]=0`.\n2. `(3, 1, 5)`: `dist[3]=1`, `dist[1]=0`. `dist[1]<dist[3]`. So `1 -> 3`.\n   `original_u=3, original_v=1`. Flow `1 -> 3`. `ans[2]=1`.\n\nResult: `[1, 0, 1]`. This exactly matches the example output!\nThis BFS + tie-breaking rule is simple and effective.\n\n```python\nimport sys\nimport collections\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    edges_input = []\n    adj = collections.defaultdict(list)\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        edges_input.append((u, v, c))\n        adj[u].append((v, c, i)) # Store neighbor, flow, original index\n        adj[v].append((u, c, i)) # Store neighbor, flow, original index\n\n    ans = [-1] * m\n\n    # Step 1: Perform BFS from source (vertex 1) to find shortest distances\n    dist = [-1] * (n + 1)\n    q = collections.deque()\n\n    dist[1] = 0\n    q.append(1)\n\n    while q:\n        u = q.popleft()\n        for v, c, idx in adj[u]:\n            if dist[v] == -1:\n                dist[v] = dist[u] + 1\n                q.append(v)\n    \n    # Step 2: Direct edges based on BFS distances\n    # Iterate through original edges to ensure each edge is processed once\n    # and output order matches input order.\n    # A set to keep track of directed edges to avoid redundant processing.\n    directed_edges = set()\n\n    for i in range(m):\n        u_orig, v_orig, c = edges_input[i]\n        \n        # Check if this edge has already been directed from the other endpoint's perspective\n        if i in directed_edges:\n            continue\n\n        # Rule 1: Prioritize flow from lower BFS distance to higher BFS distance\n        if dist[u_orig] < dist[v_orig]:\n            # Flow u_orig -> v_orig\n            ans[i] = 0 # 0 means u_orig -> v_orig\n        elif dist[v_orig] < dist[u_orig]:\n            # Flow v_orig -> u_orig\n            ans[i] = 1 # 1 means v_orig -> u_orig\n        else: # dist[u_orig] == dist[v_orig] - This is a cross-edge in BFS tree\n            # Rule 2: Tie-breaking for cross-edges (same BFS distance)\n            # Direct from smaller vertex ID to larger vertex ID.\n            # This is a common heuristic to break ties and ensure consistency.\n            if u_orig < v_orig:\n                # Flow u_orig -> v_orig\n                ans[i] = 0\n            else:\n                # Flow v_orig -> u_orig\n                ans[i] = 1\n        \n        directed_edges.add(i)\n\n    # Output results\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + '\\n')\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport collections\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    edges_input = []\n    adj = collections.defaultdict(list)\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        edges_input.append((u, v, c))\n        adj[u].append((v, c, i)) # Store neighbor, flow, original index\n        adj[v].append((u, c, i)) # Store neighbor, flow, original index\n\n    ans = [-1] * m\n\n    # Step 1: Perform BFS from source (vertex 1) to find shortest distances\n    dist = [-1] * (n + 1)\n    q = collections.deque()\n\n    dist[1] = 0\n    q.append(1)\n\n    while q:\n        u = q.popleft()\n        for v, c, idx in adj[u]:\n            if dist[v] == -1:\n                dist[v] = dist[u] + 1\n                q.append(v)\n    \n    # Step 2: Direct edges based on BFS distances\n    # Iterate through original edges to ensure each edge is processed once\n    # and output order matches input order.\n    # A set to keep track of directed edges to avoid redundant processing.\n    directed_edges = set()\n\n    for i in range(m):\n        u_orig, v_orig, c = edges_input[i]\n        \n        # Check if this edge has already been directed from the other endpoint's perspective\n        if i in directed_edges:\n            continue\n\n        # Rule 1: Prioritize flow from lower BFS distance to higher BFS distance\n        if dist[u_orig] < dist[v_orig]:\n            # Flow u_orig -> v_orig\n            ans[i] = 0 # 0 means u_orig -> v_orig\n        elif dist[v_orig] < dist[u_orig]:\n            # Flow v_orig -> u_orig\n            ans[i] = 1 # 1 means v_orig -> u_orig\n        else: # dist[u_orig] == dist[v_orig] - This is a cross-edge in BFS tree\n            # Rule 2: Tie-breaking for cross-edges (same BFS distance)\n            # Direct from smaller vertex ID to larger vertex ID.\n            # This is a common heuristic to break ties and ensure consistency.\n            if u_orig < v_orig:\n                # Flow u_orig -> v_orig\n                ans[i] = 0\n            else:\n                # Flow v_orig -> u_orig\n                ans[i] = 1\n        \n        directed_edges.add(i)\n\n    # Output results\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + '\\n')\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 745,
        "completion_token_count": 23502,
        "thoughts_token_count": 761
    }
}