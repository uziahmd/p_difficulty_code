{
    "start": 1758294842.7452261,
    "end": 1758294931.2270546,
    "start-formatted": "2025-09-20 00:14 KST",
    "end-formatted": "2025-09-20 00:15 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "**Refining the Odd Cycle Problem**\n\nAlright, let's break down this problem. My goal is to determine the fewest edges, *t*, needed to transform a given graph into one containing an odd-length cycle, and also to count the distinct ways, *w*, this can be achieved.  The initial graph is undirected, without self-loops or multiple edges.\n\nInitially, I'll check if the graph *already* has an odd cycle. This simplifies to checking if the graph is bipartite. I can do this with a Breadth-First Search (BFS) or Depth-First Search (DFS) while coloring the graph with two colors. If I encounter an edge connecting vertices of the same color, an odd cycle is present, so *t = 0*, and *w = 1*.\n\nIf the graph is bipartite, I have to add edges to break this bipartiteness.  I can divide the vertices into two sets, *L* and *R*. To make the graph non-bipartite, I must add an edge *within* the sets *L* or *R*.  So, the added edge is `(u,v)` such that u, v are in same set.\n\nThe smallest number of edges I can add is *t = 1*.  If adding one edge can create an odd cycle, I'll calculate the number of ways, *w*, this can be done. I'll need to count how many pairs of vertices from the same partition exist in a connected component where an edge could be added, accounting for any existing edges. This becomes a count of pair within each partition in a connected component.\n\nTo count how many ways to make *t=1*, I iterate through connected components of the graph. For each component, if the sizes of its partitions, *L* and *R*, are at least 2, I compute the number of possible edges that can be added within each partition using the combination formula and sum over all these ways.  However, this won't work if some connected components have only isolated vertices or single edges.\n\nIf *t = 1* isn't possible, then I'll move on to *t = 2* or *t = 3*.\n\nNow, the situation gets a bit more involved. If *t = 2* isn't possible (i.e., you cannot find an isolated component which connects to an existing edge), then it suggests that no single edge addition can create an odd cycle (e.g., all components are either isolated edges or isolated nodes).\n\nIn this case, I have to analyze how two edges can contribute.\n\nIf *t = 2* is viable, it suggests two isolated vertices which can connect to the same existing edge. The number of ways is `num_isolated_vertices * m`, where `m` is the number of edges. If this is zero, then *t=3*.\n\nIf it's impossible, then this means all components are either just isolated edges or isolated vertices. Adding three edges will create an odd cycle. If all nodes are isolated, then three will be needed, and count this as *n C 3*.\n\nSo in summary:\n1.  Check for an existing odd cycle (bipartite test). If found: *t = 0, w = 1*.\n2.  If the graph is bipartite, compute ways *t=1*. If possible: *t=1, w=ways_t1*.\n3. If ways for *t=1* is zero, compute for *t=2* based on isolated vertices and edges, If found: *t=2, w=ways_t2*.\n4.  Otherwise, *t = 3* always:\n    *   If all vertices isolated: *t = 3, w = n * (n-1) * (n-2) // 6* (n >= 3).\n    *  Otherwise (m > 0 and no isolated vertices):  3-cycle must be created. *t=3,  m C 3* if number of isolated edges >= 3, or other combinations to form a cycle with three edges between different edges.\n",
    "response": "The problem asks us to find the minimum number of edges `t` to add to a given undirected graph to form a simple cycle of odd length, and `w`, the number of ways to do so. The graph initially has no loops or parallel edges, and we cannot add them.\n\nA graph contains an odd cycle if and only if it is not bipartite. Our strategy will be to first check if the graph already contains an odd cycle. If not, the graph is bipartite, and we then determine the minimum `t` and corresponding `w` to make it non-bipartite.\n\n**Step 1: Check for existing odd cycles (t=0)**\n\nWe can use a 2-coloring algorithm (e.g., BFS or DFS) to check if the graph is bipartite.\n- Initialize `color[v] = -1` for all vertices `v`.\n- Iterate through each vertex `i` from 1 to `n`. If `color[i]` is -1, start a BFS/DFS from `i`.\n  - Assign `color[i] = 0`.\n  - For each neighbor `j` of the current vertex `u`:\n    - If `color[j]` is -1, assign `color[j] = 1 - color[u]` and add `j` to the queue/stack.\n    - If `color[j] == color[u]`, an odd cycle is found. The graph is not bipartite.\n- If an odd cycle is found anywhere in the graph, `t = 0` and `w = 1` (there's one way to add 0 edges, which is to do nothing). Print `0 1` and terminate.\n\n**Step 2: If the graph is bipartite, calculate ways for t=1**\n\nIf no odd cycle is found, the graph is bipartite. Each connected component can be 2-colored. Let's say a component `C_k` is partitioned into `L_k` and `R_k`.\nTo form an odd cycle by adding a single edge `(u, v)`, `u` and `v` must belong to the same partition within the same connected component (e.g., both in `L_k` or both in `R_k`). If such an edge is added, it connects two vertices that are already connected by an even-length path (since they are in the same partition), forming an odd-length cycle.\n\n- During the 2-coloring process, for each bipartite component `C_k`, store its partition sizes `(|L_k|, |R_k|)`.\n- Calculate `ways_t1`: For each component `C_k`, the number of ways to add an edge within `L_k` is `|L_k| * (|L_k| - 1) / 2`. Similarly for `R_k`. Sum these values over all components.\n  `ways_t1 = sum_k ( |L_k| * (|L_k| - 1) // 2 + |R_k| * (|R_k| - 1) // 2 )`\n- If `ways_t1 > 0`, then `t = 1` and `w = ways_t1`. Print `1 ways_t1` and terminate.\n\n**Step 3: If t=1 is not possible, calculate ways for t=2**\n\nIf `ways_t1 == 0`, it means that for every bipartite component `C_k`, both `|L_k| < 2` and `|R_k| < 2`. This implies that each connected component is either:\n  - An isolated vertex (e.g., `|L_k|=1, |R_k|=0` or `|L_k|=0, |R_k|=1`).\n  - A single edge (e.g., `|L_k|=1, |R_k|=1`).\n\nIn this scenario, we cannot add an edge within a single partition. To form an odd cycle with `t=2` edges, we can do the following:\n- Pick an isolated vertex `u`.\n- Pick an existing edge `(x, y)`.\n- Add two new edges `(u, x)` and `(u, y)`. This forms a 3-cycle `u - x - y - u`.\n  (These edges `(u,x)` and `(u,y)` cannot be existing edges because `u` is isolated).\n\nLet `num_isolated_vertices` be the count of components that are isolated vertices.\nLet `m` be the number of existing edges in the graph.\n- Calculate `ways_t2 = num_isolated_vertices * m`.\n- If `ways_t2 > 0`, then `t = 2` and `w = ways_t2`. Print `2 ways_t2` and terminate.\n\n**Step 4: If t=2 is not possible, calculate ways for t=3**\n\nIf `ways_t2 == 0`, it means either `num_isolated_vertices == 0` or `m == 0`.\n\nCase A: `m == 0`. All vertices are isolated.\n  - This implies `num_isolated_vertices = n`.\n  - To form an odd cycle (minimum length 3), we need to pick three distinct vertices `u, v, w` and add three edges `(u, v)`, `(v, w)`, `(w, u)`.\n  - The number of ways to choose 3 distinct vertices from `n` is `n * (n - 1) * (n - 2) / 6`.\n  - If `n >= 3`, then `t = 3` and `w = n * (n - 1) * (n - 2) // 6`. Print `3 w` and terminate.\n  - If `n < 3`, no 3-cycle is possible. The problem guarantees a solution exists, so this case should not happen for `n < 3`.\n\nCase B: `num_isolated_vertices == 0` and `m > 0`.\n  - This means all vertices are part of an existing edge. Since `ways_t1 == 0`, all components are single edges (e.g., `1-2`, `3-4`, `5-6`).\n  - To form an odd cycle (minimum length 3), we need to pick three distinct edges `(u_1, v_1)`, `(u_2, v_2)`, `(u_3, v_3)`.\n  - We can then pick one vertex from each of these three edges, say `u_1`, `u_2`, `u_3`, and add edges `(u_1, u_2)`, `(u_2, u_3)`, `(u_3, u_1)`. This forms a 3-cycle.\n  - The number of ways to choose 3 distinct edges from `m` edges is `m * (m - 1) * (m - 2) / 6`.\n  - For each choice of 3 edges, say `e_1, e_2, e_3`, we can choose one endpoint from each edge. There are `2*2*2 = 8` ways to pick 3 vertices. However, we only need to pick 3 vertices that will form the cycle. For instance, if the edges are `(1,2), (3,4), (5,6)`, we can pick `1,3,5` and add `(1,3), (3,5), (5,1)`. Or `1,3,6` and add `(1,3), (3,6), (6,1)`.\n  - Any set of 3 edges `e_1, e_2, e_3` will involve 6 distinct vertices. We pick 3 of these 6 vertices to form a triangle. The number of ways to choose 3 vertices from 6 for a triangle is `6 C 3 = 20`. But we have to make sure the added edges are not existing edges.\n  - A simpler approach: Pick 3 existing edges `(a,b), (c,d), (e,f)`. We want to add 3 edges to form a 3-cycle. We can add `(a,c), (c,e), (e,a)`. This is `t=3`.\n  - The number of ways to select 3 distinct edges is `m * (m-1) * (m-2) // 6`.\n  - For each selection of 3 edges, say `(v_1, v_2), (v_3, v_4), (v_5, v_6)`, we can pick one vertex from each edge (e.g., `v_1, v_3, v_5`) and form a cycle `v_1-v_3-v_5-v_1` by adding 3 edges. The added edges are guaranteed not to exist because all original edges connect vertices within the same component, and we are picking vertices from different components.\n  - There are `2^3 = 8` ways to choose one vertex from each of the 3 chosen edges. So `w = (m * (m-1) * (m-2) // 6) * 8`.\n  - If `m >= 3`, then `t = 3` and `w = (m * (m-1) * (m-2) // 6) * 8`. Print `3 w` and terminate.\n\nThis covers all scenarios.\n\n```python\nimport sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    edges = [] # Store edges to count existing ones\n\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n        edges.append((u, v)) # Not strictly needed if m is used directly\n\n    color = [-1] * (n + 1)\n    has_odd_cycle = False\n    bipartite_components = [] # Stores (L_size, R_size) for each bipartite component\n\n    for i in range(1, n + 1):\n        if color[i] == -1:\n            q = deque()\n            q.append(i)\n            color[i] = 0\n            \n            current_L_size = 0\n            current_R_size = 0\n            if color[i] == 0:\n                current_L_size += 1\n            else:\n                current_R_size += 1\n\n            component_is_bipartite = True\n            component_nodes = [i]\n            \n            head = 0\n            while head < len(q):\n                u = q[head]\n                head += 1\n\n                for v in adj[u]:\n                    if color[v] == -1:\n                        color[v] = 1 - color[u]\n                        if color[v] == 0:\n                            current_L_size += 1\n                        else:\n                            current_R_size += 1\n                        q.append(v)\n                        component_nodes.append(v)\n                    elif color[v] == color[u]:\n                        has_odd_cycle = True\n                        component_is_bipartite = False\n                        # No need to break explicitly, just mark and finish this component's BFS\n                        # The outer loop will check has_odd_cycle and terminate early\n            \n            if component_is_bipartite:\n                bipartite_components.append((current_L_size, current_R_size))\n\n    if has_odd_cycle:\n        print(\"0 1\")\n        return\n\n    # Case t = 1\n    ways_t1 = 0\n    for L_size, R_size in bipartite_components:\n        ways_t1 += L_size * (L_size - 1) // 2\n        ways_t1 += R_size * (R_size - 1) // 2\n    \n    if ways_t1 > 0:\n        print(f\"1 {ways_t1}\")\n        return\n\n    # Case t = 2 (if t=1 not possible)\n    # This means all bipartite components have |L_k|<2 and |R_k|<2.\n    # So components are either isolated vertices (1,0) or (0,1), or single edges (1,1).\n    num_isolated_vertices = 0\n    for L_size, R_size in bipartite_components:\n        if L_size + R_size == 1: # Isolated vertex\n            num_isolated_vertices += 1\n    \n    ways_t2 = num_isolated_vertices * m\n    \n    if ways_t2 > 0:\n        print(f\"2 {ways_t2}\")\n        return\n\n    # Case t = 3 (if t=1 and t=2 not possible)\n    # This means either num_isolated_vertices == 0 or m == 0 (or both).\n\n    if m == 0: # All vertices are isolated\n        # We need to pick 3 vertices and form a 3-cycle\n        if n < 3: # Not enough vertices to form a 3-cycle\n            # This case should not be reached based on problem constraints implying a solution\n            # For competitive programming, usually implies n >= 3 for this path.\n            # If n=0,1,2 and m=0, no cycle is possible.\n            # But the problem guarantees a solution. The example output for 3 0 is 3 1.\n            # 3 0 -> n=3, m=0. num_isolated_vertices = 3. ways_t3 = 3*2*1/6 = 1.\n            print(f\"3 {n * (n - 1) * (n - 2) // 6}\")\n        else:\n            print(f\"3 {n * (n - 1) * (n - 2) // 6}\")\n        return\n    \n    # num_isolated_vertices == 0 and m > 0.\n    # All vertices are part of an edge. Since ways_t1 == 0, all components are single edges.\n    # We need to pick 3 distinct edges (components) and form a 3-cycle.\n    # E.g., edges (v1,v2), (v3,v4), (v5,v6). Pick v1,v3,v5. Add (v1,v3), (v3,v5), (v5,v1).\n    \n    # Number of ways to choose 3 distinct edges (components)\n    if m < 3: # Not enough edges to pick 3\n        # This case should not be reached based on problem constraints\n        print(f\"3 0\") # Should not happen if a solution is guaranteed.\n    else:\n        ways_t3 = (m * (m - 1) * (m - 2) // 6) * 8\n        print(f\"3 {ways_t3}\")\n\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    edges = [] # Store edges to count existing ones\n\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n        edges.append((u, v)) # Not strictly needed if m is used directly\n\n    color = [-1] * (n + 1)\n    has_odd_cycle = False\n    bipartite_components = [] # Stores (L_size, R_size) for each bipartite component\n\n    for i in range(1, n + 1):\n        if color[i] == -1:\n            q = deque()\n            q.append(i)\n            color[i] = 0\n            \n            current_L_size = 0\n            current_R_size = 0\n            if color[i] == 0:\n                current_L_size += 1\n            else:\n                current_R_size += 1\n\n            component_is_bipartite = True\n            component_nodes = [i]\n            \n            head = 0\n            while head < len(q):\n                u = q[head]\n                head += 1\n\n                for v in adj[u]:\n                    if color[v] == -1:\n                        color[v] = 1 - color[u]\n                        if color[v] == 0:\n                            current_L_size += 1\n                        else:\n                            current_R_size += 1\n                        q.append(v)\n                        component_nodes.append(v)\n                    elif color[v] == color[u]:\n                        has_odd_cycle = True\n                        component_is_bipartite = False\n                        # No need to break explicitly, just mark and finish this component's BFS\n                        # The outer loop will check has_odd_cycle and terminate early\n            \n            if component_is_bipartite:\n                bipartite_components.append((current_L_size, current_R_size))\n\n    if has_odd_cycle:\n        print(\"0 1\")\n        return\n\n    # Case t = 1\n    ways_t1 = 0\n    for L_size, R_size in bipartite_components:\n        ways_t1 += L_size * (L_size - 1) // 2\n        ways_t1 += R_size * (R_size - 1) // 2\n    \n    if ways_t1 > 0:\n        print(f\"1 {ways_t1}\")\n        return\n\n    # Case t = 2 (if t=1 not possible)\n    # This means all bipartite components have |L_k|<2 and |R_k|<2.\n    # So components are either isolated vertices (1,0) or (0,1), or single edges (1,1).\n    num_isolated_vertices = 0\n    for L_size, R_size in bipartite_components:\n        if L_size + R_size == 1: # Isolated vertex\n            num_isolated_vertices += 1\n    \n    ways_t2 = num_isolated_vertices * m\n    \n    if ways_t2 > 0:\n        print(f\"2 {ways_t2}\")\n        return\n\n    # Case t = 3 (if t=1 and t=2 not possible)\n    # This means either num_isolated_vertices == 0 or m == 0 (or both).\n\n    if m == 0: # All vertices are isolated\n        # We need to pick 3 vertices and form a 3-cycle\n        if n < 3: # Not enough vertices to form a 3-cycle\n            # This case should not be reached based on problem constraints implying a solution\n            # For competitive programming, usually implies n >= 3 for this path.\n            # If n=0,1,2 and m=0, no cycle is possible.\n            # But the problem guarantees a solution. The example output for 3 0 is 3 1.\n            # 3 0 -> n=3, m=0. num_isolated_vertices = 3. ways_t3 = 3*2*1/6 = 1.\n            print(f\"3 {n * (n - 1) * (n - 2) // 6}\")\n        else:\n            print(f\"3 {n * (n - 1) * (n - 2) // 6}\")\n        return\n    \n    # num_isolated_vertices == 0 and m > 0.\n    # All vertices are part of an edge. Since ways_t1 == 0, all components are single edges.\n    # We need to pick 3 distinct edges (components) and form a 3-cycle.\n    # E.g., edges (v1,v2), (v3,v4), (v5,v6). Pick v1,v3,v5. Add (v1,v3), (v3,v5), (v5,v1).\n    \n    # Number of ways to choose 3 distinct edges (components)\n    if m < 3: # Not enough edges to pick 3\n        # This case should not be reached based on problem constraints\n        print(f\"3 0\") # Should not happen if a solution is guaranteed.\n    else:\n        ways_t3 = (m * (m - 1) * (m - 2) // 6) * 8\n        print(f\"3 {ways_t3}\")\n\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 604,
        "completion_token_count": 3450,
        "thoughts_token_count": 7194
    }
}