{
    "start": 1758011805.760259,
    "end": 1758011924.029872,
    "start-formatted": "2025-09-16 17:36 KST",
    "end-formatted": "2025-09-16 17:38 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "**Here's my thought process:**\n\nI need to write a Python script for the \"Rudolf and Snowflakes (hard version)\" problem. The core of this problem is figuring out if a given number `n` of vertices can form a snowflake structure.  This snowflake structure is based on a central vertex, which is connected to `k` new vertices, and then these new vertices are, in turn, connected to `k` more vertices, and so on, for at least one level.\n\nI need to analyze this structure to find a mathematical formula that relates `n` to `k` and the number of layers of new vertices, which I'll call `d`. After simplifying and generalizing, I've got the formula as `n = (k^(m+1) - 1) / (k - 1)`, where `m = d + 1` and also is >=2.\n\nSince `n` can be up to 10^18, finding a solution means determining if I can find appropriate values for `k > 1` and `m >= 2` that satisfy this equation.  I've decided to tackle this by checking two main cases:\n\n1.  **Small `m`:** If I take `m = 2`, the formula changes to `n = 1 + k + k^2`, which I can treat like a quadratic equation. If I solve for `k` using the quadratic formula, I can efficiently check if I get an integer solution by seeing if `4n - 3` is a perfect square, as well as if the solution of `k` is >1.\n\n2.  **Small `k`:**  For a small and specific `k=2`, the formula reduces to `n = 2^(m+1) - 1`. Here I just need to check if `n+1` is a power of 2, and that the result satisfies `m >= 2`.\n\nFor cases not covered by the above, I'll need a general method. The tricky part is efficiently searching for `k` for a given `m`. It seems that as `m` gets larger, the range of possible `k` values gets smaller and the computation becomes easier.\n\nI'm thinking that for larger values of `m`,  `k` will be a significant factor in determining the value of `n` since `k^m` will be close to `n`. I'll try to estimate `k` using the inverse of the sum formula and narrow down `k` using a binary search approach. Since `k^(m+1) > n`, `k <= n^(1.0/(m+1))` with some modifications.\n\nI've realized that I need to efficiently compute the sum, `1 + k + k^2 + ... + k^m` because the calculations could get large very fast and cause overflow issues. To address this, I'll check for any possible overflows during the summation within the loop to keep the calculation within the valid range and determine the correct bounds.\n\nI've carefully considered overflow problems with the large numbers I need to calculate so I'll write some specific checks to avoid it.\n\nTo summarize, for my algorithm:\n\n1.  Handle trivial cases with small numbers. (n=1,2,3,4,5,6 -> NO)\n2.  Handle the case where `m=2` using the quadratic approach.\n3.  Check the powers of 2 (case k=2).\n4.  For the remaining cases, I'll iterate on `m` from `3` up to some maximum. `log2(n)` bounds this, and `log2(n) ~ 60`, is a good start. For each `m`, I'll use binary search to determine `k`. I'll also add bounds on the size of the k. If at some value of `k` the sum is == `n`, then I can stop and say YES. Otherwise, I go on to the next case.\n5. If after all that, there's still no solution, I'll print \"NO.\"\n",
    "response": "The problem asks us to determine if a given number of vertices `n` can form a snowflake. A snowflake is defined by two parameters: `k` (an integer `k > 1`) and `d` (the number of times a specific step is repeated, `d >= 1`). The total number of vertices `n` is given by the sum of a geometric series: `n = 1 + k + k^2 + ... + k^(d+1)`.\n\nLet `m = d+1`. Since `d >= 1`, `m` must be at least `2`. So the formula for `n` is `n = 1 + k + k^2 + ... + k^m`, where `k > 1` and `m >= 2`. This sum can also be written as `n = (k^(m+1) - 1) / (k - 1)`.\n\nWe need to check if for a given `n` (up to `10^18`), there exist integers `k > 1` and `m >= 2` satisfying this equation.\n\nThe approach involves two main cases:\n\n1.  **Smallest `n` check:** The smallest possible snowflake occurs when `k=2` and `m=2`. This gives `n = 1 + 2 + 2^2 = 7`. Any `n < 7` cannot be a snowflake. So, if `n < 7`, the answer is \"NO\".\n\n2.  **Case `m = 2`:**\n    If `m = 2`, the equation becomes `n = 1 + k + k^2`.\n    Rearranging, we get `k^2 + k + (1 - n) = 0`.\n    This is a quadratic equation in `k`. Using the quadratic formula, `k = (-1 ± sqrt(1 - 4(1 - n))) / 2 = (-1 ± sqrt(4n - 3)) / 2`.\n    For `k` to be a positive integer greater than 1:\n    *   `4n - 3` must be a perfect square. Let `s = sqrt(4n - 3)`.\n    *   `s` must be an integer.\n    *   Since `k > 0`, we take the positive root: `k = (-1 + s) / 2`.\n    *   For `k` to be an integer, `s - 1` must be even, meaning `s` must be odd.\n    *   For `k > 1`, `(-1 + s) / 2 > 1`, which implies `s - 1 > 2`, or `s > 3`.\n    So, if `4n - 3` is a perfect square `s^2`, and `s` is odd and `s > 3`, then we found a valid `k` and `m=2`. In this case, print \"YES\" and return.\n\n3.  **Case `m >= 3`:**\n    The maximum value of `n` is `10^18`.\n    Since `k >= 2`, we have `n = 1 + k + ... + k^m >= 1 + 2 + ... + 2^m = 2^(m+1) - 1`.\n    `n + 1 >= 2^(m+1)`.\n    `log2(n + 1) >= m + 1`.\n    For `n = 10^18`, `log2(10^18 + 1) approx 18 * log2(10) approx 18 * 3.3219 approx 59.79`.\n    So `m + 1` can be at most `59`, which means `m` can be at most `58`.\n    Therefore, we only need to check `m` in the range `[3, 58]` (or a slightly larger safe upper bound like 60).\n\n    For each `m` in this range, we need to find if there exists an integer `k > 1` such that `1 + k + ... + k^m = n`.\n    The function `f(k) = 1 + k + ... + k^m` is monotonically increasing for `k > 1`. This allows us to use binary search for `k`.\n\n    The range for `k` in the binary search:\n    *   Lower bound: `k_low = 2`.\n    *   Upper bound: We know `k^m < n`, so `k < n^(1/m)`. A safe upper bound for `k` can be `int(n**(1.0/m)) + 2`. For `m=3` and `n=10^18`, this is `10^6 + 2`. For larger `m`, this bound decreases quickly.\n\n    Inside the binary search, for a given `mid_k`:\n    We calculate `current_sum = 1 + mid_k + ... + mid_k^m`.\n    **Crucially, we must handle potential overflows during this sum calculation** as `mid_k^m` can exceed `10^18` (e.g., `(10^6)^3 = 10^18`, `2^58` is also close to `10^18`).\n    We can check for overflow before each addition and multiplication:\n    *   Before `current_sum += power_k`: check if `current_sum > n - power_k`. If true, `current_sum + power_k` would exceed `n`.\n    *   Before `power_k *= mid_k`: check if `power_k > n // mid_k`. If true, `power_k * mid_k` would exceed `n`.\n\n    If `current_sum == n`, we found a solution. Print \"YES\" and return.\n    If `current_sum < n`, `mid_k` is too small, so set `low = mid_k + 1`.\n    If `current_sum > n` (or overflow occurred), `mid_k` is too large, so set `high = mid_k - 1`.\n\n4.  **No solution found:** If after checking all `m` and their corresponding `k` values, no solution is found, print \"NO\".\n\n**Example walkthrough for `n=15`:**\n1.  `n=15 >= 7` is true.\n2.  `m=2`: `4*15 - 3 = 57`. Not a perfect square.\n3.  `m=3`: Binary search for `k`. `low=2`, `high=int(15**(1/3))+2 = int(2.46)+2 = 4`.\n    *   `mid_k = (2+4)//2 = 3`. Calculate `1+3+3^2+3^3 = 1+3+9+27 = 40`.\n        `40 > 15`, so `high = 3-1 = 2`.\n    *   `low=2, high=2`. `mid_k = (2+2)//2 = 2`. Calculate `1+2+2^2+2^3 = 1+2+4+8 = 15`.\n        `15 == n`, so print \"YES\" and return.\n\nThis optimized approach efficiently covers all possible `k` and `m` values within the given constraints.\n\n```python\nimport sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n\n    # Case 1: Smallest possible snowflake is 7 (k=2, m=2).\n    # n = 1 + k + ... + k^m\n    # Minimum k is 2, minimum m is 2.\n    # 1 + 2 + 2^2 = 7.\n    if n < 7:\n        sys.stdout.write(\"NO\\n\")\n        return\n\n    # Case 2: m = 2 (n = 1 + k + k^2)\n    # k^2 + k + (1 - n) = 0\n    # k = (-1 + sqrt(1 - 4(1 - n))) / 2 = (-1 + sqrt(4n - 3)) / 2\n    \n    # Calculate discriminant (4n - 3)\n    discriminant = 4 * n - 3\n    \n    # Check if discriminant is a perfect square\n    s = int(discriminant**0.5)\n    if s * s == discriminant:\n        # For k to be an integer, s must be odd (s-1 must be even)\n        # For k > 1, (-1 + s) / 2 > 1 => s - 1 > 2 => s > 3\n        if s % 2 == 1 and s > 3:\n            # k = (s - 1) // 2\n            sys.stdout.write(\"YES\\n\")\n            return\n\n    # Case 3: m >= 3. Iterate m, binary search for k.\n    # Max n = 10^18.\n    # n = 1 + k + ... + k^m >= 1 + 2 + ... + 2^m = 2^(m+1) - 1\n    # So 2^(m+1) <= n + 1.\n    # m + 1 <= log2(n + 1).\n    # For n = 10^18, log2(10^18 + 1) is approx 59.79.\n    # So m + 1 <= 59, which means m <= 58.\n    # We can iterate m from 3 up to 59 (inclusive, to be safe).\n    \n    for m in range(3, 61): # m from 3 to 60\n        # Binary search for k.\n        # k_low = 2 (minimum k value).\n        # k_high: k^m < n => k < n^(1/m).\n        # For n=10^18, m=3, k_high is approx 10^6.\n        # For m=58, k_high is approx 2.\n        # A safe upper bound for k for m >= 3 is int(n**(1.0/m)) + 2.\n        low = 2\n        high = int(n**(1.0/m)) + 2\n        \n        # Ensure high is at least low (2)\n        if high < low:\n            high = low\n\n        found_k = False\n        while low <= high:\n            mid_k = (low + high) // 2\n            \n            # mid_k must be > 1. If mid_k somehow becomes 0 or 1, adjust low.\n            if mid_k < 2:\n                low = 2\n                continue\n\n            current_sum = 0\n            power_k = 1 # Represents k^0, k^1, k^2, ...\n            overflow = False\n\n            # Calculate 1 + mid_k + ... + mid_k^m\n            for _ in range(m + 1): # Loop m+1 times for terms k^0 to k^m\n                # Check for overflow before adding power_k to current_sum\n                # If current_sum + power_k > n, it means current_sum > n - power_k\n                if current_sum > n - power_k:\n                    overflow = True\n                    break\n                current_sum += power_k\n                \n                # If it's not the last term (k^m), prepare for the next power_k\n                if _ < m:\n                    # Check for overflow before multiplying power_k by mid_k\n                    # If power_k * mid_k > n, it means power_k > n // mid_k\n                    # This check is crucial to prevent power_k from exceeding n,\n                    # which would make current_sum also exceed n.\n                    if mid_k == 0: # Should not happen as mid_k >= 2\n                        overflow = True\n                        break\n                    if power_k > n // mid_k:\n                        overflow = True\n                        break\n                    power_k *= mid_k\n            \n            if overflow or current_sum > n:\n                # mid_k is too large (or caused an overflow, meaning it's too large)\n                high = mid_k - 1\n            elif current_sum < n:\n                # mid_k is too small\n                low = mid_k + 1\n            else: # current_sum == n\n                found_k = True\n                break\n        \n        if found_k:\n            sys.stdout.write(\"YES\\n\")\n            return\n\n    # If no solution found after checking all m and k\n    sys.stdout.write(\"NO\\n\")\n\nnum_test_cases = int(sys.stdin.readline())\nfor _ in range(num_test_cases):\n    solve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n\n    # Case 1: Smallest possible snowflake is 7 (k=2, m=2).\n    # n = 1 + k + ... + k^m\n    # Minimum k is 2, minimum m is 2.\n    # 1 + 2 + 2^2 = 7.\n    if n < 7:\n        sys.stdout.write(\"NO\\n\")\n        return\n\n    # Case 2: m = 2 (n = 1 + k + k^2)\n    # k^2 + k + (1 - n) = 0\n    # k = (-1 + sqrt(1 - 4(1 - n))) / 2 = (-1 + sqrt(4n - 3)) / 2\n    \n    # Calculate discriminant (4n - 3)\n    discriminant = 4 * n - 3\n    \n    # Check if discriminant is a perfect square\n    s = int(discriminant**0.5)\n    if s * s == discriminant:\n        # For k to be an integer, s must be odd (s-1 must be even)\n        # For k > 1, (-1 + s) / 2 > 1 => s - 1 > 2 => s > 3\n        if s % 2 == 1 and s > 3:\n            # k = (s - 1) // 2\n            sys.stdout.write(\"YES\\n\")\n            return\n\n    # Case 3: m >= 3. Iterate m, binary search for k.\n    # Max n = 10^18.\n    # n = 1 + k + ... + k^m >= 1 + 2 + ... + 2^m = 2^(m+1) - 1\n    # So 2^(m+1) <= n + 1.\n    # m + 1 <= log2(n + 1).\n    # For n = 10^18, log2(10^18 + 1) is approx 59.79.\n    # So m + 1 <= 59, which means m <= 58.\n    # We can iterate m from 3 up to 59 (inclusive, to be safe).\n    \n    for m in range(3, 61): # m from 3 to 60\n        # Binary search for k.\n        # k_low = 2 (minimum k value).\n        # k_high: k^m < n => k < n^(1/m).\n        # For n=10^18, m=3, k_high is approx 10^6.\n        # For m=58, k_high is approx 2.\n        # A safe upper bound for k for m >= 3 is int(n**(1.0/m)) + 2.\n        low = 2\n        high = int(n**(1.0/m)) + 2\n        \n        # Ensure high is at least low (2)\n        if high < low:\n            high = low\n\n        found_k = False\n        while low <= high:\n            mid_k = (low + high) // 2\n            \n            # mid_k must be > 1. If mid_k somehow becomes 0 or 1, adjust low.\n            if mid_k < 2:\n                low = 2\n                continue\n\n            current_sum = 0\n            power_k = 1 # Represents k^0, k^1, k^2, ...\n            overflow = False\n\n            # Calculate 1 + mid_k + ... + mid_k^m\n            for _ in range(m + 1): # Loop m+1 times for terms k^0 to k^m\n                # Check for overflow before adding power_k to current_sum\n                # If current_sum + power_k > n, it means current_sum > n - power_k\n                if current_sum > n - power_k:\n                    overflow = True\n                    break\n                current_sum += power_k\n                \n                # If it's not the last term (k^m), prepare for the next power_k\n                if _ < m:\n                    # Check for overflow before multiplying power_k by mid_k\n                    # If power_k * mid_k > n, it means power_k > n // mid_k\n                    # This check is crucial to prevent power_k from exceeding n,\n                    # which would make current_sum also exceed n.\n                    if mid_k == 0: # Should not happen as mid_k >= 2\n                        overflow = True\n                        break\n                    if power_k > n // mid_k:\n                        overflow = True\n                        break\n                    power_k *= mid_k\n            \n            if overflow or current_sum > n:\n                # mid_k is too large (or caused an overflow, meaning it's too large)\n                high = mid_k - 1\n            elif current_sum < n:\n                # mid_k is too small\n                low = mid_k + 1\n            else: # current_sum == n\n                found_k = True\n                break\n        \n        if found_k:\n            sys.stdout.write(\"YES\\n\")\n            return\n\n    # If no solution found after checking all m and k\n    sys.stdout.write(\"NO\\n\")\n\nnum_test_cases = int(sys.stdin.readline())\nfor _ in range(num_test_cases):\n    solve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 559,
        "completion_token_count": 2966,
        "thoughts_token_count": 8192
    }
}