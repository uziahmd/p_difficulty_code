{
    "start": 1758294863.750317,
    "end": 1758294931.869873,
    "start-formatted": "2025-09-20 00:14 KST",
    "end-formatted": "2025-09-20 00:15 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "**Initial Problem Analysis and Strategy Formation**\n\nOkay, so I'm looking at this \"Mushroom Strife\" problem, and it's a bit of a classic graph-based constraint satisfaction puzzle. The core is assigning mushroom counts to lawns (vertices) such that the GCD and LCM of mushrooms on connected lawns (edges) match the given values.  My initial instinct is to treat this as a graph problem where I need to find a valid assignment. The crucial relationship to exploit is that `GCD(a, b) * LCM(a, b) = a * b`, which provides a fundamental connection between the mushroom counts.\n\nI've realized that each lawn's mushroom count, let's call it `mushrooms[i]`, has to satisfy certain constraints based on the edges connected to it. For each edge, the count at each end must be a multiple of the given GCD and a divisor of the given LCM for that edge.  I'm thinking about how to propagate information across the graph, maybe starting with edges that have a unique solution or fixing one value and deducing the others. The constraints of the mushroom counts being integers between 1 and 10^6 are a key boundary condition.\n\n**Developing a Propagation Approach and Prime Factorization**\n\nI'm leaning towards a Breadth-First Search (BFS) type approach. I can start by processing the edges one by one and trying to assign values based on constraints. A key observation is that if `l % g != 0`, then the edge can't be valid, so I can immediately output \"NO.\"\n\nMy initial thought was to use the LCM of all GCDs incident to a lawn as a lower bound and the GCD of all LCMs incident to that lawn as an upper bound, but that doesn't capture the complete logic.\n\nI'm now focusing on the prime factorization of `l/g`, let's call it `P`. If I express `l/g` in its prime factorized form, I know `P` must be equal to `x * y`, where `x = val[u]/g`, `y= val[v]/g`, and `GCD(x,y)=1`. This suggests a relationship between the exponent of each prime factor of `P` and the factors x and y. If `p` is a prime factor of `P`, `p^exponent` will divide either `x` or `y`, but not both, which I need to enforce. This prime factorization perspective might be useful for encoding the constraints and assigning values.\n\n**Refining the Constraints and Potential for a 2-SAT Formulation**\n\nLet me try to refine this idea. For each lawn, `val[i]` must be a multiple of the LCM of the GCD values on edges connected to that lawn and a divisor of the GCD of LCM values on the same edges.\n\nI'm trying to formalize how to assign `v_p(ans[i])`, which will be the exponent for each prime factor `p` in the final solution.\n\nThe key condition is that for each edge `(u, v)` with `g, l`: the min/max relationships must be satisified for the exponents. This looks like it can be formed into some variation of a 2-SAT problem for each prime factor, for which I can set some constraints between exponents.\n",
    "response": "The problem asks us to assign a number of mushrooms `ans[i]` to each lawn `i` (from 1 to `n`) such that for every given road between lawns `u` and `v` with specified `GCD=g` and `LCM=l`, the conditions `GCD(ans[u], ans[v]) == g` and `LCM(ans[u], ans[v]) == l` are met. If a solution exists, we print \"YES\" and one such assignment; otherwise, \"NO\". The mushroom counts must be between 1 and 10^6.\n\nA fundamental property of GCD and LCM is `GCD(a, b) * LCM(a, b) = a * b`.\nSo, for an edge `(u, v)` with `g, l`, we must have `g * l = ans[u] * ans[v]`.\n\nAlso, for any prime `p`, let `v_p(k)` denote the exponent of `p` in the prime factorization of `k`.\nThe properties of GCD and LCM in terms of prime factor exponents are:\n`v_p(GCD(a, b)) = min(v_p(a), v_p(b))`\n`v_p(LCM(a, b)) = max(v_p(a), v_p(b))`\n\nCombining these, for an edge `(u, v)` with `g, l`, and for any prime `p`:\nLet `x_u = v_p(ans[u])` and `x_v = v_p(ans[v])`.\nLet `e_g = v_p(g)` and `e_l = v_p(l)`.\nWe must have:\n1. `min(x_u, x_v) = e_g`\n2. `max(x_u, x_v) = e_l`\n\nThese two conditions imply that the set `{x_u, x_v}` must be equal to the set `{e_g, e_l}`. In other words, for each prime `p`, the exponents of `p` in `ans[u]` and `ans[v]` must be `e_g` and `e_l` in some order.\n\nThis observation is key. We can solve the problem independently for each prime factor.\nFor each prime `p` that divides any `g` or `l` in the input (up to 10^6), we need to decide for each lawn `i` whether `v_p(ans[i])` should be `e_g` or `e_l` (from an edge constraint).\n\n**Algorithm:**\n\n1.  **Precompute Primes and Prime Factorization:** Generate all primes up to `sqrt(10^6) = 1000`. We'll need prime factors for numbers up to `10^6`. A sieve can precompute the smallest prime factor (SPF) for all numbers up to `10^6`. This allows efficient factorization.\n\n2.  **Initial Checks and Edge Storage:**\n    *   Initialize `ans[i] = 1` for all lawns `i`. We will multiply `ans[i]` by `p^exponent` for each prime `p`.\n    *   Store all edges. For each edge `(u, v, g, l)`:\n        *   If `l % g != 0`, then it's impossible. Print \"NO\" and exit.\n        *   Store `(u, v, g, l)` in an adjacency list for each node.\n\n3.  **Process Each Prime Independently:**\n    *   Iterate through all primes `p` up to `10^6`. For each `p`:\n        *   We need to determine `v_p(ans[i])` for all `i`.\n        *   For each lawn `i`, maintain `current_exp[i]`, the current exponent of `p` in `ans[i]`. Initialize `current_exp[i] = 0`.\n        *   Also, maintain `fixed[i]`, a boolean indicating if `current_exp[i]` has been definitively set for prime `p`. Initialize `fixed[i] = False`.\n        *   Use a queue for BFS-like propagation.\n        *   For each lawn `i` from 1 to `n`:\n            *   If `fixed[i]` is `False`:\n                *   Find the initial constraints for `v_p(ans[i])`. This is the most complex part.\n                *   A simpler approach for \"any solution\": If `i` is not `fixed`, try to set `current_exp[i]` to a value based on one of its neighbors.\n                *   Let's use a standard BFS for each connected component of the graph for *this prime*.\n                *   If `i` hasn't been visited for this prime `p`:\n                    *   Start a BFS from `i`. Set `current_exp[i] = v_p(g')` where `g'` is the GCD of some incident edge `(i, j)`. If `i` has no incident edges, `current_exp[i] = 0`. Mark `fixed[i] = True`. Add `i` to the queue.\n                    *   While the queue is not empty:\n                        *   Dequeue `curr_u`.\n                        *   For each neighbor `curr_v` of `curr_u` via edge `(curr_u, curr_v, g_edge, l_edge)`:\n                            *   Calculate `e_g = v_p(g_edge)` and `e_l = v_p(l_edge)`.\n                            *   `x_u = current_exp[curr_u]`.\n                            *   Based on `min(x_u, x_v) = e_g` and `max(x_u, x_v) = e_l`:\n                                *   If `x_u` is `e_g`, then `x_v` must be `e_l`.\n                                *   If `x_u` is `e_l`, then `x_v` must be `e_g`.\n                                *   If `x_u` is neither `e_g` nor `e_l`, then it's impossible. Print \"NO\" and exit.\n                                *   If `fixed[curr_v]` is `False`:\n                                    *   Set `current_exp[curr_v]` according to the rule above. Mark `fixed[curr_v] = True`. Enqueue `curr_v`.\n                                *   Else (`fixed[curr_v]` is `True`):\n                                    *   Check if the already assigned `current_exp[curr_v]` is consistent with `current_exp[curr_u]` and `(e_g, e_l)`.\n                                    *   If `(min(x_u, current_exp[curr_v]) != e_g)` or `(max(x_u, current_exp[curr_v]) != e_l)`, then it's impossible. Print \"NO\" and exit.\n\n        *   After the BFS for prime `p` completes, for each lawn `i`, multiply `ans[i]` by `p^current_exp[i]`.\n\n4.  **Final Check:**\n    *   After processing all primes, verify that all `ans[i]` are within the range [1, 10^6]. If not, print \"NO\" and exit.\n    *   Finally, for each original edge `(u, v, g, l)`:\n        *   Check `GCD(ans[u], ans[v]) == g` and `LCM(ans[u], ans[v]) == l`. If any check fails, print \"NO\" and exit.\n\n5.  **Output:** If all checks pass, print \"YES\" and then the `n` values in `ans`.\n\n**Optimization for Prime Processing:**\nInstead of iterating through all primes up to 10^6, we only need to consider primes that are factors of any `g` or `l` in the input. Collect all unique prime factors from all `g` and `l` values.\n\n**Example of Prime Processing (Step 3 refined):**\nFor each unique prime `p`:\n  `exp_p = [0] * (n + 1)` (exponent of `p` for each node `i`)\n  `visited_p = [False] * (n + 1)` (whether `v_p(ans[i])` for node `i` has been determined for prime `p`)\n  `q = deque()`\n\n  For `i` from 1 to `n`:\n    If not `visited_p[i]`:\n      If `adj[i]` is empty (node has no edges):\n        `visited_p[i] = True` (its `v_p` exponent remains 0, as `ans[i]` is initially 1)\n        Continue\n      \n      // Start BFS for this component\n      `start_node = i`\n      `first_edge_g = adj[start_node][0][2]` // g of the first incident edge\n      `exp_p[start_node] = v_p(first_edge_g)` // Assign initial exponent\n      `visited_p[start_node] = True`\n      `q.append(start_node)`\n\n      While `q`:\n        `u = q.popleft()`\n        For `(v, g_edge, l_edge)` in `adj[u]`:\n          `e_g = v_p(g_edge)`\n          `e_l = v_p(l_edge)`\n          `x_u = exp_p[u]`\n\n          If `x_u == e_g`: // Then x_v must be e_l\n            `expected_x_v = e_l`\n          elif `x_u == e_l`: // Then x_v must be e_g\n            `expected_x_v = e_g`\n          else: // Inconsistent assignment for u\n            Print \"NO\", exit.\n\n          If not `visited_p[v]`:\n            `exp_p[v] = expected_x_v`\n            `visited_p[v] = True`\n            `q.append(v)`\n          else: // Check consistency with already assigned v\n            If `exp_p[v] != expected_x_v`:\n              Print \"NO\", exit.\n\n  // After processing all components for prime p\n  For `i` from 1 to `n`:\n    `ans[i] *= (p ** exp_p[i])`\n    If `ans[i] > 1000000`:\n      Print \"NO\", exit.\n\nThis refined prime processing logic should work. The `adj` list stores `(neighbor, g, l)` tuples.\n\n**Helper Functions:**\n*   `gcd(a, b)`: Standard Euclidean algorithm.\n*   `v_p(n, p)`: Calculates `v_p(n)`.\n\n**Edge Case: `n=1, m=0`**\nThe initial `ans = [1]` will be printed, which is correct.\n\n**Maximum value of `ans[i]`:**\nEach `ans[i]` is initialized to 1. Then for each prime `p`, it's multiplied by `p^exponent`. If `ans[i]` exceeds 10^6 at any point, it's an invalid solution. This check should be included.\n\n```python\nimport sys\nfrom collections import deque\nimport math\n\n# Precompute smallest prime factor (SPF) for numbers up to MAX_VAL\nMAX_VAL = 10**6\nspf = [0] * (MAX_VAL + 1)\nprimes = []\n\ndef sieve():\n    for i in range(2, MAX_VAL + 1):\n        if spf[i] == 0:\n            spf[i] = i\n            primes.append(i)\n        for p in primes:\n            if p > spf[i] or i * p > MAX_VAL:\n                break\n            spf[i * p] = p\n\nsieve()\n\n# Function to get prime factorization (prime -> exponent)\ndef get_prime_factorization(n):\n    factors = {}\n    if n <= 1:\n        return factors\n    temp_n = n\n    while temp_n > 1:\n        p = spf[temp_n]\n        count = 0\n        while temp_n % p == 0:\n            temp_n //= p\n            count += 1\n        factors[p] = count\n    return factors\n\n# Function to calculate v_p(n)\ndef v_p(n, p):\n    count = 0\n    if p == 0: # Should not happen with valid primes\n        return 0\n    while n > 0 and n % p == 0:\n        count += 1\n        n //= p\n    return count\n\n# Function to calculate GCD\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\n# Function to calculate LCM\ndef lcm(a, b):\n    if a == 0 or b == 0:\n        return 0\n    return (a * b) // gcd(a, b)\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    all_edges = []\n    \n    # Collect all unique prime factors from g and l values\n    relevant_primes = set()\n\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        \n        if l % g != 0:\n            sys.stdout.write(\"NO\\n\")\n            return\n\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l))\n        all_edges.append((u, v, g, l))\n\n        # Add prime factors of g and l to relevant_primes set\n        for p in get_prime_factorization(g):\n            relevant_primes.add(p)\n        for p in get_prime_factorization(l):\n            relevant_primes.add(p)\n    \n    # Sort relevant primes for consistent processing\n    sorted_relevant_primes = sorted(list(relevant_primes))\n\n    ans = [1] * (n + 1) # ans[0] unused, ans[1..n] for lawns\n\n    # Process each relevant prime\n    for p in sorted_relevant_primes:\n        exp_p = [0] * (n + 1) # exponent of p for each node\n        visited_p = [False] * (n + 1) # whether v_p(ans[i]) for node i has been determined for prime p\n        q = deque()\n\n        for i in range(1, n + 1):\n            if not visited_p[i]:\n                if not adj[i]: # Node has no edges, its exponent for p remains 0\n                    visited_p[i] = True\n                    continue\n\n                # Start BFS for this component\n                # Pick an arbitrary incident edge to set the initial exponent for the component's root\n                u_start = i\n                v_neighbor, g_edge, l_edge = adj[u_start][0] # First edge for u_start\n                \n                e_g_start = v_p(g_edge, p)\n                e_l_start = v_p(l_edge, p)\n\n                # Try setting exp_p[u_start] to e_g_start\n                exp_p[u_start] = e_g_start\n                visited_p[u_start] = True\n                q.append(u_start)\n\n                while q:\n                    u = q.popleft()\n\n                    for v, g_edge, l_edge in adj[u]:\n                        e_g = v_p(g_edge, p)\n                        e_l = v_p(l_edge, p)\n                        x_u = exp_p[u]\n\n                        expected_x_v = -1 # Initialize with an invalid value\n\n                        if x_u == e_g:\n                            expected_x_v = e_l\n                        elif x_u == e_l:\n                            expected_x_v = e_g\n                        else:\n                            # Inconsistent assignment for u with this edge\n                            sys.stdout.write(\"NO\\n\")\n                            return\n\n                        if not visited_p[v]:\n                            exp_p[v] = expected_x_v\n                            visited_p[v] = True\n                            q.append(v)\n                        else:\n                            # Check consistency with already assigned v\n                            if exp_p[v] != expected_x_v:\n                                sys.stdout.write(\"NO\\n\")\n                                return\n        \n        # After processing all components for prime p\n        for i in range(1, n + 1):\n            try:\n                ans[i] *= (p ** exp_p[i])\n            except OverflowError: # p ** exp_p[i] might be too large\n                sys.stdout.write(\"NO\\n\")\n                return\n            if ans[i] > MAX_VAL:\n                sys.stdout.write(\"NO\\n\")\n                return\n    \n    # Final check: Verify all original edges\n    for u, v, g_orig, l_orig in all_edges:\n        if gcd(ans[u], ans[v]) != g_orig or lcm(ans[u], ans[v]) != l_orig:\n            sys.stdout.write(\"NO\\n\")\n            return\n            \n    sys.stdout.write(\"YES\\n\")\n    sys.stdout.write(\" \".join(map(str, ans[1:])) + \"\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\nimport math\n\n# Precompute smallest prime factor (SPF) for numbers up to MAX_VAL\nMAX_VAL = 10**6\nspf = [0] * (MAX_VAL + 1)\nprimes = []\n\ndef sieve():\n    for i in range(2, MAX_VAL + 1):\n        if spf[i] == 0:\n            spf[i] = i\n            primes.append(i)\n        for p in primes:\n            if p > spf[i] or i * p > MAX_VAL:\n                break\n            spf[i * p] = p\n\nsieve()\n\n# Function to get prime factorization (prime -> exponent)\ndef get_prime_factorization(n):\n    factors = {}\n    if n <= 1:\n        return factors\n    temp_n = n\n    while temp_n > 1:\n        p = spf[temp_n]\n        count = 0\n        while temp_n % p == 0:\n            temp_n //= p\n            count += 1\n        factors[p] = count\n    return factors\n\n# Function to calculate v_p(n)\ndef v_p(n, p):\n    count = 0\n    if p == 0: # Should not happen with valid primes\n        return 0\n    while n > 0 and n % p == 0:\n        count += 1\n        n //= p\n    return count\n\n# Function to calculate GCD\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\n# Function to calculate LCM\ndef lcm(a, b):\n    if a == 0 or b == 0:\n        return 0\n    return (a * b) // gcd(a, b)\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    all_edges = []\n    \n    # Collect all unique prime factors from g and l values\n    relevant_primes = set()\n\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        \n        if l % g != 0:\n            sys.stdout.write(\"NO\\n\")\n            return\n\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l))\n        all_edges.append((u, v, g, l))\n\n        # Add prime factors of g and l to relevant_primes set\n        for p in get_prime_factorization(g):\n            relevant_primes.add(p)\n        for p in get_prime_factorization(l):\n            relevant_primes.add(p)\n    \n    # Sort relevant primes for consistent processing\n    sorted_relevant_primes = sorted(list(relevant_primes))\n\n    ans = [1] * (n + 1) # ans[0] unused, ans[1..n] for lawns\n\n    # Process each relevant prime\n    for p in sorted_relevant_primes:\n        exp_p = [0] * (n + 1) # exponent of p for each node\n        visited_p = [False] * (n + 1) # whether v_p(ans[i]) for node i has been determined for prime p\n        q = deque()\n\n        for i in range(1, n + 1):\n            if not visited_p[i]:\n                if not adj[i]: # Node has no edges, its exponent for p remains 0\n                    visited_p[i] = True\n                    continue\n\n                # Start BFS for this component\n                # Pick an arbitrary incident edge to set the initial exponent for the component's root\n                u_start = i\n                v_neighbor, g_edge, l_edge = adj[u_start][0] # First edge for u_start\n                \n                e_g_start = v_p(g_edge, p)\n                e_l_start = v_p(l_edge, p)\n\n                # Try setting exp_p[u_start] to e_g_start\n                exp_p[u_start] = e_g_start\n                visited_p[u_start] = True\n                q.append(u_start)\n\n                while q:\n                    u = q.popleft()\n\n                    for v, g_edge, l_edge in adj[u]:\n                        e_g = v_p(g_edge, p)\n                        e_l = v_p(l_edge, p)\n                        x_u = exp_p[u]\n\n                        expected_x_v = -1 # Initialize with an invalid value\n\n                        if x_u == e_g:\n                            expected_x_v = e_l\n                        elif x_u == e_l:\n                            expected_x_v = e_g\n                        else:\n                            # Inconsistent assignment for u with this edge\n                            sys.stdout.write(\"NO\\n\")\n                            return\n\n                        if not visited_p[v]:\n                            exp_p[v] = expected_x_v\n                            visited_p[v] = True\n                            q.append(v)\n                        else:\n                            # Check consistency with already assigned v\n                            if exp_p[v] != expected_x_v:\n                                sys.stdout.write(\"NO\\n\")\n                                return\n        \n        # After processing all components for prime p\n        for i in range(1, n + 1):\n            try:\n                ans[i] *= (p ** exp_p[i])\n            except OverflowError: # p ** exp_p[i] might be too large\n                sys.stdout.write(\"NO\\n\")\n                return\n            if ans[i] > MAX_VAL:\n                sys.stdout.write(\"NO\\n\")\n                return\n    \n    # Final check: Verify all original edges\n    for u, v, g_orig, l_orig in all_edges:\n        if gcd(ans[u], ans[v]) != g_orig or lcm(ans[u], ans[v]) != l_orig:\n            sys.stdout.write(\"NO\\n\")\n            return\n            \n    sys.stdout.write(\"YES\\n\")\n    sys.stdout.write(\" \".join(map(str, ans[1:])) + \"\\n\")\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 552,
        "completion_token_count": 4076,
        "thoughts_token_count": 5857
    }
}