{
    "start": 1758011321.288525,
    "end": 1758011354.7049105,
    "start-formatted": "2025-09-16 17:28 KST",
    "end-formatted": "2025-09-16 17:29 KST",
    "gpu": 2,
    "pid": 8,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "",
    "response": "```python\nimport sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    edges_data = []\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n        edges_data.append((u, v, c))\n\n    ans = [-1] * m\n    visited_edges = [False] * m\n    balance = [0] * (n + 1)\n\n    q = [(1, 0)]  # (vertex, parent_edge_idx)\n    visited = [False] * (n + 1)\n    visited[1] = True\n    \n    dfs_order = []\n\n    stack = [(1, 0)]\n    while stack:\n        u, parent_edge_idx = stack.pop()\n        dfs_order.append(u)\n\n        for v, c, edge_idx in adj[u]:\n            if not visited[v]:\n                visited[v] = True\n                stack.append((v, edge_idx))\n\n    # Process vertices in reverse DFS order (from leaves towards root)\n    # This ensures that when we process a node, all its children (in DFS tree) have been processed\n    # and their flow balances are known.\n    \n    for u in reversed(dfs_order):\n        if u == 1:\n            continue\n\n        # Find the parent edge in the DFS tree\n        parent_edge_u = -1\n        parent_edge_c = -1\n        parent_edge_idx = -1\n        parent_node = -1\n\n        for v, c, edge_idx in adj[u]:\n            if ans[edge_idx] == -1: # This is an unassigned edge, potentially parent or non-tree edge\n                # If v is 1, it must be the parent\n                if v == 1:\n                    parent_edge_u = u\n                    parent_edge_c = c\n                    parent_edge_idx = edge_idx\n                    parent_node = v\n                    break\n                \n                # Check if v is already processed (meaning u is its parent in DFS tree)\n                # Or if u is 1, it must be the parent\n                if (ans[edge_idx] == -1 and (v != n and visited[v] and balance[v] != 0)) or v == 1:\n                    # This check is tricky. We need to identify the unique parent edge in the DFS tree.\n                    # A simpler approach is to rely on the fact that when processing u, its children's balances are finalized.\n                    # The remaining unassigned edge must be the one connecting to its parent in the DFS tree.\n                    # Or, if u is n, it could be a sink, and its parent edge is the one that brings flow to it.\n                    pass # This logic needs refinement.\n\n        # The correct way to find the parent edge is to use the DFS tree structure.\n        # However, since we are processing in reverse DFS order, for any node u (except 1),\n        # there will be exactly one unassigned edge that connects to its parent in the DFS tree.\n        # All other unassigned edges are either to children (already processed) or back-edges.\n        # This is getting complicated. Let's simplify.\n\n        # The problem statement guarantees that for 1 < v < n, incoming flow = outgoing flow.\n        # For vertex 1, no incoming edges.\n        # For vertex n, no outgoing edges.\n        # The graph does not have cycles.\n\n        # The key insight is that for any node `u` (1 < u < n), its total flow `balance[u]` must be 0.\n        # If `balance[u]` is positive, it means `u` has more outgoing flow than incoming flow.\n        # This excess must be compensated by the flow through one of its unassigned edges.\n        # If `balance[u]` is negative, it means `u` has more incoming flow than outgoing flow.\n        # This deficit must be compensated by the flow through one of its unassigned edges.\n\n        # Let's use a simpler approach: process from leaves up to the source.\n        # A node `u` is a \"leaf\" if all its neighbors (except its parent in the DFS tree) have been processed\n        # and their edges to `u` have been directed.\n        \n        # This problem is a classic application of a topological sort / DFS from leaves.\n        # We need to find the parent of each node in the DFS tree.\n        \n        # Let's re-do the DFS to build parent pointers.\n        parent_map = {}\n        visited_dfs = [False] * (n + 1)\n        dfs_stack = [(1, 0, -1)] # (node, parent_node, parent_edge_idx)\n        visited_dfs[1] = True\n        dfs_order_with_parents = [] # (node, parent_node, parent_edge_idx)\n\n        while dfs_stack:\n            u, p_node, p_edge_idx = dfs_stack.pop()\n            dfs_order_with_parents.append((u, p_node, p_edge_idx))\n\n            for v, c, edge_idx in adj[u]:\n                if not visited_dfs[v]:\n                    visited_dfs[v] = True\n                    parent_map[v] = (u, edge_idx)\n                    dfs_stack.append((v, u, edge_idx))\n        \n        # Now process nodes in reverse DFS order\n        for u, p_node, p_edge_idx in reversed(dfs_order_with_parents):\n            if u == 1:\n                continue\n\n            # Calculate the current balance for node u based on already directed edges\n            # For each neighbor v of u:\n            # If edge (u, v) is already directed:\n            #   If u -> v, add c to outgoing flow from u.\n            #   If v -> u, add c to incoming flow to u.\n            \n            # The `balance` array keeps track of `incoming_flow - outgoing_flow` for each node.\n            # So if balance[u] > 0, u has more incoming flow.\n            # If balance[u] < 0, u has more outgoing flow.\n\n            # For each edge (u, v, c, edge_idx) connected to u:\n            # If edge_idx is not p_edge_idx (i.e., not the parent edge)\n            # and edge (u,v) is directed (ans[edge_idx] != -1):\n            #   If edges_data[edge_idx] is (u,v) and ans[edge_idx] == 0: flow u->v\n            #   If edges_data[edge_idx] is (v,u) and ans[edge_idx] == 1: flow u->v\n            #   If edges_data[edge_idx] is (u,v) and ans[edge_idx] == 1: flow v->u\n            #   If edges_data[edge_idx] is (v,u) and ans[edge_idx] == 0: flow v->u\n\n            # Simplified logic for balance:\n            # When we process a node u in reverse DFS order, all its children in the DFS tree have been processed.\n            # Their edges to u have been directed, and their contribution to u's balance is already in `balance[u]`.\n            # So, `balance[u]` represents `sum(incoming from children) - sum(outgoing to children)`.\n            # For node `u` (1 < u < n), the final balance must be 0.\n            # The remaining flow to balance must go through its parent edge (u, p_node).\n\n            # Determine direction of parent edge (u, p_node)\n            # The parent edge is edges_data[p_edge_idx]. Let it be (orig_u, orig_v, flow_c).\n            # If balance[u] > 0, it means u has an excess of incoming flow from its children.\n            # To balance this, flow must go from u to p_node.\n            # If balance[u] < 0, it means u has a deficit of incoming flow (excess outgoing to children).\n            # To balance this, flow must go from p_node to u.\n            # If balance[u] == 0, the direction doesn't matter for balance, but we need to assign it.\n            # The problem states \"no cycles\". This implies a DAG. Source 1 has no incoming, sink n has no outgoing.\n            # The total flow from 1 to n must be preserved.\n\n            flow_c = edges_data[p_edge_idx][2]\n            orig_u, orig_v, _ = edges_data[p_edge_idx]\n\n            if u == n: # Sink node\n                # All flow must be incoming to n. So, flow from p_node to n.\n                if orig_u == p_node and orig_v == n:\n                    ans[p_edge_idx] = 0 # p_node -> n\n                else: # orig_u == n and orig_v == p_node\n                    ans[p_edge_idx] = 1 # p_node -> n\n                \n                # Update balance for p_node (incoming to p_node means negative balance)\n                balance[p_node] -= flow_c # p_node is sending flow\n            elif balance[u] > 0: # u has more incoming flow, must send to parent\n                if orig_u == u and orig_v == p_node:\n                    ans[p_edge_idx] = 0 # u -> p_node\n                else: # orig_u == p_node and orig_v == u\n                    ans[p_edge_idx] = 1 # u -> p_node\n                \n                balance[p_node] += balance[u] # p_node receives flow from u\n            elif balance[u] < 0: # u has more outgoing flow, must receive from parent\n                if orig_u == p_node and orig_v == u:\n                    ans[p_edge_idx] = 0 # p_node -> u\n                else: # orig_u == u and orig_v == p_node\n                    ans[p_edge_idx] = 1 # p_node -> u\n                \n                balance[p_node] += balance[u] # p_node sends flow to u (adds negative value)\n            else: # balance[u] == 0. This means u doesn't need to send/receive flow through parent to balance itself.\n                  # This implies flow from p_node to u or u to p_node with `flow_c` units.\n                  # Since there are no cycles and 1 has no incoming, we can generally direct towards 1.\n                  # Or, if u is not n, direct away from 1.\n                  # A simpler rule for balance[u] == 0: always direct towards 1 (i.e. u -> p_node)\n                  # This ensures we are not creating cycles and respecting source/sink.\n                  # If we direct u -> p_node, then p_node receives flow.\n                  # If we direct p_node -> u, then p_node sends flow.\n                  # The crucial point is that this flow_c is still part of the total flow.\n                  # If balance[u] == 0, it means all children's flows are balanced among themselves.\n                  # The parent edge (u, p_node) can carry any amount of flow 'c'.\n                  # The total flow from 1 to n is fixed.\n                  # The problem statement says \"vertex with number 1 has no incoming edges\".\n                  # This implies that all edges connected to 1 must be outgoing from 1.\n                  # So, for the edge (1, v), it must be 1 -> v.\n\n                  # Let's try a simpler approach for balance[u] == 0:\n                  # If the edge is (u, p_node), and we want flow p_node -> u,\n                  # then balance[p_node] -= flow_c.\n                  # If we want flow u -> p_node, then balance[p_node] += flow_c.\n                  # The key is to direct flow towards the source (1) if possible, to avoid cycles.\n                  # This is equivalent to saying, if balance[u] == 0, direct u -> p_node.\n                  # This ensures flow moves away from u, towards the \"root\" of the DFS tree.\n                \n                # Default direction for balance[u] == 0: u -> p_node\n                if orig_u == u and orig_v == p_node:\n                    ans[p_edge_idx] = 0 # u -> p_node\n                else: # orig_u == p_node and orig_v == u\n                    ans[p_edge_idx] = 1 # u -> p_node\n                \n                balance[p_node] += flow_c # p_node receives flow from u\n\n            # After assigning direction for parent edge, update balance for the parent node\n            # The balance for u itself is now 0 (or balanced by the parent edge).\n            # The flow_c of the parent edge is now accounted for in p_node's balance.\n\n    # Finally, for edges connected to 1, they must be outgoing from 1.\n    for v, c, edge_idx in adj[1]:\n        if ans[edge_idx] == -1: # Should not happen if DFS tree covers all edges.\n            # This means edge (1, v) was not part of the DFS tree.\n            # But the graph is connected, so all edges must be part of the DFS tree or a back-edge.\n            # If edge_idx is p_edge_idx for v, it would have been assigned.\n            # So this implies a bug in logic.\n            # The only case where ans[edge_idx] is -1 for an edge connected to 1\n            # is if 1 is the parent of v in the DFS tree, and we haven't processed 1 yet.\n            # But we process 1 last, so its edges are determined by the children.\n            \n            # Let's reconsider. The `balance` array tracks `incoming - outgoing`.\n            # For 1, it must have no incoming. All its edges must be outgoing.\n            # So for any edge (1, v) with flow c:\n            #   If original edge is (1, v), ans[edge_idx] = 0 (1 -> v)\n            #   If original edge is (v, 1), ans[edge_idx] = 1 (1 -> v)\n            # This means balance[1] should decrease by c for each such edge.\n            # The final balance[1] will be -total_flow.\n\n            orig_u, orig_v, flow_c = edges_data[edge_idx]\n            if orig_u == 1 and orig_v == v:\n                ans[edge_idx] = 0 # 1 -> v\n            else: # orig_u == v and orig_v == 1\n                ans[edge_idx] = 1 # 1 -> v\n\n    # Output the results\n    for result in ans:\n        sys.stdout.write(str(result) + '\\n')\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    edges_data = []\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n        edges_data.append((u, v, c))\n\n    ans = [-1] * m\n    visited_edges = [False] * m\n    balance = [0] * (n + 1)\n\n    q = [(1, 0)]  # (vertex, parent_edge_idx)\n    visited = [False] * (n + 1)\n    visited[1] = True\n    \n    dfs_order = []\n\n    stack = [(1, 0)]\n    while stack:\n        u, parent_edge_idx = stack.pop()\n        dfs_order.append(u)\n\n        for v, c, edge_idx in adj[u]:\n            if not visited[v]:\n                visited[v] = True\n                stack.append((v, edge_idx))\n\n    # Process vertices in reverse DFS order (from leaves towards root)\n    # This ensures that when we process a node, all its children (in DFS tree) have been processed\n    # and their flow balances are known.\n    \n    for u in reversed(dfs_order):\n        if u == 1:\n            continue\n\n        # Find the parent edge in the DFS tree\n        parent_edge_u = -1\n        parent_edge_c = -1\n        parent_edge_idx = -1\n        parent_node = -1\n\n        for v, c, edge_idx in adj[u]:\n            if ans[edge_idx] == -1: # This is an unassigned edge, potentially parent or non-tree edge\n                # If v is 1, it must be the parent\n                if v == 1:\n                    parent_edge_u = u\n                    parent_edge_c = c\n                    parent_edge_idx = edge_idx\n                    parent_node = v\n                    break\n                \n                # Check if v is already processed (meaning u is its parent in DFS tree)\n                # Or if u is 1, it must be the parent\n                if (ans[edge_idx] == -1 and (v != n and visited[v] and balance[v] != 0)) or v == 1:\n                    # This check is tricky. We need to identify the unique parent edge in the DFS tree.\n                    # A simpler approach is to rely on the fact that when processing u, its children's balances are finalized.\n                    # The remaining unassigned edge must be the one connecting to its parent in the DFS tree.\n                    # Or, if u is n, it could be a sink, and its parent edge is the one that brings flow to it.\n                    pass # This logic needs refinement.\n\n        # The correct way to find the parent edge is to use the DFS tree structure.\n        # However, since we are processing in reverse DFS order, for any node u (except 1),\n        # there will be exactly one unassigned edge that connects to its parent in the DFS tree.\n        # All other unassigned edges are either to children (already processed) or back-edges.\n        # This is getting complicated. Let's simplify.\n\n        # The problem statement guarantees that for 1 < v < n, incoming flow = outgoing flow.\n        # For vertex 1, no incoming edges.\n        # For vertex n, no outgoing edges.\n        # The graph does not have cycles.\n\n        # The key insight is that for any node `u` (1 < u < n), its total flow `balance[u]` must be 0.\n        # If `balance[u]` is positive, it means `u` has more outgoing flow than incoming flow.\n        # This excess must be compensated by the flow through one of its unassigned edges.\n        # If `balance[u]` is negative, it means `u` has more incoming flow than outgoing flow.\n        # This deficit must be compensated by the flow through one of its unassigned edges.\n\n        # Let's use a simpler approach: process from leaves up to the source.\n        # A node `u` is a \"leaf\" if all its neighbors (except its parent in the DFS tree) have been processed\n        # and their edges to `u` have been directed.\n        \n        # This problem is a classic application of a topological sort / DFS from leaves.\n        # We need to find the parent of each node in the DFS tree.\n        \n        # Let's re-do the DFS to build parent pointers.\n        parent_map = {}\n        visited_dfs = [False] * (n + 1)\n        dfs_stack = [(1, 0, -1)] # (node, parent_node, parent_edge_idx)\n        visited_dfs[1] = True\n        dfs_order_with_parents = [] # (node, parent_node, parent_edge_idx)\n\n        while dfs_stack:\n            u, p_node, p_edge_idx = dfs_stack.pop()\n            dfs_order_with_parents.append((u, p_node, p_edge_idx))\n\n            for v, c, edge_idx in adj[u]:\n                if not visited_dfs[v]:\n                    visited_dfs[v] = True\n                    parent_map[v] = (u, edge_idx)\n                    dfs_stack.append((v, u, edge_idx))\n        \n        # Now process nodes in reverse DFS order\n        for u, p_node, p_edge_idx in reversed(dfs_order_with_parents):\n            if u == 1:\n                continue\n\n            # Calculate the current balance for node u based on already directed edges\n            # For each neighbor v of u:\n            # If edge (u, v) is already directed:\n            #   If u -> v, add c to outgoing flow from u.\n            #   If v -> u, add c to incoming flow to u.\n            \n            # The `balance` array keeps track of `incoming_flow - outgoing_flow` for each node.\n            # So if balance[u] > 0, u has more incoming flow.\n            # If balance[u] < 0, u has more outgoing flow.\n\n            # For each edge (u, v, c, edge_idx) connected to u:\n            # If edge_idx is not p_edge_idx (i.e., not the parent edge)\n            # and edge (u,v) is directed (ans[edge_idx] != -1):\n            #   If edges_data[edge_idx] is (u,v) and ans[edge_idx] == 0: flow u->v\n            #   If edges_data[edge_idx] is (v,u) and ans[edge_idx] == 1: flow u->v\n            #   If edges_data[edge_idx] is (u,v) and ans[edge_idx] == 1: flow v->u\n            #   If edges_data[edge_idx] is (v,u) and ans[edge_idx] == 0: flow v->u\n\n            # Simplified logic for balance:\n            # When we process a node u in reverse DFS order, all its children in the DFS tree have been processed.\n            # Their edges to u have been directed, and their contribution to u's balance is already in `balance[u]`.\n            # So, `balance[u]` represents `sum(incoming from children) - sum(outgoing to children)`.\n            # For node `u` (1 < u < n), the final balance must be 0.\n            # The remaining flow to balance must go through its parent edge (u, p_node).\n\n            # Determine direction of parent edge (u, p_node)\n            # The parent edge is edges_data[p_edge_idx]. Let it be (orig_u, orig_v, flow_c).\n            # If balance[u] > 0, it means u has an excess of incoming flow from its children.\n            # To balance this, flow must go from u to p_node.\n            # If balance[u] < 0, it means u has a deficit of incoming flow (excess outgoing to children).\n            # To balance this, flow must go from p_node to u.\n            # If balance[u] == 0, the direction doesn't matter for balance, but we need to assign it.\n            # The problem states \"no cycles\". This implies a DAG. Source 1 has no incoming, sink n has no outgoing.\n            # The total flow from 1 to n must be preserved.\n\n            flow_c = edges_data[p_edge_idx][2]\n            orig_u, orig_v, _ = edges_data[p_edge_idx]\n\n            if u == n: # Sink node\n                # All flow must be incoming to n. So, flow from p_node to n.\n                if orig_u == p_node and orig_v == n:\n                    ans[p_edge_idx] = 0 # p_node -> n\n                else: # orig_u == n and orig_v == p_node\n                    ans[p_edge_idx] = 1 # p_node -> n\n                \n                # Update balance for p_node (incoming to p_node means negative balance)\n                balance[p_node] -= flow_c # p_node is sending flow\n            elif balance[u] > 0: # u has more incoming flow, must send to parent\n                if orig_u == u and orig_v == p_node:\n                    ans[p_edge_idx] = 0 # u -> p_node\n                else: # orig_u == p_node and orig_v == u\n                    ans[p_edge_idx] = 1 # u -> p_node\n                \n                balance[p_node] += balance[u] # p_node receives flow from u\n            elif balance[u] < 0: # u has more outgoing flow, must receive from parent\n                if orig_u == p_node and orig_v == u:\n                    ans[p_edge_idx] = 0 # p_node -> u\n                else: # orig_u == u and orig_v == p_node\n                    ans[p_edge_idx] = 1 # p_node -> u\n                \n                balance[p_node] += balance[u] # p_node sends flow to u (adds negative value)\n            else: # balance[u] == 0. This means u doesn't need to send/receive flow through parent to balance itself.\n                  # This implies flow from p_node to u or u to p_node with `flow_c` units.\n                  # Since there are no cycles and 1 has no incoming, we can generally direct towards 1.\n                  # Or, if u is not n, direct away from 1.\n                  # A simpler rule for balance[u] == 0: always direct towards 1 (i.e. u -> p_node)\n                  # This ensures we are not creating cycles and respecting source/sink.\n                  # If we direct u -> p_node, then p_node receives flow.\n                  # If we direct p_node -> u, then p_node sends flow.\n                  # The crucial point is that this flow_c is still part of the total flow.\n                  # If balance[u] == 0, it means all children's flows are balanced among themselves.\n                  # The parent edge (u, p_node) can carry any amount of flow 'c'.\n                  # The total flow from 1 to n is fixed.\n                  # The problem statement says \"vertex with number 1 has no incoming edges\".\n                  # This implies that all edges connected to 1 must be outgoing from 1.\n                  # So, for the edge (1, v), it must be 1 -> v.\n\n                  # Let's try a simpler approach for balance[u] == 0:\n                  # If the edge is (u, p_node), and we want flow p_node -> u,\n                  # then balance[p_node] -= flow_c.\n                  # If we want flow u -> p_node, then balance[p_node] += flow_c.\n                  # The key is to direct flow towards the source (1) if possible, to avoid cycles.\n                  # This is equivalent to saying, if balance[u] == 0, direct u -> p_node.\n                  # This ensures flow moves away from u, towards the \"root\" of the DFS tree.\n                \n                # Default direction for balance[u] == 0: u -> p_node\n                if orig_u == u and orig_v == p_node:\n                    ans[p_edge_idx] = 0 # u -> p_node\n                else: # orig_u == p_node and orig_v == u\n                    ans[p_edge_idx] = 1 # u -> p_node\n                \n                balance[p_node] += flow_c # p_node receives flow from u\n\n            # After assigning direction for parent edge, update balance for the parent node\n            # The balance for u itself is now 0 (or balanced by the parent edge).\n            # The flow_c of the parent edge is now accounted for in p_node's balance.\n\n    # Finally, for edges connected to 1, they must be outgoing from 1.\n    for v, c, edge_idx in adj[1]:\n        if ans[edge_idx] == -1: # Should not happen if DFS tree covers all edges.\n            # This means edge (1, v) was not part of the DFS tree.\n            # But the graph is connected, so all edges must be part of the DFS tree or a back-edge.\n            # If edge_idx is p_edge_idx for v, it would have been assigned.\n            # So this implies a bug in logic.\n            # The only case where ans[edge_idx] is -1 for an edge connected to 1\n            # is if 1 is the parent of v in the DFS tree, and we haven't processed 1 yet.\n            # But we process 1 last, so its edges are determined by the children.\n            \n            # Let's reconsider. The `balance` array tracks `incoming - outgoing`.\n            # For 1, it must have no incoming. All its edges must be outgoing.\n            # So for any edge (1, v) with flow c:\n            #   If original edge is (1, v), ans[edge_idx] = 0 (1 -> v)\n            #   If original edge is (v, 1), ans[edge_idx] = 1 (1 -> v)\n            # This means balance[1] should decrease by c for each such edge.\n            # The final balance[1] will be -total_flow.\n\n            orig_u, orig_v, flow_c = edges_data[edge_idx]\n            if orig_u == 1 and orig_v == v:\n                ans[edge_idx] = 0 # 1 -> v\n            else: # orig_u == v and orig_v == 1\n                ans[edge_idx] = 1 # 1 -> v\n\n    # Output the results\n    for result in ans:\n        sys.stdout.write(str(result) + '\\n')\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 745,
        "completion_token_count": 3556,
        "thoughts_token_count": 0
    }
}