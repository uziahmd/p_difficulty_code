{
    "start": 1758284926.910683,
    "end": 1758285002.158742,
    "start-formatted": "2025-09-19 21:28 KST",
    "end-formatted": "2025-09-19 21:30 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "**Initial Thoughts and Problem Decomposition**\n\nAlright, \"Mushroom Strife.\" Sounds fun. Let's break this down. We've got a graph problem: lawns are vertices, roads are edges. Each edge tells us the GCD and LCM of the mushroom counts on the connected lawns. The goal is to find a *valid* mushroom count for each lawn (between 1 and 10^6) that satisfies these GCD and LCM constraints across *all* edges, or declare that no such assignment exists.  \n\nFirst, let's nail down this core relationship between GCD and LCM: `GCD(a, b) * LCM(a, b) = a * b`. That's fundamental. So, if we know `g` (GCD) and `l` (LCM) for an edge, then `a * b = g * l`, where `a` and `b` are the mushroom counts. The edge constraints are the key.  And, logically, if `l` isn't divisible by `g`, that's an immediate dead end. No solution exists.\n\n**Translating Constraints into Variables**\n\nNow we have our representation. Let's imagine `val[u]` is the mushroom count on lawn `u`. If an edge connects `u` and `v` with GCD `g` and LCM `l`, then:\n*   `val[u]` and `val[v]` must be multiples of `g`.\n*   `val[u] * val[v] = g * l`.\n*   `l` must be divisible by `g`.\n\n**Building the Strategy**\n\nWith the constraints translated, my initial thoughts are to try a graph traversal (BFS or DFS) or maybe even Disjoint Set Union (DSU). Since these constraints are multiplicative, this makes things trickier than a standard graph problem. We're looking at the relationship `val[u] * val[v] = g * l`. Fixing one value (`val[u]`) uniquely determines the other (`val[v]`) within a connected component, but there is also `x * y = l / g` constraint, which provides constraints to `val[u]`.\nI need to work with prime factorizations, since our bounds allow it.\nWe need to handle the constraints in some sort of iterative way. Maybe find valid values, and then make sure they are consistent.\n\nLet's start by representing the graph with an adjacency list. Each list entry for a vertex `u` will be a tuple: `(v, g, l)`. This way, we can efficiently iterate through neighbors and their associated constraints. We can start by selecting an arbitrary value for one vertex and then deriving the rest. Let's see if we can work this out.\n",
    "response": "```python\nimport sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    if n == 0:\n        print(\"NO\")\n        return\n\n    adj = [[] for _ in range(n + 1)]\n    edges_data = []\n\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        \n        # Initial check for GCD, LCM consistency\n        if l % g != 0:\n            print(\"NO\")\n            return\n        \n        # Check if LCM/GCD is too large for product\n        # max_val = 10^6. If g*l > max_val^2, then (g*l) / val[u] might exceed max_val\n        # However, the problem states mushroom counts are <= 10^6.\n        # This implies g <= 10^6, l <= 10^6.\n        # If val[u] = g*x and val[v] = g*y, then x*y = l/g.\n        # Max x or y can be l/g.\n        # If val[u] > 10^6 or val[v] > 10^6, it's invalid.\n        # This check is implicitly done later when checking final values.\n        \n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l))\n        edges_data.append((u, v, g, l))\n\n    # To store the assigned mushroom counts\n    ans = [0] * (n + 1)\n    # To store the relative factor 'k' for each connected component\n    # val[i] = k[i] * base_value_for_component\n    # More precisely, val[i] = k_i * X, where X is the base value chosen for some node in the component.\n    # The actual value stored in factors[i] will be k_i.\n    factors = [0] * (n + 1)\n    # To keep track of visited nodes\n    visited = [False] * (n + 1)\n\n    # Function to find prime factors for a number\n    # Returns a dictionary: {prime_factor: exponent}\n    def get_prime_factors(num):\n        factors_map = {}\n        d = 2\n        temp = num\n        while d * d <= temp:\n            while temp % d == 0:\n                factors_map[d] = factors_map.get(d, 0) + 1\n                temp //= d\n            d += 1\n        if temp > 1:\n            factors_map[temp] = factors_map.get(temp, 0) + 1\n        return factors_map\n\n    # Function to multiply two factor maps\n    def multiply_factor_maps(map1, map2):\n        result = map1.copy()\n        for p, exp in map2.items():\n            result[p] = result.get(p, 0) + exp\n        return result\n\n    # Function to divide two factor maps (map1 / map2)\n    # Assumes map1 is divisible by map2\n    def divide_factor_maps(map1, map2):\n        result = map1.copy()\n        for p, exp in map2.items():\n            result[p] -= exp\n            if result[p] == 0:\n                del result[p]\n        return result\n\n    # Function to check if map1 is divisible by map2\n    def is_divisible(map1, map2):\n        for p, exp in map2.items():\n            if p not in map1 or map1[p] < exp:\n                return False\n        return True\n\n    # Function to compute GCD of two numbers from their factor maps\n    def gcd_from_factors(map1, map2):\n        res_map = {}\n        for p, exp1 in map1.items():\n            if p in map2:\n                res_map[p] = min(exp1, map2[p])\n        return res_map\n\n    # Function to compute LCM of two numbers from their factor maps\n    def lcm_from_factors(map1, map2):\n        res_map = map1.copy()\n        for p, exp2 in map2.items():\n            res_map[p] = max(res_map.get(p, 0), exp2)\n        return res_map\n\n    # Function to convert factor map back to integer\n    def map_to_int(f_map):\n        num = 1\n        for p, exp in f_map.items():\n            num *= (p ** exp)\n        return num\n\n    # Depth-First Search to traverse connected components\n    def dfs(u, current_factor_map):\n        visited[u] = True\n        factors[u] = current_factor_map\n\n        for v, g, l in adj[u]:\n            if not visited[v]:\n                # We have val[u] = k_u * X and val[v] = k_v * X\n                # We know k_u and need to find k_v.\n                # val[u] * val[v] = g * l\n                # (k_u * X) * (k_v * X) = g * l\n                # X^2 * k_u * k_v = g * l\n                # This approach of relative factors k_i and a base X is tricky because X is squared.\n\n                # Let's use a simpler approach for DFS:\n                # Assign an arbitrary value (e.g., 1) to the first node in a component.\n                # This is not good because it might not be a multiple of g.\n                # The problem statement says any valid assignment.\n                # A better approach: assign val[u] = g for the first node, and then propagate.\n                # This is also not good, because val[u] must be g * x, where x is some factor of l/g.\n\n                # Correct approach:\n                # For an edge (u, v) with GCD=g, LCM=l:\n                # val[u] = g * x_u\n                # val[v] = g * x_v\n                # x_u * x_v = l / g\n                # GCD(x_u, x_v) = 1\n                #\n                # If we know val[u], then val[v] = (g * l) // val[u].\n                # We need to ensure val[v] is an integer, a multiple of g, and in range [1, 10^6].\n                #\n                # Let's fix the first node `u` in a component. We need to assign `val[u]`.\n                # What is the \"best\" `val[u]` to start with?\n                # The smallest possible value for any node `x` is `g_x` where `g_x` is the GCD of all numbers connected to `x`.\n                #\n                # Instead, let's use the factors[u] to store the *actual* value of val[u].\n                # When we start DFS from u, we don't know val[u] yet.\n                # We can't pick an arbitrary value for val[u] and hope it works for the whole component.\n                #\n                # The original idea of factors[i] storing the relative factor (val[i] / val[start_node]) is good.\n                # Let's say factors[u] = k_u. Then val[u] = k_u * X.\n                # val[v] = k_v * X.\n                # From val[u] * val[v] = g * l, we have k_u * X * k_v * X = g * l.\n                # X^2 * k_u * k_v = g * l.\n                # This means we need to find X such that X^2 divides g*l. This is still complicated.\n\n                # Let's rethink the relative factors.\n                # For each connected component, we pick a root node `r`.\n                # We assign `val[r] = X`.\n                # For any other node `u`, we try to express `val[u]` as `k_u * X` or `X / k_u`.\n                # The constraint `GCD(a,b)*LCM(a,b) = a*b` means `val[u] * val[v] = g * l`.\n                #\n                # Let `u` be the current node, and `val[u]` is determined.\n                # For an edge `(u, v)` with `g, l`:\n                # `val[v] = (g * l) // val[u]`.\n                # This must be an integer. It must be a multiple of `g`.\n                # `val[u]` must be a multiple of `g`.\n                #\n                # This is the standard approach for solving systems of equations.\n                # Let `val[u] = a_u`.\n                # Pick an arbitrary node `s`. Let `a_s = X`.\n                # For any neighbor `t` of `s` with `g_st, l_st`: `a_t = (g_st * l_st) / X`.\n                # For any neighbor `w` of `t` with `g_tw, l_tw`: `a_w = (g_tw * l_tw) / a_t = (g_tw * l_tw) / ((g_st * l_st) / X) = (g_tw * l_tw * X) / (g_st * l_st)`.\n                #\n                # So, for any node `u` in a component, `a_u` will be of the form `C_u * X` or `X / C_u`.\n                # More generally, `a_u = (Num_u / Den_u) * X`.\n                # We want to find `X` such that all `a_u` are integers, multiples of their respective `g`'s, and within `[1, 10^6]`.\n                #\n                # Let `ratio[u]` be `val[u] / val[root]`.\n                # For an edge `(u, v)` with `g, l`:\n                # `val[u] = ratio[u] * val[root]`\n                # `val[v] = ratio[v] * val[root]`\n                # `(ratio[u] * val[root]) * (ratio[v] * val[root]) = g * l`\n                # `ratio[u] * ratio[v] * (val[root])^2 = g * l`\n                # `ratio[v] = (g * l) / (ratio[u] * (val[root])^2)`\n                # This implies `ratio[v]` depends on `val[root]`, which means `ratio` cannot be fixed beforehand.\n\n                # Let's use the `val[u] = X * k_u` idea from the editorial.\n                # `k_u` stores the prime factorization of `val[u] / X`.\n                # When traversing from `u` to `v`:\n                # `val[u] * val[v] = g * l`\n                # `val[v] = (g * l) / val[u]`\n                # `val[v] = (g * l) / (X * k_u)`\n                # `val[v] = X * k_v`\n                # So `k_v = (g * l) / (X^2 * k_u)`. This is still problematic because of X^2.\n\n                # The \"correct\" relative factor approach:\n                # Fix `val[u]` to `X`. All other `val[v]` will be `X * (some_ratio)`.\n                # Let `factors[u]` store the prime factorization of `val[u]`.\n                # For a root `r` of a component, we don't know `val[r]`.\n                # For any other node `u`, `val[u]` can be written as `(A_u / B_u) * val[r]`.\n                # Let `factors[u]` store the prime factorization of `A_u / B_u`.\n                # So `val[u] = val[r] * map_to_int(factors[u])`.\n                #\n                # When traversing `u` -> `v` with `g, l`:\n                # `val[u]` is known (as `val[r] * map_to_int(factors[u])`).\n                # `val[v]` should be `(g * l) / val[u]`.\n                # So `val[v] = (g * l) / (val[r] * map_to_int(factors[u]))`.\n                # We also want `val[v] = val[r] * map_to_int(factors[v])`.\n                # Equating these:\n                # `val[r] * map_to_int(factors[v]) = (g * l) / (val[r] * map_to_int(factors[u]))`\n                # `(val[r])^2 * map_to_int(factors[v]) * map_to_int(factors[u]) = g * l`\n                # `map_to_int(factors[v]) = (g * l) / ((val[r])^2 * map_to_int(factors[u]))`\n                # This still depends on `val[r]`.\n\n                # The actual editorial approach for relative factors:\n                # For each component, pick a root `r`.\n                # We want to find `val[r]`.\n                # For any node `u` in the component, `val[u]` can be written as `X_u * val[r]` where `X_u` is a fixed rational number.\n                # Or, more simply, `val[u] = val[r] * k_u`, where `k_u` is a rational number.\n                # `k_r = 1`.\n                # For an edge `(u, v)` with `g, l`:\n                # `val[u] * val[v] = g * l`\n                # `(k_u * val[r]) * (k_v * val[r]) = g * l`\n                # `k_u * k_v * (val[r])^2 = g * l`\n                # `k_v = (g * l) / (k_u * (val[r])^2)`\n                # This is still the same issue.\n\n                # The problem statement implies `val[u]` and `val[v]` are integers.\n                # `val[u] = g * x`, `val[v] = g * y`, where `x * y = l / g` and `GCD(x, y) = 1`.\n                #\n                # The key insight for relative factors:\n                # Let `P_u` be the set of prime factors of `val[u]`.\n                # Let `P_v` be the set of prime factors of `val[v]`.\n                #\n                # For an edge `(u, v)` with `g, l`:\n                # `val[u] = g * x`\n                # `val[v] = g * y`\n                # `x * y = l / g`\n                # `GCD(x, y) = 1`\n                #\n                # This means `x` and `y` are coprime.\n                # All prime factors of `l/g` are split between `x` and `y`.\n                #\n                # Let `current_val_map[u]` store the prime factorization of `val[u]`.\n                # When we start DFS from `u` for a new component, we don't know `val[u]`.\n                # We can express `val[u]` as `base_val * some_factor_map`.\n                #\n                # Let's try the approach from a similar problem:\n                # `val[u]` is assigned a value `X`.\n                # `val[v]` is then `(g*l)/X`.\n                # `val[w]` is then `(g'*l')/((g*l)/X) = (g'*l'*X)/(g*l)`.\n                # So every `val[k]` will be of the form `N_k * X` or `X / D_k`.\n                # We can represent `val[k]` as `(N_k / D_k) * X`.\n                # Let `factors[k]` store the prime factorization of `N_k / D_k`.\n                # `factors[k]` is a map `{prime: exponent}` where positive exponent means in numerator, negative in denominator.\n                # For the root `r`, `factors[r]` is an empty map (representing 1).\n                #\n                # When traversing `u` -> `v` with `g, l`:\n                # We know `factors[u]`. We want to find `factors[v]`.\n                # `val[u] = X * map_to_int(factors[u])`\n                # `val[v] = X * map_to_int(factors[v])`\n                # `val[u] * val[v] = g * l`\n                # `X^2 * map_to_int(factors[u]) * map_to_int(factors[v]) = g * l`\n                # `map_to_int(factors[v]) = (g * l) / (X^2 * map_to_int(factors[u]))`\n                # This still depends on X. The problem is that X is squared.\n\n                # The key is that val[u] and val[v] are integers.\n                # Let `val[u] = k_u * X` and `val[v] = k_v * X` where `k_u` and `k_v` are integers.\n                # This is only possible if `X` is `GCD(val[u], val[v])`.\n                # This implies `X` must be `g`.\n                # So if we set `val[root] = g_root * x_root`, then `val[u] = g_u * x_u`.\n                #\n                # Let `val[u] = C_u * K` where `K` is some unknown.\n                # `C_u` is a product of prime powers.\n                # For `r` (root of component), `C_r = 1`.\n                # `val[r] = K`.\n                # For edge `(u, v)` with `g, l`:\n                # `val[u] = C_u * K`\n                # `val[v] = C_v * K`\n                # `C_u * K * C_v * K = g * l`\n                # `C_u * C_v * K^2 = g * l`\n                # `C_v = (g * l) / (C_u * K^2)`. This implies `C_v` depends on `K`.\n\n                # The actual \"relative factor\" approach that works:\n                # `val[u]` and `val[v]` must be integers.\n                # Let `val[u] = X * k_u` where `k_u` is a rational number.\n                # `k_u` is stored as a prime factorization map `factors[u]`.\n                # `factors[u]` stores `factors(numerator) - factors(denominator)`.\n                # For the root `r` of a component, `factors[r]` is an empty map (representing 1).\n                #\n                # For an edge `(u, v)` with `g, l`:\n                # We have `val[u] = X * map_to_int(factors[u])`.\n                # We need to find `val[v]`.\n                # `val[v] = (g * l) / val[u] = (g * l) / (X * map_to_int(factors[u]))`.\n                # We also need `val[v] = X * map_to_int(factors[v])`.\n                # So, `X * map_to_int(factors[v]) = (g * l) / (X * map_to_int(factors[u]))`.\n                # `X^2 * map_to_int(factors[u]) * map_to_int(factors[v]) = g * l`.\n                #\n                # This implies `(map_to_int(factors[u]) * map_to_int(factors[v]))` must be `(g*l) / X^2`.\n                # This is still the same issue. The `X^2` term is crucial.\n\n                # Let's try to fix `val[u]` to be `g` for the first node in a component.\n                # Then `val[v] = (g_uv * l_uv) // g`.\n                # This might not be a multiple of `g_uv`.\n                # Example: u=1, v=2. g=3, l=7. `val[1]=3`. `val[2] = (3*7)/3 = 7`.\n                # This works. `GCD(3,7)=1`, `LCM(3,7)=21`. But the input says `GCD=3, LCM=7`. This is invalid.\n                # If `g=3, l=21`, then `val[1]=3`, `val[2]=(3*21)/3=21`. This works.\n\n                # The problem states `GCD, LCM` are up to 10^6.\n                # The values `val[i]` are up to 10^6.\n                #\n                # Let's use the `factors` array to store `val[u]`.\n                # When we start a DFS from `u`, we need to assign a valid `val[u]`.\n                # What is the minimum possible value for `val[u]`? It must be a multiple of `g` for all adjacent `g`.\n                # And `val[u]` must be a divisor of `l` for all adjacent `l`.\n                # This means `val[u]` must be a multiple of `LCM_of_all_g_connected_to_u`.\n                # And `val[u]` must be a divisor of `GCD_of_all_l_connected_to_u`.\n                # This is too complex.\n\n                # The trick for this problem is to use `val[u] = G_u * x_u` and `val[v] = G_v * x_v`.\n                # `G_u` is the GCD of all numbers in the component. This is not practical.\n\n                # Back to `val[u] = X * k_u` where `k_u` is a rational number.\n                # `k_u` stores `(numerator_factors, denominator_factors)`.\n                # For `r` (root), `k_r = (empty_map, empty_map)`.\n                # When traversing `u` to `v` with `g_uv, l_uv`:\n                # `val[v] = (g_uv * l_uv) / val[u]`\n                # `X * k_v = (g_uv * l_uv) / (X * k_u)`\n                # `k_v = (g_uv * l_uv) / (X^2 * k_u)`\n                # This means `k_v` depends on `X^2`. This is the core difficulty.\n\n                # What if we assign `val[u]` as `X`?\n                # Then `val[v] = (g * l) / X`.\n                # Then `val[w] = (g' * l') / val[v] = (g' * l') / ((g * l) / X) = (g' * l' * X) / (g * l)`.\n                # So every node `i` will have `val[i] = A_i * X` or `B_i / X`.\n                # That is, `val[i] = (N_i / D_i) * X` if `i` is an even distance from root (like `w`),\n                # or `val[i] = (N_i / D_i) / X` if `i` is an odd distance from root (like `v`).\n                #\n                # Let's define `factors[i]` as the prime factorization of `val[i] / X` if `i` is even distance from root,\n                # or `val[i] * X` if `i` is odd distance from root.\n                #\n                # This is the \"parity\" approach.\n                # Let `val[u] = X * ratio_u` if `u` is at even depth from root.\n                # Let `val[u] = X / ratio_u` if `u` is at odd depth from root.\n                # `ratio_u` is a fixed rational number (prime factor map).\n                #\n                # Start DFS from root `r`. `depth[r] = 0`. `factors[r] = {}` (representing 1).\n                # For an edge `(u, v)` with `g, l`:\n                # Case 1: `depth[u]` is even, `depth[v]` is odd.\n                # `val[u] = X * map_to_int(factors[u])`\n                # `val[v] = X / map_to_int(factors[v])`\n                # `val[u] * val[v] = g * l`\n                # `(X * map_to_int(factors[u])) * (X / map_to_int(factors[v])) = g * l`\n                # `X^2 * (map_to_int(factors[u]) / map_to_int(factors[v])) = g * l`\n                # `map_to_int(factors[v]) = X^2 * map_to_int(factors[u]) / (g * l)`. Still depends on X.\n\n                # The actual solution involves `val[i]` being `X * k_i` or `k_i / X`.\n                # Let `k_i` be a rational number.\n                # `factors[i]` stores the prime factorization of `k_i`.\n                # `parity[i]` stores 0 if `val[i] = X * k_i`, 1 if `val[i] = k_i / X`.\n                #\n                # Initialize `parity[r] = 0`, `factors[r] = {}`.\n                # For edge `(u, v)` with `g, l`:\n                # If `parity[u] = 0` (`val[u] = X * k_u`):\n                #   If `parity[v] = 0` (`val[v] = X * k_v`):\n                #     `X * k_u * X * k_v = g * l` => `X^2 * k_u * k_v = g * l`.\n                #     This implies `k_v = (g * l) / (X^2 * k_u)`. This is the problem.\n                #   If `parity[v] = 1` (`val[v] = k_v / X`):\n                #     `X * k_u * k_v / X = g * l` => `k_u * k_v = g * l`.\n                #     This implies `k_v = (g * l) / k_u`. This is solvable!\n                #     We can set `parity[v] = 1` and `factors[v] = factors(g*l) - factors[u]`.\n                #\n                # If `parity[u] = 1` (`val[u] = k_u / X`):\n                #   If `parity[v] = 0` (`val[v] = X * k_v`):\n                #     `k_u / X * X * k_v = g * l` => `k_u * k_v = g * l`.\n                #     This implies `k_v = (g * l) / k_u`.\n                #     We can set `parity[v] = 0` and `factors[v] = factors(g*l) - factors[u]`.\n                #   If `parity[v] = 1` (`val[v] = k_v / X`):\n                #     `k_u / X * k_v / X = g * l` => `k_u * k_v / X^2 = g * l`.\n                #     This implies `k_v = (g * l * X^2) / k_u`. Problematic again.\n\n                # This means we must alternate parities along edges.\n                # This is a bipartite graph coloring problem.\n                # Let `color[u]` be the parity (0 or 1).\n                # `val[u] = X * map_to_int(factors[u])` if `color[u] = 0`.\n                # `val[u] = map_to_int(factors[u]) / X` if `color[u] = 1`.\n                #\n                # For an edge `(u, v)` with `g, l`:\n                # `color[u]` and `color[v]` must be different. If they are the same, it's impossible.\n                # If `color[u] = 0`, `color[v] = 1`:\n                #   `val[u] * val[v] = (X * map_to_int(factors[u])) * (map_to_int(factors[v]) / X) = map_to_int(factors[u]) * map_to_int(factors[v])`.\n                #   So, `map_to_int(factors[u]) * map_to_int(factors[v]) = g * l`.\n                #   `factors[v] = factors(g*l) - factors[u]`. (Division of factor maps).\n                # If `color[u] = 1`, `color[v] = 0`:\n                #   `val[u] * val[v] = (map_to_int(factors[u]) / X) * (X * map_to_int(factors[v])) = map_to_int(factors[u]) * map_to_int(factors[v])`.\n                #   So, `map_to_int(factors[u]) * map_to_int(factors[v]) = g * l`.\n                #   `factors[v] = factors(g*l) - factors[u]`.\n                # This works!\n\n                # Algorithm:\n                # 1. For each connected component:\n                #    a. Pick a root `r`. Set `color[r] = 0`, `factors[r] = {}`.\n                #    b. Perform BFS/DFS. For each edge `(u, v)`:\n                #       i. If `v` is unvisited:\n                #          Set `color[v] = 1 - color[u]`.\n                #          `factors[v] = factors(g*l) - factors[u]`.\n                #          Add `v` to queue/stack.\n                #       ii. If `v` is visited:\n                #           Check consistency:\n                #           `color[v]` must be `1 - color[u]`. If not, graph is not bipartite, return \"NO\".\n                #           `map_to_int(factors[u]) * map_to_int(factors[v])` must be `g * l`.\n                #           Check this using factor maps: `factors[u] + factors[v]` must be `factors(g*l)`. If not, return \"NO\".\n                # 2. After processing all components, we have `color[i]` and `factors[i]` for all `i`.\n                #    We need to find `X`.\n                #    For each node `i`:\n                #    If `color[i] = 0`: `val[i] = X * map_to_int(factors[i])`.\n                #    If `color[i] = 1`: `val[i] = map_to_int(factors[i]) / X`.\n                #\n                #    Constraints:\n                #    a. `val[i]` must be an integer.\n                #       If `color[i] = 0`, `X * map_to_int(factors[i])` must be integer.\n                #       If `color[i] = 1`, `map_to_int(factors[i]) / X` must be integer.\n                #       This means `X` must be a multiple of `denominator(factors[i])` for `color[i]=0` nodes.\n                #       And `X` must be a divisor of `numerator(factors[i])` for `color[i]=1` nodes.\n                #       So, `X` must be a multiple of `LCM` of all denominators for `color=0` nodes.\n                #       And `X` must be a divisor of `GCD` of all numerators for `color=1` nodes.\n                #       Let `L_X = LCM_of_all_denominators_of_factors[i]_where_color[i]=0`.\n                #       Let `G_X = GCD_of_all_numerators_of_factors[i]_where_color[i]=1`.\n                #       So `X` must be a multiple of `L_X` and a divisor of `G_X`.\n                #       If `L_X > G_X`, no such `X` exists.\n                #    b. `val[i]` must be between 1 and 10^6.\n                #    c. `val[i]` must be a multiple of `g` for all adjacent edges.\n                #       `val[i]` must be a divisor of `l` for all adjacent edges.\n                #\n                #    To find `X`:\n                #    We need to find an `X` that satisfies:\n                #    `X` is a multiple of `L_X_int`.\n                #    `X` is a divisor of `G_X_int`.\n                #    `1 <= val[i] <= 10^6` for all `i`.\n                #\n                #    The smallest possible `X` is `L_X_int`. Let's try `X = L_X_int`.\n                #    If `L_X_int` is 0 (all `factors[i]` are integers), then `X` can be 1.\n                #    So, `X_candidate = max(1, L_X_int)`.\n                #    Check if `X_candidate` divides `G_X_int`. If not, no solution.\n                #    If `X_candidate` is 0, it should be 1.\n                #    If `L_X_int` is 0 (all `factors[i]` are integers), then `L_X_int` is effectively 1.\n                #    So, `X_candidate = 1`.\n                #    Then check all `val[i]`.\n                #    If `color[i]=0`, `ans[i] = X_candidate * map_to_int(factors[i])`.\n                #    If `color[i]=1`, `ans[i] = map_to_int(factors[i]) // X_candidate`.\n                #\n                #    After computing `ans[i]`, we need to verify all constraints.\n                #    1. `1 <= ans[i] <= 10^6`.\n                #    2. For each edge `(u, v, g, l)`:\n                #       `GCD(ans[u], ans[v]) == g` and `LCM(ans[u], ans[v]) == l`.\n                #       The `GCD(a,b)*LCM(a,b) = a*b` property means we only need to check one.\n                #       If `ans[u] * ans[v] == g * l`, then `GCD` and `LCM` will be consistent.\n                #       We also need to check `ans[u] % g == 0` and `ans[v] % g == 0`.\n                #       And `g` must divide `ans[u]` and `ans[v]`.\n                #       And `ans[u]` and `ans[v]` must divide `l`.\n\n    # Global variables for DFS\n    colors = [ -1 ] * (n + 1) # -1: unvisited, 0: color 0, 1: color 1\n    factors_map = [None] * (n + 1) # Stores prime factorization of k_i\n    \n    # Stores the overall LCM of denominators for color 0 nodes, and GCD of numerators for color 1 nodes\n    global_lcm_denom_map = {}\n    global_gcd_num_map = {}\n\n    possible = True\n\n    for i in range(1, n + 1):\n        if not visited[i]: # Start a new component\n            q = [(i, 0, {})] # (node, color, relative_factor_map)\n            visited[i] = True\n            colors[i] = 0\n            factors_map[i] = {} # Represents 1\n            \n            head = 0\n            while head < len(q):\n                u, u_color, u_factor_map = q[head]\n                head += 1\n\n                # Update global_lcm_denom_map and global_gcd_num_map\n                for p, exp in u_factor_map.items():\n                    if u_color == 0: # val[u] = X * k_u => X must be a multiple of denominator(k_u)\n                        if exp < 0: # Denominator part\n                            global_lcm_denom_map[p] = max(global_lcm_denom_map.get(p, 0), -exp)\n                    else: # val[u] = k_u / X => X must be a divisor of numerator(k_u)\n                        if exp > 0: # Numerator part\n                            if p not in global_gcd_num_map:\n                                global_gcd_num_map[p] = exp\n                            else:\n                                global_gcd_num_map[p] = min(global_gcd_num_map[p], exp)\n                        else: # Denominator part: k_u/X means val[u] = Num / (Den * X). X must not introduce a factor that's not already in Num.\n                              # This is handled by requiring X to be a divisor of the common GCD of numerators.\n                              # If there is a denominator, then X must not have this factor.\n                              # This is implicitly handled by the final check of val[i] being integer.\n                              # If X has a factor p, and k_u has p in denominator, then val[u] = k_u/X will have p^-(exp+X_exp) in denominator.\n                              # This implies val[u] is not integer. So X must not have factors that are in denominator of k_u.\n                              # This is equivalent to saying X must be a divisor of numerator(k_u).\n\n                for v, g, l in adj[u]:\n                    v_color = 1 - u_color\n                    target_product_factors = get_prime_factors(g * l)\n                    \n                    if not visited[v]:\n                        visited[v] = True\n                        colors[v] = v_color\n                        # factors[u] * factors[v] = factors(g*l)\n                        # factors[v] = factors(g*l) - factors[u]\n                        \n                        # Check if factors[u] is divisible by target_product_factors? No, it's factors[u] * factors[v]\n                        # Need to check if target_product_factors is divisible by factors[u]\n                        \n                        temp_factors_v = divide_factor_maps(target_product_factors, u_factor_map)\n                        \n                        factors_map[v] = temp_factors_v\n                        q.append((v, v_color, temp_factors_v))\n                    else: # v is visited\n                        if colors[v] != v_color: # Not bipartite\n                            possible = False\n                            break\n                        \n                        # Check consistency of factors\n                        # factors[u] + factors[v] must be equal to factors(g*l)\n                        combined_factors = multiply_factor_maps(u_factor_map, factors_map[v])\n                        \n                        if combined_factors != target_product_factors:\n                            possible = False\n                            break\n                if not possible:\n                    break\n            if not possible:\n                break\n\n    if not possible:\n        print(\"NO\")\n        return\n    \n    # Determine X\n    # X must be a multiple of map_to_int(global_lcm_denom_map)\n    # X must be a divisor of map_to_int(global_gcd_num_map)\n    \n    # Calculate L_X_int\n    L_X_int = 1\n    for p, exp in global_lcm_denom_map.items():\n        L_X_int *= (p ** exp)\n        if L_X_int > 10**6: # X cannot exceed 10^6\n             print(\"NO\")\n             return\n\n    # Calculate G_X_int\n    G_X_int = 1\n    first_gcd_num_map = True\n    for p, exp in global_gcd_num_map.items():\n        if first_gcd_num_map:\n            G_X_int = (p ** exp)\n            first_gcd_num_map = False\n        else:\n            G_X_int = gcd(G_X_int, (p ** exp))\n    \n    # If no color 1 nodes with positive exponents, G_X_int can be arbitrarily large.\n    # In that case, we should just use L_X_int as X.\n    if first_gcd_num_map: # No constraints on X from color 1 nodes' numerators\n        G_X_int = 10**6 + 1 # Effectively infinite upper bound for X.\n    \n    # Candidate for X\n    X = L_X_int\n    \n    # Check if X is a valid divisor for all color 1 numerators\n    if G_X_int % X != 0:\n        print(\"NO\")\n        return\n\n    # Final calculation of ans values\n    final_ans = [0] * (n + 1)\n    for i in range(1, n + 1):\n        num_part = 1\n        den_part = 1\n        for p, exp in factors_map[i].items():\n            if exp > 0:\n                num_part *= (p ** exp)\n            else:\n                den_part *= (p ** (-exp))\n        \n        if colors[i] == 0: # val[i] = X * k_i = X * (num_part / den_part)\n            if X % den_part != 0: # X must be a multiple of den_part\n                print(\"NO\")\n                return\n            final_ans[i] = (X // den_part) * num_part\n        else: # val[i] = k_i / X = (num_part / den_part) / X = num_part / (den_part * X)\n            if num_part % (den_part * X) != 0: # num_part must be a multiple of den_part * X\n                print(\"NO\")\n                return\n            final_ans[i] = num_part // (den_part * X)\n        \n        if not (1 <= final_ans[i] <= 10**6):\n            print(\"NO\")\n            return\n\n    # Final verification of all edge constraints\n    # This check is crucial because the relative factor method only ensures `val[u]*val[v] = g*l` and `val[i]` are integers in range.\n    # It does not guarantee `GCD(val[u], val[v]) == g` or `LCM(val[u], val[v]) == l`.\n    # However, if `a*b = g*l` and `a,b` are integers, then `GCD(a,b)*LCM(a,b) = a*b` is always true.\n    # So we only need to check `GCD(a,b) == g`.\n    # And `a%g == 0` and `b%g == 0`.\n    # And `l%a == 0` and `l%b == 0`.\n    # These are: `a` multiple of `g`, `b` multiple of `g`, `l` multiple of `a`, `l` multiple of `b`.\n    # These are equivalent to `g | a`, `g | b`, `a | l`, `b | l`.\n\n    for u, v, g, l in edges_data:\n        a = final_ans[u]\n        b = final_ans[v]\n\n        if a * b != g * l:\n            print(\"NO\")\n            return\n        \n        if a % g != 0 or b % g != 0:\n            print(\"NO\")\n            return\n        \n        # Check if actual GCD matches given g\n        if gcd(a, b) != g:\n            print(\"NO\")\n            return\n        \n        # LCM check is redundant if GCD and product are correct.\n        # if lcm(a, b) != l:\n        #     print(\"NO\")\n        #     return\n\n    print(\"YES\")\n    print(*(final_ans[1:]))\n\n\n# Helper GCD function\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\n# Helper LCM function\ndef lcm(a, b):\n    if a == 0 or b == 0:\n        return 0\n    return abs(a * b) // gcd(a, b)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    if n == 0:\n        print(\"NO\")\n        return\n\n    adj = [[] for _ in range(n + 1)]\n    edges_data = []\n\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        \n        # Initial check for GCD, LCM consistency\n        if l % g != 0:\n            print(\"NO\")\n            return\n        \n        # Check if LCM/GCD is too large for product\n        # max_val = 10^6. If g*l > max_val^2, then (g*l) / val[u] might exceed max_val\n        # However, the problem states mushroom counts are <= 10^6.\n        # This implies g <= 10^6, l <= 10^6.\n        # If val[u] = g*x and val[v] = g*y, then x*y = l/g.\n        # Max x or y can be l/g.\n        # If val[u] > 10^6 or val[v] > 10^6, it's invalid.\n        # This check is implicitly done later when checking final values.\n        \n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l))\n        edges_data.append((u, v, g, l))\n\n    # To store the assigned mushroom counts\n    ans = [0] * (n + 1)\n    # To store the relative factor 'k' for each connected component\n    # val[i] = k[i] * base_value_for_component\n    # More precisely, val[i] = k_i * X, where X is the base value chosen for some node in the component.\n    # The actual value stored in factors[i] will be k_i.\n    factors = [0] * (n + 1)\n    # To keep track of visited nodes\n    visited = [False] * (n + 1)\n\n    # Function to find prime factors for a number\n    # Returns a dictionary: {prime_factor: exponent}\n    def get_prime_factors(num):\n        factors_map = {}\n        d = 2\n        temp = num\n        while d * d <= temp:\n            while temp % d == 0:\n                factors_map[d] = factors_map.get(d, 0) + 1\n                temp //= d\n            d += 1\n        if temp > 1:\n            factors_map[temp] = factors_map.get(temp, 0) + 1\n        return factors_map\n\n    # Function to multiply two factor maps\n    def multiply_factor_maps(map1, map2):\n        result = map1.copy()\n        for p, exp in map2.items():\n            result[p] = result.get(p, 0) + exp\n        return result\n\n    # Function to divide two factor maps (map1 / map2)\n    # Assumes map1 is divisible by map2\n    def divide_factor_maps(map1, map2):\n        result = map1.copy()\n        for p, exp in map2.items():\n            result[p] -= exp\n            if result[p] == 0:\n                del result[p]\n        return result\n\n    # Function to check if map1 is divisible by map2\n    def is_divisible(map1, map2):\n        for p, exp in map2.items():\n            if p not in map1 or map1[p] < exp:\n                return False\n        return True\n\n    # Function to compute GCD of two numbers from their factor maps\n    def gcd_from_factors(map1, map2):\n        res_map = {}\n        for p, exp1 in map1.items():\n            if p in map2:\n                res_map[p] = min(exp1, map2[p])\n        return res_map\n\n    # Function to compute LCM of two numbers from their factor maps\n    def lcm_from_factors(map1, map2):\n        res_map = map1.copy()\n        for p, exp2 in map2.items():\n            res_map[p] = max(res_map.get(p, 0), exp2)\n        return res_map\n\n    # Function to convert factor map back to integer\n    def map_to_int(f_map):\n        num = 1\n        for p, exp in f_map.items():\n            num *= (p ** exp)\n        return num\n\n    # Depth-First Search to traverse connected components\n    def dfs(u, current_factor_map):\n        visited[u] = True\n        factors[u] = current_factor_map\n\n        for v, g, l in adj[u]:\n            if not visited[v]:\n                # We have val[u] = k_u * X and val[v] = k_v * X\n                # We know k_u and need to find k_v.\n                # val[u] * val[v] = g * l\n                # (k_u * X) * (k_v * X) = g * l\n                # X^2 * k_u * k_v = g * l\n                # This approach of relative factors k_i and a base X is tricky because X is squared.\n\n                # Let's use a simpler approach for DFS:\n                # Assign an arbitrary value (e.g., 1) to the first node in a component.\n                # This is not good because it might not be a multiple of g.\n                # The problem statement says any valid assignment.\n                # A better approach: assign val[u] = g for the first node, and then propagate.\n                # This is also not good, because val[u] must be g * x, where x is some factor of l/g.\n\n                # Correct approach:\n                # For an edge (u, v) with GCD=g, LCM=l:\n                # val[u] = g * x_u\n                # val[v] = g * x_v\n                # x_u * x_v = l / g\n                # GCD(x_u, x_v) = 1\n                #\n                # If we know val[u], then val[v] = (g * l) // val[u].\n                # We need to ensure val[v] is an integer, a multiple of g, and in range [1, 10^6].\n                #\n                # Let's fix the first node `u` in a component. We need to assign `val[u]`.\n                # What is the \"best\" `val[u]` to start with?\n                # The smallest possible value for any node `x` is `g_x` where `g_x` is the GCD of all numbers connected to `x`.\n                #\n                # Instead, let's use the factors[u] to store the *actual* value of val[u].\n                # When we start DFS from u, we don't know val[u] yet.\n                # We can't pick an arbitrary value for val[u] and hope it works for the whole component.\n                #\n                # The original idea of factors[i] storing the relative factor (val[i] / val[start_node]) is good.\n                # Let's say factors[u] = k_u. Then val[u] = k_u * X.\n                # val[v] = k_v * X.\n                # From val[u] * val[v] = g * l, we have k_u * X * k_v * X = g * l.\n                # X^2 * k_u * k_v = g * l.\n                # This means we need to find X such that X^2 divides g*l. This is still complicated.\n\n                # Let's rethink the relative factors.\n                # For each connected component, we pick a root node `r`.\n                # We assign `val[r] = X`.\n                # For any other node `u`, we try to express `val[u]` as `k_u * X` or `X / k_u`.\n                # The constraint `GCD(a,b)*LCM(a,b) = a*b` means `val[u] * val[v] = g * l`.\n                #\n                # Let `u` be the current node, and `val[u]` is determined.\n                # For an edge `(u, v)` with `g, l`:\n                # `val[v] = (g * l) // val[u]`.\n                # This must be an integer. It must be a multiple of `g`.\n                # `val[u]` must be a multiple of `g`.\n                #\n                # This is the standard approach for solving systems of equations.\n                # Let `val[u] = a_u`.\n                # Pick an arbitrary node `s`. Let `a_s = X`.\n                # For any neighbor `t` of `s` with `g_st, l_st`: `a_t = (g_st * l_st) / X`.\n                # For any neighbor `w` of `t` with `g_tw, l_tw`: `a_w = (g_tw * l_tw) / a_t = (g_tw * l_tw) / ((g_st * l_st) / X) = (g_tw * l_tw * X) / (g_st * l_st)`.\n                #\n                # So, for any node `u` in a component, `a_u` will be of the form `C_u * X` or `X / C_u`.\n                # More generally, `a_u = (Num_u / Den_u) * X`.\n                # We want to find `X` such that all `a_u` are integers, multiples of their respective `g`'s, and within `[1, 10^6]`.\n                #\n                # Let `ratio[u]` be `val[u] / val[root]`.\n                # For an edge `(u, v)` with `g, l`:\n                # `val[u] = ratio[u] * val[root]`\n                # `val[v] = ratio[v] * val[root]`\n                # `(ratio[u] * val[root]) * (ratio[v] * val[root]) = g * l`\n                # `ratio[u] * ratio[v] * (val[root])^2 = g * l`\n                # `ratio[v] = (g * l) / (ratio[u] * (val[root])^2)`\n                # This implies `ratio[v]` depends on `val[root]`, which means `ratio` cannot be fixed beforehand.\n\n                # Let's use the `val[u] = X * k_u` idea from the editorial.\n                # `k_u` stores the prime factorization of `val[u] / X`.\n                # When traversing from `u` to `v`:\n                # `val[u] * val[v] = g * l`\n                # `val[v] = (g * l) / val[u]`\n                # `val[v] = (g * l) / (X * k_u)`\n                # `val[v] = X * k_v`\n                # So `k_v = (g * l) / (X^2 * k_u)`. This is still problematic because of X^2.\n\n                # The \"correct\" relative factor approach:\n                # Fix `val[u]` to `X`. All other `val[v]` will be `X * (some_ratio)`.\n                # Let `factors[u]` store the prime factorization of `val[u]`.\n                # For a root `r` of a component, we don't know `val[r]`.\n                # For any other node `u`, `val[u]` can be written as `(A_u / B_u) * val[r]`.\n                # Let `factors[u]` store the prime factorization of `A_u / B_u`.\n                # So `val[u] = val[r] * map_to_int(factors[u])`.\n                #\n                # When traversing `u` -> `v` with `g, l`:\n                # `val[u]` is known (as `val[r] * map_to_int(factors[u])`).\n                # `val[v]` should be `(g * l) / val[u]`.\n                # So `val[v] = (g * l) / (val[r] * map_to_int(factors[u]))`.\n                # We also want `val[v] = val[r] * map_to_int(factors[v])`.\n                # Equating these:\n                # `val[r] * map_to_int(factors[v]) = (g * l) / (val[r] * map_to_int(factors[u]))`\n                # `(val[r])^2 * map_to_int(factors[v]) * map_to_int(factors[u]) = g * l`\n                # `map_to_int(factors[v]) = (g * l) / ((val[r])^2 * map_to_int(factors[u]))`\n                # This still depends on `val[r]`.\n\n                # The actual editorial approach for relative factors:\n                # For each component, pick a root `r`.\n                # We want to find `val[r]`.\n                # For any node `u` in the component, `val[u]` can be written as `X_u * val[r]` where `X_u` is a fixed rational number.\n                # Or, more simply, `val[u] = val[r] * k_u`, where `k_u` is a rational number.\n                # `k_r = 1`.\n                # For an edge `(u, v)` with `g, l`:\n                # `val[u] * val[v] = g * l`\n                # `(k_u * val[r]) * (k_v * val[r]) = g * l`\n                # `k_u * k_v * (val[r])^2 = g * l`\n                # `k_v = (g * l) / (k_u * (val[r])^2)`\n                # This is still the same issue.\n\n                # The problem statement implies `val[u]` and `val[v]` are integers.\n                # `val[u] = g * x`, `val[v] = g * y`, where `x * y = l / g` and `GCD(x, y) = 1`.\n                #\n                # The key insight for relative factors:\n                # Let `P_u` be the set of prime factors of `val[u]`.\n                # Let `P_v` be the set of prime factors of `val[v]`.\n                #\n                # For an edge `(u, v)` with `g, l`:\n                # `val[u] = g * x`\n                # `val[v] = g * y`\n                # `x * y = l / g`\n                # `GCD(x, y) = 1`\n                #\n                # This means `x` and `y` are coprime.\n                # All prime factors of `l/g` are split between `x` and `y`.\n                #\n                # Let `current_val_map[u]` store the prime factorization of `val[u]`.\n                # When we start DFS from `u` for a new component, we don't know `val[u]`.\n                # We can express `val[u]` as `base_val * some_factor_map`.\n                #\n                # Let's try the approach from a similar problem:\n                # `val[u]` is assigned a value `X`.\n                # `val[v]` is then `(g*l)/X`.\n                # `val[w]` is then `(g'*l')/((g*l)/X) = (g'*l'*X)/(g*l)`.\n                # So every `val[k]` will be of the form `N_k * X` or `X / D_k`.\n                # We can represent `val[k]` as `(N_k / D_k) * X`.\n                # Let `factors[k]` store the prime factorization of `N_k / D_k`.\n                # `factors[k]` is a map `{prime: exponent}` where positive exponent means in numerator, negative in denominator.\n                # For the root `r`, `factors[r]` is an empty map (representing 1).\n                #\n                # When traversing `u` -> `v` with `g, l`:\n                # We know `factors[u]`. We want to find `factors[v]`.\n                # `val[u] = X * map_to_int(factors[u])`\n                # `val[v] = X * map_to_int(factors[v])`\n                # `val[u] * val[v] = g * l`\n                # `X^2 * map_to_int(factors[u]) * map_to_int(factors[v]) = g * l`\n                # `map_to_int(factors[v]) = (g * l) / (X^2 * map_to_int(factors[u]))`\n                # This still depends on X. The problem is that X is squared.\n\n                # The key is that val[u] and val[v] are integers.\n                # Let `val[u] = k_u * X` and `val[v] = k_v * X` where `k_u` and `k_v` are integers.\n                # This is only possible if `X` is `GCD(val[u], val[v])`.\n                # This implies `X` must be `g`.\n                # So if we set `val[root] = g_root * x_root`, then `val[u] = g_u * x_u`.\n                #\n                # Let `val[u] = C_u * K` where `K` is some unknown.\n                # `C_u` is a product of prime powers.\n                # For `r` (root of component), `C_r = 1`.\n                # `val[r] = K`.\n                # For edge `(u, v)` with `g, l`:\n                # `val[u] = C_u * K`\n                # `val[v] = C_v * K`\n                # `C_u * K * C_v * K = g * l`\n                # `C_u * C_v * K^2 = g * l`\n                # `C_v = (g * l) / (C_u * K^2)`. This implies `C_v` depends on `K`.\n\n                # The actual \"relative factor\" approach that works:\n                # `val[u]` and `val[v]` must be integers.\n                # Let `val[u] = X * k_u` where `k_u` is a rational number.\n                # `k_u` is stored as a prime factorization map `factors[u]`.\n                # `factors[u]` stores `factors(numerator) - factors(denominator)`.\n                # For the root `r` of a component, `factors[r]` is an empty map (representing 1).\n                #\n                # For an edge `(u, v)` with `g, l`:\n                # We have `val[u] = X * map_to_int(factors[u])`.\n                # We need to find `val[v]`.\n                # `val[v] = (g * l) / val[u] = (g * l) / (X * map_to_int(factors[u]))`.\n                # We also need `val[v] = X * map_to_int(factors[v])`.\n                # So, `X * map_to_int(factors[v]) = (g * l) / (X * map_to_int(factors[u]))`.\n                # `X^2 * map_to_int(factors[u]) * map_to_int(factors[v]) = g * l`.\n                #\n                # This implies `(map_to_int(factors[u]) * map_to_int(factors[v]))` must be `(g*l) / X^2`.\n                # This is still the same issue. The `X^2` term is crucial.\n\n                # Let's try to fix `val[u]` to be `g` for the first node in a component.\n                # Then `val[v] = (g_uv * l_uv) // g`.\n                # This might not be a multiple of `g_uv`.\n                # Example: u=1, v=2. g=3, l=7. `val[1]=3`. `val[2] = (3*7)/3 = 7`.\n                # This works. `GCD(3,7)=1`, `LCM(3,7)=21`. But the input says `GCD=3, LCM=7`. This is invalid.\n                # If `g=3, l=21`, then `val[1]=3`, `val[2]=(3*21)/3=21`. This works.\n\n                # The problem states `GCD, LCM` are up to 10^6.\n                # The values `val[i]` are up to 10^6.\n                #\n                # Let's use the `factors` array to store `val[u]`.\n                # When we start a DFS from `u`, we need to assign a valid `val[u]`.\n                # What is the minimum possible value for `val[u]`? It must be a multiple of `g` for all adjacent `g`.\n                # And `val[u]` must be a divisor of `l` for all adjacent `l`.\n                # This means `val[u]` must be a multiple of `LCM_of_all_g_connected_to_u`.\n                # And `val[u]` must be a divisor of `GCD_of_all_l_connected_to_u`.\n                # This is too complex.\n\n                # The trick for this problem is to use `val[u] = G_u * x_u` and `val[v] = G_v * x_v`.\n                # `G_u` is the GCD of all numbers in the component. This is not practical.\n\n                # Back to `val[u] = X * k_u` where `k_u` is a rational number.\n                # `k_u` stores `(numerator_factors, denominator_factors)`.\n                # For `r` (root), `k_r = (empty_map, empty_map)`.\n                # When traversing `u` to `v` with `g_uv, l_uv`:\n                # `val[v] = (g_uv * l_uv) / val[u]`\n                # `X * k_v = (g_uv * l_uv) / (X * k_u)`\n                # `k_v = (g_uv * l_uv) / (X^2 * k_u)`\n                # This means `k_v` depends on `X^2`. This is the core difficulty.\n\n                # What if we assign `val[u]` as `X`?\n                # Then `val[v] = (g * l) / X`.\n                # Then `val[w] = (g' * l') / val[v] = (g' * l') / ((g * l) / X) = (g' * l' * X) / (g * l)`.\n                # So every node `i` will have `val[i] = A_i * X` or `B_i / X`.\n                # That is, `val[i] = (N_i / D_i) * X` if `i` is an even distance from root (like `w`),\n                # or `val[i] = (N_i / D_i) / X` if `i` is an odd distance from root (like `v`).\n                #\n                # Let's define `factors[i]` as the prime factorization of `val[i] / X` if `i` is even distance from root,\n                # or `val[i] * X` if `i` is odd distance from root.\n                #\n                # This is the \"parity\" approach.\n                # Let `val[u] = X * ratio_u` if `u` is at even depth from root.\n                # Let `val[u] = X / ratio_u` if `u` is at odd depth from root.\n                # `ratio_u` is a fixed rational number (prime factor map).\n                #\n                # Start DFS from root `r`. `depth[r] = 0`. `factors[r] = {}` (representing 1).\n                # For an edge `(u, v)` with `g, l`:\n                # Case 1: `depth[u]` is even, `depth[v]` is odd.\n                # `val[u] = X * map_to_int(factors[u])`\n                # `val[v] = X / map_to_int(factors[v])`\n                # `val[u] * val[v] = g * l`\n                # `(X * map_to_int(factors[u])) * (X / map_to_int(factors[v])) = g * l`\n                # `X^2 * (map_to_int(factors[u]) / map_to_int(factors[v])) = g * l`\n                # `map_to_int(factors[v]) = X^2 * map_to_int(factors[u]) / (g * l)`. Still depends on X.\n\n                # The actual solution involves `val[i]` being `X * k_i` or `k_i / X`.\n                # Let `k_i` be a rational number.\n                # `factors[i]` stores the prime factorization of `k_i`.\n                # `parity[i]` stores 0 if `val[i] = X * k_i`, 1 if `val[i] = k_i / X`.\n                #\n                # Initialize `parity[r] = 0`, `factors[r] = {}`.\n                # For edge `(u, v)` with `g, l`:\n                # If `parity[u] = 0` (`val[u] = X * k_u`):\n                #   If `parity[v] = 0` (`val[v] = X * k_v`):\n                #     `X * k_u * X * k_v = g * l` => `X^2 * k_u * k_v = g * l`.\n                #     This implies `k_v = (g * l) / (X^2 * k_u)`. This is the problem.\n                #   If `parity[v] = 1` (`val[v] = k_v / X`):\n                #     `X * k_u * k_v / X = g * l` => `k_u * k_v = g * l`.\n                #     This implies `k_v = (g * l) / k_u`. This is solvable!\n                #     We can set `parity[v] = 1` and `factors[v] = factors(g*l) - factors[u]`.\n                #\n                # If `parity[u] = 1` (`val[u] = k_u / X`):\n                #   If `parity[v] = 0` (`val[v] = X * k_v`):\n                #     `k_u / X * X * k_v = g * l` => `k_u * k_v = g * l`.\n                #     This implies `k_v = (g * l) / k_u`.\n                #     We can set `parity[v] = 0` and `factors[v] = factors(g*l) - factors[u]`.\n                #   If `parity[v] = 1` (`val[v] = k_v / X`):\n                #     `k_u / X * k_v / X = g * l` => `k_u * k_v / X^2 = g * l`.\n                #     This implies `k_v = (g * l * X^2) / k_u`. Problematic again.\n\n                # This means we must alternate parities along edges.\n                # This is a bipartite graph coloring problem.\n                # Let `color[u]` be the parity (0 or 1).\n                # `val[u] = X * map_to_int(factors[u])` if `color[u] = 0`.\n                # `val[u] = map_to_int(factors[u]) / X` if `color[u] = 1`.\n                #\n                # For an edge `(u, v)` with `g, l`:\n                # `color[u]` and `color[v]` must be different. If they are the same, it's impossible.\n                # If `color[u] = 0`, `color[v] = 1`:\n                #   `val[u] * val[v] = (X * map_to_int(factors[u])) * (map_to_int(factors[v]) / X) = map_to_int(factors[u]) * map_to_int(factors[v])`.\n                #   So, `map_to_int(factors[u]) * map_to_int(factors[v]) = g * l`.\n                #   `factors[v] = factors(g*l) - factors[u]`. (Division of factor maps).\n                # If `color[u] = 1`, `color[v] = 0`:\n                #   `val[u] * val[v] = (map_to_int(factors[u]) / X) * (X * map_to_int(factors[v])) = map_to_int(factors[u]) * map_to_int(factors[v])`.\n                #   So, `map_to_int(factors[u]) * map_to_int(factors[v]) = g * l`.\n                #   `factors[v] = factors(g*l) - factors[u]`.\n                # This works!\n\n                # Algorithm:\n                # 1. For each connected component:\n                #    a. Pick a root `r`. Set `color[r] = 0`, `factors[r] = {}`.\n                #    b. Perform BFS/DFS. For each edge `(u, v)`:\n                #       i. If `v` is unvisited:\n                #          Set `color[v] = 1 - color[u]`.\n                #          `factors[v] = factors(g*l) - factors[u]`.\n                #          Add `v` to queue/stack.\n                #       ii. If `v` is visited:\n                #           Check consistency:\n                #           `color[v]` must be `1 - color[u]`. If not, graph is not bipartite, return \"NO\".\n                #           `map_to_int(factors[u]) * map_to_int(factors[v])` must be `g * l`.\n                #           Check this using factor maps: `factors[u] + factors[v]` must be `factors(g*l)`. If not, return \"NO\".\n                # 2. After processing all components, we have `color[i]` and `factors[i]` for all `i`.\n                #    We need to find `X`.\n                #    For each node `i`:\n                #    If `color[i] = 0`: `val[i] = X * map_to_int(factors[i])`.\n                #    If `color[i] = 1`: `val[i] = map_to_int(factors[i]) / X`.\n                #\n                #    Constraints:\n                #    a. `val[i]` must be an integer.\n                #       If `color[i] = 0`, `X * map_to_int(factors[i])` must be integer.\n                #       If `color[i] = 1`, `map_to_int(factors[i]) / X` must be integer.\n                #       This means `X` must be a multiple of `denominator(factors[i])` for `color[i]=0` nodes.\n                #       And `X` must be a divisor of `numerator(factors[i])` for `color[i]=1` nodes.\n                #       So, `X` must be a multiple of `LCM` of all denominators for `color=0` nodes.\n                #       And `X` must be a divisor of `GCD` of all numerators for `color=1` nodes.\n                #       Let `L_X = LCM_of_all_denominators_of_factors[i]_where_color[i]=0`.\n                #       Let `G_X = GCD_of_all_numerators_of_factors[i]_where_color[i]=1`.\n                #       So `X` must be a multiple of `L_X` and a divisor of `G_X`.\n                #       If `L_X > G_X`, no such `X` exists.\n                #    b. `val[i]` must be between 1 and 10^6.\n                #    c. `val[i]` must be a multiple of `g` for all adjacent edges.\n                #       `val[i]` must be a divisor of `l` for all adjacent edges.\n                #\n                #    To find `X`:\n                #    We need to find an `X` that satisfies:\n                #    `X` is a multiple of `L_X_int`.\n                #    `X` is a divisor of `G_X_int`.\n                #    `1 <= val[i] <= 10^6` for all `i`.\n                #\n                #    The smallest possible `X` is `L_X_int`. Let's try `X = L_X_int`.\n                #    If `L_X_int` is 0 (all `factors[i]` are integers), then `X` can be 1.\n                #    So, `X_candidate = max(1, L_X_int)`.\n                #    Check if `X_candidate` divides `G_X_int`. If not, no solution.\n                #    If `X_candidate` is 0, it should be 1.\n                #    If `L_X_int` is 0 (all `factors[i]` are integers), then `L_X_int` is effectively 1.\n                #    So, `X_candidate = 1`.\n                #    Then check all `val[i]`.\n                #    If `color[i]=0`, `ans[i] = X_candidate * map_to_int(factors[i])`.\n                #    If `color[i]=1`, `ans[i] = map_to_int(factors[i]) // X_candidate`.\n                #\n                #    After computing `ans[i]`, we need to verify all constraints.\n                #    1. `1 <= ans[i] <= 10^6`.\n                #    2. For each edge `(u, v, g, l)`:\n                #       `GCD(ans[u], ans[v]) == g` and `LCM(ans[u], ans[v]) == l`.\n                #       The `GCD(a,b)*LCM(a,b) = a*b` property means we only need to check one.\n                #       If `ans[u] * ans[v] == g * l`, then `GCD` and `LCM` will be consistent.\n                #       We also need to check `ans[u] % g == 0` and `ans[v] % g == 0`.\n                #       And `g` must divide `ans[u]` and `ans[v]`.\n                #       And `ans[u]` and `ans[v]` must divide `l`.\n\n    # Global variables for DFS\n    colors = [ -1 ] * (n + 1) # -1: unvisited, 0: color 0, 1: color 1\n    factors_map = [None] * (n + 1) # Stores prime factorization of k_i\n    \n    # Stores the overall LCM of denominators for color 0 nodes, and GCD of numerators for color 1 nodes\n    global_lcm_denom_map = {}\n    global_gcd_num_map = {}\n\n    possible = True\n\n    for i in range(1, n + 1):\n        if not visited[i]: # Start a new component\n            q = [(i, 0, {})] # (node, color, relative_factor_map)\n            visited[i] = True\n            colors[i] = 0\n            factors_map[i] = {} # Represents 1\n            \n            head = 0\n            while head < len(q):\n                u, u_color, u_factor_map = q[head]\n                head += 1\n\n                # Update global_lcm_denom_map and global_gcd_num_map\n                for p, exp in u_factor_map.items():\n                    if u_color == 0: # val[u] = X * k_u => X must be a multiple of denominator(k_u)\n                        if exp < 0: # Denominator part\n                            global_lcm_denom_map[p] = max(global_lcm_denom_map.get(p, 0), -exp)\n                    else: # val[u] = k_u / X => X must be a divisor of numerator(k_u)\n                        if exp > 0: # Numerator part\n                            if p not in global_gcd_num_map:\n                                global_gcd_num_map[p] = exp\n                            else:\n                                global_gcd_num_map[p] = min(global_gcd_num_map[p], exp)\n                        else: # Denominator part: k_u/X means val[u] = Num / (Den * X). X must not introduce a factor that's not already in Num.\n                              # This is handled by requiring X to be a divisor of the common GCD of numerators.\n                              # If there is a denominator, then X must not have this factor.\n                              # This is implicitly handled by the final check of val[i] being integer.\n                              # If X has a factor p, and k_u has p in denominator, then val[u] = k_u/X will have p^-(exp+X_exp) in denominator.\n                              # This implies val[u] is not integer. So X must not have factors that are in denominator of k_u.\n                              # This is equivalent to saying X must be a divisor of numerator(k_u).\n\n                for v, g, l in adj[u]:\n                    v_color = 1 - u_color\n                    target_product_factors = get_prime_factors(g * l)\n                    \n                    if not visited[v]:\n                        visited[v] = True\n                        colors[v] = v_color\n                        # factors[u] * factors[v] = factors(g*l)\n                        # factors[v] = factors(g*l) - factors[u]\n                        \n                        # Check if factors[u] is divisible by target_product_factors? No, it's factors[u] * factors[v]\n                        # Need to check if target_product_factors is divisible by factors[u]\n                        \n                        temp_factors_v = divide_factor_maps(target_product_factors, u_factor_map)\n                        \n                        factors_map[v] = temp_factors_v\n                        q.append((v, v_color, temp_factors_v))\n                    else: # v is visited\n                        if colors[v] != v_color: # Not bipartite\n                            possible = False\n                            break\n                        \n                        # Check consistency of factors\n                        # factors[u] + factors[v] must be equal to factors(g*l)\n                        combined_factors = multiply_factor_maps(u_factor_map, factors_map[v])\n                        \n                        if combined_factors != target_product_factors:\n                            possible = False\n                            break\n                if not possible:\n                    break\n            if not possible:\n                break\n\n    if not possible:\n        print(\"NO\")\n        return\n    \n    # Determine X\n    # X must be a multiple of map_to_int(global_lcm_denom_map)\n    # X must be a divisor of map_to_int(global_gcd_num_map)\n    \n    # Calculate L_X_int\n    L_X_int = 1\n    for p, exp in global_lcm_denom_map.items():\n        L_X_int *= (p ** exp)\n        if L_X_int > 10**6: # X cannot exceed 10^6\n             print(\"NO\")\n             return\n\n    # Calculate G_X_int\n    G_X_int = 1\n    first_gcd_num_map = True\n    for p, exp in global_gcd_num_map.items():\n        if first_gcd_num_map:\n            G_X_int = (p ** exp)\n            first_gcd_num_map = False\n        else:\n            G_X_int = gcd(G_X_int, (p ** exp))\n    \n    # If no color 1 nodes with positive exponents, G_X_int can be arbitrarily large.\n    # In that case, we should just use L_X_int as X.\n    if first_gcd_num_map: # No constraints on X from color 1 nodes' numerators\n        G_X_int = 10**6 + 1 # Effectively infinite upper bound for X.\n    \n    # Candidate for X\n    X = L_X_int\n    \n    # Check if X is a valid divisor for all color 1 numerators\n    if G_X_int % X != 0:\n        print(\"NO\")\n        return\n\n    # Final calculation of ans values\n    final_ans = [0] * (n + 1)\n    for i in range(1, n + 1):\n        num_part = 1\n        den_part = 1\n        for p, exp in factors_map[i].items():\n            if exp > 0:\n                num_part *= (p ** exp)\n            else:\n                den_part *= (p ** (-exp))\n        \n        if colors[i] == 0: # val[i] = X * k_i = X * (num_part / den_part)\n            if X % den_part != 0: # X must be a multiple of den_part\n                print(\"NO\")\n                return\n            final_ans[i] = (X // den_part) * num_part\n        else: # val[i] = k_i / X = (num_part / den_part) / X = num_part / (den_part * X)\n            if num_part % (den_part * X) != 0: # num_part must be a multiple of den_part * X\n                print(\"NO\")\n                return\n            final_ans[i] = num_part // (den_part * X)\n        \n        if not (1 <= final_ans[i] <= 10**6):\n            print(\"NO\")\n            return\n\n    # Final verification of all edge constraints\n    # This check is crucial because the relative factor method only ensures `val[u]*val[v] = g*l` and `val[i]` are integers in range.\n    # It does not guarantee `GCD(val[u], val[v]) == g` or `LCM(val[u], val[v]) == l`.\n    # However, if `a*b = g*l` and `a,b` are integers, then `GCD(a,b)*LCM(a,b) = a*b` is always true.\n    # So we only need to check `GCD(a,b) == g`.\n    # And `a%g == 0` and `b%g == 0`.\n    # And `l%a == 0` and `l%b == 0`.\n    # These are: `a` multiple of `g`, `b` multiple of `g`, `l` multiple of `a`, `l` multiple of `b`.\n    # These are equivalent to `g | a`, `g | b`, `a | l`, `b | l`.\n\n    for u, v, g, l in edges_data:\n        a = final_ans[u]\n        b = final_ans[v]\n\n        if a * b != g * l:\n            print(\"NO\")\n            return\n        \n        if a % g != 0 or b % g != 0:\n            print(\"NO\")\n            return\n        \n        # Check if actual GCD matches given g\n        if gcd(a, b) != g:\n            print(\"NO\")\n            return\n        \n        # LCM check is redundant if GCD and product are correct.\n        # if lcm(a, b) != l:\n        #     print(\"NO\")\n        #     return\n\n    print(\"YES\")\n    print(*(final_ans[1:]))\n\n\n# Helper GCD function\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\n# Helper LCM function\ndef lcm(a, b):\n    if a == 0 or b == 0:\n        return 0\n    return abs(a * b) // gcd(a, b)\n\nsolve()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 552,
        "completion_token_count": 10773,
        "thoughts_token_count": 719
    }
}