{
    "start": 1758009284.251543,
    "end": 1758009324.749373,
    "start-formatted": "2025-09-16 16:54 KST",
    "end-formatted": "2025-09-16 16:55 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "**Thinking Through a Competitive Programming Problem**\n\nOkay, so I've got this problem in front of me, and it's asking me to find the cheapest pair of disjoint vouchers that add up to a specific duration, `x`.  My first thought is always to understand the input and the constraints. We've got `n` vouchers, each with a start and end date (`li`, `ri`) and a cost (`costi`).  `n` and the date values are up to 2 * 10^5, so brute force is probably out of the question. I need to be thinking about something with a better time complexity.\n\nThe disjoint condition is a bit awkward. It means the vouchers can't overlap, so the end of one must be before the start of the other. Also, I need the total duration of the pair to exactly equal `x`. That means if I pick one voucher, the other's duration is fixed.\n\nSince I'm dealing with date ranges, my mind immediately jumps to considering data structures indexed by day. But I also know `li`, `ri`, and `x` are all in the same range, so maybe I can get away with some clever indexing. Let's see...\n\nIf I pick one voucher `i`, with duration `d_i`, then the other one `j` must have duration `x - d_i`.  I need to find the `j` that *minimizes* `costj` given `costi`. This means, for each voucher I look at, I need to efficiently find the cheapest valid matching voucher.\n\nThe key constraint is the disjoint condition.  `ri < lj` or `rj < li`. One voucher's end must be before the other voucher's start. Let's start by considering `ri < lj`.  If I fix voucher `i`, I'm looking for a `j` where `lj > ri`.  This condition plus `rj - lj + 1 = x - (ri - li + 1)` makes this non-trivial to optimize. The other case, `rj < li`, looks symmetric, so let's handle the first case and remember the symmetry.\n\nIf I iterate through the vouchers, picking one at a time as `i`, then for each `i`, I need to efficiently search for a good `j`.  I can't just check every other voucher, that would be `O(n^2)`.  Maybe I can sort something or use a data structure that helps me quickly find vouchers that meet these criteria.  I'm thinking about how to organize the vouchers based on start and end dates and their durations.  I need to efficiently look up vouchers that have a specific duration and start *after* the current voucher ends. I'm going to have to think through some data structure options.\n\nThe problem seems to be an optimal combination problem that will need an efficient lookup approach, but I'll have to see how to implement this lookup to make it work.\n",
    "response": "The problem asks us to find two disjoint vouchers `i` and `j` such that the sum of their durations is exactly `x`, and their total cost `costi + costj` is minimized. If no such pair exists, we should print -1.\n\nLet's denote a voucher as `(l, r, c)` with duration `d = r - l + 1`.\nWe are looking for two vouchers `(l1, r1, c1)` and `(l2, r2, c2)` such that:\n1.  They are disjoint: `r1 < l2` or `r2 < l1`.\n2.  Sum of durations: `(r1 - l1 + 1) + (r2 - l2 + 1) = x`.\n3.  Total cost `c1 + c2` is minimized.\n\nThe constraints are `n, x, li, ri <= 2 * 10^5`, `costi <= 10^9`. An `O(N^2)` approach is too slow. We need a more efficient solution, likely `O(N log N)` or `O(N)`.\n\nLet's fix one voucher `(l1, r1, c1)` with duration `d1 = r1 - l1 + 1`.\nWe need to find another voucher `(l2, r2, c2)` with duration `d2 = x - d1` such that `c2` is minimized, and they are disjoint.\n\nThe disjoint condition `r1 < l2` or `r2 < l1` means one voucher must entirely precede the other.\nWe can simplify this by iterating through all vouchers and, for each voucher `(l1, r1, c1)`, trying to find a suitable `(l2, r2, c2)` that *starts after* `(l1, r1, c1)` ends (i.e., `r1 < l2`). The symmetric case (`r2 < l1`) will be covered when `(l2, r2, c2)` is considered as the first voucher.\n\nLet `max_coord = 2 * 10^5`. We can use an array `min_cost_ending_at[day]` to store the minimum cost of a voucher that ends on or before `day` and has a specific duration. This is still too complex because of the duration requirement.\n\nA better approach:\nWe need to efficiently query for a voucher `(l2, r2, c2)` with duration `d2 = x - d1` that starts after `r1` and has minimum cost.\nThis suggests processing vouchers in a specific order. Let's sort all vouchers by their start day `l`.\n\nWe can maintain a data structure that, for each possible duration `d_val`, stores the minimum cost of a voucher with that duration that has been processed so far and meets certain criteria.\n\nLet's iterate through the days from `1` to `max_coord`.\nFor each day `k`:\n1.  **Update available vouchers**: Consider all vouchers that *start* on day `k`. For each such voucher `(k, r, c)`:\n    *   Its duration is `d = r - k + 1`.\n    *   We want to find a preceding voucher `(l_prev, r_prev, c_prev)` such that `r_prev < k` and `d_prev + d = x`.\n    *   The required duration for the preceding voucher is `d_prev = x - d`.\n    *   If `d_prev > 0` and `d_prev < x` (i.e., both vouchers have positive duration), we can look up the minimum cost of such a preceding voucher.\n    *   Let `min_cost_prev[d_prev]` be the minimum cost of a voucher with duration `d_prev` that *ends before day k*.\n    *   If `min_cost_prev[d_prev]` exists (is not infinity), then `c + min_cost_prev[d_prev]` is a candidate for the minimum total cost. Update our overall minimum answer.\n\n2.  **Update `min_cost_prev` for future queries**: Consider all vouchers that *end* on day `k`. For each such voucher `(l, k, c)`:\n    *   Its duration is `d = k - l + 1`.\n    *   We can update `min_cost_ending_before_or_at[d][k]` with `c`.\n    *   This is still too much state. We need `min_cost_prev[d_val]` to be the minimum cost of a voucher with duration `d_val` that *has already ended*.\n\nLet's refine the state:\nWe need an array `min_cost_for_duration[duration]` which stores the minimum cost of a voucher with that `duration` that *has already ended*.\nWhen we process vouchers, we can iterate through the days `k` from `1` to `max_coord`.\n\nTo handle vouchers starting and ending on specific days efficiently, we can pre-process them:\n*   `vouchers_by_start_day[k]`: a list of `(r, c, duration)` for all vouchers starting on day `k`.\n*   `vouchers_by_end_day[k]`: a list of `(l, c, duration)` for all vouchers ending on day `k`.\n\nInitialize `min_total_cost = infinity`.\nInitialize `min_cost_for_duration = array of size x+1, all infinity`. This array stores `min_cost_for_duration[d]` = minimum cost `c` of a voucher `(l, r, c)` such that `r-l+1 = d` and `r < current_day_k`.\n\nIterate `k` from `1` to `max_coord`:\n    1.  **Process vouchers starting on day `k`**:\n        For each voucher `(r, c, d)` in `vouchers_by_start_day[k]`:\n            *   Calculate the required duration for the first voucher: `d_req = x - d`.\n            *   If `1 <= d_req < x` (ensuring both durations are positive and sum to `x`):\n                *   If `min_cost_for_duration[d_req]` is not infinity:\n                    *   `min_total_cost = min(min_total_cost, c + min_cost_for_duration[d_req])`.\n\n    2.  **Process vouchers ending on day `k`**:\n        For each voucher `(l, c, d)` in `vouchers_by_end_day[k]`:\n            *   Update `min_cost_for_duration[d] = min(min_cost_for_duration[d], c)`.\n            *   This update ensures that for any future voucher `(k', r', c')` starting at `k' > k`, if it needs a voucher of duration `d`, `min_cost_for_duration[d]` will correctly reflect the minimum cost of a voucher of duration `d` that ends at or before `k`.\n\nThe maximum coordinate value is `2 * 10^5`. So `max_coord` would be `2 * 10^5`.\nThe `min_cost_for_duration` array needs to be of size `x+1`, where `x` can also be `2 * 10^5`.\nThe time complexity:\n*   Pre-processing vouchers: `O(N)` to populate `vouchers_by_start_day` and `vouchers_by_end_day`.\n*   Loop `k` from `1` to `max_coord`: `O(max_coord)`.\n    *   Inside the loop, processing vouchers: Each voucher `(l, r, c)` is added to `vouchers_by_start_day[l]` and `vouchers_by_end_day[r]`. It is processed twice (once when its start day is `k`, once when its end day is `k`).\n    *   Total operations for processing vouchers: `O(N)`.\n*   Updates to `min_cost_for_duration` and `min_total_cost` are `O(1)` per voucher.\nOverall time complexity: `O(max_coord + N)`.\nSpace complexity: `O(max_coord + N)`.\nThis fits within typical competitive programming limits.\n\nExample walk-through: `N=4, X=5`, vouchers: `(1,3,4), (1,2,5), (5,6,1), (1,2,4)`\n`max_coord = 6` (max `ri`).\n`min_total_cost = infinity`\n`min_cost_for_duration = [inf] * (X+1)` (size 6)\n\n`vouchers_by_start_day`:\n`1: [(3,4,3), (2,5,2), (2,4,2)]`\n`5: [(6,1,2)]`\n`vouchers_by_end_day`:\n`2: [(1,5,2), (1,4,2)]`\n`3: [(1,4,3)]`\n`6: [(5,1,2)]`\n\n`k = 1`:\n  `vouchers_by_start_day[1]`:\n    *   `(r=3, c=4, d=3)`: `d_req = 5-3=2`. `min_cost_for_duration[2]` is inf. No update.\n    *   `(r=2, c=5, d=2)`: `d_req = 5-2=3`. `min_cost_for_duration[3]` is inf. No update.\n    *   `(r=2, c=4, d=2)`: `d_req = 5-2=3`. `min_cost_for_duration[3]` is inf. No update.\n  `vouchers_by_end_day[1]`: empty.\n\n`k = 2`:\n  `vouchers_by_start_day[2]`: empty.\n  `vouchers_by_end_day[2]`:\n    *   `(l=1, c=5, d=2)`: `min_cost_for_duration[2] = min(inf, 5) = 5`.\n    *   `(l=1, c=4, d=2)`: `min_cost_for_duration[2] = min(5, 4) = 4`.\n\n`k = 3`:\n  `vouchers_by_start_day[3]`: empty.\n  `vouchers_by_end_day[3]`:\n    *   `(l=1, c=4, d=3)`: `min_cost_for_duration[3] = min(inf, 4) = 4`.\n\n`k = 4`:\n  `vouchers_by_start_day[4]`: empty.\n  `vouchers_by_end_day[4]`: empty.\n\n`k = 5`:\n  `vouchers_by_start_day[5]`:\n    *   `(r=6, c=1, d=2)`: `d_req = 5-2=3`. `min_cost_for_duration[3]` is 4.\n        `min_total_cost = min(inf, 1 + 4) = 5`.\n  `vouchers_by_end_day[5]`: empty.\n\n`k = 6`:\n  `vouchers_by_start_day[6]`: empty.\n  `vouchers_by_end_day[6]`:\n    *   `(l=5, c=1, d=2)`: `min_cost_for_duration[2] = min(4, 1) = 1`. (Note: this is only useful for vouchers starting at `k > 6`, but `max_coord` is 6, so no more iterations)\n\nLoop ends. `min_total_cost = 5`.\nOutput 5. This matches the example.\n\nFinal check for edge cases:\n*   If `x` is too small (e.g., `x=1`), then `d_req` might be `0` or negative. The condition `1 <= d_req < x` handles this.\n*   If no pair is found, `min_total_cost` remains `infinity`. We print `-1`.\n*   `costi` can be `10^9`, so sum can be `2 * 10^9`. Python integers handle this automatically.\n*   `max_coord` can be `2 * 10^5`. Using `max_coord + 1` for array sizes is appropriate.\n*   `n, x` can be `2`. The logic still holds.\n\n```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n\n    vouchers_by_start_day = [[] for _ in range(200001)]\n    vouchers_by_end_day = [[] for _ in range(200001)]\n    \n    max_coordinate = 0\n\n    for _ in range(n):\n        l, r, c = map(int, sys.stdin.readline().split())\n        duration = r - l + 1\n        \n        vouchers_by_start_day[l].append((r, c, duration))\n        vouchers_by_end_day[r].append((l, c, duration))\n        \n        if r > max_coordinate:\n            max_coordinate = r\n\n    # min_cost_for_duration[d] stores the minimum cost of a voucher\n    # with duration 'd' that has already ended (i.e., its end day 'r' < current_day_k).\n    # Initialize with a very large value (effectively infinity).\n    # The maximum possible duration is X, so array size X+1 is sufficient.\n    # We use 2*10^9 + 7 as a value larger than any possible sum of two costs (2*10^9).\n    INF = 2 * 10**9 + 7\n    min_cost_for_duration = [INF] * (x + 1)\n    \n    min_total_cost = INF\n\n    # Iterate through each possible day from 1 up to the maximum end day encountered\n    for k in range(1, max_coordinate + 1):\n        # Step 1: Process vouchers that start on day k\n        # For each such voucher, try to find a preceding voucher to form a pair\n        for r, c, d in vouchers_by_start_day[k]:\n            required_duration_for_first_voucher = x - d\n            \n            # Ensure the required duration is positive and less than x\n            # (both vouchers must have positive duration)\n            if 1 <= required_duration_for_first_voucher < x:\n                if min_cost_for_duration[required_duration_for_first_voucher] != INF:\n                    current_pair_cost = c + min_cost_for_duration[required_duration_for_first_voucher]\n                    if current_pair_cost < min_total_cost:\n                        min_total_cost = current_pair_cost\n        \n        # Step 2: Process vouchers that end on day k\n        # Update min_cost_for_duration for future queries\n        for l, c, d in vouchers_by_end_day[k]:\n            # If this voucher's duration is within the range [1, X]\n            # (i.e., it could potentially be part of a pair summing to X)\n            if 1 <= d <= x:\n                if c < min_cost_for_duration[d]:\n                    min_cost_for_duration[d] = c\n\n    if min_total_cost == INF:\n        sys.stdout.write(\"-1\\n\")\n    else:\n        sys.stdout.write(str(min_total_cost) + \"\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n\n    vouchers_by_start_day = [[] for _ in range(200001)]\n    vouchers_by_end_day = [[] for _ in range(200001)]\n    \n    max_coordinate = 0\n\n    for _ in range(n):\n        l, r, c = map(int, sys.stdin.readline().split())\n        duration = r - l + 1\n        \n        vouchers_by_start_day[l].append((r, c, duration))\n        vouchers_by_end_day[r].append((l, c, duration))\n        \n        if r > max_coordinate:\n            max_coordinate = r\n\n    # min_cost_for_duration[d] stores the minimum cost of a voucher\n    # with duration 'd' that has already ended (i.e., its end day 'r' < current_day_k).\n    # Initialize with a very large value (effectively infinity).\n    # The maximum possible duration is X, so array size X+1 is sufficient.\n    # We use 2*10^9 + 7 as a value larger than any possible sum of two costs (2*10^9).\n    INF = 2 * 10**9 + 7\n    min_cost_for_duration = [INF] * (x + 1)\n    \n    min_total_cost = INF\n\n    # Iterate through each possible day from 1 up to the maximum end day encountered\n    for k in range(1, max_coordinate + 1):\n        # Step 1: Process vouchers that start on day k\n        # For each such voucher, try to find a preceding voucher to form a pair\n        for r, c, d in vouchers_by_start_day[k]:\n            required_duration_for_first_voucher = x - d\n            \n            # Ensure the required duration is positive and less than x\n            # (both vouchers must have positive duration)\n            if 1 <= required_duration_for_first_voucher < x:\n                if min_cost_for_duration[required_duration_for_first_voucher] != INF:\n                    current_pair_cost = c + min_cost_for_duration[required_duration_for_first_voucher]\n                    if current_pair_cost < min_total_cost:\n                        min_total_cost = current_pair_cost\n        \n        # Step 2: Process vouchers that end on day k\n        # Update min_cost_for_duration for future queries\n        for l, c, d in vouchers_by_end_day[k]:\n            # If this voucher's duration is within the range [1, X]\n            # (i.e., it could potentially be part of a pair summing to X)\n            if 1 <= d <= x:\n                if c < min_cost_for_duration[d]:\n                    min_cost_for_duration[d] = c\n\n    if min_total_cost == INF:\n        sys.stdout.write(\"-1\\n\")\n    else:\n        sys.stdout.write(str(min_total_cost) + \"\\n\")\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 798,
        "completion_token_count": 3670,
        "thoughts_token_count": 816
    }
}