{
    "start": 1758293698.2674937,
    "end": 1758293765.5232868,
    "start-formatted": "2025-09-19 23:54 KST",
    "end-formatted": "2025-09-19 23:56 KST",
    "gpu": 2,
    "pid": 57,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Olympiad\n\nA boy named Vasya has taken part in an Olympiad. His teacher knows that in total Vasya got at least x points for both tours of the Olympiad. The teacher has the results of the first and the second tour of the Olympiad but the problem is, the results have only points, no names. The teacher has to know Vasya's chances.Help Vasya's teacher, find two numbers — the best and the worst place Vasya could have won. Note that the total results' table sorts the participants by the sum of points for both tours (the first place has the participant who has got the most points). If two or more participants have got the same number of points, it's up to the jury to assign places to them according to their choice. It is guaranteed that each participant of the Olympiad participated in both tours of the Olympiad.\n\n## Input\nThe first line contains two space-separated integers n, x (1 ≤ n ≤ 105; 0 ≤ x ≤ 2·105) — the number of Olympiad participants and the minimum number of points Vasya earned.The second line contains n space-separated integers: a1, a2, ..., an (0 ≤ ai ≤ 105) — the participants' points in the first tour.The third line contains n space-separated integers: b1, b2, ..., bn (0 ≤ bi ≤ 105) — the participants' points in the second tour.The participants' points are given in the arbitrary order. It is guaranteed that Vasya was present in the Olympiad — there are two integers i, j (1 ≤ i, j ≤ n) such, that ai + bj ≥ x.\n\n## Output\nPrint two space-separated integers — the best and the worst place Vasya could have got on the Olympiad.\n\n## Example\n### Input\n['5 2\\n1 1 1 1 1\\n1 1 1 1 1', '6 7\\n4 3 5 6 4 4\\n8 6 0 4 3 4']\n\n### Output\n['1 5', '1 5']\n\n## Note\nIn the first text sample all 5 participants earn 2 points each in any case. Depending on the jury's decision, Vasya can get the first (the best) as well as the last (the worst) fifth place.In the second test sample in the best case scenario Vasya wins again: he can win 12 points and become the absolute winner if the total results' table looks like that — {4:8, 6:4, 3:6, 4:4, 4:3, 5:0}.In this table all participants are sorted by decreasing points and we can see how much a participant earned in the first and in the second tour.In the worst case scenario Vasya can get the fifth place if the table looks like that — {4:8, 4:6, 6:4, 5:4, 4:3, 3:0}, and he earned 4 and 3 points in the first and second tours, correspondingly.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "",
    "response": "```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    a.sort()\n    b.sort()\n\n    # Calculate best possible rank\n    # Vasya wants to maximize his score. He picks the highest possible a_i and b_j such that a_i + b_j >= x.\n    # To maximize his rank, he wants to have as many people as possible score less than him.\n    # The other n-1 participants should have their scores minimized.\n    # This means we should pair the remaining highest scores from one list with the lowest scores from the other.\n\n    # To find Vasya's best possible score:\n    # He can take any a_i and any b_j such that a_i + b_j >= x.\n    # To maximize his score, he should pick the largest a_i and largest b_j.\n    # Let's say Vasya picks a[n-1] and b[n-1]. His score is a[n-1] + b[n-1].\n    # Then we need to count how many other participants can score *strictly greater* than him.\n    # This is tricky because the problem states \"If two or more participants have got the same number of points,\n    # it's up to the jury to assign places to them according to their choice.\"\n    # For best rank, we assume jury assigns Vasya the best possible rank among ties.\n    # So we count people with score > Vasya's score.\n    # The problem implies Vasya is one specific person whose scores are unknown.\n    # \"find two numbers — the best and the worst place Vasya could have won.\"\n\n    # Best rank: Vasya wants to maximize his score and minimize others' scores.\n    # He can take the highest possible score: a[n-1] + b[n-1].\n    # But this pairing might not be valid if a[n-1] + b[n-1] < x.\n    # The problem guarantees that such a pair (a_i, b_j) exists.\n    # Vasya can achieve any score a_i + b_j >= x by picking a_i and b_j.\n    # To get the best rank, Vasya wants to achieve the highest possible sum,\n    # and for other participants to achieve the lowest possible sums.\n    # The highest possible sum Vasya can achieve is a[n-1] + b[n-1].\n    # If he takes a[n-1] and b[n-1], these two values are used.\n    # The remaining n-1 participants use a[0...n-2] and b[0...n-2].\n    # To minimize their scores, we pair the largest remaining 'a' with the smallest remaining 'b'.\n    # This is not how it works. The points are just given. We assign them.\n\n    # Best case: Vasya gets the highest possible sum, and all other people get the lowest possible sums.\n    # Vasya takes a[n-1] and b[n-1]. His score is S_V = a[n-1] + b[n-1]. (This assumes a[n-1] + b[n-1] >= x)\n    # The other participants are assigned points from a[0...n-2] and b[0...n-2].\n    # To minimize their scores, we pair a[i] with b[j] such that a[i]+b[j] is small.\n    # This is not how it works. We have n 'a' scores and n 'b' scores.\n    # We need to form n pairs (a_i, b_j) such that each a_k and b_k is used exactly once.\n    # Vasya is one of these pairs. He must satisfy a_i + b_j >= x.\n\n    # For best rank, Vasya wants to maximize his score.\n    # The highest possible score he can achieve is a[n-1] + b[n-1].\n    # Let Vasya take a[n-1] and b[n-1]. His score is S_V = a[n-1] + b[n-1].\n    # This score is guaranteed to be >= x (if it's the max possible score and a valid pair exists).\n    # If a[n-1] + b[n-1] < x, then Vasya cannot get this score.\n    # The problem guarantees that *some* a_i + b_j >= x.\n    # So Vasya can get a score S_V >= x. To maximize his rank, he should maximize his score.\n    # The highest score he can achieve is a[n-1] + b[n-1].\n    # Let's assume Vasya takes a[n-1] and b[n-1]. His score is S_V = a[n-1] + b[n-1].\n    # We then try to pair the remaining (n-1) 'a's and (n-1) 'b's such that their sums are as small as possible.\n    # This means pairing a[i] with b[j] such that i+j is small.\n    # This is not correct. We are not minimizing other people's scores.\n    # We are just finding the best possible rank for Vasya.\n\n    # Best rank: Vasya takes the highest possible 'a' and 'b' values, i.e., a[n-1] and b[n-1].\n    # His score is a[n-1] + b[n-1]. (This must be >= x, which is true if a[n-1]+b[n-1] is the largest sum possible).\n    # The number of people who can score strictly more than him is 0.\n    # The number of people who can score equal to him is n-1 (if we pair up the remaining such that they all get a[n-1]+b[n-1]).\n    # But this is not possible. The other n-1 participants use a[0...n-2] and b[0...n-2].\n    # The problem asks for the best rank Vasya *could* have won.\n    # This means we should arrange the pairings of the other n-1 participants such that Vasya's rank is maximized.\n    # If Vasya gets the highest possible score (a[n-1] + b[n-1]), then he is rank 1.\n    # This is possible if a[n-1] + b[n-1] >= x.\n    # Since it's guaranteed that *some* a_i + b_j >= x, and a[n-1] + b[n-1] is the maximum possible sum,\n    # it must be that a[n-1] + b[n-1] >= x.\n    # So Vasya can always achieve rank 1 by taking a[n-1] and b[n-1].\n    # The other participants will score less than or equal to a[n-1] + b[n-1].\n    # The jury can assign Vasya rank 1 in case of ties.\n    best_rank = 1\n\n    # Worst rank: Vasya wants to minimize his score (but still >= x), and maximize others' scores.\n    # Vasya's score S_V must be >= x.\n    # We want to find a pairing (a_i, b_j) for Vasya such that a_i + b_j >= x.\n    # We want this sum to be as small as possible, to maximize the number of people who score higher.\n    # Also, we want to maximize the scores of the other n-1 participants.\n    # The jury assigns Vasya the worst rank in case of ties. So we count people with score >= Vasya's score.\n\n    # Let's fix a score S for Vasya. S = a_k + b_l >= x.\n    # We want to find the minimum possible S.\n    # We also want to maximize the number of people who score >= S.\n    # This is a greedy approach.\n    # Sort 'a' in ascending order. Sort 'b' in ascending order.\n    # For a fixed 'a_i' that Vasya takes, he wants to pair it with the smallest 'b_j' such that a_i + b_j >= x.\n    # Let's iterate through all possible 'a_i' for Vasya.\n    # For each a_i, find the smallest b_j such that a_i + b_j >= x.\n    # This b_j can be found using binary search (bisect_left) on 'b'.\n    # If such a b_j exists, then a_i + b_j is a candidate score for Vasya.\n    # We want to pick the (a_i, b_j) pair for Vasya that results in the worst rank.\n\n    # Let's consider a specific total score S.\n    # How many participants can achieve a score of at least S?\n    # We want to find the maximum number of participants who can score >= S.\n    # This is a matching problem.\n    # For a given score S, we can find the maximum number of pairs (a_i, b_j) such that a_i + b_j >= S.\n    # This can be done by sorting 'a' and 'b'.\n    # Iterate 'a_i' from largest to smallest. For each a_i, we want to find a b_j such that a_i + b_j >= S.\n    # To maximize the number of such pairs, we use a two-pointer approach.\n    # Sort 'a' in ascending order. Sort 'b' in ascending order.\n    # Let 'a_ptr' point to the smallest element in 'a', and 'b_ptr' point to the largest element in 'b'.\n    # If a[a_ptr] + b[b_ptr] >= S, then we can form a pair. Increment count, increment a_ptr, decrement b_ptr.\n    # If a[a_ptr] + b[b_ptr] < S, then a[a_ptr] is too small to pair with b[b_ptr] to reach S.\n    # So we must try a larger 'a_i'. Increment a_ptr.\n    # This counts the maximum number of pairs that sum to at least S.\n    # This count is monotonic: if count(S) is the number of pairs >= S, then count(S+1) <= count(S).\n    # We are looking for the maximum possible value of count(S) such that S is a score Vasya could get (S >= x).\n\n    # The worst rank for Vasya is 1 + (number of people who score > Vasya's score) + (number of people who tie Vasya's score and are placed above him).\n    # Since the jury can place Vasya last among ties, this means his rank is 1 + (number of people who score > Vasya's score) + (number of people who tie Vasya's score).\n    # This is equivalent to finding the maximum number of people who can score >= Vasya's score.\n\n    # Let's find the maximum number of pairs (a_i, b_j) such that a_i + b_j >= S.\n    # This is a classic two-pointer problem on sorted arrays.\n    # `a` is sorted ascending. `b` is sorted ascending.\n    # To maximize pairs for `a_i + b_j >= S`:\n    # Iterate `a_i` from `a[0]` to `a[n-1]`. For each `a_i`, we need `b_j >= S - a_i`.\n    # We want to pick the smallest such `b_j` to leave larger `b` values for other `a`s.\n    # This is equivalent to: sort `a` and `b`.\n    # Count how many pairs (a_i, b_j) can be formed such that a_i + b_j >= S.\n    # Use `a` sorted ascending, `b` sorted descending.\n    # Two pointers: `ptr_a` for `a`, `ptr_b` for `b`.\n    # If `a[ptr_a] + b[ptr_b] >= S`, we form a pair. `ptr_a++`, `ptr_b++`, `count++`.\n    # If `a[ptr_a] + b[ptr_b] < S`, then `a[ptr_a]` is too small to form a pair with `b[ptr_b]`.\n    # We must try a larger `a`. `ptr_a++`.\n    # This logic is for finding max pairs where each element is used at most once.\n    # This works.\n\n    def count_ge_S(S, arr_a, arr_b):\n        \"\"\"\n        Counts the maximum number of pairs (a_i, b_j) such that a_i + b_j >= S.\n        arr_a and arr_b are sorted ascending.\n        \"\"\"\n        n_val = len(arr_a)\n        count = 0\n        b_ptr = n_val - 1  # Start from largest b\n        for i in range(n_val):  # Iterate through a from smallest to largest\n            while b_ptr >= 0 and arr_a[i] + arr_b[b_ptr] >= S:\n                b_ptr -= 1\n            # All b[b_ptr+1 ... n_val-1] can be paired with a[i] to satisfy sum >= S.\n            # But we can only use each b_j once.\n            # This logic is wrong. We need a proper matching.\n\n        # Correct logic for maximum pairs (a_i, b_j) with a_i + b_j >= S:\n        # Sort 'a' ascending. Sort 'b' ascending.\n        # Use two pointers: `l` for `a` (from left), `r` for `b` (from right).\n        # `l` starts at 0, `r` starts at n-1.\n        # If `a[l] + b[r] >= S`: This pair works. We take it. Increment `l`, decrement `r`, `count++`.\n        # If `a[l] + b[r] < S`: `a[l]` is too small. We must use a larger `a`. Increment `l`.\n        # This maximizes the number of pairs.\n        \n        l = 0\n        r = n_val - 1\n        current_count = 0\n        \n        temp_a = list(arr_a) # Make copies to simulate usage\n        temp_b = list(arr_b)\n\n        # To find max number of pairs (a_i, b_j) such that a_i + b_j >= S\n        # Sort A ascending, B ascending.\n        # For each a_i, we want to find a b_j such that a_i + b_j >= S.\n        # We want to maximize the number of such pairs.\n        # This is a greedy approach: for the smallest a_i, find the smallest b_j that works.\n        # This is not right. For the smallest a_i, we should find the largest b_j that works,\n        # to save smaller b_j's for larger a_i's.\n        # The correct greedy approach for maximum matching with a sum condition:\n        # Sort 'a' ascending. Sort 'b' ascending.\n        # Use two pointers, `ptr_a` for `a` (from left), `ptr_b` for `b` (from right).\n        # If `a[ptr_a] + b[ptr_b] >= S`: we can form a pair. Take `a[ptr_a]` and `b[ptr_b]`.\n        #   Increment `ptr_a`, decrement `ptr_b`, `count++`.\n        # If `a[ptr_a] + b[ptr_b] < S`: `a[ptr_a]` is too small to pair with `b[ptr_b]` (the largest remaining `b`).\n        #   So `a[ptr_a]` cannot form a pair with any remaining `b` to meet the condition.\n        #   We must discard `a[ptr_a]` and try a larger `a`. Increment `ptr_a`.\n        \n        # Wait, this logic is flawed. If a[ptr_a] + b[ptr_b] < S, it means a[ptr_a] is too small for b[ptr_b].\n        # It doesn't mean a[ptr_a] is too small for *any* remaining b.\n        # For example, a = [1, 5], b = [1, 5], S = 6.\n        # a[0]=1, b[1]=5. 1+5=6 >= S. Pair (1,5). Count=1.\n        # Remaining: a=[5], b=[1].\n        # But if we did a[0]=1, b[0]=1. 1+1 < S.\n        # This is a standard problem, maximum number of pairs (a_i, b_j) such that a_i + b_j >= S.\n        # Sort `a` and `b`.\n        # `ptr_a` from 0, `ptr_b` from n-1.\n        # If `a[ptr_a] + b[ptr_b] >= S`: `ptr_a++`, `ptr_b--`, `count++`. (This means `a[ptr_a]` is paired with `b[ptr_b]`)\n        # If `a[ptr_a] + b[ptr_b] < S`: `ptr_a++`. (This means `a[ptr_a]` cannot be paired with `b[ptr_b]` or any smaller `b` to meet S, so it must be paired with something else, or discarded.\n        # But we are trying to maximize pairs. If `a[ptr_a]` is too small for `b[ptr_b]`, then `b[ptr_b]` must be paired with some other `a` (which is larger than `a[ptr_a]`).\n        # So we should try to pair `b[ptr_b]` with a larger `a`. We decrement `ptr_b`.\n        # This is the correct logic for maximum pairs for sum >= S:\n        \n        ptr_a = 0\n        ptr_b = n_val - 1\n        current_count = 0\n        while ptr_a < n_val and ptr_b >= 0:\n            if arr_a[ptr_a] + arr_b[ptr_b] >= S:\n                current_count += 1\n                ptr_a += 1\n                ptr_b -= 1\n            else:\n                # a[ptr_a] is too small to make S with b[ptr_b].\n                # It means a[ptr_a] cannot make S with any b_k where k <= ptr_b.\n                # So a[ptr_a] cannot be used to make S with any of the remaining b's.\n                # We must use a larger a.\n                ptr_a += 1\n        return current_count\n\n    # The worst rank for Vasya is 1 + (number of people who score >= Vasya's score, excluding Vasya).\n    # We want to find a Vasya's score S_V >= x such that count_ge_S(S_V) is maximized.\n    # The possible scores range from 0 to 2*10^5.\n    # We can binary search on the number of people who score >= Vasya's score.\n    # Or, we can binary search on Vasya's score S_V.\n    # The function `count_ge_S(S, a, b)` is monotonically non-increasing with S.\n    # We want to maximize `count_ge_S(S)` subject to S >= x.\n    # The maximum value of `count_ge_S(S)` is `n`.\n    # The minimum value of `count_ge_S(S)` is `0`.\n    # Let `K` be the number of people scoring >= S. We want to maximize `K`.\n    # We are looking for the maximum `K` such that there exists an S >= x where `count_ge_S(S) = K`.\n    # And Vasya is one of those K people.\n\n    # This is slightly different. We need to pick a specific (a_i, b_j) for Vasya.\n    # Let Vasya's chosen score be S_V = a_k + b_l. We must have S_V >= x.\n    # Then the remaining n-1 participants are chosen from `a` (excluding a_k) and `b` (excluding b_l).\n    # We want to maximize the number of pairs (a_p, b_q) from remaining elements such that a_p + b_q >= S_V.\n    # The worst rank is 1 + (count of remaining people with score >= S_V).\n\n    # This seems like a difficult matching problem.\n    # Let's reconsider the problem statement: \"find two numbers — the best and the worst place Vasya could have won.\"\n    # This means we can choose any valid assignment of scores (n pairs, each a_i and b_j used once)\n    # such that Vasya's score is >= x.\n    # Then we calculate Vasya's rank based on that assignment.\n    # We want to find the minimum possible rank and maximum possible rank over all valid assignments.\n\n    # Best rank: Always 1. Vasya takes a[n-1] and b[n-1]. His score S_V = a[n-1] + b[n-1].\n    # Since there's a guaranteed pair (a_i, b_j) with sum >= x, and a[n-1]+b[n-1] is the maximum possible sum,\n    # it must be that a[n-1]+b[n-1] >= x.\n    # So Vasya can achieve the highest possible score.\n    # In case of ties, the jury can place him first. So best rank is 1.\n\n    # Worst rank:\n    # Vasya wants to be paired (a_k, b_l) such that a_k + b_l >= x.\n    # He wants this S_V = a_k + b_l to be as low as possible,\n    # AND he wants as many other participants as possible to have a score >= S_V.\n    # This is equivalent to finding the minimum S_V >= x such that `count_ge_S(S_V)` is maximized.\n    # The problem is that `count_ge_S` uses all `n` participants.\n    # If Vasya takes a_k and b_l, then `count_ge_S(S_V)` should be computed on `a` excluding a_k and `b` excluding b_l.\n    # This means we'd have to iterate through all possible (a_k, b_l) pairs for Vasya.\n    # There are n*n such pairs, too many.\n\n    # Let's re-read carefully: \"the total results' table sorts the participants by the sum of points for both tours (the first place has the participant who has got the most points). If two or more participants have got the same number of points, it's up to the jury to assign places to them according to their choice.\"\n    # \"Help Vasya's teacher, find two numbers — the best and the worst place Vasya could have won.\"\n    # This means we are trying to find the best/worst rank over ALL possible assignments of scores to participants, given that Vasya gets one of these pairs and his sum is >= x.\n\n    # Worst rank:\n    # We want to maximize the number of people who score >= Vasya.\n    # Let Vasya score S_V.\n    # We need to find an assignment of all n pairs (a_i, b_j) such that:\n    # 1. Each a_val from `a` and b_val from `b` is used exactly once.\n    # 2. One of these pairs (Vasya's pair) has sum >= x.\n    # 3. Among all such assignments, we pick one that maximizes Vasya's rank (i.e., minimizes his rank number).\n    #    No, we pick one that minimizes Vasya's rank (i.e., maximizes his rank number).\n    # And for this chosen assignment, we calculate Vasya's rank.\n    # We want to maximize 1 + (number of people with score > S_V) + (number of people with score = S_V, placed above Vasya).\n    # Since jury can place Vasya last among ties, this means we count all people with score >= S_V.\n\n    # Let's consider a target rank `k`. Can Vasya get rank `k` (or worse)?\n    # This means we need to find an assignment such that at least `k` people (including Vasya) have score >= S_V.\n    # And Vasya's score S_V must be >= x.\n\n    # The key insight for worst rank:\n    # We want to maximize the number of people who score strictly greater than Vasya,\n    # and then maximize the number of people who score equal to Vasya (and are placed above him).\n    # This is equivalent to maximizing the number of people who score >= S_V.\n    # Let Vasya's score be S_V. We need to find an assignment of n pairs such that S_V >= x,\n    # and the number of people with score >= S_V is maximized.\n    # The `count_ge_S` function counts the maximum number of pairs (a_i, b_j) such that a_i + b_j >= S.\n    # This function gives the maximum possible number of people who can score at least S, if we arrange pairings optimally.\n    # Vasya's score S_V must be one of these S's.\n    # So we want to find `max_{S >= x} count_ge_S(S, a, b)`.\n    # Let this maximum count be `K_max`.\n    # The worst rank for Vasya will be `K_max`.\n    # We need to check if `K_max` can actually be achieved.\n    # The function `count_ge_S(S, a, b)` gives the maximum number of people who can score >= S.\n    # This count includes Vasya. So if `count_ge_S(S) = K`, then Vasya is one of those K people.\n    # And the jury places him last among ties. So his rank is K.\n    # We want to find the maximum possible K, such that there exists an S >= x for which K people score >= S.\n    # The function `f(S) = count_ge_S(S, a, b)` is non-increasing.\n    # We are looking for `max_{S >= x} f(S)`.\n    # Since `f(S)` is non-increasing, `max_{S >= x} f(S)` will be `f(x)` (if S can be x).\n    # No, it should be `f(S_min)` where S_min is the smallest S >= x that can be achieved by a pair.\n    # For example, if x=10, and possible sums are {5, 6, 7, 8, 9, 11, 12}.\n    # We only care about sums >= 10. So {11, 12}.\n    # `count_ge_S(11)` could be 3, `count_ge_S(12)` could be 2.\n    # If Vasya takes 11, his rank is 3. If Vasya takes 12, his rank is 2.\n    # He wants the worst rank, so he'd pick 11.\n    # So we want to find `max_{S_V possible and S_V >= x} count_ge_S(S_V)`.\n\n    # Let's consider all possible sums `s = a[i] + b[j]`.\n    # For each such sum `s` that is >= x, calculate `count_ge_S(s, a, b)`.\n    # The maximum of these values will be the worst rank.\n    # There are n*n possible sums. This is too many.\n    # The values of `count_ge_S(S)` only change at specific `S` values (when `S` crosses an `a_i + b_j` boundary).\n    # The possible sums `a_i + b_j` range from 0 to 2*10^5.\n    # We can binary search for the optimal S.\n    # No, we want to maximize `count_ge_S(S)` for `S >= x`.\n    # This means we should choose the smallest possible S that Vasya can get such that S >= x.\n    # But this is not guaranteed to maximize the count.\n\n    # Example: a = [1, 1, 1, 1, 1], b = [1, 1, 1, 1, 1], n=5, x=2.\n    # All participants score 1+1=2.\n    # count_ge_S(2, a, b) = 5. Vasya's rank is 5.\n    # Best rank is 1. Worst rank is 5. Matches example.\n\n    # Example: n=6, x=7, a=[4,3,5,6,4,4], b=[8,6,0,4,3,4]\n    # Sorted a: [3, 4, 4, 4, 5, 6]\n    # Sorted b: [0, 3, 4, 4, 6, 8]\n\n    # Best rank: 1. (Vasya takes 6+8=14, which is >= x=7. No one can score higher. Jury places him 1st.)\n\n    # Worst rank:\n    # We need to find `max_{S_V >= x} count_ge_S(S_V, a, b)`.\n    # The range of possible scores S is [0, 2*10^5].\n    # Let's try to find the smallest S >= x for which `count_ge_S(S)` is maximized.\n    # This is not necessarily the smallest S >= x.\n    # Let `max_count = 0`.\n    # Iterate `S` from `x` to `2*10^5`.\n    # `max_count = max(max_count, count_ge_S(S, a, b))`\n    # This is too slow (2*10^5 * N).\n\n    # The function `count_ge_S(S)` is non-increasing.\n    # We are looking for `max_{S_V >= x} count_ge_S(S_V)`.\n    # This means we want to find the smallest S_V >= x such that `count_ge_S(S_V)` is maximized.\n    # Let `f(S) = count_ge_S(S)`. We want to maximize `f(S)` for `S >= x`.\n    # Since `f(S)` is non-increasing, `f(x)` is the maximum value of `f(S)` for `S >= x`.\n    # So the worst rank is simply `count_ge_S(x, a, b)`.\n    # Let's check this logic.\n    # If Vasya chooses a pair (a_k, b_l) such that a_k + b_l = S_V.\n    # We want to maximize the number of people who score >= S_V.\n    # This maximum number is given by `count_ge_S(S_V, a, b)`.\n    # Vasya can choose *any* pair (a_k, b_l) such that a_k + b_l >= x.\n    # He wants to choose one such pair that maximizes his rank (i.e., makes it as large as possible).\n    # This means he chooses S_V such that `count_ge_S(S_V, a, b)` is maximized.\n    # Since `count_ge_S(S)` is non-increasing, its maximum value for `S >= x` is achieved at the smallest possible `S` value in this range.\n    # The smallest possible `S` value that Vasya can achieve and is >= x, is not necessarily `x`.\n    # It could be `x` itself, or `x+1`, etc.\n    # However, the function `count_ge_S(S, a, b)` uses *all* `n` participants.\n    # If `count_ge_S(x, a, b)` is `K`, it means there is an arrangement of `n` pairs such that `K` pairs sum to at least `x`.\n    # Can Vasya be one of these `K` pairs? Yes.\n    # So, if Vasya picks a pair that sums to exactly `x`, and there are `K` such pairs possible (including his),\n    # then his rank is `K`.\n    # If he picks a pair that sums to `x+1`, and there are `K'` such pairs possible, his rank is `K'`.\n    # He wants to maximize this `K` or `K'`.\n    # Since `count_ge_S(S)` is non-increasing, `count_ge_S(x)` will be the maximum value among `count_ge_S(S)` for `S >= x`.\n    # So, the worst rank is indeed `count_ge_S(x, a, b)`.\n\n    worst_rank = count_ge_S(x, a, b)\n\n    sys.stdout.write(f\"{best_rank} {worst_rank}\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    a.sort()\n    b.sort()\n\n    # Calculate best possible rank\n    # Vasya wants to maximize his score. He picks the highest possible a_i and b_j such that a_i + b_j >= x.\n    # To maximize his rank, he wants to have as many people as possible score less than him.\n    # The other n-1 participants should have their scores minimized.\n    # This means we should pair the remaining highest scores from one list with the lowest scores from the other.\n\n    # To find Vasya's best possible score:\n    # He can take any a_i and any b_j such that a_i + b_j >= x.\n    # To maximize his score, he should pick the largest a_i and largest b_j.\n    # Let's say Vasya picks a[n-1] and b[n-1]. His score is a[n-1] + b[n-1].\n    # Then we need to count how many other participants can score *strictly greater* than him.\n    # This is tricky because the problem states \"If two or more participants have got the same number of points,\n    # it's up to the jury to assign places to them according to their choice.\"\n    # For best rank, we assume jury assigns Vasya the best possible rank among ties.\n    # So we count people with score > Vasya's score.\n    # The problem implies Vasya is one specific person whose scores are unknown.\n    # \"find two numbers — the best and the worst place Vasya could have won.\"\n\n    # Best rank: Vasya wants to maximize his score and minimize others' scores.\n    # He can take the highest possible score: a[n-1] + b[n-1].\n    # But this pairing might not be valid if a[n-1] + b[n-1] < x.\n    # The problem guarantees that such a pair (a_i, b_j) exists.\n    # Vasya can achieve any score a_i + b_j >= x by picking a_i and b_j.\n    # To get the best rank, Vasya wants to achieve the highest possible sum,\n    # and for other participants to achieve the lowest possible sums.\n    # The highest possible sum Vasya can achieve is a[n-1] + b[n-1].\n    # If he takes a[n-1] and b[n-1], these two values are used.\n    # The remaining n-1 participants use a[0...n-2] and b[0...n-2].\n    # To minimize their scores, we pair the largest remaining 'a' with the smallest remaining 'b'.\n    # This is not how it works. The points are just given. We assign them.\n\n    # Best case: Vasya gets the highest possible sum, and all other people get the lowest possible sums.\n    # Vasya takes a[n-1] and b[n-1]. His score is S_V = a[n-1] + b[n-1]. (This assumes a[n-1] + b[n-1] >= x)\n    # The other participants are assigned points from a[0...n-2] and b[0...n-2].\n    # To minimize their scores, we pair a[i] with b[j] such that a[i]+b[j] is small.\n    # This is not how it works. We have n 'a' scores and n 'b' scores.\n    # We need to form n pairs (a_i, b_j) such that each a_k and b_k is used exactly once.\n    # Vasya is one of these pairs. He must satisfy a_i + b_j >= x.\n\n    # For best rank, Vasya wants to maximize his score.\n    # The highest possible score he can achieve is a[n-1] + b[n-1].\n    # Let Vasya take a[n-1] and b[n-1]. His score is S_V = a[n-1] + b[n-1].\n    # This score is guaranteed to be >= x (if it's the max possible score and a valid pair exists).\n    # If a[n-1] + b[n-1] < x, then Vasya cannot get this score.\n    # The problem guarantees that *some* a_i + b_j >= x.\n    # So Vasya can get a score S_V >= x. To maximize his rank, he should maximize his score.\n    # The highest score he can achieve is a[n-1] + b[n-1].\n    # Let's assume Vasya takes a[n-1] and b[n-1]. His score is S_V = a[n-1] + b[n-1].\n    # We then try to pair the remaining (n-1) 'a's and (n-1) 'b's such that their sums are as small as possible.\n    # This means pairing a[i] with b[j] such that i+j is small.\n    # This is not correct. We are not minimizing other people's scores.\n    # We are just finding the best possible rank for Vasya.\n\n    # Best rank: Vasya takes the highest possible 'a' and 'b' values, i.e., a[n-1] and b[n-1].\n    # His score is a[n-1] + b[n-1]. (This must be >= x, which is true if a[n-1]+b[n-1] is the largest sum possible).\n    # The number of people who can score strictly more than him is 0.\n    # The number of people who can score equal to him is n-1 (if we pair up the remaining such that they all get a[n-1]+b[n-1]).\n    # But this is not possible. The other n-1 participants use a[0...n-2] and b[0...n-2].\n    # The problem asks for the best rank Vasya *could* have won.\n    # This means we should arrange the pairings of the other n-1 participants such that Vasya's rank is maximized.\n    # If Vasya gets the highest possible score (a[n-1] + b[n-1]), then he is rank 1.\n    # This is possible if a[n-1] + b[n-1] >= x.\n    # Since it's guaranteed that *some* a_i + b_j >= x, and a[n-1] + b[n-1] is the maximum possible sum,\n    # it must be that a[n-1] + b[n-1] >= x.\n    # So Vasya can always achieve rank 1 by taking a[n-1] and b[n-1].\n    # The other participants will score less than or equal to a[n-1] + b[n-1].\n    # The jury can assign Vasya rank 1 in case of ties.\n    best_rank = 1\n\n    # Worst rank: Vasya wants to minimize his score (but still >= x), and maximize others' scores.\n    # Vasya's score S_V must be >= x.\n    # We want to find a pairing (a_i, b_j) for Vasya such that a_i + b_j >= x.\n    # We want this sum to be as small as possible, to maximize the number of people who score higher.\n    # Also, we want to maximize the scores of the other n-1 participants.\n    # The jury assigns Vasya the worst rank in case of ties. So we count people with score >= Vasya's score.\n\n    # Let's fix a score S for Vasya. S = a_k + b_l >= x.\n    # We want to find the minimum possible S.\n    # We also want to maximize the number of people who score >= S.\n    # This is a greedy approach.\n    # Sort 'a' in ascending order. Sort 'b' in ascending order.\n    # For a fixed 'a_i' that Vasya takes, he wants to pair it with the smallest 'b_j' such that a_i + b_j >= x.\n    # Let's iterate through all possible 'a_i' for Vasya.\n    # For each a_i, find the smallest b_j such that a_i + b_j >= x.\n    # This b_j can be found using binary search (bisect_left) on 'b'.\n    # If such a b_j exists, then a_i + b_j is a candidate score for Vasya.\n    # We want to pick the (a_i, b_j) pair for Vasya that results in the worst rank.\n\n    # Let's consider a specific total score S.\n    # How many participants can achieve a score of at least S?\n    # We want to find the maximum number of participants who can score >= S.\n    # This is a matching problem.\n    # For a given score S, we can find the maximum number of pairs (a_i, b_j) such that a_i + b_j >= S.\n    # This can be done by sorting 'a' and 'b'.\n    # Iterate 'a_i' from largest to smallest. For each a_i, we want to find a b_j such that a_i + b_j >= S.\n    # To maximize the number of such pairs, we use a two-pointer approach.\n    # Sort 'a' in ascending order. Sort 'b' in ascending order.\n    # Let 'a_ptr' point to the smallest element in 'a', and 'b_ptr' point to the largest element in 'b'.\n    # If a[a_ptr] + b[b_ptr] >= S, then we can form a pair. Increment count, increment a_ptr, decrement b_ptr.\n    # If a[a_ptr] + b[b_ptr] < S, then a[a_ptr] is too small to pair with b[b_ptr] to reach S.\n    # So we must try a larger 'a_i'. Increment a_ptr.\n    # This counts the maximum number of pairs that sum to at least S.\n    # This count is monotonic: if count(S) is the number of pairs >= S, then count(S+1) <= count(S).\n    # We are looking for the maximum possible value of count(S) such that S is a score Vasya could get (S >= x).\n\n    # The worst rank for Vasya is 1 + (number of people who score > Vasya's score) + (number of people who tie Vasya's score and are placed above him).\n    # Since the jury can place Vasya last among ties, this means his rank is 1 + (number of people who score > Vasya's score) + (number of people who tie Vasya's score).\n    # This is equivalent to finding the maximum number of people who can score >= Vasya's score.\n\n    # Let's find the maximum number of pairs (a_i, b_j) such that a_i + b_j >= S.\n    # This is a classic two-pointer problem on sorted arrays.\n    # `a` is sorted ascending. `b` is sorted ascending.\n    # To maximize pairs for `a_i + b_j >= S`:\n    # Iterate `a_i` from `a[0]` to `a[n-1]`. For each `a_i`, we need `b_j >= S - a_i`.\n    # We want to pick the smallest such `b_j` to leave larger `b` values for other `a`s.\n    # This is equivalent to: sort `a` and `b`.\n    # Count how many pairs (a_i, b_j) can be formed such that a_i + b_j >= S.\n    # Use `a` sorted ascending, `b` sorted descending.\n    # Two pointers: `ptr_a` for `a`, `ptr_b` for `b`.\n    # If `a[ptr_a] + b[ptr_b] >= S`, we form a pair. `ptr_a++`, `ptr_b++`, `count++`.\n    # If `a[ptr_a] + b[ptr_b] < S`, then `a[ptr_a]` is too small to form a pair with `b[ptr_b]`.\n    # We must try a larger `a`. `ptr_a++`.\n    # This logic is for finding max pairs where each element is used at most once.\n    # This works.\n\n    def count_ge_S(S, arr_a, arr_b):\n        \"\"\"\n        Counts the maximum number of pairs (a_i, b_j) such that a_i + b_j >= S.\n        arr_a and arr_b are sorted ascending.\n        \"\"\"\n        n_val = len(arr_a)\n        count = 0\n        b_ptr = n_val - 1  # Start from largest b\n        for i in range(n_val):  # Iterate through a from smallest to largest\n            while b_ptr >= 0 and arr_a[i] + arr_b[b_ptr] >= S:\n                b_ptr -= 1\n            # All b[b_ptr+1 ... n_val-1] can be paired with a[i] to satisfy sum >= S.\n            # But we can only use each b_j once.\n            # This logic is wrong. We need a proper matching.\n\n        # Correct logic for maximum pairs (a_i, b_j) with a_i + b_j >= S:\n        # Sort 'a' ascending. Sort 'b' ascending.\n        # Use two pointers: `l` for `a` (from left), `r` for `b` (from right).\n        # `l` starts at 0, `r` starts at n-1.\n        # If `a[l] + b[r] >= S`: This pair works. We take it. Increment `l`, decrement `r`, `count++`.\n        # If `a[l] + b[r] < S`: `a[l]` is too small. We must use a larger `a`. Increment `l`.\n        # This maximizes the number of pairs.\n        \n        l = 0\n        r = n_val - 1\n        current_count = 0\n        \n        temp_a = list(arr_a) # Make copies to simulate usage\n        temp_b = list(arr_b)\n\n        # To find max number of pairs (a_i, b_j) such that a_i + b_j >= S\n        # Sort A ascending, B ascending.\n        # For each a_i, we want to find a b_j such that a_i + b_j >= S.\n        # We want to maximize the number of such pairs.\n        # This is a greedy approach: for the smallest a_i, find the smallest b_j that works.\n        # This is not right. For the smallest a_i, we should find the largest b_j that works,\n        # to save smaller b_j's for larger a_i's.\n        # The correct greedy approach for maximum matching with a sum condition:\n        # Sort 'a' ascending. Sort 'b' ascending.\n        # Use two pointers, `ptr_a` for `a` (from left), `ptr_b` for `b` (from right).\n        # If `a[ptr_a] + b[ptr_b] >= S`: we can form a pair. Take `a[ptr_a]` and `b[ptr_b]`.\n        #   Increment `ptr_a`, decrement `ptr_b`, `count++`.\n        # If `a[ptr_a] + b[ptr_b] < S`: `a[ptr_a]` is too small to pair with `b[ptr_b]` (the largest remaining `b`).\n        #   So `a[ptr_a]` cannot form a pair with any remaining `b` to meet the condition.\n        #   We must discard `a[ptr_a]` and try a larger `a`. Increment `ptr_a`.\n        \n        # Wait, this logic is flawed. If a[ptr_a] + b[ptr_b] < S, it means a[ptr_a] is too small for b[ptr_b].\n        # It doesn't mean a[ptr_a] is too small for *any* remaining b.\n        # For example, a = [1, 5], b = [1, 5], S = 6.\n        # a[0]=1, b[1]=5. 1+5=6 >= S. Pair (1,5). Count=1.\n        # Remaining: a=[5], b=[1].\n        # But if we did a[0]=1, b[0]=1. 1+1 < S.\n        # This is a standard problem, maximum number of pairs (a_i, b_j) such that a_i + b_j >= S.\n        # Sort `a` and `b`.\n        # `ptr_a` from 0, `ptr_b` from n-1.\n        # If `a[ptr_a] + b[ptr_b] >= S`: `ptr_a++`, `ptr_b--`, `count++`. (This means `a[ptr_a]` is paired with `b[ptr_b]`)\n        # If `a[ptr_a] + b[ptr_b] < S`: `ptr_a++`. (This means `a[ptr_a]` cannot be paired with `b[ptr_b]` or any smaller `b` to meet S, so it must be paired with something else, or discarded.\n        # But we are trying to maximize pairs. If `a[ptr_a]` is too small for `b[ptr_b]`, then `b[ptr_b]` must be paired with some other `a` (which is larger than `a[ptr_a]`).\n        # So we should try to pair `b[ptr_b]` with a larger `a`. We decrement `ptr_b`.\n        # This is the correct logic for maximum pairs for sum >= S:\n        \n        ptr_a = 0\n        ptr_b = n_val - 1\n        current_count = 0\n        while ptr_a < n_val and ptr_b >= 0:\n            if arr_a[ptr_a] + arr_b[ptr_b] >= S:\n                current_count += 1\n                ptr_a += 1\n                ptr_b -= 1\n            else:\n                # a[ptr_a] is too small to make S with b[ptr_b].\n                # It means a[ptr_a] cannot make S with any b_k where k <= ptr_b.\n                # So a[ptr_a] cannot be used to make S with any of the remaining b's.\n                # We must use a larger a.\n                ptr_a += 1\n        return current_count\n\n    # The worst rank for Vasya is 1 + (number of people who score >= Vasya's score, excluding Vasya).\n    # We want to find a Vasya's score S_V >= x such that count_ge_S(S_V) is maximized.\n    # The possible scores range from 0 to 2*10^5.\n    # We can binary search on the number of people who score >= Vasya's score.\n    # Or, we can binary search on Vasya's score S_V.\n    # The function `count_ge_S(S, a, b)` is monotonically non-increasing with S.\n    # We want to maximize `count_ge_S(S)` subject to S >= x.\n    # The maximum value of `count_ge_S(S)` is `n`.\n    # The minimum value of `count_ge_S(S)` is `0`.\n    # Let `K` be the number of people scoring >= S. We want to maximize `K`.\n    # We are looking for the maximum `K` such that there exists an S >= x where `count_ge_S(S) = K`.\n    # And Vasya is one of those K people.\n\n    # This is slightly different. We need to pick a specific (a_i, b_j) for Vasya.\n    # Let Vasya's chosen score be S_V = a_k + b_l. We must have S_V >= x.\n    # Then the remaining n-1 participants are chosen from `a` (excluding a_k) and `b` (excluding b_l).\n    # We want to maximize the number of pairs (a_p, b_q) from remaining elements such that a_p + b_q >= S_V.\n    # The worst rank is 1 + (count of remaining people with score >= S_V).\n\n    # This seems like a difficult matching problem.\n    # Let's reconsider the problem statement: \"find two numbers — the best and the worst place Vasya could have won.\"\n    # This means we can choose any valid assignment of scores (n pairs, each a_i and b_j used once)\n    # such that Vasya's score is >= x.\n    # Then we calculate Vasya's rank based on that assignment.\n    # We want to find the minimum possible rank and maximum possible rank over all valid assignments.\n\n    # Best rank: Always 1. Vasya takes a[n-1] and b[n-1]. His score S_V = a[n-1] + b[n-1].\n    # Since there's a guaranteed pair (a_i, b_j) with sum >= x, and a[n-1]+b[n-1] is the maximum possible sum,\n    # it must be that a[n-1]+b[n-1] >= x.\n    # So Vasya can achieve the highest possible score.\n    # In case of ties, the jury can place him first. So best rank is 1.\n\n    # Worst rank:\n    # Vasya wants to be paired (a_k, b_l) such that a_k + b_l >= x.\n    # He wants this S_V = a_k + b_l to be as low as possible,\n    # AND he wants as many other participants as possible to have a score >= S_V.\n    # This is equivalent to finding the minimum S_V >= x such that `count_ge_S(S_V)` is maximized.\n    # The problem is that `count_ge_S` uses all `n` participants.\n    # If Vasya takes a_k and b_l, then `count_ge_S(S_V)` should be computed on `a` excluding a_k and `b` excluding b_l.\n    # This means we'd have to iterate through all possible (a_k, b_l) pairs for Vasya.\n    # There are n*n such pairs, too many.\n\n    # Let's re-read carefully: \"the total results' table sorts the participants by the sum of points for both tours (the first place has the participant who has got the most points). If two or more participants have got the same number of points, it's up to the jury to assign places to them according to their choice.\"\n    # \"Help Vasya's teacher, find two numbers — the best and the worst place Vasya could have won.\"\n    # This means we are trying to find the best/worst rank over ALL possible assignments of scores to participants, given that Vasya gets one of these pairs and his sum is >= x.\n\n    # Worst rank:\n    # We want to maximize the number of people who score >= Vasya.\n    # Let Vasya score S_V.\n    # We need to find an assignment of all n pairs (a_i, b_j) such that:\n    # 1. Each a_val from `a` and b_val from `b` is used exactly once.\n    # 2. One of these pairs (Vasya's pair) has sum >= x.\n    # 3. Among all such assignments, we pick one that maximizes Vasya's rank (i.e., minimizes his rank number).\n    #    No, we pick one that minimizes Vasya's rank (i.e., maximizes his rank number).\n    # And for this chosen assignment, we calculate Vasya's rank.\n    # We want to maximize 1 + (number of people with score > S_V) + (number of people with score = S_V, placed above Vasya).\n    # Since jury can place Vasya last among ties, this means we count all people with score >= S_V.\n\n    # Let's consider a target rank `k`. Can Vasya get rank `k` (or worse)?\n    # This means we need to find an assignment such that at least `k` people (including Vasya) have score >= S_V.\n    # And Vasya's score S_V must be >= x.\n\n    # The key insight for worst rank:\n    # We want to maximize the number of people who score strictly greater than Vasya,\n    # and then maximize the number of people who score equal to Vasya (and are placed above him).\n    # This is equivalent to maximizing the number of people who score >= S_V.\n    # Let Vasya's score be S_V. We need to find an assignment of n pairs such that S_V >= x,\n    # and the number of people with score >= S_V is maximized.\n    # The `count_ge_S` function counts the maximum number of pairs (a_i, b_j) such that a_i + b_j >= S.\n    # This function gives the maximum possible number of people who can score at least S, if we arrange pairings optimally.\n    # Vasya's score S_V must be one of these S's.\n    # So we want to find `max_{S >= x} count_ge_S(S, a, b)`.\n    # Let this maximum count be `K_max`.\n    # The worst rank for Vasya will be `K_max`.\n    # We need to check if `K_max` can actually be achieved.\n    # The function `count_ge_S(S, a, b)` gives the maximum number of people who can score >= S.\n    # This count includes Vasya. So if `count_ge_S(S) = K`, then Vasya is one of those K people.\n    # And the jury places him last among ties. So his rank is K.\n    # We want to find the maximum possible K, such that there exists an S >= x for which K people score >= S.\n    # The function `f(S) = count_ge_S(S, a, b)` is non-increasing.\n    # We are looking for `max_{S >= x} f(S)`.\n    # Since `f(S)` is non-increasing, `max_{S >= x} f(S)` will be `f(x)` (if S can be x).\n    # No, it should be `f(S_min)` where S_min is the smallest S >= x that can be achieved by a pair.\n    # For example, if x=10, and possible sums are {5, 6, 7, 8, 9, 11, 12}.\n    # We only care about sums >= 10. So {11, 12}.\n    # `count_ge_S(11)` could be 3, `count_ge_S(12)` could be 2.\n    # If Vasya takes 11, his rank is 3. If Vasya takes 12, his rank is 2.\n    # He wants the worst rank, so he'd pick 11.\n    # So we want to find `max_{S_V possible and S_V >= x} count_ge_S(S_V)`.\n\n    # Let's consider all possible sums `s = a[i] + b[j]`.\n    # For each such sum `s` that is >= x, calculate `count_ge_S(s, a, b)`.\n    # The maximum of these values will be the worst rank.\n    # There are n*n possible sums. This is too many.\n    # The values of `count_ge_S(S)` only change at specific `S` values (when `S` crosses an `a_i + b_j` boundary).\n    # The possible sums `a_i + b_j` range from 0 to 2*10^5.\n    # We can binary search for the optimal S.\n    # No, we want to maximize `count_ge_S(S)` for `S >= x`.\n    # This means we should choose the smallest possible S that Vasya can get such that S >= x.\n    # But this is not guaranteed to maximize the count.\n\n    # Example: a = [1, 1, 1, 1, 1], b = [1, 1, 1, 1, 1], n=5, x=2.\n    # All participants score 1+1=2.\n    # count_ge_S(2, a, b) = 5. Vasya's rank is 5.\n    # Best rank is 1. Worst rank is 5. Matches example.\n\n    # Example: n=6, x=7, a=[4,3,5,6,4,4], b=[8,6,0,4,3,4]\n    # Sorted a: [3, 4, 4, 4, 5, 6]\n    # Sorted b: [0, 3, 4, 4, 6, 8]\n\n    # Best rank: 1. (Vasya takes 6+8=14, which is >= x=7. No one can score higher. Jury places him 1st.)\n\n    # Worst rank:\n    # We need to find `max_{S_V >= x} count_ge_S(S_V, a, b)`.\n    # The range of possible scores S is [0, 2*10^5].\n    # Let's try to find the smallest S >= x for which `count_ge_S(S)` is maximized.\n    # This is not necessarily the smallest S >= x.\n    # Let `max_count = 0`.\n    # Iterate `S` from `x` to `2*10^5`.\n    # `max_count = max(max_count, count_ge_S(S, a, b))`\n    # This is too slow (2*10^5 * N).\n\n    # The function `count_ge_S(S)` is non-increasing.\n    # We are looking for `max_{S_V >= x} count_ge_S(S_V)`.\n    # This means we want to find the smallest S_V >= x such that `count_ge_S(S_V)` is maximized.\n    # Let `f(S) = count_ge_S(S)`. We want to maximize `f(S)` for `S >= x`.\n    # Since `f(S)` is non-increasing, `f(x)` is the maximum value of `f(S)` for `S >= x`.\n    # So the worst rank is simply `count_ge_S(x, a, b)`.\n    # Let's check this logic.\n    # If Vasya chooses a pair (a_k, b_l) such that a_k + b_l = S_V.\n    # We want to maximize the number of people who score >= S_V.\n    # This maximum number is given by `count_ge_S(S_V, a, b)`.\n    # Vasya can choose *any* pair (a_k, b_l) such that a_k + b_l >= x.\n    # He wants to choose one such pair that maximizes his rank (i.e., makes it as large as possible).\n    # This means he chooses S_V such that `count_ge_S(S_V, a, b)` is maximized.\n    # Since `count_ge_S(S)` is non-increasing, its maximum value for `S >= x` is achieved at the smallest possible `S` value in this range.\n    # The smallest possible `S` value that Vasya can achieve and is >= x, is not necessarily `x`.\n    # It could be `x` itself, or `x+1`, etc.\n    # However, the function `count_ge_S(S, a, b)` uses *all* `n` participants.\n    # If `count_ge_S(x, a, b)` is `K`, it means there is an arrangement of `n` pairs such that `K` pairs sum to at least `x`.\n    # Can Vasya be one of these `K` pairs? Yes.\n    # So, if Vasya picks a pair that sums to exactly `x`, and there are `K` such pairs possible (including his),\n    # then his rank is `K`.\n    # If he picks a pair that sums to `x+1`, and there are `K'` such pairs possible, his rank is `K'`.\n    # He wants to maximize this `K` or `K'`.\n    # Since `count_ge_S(S)` is non-increasing, `count_ge_S(x)` will be the maximum value among `count_ge_S(S)` for `S >= x`.\n    # So, the worst rank is indeed `count_ge_S(x, a, b)`.\n\n    worst_rank = count_ge_S(x, a, b)\n\n    sys.stdout.write(f\"{best_rank} {worst_rank}\\n\")\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 863,
        "completion_token_count": 7871,
        "thoughts_token_count": 0
    }
}