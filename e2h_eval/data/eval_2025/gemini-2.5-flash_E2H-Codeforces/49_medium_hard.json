{
    "start": 1758294892.0157506,
    "end": 1758294992.8553932,
    "start-formatted": "2025-09-20 00:14 KST",
    "end-formatted": "2025-09-20 00:16 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "**The Mushroom Strife Problem: An Expert's Approach**\n\nOkay, so I've got this competitive programming problem, \"Mushroom Strife.\"  It's a graph problem where we need to assign mushroom counts (`x_i`) to lawns (vertices) such that the given GCDs and LCMs along the roads (edges) are satisfied.  The key is to leverage the relationship: `GCD(a, b) * LCM(a, b) = a * b`.\n\nFirst, I need to check if a solution *even exists*.  If the LCM isn't divisible by the GCD for an edge, forget about it – that's a \"NO\" right there.  Then, it's about assigning values to `x_i` that are consistent with the GCDs and LCMs along the edges.\n\nSince the graph can be disconnected, I can handle each connected component separately. The trick lies in how to assign those initial values.  If I choose a value for one vertex, the values for its neighbors are *uniquely determined* by the GCD and LCM.  But, the value I pick has to satisfy the conditions for *all* its neighboring edges.\n\nLet's break it down further. For an edge, `x_u` is a multiple of the GCD and a divisor of the LCM, and  `x_v` is linked to it through `g*l` where  `x_u * x_v = g * l`. A key is that `x_u = g * k_u` and  `x_v = g * k_v` where `k_u * k_v = l/g` and `GCD(k_u, k_v) = 1`. This leads me to factor `l/g` into coprime components.\n\nA 2-coloring-like structure for the problem. For each prime `p` factor, the problem can be visualized as assigning either the exponent of `p` in the GCD or the exponent in the LCM to a vertex. Each vertex exponent depends on values from the GCD or the LCMs from its incident edges.  This means either the exponent of `x_u` is same as that of `g` or that of `l`. If there's a conflict, there's no solution.\n\nLet's try a DFS or BFS approach. I'll pick an arbitrary starting point and try assigning it the prime factors in the GCDs of its adjacent edges. I'll propagate those exponent assignments. If I hit a contradiction (i.e., a vertex would have two different valid assignments of a prime's exponent), I'll backtrack and try the other option.  This seems manageable, given the constraints.  So the main idea here is assigning exponents of the prime factors to form valid counts for the `x_i`.\n",
    "response": "The problem asks us to restore the number of mushrooms `x_i` on `n` lawns, given `m` roads. For each road between lawns `u` and `v`, we are given `G = GCD(x_u, x_v)` and `L = LCM(x_u, x_v)`. We need to output any valid assignment or report if none exists. The values `x_i`, `G`, `L` are between 1 and 10^6.\n\n**Key Mathematical Property:**\nFor any two positive integers `a` and `b`, `GCD(a, b) * LCM(a, b) = a * b`.\nLet `g = GCD(x_u, x_v)` and `l = LCM(x_u, x_v)`. Then `x_u * x_v = g * l`.\n\nA crucial property relating prime factorizations:\nFor any prime `p`, let `v_p(N)` denote the exponent of `p` in the prime factorization of `N`.\nWe know:\n1. `v_p(GCD(a, b)) = min(v_p(a), v_p(b))`\n2. `v_p(LCM(a, b)) = max(v_p(a), v_p(b))`\n\nApplying this to `x_u` and `x_v` for an edge `(u, v)` with given `g` and `l`:\n`v_p(g) = min(v_p(x_u), v_p(x_v))`\n`v_p(l) = max(v_p(x_u), v_p(x_v))`\n\nThese two conditions together imply that for each prime `p`, the pair of exponents `(v_p(x_u), v_p(x_v))` must be either `(v_p(g), v_p(l))` or `(v_p(l), v_p(g))`.\nThis is a very powerful observation. It means that for each prime `p`, and for each edge `(u, v)`, the exponents `v_p(x_u)` and `v_p(x_v)` are restricted to specific values determined by `v_p(g)` and `v_p(l)`.\n\n**Algorithm Strategy:**\n\nThe problem can be decomposed by prime factors. For each prime `p`, we need to determine `v_p(x_i)` for all `i`. Once we have all `v_p(x_i)` for all relevant primes `p`, we can reconstruct `x_i = product(p^v_p(x_i))`.\n\n1.  **Precompute Primes and Factorizations:**\n    Since `G, L <= 10^6`, `x_i` will also be `10^6`. We need primes up to `10^6`. A Sieve of Eratosthenes can precompute primes and smallest prime factors (SPF) for numbers up to `10^6`. This allows efficient factorization.\n    `v_p(N)` can be computed by repeatedly dividing `N` by `p` and counting.\n\n2.  **Collect Relevant Primes:**\n    Iterate through all `m` edges. For each `(g, l)` pair, find all prime factors of `g` and `l`. Collect these unique primes into a set `all_primes`.\n\n3.  **Solve for Each Prime Independently:**\n    For each prime `p` in `all_primes`:\n    This subproblem is a 2-coloring type problem on the graph.\n    Let `exp_values[u]` store `v_p(x_u)` for the current prime `p`. Initialize `exp_values[u] = -1` (unknown).\n    `visited[u]` will track nodes visited in the current connected component.\n    `color[u]` will be `0` or `1`, representing one of the two choices for `v_p(x_u)` on an edge.\n\n    For each vertex `u` from `1` to `n`:\n        If `visited[u]` is false:\n            Start a BFS/DFS from `u`.\n            `q = deque()`\n            `q.append(u)`\n            `visited[u] = true`\n            `color[u] = 0` (arbitrarily choose a \"color\" for the starting node)\n\n            While `q` is not empty:\n                `curr = q.popleft()`\n                For each neighbor `v` of `curr` with edge `(g, l)`:\n                    Let `g_p = v_p(g)` and `l_p = v_p(l)`.\n                    If `g_p == l_p`:\n                        // Both `v_p(x_curr)` and `v_p(x_v)` must be `g_p`.\n                        // This means `color[curr]` and `color[v]` must be \"consistent\"\n                        // with this fixed value. Let's make `color[curr] == color[v]` a requirement.\n                        // If `color[v]` is unassigned, assign `color[v] = color[curr]`.\n                        // If `color[v]` is assigned and `color[v] != color[curr]`, conflict.\n                        If `visited[v]` is false:\n                            `visited[v] = true`\n                            `color[v] = color[curr]`\n                            `q.append(v)`\n                        Else if `color[v] != color[curr]`:\n                            // Conflict detected. This prime assignment is impossible.\n                            // We need to try the other choice for the starting node `u` in this component.\n                            // Or, if this is the second choice, then no solution for this prime.\n                            // This means we need to handle backtracking/two attempts per component.\n                            // A simpler way: if `g_p == l_p`, then `v_p(x_curr)` and `v_p(x_v)` are forced.\n                            // The 2-coloring approach doesn't fit perfectly here.\n                            // Instead, let `exp_values[u]` store the actual exponent.\n                            // If `exp_values[u]` is unassigned, assign it.\n                            // If `exp_values[v]` is unassigned, assign it.\n                            // If both assigned, check consistency.\n\n    **Revised BFS/DFS for a single prime `p`:**\n    We need to handle the two cases for `(v_p(x_u), v_p(x_v))`: `(v_p(g), v_p(l))` or `(v_p(l), v_p(g))`.\n    This can be modeled as assigning a \"state\" `s_u` to each node `u` such that `s_u = 0` means `v_p(x_u)` takes the `v_p(g)` value, and `s_u = 1` means it takes the `v_p(l)` value.\n    For an edge `(u, v)` with `(g, l)`:\n    - If `v_p(g) == v_p(l)`: then `s_u` and `s_v` must both be `0` (or both `1`), and `v_p(x_u) = v_p(x_v) = v_p(g)`. This means `s_u == s_v`.\n    - If `v_p(g) != v_p(l)`: then `(v_p(x_u), v_p(x_v))` is `(v_p(g), v_p(l))` or `(v_p(l), v_p(g))`. This means `s_u != s_v`.\n\n    This is a standard 2-coloring problem.\n    Let `current_component_possible = true`.\n    For each vertex `u` from `1` to `n`:\n        If `visited_p[u]` is false:\n            `q = deque()`\n            `q.append(u)`\n            `visited_p[u] = true`\n            `color_p[u] = 0` (arbitrary initial color)\n            While `q` is not empty:\n                `curr = q.popleft()`\n                For `(v, g_val, l_val)` in `adj[curr]`:\n                    `g_p = v_p(g_val)`\n                    `l_p = v_p(l_val)`\n                    `target_color_v = color_p[curr]` if `g_p == l_p` else `1 - color_p[curr]`\n                    If `visited_p[v]` is false:\n                        `visited_p[v] = true`\n                        `color_p[v] = target_color_v`\n                        `q.append(v)`\n                    Else if `color_p[v] != target_color_v`:\n                        `current_component_possible = false`\n                        Break from inner loop.\n                If not `current_component_possible`: Break from while loop.\n            If not `current_component_possible`: Break from outer loop.\n    \n    If `current_component_possible` is false, it means this assignment of `color_p[u]=0` for the starting node `u` led to a conflict. We must try `color_p[u]=1` for the entire component.\n    So, for each connected component:\n    `try_color_0_succeeded = BFS_check(start_node, initial_color=0)`\n    If `try_color_0_succeeded`:\n        Store the `color_p` assignments.\n    Else:\n        `try_color_1_succeeded = BFS_check(start_node, initial_color=1)`\n        If `try_color_1_succeeded`:\n            Store the `color_p` assignments.\n        Else:\n            // No solution for this prime `p`. Output \"NO\".\n            `return \"NO\"`\n\n    Once `color_p` is determined for all nodes for prime `p`:\n    For each node `u`, `final_exponents[u][p]` must be determined.\n    For `u` from `1` to `n`:\n        `v_p_val_u = -1`\n        For `(v, g_val, l_val)` in `adj[u]`:\n            `g_p = v_p(g_val)`\n            `l_p = v_p(l_val)`\n            `curr_exp_u = g_p` if `color_p[u] == color_p[curr]` (from BFS) else `l_p`\n            // This is incorrect. The `color_p` determines which of `g_p` or `l_p` `v_p(x_u)` takes.\n            // If `color_p[u] == 0`, `v_p(x_u)` should be `v_p(g)` or `v_p(l)` depending on some rule.\n            // A simpler way: if `color_p[u]` is assigned, and `color_p[v]` is assigned, and `(u,v)` is an edge:\n            // if `color_p[u] == color_p[v]` means `v_p(x_u)` and `v_p(x_v)` must be `v_p(g)` and `v_p(l)` in the same \"order\".\n            // If `g_p == l_p`, then `v_p(x_u) = v_p(x_v) = g_p`.\n            // If `g_p != l_p`, then `v_p(x_u)` and `v_p(x_v)` are `g_p` and `l_p` in different order.\n\n    The 2-coloring implies that for an edge `(u, v)` with `(g, l)`:\n    - If `v_p(g) == v_p(l)`: `color_p[u]` must be equal to `color_p[v]`. And `v_p(x_u) = v_p(x_v) = v_p(g)`.\n    - If `v_p(g) != v_p(l)`: `color_p[u]` must be different from `color_p[v]`.\n        If `color_p[u] = 0`: `v_p(x_u) = v_p(g)` and `v_p(x_v) = v_p(l)`.\n        If `color_p[u] = 1`: `v_p(x_u) = v_p(l)` and `v_p(x_v) = v_p(g)`.\n\n    This means for a component, after 2-coloring, we fix `v_p(x_s)` for the starting node `s` for that component.\n    Let's say we try `v_p(x_s) = v_p(g_0)` for an arbitrary edge `(s, v_0)` incident to `s`.\n    Then `v_p(x_v0)` must be `v_p(l_0)`.\n    And so on. This is a single BFS/DFS.\n\n    **Final Refined Algorithm:**\n    1.  Precompute primes and SPF up to `MAX_VAL = 10^6`.\n    2.  `adj` list stores `(v, g, l)` for each edge.\n    3.  `ans_x[i]` will store the final `x_i` values. Initialize `ans_x[i] = 1`.\n    4.  `all_primes = set()`. For each edge `(u, v, g, l)`:\n        If `l % g != 0`, print \"NO\" and exit.\n        Add prime factors of `g` and `l` to `all_primes`.\n    5.  For each prime `p` in `all_primes`:\n        `v_p_x[u]` stores `v_p(x_u)`. Initialize `v_p_x[u] = -1` (unassigned).\n        `visited_p[u]` tracks visited nodes for prime `p`.\n        For `u` from `1` to `n`:\n            If `visited_p[u]` is false:\n                // Try two initial assignments for `v_p(x_u)` for this component.\n                // The two choices are `v_p(g)` and `v_p(l)` from an arbitrary incident edge.\n                // If `u` has no incident edges, `v_p(x_u)` can be 0.\n                \n                `start_node_val_options = set()`\n                if not adj[u]: # Isolated node\n                    start_node_val_options.add(0)\n                else:\n                    // Take the first edge incident to `u`\n                    `v0, g0, l0 = adj[u][0]`\n                    `start_node_val_options.add(v_p(g0))`\n                    `start_node_val_options.add(v_p(l0))`\n\n                `component_solved = False`\n                For `initial_val` in `start_node_val_options`:\n                    // Reset `v_p_x` and `visited_p` for current component before trying `initial_val`\n                    `temp_v_p_x = v_p_x.copy()`\n                    `temp_visited_p = visited_p.copy()`\n                    `q = deque()`\n                    `q.append(u)`\n                    `temp_visited_p[u] = True`\n                    `temp_v_p_x[u] = initial_val`\n                    `current_attempt_possible = True`\n\n                    While `q` is not empty:\n                        `curr = q.popleft()`\n                        For `(v, g_val, l_val)` in `adj[curr]`:\n                            `g_p = v_p(g_val)`\n                            `l_p = v_p(l_val)`\n                            \n                            // Check if `v_p(x_curr)` is valid for this edge\n                            If `temp_v_p_x[curr] not in {g_p, l_p}`:\n                                `current_attempt_possible = False`\n                                Break\n                            \n                            `target_v_p_x_v = g_p` if `temp_v_p_x[curr] == l_p` else `l_p`\n                            \n                            If `temp_visited_p[v]` is false:\n                                `temp_visited_p[v] = True`\n                                `temp_v_p_x[v] = target_v_p_x_v`\n                                `q.append(v)`\n                            Else if `temp_v_p_x[v] != target_v_p_x_v`:\n                                `current_attempt_possible = False`\n                                Break\n                        If not `current_attempt_possible`: Break\n\n                    If `current_attempt_possible`:\n                        // This assignment worked for the component. Copy values and mark as solved.\n                        For `node` from `1` to `n`:\n                            If `temp_visited_p[node]` and `v_p_x[node] == -1`: // Only copy for nodes within this component\n                                `v_p_x[node] = temp_v_p_x[node]`\n                            If `temp_visited_p[node]`: // Mark as visited for this prime\n                                `visited_p[node] = True`\n                        `component_solved = True`\n                        Break // From `initial_val` loop\n\n                If not `component_solved`:\n                    print(\"NO\")\n                    return\n\n        // After processing all components for prime `p`, update `ans_x`\n        For `node` from `1` to `n`:\n            If `v_p_x[node] == -1`: // Isolated node not visited for this prime, assign 0 exponent\n                `v_p_x[node] = 0`\n            `ans_x[node] *= (p ** v_p_x[node])`\n            // Check if `ans_x[node]` exceeds `10^6`\n            If `ans_x[node] > MAX_VAL`:\n                print(\"NO\")\n                return\n\n    6.  **Final Verification:**\n        For each edge `(u, v, g, l)`:\n            If `GCD(ans_x[u], ans_x[v]) != g` or `LCM(ans_x[u], ans_x[v]) != l`:\n                print(\"NO\")\n                return\n        \n        Print \"YES\" and `ans_x` values.\n\n**Optimization for `v_p(N)`:**\n`v_p(N)` can be computed by iterating `N //= p` until `N % p != 0`.\nSince primes are up to `10^6`, `p` can be `10^6`. `p**2` can exceed `10^6`.\nSPF (Smallest Prime Factor) array can speed up factorization.\n`v_p(N)` for a given `p` and `N`:\n```python\ndef get_exponent(n, p):\n    count = 0\n    while n > 0 and n % p == 0:\n        count += 1\n        n //= p\n    return count\n```\nThis is efficient enough as `log_p(N)` is small.\n\n**Max value of `x_i`:**\nIf `x_i` can be `10^6`, then `p**v_p(x_i)` contributes to `x_i`.\n`ans_x[node]` should not exceed `10^6`. This check is important.\n\n**Example of `start_node_val_options`:**\nIf `u` has edges `(u, v1, g1, l1)` and `(u, v2, g2, l2)`.\nFor prime `p`:\n`v_p(g1), v_p(l1)` and `v_p(g2), v_p(l2)`.\n`v_p(x_u)` must be in `{v_p(g1), v_p(l1)}` AND in `{v_p(g2), v_p(l2)}`.\nSo `start_node_val_options` should be `set({v_p(g1), v_p(l1)}) intersect set({v_p(g2), v_p(l2)})`.\nThis intersection might be empty, or contain one or two values.\nThis approach is more robust than picking just one edge.\n\n**Corrected `start_node_val_options`:**\nFor `u` (the starting node of a component for prime `p`):\n`possible_v_p_x_u = set()`\nIf `u` has no incident edges, `possible_v_p_x_u.add(0)`.\nElse:\n    `possible_v_p_x_u = {v_p(g_first_edge), v_p(l_first_edge)}`\n    For each other edge `(u, v, g, l)` incident to `u`:\n        `possible_v_p_x_u = possible_v_p_x_u.intersection({v_p(g), v_p(l)})`\n    If `possible_v_p_x_u` is empty, then no solution for `u` (for this prime `p`). Print \"NO\" and return.\n\nThis ensures `initial_val` is consistent with all edges incident to `u`.\n\n**GCD/LCM implementation:**\nPython's `math.gcd` is efficient.\n`LCM(a, b) = (a * b) // GCD(a, b)`. Need to handle potential overflow for `a*b` before division if numbers were larger, but here `10^6 * 10^6` is `10^12`, which fits in standard integer types.\n\n```python\nimport sys\nfrom collections import deque\nimport math\n\n# Max value for G, L, X_i\nMAX_VAL = 10**6\n\n# Precompute primes and smallest prime factors (SPF) for numbers up to MAX_VAL\nspf = [0] * (MAX_VAL + 1)\nprimes = []\n\ndef sieve():\n    for i in range(2, MAX_VAL + 1):\n        if spf[i] == 0:  # i is prime\n            spf[i] = i\n            primes.append(i)\n        for p in primes:\n            if p > spf[i] or i * p > MAX_VAL:\n                break\n            spf[i * p] = p\n\nsieve()\n\n# Function to get prime factorization (p, exponent) pairs\ndef get_prime_factorization(n):\n    factors = {}\n    if n <= 1:\n        return factors\n    temp_n = n\n    while temp_n > 1:\n        p = spf[temp_n]\n        count = 0\n        while temp_n % p == 0:\n            count += 1\n            temp_n //= p\n        factors[p] = count\n    return factors\n\n# Function to get exponent of a prime p in n\ndef get_exponent(n, p):\n    count = 0\n    if n == 0: return 0 # Special case for v_p(0) - though problem implies positive integers\n    while n > 0 and n % p == 0:\n        count += 1\n        n //= p\n    return count\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    all_edge_data = [] # Store all (u, v, g, l) for final verification\n\n    all_primes_in_map = set()\n\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        if l % g != 0:\n            print(\"NO\")\n            return\n\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l))\n        all_edge_data.append((u, v, g, l))\n\n        # Collect all prime factors from G and L\n        factors_g = get_prime_factorization(g)\n        factors_l = get_prime_factorization(l)\n        all_primes_in_map.update(factors_g.keys())\n        all_primes_in_map.update(factors_l.keys())\n    \n    # Store final x_i values\n    ans_x = [1] * (n + 1)\n\n    # Dictionary to store v_p(x_i) for each prime p and node i\n    # v_p_x_for_all_primes[p][i] = exponent of p in x_i\n    v_p_x_for_all_primes = {p: [-1] * (n + 1) for p in all_primes_in_map}\n\n    # Process each prime independently\n    for p in all_primes_in_map:\n        # v_p_x for current prime p\n        current_v_p_x = v_p_x_for_all_primes[p]\n        visited_p = [False] * (n + 1)\n\n        for u_start in range(1, n + 1):\n            if not visited_p[u_start]:\n                # Determine possible initial values for v_p(x_u_start)\n                possible_initial_vals = set()\n                if not adj[u_start]: # Isolated node\n                    possible_initial_vals.add(0)\n                else:\n                    # Start with values from the first incident edge\n                    v0, g0, l0 = adj[u_start][0]\n                    possible_initial_vals.add(get_exponent(g0, p))\n                    possible_initial_vals.add(get_exponent(l0, p))\n                    \n                    # Intersect with values from other incident edges\n                    for v_neighbor, g_val, l_val in adj[u_start]:\n                        possible_initial_vals = possible_initial_vals.intersection(\n                            {get_exponent(g_val, p), get_exponent(l_val, p)}\n                        )\n                \n                if not possible_initial_vals:\n                    # No consistent initial value for u_start for this prime\n                    print(\"NO\")\n                    return\n\n                component_solved = False\n                for initial_val in possible_initial_vals:\n                    # Attempt a BFS/DFS with this initial_val\n                    q = deque()\n                    temp_v_p_x = current_v_p_x[:] # Copy current state\n                    temp_visited_p = visited_p[:] # Copy current state\n                    \n                    q.append(u_start)\n                    temp_visited_p[u_start] = True\n                    temp_v_p_x[u_start] = initial_val\n                    \n                    current_attempt_possible = True\n\n                    while q:\n                        curr = q.popleft()\n                        \n                        # Check if current node's exponent is valid based on its edges\n                        # This check is implicitly done by how target_v_p_x_v is derived.\n                        # If temp_v_p_x[curr] is not g_p or l_p for some edge, it's already an invalid path.\n                        \n                        for v_neighbor, g_val, l_val in adj[curr]:\n                            g_p = get_exponent(g_val, p)\n                            l_p = get_exponent(l_val, p)\n\n                            # Determine the required exponent for v_neighbor\n                            # If v_p(x_curr) is g_p, then v_p(x_v_neighbor) must be l_p\n                            # If v_p(x_curr) is l_p, then v_p(x_v_neighbor) must be g_p\n                            # This is based on the (min, max) property.\n                            \n                            if temp_v_p_x[curr] == g_p:\n                                target_v_p_x_v = l_p\n                            elif temp_v_p_x[curr] == l_p:\n                                target_v_p_x_v = g_p\n                            else:\n                                # This means temp_v_p_x[curr] is inconsistent with edge (curr, v_neighbor)\n                                current_attempt_possible = False\n                                break\n\n                            if not temp_visited_p[v_neighbor]:\n                                temp_visited_p[v_neighbor] = True\n                                temp_v_p_x[v_neighbor] = target_v_p_x_v\n                                q.append(v_neighbor)\n                            elif temp_v_p_x[v_neighbor] != target_v_p_x_v:\n                                current_attempt_possible = False\n                                break\n                        \n                        if not current_attempt_possible:\n                            break # Break from while q loop\n                    \n                    if current_attempt_possible:\n                        # This attempt succeeded for the component. Copy results.\n                        for i in range(1, n + 1):\n                            if temp_visited_p[i] and not visited_p[i]: # Only copy if part of this component and not yet finalized\n                                current_v_p_x[i] = temp_v_p_x[i]\n                            if temp_visited_p[i]: # Mark as visited for this prime\n                                visited_p[i] = True\n                        component_solved = True\n                        break # Break from possible_initial_vals loop\n                \n                if not component_solved:\n                    print(\"NO\")\n                    return\n        \n        # All nodes for this prime are assigned. Update ans_x.\n        for i in range(1, n + 1):\n            if current_v_p_x[i] == -1: # Isolated node or node not involved with this prime, exponent is 0\n                current_v_p_x[i] = 0\n            \n            # Check for overflow before multiplication\n            if p != 0 and (MAX_VAL // p < ans_x[i] or MAX_VAL // (p**current_v_p_x[i]) < ans_x[i]):\n                # This check is still not perfect for p**exp potentially being large.\n                # A better check: if ans_x[i] * (p**current_v_p_x[i]) > MAX_VAL\n                # but p**current_v_p_x[i] itself can be large.\n                # A safer way is to multiply iteratively:\n                temp_val = ans_x[i]\n                for _ in range(current_v_p_x[i]):\n                    if temp_val > MAX_VAL // p:\n                        print(\"NO\")\n                        return\n                    temp_val *= p\n                ans_x[i] = temp_val\n            else:\n                ans_x[i] *= (p ** current_v_p_x[i])\n            \n            if ans_x[i] > MAX_VAL:\n                print(\"NO\")\n                return\n\n    # Final verification\n    for u, v, g, l in all_edge_data:\n        if math.gcd(ans_x[u], ans_x[v]) != g or (ans_x[u] * ans_x[v]) // math.gcd(ans_x[u], ans_x[v]) != l:\n            print(\"NO\")\n            return\n    \n    print(\"YES\")\n    print(*(ans_x[1:]))\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\nimport math\n\n# Max value for G, L, X_i\nMAX_VAL = 10**6\n\n# Precompute primes and smallest prime factors (SPF) for numbers up to MAX_VAL\nspf = [0] * (MAX_VAL + 1)\nprimes = []\n\ndef sieve():\n    for i in range(2, MAX_VAL + 1):\n        if spf[i] == 0:  # i is prime\n            spf[i] = i\n            primes.append(i)\n        for p in primes:\n            if p > spf[i] or i * p > MAX_VAL:\n                break\n            spf[i * p] = p\n\nsieve()\n\n# Function to get prime factorization (p, exponent) pairs\ndef get_prime_factorization(n):\n    factors = {}\n    if n <= 1:\n        return factors\n    temp_n = n\n    while temp_n > 1:\n        p = spf[temp_n]\n        count = 0\n        while temp_n % p == 0:\n            count += 1\n            temp_n //= p\n        factors[p] = count\n    return factors\n\n# Function to get exponent of a prime p in n\ndef get_exponent(n, p):\n    count = 0\n    if n == 0: return 0 # Special case for v_p(0) - though problem implies positive integers\n    while n > 0 and n % p == 0:\n        count += 1\n        n //= p\n    return count\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    all_edge_data = [] # Store all (u, v, g, l) for final verification\n\n    all_primes_in_map = set()\n\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        if l % g != 0:\n            print(\"NO\")\n            return\n\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l))\n        all_edge_data.append((u, v, g, l))\n\n        # Collect all prime factors from G and L\n        factors_g = get_prime_factorization(g)\n        factors_l = get_prime_factorization(l)\n        all_primes_in_map.update(factors_g.keys())\n        all_primes_in_map.update(factors_l.keys())\n    \n    # Store final x_i values\n    ans_x = [1] * (n + 1)\n\n    # Dictionary to store v_p(x_i) for each prime p and node i\n    # v_p_x_for_all_primes[p][i] = exponent of p in x_i\n    v_p_x_for_all_primes = {p: [-1] * (n + 1) for p in all_primes_in_map}\n\n    # Process each prime independently\n    for p in all_primes_in_map:\n        # v_p_x for current prime p\n        current_v_p_x = v_p_x_for_all_primes[p]\n        visited_p = [False] * (n + 1)\n\n        for u_start in range(1, n + 1):\n            if not visited_p[u_start]:\n                # Determine possible initial values for v_p(x_u_start)\n                possible_initial_vals = set()\n                if not adj[u_start]: # Isolated node\n                    possible_initial_vals.add(0)\n                else:\n                    # Start with values from the first incident edge\n                    v0, g0, l0 = adj[u_start][0]\n                    possible_initial_vals.add(get_exponent(g0, p))\n                    possible_initial_vals.add(get_exponent(l0, p))\n                    \n                    # Intersect with values from other incident edges\n                    for v_neighbor, g_val, l_val in adj[u_start]:\n                        possible_initial_vals = possible_initial_vals.intersection(\n                            {get_exponent(g_val, p), get_exponent(l_val, p)}\n                        )\n                \n                if not possible_initial_vals:\n                    # No consistent initial value for u_start for this prime\n                    print(\"NO\")\n                    return\n\n                component_solved = False\n                for initial_val in possible_initial_vals:\n                    # Attempt a BFS/DFS with this initial_val\n                    q = deque()\n                    temp_v_p_x = current_v_p_x[:] # Copy current state\n                    temp_visited_p = visited_p[:] # Copy current state\n                    \n                    q.append(u_start)\n                    temp_visited_p[u_start] = True\n                    temp_v_p_x[u_start] = initial_val\n                    \n                    current_attempt_possible = True\n\n                    while q:\n                        curr = q.popleft()\n                        \n                        # Check if current node's exponent is valid based on its edges\n                        # This check is implicitly done by how target_v_p_x_v is derived.\n                        # If temp_v_p_x[curr] is not g_p or l_p for some edge, it's already an invalid path.\n                        \n                        for v_neighbor, g_val, l_val in adj[curr]:\n                            g_p = get_exponent(g_val, p)\n                            l_p = get_exponent(l_val, p)\n\n                            # Determine the required exponent for v_neighbor\n                            # If v_p(x_curr) is g_p, then v_p(x_v_neighbor) must be l_p\n                            # If v_p(x_curr) is l_p, then v_p(x_v_neighbor) must be g_p\n                            # This is based on the (min, max) property.\n                            \n                            if temp_v_p_x[curr] == g_p:\n                                target_v_p_x_v = l_p\n                            elif temp_v_p_x[curr] == l_p:\n                                target_v_p_x_v = g_p\n                            else:\n                                # This means temp_v_p_x[curr] is inconsistent with edge (curr, v_neighbor)\n                                current_attempt_possible = False\n                                break\n\n                            if not temp_visited_p[v_neighbor]:\n                                temp_visited_p[v_neighbor] = True\n                                temp_v_p_x[v_neighbor] = target_v_p_x_v\n                                q.append(v_neighbor)\n                            elif temp_v_p_x[v_neighbor] != target_v_p_x_v:\n                                current_attempt_possible = False\n                                break\n                        \n                        if not current_attempt_possible:\n                            break # Break from while q loop\n                    \n                    if current_attempt_possible:\n                        # This attempt succeeded for the component. Copy results.\n                        for i in range(1, n + 1):\n                            if temp_visited_p[i] and not visited_p[i]: # Only copy if part of this component and not yet finalized\n                                current_v_p_x[i] = temp_v_p_x[i]\n                            if temp_visited_p[i]: # Mark as visited for this prime\n                                visited_p[i] = True\n                        component_solved = True\n                        break # Break from possible_initial_vals loop\n                \n                if not component_solved:\n                    print(\"NO\")\n                    return\n        \n        # All nodes for this prime are assigned. Update ans_x.\n        for i in range(1, n + 1):\n            if current_v_p_x[i] == -1: # Isolated node or node not involved with this prime, exponent is 0\n                current_v_p_x[i] = 0\n            \n            # Check for overflow before multiplication\n            if p != 0 and (MAX_VAL // p < ans_x[i] or MAX_VAL // (p**current_v_p_x[i]) < ans_x[i]):\n                # This check is still not perfect for p**exp potentially being large.\n                # A better check: if ans_x[i] * (p**current_v_p_x[i]) > MAX_VAL\n                # but p**current_v_p_x[i] itself can be large.\n                # A safer way is to multiply iteratively:\n                temp_val = ans_x[i]\n                for _ in range(current_v_p_x[i]):\n                    if temp_val > MAX_VAL // p:\n                        print(\"NO\")\n                        return\n                    temp_val *= p\n                ans_x[i] = temp_val\n            else:\n                ans_x[i] *= (p ** current_v_p_x[i])\n            \n            if ans_x[i] > MAX_VAL:\n                print(\"NO\")\n                return\n\n    # Final verification\n    for u, v, g, l in all_edge_data:\n        if math.gcd(ans_x[u], ans_x[v]) != g or (ans_x[u] * ans_x[v]) // math.gcd(ans_x[u], ans_x[v]) != l:\n            print(\"NO\")\n            return\n    \n    print(\"YES\")\n    print(*(ans_x[1:]))\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 551,
        "completion_token_count": 7372,
        "thoughts_token_count": 6822
    }
}