{
    "start": 1758284898.1431744,
    "end": 1758284911.059071,
    "start-formatted": "2025-09-19 21:28 KST",
    "end-formatted": "2025-09-19 21:28 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "**Neko's Maths Problem - My Approach**\n\nOkay, so I'm tackling this Neko's Maths problem, and the core of it is finding a non-negative integer `k` that minimizes the least common multiple of `a+k` and `b+k`. If there are multiple solutions, I need the smallest `k`.\n\nLet's call `x = a+k` and `y = b+k`. The goal is to minimize `lcm(x, y)`. I know `lcm(x, y) = (x * y) / gcd(x, y)`. So, minimizing the LCM is about playing with the greatest common divisor.\n\nI'll call `g = gcd(a+k, b+k)`. Since `g` divides both `a+k` and `b+k`, it *must* divide their difference, which is `b - a`. Let's say `d = b - a`. No problem if `a` and `b` are equal, `d` will be 0, and `k = 0` minimizes the LCM to `a`.\n\nIf `a` is smaller than `b`, then `d` is positive. Now, my strategy is to consider all the divisors `g` of `d`. For each divisor, I'll figure out what `k` would result in `gcd(a+k, b+k) = g`.\n\nIf `g` divides `d`, and that means `a+k` must be a multiple of `g`. That's where I can solve for `k`. `a+k = m * g`, so `k = m * g - a`. I want the smallest non-negative `k`, so I need to find the smallest integer `m` that makes `m * g >= a`. That turns out to be `m = ceil(a / g)`, but I can calculate that easily with `(a + g - 1) // g` . So, for each divisor `g`, I calculate `k = ( (a + g - 1) // g ) * g - a`.\n\nNow, for each divisor, I calculate a `k` candidate, compute the `lcm(a+k, b+k)`. I keep track of the minimum LCM seen so far, and the corresponding `k`. At the end, I'll have my optimal `k`!\n",
    "response": "```python\nimport sys\nimport math\n\ndef solve():\n    a, b = map(int, sys.stdin.readline().split())\n\n    if a == b:\n        print(0)\n        return\n\n    # Ensure a < b for consistent calculation of diff\n    if a > b:\n        a, b = b, a\n\n    diff = b - a\n\n    # Find all divisors of diff\n    divs = set()\n    for i in range(1, int(math.sqrt(diff)) + 1):\n        if diff % i == 0:\n            divs.add(i)\n            divs.add(diff // i)\n    \n    # Initialize min_lcm and best_k\n    min_lcm = float('inf')\n    best_k = -1\n\n    # Iterate through each divisor 'g' of 'diff'\n    for g in divs:\n        # We need a+k to be a multiple of g.\n        # Let a+k = C * g.\n        # k = C * g - a.\n        # Since k >= 0, C * g >= a.\n        # The smallest integer C satisfying this is ceil(a/g).\n        # In integer arithmetic, ceil(a/g) can be computed as (a + g - 1) // g.\n        # If a is already a multiple of g, this is a/g.\n        # If a is not a multiple of g, this is (a // g) + 1.\n        \n        # Calculate the smallest non-negative k for this g\n        # (a % g) gives the remainder when a is divided by g.\n        # If a % g == 0, then a is already a multiple of g. We can choose k=0.\n        # If a % g != 0, then we need to add (g - (a % g)) to 'a' to make it the next multiple of 'g'.\n        # Example: a=6, g=10. a%g=6. k = 10 - 6 = 4. a+k = 10.\n        # Example: a=6, g=8. a%g=6. k = 8 - 6 = 2. a+k = 8.\n        \n        current_k = 0\n        if a % g != 0:\n            current_k = g - (a % g)\n        \n        # Calculate the numbers x = a+k and y = b+k\n        x_val = a + current_k\n        y_val = b + current_k\n\n        # Calculate lcm(x_val, y_val)\n        # We know that gcd(x_val, y_val) must be g for this k.\n        # (x_val and y_val are both multiples of g, and their difference is diff, which is also a multiple of g)\n        # So lcm(x_val, y_val) = (x_val * y_val) / g\n        current_lcm = (x_val // g) * y_val # Avoid potential overflow with (x_val * y_val) if x_val, y_val are large\n\n        # Update min_lcm and best_k if current_lcm is smaller\n        if current_lcm < min_lcm:\n            min_lcm = current_lcm\n            best_k = current_k\n        # If current_lcm is equal to min_lcm, choose the smaller k\n        elif current_lcm == min_lcm:\n            if best_k == -1 or current_k < best_k: # best_k == -1 handles initial assignment\n                best_k = current_k\n\n    print(best_k)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\n\ndef solve():\n    a, b = map(int, sys.stdin.readline().split())\n\n    if a == b:\n        print(0)\n        return\n\n    # Ensure a < b for consistent calculation of diff\n    if a > b:\n        a, b = b, a\n\n    diff = b - a\n\n    # Find all divisors of diff\n    divs = set()\n    for i in range(1, int(math.sqrt(diff)) + 1):\n        if diff % i == 0:\n            divs.add(i)\n            divs.add(diff // i)\n    \n    # Initialize min_lcm and best_k\n    min_lcm = float('inf')\n    best_k = -1\n\n    # Iterate through each divisor 'g' of 'diff'\n    for g in divs:\n        # We need a+k to be a multiple of g.\n        # Let a+k = C * g.\n        # k = C * g - a.\n        # Since k >= 0, C * g >= a.\n        # The smallest integer C satisfying this is ceil(a/g).\n        # In integer arithmetic, ceil(a/g) can be computed as (a + g - 1) // g.\n        # If a is already a multiple of g, this is a/g.\n        # If a is not a multiple of g, this is (a // g) + 1.\n        \n        # Calculate the smallest non-negative k for this g\n        # (a % g) gives the remainder when a is divided by g.\n        # If a % g == 0, then a is already a multiple of g. We can choose k=0.\n        # If a % g != 0, then we need to add (g - (a % g)) to 'a' to make it the next multiple of 'g'.\n        # Example: a=6, g=10. a%g=6. k = 10 - 6 = 4. a+k = 10.\n        # Example: a=6, g=8. a%g=6. k = 8 - 6 = 2. a+k = 8.\n        \n        current_k = 0\n        if a % g != 0:\n            current_k = g - (a % g)\n        \n        # Calculate the numbers x = a+k and y = b+k\n        x_val = a + current_k\n        y_val = b + current_k\n\n        # Calculate lcm(x_val, y_val)\n        # We know that gcd(x_val, y_val) must be g for this k.\n        # (x_val and y_val are both multiples of g, and their difference is diff, which is also a multiple of g)\n        # So lcm(x_val, y_val) = (x_val * y_val) / g\n        current_lcm = (x_val // g) * y_val # Avoid potential overflow with (x_val * y_val) if x_val, y_val are large\n\n        # Update min_lcm and best_k if current_lcm is smaller\n        if current_lcm < min_lcm:\n            min_lcm = current_lcm\n            best_k = current_k\n        # If current_lcm is equal to min_lcm, choose the smaller k\n        elif current_lcm == min_lcm:\n            if best_k == -1 or current_k < best_k: # best_k == -1 handles initial assignment\n                best_k = current_k\n\n    print(best_k)\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 421,
        "completion_token_count": 859,
        "thoughts_token_count": 800
    }
}