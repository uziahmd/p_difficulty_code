{
    "start": 1758293721.0236487,
    "end": 1758293743.3515909,
    "start-formatted": "2025-09-19 23:55 KST",
    "end-formatted": "2025-09-19 23:55 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "",
    "response": "```python\ndef solve():\n    p = int(input())\n\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    min_nodes = float('inf')\n    max_unidirectional = -1\n\n    # Iterate through possible number of nodes `n`\n    # The maximum possible p for n nodes is n * (n-1) / 2.\n    # So, n * (n-1) / 2 >= p implies n^2 - n - 2p >= 0.\n    # For p = 2 * 10^5, n^2 approx 4 * 10^5, n approx 632.\n    # So, n can go up to around 633.\n    for n in range(2, 633):\n        # The number of pairs (u, v) with u < v that are reachable from each other\n        # is determined by the number of nodes in strongly connected components (SCCs).\n        # If an SCC has size `k`, it contributes k * (k-1) / 2 such pairs.\n        # To minimize nodes for a given `p`, we want to use as few SCCs as possible\n        # and make them as large as possible.\n        # We can achieve any `p` by having one SCC of size `k` and one SCC of size `m`\n        # such that k*(k-1)/2 + m*(m-1)/2 = p, or one SCC of size `k` and some\n        # isolated nodes, or multiple SCCs.\n        # The most efficient way to get `p` reachable pairs (u < v) is to form\n        # one large SCC and potentially one smaller SCC.\n\n        # Let's try to find k such that k*(k-1)/2 <= p.\n        # We want to maximize k.\n        k_max = 0\n        for k_val in range(1, n + 1):\n            if k_val * (k_val - 1) // 2 <= p:\n                k_max = k_val\n            else:\n                break\n\n        # Case 1: Use one SCC of size k_max and the remaining p_rem from other nodes\n        p_rem = p - k_max * (k_max - 1) // 2\n\n        # If p_rem > 0, we need to get these from other nodes.\n        # The most efficient way is to form another SCC.\n        # We need to find m such that m * (m - 1) // 2 = p_rem.\n        # If such an integer m exists, and k_max + m <= n, then this is a valid configuration.\n        # If not, we might need multiple smaller SCCs or isolated nodes.\n        # However, to minimize `n`, we always want to use as few nodes as possible\n        # to achieve `p`.\n        # The problem asks for minimum `n`, then maximum unidirectional pairs.\n\n        # We are iterating `n`, the total number of nodes.\n        # We need to find if `p` can be formed using `n` nodes.\n        # `p` is formed by sum_{i=1 to num_sccs} (s_i * (s_i - 1) / 2), where s_i is size of i-th SCC.\n        # And sum s_i <= n.\n        # To minimize `n`, we want to make s_i as large as possible.\n        # We can always form `p` by having one SCC of size `k` and another SCC of size `m`\n        # such that k*(k-1)/2 + m*(m-1)/2 = p, and k+m <= n.\n        # Or, we can have one SCC of size `k` and `p_rem` isolated nodes, where `p_rem`\n        # is formed by having `p_rem` additional nodes that form cycles of length 2.\n        # This is not how it works. `p` is the total sum.\n\n        # Let's find the largest k such that k*(k-1)/2 <= p.\n        # This k is the size of our primary SCC.\n        # The remaining `p_rem = p - k*(k-1)/2` must be formed by other nodes.\n        # These `p_rem` pairs must be formed by pairs (u, v) with u < v.\n        # This means we need `p_rem` additional nodes that are part of 2-cycles with some other nodes.\n        # Or, we can form another SCC.\n        # The most efficient way to get `p_rem` pairs is to form a 2-cycle.\n        # For example, if we need 1 pair, we can use two nodes `x, y` and have edges `x->y` and `y->x`.\n        # This forms an SCC of size 2. It uses 2 nodes and contributes 1 pair.\n        # So, if p_rem > 0, we need p_rem additional nodes to form 2-cycles.\n        # Each 2-cycle requires 2 nodes and contributes 1 pair.\n        # This means we need 2 * p_rem nodes to form p_rem pairs this way.\n        # This is not right. We can use a single node for multiple 2-cycles.\n        # Example: 3 nodes (1,2,3). (1,2) reachable both ways, (1,3) reachable both ways, (2,3) reachable both ways.\n        # This means 1,2,3 are all in the same SCC. This gives 3 pairs for 3 nodes.\n\n        # Let's re-evaluate how `p` pairs are formed.\n        # `p` is the count of (u, v) with u < v where u and v are reachable from each other.\n        # This means u and v must be in the same SCC.\n        # If an SCC has size `s`, it contributes `s * (s - 1) / 2` such pairs.\n        # Let the SCCs have sizes `s_1, s_2, ..., s_m`.\n        # Then `p = sum(s_i * (s_i - 1) / 2)`.\n        # The total number of nodes used is `sum(s_i) + isolated_nodes`.\n        # To minimize total nodes, we want to maximize `s_i` for each `p_i`.\n        # We want to find `s_1, s_2, ..., s_m` such that `sum(s_i * (s_i - 1) / 2) = p`\n        # and `sum(s_i)` is minimized.\n\n        # Greedily, we find the largest `k` such that `k * (k - 1) / 2 <= p`.\n        # This `k` will be the size of our largest SCC.\n        # Let `p_k = k * (k - 1) / 2`.\n        # We then need to form `p - p_k` additional pairs.\n        # We can recursively apply this.\n        # Let `k_0` be the largest integer such that `k_0 * (k_0 - 1) / 2 <= p`.\n        # We form an SCC of size `k_0`. This uses `k_0` nodes and contributes `k_0 * (k_0 - 1) / 2` pairs.\n        # Remaining pairs needed: `p_rem = p - k_0 * (k_0 - 1) / 2`.\n        # We then find the largest `k_1` such that `k_1 * (k_1 - 1) / 2 <= p_rem`.\n        # We form an SCC of size `k_1`. This uses `k_1` nodes and contributes `k_1 * (k_1 - 1) / 2` pairs.\n        # We continue this until `p_rem` becomes 0.\n        # The total number of nodes used will be `k_0 + k_1 + ... + k_m`.\n        # This strategy minimizes the number of nodes required to achieve `p`.\n\n        current_p = p\n        scc_sizes = []\n        nodes_used_for_sccs = 0\n\n        while current_p > 0:\n            k = 0\n            # Find largest k such that k*(k-1)/2 <= current_p\n            # k*(k-1)/2 = x => k^2 - k - 2x = 0 => k = (1 + sqrt(1 + 8x)) / 2\n            # We need floor of this k.\n            # Max k for p=2e5 is approx 632.\n            # So, k_val goes up to 632.\n            for k_val in range(1, 633): # k_val can't exceed 632 for p=2e5\n                if k_val * (k_val - 1) // 2 <= current_p:\n                    k = k_val\n                else:\n                    break\n            \n            if k == 0: # This should not happen if current_p > 0\n                break\n\n            scc_sizes.append(k)\n            nodes_used_for_sccs += k\n            current_p -= k * (k - 1) // 2\n\n        # The minimum number of nodes for `p` is `nodes_used_for_sccs`.\n        # Let this be `N_min`.\n        # Now we need to calculate the maximum unidirectional pairs for `N_min` nodes.\n\n        # A graph with `N_min` nodes and SCCs of sizes `s_1, ..., s_m` (as calculated above)\n        # will have `p` reachable pairs (u < v).\n        # To maximize unidirectional pairs:\n        # A unidirectional pair (u, v) means u -> v but not v -> u.\n        # This means u and v are in different SCCs, and there's a path from u's SCC to v's SCC.\n        # If we have `m` SCCs of sizes `s_1, ..., s_m`, and we arrange them in a line:\n        # SCC_1 -> SCC_2 -> ... -> SCC_m.\n        # For any u in SCC_i and v in SCC_j where i < j, there is a path u -> v.\n        # But there is no path v -> u.\n        # The number of such pairs (u, v) is `s_i * s_j`.\n        # Total unidirectional pairs = sum_{1 <= i < j <= m} (s_i * s_j).\n        # This is `(sum(s_i))^2 - sum(s_i^2)` / 2.\n        # Or, `(sum(s_i) * sum(s_i) - sum(s_i * s_i)) / 2`.\n        # This is the formula for number of edges in a complete graph where nodes are SCCs.\n        # No, it's `sum_{1 <= i < j <= m} (s_i * s_j)`.\n        # This is equivalent to `(Total_nodes_in_sccs^2 - sum(s_i^2)) / 2`.\n        # Let `S = sum(s_i)`. Then `S^2 = (s_1 + ... + s_m)^2 = sum(s_i^2) + 2 * sum_{i<j} (s_i * s_j)`.\n        # So, `sum_{i<j} (s_i * s_j) = (S^2 - sum(s_i^2)) / 2`.\n\n        N_min_current = nodes_used_for_sccs\n        \n        sum_s_i = N_min_current\n        sum_s_i_squared = sum(s * s for s in scc_sizes)\n        unidirectional_pairs = (sum_s_i * sum_s_i - sum_s_i_squared) // 2\n\n        # We found the minimum nodes for `p` and the maximum unidirectional pairs.\n        # This is the answer.\n        print(N_min_current, unidirectional_pairs)\n        return\n\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "def solve():\n    p = int(input())\n\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    min_nodes = float('inf')\n    max_unidirectional = -1\n\n    # Iterate through possible number of nodes `n`\n    # The maximum possible p for n nodes is n * (n-1) / 2.\n    # So, n * (n-1) / 2 >= p implies n^2 - n - 2p >= 0.\n    # For p = 2 * 10^5, n^2 approx 4 * 10^5, n approx 632.\n    # So, n can go up to around 633.\n    for n in range(2, 633):\n        # The number of pairs (u, v) with u < v that are reachable from each other\n        # is determined by the number of nodes in strongly connected components (SCCs).\n        # If an SCC has size `k`, it contributes k * (k-1) / 2 such pairs.\n        # To minimize nodes for a given `p`, we want to use as few SCCs as possible\n        # and make them as large as possible.\n        # We can achieve any `p` by having one SCC of size `k` and one SCC of size `m`\n        # such that k*(k-1)/2 + m*(m-1)/2 = p, or one SCC of size `k` and some\n        # isolated nodes, or multiple SCCs.\n        # The most efficient way to get `p` reachable pairs (u < v) is to form\n        # one large SCC and potentially one smaller SCC.\n\n        # Let's try to find k such that k*(k-1)/2 <= p.\n        # We want to maximize k.\n        k_max = 0\n        for k_val in range(1, n + 1):\n            if k_val * (k_val - 1) // 2 <= p:\n                k_max = k_val\n            else:\n                break\n\n        # Case 1: Use one SCC of size k_max and the remaining p_rem from other nodes\n        p_rem = p - k_max * (k_max - 1) // 2\n\n        # If p_rem > 0, we need to get these from other nodes.\n        # The most efficient way is to form another SCC.\n        # We need to find m such that m * (m - 1) // 2 = p_rem.\n        # If such an integer m exists, and k_max + m <= n, then this is a valid configuration.\n        # If not, we might need multiple smaller SCCs or isolated nodes.\n        # However, to minimize `n`, we always want to use as few nodes as possible\n        # to achieve `p`.\n        # The problem asks for minimum `n`, then maximum unidirectional pairs.\n\n        # We are iterating `n`, the total number of nodes.\n        # We need to find if `p` can be formed using `n` nodes.\n        # `p` is formed by sum_{i=1 to num_sccs} (s_i * (s_i - 1) / 2), where s_i is size of i-th SCC.\n        # And sum s_i <= n.\n        # To minimize `n`, we want to make s_i as large as possible.\n        # We can always form `p` by having one SCC of size `k` and another SCC of size `m`\n        # such that k*(k-1)/2 + m*(m-1)/2 = p, and k+m <= n.\n        # Or, we can have one SCC of size `k` and `p_rem` isolated nodes, where `p_rem`\n        # is formed by having `p_rem` additional nodes that form cycles of length 2.\n        # This is not how it works. `p` is the total sum.\n\n        # Let's find the largest k such that k*(k-1)/2 <= p.\n        # This k is the size of our primary SCC.\n        # The remaining `p_rem = p - k*(k-1)/2` must be formed by other nodes.\n        # These `p_rem` pairs must be formed by pairs (u, v) with u < v.\n        # This means we need `p_rem` additional nodes that are part of 2-cycles with some other nodes.\n        # Or, we can form another SCC.\n        # The most efficient way to get `p_rem` pairs is to form a 2-cycle.\n        # For example, if we need 1 pair, we can use two nodes `x, y` and have edges `x->y` and `y->x`.\n        # This forms an SCC of size 2. It uses 2 nodes and contributes 1 pair.\n        # So, if p_rem > 0, we need p_rem additional nodes to form 2-cycles.\n        # Each 2-cycle requires 2 nodes and contributes 1 pair.\n        # This means we need 2 * p_rem nodes to form p_rem pairs this way.\n        # This is not right. We can use a single node for multiple 2-cycles.\n        # Example: 3 nodes (1,2,3). (1,2) reachable both ways, (1,3) reachable both ways, (2,3) reachable both ways.\n        # This means 1,2,3 are all in the same SCC. This gives 3 pairs for 3 nodes.\n\n        # Let's re-evaluate how `p` pairs are formed.\n        # `p` is the count of (u, v) with u < v where u and v are reachable from each other.\n        # This means u and v must be in the same SCC.\n        # If an SCC has size `s`, it contributes `s * (s - 1) / 2` such pairs.\n        # Let the SCCs have sizes `s_1, s_2, ..., s_m`.\n        # Then `p = sum(s_i * (s_i - 1) / 2)`.\n        # The total number of nodes used is `sum(s_i) + isolated_nodes`.\n        # To minimize total nodes, we want to maximize `s_i` for each `p_i`.\n        # We want to find `s_1, s_2, ..., s_m` such that `sum(s_i * (s_i - 1) / 2) = p`\n        # and `sum(s_i)` is minimized.\n\n        # Greedily, we find the largest `k` such that `k * (k - 1) / 2 <= p`.\n        # This `k` will be the size of our largest SCC.\n        # Let `p_k = k * (k - 1) / 2`.\n        # We then need to form `p - p_k` additional pairs.\n        # We can recursively apply this.\n        # Let `k_0` be the largest integer such that `k_0 * (k_0 - 1) / 2 <= p`.\n        # We form an SCC of size `k_0`. This uses `k_0` nodes and contributes `k_0 * (k_0 - 1) / 2` pairs.\n        # Remaining pairs needed: `p_rem = p - k_0 * (k_0 - 1) / 2`.\n        # We then find the largest `k_1` such that `k_1 * (k_1 - 1) / 2 <= p_rem`.\n        # We form an SCC of size `k_1`. This uses `k_1` nodes and contributes `k_1 * (k_1 - 1) / 2` pairs.\n        # We continue this until `p_rem` becomes 0.\n        # The total number of nodes used will be `k_0 + k_1 + ... + k_m`.\n        # This strategy minimizes the number of nodes required to achieve `p`.\n\n        current_p = p\n        scc_sizes = []\n        nodes_used_for_sccs = 0\n\n        while current_p > 0:\n            k = 0\n            # Find largest k such that k*(k-1)/2 <= current_p\n            # k*(k-1)/2 = x => k^2 - k - 2x = 0 => k = (1 + sqrt(1 + 8x)) / 2\n            # We need floor of this k.\n            # Max k for p=2e5 is approx 632.\n            # So, k_val goes up to 632.\n            for k_val in range(1, 633): # k_val can't exceed 632 for p=2e5\n                if k_val * (k_val - 1) // 2 <= current_p:\n                    k = k_val\n                else:\n                    break\n            \n            if k == 0: # This should not happen if current_p > 0\n                break\n\n            scc_sizes.append(k)\n            nodes_used_for_sccs += k\n            current_p -= k * (k - 1) // 2\n\n        # The minimum number of nodes for `p` is `nodes_used_for_sccs`.\n        # Let this be `N_min`.\n        # Now we need to calculate the maximum unidirectional pairs for `N_min` nodes.\n\n        # A graph with `N_min` nodes and SCCs of sizes `s_1, ..., s_m` (as calculated above)\n        # will have `p` reachable pairs (u < v).\n        # To maximize unidirectional pairs:\n        # A unidirectional pair (u, v) means u -> v but not v -> u.\n        # This means u and v are in different SCCs, and there's a path from u's SCC to v's SCC.\n        # If we have `m` SCCs of sizes `s_1, ..., s_m`, and we arrange them in a line:\n        # SCC_1 -> SCC_2 -> ... -> SCC_m.\n        # For any u in SCC_i and v in SCC_j where i < j, there is a path u -> v.\n        # But there is no path v -> u.\n        # The number of such pairs (u, v) is `s_i * s_j`.\n        # Total unidirectional pairs = sum_{1 <= i < j <= m} (s_i * s_j).\n        # This is `(sum(s_i))^2 - sum(s_i^2)` / 2.\n        # Or, `(sum(s_i) * sum(s_i) - sum(s_i * s_i)) / 2`.\n        # This is the formula for number of edges in a complete graph where nodes are SCCs.\n        # No, it's `sum_{1 <= i < j <= m} (s_i * s_j)`.\n        # This is equivalent to `(Total_nodes_in_sccs^2 - sum(s_i^2)) / 2`.\n        # Let `S = sum(s_i)`. Then `S^2 = (s_1 + ... + s_m)^2 = sum(s_i^2) + 2 * sum_{i<j} (s_i * s_j)`.\n        # So, `sum_{i<j} (s_i * s_j) = (S^2 - sum(s_i^2)) / 2`.\n\n        N_min_current = nodes_used_for_sccs\n        \n        sum_s_i = N_min_current\n        sum_s_i_squared = sum(s * s for s in scc_sizes)\n        unidirectional_pairs = (sum_s_i * sum_s_i - sum_s_i_squared) // 2\n\n        # We found the minimum nodes for `p` and the maximum unidirectional pairs.\n        # This is the answer.\n        print(N_min_current, unidirectional_pairs)\n        return\n\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 482,
        "completion_token_count": 2825,
        "thoughts_token_count": 0
    }
}