{
    "start": 1758015868.1368272,
    "end": 1758015950.3042047,
    "start-formatted": "2025-09-16 18:44 KST",
    "end-formatted": "2025-09-16 18:45 KST",
    "gpu": 2,
    "pid": 8,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "**Okay, here's my plan to tackle the \"Flawed Flow\" problem.**  My initial thoughts are centered around understanding the constraints and figuring out the core algorithmic approach.  It's clear we're dealing with a directed graph, with flow conservation at each intermediate node.  A key challenge is the acyclicity requirement – that's a big clue about using a topological sort or some form of traversal to build the graph correctly.\n\nThe input tells me I've got a connected, undirected graph with flow volumes on the edges. The output needs to provide the direction of each edge.  The most important conditions, besides conservation and no cycles, are the special cases for the source (node 1) and the (implicit) sink (node n).\n\nMy thinking goes like this: since source node 1 has no incoming edges, it *must* be the starting point.  Any traversal I use must start from there. Also, since there are no cycles, the edges have to follow some sort of logical ordering from start to end (sink). I'm strongly leaning towards an algorithm with a BFS (breadth-first search) or DFS (depth-first search) structure, because this can help ensure there aren't any cycles, and the initial source is handled properly.  I'm thinking about tracking the balance of flow for each vertex – how much flow comes in vs. goes out. This balance should eventually be zero for all nodes except maybe the source and sink.\n\nHere's the approach I'm considering: I need to maintain this balance idea. As I traverse the graph, I'll direct edges and adjust the in/out flow balance. I'll need to use a queue of \"ready\" nodes – nodes that I can fully determine the direction of all incident edges. A node becomes ready when it either has only one undirected edge remaining, or when the current incoming flow matches its required incoming flow.\n\nSo, here's what the algorithm might look like: start with node 1 and direct all of its edges outwards, then iteratively add nodes to the queue based on the direction of their edges. At some point the edges to sink node n get decided. The key here is not to create any cycles.\n\nI'm feeling confident, because the problem guarantees a solution. That is a huge hint. This means I'm not going to be in a situation where I need to backtrack or consider all possible combinations. The algorithm I'm formulating will provide the optimal directions. Let's get coding!\n",
    "response": "The problem asks us to direct the flow for each edge in a given undirected graph, along with its flow volume, such that several conditions are met:\n1.  **Flow Conservation**: For any intermediate vertex `v` (1 < `v` < `n`), the sum of flow volumes on incoming edges equals the sum of flow volumes on outgoing edges.\n2.  **Source Condition**: Vertex 1 (the source) has no incoming edges.\n3.  **Acyclicity**: The resulting directed graph must not contain any cycles.\n\nWe are guaranteed that a solution always exists.\n\nLet's analyze the conditions:\n*   **Flow Conservation for `1 < v < n`**: If `TotalFlow(v)` is the sum of flow volumes of all edges incident to `v`, then for flow conservation, the incoming flow must be `TotalFlow(v) / 2`, and the outgoing flow must also be `TotalFlow(v) / 2`. This implies `TotalFlow(v)` must be an even number. Since a solution is guaranteed, this will always hold.\n*   **Source Condition for `v = 1`**: All edges incident to vertex 1 must be directed away from it.\n*   **Acyclicity**: This is a strong constraint. It implies that there exists a topological ordering of the vertices.\n\nWe can solve this problem using a modified Breadth-First Search (BFS) or a queue-based approach similar to Kahn's algorithm for topological sort. The core idea is to identify vertices whose edge directions can be uniquely determined and then propagate these decisions.\n\nLet's maintain the following for each vertex `v`:\n*   `total_incident_flow[v]`: The sum of flow volumes of all edges connected to `v`. This can be pre-calculated.\n*   `current_in_flow[v]`: The sum of flow volumes of edges already directed *into* `v`. Initially 0.\n*   `num_undirected_edges[v]`: The number of edges incident to `v` that have not yet been directed. Initially, this is the degree of `v`.\n\nThe target incoming flow for an intermediate vertex `v` (1 < `v` < `n`) is `total_incident_flow[v] / 2`. For vertex 1, the target incoming flow is 0. Vertex `n` (the sink) doesn't have a strict flow conservation rule or incoming flow target from the problem statement, but its edges will be determined by its neighbors.\n\n**Algorithm Steps:**\n\n1.  **Initialization**:\n    *   Store the graph using an adjacency list `adj[u]` where each entry is `(v, c, edge_idx)`. `edge_idx` is the original 0-indexed position of the edge in the input.\n    *   Store the original `(u, v, c)` for each edge in `edges_info` to easily retrieve endpoints later.\n    *   Initialize `total_incident_flow[v]` for all `v` by summing `c` for all incident edges.\n    *   Initialize `current_in_flow[v] = 0` for all `v`.\n    *   Initialize `num_undirected_edges[v]` to `degree[v]` for all `v`.\n    *   Initialize `ans[edge_idx] = -1` for all edges (indicating undirected).\n    *   Create a deque `q`.\n\n2.  **Seed the Queue**:\n    *   For `v` from 1 to `n`:\n        *   If `v == 1`: Add `v` to `q`. Vertex 1 must send all flow out.\n        *   If `v > 1` and `v < n`: If `num_undirected_edges[v] == 1`, add `v` to `q`. If a vertex has only one undirected edge left, its direction is uniquely determined (either it must be incoming to meet `total_incident_flow[v] / 2` or outgoing if `current_in_flow[v]` already met the target).\n\n3.  **BFS Traversal**:\n    *   While `q` is not empty:\n        *   Dequeue a vertex `u`.\n        *   Iterate through all neighbors `v` of `u` via edge `(u, v, c)` with original index `edge_idx`:\n            *   If `ans[edge_idx]` is not -1, this edge has already been directed, so skip it.\n            *   **Direct the edge `(u, v)`**:\n                *   If `u == 1`: The edge must be `u -> v`. Set `ans[edge_idx] = 0`.\n                *   If `u > 1` and `u < n`:\n                    *   If `current_in_flow[u] == total_incident_flow[u] / 2`: Vertex `u` has received all its required incoming flow. This edge `(u, v)` must be outgoing from `u`. Set `ans[edge_idx] = 0`.\n                    *   Else (`current_in_flow[u] < total_incident_flow[u] / 2`): This edge `(u, v)` must be incoming to `u` to fulfill its requirement. Set `ans[edge_idx] = 1`.\n                *   If `u == n`: This case should ideally not be reached if `n` is a pure sink. However, if `n` is processed, it means its neighbors have determined its edges.\n                    *   The problem states \"vertex with number 1 has no incoming edges\". It doesn't put a similar constraint on `n`. The \"no cycles\" condition combined with `1` being a source implies `n` is topologically later than `1`.\n                    *   In the context of max-flow, `n` is typically a sink. If `u` is `n`, and it's being processed, it implies the other endpoint `v` is the one determining the direction.\n                    *   A more robust approach for `u == n` is to ensure `v -> n`. This is equivalent to saying `n` receives all flow. So `ans[edge_idx] = 1`.\n                    *   However, the logic for `1 < v < n` and `num_undirected_edges[v] == 1` should naturally handle edges to `n` as well.\n                    *   Let's stick to the rule: if `u` is processed, and `ans[edge_idx]` is -1, it means `u` is dictating the direction.\n                    *   The most general rule that works is: if `u` is processed, and it has `num_undirected_edges[u] == 1`, it means `u` is the one whose balance is being finalized.\n                    *   If `u` is the one whose direction is being decided, and `current_in_flow[u]` is less than `total_incident_flow[u] / 2` (or `0` for `u=1`), then the edge `(u,v)` must be `v -> u`. Otherwise, it must be `u -> v`.\n                    *   Let's use `is_u_source_like = (current_in_flow[u] == target_in_flow_for_u)` where `target_in_flow_for_u = (0 if u == 1 else total_incident_flow[u] / 2)`.\n                    *   If `is_u_source_like` is true, direct `u -> v` (`ans[edge_idx] = 0`).\n                    *   Else, direct `v -> u` (`ans[edge_idx] = 1`).\n\n            *   After directing `(u, v)`:\n                *   If `ans[edge_idx] == 0` (flow `u -> v`): `current_in_flow[v] += c`.\n                *   If `ans[edge_idx] == 1` (flow `v -> u`): `current_in_flow[u] += c`.\n                *   Decrement `num_undirected_edges[u]` and `num_undirected_edges[v]`.\n                *   **Check `v` for readiness**:\n                    *   If `v == 1`: No action needed, it's already processed.\n                    *   If `v == n`: No action needed immediately, it's processed implicitly.\n                    *   If `v > 1` and `v < n`: If `num_undirected_edges[v] == 1`, add `v` to `q`.\n                    *   Also, if `num_undirected_edges[v] == 0` and `v` is an intermediate node, `current_in_flow[v]` must equal `total_incident_flow[v] / 2`. This is a check for correctness, not for adding to queue.\n\nThe crucial part is that `u` is only dequeued if its `num_undirected_edges[u]` becomes 1 (for intermediate nodes) or if it's node 1. This ensures that when we process `u`, we have enough information to make a decision about its last undirected edge.\nIf `u` is `1`, it always sends flow out.\nIf `u` is an intermediate node and `num_undirected_edges[u] == 1`, it means we are processing its *last* undirected edge. We know `current_in_flow[u]` from already directed edges.\n    *   If `current_in_flow[u]` is already `total_incident_flow[u] / 2`, the last edge must be outgoing.\n    *   If `current_in_flow[u]` is less than `total_incident_flow[u] / 2`, the last edge must be incoming to make up the difference. Since `total_incident_flow[u]` is even, and `current_in_flow[u]` is a sum of integers, the remaining flow needed (`total_incident_flow[u] / 2 - current_in_flow[u]`) must be exactly the flow `c` of the last undirected edge.\n\nThe sink `n` is special. It doesn't have a flow conservation rule. Its edges will be directed when its neighbors are processed. Since the graph is connected and a solution exists, all edges will eventually be directed.\n\nExample Walkthrough:\nLet's consider an intermediate node `v` (1 < `v` < `n`).\nSuppose `total_incident_flow[v] = 10`. So `v` needs 5 units of incoming flow.\nInitially `current_in_flow[v] = 0`.\nSuppose `v` has 3 edges: `(v, a, 3)`, `(v, b, 2)`, `(v, c, 5)`. `num_undirected_edges[v] = 3`.\nSuppose `a` is processed and directs `a -> v` with 3 flow. `current_in_flow[v] = 3`. `num_undirected_edges[v] = 2`.\nSuppose `b` is processed and directs `b -> v` with 2 flow. `current_in_flow[v] = 5`. `num_undirected_edges[v] = 1`.\nNow `num_undirected_edges[v] == 1`, so `v` is added to `q`.\nWhen `v` is dequeued, its last undirected edge is `(v, c, 5)`.\n`current_in_flow[v] = 5`, `total_incident_flow[v] / 2 = 5`.\nSince `current_in_flow[v] == total_incident_flow[v] / 2`, the edge `(v, c)` must be outgoing: `v -> c`.\n`ans[edge_idx_vc] = 0`. `num_undirected_edges[v]` becomes 0. `current_in_flow[c]` increases by 5.\n\nThis logic correctly handles intermediate nodes. For node 1, all edges are outgoing. For node `n`, its edges will be determined by its neighbors' flow conservation rules or by node 1.\n\n```python\nimport sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    # Store edges info: (u, v, c) for original edge index\n    # Note: vertices are 1-indexed in input, convert to 0-indexed for convenience\n    # Store original (u, v, c) to reconstruct direction later\n    edges_info = [] \n    \n    # Adjacency list: adj[u] stores list of (v, c, edge_idx)\n    adj = [[] for _ in range(n + 1)] \n    \n    # total_incident_flow[v]: sum of flow capacities of all edges incident to v\n    total_incident_flow = [0] * (n + 1)\n    \n    # num_undirected_edges[v]: count of edges incident to v that are not yet directed\n    num_undirected_edges = [0] * (n + 1)\n\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        edges_info.append((u, v, c))\n        \n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n        \n        total_incident_flow[u] += c\n        total_incident_flow[v] += c\n        \n        num_undirected_edges[u] += 1\n        num_undirected_edges[v] += 1\n\n    # ans[edge_idx]: 0 if u -> v, 1 if v -> u (where (u,v) is the original edge from edges_info)\n    ans = [-1] * m \n    \n    # current_in_flow[v]: current sum of flow directed *into* v\n    current_in_flow = [0] * (n + 1)\n    \n    q = deque()\n\n    # Initialize queue with nodes whose last edge direction can be determined\n    for v in range(1, n + 1):\n        if v == 1:\n            q.append(v)\n        elif v != n and num_undirected_edges[v] == 1:\n            q.append(v)\n            \n    # The actual target incoming flow for intermediate nodes\n    # For node 1, it's 0 (no incoming). For node n, it's not strictly defined by conservation.\n    # For 1 < v < n, it's total_incident_flow[v] / 2.\n    target_in_flow = [0] * (n + 1)\n    for v in range(2, n): # Only for intermediate nodes\n        target_in_flow[v] = total_incident_flow[v] // 2\n\n    while q:\n        u = q.popleft()\n\n        # Iterate through neighbors of u\n        for v_neighbor, c_flow, edge_idx in adj[u]:\n            if ans[edge_idx] != -1: # Edge already directed\n                continue\n\n            # Determine direction of edge (u, v_neighbor) with flow c_flow\n            # Original edge endpoints are stored in edges_info[edge_idx]\n            original_u, original_v, _ = edges_info[edge_idx]\n\n            # Decide if flow is u -> v_neighbor or v_neighbor -> u\n            # This logic must be robust to ensure acyclicity and flow conservation.\n            # The key insight is that when a node `u` is processed from the queue,\n            # either it's the source (1), or it's an intermediate node (1 < u < n) with only one undirected edge left.\n            # If u is the source (1), all its edges must be outgoing.\n            # If u is an intermediate node (1 < u < n) with one undirected edge left:\n            #   - If current_in_flow[u] is already target_in_flow[u], the last edge must be outgoing from u.\n            #   - Otherwise, the last edge must be incoming to u to meet the target.\n            \n            # For node 'u', its 'target_balance' is 'target_in_flow[u]'.\n            # If 'current_in_flow[u]' has already reached 'target_in_flow[u]', then 'u' must send flow out.\n            # Otherwise, 'u' must receive flow in.\n            \n            # Special case for node 1: all edges must be outgoing.\n            if u == 1:\n                # Flow is u -> v_neighbor\n                ans[edge_idx] = 0 if original_u == u else 1\n            elif current_in_flow[u] < target_in_flow[u]:\n                # u needs more incoming flow, so this edge must be v_neighbor -> u\n                ans[edge_idx] = 1 if original_u == u else 0\n            else: # current_in_flow[u] == target_in_flow[u]\n                # u has enough incoming flow, so this edge must be u -> v_neighbor\n                ans[edge_idx] = 0 if original_u == u else 1\n\n            # Update current_in_flow for the receiving vertex\n            if ans[edge_idx] == 0: # Flow is original_u -> original_v\n                current_in_flow[original_v] += c_flow\n            else: # Flow is original_v -> original_u\n                current_in_flow[original_u] += c_flow\n\n            # Decrement undirected edge counts for both endpoints\n            num_undirected_edges[u] -= 1\n            num_undirected_edges[v_neighbor] -= 1\n\n            # Add v_neighbor to queue if it's ready\n            if v_neighbor != 1 and v_neighbor != n and num_undirected_edges[v_neighbor] == 1:\n                q.append(v_neighbor)\n            # If v_neighbor is n and it has only one undirected edge left, it might be added.\n            # However, the logic for intermediate nodes (1 < v < n) is sufficient\n            # because edges connected to n will eventually be the last undirected edge for some intermediate node.\n\n    # Output results\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + '\\n')\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    # Store edges info: (u, v, c) for original edge index\n    # Note: vertices are 1-indexed in input, convert to 0-indexed for convenience\n    # Store original (u, v, c) to reconstruct direction later\n    edges_info = [] \n    \n    # Adjacency list: adj[u] stores list of (v, c, edge_idx)\n    adj = [[] for _ in range(n + 1)] \n    \n    # total_incident_flow[v]: sum of flow capacities of all edges incident to v\n    total_incident_flow = [0] * (n + 1)\n    \n    # num_undirected_edges[v]: count of edges incident to v that are not yet directed\n    num_undirected_edges = [0] * (n + 1)\n\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        edges_info.append((u, v, c))\n        \n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n        \n        total_incident_flow[u] += c\n        total_incident_flow[v] += c\n        \n        num_undirected_edges[u] += 1\n        num_undirected_edges[v] += 1\n\n    # ans[edge_idx]: 0 if u -> v, 1 if v -> u (where (u,v) is the original edge from edges_info)\n    ans = [-1] * m \n    \n    # current_in_flow[v]: current sum of flow directed *into* v\n    current_in_flow = [0] * (n + 1)\n    \n    q = deque()\n\n    # Initialize queue with nodes whose last edge direction can be determined\n    for v in range(1, n + 1):\n        if v == 1:\n            q.append(v)\n        elif v != n and num_undirected_edges[v] == 1:\n            q.append(v)\n            \n    # The actual target incoming flow for intermediate nodes\n    # For node 1, it's 0 (no incoming). For node n, it's not strictly defined by conservation.\n    # For 1 < v < n, it's total_incident_flow[v] / 2.\n    target_in_flow = [0] * (n + 1)\n    for v in range(2, n): # Only for intermediate nodes\n        target_in_flow[v] = total_incident_flow[v] // 2\n\n    while q:\n        u = q.popleft()\n\n        # Iterate through neighbors of u\n        for v_neighbor, c_flow, edge_idx in adj[u]:\n            if ans[edge_idx] != -1: # Edge already directed\n                continue\n\n            # Determine direction of edge (u, v_neighbor) with flow c_flow\n            # Original edge endpoints are stored in edges_info[edge_idx]\n            original_u, original_v, _ = edges_info[edge_idx]\n\n            # Decide if flow is u -> v_neighbor or v_neighbor -> u\n            # This logic must be robust to ensure acyclicity and flow conservation.\n            # The key insight is that when a node `u` is processed from the queue,\n            # either it's the source (1), or it's an intermediate node (1 < u < n) with only one undirected edge left.\n            # If u is the source (1), all its edges must be outgoing.\n            # If u is an intermediate node (1 < u < n) with one undirected edge left:\n            #   - If current_in_flow[u] is already target_in_flow[u], the last edge must be outgoing from u.\n            #   - Otherwise, the last edge must be incoming to u to meet the target.\n            \n            # For node 'u', its 'target_balance' is 'target_in_flow[u]'.\n            # If 'current_in_flow[u]' has already reached 'target_in_flow[u]', then 'u' must send flow out.\n            # Otherwise, 'u' must receive flow in.\n            \n            # Special case for node 1: all edges must be outgoing.\n            if u == 1:\n                # Flow is u -> v_neighbor\n                ans[edge_idx] = 0 if original_u == u else 1\n            elif current_in_flow[u] < target_in_flow[u]:\n                # u needs more incoming flow, so this edge must be v_neighbor -> u\n                ans[edge_idx] = 1 if original_u == u else 0\n            else: # current_in_flow[u] == target_in_flow[u]\n                # u has enough incoming flow, so this edge must be u -> v_neighbor\n                ans[edge_idx] = 0 if original_u == u else 1\n\n            # Update current_in_flow for the receiving vertex\n            if ans[edge_idx] == 0: # Flow is original_u -> original_v\n                current_in_flow[original_v] += c_flow\n            else: # Flow is original_v -> original_u\n                current_in_flow[original_u] += c_flow\n\n            # Decrement undirected edge counts for both endpoints\n            num_undirected_edges[u] -= 1\n            num_undirected_edges[v_neighbor] -= 1\n\n            # Add v_neighbor to queue if it's ready\n            if v_neighbor != 1 and v_neighbor != n and num_undirected_edges[v_neighbor] == 1:\n                q.append(v_neighbor)\n            # If v_neighbor is n and it has only one undirected edge left, it might be added.\n            # However, the logic for intermediate nodes (1 < v < n) is sufficient\n            # because edges connected to n will eventually be the last undirected edge for some intermediate node.\n\n    # Output results\n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + '\\n')\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 746,
        "completion_token_count": 4193,
        "thoughts_token_count": 6278
    }
}