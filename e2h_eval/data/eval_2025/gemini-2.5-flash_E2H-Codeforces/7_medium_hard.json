{
    "start": 1758016319.697296,
    "end": 1758016425.5107417,
    "start-formatted": "2025-09-16 18:51 KST",
    "end-formatted": "2025-09-16 18:53 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "**Here's how I'm thinking about solving the \"Rudolf and Snowflakes (hard version)\" problem:**\n\nMy goal is to write a Python script that can efficiently determine if a given number `n` can represent the total number of vertices in a snowflake structure.\n\nI've analyzed the snowflake structure and realized it's built in layers, with a central vertex and branches radiating outward. The core constraint is that each leaf vertex (connected to only one other) must connect to `k` new vertices, and this branching process happens at least once.\n\nI've modeled the total number of vertices as a geometric series: `1 + k + k^2 + ... + k^L`, where `L` represents the number of branching layers and must be at least 2 (`m >= 1` in the original prompt means `L >= 2`, and represents the branching). The formula for the sum of this series simplifies to `(k^(L+1) - 1) / (k - 1)`.\n\nNow, the core of the problem is: given `n`, can we find integer values for `k > 1` and `L >= 2` that satisfy `n = (k^(L+1) - 1) / (k - 1)`?\n\nI've recognized that `n` can be up to `10^18`, which influences my approach. I need an efficient solution. I've broken the problem into two main cases:\n\n1.  **P = 3 (i.e. L = 2)**: This is the easiest case, where `n = 1 + k + k^2`. I can solve this using the quadratic formula for `k`. However, I need to check if the solution is an integer (`k` has to be an integer).  The discriminant `4n - 3` must be a perfect square for an integer solution. I'll use `isqrt` (integer square root) to check this, making this a very efficient `O(log n)` check (i.e. binary search based root finding) for each test case.\n\n2.  **P >= 4 (i.e. L >= 3)**: This becomes more complex. Here I'll iterate through possible values of `P = L+1` and for each P I'll search for k.\n\nI can rewrite the sum as `n = (k^P - 1) / (k - 1)`, where `P = L+1`. The range for `P` is small and will be up to about 60.\n\nFor a fixed `P`, I'm going to use binary search to efficiently find a potential `k`. Since the sum `1 + k + k^2 + ... + k^(P-1)` is monotonically increasing with respect to k, binary search is the right way to search for k. The range for `k` must be within `2 <= k <= (n-1)^(1/(P-1)) + 2`.  I'll need to calculate this carefully, keeping in mind overflow for these values of `k`.  I'm calculating `high = int(n**(1.0/(P-1))) + 2` and then binary searching for `k`.\n\nIn the binary search, I'll need to check if the calculated sum `1 + k + ... + k^(P-1)` equals `n`. This involves summing terms using a `check` function, which needs to be efficient and handle potential integer overflows carefully.\n\nTo prevent overflow within the binary search, I created the `check(k, P, n)` function to calculate if `1 + k + ... k^(P-1)` is less than `n` and it includes checks to prevent the intermediate terms from overflowing.\n\nThe `check` function calculates the sum efficiently.\n\nThe combination of the initial check for P=3, the binary search for k for larger P values, the geometric series calculation within the binary search loop, and overflow management should provide an efficient solution. The search space is bounded, and within the bounded search, the steps are efficient, as `P` is at most 60 (for the largest value of n), and the binary search on k is `log(k)`, and `k` is small.\n",
    "response": "The problem asks us to determine if a given number `n` (up to `10^18`) can be the total number of vertices in a snowflake graph. A snowflake is constructed as follows:\n1. Start with one central vertex.\n2. Connect the central vertex to `k` new vertices, where `k > 1`.\n3. Each vertex that is connected to only one other vertex is connected by edges to `k` more new vertices. This step must be done at least once.\n\nLet's analyze the number of vertices.\n- Initially: 1 vertex (the central one).\n- After step 2: `k` new vertices are added. Total: `1 + k`. These `k` vertices are leaves (connected to only one other vertex).\n- Step 3 is applied for the first time: Each of the `k` leaves from the previous step is connected to `k` new vertices. This adds `k * k = k^2` new vertices. Total: `1 + k + k^2`. These `k^2` vertices are now leaves. This is the smallest possible snowflake, as step 3 has been done once.\n- Step 3 is applied for the second time: Each of the `k^2` leaves from the previous step is connected to `k` new vertices. This adds `k^2 * k = k^3` new vertices. Total: `1 + k + k^2 + k^3`.\n\nIn general, if step 3 is applied `L-1` times (meaning `L` layers of branching from the central vertex, where `L >= 2`), the total number of vertices `n` is given by the sum of a geometric series:\n`n = 1 + k + k^2 + ... + k^L`\n\nThis sum can be written as `n = (k^(L+1) - 1) / (k - 1)`.\nLet `P = L+1`. Since `L >= 2`, we must have `P >= 3`.\nSo, we need to check if `n = (k^P - 1) / (k - 1)` for some integer `k > 1` and `P >= 3`.\n\nWe can break this down into two main cases:\n\n**Case 1: `P = 3` (i.e., `L = 2`)**\nIn this case, `n = 1 + k + k^2`.\nThis is a quadratic equation in `k`: `k^2 + k + (1 - n) = 0`.\nUsing the quadratic formula, `k = (-1 + sqrt(1 - 4(1 - n))) / 2 = (-1 + sqrt(4n - 3)) / 2`.\nFor `k` to be a positive integer, `4n - 3` must be a perfect square, say `s^2`.\nThen `s` must be an integer, and `s = sqrt(4n - 3)`.\nAlso, `s` must be odd (because `s^2 = 4n - 3` implies `s^2 \\equiv 1 \\pmod 4`).\nThen `k = (s - 1) / 2`. We need `k > 1`, which means `(s - 1) / 2 > 1`, so `s - 1 > 2`, or `s > 3`.\nSo, for `P=3`, we check if `4n - 3` is a perfect square `s^2` such that `s > 3`. If it is, `n` can be a snowflake.\nWe can use `math.isqrt` (integer square root) for this check.\n\n**Case 2: `P >= 4`**\nFor `P >= 4`, `n = 1 + k + k^2 + ... + k^(P-1)`.\nWe need to find if there exists a `k > 1` for a given `P`.\nThe function `f(k) = 1 + k + ... + k^(P-1)` is strictly increasing for `k > 1`. This allows us to use binary search for `k`.\n\nThe maximum value of `n` is `10^{18}`.\n- If `k=2`, `n = 1 + 2 + ... + 2^L = 2^{L+1} - 1`.\n  `n+1 = 2^{L+1}`. For `n=10^{18}`, `n+1` is roughly `2^{60}`. So `L+1` can be up to around `60`.\n  Therefore, `P` can range from `4` up to approximately `60` (or `64` to be safe, as `2^{63}` is about `9 \\times 10^{18}`).\n- If `P` is small, `k` can be large. For example, if `P=4`, `n \\approx k^3`. So `k \\approx n^{1/3} \\approx (10^{18})^{1/3} = 10^6`.\n- If `P` is large, `k` must be small. For `P=60`, `n \\approx k^{59}`. So `k \\approx n^{1/59} \\approx (10^{18})^{1/59} \\approx 2`.\n\nThis suggests iterating `P` from `4` up to `64`. For each `P`, we perform a binary search for `k`.\nThe range for `k` in the binary search:\n- `low = 2` (since `k > 1`).\n- `high = int(n**(1.0/(P-1))) + 2`. This upper bound is derived from `k^(P-1) < n`. For `P=4`, `high \\approx 10^6`. For `P=64`, `high \\approx 2`.\n\nInside the binary search, we need a helper function `check(k, P, n)` that calculates `1 + k + ... + k^(P-1)` and returns this sum, or a value greater than `n` if it exceeds `n` (to guide the binary search) or if an overflow occurs during calculation.\n\n`check(k, P, n)` function:\n```python\ndef check(k_val, P_val, n_target):\n    current_sum = 1\n    current_power = 1\n    for _ in range(P_val - 1): # Iterate P_val - 1 times for k^1 to k^(P_val-1)\n        # Check for overflow before multiplying current_power by k_val\n        # If current_power * k_val would exceed n_target, then current_sum + current_power * k_val will also exceed n_target.\n        # We use n_target // k_val to avoid direct multiplication that might exceed system's max int if n_target is large.\n        if current_power > n_target // k_val:\n            return n_target + 1 # Indicates sum will be greater than n_target\n        current_power *= k_val\n        \n        # Check for overflow before adding current_power to current_sum\n        if current_sum > n_target - current_power:\n            return n_target + 1 # Indicates sum will be greater than n_target\n        current_sum += current_power\n    return current_sum\n```\n\n**Overall Algorithm:**\n1. Handle small `n` values: If `n < 7`, it cannot be a snowflake (the smallest is `1+2+2^2 = 7` for `k=2, L=2`). Return \"NO\".\n2. **Check for `P=3`:**\n   Calculate `val = 4 * n - 3`.\n   Calculate `s = math.isqrt(val)`.\n   If `s * s == val` and `s > 3` (ensuring `k = (s-1)/2 > 1`), then return \"YES\".\n3. **Check for `P >= 4`:**\n   Iterate `P` from `4` to `64`.\n   For each `P`:\n     Initialize `low = 2`, `high = int(n**(1.0/(P-1))) + 2`.\n     Perform binary search:\n       While `low <= high`:\n         `mid = (low + high) // 2`.\n         `current_sum = check(mid, P, n)`.\n         If `current_sum == n`: return \"YES\".\n         If `current_sum < n`: `low = mid + 1`.\n         Else (`current_sum > n`): `high = mid - 1`.\n4. If no `k, P` pair is found after all checks, return \"NO\".\n\n**Time Complexity:**\n- `P=3` case: `O(log n)` due to `isqrt`.\n- `P >= 4` cases:\n  - The loop for `P` runs about `60` times.\n  - Inside the loop, binary search runs `O(log(n^(1/(P-1)))) = O(log n / (P-1))` iterations.\n  - Each `check` call takes `O(P)` time.\n  - Total for `P >= 4`: `sum_{P=4}^{64} ( (log n / (P-1)) * P )`.\n  - `log n` for `n=10^{18}` is about `60`. So `sum_{P=4}^{64} (60 / (P-1) * P) \\approx sum_{P=4}^{64} (60) \\approx 60 * 60 = 3600`.\nTotal time per test case is very efficient, roughly `O(log n)`. With `t=10^4` test cases, `10^4 * 3600 = 3.6 \\times 10^7` operations, which is well within typical time limits.\n\n```python\nimport math\n\ndef solve():\n    n = int(input())\n\n    # Smallest snowflake is 1 + 2 + 2^2 = 7 (k=2, L=2)\n    # n must be at least 7\n    if n < 7:\n        print(\"NO\")\n        return\n\n    # Case 1: P = 3 (L = 2), n = 1 + k + k^2\n    # k^2 + k + (1 - n) = 0\n    # k = (-1 + sqrt(1 - 4(1 - n))) / 2\n    # k = (-1 + sqrt(4n - 3)) / 2\n    # We need 4n - 3 to be a perfect square, say s^2.\n    # Also, k > 1 implies (-1 + s) / 2 > 1, so s - 1 > 2, s > 3.\n    \n    val = 4 * n - 3\n    s = math.isqrt(val)\n    if s * s == val:\n        if s > 3: # Ensures k = (s-1)/2 > 1\n            print(\"YES\")\n            return\n\n    # Case 2: P >= 4 (L >= 3), n = 1 + k + k^2 + ... + k^(P-1)\n    # We iterate P from 4 up to a maximum value (e.g., 64, since 2^63 is approx 9*10^18)\n    # For each P, we binary search for k.\n\n    # Helper function to calculate sum and check for overflow\n    def check_sum(k_val, P_val, n_target):\n        current_sum = 1\n        current_power = 1 # k^0\n        for _ in range(P_val - 1): # Iterate P_val - 1 times for k^1 to k^(P_val-1)\n            # Check for overflow before multiplying current_power by k_val\n            # If current_power * k_val would exceed n_target, then current_sum + current_power * k_val will also exceed n_target.\n            # We use n_target // k_val to avoid direct multiplication that might exceed system's max int if n_target is large.\n            if current_power > n_target // k_val:\n                return n_target + 1 # Indicates sum will be greater than n_target\n            current_power *= k_val\n            \n            # Check for overflow before adding current_power to current_sum\n            if current_sum > n_target - current_power:\n                return n_target + 1 # Indicates sum will be greater than n_target\n            current_sum += current_power\n        return current_sum\n\n    # Max P for k=2 and n=10^18 is around 60 (2^60-1 approx 1.15e18)\n    # Upper bound for P can be safely set to 64\n    for P in range(4, 65):\n        # Binary search for k\n        # k^(P-1) approx n, so k approx n^(1/(P-1))\n        low = 2\n        # A safe upper bound for k for n=10^18 and P=4 is (10^18)^(1/3) approx 10^6\n        # For larger P, k will be smaller.\n        # Add 2 for safety margin in float calculations.\n        high = int(n**(1.0/(P-1))) + 2 \n\n        while low <= high:\n            mid = (low + high) // 2\n            if mid < 2: # Ensure k > 1\n                low = 2 # Adjust low to 2 if mid somehow becomes less than 2\n                continue\n\n            current_sum = check_sum(mid, P, n)\n\n            if current_sum == n:\n                print(\"YES\")\n                return\n            elif current_sum < n:\n                low = mid + 1\n            else: # current_sum > n\n                high = mid - 1\n                \n    print(\"NO\")\n\n\nt = int(input())\nfor _ in range(t):\n    solve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef solve():\n    n = int(input())\n\n    # Smallest snowflake is 1 + 2 + 2^2 = 7 (k=2, L=2)\n    # n must be at least 7\n    if n < 7:\n        print(\"NO\")\n        return\n\n    # Case 1: P = 3 (L = 2), n = 1 + k + k^2\n    # k^2 + k + (1 - n) = 0\n    # k = (-1 + sqrt(1 - 4(1 - n))) / 2\n    # k = (-1 + sqrt(4n - 3)) / 2\n    # We need 4n - 3 to be a perfect square, say s^2.\n    # Also, k > 1 implies (-1 + s) / 2 > 1, so s - 1 > 2, s > 3.\n    \n    val = 4 * n - 3\n    s = math.isqrt(val)\n    if s * s == val:\n        if s > 3: # Ensures k = (s-1)/2 > 1\n            print(\"YES\")\n            return\n\n    # Case 2: P >= 4 (L >= 3), n = 1 + k + k^2 + ... + k^(P-1)\n    # We iterate P from 4 up to a maximum value (e.g., 64, since 2^63 is approx 9*10^18)\n    # For each P, we binary search for k.\n\n    # Helper function to calculate sum and check for overflow\n    def check_sum(k_val, P_val, n_target):\n        current_sum = 1\n        current_power = 1 # k^0\n        for _ in range(P_val - 1): # Iterate P_val - 1 times for k^1 to k^(P_val-1)\n            # Check for overflow before multiplying current_power by k_val\n            # If current_power * k_val would exceed n_target, then current_sum + current_power * k_val will also exceed n_target.\n            # We use n_target // k_val to avoid direct multiplication that might exceed system's max int if n_target is large.\n            if current_power > n_target // k_val:\n                return n_target + 1 # Indicates sum will be greater than n_target\n            current_power *= k_val\n            \n            # Check for overflow before adding current_power to current_sum\n            if current_sum > n_target - current_power:\n                return n_target + 1 # Indicates sum will be greater than n_target\n            current_sum += current_power\n        return current_sum\n\n    # Max P for k=2 and n=10^18 is around 60 (2^60-1 approx 1.15e18)\n    # Upper bound for P can be safely set to 64\n    for P in range(4, 65):\n        # Binary search for k\n        # k^(P-1) approx n, so k approx n^(1/(P-1))\n        low = 2\n        # A safe upper bound for k for n=10^18 and P=4 is (10^18)^(1/3) approx 10^6\n        # For larger P, k will be smaller.\n        # Add 2 for safety margin in float calculations.\n        high = int(n**(1.0/(P-1))) + 2 \n\n        while low <= high:\n            mid = (low + high) // 2\n            if mid < 2: # Ensure k > 1\n                low = 2 # Adjust low to 2 if mid somehow becomes less than 2\n                continue\n\n            current_sum = check_sum(mid, P, n)\n\n            if current_sum == n:\n                print(\"YES\")\n                return\n            elif current_sum < n:\n                low = mid + 1\n            else: # current_sum > n\n                high = mid - 1\n                \n    print(\"NO\")\n\n\nt = int(input())\nfor _ in range(t):\n    solve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 568,
        "completion_token_count": 3261,
        "thoughts_token_count": 7529
    }
}