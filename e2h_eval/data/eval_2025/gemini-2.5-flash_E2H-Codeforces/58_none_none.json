{
    "start": 1758293765.524565,
    "end": 1758293839.3738475,
    "start-formatted": "2025-09-19 23:56 KST",
    "end-formatted": "2025-09-19 23:57 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "",
    "response": "```python\nimport sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    adj = [[] for _ in range(n + 1)]\n    edges = set()\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n        edges.add(tuple(sorted((u, v))))\n\n    # Check for existing odd cycle (t=0)\n    # Use BFS for 2-coloring to detect odd cycles\n    \n    # visited: 0 = unvisited, 1 = visiting, 2 = visited\n    # color: 0 or 1\n    \n    for start_node in range(1, n + 1):\n        if adj[start_node] and not any(color_map.get(node) is not None for node in range(1, n + 1) if node in adj[start_node]):\n            # This check is for disconnected components.\n            # We need to run BFS for each component.\n            pass\n\n    color_map = {} # node -> color (0 or 1)\n    \n    for i in range(1, n + 1):\n        if i not in color_map:\n            q = [(i, 0)] # (node, color)\n            color_map[i] = 0\n            head = 0\n            \n            while head < len(q):\n                u, u_color = q[head]\n                head += 1\n                \n                for v in adj[u]:\n                    if v not in color_map:\n                        color_map[v] = 1 - u_color\n                        q.append((v, 1 - u_color))\n                    elif color_map[v] == u_color:\n                        print(\"0 1\")\n                        return\n\n    # If no odd cycle exists, the graph is bipartite.\n    # We need to add edges to form an odd cycle.\n\n    # t = 1: Add one edge to form an odd cycle.\n    # This requires connecting two vertices of the same color within a connected component.\n    # Or, if there are multiple components, connecting two vertices from different components,\n    # and then an existing path within one of those components completes an odd cycle.\n    # The simplest way to form an odd cycle with 1 added edge is to connect two vertices\n    # of the same color in a bipartite graph.\n\n    # Count nodes in each partition for each component.\n    # A component is a set of nodes reachable from a start_node.\n    \n    component_colors = [] # list of (count_color0, count_color1) for each component\n    visited_comp = [False] * (n + 1)\n\n    for i in range(1, n + 1):\n        if not visited_comp[i]:\n            q = [(i, 0)]\n            visited_comp[i] = True\n            current_component_colors = {0: 0, 1: 0}\n            current_component_colors[0] += 1\n            \n            component_nodes = [i]\n            \n            head = 0\n            while head < len(q):\n                u, u_color = q[head]\n                head += 1\n                \n                for v in adj[u]:\n                    if not visited_comp[v]:\n                        visited_comp[v] = True\n                        v_color = 1 - u_color\n                        current_component_colors[v_color] += 1\n                        q.append((v, v_color))\n                        component_nodes.append(v)\n            \n            component_colors.append((current_component_colors[0], current_component_colors[1]))\n\n    ways_t1 = 0\n    for c0, c1 in component_colors:\n        # Add an edge between two nodes of color 0, or two nodes of color 1\n        # within the same component.\n        # Number of ways to choose 2 nodes of color 0: c0 * (c0 - 1) / 2\n        # Number of ways to choose 2 nodes of color 1: c1 * (c1 - 1) / 2\n        ways_t1 += c0 * (c0 - 1) // 2\n        ways_t1 += c1 * (c1 - 1) // 2\n\n    # We need to subtract existing edges from these counts.\n    # This is tricky because we don't know the specific nodes that would form the cycle.\n    # The problem asks for the minimum number of edges to add.\n    # If we add an edge (u, v) where u and v have the same color, it creates an odd cycle.\n    # We just need to count pairs (u, v) such that u, v are in the same component,\n    # have the same color, and (u, v) is not an existing edge.\n    \n    # Recalculate ways_t1 more carefully.\n    ways_t1 = 0\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if i in color_map and j in color_map and color_map[i] == color_map[j]:\n                # Check if i and j are in the same connected component\n                # A simple way to check this without re-running BFS for each pair\n                # is to use the `visited_comp` logic or a component ID map.\n                # For now, let's assume if they have colors, they are part of some bipartite component.\n                # The critical part is that they must be in the *same* component.\n                \n                # A quick way to check if two nodes are in the same component:\n                # Re-run BFS/DFS from i and see if j is reachable. Too slow.\n                # A better way is to assign a component ID during the initial BFS passes.\n                \n                # Let's re-do component processing to assign component IDs.\n                component_id_map = {}\n                component_counter = 0\n                visited_for_comp_id = [False] * (n + 1)\n                \n                for start_node in range(1, n + 1):\n                    if not visited_for_comp_id[start_node]:\n                        component_counter += 1\n                        q = [start_node]\n                        visited_for_comp_id[start_node] = True\n                        component_id_map[start_node] = component_counter\n                        head = 0\n                        while head < len(q):\n                            u = q[head]\n                            head += 1\n                            for v in adj[u]:\n                                if not visited_for_comp_id[v]:\n                                    visited_for_comp_id[v] = True\n                                    component_id_map[v] = component_counter\n                                    q.append(v)\n                \n                if component_id_map.get(i) == component_id_map.get(j):\n                    if tuple(sorted((i, j))) not in edges:\n                        ways_t1 += 1\n\n    if ways_t1 > 0:\n        print(f\"1 {ways_t1}\")\n        return\n\n    # t = 2: Add two edges to form an odd cycle.\n    # This happens if all components are bipartite, and we can't form an odd cycle with 1 edge.\n    # This implies that within each component, there are no two nodes of the same color that are not connected.\n    # This is not necessarily true. ways_t1 could be 0 because c0 < 2 and c1 < 2 for all components,\n    # meaning all components are just single nodes or single edges.\n    #\n    # Case 1: Connect two nodes from two different components.\n    # Let's say we have component A (partition sizes cA0, cA1) and component B (cB0, cB1).\n    # If we add an edge (u, v) where u is in A and v is in B,\n    # then the resulting graph is still bipartite IF u_color != v_color.\n    # It becomes non-bipartite IF u_color == v_color.\n    # But we need *two* edges.\n    #\n    # If we add two edges (u, v) and (x, y):\n    # The goal is to create an odd cycle.\n    #\n    # The simplest way to create an odd cycle with 2 edges is to connect\n    # three distinct vertices A, B, C to form a triangle.\n    # We need to add 2 edges to form a triangle (A-B, B-C, C-A).\n    # If A-B exists, we add A-C and B-C.\n    # If no edges exist, we add all three.\n    #\n    # This problem is about the minimum number of edges.\n    # If t=1 didn't work, it means for every component, for any two nodes u,v of the same color,\n    # they are already connected by an edge. This is a very specific graph structure.\n    # It means each partition (color 0 or color 1) has at most one node, or if it has more,\n    # all pairs are connected.\n    # For a bipartite graph, this means each component is a complete bipartite graph K_{c0,c1}.\n    # And if c0 >= 2, all pairs of color 0 nodes are connected. This is only possible if c0=2 and c1=0 or 1.\n    # For example, if c0=2, nodes {u,v} have color 0. If (u,v) exists, then ways_t1 for this pair is 0.\n    # If c0=3, nodes {u,v,w} have color 0. If (u,v) exists, (u,w) exists, (v,w) exists, then ways_t1 is 0.\n    # This implies that if ways_t1 is 0, then for any component, the number of nodes of a given color is at most 1,\n    # OR if it's more than 1, all pairs of nodes of that color are already connected.\n    # The latter case is impossible in a simple graph for more than 2 nodes of the same color,\n    # because it would require an odd cycle (e.g., K_3 is an odd cycle).\n    # So, if ways_t1 is 0, it means that for every component, c0 <= 1 or c1 <= 1.\n    # This means each component is a path or a star graph where the center is one color and leaves are the other.\n    # Or, more simply, each component has at most one node of color 0, or at most one node of color 1.\n    # This implies that each component is essentially a \"line\" of length at most 1 from the perspective of one color.\n    # e.g., if c0=1, c1=5, it's a star graph.\n    # If c0=0 or c1=0, it's a set of isolated nodes.\n    # So if ways_t1 is 0, every component has at most one node of color 0 OR at most one node of color 1.\n    # This means for any component, min(c0, c1) <= 1.\n    #\n    # Let's verify this. If a component has c0 >= 2 and c1 >= 2, then we can pick two nodes u, v of color 0.\n    # If (u, v) is not an edge, ways_t1 > 0.\n    # If (u, v) is an edge, this is an odd cycle (u-v-path-u where path is even). This contradicts bipartiteness.\n    # So, if ways_t1 is 0, it means for every component, either c0 < 2 or c1 < 2.\n    # This means for every component, min(c0, c1) <= 1.\n    #\n    # So, if ways_t1 is 0, then every component has at most one node of one of the colors.\n    # This implies that the graph is a collection of \"star-like\" components or paths.\n    # Example:\n    # 1-2, 2-3, 3-4, 4-1 (4 nodes, 4 edges) -> odd cycle, t=0\n    # 1-2, 2-3, 3-1 (3 nodes, 3 edges) -> odd cycle, t=0\n    # 1-2, 2-3, 3-4, 4-2 (4 nodes, 4 edges) -> 1-2-4-3-2 (not simple), 1-2-4, 2-3-4.\n    # This graph is bipartite: 1(0), 2(1), 3(0), 4(0). No, 1(0), 2(1), 3(0), 4(1).\n    # 1-2, 2-3, 3-4, 4-2.\n    # 1(0) -> 2(1)\n    # 2(1) -> 3(0)\n    # 3(0) -> 4(1)\n    # 4(1) -> 2(1) - conflict! So 4-2 is an odd cycle. t=0.\n    #\n    # The example input 1: 4 4, 1-2, 1-3, 4-2, 4-3\n    # 1(0) -> 2(1), 3(1)\n    # 4(0) -> 2(1), 3(1)\n    # This is bipartite. Component 1: {1,2,3,4}. Color 0: {1,4}, Color 1: {2,3}.\n    # c0=2, c1=2.\n    # Ways to add 1 edge:\n    # (1,4) not existing? Yes. Add (1,4). Forms 1-2-4-3-1 (length 4) or 1-3-4-2-1 (length 4).\n    # Wait, an odd cycle means an odd number of edges.\n    # If we add (1,4), we get cycle 1-2-4-3-1. Length 4. Even.\n    # Or 1-3-4-2-1. Length 4. Even.\n    #\n    # My understanding of \"add one edge to form an odd cycle\" is flawed.\n    # If graph is bipartite, and we add an edge (u, v) where u and v have the same color,\n    # say u_color = v_color = 0.\n    # There is a path P from u to v in the original bipartite graph.\n    # This path must have an even length (because it connects two nodes of the same color in a bipartite graph).\n    # Adding edge (u, v) creates a cycle: u -- P -- v -- u.\n    # The length of this cycle is (length of P) + 1.\n    # Since length of P is even, (length of P) + 1 is odd.\n    # So, adding an edge between two nodes of the same color *always* creates an odd cycle.\n    #\n    # For example 1: 4 4, 1-2, 1-3, 4-2, 4-3\n    # Bipartition: {1,4} (color 0), {2,3} (color 1).\n    # c0=2, c1=2.\n    # Ways to add 1 edge:\n    # Pick two nodes of color 0: (1,4). Is (1,4) an edge? No. Add (1,4). This forms an odd cycle.\n    # Pick two nodes of color 1: (2,3). Is (2,3) an edge? No. Add (2,3). This forms an odd cycle.\n    # So t=1, w=2. This matches example output. My logic for t=1 seems correct.\n\n    # If ways_t1 is 0, it means for every component, min(c0, c1) <= 1.\n    # This means each component is a collection of isolated nodes, or a star graph (or a path of length 1, i.e., an edge).\n    # E.g., {1}, {2}, {3,4} where 3-4 is an edge.\n    # In such a graph, we cannot pick two nodes of the same color that are not already connected.\n    # (Because if c0 >= 2, say {u,v} are color 0, then (u,v) must be an edge. But this is impossible in a bipartite graph unless c0=2 and c1=0 or 1.\n    # If c0=2, c1=0, then it's just two isolated nodes. If c0=2, c1=1, it's K_{2,1} which is a path of length 2 or a triangle if you consider the center node.\n    # If c0=2, c1=1, nodes {u,v} color 0, node {w} color 1. (u,v) cannot be an edge. So if c0=2 and c1>=1, then ways_t1 > 0.)\n    #\n    # So, ways_t1 == 0 implies that for every component, c0 <= 1 AND c1 <= 1.\n    # This means every component is either an isolated node or a single edge.\n    # Example: 3 0 (3 nodes, 0 edges)\n    # Components: {1}, {2}, {3}. Each has c0=1, c1=0 (or vice versa).\n    # ways_t1 = 0.\n    #\n    # In this case (t=2 or t=3):\n    # If ways_t1 is 0, then we need to add more edges.\n    #\n    # t=2:\n    # We need to pick two nodes u, v, w such that (u,v) and (v,w) exist, and add (u,w) to form a triangle.\n    # Or, pick two nodes u, v, w such that (u,v) exists, and add (u,w) and (v,w).\n    # Or, pick three nodes u,v,w and add (u,v), (v,w), (u,w). (This is t=3)\n    #\n    # If t=1 is not possible, it means every component is either an isolated node or a single edge.\n    # Example: {1}, {2}, {3,4} (3-4 edge).\n    # Total nodes: n. Total edges: m.\n    # Number of isolated nodes: n_isolated.\n    # Number of edges (components of size 2): n_edges_comp.\n    # Total components: n_isolated + n_edges_comp.\n    #\n    # To form an odd cycle with 2 added edges:\n    # We need to connect three distinct nodes A, B, C.\n    # If we add (A,B) and (B,C) and (A,C) is already there, that's 2 edges.\n    # This is not possible if t=1 ways_t1=0, because it implies no existing odd cycle.\n    #\n    # Consider connecting two different components.\n    # Let component A be {u_A}, component B be {u_B}. Add (u_A, u_B). Still bipartite.\n    # Let component A be {u_A, v_A} (edge u_A-v_A), component B be {u_B}.\n    # Add (u_A, u_B) and (v_A, u_B). This forms an odd cycle u_A-u_B-v_A-u_A (length 3).\n    # This needs 2 added edges.\n    #\n    # Number of nodes: n.\n    # Number of edges: m.\n    # Number of connected components (that are not just isolated nodes): `len(component_colors)`\n    #\n    # If ways_t1 == 0:\n    # Each component is a single node or a single edge.\n    #\n    # If there are at least 3 isolated nodes (n_isolated >= 3):\n    # Pick 3 isolated nodes A, B, C. Add (A,B) and (B,C) and (A,C). That's 3 edges.\n    #\n    # If there are at least 2 isolated nodes and 1 edge component:\n    # Isolated nodes: A, B. Edge component: C-D.\n    # Add (A,C) and (A,D). Cycle A-C-D-A. Length 3. 2 edges added.\n    # Ways: (num_isolated * (num_isolated - 1) / 2) * num_edge_components. (No, this is wrong.)\n    # Ways: num_isolated * num_edge_components * 2 (for C or D).\n    #\n    # Let's count nodes that are part of an edge component (degree >= 1).\n    # Let's count isolated nodes (degree = 0).\n    \n    num_isolated_nodes = 0\n    num_nodes_in_edges = 0\n    \n    for i in range(1, n + 1):\n        if not adj[i]:\n            num_isolated_nodes += 1\n        else:\n            num_nodes_in_edges += 1\n            \n    # t=2:\n    # Case 1: Connect an isolated node to an edge component.\n    # Pick an isolated node `u`. Pick an edge `(v, w)`. Add edges `(u, v)` and `(u, w)`.\n    # This forms a triangle `u-v-w-u`. Two edges added.\n    # Number of ways:\n    # `num_isolated_nodes` choices for `u`.\n    # `m` choices for `(v, w)`.\n    # Total ways = `num_isolated_nodes * m`.\n    # This covers `num_isolated_nodes > 0` and `m > 0`.\n    if num_isolated_nodes > 0 and m > 0:\n        print(f\"2 {num_isolated_nodes * m}\")\n        return\n\n    # t=3:\n    # If num_isolated_nodes >= 3:\n    # Pick 3 isolated nodes A, B, C. Add (A,B), (B,C), (A,C). Forms a triangle. 3 edges added.\n    # Ways: n_isolated * (n_isolated - 1) * (n_isolated - 2) / 6.\n    if num_isolated_nodes >= 3:\n        print(f\"3 {num_isolated_nodes * (num_isolated_nodes - 1) * (num_isolated_nodes - 2) // 6}\")\n        return\n\n    # If num_isolated_nodes = 2:\n    # A, B are isolated.\n    # If m=0: A, B, C, ... (all isolated). We need 3 isolated nodes for t=3.\n    # So if n_isolated = 2 and m=0, then n=2. Not possible to form an odd cycle.\n    # If n_isolated = 2 and m > 0, we would have caught it with t=2.\n    #\n    # If num_isolated_nodes = 1:\n    # A is isolated.\n    # If m=0: n=1. Not possible.\n    # If m>0: caught with t=2.\n    #\n    # If num_isolated_nodes = 0:\n    # All nodes have degree >= 1.\n    # If t=1 ways_t1=0, it means all components are single edges.\n    # This means the graph is a perfect matching (or a collection of disjoint edges).\n    # E.g., 1-2, 3-4, 5-6.\n    # We need to add 3 edges to form a triangle.\n    # Pick an edge (u,v). Pick another edge (x,y). Pick a third edge (a,b).\n    # To form an odd cycle:\n    # Pick 3 distinct nodes A, B, C.\n    # Add (A,B), (B,C), (C,A). This takes 3 edges.\n    # If there are 3 nodes, and no edges, we need 3 edges.\n    # If there are 3 nodes, and 1 edge (A-B), we need (B,C), (C,A). That's 2 edges.\n    # But this was covered by t=2 for isolated node + edge component.\n    #\n    # If ways_t1 is 0, then every component is a single node or a single edge.\n    # We are sure that if ways_t1 is 0, it means min(c0, c1) <= 1 for all components.\n    #\n    # Let's count nodes in different categories:\n    # `isolated_nodes`: nodes with degree 0.\n    # `edge_nodes`: nodes with degree > 0.\n    \n    # If ways_t1 > 0, we already printed \"1 ways_t1\".\n    # If ways_t1 == 0, then we know min(c0, c1) <= 1 for all components.\n    # This means each component is a path of length at most 1 (i.e., an isolated node or an edge).\n    \n    isolated_nodes_count = 0\n    nodes_in_edge_components_count = 0\n    \n    for i in range(1, n + 1):\n        if not adj[i]:\n            isolated_nodes_count += 1\n        else:\n            nodes_in_edge_components_count += 1\n            \n    # Number of edges in the graph is `m`.\n    # Number of components that are single edges: `m`.\n    # Number of isolated nodes: `isolated_nodes_count`.\n    \n    # If `isolated_nodes_count >= 1` and `m >= 1`:\n    #   Pick one isolated node `u`. Pick one existing edge `(v, w)`.\n    #   Add edges `(u, v)` and `(u, w)`. This forms a triangle `u-v-w-u`. 2 edges added.\n    #   Ways: `isolated_nodes_count * m`.\n    if isolated_nodes_count >= 1 and m >= 1:\n        print(f\"2 {isolated_nodes_count * m}\")\n        return\n        \n    # If `isolated_nodes_count >= 3`:\n    #   Pick three isolated nodes `u, v, w`. Add edges `(u, v), (v, w), (w, u)`. 3 edges added.\n    #   Ways: `isolated_nodes_count * (isolated_nodes_count - 1) * (isolated_nodes_count - 2) // 6`.\n    if isolated_nodes_count >= 3:\n        print(f\"3 {isolated_nodes_count * (isolated_nodes_count - 1) * (isolated_nodes_count - 2) // 6}\")\n        return\n\n    # If `isolated_nodes_count == 2` and `m == 0`: (n=2, 0 edges)\n    #   Cannot form an odd cycle. Max 2 nodes.\n    # If `isolated_nodes_count == 1` and `m == 0`: (n=1, 0 edges)\n    #   Cannot form an odd cycle. Max 1 node.\n    # If `isolated_nodes_count == 0` and `m == 0`: (n=0, 0 edges)\n    #   Cannot form an odd cycle.\n    \n    # What if `n < 3`?\n    # If n=1, 0 edges, output 3 1 (for 3 0 case). This is wrong.\n    # For 3 0: isolated_nodes_count=3, m=0. Output: 3 1. This is correct.\n    # My example output is 3 1 for input '3 0'.\n    # For n=1, 0 edges: isolated_nodes_count=1, m=0. Neither t=2 nor t=3 condition met.\n    # For n=2, 0 edges: isolated_nodes_count=2, m=0. Neither t=2 nor t=3 condition met.\n    # The problem states \"consisting of more than one vertex\".\n    # A cycle of length 3 needs 3 vertices.\n    # If n < 3, it's impossible to form a cycle of length 3.\n    # What if n=2? e.g., 2 0. isolated_nodes_count=2.\n    # Can we form an odd cycle? No, min length is 3.\n    # The problem implies such a cycle is always possible.\n    # \"minimum number of edges that must be added ... to form a simple cycle of an odd length\"\n    # This implies that `n` is large enough to form such a cycle.\n    # The minimum cycle length is 3. So we need at least 3 vertices.\n    # If n < 3, it's impossible.\n    # The constraints are n >= 1.\n    # If n=1, cannot form cycle.\n    # If n=2, cannot form cycle.\n    # The problem statement guarantees \"more than one vertex\".\n    # An odd cycle must have length >= 3.\n    # So if n < 3, there's no solution. But the problem implies there is always a solution.\n    # This means n >= 3 must hold for any valid test case.\n    \n    # If `isolated_nodes_count == 0` and `m >= 1`:\n    # All nodes have degree >= 1.\n    # And we know `ways_t1 == 0`, meaning every component is a single edge.\n    # So the graph is a collection of disjoint edges (a matching).\n    # E.g., 1-2, 3-4, 5-6.\n    # To form an odd cycle, we need to connect 3 nodes.\n    # Pick 3 nodes A, B, C.\n    # If A-B exists, B-C exists, C-A exists, this is t=0.\n    # If A-B exists, B-C exists, C-A does not exist, this is t=1. (But ways_t1 is 0, so this case is impossible)\n    #\n    # So we need to add 3 edges.\n    # Pick 3 distinct nodes u, v, w.\n    # Add (u,v), (v,w), (w,u).\n    # The number of such ways is `n * (n - 1) * (n - 2) // 6`.\n    # But we need to subtract cases where one or more of these edges already exist.\n    # If ways_t1 == 0 and isolated_nodes_count == 0:\n    # Graph is a perfect matching (or a set of disjoint edges).\n    # Number of nodes `n`. Number of edges `m`.\n    # `n` must be even. `m = n / 2`.\n    # Example: n=4, m=2. Edges: 1-2, 3-4.\n    # We need to add 3 edges.\n    # Pick 3 nodes, say 1, 3, 4. Add (1,3), (3,4), (4,1).\n    # (3,4) exists. So we add (1,3) and (4,1). This is t=2.\n    # This is exactly the \"pick an edge and an isolated node\" type of operation, but here there are no isolated nodes.\n    #\n    # So if `isolated_nodes_count == 0` and `ways_t1 == 0`:\n    # This means the graph is a collection of disjoint edges.\n    # `m` edges, `2*m` nodes. `n - 2*m` isolated nodes (which is 0 here).\n    #\n    # To form an odd cycle with 2 added edges:\n    # Pick an existing edge (u, v). Pick another existing edge (x, y).\n    # Add (u, x) and (v, x). This forms u-x-v-u. (u,v) exists.\n    # This is 2 edges added.\n    # Number of ways:\n    # Choose an existing edge (u,v): `m` ways.\n    # Choose another existing edge (x,y): `m-1` ways.\n    # Choose one endpoint from (x,y) to connect to both u and v: 2 ways (x or y).\n    # This forms a cycle (u-v-x-u) or (u-v-y-u).\n    # This is `m * (m - 1) * 2`. But this counts ordered pairs of edges, and also (x,y) vs (y,x).\n    #\n    # Let's be more precise for t=2.\n    # If ways_t1 == 0 and isolated_nodes_count == 0:\n    # The graph consists of `m` disjoint edges.\n    # We need to pick two edges `(u, v)` and `(x, y)`.\n    # Then we add two edges to form an odd cycle.\n    # E.g., add `(u, x)` and `(v, x)`. This forms a triangle `u-v-x-u`. (u,v) exists.\n    # Number of ways to choose two distinct edges: `m * (m - 1) / 2`.\n    # For each pair of edges `{(u,v), (x,y)}`:\n    #   We can pick `u` or `v` from the first edge, and `x` or `y` from the second.\n    #   To form a triangle with 2 added edges, we need to pick one node from one edge, say `u`,\n    #   and both nodes from the other edge, `x` and `y`.\n    #   Then add `(u,x)` and `(u,y)`. This forms a cycle `u-x-y-u`. (x,y) exists.\n    #   The nodes are `u, x, y`.\n    #   Ways to pick `u`: `n` choices.\n    #   Ways to pick edge `(x,y)`: `m` choices.\n    #   But `u` cannot be `x` or `y`.\n    #\n    # Let's re-evaluate t=2 for the case `isolated_nodes_count == 0` and `ways_t1 == 0`.\n    # Graph is a perfect matching (or disjoint edges).\n    # We need to find 3 distinct nodes A, B, C such that 1 edge exists and 2 edges are added.\n    # Or, 2 edges exist and 1 edge is added. (This would be t=1, which is 0).\n    # So, 1 edge exists, 2 edges are added.\n    # Let (A,B) be an existing edge. We need to find a node C not A or B.\n    # Add (A,C) and (B,C). This forms a triangle A-B-C-A.\n    # Ways:\n    # 1. Choose an existing edge (A,B): `m` ways.\n    # 2. Choose a third node C such that C is not A or B.\n    #    Since `isolated_nodes_count == 0`, C must be part of another existing edge (C,D).\n    #    Number of choices for C: `n - 2` ways.\n    #    For each such C, we need to check if (A,C) and (B,C) exist. They cannot exist.\n    #    The `n-2` nodes are partitioned into `m-1` other edges.\n    #    So we pick an existing edge (A,B).\n    #    We pick another node C from the remaining `n-2` nodes.\n    #    There are `n-2` choices for C.\n    #    Total ways: `m * (n - 2)`.\n    #    Example: 1-2, 3-4. n=4, m=2.\n    #    Pick (1,2).\n    #    C can be 3 or 4.\n    #    If C=3: add (1,3) and (2,3). Forms 1-2-3-1. 2 edges added.\n    #    If C=4: add (1,4) and (2,4). Forms 1-2-4-1. 2 edges added.\n    #    Total ways = `m * (n - 2) = 2 * (4 - 2) = 4`.\n    #    This seems correct.\n    # This implies `n >= 3`.\n    if isolated_nodes_count == 0 and m >= 1: # implies n is even, n >= 2. If n=2, m=1. n-2=0.\n        if n >= 3: # To pick a third node C\n            print(f\"2 {m * (n - 2)}\")\n            return\n        else: # n=2, m=1. (e.g., 2 1, 1-2). Cannot form odd cycle.\n            # This case should not happen based on problem constraints or interpretation.\n            # If n=2, m=1, then the only graph is 1-2. No odd cycle possible.\n            # The problem implies there's always a way.\n            # This means if n=2, it won't be given. So n >= 3 always.\n            pass # Fall through to t=3 logic if n=2 is not possible.\n\n    # Final fallback if nothing else worked (should only be for n < 3, or n=3, m=0).\n    # If n=3, m=0: isolated_nodes_count = 3. This is caught by t=3 condition above.\n    # If n=1 or n=2, this should not be reachable if problem implies a solution.\n    # If we reach here, it implies we have not found a solution with t=0, 1, or 2.\n    # This means the only possibility left is t=3.\n    # And the only way to get t=3 is to pick 3 nodes and add all 3 edges to form a triangle.\n    # This is covered by `isolated_nodes_count >= 3`.\n    # What if `isolated_nodes_count < 3`?\n    # e.g., n=3, m=1 (1-2). isolated_nodes_count=1 (node 3). m=1.\n    # This is covered by t=2 condition: `isolated_nodes_count * m = 1 * 1 = 1`.\n    # Output: 2 1.\n    #\n    # So if we reach here, it implies that the graph is such that no odd cycle can be formed with t=0,1,2.\n    # This can only happen if n < 3. But the problem implies a solution.\n    #\n    # The only remaining case is if n=3, m=0.\n    # Input: 3 0. Output: 3 1.\n    # My code for 3 0:\n    # ways_t1 = 0.\n    # isolated_nodes_count = 3, m = 0.\n    # t=2 condition `isolated_nodes_count >= 1 and m >= 1` is false.\n    # t=3 condition `isolated_nodes_count >= 3` is true. `3 * 2 * 1 // 6 = 1`.\n    # Output: 3 1. Correct.\n\n    # It seems all cases are covered.\n    # The logic for `isolated_nodes_count == 0 and ways_t1 == 0` is `m * (n - 2)`.\n    # Example: 4 2, 1-2, 3-4.\n    # isolated_nodes_count = 0, m=2.\n    # `ways_t1 = 0` (no nodes of same color within a component that aren't already connected)\n    # This graph is bipartite: {1,3} (color 0), {2,4} (color 1).\n    # Component 1: {1,2}, c0=1, c1=1. Component 2: {3,4}, c0=1, c1=1.\n    # So indeed `ways_t1` is 0.\n    # The condition `isolated_nodes_count == 0 and m >= 1` is met.\n    # `n=4, m=2`. Output: `2 {2 * (4-2)} = 2 4`.\n    # This is correct.\n    # Ways:\n    # 1. Pick (1,2). C can be 3 or 4. Add (1,3), (2,3) -> triangle 1-2-3-1. Add (1,4), (2,4) -> triangle 1-2-4-1.\n    # 2. Pick (3,4). C can be 1 or 2. Add (3,1), (4,1) -> triangle 3-4-1-3. Add (3,2), (4,2) -> triangle 3-4-2-3.\n    # Total 4 ways.\n\n    # If the code reaches here, it means n < 3.\n    # The problem implies a solution always exists.\n    # So this path should not be taken in competitive programming.\n    # If it is, it means the problem constraints are not as expected or my interpretation is wrong.\n    # The problem statement guarantees \"more than one vertex\".\n    # An odd cycle must have length at least 3. So n must be at least 3.\n    # If n < 3, it's impossible.\n    # If the input guarantees n >= 3, then one of the conditions above must be met.\n    # So this `sys.exit(1)` should not be reached.\n    sys.exit(1) # Should not be reached if problem guarantees a solution.\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    adj = [[] for _ in range(n + 1)]\n    edges = set()\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n        edges.add(tuple(sorted((u, v))))\n\n    # Check for existing odd cycle (t=0)\n    # Use BFS for 2-coloring to detect odd cycles\n    \n    # visited: 0 = unvisited, 1 = visiting, 2 = visited\n    # color: 0 or 1\n    \n    for start_node in range(1, n + 1):\n        if adj[start_node] and not any(color_map.get(node) is not None for node in range(1, n + 1) if node in adj[start_node]):\n            # This check is for disconnected components.\n            # We need to run BFS for each component.\n            pass\n\n    color_map = {} # node -> color (0 or 1)\n    \n    for i in range(1, n + 1):\n        if i not in color_map:\n            q = [(i, 0)] # (node, color)\n            color_map[i] = 0\n            head = 0\n            \n            while head < len(q):\n                u, u_color = q[head]\n                head += 1\n                \n                for v in adj[u]:\n                    if v not in color_map:\n                        color_map[v] = 1 - u_color\n                        q.append((v, 1 - u_color))\n                    elif color_map[v] == u_color:\n                        print(\"0 1\")\n                        return\n\n    # If no odd cycle exists, the graph is bipartite.\n    # We need to add edges to form an odd cycle.\n\n    # t = 1: Add one edge to form an odd cycle.\n    # This requires connecting two vertices of the same color within a connected component.\n    # Or, if there are multiple components, connecting two vertices from different components,\n    # and then an existing path within one of those components completes an odd cycle.\n    # The simplest way to form an odd cycle with 1 added edge is to connect two vertices\n    # of the same color in a bipartite graph.\n\n    # Count nodes in each partition for each component.\n    # A component is a set of nodes reachable from a start_node.\n    \n    component_colors = [] # list of (count_color0, count_color1) for each component\n    visited_comp = [False] * (n + 1)\n\n    for i in range(1, n + 1):\n        if not visited_comp[i]:\n            q = [(i, 0)]\n            visited_comp[i] = True\n            current_component_colors = {0: 0, 1: 0}\n            current_component_colors[0] += 1\n            \n            component_nodes = [i]\n            \n            head = 0\n            while head < len(q):\n                u, u_color = q[head]\n                head += 1\n                \n                for v in adj[u]:\n                    if not visited_comp[v]:\n                        visited_comp[v] = True\n                        v_color = 1 - u_color\n                        current_component_colors[v_color] += 1\n                        q.append((v, v_color))\n                        component_nodes.append(v)\n            \n            component_colors.append((current_component_colors[0], current_component_colors[1]))\n\n    ways_t1 = 0\n    for c0, c1 in component_colors:\n        # Add an edge between two nodes of color 0, or two nodes of color 1\n        # within the same component.\n        # Number of ways to choose 2 nodes of color 0: c0 * (c0 - 1) / 2\n        # Number of ways to choose 2 nodes of color 1: c1 * (c1 - 1) / 2\n        ways_t1 += c0 * (c0 - 1) // 2\n        ways_t1 += c1 * (c1 - 1) // 2\n\n    # We need to subtract existing edges from these counts.\n    # This is tricky because we don't know the specific nodes that would form the cycle.\n    # The problem asks for the minimum number of edges to add.\n    # If we add an edge (u, v) where u and v have the same color, it creates an odd cycle.\n    # We just need to count pairs (u, v) such that u, v are in the same component,\n    # have the same color, and (u, v) is not an existing edge.\n    \n    # Recalculate ways_t1 more carefully.\n    ways_t1 = 0\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if i in color_map and j in color_map and color_map[i] == color_map[j]:\n                # Check if i and j are in the same connected component\n                # A simple way to check this without re-running BFS for each pair\n                # is to use the `visited_comp` logic or a component ID map.\n                # For now, let's assume if they have colors, they are part of some bipartite component.\n                # The critical part is that they must be in the *same* component.\n                \n                # A quick way to check if two nodes are in the same component:\n                # Re-run BFS/DFS from i and see if j is reachable. Too slow.\n                # A better way is to assign a component ID during the initial BFS passes.\n                \n                # Let's re-do component processing to assign component IDs.\n                component_id_map = {}\n                component_counter = 0\n                visited_for_comp_id = [False] * (n + 1)\n                \n                for start_node in range(1, n + 1):\n                    if not visited_for_comp_id[start_node]:\n                        component_counter += 1\n                        q = [start_node]\n                        visited_for_comp_id[start_node] = True\n                        component_id_map[start_node] = component_counter\n                        head = 0\n                        while head < len(q):\n                            u = q[head]\n                            head += 1\n                            for v in adj[u]:\n                                if not visited_for_comp_id[v]:\n                                    visited_for_comp_id[v] = True\n                                    component_id_map[v] = component_counter\n                                    q.append(v)\n                \n                if component_id_map.get(i) == component_id_map.get(j):\n                    if tuple(sorted((i, j))) not in edges:\n                        ways_t1 += 1\n\n    if ways_t1 > 0:\n        print(f\"1 {ways_t1}\")\n        return\n\n    # t = 2: Add two edges to form an odd cycle.\n    # This happens if all components are bipartite, and we can't form an odd cycle with 1 edge.\n    # This implies that within each component, there are no two nodes of the same color that are not connected.\n    # This is not necessarily true. ways_t1 could be 0 because c0 < 2 and c1 < 2 for all components,\n    # meaning all components are just single nodes or single edges.\n    #\n    # Case 1: Connect two nodes from two different components.\n    # Let's say we have component A (partition sizes cA0, cA1) and component B (cB0, cB1).\n    # If we add an edge (u, v) where u is in A and v is in B,\n    # then the resulting graph is still bipartite IF u_color != v_color.\n    # It becomes non-bipartite IF u_color == v_color.\n    # But we need *two* edges.\n    #\n    # If we add two edges (u, v) and (x, y):\n    # The goal is to create an odd cycle.\n    #\n    # The simplest way to create an odd cycle with 2 edges is to connect\n    # three distinct vertices A, B, C to form a triangle.\n    # We need to add 2 edges to form a triangle (A-B, B-C, C-A).\n    # If A-B exists, we add A-C and B-C.\n    # If no edges exist, we add all three.\n    #\n    # This problem is about the minimum number of edges.\n    # If t=1 didn't work, it means for every component, for any two nodes u,v of the same color,\n    # they are already connected by an edge. This is a very specific graph structure.\n    # It means each partition (color 0 or color 1) has at most one node, or if it has more,\n    # all pairs are connected.\n    # For a bipartite graph, this means each component is a complete bipartite graph K_{c0,c1}.\n    # And if c0 >= 2, all pairs of color 0 nodes are connected. This is only possible if c0=2 and c1=0 or 1.\n    # For example, if c0=2, nodes {u,v} have color 0. If (u,v) exists, then ways_t1 for this pair is 0.\n    # If c0=3, nodes {u,v,w} have color 0. If (u,v) exists, (u,w) exists, (v,w) exists, then ways_t1 is 0.\n    # This implies that if ways_t1 is 0, then for any component, the number of nodes of a given color is at most 1,\n    # OR if it's more than 1, all pairs of nodes of that color are already connected.\n    # The latter case is impossible in a simple graph for more than 2 nodes of the same color,\n    # because it would require an odd cycle (e.g., K_3 is an odd cycle).\n    # So, if ways_t1 is 0, it means that for every component, c0 <= 1 or c1 <= 1.\n    # This means each component is a path or a star graph where the center is one color and leaves are the other.\n    # Or, more simply, each component has at most one node of color 0, or at most one node of color 1.\n    # This implies that each component is essentially a \"line\" of length at most 1 from the perspective of one color.\n    # e.g., if c0=1, c1=5, it's a star graph.\n    # If c0=0 or c1=0, it's a set of isolated nodes.\n    # So if ways_t1 is 0, every component has at most one node of color 0 OR at most one node of color 1.\n    # This means for any component, min(c0, c1) <= 1.\n    #\n    # Let's verify this. If a component has c0 >= 2 and c1 >= 2, then we can pick two nodes u, v of color 0.\n    # If (u, v) is not an edge, ways_t1 > 0.\n    # If (u, v) is an edge, this is an odd cycle (u-v-path-u where path is even). This contradicts bipartiteness.\n    # So, if ways_t1 is 0, it means for every component, either c0 < 2 or c1 < 2.\n    # This means for every component, min(c0, c1) <= 1.\n    #\n    # So, if ways_t1 is 0, then every component has at most one node of one of the colors.\n    # This implies that the graph is a collection of \"star-like\" components or paths.\n    # Example:\n    # 1-2, 2-3, 3-4, 4-1 (4 nodes, 4 edges) -> odd cycle, t=0\n    # 1-2, 2-3, 3-1 (3 nodes, 3 edges) -> odd cycle, t=0\n    # 1-2, 2-3, 3-4, 4-2 (4 nodes, 4 edges) -> 1-2-4-3-2 (not simple), 1-2-4, 2-3-4.\n    # This graph is bipartite: 1(0), 2(1), 3(0), 4(0). No, 1(0), 2(1), 3(0), 4(1).\n    # 1-2, 2-3, 3-4, 4-2.\n    # 1(0) -> 2(1)\n    # 2(1) -> 3(0)\n    # 3(0) -> 4(1)\n    # 4(1) -> 2(1) - conflict! So 4-2 is an odd cycle. t=0.\n    #\n    # The example input 1: 4 4, 1-2, 1-3, 4-2, 4-3\n    # 1(0) -> 2(1), 3(1)\n    # 4(0) -> 2(1), 3(1)\n    # This is bipartite. Component 1: {1,2,3,4}. Color 0: {1,4}, Color 1: {2,3}.\n    # c0=2, c1=2.\n    # Ways to add 1 edge:\n    # (1,4) not existing? Yes. Add (1,4). Forms 1-2-4-3-1 (length 4) or 1-3-4-2-1 (length 4).\n    # Wait, an odd cycle means an odd number of edges.\n    # If we add (1,4), we get cycle 1-2-4-3-1. Length 4. Even.\n    # Or 1-3-4-2-1. Length 4. Even.\n    #\n    # My understanding of \"add one edge to form an odd cycle\" is flawed.\n    # If graph is bipartite, and we add an edge (u, v) where u and v have the same color,\n    # say u_color = v_color = 0.\n    # There is a path P from u to v in the original bipartite graph.\n    # This path must have an even length (because it connects two nodes of the same color in a bipartite graph).\n    # Adding edge (u, v) creates a cycle: u -- P -- v -- u.\n    # The length of this cycle is (length of P) + 1.\n    # Since length of P is even, (length of P) + 1 is odd.\n    # So, adding an edge between two nodes of the same color *always* creates an odd cycle.\n    #\n    # For example 1: 4 4, 1-2, 1-3, 4-2, 4-3\n    # Bipartition: {1,4} (color 0), {2,3} (color 1).\n    # c0=2, c1=2.\n    # Ways to add 1 edge:\n    # Pick two nodes of color 0: (1,4). Is (1,4) an edge? No. Add (1,4). This forms an odd cycle.\n    # Pick two nodes of color 1: (2,3). Is (2,3) an edge? No. Add (2,3). This forms an odd cycle.\n    # So t=1, w=2. This matches example output. My logic for t=1 seems correct.\n\n    # If ways_t1 is 0, it means for every component, min(c0, c1) <= 1.\n    # This means each component is a collection of isolated nodes, or a star graph (or a path of length 1, i.e., an edge).\n    # E.g., {1}, {2}, {3,4} where 3-4 is an edge.\n    # In such a graph, we cannot pick two nodes of the same color that are not already connected.\n    # (Because if c0 >= 2, say {u,v} are color 0, then (u,v) must be an edge. But this is impossible in a bipartite graph unless c0=2 and c1=0 or 1.\n    # If c0=2, c1=0, then it's just two isolated nodes. If c0=2, c1=1, it's K_{2,1} which is a path of length 2 or a triangle if you consider the center node.\n    # If c0=2, c1=1, nodes {u,v} color 0, node {w} color 1. (u,v) cannot be an edge. So if c0=2 and c1>=1, then ways_t1 > 0.)\n    #\n    # So, ways_t1 == 0 implies that for every component, c0 <= 1 AND c1 <= 1.\n    # This means every component is either an isolated node or a single edge.\n    # Example: 3 0 (3 nodes, 0 edges)\n    # Components: {1}, {2}, {3}. Each has c0=1, c1=0 (or vice versa).\n    # ways_t1 = 0.\n    #\n    # In this case (t=2 or t=3):\n    # If ways_t1 is 0, then we need to add more edges.\n    #\n    # t=2:\n    # We need to pick two nodes u, v, w such that (u,v) and (v,w) exist, and add (u,w) to form a triangle.\n    # Or, pick two nodes u, v, w such that (u,v) exists, and add (u,w) and (v,w).\n    # Or, pick three nodes u,v,w and add (u,v), (v,w), (u,w). (This is t=3)\n    #\n    # If t=1 is not possible, it means every component is either an isolated node or a single edge.\n    # Example: {1}, {2}, {3,4} (3-4 edge).\n    # Total nodes: n. Total edges: m.\n    # Number of isolated nodes: n_isolated.\n    # Number of edges (components of size 2): n_edges_comp.\n    # Total components: n_isolated + n_edges_comp.\n    #\n    # To form an odd cycle with 2 added edges:\n    # We need to connect three distinct nodes A, B, C.\n    # If we add (A,B) and (B,C) and (A,C) is already there, that's 2 edges.\n    # This is not possible if t=1 ways_t1=0, because it implies no existing odd cycle.\n    #\n    # Consider connecting two different components.\n    # Let component A be {u_A}, component B be {u_B}. Add (u_A, u_B). Still bipartite.\n    # Let component A be {u_A, v_A} (edge u_A-v_A), component B be {u_B}.\n    # Add (u_A, u_B) and (v_A, u_B). This forms an odd cycle u_A-u_B-v_A-u_A (length 3).\n    # This needs 2 added edges.\n    #\n    # Number of nodes: n.\n    # Number of edges: m.\n    # Number of connected components (that are not just isolated nodes): `len(component_colors)`\n    #\n    # If ways_t1 == 0:\n    # Each component is a single node or a single edge.\n    #\n    # If there are at least 3 isolated nodes (n_isolated >= 3):\n    # Pick 3 isolated nodes A, B, C. Add (A,B) and (B,C) and (A,C). That's 3 edges.\n    #\n    # If there are at least 2 isolated nodes and 1 edge component:\n    # Isolated nodes: A, B. Edge component: C-D.\n    # Add (A,C) and (A,D). Cycle A-C-D-A. Length 3. 2 edges added.\n    # Ways: (num_isolated * (num_isolated - 1) / 2) * num_edge_components. (No, this is wrong.)\n    # Ways: num_isolated * num_edge_components * 2 (for C or D).\n    #\n    # Let's count nodes that are part of an edge component (degree >= 1).\n    # Let's count isolated nodes (degree = 0).\n    \n    num_isolated_nodes = 0\n    num_nodes_in_edges = 0\n    \n    for i in range(1, n + 1):\n        if not adj[i]:\n            num_isolated_nodes += 1\n        else:\n            num_nodes_in_edges += 1\n            \n    # t=2:\n    # Case 1: Connect an isolated node to an edge component.\n    # Pick an isolated node `u`. Pick an edge `(v, w)`. Add edges `(u, v)` and `(u, w)`.\n    # This forms a triangle `u-v-w-u`. Two edges added.\n    # Number of ways:\n    # `num_isolated_nodes` choices for `u`.\n    # `m` choices for `(v, w)`.\n    # Total ways = `num_isolated_nodes * m`.\n    # This covers `num_isolated_nodes > 0` and `m > 0`.\n    if num_isolated_nodes > 0 and m > 0:\n        print(f\"2 {num_isolated_nodes * m}\")\n        return\n\n    # t=3:\n    # If num_isolated_nodes >= 3:\n    # Pick 3 isolated nodes A, B, C. Add (A,B), (B,C), (A,C). Forms a triangle. 3 edges added.\n    # Ways: n_isolated * (n_isolated - 1) * (n_isolated - 2) / 6.\n    if num_isolated_nodes >= 3:\n        print(f\"3 {num_isolated_nodes * (num_isolated_nodes - 1) * (num_isolated_nodes - 2) // 6}\")\n        return\n\n    # If num_isolated_nodes = 2:\n    # A, B are isolated.\n    # If m=0: A, B, C, ... (all isolated). We need 3 isolated nodes for t=3.\n    # So if n_isolated = 2 and m=0, then n=2. Not possible to form an odd cycle.\n    # If n_isolated = 2 and m > 0, we would have caught it with t=2.\n    #\n    # If num_isolated_nodes = 1:\n    # A is isolated.\n    # If m=0: n=1. Not possible.\n    # If m>0: caught with t=2.\n    #\n    # If num_isolated_nodes = 0:\n    # All nodes have degree >= 1.\n    # If t=1 ways_t1=0, it means all components are single edges.\n    # This means the graph is a perfect matching (or a collection of disjoint edges).\n    # E.g., 1-2, 3-4, 5-6.\n    # We need to add 3 edges to form a triangle.\n    # Pick an edge (u,v). Pick another edge (x,y). Pick a third edge (a,b).\n    # To form an odd cycle:\n    # Pick 3 distinct nodes A, B, C.\n    # Add (A,B), (B,C), (C,A). This takes 3 edges.\n    # If there are 3 nodes, and no edges, we need 3 edges.\n    # If there are 3 nodes, and 1 edge (A-B), we need (B,C), (C,A). That's 2 edges.\n    # But this was covered by t=2 for isolated node + edge component.\n    #\n    # If ways_t1 is 0, then every component is a single node or a single edge.\n    # We are sure that if ways_t1 is 0, it means min(c0, c1) <= 1 for all components.\n    #\n    # Let's count nodes in different categories:\n    # `isolated_nodes`: nodes with degree 0.\n    # `edge_nodes`: nodes with degree > 0.\n    \n    # If ways_t1 > 0, we already printed \"1 ways_t1\".\n    # If ways_t1 == 0, then we know min(c0, c1) <= 1 for all components.\n    # This means each component is a path of length at most 1 (i.e., an isolated node or an edge).\n    \n    isolated_nodes_count = 0\n    nodes_in_edge_components_count = 0\n    \n    for i in range(1, n + 1):\n        if not adj[i]:\n            isolated_nodes_count += 1\n        else:\n            nodes_in_edge_components_count += 1\n            \n    # Number of edges in the graph is `m`.\n    # Number of components that are single edges: `m`.\n    # Number of isolated nodes: `isolated_nodes_count`.\n    \n    # If `isolated_nodes_count >= 1` and `m >= 1`:\n    #   Pick one isolated node `u`. Pick one existing edge `(v, w)`.\n    #   Add edges `(u, v)` and `(u, w)`. This forms a triangle `u-v-w-u`. 2 edges added.\n    #   Ways: `isolated_nodes_count * m`.\n    if isolated_nodes_count >= 1 and m >= 1:\n        print(f\"2 {isolated_nodes_count * m}\")\n        return\n        \n    # If `isolated_nodes_count >= 3`:\n    #   Pick three isolated nodes `u, v, w`. Add edges `(u, v), (v, w), (w, u)`. 3 edges added.\n    #   Ways: `isolated_nodes_count * (isolated_nodes_count - 1) * (isolated_nodes_count - 2) // 6`.\n    if isolated_nodes_count >= 3:\n        print(f\"3 {isolated_nodes_count * (isolated_nodes_count - 1) * (isolated_nodes_count - 2) // 6}\")\n        return\n\n    # If `isolated_nodes_count == 2` and `m == 0`: (n=2, 0 edges)\n    #   Cannot form an odd cycle. Max 2 nodes.\n    # If `isolated_nodes_count == 1` and `m == 0`: (n=1, 0 edges)\n    #   Cannot form an odd cycle. Max 1 node.\n    # If `isolated_nodes_count == 0` and `m == 0`: (n=0, 0 edges)\n    #   Cannot form an odd cycle.\n    \n    # What if `n < 3`?\n    # If n=1, 0 edges, output 3 1 (for 3 0 case). This is wrong.\n    # For 3 0: isolated_nodes_count=3, m=0. Output: 3 1. This is correct.\n    # My example output is 3 1 for input '3 0'.\n    # For n=1, 0 edges: isolated_nodes_count=1, m=0. Neither t=2 nor t=3 condition met.\n    # For n=2, 0 edges: isolated_nodes_count=2, m=0. Neither t=2 nor t=3 condition met.\n    # The problem states \"consisting of more than one vertex\".\n    # A cycle of length 3 needs 3 vertices.\n    # If n < 3, it's impossible to form a cycle of length 3.\n    # What if n=2? e.g., 2 0. isolated_nodes_count=2.\n    # Can we form an odd cycle? No, min length is 3.\n    # The problem implies such a cycle is always possible.\n    # \"minimum number of edges that must be added ... to form a simple cycle of an odd length\"\n    # This implies that `n` is large enough to form such a cycle.\n    # The minimum cycle length is 3. So we need at least 3 vertices.\n    # If n < 3, it's impossible.\n    # The constraints are n >= 1.\n    # If n=1, cannot form cycle.\n    # If n=2, cannot form cycle.\n    # The problem statement guarantees \"more than one vertex\".\n    # An odd cycle must have length >= 3.\n    # So if n < 3, there's no solution. But the problem implies there is always a solution.\n    # This means n >= 3 must hold for any valid test case.\n    \n    # If `isolated_nodes_count == 0` and `m >= 1`:\n    # All nodes have degree >= 1.\n    # And we know `ways_t1 == 0`, meaning every component is a single edge.\n    # So the graph is a collection of disjoint edges (a matching).\n    # E.g., 1-2, 3-4, 5-6.\n    # To form an odd cycle, we need to connect 3 nodes.\n    # Pick 3 nodes A, B, C.\n    # If A-B exists, B-C exists, C-A exists, this is t=0.\n    # If A-B exists, B-C exists, C-A does not exist, this is t=1. (But ways_t1 is 0, so this case is impossible)\n    #\n    # So we need to add 3 edges.\n    # Pick 3 distinct nodes u, v, w.\n    # Add (u,v), (v,w), (w,u).\n    # The number of such ways is `n * (n - 1) * (n - 2) // 6`.\n    # But we need to subtract cases where one or more of these edges already exist.\n    # If ways_t1 == 0 and isolated_nodes_count == 0:\n    # Graph is a perfect matching (or a set of disjoint edges).\n    # Number of nodes `n`. Number of edges `m`.\n    # `n` must be even. `m = n / 2`.\n    # Example: n=4, m=2. Edges: 1-2, 3-4.\n    # We need to add 3 edges.\n    # Pick 3 nodes, say 1, 3, 4. Add (1,3), (3,4), (4,1).\n    # (3,4) exists. So we add (1,3) and (4,1). This is t=2.\n    # This is exactly the \"pick an edge and an isolated node\" type of operation, but here there are no isolated nodes.\n    #\n    # So if `isolated_nodes_count == 0` and `ways_t1 == 0`:\n    # This means the graph is a collection of disjoint edges.\n    # `m` edges, `2*m` nodes. `n - 2*m` isolated nodes (which is 0 here).\n    #\n    # To form an odd cycle with 2 added edges:\n    # Pick an existing edge (u, v). Pick another existing edge (x, y).\n    # Add (u, x) and (v, x). This forms u-x-v-u. (u,v) exists.\n    # This is 2 edges added.\n    # Number of ways:\n    # Choose an existing edge (u,v): `m` ways.\n    # Choose another existing edge (x,y): `m-1` ways.\n    # Choose one endpoint from (x,y) to connect to both u and v: 2 ways (x or y).\n    # This forms a cycle (u-v-x-u) or (u-v-y-u).\n    # This is `m * (m - 1) * 2`. But this counts ordered pairs of edges, and also (x,y) vs (y,x).\n    #\n    # Let's be more precise for t=2.\n    # If ways_t1 == 0 and isolated_nodes_count == 0:\n    # The graph consists of `m` disjoint edges.\n    # We need to pick two edges `(u, v)` and `(x, y)`.\n    # Then we add two edges to form an odd cycle.\n    # E.g., add `(u, x)` and `(v, x)`. This forms a triangle `u-v-x-u`. (u,v) exists.\n    # Number of ways to choose two distinct edges: `m * (m - 1) / 2`.\n    # For each pair of edges `{(u,v), (x,y)}`:\n    #   We can pick `u` or `v` from the first edge, and `x` or `y` from the second.\n    #   To form a triangle with 2 added edges, we need to pick one node from one edge, say `u`,\n    #   and both nodes from the other edge, `x` and `y`.\n    #   Then add `(u,x)` and `(u,y)`. This forms a cycle `u-x-y-u`. (x,y) exists.\n    #   The nodes are `u, x, y`.\n    #   Ways to pick `u`: `n` choices.\n    #   Ways to pick edge `(x,y)`: `m` choices.\n    #   But `u` cannot be `x` or `y`.\n    #\n    # Let's re-evaluate t=2 for the case `isolated_nodes_count == 0` and `ways_t1 == 0`.\n    # Graph is a perfect matching (or disjoint edges).\n    # We need to find 3 distinct nodes A, B, C such that 1 edge exists and 2 edges are added.\n    # Or, 2 edges exist and 1 edge is added. (This would be t=1, which is 0).\n    # So, 1 edge exists, 2 edges are added.\n    # Let (A,B) be an existing edge. We need to find a node C not A or B.\n    # Add (A,C) and (B,C). This forms a triangle A-B-C-A.\n    # Ways:\n    # 1. Choose an existing edge (A,B): `m` ways.\n    # 2. Choose a third node C such that C is not A or B.\n    #    Since `isolated_nodes_count == 0`, C must be part of another existing edge (C,D).\n    #    Number of choices for C: `n - 2` ways.\n    #    For each such C, we need to check if (A,C) and (B,C) exist. They cannot exist.\n    #    The `n-2` nodes are partitioned into `m-1` other edges.\n    #    So we pick an existing edge (A,B).\n    #    We pick another node C from the remaining `n-2` nodes.\n    #    There are `n-2` choices for C.\n    #    Total ways: `m * (n - 2)`.\n    #    Example: 1-2, 3-4. n=4, m=2.\n    #    Pick (1,2).\n    #    C can be 3 or 4.\n    #    If C=3: add (1,3) and (2,3). Forms 1-2-3-1. 2 edges added.\n    #    If C=4: add (1,4) and (2,4). Forms 1-2-4-1. 2 edges added.\n    #    Total ways = `m * (n - 2) = 2 * (4 - 2) = 4`.\n    #    This seems correct.\n    # This implies `n >= 3`.\n    if isolated_nodes_count == 0 and m >= 1: # implies n is even, n >= 2. If n=2, m=1. n-2=0.\n        if n >= 3: # To pick a third node C\n            print(f\"2 {m * (n - 2)}\")\n            return\n        else: # n=2, m=1. (e.g., 2 1, 1-2). Cannot form odd cycle.\n            # This case should not happen based on problem constraints or interpretation.\n            # If n=2, m=1, then the only graph is 1-2. No odd cycle possible.\n            # The problem implies there's always a way.\n            # This means if n=2, it won't be given. So n >= 3 always.\n            pass # Fall through to t=3 logic if n=2 is not possible.\n\n    # Final fallback if nothing else worked (should only be for n < 3, or n=3, m=0).\n    # If n=3, m=0: isolated_nodes_count = 3. This is caught by t=3 condition above.\n    # If n=1 or n=2, this should not be reachable if problem implies a solution.\n    # If we reach here, it implies we have not found a solution with t=0, 1, or 2.\n    # This means the only possibility left is t=3.\n    # And the only way to get t=3 is to pick 3 nodes and add all 3 edges to form a triangle.\n    # This is covered by `isolated_nodes_count >= 3`.\n    # What if `isolated_nodes_count < 3`?\n    # e.g., n=3, m=1 (1-2). isolated_nodes_count=1 (node 3). m=1.\n    # This is covered by t=2 condition: `isolated_nodes_count * m = 1 * 1 = 1`.\n    # Output: 2 1.\n    #\n    # So if we reach here, it implies that the graph is such that no odd cycle can be formed with t=0,1,2.\n    # This can only happen if n < 3. But the problem implies a solution.\n    #\n    # The only remaining case is if n=3, m=0.\n    # Input: 3 0. Output: 3 1.\n    # My code for 3 0:\n    # ways_t1 = 0.\n    # isolated_nodes_count = 3, m = 0.\n    # t=2 condition `isolated_nodes_count >= 1 and m >= 1` is false.\n    # t=3 condition `isolated_nodes_count >= 3` is true. `3 * 2 * 1 // 6 = 1`.\n    # Output: 3 1. Correct.\n\n    # It seems all cases are covered.\n    # The logic for `isolated_nodes_count == 0 and ways_t1 == 0` is `m * (n - 2)`.\n    # Example: 4 2, 1-2, 3-4.\n    # isolated_nodes_count = 0, m=2.\n    # `ways_t1 = 0` (no nodes of same color within a component that aren't already connected)\n    # This graph is bipartite: {1,3} (color 0), {2,4} (color 1).\n    # Component 1: {1,2}, c0=1, c1=1. Component 2: {3,4}, c0=1, c1=1.\n    # So indeed `ways_t1` is 0.\n    # The condition `isolated_nodes_count == 0 and m >= 1` is met.\n    # `n=4, m=2`. Output: `2 {2 * (4-2)} = 2 4`.\n    # This is correct.\n    # Ways:\n    # 1. Pick (1,2). C can be 3 or 4. Add (1,3), (2,3) -> triangle 1-2-3-1. Add (1,4), (2,4) -> triangle 1-2-4-1.\n    # 2. Pick (3,4). C can be 1 or 2. Add (3,1), (4,1) -> triangle 3-4-1-3. Add (3,2), (4,2) -> triangle 3-4-2-3.\n    # Total 4 ways.\n\n    # If the code reaches here, it means n < 3.\n    # The problem implies a solution always exists.\n    # So this path should not be taken in competitive programming.\n    # If it is, it means the problem constraints are not as expected or my interpretation is wrong.\n    # The problem statement guarantees \"more than one vertex\".\n    # An odd cycle must have length at least 3. So n must be at least 3.\n    # If n < 3, it's impossible.\n    # If the input guarantees n >= 3, then one of the conditions above must be met.\n    # So this `sys.exit(1)` should not be reached.\n    sys.exit(1) # Should not be reached if problem guarantees a solution.\n\nsolve()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 594,
        "completion_token_count": 9884,
        "thoughts_token_count": 0
    }
}