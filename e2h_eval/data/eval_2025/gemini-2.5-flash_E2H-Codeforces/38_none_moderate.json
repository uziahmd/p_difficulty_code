{
    "start": 1758293706.769874,
    "end": 1758293741.5351665,
    "start-formatted": "2025-09-19 23:55 KST",
    "end-formatted": "2025-09-19 23:55 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "",
    "response": "```python\ndef solve():\n    p = int(input())\n\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    min_nodes = float('inf')\n    max_unidirectional = -1\n\n    # Iterate through possible numbers of nodes 'n'\n    # The maximum possible p for n nodes is n * (n-1) / 2.\n    # So n * (n-1) / 2 >= p => n^2 - n - 2p >= 0.\n    # For large p, n approx sqrt(2p).\n    # We can set an upper bound for n, e.g., 2 * sqrt(2 * 2e5) approx 2 * 632 = 1264.\n    # A safer upper bound would be around 700-800 for p=2e5.\n    # For p=2e5, max n is 633.\n    # Let's try n from 1 up to 700.\n    for n_scc in range(1, 701):\n        # Calculate the number of pairs reachable within the SCC\n        # This is n_scc * (n_scc - 1) / 2\n        p_scc = n_scc * (n_scc - 1) // 2\n\n        if p_scc > p:\n            continue\n\n        remaining_p = p - p_scc\n\n        # We need to add 'k' isolated nodes to account for remaining_p\n        # Each isolated node 'k' can form 'k' pairs with nodes in the SCC if it's connected to them.\n        # However, the problem states 'u < v' and 'u' and 'v' are reachable from each other.\n        # This implies that the 'p' pairs must be within an SCC.\n        # So, if p_scc < p, it means we need more nodes in the SCC, or we made a mistake in understanding.\n        # The problem states \"u < v and u and v are reachable from each other\".\n        # This means these pairs (u, v) must belong to the same SCC.\n        # So, the total number of such pairs 'p' must be equal to the sum of p_i * (p_i - 1) / 2 for all SCCs of size p_i.\n        # To minimize nodes, we want to put all 'p' pairs into a single SCC.\n        # So, p_scc must be exactly p.\n        if p_scc == p:\n            current_n = n_scc\n            # If we have exactly p pairs within one SCC of size n_scc,\n            # then the minimum number of nodes is n_scc.\n            # Now we need to maximize unidirectional pairs.\n            # Unidirectional pairs are formed between nodes in different SCCs.\n            # Let's say we have k SCCs.\n            # We want to maximize (total nodes) * (total nodes - 1) - (sum of (size_i * (size_i - 1)))\n            # No, it's (N choose 2) - sum( (size_i choose 2) ) if we consider all pairs (u,v) where u!=v.\n            # The problem definition: \"unidirectional if u != v, there exists a path from u to v, and there are no paths from v to u.\"\n            # This means u and v are in different SCCs, and there's a path from u's SCC to v's SCC.\n            # To maximize unidirectional pairs, we want to maximize the number of distinct SCCs and connect them linearly.\n            # If we have one SCC of size n_scc (which gives us 'p' pairs), and we have 'k' other isolated nodes,\n            # we can connect them in a line: node1 -> node2 -> ... -> node_k -> SCC.\n            # The total number of nodes would be n_scc + k.\n            # Unidirectional pairs:\n            # - Between SCC and an isolated node: If node_i -> SCC, then n_scc pairs (node_i, u) for u in SCC.\n            # - Between isolated nodes: If node_i -> node_j, then 1 pair (node_i, node_j).\n            # To maximize unidirectional pairs, we should have as many \"non-SCC\" nodes as possible,\n            # and connect them all to the single SCC.\n            # If we have n_scc nodes in the SCC, and 'k' other nodes, let's call them x_1, ..., x_k.\n            # We can make a structure like: x_1 -> x_2 -> ... -> x_k -> SCC.\n            # Total nodes = n_scc + k.\n            # Unidirectional pairs:\n            # - Between x_i and x_j (i < j): k * (k-1) / 2 pairs.\n            # - Between x_i and SCC: k * n_scc pairs.\n            # Total unidirectional = k * (k-1) / 2 + k * n_scc.\n            # We want to maximize this value for the minimum n_scc.\n            # However, the problem asks for the minimum number of nodes required *to create a p-reachable graph*.\n            # This means the total number of nodes in the graph.\n            # So, if we found n_scc such that n_scc * (n_scc - 1) / 2 = p, then n_scc is a candidate for min_nodes.\n            # In this case, we don't need any additional nodes to satisfy the 'p' condition.\n            # So, the minimum number of nodes is n_scc.\n            # All other nodes (if any) would just be isolated or form other SCCs, but to minimize nodes,\n            # we just use n_scc nodes.\n            # With only n_scc nodes, all in one SCC, there are no unidirectional pairs.\n            # So, max_unidirectional would be 0.\n\n            # This interpretation of \"minimum number of nodes required\" seems to lead to 0 unidirectional pairs.\n            # Let's re-read: \"Find the minimum number of nodes required to create a p-reachable directed graph.\n            # Also, among all such p-reachable directed graphs with the minimum number of nodes,\n            # let G denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\"\n\n            # This means we fix the minimum number of nodes, say N_min.\n            # Then, among all graphs with N_min nodes that are p-reachable, find the one with max unidirectional pairs.\n\n            # To make a graph p-reachable with N nodes, we need to partition N nodes into SCCs.\n            # Let the SCCs have sizes s_1, s_2, ..., s_k. Sum(s_i) = N.\n            # The total number of pairs (u, v) with u < v and u, v reachable from each other is\n            # sum_{i=1 to k} (s_i * (s_i - 1) / 2). This sum must be equal to p.\n            # To minimize N for a fixed p, we want to use as few SCCs as possible, and make them as large as possible.\n            # Specifically, we want to put all 'p' pairs into a single SCC.\n            # So, we are looking for the smallest n_scc such that n_scc * (n_scc - 1) / 2 >= p.\n            # If n_scc * (n_scc - 1) / 2 = p, then we use exactly n_scc nodes, all in one SCC.\n            # If n_scc * (n_scc - 1) / 2 > p, then we use n_scc nodes, and we can form an SCC of size 'x'\n            # such that x * (x-1)/2 = p. But this doesn't guarantee min nodes.\n            # The optimal strategy to get 'p' reachable-from-each-other pairs with minimum nodes\n            # is to find the smallest 'n' such that n * (n-1)/2 >= p.\n            # Let this smallest 'n' be N_min.\n            # Within these N_min nodes, we must have exactly 'p' pairs.\n            # This means we form one SCC of size 's' such that s * (s-1)/2 = p_target,\n            # and potentially other SCCs of size 1 (isolated nodes).\n            # The sum of s_i * (s_i - 1) / 2 must be exactly p.\n            # To minimize total nodes, we want to make one SCC as large as possible.\n            # So we find the largest 's' such that s * (s-1)/2 <= p.\n            # Let this 's' be `s_main`.\n            # Then p_main = s_main * (s_main - 1) / 2.\n            # We have `p - p_main` pairs remaining. These must be formed by other SCCs.\n            # Each additional SCC of size 2 contributes 1 pair.\n            # So we need `p - p_main` SCCs of size 2.\n            # The total nodes would be `s_main + 2 * (p - p_main)`.\n            # This is the minimum number of nodes.\n\n            # Let's try this approach.\n            # Find largest 's' such that s * (s-1)/2 <= p.\n            s_main = 0\n            for s_cand in range(1, 701): # s_cand can go up to 633 for p=2e5\n                if s_cand * (s_cand - 1) // 2 <= p:\n                    s_main = s_cand\n                else:\n                    break\n\n            p_main = s_main * (s_main - 1) // 2\n            remaining_p = p - p_main\n\n            # Each remaining_p pair must come from an SCC of size 2.\n            # This adds 2 nodes for each such pair.\n            # Total nodes = s_main + 2 * remaining_p.\n            current_min_nodes = s_main + 2 * remaining_p\n\n            # Now, for this `current_min_nodes`, we need to maximize unidirectional pairs.\n            # We have one SCC of size `s_main`.\n            # We have `remaining_p` SCCs of size 2.\n            # And we have `current_min_nodes - s_main - 2 * remaining_p` isolated nodes (SCCs of size 1).\n            # This simplifies to: we have `s_main` nodes in one SCC, and `remaining_p` SCCs of size 2.\n            # The total number of SCCs is `1 + remaining_p`.\n            # To maximize unidirectional pairs, we arrange all these SCCs in a line.\n            # Let N_scc = 1 + remaining_p be the number of SCCs.\n            # Let their sizes be `s_main`, `2`, `2`, ..., `2`.\n            # Total nodes N = current_min_nodes.\n            # If we arrange them as SCC_1 -> SCC_2 -> ... -> SCC_{N_scc}.\n            # Number of unidirectional pairs = Sum_{i < j} (size_i * size_j).\n            # To maximize this, we want to make the sizes as different as possible, and connect them all.\n            # The maximum number of unidirectional pairs in a graph with N nodes and k SCCs with sizes s_1, ..., s_k\n            # is achieved when all SCCs are arranged in a single path.\n            # If SCC_1 -> SCC_2 -> ... -> SCC_k, the number of unidirectional pairs is\n            # sum_{i=1 to k} sum_{j=i+1 to k} (s_i * s_j).\n            # This is equivalent to ( (sum s_i)^2 - sum (s_i^2) ) / 2.\n            # (sum s_i) = N.\n            # So it's (N^2 - sum(s_i^2)) / 2.\n            # To maximize this, we need to minimize sum(s_i^2).\n            # To minimize sum(s_i^2) for a fixed sum(s_i)=N, we want the s_i to be as equal as possible.\n            # However, the sizes s_i are constrained by the 'p' value.\n            # We have `s_main` nodes in one SCC, and `remaining_p` SCCs of size 2.\n            # The remaining nodes are 1-node SCCs.\n            # So, we have:\n            # - One SCC of size `s_main`.\n            # - `remaining_p` SCCs of size 2.\n            # - `current_min_nodes - s_main - 2 * remaining_p` SCCs of size 1.\n            num_1_scc = current_min_nodes - s_main - 2 * remaining_p\n\n            # The actual sizes of the SCCs are:\n            scc_sizes = []\n            if s_main > 0:\n                scc_sizes.append(s_main)\n            for _ in range(remaining_p):\n                scc_sizes.append(2)\n            for _ in range(num_1_scc):\n                scc_sizes.append(1)\n\n            # If s_main is 0, and p is not 0, it means p_main is 0, and remaining_p = p.\n            # So we have p SCCs of size 2. Total nodes = 2p.\n            # And 0 SCCs of size 1.\n            # In this case, scc_sizes will be [2, 2, ..., 2] (p times).\n\n            # Calculate sum(s_i^2)\n            sum_sq_s = sum(s * s for s in scc_sizes)\n\n            # Calculate max unidirectional pairs\n            current_max_unidirectional = (current_min_nodes * current_min_nodes - sum_sq_s) // 2\n\n            # This is the maximum possible unidirectional pairs for *any* graph with these SCC sizes.\n            # We have fixed the total number of nodes to `current_min_nodes`.\n            # This structure gives exactly `p` reachable-from-each-other pairs.\n            # And it maximizes unidirectional pairs for this fixed set of SCC sizes.\n\n            # Since we are iterating to find `s_main` (which determines `current_min_nodes`),\n            # and we are looking for the absolute minimum `current_min_nodes`,\n            # we should update `min_nodes` and `max_unidirectional` only when `current_min_nodes` is smaller.\n            # If `current_min_nodes` is equal to `min_nodes`, we update `max_unidirectional` if it's larger.\n\n            if current_min_nodes < min_nodes:\n                min_nodes = current_min_nodes\n                max_unidirectional = current_max_unidirectional\n            elif current_min_nodes == min_nodes:\n                max_unidirectional = max(max_unidirectional, current_max_unidirectional)\n            \n            # The loop for s_main only finds the largest s_main such that s_main*(s_main-1)/2 <= p.\n            # This `s_main` directly gives the minimum number of nodes.\n            # There is only one unique `s_main` that leads to the minimum `current_min_nodes`.\n            # So we can break after finding the first valid `s_main`.\n            # This means the iteration for `n_scc` (which was `s_cand`) is just to find the correct `s_main`.\n            # Once `s_main` is found, `current_min_nodes` is fixed.\n            # So the outer loop should not be `for n_scc in range(1, 701)`.\n            # It should be: find `s_main` first, then calculate.\n\n            # Let's restart with the correct logic.\n            # 1. Find the largest `s` such that `s * (s - 1) / 2 <= p`. Let this be `s_val`.\n            # 2. Calculate `p_s = s_val * (s_val - 1) / 2`.\n            # 3. `remaining_p_val = p - p_s`.\n            # 4. The minimum number of nodes `N_min` is `s_val + 2 * remaining_p_val`.\n            # 5. The SCC structure is: one SCC of size `s_val`, and `remaining_p_val` SCCs of size 2.\n            #    The total number of nodes is exactly `N_min`. No isolated nodes are needed.\n            # 6. Calculate `max_unidirectional` for this `N_min` and this SCC structure.\n\n    s_val = 0\n    for s_cand in range(1, 701):\n        if s_cand * (s_cand - 1) // 2 <= p:\n            s_val = s_cand\n        else:\n            break\n\n    p_s = s_val * (s_val - 1) // 2\n    remaining_p_val = p - p_s\n\n    N_min = s_val + 2 * remaining_p_val\n\n    scc_sizes_for_max_uni = []\n    if s_val > 0: # If s_val is 0, it means p=0, but we already handled p=0. So s_val will be >=1 for p>0.\n        scc_sizes_for_max_uni.append(s_val)\n    for _ in range(remaining_p_val):\n        scc_sizes_for_max_uni.append(2)\n\n    sum_sq_s = sum(s * s for s in scc_sizes_for_max_uni)\n    max_unidirectional = (N_min * N_min - sum_sq_s) // 2\n\n    print(f\"{N_min} {max_unidirectional}\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "def solve():\n    p = int(input())\n\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    min_nodes = float('inf')\n    max_unidirectional = -1\n\n    # Iterate through possible numbers of nodes 'n'\n    # The maximum possible p for n nodes is n * (n-1) / 2.\n    # So n * (n-1) / 2 >= p => n^2 - n - 2p >= 0.\n    # For large p, n approx sqrt(2p).\n    # We can set an upper bound for n, e.g., 2 * sqrt(2 * 2e5) approx 2 * 632 = 1264.\n    # A safer upper bound would be around 700-800 for p=2e5.\n    # For p=2e5, max n is 633.\n    # Let's try n from 1 up to 700.\n    for n_scc in range(1, 701):\n        # Calculate the number of pairs reachable within the SCC\n        # This is n_scc * (n_scc - 1) / 2\n        p_scc = n_scc * (n_scc - 1) // 2\n\n        if p_scc > p:\n            continue\n\n        remaining_p = p - p_scc\n\n        # We need to add 'k' isolated nodes to account for remaining_p\n        # Each isolated node 'k' can form 'k' pairs with nodes in the SCC if it's connected to them.\n        # However, the problem states 'u < v' and 'u' and 'v' are reachable from each other.\n        # This implies that the 'p' pairs must be within an SCC.\n        # So, if p_scc < p, it means we need more nodes in the SCC, or we made a mistake in understanding.\n        # The problem states \"u < v and u and v are reachable from each other\".\n        # This means these pairs (u, v) must belong to the same SCC.\n        # So, the total number of such pairs 'p' must be equal to the sum of p_i * (p_i - 1) / 2 for all SCCs of size p_i.\n        # To minimize nodes, we want to put all 'p' pairs into a single SCC.\n        # So, p_scc must be exactly p.\n        if p_scc == p:\n            current_n = n_scc\n            # If we have exactly p pairs within one SCC of size n_scc,\n            # then the minimum number of nodes is n_scc.\n            # Now we need to maximize unidirectional pairs.\n            # Unidirectional pairs are formed between nodes in different SCCs.\n            # Let's say we have k SCCs.\n            # We want to maximize (total nodes) * (total nodes - 1) - (sum of (size_i * (size_i - 1)))\n            # No, it's (N choose 2) - sum( (size_i choose 2) ) if we consider all pairs (u,v) where u!=v.\n            # The problem definition: \"unidirectional if u != v, there exists a path from u to v, and there are no paths from v to u.\"\n            # This means u and v are in different SCCs, and there's a path from u's SCC to v's SCC.\n            # To maximize unidirectional pairs, we want to maximize the number of distinct SCCs and connect them linearly.\n            # If we have one SCC of size n_scc (which gives us 'p' pairs), and we have 'k' other isolated nodes,\n            # we can connect them in a line: node1 -> node2 -> ... -> node_k -> SCC.\n            # The total number of nodes would be n_scc + k.\n            # Unidirectional pairs:\n            # - Between SCC and an isolated node: If node_i -> SCC, then n_scc pairs (node_i, u) for u in SCC.\n            # - Between isolated nodes: If node_i -> node_j, then 1 pair (node_i, node_j).\n            # To maximize unidirectional pairs, we should have as many \"non-SCC\" nodes as possible,\n            # and connect them all to the single SCC.\n            # If we have n_scc nodes in the SCC, and 'k' other nodes, let's call them x_1, ..., x_k.\n            # We can make a structure like: x_1 -> x_2 -> ... -> x_k -> SCC.\n            # Total nodes = n_scc + k.\n            # Unidirectional pairs:\n            # - Between x_i and x_j (i < j): k * (k-1) / 2 pairs.\n            # - Between x_i and SCC: k * n_scc pairs.\n            # Total unidirectional = k * (k-1) / 2 + k * n_scc.\n            # We want to maximize this value for the minimum n_scc.\n            # However, the problem asks for the minimum number of nodes required *to create a p-reachable graph*.\n            # This means the total number of nodes in the graph.\n            # So, if we found n_scc such that n_scc * (n_scc - 1) / 2 = p, then n_scc is a candidate for min_nodes.\n            # In this case, we don't need any additional nodes to satisfy the 'p' condition.\n            # So, the minimum number of nodes is n_scc.\n            # All other nodes (if any) would just be isolated or form other SCCs, but to minimize nodes,\n            # we just use n_scc nodes.\n            # With only n_scc nodes, all in one SCC, there are no unidirectional pairs.\n            # So, max_unidirectional would be 0.\n\n            # This interpretation of \"minimum number of nodes required\" seems to lead to 0 unidirectional pairs.\n            # Let's re-read: \"Find the minimum number of nodes required to create a p-reachable directed graph.\n            # Also, among all such p-reachable directed graphs with the minimum number of nodes,\n            # let G denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\"\n\n            # This means we fix the minimum number of nodes, say N_min.\n            # Then, among all graphs with N_min nodes that are p-reachable, find the one with max unidirectional pairs.\n\n            # To make a graph p-reachable with N nodes, we need to partition N nodes into SCCs.\n            # Let the SCCs have sizes s_1, s_2, ..., s_k. Sum(s_i) = N.\n            # The total number of pairs (u, v) with u < v and u, v reachable from each other is\n            # sum_{i=1 to k} (s_i * (s_i - 1) / 2). This sum must be equal to p.\n            # To minimize N for a fixed p, we want to use as few SCCs as possible, and make them as large as possible.\n            # Specifically, we want to put all 'p' pairs into a single SCC.\n            # So, we are looking for the smallest n_scc such that n_scc * (n_scc - 1) / 2 >= p.\n            # If n_scc * (n_scc - 1) / 2 = p, then we use exactly n_scc nodes, all in one SCC.\n            # If n_scc * (n_scc - 1) / 2 > p, then we use n_scc nodes, and we can form an SCC of size 'x'\n            # such that x * (x-1)/2 = p. But this doesn't guarantee min nodes.\n            # The optimal strategy to get 'p' reachable-from-each-other pairs with minimum nodes\n            # is to find the smallest 'n' such that n * (n-1)/2 >= p.\n            # Let this smallest 'n' be N_min.\n            # Within these N_min nodes, we must have exactly 'p' pairs.\n            # This means we form one SCC of size 's' such that s * (s-1)/2 = p_target,\n            # and potentially other SCCs of size 1 (isolated nodes).\n            # The sum of s_i * (s_i - 1) / 2 must be exactly p.\n            # To minimize total nodes, we want to make one SCC as large as possible.\n            # So we find the largest 's' such that s * (s-1)/2 <= p.\n            # Let this 's' be `s_main`.\n            # Then p_main = s_main * (s_main - 1) / 2.\n            # We have `p - p_main` pairs remaining. These must be formed by other SCCs.\n            # Each additional SCC of size 2 contributes 1 pair.\n            # So we need `p - p_main` SCCs of size 2.\n            # The total nodes would be `s_main + 2 * (p - p_main)`.\n            # This is the minimum number of nodes.\n\n            # Let's try this approach.\n            # Find largest 's' such that s * (s-1)/2 <= p.\n            s_main = 0\n            for s_cand in range(1, 701): # s_cand can go up to 633 for p=2e5\n                if s_cand * (s_cand - 1) // 2 <= p:\n                    s_main = s_cand\n                else:\n                    break\n\n            p_main = s_main * (s_main - 1) // 2\n            remaining_p = p - p_main\n\n            # Each remaining_p pair must come from an SCC of size 2.\n            # This adds 2 nodes for each such pair.\n            # Total nodes = s_main + 2 * remaining_p.\n            current_min_nodes = s_main + 2 * remaining_p\n\n            # Now, for this `current_min_nodes`, we need to maximize unidirectional pairs.\n            # We have one SCC of size `s_main`.\n            # We have `remaining_p` SCCs of size 2.\n            # And we have `current_min_nodes - s_main - 2 * remaining_p` isolated nodes (SCCs of size 1).\n            # This simplifies to: we have `s_main` nodes in one SCC, and `remaining_p` SCCs of size 2.\n            # The total number of SCCs is `1 + remaining_p`.\n            # To maximize unidirectional pairs, we arrange all these SCCs in a line.\n            # Let N_scc = 1 + remaining_p be the number of SCCs.\n            # Let their sizes be `s_main`, `2`, `2`, ..., `2`.\n            # Total nodes N = current_min_nodes.\n            # If we arrange them as SCC_1 -> SCC_2 -> ... -> SCC_{N_scc}.\n            # Number of unidirectional pairs = Sum_{i < j} (size_i * size_j).\n            # To maximize this, we want to make the sizes as different as possible, and connect them all.\n            # The maximum number of unidirectional pairs in a graph with N nodes and k SCCs with sizes s_1, ..., s_k\n            # is achieved when all SCCs are arranged in a single path.\n            # If SCC_1 -> SCC_2 -> ... -> SCC_k, the number of unidirectional pairs is\n            # sum_{i=1 to k} sum_{j=i+1 to k} (s_i * s_j).\n            # This is equivalent to ( (sum s_i)^2 - sum (s_i^2) ) / 2.\n            # (sum s_i) = N.\n            # So it's (N^2 - sum(s_i^2)) / 2.\n            # To maximize this, we need to minimize sum(s_i^2).\n            # To minimize sum(s_i^2) for a fixed sum(s_i)=N, we want the s_i to be as equal as possible.\n            # However, the sizes s_i are constrained by the 'p' value.\n            # We have `s_main` nodes in one SCC, and `remaining_p` SCCs of size 2.\n            # The remaining nodes are 1-node SCCs.\n            # So, we have:\n            # - One SCC of size `s_main`.\n            # - `remaining_p` SCCs of size 2.\n            # - `current_min_nodes - s_main - 2 * remaining_p` SCCs of size 1.\n            num_1_scc = current_min_nodes - s_main - 2 * remaining_p\n\n            # The actual sizes of the SCCs are:\n            scc_sizes = []\n            if s_main > 0:\n                scc_sizes.append(s_main)\n            for _ in range(remaining_p):\n                scc_sizes.append(2)\n            for _ in range(num_1_scc):\n                scc_sizes.append(1)\n\n            # If s_main is 0, and p is not 0, it means p_main is 0, and remaining_p = p.\n            # So we have p SCCs of size 2. Total nodes = 2p.\n            # And 0 SCCs of size 1.\n            # In this case, scc_sizes will be [2, 2, ..., 2] (p times).\n\n            # Calculate sum(s_i^2)\n            sum_sq_s = sum(s * s for s in scc_sizes)\n\n            # Calculate max unidirectional pairs\n            current_max_unidirectional = (current_min_nodes * current_min_nodes - sum_sq_s) // 2\n\n            # This is the maximum possible unidirectional pairs for *any* graph with these SCC sizes.\n            # We have fixed the total number of nodes to `current_min_nodes`.\n            # This structure gives exactly `p` reachable-from-each-other pairs.\n            # And it maximizes unidirectional pairs for this fixed set of SCC sizes.\n\n            # Since we are iterating to find `s_main` (which determines `current_min_nodes`),\n            # and we are looking for the absolute minimum `current_min_nodes`,\n            # we should update `min_nodes` and `max_unidirectional` only when `current_min_nodes` is smaller.\n            # If `current_min_nodes` is equal to `min_nodes`, we update `max_unidirectional` if it's larger.\n\n            if current_min_nodes < min_nodes:\n                min_nodes = current_min_nodes\n                max_unidirectional = current_max_unidirectional\n            elif current_min_nodes == min_nodes:\n                max_unidirectional = max(max_unidirectional, current_max_unidirectional)\n            \n            # The loop for s_main only finds the largest s_main such that s_main*(s_main-1)/2 <= p.\n            # This `s_main` directly gives the minimum number of nodes.\n            # There is only one unique `s_main` that leads to the minimum `current_min_nodes`.\n            # So we can break after finding the first valid `s_main`.\n            # This means the iteration for `n_scc` (which was `s_cand`) is just to find the correct `s_main`.\n            # Once `s_main` is found, `current_min_nodes` is fixed.\n            # So the outer loop should not be `for n_scc in range(1, 701)`.\n            # It should be: find `s_main` first, then calculate.\n\n            # Let's restart with the correct logic.\n            # 1. Find the largest `s` such that `s * (s - 1) / 2 <= p`. Let this be `s_val`.\n            # 2. Calculate `p_s = s_val * (s_val - 1) / 2`.\n            # 3. `remaining_p_val = p - p_s`.\n            # 4. The minimum number of nodes `N_min` is `s_val + 2 * remaining_p_val`.\n            # 5. The SCC structure is: one SCC of size `s_val`, and `remaining_p_val` SCCs of size 2.\n            #    The total number of nodes is exactly `N_min`. No isolated nodes are needed.\n            # 6. Calculate `max_unidirectional` for this `N_min` and this SCC structure.\n\n    s_val = 0\n    for s_cand in range(1, 701):\n        if s_cand * (s_cand - 1) // 2 <= p:\n            s_val = s_cand\n        else:\n            break\n\n    p_s = s_val * (s_val - 1) // 2\n    remaining_p_val = p - p_s\n\n    N_min = s_val + 2 * remaining_p_val\n\n    scc_sizes_for_max_uni = []\n    if s_val > 0: # If s_val is 0, it means p=0, but we already handled p=0. So s_val will be >=1 for p>0.\n        scc_sizes_for_max_uni.append(s_val)\n    for _ in range(remaining_p_val):\n        scc_sizes_for_max_uni.append(2)\n\n    sum_sq_s = sum(s * s for s in scc_sizes_for_max_uni)\n    max_unidirectional = (N_min * N_min - sum_sq_s) // 2\n\n    print(f\"{N_min} {max_unidirectional}\")\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 483,
        "completion_token_count": 4219,
        "thoughts_token_count": 0
    }
}