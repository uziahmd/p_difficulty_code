{
    "start": 1758284899.0378366,
    "end": 1758284954.41548,
    "start-formatted": "2025-09-19 21:28 KST",
    "end-formatted": "2025-09-19 21:29 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "**Breaking Down the Odd Cycle Problem**\n\nOkay, so I'm looking at this competitive programming problem, and the core of it is making a graph contain an odd cycle by adding the minimum number of edges.  Essentially, I need to figure out how many edges I need to add, and then *how many different ways* I can add that minimal number.\n\nMy initial thought is that an odd cycle is the defining characteristic of a non-bipartite graph. Therefore, if the graph *already* contains an odd cycle, the answer is trivial: zero edges need to be added, and there's only one way to do it. Easy!\n\nSo, the first step is clearly to check if any connected component in the graph *already* violates bipartiteness. I can do this with a straightforward Breadth-First Search (BFS) or Depth-First Search (DFS) coloring approach. If I find any edge connecting vertices of the same color during the 2-coloring process, I know that component, and the graph as a whole, isn't bipartite, and I'm done.\n\nIf *every* connected component turns out to be bipartite, I've got more work to do.  This means I need to *force* a non-bipartite state by adding edges. The problem asks for the minimum number of edges to add, so let's start with the simplest scenario: adding a single edge.\n\nAdding a single edge can create an odd cycle only if it bridges two vertices within the same connected component, and these vertices must have the *same* color in the 2-coloring. This makes sense: adding an edge between vertices of the same color *closes* an odd path, resulting in an odd cycle. If these vertices have different colors, it would close an even path instead, resulting in an even cycle and no change in bipartiteness.\n\nSo, for each connected component, I need to look at its 2-coloring. Let's call the sets of vertices colored 0 and 1, `C_0` and `C_1`, respectively. Adding an edge between any two vertices in `C_0` or any two vertices in `C_1` within a particular connected component forces an odd cycle.\n\nThe number of ways to add one edge within a particular component is the number of pairs in C0 + number of pairs in C1, calculated using combinations. The total number of ways to create an odd cycle with one added edge is the sum of these pairwise combinations across *all* connected components.\n\nLet me think a bit more, this sounds like a solid starting point.\n",
    "response": "The problem asks us to find the minimum number of edges `t` to add to a given graph to form a simple cycle of odd length, and `w`, the number of ways to do so. A simple cycle of odd length exists in a graph if and only if the graph is not bipartite.\n\nWe can solve this by analyzing the bipartite nature of the connected components of the graph.\n\n1.  **Check for existing odd cycles (t = 0):**\n    We iterate through each connected component of the graph. For each component, we attempt to 2-color it using Breadth-First Search (BFS) or Depth-First Search (DFS).\n    *   Initialize all vertices as unvisited and uncolored.\n    *   For each unvisited vertex `s`:\n        *   Start a BFS/DFS from `s`, assigning it color 0.\n        *   When traversing an edge `(u, v)`:\n            *   If `v` is uncolored, assign it the opposite color of `u` and add it to the queue/stack.\n            *   If `v` is already colored and has the same color as `u`, then we have found an odd cycle. In this case, `t = 0` and `w = 1`. We can immediately print `0 1` and terminate.\n    *   If we successfully 2-color all components without finding any conflicts, then the graph is bipartite. We proceed to find `t > 0`.\n\n2.  **Case t = 1:**\n    If the graph is bipartite, we need to add at least one edge. The minimum `t` could be 1.\n    An odd cycle of length `2k+1` can be formed by adding one edge `(u, v)` if `u` and `v` are in the same connected component and have the same color in a 2-coloring. The path between `u` and `v` in the component will have an even length, making `path(u,v) + (u,v)` an odd cycle.\n    *   After 2-coloring all components (if no existing odd cycle), for each connected component `C`:\n        *   Let `C_0` be the set of vertices colored 0 and `C_1` be the set of vertices colored 1.\n        *   Any edge added between two vertices `u, v \\in C_0` or between two vertices `u, v \\in C_1` will form an odd cycle.\n        *   The number of such pairs within component `C` is `|C_0| * (|C_0| - 1) / 2 + |C_1| * (|C_1| - 1) / 2`.\n    *   Sum these counts over all connected components. Let this sum be `W1`.\n    *   If `W1 > 0`, then `t = 1` and `w = W1`. Print `1 W1` and terminate.\n\n3.  **Case t = 2:**\n    If `t` is not 0 or 1, it must be at least 2.\n    An odd cycle can be formed by adding two edges `(u, v)` and `(v, w)` such that `u, v, w` are distinct vertices.\n    This can happen if `u` and `w` are in different connected components, say `C_A` and `C_B`, respectively. We pick an arbitrary vertex `v` (which can be in `C_A`, `C_B`, or a third component `C_C`, or isolated).\n    The simplest way to form an odd cycle with two added edges is to pick two distinct connected components, `C_A` and `C_B`, and connect a vertex from `C_A` to a vertex from `C_B`, and another vertex from `C_A` to a vertex from `C_B`.\n    Specifically, we can pick `u_A \\in C_A`, `v_A \\in C_A`, `u_B \\in C_B`, `v_B \\in C_B`.\n    If we add edges `(u_A, u_B)` and `(v_A, v_B)`, this forms an odd cycle if `u_A` and `v_A` have different colors in `C_A`, and `u_B` and `v_B` have different colors in `C_B`.\n    For any two distinct connected components `C_i` and `C_j` (both bipartite), we can pick any vertex `u` from `C_i` and any vertex `v` from `C_j`. We can connect them with an edge `(u, v)`. To form an odd cycle with one more edge, we would need to connect another vertex `x` from `C_i` and `y` from `C_j` with `(x, y)`. The cycle would be `u -> ... -> x -> y -> ... -> v -> u`.\n    The path `u -> ... -> x` has length `L_i` (must be odd if `u, x` have same color, even if different). The path `y -> ... -> v` has length `L_j`. The total cycle length is `L_i + 1 + L_j + 1`.\n    To make this odd, `L_i + L_j` must be odd. This is always possible.\n    The number of ways to pick two distinct components `C_i` and `C_j` and connect them with two edges `(u, v)` and `(x, y)` where `u, x \\in C_i` and `v, y \\in C_j` is:\n    `N_C * (N_C - 1) / 2` pairs of components. For each pair, we need to pick 2 vertices from `C_i` and 2 from `C_j`.\n    This forms a 4-cycle if `(u,v)` and `(x,y)` are the new edges.\n    The number of ways to pick `(u,v)` and `(x,y)` is `|C_i| * |C_j| * (|C_i| - 1) * (|C_j| - 1) / 2`.\n    This is incorrect for minimum `t`.\n    The minimum `t=2` occurs if we pick two distinct connected components, say `C_A` and `C_B`. Let `|C_A|` be the number of vertices in `C_A` and `|C_B|` in `C_B`. We can add two edges `(u, v)` and `(v, w)`.\n    If we pick any two distinct connected components `C_i` and `C_j`, we can pick any vertex `u \\in C_i` and any vertex `v \\in C_j`. We add edge `(u, v)`. Now `C_i` and `C_j` are merged into one component. To make this new component non-bipartite, we need to add another edge `(x, y)` such that `x, y` are in the same partition of the 2-coloring of the merged component.\n    After adding `(u, v)`, `u` and `v` effectively have different colors.\n    The total number of vertices in the graph is `N`.\n    The number of ways to choose two distinct vertices `u, v` from the entire graph is `N * (N - 1) / 2`.\n    If `u` and `v` are in different components, adding `(u, v)` merges them. Let's count how many such pairs `(u, v)` create an odd cycle.\n    Consider all pairs of distinct vertices `(u, v)`.\n    If `u` and `v` are in different components, adding `(u, v)` merges them. The resulting component is bipartite. We still need to add another edge.\n    The crucial insight for `t=2` is that we can merge all connected components into one large bipartite component by adding `k-1` edges (where `k` is the number of components). Then, to make it non-bipartite, we need to add one more edge within this large component, between two vertices of the same color. This means `t = k`. This is not necessarily `t=2`.\n\n    A simpler `t=2` case:\n    If there are at least two connected components, say `C_A` and `C_B`.\n    *   Number of vertices in `C_A` is `|C_A|`. Number of vertices in `C_B` is `|C_B|`.\n    *   We pick any vertex `u` from `C_A` and any vertex `v` from `C_B`. Add edge `(u, v)`.\n    *   We pick any *other* vertex `x` from `C_A` and any *other* vertex `y` from `C_B`. Add edge `(x, y)`.\n    *   This forms a 4-cycle `u - v - y - x - u`. A 4-cycle is an even cycle.\n    *   However, if we connect `u \\in C_A` to `v \\in C_B`, and `u \\in C_A` to `w \\in C_C` (where `C_A, C_B, C_C` are distinct components), we add two edges `(u,v)` and `(u,w)`. This connects `C_A, C_B, C_C`. The cycle `v-u-w` is length 2, not a simple cycle.\n    *   To form an odd cycle with 2 edges, we need to pick three distinct vertices `u, v, w`.\n        *   If `u, v, w` are all in different components, say `C_U, C_V, C_W`. Add `(u,v)` and `(v,w)`. This forms a path `u-v-w` of length 2. This is not a cycle.\n        *   If `u` is in `C_U`, `v` in `C_V`, `w` in `C_U` (where `C_U != C_V`). Add `(u,v)` and `(v,w)`. The path `u-v-w` is length 2. The path `u-...-w` within `C_U` has some length `L`. The cycle is `u-v-w-...-u`. Its length is `2+L`. For this to be odd, `L` must be odd. This means `u` and `w` must have the same color in `C_U`.\n        *   So, if there exists at least one component `C_i` which has `|C_i_0| > 1` or `|C_i_1| > 1` (i.e., at least two vertices of the same color), and there is at least one other component `C_j` (`C_j` can be a single vertex or a larger component), then we can pick `u, w \\in C_i` with same color, and `v \\in C_j`. Add `(u, v)` and `(v, w)`. This forms an odd cycle of length `2 + L_{u,w}` where `L_{u,w}` is the path length in `C_i` between `u` and `w`, which is even. So `2+L_{u,w}` is even. This is wrong.\n        *   Path `u-...-w` has even length `L`. Cycle is `u-v-w-...-u`. Length `2+L`. Still even.\n\n    Let's re-evaluate `t=2`.\n    We need to add two edges `(a, b)` and `(c, d)`.\n    If we pick two vertices `u, v` from the same component `C_i` such that `u` and `v` have different colors. And we pick another component `C_j`. We select `x \\in C_j`. We add edges `(u, x)` and `(v, x)`.\n    The path `u-...-v` in `C_i` has odd length `L`. The cycle `u-x-v-...-u` has length `2+L`. This is an odd cycle!\n    The number of ways to do this:\n    *   For each component `C_i`:\n        *   Count `|C_i_0|` and `|C_i_1|`.\n        *   Number of pairs `(u, v)` with different colors in `C_i` is `|C_i_0| * |C_i_1|`.\n    *   Sum this over all components: `S_diff = sum(|C_i_0| * |C_i_1|)`.\n    *   Number of ways to pick `x` from *any other* component `C_j` (or an isolated vertex not in `C_i`) is `N - |C_i|`.\n    *   So, `W2 = sum_{C_i} (|C_i_0| * |C_i_1| * (N - |C_i|))`.\n    *   This counts `(u,v)` and `(v,u)` as distinct when picking `u,v` from `C_i`, but the pair of edges `{(u,x), (v,x)}` is the same regardless of `u` and `v` order. So we need to divide by 2? No, because `u` and `v` are distinct vertices.\n    *   The pairs of edges `{(u,x), (v,x)}` are distinct for distinct `u,v,x`.\n    *   This sum `W2` is the number of ways to add two edges `(u, x)` and `(v, x)` such that `u, v` are in the same component `C_i` with different colors, and `x` is not in `C_i`.\n    *   If `W2 > 0`, then `t = 2` and `w = W2`. Print `2 W2` and terminate.\n\n4.  **Case t = 3:**\n    If `t` is not 0, 1, or 2, it must be at least 3.\n    This happens if all components are single vertices (isolated vertices). In this case, `N_C = N`.\n    `W1` would be 0 because `|C_i_0|` or `|C_i_1|` would be 1 for each component (a single vertex). `1*(1-1)/2 = 0`.\n    `W2` would be 0 because `|C_i_0| * |C_i_1|` would be 0 (a single vertex is either `C_i_0` or `C_i_1`, but not both).\n    So, if all vertices are isolated, we need to add 3 edges.\n    Pick three distinct vertices `u, v, w`. Add edges `(u, v)`, `(v, w)`, `(w, u)`. This forms a 3-cycle, which is an odd cycle.\n    The number of ways to do this is `N * (N - 1) * (N - 2) / 6`.\n    This is the only remaining case for `t=3`. Print `3 (N * (N - 1) * (N - 2) / 6)`.\n\n**Summary of Logic:**\n\n1.  **Graph Representation:** Adjacency list.\n2.  **Bipartite Check / Component Traversal:**\n    *   Use `colors` array initialized to -1 (unvisited/uncolored).\n    *   Use `visited` array (or just check `colors != -1`).\n    *   `q` for BFS.\n    *   `components_data`: list to store `(num_color0, num_color1, component_size)` for each bipartite component.\n    *   `has_odd_cycle = False`.\n    *   Iterate `i` from 1 to `N`:\n        *   If `i` is unvisited:\n            *   Initialize `c0=0, c1=0`.\n            *   Start BFS from `i`: `q.append(i)`, `colors[i] = 0`, `c0 = 1`.\n            *   While `q` not empty:\n                *   `u = q.popleft()`.\n                *   For `v` in `adj[u]`:\n                    *   If `v` uncolored: `colors[v] = 1 - colors[u]`. If `colors[v] == 0`, `c0++`, else `c1++`. `q.append(v)`.\n                    *   Else if `colors[v] == colors[u]`: `has_odd_cycle = True`. Break BFS.\n            *   If `has_odd_cycle`: break outer loop.\n            *   Else (component is bipartite): `components_data.append((c0, c1, c0 + c1))`.\n\n3.  **Determine t and w:**\n    *   If `has_odd_cycle`: Print `0 1`.\n    *   Else (`t=0` failed, all components bipartite):\n        *   Calculate `W1 = 0`. For each `(c0, c1, size)` in `components_data`:\n            `W1 += c0 * (c0 - 1) // 2 + c1 * (c1 - 1) // 2`.\n        *   If `W1 > 0`: Print `1 W1`.\n        *   Else (`t=1` failed):\n            *   Calculate `W2 = 0`. For each `(c0, c1, size)` in `components_data`:\n                `W2 += c0 * c1 * (N - size)`.\n            *   If `W2 > 0`: Print `2 W2`.\n            *   Else (`t=2` failed):\n                *   This implies all components are isolated vertices (since `c0*(c0-1)/2 + c1*(c1-1)/2` is 0 only if `c0 <= 1` and `c1 <= 1`. And `c0*c1` is 0 only if `c0=0` or `c1=0`. For a connected component, `c0+c1 >= 1`. So `c0=1, c1=0` or `c0=0, c1=1`, meaning it's a single vertex).\n                *   Print `3 (N * (N - 1) * (N - 2) // 6)`.\n\nThis covers all cases and correctly calculates `t` and `w`.\n\nExample 1:\n4 4\n1 2\n1 3\n4 2\n4 3\nGraph: 1-2, 1-3, 4-2, 4-3.\nComponent 1: {1,2,3,4}\nColoring:\n1:0\n2:1 (from 1)\n3:1 (from 1)\n4:0 (from 2)\nCheck 4-3: 4 is 0, 3 is 1. OK.\nThis component is bipartite.\nc0=2 (1,4), c1=2 (2,3). size=4.\ncomponents_data = [(2,2,4)]\nW1 = 2*(2-1)//2 + 2*(2-1)//2 = 1 + 1 = 2.\nOutput: 1 2. (Pairs (1,4) or (2,3) can be connected)\n\nExample 2:\n3 3\n1 2\n2 3\n3 1\nGraph: 1-2, 2-3, 3-1.\nComponent 1: {1,2,3}\nColoring:\n1:0\n2:1 (from 1)\n3:0 (from 2)\nCheck 3-1: 3 is 0, 1 is 0. Same color! Odd cycle found.\nOutput: 0 1.\n\nExample 3:\n3 0\nGraph: 1, 2, 3 (all isolated)\nComponent 1: {1}, c0=1, c1=0, size=1.\nComponent 2: {2}, c0=1, c1=0, size=1.\nComponent 3: {3}, c0=1, c1=0, size=1.\ncomponents_data = [(1,0,1), (1,0,1), (1,0,1)]\nW1 = 0 (since c0*(c0-1)/2 + c1*(c1-1)/2 is 0 for all).\nW2 = 0 (since c0*c1 is 0 for all).\nOutput: 3 (3 * 2 * 1 // 6) = 3 1.\n\n```python\nimport sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n\n    colors = [-1] * (n + 1) # -1: uncolored, 0: color A, 1: color B\n    visited = [False] * (n + 1)\n    \n    components_data = [] # Stores (count_color_A, count_color_B, component_size) for bipartite components\n    has_odd_cycle = False\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            q = deque()\n            q.append(i)\n            colors[i] = 0\n            visited[i] = True\n            \n            current_component_c0 = 0\n            current_component_c1 = 0\n            \n            is_bipartite_component = True\n\n            component_nodes = []\n            component_nodes.append(i)\n            \n            head = 0\n            while head < len(component_nodes):\n                u = component_nodes[head]\n                head += 1\n                \n                if colors[u] == 0:\n                    current_component_c0 += 1\n                else:\n                    current_component_c1 += 1\n\n                for v in adj[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        colors[v] = 1 - colors[u]\n                        component_nodes.append(v)\n                    elif colors[v] == colors[u]:\n                        is_bipartite_component = False\n                        break\n                if not is_bipartite_component:\n                    break\n\n            if not is_bipartite_component:\n                has_odd_cycle = True\n                break\n            else:\n                components_data.append((current_component_c0, current_component_c1, len(component_nodes)))\n\n    if has_odd_cycle:\n        print(\"0 1\")\n        return\n\n    # All components are bipartite\n    # Try t = 1\n    w1 = 0\n    for c0, c1, _ in components_data:\n        w1 += c0 * (c0 - 1) // 2\n        w1 += c1 * (c1 - 1) // 2\n    \n    if w1 > 0:\n        print(f\"1 {w1}\")\n        return\n\n    # Try t = 2\n    w2 = 0\n    for c0, c1, size in components_data:\n        # We need to pick two vertices u, v from the same component that have different colors.\n        # And pick a third vertex x from outside this component.\n        # Add edges (u, x) and (v, x). This forms an odd cycle of length 2 + path_len(u,v)\n        # where path_len(u,v) is odd.\n        \n        # Number of ways to pick u,v with different colors from this component\n        pairs_diff_colors = c0 * c1\n        \n        # Number of ways to pick x from outside this component\n        other_vertices = n - size\n        \n        w2 += pairs_diff_colors * other_vertices\n    \n    if w2 > 0:\n        print(f\"2 {w2}\")\n        return\n\n    # Try t = 3\n    # This case is reached if all components are single vertices.\n    # (Because if any component has c0 > 1 or c1 > 1, then w1 > 0.\n    # If any component has c0 > 0 and c1 > 0, then w2 > 0 (if n > size, which is true if n > 1).\n    # If n=1, then w1=0, w2=0, but N*(N-1)*(N-2)//6 is 0. So t=0, w=1 for N=1, M=0? No, cycle needs >1 vertex.\n    # For N=1, M=0, the definition of cycle 'consisting of more than one vertex' means no solution.\n    # But problem statement implies there's always a solution.\n    # For N=1, M=0, t=3, w=0. This is not handled. But N>=2 for this problem to make sense.\n    # If N=2, M=0, components are (1,0,1), (1,0,1). w1=0, w2=0. t=3. 2*(1)*(0)/6 = 0.\n    # Oh, N * (N - 1) * (N - 2) // 6 is the number of ways to pick 3 distinct vertices.\n    # If N < 3, this is 0.\n    # So if N=2, M=0, t=3, w=0. But problem implies solution.\n    # The problem implies N >= 3 for this case to be non-zero.\n    # The minimum number of vertices for an odd cycle is 3. So if N < 3, no solution.\n    # But N, M constraints are 1 <= N <= 10^5.\n    # If N=1, M=0, t=3, w=0.\n    # If N=2, M=0, t=3, w=0.\n    # If N=2, M=1 (1-2), t=3, w=0.\n    # This is a bit tricky. The problem guarantees a solution.\n    # The only way N*(N-1)*(N-2)//6 can be 0 when N>=3 is if N=0,1,2.\n    # If N=3, M=0, w3 = 3*2*1/6 = 1. This is correct.\n    # So for N < 3, this `t=3` strategy doesn't work.\n    # But if N < 3, there's no way to form an odd cycle of length > 1.\n    # The problem implies N >= 3 for a solution to exist.\n    # If N=1 or N=2, it's impossible to form an odd cycle of length > 1.\n    # Let's assume N >= 3 if we reach this point.\n    \n    w3 = n * (n - 1) * (n - 2) // 6\n    print(f\"3 {w3}\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n\n    colors = [-1] * (n + 1) # -1: uncolored, 0: color A, 1: color B\n    visited = [False] * (n + 1)\n    \n    components_data = [] # Stores (count_color_A, count_color_B, component_size) for bipartite components\n    has_odd_cycle = False\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            q = deque()\n            q.append(i)\n            colors[i] = 0\n            visited[i] = True\n            \n            current_component_c0 = 0\n            current_component_c1 = 0\n            \n            is_bipartite_component = True\n\n            component_nodes = []\n            component_nodes.append(i)\n            \n            head = 0\n            while head < len(component_nodes):\n                u = component_nodes[head]\n                head += 1\n                \n                if colors[u] == 0:\n                    current_component_c0 += 1\n                else:\n                    current_component_c1 += 1\n\n                for v in adj[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        colors[v] = 1 - colors[u]\n                        component_nodes.append(v)\n                    elif colors[v] == colors[u]:\n                        is_bipartite_component = False\n                        break\n                if not is_bipartite_component:\n                    break\n\n            if not is_bipartite_component:\n                has_odd_cycle = True\n                break\n            else:\n                components_data.append((current_component_c0, current_component_c1, len(component_nodes)))\n\n    if has_odd_cycle:\n        print(\"0 1\")\n        return\n\n    # All components are bipartite\n    # Try t = 1\n    w1 = 0\n    for c0, c1, _ in components_data:\n        w1 += c0 * (c0 - 1) // 2\n        w1 += c1 * (c1 - 1) // 2\n    \n    if w1 > 0:\n        print(f\"1 {w1}\")\n        return\n\n    # Try t = 2\n    w2 = 0\n    for c0, c1, size in components_data:\n        # We need to pick two vertices u, v from the same component that have different colors.\n        # And pick a third vertex x from outside this component.\n        # Add edges (u, x) and (v, x). This forms an odd cycle of length 2 + path_len(u,v)\n        # where path_len(u,v) is odd.\n        \n        # Number of ways to pick u,v with different colors from this component\n        pairs_diff_colors = c0 * c1\n        \n        # Number of ways to pick x from outside this component\n        other_vertices = n - size\n        \n        w2 += pairs_diff_colors * other_vertices\n    \n    if w2 > 0:\n        print(f\"2 {w2}\")\n        return\n\n    # Try t = 3\n    # This case is reached if all components are single vertices.\n    # (Because if any component has c0 > 1 or c1 > 1, then w1 > 0.\n    # If any component has c0 > 0 and c1 > 0, then w2 > 0 (if n > size, which is true if n > 1).\n    # If n=1, then w1=0, w2=0, but N*(N-1)*(N-2)//6 is 0. So t=0, w=1 for N=1, M=0? No, cycle needs >1 vertex.\n    # For N=1, M=0, the definition of cycle 'consisting of more than one vertex' means no solution.\n    # But problem statement implies there's always a solution.\n    # For N=1, M=0, t=3, w=0. This is not handled. But N>=2 for this problem to make sense.\n    # If N=2, M=0, components are (1,0,1), (1,0,1). w1=0, w2=0. t=3. 2*(1)*(0)/6 = 0.\n    # Oh, N * (N - 1) * (N - 2) // 6 is the number of ways to pick 3 distinct vertices.\n    # If N < 3, this is 0.\n    # So if N=2, M=0, t=3, w=0. But problem implies solution.\n    # The problem implies N >= 3 for this case to be non-zero.\n    # The minimum number of vertices for an odd cycle is 3. So if N < 3, no solution.\n    # But N, M constraints are 1 <= N <= 10^5.\n    # If N=1, M=0, t=3, w=0.\n    # If N=2, M=0, t=3, w=0.\n    # If N=2, M=1 (1-2), t=3, w=0.\n    # This is a bit tricky. The problem guarantees a solution.\n    # The only way N*(N-1)*(N-2)//6 can be 0 when N>=3 is if N=0,1,2.\n    # If N=3, M=0, w3 = 3*2*1/6 = 1. This is correct.\n    # So for N < 3, this `t=3` strategy doesn't work.\n    # But if N < 3, there's no way to form an odd cycle of length > 1.\n    # The problem implies N >= 3 for a solution to exist.\n    # If N=1 or N=2, it's impossible to form an odd cycle of length > 1.\n    # Let's assume N >= 3 if we reach this point.\n    \n    w3 = n * (n - 1) * (n - 2) // 6\n    print(f\"3 {w3}\")\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 603,
        "completion_token_count": 6364,
        "thoughts_token_count": 710
    }
}