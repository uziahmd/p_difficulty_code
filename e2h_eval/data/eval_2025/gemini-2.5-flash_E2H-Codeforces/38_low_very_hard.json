{
    "start": 1758284949.3860273,
    "end": 1758284973.989611,
    "start-formatted": "2025-09-19 21:29 KST",
    "end-formatted": "2025-09-19 21:29 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "**Problem Decomposition and Strategic Approach**\n\nOkay, so I'm tackling a competitive programming problem. My goal is to figure out two things: the smallest number of nodes I need to build a directed graph that satisfies a 'p'-reachability condition, and then, the maximum number of unidirectional pairs possible in any such graph.\n\nFirst, let's nail down what \"p\"-reachable means.  We're talking about pairs of nodes (u, v) where u < v and there's a path both ways between them. This is key: these pairs are essentially nodes within the same strongly connected component (SCC).\n\nThe problem defines \"unidirectional pairs\" as pairs where there's a path from u to v, but no path back. I need to maximize the number of these.\n\nHere's how I'm thinking:  Let's say we've got `n` nodes, and those nodes are grouped into `k` SCCs. The size of each SCC is `S_i`.  The total nodes, of course, is the sum of all the SCC sizes: `n = S_1 + S_2 + ... + S_k`.\n\nNow, the crucial insight: to calculate `p`, the number of reachable pairs, I need to focus on each SCC.  Within an SCC of size `S`, there are `S * (S - 1) / 2` pairs where u < v and they're reachable from each other. So `p` is the sum of these contributions from each SCC.  To minimize the total nodes `n`, I need to keep the sizes of the SCCs as *large* as possible.  Splitting an SCC into smaller ones always increases the number of nodes necessary for a given `p`, due to the nature of the quadratic expression.\n\nTherefore, for minimizing `n`, I need to *maximize* the sizes of the SCCs to minimize `k` (the number of SCCs)\n\nTo find the minimum 'n', the strategy is clear: I must find combinations of `S_i` values that give me `p` and minimize their sum. I need to carefully consider how many SCCs I can use given `p`. My intuition says I want to use the largest SCCs possible to minimize the required 'n'.\n",
    "response": "The problem asks us to find two values:\n1. The minimum number of nodes `n` required to create a `p`-reachable directed graph.\n2. The maximum number of unidirectional pairs among all `p`-reachable graphs with this minimum `n`.\n\nLet's first understand the definitions:\n- A pair `(u, v)` is \"reachable from each other\" if there's a path `u -> v` and `v -> u`. This means `u` and `v` are in the same Strongly Connected Component (SCC).\n- A graph is `p`-reachable if it has exactly `p` ordered pairs `(u, v)` such that `u < v` and `u`, `v` are reachable from each other.\n- A pair `(u, v)` is \"unidirectional\" if `u != v`, there's a path `u -> v`, and no path `v -> u`. This means `u` and `v` are in different SCCs, and there's a path from `u`'s SCC to `v`'s SCC in the condensation graph.\n\nLet `S_1, S_2, ..., S_k` be the sizes of the `k` SCCs in the graph. The total number of nodes is `n = S_1 + S_2 + ... + S_k`.\n\n**Part 1: Minimum `n` for a given `p`**\n\nFor a single SCC of size `S`, any two distinct nodes `u, v` within it are reachable from each other. The number of ordered pairs `(u, v)` with `u < v` is `S * (S - 1) / 2`.\nThe total `p` for the graph is the sum of `S_i * (S_i - 1) / 2` over all SCCs:\n`p = sum(S_i * (S_i - 1) / 2 for i in range(k))`\n\nTo minimize `n` for a given `p`, we want to make the `S_i` values as large as possible. This is because `f(S) = S * (S - 1) / 2` is a convex function, meaning `f(S_1) + f(S_2)` is minimized for `S_1 + S_2 = S` when one of `S_1, S_2` is 0 or 1, and maximized when `S_1, S_2` are close. More generally, to achieve a target sum `p` using `f(S_i)` terms, we should use as few terms as possible, and make them as large as possible.\n\nWe can use a greedy approach:\n1. Start with `n = 0` and `p_current = p`.\n2. Find the largest `S` such that `S * (S - 1) / 2 <= p_current`.\n3. Add `S` to `n` (i.e., `n += S`).\n4. Subtract `S * (S - 1) / 2` from `p_current` (i.e., `p_current -= S * (S - 1) / 2`).\n5. Repeat until `p_current` becomes 0.\n\nThis strategy ensures we use the largest possible SCCs first, which minimizes `n`.\nThe maximum value for `p` is `2 * 10^5`.\nIf `S * (S - 1) / 2 <= 2 * 10^5`, then `S^2` is roughly `4 * 10^5`, so `S` is roughly `sqrt(4 * 10^5) = 2 * 10^2 = 200 * 1.414 = 632`.\nSo `S` will be at most around 632. We can precompute `f(S) = S * (S - 1) / 2` for `S` up to, say, 650.\n\nLet `p_values[S] = S * (S - 1) / 2`.\nWe can find the largest `S` such that `p_values[S] <= p_current` by iterating downwards from `S_max = 650` or using binary search.\n\nExample: `p = 3`\n- `p_values[1] = 0`, `p_values[2] = 1`, `p_values[3] = 3`.\n- Largest `S` such that `p_values[S] <= 3` is `S = 3`.\n- `n = 3`, `p_current = 3 - 3 = 0`.\n- Minimum `n = 3`. SCCs: `{3}`.\n\nExample: `p = 4`\n- Largest `S` such that `p_values[S] <= 4` is `S = 3`. (`p_values[3] = 3`)\n- `n = 3`, `p_current = 4 - 3 = 1`.\n- Largest `S` such that `p_values[S] <= 1` is `S = 2`. (`p_values[2] = 1`)\n- `n = 3 + 2 = 5`, `p_current = 1 - 1 = 0`.\n- Minimum `n = 5`. SCCs: `{3, 2}`.\n\n**Part 2: Maximum Unidirectional Pairs for minimum `n`**\n\nLet the SCCs be `C_1, C_2, ..., C_k` with sizes `S_1, S_2, ..., S_k` respectively, determined by the greedy strategy above.\nA pair `(u, v)` is unidirectional if `u \\in C_i`, `v \\in C_j` with `i != j`, there's a path `C_i -> C_j`, and no path `C_j -> C_i`.\nTo maximize unidirectional pairs, we want to maximize paths between distinct SCCs in one direction.\nThe maximum number of unidirectional pairs is achieved when the condensation graph (graph of SCCs) is a single directed path or a complete directed acyclic graph (DAG).\nConsider a linear arrangement of SCCs: `C_1 -> C_2 -> ... -> C_k`.\nIn this arrangement, for any `i < j`, there is a path from `C_i` to `C_j`, but no path from `C_j` to `C_i`.\nThe number of unidirectional pairs from `C_i` to `C_j` (where `i < j`) is `S_i * S_j`.\nThe total number of unidirectional pairs for this linear arrangement is `sum(S_i * S_j for i < j)`.\n\nLet `N = sum(S_i)` be the total number of nodes.\nConsider the sum `(sum(S_i))^2 = N^2`.\n`N^2 = (S_1 + S_2 + ... + S_k)^2`\n`N^2 = sum(S_i^2) + sum(2 * S_i * S_j for i < j)`\nSo, `sum(S_i * S_j for i < j) = (N^2 - sum(S_i^2)) / 2`.\nThis is the maximum possible number of unidirectional pairs for a given set of SCC sizes `S_i`. This is achieved by arranging them in a linear order and adding edges `C_i -> C_j` for all `i < j`.\n\nThe algorithm:\n1. Initialize `min_n = 0`, `p_remaining = p`.\n2. Initialize `scc_sizes = []`.\n3. Precompute `p_val[s] = s * (s - 1) / 2` for `s` up to `~650`.\n4. While `p_remaining > 0`:\n   a. Find the largest `s` such that `p_val[s] <= p_remaining`.\n   b. Add `s` to `min_n`.\n   c. Add `s` to `scc_sizes`.\n   d. Subtract `p_val[s]` from `p_remaining`.\n5. Calculate `max_unidirectional = (min_n * min_n - sum(s*s for s in scc_sizes)) // 2`.\n\nEdge case: `p = 0`.\n- `min_n = 0`, `p_remaining = 0`. Loop doesn't run.\n- `scc_sizes = []`.\n- `max_unidirectional = (0 * 0 - 0) // 2 = 0`.\nThis is correct. If `p=0`, there are no pairs `(u,v)` with `u<v` reachable from each other. This implies all SCCs must have size 1. So `n` is just the number of nodes. If `n=0`, then there are no nodes, so no `p` pairs and no unidirectional pairs. If `n > 0`, all `S_i=1`, `min_n = n`. Then `max_unidirectional = (n^2 - n) / 2`. Example `p=0` gives `0 0`. This implies `n=0`. If `n=1`, `p=0`. `max_unidirectional = 0`.\nThe problem statement implies `u != v` for unidirectional pairs. If `n=0`, `p=0`, `unidirectional=0`. This is the base case.\nIf `p=0`, the greedy choice for `S` would be `S=1` (since `S=0` means no nodes, `p_val[1]=0`). So if `p=0`, `scc_sizes` remains empty. `min_n` is 0.\nThis is correct. If `p=0`, the minimum number of nodes is 0. A graph with 0 nodes has 0 `p` pairs and 0 unidirectional pairs.\n\nLet's verify the `p=0` case again. If `p=0`, `min_n` is 0. `scc_sizes` is empty. `max_unidirectional` is `(0^2 - 0) / 2 = 0`. This matches the example output `0 0`.\n\nLet's implement this.\n\n```python\nimport math\n\ndef solve():\n    p = int(input())\n\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    # Precompute p_val[s] = s * (s - 1) / 2\n    # Max p is 2 * 10^5.\n    # s * (s - 1) / 2 <= 2 * 10^5\n    # s^2 - s <= 4 * 10^5\n    # s^2 approx 4 * 10^5 => s approx sqrt(4 * 10^5) = 200 * sqrt(10) approx 200 * 3.16 = 632\n    # So max_s is around 632. Let's go up to 650 to be safe.\n    MAX_S = 650\n    p_val = [0] * (MAX_S + 1)\n    for s in range(1, MAX_S + 1):\n        p_val[s] = s * (s - 1) // 2\n    \n    min_n = 0\n    scc_sizes = []\n    p_remaining = p\n\n    # Greedy approach to find min_n and scc_sizes\n    while p_remaining > 0:\n        # Find the largest s such that p_val[s] <= p_remaining\n        s = MAX_S\n        while s > 0 and p_val[s] > p_remaining:\n            s -= 1\n        \n        if s == 0: # Should not happen if p_remaining > 0, unless p_remaining is 0 itself\n            break \n        \n        min_n += s\n        scc_sizes.append(s)\n        p_remaining -= p_val[s]\n    \n    # Calculate max_unidirectional\n    # max_unidirectional = sum(S_i * S_j for i < j)\n    # This is (min_n^2 - sum(S_i^2)) / 2\n    \n    sum_s_squared = 0\n    for s in scc_sizes:\n        sum_s_squared += s * s\n    \n    max_unidirectional = (min_n * min_n - sum_s_squared) // 2\n    \n    print(min_n, max_unidirectional)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef solve():\n    p = int(input())\n\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    # Precompute p_val[s] = s * (s - 1) / 2\n    # Max p is 2 * 10^5.\n    # s * (s - 1) / 2 <= 2 * 10^5\n    # s^2 - s <= 4 * 10^5\n    # s^2 approx 4 * 10^5 => s approx sqrt(4 * 10^5) = 200 * sqrt(10) approx 200 * 3.16 = 632\n    # So max_s is around 632. Let's go up to 650 to be safe.\n    MAX_S = 650\n    p_val = [0] * (MAX_S + 1)\n    for s in range(1, MAX_S + 1):\n        p_val[s] = s * (s - 1) // 2\n    \n    min_n = 0\n    scc_sizes = []\n    p_remaining = p\n\n    # Greedy approach to find min_n and scc_sizes\n    while p_remaining > 0:\n        # Find the largest s such that p_val[s] <= p_remaining\n        s = MAX_S\n        while s > 0 and p_val[s] > p_remaining:\n            s -= 1\n        \n        if s == 0: # Should not happen if p_remaining > 0, unless p_remaining is 0 itself\n            break \n        \n        min_n += s\n        scc_sizes.append(s)\n        p_remaining -= p_val[s]\n    \n    # Calculate max_unidirectional\n    # max_unidirectional = sum(S_i * S_j for i < j)\n    # This is (min_n^2 - sum(S_i^2)) / 2\n    \n    sum_s_squared = 0\n    for s in scc_sizes:\n        sum_s_squared += s * s\n    \n    max_unidirectional = (min_n * min_n - sum_s_squared) // 2\n    \n    print(min_n, max_unidirectional)\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 483,
        "completion_token_count": 2895,
        "thoughts_token_count": 792
    }
}