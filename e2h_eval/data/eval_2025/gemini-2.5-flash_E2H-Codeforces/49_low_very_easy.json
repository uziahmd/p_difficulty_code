{
    "start": 1758284905.4406018,
    "end": 1758284925.7325025,
    "start-formatted": "2025-09-19 21:28 KST",
    "end-formatted": "2025-09-19 21:28 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "**Tackling the Mushroom Strife Problem**\n\nOkay, so I'm looking at this \"Mushroom Strife\" problem, and my immediate goal is a Python solution. The setup is pretty standard graph fare: lawns as vertices, roads as edges. Each edge tells me the GCD and LCM of the mushroom counts on the connected lawns. My task? Find a valid mushroom assignment for each lawn, or declare that no such assignment exists.\n\nFirst thing's first, I need to understand the constraints. I know the fundamental relationship: `GCD(a, b) * LCM(a, b) = a * b`. That's the key. For a given edge, where the GCD is *g* and the LCM is *l*, I have a set of conditions that *must* hold true.\n\n*   *g* needs to divide *l*.  If that's not true, there's no way this thing works.\n*   The mushroom counts on the connected lawns, `a_u` and `a_v`, are multiples of *g*.\n*   `a_u` and `a_v` have to be divisors of *l*.\n*   The product of the mushroom counts, `a_u * a_v`, *must* equal `g * l`.\n*   And finally, the GCD of `a_u` and `a_v` needs to be *g*.\n\nNow I'm thinking about how to translate this into an algorithm. I've got a graph structure, which means I'm dealing with interconnected values. The fact that the mushroom counts are integers between 1 and 10^6 and that `n` and `m` are up to 100, gives me some guidance. It suggests I should be able to get away with a solution whose runtime complexity might be as high as `N^3`, `N^4`, or maybe even `N^2 * M`.\n\nMy plan? Use these constraints to systematically narrow down the possible mushroom counts for each lawn. I need to figure out how to propagate these constraints across the graph, making sure every assignment is valid and consistent. I should probably start by figuring out the dependencies and then devise a way to propagate values while checking for conflicts. The real challenge will be ensuring this process doesn't get stuck in a loop or explore an unreasonably large search space.\n",
    "response": "```python\nimport sys\nimport math\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    if n == 0: # Edge case: no lawns, but n is at least 1 per constraints\n        sys.stdout.write(\"YES\\n\")\n        sys.stdout.write(\"\\n\")\n        return\n\n    # Store edges and their GCD/LCM values\n    # edges[u] will be a list of (v, g, l) tuples\n    edges = [[] for _ in range(n + 1)]\n    \n    # Store initial constraints for each lawn\n    # lower_bound[i]: must be a multiple of this value\n    # upper_bound[i]: must be a divisor of this value\n    # Initially, lower_bound is 1 (all numbers >= 1)\n    # upper_bound is 10^6 (all numbers <= 10^6)\n    lower_bound = [1] * (n + 1)\n    upper_bound = [1000001] * (n + 1) # Max value 10^6, so 10^6+1 as an exclusive upper bound for iteration\n\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        \n        # Basic check: g must divide l\n        if l % g != 0:\n            sys.stdout.write(\"NO\\n\")\n            return\n\n        edges[u].append((v, g, l))\n        edges[v].append((u, g, l))\n\n        # Update lower_bound for u and v: must be a multiple of g\n        lower_bound[u] = math.lcm(lower_bound[u], g)\n        lower_bound[v] = math.lcm(lower_bound[v], g)\n\n        # Update upper_bound for u and v: must be a divisor of l\n        # The value must divide upper_bound[i] AND l. So it must divide GCD(upper_bound[i], l)\n        # This is not quite right. A value X must divide L_1, L_2, ..., L_k. So X must divide GCD(L_1, L_2, ..., L_k).\n        # We need to find the largest possible value, so we take GCD of all upper bounds.\n        if upper_bound[u] == 1000001: # First time setting an actual LCM constraint\n            upper_bound[u] = l\n        else:\n            upper_bound[u] = math.gcd(upper_bound[u], l)\n        \n        if upper_bound[v] == 1000001: # First time setting an actual LCM constraint\n            upper_bound[v] = l\n        else:\n            upper_bound[v] = math.gcd(upper_bound[v], l)\n\n    # Check for consistency of initial bounds\n    for i in range(1, n + 1):\n        # If lower_bound[i] > upper_bound[i], it's impossible\n        # Or if upper_bound[i] is not a multiple of lower_bound[i]\n        # (e.g., must be a multiple of 6, must be a divisor of 10. No such number)\n        if lower_bound[i] > upper_bound[i] or (upper_bound[i] % lower_bound[i] != 0):\n            sys.stdout.write(\"NO\\n\")\n            return\n        # Also check if lower_bound[i] itself exceeds 10^6\n        if lower_bound[i] > 1000000:\n            sys.stdout.write(\"NO\\n\")\n            return\n\n    # Possible values for each lawn\n    possible_values = [[] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        current_val = lower_bound[i]\n        while current_val <= upper_bound[i] and current_val <= 1000000:\n            # Check if current_val divides upper_bound[i]\n            # This is implicitly handled by the loop condition current_val <= upper_bound[i]\n            # and current_val being multiples of lower_bound[i].\n            # If upper_bound[i] is not a multiple of lower_bound[i], we already returned NO.\n            # So, current_val will always divide upper_bound[i].\n            possible_values[i].append(current_val)\n            if current_val == 0: # Avoid infinite loop if lower_bound[i] is 0, though it's >=1\n                break\n            if upper_bound[i] // current_val < lower_bound[i]: # Avoid overflow or very large step if current_val is huge\n                break\n            current_val += lower_bound[i] # Next multiple of lower_bound[i]\n\n        if not possible_values[i]: # No possible values found for this lawn\n            sys.stdout.write(\"NO\\n\")\n            return\n\n    # Use backtracking to find a solution\n    ans = [0] * (n + 1)\n\n    def backtrack(k):\n        if k == n + 1:\n            # All lawns assigned, check all edges\n            for u in range(1, n + 1):\n                for v_node, g, l in edges[u]:\n                    # Only check each edge once (e.g., u < v_node)\n                    # For simplicity, we can check all stored edges.\n                    # If u is 1 and v_node is 2, and we have (1,2,g,l) and (2,1,g,l),\n                    # we will check it twice, but that's fine.\n                    # It's better to check only if u < v_node to avoid redundant checks.\n                    # However, the problem guarantees no self-loops, no duplicate edges.\n                    # The current graph representation stores (v,g,l) for u and (u,g,l) for v.\n                    # So, if we iterate through edges[u], we'll check (u,v) relation.\n                    # If we iterate through edges[v], we'll check (v,u) relation.\n                    # This is fine, as long as the check is correct.\n                    if math.gcd(ans[u], ans[v_node]) != g or math.lcm(ans[u], ans[v_node]) != l:\n                        return False\n            return True # All edges satisfy conditions\n        \n        # Try assigning a value to lawn k\n        for val in possible_values[k]:\n            ans[k] = val\n            \n            # Check consistency with already assigned neighbors (1 to k-1)\n            is_valid_so_far = True\n            for prev_lawn_idx in range(1, k):\n                for neighbor_node, g, l in edges[k]:\n                    if neighbor_node == prev_lawn_idx: # If prev_lawn_idx is a neighbor of k\n                        if math.gcd(ans[k], ans[neighbor_node]) != g or math.lcm(ans[k], ans[neighbor_node]) != l:\n                            is_valid_so_far = False\n                            break\n                if not is_valid_so_far:\n                    break\n            \n            if is_valid_so_far:\n                if backtrack(k + 1):\n                    return True\n        \n        return False # No value for lawn k leads to a solution\n\n    # Start backtracking from lawn 1\n    if backtrack(1):\n        sys.stdout.write(\"YES\\n\")\n        sys.stdout.write(\" \".join(map(str, ans[1:])) + \"\\n\")\n    else:\n        sys.stdout.write(\"NO\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    if n == 0: # Edge case: no lawns, but n is at least 1 per constraints\n        sys.stdout.write(\"YES\\n\")\n        sys.stdout.write(\"\\n\")\n        return\n\n    # Store edges and their GCD/LCM values\n    # edges[u] will be a list of (v, g, l) tuples\n    edges = [[] for _ in range(n + 1)]\n    \n    # Store initial constraints for each lawn\n    # lower_bound[i]: must be a multiple of this value\n    # upper_bound[i]: must be a divisor of this value\n    # Initially, lower_bound is 1 (all numbers >= 1)\n    # upper_bound is 10^6 (all numbers <= 10^6)\n    lower_bound = [1] * (n + 1)\n    upper_bound = [1000001] * (n + 1) # Max value 10^6, so 10^6+1 as an exclusive upper bound for iteration\n\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        \n        # Basic check: g must divide l\n        if l % g != 0:\n            sys.stdout.write(\"NO\\n\")\n            return\n\n        edges[u].append((v, g, l))\n        edges[v].append((u, g, l))\n\n        # Update lower_bound for u and v: must be a multiple of g\n        lower_bound[u] = math.lcm(lower_bound[u], g)\n        lower_bound[v] = math.lcm(lower_bound[v], g)\n\n        # Update upper_bound for u and v: must be a divisor of l\n        # The value must divide upper_bound[i] AND l. So it must divide GCD(upper_bound[i], l)\n        # This is not quite right. A value X must divide L_1, L_2, ..., L_k. So X must divide GCD(L_1, L_2, ..., L_k).\n        # We need to find the largest possible value, so we take GCD of all upper bounds.\n        if upper_bound[u] == 1000001: # First time setting an actual LCM constraint\n            upper_bound[u] = l\n        else:\n            upper_bound[u] = math.gcd(upper_bound[u], l)\n        \n        if upper_bound[v] == 1000001: # First time setting an actual LCM constraint\n            upper_bound[v] = l\n        else:\n            upper_bound[v] = math.gcd(upper_bound[v], l)\n\n    # Check for consistency of initial bounds\n    for i in range(1, n + 1):\n        # If lower_bound[i] > upper_bound[i], it's impossible\n        # Or if upper_bound[i] is not a multiple of lower_bound[i]\n        # (e.g., must be a multiple of 6, must be a divisor of 10. No such number)\n        if lower_bound[i] > upper_bound[i] or (upper_bound[i] % lower_bound[i] != 0):\n            sys.stdout.write(\"NO\\n\")\n            return\n        # Also check if lower_bound[i] itself exceeds 10^6\n        if lower_bound[i] > 1000000:\n            sys.stdout.write(\"NO\\n\")\n            return\n\n    # Possible values for each lawn\n    possible_values = [[] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        current_val = lower_bound[i]\n        while current_val <= upper_bound[i] and current_val <= 1000000:\n            # Check if current_val divides upper_bound[i]\n            # This is implicitly handled by the loop condition current_val <= upper_bound[i]\n            # and current_val being multiples of lower_bound[i].\n            # If upper_bound[i] is not a multiple of lower_bound[i], we already returned NO.\n            # So, current_val will always divide upper_bound[i].\n            possible_values[i].append(current_val)\n            if current_val == 0: # Avoid infinite loop if lower_bound[i] is 0, though it's >=1\n                break\n            if upper_bound[i] // current_val < lower_bound[i]: # Avoid overflow or very large step if current_val is huge\n                break\n            current_val += lower_bound[i] # Next multiple of lower_bound[i]\n\n        if not possible_values[i]: # No possible values found for this lawn\n            sys.stdout.write(\"NO\\n\")\n            return\n\n    # Use backtracking to find a solution\n    ans = [0] * (n + 1)\n\n    def backtrack(k):\n        if k == n + 1:\n            # All lawns assigned, check all edges\n            for u in range(1, n + 1):\n                for v_node, g, l in edges[u]:\n                    # Only check each edge once (e.g., u < v_node)\n                    # For simplicity, we can check all stored edges.\n                    # If u is 1 and v_node is 2, and we have (1,2,g,l) and (2,1,g,l),\n                    # we will check it twice, but that's fine.\n                    # It's better to check only if u < v_node to avoid redundant checks.\n                    # However, the problem guarantees no self-loops, no duplicate edges.\n                    # The current graph representation stores (v,g,l) for u and (u,g,l) for v.\n                    # So, if we iterate through edges[u], we'll check (u,v) relation.\n                    # If we iterate through edges[v], we'll check (v,u) relation.\n                    # This is fine, as long as the check is correct.\n                    if math.gcd(ans[u], ans[v_node]) != g or math.lcm(ans[u], ans[v_node]) != l:\n                        return False\n            return True # All edges satisfy conditions\n        \n        # Try assigning a value to lawn k\n        for val in possible_values[k]:\n            ans[k] = val\n            \n            # Check consistency with already assigned neighbors (1 to k-1)\n            is_valid_so_far = True\n            for prev_lawn_idx in range(1, k):\n                for neighbor_node, g, l in edges[k]:\n                    if neighbor_node == prev_lawn_idx: # If prev_lawn_idx is a neighbor of k\n                        if math.gcd(ans[k], ans[neighbor_node]) != g or math.lcm(ans[k], ans[neighbor_node]) != l:\n                            is_valid_so_far = False\n                            break\n                if not is_valid_so_far:\n                    break\n            \n            if is_valid_so_far:\n                if backtrack(k + 1):\n                    return True\n        \n        return False # No value for lawn k leads to a solution\n\n    # Start backtracking from lawn 1\n    if backtrack(1):\n        sys.stdout.write(\"YES\\n\")\n        sys.stdout.write(\" \".join(map(str, ans[1:])) + \"\\n\")\n    else:\n        sys.stdout.write(\"NO\\n\")\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 552,
        "completion_token_count": 1821,
        "thoughts_token_count": 724
    }
}