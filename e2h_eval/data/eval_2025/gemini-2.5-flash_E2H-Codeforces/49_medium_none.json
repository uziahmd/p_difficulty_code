{
    "start": 1758294878.7744513,
    "end": 1758295017.241172,
    "start-formatted": "2025-09-20 00:14 KST",
    "end-formatted": "2025-09-20 00:16 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "**Alright, here's my breakdown of this \"Mushroom Strife\" problem. It's a graph problem with a twist, and I'm zeroing in on a strategy that seems promising.**\n\nFirst, the core issue is assigning mushroom counts to lawns (graph nodes) in a way that respects the GCD and LCM constraints defined by the roads (edges). We have:\n- `x_u * x_v = g * l`, where `x_u`, `x_v` are mushroom counts for connected lawns `u` and `v`, and `g`, `l` are given GCD and LCM.\n\nThis immediately tells me that both `x_u` and `x_v` *must* be multiples of `g`.\n\nA standard strategy, for this kind of constraint problem, involves exploring a Disjoint Set Union (DSU) or graph traversal (BFS/DFS) approach. If we somehow *know* the mushroom count for one lawn, all the connected lawns become constrained (given the edge data).  \n\nIf `x_u` is known, then:\n- `x_v = (g * l) / x_u` AND `GCD(x_u, x_v) = g`.\n\nBut here's the kicker: `x_u` must be `g * a'` and `x_v = g * b'`, where `a' * b' = l/g`, and `GCD(a', b') = 1`. This leads me down a path of Unitary Divisors for `l/g`.\n\nEach edge is a relationship. The initial mushroom value can be chosen only from unitary divisors of `l/g`.\nI now think of the value of each node as a product of \n`X_i = Base_i * K`\nWe have an upper bound, a lower bound. \nEach connected component should form a set.\nIf this `l % g !=0` for any edge, then no solution is possible.\n\nI'm thinking of building an adjacency list. For each node, it would contain neighbors and associated GCD/LCM pairs.\nFor an unvisited node, it can be added to the BFS queue.\nIt is then given a value that must be between 1 and 10^6. This approach should then work.\nLet's see if this works!\n",
    "response": "The problem asks us to assign a positive integer number of mushrooms `x_i` to each lawn `i` (vertex) such that for every given road (edge) between lawns `u` and `v` with specified `GCD(x_u, x_v) = g` and `LCM(x_u, x_v) = l`, these conditions are met. If multiple solutions exist, any one is fine. If no solution, report \"NO\". All `x_i`, `g`, `l` must be between 1 and 10^6.\n\n**Key Properties:**\n1. For any two positive integers `a` and `b`, `a * b = GCD(a, b) * LCM(a, b)`.\n   So, for an edge `(u, v)` with `g, l`, we must have `x_u * x_v = g * l`.\n2. `GCD(a, b) = g` implies `a` and `b` are both multiples of `g`.\n   Let `a = g * a'` and `b = g * b'`.\n   Then `GCD(g * a', g * b') = g * GCD(a', b') = g`, which means `GCD(a', b') = 1`.\n3. Substituting into `a * b = g * l`:\n   `(g * a') * (g * b') = g * l`\n   `g^2 * a' * b' = g * l`\n   `g * a' * b' = l`\n   `a' * b' = l / g`.\n   Let `P = l / g`. So `a' * b' = P` and `GCD(a', b') = 1`.\n\n**Initial Checks and Constraints:**\n- For every edge `(u, v)` with `g, l`:\n    - `l` must be divisible by `g`. If `l % g != 0`, no solution exists.\n    - `x_u` and `x_v` must be multiples of `g`.\n    - `x_u` and `x_v` must be divisors of `l`.\n    - `x_u` and `x_v` must be between 1 and 10^6.\n\n**Graph Traversal Approach:**\nThe problem can be solved by processing each connected component of the graph. For each component, we can pick an arbitrary starting node and assign it an initial value. Then, we propagate values through the component using BFS or DFS.\n\n1. **Precomputation:**\n   - For efficient `GCD` and `LCM` calculations, we'll use `math.gcd`. `LCM(a, b) = (a * b) // GCD(a, b)`.\n   - Store the graph using an adjacency list: `adj[u]` contains tuples `(v, g, l)` for edges connected to `u`.\n\n2. **Node Value Initialization:**\n   - Initialize an array `ans` of size `n+1` with zeros, indicating unknown values.\n   - For each node `i` from `1` to `n`:\n     - If `ans[i]` is still `0` (meaning `i` hasn't been visited yet, starting a new connected component or `i` is isolated):\n       - Determine a set of candidates for `x_i`. `x_i` must be a multiple of `g` for all incident edges, and a divisor of `l` for all incident edges.\n       - Let `min_multiplier_for_i = 1` and `max_divisor_for_i = 10^6`.\n       - For each edge `(i, j, g_ij, l_ij)` incident to `i`:\n         - `min_multiplier_for_i = LCM(min_multiplier_for_i, g_ij)`\n         - `max_divisor_for_i = GCD(max_divisor_for_i, l_ij)`\n       - If `min_multiplier_for_i > max_divisor_for_i` or `max_divisor_for_i % min_multiplier_for_i != 0`, then no solution is possible for this node, so report \"NO\".\n       - The actual value `x_i` must be `min_multiplier_for_i * K` for some `K` that divides `max_divisor_for_i / min_multiplier_for_i`.\n       - A simple valid choice for `x_i` is `min_multiplier_for_i`. This satisfies the basic multiple/divisor constraints for all its edges. Let's try this as our initial guess for the starting node of a component.\n       - If `min_multiplier_for_i > 10^6`, then `NO`.\n\n3. **BFS/DFS Traversal:**\n   - Start a BFS from `i` with `ans[i] = min_multiplier_for_i`.\n   - Use a queue for BFS and a `visited` set to track nodes.\n   - While the queue is not empty:\n     - Dequeue `u`.\n     - For each neighbor `v` of `u` with edge `(u, v, g_uv, l_uv)`:\n       - If `ans[v]` is `0` (unvisited):\n         - Calculate `x_v_candidate = (g_uv * l_uv) // ans[u]`.\n         - **Validation steps for `x_v_candidate`:**\n           - `(g_uv * l_uv) % ans[u] != 0`: `x_v_candidate` is not an integer. `NO`.\n           - `x_v_candidate < 1` or `x_v_candidate > 10^6`: Out of range. `NO`.\n           - `GCD(ans[u], x_v_candidate) != g_uv`: GCD condition not met. `NO`.\n           - `LCM(ans[u], x_v_candidate) != l_uv`: LCM condition not met. `NO`. (This check is often redundant if `GCD` and `x_u * x_v = g*l` hold, but good for robustness).\n           - **Crucially, `x_v_candidate` must also satisfy the local `min_multiplier` and `max_divisor` constraints for `v`**:\n             - Calculate `v_min_mult = 1`, `v_max_div = 10^6` based on all edges incident to `v` (similar to step 2).\n             - If `x_v_candidate % v_min_mult != 0` or `v_max_div % x_v_candidate != 0`: `NO`.\n         - If all checks pass, set `ans[v] = x_v_candidate`, enqueue `v`, and add to `visited`.\n       - Else (`ans[v]` is already known):\n         - Check consistency: `GCD(ans[u], ans[v]) != g_uv` or `LCM(ans[u], ans[v]) != l_uv`. If either is true, `NO`.\n\n4. **Final Output:**\n   - If the BFS/DFS completes for all components without reporting \"NO\", then a solution exists. Print \"YES\" and then the `n` values in `ans[1...n]`.\n\n**Edge Cases:**\n- `m = 0`: All nodes are isolated. Assign `1` to all `ans[i]`.\n- Single node `n=1`: `ans[1] = 1`.\n-Disconnected components: Handled by iterating `i` from `1` to `n` and starting BFS if `ans[i]` is `0`.\n\n**Helper Functions:**\n- `gcd(a, b)`: `math.gcd(a, b)`\n- `lcm(a, b)`: `(a * b) // math.gcd(a, b)`. Need to be careful with potential overflow if `a*b` exceeds typical integer limits before division, but here `a, b <= 10^6`, so `a*b <= 10^12`, which fits in standard 64-bit integers. Python handles large integers automatically.\n\n**Example Walkthrough (from problem statement):**\n`n=3, m=2`\n`3 2 1 2` (edge between 3 and 2, g=1, l=2)\n`3 1 1 10` (edge between 3 and 1, g=1, l=10)\n\n`adj`:\n`1: [(3, 1, 10)]`\n`2: [(3, 1, 2)]`\n`3: [(2, 1, 2), (1, 1, 10)]`\n`ans = [0, 0, 0, 0]`\n\n`i = 1`: `ans[1]` is `0`.\n  - Calculate `min_multiplier_for_1`, `max_divisor_for_1`:\n    - Edge `(1, 3, 1, 10)`: `g=1, l=10`.\n    - `min_multiplier_for_1 = LCM(1, 1) = 1`.\n    - `max_divisor_for_1 = GCD(10^6, 10) = 10`.\n  - `max_divisor_for_1 % min_multiplier_for_1 == 0` (10 % 1 == 0). OK.\n  - `min_multiplier_for_1 = 1 <= 10^6`. OK.\n  - Set `ans[1] = 1`. `q = [1]`. `visited = {1}`.\n\n  Pop `u=1`.\n  Neighbor `v=3` with `g_13=1, l_13=10`.\n  `ans[3]` is `0`.\n    - `x_u = ans[1] = 1`.\n    - `x_v_candidate = (1 * 10) // 1 = 10`.\n    - Checks: `10 % 1 != 0` (false), `1 <= 10 <= 10^6` (true), `GCD(1, 10) == 1` (true), `LCM(1, 10) == 10` (true). All OK.\n    - Calculate `min_multiplier_for_3`, `max_divisor_for_3`:\n      - Edge `(3, 2, 1, 2)`: `g=1, l=2`.\n      - Edge `(3, 1, 1, 10)`: `g=1, l=10`.\n      - `min_multiplier_for_3 = LCM(1, 1, 1) = 1`.\n      - `max_divisor_for_3 = GCD(10^6, 2, 10) = 2`.\n    - Check `x_v_candidate=10` against `min_multiplier_for_3=1` and `max_divisor_for_3=2`:\n      - `10 % 1 != 0` (false). OK.\n      - `2 % 10 != 0` (true)! `x_v_candidate=10` is not a divisor of `max_divisor_for_3=2`. This implies `ans[1]=1` was a wrong choice.\n    - So, output \"NO\".\n\nWait, the example output is `YES\\n5 1 2`. My logic led to \"NO\". What went wrong?\nThe assumption `ans[i] = min_multiplier_for_i` for the starting node `i` is too restrictive. `x_i` can be `min_multiplier_for_i * K` where `K` is any divisor of `max_divisor_for_i / min_multiplier_for_i`.\nThe example solution `5 1 2` for `(x_1, x_2, x_3)` implies:\n- `x_1 = 5, x_3 = 1`: `GCD(5,1)=1, LCM(5,1)=5`. But edge `(1,3)` has `g=1, l=10`. This is a mismatch.\nAh, the example output order is `n` numbers for `x_1, x_2, ..., x_n`.\nFor `n=3, m=2`:\n`3 2 1 2` means `(x_3, x_2)` has `g=1, l=2`.\n`3 1 1 10` means `(x_3, x_1)` has `g=1, l=10`.\nExample output: `x_1=5, x_2=1, x_3=2`.\nLet's verify this solution:\n- Edge `(3, 2)`: `x_3=2, x_2=1`. `GCD(2,1)=1`, `LCM(2,1)=2`. Matches `g=1, l=2`.\n- Edge `(3, 1)`: `x_3=2, x_1=5`. `GCD(2,5)=1`, `LCM(2,5)=10`. Matches `g=1, l=10`.\nThis solution is valid!\n\nMy initial guess `ans[i] = min_multiplier_for_i` is insufficient.\nThe correct approach for setting `x_u` and `x_v` where `x_u = g * a'` and `x_v = g * b'` with `a' * b' = P = l/g` and `GCD(a', b') = 1` is that `a'` must be a unitary divisor of `P`.\nThis means `a'` is formed by taking some subset of the prime power factors of `P`.\nFor example, if `P = p1^k1 * p2^k2`, `a'` can be `1`, `p1^k1`, `p2^k2`, or `p1^k1 * p2^k2`.\n\nThe problem is that if we fix `x_s` for a node `s`, say `x_s = K`, then for any other node `u` in the component, `x_u` is determined by `K` and a path from `s` to `u`.\nLet `x_u = K * R_u` where `R_u` is a rational number.\n`x_v = (g_uv * l_uv) / x_u = (g_uv * l_uv) / (K * R_u)`.\nThis implies `x_u` and `x_v` must be integers.\nSo `K * R_u` must be an integer for all `u`.\nThis means `K` must be a multiple of the common denominator of all `R_u`.\nAnd `K * R_u` must satisfy the `[1, 10^6]` range.\n\nA more robust approach for fixing `x_s`:\nFor each connected component, pick a starting node `s`. Instead of assigning `ans[s]` a concrete value, assign it a symbolic value, say `X`.\nThen for any node `u`, `ans[u]` will be `X * factor[u]`, where `factor[u]` is a rational number.\n`factor[s] = 1`.\nWhen traversing an edge `(u, v)` with `g, l`:\nIf `ans[u] = X * factor[u]` is known, and `ans[v]` is unknown:\n  `ans[v] = (g * l) / (X * factor[u]) = (g * l / factor[u]) * (1/X)`.\n  This means `factor[v] = (g * l) / (factor[u] * X^2)`... This is not `X * factor[v]`.\n  The relation `x_u * x_v = g*l` means `(X*factor_u) * (X*factor_v) = g*l`.\n  So `X^2 * factor_u * factor_v = g*l`.\n  This means `factor_v = (g*l) / (X^2 * factor_u)`. This is not good.\n\nThe structure of `x_i` values is more like `x_i = C_i * K` where `C_i` is a fixed integer and `K` is some integer we need to determine for the component.\nFor each edge `(u, v, g, l)`:\n`x_u = g * a'`, `x_v = g * b'`.\n`a' * b' = l/g`. `GCD(a', b') = 1`.\nThis implies `a'` and `b'` are \"complementary unitary divisors\" of `l/g`.\nLet `P_uv = l/g`.\n`x_u` must be `g * D` where `D` is a unitary divisor of `P_uv`.\nAnd `x_v` must be `g * (P_uv / D)`.\n\nLet's maintain for each node `u` a value `val[u]` and a `base_val[u]`.\n`x_u = val[u] / base_val[u] * K` for some `K`.\nNo, this is getting complicated.\n\nLet's simplify. For a connected component, if we fix `x_s`, all `x_u` are determined as `x_u = x_s * R_u` where `R_u` is a rational.\n`R_s = 1`.\nFor an edge `(u,v)` with `g, l`: if `x_u = x_s * R_u` is known, then `x_v = (g*l)/x_u = (g*l) / (x_s * R_u)`.\nSo `R_v = (g*l) / (x_s^2 * R_u)`. This is problematic.\n\nLet's use the `x_u = g*a'` form.\nFor each node `u`, we want to find `x_u`.\nLet `x_u = k_u`.\nFor an edge `(u, v)` with `g, l`:\n`k_u` must be a divisor of `l`. `k_u` must be a multiple of `g`.\n`k_v` must be a divisor of `l`. `k_v` must be a multiple of `g`.\nAnd `k_u * k_v = g * l`.\nAlso `GCD(k_u, k_v) = g`.\n\nThis structure suggests that `k_u` and `k_v` are of the form `g * D` and `g * (l/g)/D` where `D` is a unitary divisor of `l/g`.\nThe possible values for `x_u` (and `x_v`) are `g * D_i` where `D_i` are unitary divisors of `l/g`.\nThere are `2^k` such `D_i` where `k` is the number of distinct prime factors of `l/g`. `k` is small (max 7 for `10^6`).\n\nFor each connected component, pick a root `r`.\nFor `r`, we have `x_r`.\nFor any node `u` in the component, `x_u` is related to `x_r` by a specific factor.\nLet `x_u = x_r * (factor_num[u] / factor_den[u])`.\nInitialize `factor_num[r] = 1`, `factor_den[r] = 1`.\nWhen traversing `(u, v, g_uv, l_uv)`:\nIf `x_u = x_r * (N_u / D_u)` is known, and `x_v` is unknown:\n  `x_v = (g_uv * l_uv) / x_u = (g_uv * l_uv) * (D_u / (x_r * N_u))`.\n  This means `x_v = x_r * (g_uv * l_uv * D_u) / (N_u * x_r^2)`. Still `x_r` in denominator.\n\nThe problem states \"restore any one\". This usually means there's a canonical choice or a simple heuristic that works.\nThe \"canonical choice\" for `x_i` that satisfies `GCD(x_i, x_j) = g` and `LCM(x_i, x_j) = l` is `g` (then `x_j = l`).\nBut this is only for one edge.\n\nWhat if we fix `x_u` to `1` for the first node in a component, and then adjust it later?\nIf we find a contradiction, we need to backtrack and try a different `x_u` for the root.\nThis means we would need to iterate through all possible unitary divisors `D` for the root node, which could be up to 128 choices for `D`.\nFor each choice, run BFS/DFS. This might be too slow if `N` is large.\n\nThe key is that `x_u` and `x_v` are related by `x_u * x_v = g * l`.\nLet `x_u = A` and `x_v = B`.\nIf `A` is known, `B = g*l / A`. Then check `GCD(A, B) = g`.\nIf `A` is not known, for each edge `(u, v, g, l)`, `x_u` must be a multiple of `g` and `x_v` must be a multiple of `g`.\nLet `x_u = g_u * a_u` and `x_v = g_v * a_v`.\nThis is exactly the formulation that if `x_u = k`, then `x_v = (g*l)/k`.\nThe condition `GCD(k, (g*l)/k) = g` is the crucial one.\nThis implies `k` must be a multiple of `g`. Let `k = g*A`.\nThen `GCD(g*A, (g*l)/(g*A)) = g`.\n`GCD(g*A, l/A) = g`.\nThis means `g` must divide `l/A`. So `l/A` must be a multiple of `g`.\n`l/A = g*B` for some integer `B`.\nSo `l = g*A*B`.\nAnd `GCD(g*A, g*B) = g`. This implies `GCD(A, B) = 1`.\nSo `A*B = l/g`.\nThis means `A` must be a unitary divisor of `l/g`.\nAnd `x_u = g*A`, `x_v = g*B`.\n\nLet `ans[u]` store the final value for node `u`.\nLet `factors[u]` store `x_u / GCD_for_component_root`.\nNo, let's use a simpler formulation.\nFor each node `u`, `ans[u]` will be `X_u`, which is the final mushroom count.\nFor any node `u`, `ans[u]` must be a multiple of `g_uv` for all incident edges `(u,v)`.\nSo `ans[u]` must be a multiple of `LCM(g_uv for all v)`. Let this be `mult_u`.\nAlso `ans[u]` must be a divisor of `l_uv` for all incident edges `(u,v)`.\nSo `ans[u]` must be a divisor of `GCD(l_uv for all v)`. Let this be `div_u`.\nIf `mult_u > div_u` or `div_u % mult_u != 0`, then `NO`.\nThis gives us a range `[mult_u, div_u]` for `ans[u]`, where `ans[u]` must be a multiple of `mult_u` and a divisor of `div_u`.\nLet `ans[u] = mult_u * K_u`, where `K_u` is a divisor of `div_u / mult_u`.\n\nThe structure `x_u = g*A` and `x_v = g*B` where `A*B = l/g` and `GCD(A,B)=1` means that `A` and `B` are \"complementary unitary divisors\" of `l/g`.\nThis is the key.\n\nFor each component, pick a root `r`.\nAssign `ans[r] = mult_r`. (This is the smallest valid value for `x_r` locally.)\nThen do BFS.\nWhen processing `u` and neighbor `v` with edge `(u, v, g, l)`:\nIf `ans[u]` is known and `ans[v]` is not:\n  `P = l/g`.\n  `A = ans[u] / g`.\n  If `ans[u] % g != 0`, then `ans[u]` is not a multiple of `g`. This means our choice for `ans[r]` (or a previous propagation) was wrong. This should lead to `NO`.\n  If `P % A != 0`, then `A` is not a divisor of `P`. This means `ans[u]` is not `g*A` where `A` is a divisor of `P`. `NO`.\n  Let `B = P / A`.\n  If `GCD(A, B) != 1`, then `ans[u]` and `x_v` cannot satisfy `GCD(x_u, x_v) = g`. `NO`.\n  Then `ans[v]` must be `g * B`.\n  Check `ans[v]` validity: `1 <= ans[v] <= 10^6`.\n  Check `ans[v]` against `mult_v` and `div_v`: `ans[v] % mult_v != 0` or `div_v % ans[v] != 0`. If so, `NO`.\n  Set `ans[v] = g * B`, add `v` to queue.\nIf both `ans[u]` and `ans[v]` are known:\n  Verify `GCD(ans[u], ans[v]) == g` and `LCM(ans[u], ans[v]) == l`. If not, `NO`.\n\nThis modified approach is exactly what I tried in the example walkthrough and it failed.\nThe problem is `ans[r] = mult_r` is one specific choice for `x_r`. If this choice leads to a contradiction, it doesn't mean no solution exists, it just means this particular choice for `x_r` (and its derived values) is wrong.\nWe need to find *any* choice.\n\nThe fact that `A` must be a unitary divisor of `P = l/g` is the key.\nFor each node `u`, define `base_val[u]` and `relative_val[u]`.\n`x_u = base_val[u] * relative_val[u]`.\nFor a component, pick root `r`. `base_val[r] = 1`. `relative_val[r] = 1`.\nWhen going `(u, v)` with `g, l`:\n`x_u = base_val[u] * relative_val[u]`.\n`x_v = (g*l) / x_u`.\nIf `x_v` is not an integer, `NO`.\nIf `GCD(x_u, x_v) != g`, `NO`.\nIf `LCM(x_u, x_v) != l`, `NO`.\nThis means `x_u` and `x_v` must be `g*A` and `g*B` with `A*B = l/g` and `GCD(A,B)=1`.\nSo `x_u` must be a multiple of `g`. `x_v` must be a multiple of `g`.\n`x_u = C_u * K` and `x_v = C_v * K` where `K` is some unknown value for the component.\nThis means `x_u / C_u = x_v / C_v = K`.\nSo `(C_u * K) * (C_v * K) = g * l`.\n`K^2 * C_u * C_v = g * l`.\nThis implies `K = sqrt((g*l) / (C_u * C_v))`.\n`K` must be an integer. This is the approach for trees.\n`C_u` and `C_v` can be calculated using BFS/DFS.\n`C_r = 1`. For edge `(u, v, g, l)`:\n`C_v = C_u * (l/g) / (C_u^2 / g^2)`. No, this is not right.\n`C_v = (g*l) / (C_u * (K/K))`.\n`x_u = C_u * K`, `x_v = C_v * K`.\n`C_u * K = g * A`, `C_v * K = g * B`.\n`A * B = l/g`, `GCD(A,B)=1`.\nThis means `C_u * K` must be a multiple of `g`.\nFor each node `u`, we calculate `base[u]` and `coeff[u]`. `x_u = base[u] * coeff[u]`.\n`base[u]` is a value derived from the path from the root. `coeff[u]` is the unknown `K`.\nFor a root `r`, `base[r] = 1`. `coeff[r] = K_r`.\nFor an edge `(u, v, g, l)`:\n`x_u = base[u] * K_r`\n`x_v = base[v] * K_r`\n`base[u] * base[v] * K_r^2 = g * l`.\nThis means `K_r^2 = (g * l) / (base[u] * base[v])`.\nThis is only true if `base[u]` and `base[v]` are calculated such that `base[u] * base[v]` is fixed.\nThis implies `base[v] = (g*l) / base[u]`.\nThis is the approach for trees where `x_u * x_v = g*l` is the only constraint.\nBut we also have `GCD(x_u, x_v) = g`.\n\nThe problem is that `x_u` and `x_v` must be `g*A` and `g*B` where `A*B = l/g` and `GCD(A,B)=1`.\nThis means `x_u/g` and `x_v/g` are coprime.\nLet `y_u = x_u / g_u` where `g_u` is some base value for node `u`.\nThis is a standard problem, usually solved by picking a root `r` and setting `x_r = 1`.\nThen for any `u`, `x_u` can be expressed as `1 * (N_u / D_u)`.\nAll `x_i` must be integers, so `1` is not a good choice.\n`x_u = K * (N_u / D_u)`. `K` is the value of `x_r`.\n`N_u / D_u` is `ratio_u` relative to `x_r`.\n`x_r * ratio_u * x_r * ratio_v = g*l`.\n`x_r^2 * ratio_u * ratio_v = g*l`.\n`x_r = sqrt((g*l) / (ratio_u * ratio_v))`. This implies `x_r` must be integer.\n`ratio_u` for `u` connected to `v` by `(g,l)`:\n`x_u = x_r * path_ratio_u`.\n`x_v = x_r * path_ratio_v`.\n`path_ratio_v = (g*l) / (x_r^2 * path_ratio_u)`.\nThis is not what we want.\n\nThe `x_u = g*A` and `x_v = g*B` with `A*B=l/g` and `GCD(A,B)=1` is the strongest constraint.\nFor each connected component:\n1. Pick an arbitrary root `r`.\n2. Assign `x_r = 1`. (This is a temporary assignment for calculating relative values).\n3. Perform BFS/DFS to calculate `x_u` for all `u` in the component relative to `x_r`.\n   For an edge `(u, v)` with `g, l`:\n   If `x_u` is known, `x_v_temp = (g*l) // x_u`.\n   If `(g*l) % x_u != 0` or `GCD(x_u, x_v_temp) != g`, then this `x_u` is invalid.\n   What if `x_u` is not a multiple of `g`? Then `GCD(x_u, x_v_temp)` will not be `g`.\n   The `x_u` values for a component will be `y_1, y_2, ..., y_k`.\n   We need to find a `K` such that `K*y_i` are integers and satisfy all constraints.\n   `y_i` are rational numbers.\n   Let `y_i = N_i / D_i`.\n   We need `K * N_i / D_i` to be an integer. So `K` must be a multiple of `LCM(D_i)`.\n   Let `K_min = LCM(D_i)`.\n   Then `x_i = K_min * (N_i / D_i)`.\n   This `x_i` must satisfy `[1, 10^6]` and `GCD(x_u, x_v)=g, LCM(x_u, x_v)=l`.\n\nThe solution for the example `3 2, 3 2 1 2, 3 1 1 10` is `x_1=5, x_2=1, x_3=2`.\nLet's trace this with the `x_u = K * (N_u/D_u)` idea.\nPick `r=3`. Set `x_3 = K`.\nEdge `(3, 2, 1, 2)`: `x_3=K, x_2`. `K * x_2 = 1*2=2`. `x_2 = 2/K`.\n  `GCD(K, 2/K) = 1`. This implies `K` must be odd. And `K` must be a divisor of 2. So `K=1`.\n  If `K=1`, then `x_3=1, x_2=2`. `GCD(1,2)=1`. OK.\nEdge `(3, 1, 1, 10)`: `x_3=K, x_1`. `K * x_1 = 1*10=10`. `x_1 = 10/K`.\n  `GCD(K, 10/K) = 1`. This implies `K` must be `1` or `5`.\n  If `K=1`, then `x_3=1, x_1=10`. `GCD(1,10)=1`. OK.\n  If `K=5`, then `x_3=5, x_1=2`. `GCD(5,2)=1`. OK.\n\nSo, for `r=3`:\n- If `x_3=1`: then `x_2=2`, `x_1=10`.\n  Check: `x_1=10, x_2=2, x_3=1`.\n  Edge `(3,2)`: `x_3=1, x_2=2`. `GCD(1,2)=1, LCM(1,2)=2`. OK.\n  Edge `(3,1)`: `x_3=1, x_1=10`. `GCD(1,10)=1, LCM(1,10)=10`. OK.\n  This is a valid solution! `10 2 1`.\n\n- If `x_3=5`: then `x_2=2/5` (not integer). Not possible.\n  Wait, `GCD(K, 2/K)=1` means `K` must be a unitary divisor of 2. Unitary divisors of 2 are {1, 2}.\n  `GCD(K, 10/K)=1` means `K` must be a unitary divisor of 10. Unitary divisors of 10 are {1, 10}.\n  So `K` must be in `{1, 2}` and `{1, 10}`. The intersection is `{1}`.\n  So `K=1` is the only choice for `x_3` if we use this method.\n  This produced `10 2 1`. The example output is `5 1 2`.\n  This means the chosen `x_r` (or `K`) is not simply `1` or a unitary divisor of `l/g`.\n\nThe example solution `x_1=5, x_2=1, x_3=2` implies that `x_1/x_3 = 5/2`, `x_2/x_3 = 1/2`.\nThis suggests that `x_u = K * ratio_u` where `ratio_u` is a rational number.\nFor `r=3`, `ratio_3 = 1`.\nFor `(3,2, g=1, l=2)`: `x_3=K, x_2`. `x_3*x_2=2`. `x_2=2/K`.\n  `GCD(K, 2/K)=1`.\n  `ratio_2 = 2/K`.\nFor `(3,1, g=1, l=10)`: `x_3=K, x_1`. `x_3*x_1=10`. `x_1=10/K`.\n  `GCD(K, 10/K)=1`.\n  `ratio_1 = 10/K`.\nSo `x_1 = K * (10/K)`, `x_2 = K * (2/K)`, `x_3 = K * 1`.\nThis is incorrect. `ratio_u` should be independent of `K`.\n`x_u = C_u * K` where `C_u` is an integer.\n`C_3 = 2`.\n`C_2 = 1`.\n`C_1 = 5`.\nThen `K=1`.\nThis means `x_u` values are fixed relative to each other, and `K` is a global scaling factor.\n`x_u = C_u * K`.\n`C_u * K * C_v * K = g * l`.\n`K^2 * C_u * C_v = g * l`.\n`GCD(C_u * K, C_v * K) = g`.\n`K * GCD(C_u, C_v) = g`.\nThis means `K` must divide `g`.\nAnd `K^2` must divide `g*l`.\nAlso, `(g*l) / (C_u * C_v)` must be a perfect square.\nAnd `K = g / GCD(C_u, C_v)`.\nSubstitute `K` into `K^2 * C_u * C_v = g * l`:\n`(g / GCD(C_u, C_v))^2 * C_u * C_v = g * l`.\n`g^2 * C_u * C_v / GCD(C_u, C_v)^2 = g * l`.\n`g * C_u * C_v / GCD(C_u, C_v)^2 = l`.\nThis must hold for every edge.\n\nAlgorithm using this approach:\n1. Initialize `ans = [0]*(n+1)`.\n2. For each node `i` from `1` to `n`:\n   If `ans[i]` is `0` (new component):\n     a. Start BFS from `i`. `q = deque()`, `q.append(i)`.\n     b. `comp_base = [0]*(n+1)`. `comp_base[i] = 1`. This is `C_i`.\n     c. `comp_g = 0`. `comp_l = 0`. These will be `g` and `l` for `K`.\n     d. While `q` is not empty:\n        `u = q.popleft()`.\n        For `(v, g_uv, l_uv)` in `adj[u]`:\n          If `comp_base[v] == 0`:\n            `C_u = comp_base[u]`.\n            `C_v_candidate = (g_uv * l_uv) // C_u`.\n            If `(g_uv * l_uv) % C_u != 0`: `NO`.\n            `comp_base[v] = C_v_candidate`. `q.append(v)`.\n          Else (both `C_u, C_v` known):\n            `C_u = comp_base[u]`, `C_v = comp_base[v]`.\n            If `C_u * C_v != g_uv * l_uv`: `NO`.\n     e. After BFS, all `comp_base[u]` are set for this component.\n     f. Now find `K`. For any edge `(u, v, g_uv, l_uv)` in the component:\n        `C_u = comp_base[u]`, `C_v = comp_base[v]`.\n        `K_sq = (g_uv * l_uv) // (C_u * C_v)`.\n        If `(g_uv * l_uv) % (C_u * C_v) != 0` or `K_sq` is not a perfect square: `NO`.\n        Let `K_val = sqrt(K_sq)`. This `K_val` must be consistent across all edges.\n        Also, `K_val * GCD(C_u, C_v) = g_uv`.\n        If this `K_val` is not consistent, `NO`.\n        Find the smallest `K_val` that satisfies all `K_val * GCD(C_u, C_v) = g_uv`.\n        This `K_val` must be `LCM(g_uv / GCD(C_u, C_v))` over all edges.\n        Let `K_final = 1`.\n        For each edge `(u, v, g_uv, l_uv)` in the component:\n          `K_candidate = g_uv // GCD(comp_base[u], comp_base[v])`.\n          If `g_uv % GCD(comp_base[u], comp_base[v]) != 0`: `NO`.\n          `K_final = LCM(K_final, K_candidate)`.\n        After finding `K_final`, check if `K_final^2 * comp_base[u] * comp_base[v] == g_uv * l_uv` for all edges. If not, `NO`.\n        Check if `K_final * comp_base[u]` is in `[1, 10^6]` for all `u`. If not, `NO`.\n     g. Assign `ans[u] = comp_base[u] * K_final` for all `u` in the component.\n\nThis approach looks more promising. The `comp_base` values are relative multipliers. `K_final` is the common scaling factor.\n\nFinal checks:\n- `math.isqrt` is available in Python 3.8+. For older versions, `int(math.sqrt(x))` and check `x == y*y`.\n- `LCM` implementation: `(a * b) // math.gcd(a, b)`. Need to handle `a=0` or `b=0` cases, but here values are positive. `lcm(1, x) = x`.\n- The maximum value of `C_u * C_v` could be `10^12` (if `g*l` is `10^12`). `K_sq` could be `10^12`. `K_val` could be `10^6`. `K_final * comp_base[u]` could be `10^6 * 10^6 = 10^12`, which is too large.\n  The constraint is `x_i <= 10^6`. So `comp_base[u] * K_final <= 10^6`.\n  This implies `comp_base[u]` can't be too large if `K_final` is large.\n\nLet's re-examine `K_final` calculation.\n`K_val * GCD(C_u, C_v) = g_uv`.\n`K_val` must be `g_uv / GCD(C_u, C_v)`.\nThis `K_val` must be the same for all edges in the component.\nSo we can pick the first edge `(u0, v0, g0, l0)` and compute `K_val_0 = g0 // GCD(comp_base[u0], comp_base[v0])`.\nThen iterate over all other edges `(u, v, g, l)`:\n  `K_candidate = g // GCD(comp_base[u], comp_base[v])`.\n  If `K_candidate != K_val_0` or `g % GCD(comp_base[u], comp_base[v]) != 0`: `NO`.\nThis `K_val_0` is our `K_final`.\n\n```python\nimport sys\nimport math\nfrom collections import deque\n\ndef gcd(a, b):\n    return math.gcd(a, b)\n\ndef lcm(a, b):\n    if a == 0 or b == 0:\n        return 0\n    return (a * b) // gcd(a, b)\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    edges = [] # Store all edges for final K_final check\n\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        if l % g != 0:\n            print(\"NO\")\n            return\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l))\n        edges.append((u, v, g, l))\n\n    ans = [0] * (n + 1)\n    \n    # Pre-calculate min_mult and max_div for each node\n    # x_i must be a multiple of min_mult[i] and a divisor of max_div[i]\n    min_mult = [1] * (n + 1)\n    max_div = [10**6] * (n + 1)\n\n    for u in range(1, n + 1):\n        for v_neighbor, g_uv, l_uv in adj[u]:\n            min_mult[u] = lcm(min_mult[u], g_uv)\n            max_div[u] = gcd(max_div[u], l_uv)\n        \n        if min_mult[u] > max_div[u] or max_div[u] % min_mult[u] != 0:\n            print(\"NO\")\n            return\n        if min_mult[u] > 10**6: # Even the minimum possible value is too high\n            print(\"NO\")\n            return\n\n    for i in range(1, n + 1):\n        if ans[i] == 0: # Start BFS for a new connected component\n            \n            comp_base = [0] * (n + 1) # C_u values\n            q = deque()\n\n            # Assign first node in component a base value of 1\n            comp_base[i] = 1 \n            q.append(i)\n\n            component_nodes = [] # To keep track of nodes in this component\n            component_edges = [] # To keep track of edges in this component\n\n            head_k_val = -1 # K_final for this component\n\n            while q:\n                u = q.popleft()\n                component_nodes.append(u)\n\n                for v_neighbor, g_uv, l_uv in adj[u]:\n                    if (u, v_neighbor, g_uv, l_uv) not in component_edges and \\\n                       (v_neighbor, u, g_uv, l_uv) not in component_edges: # Avoid duplicate edge processing\n                        component_edges.append((u, v_neighbor, g_uv, l_uv))\n\n                    if comp_base[v_neighbor] == 0:\n                        # x_u * x_v = g_uv * l_uv\n                        # (C_u * K) * (C_v * K) = g_uv * l_uv\n                        # C_u * C_v * K^2 = g_uv * l_uv\n                        # We are setting C_u and C_v such that C_u * C_v = g_uv * l_uv\n                        # And then K will be 1. This is the first step.\n                        # Later, we will find the actual K.\n                        \n                        # So, C_v = (g_uv * l_uv) / C_u\n                        \n                        # Check if C_u divides g_uv * l_uv\n                        if (g_uv * l_uv) % comp_base[u] != 0:\n                            print(\"NO\")\n                            return\n                        \n                        C_v_candidate = (g_uv * l_uv) // comp_base[u]\n                        \n                        comp_base[v_neighbor] = C_v_candidate\n                        q.append(v_neighbor)\n                    else:\n                        # Both C_u and C_v are known. Check consistency.\n                        # C_u * C_v must be equal to g_uv * l_uv\n                        if comp_base[u] * comp_base[v_neighbor] != g_uv * l_uv:\n                            print(\"NO\")\n                            return\n            \n            # After BFS, all comp_base values are relative to each other.\n            # Now determine the actual scaling factor K for this component.\n            # K * GCD(C_u, C_v) = g_uv must hold for all edges.\n            # So K = g_uv / GCD(C_u, C_v) must be consistent.\n            \n            if not component_edges: # Isolated node\n                K_final = 1\n            else:\n                first_u, first_v, first_g, first_l = component_edges[0]\n                \n                # Check divisibility for the first edge\n                if first_g % gcd(comp_base[first_u], comp_base[first_v]) != 0:\n                    print(\"NO\")\n                    return\n                \n                head_k_val = first_g // gcd(comp_base[first_u], comp_base[first_v])\n                \n                # Check consistency for all other edges\n                for u_e, v_e, g_e, l_e in component_edges:\n                    if g_e % gcd(comp_base[u_e], comp_base[v_e]) != 0:\n                        print(\"NO\")\n                        return\n                    \n                    current_k_val = g_e // gcd(comp_base[u_e], comp_base[v_e])\n                    if current_k_val != head_k_val:\n                        print(\"NO\")\n                        return\n                K_final = head_k_val\n\n            # Final validation and assignment\n            for u in component_nodes:\n                x_u_final = comp_base[u] * K_final\n\n                # Check range\n                if not (1 <= x_u_final <= 10**6):\n                    print(\"NO\")\n                    return\n                \n                # Check against pre-calculated min_mult and max_div\n                if x_u_final % min_mult[u] != 0 or max_div[u] % x_u_final != 0:\n                    print(\"NO\")\n                    return\n                \n                ans[u] = x_u_final\n\n    print(\"YES\")\n    print(*(ans[1:]))\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\nfrom collections import deque\n\ndef gcd(a, b):\n    return math.gcd(a, b)\n\ndef lcm(a, b):\n    if a == 0 or b == 0:\n        return 0\n    return (a * b) // gcd(a, b)\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    edges = [] # Store all edges for final K_final check\n\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        if l % g != 0:\n            print(\"NO\")\n            return\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l))\n        edges.append((u, v, g, l))\n\n    ans = [0] * (n + 1)\n    \n    # Pre-calculate min_mult and max_div for each node\n    # x_i must be a multiple of min_mult[i] and a divisor of max_div[i]\n    min_mult = [1] * (n + 1)\n    max_div = [10**6] * (n + 1)\n\n    for u in range(1, n + 1):\n        for v_neighbor, g_uv, l_uv in adj[u]:\n            min_mult[u] = lcm(min_mult[u], g_uv)\n            max_div[u] = gcd(max_div[u], l_uv)\n        \n        if min_mult[u] > max_div[u] or max_div[u] % min_mult[u] != 0:\n            print(\"NO\")\n            return\n        if min_mult[u] > 10**6: # Even the minimum possible value is too high\n            print(\"NO\")\n            return\n\n    for i in range(1, n + 1):\n        if ans[i] == 0: # Start BFS for a new connected component\n            \n            comp_base = [0] * (n + 1) # C_u values\n            q = deque()\n\n            # Assign first node in component a base value of 1\n            comp_base[i] = 1 \n            q.append(i)\n\n            component_nodes = [] # To keep track of nodes in this component\n            component_edges = [] # To keep track of edges in this component\n\n            head_k_val = -1 # K_final for this component\n\n            while q:\n                u = q.popleft()\n                component_nodes.append(u)\n\n                for v_neighbor, g_uv, l_uv in adj[u]:\n                    if (u, v_neighbor, g_uv, l_uv) not in component_edges and \\\n                       (v_neighbor, u, g_uv, l_uv) not in component_edges: # Avoid duplicate edge processing\n                        component_edges.append((u, v_neighbor, g_uv, l_uv))\n\n                    if comp_base[v_neighbor] == 0:\n                        # x_u * x_v = g_uv * l_uv\n                        # (C_u * K) * (C_v * K) = g_uv * l_uv\n                        # C_u * C_v * K^2 = g_uv * l_uv\n                        # We are setting C_u and C_v such that C_u * C_v = g_uv * l_uv\n                        # And then K will be 1. This is the first step.\n                        # Later, we will find the actual K.\n                        \n                        # So, C_v = (g_uv * l_uv) / C_u\n                        \n                        # Check if C_u divides g_uv * l_uv\n                        if (g_uv * l_uv) % comp_base[u] != 0:\n                            print(\"NO\")\n                            return\n                        \n                        C_v_candidate = (g_uv * l_uv) // comp_base[u]\n                        \n                        comp_base[v_neighbor] = C_v_candidate\n                        q.append(v_neighbor)\n                    else:\n                        # Both C_u and C_v are known. Check consistency.\n                        # C_u * C_v must be equal to g_uv * l_uv\n                        if comp_base[u] * comp_base[v_neighbor] != g_uv * l_uv:\n                            print(\"NO\")\n                            return\n            \n            # After BFS, all comp_base values are relative to each other.\n            # Now determine the actual scaling factor K for this component.\n            # K * GCD(C_u, C_v) = g_uv must hold for all edges.\n            # So K = g_uv / GCD(C_u, C_v) must be consistent.\n            \n            if not component_edges: # Isolated node\n                K_final = 1\n            else:\n                first_u, first_v, first_g, first_l = component_edges[0]\n                \n                # Check divisibility for the first edge\n                if first_g % gcd(comp_base[first_u], comp_base[first_v]) != 0:\n                    print(\"NO\")\n                    return\n                \n                head_k_val = first_g // gcd(comp_base[first_u], comp_base[first_v])\n                \n                # Check consistency for all other edges\n                for u_e, v_e, g_e, l_e in component_edges:\n                    if g_e % gcd(comp_base[u_e], comp_base[v_e]) != 0:\n                        print(\"NO\")\n                        return\n                    \n                    current_k_val = g_e // gcd(comp_base[u_e], comp_base[v_e])\n                    if current_k_val != head_k_val:\n                        print(\"NO\")\n                        return\n                K_final = head_k_val\n\n            # Final validation and assignment\n            for u in component_nodes:\n                x_u_final = comp_base[u] * K_final\n\n                # Check range\n                if not (1 <= x_u_final <= 10**6):\n                    print(\"NO\")\n                    return\n                \n                # Check against pre-calculated min_mult and max_div\n                if x_u_final % min_mult[u] != 0 or max_div[u] % x_u_final != 0:\n                    print(\"NO\")\n                    return\n                \n                ans[u] = x_u_final\n\n    print(\"YES\")\n    print(*(ans[1:]))\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 542,
        "completion_token_count": 12229,
        "thoughts_token_count": 7596
    }
}