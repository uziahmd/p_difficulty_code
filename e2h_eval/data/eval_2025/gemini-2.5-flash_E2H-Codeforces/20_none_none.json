{
    "start": 1758011557.5964842,
    "end": 1758011616.2384262,
    "start-formatted": "2025-09-16 17:32 KST",
    "end-formatted": "2025-09-16 17:33 KST",
    "gpu": 2,
    "pid": 20,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Multiset of Strings\n\nYou are given three integers $$$n$$$, $$$k$$$ and $$$f$$$.Consider all binary strings (i. e. all strings consisting of characters $$$0$$$ and/or $$$1$$$) of length from $$$1$$$ to $$$n$$$. For every such string $$$s$$$, you need to choose an integer $$$c_s$$$ from $$$0$$$ to $$$k$$$.A multiset of binary strings of length exactly $$$n$$$ is considered beautiful if for every binary string $$$s$$$ with length from $$$1$$$ to $$$n$$$, the number of strings in the multiset such that $$$s$$$ is their prefix is not exceeding $$$c_s$$$.For example, let $$$n = 2$$$, $$$c_{0} = 3$$$, $$$c_{00} = 1$$$, $$$c_{01} = 2$$$, $$$c_{1} = 1$$$, $$$c_{10} = 2$$$, and $$$c_{11} = 3$$$. The multiset of strings $$$\\{11, 01, 00, 01\\}$$$ is beautiful, since:  for the string $$$0$$$, there are $$$3$$$ strings in the multiset such that $$$0$$$ is their prefix, and $$$3 \\le c_0$$$;  for the string $$$00$$$, there is one string in the multiset such that $$$00$$$ is its prefix, and $$$1 \\le c_{00}$$$;  for the string $$$01$$$, there are $$$2$$$ strings in the multiset such that $$$01$$$ is their prefix, and $$$2 \\le c_{01}$$$;  for the string $$$1$$$, there is one string in the multiset such that $$$1$$$ is its prefix, and $$$1 \\le c_1$$$;  for the string $$$10$$$, there are $$$0$$$ strings in the multiset such that $$$10$$$ is their prefix, and $$$0 \\le c_{10}$$$;  for the string $$$11$$$, there is one string in the multiset such that $$$11$$$ is its prefix, and $$$1 \\le c_{11}$$$. Now, for the problem itself. You have to calculate the number of ways to choose the integer $$$c_s$$$ for every binary string $$$s$$$ of length from $$$1$$$ to $$$n$$$ in such a way that the maximum possible size of a beautiful multiset is exactly $$$f$$$.\n\n## Input\nThe only line of input contains three integers $$$n$$$, $$$k$$$ and $$$f$$$ ($$$1 \\le n \\le 15$$$; $$$1 \\le k, f \\le 2 \\cdot 10^5$$$).\n\n## Output\nPrint one integer — the number of ways to choose the integer $$$c_s$$$ for every binary string $$$s$$$ of length from $$$1$$$ to $$$n$$$ in such a way that the maximum possible size of a beautiful multiset is exactly $$$f$$$. Since it can be huge, print it modulo $$$998244353$$$.\n\n## Example\n### Input\n['1 42 2', '2 37 13', '4 1252 325', '6 153 23699', '15 200000 198756']\n\n### Output\n['3', '36871576', '861735572', '0', '612404746']\n\n## Note\nIn the first example, the three ways to choose the integers $$$c_s$$$ are:  $$$c_0 = 0$$$, $$$c_1 = 2$$$, then the maximum beautiful multiset is $$$\\{1, 1\\}$$$;  $$$c_0 = 1$$$, $$$c_1 = 1$$$, then the maximum beautiful multiset is $$$\\{0, 1\\}$$$;  $$$c_0 = 2$$$, $$$c_1 = 0$$$, then the maximum beautiful multiset is $$$\\{0, 0\\}$$$. \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "",
    "response": "```python\nMOD = 998244353\n\ndef solve():\n    n, k, f = map(int, input().split())\n\n    dp_ways = [[0] * (k + 1) for _ in range(n + 1)]\n    dp_sum = [[0] * (k + 1) for _ in range(n + 1)]\n\n    # Base case: length n\n    # For strings of length n, c_s is the count for that specific string.\n    # The sum of c_s for all strings of length n is the total size.\n    # dp_ways[n][s] = number of ways to choose c_s for strings of length n\n    #                 such that their sum is s.\n    # dp_sum[n][s] = sum of (ways * s) for s.\n\n    # For length n, there are 2^n strings.\n    # Each c_s can be from 0 to k.\n    # This is equivalent to distributing s items into 2^n bins, where each bin has capacity k.\n    # Or, choosing 2^n numbers (c_s) from 0 to k that sum to s.\n    # This is (s + 2^n - 1) choose (2^n - 1) without upper bound,\n    # and then using inclusion-exclusion for upper bound k.\n    # However, k can be large, and 2^n can be large (up to 2^15).\n    # The problem statement says \"maximum possible size of a beautiful multiset is exactly f\".\n    # Let's re-evaluate what the maximum size is.\n\n    # Maximum size of a beautiful multiset:\n    # For any string s of length < n, let P(s) be the set of strings in the multiset that have s as a prefix.\n    # The condition is |P(s)| <= c_s.\n    # For a string s of length n, P(s) is just the count of s in the multiset.\n    #\n    # The maximum size of a beautiful multiset is determined by the minimum of c_s for prefixes.\n    # Let M(s) be the maximum number of strings in a beautiful multiset that have s as a prefix.\n    # If s has length n, M(s) = c_s.\n    # If s has length < n, M(s) = min(c_s, M(s0) + M(s1)).\n    # The total size of the multiset is M(\"\"), where \"\" is the empty string (root of the trie).\n    # M(\"\") = M(\"0\") + M(\"1\").\n    # The problem asks for the number of ways to choose c_s such that M(\"\") = f.\n\n    # Let's define dp[len][val] as the number of ways to choose c_s for all strings of length `len` to `n`\n    # (that are extensions of some fixed prefix of length `len-1`) such that the total maximum size\n    # for this subtree is `val`.\n    # This is still not quite right. The `c_s` values for prefixes depend on children.\n\n    # Let's re-read: \"the number of strings in the multiset such that s is their prefix is not exceeding c_s\".\n    # The maximum possible size of a beautiful multiset is determined by the `c_s` values.\n    # For any node `u` in the trie (representing string `s`), let `N(u)` be the number of strings in the multiset\n    # that have `s` as a prefix.\n    # We must have `N(u) <= c_s`.\n    # If `s` has length `n`, `N(u)` is the count of string `s` in the multiset.\n    # If `s` has length `< n`, `N(u) = N(u_0) + N(u_1)`, where `u_0` is `s0` and `u_1` is `s1`.\n    #\n    # To maximize the total size, we want to maximize `N(\"\")`.\n    # `N(\"\") = N(\"0\") + N(\"1\")`.\n    # `N(\"s\") = min(c_s, N(\"s0\") + N(\"s1\"))` for `len(s) < n`.\n    # `N(\"s\") = c_s` for `len(s) = n`.\n    #\n    # Let `dp[i][j]` be the number of ways to choose `c_s` for all strings `s` of length `i` to `n`\n    # that are descendants of a fixed string of length `i-1`, such that the maximum possible\n    # contribution from this subtree (i.e., `N(s_parent)`) is `j`.\n    #\n    # Base case: `i = n`.\n    # For each string `s` of length `n`, we choose `c_s`.\n    # The maximum contribution from this string is `c_s`.\n    # We are considering *one* string `s` of length `n`.\n    # The value `j` is `c_s`.\n    # There is 1 way to choose `c_s` such that `N(s) = c_s`.\n    # So `dp[n][j] = 1` for `0 <= j <= k`.\n    # This counts choices for *one* leaf node.\n    # There are `2^n` leaf nodes.\n    # For `i=n`, we are considering the values `c_s` for all `2^n` strings of length `n`.\n    # The total sum of `c_s` for these `2^n` strings will be the total size.\n    # Let `dp_n[s]` be the number of ways to choose `c_s` for all `2^n` strings of length `n`\n    # such that their sum is `s`.\n    # This is a stars and bars problem: `s` items into `2^n` bins, each bin capacity `k`.\n    # This is `(s + 2^n - 1) choose (2^n - 1)` without capacity constraint.\n    # `2^n` can be up to `2^15 = 32768`. `k` up to `2e5`. `f` up to `2e5`.\n    # The sum `s` can be up to `2^n * k`.\n    # `f` is the total size, so `s` can be up to `f`.\n    # `dp_n[s]` for `s` from `0` to `f`.\n    #\n    # Let `ways[count][current_sum]` be the number of ways to choose `count` values `c_s`\n    # (each from `0` to `k`) that sum up to `current_sum`.\n    # `ways[1][j] = 1` for `0 <= j <= k`.\n    # For `c = 2` to `2^n`:\n    # `ways[c][s] = sum(ways[c-1][s - j])` for `0 <= j <= k`.\n    # This is `ways[c][s] = sum_{j=0 to k} ways[c-1][s-j]`.\n    # This can be computed efficiently using prefix sums: `ways[c][s] = prefix_sum[c-1][s] - prefix_sum[c-1][s-k-1]`.\n    # Let `dp_last_level[s]` be `ways[2^n][s]`.\n    # `dp_last_level` will be the base for our DP.\n    #\n    # `dp[i][j]` = number of ways to choose `c_s` for all strings `s` of length `i` to `n`\n    #              (descendants of a fixed string of length `i-1`)\n    #              such that `min(c_s_parent, N(s0) + N(s1))` is `j`.\n    # This is still wrong. The problem is that `c_s` values are chosen *first*, then `f` is determined.\n    # We need to count ways to choose `c_s` for all strings `s` (length 1 to n)\n    # such that `max_size = f`.\n\n    # Let `g[len][val]` be the number of ways to choose `c_s` for all strings `s` of length `len` to `n`\n    # that are descendants of a fixed string of length `len-1`, such that the *maximum possible value*\n    # for `N(s_parent)` (which is `min(c_s_parent, N(s0) + N(s1))`) is `val`.\n    # This `val` is the effective capacity for the parent.\n    #\n    # Let `dp[i][j]` be the number of ways to assign `c_s` values for all strings `s` of length `i` to `n`\n    # that are extensions of a particular string of length `i-1`, such that the maximum possible\n    # number of strings in a beautiful multiset with this prefix is `j`.\n    #\n    # For `i = n`: There is one string `s` of length `n`. We choose `c_s`.\n    # The maximum possible count for this string is `c_s`.\n    # So, `dp[n][j]` is the number of ways to choose `c_s` for *this specific string* such that its max count is `j`.\n    # This is 1 way (choose `c_s = j`).\n    # `dp[n][j] = 1` for `0 <= j <= k`.\n    #\n    # For `i < n`: Consider a string `s` of length `i-1`. Its children are `s0` and `s1`.\n    # We need to choose `c_s`, `c_{s0}`, `c_{s1}`, ..., `c_{leaf_nodes}`.\n    # The maximum count for `s` is `min(c_s, N(s0) + N(s1))`.\n    # `N(s0)` is the max count for `s0`'s subtree, `N(s1)` for `s1`'s subtree.\n    #\n    # Let `dp[i][j]` be the number of ways to choose `c_x` for all strings `x` of length `i` to `n`\n    # that are descendants of a fixed string `s` of length `i-1`, such that `N(s0) + N(s1)` (the sum of max counts\n    # from its children's subtrees) is `j`.\n    #\n    # Let `ways_subtree[i][j]` be the number of ways to choose `c_x` for all strings `x` of length `i` to `n`\n    # that are descendants of a fixed string `s` of length `i-1`, such that the sum of maximum counts\n    # from its children `s0` and `s1` (i.e., `N(s0) + N(s1)`) is `j`.\n    #\n    # Base case: `i = n`.\n    # For a string `s` of length `n-1`, its children are `s0` and `s1`, both of length `n`.\n    # `N(s0) = c_{s0}` and `N(s1) = c_{s1}`.\n    # We need to choose `c_{s0}` and `c_{s1}`.\n    # `ways_subtree[n][j]` is the number of ways to choose `c_{s0}` and `c_{s1}` such that `c_{s0} + c_{s1} = j`.\n    # Each `c_x` is from `0` to `k`.\n    # This is `j+1` ways if `j <= k`, `k - (j-k) + 1 = 2k - j + 1` if `k < j <= 2k`.\n    # Let `dp[j]` be the number of ways to pick two integers `a, b` s.t. `0 <= a, b <= k` and `a+b=j`.\n    # `dp[j] = j+1` for `0 <= j <= k`.\n    # `dp[j] = k - (j-k) + 1 = 2k - j + 1` for `k < j <= 2k`.\n    # `dp[j] = 0` otherwise.\n    # This `dp` array will be `ways_subtree[n]`.\n    # Let `S_n[j]` be this array.\n    #\n    # Now for `i` from `n-1` down to `1`:\n    # `ways_subtree[i][j]` is the number of ways to choose `c_x` for descendants of `s0` and `s1` (of length `i`)\n    # such that `N(s0) + N(s1) = j`.\n    # `N(s0)` is determined by `min(c_{s0}, N(s00) + N(s01))`.\n    # `N(s1)` is determined by `min(c_{s1}, N(s10) + N(s11))`.\n    #\n    # Let `dp_current_level[j]` be the number of ways to choose `c_x` for descendants of a string `s` of length `i`\n    # such that `N(s) = j`.\n    #\n    # `dp_current_level[j]` depends on `ways_subtree[i+1][sum_children]`.\n    # For a fixed string `s` of length `i`, we need to choose `c_s` from `0` to `k`.\n    # And we need to choose `c_x` for its descendants `s0` and `s1`.\n    # Let `sum_children = N(s0) + N(s1)`.\n    # The number of ways to get `sum_children` is `ways_subtree[i+1][sum_children] * ways_subtree[i+1][sum_children]`.\n    # No, this is wrong. It's `conv(ways_subtree[i+1], ways_subtree[i+1])`.\n    # Let `W_{i+1}` be `ways_subtree[i+1]`.\n    # Let `W'_{i+1} = W_{i+1} * W_{i+1}` (convolution).\n    # `W'_{i+1}[j]` = number of ways to choose `c_x` for descendants of `s0` and `s1`\n    #                  such that `N(s0) + N(s1) = j`.\n    #\n    # Now, for a fixed string `s` of length `i`, we choose `c_s` from `0` to `k`.\n    # And we have `W'_{i+1}[sum_children]` ways to choose `c_x` for descendants of `s0` and `s1`\n    # such that `N(s0) + N(s1) = sum_children`.\n    # The actual `N(s)` will be `min(c_s, sum_children)`.\n    #\n    # So `dp_val_for_one_node[i][j]` = number of ways to choose `c_s` for *one* string `s` of length `i`\n    #                                  and its descendants such that `N(s) = j`.\n    # `dp_val_for_one_node[i][j] = sum_{c_s=0 to k} sum_{sum_children=0 to MAX_SUM} [min(c_s, sum_children) == j] * W'_{i+1}[sum_children]`\n    #\n    # Let `P_{i+1}[val]` be the prefix sum of `W'_{i+1}`.\n    # `P_{i+1}[val] = sum_{x=0 to val} W'_{i+1}[x]`.\n    #\n    # `dp_val_for_one_node[i][j]`\n    # `j = min(c_s, sum_children)`\n    #\n    # Case 1: `c_s = j`. Then `sum_children >= j`.\n    # Sum over `sum_children` from `j` to `MAX_SUM`: `W'_{i+1}[sum_children]`.\n    # This is `P_{i+1}[MAX_SUM] - P_{i+1}[j-1]`.\n    #\n    # Case 2: `sum_children = j`. Then `c_s > j`.\n    # Sum over `c_s` from `j+1` to `k`: `1` (for each `c_s`).\n    # This is `k - (j+1) + 1 = k - j`.\n    # So, `(k-j) * W'_{i+1}[j]`.\n    #\n    # Combining:\n    # `dp_val_for_one_node[i][j] = (P_{i+1}[MAX_SUM] - P_{i+1}[j-1] + MOD) % MOD` (for `c_s = j`)\n    #                            `+ (k-j) * W'_{i+1}[j] % MOD` (for `sum_children = j`)\n    # This is for `0 <= j <= k`. If `j > k`, `c_s` cannot be `j`, so `dp_val_for_one_node[i][j] = 0`.\n    # The `P_{i+1}[MAX_SUM]` part is the total number of ways to choose `c_x` for descendants.\n    #\n    # `dp_val_for_one_node[i][j]` calculation:\n    # `term1 = (P_{i+1}[MAX_SUM] - (P_{i+1}[j-1] if j > 0 else 0) + MOD) % MOD`\n    # `term2 = (k - j) * W'_{i+1}[j] % MOD` if `j <= k` else `0`\n    # `dp_val_for_one_node[i][j] = (term1 + term2) % MOD`\n    #\n    # This `dp_val_for_one_node[i]` array becomes `ways_subtree[i]`.\n    #\n    # Max possible sum `f` is `2e5`. `k` is `2e5`.\n    # The maximum value for `j` (total count) is `f`.\n    # The maximum value for `sum_children` is `f`.\n    # So arrays should be of size `f+1`.\n    #\n    # Let `dp[i]` be the array `dp_val_for_one_node[i]`.\n    # `dp[n]` is special. For a string `s` of length `n`, `N(s) = c_s`.\n    # `dp[n][j] = 1` for `0 <= j <= k`.\n    # `dp[n][j] = 0` for `j > k`.\n    #\n    # Iteration:\n    # `dp[n]` is initialized as above.\n    # `MAX_SUM_CHILDREN = 2 * f` (since `N(s0)` and `N(s1)` can be up to `f`).\n    #\n    # For `i = n-1` down to `1`:\n    #   `W_prime_i_plus_1 = convolution(dp[i+1], dp[i+1])`\n    #   `P_i_plus_1 = prefix_sums(W_prime_i_plus_1)`\n    #   For `j = 0` to `f`:\n    #     `term1 = (P_i_plus_1[f] - (P_i_plus_1[j-1] if j > 0 else 0) + MOD) % MOD`\n    #     `term2 = 0`\n    #     If `j <= k`:\n    #       `term2 = (k - j) * W_prime_i_plus_1[j] % MOD`\n    #     `dp[i][j] = (term1 + term2) % MOD`\n    #\n    # The final answer is `dp[1][f]`.\n    #\n    # Convolution: `C[s] = sum_{x=0 to s} A[x] * B[s-x]`.\n    # Max `f` is `2e5`. Convolution of two arrays of size `f+1` takes `O(f^2)`.\n    # `n` is up to `15`. `O(n * f^2)` is too slow. `15 * (2e5)^2 = 15 * 4e10`.\n    #\n    # Convolution can be done using NTT (Number Theoretic Transform) in `O(f log f)`.\n    # Total `O(n * f log f)`. `15 * 2e5 * log(2e5) = 15 * 2e5 * 18 = 5.4e7`. This is feasible.\n\n    # NTT setup\n    # MOD = 998244353 is a prime, and 998244353 = 119 * 2^23 + 1.\n    # Primitive root g = 3.\n\n    def ntt(a, invert):\n        n = len(a)\n        j = 0\n        for i in range(1, n):\n            if i < j:\n                a[i], a[j] = a[j], a[i]\n            k = n // 2\n            while j >= k:\n                j -= k\n                k //= 2\n            j += k\n\n        root = pow(3, (MOD - 1) // n, MOD)\n        if invert:\n            root = pow(root, MOD - 2, MOD)\n\n        for length in range(2, n + 1, 2):\n            for i in range(0, n, length):\n                w = 1\n                for j in range(length // 2):\n                    u = a[i + j]\n                    v = a[i + j + length // 2] * w % MOD\n                    a[i + j] = (u + v) % MOD\n                    a[i + j + length // 2] = (u - v + MOD) % MOD\n                    w = w * root % MOD\n\n        if invert:\n            n_inv = pow(n, MOD - 2, MOD)\n            for i in range(n):\n                a[i] = a[i] * n_inv % MOD\n        return a\n\n    def multiply(a, b):\n        len_a = len(a)\n        len_b = len(b)\n        res_len = len_a + len_b - 1\n        \n        # Find smallest power of 2 greater than or equal to res_len\n        ntt_len = 1\n        while ntt_len < res_len:\n            ntt_len <<= 1\n        \n        a_padded = list(a) + [0] * (ntt_len - len_a)\n        b_padded = list(b) + [0] * (ntt_len - len_b)\n\n        a_fft = ntt(a_padded, False)\n        b_fft = ntt(b_padded, False)\n\n        c_fft = [a_fft[i] * b_fft[i] % MOD for i in range(ntt_len)]\n        \n        c = ntt(c_fft, True)\n        \n        return c[:res_len]\n\n    # Initialize dp[n]\n    # dp[n][j] = 1 for 0 <= j <= k, 0 otherwise\n    dp = [[0] * (f + 1) for _ in range(n + 1)]\n\n    for j in range(min(f, k) + 1):\n        dp[n][j] = 1\n\n    # Max possible sum for N(s) is f.\n    # Max possible sum for N(s0) + N(s1) is 2*f.\n    # So `W_prime` array size should be `2*f + 1`.\n    \n    # Precompute prefix sums for dp[n]\n    prefix_dp_n = [0] * (f + 2)\n    for j in range(f + 1):\n        prefix_dp_n[j+1] = (prefix_dp_n[j] + dp[n][j]) % MOD\n\n    for i in range(n - 1, 0, -1):\n        # W_prime_i_plus_1 = convolution(dp[i+1], dp[i+1])\n        # The length of dp[i+1] is f+1.\n        # The length of W_prime_i_plus_1 will be 2*(f+1) - 1 = 2f + 1.\n        # We only need values up to f for W_prime_i_plus_1[j] if j is used in (k-j)*W_prime_i_plus_1[j]\n        # But we need up to 2f for prefix sums.\n        \n        current_dp_len = f + 1\n        \n        # We need to compute convolution up to index 2*f.\n        # The length of the result array from multiply will be up to 2*f + 1.\n        # So pad dp[i+1] to `f+1` elements.\n        W_prime_i_plus_1 = multiply(dp[i+1], dp[i+1])\n        \n        # W_prime_i_plus_1 might be longer than 2*f+1. Truncate it to max_val + 1.\n        max_val_for_sum_children = min(2 * f, len(W_prime_i_plus_1) - 1)\n        \n        # Calculate prefix sums for W_prime_i_plus_1\n        P_i_plus_1 = [0] * (max_val_for_sum_children + 2)\n        for j in range(max_val_for_sum_children + 1):\n            P_i_plus_1[j+1] = (P_i_plus_1[j] + W_prime_i_plus_1[j]) % MOD\n\n        for j in range(f + 1): # j is the target N(s)\n            term1 = 0\n            if j <= max_val_for_sum_children: # sum_children >= j\n                term1 = (P_i_plus_1[max_val_for_sum_children + 1] - P_i_plus_1[j] + MOD) % MOD\n            else: # If j is greater than max possible sum_children, then sum_children >= j is impossible.\n                term1 = 0 # This case means N(s) can't be j if c_s=j and sum_children >= j is impossible.\n\n            term2 = 0\n            if j <= k: # c_s > j\n                if j <= max_val_for_sum_children:\n                    term2 = (k - j) * W_prime_i_plus_1[j] % MOD\n            \n            dp[i][j] = (term1 + term2) % MOD\n\n    print(dp[1][f])\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "MOD = 998244353\n\ndef solve():\n    n, k, f = map(int, input().split())\n\n    dp_ways = [[0] * (k + 1) for _ in range(n + 1)]\n    dp_sum = [[0] * (k + 1) for _ in range(n + 1)]\n\n    # Base case: length n\n    # For strings of length n, c_s is the count for that specific string.\n    # The sum of c_s for all strings of length n is the total size.\n    # dp_ways[n][s] = number of ways to choose c_s for strings of length n\n    #                 such that their sum is s.\n    # dp_sum[n][s] = sum of (ways * s) for s.\n\n    # For length n, there are 2^n strings.\n    # Each c_s can be from 0 to k.\n    # This is equivalent to distributing s items into 2^n bins, where each bin has capacity k.\n    # Or, choosing 2^n numbers (c_s) from 0 to k that sum to s.\n    # This is (s + 2^n - 1) choose (2^n - 1) without upper bound,\n    # and then using inclusion-exclusion for upper bound k.\n    # However, k can be large, and 2^n can be large (up to 2^15).\n    # The problem statement says \"maximum possible size of a beautiful multiset is exactly f\".\n    # Let's re-evaluate what the maximum size is.\n\n    # Maximum size of a beautiful multiset:\n    # For any string s of length < n, let P(s) be the set of strings in the multiset that have s as a prefix.\n    # The condition is |P(s)| <= c_s.\n    # For a string s of length n, P(s) is just the count of s in the multiset.\n    #\n    # The maximum size of a beautiful multiset is determined by the minimum of c_s for prefixes.\n    # Let M(s) be the maximum number of strings in a beautiful multiset that have s as a prefix.\n    # If s has length n, M(s) = c_s.\n    # If s has length < n, M(s) = min(c_s, M(s0) + M(s1)).\n    # The total size of the multiset is M(\"\"), where \"\" is the empty string (root of the trie).\n    # M(\"\") = M(\"0\") + M(\"1\").\n    # The problem asks for the number of ways to choose c_s such that M(\"\") = f.\n\n    # Let's define dp[len][val] as the number of ways to choose c_s for all strings of length `len` to `n`\n    # (that are extensions of some fixed prefix of length `len-1`) such that the total maximum size\n    # for this subtree is `val`.\n    # This is still not quite right. The `c_s` values for prefixes depend on children.\n\n    # Let's re-read: \"the number of strings in the multiset such that s is their prefix is not exceeding c_s\".\n    # The maximum possible size of a beautiful multiset is determined by the `c_s` values.\n    # For any node `u` in the trie (representing string `s`), let `N(u)` be the number of strings in the multiset\n    # that have `s` as a prefix.\n    # We must have `N(u) <= c_s`.\n    # If `s` has length `n`, `N(u)` is the count of string `s` in the multiset.\n    # If `s` has length `< n`, `N(u) = N(u_0) + N(u_1)`, where `u_0` is `s0` and `u_1` is `s1`.\n    #\n    # To maximize the total size, we want to maximize `N(\"\")`.\n    # `N(\"\") = N(\"0\") + N(\"1\")`.\n    # `N(\"s\") = min(c_s, N(\"s0\") + N(\"s1\"))` for `len(s) < n`.\n    # `N(\"s\") = c_s` for `len(s) = n`.\n    #\n    # Let `dp[i][j]` be the number of ways to choose `c_s` for all strings `s` of length `i` to `n`\n    # that are descendants of a fixed string of length `i-1`, such that the maximum possible\n    # contribution from this subtree (i.e., `N(s_parent)`) is `j`.\n    #\n    # Base case: `i = n`.\n    # For each string `s` of length `n`, we choose `c_s`.\n    # The maximum contribution from this string is `c_s`.\n    # We are considering *one* string `s` of length `n`.\n    # The value `j` is `c_s`.\n    # There is 1 way to choose `c_s` such that `N(s) = c_s`.\n    # So `dp[n][j] = 1` for `0 <= j <= k`.\n    # This counts choices for *one* leaf node.\n    # There are `2^n` leaf nodes.\n    # For `i=n`, we are considering the values `c_s` for all `2^n` strings of length `n`.\n    # The total sum of `c_s` for these `2^n` strings will be the total size.\n    # Let `dp_n[s]` be the number of ways to choose `c_s` for all `2^n` strings of length `n`\n    # such that their sum is `s`.\n    # This is a stars and bars problem: `s` items into `2^n` bins, each bin capacity `k`.\n    # This is `(s + 2^n - 1) choose (2^n - 1)` without capacity constraint.\n    # `2^n` can be up to `2^15 = 32768`. `k` up to `2e5`. `f` up to `2e5`.\n    # The sum `s` can be up to `2^n * k`.\n    # `f` is the total size, so `s` can be up to `f`.\n    # `dp_n[s]` for `s` from `0` to `f`.\n    #\n    # Let `ways[count][current_sum]` be the number of ways to choose `count` values `c_s`\n    # (each from `0` to `k`) that sum up to `current_sum`.\n    # `ways[1][j] = 1` for `0 <= j <= k`.\n    # For `c = 2` to `2^n`:\n    # `ways[c][s] = sum(ways[c-1][s - j])` for `0 <= j <= k`.\n    # This is `ways[c][s] = sum_{j=0 to k} ways[c-1][s-j]`.\n    # This can be computed efficiently using prefix sums: `ways[c][s] = prefix_sum[c-1][s] - prefix_sum[c-1][s-k-1]`.\n    # Let `dp_last_level[s]` be `ways[2^n][s]`.\n    # `dp_last_level` will be the base for our DP.\n    #\n    # `dp[i][j]` = number of ways to choose `c_s` for all strings `s` of length `i` to `n`\n    #              (descendants of a fixed string of length `i-1`)\n    #              such that `min(c_s_parent, N(s0) + N(s1))` is `j`.\n    # This is still wrong. The problem is that `c_s` values are chosen *first*, then `f` is determined.\n    # We need to count ways to choose `c_s` for all strings `s` (length 1 to n)\n    # such that `max_size = f`.\n\n    # Let `g[len][val]` be the number of ways to choose `c_s` for all strings `s` of length `len` to `n`\n    # that are descendants of a fixed string of length `len-1`, such that the *maximum possible value*\n    # for `N(s_parent)` (which is `min(c_s_parent, N(s0) + N(s1))`) is `val`.\n    # This `val` is the effective capacity for the parent.\n    #\n    # Let `dp[i][j]` be the number of ways to assign `c_s` values for all strings `s` of length `i` to `n`\n    # that are extensions of a particular string of length `i-1`, such that the maximum possible\n    # number of strings in a beautiful multiset with this prefix is `j`.\n    #\n    # For `i = n`: There is one string `s` of length `n`. We choose `c_s`.\n    # The maximum possible count for this string is `c_s`.\n    # So, `dp[n][j]` is the number of ways to choose `c_s` for *this specific string* such that its max count is `j`.\n    # This is 1 way (choose `c_s = j`).\n    # `dp[n][j] = 1` for `0 <= j <= k`.\n    #\n    # For `i < n`: Consider a string `s` of length `i-1`. Its children are `s0` and `s1`.\n    # We need to choose `c_s`, `c_{s0}`, `c_{s1}`, ..., `c_{leaf_nodes}`.\n    # The maximum count for `s` is `min(c_s, N(s0) + N(s1))`.\n    # `N(s0)` is the max count for `s0`'s subtree, `N(s1)` for `s1`'s subtree.\n    #\n    # Let `dp[i][j]` be the number of ways to choose `c_x` for all strings `x` of length `i` to `n`\n    # that are descendants of a fixed string `s` of length `i-1`, such that `N(s0) + N(s1)` (the sum of max counts\n    # from its children's subtrees) is `j`.\n    #\n    # Let `ways_subtree[i][j]` be the number of ways to choose `c_x` for all strings `x` of length `i` to `n`\n    # that are descendants of a fixed string `s` of length `i-1`, such that the sum of maximum counts\n    # from its children `s0` and `s1` (i.e., `N(s0) + N(s1)`) is `j`.\n    #\n    # Base case: `i = n`.\n    # For a string `s` of length `n-1`, its children are `s0` and `s1`, both of length `n`.\n    # `N(s0) = c_{s0}` and `N(s1) = c_{s1}`.\n    # We need to choose `c_{s0}` and `c_{s1}`.\n    # `ways_subtree[n][j]` is the number of ways to choose `c_{s0}` and `c_{s1}` such that `c_{s0} + c_{s1} = j`.\n    # Each `c_x` is from `0` to `k`.\n    # This is `j+1` ways if `j <= k`, `k - (j-k) + 1 = 2k - j + 1` if `k < j <= 2k`.\n    # Let `dp[j]` be the number of ways to pick two integers `a, b` s.t. `0 <= a, b <= k` and `a+b=j`.\n    # `dp[j] = j+1` for `0 <= j <= k`.\n    # `dp[j] = k - (j-k) + 1 = 2k - j + 1` for `k < j <= 2k`.\n    # `dp[j] = 0` otherwise.\n    # This `dp` array will be `ways_subtree[n]`.\n    # Let `S_n[j]` be this array.\n    #\n    # Now for `i` from `n-1` down to `1`:\n    # `ways_subtree[i][j]` is the number of ways to choose `c_x` for descendants of `s0` and `s1` (of length `i`)\n    # such that `N(s0) + N(s1) = j`.\n    # `N(s0)` is determined by `min(c_{s0}, N(s00) + N(s01))`.\n    # `N(s1)` is determined by `min(c_{s1}, N(s10) + N(s11))`.\n    #\n    # Let `dp_current_level[j]` be the number of ways to choose `c_x` for descendants of a string `s` of length `i`\n    # such that `N(s) = j`.\n    #\n    # `dp_current_level[j]` depends on `ways_subtree[i+1][sum_children]`.\n    # For a fixed string `s` of length `i`, we need to choose `c_s` from `0` to `k`.\n    # And we need to choose `c_x` for its descendants `s0` and `s1`.\n    # Let `sum_children = N(s0) + N(s1)`.\n    # The number of ways to get `sum_children` is `ways_subtree[i+1][sum_children] * ways_subtree[i+1][sum_children]`.\n    # No, this is wrong. It's `conv(ways_subtree[i+1], ways_subtree[i+1])`.\n    # Let `W_{i+1}` be `ways_subtree[i+1]`.\n    # Let `W'_{i+1} = W_{i+1} * W_{i+1}` (convolution).\n    # `W'_{i+1}[j]` = number of ways to choose `c_x` for descendants of `s0` and `s1`\n    #                  such that `N(s0) + N(s1) = j`.\n    #\n    # Now, for a fixed string `s` of length `i`, we choose `c_s` from `0` to `k`.\n    # And we have `W'_{i+1}[sum_children]` ways to choose `c_x` for descendants of `s0` and `s1`\n    # such that `N(s0) + N(s1) = sum_children`.\n    # The actual `N(s)` will be `min(c_s, sum_children)`.\n    #\n    # So `dp_val_for_one_node[i][j]` = number of ways to choose `c_s` for *one* string `s` of length `i`\n    #                                  and its descendants such that `N(s) = j`.\n    # `dp_val_for_one_node[i][j] = sum_{c_s=0 to k} sum_{sum_children=0 to MAX_SUM} [min(c_s, sum_children) == j] * W'_{i+1}[sum_children]`\n    #\n    # Let `P_{i+1}[val]` be the prefix sum of `W'_{i+1}`.\n    # `P_{i+1}[val] = sum_{x=0 to val} W'_{i+1}[x]`.\n    #\n    # `dp_val_for_one_node[i][j]`\n    # `j = min(c_s, sum_children)`\n    #\n    # Case 1: `c_s = j`. Then `sum_children >= j`.\n    # Sum over `sum_children` from `j` to `MAX_SUM`: `W'_{i+1}[sum_children]`.\n    # This is `P_{i+1}[MAX_SUM] - P_{i+1}[j-1]`.\n    #\n    # Case 2: `sum_children = j`. Then `c_s > j`.\n    # Sum over `c_s` from `j+1` to `k`: `1` (for each `c_s`).\n    # This is `k - (j+1) + 1 = k - j`.\n    # So, `(k-j) * W'_{i+1}[j]`.\n    #\n    # Combining:\n    # `dp_val_for_one_node[i][j] = (P_{i+1}[MAX_SUM] - P_{i+1}[j-1] + MOD) % MOD` (for `c_s = j`)\n    #                            `+ (k-j) * W'_{i+1}[j] % MOD` (for `sum_children = j`)\n    # This is for `0 <= j <= k`. If `j > k`, `c_s` cannot be `j`, so `dp_val_for_one_node[i][j] = 0`.\n    # The `P_{i+1}[MAX_SUM]` part is the total number of ways to choose `c_x` for descendants.\n    #\n    # `dp_val_for_one_node[i][j]` calculation:\n    # `term1 = (P_{i+1}[MAX_SUM] - (P_{i+1}[j-1] if j > 0 else 0) + MOD) % MOD`\n    # `term2 = (k - j) * W'_{i+1}[j] % MOD` if `j <= k` else `0`\n    # `dp_val_for_one_node[i][j] = (term1 + term2) % MOD`\n    #\n    # This `dp_val_for_one_node[i]` array becomes `ways_subtree[i]`.\n    #\n    # Max possible sum `f` is `2e5`. `k` is `2e5`.\n    # The maximum value for `j` (total count) is `f`.\n    # The maximum value for `sum_children` is `f`.\n    # So arrays should be of size `f+1`.\n    #\n    # Let `dp[i]` be the array `dp_val_for_one_node[i]`.\n    # `dp[n]` is special. For a string `s` of length `n`, `N(s) = c_s`.\n    # `dp[n][j] = 1` for `0 <= j <= k`.\n    # `dp[n][j] = 0` for `j > k`.\n    #\n    # Iteration:\n    # `dp[n]` is initialized as above.\n    # `MAX_SUM_CHILDREN = 2 * f` (since `N(s0)` and `N(s1)` can be up to `f`).\n    #\n    # For `i = n-1` down to `1`:\n    #   `W_prime_i_plus_1 = convolution(dp[i+1], dp[i+1])`\n    #   `P_i_plus_1 = prefix_sums(W_prime_i_plus_1)`\n    #   For `j = 0` to `f`:\n    #     `term1 = (P_i_plus_1[f] - (P_i_plus_1[j-1] if j > 0 else 0) + MOD) % MOD`\n    #     `term2 = 0`\n    #     If `j <= k`:\n    #       `term2 = (k - j) * W_prime_i_plus_1[j] % MOD`\n    #     `dp[i][j] = (term1 + term2) % MOD`\n    #\n    # The final answer is `dp[1][f]`.\n    #\n    # Convolution: `C[s] = sum_{x=0 to s} A[x] * B[s-x]`.\n    # Max `f` is `2e5`. Convolution of two arrays of size `f+1` takes `O(f^2)`.\n    # `n` is up to `15`. `O(n * f^2)` is too slow. `15 * (2e5)^2 = 15 * 4e10`.\n    #\n    # Convolution can be done using NTT (Number Theoretic Transform) in `O(f log f)`.\n    # Total `O(n * f log f)`. `15 * 2e5 * log(2e5) = 15 * 2e5 * 18 = 5.4e7`. This is feasible.\n\n    # NTT setup\n    # MOD = 998244353 is a prime, and 998244353 = 119 * 2^23 + 1.\n    # Primitive root g = 3.\n\n    def ntt(a, invert):\n        n = len(a)\n        j = 0\n        for i in range(1, n):\n            if i < j:\n                a[i], a[j] = a[j], a[i]\n            k = n // 2\n            while j >= k:\n                j -= k\n                k //= 2\n            j += k\n\n        root = pow(3, (MOD - 1) // n, MOD)\n        if invert:\n            root = pow(root, MOD - 2, MOD)\n\n        for length in range(2, n + 1, 2):\n            for i in range(0, n, length):\n                w = 1\n                for j in range(length // 2):\n                    u = a[i + j]\n                    v = a[i + j + length // 2] * w % MOD\n                    a[i + j] = (u + v) % MOD\n                    a[i + j + length // 2] = (u - v + MOD) % MOD\n                    w = w * root % MOD\n\n        if invert:\n            n_inv = pow(n, MOD - 2, MOD)\n            for i in range(n):\n                a[i] = a[i] * n_inv % MOD\n        return a\n\n    def multiply(a, b):\n        len_a = len(a)\n        len_b = len(b)\n        res_len = len_a + len_b - 1\n        \n        # Find smallest power of 2 greater than or equal to res_len\n        ntt_len = 1\n        while ntt_len < res_len:\n            ntt_len <<= 1\n        \n        a_padded = list(a) + [0] * (ntt_len - len_a)\n        b_padded = list(b) + [0] * (ntt_len - len_b)\n\n        a_fft = ntt(a_padded, False)\n        b_fft = ntt(b_padded, False)\n\n        c_fft = [a_fft[i] * b_fft[i] % MOD for i in range(ntt_len)]\n        \n        c = ntt(c_fft, True)\n        \n        return c[:res_len]\n\n    # Initialize dp[n]\n    # dp[n][j] = 1 for 0 <= j <= k, 0 otherwise\n    dp = [[0] * (f + 1) for _ in range(n + 1)]\n\n    for j in range(min(f, k) + 1):\n        dp[n][j] = 1\n\n    # Max possible sum for N(s) is f.\n    # Max possible sum for N(s0) + N(s1) is 2*f.\n    # So `W_prime` array size should be `2*f + 1`.\n    \n    # Precompute prefix sums for dp[n]\n    prefix_dp_n = [0] * (f + 2)\n    for j in range(f + 1):\n        prefix_dp_n[j+1] = (prefix_dp_n[j] + dp[n][j]) % MOD\n\n    for i in range(n - 1, 0, -1):\n        # W_prime_i_plus_1 = convolution(dp[i+1], dp[i+1])\n        # The length of dp[i+1] is f+1.\n        # The length of W_prime_i_plus_1 will be 2*(f+1) - 1 = 2f + 1.\n        # We only need values up to f for W_prime_i_plus_1[j] if j is used in (k-j)*W_prime_i_plus_1[j]\n        # But we need up to 2f for prefix sums.\n        \n        current_dp_len = f + 1\n        \n        # We need to compute convolution up to index 2*f.\n        # The length of the result array from multiply will be up to 2*f + 1.\n        # So pad dp[i+1] to `f+1` elements.\n        W_prime_i_plus_1 = multiply(dp[i+1], dp[i+1])\n        \n        # W_prime_i_plus_1 might be longer than 2*f+1. Truncate it to max_val + 1.\n        max_val_for_sum_children = min(2 * f, len(W_prime_i_plus_1) - 1)\n        \n        # Calculate prefix sums for W_prime_i_plus_1\n        P_i_plus_1 = [0] * (max_val_for_sum_children + 2)\n        for j in range(max_val_for_sum_children + 1):\n            P_i_plus_1[j+1] = (P_i_plus_1[j] + W_prime_i_plus_1[j]) % MOD\n\n        for j in range(f + 1): # j is the target N(s)\n            term1 = 0\n            if j <= max_val_for_sum_children: # sum_children >= j\n                term1 = (P_i_plus_1[max_val_for_sum_children + 1] - P_i_plus_1[j] + MOD) % MOD\n            else: # If j is greater than max possible sum_children, then sum_children >= j is impossible.\n                term1 = 0 # This case means N(s) can't be j if c_s=j and sum_children >= j is impossible.\n\n            term2 = 0\n            if j <= k: # c_s > j\n                if j <= max_val_for_sum_children:\n                    term2 = (k - j) * W_prime_i_plus_1[j] % MOD\n            \n            dp[i][j] = (term1 + term2) % MOD\n\n    print(dp[1][f])\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 1033,
        "completion_token_count": 6489,
        "thoughts_token_count": 0
    }
}