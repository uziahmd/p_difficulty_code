{
    "start": 1758011282.8246474,
    "end": 1758011307.621757,
    "start-formatted": "2025-09-16 17:28 KST",
    "end-formatted": "2025-09-16 17:28 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "",
    "response": "```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    vouchers = []\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        vouchers.append((l, r, cost))\n\n    vouchers.sort()\n\n    # Max possible coordinate for l or r is 2 * 10^5\n    MAX_COORD = 2 * 10**5\n\n    # dp[duration][end_day] stores the minimum cost of a voucher with given duration ending on end_day\n    # We don't need end_day in the DP state, we just need to know the minimum cost for a given duration\n    # that ends by a certain day.\n    # Instead, let's use a list of lists, where each inner list stores vouchers for a specific start day.\n    # Or, group vouchers by their duration.\n\n    # Option 1: Iterate through all possible start/end days\n    # For each day `d`, we want to find the minimum cost of a voucher that ends on `d`\n    # and has a specific duration `dur`.\n    # Let's use `min_cost_ending_at[end_day][duration]` to store the minimum cost\n    # of a voucher that ends at `end_day` and has a duration `duration`.\n    # This is too large. `MAX_COORD * MAX_COORD`\n\n    # Let's try another approach.\n    # Store vouchers grouped by their duration.\n    # `vouchers_by_duration[duration]` will be a list of (start_day, end_day, cost) for that duration.\n    # This still requires iterating over `x` for `x` durations.\n\n    # The problem asks for two non-intersecting vouchers.\n    # Condition: ri < lj or rj < li.\n    # This means one voucher must entirely precede the other.\n\n    # Let's iterate through all possible vouchers `v1`.\n    # For each `v1 = (l1, r1, cost1)`, its duration is `d1 = r1 - l1 + 1`.\n    # We need to find `v2 = (l2, r2, cost2)` such that:\n    # 1. `d2 = r2 - l2 + 1 = x - d1`\n    # 2. `r1 < l2` or `r2 < l1`\n    # 3. `cost1 + cost2` is minimized.\n\n    # The condition `r2 < l1` is symmetric to `r1 < l2`.\n    # Let's assume `r1 < l2` (voucher 1 precedes voucher 2).\n    # Then we need to find a voucher `v2` such that `l2 > r1` and `r2 - l2 + 1 = x - d1`.\n    # To minimize `cost2`, we need to efficiently query for the minimum cost voucher\n    # with a specific duration `d2` that starts after `r1`.\n\n    # Let's precompute minimum costs.\n    # `min_cost_for_duration_ending_by[duration][end_day]`\n    # This is still too large.\n\n    # What if we iterate through all possible split points?\n    # No, that's not how it works.\n\n    # Let's process vouchers sorted by their start day.\n    # When considering a voucher `(l, r, cost)`, its duration is `d = r - l + 1`.\n    # We are looking for another voucher with duration `x - d`.\n    #\n    # We need to find a voucher `(l', r', cost')` such that:\n    # 1. `r' - l' + 1 == x - d`\n    # 2. `r < l'` (this voucher starts after the current one ends)\n    # 3. `cost + cost'` is minimized.\n    # OR\n    # 1. `r' - l' + 1 == x - d`\n    # 2. `r' < l` (this voucher ends before the current one starts)\n    # 3. `cost + cost'` is minimized.\n\n    # Let's maintain `min_cost_for_duration_ending_at_or_before[duration][day]`\n    # This still seems too large.\n    # `min_cost_for_duration_ending_at_or_before[duration][day]` can be a segment tree or similar.\n\n    # Let `min_cost_for_duration[duration]` be a data structure that stores minimum costs\n    # for vouchers of that duration, indexed by their start or end day.\n    # For example, `min_cost_for_duration[duration]` could be a dictionary mapping `start_day` to `min_cost`.\n    # Or, it could be a list of `(start_day, cost)` pairs, sorted by `start_day`.\n\n    # The maximum `r` is `MAX_COORD`.\n    # The maximum `duration` is `MAX_COORD`.\n\n    # Let's create `vouchers_by_start_day[start_day]` which is a list of `(end_day, cost)` for vouchers starting on `start_day`.\n    # And `vouchers_by_end_day[end_day]` which is a list of `(start_day, cost)` for vouchers ending on `end_day`.\n    # This is not helpful for duration.\n\n    # Let's consider the problem with a sweep-line approach or by iterating through all possible end days.\n    # For each possible `end_day` from 1 to `MAX_COORD`:\n    # 1. Process all vouchers that end on `end_day`.\n    #    For each such voucher `(l, r, cost)` where `r = end_day`:\n    #    Its duration is `d = r - l + 1`.\n    #    We are looking for a voucher `v_prev = (l_prev, r_prev, cost_prev)` such that:\n    #    `r_prev < l` and `r_prev - l_prev + 1 == x - d`.\n    #    We need to find the minimum `cost_prev` among such vouchers.\n    #    To do this efficiently, we need a data structure that, for a given duration `d_prev`,\n    #    can query for the minimum cost of a voucher with `d_prev` that ends before `l`.\n    #\n    # 2. Update a data structure with vouchers that start on `end_day + 1`.\n    #    This is not right.\n\n    # Let's maintain an array `min_cost_for_duration[duration]` which stores the minimum cost\n    # of a voucher with that duration that has been processed so far (i.e., its `r` is less than the current `l` we are considering).\n    # This is also not quite right because we need to consider `r < l'` or `r' < l`.\n\n    # Let's process vouchers by their `r` values.\n    # Group vouchers by their end day `r`.\n    # `vouchers_at_end_day[r]` will be a list of `(l, cost)` for vouchers ending on day `r`.\n    # Iterate `current_day` from 1 to `MAX_COORD`.\n    # `min_cost_for_duration_ending_before_current_day[duration]`\n    # This array will store the minimum cost of a voucher with `duration` that ends strictly before `current_day`.\n    # `min_cost_for_duration_ending_before_current_day` should be initialized to infinity.\n\n    # `min_cost_for_duration_ending_before_current_day[duration]` will store the minimum cost\n    # of a voucher with `duration` that ends at `current_day - 1` or earlier.\n    # When we are at `current_day`:\n    # 1. For each voucher `(l, r, cost)` that starts at `current_day`:\n    #    Duration `d = r - l + 1`.\n    #    We need to find a voucher `v_prev` with duration `d_prev = x - d` such that `r_prev < l`.\n    #    The `min_cost_for_duration_ending_before_current_day[d_prev]` would give us the minimum cost\n    #    of such a voucher.\n    #    So, `ans = min(ans, cost + min_cost_for_duration_ending_before_current_day[x - d])`.\n    #\n    # 2. For each voucher `(l, r, cost)` that ends at `current_day`:\n    #    Duration `d = r - l + 1`.\n    #    We update `min_cost_for_duration_ending_before_current_day[d]`\n    #    with `min(min_cost_for_duration_ending_before_current_day[d], cost)`.\n    #    This update should actually happen for `current_day + 1`.\n\n    # This suggests two passes or careful indexing.\n\n    # Let's use an array `min_cost_for_duration_ending_at_or_before_day[duration]`\n    # This array will be updated as we sweep through days.\n    # `min_cost_for_duration_ending_at_or_before_day[d]` stores the minimum cost of a voucher\n    # with duration `d` that ends *up to the current day*.\n\n    # Let's rephrase:\n    # `min_cost_prev[duration]` stores the minimum cost of a voucher with given `duration`\n    # that has already finished.\n    # `min_cost_prev[duration]` will be updated as we iterate through days.\n\n    # Create a list of vouchers grouped by their start day.\n    # `start_events[day]` will be a list of `(r, cost)` for vouchers starting on `day`.\n    # Create a list of vouchers grouped by their end day.\n    # `end_events[day]` will be a list of `(l, cost)` for vouchers ending on `day`.\n\n    start_events = [[] for _ in range(MAX_COORD + 1)]\n    end_events = [[] for _ in range(MAX_COORD + 1)]\n\n    for l, r, cost in vouchers:\n        start_events[l].append((r, cost))\n        end_events[r].append((l, cost))\n\n    min_total_cost = float('inf')\n\n    # `min_cost_for_duration[duration]` stores the minimum cost of a voucher\n    # with `duration` that has *already ended*.\n    # Initialize with infinity.\n    min_cost_for_duration = [float('inf')] * (MAX_COORD + 1)\n\n    # Iterate through each day `d` from 1 to MAX_COORD\n    for current_day in range(1, MAX_COORD + 1):\n        # 1. Process vouchers that *start* on `current_day`.\n        # For each such voucher `(current_day, r, cost)`:\n        # Its duration is `d1 = r - current_day + 1`.\n        # We need to find a previous voucher `v_prev` with duration `d2 = x - d1`\n        # such that `v_prev` ends strictly before `current_day`.\n        # The `min_cost_for_duration[d2]` stores the minimum cost of such a voucher.\n        # If `d1 >= x` (current voucher alone is too long or exactly `x`), `x - d1` will be non-positive.\n        # If `x - d1 <= 0`, then it's impossible to combine.\n        # Also, `d1` must be less than `x` for `x - d1` to be positive.\n        # If `d1 >= x`, then `d2 <= 0`.\n        # If `d1 < x`, then `d2 = x - d1` is a valid positive duration.\n        for r_curr, cost_curr in start_events[current_day]:\n            d1 = r_curr - current_day + 1\n            d2 = x - d1\n            if d2 > 0 and d2 <= MAX_COORD: # Ensure d2 is a valid duration\n                if min_cost_for_duration[d2] != float('inf'):\n                    min_total_cost = min(min_total_cost, cost_curr + min_cost_for_duration[d2])\n\n        # 2. Process vouchers that *end* on `current_day`.\n        # For each such voucher `(l, current_day, cost)`:\n        # Its duration is `d = current_day - l + 1`.\n        # We update `min_cost_for_duration[d]` with `cost`.\n        # This update ensures that for future `current_day'` where `current_day' > current_day`,\n        # `min_cost_for_duration[d]` will reflect the minimum cost of a voucher\n        # with duration `d` that ended at `current_day` or earlier.\n        for l_curr, cost_curr in end_events[current_day]:\n            d = current_day - l_curr + 1\n            min_cost_for_duration[d] = min(min_cost_for_duration[d], cost_curr)\n\n    if min_total_cost == float('inf'):\n        print(-1)\n    else:\n        print(min_total_cost)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    vouchers = []\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        vouchers.append((l, r, cost))\n\n    vouchers.sort()\n\n    # Max possible coordinate for l or r is 2 * 10^5\n    MAX_COORD = 2 * 10**5\n\n    # dp[duration][end_day] stores the minimum cost of a voucher with given duration ending on end_day\n    # We don't need end_day in the DP state, we just need to know the minimum cost for a given duration\n    # that ends by a certain day.\n    # Instead, let's use a list of lists, where each inner list stores vouchers for a specific start day.\n    # Or, group vouchers by their duration.\n\n    # Option 1: Iterate through all possible start/end days\n    # For each day `d`, we want to find the minimum cost of a voucher that ends on `d`\n    # and has a specific duration `dur`.\n    # Let's use `min_cost_ending_at[end_day][duration]` to store the minimum cost\n    # of a voucher that ends at `end_day` and has a duration `duration`.\n    # This is too large. `MAX_COORD * MAX_COORD`\n\n    # Let's try another approach.\n    # Store vouchers grouped by their duration.\n    # `vouchers_by_duration[duration]` will be a list of (start_day, end_day, cost) for that duration.\n    # This still requires iterating over `x` for `x` durations.\n\n    # The problem asks for two non-intersecting vouchers.\n    # Condition: ri < lj or rj < li.\n    # This means one voucher must entirely precede the other.\n\n    # Let's iterate through all possible vouchers `v1`.\n    # For each `v1 = (l1, r1, cost1)`, its duration is `d1 = r1 - l1 + 1`.\n    # We need to find `v2 = (l2, r2, cost2)` such that:\n    # 1. `d2 = r2 - l2 + 1 = x - d1`\n    # 2. `r1 < l2` or `r2 < l1`\n    # 3. `cost1 + cost2` is minimized.\n\n    # The condition `r2 < l1` is symmetric to `r1 < l2`.\n    # Let's assume `r1 < l2` (voucher 1 precedes voucher 2).\n    # Then we need to find a voucher `v2` such that `l2 > r1` and `r2 - l2 + 1 = x - d1`.\n    # To minimize `cost2`, we need to efficiently query for the minimum cost voucher\n    # with a specific duration `d2` that starts after `r1`.\n\n    # Let's precompute minimum costs.\n    # `min_cost_for_duration_ending_by[duration][end_day]`\n    # This is still too large.\n\n    # What if we iterate through all possible split points?\n    # No, that's not how it works.\n\n    # Let's process vouchers sorted by their start day.\n    # When considering a voucher `(l, r, cost)`, its duration is `d = r - l + 1`.\n    # We are looking for another voucher with duration `x - d`.\n    #\n    # We need to find a voucher `(l', r', cost')` such that:\n    # 1. `r' - l' + 1 == x - d`\n    # 2. `r < l'` (this voucher starts after the current one ends)\n    # 3. `cost + cost'` is minimized.\n    # OR\n    # 1. `r' - l' + 1 == x - d`\n    # 2. `r' < l` (this voucher ends before the current one starts)\n    # 3. `cost + cost'` is minimized.\n\n    # Let's maintain `min_cost_for_duration_ending_at_or_before[duration][day]`\n    # This still seems too large.\n    # `min_cost_for_duration_ending_at_or_before[duration][day]` can be a segment tree or similar.\n\n    # Let `min_cost_for_duration[duration]` be a data structure that stores minimum costs\n    # for vouchers of that duration, indexed by their start or end day.\n    # For example, `min_cost_for_duration[duration]` could be a dictionary mapping `start_day` to `min_cost`.\n    # Or, it could be a list of `(start_day, cost)` pairs, sorted by `start_day`.\n\n    # The maximum `r` is `MAX_COORD`.\n    # The maximum `duration` is `MAX_COORD`.\n\n    # Let's create `vouchers_by_start_day[start_day]` which is a list of `(end_day, cost)` for vouchers starting on `start_day`.\n    # And `vouchers_by_end_day[end_day]` which is a list of `(start_day, cost)` for vouchers ending on `end_day`.\n    # This is not helpful for duration.\n\n    # Let's consider the problem with a sweep-line approach or by iterating through all possible end days.\n    # For each possible `end_day` from 1 to `MAX_COORD`:\n    # 1. Process all vouchers that end on `end_day`.\n    #    For each such voucher `(l, r, cost)` where `r = end_day`:\n    #    Its duration is `d = r - l + 1`.\n    #    We are looking for a voucher `v_prev = (l_prev, r_prev, cost_prev)` such that:\n    #    `r_prev < l` and `r_prev - l_prev + 1 == x - d`.\n    #    We need to find the minimum `cost_prev` among such vouchers.\n    #    To do this efficiently, we need a data structure that, for a given duration `d_prev`,\n    #    can query for the minimum cost of a voucher with `d_prev` that ends before `l`.\n    #\n    # 2. Update a data structure with vouchers that start on `end_day + 1`.\n    #    This is not right.\n\n    # Let's maintain an array `min_cost_for_duration[duration]` which stores the minimum cost\n    # of a voucher with that duration that has been processed so far (i.e., its `r` is less than the current `l` we are considering).\n    # This is also not quite right because we need to consider `r < l'` or `r' < l`.\n\n    # Let's process vouchers by their `r` values.\n    # Group vouchers by their end day `r`.\n    # `vouchers_at_end_day[r]` will be a list of `(l, cost)` for vouchers ending on day `r`.\n    # Iterate `current_day` from 1 to `MAX_COORD`.\n    # `min_cost_for_duration_ending_before_current_day[duration]`\n    # This array will store the minimum cost of a voucher with `duration` that ends strictly before `current_day`.\n    # `min_cost_for_duration_ending_before_current_day` should be initialized to infinity.\n\n    # `min_cost_for_duration_ending_before_current_day[duration]` will store the minimum cost\n    # of a voucher with `duration` that ends at `current_day - 1` or earlier.\n    # When we are at `current_day`:\n    # 1. For each voucher `(l, r, cost)` that starts at `current_day`:\n    #    Duration `d = r - l + 1`.\n    #    We need to find a voucher `v_prev` with duration `d_prev = x - d` such that `r_prev < l`.\n    #    The `min_cost_for_duration_ending_before_current_day[d_prev]` would give us the minimum cost\n    #    of such a voucher.\n    #    So, `ans = min(ans, cost + min_cost_for_duration_ending_before_current_day[x - d])`.\n    #\n    # 2. For each voucher `(l, r, cost)` that ends at `current_day`:\n    #    Duration `d = r - l + 1`.\n    #    We update `min_cost_for_duration_ending_before_current_day[d]`\n    #    with `min(min_cost_for_duration_ending_before_current_day[d], cost)`.\n    #    This update should actually happen for `current_day + 1`.\n\n    # This suggests two passes or careful indexing.\n\n    # Let's use an array `min_cost_for_duration_ending_at_or_before_day[duration]`\n    # This array will be updated as we sweep through days.\n    # `min_cost_for_duration_ending_at_or_before_day[d]` stores the minimum cost of a voucher\n    # with duration `d` that ends *up to the current day*.\n\n    # Let's rephrase:\n    # `min_cost_prev[duration]` stores the minimum cost of a voucher with given `duration`\n    # that has already finished.\n    # `min_cost_prev[duration]` will be updated as we iterate through days.\n\n    # Create a list of vouchers grouped by their start day.\n    # `start_events[day]` will be a list of `(r, cost)` for vouchers starting on `day`.\n    # Create a list of vouchers grouped by their end day.\n    # `end_events[day]` will be a list of `(l, cost)` for vouchers ending on `day`.\n\n    start_events = [[] for _ in range(MAX_COORD + 1)]\n    end_events = [[] for _ in range(MAX_COORD + 1)]\n\n    for l, r, cost in vouchers:\n        start_events[l].append((r, cost))\n        end_events[r].append((l, cost))\n\n    min_total_cost = float('inf')\n\n    # `min_cost_for_duration[duration]` stores the minimum cost of a voucher\n    # with `duration` that has *already ended*.\n    # Initialize with infinity.\n    min_cost_for_duration = [float('inf')] * (MAX_COORD + 1)\n\n    # Iterate through each day `d` from 1 to MAX_COORD\n    for current_day in range(1, MAX_COORD + 1):\n        # 1. Process vouchers that *start* on `current_day`.\n        # For each such voucher `(current_day, r, cost)`:\n        # Its duration is `d1 = r - current_day + 1`.\n        # We need to find a previous voucher `v_prev` with duration `d2 = x - d1`\n        # such that `v_prev` ends strictly before `current_day`.\n        # The `min_cost_for_duration[d2]` stores the minimum cost of such a voucher.\n        # If `d1 >= x` (current voucher alone is too long or exactly `x`), `x - d1` will be non-positive.\n        # If `x - d1 <= 0`, then it's impossible to combine.\n        # Also, `d1` must be less than `x` for `x - d1` to be positive.\n        # If `d1 >= x`, then `d2 <= 0`.\n        # If `d1 < x`, then `d2 = x - d1` is a valid positive duration.\n        for r_curr, cost_curr in start_events[current_day]:\n            d1 = r_curr - current_day + 1\n            d2 = x - d1\n            if d2 > 0 and d2 <= MAX_COORD: # Ensure d2 is a valid duration\n                if min_cost_for_duration[d2] != float('inf'):\n                    min_total_cost = min(min_total_cost, cost_curr + min_cost_for_duration[d2])\n\n        # 2. Process vouchers that *end* on `current_day`.\n        # For each such voucher `(l, current_day, cost)`:\n        # Its duration is `d = current_day - l + 1`.\n        # We update `min_cost_for_duration[d]` with `cost`.\n        # This update ensures that for future `current_day'` where `current_day' > current_day`,\n        # `min_cost_for_duration[d]` will reflect the minimum cost of a voucher\n        # with duration `d` that ended at `current_day` or earlier.\n        for l_curr, cost_curr in end_events[current_day]:\n            d = current_day - l_curr + 1\n            min_cost_for_duration[d] = min(min_cost_for_duration[d], cost_curr)\n\n    if min_total_cost == float('inf'):\n        print(-1)\n    else:\n        print(min_total_cost)\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 799,
        "completion_token_count": 3137,
        "thoughts_token_count": 0
    }
}