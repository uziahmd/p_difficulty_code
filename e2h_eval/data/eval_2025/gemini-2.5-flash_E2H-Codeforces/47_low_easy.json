{
    "start": 1758284890.0965796,
    "end": 1758284912.6143434,
    "start-formatted": "2025-09-19 21:28 KST",
    "end-formatted": "2025-09-19 21:28 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "**Breaking Down the Neko Maths Problem**\n\nOkay, so I'm looking at this \"Neko does Maths\" problem, and my immediate goal is a Python script to solve it.  It's about minimizing the least common multiple (LCM) of two numbers, `a` and `b`, when we add a non-negative integer `k` to both.  The core of this has to revolve around finding the optimal `k`.\n\nThe problem boils down to understanding the relationship between LCM and GCD (greatest common divisor).  I know `lcm(x, y) = (x * y) / gcd(x, y)`.  Applying that, `lcm(a+k, b+k) = ((a+k) * (b+k)) / gcd(a+k, b+k)`.  Minimizing the LCM means I want to *maximize* the GCD of `a+k` and `b+k`, while considering how the product `(a+k) * (b+k)` changes with `k`.\n\nNow, I can use a clever trick with GCD properties.  `gcd(x, y) = gcd(x, y-x)`.  Letting `x = a+k` and `y = b+k`,  I get `gcd(a+k, b+k) = gcd(a+k, (b+k) - (a+k)) = gcd(a+k, b-a)`.  This is a game changer!  The GCD has to be a divisor of `b-a`, or the absolute difference.\n\nIf `a` and `b` are the same, things are simple; the difference is zero.  In that scenario, the LCM is just `a+k`, and the minimal LCM would be `a` when `k = 0`.  This is a trivial case to handle.\n\nFor the more general case where `a != b`, let `diff = abs(b-a)`.  The GCD, `d`, must be a divisor of this difference. I can iterate through all the divisors of `diff`.  For each divisor `d`, I need to find the smallest `k` such that `gcd(a+k, b+k) = d`.\n\nIf `d` is a divisor, I can rewrite `a+k = m*d` for some integer `m`.  Solving for `k`, I have `k = m*d - a`. For `k` to be non-negative, I need `m*d` to be at least `a`.  The smallest such `k` comes from the smallest value of `m`, effectively finding the smallest multiple of `d` that is at least `a`.\n\nI can express this directly with modular arithmetic.  `k = (d - (a % d)) % d`. This covers the cases where `a` is already a multiple of `d`, making `k=0`, and the case where `a` isn't a multiple. When I compute the LCM for this `k`, it'll also yield the minimum.\n\nTherefore, for each divisor `d` of `diff`, I'll calculate `k = (d - (a % d)) % d`. Then, calculate the LCM using this `k`. I'll keep track of the smallest LCM encountered. The final smallest LCM value will be the output. This sounds like an efficient way to find the solution.\n",
    "response": "The problem asks us to find the smallest non-negative integer `k` such that `lcm(a+k, b+k)` is minimized.\n\nLet `x = a+k` and `y = b+k`. We want to minimize `lcm(x, y)`.\nWe know that `lcm(x, y) = (x * y) / gcd(x, y)`.\n\nLet `d = gcd(x, y) = gcd(a+k, b+k)`.\nA fundamental property of GCD is `gcd(X, Y) = gcd(X, Y-X)`.\nApplying this, `d = gcd(a+k, (b+k)-(a+k)) = gcd(a+k, b-a)`.\nThis implies that `d` must be a divisor of `b-a`.\n\nLet `diff = abs(b-a)`.\nIf `a = b`, then `diff = 0`. In this case, `gcd(a+k, a+k) = a+k`.\n`lcm(a+k, a+k) = a+k`. To minimize this, we choose the smallest possible `a+k`, which means `k=0`. The `lcm` would be `a`.\n\nIf `a != b`, then `diff > 0`. The possible values for `d` are the divisors of `diff`.\nFor each divisor `d` of `diff`, we want to find the smallest non-negative `k` such that `gcd(a+k, b+k)` is *at least* `d`. Specifically, we want `a+k` to be a multiple of `d`.\nThe smallest non-negative `k` that makes `a+k` a multiple of `d` is:\n`k = (d - (a % d)) % d`.\nLet's call this `k_d`.\nWith this `k_d`, `a+k_d` is a multiple of `d`.\nSince `d` is a divisor of `diff`, and `b+k_d = (a+diff)+k_d = (a+k_d)+diff`, `b+k_d` will also be a multiple of `d`.\nSo, for this `k_d`, `d` divides both `a+k_d` and `b+k_d`. This means `gcd(a+k_d, b+k_d)` is at least `d`.\nThe `lcm` value for this `k_d` would be `((a+k_d) * (b+k_d)) / gcd(a+k_d, b+k_d)`.\nSince `gcd(a+k_d, b+k_d)` must be a divisor of `diff`, and `d` is also a divisor of `diff`, the `gcd` for this `k_d` could be `d` or a multiple of `d`.\n\nWe need to iterate through all divisors `d` of `diff`. For each `d`:\n1. Calculate `k_d = (d - (a % d)) % d`.\n2. Calculate `val_a = a + k_d` and `val_b = b + k_d`.\n3. Calculate `current_lcm = (val_a * val_b) // math.gcd(val_a, val_b)`.\n4. Keep track of the minimum `current_lcm` found so far and the corresponding smallest `k_d`.\n\n**Algorithm:**\n1. Read `a` and `b`.\n2. Initialize `min_lcm` to infinity and `best_k` to 0.\n3. If `a == b`:\n   The minimum `lcm` is `a` for `k=0`. Print `0` and exit.\n4. Calculate `diff = abs(a - b)`.\n5. Find all divisors of `diff`. We can do this by iterating from `1` up to `sqrt(diff)`. If `i` divides `diff`, then both `i` and `diff // i` are divisors.\n6. For each divisor `d` found:\n   a. Calculate `k = (d - (a % d)) % d`.\n   b. Calculate `current_a = a + k`.\n   c. Calculate `current_b = b + k`.\n   d. Calculate `current_lcm = (current_a * current_b) // math.gcd(current_a, current_b)`.\n   e. If `current_lcm < min_lcm`:\n      Update `min_lcm = current_lcm`.\n      Update `best_k = k`.\n   f. Else if `current_lcm == min_lcm`:\n      Update `best_k = min(best_k, k)` (to ensure we pick the smallest `k` for ties).\n7. Print `best_k`.\n\n**Example Walkthrough (a=6, b=10):**\n1. `a=6, b=10`. `a != b`.\n2. `diff = abs(10-6) = 4`.\n3. Divisors of 4: 1, 2, 4.\n4. Initialize `min_lcm = infinity`, `best_k = 0`.\n\n   - **For d = 1:**\n     `k = (1 - (6 % 1)) % 1 = (1 - 0) % 1 = 0`.\n     `current_a = 6 + 0 = 6`.\n     `current_b = 10 + 0 = 10`.\n     `current_lcm = (6 * 10) // gcd(6, 10) = 60 // 2 = 30`.\n     `min_lcm = 30`, `best_k = 0`.\n\n   - **For d = 2:**\n     `k = (2 - (6 % 2)) % 2 = (2 - 0) % 2 = 0`.\n     `current_a = 6 + 0 = 6`.\n     `current_b = 10 + 0 = 10`.\n     `current_lcm = (6 * 10) // gcd(6, 10) = 60 // 2 = 30`.\n     `current_lcm (30) == min_lcm (30)`. `best_k = min(0, 0) = 0`.\n\n   - **For d = 4:**\n     `k = (4 - (6 % 4)) % 4 = (4 - 2) % 4 = 2`.\n     `current_a = 6 + 2 = 8`.\n     `current_b = 10 + 2 = 12`.\n     `current_lcm = (8 * 12) // gcd(8, 12) = 96 // 4 = 24`.\n     `current_lcm (24) < min_lcm (30)`.\n     `min_lcm = 24`, `best_k = 2`.\n\n5. After checking all divisors, print `best_k = 2`.\n\nThis matches the example output.\n\n**Constraints:** `1 <= a, b <= 10^9`.\n`diff` can be up to `10^9 - 1`.\nThe number of divisors for a number up to `10^9` is relatively small. For example, `735134400` has 1344 divisors, `720720` has 240 divisors. The maximum number of divisors for a number less than or equal to `10^9` is for `735134400`, which is 1344.\nThe loop runs `2 * sqrt(diff)` times to find divisors, and then for each divisor, performs constant time arithmetic operations. `sqrt(10^9)` is about `31622`. This is very efficient.\n\n```python\nimport math\n\ndef solve():\n    a, b = map(int, input().split())\n\n    if a == b:\n        print(0)\n        return\n\n    # Initialize with a base case: k=0\n    # current_a = a, current_b = b\n    # current_lcm = (a * b) // math.gcd(a, b)\n    # min_lcm = current_lcm\n    # best_k = 0\n    #\n    # However, it's better to initialize min_lcm to infinity\n    # and best_k to a value that will be overwritten or is the\n    # default smallest k if no better LCM is found.\n    # The smallest k is 0, so we can initialize best_k = 0\n    # and min_lcm to a sufficiently large value.\n    \n    # A safe initial value for min_lcm could be lcm(a,b) for k=0.\n    # But it's simpler to use a very large number and handle the first update.\n    min_lcm = float('inf') \n    best_k = 0 # Default to 0, will be updated if a better k is found\n\n    diff = abs(a - b)\n\n    # Find all divisors of diff\n    divisors = set()\n    for i in range(1, int(math.sqrt(diff)) + 1):\n        if diff % i == 0:\n            divisors.add(i)\n            divisors.add(diff // i)\n\n    # Iterate through each divisor d\n    for d in divisors:\n        # Calculate k such that (a+k) is a multiple of d\n        # k = (d - (a % d)) % d\n        # If a % d == 0, k = 0.\n        # If a % d != 0, k = d - (a % d).\n        k_candidate = (d - (a % d)) % d\n        \n        val_a = a + k_candidate\n        val_b = b + k_candidate\n        \n        # Calculate LCM using the property lcm(x,y) = (x*y)/gcd(x,y)\n        current_lcm = (val_a * val_b) // math.gcd(val_a, val_b)\n        \n        # Check if this LCM is better than the minimum found so far\n        if current_lcm < min_lcm:\n            min_lcm = current_lcm\n            best_k = k_candidate\n        elif current_lcm == min_lcm:\n            # If LCMs are equal, choose the smallest k\n            best_k = min(best_k, k_candidate)\n            \n    print(best_k)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef solve():\n    a, b = map(int, input().split())\n\n    if a == b:\n        print(0)\n        return\n\n    # Initialize with a base case: k=0\n    # current_a = a, current_b = b\n    # current_lcm = (a * b) // math.gcd(a, b)\n    # min_lcm = current_lcm\n    # best_k = 0\n    #\n    # However, it's better to initialize min_lcm to infinity\n    # and best_k to a value that will be overwritten or is the\n    # default smallest k if no better LCM is found.\n    # The smallest k is 0, so we can initialize best_k = 0\n    # and min_lcm to a sufficiently large value.\n    \n    # A safe initial value for min_lcm could be lcm(a,b) for k=0.\n    # But it's simpler to use a very large number and handle the first update.\n    min_lcm = float('inf') \n    best_k = 0 # Default to 0, will be updated if a better k is found\n\n    diff = abs(a - b)\n\n    # Find all divisors of diff\n    divisors = set()\n    for i in range(1, int(math.sqrt(diff)) + 1):\n        if diff % i == 0:\n            divisors.add(i)\n            divisors.add(diff // i)\n\n    # Iterate through each divisor d\n    for d in divisors:\n        # Calculate k such that (a+k) is a multiple of d\n        # k = (d - (a % d)) % d\n        # If a % d == 0, k = 0.\n        # If a % d != 0, k = d - (a % d).\n        k_candidate = (d - (a % d)) % d\n        \n        val_a = a + k_candidate\n        val_b = b + k_candidate\n        \n        # Calculate LCM using the property lcm(x,y) = (x*y)/gcd(x,y)\n        current_lcm = (val_a * val_b) // math.gcd(val_a, val_b)\n        \n        # Check if this LCM is better than the minimum found so far\n        if current_lcm < min_lcm:\n            min_lcm = current_lcm\n            best_k = k_candidate\n        elif current_lcm == min_lcm:\n            # If LCMs are equal, choose the smallest k\n            best_k = min(best_k, k_candidate)\n            \n    print(best_k)\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 421,
        "completion_token_count": 2468,
        "thoughts_token_count": 789
    }
}