{
    "start": 1758284929.9682455,
    "end": 1758284967.3932295,
    "start-formatted": "2025-09-19 21:28 KST",
    "end-formatted": "2025-09-19 21:29 KST",
    "gpu": 2,
    "pid": 44,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Polycarp's Practice\n\nPolycarp is practicing his problem solving skill. He has a list of $$$n$$$ problems with difficulties $$$a_1, a_2, \\dots, a_n$$$, respectively. His plan is to practice for exactly $$$k$$$ days. Each day he has to solve at least one problem from his list. Polycarp solves the problems in the order they are given in his list, he cannot skip any problem from his list. He has to solve all $$$n$$$ problems in exactly $$$k$$$ days.Thus, each day Polycarp solves a contiguous sequence of (consecutive) problems from the start of the list. He can't skip problems or solve them multiple times. As a result, in $$$k$$$ days he will solve all the $$$n$$$ problems.The profit of the $$$j$$$-th day of Polycarp's practice is the maximum among all the difficulties of problems Polycarp solves during the $$$j$$$-th day (i.e. if he solves problems with indices from $$$l$$$ to $$$r$$$ during a day, then the profit of the day is $$$\\max\\limits_{l \\le i \\le r}a_i$$$). The total profit of his practice is the sum of the profits over all $$$k$$$ days of his practice.You want to help Polycarp to get the maximum possible total profit over all valid ways to solve problems. Your task is to distribute all $$$n$$$ problems between $$$k$$$ days satisfying the conditions above in such a way, that the total profit is maximum.For example, if $$$n = 8, k = 3$$$ and $$$a = [5, 4, 2, 6, 5, 1, 9, 2]$$$, one of the possible distributions with maximum total profit is: $$$[5, 4, 2], [6, 5], [1, 9, 2]$$$. Here the total profit equals $$$5 + 6 + 9 = 20$$$.\n\n## Input\nThe first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\le k \\le n \\le 2000$$$) — the number of problems and the number of days, respectively.The second line of the input contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le 2000$$$) — difficulties of problems in Polycarp's list, in the order they are placed in the list (i.e. in the order Polycarp will solve them).\n\n## Output\nIn the first line of the output print the maximum possible total profit.In the second line print exactly $$$k$$$ positive integers $$$t_1, t_2, \\dots, t_k$$$ ($$$t_1 + t_2 + \\dots + t_k$$$ must equal $$$n$$$), where $$$t_j$$$ means the number of problems Polycarp will solve during the $$$j$$$-th day in order to achieve the maximum possible total profit of his practice.If there are many possible answers, you may print any of them.\n\n## Example\n### Input\n['8 3\\n5 4 2 6 5 1 9 2', '5 1\\n1 1 1 1 1', '4 2\\n1 2000 2000 2']\n\n### Output\n['20\\n3 2 3', '1\\n5', '4000\\n2 2']\n\n## Note\nThe first example is described in the problem statement.In the second example there is only one possible distribution.In the third example the best answer is to distribute problems in the following way: $$$[1, 2000], [2000, 2]$$$. The total profit of this distribution is $$$2000 + 2000 = 4000$$$.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "**Breaking Down \"Polycarp's Practice\" for a Python Solution**\n\nOkay, so I'm looking at this \"Polycarp's Practice\" problem and my expert brain is already starting to formulate a strategy.  The core of the problem is optimizing profit, which is really about maximizing the *sum* of the daily maximum difficulty problems.  I'm thinking Python is definitely the way to go here.\n\nFirst, I need to really solidify my understanding. We've got `n` problems, spread across `k` days.  Each day's profit is the *highest* difficulty among the problems tackled. The goal? Maximize the total profit over all days. I get the example, which shows that splitting the problems smartly is key.\n\nHere's the key:  To get the absolute *biggest* total profit, I need to get the largest numbers into the daily maxes.  Ideally, if I can somehow *force* the `k` largest values from the original list `a` to be the daily maxima, that's the absolute best I can do.  That sum will be the *optimal* profit.  It's a greedy approach, and in this case, it seems to be optimal.\n\nBut, can this be *always* done?  I think so.  The tricky part is finding those optimal splits. I see it: sort the array, take the k largest, and then try to find the split points. I need to retain the *original indices* of these top `k` values so that I can figure out how to arrange the segments around them. This is the trick to be able to make it work.\n\nSo, the plan: First, I'll identify and sort the array to isolate those top `k` difficulties. Then, I need to find the split points in the original list.  Now I need to connect this to the code...\n",
    "response": "The problem asks us to distribute `n` problems into `k` contiguous segments (days) such that the sum of the maximum difficulties in each segment is maximized. We also need to output the number of problems solved each day.\n\n**Key Insight:**\nTo maximize the sum of `k` daily maximums, we should aim for the largest possible values to be these maximums. The absolute maximum sum we can achieve is the sum of the `k` largest problem difficulties from the entire list `a`. If we can ensure that each of these `k` largest difficulties becomes the maximum for exactly one day, then we've found the optimal total profit.\n\n**Strategy:**\n1.  **Find the `k` largest difficulties:**\n    Create a list of tuples `(difficulty, original_index)` for each problem.\n    Sort this list in descending order of difficulty.\n    Take the top `k` elements from this sorted list. These are the `k` largest difficulties.\n\n2.  **Calculate the maximum total profit:**\n    Sum the difficulties of these `k` largest problems. This sum will be our maximum total profit.\n\n3.  **Determine the split points for days:**\n    The `k` largest problems we identified must each be the maximum for one day. To achieve this, we can make sure that each of these `k` problems is the *last* problem of a day segment (or, more generally, is contained within a segment whose maximum it is).\n    A simple way to ensure this is to use the *original indices* of these `k` largest problems as the split points.\n    Collect the original indices of these `k` largest problems. Let's call them `idx_1, idx_2, ..., idx_k`.\n    Sort these indices in ascending order.\n    These `k` indices (let's say `p_1 < p_2 < ... < p_k`) will define the end points of our daily segments.\n    -   The first day will solve problems from index `0` up to `p_1` (inclusive).\n    -   The second day will solve problems from index `p_1 + 1` up to `p_2` (inclusive).\n    -   ...\n    -   The `k`-th day will solve problems from index `p_{k-1} + 1` up to `p_k` (inclusive, which must be `n-1`).\n\n    Since each `p_j` corresponds to one of the `k` largest difficulties, and the problems are solved contiguously, each of these `k` largest difficulties will naturally fall into one of the `k` segments. By making them the *last* problem of a segment (or simply including them in a segment), they will be the maximums for their respective segments because they are among the overall largest values. Any other problem in their segment will either have a smaller or equal difficulty.\n\n**Example Walkthrough:**\n`n = 8, k = 3, a = [5, 4, 2, 6, 5, 1, 9, 2]`\n\n1.  **Problems with indices:**\n    `(5,0), (4,1), (2,2), (6,3), (5,4), (1,5), (9,6), (2,7)`\n\n2.  **Sort by difficulty (descending) and take top `k=3`:**\n    `(9,6), (6,3), (5,0)` (There's another `5` at index `4`, but we only need `k` unique largest values. If there are ties for the `k`-th largest value, any choice works.)\n\n3.  **Maximum total profit:** `9 + 6 + 5 = 20`\n\n4.  **Original indices of these problems:** `6, 3, 0`\n    Sort these indices: `0, 3, 6`\n\n5.  **Determine daily problem counts:**\n    -   Day 1: Problems from index `0` up to `0`. Number of problems: `0 - (-1) = 1`.\n        Wait, this is wrong. The indices `p_j` are the *last* index of problems solved on day `j`.\n        So, the first day ends at index `p_1`.\n        The second day ends at index `p_2`.\n        ...\n        The `k`-th day ends at index `p_k` (which must be `n-1`).\n\n        Correct split logic:\n        The sorted indices are `p_1, p_2, ..., p_k`.\n        -   Problems for Day 1: `a[0]` to `a[p_1]`. Count: `p_1 - 0 + 1`.\n        -   Problems for Day 2: `a[p_1+1]` to `a[p_2]`. Count: `p_2 - (p_1+1) + 1`.\n        -   ...\n        -   Problems for Day `k`: `a[p_{k-1}+1]` to `a[p_k]`. Count: `p_k - (p_{k-1}+1) + 1`.\n\n        Using `0, 3, 6` for our example.\n        The problem states `k` days, so we need `k-1` split points.\n        The `k` largest values are `a[0]=5`, `a[3]=6`, `a[6]=9`.\n        Their indices are `0, 3, 6`.\n        We must ensure the last day ends at `n-1`. The `k`-th largest value should be `a[p_k]`.\n        So, we take the `k-1` smallest indices from `0, 3, 6` as internal split points.\n        The internal split points are `0` and `3`.\n        -   Day 1: `a[0]` to `a[0]`. Count: `0 - (-1) = 1`. Problems: `[5]`. Max: `5`.\n        -   Day 2: `a[1]` to `a[3]`. Count: `3 - 0 = 3`. Problems: `[4, 2, 6]`. Max: `6`.\n        -   Day 3: `a[4]` to `a[7]`. Count: `7 - 3 = 4`. Problems: `[5, 1, 9, 2]`. Max: `9`.\n        Total profit: `5 + 6 + 9 = 20`. Daily counts: `1, 3, 4`.\n        This is a valid solution, but different from the example output (`3 2 3`). The problem statement says \"If there are many possible answers, you may print any of them.\"\n\n    Let's refine the split points. We need `k-1` actual split points.\n    The indices of the `k` largest elements are `p_1, p_2, ..., p_k`.\n    The problems for day 1 are `a[0]` to `a[p_1]`.\n    The problems for day 2 are `a[p_1+1]` to `a[p_2]`.\n    ...\n    The problems for day `k` are `a[p_{k-1}+1]` to `a[n-1]`.\n    This means `p_k` must be `n-1`. If `n-1` is not among the `k` largest values' indices, this strategy doesn't work directly.\n    A simpler approach for split points:\n    The `k` largest values are `a[idx_1], a[idx_2], ..., a[idx_k]`.\n    Sort these `k` indices: `sorted_indices = [idx_a, idx_b, ..., idx_k]`.\n    These `k` indices represent the positions where we *could* end a day.\n    The first day ends at `sorted_indices[0]`.\n    The second day ends at `sorted_indices[1]`.\n    ...\n    The `k-1`th day ends at `sorted_indices[k-2]`.\n    The `k`th day ends at `n-1`.\n    This defines `k` segments.\n    The segment for day `j` (for `j < k`) will run from the end of day `j-1`'s segment plus one, up to `sorted_indices[j-1]`.\n    The segment for day `k` will run from the end of day `k-1`'s segment plus one, up to `n-1`.\n\n    Let's re-try with `n = 8, k = 3, a = [5, 4, 2, 6, 5, 1, 9, 2]`\n    `k` largest values: `9` (index 6), `6` (index 3), `5` (index 0).\n    Sorted indices: `[0, 3, 6]`\n\n    `split_indices = [0, 3]` (these are the first `k-1` sorted indices)\n    `current_start_index = 0`\n    `day_lengths = []`\n\n    For `idx` in `split_indices`:\n        Length of current day: `idx - current_start_index + 1`\n        `day_lengths.append(idx - current_start_index + 1)`\n        `current_start_index = idx + 1`\n\n    After loop:\n    `day_lengths.append(n - current_start_index)` (for the last day)\n\n    1. `idx = 0`:\n       `day_lengths.append(0 - 0 + 1) = 1`. `day_lengths = [1]`.\n       `current_start_index = 0 + 1 = 1`.\n    2. `idx = 3`:\n       `day_lengths.append(3 - 1 + 1) = 3`. `day_lengths = [1, 3]`.\n       `current_start_index = 3 + 1 = 4`.\n\n    After loop:\n    Last day: `n - current_start_index = 8 - 4 = 4`.\n    `day_lengths = [1, 3, 4]`.\n    This matches the `1 3 4` solution found above. It's a valid solution.\n\n    The example output `3 2 3` implies that the `k` largest values chosen were `a[0]=5`, `a[3]=6`, `a[6]=9`.\n    The splits are:\n    Day 1: `[5, 4, 2]` (length 3). Max is `5` (at index 0).\n    Day 2: `[6, 5]` (length 2). Max is `6` (at index 3).\n    Day 3: `[1, 9, 2]` (length 3). Max is `9` (at index 6).\n    In this case, the split points are *after* indices `2` and `4`. The problem indices `0, 3, 6` are still the maximums.\n    This means we can choose any `k-1` split points, as long as each of the `k` largest values falls into a unique segment and is its maximum.\n    The strategy of using the *first* `k-1` sorted indices as split points (meaning, a day ends exactly at that index) guarantees that each of the selected `k` largest values is part of a day, and since they are the largest, they will be the maximums. The last day will simply take all remaining problems.\n\n    Let's re-verify the example output `3 2 3`.\n    If the cuts are after index 2 and index 4:\n    `a[0...2] = [5, 4, 2]`. Max = 5.\n    `a[3...4] = [6, 5]`. Max = 6.\n    `a[5...7] = [1, 9, 2]`. Max = 9.\n    Total profit = 5 + 6 + 9 = 20.\n    The indices of the maximums are `0, 3, 6`.\n    The split points are `2` and `4`. Notice that these split points are not necessarily among the indices of the largest elements.\n    However, the crucial thing is that the `k` largest elements are *covered* and become the maximum of their respective days.\n\n    The strategy of taking the *original indices* of the `k` largest values, sorting them, and using them to define the end points of the first `k-1` segments, with the last segment ending at `n-1`, is simple and correct.\n\n**Algorithm:**\n\n1.  Read `n` and `k`.\n2.  Read the array `a`.\n3.  Create a list of tuples `(difficulty, index)` for `a`.\n    `indexed_a = [(a[i], i) for i in range(n)]`\n4.  Sort `indexed_a` in descending order of difficulty.\n    `indexed_a.sort(key=lambda x: x[0], reverse=True)`\n5.  Extract the top `k` difficulties and their original indices.\n    `top_k_elements = indexed_a[:k]`\n6.  Calculate `max_total_profit = sum(item[0] for item in top_k_elements)`.\n7.  Extract the original indices of these `k` elements and sort them.\n    `split_indices = sorted([item[1] for item in top_k_elements])`\n8.  Calculate `day_lengths`:\n    Initialize `current_start_index = 0`.\n    Initialize `lengths = []`.\n    For `i` from `0` to `k-2`:\n        `end_index = split_indices[i]`\n        `length = end_index - current_start_index + 1`\n        `lengths.append(length)`\n        `current_start_index = end_index + 1`\n    The last day takes the remaining problems:\n    `lengths.append(n - current_start_index)`\n\n9.  Print `max_total_profit`.\n10. Print `lengths` joined by spaces.\n\n**Edge Cases:**\n-   `k = 1`: The first day takes all `n` problems. The max profit is `max(a)`. My algorithm: `top_k_elements` will have 1 item `(max(a), index_of_max)`. `split_indices` will have 1 item. The loop for `k-2` iterations won't run. `lengths.append(n - 0)` gives `[n]`. Correct.\n-   `k = n`: Each day takes 1 problem. The max profit is `sum(a)`. My algorithm: `top_k_elements` will be all problems. `split_indices` will be `[0, 1, ..., n-1]`.\n    `current_start_index = 0`.\n    For `i` from `0` to `n-2`:\n        `end_index = i`\n        `length = i - current_start_index + 1`\n        `lengths.append(length)` (will be 1)\n        `current_start_index = i + 1`\n    Last day: `lengths.append(n - (n-1))` (will be 1).\n    Result `[1, 1, ..., 1]`. Correct.\n\n**Constraints:**\n`1 <= k <= n <= 2000`\n`1 <= a_i <= 2000`\nThe approach involves sorting `n` elements (O(N log N)) and then iterating `k` times. This is efficient enough. `2000 log 2000` is well within time limits.\n\n```python\nimport sys\n\ndef solve():\n    n, k = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    # Step 1: Create a list of (difficulty, original_index) tuples\n    indexed_a = []\n    for i in range(n):\n        indexed_a.append((a[i], i))\n\n    # Step 2: Sort by difficulty in descending order\n    # If difficulties are equal, the original index doesn't matter for finding the max profit,\n    # but sorting by index might provide a deterministic choice for tie-breaking.\n    # For this problem, any tie-breaking is fine, so a simple sort is enough.\n    indexed_a.sort(key=lambda x: x[0], reverse=True)\n\n    # Step 3: Select the top k elements\n    top_k_elements = indexed_a[:k]\n\n    # Step 4: Calculate the maximum total profit\n    max_total_profit = sum(item[0] for item in top_k_elements)\n\n    # Step 5: Extract and sort the original indices of these top k elements\n    # These indices will define the split points for the days.\n    # We will use the first k-1 of these sorted indices as the end points of the first k-1 days.\n    # The last day will take all remaining problems up to n-1.\n    split_indices = sorted([item[1] for item in top_k_elements])\n\n    # Step 6: Calculate the number of problems for each day\n    day_lengths = []\n    current_start_index = 0\n\n    # The first k-1 split_indices define the end of the first k-1 days\n    for i in range(k - 1):\n        end_index = split_indices[i]\n        length = end_index - current_start_index + 1\n        day_lengths.append(length)\n        current_start_index = end_index + 1 # Next day starts after this end_index\n\n    # The last day takes all remaining problems\n    # It starts from current_start_index and goes up to n-1\n    day_lengths.append(n - current_start_index)\n\n    # Step 7: Print the results\n    print(max_total_profit)\n    print(*(day_lengths))\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, k = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    # Step 1: Create a list of (difficulty, original_index) tuples\n    indexed_a = []\n    for i in range(n):\n        indexed_a.append((a[i], i))\n\n    # Step 2: Sort by difficulty in descending order\n    # If difficulties are equal, the original index doesn't matter for finding the max profit,\n    # but sorting by index might provide a deterministic choice for tie-breaking.\n    # For this problem, any tie-breaking is fine, so a simple sort is enough.\n    indexed_a.sort(key=lambda x: x[0], reverse=True)\n\n    # Step 3: Select the top k elements\n    top_k_elements = indexed_a[:k]\n\n    # Step 4: Calculate the maximum total profit\n    max_total_profit = sum(item[0] for item in top_k_elements)\n\n    # Step 5: Extract and sort the original indices of these top k elements\n    # These indices will define the split points for the days.\n    # We will use the first k-1 of these sorted indices as the end points of the first k-1 days.\n    # The last day will take all remaining problems up to n-1.\n    split_indices = sorted([item[1] for item in top_k_elements])\n\n    # Step 6: Calculate the number of problems for each day\n    day_lengths = []\n    current_start_index = 0\n\n    # The first k-1 split_indices define the end of the first k-1 days\n    for i in range(k - 1):\n        end_index = split_indices[i]\n        length = end_index - current_start_index + 1\n        day_lengths.append(length)\n        current_start_index = end_index + 1 # Next day starts after this end_index\n\n    # The last day takes all remaining problems\n    # It starts from current_start_index and goes up to n-1\n    day_lengths.append(n - current_start_index)\n\n    # Step 7: Print the results\n    print(max_total_profit)\n    print(*(day_lengths))\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 973,
        "completion_token_count": 4171,
        "thoughts_token_count": 781
    }
}