{
    "start": 1758009311.3785646,
    "end": 1758009380.6763883,
    "start-formatted": "2025-09-16 16:55 KST",
    "end-formatted": "2025-09-16 16:56 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "**My Analytical Process for the \"Rudolf and Snowflakes (Hard Version)\" Problem**\n\nOkay, so I'm tasked with writing a Python script to tackle this snowflake problem.  The core of it is understanding the snowflake's structure.  It starts with a central vertex, then sprouts 'k' leaves.  The key is this iterative expansion: each leaf then sprouts 'k' more leaves.  This expansion, as the problem states, must happen at least once.\n\nLet's break down the vertex count. Level 0 has one center. Level 1 has 'k' leaves attached to that center. Applying the expansion once means those 'k' leaves each spawn 'k' more, so Level 2 has k*k = k^2 new leaves.\n\nWe'll call the number of times this leaf expansion happens 'd', and we know d has to be greater than or equal to 1. Now, summing the vertices across levels, the total number of vertices 'n' becomes: 1 (center) + k (Level 1) + k^2 (Level 2) ... all the way up to k^(d+1) after d expansions.\n\nThat's a geometric series! So, `n = (k^(d+2) - 1) / (k - 1)`. I have 'n' as input, and I need to figure out if integers 'k > 1' and 'd >= 1' exist to satisfy this equation. We're given that 'n' is less than or equal to 10^18.\n\nLet's simplify that series sum and denote m = d+1. So, now m is greater or equal to 2, and n = 1 + k + k^2 + ... + k^m. I need to check for integer k and m such that this equation holds.\n\nI'm starting with smaller values of 'm'. If m = 2, the equation becomes n = 1 + k + k^2, a quadratic in k.  I can solve for 'k' using the quadratic formula:  `k = (-1 +/- sqrt(4n - 3)) / 2`. For 'k' to be an integer, `4n - 3` must be a perfect square. If it is, then I can compute k.\n",
    "response": "The problem asks us to determine if a given number of vertices `n` can form a snowflake. A snowflake is defined by a central vertex, which is connected to `k` new vertices (`k > 1`). Then, this \"expansion\" step is repeated at least once: each vertex connected to only one other vertex (i.e., a leaf) is connected to `k` more new vertices.\n\nLet's trace the number of vertices:\n1.  **Initial vertex:** 1 vertex (the center).\n2.  **First expansion:** The central vertex is connected to `k` new vertices. Total vertices: `1 + k`. These `k` vertices are now leaves.\n3.  **Subsequent expansions:** The problem states this step \"should be done at least once\". Let `d` be the number of times this step is performed.\n    *   If `d=1`: Each of the `k` leaves from step 2 gets `k` new children. So, `k * k = k^2` new vertices are added. Total vertices: `1 + k + k^2`.\n    *   If `d=2`: Each of the `k^2` leaves from the previous step gets `k` new children. So, `k^2 * k = k^3` new vertices are added. Total vertices: `1 + k + k^2 + k^3`.\n    *   In general, if the expansion step is performed `d` times, the total number of vertices will be `n = 1 + k + k^2 + ... + k^(d+1)`.\n\nThe problem states `k > 1` and the expansion step is done \"at least once\", which means `d >= 1`.\nLet `m = d+1`. Since `d >= 1`, we have `m >= 2`.\nSo, the problem reduces to checking if `n` can be expressed as the sum of a geometric series `1 + k + k^2 + ... + k^m` for some integers `k > 1` and `m >= 2`.\n\nThe sum of a geometric series is `n = (k^(m+1) - 1) / (k - 1)`.\n\nWe need to check this for `n` up to `10^18`.\n\nThere are two main cases to consider:\n\n**Case 1: `m` is small.**\nIf `m` is small, `k` can be large.\nThe smallest possible `m` is 2.\n*   If `m = 2`: `n = 1 + k + k^2`.\n    This is a quadratic equation `k^2 + k + (1 - n) = 0`.\n    Using the quadratic formula, `k = (-1 + sqrt(1 - 4(1 - n))) / 2 = (-1 + sqrt(4n - 3)) / 2`.\n    For `k` to be a valid integer `> 1`, `4n - 3` must be a perfect square, say `S^2`, and `(-1 + S)` must be an even integer greater than 2.\n    We can check this by calculating `S = round(sqrt(4n - 3))`. If `S*S == 4n - 3` and `(S - 1)` is even and `(S - 1) / 2 > 1`, then `n` is a YES.\n\n*   If `m = 3`: `n = 1 + k + k^2 + k^3`.\n    This is a cubic equation. For `n = 10^18`, `k^3` is approximately `n`, so `k` is around `(10^18)^(1/3) = 10^6`.\n    We can iterate `k` from 2 up to a certain limit. For `m=3`, `k^3 < n`, so `k < n^(1/3)`.\n    For `n=10^18`, `k < 10^6`.\n    We can iterate `k` from 2 up to `10^6`. For each `k`, calculate `1 + k + k^2 + k^3`. If it equals `n`, then `n` is a YES.\n\n*   If `m = 4`: `n = 1 + k + k^2 + k^3 + k^4`.\n    `k^4 < n`, so `k < n^(1/4)`. For `n=10^18`, `k < (10^18)^(1/4) = 10^(4.5) approx 31622`.\n    We can iterate `k` from 2 up to `31622`.\n\n*   In general, for fixed `m`, `k^m < n`, so `k < n^(1/m)`.\n    The maximum value of `m` for `k=2` is when `2^m` is approximately `n`.\n    `2^m <= n` implies `m <= log2(n)`. For `n=10^18`, `log2(10^18) approx 18 * log2(10) approx 18 * 3.32 approx 59.79`. So `m` can go up to about 60.\n    For `m=60`, `k < n^(1/60)`. For `n=10^18`, `k < (10^18)^(1/60) = (10^3)^(1/10) = 10^(0.3) approx 1.99`. This means `k` must be 1, but `k > 1`. So, `m` cannot be 60.\n    For `k=2`, the maximum `m` is when `2^(m+1) - 1` is around `10^18`. This means `m+1` is around 60, so `m` is around 59.\n    The largest possible `m` for `k=2` is `m=59`.\n    The sum `1 + 2 + ... + 2^59` is `2^60 - 1`.\n    For `m=59`, `k` must be 2.\n\nWe can iterate through possible values of `m` from 2 up to about 60. For each `m`:\n  We need to find `k` such that `n = 1 + k + ... + k^m`.\n  Since `k^m < n`, `k < n^(1/m)`.\n  We can use binary search to find `k` for a fixed `m`.\n  The range for `k` is `[2, n^(1/m)]`.\n  For `m=2`, `k` can be up to `sqrt(10^18) = 10^9`.\n  For `m=3`, `k` can be up to `(10^18)^(1/3) = 10^6`.\n  For `m=4`, `k` can be up to `(10^18)^(1/4) = 31622`.\n  For `m=5`, `k` can be up to `(10^18)^(1/5) = 6309`.\n  For `m=6`, `k` can be up to `(10^18)^(1/6) = 1000`.\n  For `m=7`, `k` can be up to `(10^18)^(1/7) = 372`.\n  For `m=8`, `k` can be up to `(10^18)^(1/8) = 177`.\n  For `m=9`, `k` can be up to `(10^18)^(1/9) = 100`.\n  For `m=10`, `k` can be up to `(10^18)^(1/10) = 63`.\n  For `m=11`, `k` can be up to `(10^18)^(1/11) = 45`.\n  For `m=12`, `k` can be up to `(10^18)^(1/12) = 31`.\n  For `m=13`, `k` can be up to `(10^18)^(1/13) = 25`.\n  For `m=14`, `k` can be up to `(10^18)^(1/14) = 21`.\n  For `m=15`, `k` can be up to `(10^18)^(1/15) = 18`.\n  For `m=16`, `k` can be up to `(10^18)^(1/16) = 15`.\n  For `m=17`, `k` can be up to `(10^18)^(1/17) = 13`.\n  For `m=18`, `k` can be up to `(10^18)^(1/18) = 10`.\n  For `m=19`, `k` can be up to `(10^18)^(1/19) = 9`.\n  For `m=20`, `k` can be up to `(10^18)^(1/20) = 8`.\n  For `m=21`, `k` can be up to `(10^18)^(1/21) = 7`.\n  For `m=22`, `k` can be up to `(10^18)^(1/22) = 6`.\n  For `m=25`, `k` can be up to `(10^18)^(1/25) = 5`.\n  For `m=30`, `k` can be up to `(10^18)^(1/30) = 4`.\n  For `m=36`, `k` can be up to `(10^18)^(1/36) = 3`.\n  For `m=59`, `k` can be up to `(10^18)^(1/59) = 2`.\n\nThe maximum `k` for `m=2` is `10^9`. Binary search for `k` in `[2, 10^9]` takes `log(10^9)` iterations, which is about 30.\nFor each `m` from 3 to 59, the upper bound for `k` decreases significantly. The number of iterations for binary search is small.\nThe calculation of `k^m` can be done efficiently using `pow(k, m)`. We must be careful about potential overflow if intermediate `k^p` exceeds `10^18`, but since we are looking for `sum <= n`, we can stop early if the sum exceeds `n`.\n\n**Algorithm:**\n1.  Handle `n=1, 2, 3, 4, 5, 6` which are all \"NO\" based on `k > 1` and `m >= 2`.\n    *   `m=2`: `1+k+k^2`. Smallest is `1+2+2^2 = 7`. So `n < 7` is \"NO\".\n2.  Check the special case `m=2`:\n    Calculate `S = round(sqrt(4*n - 3))`.\n    If `S*S == 4*n - 3` and `(S - 1) % 2 == 0` and `(S - 1) // 2 > 1`, then return \"YES\".\n3.  Iterate `m` from 3 up to 60 (or `ceil(log2(n))` but 60 is a safe upper bound for `n=10^18`).\n    For each `m`:\n    *   Set `low = 2`, `high = int(n**(1/m)) + 2` (add a small margin to `n**(1/m)` to account for floating point inaccuracies). The upper bound for `high` can be `10^6` for `m=3`, or `2` for `m=59`. `10^6` is a safe upper bound for `high` for `m >= 3`.\n    *   Perform binary search for `k` in `[low, high]`:\n        *   `mid = (low + high) // 2`\n        *   Calculate `current_sum = 1 + mid + mid^2 + ... + mid^m`.\n            This can be done by `current_sum = 0`, `term = 1`. For `_ in range(m + 1)`: `current_sum += term`; if `current_sum > n`: break; `term *= mid`. If `term` overflows, we can also break.\n        *   If `current_sum == n`, then `n` is a YES. Return \"YES\".\n        *   If `current_sum < n`, then `k` might be larger, so `low = mid + 1`.\n        *   If `current_sum > n`, then `k` must be smaller, so `high = mid - 1`.\n4.  If no such `k, m` are found after checking all possibilities, return \"NO\".\n\nThe `n**(1/m)` calculation can be slightly imprecise due to floating point. A safer upper bound for `k` would be `min(int(n**(1/m)) + 2, 10**6)` for `m >= 3`, and `10**9` for `m=2`. However, for `m=2`, we have a direct formula. So for `m >= 3`, `10^6` is a safe upper bound for binary search's `high`.\n\nLet's refine the binary search for `k`:\nFor a fixed `m` (from 3 to 60):\n`low = 2`, `high = int(pow(n, 1/m)) + 2` (a small margin for float precision).\nWhile `low <= high`:\n    `mid_k = (low + high) // 2`\n    If `mid_k < 2`: `mid_k = 2` (ensure `k > 1`). If `low` is already `2`, this is not strictly needed.\n    `current_sum = 0`\n    `term = 1`\n    `valid_sum = True`\n    For `_ in range(m + 1)`:\n        `current_sum += term`\n        If `current_sum > n`:\n            `valid_sum = False`\n            break\n        If `term > n // mid_k` and `_ < m`: # Check for overflow before multiplying `term`\n            `valid_sum = False`\n            break\n        `term *= mid_k`\n\n    If `valid_sum` and `current_sum == n`: return \"YES\".\n    If `valid_sum` and `current_sum < n`: `low = mid_k + 1`.\n    Else (`current_sum > n` or `not valid_sum`): `high = mid_k - 1`.\n\nThis approach covers all `k > 1` and `m >= 2`.\n\nExample walk-through: `n = 13`\n1. `n=13`. Not `1,2,3,4,5,6`.\n2. `m=2` check: `4*n - 3 = 4*13 - 3 = 52 - 3 = 49`. `sqrt(49) = 7`.\n   `S = 7`. `S*S == 49`. `(S - 1) % 2 == (7 - 1) % 2 == 6 % 2 == 0`.\n   `(S - 1) // 2 = 6 // 2 = 3`. `3 > 1`.\n   All conditions met. Return \"YES\". (`k=3`, `m=2` gives `1 + 3 + 3^2 = 1 + 3 + 9 = 13`).\n\nExample walk-through: `n = 255`\n1. `n=255`. Not `1,2,3,4,5,6`.\n2. `m=2` check: `4*n - 3 = 4*255 - 3 = 1020 - 3 = 1017`. `sqrt(1017)` is not an integer. `31^2 = 961`, `32^2 = 1024`. So `m=2` fails.\n3. Iterate `m` from 3 to 60.\n   *   `m=3`: `low=2`, `high=int(255**(1/3))+2 = 6+2 = 8`.\n       Binary search for `k` in `[2, 8]`.\n       Try `mid_k = 4`. `1 + 4 + 4^2 + 4^3 = 1 + 4 + 16 + 64 = 85`. `85 < 255`. `low = 5`.\n       Try `mid_k = (5+8)//2 = 6`. `1 + 6 + 6^2 + 6^3 = 1 + 6 + 36 + 216 = 259`. `259 > 255`. `high = 5`.\n       Try `mid_k = (5+5)//2 = 5`. `1 + 5 + 5^2 + 5^3 = 1 + 5 + 25 + 125 = 156`. `156 < 255`. `low = 6`.\n       `low=6, high=5`. Loop ends. `m=3` fails.\n   *   `m=4`: `low=2`, `high=int(255**(1/4))+2 = 3+2 = 5`.\n       Binary search for `k` in `[2, 5]`.\n       Try `mid_k = 3`. `1 + 3 + 3^2 + 3^3 + 3^4 = 1 + 3 + 9 + 27 + 81 = 121`. `121 < 255`. `low = 4`.\n       Try `mid_k = (4+5)//2 = 4`. `1 + 4 + 4^2 + 4^3 + 4^4 = 1 + 4 + 16 + 64 + 256 = 341`. `341 > 255`. `high = 3`.\n       `low=4, high=3`. Loop ends. `m=4` fails.\n   *   `m=5`: `low=2`, `high=int(255**(1/5))+2 = 3+2 = 5`.\n       Binary search for `k` in `[2, 5]`.\n       Try `mid_k = 3`. `1 + 3 + ... + 3^5 = 1 + 3 + 9 + 27 + 81 + 243 = 364`. `364 > 255`. `high = 2`.\n       Try `mid_k = (2+2)//2 = 2`. `1 + 2 + 2^2 + 2^3 + 2^4 + 2^5 = 1 + 2 + 4 + 8 + 16 + 32 = 63`. `63 < 255`. `low = 3`.\n       `low=3, high=2`. Loop ends. `m=5` fails.\n   *   `m=6`: `low=2`, `high=int(255**(1/6))+2 = 2+2 = 4`.\n       Binary search for `k` in `[2, 4]`.\n       Try `mid_k = 3`. `1 + 3 + ... + 3^6 = (3^7 - 1)/(3-1) = (2187 - 1)/2 = 1093`. `1093 > 255`. `high = 2`.\n       Try `mid_k = (2+2)//2 = 2`. `1 + 2 + ... + 2^6 = (2^7 - 1)/(2-1) = 128 - 1 = 127`. `127 < 255`. `low = 3`.\n       `low=3, high=2`. Loop ends. `m=6` fails.\n   *   `m=7`: `low=2`, `high=int(255**(1/7))+2 = 2+2 = 4`.\n       Binary search for `k` in `[2, 4]`.\n       Try `mid_k = 3`. `1 + 3 + ... + 3^7 = (3^8 - 1)/2 = (6561 - 1)/2 = 3280`. `3280 > 255`. `high = 2`.\n       Try `mid_k = (2+2)//2 = 2`. `1 + 2 + ... + 2^7 = (2^8 - 1)/1 = 255`. `255 == 255`. Return \"YES\".\n       (`k=2`, `m=7` gives `1 + 2 + 2^2 + 2^3 + 2^4 + 2^5 + 2^6 + 2^7 = 2^8 - 1 = 255`).\n\nThis logic seems sound.\n\n```python\nimport math\n\ndef solve():\n    n = int(input())\n\n    # Base cases for small n\n    # Smallest possible snowflake is for k=2, m=2: 1 + 2 + 2^2 = 7 vertices.\n    # So if n < 7, it's impossible.\n    if n < 7:\n        print(\"NO\")\n        return\n\n    # Case 1: m = 2 (d = 1)\n    # n = 1 + k + k^2\n    # k^2 + k + (1 - n) = 0\n    # Discriminant D = 1 - 4(1 - n) = 1 - 4 + 4n = 4n - 3\n    # k = (-1 + sqrt(4n - 3)) / 2\n    \n    discriminant = 4 * n - 3\n    \n    # Check if discriminant is a perfect square\n    s_float = math.isqrt(discriminant) # integer square root\n    \n    if s_float * s_float == discriminant:\n        # If it is, check if k is an integer and k > 1\n        # k = (-1 + s_float) / 2\n        if (s_float - 1) % 2 == 0: # numerator must be even\n            k = (s_float - 1) // 2\n            if k > 1:\n                print(\"YES\")\n                return\n\n    # Case 2: m >= 3 (d >= 2)\n    # n = 1 + k + k^2 + ... + k^m\n    # We iterate m from 3 up to a certain limit.\n    # For k=2, the sum is 2^(m+1) - 1.\n    # 2^(m+1) - 1 <= 10^18 => 2^(m+1) <= 10^18 + 1\n    # m+1 <= log2(10^18 + 1) approx 59.79. So m+1 can be at most 59.\n    # This means m can be at most 58. (If m+1=59, m=58)\n    # A safe upper bound for m is 60.\n\n    for m in range(3, 61): # m from 3 to 60\n        # For a fixed m, we need to find k such that sum(k^i) = n\n        # k^m < n => k < n^(1/m)\n        # We can use binary search for k.\n        # Lower bound for k is 2.\n        # Upper bound for k: n^(1/m). For n=10^18, m=3, k approx 10^6.\n        # For n=10^18, m=60, k approx 2.\n        # A safe upper bound for binary search for k can be 10^6 (since for larger m, k gets smaller).\n        # For m=3, high can be up to 10^6. For larger m, high decreases.\n        \n        low = 2\n        # Calculate high for k. Use pow for float, then convert to int and add margin.\n        # min is used to cap high to avoid excessively large values, 10^6 is a good practical cap.\n        high = int(math.pow(n, 1/m)) + 2 \n        high = min(high, 10**6 + 7) # Add a margin and cap it for efficiency\n        \n        # If low becomes greater than high (e.g., if n^(1/m) is less than 2),\n        # there are no k values to check for this m.\n        if low > high:\n            continue\n\n        while low <= high:\n            mid_k = (low + high) // 2\n            if mid_k < 2: # Ensure k > 1, though low starts at 2\n                mid_k = 2\n            \n            current_sum = 0\n            term = 1\n            possible = True\n            \n            # Calculate 1 + mid_k + mid_k^2 + ... + mid_k^m\n            for _ in range(m + 1): # m+1 terms\n                current_sum += term\n                if current_sum > n: # Sum exceeded n, this k is too large\n                    possible = False\n                    break\n                # Check for overflow before multiplying term by mid_k\n                # If term * mid_k > n, then current_sum will definitely exceed n in next step\n                # (unless mid_k is 1, but we ensure mid_k > 1)\n                # A more robust overflow check: term > n // mid_k\n                if _ < m and term > n // mid_k: # If term*mid_k would overflow n, and we still have terms to add\n                    possible = False\n                    break\n                term *= mid_k\n            \n            if possible and current_sum == n:\n                print(\"YES\")\n                return\n            \n            if possible and current_sum < n:\n                low = mid_k + 1\n            else: # current_sum > n or overflow occurred\n                high = mid_k - 1\n\n    print(\"NO\")\n\n\nnum_test_cases = int(input())\nfor _ in range(num_test_cases):\n    solve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef solve():\n    n = int(input())\n\n    # Base cases for small n\n    # Smallest possible snowflake is for k=2, m=2: 1 + 2 + 2^2 = 7 vertices.\n    # So if n < 7, it's impossible.\n    if n < 7:\n        print(\"NO\")\n        return\n\n    # Case 1: m = 2 (d = 1)\n    # n = 1 + k + k^2\n    # k^2 + k + (1 - n) = 0\n    # Discriminant D = 1 - 4(1 - n) = 1 - 4 + 4n = 4n - 3\n    # k = (-1 + sqrt(4n - 3)) / 2\n    \n    discriminant = 4 * n - 3\n    \n    # Check if discriminant is a perfect square\n    s_float = math.isqrt(discriminant) # integer square root\n    \n    if s_float * s_float == discriminant:\n        # If it is, check if k is an integer and k > 1\n        # k = (-1 + s_float) / 2\n        if (s_float - 1) % 2 == 0: # numerator must be even\n            k = (s_float - 1) // 2\n            if k > 1:\n                print(\"YES\")\n                return\n\n    # Case 2: m >= 3 (d >= 2)\n    # n = 1 + k + k^2 + ... + k^m\n    # We iterate m from 3 up to a certain limit.\n    # For k=2, the sum is 2^(m+1) - 1.\n    # 2^(m+1) - 1 <= 10^18 => 2^(m+1) <= 10^18 + 1\n    # m+1 <= log2(10^18 + 1) approx 59.79. So m+1 can be at most 59.\n    # This means m can be at most 58. (If m+1=59, m=58)\n    # A safe upper bound for m is 60.\n\n    for m in range(3, 61): # m from 3 to 60\n        # For a fixed m, we need to find k such that sum(k^i) = n\n        # k^m < n => k < n^(1/m)\n        # We can use binary search for k.\n        # Lower bound for k is 2.\n        # Upper bound for k: n^(1/m). For n=10^18, m=3, k approx 10^6.\n        # For n=10^18, m=60, k approx 2.\n        # A safe upper bound for binary search for k can be 10^6 (since for larger m, k gets smaller).\n        # For m=3, high can be up to 10^6. For larger m, high decreases.\n        \n        low = 2\n        # Calculate high for k. Use pow for float, then convert to int and add margin.\n        # min is used to cap high to avoid excessively large values, 10^6 is a good practical cap.\n        high = int(math.pow(n, 1/m)) + 2 \n        high = min(high, 10**6 + 7) # Add a margin and cap it for efficiency\n        \n        # If low becomes greater than high (e.g., if n^(1/m) is less than 2),\n        # there are no k values to check for this m.\n        if low > high:\n            continue\n\n        while low <= high:\n            mid_k = (low + high) // 2\n            if mid_k < 2: # Ensure k > 1, though low starts at 2\n                mid_k = 2\n            \n            current_sum = 0\n            term = 1\n            possible = True\n            \n            # Calculate 1 + mid_k + mid_k^2 + ... + mid_k^m\n            for _ in range(m + 1): # m+1 terms\n                current_sum += term\n                if current_sum > n: # Sum exceeded n, this k is too large\n                    possible = False\n                    break\n                # Check for overflow before multiplying term by mid_k\n                # If term * mid_k > n, then current_sum will definitely exceed n in next step\n                # (unless mid_k is 1, but we ensure mid_k > 1)\n                # A more robust overflow check: term > n // mid_k\n                if _ < m and term > n // mid_k: # If term*mid_k would overflow n, and we still have terms to add\n                    possible = False\n                    break\n                term *= mid_k\n            \n            if possible and current_sum == n:\n                print(\"YES\")\n                return\n            \n            if possible and current_sum < n:\n                low = mid_k + 1\n            else: # current_sum > n or overflow occurred\n                high = mid_k - 1\n\n    print(\"NO\")\n\n\nnum_test_cases = int(input())\nfor _ in range(num_test_cases):\n    solve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 559,
        "completion_token_count": 6324,
        "thoughts_token_count": 822
    }
}