{
    "start": 1758294869.698418,
    "end": 1758294947.3953822,
    "start-formatted": "2025-09-20 00:14 KST",
    "end-formatted": "2025-09-20 00:15 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "**The Plan for Tackling a Tricky Programming Puzzle**\n\nI'm aiming to crack a competitive programming problem that boils down to understanding and constructing special directed graphs. My mission is twofold: First, determine the smallest number of nodes (`n`) needed to build a directed graph with a specific property (`p`-reachable). Second, I need to figure out the maximum number of \"unidirectional pairs\" possible within any such optimally constructed graph.\n\nLet's dissect the terms. A \"unidirectional pair\" means a one-way street between two nodes, while \"reachable from each other\" implies a round trip. A \"p-reachable graph\" is one that has precisely `p` pairs of nodes (where the first node's index is smaller than the second) that are reachable from each other. My starting point is that any group of nodes forming a \"strongly connected component\" are inherently reachable from each other.\n\nThe core insight is that I'm trying to strategically arrange these strongly connected components to satisfy the `p`-reachable condition, while simultaneously maximizing the unidirectional relationships. To minimize the number of nodes, I need the components to be as large as possible. This is because the number of reachable pairs within a component grows quadratically with the number of nodes.\n\nI initially considered using dynamic programming, but I realized a greedy strategy could work. The goal is to represent `p` as a sum of triangular numbers (`k*(k-1)/2`) by choosing the most nodes possible. This approach, similar to a coin-changing problem, minimizes the number of nodes to achieve `p`. By always selecting the largest possible triangular number less than or equal to the remaining target (`p`), I'm building up the components as efficiently as possible. I implemented a dynamic programming solution to verify, but it was too slow.\n\nThen, to maximize the unidirectional pairs in the second part, I need to order the components so that there are one-way paths between them. To maximize this, I compute the sum of all possible product terms resulting from pairwise multiplication of the components. The strategy involves ordering components in a line, creating unidirectional connections between them. This is achieved by forming a total order out of the components, where the edges in the condensation graph go in a single direction. The formula for maximum unidirectional pairs then becomes a function of the total number of nodes and the sum of squared component sizes.\n\nMy greedy approach successfully tackles both parts of the problem.\n",
    "response": "The problem asks us to find two values for a given integer `p`:\n1. The minimum number of nodes `n` required to create a directed graph that has exactly `p` ordered pairs of nodes `(u, v)` such that `u < v` and `u` and `v` are reachable from each other.\n2. Among all such graphs with the minimum number of nodes `n`, the maximum possible number of unidirectional pairs of nodes. An ordered pair `(u, v)` is unidirectional if `u \\neq v`, there's a path from `u` to `v`, and no path from `v` to `u`.\n\nLet's analyze the conditions:\n\n**Pairs reachable from each other:**\nIf two nodes `u` and `v` are reachable from each other, they must belong to the same strongly connected component (SCC). Conversely, any two distinct nodes within the same SCC are reachable from each other.\nIf an SCC has `k` nodes, say `x_1, x_2, ..., x_k`, then for any pair `(x_i, x_j)` with `i \\neq j`, `x_i` and `x_j` are reachable from each other.\nThe problem counts ordered pairs `(u, v)` such that `u < v` and `u` and `v` are reachable from each other. If we label nodes `1` to `n`, then within an SCC of size `k`, there are `k * (k - 1) / 2` such pairs.\nLet `T(k) = k * (k - 1) / 2`. This is the number of pairs `(u, v)` with `u < v` that are mutually reachable, if they all belong to an SCC of size `k`.\nThe total number of such pairs `p` in a graph is the sum of `T(k_i)` for all SCCs `C_i` with size `k_i`. That is, `p = \\sum T(k_i)`.\nThe total number of nodes `n` is `\\sum k_i`.\n\n**Part 1: Minimum number of nodes `n`**\nWe need to find `k_1, k_2, ..., k_m` such that `\\sum T(k_i) = p` and `\\sum k_i` is minimized.\nTo minimize `\\sum k_i`, we should use `k_i` values that are as large as possible for the `T(k_i)` values. This is because `T(k)` grows quadratically with `k`, while `k` grows linearly. The ratio `k / T(k) = k / (k(k-1)/2) = 2 / (k-1)` decreases as `k` increases (for `k > 1`). This suggests a greedy approach:\nIteratively, as long as `p > 0`, find the largest `k` such that `T(k) \\le p`. Add this `k` to our total node count `n`, and subtract `T(k)` from `p`.\n\nAlgorithm for `n_min`:\n1. Initialize `n_min = 0` and an empty list `k_values` to store the sizes of the SCCs.\n2. While `p > 0`:\n   a. Find the largest integer `k` such that `T(k) = k * (k - 1) / 2 \\le p`.\n      This can be found by solving `k^2 - k - 2p \\le 0` for `k`. The positive root of `k^2 - k - 2p = 0` is `(1 + \\sqrt{1 + 8p}) / 2`. So, `k` must be less than or equal to this value. We can start with `k = \\lfloor (1 + \\sqrt{1 + 8p}) / 2 \\rfloor` and decrement `k` if `T(k) > p` (this happens if `1+8p` is not a perfect square, or due to floating point precision, or if `k=1` gives `T(1)=0` but we need `T(k) > 0` to reduce `p`).\n      A simpler way for small `p` (up to `2 \\cdot 10^5`) is to iterate `k` from `2` up to about `\\sqrt{2p}` (approx 632) and find the largest `k` such that `T(k) \\le p`. However, it's more efficient to use the quadratic formula directly.\n      Specifically, `k_val = int((1 + (1 + 8*p)**0.5) / 2)`. If `T(k_val) > p`, decrement `k_val` by 1. If `k_val` becomes `0` or `1` and `p > 0`, it means `p` must be `1`. In this case, `k_val` should be `2` (since `T(2)=1`).\n   b. Add `k` to `n_min`.\n   c. Add `k` to `k_values`.\n   d. Subtract `T(k)` from `p`.\n3. The final `n_min` is the minimum number of nodes.\n\n**Part 2: Maximum number of unidirectional pairs**\nTo maximize unidirectional pairs, we construct the graph by arranging the SCCs `C_1, C_2, ..., C_m` (with sizes `k_1, k_2, ..., k_m` as determined in Part 1) in a chain. That is, we add edges such that there is a path from `C_i` to `C_j` if and only if `i < j`. For example, add an edge from an arbitrary node in `C_i` to an arbitrary node in `C_{i+1}` for all `i=1, ..., m-1`.\nIn such a graph, for any `i < j`, any node `u \\in C_i` can reach any node `v \\in C_j`, but `v` cannot reach `u`. Thus, all `k_i * k_j` pairs `(u, v)` where `u \\in C_i` and `v \\in C_j` are unidirectional.\nThe total number of unidirectional pairs is `\\sum_{1 \\le i < j \\le m} k_i * k_j`.\nThis sum can be computed using the identity:\n`(\\sum k_i)^2 = \\sum k_i^2 + 2 \\sum_{i < j} k_i k_j`.\nSo, `\\sum_{i < j} k_i k_j = ((\\sum k_i)^2 - \\sum k_i^2) / 2`.\nSince `\\sum k_i = n_min`, the maximum number of unidirectional pairs is `(n_min^2 - \\sum k_i^2) / 2`.\n\n**Example Walkthroughs:**\n\n**p = 3:**\n1. `n_min = 0`, `k_values = []`. `p = 3`.\n2. Find `k` for `p=3`: `k_val = int((1 + (1 + 8*3)**0.5) / 2) = int((1 + 25**0.5) / 2) = int(3) = 3`.\n   `T(3) = 3 * 2 / 2 = 3`. `3 \\le 3`. So `k=3`.\n   `n_min = 0 + 3 = 3`.\n   `k_values = [3]`.\n   `p = 3 - 3 = 0`.\n3. `p` is 0, loop terminates. `n_min = 3`. `k_values = [3]`.\n4. Max unidirectional pairs:\n   `n_min = 3`. `\\sum k_i^2 = 3^2 = 9`.\n   Unidirectional pairs = `(3^2 - 9) / 2 = (9 - 9) / 2 = 0`.\nOutput: `3 0`.\n\n**p = 4:**\n1. `n_min = 0`, `k_values = []`. `p = 4`.\n2. Find `k` for `p=4`: `k_val = int((1 + (1 + 8*4)**0.5) / 2) = int((1 + 33**0.5) / 2) = int(3.37...) = 3`.\n   `T(3) = 3`. `3 \\le 4`. So `k=3`.\n   `n_min = 0 + 3 = 3`.\n   `k_values = [3]`.\n   `p = 4 - 3 = 1`.\n3. `p = 1`. Find `k` for `p=1`: `k_val = int((1 + (1 + 8*1)**0.5) / 2) = int((1 + 9**0.5) / 2) = int(2) = 2`.\n   `T(2) = 1 * 2 / 2 = 1`. `1 \\le 1`. So `k=2`.\n   `n_min = 3 + 2 = 5`.\n   `k_values = [3, 2]`.\n   `p = 1 - 1 = 0`.\n4. `p` is 0, loop terminates. `n_min = 5`. `k_values = [3, 2]`.\n5. Max unidirectional pairs:\n   `n_min = 5`. `\\sum k_i^2 = 3^2 + 2^2 = 9 + 4 = 13`.\n   Unidirectional pairs = `(5^2 - 13) / 2 = (25 - 13) / 2 = 12 / 2 = 6`.\nOutput: `5 6`.\n\n**p = 0:**\n1. `n_min = 0`, `k_values = []`. `p = 0`.\n2. `p` is 0, loop terminates immediately. `n_min = 0`. `k_values = []`.\n3. Max unidirectional pairs:\n   `n_min = 0`. `\\sum k_i^2 = 0`.\n   Unidirectional pairs = `(0^2 - 0) / 2 = 0`.\nOutput: `0 0`.\n\nThe approach is efficient. The `while` loop runs `O(\\sqrt{P})` times, and each iteration involves a constant number of arithmetic operations (including `sqrt`). Total time complexity is `O(\\sqrt{P})`. For `P = 2 \\cdot 10^5`, `\\sqrt{P} \\approx 447`, which is very fast.\n\n```python\nimport math\n\ndef solve():\n    p = int(input())\n\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    min_nodes = 0\n    k_values = []\n\n    current_p = p\n    while current_p > 0:\n        # Find largest k such that k * (k - 1) / 2 <= current_p\n        # k^2 - k - 2*current_p <= 0\n        # Roots of k^2 - k - 2*current_p = 0 are (1 +/- sqrt(1 + 8*current_p)) / 2\n        # We want the positive root, so k <= (1 + sqrt(1 + 8*current_p)) / 2\n        \n        # Calculate k using the quadratic formula.\n        # It's an integer, so we need to be careful with floor/ceil.\n        # int() truncates, so it's floor.\n        # If (1 + sqrt(1 + 8*current_p)) / 2 is exactly k, then int() works.\n        # If it's k.something, int() gives k.\n        # If it's k.000...001, int() gives k.\n        # But if it's k.999...999 due to float precision, int() gives k-1.\n        # Also, if T(k) is exactly current_p, we want k.\n        # We need the largest k such that T(k) <= current_p.\n        \n        # A robust way: calculate k using the formula, then check and adjust.\n        # The formula gives an upper bound for k.\n        k_val_float = (1 + math.sqrt(1 + 8 * current_p)) / 2\n        k_val = int(k_val_float)\n\n        # Ensure T(k_val) does not exceed current_p.\n        # In rare cases due to float precision or if k_val_float was slightly above an integer,\n        # k_val might be too high.\n        while k_val * (k_val - 1) // 2 > current_p:\n            k_val -= 1\n        \n        # Ensure k_val is at least 2 if current_p > 0, because T(1)=0.\n        # If current_p is 1, T(2)=1, so k_val should be 2.\n        # If current_p is 0, k_val will be 1, but loop condition handles it.\n        if k_val < 2 and current_p > 0:\n            # This case should only happen if current_p is 1, and k_val was computed as 1\n            # (e.g., if 1+8*1=9, sqrt(9)=3, (1+3)/2=2, so k_val would be 2.\n            #  This check is mostly for robustness or if current_p is 0, which is handled by loop).\n            #  However, if current_p is 1, k_val should be 2 because T(2)=1.\n            # The previous calculation `k_val = int((1 + math.sqrt(1 + 8 * current_p)) / 2)`\n            # correctly gives 2 for current_p=1. So this branch might not be strictly needed for k_val=1.\n            # Let's keep it simple: just decrement if T(k_val) too large.\n            # If current_p is 1, k_val will be 2. T(2)=1.\n            # If current_p is 0, loop terminates.\n            pass # The logic derived from the formula seems to handle this correctly.\n\n        # Add k_val to total nodes and store it\n        min_nodes += k_val\n        k_values.append(k_val)\n        \n        # Subtract the pairs contributed by this SCC\n        current_p -= k_val * (k_val - 1) // 2\n\n    # Calculate maximum unidirectional pairs\n    sum_k_squared = sum(k*k for k in k_values)\n    max_unidirectional_pairs = (min_nodes * min_nodes - sum_k_squared) // 2\n\n    print(min_nodes, max_unidirectional_pairs)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef solve():\n    p = int(input())\n\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    min_nodes = 0\n    k_values = []\n\n    current_p = p\n    while current_p > 0:\n        # Find largest k such that k * (k - 1) / 2 <= current_p\n        # k^2 - k - 2*current_p <= 0\n        # Roots of k^2 - k - 2*current_p = 0 are (1 +/- sqrt(1 + 8*current_p)) / 2\n        # We want the positive root, so k <= (1 + sqrt(1 + 8*current_p)) / 2\n        \n        # Calculate k using the quadratic formula.\n        # It's an integer, so we need to be careful with floor/ceil.\n        # int() truncates, so it's floor.\n        # If (1 + sqrt(1 + 8*current_p)) / 2 is exactly k, then int() works.\n        # If it's k.something, int() gives k.\n        # If it's k.000...001, int() gives k.\n        # But if it's k.999...999 due to float precision, int() gives k-1.\n        # Also, if T(k) is exactly current_p, we want k.\n        # We need the largest k such that T(k) <= current_p.\n        \n        # A robust way: calculate k using the formula, then check and adjust.\n        # The formula gives an upper bound for k.\n        k_val_float = (1 + math.sqrt(1 + 8 * current_p)) / 2\n        k_val = int(k_val_float)\n\n        # Ensure T(k_val) does not exceed current_p.\n        # In rare cases due to float precision or if k_val_float was slightly above an integer,\n        # k_val might be too high.\n        while k_val * (k_val - 1) // 2 > current_p:\n            k_val -= 1\n        \n        # Ensure k_val is at least 2 if current_p > 0, because T(1)=0.\n        # If current_p is 1, T(2)=1, so k_val should be 2.\n        # If current_p is 0, k_val will be 1, but loop condition handles it.\n        if k_val < 2 and current_p > 0:\n            # This case should only happen if current_p is 1, and k_val was computed as 1\n            # (e.g., if 1+8*1=9, sqrt(9)=3, (1+3)/2=2, so k_val would be 2.\n            #  This check is mostly for robustness or if current_p is 0, which is handled by loop).\n            #  However, if current_p is 1, k_val should be 2 because T(2)=1.\n            # The previous calculation `k_val = int((1 + math.sqrt(1 + 8 * current_p)) / 2)`\n            # correctly gives 2 for current_p=1. So this branch might not be strictly needed for k_val=1.\n            # Let's keep it simple: just decrement if T(k_val) too large.\n            # If current_p is 1, k_val will be 2. T(2)=1.\n            # If current_p is 0, loop terminates.\n            pass # The logic derived from the formula seems to handle this correctly.\n\n        # Add k_val to total nodes and store it\n        min_nodes += k_val\n        k_values.append(k_val)\n        \n        # Subtract the pairs contributed by this SCC\n        current_p -= k_val * (k_val - 1) // 2\n\n    # Calculate maximum unidirectional pairs\n    sum_k_squared = sum(k*k for k in k_values)\n    max_unidirectional_pairs = (min_nodes * min_nodes - sum_k_squared) // 2\n\n    print(min_nodes, max_unidirectional_pairs)\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 482,
        "completion_token_count": 3488,
        "thoughts_token_count": 8192
    }
}