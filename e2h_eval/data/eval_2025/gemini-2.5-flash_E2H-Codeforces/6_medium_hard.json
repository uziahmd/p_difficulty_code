{
    "start": 1758011743.0855007,
    "end": 1758011814.1166968,
    "start-formatted": "2025-09-16 17:35 KST",
    "end-formatted": "2025-09-16 17:36 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "**Reflecting on Voucher Pair Optimization**\n\nAlright, let's tackle this competitive programming challenge. We're tasked with finding two non-overlapping vouchers whose durations sum to a target `x`, minimizing their combined cost.  The constraints are manageable: up to 2 * 10^5 vouchers, and coordinates up to that same value, so a quadratic solution is a no-go. We need something more efficient.\n\nMy initial thought was a brute-force approach, iterating through all voucher pairs, but that was quickly dismissed. We needed a strategy.  We can represent the vouchers as intervals and exploit the disjointness condition (`r_i < l_j` or `r_j < l_i`). The sum of durations and minimizing cost are straightforward requirements.\n\nAfter some contemplation, I realized that sorting by start time or end time might reveal some structure, but it still didn't lead directly to an efficient algorithm. I played with the idea of iterating through each voucher and searching for a compatible one, but querying for that compatible voucher remained a problem.\n\nThe key insight was to consider a \"sweep-line\" approach across the day axis, thinking in terms of what vouchers *end* and *start* on a given day.  This led to the idea of maintaining a data structure (`min_cost_for_duration`) that stores the minimum cost of a voucher with a specific duration that has *already ended*.\n\nSpecifically, the approach involves:\n\n1.  **Sorting or grouping**: Group the vouchers based on their start and end dates.\n2.  **Sweep and Query**:\n    *   Iterate through each day.\n    *   For vouchers *starting* on the current day, we calculate the required complementary duration, then query our `min_cost_for_duration` array (vouchers ending *before* this day) to find the minimum cost for this \"complementary\" voucher.\n    *   For vouchers *ending* on this day, we update our `min_cost_for_duration` array with the cost of that voucher, which then becomes available as a candidate for vouchers that will begin in subsequent days.\n3.  **Result**: Our `min_cost_for_duration` array is initialized with infinity. We process each voucher, looking for the minimum combined cost using the `min_cost_for_duration` array. If no valid pair is found, we return -1.\n\nThis strategy requires `O(N+M)` time and space where N is the number of vouchers and M is the maximum coordinate value, resulting in an O(N) solution. The sweep-line technique seems optimal given the constraints, and the algorithm is a good fit. I'm confident in this approach.\n",
    "response": "The problem asks us to find two distinct, non-overlapping vouchers `i` and `j` such that the sum of their durations is exactly `x`, and their total cost `cost_i + cost_j` is minimized. If no such pair exists, we should output -1.\n\nLet `(l_k, r_k, cost_k)` be the start day, end day, and cost of voucher `k`. The duration of voucher `k` is `d_k = r_k - l_k + 1`.\n\nTwo vouchers `i` and `j` are non-overlapping if `r_i < l_j` or `r_j < l_i`.\nWithout loss of generality, let's assume `r_i < l_j`. This means voucher `i` must end before voucher `j` begins.\n\nThe core idea is to use a sweep-line algorithm. We iterate through each day from 1 up to the maximum possible end day (`MAX_COORD = 2 * 10^5`). As we sweep through the days, we maintain information about vouchers that have already ended.\n\nWe'll use an array, `min_cost_for_duration`, where `min_cost_for_duration[d]` stores the minimum cost of a voucher that has duration `d` and has already finished by the current day.\n\nHere's the detailed sweep-line approach:\n\n1.  **Data Structures:**\n    *   `MAX_COORD`: The maximum possible value for `l_i` or `r_i` (given as `2 * 10^5`).\n    *   `vouchers_by_start`: A list of lists (or array of lists) where `vouchers_by_start[day]` stores all vouchers that start on `day`. Each voucher is stored as `(r, cost, duration)`.\n    *   `vouchers_by_end`: Similar to `vouchers_by_start`, but `vouchers_by_end[day]` stores all vouchers that end on `day`. Each voucher is stored as `(l, cost, duration)`.\n    *   `min_cost_for_duration`: An array of size `MAX_COORD + 1`, initialized with `infinity`. `min_cost_for_duration[d]` will store the minimum cost of a voucher with duration `d` that has *already ended* by the current sweep line day.\n    *   `min_total_cost`: A variable initialized to `infinity` to store the overall minimum combined cost found.\n\n2.  **Preprocessing Input:**\n    *   Read `n` and `x`.\n    *   For each voucher `(l_i, r_i, cost_i)`:\n        *   Calculate its duration `d_i = r_i - l_i + 1`.\n        *   Add `(r_i, cost_i, d_i)` to `vouchers_by_start[l_i]`.\n        *   Add `(l_i, cost_i, d_i)` to `vouchers_by_end[r_i]`.\n\n3.  **Sweep Line:**\n    *   Iterate `day` from `1` to `MAX_COORD`.\n    *   **Step A: Process vouchers starting on `day` (potential `v_j` candidates):**\n        For each voucher `v_j = (r_j, cost_j, duration_j)` in `vouchers_by_start[day]`:\n        *   We need to find a `v_i` such that `r_i < l_j` (i.e., `r_i < day`) and `d_i + d_j = x`.\n        *   The required duration for `v_i` is `needed_duration_i = x - duration_j`.\n        *   If `needed_duration_i` is a valid duration (i.e., `1 <= needed_duration_i <= MAX_COORD`):\n            *   Check `min_cost_for_duration[needed_duration_i]`. If it's not `infinity`, it means there's at least one voucher `v_i` that ended *before* `day` with `needed_duration_i` and `min_cost_for_duration[needed_duration_i]` is its minimum cost.\n            *   Update `min_total_cost = min(min_total_cost, cost_j + min_cost_for_duration[needed_duration_i])`.\n\n    *   **Step B: Update `min_cost_for_duration` with vouchers ending on `day` (potential `v_i` candidates for future `v_j`):**\n        For each voucher `v_k = (l_k, cost_k, duration_k)` in `vouchers_by_end[day]`:\n        *   This voucher `v_k` has just ended on `day`. It can now be considered as `v_i` for any `v_j` that starts on `day + 1` or later.\n        *   Update `min_cost_for_duration[duration_k] = min(min_cost_for_duration[duration_k], cost_k)`.\n\n4.  **Result:**\n    *   After the loop finishes, if `min_total_cost` is still `infinity`, it means no valid pair of vouchers was found. Print -1.\n    *   Otherwise, print `min_total_cost`.\n\n**Complexity Analysis:**\n*   **Time Complexity:**\n    *   Preprocessing: `O(N)` to iterate through all vouchers and add them to `vouchers_by_start` and `vouchers_by_end`.\n    *   Sweep Line: The loop runs `MAX_COORD` times.\n        *   Step A: Each voucher is processed once when its `l_i` matches `day`. Total `O(N)` over all days.\n        *   Step B: Each voucher is processed once when its `r_i` matches `day`. Total `O(N)` over all days.\n    *   Total time complexity: `O(N + MAX_COORD)`. Given `N, MAX_COORD <= 2 * 10^5`, this is efficient enough.\n*   **Space Complexity:**\n    *   `vouchers_by_start` and `vouchers_by_end` store `N` vouchers in total: `O(N)`.\n    *   `min_cost_for_duration` array: `O(MAX_COORD)`.\n    *   Total space complexity: `O(N + MAX_COORD)`.\n\n```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n\n    # Max coordinate value for l_i, r_i is 2 * 10^5\n    MAX_COORD = 2 * 10**5\n\n    # vouchers_by_start[d] stores (r, cost, duration) for vouchers starting on day d\n    vouchers_by_start = [[] for _ in range(MAX_COORD + 1)]\n    # vouchers_by_end[d] stores (l, cost, duration) for vouchers ending on day d\n    vouchers_by_end = [[] for _ in range(MAX_COORD + 1)]\n\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        duration = r - l + 1\n        vouchers_by_start[l].append((r, cost, duration))\n        vouchers_by_end[r].append((l, cost, duration))\n\n    # min_cost_for_duration[d] stores the minimum cost of a voucher with duration 'd'\n    # that has ended by the current sweep-line day.\n    # Initialize with infinity, as no vouchers have ended yet.\n    min_cost_for_duration = [float('inf')] * (MAX_COORD + 1)\n\n    min_total_cost = float('inf')\n\n    # Sweep through each day from 1 to MAX_COORD\n    for day in range(1, MAX_COORD + 1):\n        # Step 1: Process vouchers starting on 'day'\n        # These are potential second vouchers (v_j) in a pair (v_i, v_j) where r_i < l_j.\n        # We look for a v_i that ended before 'day' (r_i < day).\n        for r_j, cost_j, duration_j in vouchers_by_start[day]:\n            needed_duration_i = x - duration_j\n            \n            # Check if needed_duration_i is valid (positive and within bounds)\n            if 1 <= needed_duration_i <= MAX_COORD:\n                # If a voucher v_i with needed_duration_i has ended before 'day',\n                # min_cost_for_duration[needed_duration_i] will not be infinity.\n                if min_cost_for_duration[needed_duration_i] != float('inf'):\n                    min_total_cost = min(min_total_cost, cost_j + min_cost_for_duration[needed_duration_i])\n\n        # Step 2: Update min_cost_for_duration with vouchers ending on 'day'\n        # These vouchers can now serve as v_i for future vouchers v_j that start on 'day + 1' or later.\n        for l_k, cost_k, duration_k in vouchers_by_end[day]:\n            min_cost_for_duration[duration_k] = min(min_cost_for_duration[duration_k], cost_k)\n\n    if min_total_cost == float('inf'):\n        sys.stdout.write(\"-1\\n\")\n    else:\n        sys.stdout.write(str(min_total_cost) + \"\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n\n    # Max coordinate value for l_i, r_i is 2 * 10^5\n    MAX_COORD = 2 * 10**5\n\n    # vouchers_by_start[d] stores (r, cost, duration) for vouchers starting on day d\n    vouchers_by_start = [[] for _ in range(MAX_COORD + 1)]\n    # vouchers_by_end[d] stores (l, cost, duration) for vouchers ending on day d\n    vouchers_by_end = [[] for _ in range(MAX_COORD + 1)]\n\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        duration = r - l + 1\n        vouchers_by_start[l].append((r, cost, duration))\n        vouchers_by_end[r].append((l, cost, duration))\n\n    # min_cost_for_duration[d] stores the minimum cost of a voucher with duration 'd'\n    # that has ended by the current sweep-line day.\n    # Initialize with infinity, as no vouchers have ended yet.\n    min_cost_for_duration = [float('inf')] * (MAX_COORD + 1)\n\n    min_total_cost = float('inf')\n\n    # Sweep through each day from 1 to MAX_COORD\n    for day in range(1, MAX_COORD + 1):\n        # Step 1: Process vouchers starting on 'day'\n        # These are potential second vouchers (v_j) in a pair (v_i, v_j) where r_i < l_j.\n        # We look for a v_i that ended before 'day' (r_i < day).\n        for r_j, cost_j, duration_j in vouchers_by_start[day]:\n            needed_duration_i = x - duration_j\n            \n            # Check if needed_duration_i is valid (positive and within bounds)\n            if 1 <= needed_duration_i <= MAX_COORD:\n                # If a voucher v_i with needed_duration_i has ended before 'day',\n                # min_cost_for_duration[needed_duration_i] will not be infinity.\n                if min_cost_for_duration[needed_duration_i] != float('inf'):\n                    min_total_cost = min(min_total_cost, cost_j + min_cost_for_duration[needed_duration_i])\n\n        # Step 2: Update min_cost_for_duration with vouchers ending on 'day'\n        # These vouchers can now serve as v_i for future vouchers v_j that start on 'day + 1' or later.\n        for l_k, cost_k, duration_k in vouchers_by_end[day]:\n            min_cost_for_duration[duration_k] = min(min_cost_for_duration[duration_k], cost_k)\n\n    if min_total_cost == float('inf'):\n        sys.stdout.write(\"-1\\n\")\n    else:\n        sys.stdout.write(str(min_total_cost) + \"\\n\")\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 798,
        "completion_token_count": 2239,
        "thoughts_token_count": 4738
    }
}