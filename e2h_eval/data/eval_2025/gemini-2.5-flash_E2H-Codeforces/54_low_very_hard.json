{
    "start": 1758284880.2708924,
    "end": 1758284896.3007483,
    "start-formatted": "2025-09-19 21:28 KST",
    "end-formatted": "2025-09-19 21:28 KST",
    "gpu": 2,
    "pid": 54,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mister B and Angle in Polygon\n\nOn one quiet day all of sudden Mister B decided to draw angle a on his field. Aliens have already visited his field and left many different geometric figures on it. One of the figures is regular convex n-gon (regular convex polygon with n sides).That's why Mister B decided to use this polygon. Now Mister B must find three distinct vertices v1, v2, v3 such that the angle  (where v2 is the vertex of the angle, and v1 and v3 lie on its sides) is as close as possible to a. In other words, the value  should be minimum possible.If there are many optimal solutions, Mister B should be satisfied with any of them.\n\n## Input\nFirst and only line contains two space-separated integers n and a (3 ≤ n ≤ 105, 1 ≤ a ≤ 180) — the number of vertices in the polygon and the needed angle, in degrees.\n\n## Output\nPrint three space-separated integers: the vertices v1, v2, v3, which form . If there are multiple optimal solutions, print any of them. The vertices are numbered from 1 to n in clockwise order.\n\n## Example\n### Input\n['3 15', '4 67', '4 68']\n\n### Output\n['1 2 3', '2 1 3', '4 1 2']\n\n## Note\nIn first sample test vertices of regular triangle can create only angle of 60 degrees, that's why every possible angle is correct.Vertices of square can create 45 or 90 degrees angles only. That's why in second sample test the angle of 45 degrees was chosen, since |45 - 67| < |90 - 67|. Other correct answers are: \"3 1 2\", \"3 2 4\", \"4 2 3\", \"4 3 1\", \"1 3 4\", \"1 4 2\", \"2 4 1\", \"4 1 3\", \"3 1 4\", \"3 4 2\", \"2 4 3\", \"2 3 1\", \"1 3 2\", \"1 2 4\", \"4 2 1\".In third sample test, on the contrary, the angle of 90 degrees was chosen, since |90 - 68| < |45 - 68|. Other correct answers are: \"2 1 4\", \"3 2 1\", \"1 2 3\", \"4 3 2\", \"2 3 4\", \"1 4 3\", \"3 4 1\".\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "**Problem Breakdown & Approach**\n\nOkay, so I'm looking at this \"Mister B and Angle in Polygon\" problem. It's a classic computational geometry problem. The core idea is this: I'm given a regular *n*-gon and a target angle *a*. I need to find three vertices of the polygon that form an angle as close as possible to *a*. The catch? I need to give the *indices* of these vertices.\n\nMy first thought is to dig into the geometry of regular polygons. I know a few things instinctively: each side subtends an equal central angle (360/n). The internal angle of a regular polygon is (n-2)*180/n. But this problem deals with *inscribed* angles, not interior angles.\n\nThen it hits me: inscribed angles are related to the *central* angle they subtend. Specifically, the inscribed angle is half of the central angle subtended by the same arc. That's the key!\n\nI can fix one vertex, say vertex 2, as the vertex of the angle I want to calculate. I can also fix another vertex to be vertex 1, meaning now I want to vary the third vertex, say *k*.  The important part is the arc between vertex 1 and vertex *k*. The number of sides that make up this arc will be `k-1`. Each side subtends a central angle of 360/n, so the central angle for arc 1-k is (k-1) * (360/n).  Thus, the inscribed angle is half of that: (k-1) * (180/n).\n\nSo there you have it: the angle formed by vertices 1, 2, and *k* (angle 1-2-k), is given by the formula (k-1) * (180/n). This is the foundation I need to solve this. Next is to figure out the code part.\n",
    "response": "```python\nimport sys\n\ndef solve():\n    n, a = map(int, sys.stdin.readline().split())\n\n    # We can fix v2 as vertex 2 and v1 as vertex 1 due to symmetry.\n    # Then v3 will be some vertex k, where k ranges from 3 to n.\n    # The angle formed by (1, 2, k) is an inscribed angle subtending the arc from 1 to k.\n    # The number of segments in the arc from 1 to k (not passing through 2) is k-1.\n    # Each segment subtends a central angle of 360/n degrees.\n    # The central angle for k-1 segments is (k-1) * 360/n.\n    # The inscribed angle is half of the central angle: (k-1) * 180/n.\n    # Let's denote this angle by `current_angle`.\n    # k must be distinct from 1 and 2. So k goes from 3 to n.\n    # This means (k-1) goes from 2 to n-1.\n    # So the number of segments 's' can be any integer from 2 to n-1.\n    # The possible angles are s * (180/n) for s = 2, 3, ..., n-1.\n\n    # We need to find 's' (from 2 to n-1) such that |s * (180/n) - a| is minimized.\n    # This is equivalent to finding 's' such that |s - a * (n/180)| is minimized.\n    # Let target_s = a * (n/180).\n    # We are looking for an integer 's' in the range [2, n-1] closest to target_s.\n\n    # Calculate the target number of segments.\n    # Using float for target_s to find the closest integer.\n    target_s_float = a * n / 180.0\n\n    # The closest integers to target_s_float are floor(target_s_float) and ceil(target_s_float).\n    # Let's check s1 = floor(target_s_float) and s2 = ceil(target_s_float).\n    # We must also ensure that s1 and s2 are within the valid range [2, n-1].\n\n    best_diff = float('inf')\n    best_s = -1\n\n    # Candidate 1: floor(target_s_float)\n    s_candidate1 = int(target_s_float)\n    if 2 <= s_candidate1 <= n - 1:\n        current_angle = s_candidate1 * 180.0 / n\n        diff = abs(current_angle - a)\n        if diff < best_diff:\n            best_diff = diff\n            best_s = s_candidate1\n\n    # Candidate 2: ceil(target_s_float)\n    s_candidate2 = int(target_s_float) + 1\n    if 2 <= s_candidate2 <= n - 1:\n        current_angle = s_candidate2 * 180.0 / n\n        diff = abs(current_angle - a)\n        # If diff is strictly smaller, update.\n        # If diff is equal, we can choose either. The problem says \"any of them\".\n        # Since we check floor first, if there's a tie, s_candidate1 (closer to floor) will be preferred\n        # or it will keep the current best_s.\n        # This is fine as any optimal solution is accepted.\n        if diff < best_diff:\n            best_diff = diff\n            best_s = s_candidate2\n\n    # Edge case: If n=3, the only possible s is 2.\n    # The angle is 2 * 180/3 = 120 (interior angle) / 2 = 60.\n    # The range for s is [2, n-1]. If n=3, range is [2, 2]. So s=2 is the only choice.\n    # Our logic above handles this: if target_s_float is, say, 1.5, floor is 1 (invalid), ceil is 2 (valid).\n    # If target_s_float is, say, 2.5, floor is 2 (valid), ceil is 3 (invalid).\n    # So the `if 2 <= s_candidate <= n - 1` checks correctly handle the range.\n\n    # If best_s is still -1, it means no valid 's' was found in the range [2, n-1].\n    # This should not happen for n >= 3, as 's=2' (angle 2*180/n) is always a valid choice.\n    # For n=3, s=2 is the only choice.\n    # For n > 3, s=2 is always valid, and n-1 is also valid (n-1 >= 3).\n    # So best_s will always be updated.\n\n    # Now we have the optimal `best_s`.\n    # v2 is vertex 2.\n    # v1 is vertex 1.\n    # v3 is vertex k such that k-1 = best_s. So k = best_s + 1.\n\n    # Output vertices: v1, v2, v3\n    print(1, 2, best_s + 1)\n\nsolve()\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, a = map(int, sys.stdin.readline().split())\n\n    # We can fix v2 as vertex 2 and v1 as vertex 1 due to symmetry.\n    # Then v3 will be some vertex k, where k ranges from 3 to n.\n    # The angle formed by (1, 2, k) is an inscribed angle subtending the arc from 1 to k.\n    # The number of segments in the arc from 1 to k (not passing through 2) is k-1.\n    # Each segment subtends a central angle of 360/n degrees.\n    # The central angle for k-1 segments is (k-1) * 360/n.\n    # The inscribed angle is half of the central angle: (k-1) * 180/n.\n    # Let's denote this angle by `current_angle`.\n    # k must be distinct from 1 and 2. So k goes from 3 to n.\n    # This means (k-1) goes from 2 to n-1.\n    # So the number of segments 's' can be any integer from 2 to n-1.\n    # The possible angles are s * (180/n) for s = 2, 3, ..., n-1.\n\n    # We need to find 's' (from 2 to n-1) such that |s * (180/n) - a| is minimized.\n    # This is equivalent to finding 's' such that |s - a * (n/180)| is minimized.\n    # Let target_s = a * (n/180).\n    # We are looking for an integer 's' in the range [2, n-1] closest to target_s.\n\n    # Calculate the target number of segments.\n    # Using float for target_s to find the closest integer.\n    target_s_float = a * n / 180.0\n\n    # The closest integers to target_s_float are floor(target_s_float) and ceil(target_s_float).\n    # Let's check s1 = floor(target_s_float) and s2 = ceil(target_s_float).\n    # We must also ensure that s1 and s2 are within the valid range [2, n-1].\n\n    best_diff = float('inf')\n    best_s = -1\n\n    # Candidate 1: floor(target_s_float)\n    s_candidate1 = int(target_s_float)\n    if 2 <= s_candidate1 <= n - 1:\n        current_angle = s_candidate1 * 180.0 / n\n        diff = abs(current_angle - a)\n        if diff < best_diff:\n            best_diff = diff\n            best_s = s_candidate1\n\n    # Candidate 2: ceil(target_s_float)\n    s_candidate2 = int(target_s_float) + 1\n    if 2 <= s_candidate2 <= n - 1:\n        current_angle = s_candidate2 * 180.0 / n\n        diff = abs(current_angle - a)\n        # If diff is strictly smaller, update.\n        # If diff is equal, we can choose either. The problem says \"any of them\".\n        # Since we check floor first, if there's a tie, s_candidate1 (closer to floor) will be preferred\n        # or it will keep the current best_s.\n        # This is fine as any optimal solution is accepted.\n        if diff < best_diff:\n            best_diff = diff\n            best_s = s_candidate2\n\n    # Edge case: If n=3, the only possible s is 2.\n    # The angle is 2 * 180/3 = 120 (interior angle) / 2 = 60.\n    # The range for s is [2, n-1]. If n=3, range is [2, 2]. So s=2 is the only choice.\n    # Our logic above handles this: if target_s_float is, say, 1.5, floor is 1 (invalid), ceil is 2 (valid).\n    # If target_s_float is, say, 2.5, floor is 2 (valid), ceil is 3 (invalid).\n    # So the `if 2 <= s_candidate <= n - 1` checks correctly handle the range.\n\n    # If best_s is still -1, it means no valid 's' was found in the range [2, n-1].\n    # This should not happen for n >= 3, as 's=2' (angle 2*180/n) is always a valid choice.\n    # For n=3, s=2 is the only choice.\n    # For n > 3, s=2 is always valid, and n-1 is also valid (n-1 >= 3).\n    # So best_s will always be updated.\n\n    # Now we have the optimal `best_s`.\n    # v2 is vertex 2.\n    # v1 is vertex 1.\n    # v3 is vertex k such that k-1 = best_s. So k = best_s + 1.\n\n    # Output vertices: v1, v2, v3\n    print(1, 2, best_s + 1)\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 739,
        "completion_token_count": 1263,
        "thoughts_token_count": 821
    }
}