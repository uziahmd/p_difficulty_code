{
    "start": 1758284979.9015465,
    "end": 1758285073.8023133,
    "start-formatted": "2025-09-19 21:29 KST",
    "end-formatted": "2025-09-19 21:31 KST",
    "gpu": 2,
    "pid": 28,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vasily the Bear and Beautiful Strings\n\nVasily the Bear loves beautiful strings. String s is beautiful if it meets the following criteria:   String s only consists of characters 0 and 1, at that character 0 must occur in string s exactly n times, and character 1 must occur exactly m times.  We can obtain character g from string s with some (possibly, zero) number of modifications. The character g equals either zero or one. A modification of string with length at least two is the following operation: we replace two last characters from the string by exactly one other character. This character equals one if it replaces two zeros, otherwise it equals zero. For example, one modification transforms string \"01010\" into string \"0100\", two modifications transform it to \"011\". It is forbidden to modify a string with length less than two.Help the Bear, count the number of beautiful strings. As the number of beautiful strings can be rather large, print the remainder after dividing the number by 1000000007 (109 + 7). \n\n## Input\nThe first line of the input contains three space-separated integers n, m, g (0 ≤ n, m ≤ 105, n + m ≥ 1, 0 ≤ g ≤ 1).\n\n## Output\nPrint a single integer — the answer to the problem modulo 1000000007 (109 + 7).\n\n## Example\n### Input\n['1 1 0', '2 2 0', '1 1 1']\n\n### Output\n['2', '4', '0']\n\n## Note\nIn the first sample the beautiful strings are: \"01\", \"10\".In the second sample the beautiful strings are: \"0011\", \"1001\", \"1010\", \"1100\".In the third sample there are no beautiful strings.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "**Diving Deep into Beautiful Strings**\n\nOkay, so I'm looking at this \"beautiful string\" problem, and my immediate goal is to devise a Python script to count these things. The definition is pretty straightforward: strings made up of '0's and '1's, with a specific count of each, that can be whittled down to a single character through some modifications.  The core of the problem, really, lies in that modification rule and how it impacts the structure of these strings.\n\nThe modification itself seems straightforward at first glance – replace the last two characters based on a specific set of rules. However, I need to pay close attention to the order of operations; it specifies that the replacements happen from right to left, which is crucial.  This implies a form of reduction from the end.  I'm representing this with `op(x, y)`, where `y` is the rightmost character and `x` is the one to its immediate left.\n\nI started by trying to relate this `op` to familiar binary operations like XOR, but it quickly became apparent that it wasn't a direct match.  Then it hit me: the parity of the number of '1's might be key here.  I started tracking how the parity changes with each application of `op`. This is where it got interesting.  The changes in parity when we replace two characters look promising. If I let `P(s)` be the parity of the number of ones in string `s`, I can track how P changes. This looks like a critical part of the puzzle.  I need to dig deeper into the implications of this parity shift.\n",
    "response": "The problem asks us to count the number of binary strings with `n` zeros and `m` ones that can be reduced to a single character `g` (either '0' or '1') using a specific modification rule. The modification rule is: replace the two last characters `xy` with a new character `z`. `z` is '1' if `xy` is \"00\", and '0' otherwise (\"01\", \"10\", \"11\"). This operation is performed repeatedly until a single character remains.\n\nLet's analyze the modification rule `op(x, y)`:\n`op(0, 0) = 1`\n`op(0, 1) = 0`\n`op(1, 0) = 0`\n`op(1, 1) = 0`\n\nLet's observe the effect of this operation on the parity of the number of '1's in the string.\nSuppose a string `S` has `k` ones. When we replace `x, y` with `op(x, y)`:\n- If `x=0, y=0`: The number of ones changes from `k` to `k+1`. The parity flips.\n- If `x=0, y=1`: The number of ones changes from `k` to `k-1`. The parity flips.\n- If `x=1, y=0`: The number of ones changes from `k` to `k-1`. The parity flips.\n- If `x=1, y=1`: The number of ones changes from `k` to `k-2`. The parity remains the same.\n\nThis means that if we apply the operation `op(x, y)` where `x, y` are the last two characters of a string `S`, and `S'` is the resulting string, then `(num_ones(S) % 2)` is generally *not* equal to `(num_ones(S') % 2)`. This property is tricky.\n\nHowever, consider the effect on the character `1`. The only way to produce a `1` is from `00`. If there are any `1`s in the string, or if `00` is not the pair being reduced, the result is `0`.\n\nLet's re-examine the operation `op(x,y)`. It's equivalent to `(x + y + 1) % 2` if we interpret `0` as `0` and `1` as `1`.\n`op(0,0) = (0+0+1)%2 = 1`\n`op(0,1) = (0+1+1)%2 = 0`\n`op(1,0) = (1+0+1)%2 = 0`\n`op(1,1) = (1+1+1)%2 = 1`\nWait, this is not the rule given. The rule given is `op(1,1)=0`. So `(x+y+1)%2` is incorrect.\n\nThe rule `op(x,y)` is `1` if `x=0, y=0`, and `0` otherwise.\nThis is exactly equivalent to `NOT (x OR y)` if we interpret `0` as `false` and `1` as `true`.\n`op(0,0) = NOT (false OR false) = NOT false = true = 1`\n`op(0,1) = NOT (false OR true) = NOT true = false = 0`\n`op(1,0) = NOT (true OR false) = NOT true = false = 0`\n`op(1,1) = NOT (true OR true) = NOT true = false = 0`\nThis is the correct interpretation.\n\nLet's denote the operation as `f(x, y) = NOT (x OR y)`.\nWhen we reduce a string `s_1 s_2 ... s_k` from right to left, we get:\n`f(s_1, f(s_2, ..., f(s_{k-1}, s_k)...))`\nThis is `s_1 NAND s_2 NAND ... NAND s_k` if we consider `NAND` as `NOT (x AND y)`.\nNo, this is not NAND either. The operation is `NOT (x OR y)`.\nLet's call this operation `NOR`. So `f(x, y) = x NOR y`.\nThe final character obtained from `s_1 s_2 ... s_k` is `s_1 NOR (s_2 NOR (... NOR (s_{k-1} NOR s_k)...))`.\nThis operation is not associative, so the order matters. The problem states \"replace two last characters\", which implies a fixed reduction order.\n\nLet `R(s)` be the final character obtained from string `s`.\n`R(s_1 s_2 ... s_k) = s_1 NOR R(s_2 ... s_k)`.\nLet's see the truth table for `x NOR y`:\n`0 NOR 0 = 1`\n`0 NOR 1 = 0`\n`1 NOR 0 = 0`\n`1 NOR 1 = 0`\n\nConsider the value of `R(s)` based on the number of `1`s in `s`.\nIf `s` contains at least one `1`:\n- If `s_k = 1`, then `s_{k-1} NOR s_k = s_{k-1} NOR 1 = 0`.\n  The string becomes `s_1 ... s_{k-2} 0`.\n- If `s_{k-1} = 1` and `s_k = 0`, then `s_{k-1} NOR s_k = 1 NOR 0 = 0`.\n  The string becomes `s_1 ... s_{k-2} 0`.\nIn general, if `R(s')` is the result of reducing `s_2 ... s_k`, then `R(s) = s_1 NOR R(s')`.\nIf `R(s')` is `1`, then `R(s)` is `s_1 NOR 1 = 0`.\nIf `R(s')` is `0`, then `R(s)` is `s_1 NOR 0`. This is `1` if `s_1=0`, and `0` if `s_1=1`.\n\nThis recursive definition is difficult to analyze directly.\nLet's try to find the condition for `R(s) = 1`.\n`R(s)` can only be `1` if `s_1 = 0` AND `R(s_2 ... s_k) = 0`.\nSo, for `R(s)=1`, the first character `s_1` must be `0`.\nAnd the result of reducing the rest of the string `s_2 ... s_k` must be `0`.\nThis means `s_2` cannot be `0` AND `R(s_3 ... s_k)` cannot be `0` (if `s_2` is `0` then `R(s_2 ... s_k)` would be `1` if `R(s_3 ... s_k)` is `0`).\nThis implies that for `R(s)=1`, we need `s_1=0`, `s_2=1`, `s_3=1`, ..., `s_k=1`.\nLet's test this:\n- `R(0)` is `0` (length 1, no operations).\n- `R(1)` is `1`.\nThis is a base case for string length 1. The problem says \"forbidden to modify a string with length less than two\". So if `n+m=1`, the result `g` is just the character itself.\nIf `n=1, m=0`, string is \"0\". `R(\"0\")=0`.\nIf `n=0, m=1`, string is \"1\". `R(\"1\")=1`.\n\nLet's re-evaluate the problem statement: \"We can obtain character g from string s with some (possibly, zero) number of modifications.\"\nThis means if `n+m=1`, the string itself is the final character.\n- If `n=1, m=0`, string is \"0\". `g` must be `0`.\n- If `n=0, m=1`, string is \"1\". `g` must be `1`.\n\nNow for `n+m >= 2`:\nLet `X_i` be the `i`-th character from the left.\n`X_1 X_2 ... X_k`\nThe operation is `X_i, X_{i+1} -> X_i'`\nNo, it's `s_1 s_2 ... s_{k-2} (s_{k-1} op s_k)`.\nLet `v_k = s_k`.\n`v_{k-1} = s_{k-1} op v_k`.\n`v_{k-2} = s_{k-2} op v_{k-1}`.\n...\n`v_1 = s_1 op v_2`.\nThe final character is `v_1`.\n\nLet's trace the final character `v_1`:\nIf any `s_i = 1` for `i >= 2`:\n  Then `s_{i-1} op s_i = s_{i-1} op 1 = 0`.\n  The `v_j` values will eventually become `0` from this point on.\n  For example, if `s_k = 1`, then `v_{k-1} = s_{k-1} op 1 = 0`.\n  Then `v_{k-2} = s_{k-2} op 0`. This is `1` if `s_{k-2}=0`, `0` if `s_{k-2}=1`.\n  So `v_{k-2}` is `NOT s_{k-2}`.\n  Then `v_{k-3} = s_{k-3} op v_{k-2} = s_{k-3} op (NOT s_{k-2})`.\n  This is `1` if `s_{k-3}=0` and `NOT s_{k-2}=0` (i.e. `s_{k-2}=1`).\n  This is `0` otherwise.\n\nThis looks like the result depends on the *last* `1` in the string.\nLet `j` be the largest index such that `s_j = 1`. If there are no `1`s, all characters are `0`.\nCase 1: All characters are `0`. String is \"00...0\" (`n` zeros, `m=0`).\n  `0 op 0 = 1`.\n  `000 -> 0(0 op 0) -> 01 -> 0 op 1 = 0`.\n  `0000 -> 00(0 op 0) -> 001 -> 0(0 op 1) -> 00 -> 0 op 0 = 1`.\n  In general, for `k` zeros:\n  - If `k=1`, result is `0`.\n  - If `k=2`, result is `1`.\n  - If `k=3`, result is `0`.\n  - If `k=4`, result is `1`.\n  The result is `k % 2 == 0 ? 1 : 0`. Or `(k+1)%2`.\n  So if `m=0`:\n  - `g=0` requires `n` to be odd. Number of strings: 1 (the string \"0...0\").\n  - `g=1` requires `n` to be even and `n>=2`. Number of strings: 1 (the string \"0...0\").\n  (If `n=0, m=0`, `n+m<1`, not allowed).\n\nCase 2: There is at least one `1` (`m >= 1`).\n  Let `j` be the index of the rightmost `1`. So `s_j = 1`, and `s_{j+1}, ..., s_k` are all `0`s.\n  The suffix `s_{j+1} ... s_k` has `k-j` zeros.\n  `v_k = s_k`.\n  `v_{k-1} = s_{k-1} op v_k`.\n  ...\n  `v_j = s_j op v_{j+1}`.\n  The value `v_{j+1}` is the result of reducing `s_{j+1} ... s_k` (which are all zeros).\n  From Case 1, `v_{j+1}` is `( (k-j) + 1 ) % 2`.\n  Now, `v_j = s_j op v_{j+1} = 1 op v_{j+1}`.\n  Since `1 op X` is always `0` (from the NOR table), `v_j` must be `0`.\n  So the result of reducing `s_j ... s_k` is `0`.\n  Now we have `v_{j-1} = s_{j-1} op v_j = s_{j-1} op 0`.\n  `s_{j-1} op 0` is `1` if `s_{j-1}=0`, and `0` if `s_{j-1}=1`.\n  So `v_{j-1} = NOT s_{j-1}`.\n  Then `v_{j-2} = s_{j-2} op v_{j-1} = s_{j-2} op (NOT s_{j-1})`.\n  This is `1` if `s_{j-2}=0` and `NOT s_{j-1}=0` (i.e. `s_{j-1}=1`).\n  This is `0` otherwise.\n  \n  This pattern `s_i op (NOT s_{i+1})` for `v_{i}` when `v_{i+1}` is `NOT s_{i+1}` is getting complicated.\n  Let's use the `NOR` notation.\n  The final result is `s_1 NOR (s_2 NOR (... NOR (s_k)...))`.\n  Let `res(s)` be the final result.\n  If `m >= 1`:\n  Let `s_j` be the rightmost '1'.\n  `res(s_j ... s_k)`:\n  The suffix `s_{j+1}...s_k` consists of `k-j` zeros. Let `res_suffix = res(s_{j+1}...s_k)`.\n  `res_suffix = ((k-j)+1)%2`. (This is `1` if `k-j` is even, `0` if `k-j` is odd).\n  Then `res(s_j ... s_k) = s_j NOR res_suffix = 1 NOR res_suffix = 0`.\n  So, any string ending with `0...01` (where `0...0` can be empty) reduces to `0`.\n  Now, let `s' = s_1 ... s_{j-1}`. The string `s_j ... s_k` reduces to `0`.\n  So `res(s_1 ... s_k) = res(s_1 ... s_{j-1} 0)`.\n  Let `s'' = s_1 ... s_{j-1}`. We need to compute `res(s'' 0)`.\n  `res(s'' 0) = s_1 NOR (s_2 NOR (... NOR (s_{j-1} NOR 0)...))`.\n  The operation `X NOR 0` is `NOT X`.\n  So `s_{j-1} NOR 0 = NOT s_{j-1}`.\n  Then `s_{j-2} NOR (NOT s_{j-1})`.\n  Then `s_{j-3} NOR (s_{j-2} NOR (NOT s_{j-1}))`.\n  \n  This is `s_1 NOR (s_2 NOR (... NOR (s_{j-2} NOR (NOT s_{j-1}))...))`.\n  Let's define `f_i(x) = s_i NOR x`.\n  We are computing `f_1(f_2(...f_{j-1}(NOT s_{j-1})...))`.\n  \n  Consider the result of `X NOR Y`.\n  If `Y=1`, result is `0`.\n  If `Y=0`, result is `NOT X`.\n  \n  Let's look at the sequence `s_1, s_2, ..., s_k`.\n  `v_k = s_k`.\n  `v_{k-1} = s_{k-1} NOR v_k`.\n  `v_{k-2} = s_{k-2} NOR v_{k-1}`.\n  ...\n  `v_1 = s_1 NOR v_2`.\n  \n  If there is any `1` at an odd position (from the right, 1-indexed), i.e., `s_{k-2i+1} = 1` for some `i >= 1`.\n  `s_k, s_{k-1}, s_{k-2}, ..., s_1`.\n  If `s_k = 1`: `v_{k-1} = s_{k-1} NOR 1 = 0`.\n    `v_{k-2} = s_{k-2} NOR 0 = NOT s_{k-2}`.\n    `v_{k-3} = s_{k-3} NOR (NOT s_{k-2})`.\n    This `v_{k-3}` is `1` if `s_{k-3}=0` AND `NOT s_{k-2}=0` (i.e. `s_{k-2}=1`).\n    This `v_{k-3}` is `0` otherwise.\n  \n  This is a known pattern for `NOR` chains.\n  `A NOR B`\n  `A NOR (B NOR C)`\n  `A NOR (B NOR (C NOR D))`\n  \n  The final result `v_1` is `1` if and only if:\n  - `s_1 = 0` AND\n  - `v_2 = 0`\n  And `v_2 = 0` if and only if:\n  - `s_2 = 1` OR\n  - `v_3 = 1`\n  This is: `s_1=0` AND (`s_2=1` OR (`s_3=1` OR (`s_4=1` OR ... OR (`s_k=1` OR `s_k=0` if `k` is even and all are 0s)))).\n  \n  Let's make this simpler.\n  The final result `g` is `1` if and only if the string is of the form `011...1` (one `0` followed by `m` ones, and `n-1` zeros before the first `0`).\n  This is not right. This is for `NAND` operation.\n  \n  Let's evaluate `v_1` (the final result) based on the input string `s_1 s_2 ... s_k`.\n  `v_1 = s_1 NOR v_2`\n  `v_2 = s_2 NOR v_3`\n  ...\n  `v_{k-1} = s_{k-1} NOR s_k`\n  \n  If `m=0` (all zeros): `s_1=s_2=...=s_k=0`.\n  `v_{k-1} = 0 NOR 0 = 1`.\n  `v_{k-2} = 0 NOR 1 = 0`.\n  `v_{k-3} = 0 NOR 0 = 1`.\n  The sequence `v_k, v_{k-1}, ..., v_1` is `0, 1, 0, 1, ...`.\n  So `v_1` is `1` if `k-1` is odd (i.e., `k` is even), and `0` if `k-1` is even (i.e., `k` is odd).\n  This means `v_1 = (k+1)%2`. This matches our previous observation for `m=0`.\n  \n  If `m >= 1`:\n  Let `j` be the index of the rightmost `1`. `s_j = 1`. `s_{j+1}=...=s_k=0`.\n  `v_k = 0`.\n  `v_{k-1} = 0 NOR 0 = 1`.\n  `v_{k-2} = 0 NOR 1 = 0`.\n  ...\n  `v_{j+1}` is `( (k-(j+1)) + 1 ) % 2` (result of reducing `k-j` zeros).\n  `v_j = s_j NOR v_{j+1} = 1 NOR v_{j+1} = 0`.\n  So, the result of reducing the suffix `s_j ... s_k` is `0`.\n  Now we need to compute `s_1 NOR (s_2 NOR (... NOR (s_{j-1} NOR 0)...))`.\n  Let `X = s_1 ... s_{j-1}`. We are computing `res(X0)`.\n  `res(X0)` depends on `X`.\n  `s_{j-1} NOR 0 = NOT s_{j-1}`.\n  `s_{j-2} NOR (NOT s_{j-1})`.\n  `s_{j-3} NOR (s_{j-2} NOR (NOT s_{j-1}))`.\n  \n  This structure is: `s_1 NOR (s_2 NOR (... NOR (s_{p} NOR X)...))`\n  where `p=j-1` and `X=0`.\n  The final result `g` is `1` if and only if `s_1=0`, `s_2=1`, `s_3=1`, ..., `s_{j-1}=1`, `s_j=0` (effectively).\n  This is the form `011...1`.\n  Let's verify this pattern:\n  `0` -> `0`\n  `1` -> `1`\n  `00` -> `1`\n  `01` -> `0`\n  `10` -> `0`\n  `11` -> `0`\n  \n  `011` (`n=1, m=2`)\n  `1 op 1 = 0`\n  `0 op 0 = 1`. Result is `1`.\n  \n  `001` (`n=2, m=1`)\n  `0 op 1 = 0`\n  `0 op 0 = 1`. Result is `1`.\n  \n  `100` (`n=2, m=1`)\n  `0 op 0 = 1`\n  `1 op 1 = 0`. Result is `0`.\n  \n  `000` (`n=3, m=0`)\n  `0 op 0 = 1`\n  `0 op 1 = 0`. Result is `0`.\n  \n  The property is: `v_1` is `1` if and only if the string is of the form `011...1` (a `0` followed by `k-1` ones), OR if the string is `00...0` and its length is even and positive.\n  \n  Let's analyze the final `g` value:\n  `g = 1` if and only if:\n  1. The string is `0...0` (all zeros), and `n` is even and `n >= 2`.\n  2. The string is `011...1` (one `0` followed by `k-1` ones), and `m=k-1`. In this case `n=1`.\n  \n  Let's prove this.\n  Let `s` be `s_1 s_2 ... s_k`.\n  `res(s) = 1` iff `s_1=0` and `res(s_2...s_k)=0`.\n  `res(s_2...s_k) = 0` iff `s_2=1` or `res(s_3...s_k)=1`.\n  `res(s_3...s_k) = 1` iff `s_3=0` and `res(s_4...s_k)=0`.\n  `res(s_4...s_k) = 0` iff `s_4=1` or `res(s_5...s_k)=1`.\n  \n  This implies:\n  `res(s) = 1` iff `s_1=0` AND (`s_2=1` OR (`s_3=0` AND (`s_4=1` OR (`s_5=0` AND ...))))\n  This is an alternating pattern.\n  `s_1=0`\n  `s_2=1`\n  `s_3=0`\n  `s_4=1`\n  ...\n  `s_i = (i-1)%2` (for `i >= 1`)\n  \n  No, it's `s_i = (i%2==0)`.\n  `s_1=0`\n  `s_2=1`\n  `s_3=0`\n  `s_4=1`\n  ...\n  The string must be `010101...`.\n  Let's verify this for `010` (`n=2, m=1`):\n  `0 op 1 = 0`\n  `0 op 0 = 1`. Result is `1`. This matches.\n  \n  Let's verify for `0101` (`n=2, m=2`):\n  `1 op 1 = 0`\n  `0 op 0 = 1`\n  `0 op 1 = 0`. Result is `0`.\n  \n  So the pattern `0101...` gives `g=1` if `k` is odd, and `g=0` if `k` is even.\n  \n  Let's re-examine `res(s) = 1` conditions:\n  `res(s_1...s_k) = 1`\n  1. `k=1`: `s_1=1`. So `n=0, m=1`.\n  2. `k >= 2`: `s_1=0` AND `res(s_2...s_k)=0`.\n  \n  `res(s') = 0` conditions (where `s'` is `s_2...s_k`):\n  1. `k-1=1`: `s_2=0`. So `s_2=0`. This implies `s_1=0, s_2=0`. `00` reduces to `1`. This is correct.\n  2. `k-1 >= 2`: `s_2=1` OR `res(s_3...s_k)=1`.\n  \n  So `res(s_1...s_k)=1` iff:\n  (`s_1=0` AND `s_2=0`) OR (`s_1=0` AND `s_2=1` AND `res(s_3...s_k)=1`).\n  \n  Let's trace `res(s)` with `k` characters.\n  `res(s_1 ... s_k)` is `1` if and only if:\n  - `s_k = 1` and `k` is odd. (e.g. `1` itself, `001` -> `1`, `0101` -> `0` (fails), `01011` -> `1`).\n  - `s_k = 0` and `k` is even. (e.g. `00` -> `1`, `0000` -> `1`).\n  This feels like it depends on the parity of `k` and the last character.\n  \n  This is the final result for `NOR` operation `s_1 NOR (s_2 NOR (... NOR s_k))`:\n  If `s_i=1` for any `i < k`, then `res = 0`.\n  The only way to get `res=1` is if `s_1=0, s_2=0, ..., s_{k-1}=0`.\n  And then `res = (NOT (NOT (...(NOT s_k)...)))`. This is `s_k` if `k-1` is even, `NOT s_k` if `k-1` is odd.\n  So `res = s_k` if `k` is odd, `NOT s_k` if `k` is even.\n  \n  This is the final result of `s_1 NOR s_2 NOR ... NOR s_k` if we consider `NOR` as an associative operation.\n  But the problem specifies `s_1 NOR (s_2 NOR (... NOR s_k)...)`.\n  \n  Let `f(s_1, ..., s_k)` be the result.\n  `f(s_1, ..., s_k) = s_1 NOR f(s_2, ..., s_k)`.\n  \n  Base cases:\n  `f(0) = 0`\n  `f(1) = 1`\n  \n  `f(00) = 0 NOR f(0) = 0 NOR 0 = 1`.\n  `f(01) = 0 NOR f(1) = 0 NOR 1 = 0`.\n  `f(10) = 1 NOR f(0) = 1 NOR 0 = 0`.\n  `f(11) = 1 NOR f(1) = 1 NOR 1 = 0`.\n  \n  `f(000) = 0 NOR f(00) = 0 NOR 1 = 0`.\n  `f(001) = 0 NOR f(01) = 0 NOR 0 = 1`.\n  `f(010) = 0 NOR f(10) = 0 NOR 0 = 1`.\n  `f(011) = 0 NOR f(11) = 0 NOR 0 = 1`.\n  `f(100) = 1 NOR f(00) = 1 NOR 1 = 0`.\n  `f(101) = 1 NOR f(01) = 1 NOR 0 = 0`.\n  `f(110) = 1 NOR f(10) = 1 NOR 0 = 0`.\n  `f(111) = 1 NOR f(11) = 1 NOR 0 = 0`.\n  \n  Summary of `f(s)=1` for length 1, 2, 3:\n  Length 1: \"1\" (`n=0, m=1`)\n  Length 2: \"00\" (`n=2, m=0`)\n  Length 3: \"001\", \"010\", \"011\" (`n=2, m=1`, `n=1, m=2`, `n=1, m=2`)\n  \n  Let's look at `g=1` condition:\n  If `m=0` (all zeros): `n` must be even and `n >= 2`.\n  If `m > 0`:\n    `f(s)=1` if and only if:\n    - `s_1=0` AND `f(s_2...s_k)=0`.\n    - `f(s_2...s_k)=0` if and only if `s_2=1` OR `f(s_3...s_k)=1`.\n    \n    This is equivalent to `f(s)=1` iff `s_1=0` AND (`s_2=1` OR `f(s_3...s_k)=1`).\n    \n    This structure `(A AND (B OR C))` means that if `s_1=0` and `s_2=1`, then `f(s)=1` regardless of `f(s_3...s_k)`.\n    So if string starts with \"01\", `f(01...) = 0 NOR f(1...) = 0 NOR (1 NOR f(...)) = 0 NOR 0 = 1`.\n    This is a critical observation!\n    If a string starts with \"01\", its result is `1`.\n    \n    What if a string does not start with \"01\"?\n    - If `s_1=1`: `f(1...) = 1 NOR f(...) = 0`. So result is `0`.\n    - If `s_1=0` and `s_2=0`: `f(00...) = 0 NOR f(0...)`.\n      `f(00...0)` (all zeros, `n` of them): `n` must be even and `n >= 2`.\n      `f(00...1...) = 0 NOR f(01...) = 0 NOR 1 = 0`.\n      So if `s_1=0, s_2=0` and there's a `1` later, the result is `0`.\n      \n  Combining these:\n  The final character `g` is `1` if and only if:\n  1. The string is `0...0` (all zeros), and `n` is even and `n >= 2`.\n  2. The string starts with `01`. (This implies `n>=1, m>=1`).\n  \n  The final character `g` is `0` if and only if:\n  1. The string is `0...0` (all zeros), and `n` is odd.\n  2. The string starts with `1`. (This implies `m>=1`).\n  3. The string starts with `00` and contains at least one `1`. (This implies `n>=2, m>=1`).\n  \n  Let's verify the examples:\n  `n=1, m=1, g=0`: Strings are \"01\", \"10\".\n    \"01\" starts with \"01\", so `g=1`.\n    \"10\" starts with \"1\", so `g=0`.\n    Expected `g=0`. So \"10\" is beautiful. \"01\" is not. Answer should be 1.\n    The example output is 2. My logic is incorrect.\n\nWhat is wrong? The problem implies `s_1 s_2 ... s_k` is reduced by `op(s_{k-1}, s_k)`, then `op(s_{k-2}, new_s_{k-1})` and so on. This is reduction from right to left.\nMy previous `v_1 = s_1 op v_2` was correct for right-to-left reduction.\n\nLet's re-evaluate `f(s)=1` conditions with right-to-left reduction.\n`f(s_1 ... s_k)` is `1` if and only if:\n1. `m=0` (all zeros): `n` must be even and `n >= 2`. (e.g. `00` -> `1`, `0000` -> `1`).\n2. `m > 0`:\n   Let `j` be the index of the rightmost `1`. `s_j=1`, `s_{j+1}...s_k` are all `0`s.\n   `f(s_j ... s_k) = f(10...0)` (where there are `k-j` zeros after the `1`).\n   `f(10...0)`:\n   `f(1) = 1`\n   `f(10) = 1 op 0 = 0`\n   `f(100) = 1 op (0 op 0) = 1 op 1 = 0`\n   `f(1000) = 1 op (0 op (0 op 0)) = 1 op (0 op 1) = 1 op 0 = 0`\n   It seems `f(10...0)` is `1` if `k-j=0` (just `1`), and `0` if `k-j >= 1`.\n   So if `s_j=1` is the rightmost `1`:\n   - If `j=k` (string ends with `1`): `f(s_j...s_k) = 1`.\n   - If `j < k` (string ends with `10...0`): `f(s_j...s_k) = 0`.\n   \n   Now consider `f(s_1 ... s_k) = f(s_1 ... s_{j-1} (f(s_j ... s_k)))`.\n   Let `val_suffix = f(s_j ... s_k)`.\n   If `j=k` (string ends with `1`): `val_suffix = 1`.\n     `f(s_1 ... s_k) = f(s_1 ... s_{k-1} 1)`.\n     `f(s_1 ... s_{k-1} 1) = s_1 op f(s_2 ... s_{k-1} 1)`.\n     This means `s_{k-1} op 1 = 0`.\n     `s_{k-2} op 0 = NOT s_{k-2}`.\n     `s_{k-3} op (NOT s_{k-2})`.\n     This pattern `X op (NOT Y)` means `1` if `X=0, Y=1` and `0` otherwise.\n     The final result `f(s)` will be `1` iff `s_1=0` and `s_2=1` and `s_3=0` and `s_4=1` ... and `s_{k-1}=X` (where `X` depends on `k-1`'s parity), AND `s_k=1`.\n     This is the alternating string `0101...` ending in `1`.\n     `f(01)=0`\n     `f(011)=1`\n     `f(0101)=0`\n     `f(01011)=1`\n     The pattern is `0101...01` gives `1` if number of chars `k` is odd.\n     `0101...1` gives `1` if `k` is odd. (e.g. `011` -> `1`, `01011` -> `1`).\n     \n   If `j < k` (string ends with `10...0`): `val_suffix = 0`.\n     `f(s_1 ... s_k) = f(s_1 ... s_{j-1} 0)`.\n     This means `s_{j-1} op 0 = NOT s_{j-1}`.\n     `s_{j-2} op (NOT s_{j-1})`.\n     The final result `f(s)` will be `1` iff `s_1=0` and `s_2=1` and `s_3=0` and `s_4=1` ... and `s_{j-1}=X` (where `X` depends on `j-1`'s parity), AND `s_j=0` (effectively).\n     This is the alternating string `0101...` ending in `0`.\n     `f(00)=1`\n     `f(010)=1`\n     `f(0100)=0`\n     `f(01010)=1`\n     The pattern is `0101...0` gives `1` if `k` is odd.\n     \n  This is getting complex. Let's list `f(s)=1` strings:\n  `k=1`: \"1\" (`n=0, m=1`)\n  `k=2`: \"00\" (`n=2, m=0`)\n  `k=3`: \"001\" (`n=2, m=1`), \"010\" (`n=1, m=2`), \"011\" (`n=1, m=2`)\n  `k=4`: \"0000\" (`n=4, m=0`), \"0101\" (`n=2, m=2`) (from example, my `f(0101)=0` is wrong, let's re-eval it)\n  \n  `f(0101)`: `1 op 1 = 0`. String `010`.\n  `0 op 0 = 1`. String `01`.\n  `0 op 1 = 0`. String `0`. Result `0`.\n  \n  The example says `n=2, m=2, g=0` -> `4` strings: \"0011\", \"1001\", \"1010\", \"1100\".\n  Let's check `f(0011)`:\n  `1 op 1 = 0`. String `000`.\n  `0 op 0 = 1`. String `01`.\n  `0 op 1 = 0`. String `0`. Result `0`. This matches example.\n  \n  Let's check `f(1001)`:\n  `0 op 1 = 0`. String `100`.\n  `0 op 0 = 1`. String `11`.\n  `1 op 1 = 0`. String `1`. Result `0`. This matches example.\n  \n  Let's check `f(1010)`:\n  `1 op 0 = 0`. String `100`.\n  `0 op 0 = 1`. String `11`.\n  `1 op 1 = 0`. String `1`. Result `0`. This matches example.\n  \n  Let's check `f(1100)`:\n  `0 op 0 = 1`. String `111`.\n  `1 op 1 = 0`. String `10`.\n  `1 op 0 = 0`. String `1`. Result `0`. This matches example.\n  \n  All `n=2, m=2` strings reduce to `0`. So `g=0` gives 4 strings, `g=1` gives 0 strings. This matches example.\n  \n  My earlier analysis of `f(s)=1` for `010` was `1`.\n  `f(010)`: `1 op 0 = 0`. String `00`.\n  `0 op 0 = 1`. String `1`. Result `1`. This matches.\n  \n  My earlier analysis of `f(s)=1` for `011` was `1`.\n  `f(011)`: `1 op 1 = 0`. String `00`.\n  `0 op 0 = 1`. String `1`. Result `1`. This matches.\n  \n  My earlier analysis of `f(s)=1` for `001` was `1`.\n  `f(001)`: `0 op 1 = 0`. String `00`.\n  `0 op 0 = 1`. String `1`. Result `1`. This matches.\n  \n  The `f(s)=1` strings for `k=3` are indeed `001, 010, 011`.\n  \n  The condition for `f(s)=1` seems to be:\n  If `m=0`: `n` is even and `n >= 2`.\n  If `m > 0`:\n    `f(s)=1` if and only if `s_1=0` AND `s_2=0` AND `s_3=1` (This is `001...`) OR\n    `s_1=0` AND `s_2=1` AND `s_3=0` (This is `010...`) OR\n    `s_1=0` AND `s_2=1` AND `s_3=1` (This is `011...`)\n    \n    This is equivalent to `s_1=0` AND (`s_2=0` AND `s_3=1` OR `s_2=1`).\n    This simplifies to `s_1=0` AND (`s_2=1` OR (`s_2=0` AND `s_3=1`)).\n    This is `s_1=0` AND (`s_2=1` OR `s_2s_3=01`).\n    \n    This is still not a general rule. Let's look at the parity of `m`.\n    If `m` is odd:\n      `g=1` if `n=0, m=1` (string \"1\")\n      `g=0` otherwise?\n      `n=1, m=0, g=0`: \"0\" -> 0. (Correct)\n      `n=0, m=1, g=1`: \"1\" -> 1. (Correct)\n      `n=1, m=1, g=0`: Strings \"01\", \"10\".\n        \"01\" -> 0 (from my trace `f(01)=0`).\n        \"10\" -> 0 (from my trace `f(10)=0`).\n        So both \"01\" and \"10\" produce `0`. Number of beautiful strings is 2. This matches example.\n        This means my earlier `f(01)=0` was correct. And `f(011)=1` was also correct.\n        What was wrong with my `01` logic?\n        `f(01) = 0 NOR f(1) = 0 NOR 1 = 0`. This is correct.\n        \nThis means the condition `f(s)=1` is very specific.\nLet's analyze the problem based on the parity of `m`.\n\nCase 1: `m` is odd.\n  The total number of `1`s is odd.\n  If `n=0, m=1`: String is \"1\". `f(\"1\")=1`. So if `g=1`, count is 1. If `g=0`, count is 0.\n  If `n>=1, m` is odd:\n    Consider `s_k`.\n    If `s_k = 0`: `s_{k-1} op 0 = NOT s_{k-1}`.\n    If `s_k = 1`: `s_{k-1} op 1 = 0`.\n    \n    The crucial observation from a similar problem: The final result of such operations often depends on the parity of the number of `1`s.\n    Let's define `val(s)` as the integer value of `s` where `0` is `0` and `1` is `1`.\n    `op(x, y)` is `1 - (x OR y)`.\n    This is `1 - (x + y - xy)`.\n    \n    A known property of such right-to-left reductions (like `s_1 op (s_2 op (... op s_k))`) is that the final result is `1` if and only if:\n    1. The string contains no `1`s (all `0`s), and its length `k` is even and positive.\n    2. The string contains at least one `1`, and the number of `1`s is odd, and the first character is `0`.\n    \n    Let's test this rule.\n    `n=1, m=1, g=0`: `k=2`. Strings \"01\", \"10\". `m=1` is odd.\n      \"01\": first char `0`, `m=1` is odd. Rule says `g=1`. My `f(01)=0`. This rule is wrong.\n      \"10\": first char `1`. Rule says `g=0`. My `f(10)=0`. This matches.\n      So for `g=0`, \"10\" is beautiful. Count 1. Example says 2.\n      \nMy analysis of the operations is failing to match the examples. Let's re-read the operation carefully.\n\"we replace two last characters from the string by exactly one other character. This character equals one if it replaces two zeros, otherwise it equals zero.\"\n`s_1 s_2 ... s_{k-2} s_{k-1} s_k` becomes `s_1 s_2 ... s_{k-2} (s_{k-1} op s_k)`.\nThis is exactly `s_1 NOR (s_2 NOR (... NOR (s_{k-1} NOR s_k)...))` as I analyzed.\nMy `f(01)=0` and `f(10)=0` are correct based on this.\nBut example `n=1, m=1, g=0` output is `2`. This implies both \"01\" and \"10\" produce `0`.\nMy trace:\n`f(01) = 0` (correct)\n`f(10) = 0` (correct)\nSo for `n=1, m=1, g=0`, the answer is `2`. This matches the example. My traces were correct. My interpretation of the example output was wrong.\n\nOkay, let's restart the conditions for `g=1` and `g=0` based on my correct traces.\n`f(s)=1` conditions:\n  - If `m=0` (all zeros): `n` must be even and `n >= 2`. (e.g. `00` -> `1`, `0000` -> `1`).\n  - If `m > 0`:\n    - `f(001) = 1`\n    - `f(010) = 1`\n    - `f(011) = 1`\n    These are the only length 3 strings that produce `1`.\n    For length 4: `f(0000)=1`. `f(0001) = 0 NOR f(001) = 0 NOR 1 = 0`.\n    `f(0010) = 0 NOR f(010) = 0 NOR 1 = 0`.\n    `f(0011) = 0 NOR f(011) = 0 NOR 1 = 0`.\n    `f(0100) = 0 NOR f(100) = 0 NOR 0 = 1`.\n    `f(0101) = 0 NOR f(101) = 0 NOR 0 = 1`.\n    `f(0110) = 0 NOR f(110) = 0 NOR 0 = 1`.\n    `f(0111) = 0 NOR f(111) = 0 NOR 0 = 1`.\n    \n    This is an interesting pattern. All strings starting with `01` reduce to `1` if `k >= 3`.\n    `f(01X) = 0 NOR f(1X)`.\n    `f(1X) = 1 NOR f(X)`. Since `1 NOR Y = 0` always, `f(1X) = 0`.\n    So `f(01X) = 0 NOR 0 = 1`.\n    This means any string `s` of length `k >= 3` that starts with `01` reduces to `1`.\n    \n    Let's check `f(01) = 0`. This is length 2, not `k>=3`.\n    \nSo, conditions for `g=1`:\n1. `n=0, m=1` (string \"1\"). Result `1`. Count = 1.\n2. `n>=2, m=0` (string \"0...0\"). `n` must be even. Result `1`. Count = 1.\n3. `n>=1, m>=1`, and `n+m >= 3`. String starts with `01`. Result `1`.\n   Number of such strings:\n   The first two characters are fixed as `01`. We need to arrange `n-1` zeros and `m-1` ones in the remaining `n+m-2` positions.\n   This is `C(n+m-2, n-1)`.\n   \nConditions for `g=0`:\n1. `n=1, m=0` (string \"0\"). Result `0`. Count = 1.\n2. `n>=1, m=0` (string \"0...0\"). `n` must be odd and `n >= 3`. Result `0`. Count = 1.\n3. `n>=1, m>=1`. String does not start with `01`.\n   This means string starts with `1...` OR starts with `00...`.\n   Strings starting with `1`: `m>=1`. Total `n` zeros, `m-1` ones in `n+m-1` positions. `C(n+m-1, n)`.\n   Strings starting with `00`: `n>=2`. Total `n-2` zeros, `m` ones in `n+m-2` positions. `C(n+m-2, n-2)`.\n   \nTotal number of strings with `n` zeros and `m` ones is `C(n+m, n)`.\nLet `Total = C(n+m, n)`.\nLet `Count_g1` be the number of strings that reduce to `1`.\nLet `Count_g0` be the number of strings that reduce to `0`.\n`Count_g1 + Count_g0 = Total`.\n\nLet's refine `g=1` conditions:\nA. `m=0`: `n` must be even and `n >= 2`. (String `0...0`). `Count_A = 1`.\nB. `n=0, m=1`: (String `1`). `Count_B = 1`.\nC. `n>=1, m>=1` AND `n+m >= 3`. String starts with `01`. `Count_C = C(n+m-2, n-1)`.\n   (This covers `n=1, m=2`, `n=2, m=1`, etc. for `k>=3`).\n\nLet's test these conditions with examples:\n`n=1, m=1, g=0`:\n  `k=2`.\n  `g=1` conditions:\n    A: `m=0` fails.\n    B: `n=0` fails.\n    C: `n+m=2`, fails `n+m>=3`.\n  So `Count_g1 = 0`.\n  `Total = C(1+1, 1) = C(2,1) = 2`.\n  `Count_g0 = Total - Count_g1 = 2 - 0 = 2`.\n  This matches example output `2`.\n\n`n=2, m=2, g=0`:\n  `k=4`.\n  `g=1` conditions:\n    A: `m=0` fails.\n    B: `n=0` fails.\n    C: `n+m=4 >= 3`. String starts with `01`. `C(4-2, 2-1) = C(2,1) = 2`.\n      These strings are `0101` and `0110`.\n  So `Count_g1 = 2`.\n  `Total = C(2+2, 2) = C(4,2) = 6`.\n  `Count_g0 = Total - Count_g1 = 6 - 2 = 4`.\n  This matches example output `4`.\n\n`n=1, m=1, g=1`:\n  `k=2`.\n  `g=1` conditions:\n    A: `m=0` fails.\n    B: `n=0` fails.\n    C: `n+m=2`, fails `n+m>=3`.\n  So `Count_g1 = 0`.\n  This matches example output `0`.\n\nThe logic seems to hold for examples.\n\nLet's consider edge cases for `n, m`:\n`n=0, m=0`: `n+m < 1`, not allowed by problem statement.\n`n=1, m=0`: string \"0\". `k=1`.\n  `g=1` conditions: A fails (`n=1` odd). B fails. C fails (`m=0`). `Count_g1 = 0`.\n  `Total = C(1,1)=1`. `Count_g0 = 1`.\n  If `g=0`, answer is 1. If `g=1`, answer is 0. (Correct, \"0\" reduces to 0).\n`n=0, m=1`: string \"1\". `k=1`.\n  `g=1` conditions: A fails (`m=1`). B: `n=0, m=1` matches. `Count_g1 = 1`.\n  `Total = C(1,0)=1`. `Count_g0 = 0`.\n  If `g=1`, answer is 1. If `g=0`, answer is 0. (Correct, \"1\" reduces to 1).\n\n`n=2, m=0`: string \"00\". `k=2`.\n  `g=1` conditions: A: `n=2` even and `n>=2` matches. `Count_A = 1`. B fails. C fails (`m=0`).\n  `Count_g1 = 1`.\n  `Total = C(2,2)=1`. `Count_g0 = 0`.\n  If `g=1`, answer is 1. If `g=0`, answer is 0. (Correct, \"00\" reduces to 1).\n\n`n=3, m=0`: string \"000\". `k=3`.\n  `g=1` conditions: A fails (`n=3` odd). B fails. C fails (`m=0`).\n  `Count_g1 = 0`.\n  `Total = C(3,3)=1`. `Count_g0 = 1`.\n  If `g=0`, answer is 1. If `g=1`, answer is 0. (Correct, \"000\" reduces to 0).\n\nThe logic seems robust.\n\nFinal conditions for `g=1`:\nInitialize `ans = 0`.\n1. If `m=0` and `n % 2 == 0` and `n >= 2`: `ans = (ans + 1) % MOD`.\n2. If `n=0` and `m=1`: `ans = (ans + 1) % MOD`.\n3. If `n>=1` and `m>=1` and `n+m >= 3`: `ans = (ans + C(n+m-2, n-1)) % MOD`.\n\nIf `g=0`, the answer is `(C(n+m, n) - ans + MOD) % MOD`.\n\nNeed to implement combinations `C(N, K)` modulo `10^9 + 7`.\n`C(N, K) = N! / (K! * (N-K)!)`.\nThis requires precomputing factorials and inverse factorials modulo `MOD`.\n`MOD = 1000000007`.\n\nMax `N = n+m = 2*10^5`.\nPrecompute factorials up to `2*10^5`.\n`fact[i] = i! % MOD`.\n`inv_fact[i] = (i!)^(-1) % MOD`.\n`inv_fact[i] = pow(fact[i], MOD-2, MOD)`.\n\n`C(N, K) = fact[N] * inv_fact[K] * inv_fact[N-K] % MOD`.\n\nMaximum `n+m` is `2 * 10^5`.\nIf `n=0, m=0`, `n+m>=1` constraint means this case is not possible.\n\nConsider `n+m-2 < n-1` or `n+m-2 < m-1` for `C(N,K)` calculation.\n`C(N, K)` is `0` if `K < 0` or `K > N`.\nFor `C(n+m-2, n-1)`:\n`N = n+m-2`. `K = n-1`.\nIf `n-1 < 0` (i.e., `n=0`): This case is already handled by conditions 1 and 2 for `g=1`. Condition 3 requires `n>=1`. So `n-1 >= 0`.\nIf `n-1 > n+m-2`: `n-1 > n+m-2` => `-1 > m-2` => `1 > m`.\n  If `m=0`: This case is already handled by condition 1. Condition 3 requires `m>=1`. So `m-1 >= 0`.\n  If `m=1`: `n-1 > n+1-2` => `n-1 > n-1`. This is false. So `n-1 <= n+m-2` is always true when `m>=1`.\nSo `K` is always valid for `C(n+m-2, n-1)` given `n>=1, m>=1`.\n\nImplementation details:\n- Read `n, m, g`.\n- Define `MOD`.\n- Precompute factorials and inverse factorials.\n- Function `nCr(N, K)`.\n- Calculate `Count_g1` using the three conditions.\n- If `g=1`, print `Count_g1`.\n- If `g=0`, print `(nCr(n+m, n) - Count_g1 + MOD) % MOD`.\n\n```python\nimport sys\n\nMOD = 1000000007\nMAX_N_M = 2 * 10**5\n\nfact = [1] * (MAX_N_M + 1)\ninv_fact = [1] * (MAX_N_M + 1)\n\ndef precompute_factorials():\n    for i in range(1, MAX_N_M + 1):\n        fact[i] = (fact[i-1] * i) % MOD\n    \n    inv_fact[MAX_N_M] = pow(fact[MAX_N_M], MOD - 2, MOD)\n    for i in range(MAX_N_M - 1, -1, -1):\n        inv_fact[i] = (inv_fact[i+1] * (i+1)) % MOD\n\ndef nCr(n, r):\n    if r < 0 or r > n:\n        return 0\n    num = fact[n]\n    den = (inv_fact[r] * inv_fact[n-r]) % MOD\n    return (num * den) % MOD\n\n# Precompute factorials once\nprecompute_factorials()\n\ndef solve():\n    n, m, g = map(int, sys.stdin.readline().split())\n\n    count_g1 = 0\n\n    # Case 1: All zeros (m=0)\n    if m == 0:\n        if n % 2 == 0 and n >= 2:\n            count_g1 = (count_g1 + 1) % MOD\n        # If n=1, m=0, result is 0. If n is odd and >=3, result is 0.\n        # These are not g=1, so don't add to count_g1.\n    \n    # Case 2: String is \"1\" (n=0, m=1)\n    elif n == 0 and m == 1:\n        count_g1 = (count_g1 + 1) % MOD\n    \n    # Case 3: String starts with \"01\" and length >= 3\n    # This implies n >= 1, m >= 1.\n    # If n+m >= 3, and starts with \"01\", it reduces to 1.\n    elif n >= 1 and m >= 1 and (n + m) >= 3:\n        # String must start with '01'. Remaining n-1 zeros and m-1 ones.\n        # Total remaining characters: (n-1) + (m-1) = n+m-2.\n        # Choose n-1 positions for zeros (or m-1 for ones).\n        count_g1 = (count_g1 + nCr(n + m - 2, n - 1)) % MOD\n\n    # Total possible strings\n    total_strings = nCr(n + m, n)\n\n    if g == 1:\n        print(count_g1)\n    else: # g == 0\n        ans = (total_strings - count_g1 + MOD) % MOD\n        print(ans)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\nMOD = 1000000007\nMAX_N_M = 2 * 10**5\n\nfact = [1] * (MAX_N_M + 1)\ninv_fact = [1] * (MAX_N_M + 1)\n\ndef precompute_factorials():\n    for i in range(1, MAX_N_M + 1):\n        fact[i] = (fact[i-1] * i) % MOD\n    \n    inv_fact[MAX_N_M] = pow(fact[MAX_N_M], MOD - 2, MOD)\n    for i in range(MAX_N_M - 1, -1, -1):\n        inv_fact[i] = (inv_fact[i+1] * (i+1)) % MOD\n\ndef nCr(n, r):\n    if r < 0 or r > n:\n        return 0\n    num = fact[n]\n    den = (inv_fact[r] * inv_fact[n-r]) % MOD\n    return (num * den) % MOD\n\n# Precompute factorials once\nprecompute_factorials()\n\ndef solve():\n    n, m, g = map(int, sys.stdin.readline().split())\n\n    count_g1 = 0\n\n    # Case 1: All zeros (m=0)\n    if m == 0:\n        if n % 2 == 0 and n >= 2:\n            count_g1 = (count_g1 + 1) % MOD\n        # If n=1, m=0, result is 0. If n is odd and >=3, result is 0.\n        # These are not g=1, so don't add to count_g1.\n    \n    # Case 2: String is \"1\" (n=0, m=1)\n    elif n == 0 and m == 1:\n        count_g1 = (count_g1 + 1) % MOD\n    \n    # Case 3: String starts with \"01\" and length >= 3\n    # This implies n >= 1, m >= 1.\n    # If n+m >= 3, and starts with \"01\", it reduces to 1.\n    elif n >= 1 and m >= 1 and (n + m) >= 3:\n        # String must start with '01'. Remaining n-1 zeros and m-1 ones.\n        # Total remaining characters: (n-1) + (m-1) = n+m-2.\n        # Choose n-1 positions for zeros (or m-1 for ones).\n        count_g1 = (count_g1 + nCr(n + m - 2, n - 1)) % MOD\n\n    # Total possible strings\n    total_strings = nCr(n + m, n)\n\n    if g == 1:\n        print(count_g1)\n    else: # g == 0\n        ans = (total_strings - count_g1 + MOD) % MOD\n        print(ans)\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 569,
        "completion_token_count": 15210,
        "thoughts_token_count": 724
    }
}