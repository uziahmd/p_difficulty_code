{
    "start": 1758284893.4517107,
    "end": 1758284936.7948444,
    "start-formatted": "2025-09-19 21:28 KST",
    "end-formatted": "2025-09-19 21:28 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "**Solving the Mushroom Strife Problem with Python**\n\nOkay, I'm facing the \"Mushroom Strife\" problem, and I need a Python solution. The core is figuring out the number of mushrooms on each lawn, given GCD and LCM constraints.\n\n**Problem Breakdown:**\n\nI get `n` lawns (vertices), `m` roads (edges), and for each road, the connected lawns and the GCD and LCM of their mushroom counts. My goal is to find valid mushroom counts for all lawns (between 1 and 10^6), or report it's impossible.\n\n**Key Insight: GCD and LCM Relationship:**\n\nThe critical piece here is the relationship between GCD and LCM: `GCD(a, b) * LCM(a, b) = a * b`. Let's say `g = GCD(a, b)` and `l = LCM(a, b)`. We know `a = g * x` and `b = g * y` where `GCD(x, y) = 1`. Substituting and simplifying, I get `l / g = x * y`. This is crucial. If I know `g` and `l`, I know `x * y`.  And, `a = g * x` and `b = g * y`.\n\n**Constraints:**\n\nThe input size is significant: `n` and `m` up to 10^5, and the GCD, LCM, and mushroom counts themselves are up to 10^6. This implies I need an efficient algorithm.\n\n**Graph Representation:**\n\nA graph is a natural way to represent this problem.  I'll use an adjacency list to represent the lawns (vertices) and roads (edges) where each edge holds the GCD and LCM information.\n\n**The Approach - Propagation is the Key:**\n\nThe problem asks for *any* solution, hinting at a constructive algorithm, possibly using propagation. I'm thinking I can start with a connected component of the graph, and if I fix the mushroom count of one lawn (`M[u]`), can I propagate and deduce the counts for its neighbors?\n\nHere's my idea:\nFor an edge `(u, v, g, l)`,\nI know `M[u] * M[v] = g * l`.\nSo `M[v] = (g * l) / M[u]`.\nFor a valid integer solution, `M[u]` must divide `g * l`. Also, `g` must divide `M[u]`.\nI need to check for consistency with the constraints, but this looks promising. Now to turn this into Python code...\n",
    "response": "The problem asks us to assign a number of mushrooms (1 to 10^6) to each of `n` lawns such that given GCD and LCM constraints for `m` roads are satisfied. If multiple solutions exist, any one is fine; if none, we report that.\n\nLet `M[i]` be the number of mushrooms on lawn `i`. For an edge connecting lawns `u` and `v` with given `GCD(M[u], M[v]) = g` and `LCM(M[u], M[v]) = l`, we know two fundamental properties:\n1. `M[u] * M[v] = g * l`\n2. `g` must divide both `M[u]` and `M[v]`.\n3. `l` must be a multiple of both `M[u]` and `M[v]`. (This is redundant if `M[u] * M[v] = g * l` and `g` divides `M[u], M[v]`.)\n\nFrom property 2, we can write `M[u] = g * x` and `M[v] = g * y` for some integers `x` and `y` such that `GCD(x, y) = 1`.\nSubstituting into property 1: `(g * x) * (g * y) = g * l`, which simplifies to `g * x * y = l`.\nThis implies `x * y = l / g`.\nSo, for each edge `(u, v, g, l)`, `l` must be divisible by `g`. If `l % g != 0`, then no solution exists.\n\nThe problem can be modeled as finding values for `M[i]` in a graph. Since `n` can be up to 10^5, we need an efficient way to determine `M[i]`. The graph might be disconnected, so we can process each connected component independently.\n\nConsider a connected component. If we fix the value of `M[u]` for some lawn `u`, we can potentially determine the values for its neighbors and propagate this information.\nFor an edge `(u, v, g, l)`:\nIf `M[u]` is known, then `M[v]` must be `(g * l) / M[u]`.\nWe must also verify that `GCD(M[u], M[v]) = g`.\n\nThis approach can be implemented using Breadth-First Search (BFS) or Depth-First Search (DFS).\n1. Initialize `M[i] = 0` for all `i` (meaning not yet determined).\n2. For each lawn `i` from 1 to `n`:\n   If `M[i]` is not yet determined:\n     a. Start a BFS/DFS from `i`.\n     b. Set `M[i]` to an initial candidate value. A natural candidate for `M[i]` is `g` itself, where `g` is the GCD from an incident edge. However, a simpler strategy is to just set `M[i] = 1` for the first node in a component, and then verify. But setting `M[i]` to `g` for some edge `(i, v, g, l)` is more robust.\n     c. A better strategy for the initial value: For any edge `(u, v, g, l)`, `M[u]` must be a multiple of `g` and `M[v]` must be a multiple of `g`.\n        Let's maintain for each node `i` a set of *candidate values* `C[i]`. Initially, `C[i]` could be all numbers from 1 to 10^6.\n        When processing an edge `(u, v, g, l)`:\n        - `M[u]` must be a multiple of `g`.\n        - `M[v]` must be a multiple of `g`.\n        - `M[u]` must divide `l`.\n        - `M[v]` must divide `l`.\n        So, `M[u]` and `M[v]` must be common divisors of `l` that are also multiples of `g`. Let `D_ul = {d | d \\text{ divides } l, d \\text{ is a multiple of } g}`.\n        The actual value `M[u]` must be in `D_ul`. The actual value `M[v]` must be in `D_ul`.\n        Furthermore, `M[u] * M[v] = g * l`.\n        This means `M[u]` must be a value `k` such that `(g*l)/k` is also in `D_ul`.\n        And `GCD(k, (g*l)/k) = g`.\n\nThis leads to a more constrained approach:\nFor each node `i`, we can precompute the set of *possible values* `P[i]`.\nFor every edge `(u, v, g, l)`:\n`M[u]` must be a multiple of `g`. `M[u]` must divide `l`.\n`M[v]` must be a multiple of `g`. `M[v]` must divide `l`.\nSo, for each node `i`, `M[i]` must be a multiple of `g` and a divisor of `l` for *every* edge `(i, j, g, l)` incident to `i`.\nThis means `M[i]` must be a multiple of `LCM(g_1, g_2, ...)` and a divisor of `GCD(l_1, l_2, ...)` for all edges `(i, j_k, g_k, l_k)` incident to `i`. Let `min_mult[i]` be `LCM` of all `g_k` and `max_div[i]` be `GCD` of all `l_k`.\nIf `min_mult[i]` does not divide `max_div[i]`, then no solution exists.\nAlso, `M[i]` must be a multiple of `min_mult[i]` and a divisor of `max_div[i]`.\nThis significantly reduces the search space for `M[i]`.\nThe candidate values for `M[i]` are now divisors of `max_div[i]` that are multiples of `min_mult[i]`.\n\nLet's refine the BFS/DFS approach:\n1. Pre-check `l % g == 0` for all edges. If not, print \"NO\".\n2. Create an adjacency list `adj[u]` storing `(v, g, l)` for each edge.\n3. Initialize `ans[i] = 0` for all `i` (unknown). `visited[i] = False`.\n4. For each `i` from 1 to `n`:\n   If `ans[i] == 0`: (Node `i` is part of an unvisited component)\n     a. Start a BFS/DFS from `i`. Let `q` be a queue.\n     b. We need to pick an initial value for `ans[i]`.\n        The simplest is to pick `ans[i] = 1`. This might not always work or might lead to `M[v]` values that are too large/small.\n        A better initial value for `ans[i]` would be `min_mult[i]` (the LCM of all `g` values incident to `i`). This is the smallest possible value for `M[i]` that satisfies all `g` constraints.\n        Let's calculate `min_mult[i]` and `max_div[i]` for all `i`.\n        `min_mult[i] = 1` initially. For each edge `(i, j, g, l)`, `min_mult[i] = LCM(min_mult[i], g)`.\n        `max_div[i] = infinity` (or `10^6` or `l` of first edge) initially. For each edge `(i, j, g, l)`, `max_div[i] = GCD(max_div[i], l)`.\n        If `min_mult[i] > max_div[i]` or `max_div[i] % min_mult[i] != 0` for any `i`, print \"NO\".\n        If `ans[i]` is not determined, set `ans[i] = min_mult[i]`. Add `i` to `q`. Mark `visited[i] = True`.\n     c. While `q` is not empty:\n        Pop `u` from `q`.\n        For each neighbor `(v, g, l)` of `u`:\n          If `ans[v] == 0`: (Node `v` is unvisited in current component)\n            Calculate `potential_Mv = (g * l) // ans[u]`.\n            Check validity:\n              1. `potential_Mv` must be an integer (already guaranteed by `l % g == 0` and `ans[u]` being a multiple of `g`).\n              2. `potential_Mv` must be within `[1, 10^6]`.\n              3. `potential_Mv` must be a multiple of `min_mult[v]`.\n              4. `potential_Mv` must divide `max_div[v]`.\n              5. `GCD(ans[u], potential_Mv)` must be `g`.\n            If any check fails, print \"NO\" and exit.\n            Set `ans[v] = potential_Mv`. Add `v` to `q`.\n          Else (`ans[v]` is already determined):\n            Check consistency:\n              1. `ans[u] * ans[v]` must be `g * l`.\n              2. `GCD(ans[u], ans[v])` must be `g`.\n            If any check fails, print \"NO\" and exit.\n\n**Example of `min_mult` and `max_div` calculation:**\nNode 1 connected to (2, g1, l1) and (3, g2, l2).\n`min_mult[1] = LCM(g1, g2)`\n`max_div[1] = GCD(l1, l2)`\n\n**Algorithm Steps:**\n\n1. **Pre-processing:**\n   a. Read `n, m`.\n   b. Initialize `adj` as an adjacency list.\n   c. Initialize `min_mult[i] = 1` for all `i`.\n   d. Initialize `max_div[i] = 10**7` (a value larger than 10^6, effectively infinity for GCD) for all `i`.\n   e. For each edge `(u, v, g, l)`:\n      i. If `l % g != 0`, print \"NO\" and exit.\n      ii. Add `(v, g, l)` to `adj[u]` and `(u, g, l)` to `adj[v]`.\n      iii. Update `min_mult[u] = LCM(min_mult[u], g)`.\n      iv. Update `max_div[u] = GCD(max_div[u], l)`.\n      v. Update `min_mult[v] = LCM(min_mult[v], g)`.\n      vi. Update `max_div[v] = GCD(max_div[v], l)`.\n\n2. **Initial Checks based on `min_mult` and `max_div`:**\n   a. For each `i` from 1 to `n`:\n      If `min_mult[i] > max_div[i]` or `max_div[i] % min_mult[i] != 0` or `min_mult[i] > 10**6` or `max_div[i] > 10**6`:\n         Print \"NO\" and exit.\n      (The last two checks are important because `LCM` can grow large. `max_div` should always be `<= 10^6` if it's a `l` from input, but `min_mult` can exceed `10^6` if `g` values are large).\n\n3. **BFS/DFS Traversal:**\n   a. Initialize `ans[i] = 0` for all `i`.\n   b. For `i` from 1 to `n`:\n      If `ans[i] == 0`: (Start a new component traversal)\n         i. `q = deque()`\n         ii. Set `ans[i] = min_mult[i]`.\n         iii. If `ans[i] > 10**6`, print \"NO\" and exit. (It could have become large due to LCM operation)\n         iv. `q.append(i)`.\n         v. While `q` is not empty:\n            Pop `u` from `q`.\n            For each `(v, g, l)` in `adj[u]`:\n               If `ans[v] == 0`: (Unvisited neighbor)\n                  `potential_Mv = (g * l) // ans[u]`\n                  If `potential_Mv < 1` or `potential_Mv > 10**6`:\n                     Print \"NO\" and exit.\n                  If `potential_Mv % min_mult[v] != 0` or `max_div[v] % potential_Mv != 0`:\n                     Print \"NO\" and exit.\n                  If `GCD(ans[u], potential_Mv) != g`:\n                     Print \"NO\" and exit.\n                  `ans[v] = potential_Mv`\n                  `q.append(v)`\n               Else: (Visited neighbor, check consistency)\n                  If `ans[u] * ans[v] != g * l` or `GCD(ans[u], ans[v]) != g`:\n                     Print \"NO\" and exit.\n\n4. **Output:**\n   If all checks pass, print \"YES\" and then `ans[1] ... ans[n]`.\n\n**Helper Functions:**\n- `GCD(a, b)`: `math.gcd`\n- `LCM(a, b)`: `(a * b) // GCD(a, b)`. Need to be careful with overflow if `a*b` exceeds typical integer limits, but here `a, b <= 10^6`, so `a*b` can be `10^12`, which fits in Python's arbitrary precision integers.\n\n**Edge Cases:**\n- `m = 0`: All `ans[i]` remain 0. `min_mult[i]` will be 1, `max_div[i]` will be `10^7`. The loops for `ans[i] == 0` will set `ans[i] = 1`. Prints \"YES\" and `1 1 ... 1`. This is correct.\n- Disconnected graph: Handled by iterating `i` from 1 to `n` and starting BFS for unvisited nodes.\n- `n=1, m=0`: Prints \"YES\\n1\". Correct.\n- Values of `g` or `l` outside `[1, 10^6]` are guaranteed not to happen.\n- Mushroom counts must be `[1, 10^6]`. This is checked.\n\n**Complexity:**\n- Pre-processing: `O(N + M * log(max_val))` for GCD/LCM calculations. `max_val` is `10^6`.\n- BFS/DFS: `O(N + M * log(max_val))` for GCD calculations within the loop.\nOverall: `O((N + M) * log(max_val))`. Given `N, M <= 10^5`, `log(10^6)` is small (around 20 for base 2), this should be efficient enough.\n\nLet's consider the `min_mult[i]` and `max_div[i]` bounds.\n`min_mult[i]` can be up to `10^6` (if all `g_k` are `10^6`).\n`max_div[i]` can be up to `10^6` (if all `l_k` are `10^6`).\nIf `min_mult[i]` becomes greater than `10^6`, it's impossible, as `M[i]` must be `<= 10^6`.\nAlso, `ans[i]` could be `min_mult[i]`, which could be `> 10^6`. This needs to be checked when assigning `ans[i] = min_mult[i]`.\n\n```python\nimport math\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, input().split())\n\n    adj = [[] for _ in range(n + 1)]\n    \n    # min_mult[i] stores LCM of all g values connected to i\n    # max_div[i] stores GCD of all l values connected to i\n    # Initialize max_div with a large value (e.g., 10^7) or the first l value\n    min_mult = [1] * (n + 1)\n    max_div = [0] * (n + 1) # Will be updated with first l value, or 10^7 if no edges\n\n    edges_data = [] # Store edges to process min_mult/max_div properly\n\n    for _ in range(m):\n        u, v, g, l = map(int, input().split())\n        edges_data.append((u, v, g, l))\n\n        if l % g != 0:\n            print(\"NO\")\n            return\n        \n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l))\n    \n    # Initialize max_div for nodes with edges, and 1 for isolated nodes\n    for i in range(1, n + 1):\n        if adj[i]:\n            max_div[i] = edges_data[0][3] # Initialize with an arbitrary l from an edge\n            for neighbor_v, neighbor_g, neighbor_l in adj[i]:\n                max_div[i] = math.gcd(max_div[i], neighbor_l)\n                min_mult[i] = (min_mult[i] * neighbor_g) // math.gcd(min_mult[i], neighbor_g)\n        else:\n            max_div[i] = 1 # Isolated node can have 1 mushroom\n\n    # Check initial conditions for min_mult and max_div\n    for i in range(1, n + 1):\n        if min_mult[i] > max_div[i] or max_div[i] % min_mult[i] != 0:\n            print(\"NO\")\n            return\n        if min_mult[i] > 10**6: # Mushroom count must be <= 10^6\n             print(\"NO\")\n             return\n\n    ans = [0] * (n + 1) # Stores the determined mushroom counts\n\n    for i in range(1, n + 1):\n        if ans[i] == 0: # If node i hasn't been visited yet (start a new component)\n            q = deque()\n            \n            # Initial value for M[i] is min_mult[i]\n            ans[i] = min_mult[i]\n            if ans[i] < 1 or ans[i] > 10**6:\n                print(\"NO\")\n                return\n            q.append(i)\n\n            while q:\n                u = q.popleft()\n\n                for v, g, l in adj[u]:\n                    if ans[v] == 0: # Neighbor v is unvisited in this component\n                        potential_Mv = (g * l) // ans[u]\n                        \n                        if potential_Mv < 1 or potential_Mv > 10**6:\n                            print(\"NO\")\n                            return\n                        \n                        # Check if potential_Mv satisfies min_mult and max_div constraints for v\n                        if potential_Mv % min_mult[v] != 0 or max_div[v] % potential_Mv != 0:\n                            print(\"NO\")\n                            return\n                        \n                        # Final check: GCD(ans[u], potential_Mv) must be g\n                        if math.gcd(ans[u], potential_Mv) != g:\n                            print(\"NO\")\n                            return\n                        \n                        ans[v] = potential_Mv\n                        q.append(v)\n                    else: # Neighbor v has already been visited and its value determined\n                        # Check consistency\n                        if ans[u] * ans[v] != g * l:\n                            print(\"NO\")\n                            return\n                        if math.gcd(ans[u], ans[v]) != g:\n                            print(\"NO\")\n                            return\n    \n    print(\"YES\")\n    print(*(ans[1:]))\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, input().split())\n\n    adj = [[] for _ in range(n + 1)]\n    \n    # min_mult[i] stores LCM of all g values connected to i\n    # max_div[i] stores GCD of all l values connected to i\n    # Initialize max_div with a large value (e.g., 10^7) or the first l value\n    min_mult = [1] * (n + 1)\n    max_div = [0] * (n + 1) # Will be updated with first l value, or 10^7 if no edges\n\n    edges_data = [] # Store edges to process min_mult/max_div properly\n\n    for _ in range(m):\n        u, v, g, l = map(int, input().split())\n        edges_data.append((u, v, g, l))\n\n        if l % g != 0:\n            print(\"NO\")\n            return\n        \n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l))\n    \n    # Initialize max_div for nodes with edges, and 1 for isolated nodes\n    for i in range(1, n + 1):\n        if adj[i]:\n            max_div[i] = edges_data[0][3] # Initialize with an arbitrary l from an edge\n            for neighbor_v, neighbor_g, neighbor_l in adj[i]:\n                max_div[i] = math.gcd(max_div[i], neighbor_l)\n                min_mult[i] = (min_mult[i] * neighbor_g) // math.gcd(min_mult[i], neighbor_g)\n        else:\n            max_div[i] = 1 # Isolated node can have 1 mushroom\n\n    # Check initial conditions for min_mult and max_div\n    for i in range(1, n + 1):\n        if min_mult[i] > max_div[i] or max_div[i] % min_mult[i] != 0:\n            print(\"NO\")\n            return\n        if min_mult[i] > 10**6: # Mushroom count must be <= 10^6\n             print(\"NO\")\n             return\n\n    ans = [0] * (n + 1) # Stores the determined mushroom counts\n\n    for i in range(1, n + 1):\n        if ans[i] == 0: # If node i hasn't been visited yet (start a new component)\n            q = deque()\n            \n            # Initial value for M[i] is min_mult[i]\n            ans[i] = min_mult[i]\n            if ans[i] < 1 or ans[i] > 10**6:\n                print(\"NO\")\n                return\n            q.append(i)\n\n            while q:\n                u = q.popleft()\n\n                for v, g, l in adj[u]:\n                    if ans[v] == 0: # Neighbor v is unvisited in this component\n                        potential_Mv = (g * l) // ans[u]\n                        \n                        if potential_Mv < 1 or potential_Mv > 10**6:\n                            print(\"NO\")\n                            return\n                        \n                        # Check if potential_Mv satisfies min_mult and max_div constraints for v\n                        if potential_Mv % min_mult[v] != 0 or max_div[v] % potential_Mv != 0:\n                            print(\"NO\")\n                            return\n                        \n                        # Final check: GCD(ans[u], potential_Mv) must be g\n                        if math.gcd(ans[u], potential_Mv) != g:\n                            print(\"NO\")\n                            return\n                        \n                        ans[v] = potential_Mv\n                        q.append(v)\n                    else: # Neighbor v has already been visited and its value determined\n                        # Check consistency\n                        if ans[u] * ans[v] != g * l:\n                            print(\"NO\")\n                            return\n                        if math.gcd(ans[u], ans[v]) != g:\n                            print(\"NO\")\n                            return\n    \n    print(\"YES\")\n    print(*(ans[1:]))\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 542,
        "completion_token_count": 4756,
        "thoughts_token_count": 721
    }
}