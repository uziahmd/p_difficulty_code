{
    "start": 1758009380.6772332,
    "end": 1758009438.9824548,
    "start-formatted": "2025-09-16 16:56 KST",
    "end-formatted": "2025-09-16 16:57 KST",
    "gpu": 2,
    "pid": 8,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "**Thinking Through \"Flawed Flow\"**\n\nOkay, so I've got this \"Flawed Flow\" problem in front of me.  It's a classic graph problem with a twist.  My goal is a Python script to solve it. Let's break down the input and the constraints, and see where this leads.\n\nFirst, I have the input: `n` vertices and `m` edges, each edge specified with a capacity. My output needs to be a direction for each edge (0 or 1, essentially). This tells me whether the flow goes from node `ai` to `bi` or vice-versa.\n\nThe real meat of the problem is in the *conditions* for this flow.\n\n1.  **Flow Conservation:** This is the big one. For any vertex that isn't the source (vertex 1) or the potential sink (vertex n), the amount of flow going in must equal the amount of flow going out. That's a fundamental principle of network flows.\n\n2.  **Source Condition (Vertex 1):** The source has *no* incoming flow. Everything attached to vertex 1 must be outgoing. This is a crucial starting point to identify.\n\n3.  **Acyclicity:** This means the directed graph I construct can't have cycles. Flow needs to move in a consistent direction. I'll need to figure out how to satisfy this, maybe by applying topological sorting principles.\n\n4.  **Max Flow Implication:** The problem is tricky here. The provided `ci` values are guaranteed to be consistent with *some* maximum flow solution.  I just have to build a graph that satisfies the other three conditions. I won't have to explicitly compute the max flow here; just direction assignment is the requirement.\n\nNow, some critical observations are popping into my head. The acyclicity and the source with no incoming edges strongly point to a Directed Acyclic Graph (DAG) and some kind of topological ordering. Flow will typically travel from the \"earlier\" vertices in the topological order to the \"later\" vertices.\n\nThe flow conservation, especially for those intermediate vertices (not 1 or n), is the most important constraint. It forces a balance. The flow in must equal the flow out.\n\nThe source (vertex 1) is a no-brainer. All edges from vertex 1 go outwards.  That's a nice easy starting point.\n\nThe sink (vertex *n*) is an interesting consideration. Though not explicitly stated in the problem statement, with the flow conservation and acyclicity constraint, I can almost guarantee that n will be the sink, or where the flow accumulates. This needs verification, but makes intuitive sense. For instance, if an edge came *out* of n, where would that flow go such that conservation holds?\n\nSo, I need to think about incoming/outgoing flows.\nFor vertex `v`:\nLet `In(v)` be the sum of `ci` for edges `u -> v`.\nLet `Out(v)` be the sum of `ci` for edges `v -> u`.\n\n*   For `1 < v < n`: `In(v) = Out(v)`.\n*   For `v = 1`: `In(1) = 0`. All edges connected to 1 must be `1 -> u`.\n*   For `v = n`: The problem doesn't explicitly state `Out(n) = 0`. But in practice of DAGs, that feels necessary.\n\nThis is a good point to start the Python code. I am thinking of using a graph library or building my own graph data structure. I'll need to think about how to apply these observations to construct the correct direction. The acyclicity will also be a major concern, I will likely need to incorporate some cycle-detection logic.\n",
    "response": "The problem asks us to direct edges of an undirected graph, given their flow volumes, such that specific conditions for a max-flow are met:\n1.  **Flow Conservation:** For any intermediate vertex `v` (1 < `v` < `n`), the sum of incoming flow equals the sum of outgoing flow.\n2.  **Source Condition:** Vertex 1 has no incoming edges.\n3.  **Acyclicity:** The resulting directed graph must not contain cycles.\n4.  **Max Flow:** The resulting flow should be a correct maximum flow (guaranteed to exist).\n\nLet's analyze the conditions:\n\n*   **Source (Vertex 1):** The condition that vertex 1 has no incoming edges implies that all flow on edges connected to vertex 1 must originate from vertex 1. This means if an edge is (1, `u`) with flow `c`, it must be directed `1 -> u`.\n\n*   **Acyclicity:** This is a crucial constraint. Combined with the source condition, it strongly suggests a topological ordering of vertices. Flow generally moves from \"earlier\" vertices in the topological order to \"later\" ones.\n\n*   **Flow Conservation:** For any vertex `v` (1 < `v` < `n`), the net flow must be zero. That is, `sum(incoming_flow) - sum(outgoing_flow) = 0`.\n\nConsider the sum of all flow volumes `C` connected to a vertex `v`. This is `sum(c_i)` for all edges `(v, u_i)` or `(u_i, v)`. Let this be `total_flow_at_v`.\nIf we direct an edge `v -> u` with flow `c`, `c` contributes to `outgoing_flow_at_v`.\nIf we direct an edge `u -> v` with flow `c`, `c` contributes to `incoming_flow_at_v`.\n\nFor each vertex `v` (1 < `v` < `n`), we need `incoming_flow_at_v = outgoing_flow_at_v`.\nThis implies that `2 * incoming_flow_at_v = total_flow_at_v`.\nSo, `total_flow_at_v` must be an even number. This is a necessary condition for flow conservation, but not sufficient.\n\nLet's define `current_incoming_flow[v]` as the sum of flows on edges already directed into `v`.\nLet `current_outgoing_flow[v]` as the sum of flows on edges already directed out of `v`.\n\nThe strategy involves a topological sort-like approach:\n\n1.  **Initialize:**\n    *   For each vertex `v`, calculate `total_flow_at_v = sum(c_i)` for all edges incident to `v`.\n    *   Initialize `balance[v] = 0` for all `v`. This `balance[v]` will track `incoming_flow - outgoing_flow`.\n    *   Create an adjacency list for the graph, storing `(neighbor, flow_volume, edge_index)` for each edge.\n    *   Maintain a `visited` array for edges to avoid processing the same edge twice.\n    *   Initialize `ans` array to store the directions.\n\n2.  **Queue for Processing:** We use a queue for vertices that are ready to be processed. A vertex `v` is \"ready\" if we know enough about its flow to make decisions about its incident edges.\n    *   Initially, add vertex `1` to the queue. Vertex `1` has a strict condition: all its edges must be outgoing.\n\n3.  **Breadth-First Search (BFS) / Topological Sort:**\n    *   While the queue is not empty:\n        *   Dequeue a vertex `u`.\n        *   For each undirected edge `(u, v)` with flow `c` and original index `idx` connected to `u` (that hasn't been directed yet):\n            *   Mark this edge as visited.\n            *   Determine the direction based on `u`'s role:\n                *   If `u = 1` (source): The edge must be `1 -> v`. So, `ans[idx] = 0` (if `a_i=1, b_i=v`) or `ans[idx] = 1` (if `a_i=v, b_i=1`).\n                *   If `u = n` (sink): The problem doesn't explicitly state `Out(n)=0`, but combined with acyclicity and conservation for intermediate nodes, flow typically terminates at `n`. If we are processing `u=n`, it means `u` was reached from `v` via `v -> n`. So, the edge must be `v -> n`. This means `ans[idx] = 0` (if `a_i=v, b_i=n`) or `ans[idx] = 1` (if `a_i=n, b_i=v`).\n                *   If `1 < u < n` (intermediate vertex): We need `balance[u] = 0` eventually. If we are processing `u`, it means all *other* edges incident to `u` have already been processed and contributed to `balance[u]`. At this point, `balance[u]` should be `total_flow_at_u - 2 * current_incoming_flow[u]`. If `balance[u]` is non-zero, it means this last edge `(u, v)` must be directed to make `balance[u]` zero.\n                    *   Specifically, if `balance[u] > 0`, it means `u` has too much incoming flow (or too little outgoing flow). The edge `(u, v)` must be `u -> v`. Direct it `u -> v`. Update `balance[u] -= c` and `balance[v] += c`.\n                    *   If `balance[u] < 0`, it means `u` has too much outgoing flow (or too little incoming flow). The edge `(u, v)` must be `v -> u`. Direct it `v -> u`. Update `balance[u] += c` and `balance[v] -= c`.\n                    *   (In our specific BFS approach, `balance[u]` will be `0` when we process `u` *unless* `u` is the source or sink. For intermediate nodes, we use the `total_flow_at_v` and `current_flow_sum[v]` to decide.)\n\nA more robust approach for intermediate nodes, respecting the acyclicity and source conditions:\nWe can use a BFS starting from the source (vertex 1).\nFor each vertex `u` we visit:\n1.  We need to ensure `balance[u]` eventually becomes 0 (for `1 < u < n`).\n2.  We want to direct edges away from `u` if possible, to maintain a topological order.\n\nLet's refine the BFS:\nWe'll track `current_flow_sum[v]`: the sum of flows of edges incident to `v` that have already been directed.\nWe'll also track `total_flow_at_v`: the sum of all flow volumes incident to `v`.\n\n1.  **Initialization:**\n    *   `adj`: Adjacency list `adj[u]` stores `(v, c, edge_idx)` for undirected edge `(u,v)` with flow `c` and original index `idx`.\n    *   `ans`: Array of size `m`, initialized to -1.\n    *   `total_flow_at_v[v]`: Sum of flow volumes of all edges incident to `v`.\n    *   `current_flow_sum[v]`: Sum of flow volumes of *incoming* edges *already directed* into `v`.\n    *   `queue`: A `deque` for BFS.\n    *   `visited_edges`: A set or boolean array to mark edges that have been processed.\n\n2.  **Start BFS:**\n    *   Add vertex `1` to the queue.\n    *   For each edge `(1, v)` with flow `c` and index `idx`:\n        *   Direct it `1 -> v`. Set `ans[idx]` appropriately (0 if input was `1 v`, 1 if input was `v 1`).\n        *   Add `c` to `current_flow_sum[v]`.\n        *   Mark edge `idx` as visited.\n        *   If `v != n` and `current_flow_sum[v] * 2 == total_flow_at_v[v]`: This means all flow conservation requirements for `v` are met. Add `v` to the queue.\n\n3.  **BFS Loop:**\n    *   While `queue` is not empty:\n        *   Dequeue `u`.\n        *   For each neighbor `v` of `u` via edge `(u, v)` with flow `c` and index `idx`:\n            *   If edge `idx` is already visited, continue.\n            *   Mark edge `idx` as visited.\n            *   Direct the edge `u -> v`. Set `ans[idx]` appropriately.\n            *   Add `c` to `current_flow_sum[v]`.\n            *   If `v != n` and `current_flow_sum[v] * 2 == total_flow_at_v[v]`: Add `v` to the queue.\n\nThis BFS strategy effectively builds a directed acyclic graph (DAG) where flow moves from source to sink.\n*   Vertex 1's edges are all outgoing.\n*   For any intermediate vertex `u` that is dequeued, we direct all its *remaining* undirected edges away from `u`. This implies that `u` is \"processed\" and its outgoing flow is being established.\n*   When a neighbor `v` receives flow from `u`, its `current_flow_sum[v]` increases. If `v` is an intermediate node and `current_flow_sum[v]` becomes exactly half of `total_flow_at_v[v]`, it means all its *incoming* flow is accounted for. At this point, `v` is ready to have its *outgoing* edges directed. This is precisely when `v` is added to the queue.\n*   The condition `current_flow_sum[v] * 2 == total_flow_at_v[v]` ensures that `sum(incoming_flow) = sum(outgoing_flow)` for intermediate nodes. Since we are always directing edges from `u` to `v` where `u` was processed earlier in BFS, we guarantee acyclicity.\n*   The sink `n` is never added to the queue, as its `current_flow_sum[n]` will accumulate all incoming flow, and it doesn't need to satisfy `current_flow_sum[n] * 2 == total_flow_at_v[n]` (unless it's a special case where all flow goes `1->n` directly). Its role is simply to receive flow.\n\nThis approach correctly handles all conditions.\n\n**Example Walkthrough:**\nInput:\n3 3\n3 2 10 (edge 0: a=3, b=2, c=10)\n1 2 10 (edge 1: a=1, b=2, c=10)\n3 1 5  (edge 2: a=3, b=1, c=5)\n\n1.  **Initialization:**\n    *   `adj`:\n        *   `adj[1] = [(2, 10, 1), (3, 5, 2)]`\n        *   `adj[2] = [(3, 10, 0), (1, 10, 1)]`\n        *   `adj[3] = [(2, 10, 0), (1, 5, 2)]`\n    *   `ans = [-1, -1, -1]`\n    *   `total_flow_at_v`: `[0, 15, 20, 15]` (index 0 unused, index 1 for vertex 1, etc.)\n        *   `total_flow_at_v[1] = 10 + 5 = 15`\n        *   `total_flow_at_v[2] = 10 + 10 = 20`\n        *   `total_flow_at_v[3] = 10 + 5 = 15`\n    *   `current_flow_sum = [0, 0, 0, 0]`\n    *   `queue = deque()`\n    *   `visited_edges = set()`\n\n2.  **Start BFS (add 1 to queue):**\n    *   `queue = [1]`\n    *   Process edges from vertex 1:\n        *   Edge (1, 2, 10, idx=1):\n            *   `ans[1] = 0` (1->2, input was 1 2)\n            *   `current_flow_sum[2] += 10` (`current_flow_sum[2]` is now 10)\n            *   `visited_edges.add(1)`\n            *   `v = 2` is not `n=3`. `current_flow_sum[2]*2 = 20`. `total_flow_at_v[2] = 20`. They are equal. Add 2 to queue. `queue = [1, 2]`\n        *   Edge (1, 3, 5, idx=2):\n            *   `ans[2] = 0` (1->3, input was 3 1, so 1->3 is `b_i -> a_i`, which is 1)\n            *   `current_flow_sum[3] += 5` (`current_flow_sum[3]` is now 5)\n            *   `visited_edges.add(2)`\n            *   `v = 3` is `n`. Do not add to queue. `queue = [1, 2]`\n\n3.  **BFS Loop:**\n    *   Dequeue `u = 1`. (Done processing its edges in start phase).\n    *   Dequeue `u = 2`.\n        *   For each neighbor of 2:\n            *   Edge (2, 3, 10, idx=0):\n                *   `idx=0` not visited.\n                *   `ans[0] = 0` (2->3, input was 3 2, so 2->3 is `b_i -> a_i`, which is 1)\n                *   `current_flow_sum[3] += 10` (`current_flow_sum[3]` is now 5 + 10 = 15)\n                *   `visited_edges.add(0)`\n                *   `v = 3` is `n`. Do not add to queue.\n            *   Edge (2, 1, 10, idx=1):\n                *   `idx=1` is visited. Skip.\n    *   Queue is empty.\n\n4.  **Final `ans`:**\n    *   `ans[0]` (edge 3 2 10) was set to 1 (direction 2->3).\n    *   `ans[1]` (edge 1 2 10) was set to 0 (direction 1->2).\n    *   `ans[2]` (edge 3 1 5) was set to 1 (direction 1->3).\n\nOutput:\n1\n0\n1\nThis matches the example output.\n\n```python\nimport sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    edges_input = []\n    adj = [[] for _ in range(n + 1)]\n    total_flow_at_v = [0] * (n + 1)\n\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        edges_input.append((u, v, c))\n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n        total_flow_at_v[u] += c\n        total_flow_at_v[v] += c\n\n    ans = [-1] * m\n    current_incoming_flow_sum = [0] * (n + 1) # Sum of flow on incoming edges already directed\n    \n    q = deque()\n    visited_edges = [False] * m # To keep track of edges whose direction has been determined\n\n    # Start BFS from source (vertex 1)\n    q.append(1)\n\n    # Process edges directly connected to source (vertex 1)\n    # All edges from vertex 1 must be outgoing\n    for neighbor, flow_c, edge_idx in adj[1]:\n        if not visited_edges[edge_idx]:\n            u_original, v_original, _ = edges_input[edge_idx]\n            \n            # Determine direction: 1 -> neighbor\n            if u_original == 1: # Input was 1 -> neighbor\n                ans[edge_idx] = 0\n            else: # Input was neighbor -> 1, so 1 -> neighbor is b_i -> a_i\n                ans[edge_idx] = 1\n            \n            visited_edges[edge_idx] = True\n            current_incoming_flow_sum[neighbor] += flow_c\n            \n            # If 'neighbor' is an intermediate node and its incoming flow sum\n            # reaches half of its total incident flow, it means all its incoming flow\n            # is accounted for. It's ready to be processed for its outgoing edges.\n            if neighbor != n and current_incoming_flow_sum[neighbor] * 2 == total_flow_at_v[neighbor]:\n                q.append(neighbor)\n    \n    # BFS to process intermediate nodes\n    # For any intermediate node 'u' dequeued, all its *incoming* flow must be accounted for.\n    # We then direct its *remaining* undirected edges away from 'u'.\n    while q:\n        u = q.popleft()\n\n        # Iterate through all incident edges of u\n        for neighbor, flow_c, edge_idx in adj[u]:\n            if not visited_edges[edge_idx]:\n                u_original, v_original, _ = edges_input[edge_idx]\n\n                # Direction must be u -> neighbor\n                if u_original == u: # Input was u -> neighbor\n                    ans[edge_idx] = 0\n                else: # Input was neighbor -> u, so u -> neighbor is b_i -> a_i\n                    ans[edge_idx] = 1\n                \n                visited_edges[edge_idx] = True\n                current_incoming_flow_sum[neighbor] += flow_c\n\n                # If 'neighbor' is an intermediate node and its incoming flow sum\n                # reaches half of its total incident flow, it's ready to be processed.\n                if neighbor != n and current_incoming_flow_sum[neighbor] * 2 == total_flow_at_v[neighbor]:\n                    q.append(neighbor)\n    \n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + '\\n')\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    edges_input = []\n    adj = [[] for _ in range(n + 1)]\n    total_flow_at_v = [0] * (n + 1)\n\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        edges_input.append((u, v, c))\n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n        total_flow_at_v[u] += c\n        total_flow_at_v[v] += c\n\n    ans = [-1] * m\n    current_incoming_flow_sum = [0] * (n + 1) # Sum of flow on incoming edges already directed\n    \n    q = deque()\n    visited_edges = [False] * m # To keep track of edges whose direction has been determined\n\n    # Start BFS from source (vertex 1)\n    q.append(1)\n\n    # Process edges directly connected to source (vertex 1)\n    # All edges from vertex 1 must be outgoing\n    for neighbor, flow_c, edge_idx in adj[1]:\n        if not visited_edges[edge_idx]:\n            u_original, v_original, _ = edges_input[edge_idx]\n            \n            # Determine direction: 1 -> neighbor\n            if u_original == 1: # Input was 1 -> neighbor\n                ans[edge_idx] = 0\n            else: # Input was neighbor -> 1, so 1 -> neighbor is b_i -> a_i\n                ans[edge_idx] = 1\n            \n            visited_edges[edge_idx] = True\n            current_incoming_flow_sum[neighbor] += flow_c\n            \n            # If 'neighbor' is an intermediate node and its incoming flow sum\n            # reaches half of its total incident flow, it means all its incoming flow\n            # is accounted for. It's ready to be processed for its outgoing edges.\n            if neighbor != n and current_incoming_flow_sum[neighbor] * 2 == total_flow_at_v[neighbor]:\n                q.append(neighbor)\n    \n    # BFS to process intermediate nodes\n    # For any intermediate node 'u' dequeued, all its *incoming* flow must be accounted for.\n    # We then direct its *remaining* undirected edges away from 'u'.\n    while q:\n        u = q.popleft()\n\n        # Iterate through all incident edges of u\n        for neighbor, flow_c, edge_idx in adj[u]:\n            if not visited_edges[edge_idx]:\n                u_original, v_original, _ = edges_input[edge_idx]\n\n                # Direction must be u -> neighbor\n                if u_original == u: # Input was u -> neighbor\n                    ans[edge_idx] = 0\n                else: # Input was neighbor -> u, so u -> neighbor is b_i -> a_i\n                    ans[edge_idx] = 1\n                \n                visited_edges[edge_idx] = True\n                current_incoming_flow_sum[neighbor] += flow_c\n\n                # If 'neighbor' is an intermediate node and its incoming flow sum\n                # reaches half of its total incident flow, it's ready to be processed.\n                if neighbor != n and current_incoming_flow_sum[neighbor] * 2 == total_flow_at_v[neighbor]:\n                    q.append(neighbor)\n    \n    for i in range(m):\n        sys.stdout.write(str(ans[i]) + '\\n')\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 736,
        "completion_token_count": 4389,
        "thoughts_token_count": 752
    }
}