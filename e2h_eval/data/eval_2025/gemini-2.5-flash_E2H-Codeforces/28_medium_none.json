{
    "start": 1758294919.3671582,
    "end": 1758295028.4610467,
    "start-formatted": "2025-09-20 00:15 KST",
    "end-formatted": "2025-09-20 00:17 KST",
    "gpu": 2,
    "pid": 28,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vasily the Bear and Beautiful Strings\n\nVasily the Bear loves beautiful strings. String s is beautiful if it meets the following criteria:   String s only consists of characters 0 and 1, at that character 0 must occur in string s exactly n times, and character 1 must occur exactly m times.  We can obtain character g from string s with some (possibly, zero) number of modifications. The character g equals either zero or one. A modification of string with length at least two is the following operation: we replace two last characters from the string by exactly one other character. This character equals one if it replaces two zeros, otherwise it equals zero. For example, one modification transforms string \"01010\" into string \"0100\", two modifications transform it to \"011\". It is forbidden to modify a string with length less than two.Help the Bear, count the number of beautiful strings. As the number of beautiful strings can be rather large, print the remainder after dividing the number by 1000000007 (109 + 7). \n\n## Input\nThe first line of the input contains three space-separated integers n, m, g (0 ≤ n, m ≤ 105, n + m ≥ 1, 0 ≤ g ≤ 1).\n\n## Output\nPrint a single integer — the answer to the problem modulo 1000000007 (109 + 7).\n\n## Example\n### Input\n['1 1 0', '2 2 0', '1 1 1']\n\n### Output\n['2', '4', '0']\n\n## Note\nIn the first sample the beautiful strings are: \"01\", \"10\".In the second sample the beautiful strings are: \"0011\", \"1001\", \"1010\", \"1100\".In the third sample there are no beautiful strings.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "**Alright, here's my breakdown of this \"Vasily the Bear and Beautiful Strings\" problem, as I see it:**\n\nI'm tackling a counting problem, where the core idea is taking a string of zeros and ones, and condensing it down using a special rule. The rule is basically like a NOR gate, taking the last two characters and replacing them with a new one.  I need to figure out how many initial strings will, after repeated application of this rule, end up with a single specific character `g`.\n\nMy first thought was that this looks like binary arithmetic, but the \"NOR\" logic is the key.  I quickly realized that the *order* of the characters in the string matters.  Also, the string’s *value* isn't the key - it's the sequence of operations. This operation acts from right to left like a recursive reduction.\n\nI’m trying to identify properties of this reduction.  One key observation is that if there is a '1', it will eventually become a '0' (except in the case where the final string is `1`). I tried to consider the number of ones and zeros, but it turns out the parity of the first one is the key.\n\nThen, I focused on the string's composition - `n` zeros, `m` ones. The goal is to calculate the number of beautiful strings for each combination of `n`, `m`, and `g`.\n\nWhen there are no 1s, the parity of `n` determines the final value.  If there's at least one `1` in the string, I’ve worked out that it depends on the index of the *first* `1` in the string, is even or odd. If the first 1 has an even index, the final value will be 1 and zero otherwise.\n\nSo, for each combination, I have to compute `C(n + m - k - 1, m-1)` for appropriate `k` values, where `k` represents the number of leading zeros. The constraints are straightforward to compute, the main focus will be correctly selecting valid `k` values, given `g` and `n`.\n\nUltimately, I need a combinatorics-based solution. The algorithm must precompute factorials and inverse factorials, apply the binomial coefficient calculations efficiently, and correctly sum the possibilities based on the first \"1\" position.\n",
    "response": "The problem asks us to count the number of binary strings `s` that contain exactly `n` zeros and `m` ones, such that after repeatedly applying a specific modification operation, the string reduces to a single character `g`. The result should be modulo 1000000007.\n\nThe modification operation replaces the two last characters `c_1 c_2` with a single character `res`.\n`res = '1'` if `c_1 = '0'` and `c_2 = '0'`.\n`res = '0'` otherwise (i.e., if `c_1='0', c_2='1'` or `c_1='1', c_2='0'` or `c_1='1', c_2='1'`).\n\nLet `f(s)` denote the final single character obtained from string `s`. If `s` has length `k`, the operation is applied `k-1` times. The problem statement's example `01010` -> `0100` -> `011` suggests a right-to-left reduction. However, the example `000 -> 01 -> 0` in my scratchpad and the common interpretation of such problems (like `eval` in Lisp) often implies a left-to-right reduction. Let's verify the operation order.\n\nThe phrasing \"replace two last characters\" means `s_1 s_2 ... s_{k-2} s_{k-1} s_k` becomes `s_1 s_2 ... s_{k-2} op(s_{k-1}, s_k)`.\nThis is a right-associative reduction. Let `R(s)` be the final character.\n`R(c_1 c_2 ... c_k) = R(c_1 ... c_{k-2} op(c_{k-1}, c_k))`.\nThis is equivalent to `R(s) = op(c_1, op(c_2, ..., op(c_{k-1}, c_k)...))` IF the operation was `op(s_1, s_2)` followed by `op(res, s_3)` etc. This is left-associative.\n\nLet's trace `000` with the right-associative rule:\n`000 -> 0 op(0,0) -> 01 -> op(0,1) -> 0`.\nThis matches the example `000 -> 01 -> 0` from my scratchpad.\nSo `f(c_1, ..., c_k) = op(c_1, f(c_2, ..., c_k))` is indeed the correct recursive definition for the final character, where `f(c_k) = c_k`.\n\nLet's analyze `op(X, Y)`:\n`op(0,0) = 1`\n`op(0,1) = 0`\n`op(1,0) = 0`\n`op(1,1) = 0`\nThe result is `1` if and only if both inputs are `0`. Otherwise, it's `0`.\n\nLet `S_i` be the result of `f(c_i, c_{i+1}, ..., c_k)`. We want to find `S_1`.\n`S_k = c_k`.\n`S_i = op(c_i, S_{i+1})`.\n\n**Case 1: `m = 0` (string consists of `n` zeros)**\nThe string is `00...0` (`n` times).\n`S_n = 0`.\n`S_{n-1} = op(0, S_n) = op(0,0) = 1`.\n`S_{n-2} = op(0, S_{n-1}) = op(0,1) = 0`.\n`S_{n-3} = op(0, S_{n-2}) = op(0,0) = 1`.\nThe pattern is `S_i = 1` if `n-i` is odd, and `S_i = 0` if `n-i` is even.\nWe want `S_1`. Here `n-1` is the number of operations to get to `S_1` from `S_n`.\n`S_1 = 1` if `n-1` is odd (i.e., `n` is even).\n`S_1 = 0` if `n-1` is even (i.e., `n` is odd).\nThere is only 1 such string (`0...0`).\nSo, if `m=0`:\n*   If `g=1`: answer is `1` if `n` is even, `0` otherwise.\n*   If `g=0`: answer is `1` if `n` is odd, `0` otherwise.\n\n**Case 2: `m > 0` (string contains at least one '1')**\nLet `j` be the 1-based index of the *first* '1' in the string.\nThis means `c_1 = c_2 = ... = c_{j-1} = '0'`, and `c_j = '1'`.\nFrom `S_j` onwards:\n`S_j = op(c_j, S_{j+1}) = op(1, S_{j+1}) = 0`. (Since `op(1, X)` is always `0`).\nNow we propagate this `S_j=0` to the left:\n`S_{j-1} = op(c_{j-1}, S_j) = op(0, 0) = 1`. (Since `c_{j-1}=0`).\n`S_{j-2} = op(c_{j-2}, S_{j-1}) = op(0, 1) = 0`. (Since `c_{j-2}=0`).\n`S_{j-3} = op(c_{j-3}, S_{j-2}) = op(0, 0) = 1`. (Since `c_{j-3}=0`).\nThis pattern `1, 0, 1, 0, ...` continues until `S_1`.\nSpecifically, `S_{j-x}` is `1` if `x` is odd, and `0` if `x` is even.\nWe are interested in `S_1`. This corresponds to `x = j-1`.\nSo, `S_1 = 1` if `j-1` is odd (i.e., `j` is even).\n`S_1 = 0` if `j-1` is even (i.e., `j` is odd).\n\nThis rule is consistent with the example outputs:\n*   `n=1, m=1, g=0`: Strings are \"01\", \"10\".\n    *   For \"01\": first '1' is at `j=2` (even). My rule says `g=1`.\n    *   For \"10\": first '1' is at `j=1` (odd). My rule says `g=0`.\n    The output `g=0` means we only count \"10\". My rule correctly identifies \"10\" as `g=0`. But the example output is `2`, implying \"01\" is also counted for `g=0`.\n    This indicates a misunderstanding or a trick. The note \"In the first sample the beautiful strings are: '01', '10'\" is for `g=0`.\n    Let's re-verify the rules for `n=1, m=1`.\n    \"01\": `op(0,1) = 0`. Final `g=0`.\n    \"10\": `op(1,0) = 0`. Final `g=0`.\n    Both strings result in `g=0`. My rule `S_1=1` if `j` is even, `S_1=0` if `j` is odd is wrong.\n\nLet's re-evaluate the function `f(s)` using the example output.\n`f(\"01\") = 0`\n`f(\"10\") = 0`\nMy rule predicted `f(\"01\") = 1` (j=2, even) and `f(\"10\") = 0` (j=1, odd).\nThe rule `S_1 = 1` if `j` is even, `S_1 = 0` if `j` is odd is incorrect.\n\nThe problem states \"we replace two last characters\". This means `s_1 s_2 ... s_{k-1} s_k` becomes `s_1 ... s_{k-2} op(s_{k-1}, s_k)`.\nThis is a right-associative operation.\n`f(c_1, c_2, ..., c_k)` is the result.\n`f(c_1, ..., c_k) = f(c_1, ..., c_{k-2}, op(c_{k-1}, c_k))`.\nThis is *not* `op(c_1, f(c_2, ..., c_k))`.\nLet `s = s_1 s_2 ... s_L`.\n`s_1 s_2 ... s_L`\n`s_1 s_2 ... s_{L-2} (op(s_{L-1}, s_L))`\n`s_1 s_2 ... s_{L-3} (op(s_{L-2}, op(s_{L-1}, s_L)))`\nThis is `s_1 op(s_2, op(s_3, ... op(s_{L-1}, s_L) ...))`. This is left-associative.\nNo, that's not it either. It's `op(s_1, s_2)` then `op(res, s_3)` for left-associative.\nThe operation `op(c_1, c_2)` is applied to the two characters on the *right*.\nLet's define `Result(s_1 s_2 ... s_k)`:\nIf `k=1`, `Result(s_1) = s_1`.\nIf `k>=2`, `Result(s_1 ... s_k) = Result(s_1 ... s_{k-2} op(s_{k-1}, s_k))`.\n\nLet's retrace `001` with this:\n`Result(001) = Result(0 op(0,1)) = Result(00) = Result(op(0,0)) = Result(1) = 1`. Correct.\nLet's retrace `01` with this:\n`Result(01) = Result(op(0,1)) = Result(0) = 0`. Correct.\nLet's retrace `10` with this:\n`Result(10) = Result(op(1,0)) = Result(0) = 0`. Correct.\n\nNow the example `n=1, m=1, g=0` output `2` makes sense. Both \"01\" and \"10\" produce `g=0`.\nMy recursive definition of `f` was wrong. The correct one is `f(s_1 ... s_k) = f(s_1 ... s_{k-2} op(s_{k-1}, s_k))`.\n\nLet `v(c)` be the integer value of character `c` (0 or 1).\n`v(op(c_1, c_2)) = (1-v(c_1)) * (1-v(c_2))`. This is `1` iff both `c_1=0, c_2=0`.\nLet `A_k` be the final result of a string of length `k`.\n`A_k(s_1 ... s_k) = A_{k-1}(s_1 ... s_{k-2} ((1-s_{k-1})(1-s_k)))`.\n\nConsider the number of ones modulo 2.\n`00 -> 1`: `m` changes from `0` to `1`. Parity changes.\n`01 -> 0`: `m` changes from `1` to `0`. Parity changes.\n`10 -> 0`: `m` changes from `1` to `0`. Parity changes.\n`11 -> 0`: `m` changes from `2` to `0`. Parity unchanged.\n\nThis is equivalent to `s_i = 1` if `s_i` is the result of `00`.\nThe character `1` can only be generated from `00`.\nIf the string contains any `1`s initially, and `n` is the count of `0`s, `m` is the count of `1`s.\nThe final character `g` is `1` if and only if the *number of zeros* `n` is odd.\nThis is a known property of this specific operation (NOR-like, or `(1-x)(1-y)`).\nLet `N_0` be the number of zeros and `N_1` be the number of ones.\nThe operation `op(X,Y)`:\n- `00 -> 1`: `N_0` decreases by 2, `N_1` increases by 1. `N_0 mod 2` changes.\n- `01 -> 0`: `N_0` decreases by 1, `N_1` decreases by 1. `N_0` becomes `N_0-1+1 = N_0`. `N_1` becomes `N_1-1`. `N_0 mod 2` unchanged.\n- `10 -> 0`: `N_0` decreases by 1, `N_1` decreases by 1. `N_0 mod 2` unchanged.\n- `11 -> 0`: `N_0` unchanged, `N_1` decreases by 2. `N_0 mod 2` unchanged.\n\nThe only way `N_0 mod 2` changes is if `00` is replaced by `1`.\nEvery other operation preserves `N_0 mod 2`.\nThe final string has length 1.\nIf the final character is `0`, then `N_0=1, N_1=0`.\nIf the final character is `1`, then `N_0=0, N_1=1`.\n\nLet `P_0` be the parity of the number of zeros.\nIf `g=0`: `P_0` must be odd.\nIf `g=1`: `P_0` must be even.\n\nThis is because `(1-x)(1-y)` has the property `(1-x)(1-y) = 1` if and only if `x=0, y=0`.\nIf we have `k` zeros initially, the final character `g` will be `1` if and only if `k` is odd.\nLet's try this rule: `g=1` iff `n` is odd.\n`n=1, m=1, g=0`: `n=1` (odd). Rule says `g=1`. But we need `g=0`. So this rule is `g=1` iff `n` is odd.\nSo, if `n` is odd, `g=1`. If `n` is even, `g=0`. This is the rule for the target `g`.\n\nLet's re-check the examples with `g = (n % 2 == 1)`.\nExample 1: `n=1, m=1, g=0`. `n=1` (odd). Rule predicts `g=1`. Required `g=0`. This means no string can be beautiful. Output `2`.\nMy rule `g = (n % 2 == 1)` is incorrect.\n\nThis operation is `NOR`.\n`x NOR y = 1` iff `x=0` and `y=0`.\nLet `s_i` be boolean values (0 for '0', 1 for '1').\nThe sequence of operations is `s_1, s_2, ..., s_k`\n`s_1, s_2, ..., s_{k-2}, (s_{k-1} NOR s_k)`\n`s_1, s_2, ..., s_{k-3}, (s_{k-2} NOR (s_{k-1} NOR s_k))`\nThis is `s_1 NOR (s_2 NOR (s_3 NOR ... (s_{k-1} NOR s_k)...))`. (Left-associative interpretation of original problem's description)\nNo, that's not right. The operation is always on the LAST two chars.\n`f(s_1 ... s_k) = f(s_1 ... s_{k-2} (s_{k-1} NOR s_k))`\nThis means the final result depends on the *number of ones* modulo 2.\nSpecifically, `g = 0` if `m` is even, and `g = 1` if `m` is odd.\nThis is a known property for `NOR` reduction.\nLet's test this rule: `g = (m % 2 == 1)`.\n\nExample 1: `n=1, m=1, g=0`. `m=1` (odd). Rule predicts `g=1`. Required `g=0`. This means no string can be beautiful. Output `2`. Still wrong.\n\nThe rule is `g = (m == 0 && n % 2 == 0) || (m % 2 == 1 && n % 2 == 1) || (m % 2 == 0 && n % 2 == 0)` for `g=0`\nNo, this is getting confusing.\nLet's use the actual example results:\n`n=1, m=1, g=0` -> 2 strings (\"01\", \"10\")\n`n=2, m=2, g=0` -> 4 strings (\"0011\", \"1001\", \"1010\", \"1100\")\n`n=1, m=1, g=1` -> 0 strings\n\nFrom this, it seems `g=1` is impossible if `m=1`.\nLet's check `m=1`:\n`0...01`. `n` zeros, then one `1`. Length `n+1`.\n`f(0...01) = f(0...0 op(0,1)) = f(0...00)`. This is `n` zeros.\nIf `n` is odd, `f(0...00)` for `n` zeros is `0`.\nIf `n` is even, `f(0...00)` for `n` zeros is `1`.\nThis is for `m=1` and the `1` is at the end.\n\nWhat if `1` is not at the end? `0...010...0`.\n`f(s_1 ... s_j ... s_k)`.\nIf `s_k = 1`, then `op(s_{k-1}, s_k) = 0`. So `s_1 ... s_{k-2} 0`.\nIf `s_k = 0`, then `op(s_{k-1}, s_k)` can be `0` or `1`.\nIf there is *any* `1` in the string, say `s_j=1`, and `s_{j+1}, ..., s_k` are all `0`.\nThen `op(s_{k-1}, s_k)` will be `1` if `s_{k-1}=0, s_k=0`.\nThis implies that `1`s can be generated even if none exist initially.\n\nLet's consider the parity of the number of zeros `n` and ones `m`.\nThe final character `g` is `0` if `n` is even.\nThe final character `g` is `1` if `n` is odd.\nThis is for `m > 0`.\nIf `m=0`, `g=0` if `n` is odd, `g=1` if `n` is even.\nThis is the `(n%2 == 0)` for `g=1` rule.\n\nLet's test this rule: `g = 1` if `n` is odd (when `m>0`). `g = 0` if `n` is even (when `m>0`).\nAnd `g = 1` if `n` is even (when `m=0`). `g = 0` if `n` is odd (when `m=0`).\nThis can be summarized as:\nIf `m=0`, `g = (n%2 == 0)`.\nIf `m>0`, `g = (n%2 == 1)`.\n\nExample 1: `n=1, m=1, g=0`. `m>0`. `n=1` (odd). Rule predicts `g=1`. Required `g=0`. So `0` strings. Output `2`. Still wrong.\n\nThe rule is actually much simpler:\nThe final character `g` is `1` if and only if `n` is odd AND `m` is even.\nOtherwise, `g` is `0`.\nLet's test this rule: `g_predicted = (n % 2 == 1 and m % 2 == 0)`.\n\nExample 1: `n=1, m=1, g=0`. `n=1` (odd), `m=1` (odd). `g_predicted = (True and False) = False`. So `g_predicted = 0`. Matches `g=0`. Correct.\nExample 2: `n=2, m=2, g=0`. `n=2` (even), `m=2` (even). `g_predicted = (False and True) = False`. So `g_predicted = 0`. Matches `g=0`. Correct.\nExample 3: `n=1, m=1, g=1`. `n=1` (odd), `m=1` (odd). `g_predicted = (True and False) = False`. So `g_predicted = 0`. Required `g=1`. So `0` strings. Correct.\n\nThis rule seems to be the correct one!\nThe rule is: The final character `g` is `1` if `n` is odd and `m` is even. Otherwise, `g` is `0`.\n\nNow, we need to count strings:\n1.  If `g=1`: We need `n` odd AND `m` even.\n    If `n` is even OR `m` is odd, then the answer is `0`.\n    Otherwise (`n` odd AND `m` even), the answer is `C(n+m, n)`. (Any string with `n` zeros and `m` ones will work).\n2.  If `g=0`: We need `n` even OR `m` is odd.\n    If `n` is odd AND `m` is even, then the answer is `0`.\n    Otherwise (`n` even OR `m` is odd), the answer is `C(n+m, n)`.\n\nThis looks like `C(n+m, n)` if the conditions match, else `0`.\nThis is a very simple result. Let's double check the `m=0` case.\nIf `m=0`:\n`n=1, m=0, g=0`. `n=1` (odd), `m=0` (even). Predicted `g=1`. Required `g=0`. Result 0.\n`n=1, m=0, g=1`. `n=1` (odd), `m=0` (even). Predicted `g=1`. Required `g=1`. Result 1. (String \"0\").\n`n=2, m=0, g=0`. `n=2` (even), `m=0` (even). Predicted `g=0`. Required `g=0`. Result 1. (String \"00\").\n`n=2, m=0, g=1`. `n=2` (even), `m=0` (even). Predicted `g=0`. Required `g=1`. Result 0.\n\nThis rule holds for `m=0` too.\nThe only edge case for `C(N, K)` is `N=0, K=0`, where `C(0,0)=1`.\n`n=0, m=1, g=0`. `n=0` (even), `m=1` (odd). Predicted `g=0`. Required `g=0`. Result `C(0+1, 0) = C(1,0) = 1`. (String \"1\").\n`n=0, m=1, g=1`. `n=0` (even), `m=1` (odd). Predicted `g=0`. Required `g=1`. Result `0`.\n\nThis rule `g_predicted = (n % 2 == 1 and m % 2 == 0)` seems to be universally correct.\nSo the logic is:\n1. Calculate `g_actual_for_n_m = (n % 2 == 1 and m % 2 == 0)`.\n2. If `g_actual_for_n_m == g`, then the answer is `C(n+m, n)`.\n3. Else, the answer is `0`.\n\nThe maximum value for `n+m` is `2 * 10^5`. We need to compute combinations `C(N, K) = N! / (K! * (N-K)!) mod P`.\nThis requires precomputing factorials and inverse factorials modulo `P = 1000000007`.\n\n**Implementation details:**\n*   `MOD = 1000000007` (prime number).\n*   Precompute factorials `fact[i]` up to `N_MAX = 2 * 10^5`.\n*   Precompute inverse factorials `invFact[i]` using Fermat's Little Theorem: `a^(P-2) mod P` for `a^(P-1) = 1 mod P`.\n    `invFact[i] = pow(fact[i], MOD - 2, MOD)`.\n*   `n_plus_m = n + m`.\n*   If `n+m == 0`, the input constraint `n+m >= 1` prevents this.\n*   `C(N, K)` function: `fact[N] * invFact[K] * invFact[N-K] % MOD`. Handle `K < 0` or `K > N` returning `0`.\n\nFinal check for constraints: `0 <= n, m <= 10^5`, `n+m >= 1`.\nIf `n=0, m=0`, `n+m=0`, but this is disallowed.\nIf `n=0, m=1`, `C(1,0)=1`.\nIf `n=1, m=0`, `C(1,1)=1`.\n\nThis problem is a classic example where the operation's effect on parity (or some other invariant) simplifies the problem greatly. The `(1-x)(1-y)` operation is related to the number of zeros. The final value depends only on the parity of `n` and `m`.\n\n```python\nimport sys\n\nMOD = 1000000007\nMAX_N_M = 2 * 10**5\n\nfact = [1] * (MAX_N_M + 1)\ninv_fact = [1] * (MAX_N_M + 1)\n\ndef precompute_factorials():\n    for i in range(1, MAX_N_M + 1):\n        fact[i] = (fact[i-1] * i) % MOD\n    \n    inv_fact[MAX_N_M] = pow(fact[MAX_N_M], MOD - 2, MOD)\n    for i in range(MAX_N_M - 1, -1, -1):\n        inv_fact[i] = (inv_fact[i+1] * (i+1)) % MOD\n\ndef combinations(n, k):\n    if k < 0 or k > n:\n        return 0\n    return (((fact[n] * inv_fact[k]) % MOD) * inv_fact[n-k]) % MOD\n\ndef solve():\n    n, m, g = map(int, sys.stdin.readline().split())\n\n    precompute_factorials()\n\n    # The rule for the final character g is:\n    # g is 1 if n is odd AND m is even.\n    # Otherwise, g is 0.\n    \n    # This can be written as:\n    # g_predicted = (n % 2 == 1 and m % 2 == 0)\n    \n    # Check if the target g matches the predicted g\n    if (n % 2 == 1 and m % 2 == 0) == (g == 1):\n        # If they match, all C(n+m, n) strings are beautiful\n        print(combinations(n + m, n))\n    else:\n        # If they don't match, no strings are beautiful\n        print(0)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\nMOD = 1000000007\nMAX_N_M = 2 * 10**5\n\nfact = [1] * (MAX_N_M + 1)\ninv_fact = [1] * (MAX_N_M + 1)\n\ndef precompute_factorials():\n    for i in range(1, MAX_N_M + 1):\n        fact[i] = (fact[i-1] * i) % MOD\n    \n    inv_fact[MAX_N_M] = pow(fact[MAX_N_M], MOD - 2, MOD)\n    for i in range(MAX_N_M - 1, -1, -1):\n        inv_fact[i] = (inv_fact[i+1] * (i+1)) % MOD\n\ndef combinations(n, k):\n    if k < 0 or k > n:\n        return 0\n    return (((fact[n] * inv_fact[k]) % MOD) * inv_fact[n-k]) % MOD\n\ndef solve():\n    n, m, g = map(int, sys.stdin.readline().split())\n\n    precompute_factorials()\n\n    # The rule for the final character g is:\n    # g is 1 if n is odd AND m is even.\n    # Otherwise, g is 0.\n    \n    # This can be written as:\n    # g_predicted = (n % 2 == 1 and m % 2 == 0)\n    \n    # Check if the target g matches the predicted g\n    if (n % 2 == 1 and m % 2 == 0) == (g == 1):\n        # If they match, all C(n+m, n) strings are beautiful\n        print(combinations(n + m, n))\n    else:\n        # If they don't match, no strings are beautiful\n        print(0)\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 559,
        "completion_token_count": 6742,
        "thoughts_token_count": 8191
    }
}