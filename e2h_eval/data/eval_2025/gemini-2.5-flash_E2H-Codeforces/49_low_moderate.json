{
    "start": 1758284909.8211398,
    "end": 1758285040.91665,
    "start-formatted": "2025-09-19 21:28 KST",
    "end-formatted": "2025-09-19 21:30 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "**Thinking Through \"Mushroom Strife\"**\n\nOkay, so I've got this \"Mushroom Strife\" problem. It's a graph problem, and I need to find valid mushroom counts for each lawn (vertex). Each lawn has a number of mushrooms associated with it, and the constraints are derived from the edges which give me GCD and LCM of mushrooms on each linked lawn.\n\nHere's my thought process:\n\nFirst, let's unpack the core relationships.  I know that for any two positive integers (the mushroom counts), their product equals the product of their GCD and LCM. That's fundamental. If `a * b = g * l`, and I have `g` and `l` for a given edge, I'm working with the idea that `a * b = g * l`. And I realize `a` and `b` must be multiples of `g`.\n\nAha! We can derive relationships from this! Let `a = g * x` and `b = g * y`. Then  `GCD(x,y) = 1` because we defined `g` as the greatest common divisor. Also, `LCM(g*x, g*y) = g*x*y`. So  `l = g*x*y`. From this, I get  `l/g = x*y`.\n\nSo for each edge, I know a few things. First, both mushroom counts must be multiples of the GCD. Also, the LCM must be a multiple of the GCD. If that's not the case, boom, no solution. Then, the product of the mushroom counts is the product of the GCD and LCM. And let's call the mushroom counts divided by the GCD, `x_u` and `x_v`, respectively.  Then, the product of the newly defined `x_u` and `x_v` equals `l/g`, and they must be coprime, meaning their GCD is 1.\n\nI think I see a path. Since `n` is relatively small, I'm thinking about assignment and propagation. If I assign a value to one lawn, then I can use the edge constraints to derive the values of the connected lawns. However, the constraints on each edge will provide consistency, I think. If I start with a `mushrooms[u] = A`, then I know `A` is a multiple of `g_uv`. Then `mushrooms[v] = g_uv*l_uv/A`.\n\nThe maximum range for GCD and LCM is given to be 10^6, so the numbers will not be too large.  I need to design an algorithm to find *any* solution, or report no solution exists. I think some search method might work... possibly with backtracking if a bad assignment leads to a contradiction? Or perhaps a system of constraints?\n",
    "response": "The problem asks us to restore the number of mushrooms on `n` lawns, given `m` roads. For each road connecting lawns `u` and `v`, we are given `GCD(mushrooms[u], mushrooms[v])` and `LCM(mushrooms[u], mushrooms[v])`. We need to find any valid assignment of mushrooms or report that none exists.\n\n**Key Mathematical Properties:**\n\nFor any two positive integers `a` and `b`:\n1. `a * b = GCD(a, b) * LCM(a, b)`\n2. `GCD(a, b)` must divide both `a` and `b`.\n3. `a` and `b` must both divide `LCM(a, b)`.\n\nFrom these properties, if we are given `g = GCD(a, b)` and `l = LCM(a, b)`:\n* `l` must be a multiple of `g`. If `l % g != 0`, no solution exists.\n* `a` must be a multiple of `g`, so `a = g * x` for some integer `x`.\n* `b` must be a multiple of `g`, so `b = g * y` for some integer `y`.\n* Substituting into `a * b = g * l`: `(g * x) * (g * y) = g * l`, which simplifies to `g * x * y = l`.\n* This means `x * y = l / g`.\n* Also, `GCD(a, b) = GCD(g * x, g * y) = g * GCD(x, y)`. Since `GCD(a, b) = g`, it implies `GCD(x, y) = 1`.\n\nSo, for each edge `(u, v)` with `g_uv` and `l_uv`, we need to find `mushrooms[u]` and `mushrooms[v]` such that:\n1. `mushrooms[u]` and `mushrooms[v]` are both multiples of `g_uv`.\n2. `mushrooms[u] * mushrooms[v] = g_uv * l_uv`.\n3. Let `x_u = mushrooms[u] / g_uv` and `x_v = mushrooms[v] / g_uv`. Then `GCD(x_u, x_v) = 1`.\n\n**Algorithm Idea:**\n\nThe constraints `n <= 100` suggest that an `O(N^3)` or `O(N^4)` approach might be acceptable. The values of mushrooms are up to `10^6`.\n\nThis problem can be modeled as a system of constraints. We can use a Disjoint Set Union (DSU) data structure, but with a twist to handle the multiplicative relationships.\n\nLet `mushrooms[i]` be the number of mushrooms on lawn `i`.\nFor each lawn `i`, let's try to express `mushrooms[i]` as `C_i * K`, where `K` is some base value that we determine for a connected component, and `C_i` is a relative multiplier for lawn `i` within that component.\n\nConsider an edge `(u, v)` with `g_uv` and `l_uv`.\nIf `mushrooms[u]` is known, say `A`, then `mushrooms[v]` must be `(g_uv * l_uv) / A`. We also need to check `GCD(A, (g_uv * l_uv) / A) == g_uv`.\n\nThis suggests a graph traversal (like BFS or DFS) within each connected component.\n1. Initialize `ans[i] = 0` for all `i`. This indicates values are not yet determined.\n2. For each lawn `i` from 1 to `n`:\n   If `ans[i]` is 0, it means this lawn hasn't been assigned a value yet, so it starts a new connected component.\n   * Pick an arbitrary value for `ans[i]`. A good choice is `1`. This value will be a *tentative* assignment.\n   * Start a BFS/DFS from `i`.\n   * Maintain a queue/stack for traversal.\n   * When processing an edge `(curr, neighbor)` with `g_c_n` and `l_c_n`:\n     * If `ans[neighbor]` is 0:\n       * Calculate `expected_neighbor_val = (g_c_n * l_c_n) // ans[curr]`.\n       * Check consistency:\n         * `(g_c_n * l_c_n) % ans[curr] == 0` (must be divisible)\n         * `GCD(ans[curr], expected_neighbor_val) == g_c_n`\n         * `LCM(ans[curr], expected_neighbor_val) == l_c_n`\n       * If any check fails, this initial assignment for `ans[i]` is invalid. We need to backtrack or try a different approach.\n       * If consistent, set `ans[neighbor] = expected_neighbor_val` and add `neighbor` to queue/stack.\n     * If `ans[neighbor]` is not 0:\n       * It means `neighbor` has already been assigned a value (possibly from another path in the same component).\n       * Check if `ans[curr]` and `ans[neighbor]` are consistent with `g_c_n` and `l_c_n`:\n         * `GCD(ans[curr], ans[neighbor]) == g_c_n`\n         * `LCM(ans[curr], ans[neighbor]) == l_c_n`\n       * If inconsistent, this initial assignment for `ans[i]` is invalid.\n\nThe problem with picking `ans[i] = 1` arbitrarily is that it might not be the correct base value. The actual values could be `1 * K`, `3 * K`, `5 * K`, etc., where `K` is some common factor.\n\n**Revised Approach: Factorization and Constraints**\n\nLet `val[i]` be the number of mushrooms on lawn `i`.\nFor each edge `(u, v)` with `g_uv` and `l_uv`:\n1. `l_uv` must be divisible by `g_uv`. If not, output \"NO\".\n2. `val[u]` must be a multiple of `g_uv`.\n3. `val[v]` must be a multiple of `g_uv`.\n4. `val[u] * val[v] = g_uv * l_uv`.\n\nLet `P = l_uv / g_uv`. Then `(val[u]/g_uv) * (val[v]/g_uv) = P`.\nAlso, `GCD(val[u]/g_uv, val[v]/g_uv) = 1`.\nThis means `val[u]/g_uv` and `val[v]/g_uv` must be coprime factors of `P`.\n\nFor each `val[i]`, we can represent it as `val[i] = product of (p_j^e_j)`.\nConsider the prime factorization of `P = l_uv / g_uv`. Let `P = p_1^{a_1} * p_2^{a_2} * ... * p_k^{a_k}`.\nSince `val[u]/g_uv` and `val[v]/g_uv` are coprime, for each prime `p_j`, its entire power `p_j^{a_j}` must belong to either `val[u]/g_uv` or `val[v]/g_uv`, but not split between them.\n\nThis means for each lawn `i`, `val[i]` can be represented as `base_val[i] * factor[i]`, where `base_val[i]` captures the `g` parts and `factor[i]` captures the `l/g` parts.\nLet `val[i] = A_i`.\nFor an edge `(u, v)` with `g, l`:\n`A_u / g = X_u` and `A_v / g = X_v`.\n`X_u * X_v = l / g`.\n`GCD(X_u, X_v) = 1`.\n\nThis structure suggests that for each prime `p`, and each lawn `i`, `val[i]` has a certain exponent for `p`.\nLet `exp(N, p)` be the exponent of prime `p` in the factorization of `N`.\nFor `val[u]` and `val[v]`:\n`min(exp(val[u], p), exp(val[v], p)) = exp(g_uv, p)`\n`max(exp(val[u], p), exp(val[v], p)) = exp(l_uv, p)`\n\nThis means for every prime `p` and every edge `(u, v)`:\n`{exp(val[u], p), exp(val[v], p)} = {exp(g_uv, p), exp(l_uv, p)}`.\nThe sum `exp(val[u], p) + exp(val[v], p) = exp(g_uv, p) + exp(l_uv, p)`.\n\nThis is a 2-SAT like problem for exponents. For each prime `p` and each lawn `i`, `exp(val[i], p)` can be one of two values if `exp(g_uv, p) != exp(l_uv, p)`.\nSpecifically, `exp(val[u], p)` must be either `exp(g_uv, p)` or `exp(l_uv, p)`. The other exponent will be the remaining value.\nExample: `g_uv = 2^1 * 3^0`, `l_uv = 2^3 * 3^2`.\nFor `p=2`: `exp(g_uv, 2) = 1`, `exp(l_uv, 2) = 3`. So `{exp(val[u], 2), exp(val[v], 2)} = {1, 3}`.\nFor `p=3`: `exp(g_uv, 3) = 0`, `exp(l_uv, 3) = 2`. So `{exp(val[u], 3), exp(val[v], 3)} = {0, 2}`.\n\nWe can solve this independently for each prime factor `p` that appears in any `g` or `l` value.\nThe maximum value for `g, l` is `10^6`. Primes up to `10^6` are relevant. Sieve for primes up to `sqrt(10^6) = 1000` is enough for factorization, then check remaining factor.\n\nFor each prime `p`:\n* Create a graph where nodes are `1...n`.\n* For each edge `(u, v)` with `g_uv, l_uv`:\n    * Let `e_g = exp(g_uv, p)` and `e_l = exp(l_uv, p)`.\n    * If `e_g == e_l`, then `exp(val[u], p)` must be `e_g` and `exp(val[v], p)` must be `e_g`. This means `exp(val[i], p)` is fixed for `u` and `v`.\n    * If `e_g != e_l`:\n        * This means `exp(val[u], p)` is either `e_g` or `e_l`.\n        * If `exp(val[u], p) = e_g`, then `exp(val[v], p)` must be `e_l`.\n        * If `exp(val[u], p) = e_l`, then `exp(val[v], p)` must be `e_g`.\n        * This is a \"xor\" constraint. We can model this using a DSU or a 2-coloring approach.\n\n**DSU for Exponents:**\n\nFor each prime `p`, we want to determine `exp(val[i], p)` for all `i`.\nLet `offset[i][p]` be the exponent `exp(val[i], p)`.\nFor each prime `p`:\nInitialize `offset[i][p] = -1` (undetermined) for all `i`.\nInitialize `base_exp[i][p] = 0` for all `i`. This will store the fixed part of the exponent.\n\nIterate through edges `(u, v)` with `g, l`:\nFor each prime `p`:\n  `e_g = exp(g, p)`\n  `e_l = exp(l, p)`\n\n  If `e_g == e_l`:\n    For `k` in `{u, v}`:\n      If `offset[k][p] == -1`: `offset[k][p] = e_g`\n      Else if `offset[k][p] != e_g`: Conflict! Output \"NO\".\n  Else (`e_g != e_l`):\n    This is a relative constraint. `exp(val[u], p)` and `exp(val[v], p)` must be `e_g` and `e_l` in some order.\n    We can use a DSU for this. For each `i`, we have two states: `exp(val[i], p) = e_g` or `exp(val[i], p) = e_l`.\n    A better way for DSU:\n    For each node `i`, we want to find `val[i]`. Let `val[i] = R_i * X_i` where `R_i` is the root of `i`'s component, and `X_i` is the relative multiplier.\n    For an edge `(u, v)` with `g, l`: `val[u] * val[v] = g * l`.\n    If `u` and `v` are in the same component, say root `r`.\n    `val[u] = val[r] * rel[u]`, `val[v] = val[r] * rel[v]`.\n    `val[r]^2 * rel[u] * rel[v] = g * l`. This is problematic because `val[r]` is unknown.\n\nLet's stick to the exponent idea.\nFor each prime `p`:\nWe will assign `exp_val[i]` to `exp(val[i], p)`.\nWe can use a DSU where each node `i` has a `parent` and a `diff` value. `diff[i]` stores `exp_val[i] - exp_val[parent[i]]`.\nWhen merging `u` and `v` for prime `p`:\nFind roots `root_u` and `root_v`.\nIf `root_u == root_v`:\n  Check consistency: `(exp_val[u] - exp_val[v]) % 2 == (exp(l_uv, p) - exp(g_uv, p)) % 2`.\n  This is `exp(val[u], p) + exp(val[v], p) = exp(g_uv, p) + exp(l_uv, p)`.\n  And `min(exp(val[u], p), exp(val[v], p)) = exp(g_uv, p)`.\n  This is equivalent to `exp(val[u], p) = exp(g_uv, p)` and `exp(val[v], p) = exp(l_uv, p)` OR vice versa.\n  So `exp(val[u], p) - exp(val[v], p)` must be `exp(g_uv, p) - exp(l_uv, p)` or `exp(l_uv, p) - exp(g_uv, p)`.\n  The DSU `diff` should store `exp(val[i], p)` relative to `exp(val[root_i], p)`.\n  Let `exp(val[i], p) = E_i`.\n  We want to find `E_i`.\n  For an edge `(u, v)`: `{E_u, E_v} = {exp(g_uv, p), exp(l_uv, p)}`.\n  This means `E_u + E_v = exp(g_uv, p) + exp(l_uv, p)`.\n  And `E_u - E_v = +/- (exp(l_uv, p) - exp(g_uv, p))`.\n\nLet `base_exp[i]` be the actual `exp(val[i], p)` for node `i`.\nInitialize `base_exp[i] = -1` (undetermined) for all `i`.\nFor each prime `p`:\n  For each node `i`, `exp_offset[i]` stores `exp(val[i], p) - exp(val[root_i], p)`.\n  Initialize `parent[i] = i`, `exp_offset[i] = 0`.\n  For each edge `(u, v)` with `g_uv, l_uv`:\n    `e_g = exp(g_uv, p)`\n    `e_l = exp(l_uv, p)`\n    If `e_g == e_l`:\n      For `k` in `{u, v}`:\n        If `base_exp[k] == -1`: `base_exp[k] = e_g`.\n        Else if `base_exp[k] != e_g`: Conflict! Output \"NO\".\n    Else (`e_g != e_l`):\n      `root_u, total_offset_u = find_set(u)`\n      `root_v, total_offset_v = find_set(v)`\n      If `root_u != root_v`:\n        `parent[root_v] = root_u`\n        `exp_offset[root_v] = e_g + e_l - total_offset_u - total_offset_v` (This is `E_u + E_v = e_g + e_l`. `E_u = E_{root_u} + total_offset_u`, `E_v = E_{root_v} + total_offset_v`. So `E_{root_u} + total_offset_u + E_{root_v} + total_offset_v = e_g + e_l`. We set `E_{root_v} = e_g + e_l - total_offset_u - total_offset_v - E_{root_u}`. This `exp_offset[root_v]` is `E_{root_v} - E_{root_u}`.)\n        More simply, `exp_offset[root_v] = (e_g + e_l) - (total_offset_u + total_offset_v)`. This `exp_offset[root_v]` is the value of `exp(val[root_v], p)` relative to `exp(val[root_u], p)`.\n        No, this is wrong. `exp_offset` should be `exp(val[i], p) - exp(val[parent[i]], p)`.\n        When merging `u` and `v`:\n        `E_u + E_v = e_g + e_l`\n        `E_u = E_{root_u} + diff_u`\n        `E_v = E_{root_v} + diff_v`\n        So `E_{root_u} + diff_u + E_{root_v} + diff_v = e_g + e_l`.\n        We want to set `E_{root_v} = E_{root_u} + diff_new`.\n        `diff_new = E_{root_v} - E_{root_u} = e_g + e_l - diff_u - diff_v - 2 * E_{root_u}`. This still depends on `E_{root_u}`.\n\nThis implies that the DSU `diff` should store `exp(val[i], p)` directly, or `exp(val[i], p) % 2`.\nThe `exp(val[i], p) % 2` approach works for 2-coloring.\nFor `exp(val[i], p)` itself, we need to assign a value to `exp(val[root_i], p)`.\n\nLet's try a simpler DSU:\nFor each prime `p`:\n  `parent[i]` and `relative_exp[i]` for `i=1..n`.\n  `relative_exp[i]` stores `exp(val[i], p) - exp(val[parent[i]], p)`.\n  Initialize `parent[i]=i`, `relative_exp[i]=0`.\n  When processing edge `(u, v)` with `g, l`:\n    `e_g = exp(g, p)`, `e_l = exp(l, p)`\n    `root_u, path_exp_u = find_set(u)` (path_exp_u is `exp(val[u], p) - exp(val[root_u], p)`)\n    `root_v, path_exp_v = find_set(v)` (path_exp_v is `exp(val[v], p) - exp(val[root_v], p)`)\n\n    If `root_u != root_v`:\n      Merge `root_v` into `root_u`.\n      `parent[root_v] = root_u`\n      `relative_exp[root_v]` needs to be set.\n      We know `exp(val[u], p) + exp(val[v], p) = e_g + e_l`.\n      Substitute: `(exp(val[root_u], p) + path_exp_u) + (exp(val[root_v], p) + path_exp_v) = e_g + e_l`.\n      We need to find `exp(val[root_v], p) - exp(val[root_u], p)`.\n      `exp(val[root_v], p) - exp(val[root_u], p) = e_g + e_l - path_exp_u - path_exp_v - 2 * exp(val[root_u], p)`.\n      This still depends on `exp(val[root_u], p)`. This means we can't determine the absolute exponents yet, only relative ones.\n\n      The `exp(val[u], p) + exp(val[v], p) = e_g + e_l` constraint is an absolute sum.\n      The `min(exp(val[u], p), exp(val[v], p)) = e_g` constraint is also absolute.\n\n**Correct DSU for Exponents:**\n\nFor each prime `p`:\n  `parent[i]` and `diff[i]` for `i=1..n`.\n  `diff[i]` stores `exp(val[i], p) - exp(val[parent[i]], p)`.\n  Initialize `parent[i]=i`, `diff[i]=0`.\n  `final_exp[i]` stores the determined exponent for `val[i]` w.r.t. `p`. Initialize `final_exp[i] = -1`.\n\n  `find_set(i)`:\n    If `parent[i] == i`: return `(i, 0)`\n    `root, root_diff = find_set(parent[i])`\n    `parent[i] = root`\n    `diff[i] += root_diff`\n    return `(root, diff[i])`\n\n  For each edge `(u, v)` with `g_uv, l_uv`:\n    `e_g = exp(g_uv, p)`, `e_l = exp(l_uv, p)`\n    `root_u, d_u = find_set(u)`\n    `root_v, d_v = find_set(v)`\n\n    If `root_u != root_v`:\n      // `exp(val[u], p) = exp(val[root_u], p) + d_u`\n      // `exp(val[v], p) = exp(val[root_v], p) + d_v`\n      // We need `exp(val[u], p) + exp(val[v], p) = e_g + e_l`\n      // And `min(exp(val[u], p), exp(val[v], p)) = e_g`\n      // This implies `exp(val[u], p)` and `exp(val[v], p)` are `e_g` and `e_l` in some order.\n      // So `exp(val[u], p) - exp(val[v], p) = +/- (e_l - e_g)`.\n      // Let's assume we want `exp(val[root_v], p) - exp(val[root_u], p) = (e_l - e_g) - (d_u - d_v)`.\n      // This makes `exp(val[u], p) - exp(val[v], p) = (exp(val[root_u], p) + d_u) - (exp(val[root_u], p) + d_u + (e_l - e_g) - (d_u - d_v) + d_v) = d_u - d_v - (e_l - e_g) - (d_u - d_v) = -(e_l - e_g)`.\n      // If we want `exp(val[u], p) - exp(val[v], p) = +(e_l - e_g)`, then `exp(val[root_v], p) - exp(val[root_u], p) = (e_l - e_g) - (d_u - d_v)`.\n      // The issue is, we don't know which one is `e_g` and which is `e_l`.\n      // This means we have two choices for `diff[root_v]` relative to `diff[root_u]`.\n      // `diff[root_v] = (e_l - e_g) - (d_u - d_v)` or `diff[root_v] = (e_g - e_l) - (d_u - d_v)`.\n\n      // This is exactly the 2-coloring problem.\n      // For each node `i` and prime `p`, `exp(val[i], p)` can be `e_g` or `e_l`.\n      // If `e_g == e_l`, then `exp(val[i], p)` is fixed.\n      // If `e_g != e_l`, then `exp(val[i], p)` is either `e_g` or `e_l`.\n      // We can use a DSU for each prime `p`. Each node `i` has two \"states\": `i_0` (meaning `exp(val[i], p) = e_g`) and `i_1` (meaning `exp(val[i], p) = e_l`).\n      // For an edge `(u, v)` with `g, l`:\n      // `e_g = exp(g, p)`, `e_l = exp(l, p)`.\n      // If `e_g == e_l`:\n      //   All nodes in the component containing `u` and `v` must have `exp = e_g`.\n      //   This fixes `exp(val[i], p)` for the component.\n      // If `e_g != e_l`:\n      //   `u` has `e_g` and `v` has `e_l`, OR `u` has `e_l` and `v` has `e_g`.\n      //   This means `u_0` is connected to `v_1`, and `u_1` is connected to `v_0`.\n      //   We can use a DSU with `2N` elements. For each node `i`, `i` and `i+N` represent the two choices.\n      //   `parent[i]` and `parent[i+N]`.\n      //   `exp_choice[i]` stores `0` or `1` for node `i`.\n      //   `exp_choice[i]` = 0 means `exp(val[i], p)` will be `e_g`.\n      //   `exp_choice[i]` = 1 means `exp(val[i], p)` will be `e_l`.\n      //   When merging `u` and `v`:\n      //   We need `exp_choice[u] != exp_choice[v]`.\n      //   This is a standard 2-coloring DSU.\n      //   `union(u, v+N)` and `union(u+N, v)`.\n      //   If `find(u) == find(u+N)` then conflict.\n      //   After processing all edges, iterate through `i=1..n`. If `exp_choice[i]` is not determined, pick one (e.g., 0).\n      //   Then `exp(val[i], p)` is `e_g` if `exp_choice[i]=0`, else `e_l`.\n\nThis is the most promising approach.\n\n**Detailed Algorithm for each prime `p`:**\n\n1. **Precomputation:**\n   * Sieve primes up to `10^6`. Store them in a list `primes`.\n   * For each `N` up to `10^6`, compute `prime_factors_map[N]` which is a dictionary mapping prime `p` to `exp(N, p)`.\n\n2. **Overall Initialization:**\n   * `ans[i] = 1` for `i=1..n`. (This will store the final mushroom counts).\n   * `possible = true`.\n\n3. **Iterate through unique primes:**\n   * Collect all unique prime factors from all `g` and `l` values in the input. Let this set be `relevant_primes`.\n   * For each `p` in `relevant_primes`:\n     * Initialize DSU for `2N` elements: `parent[k]=k` for `k=0..2N-1`.\n     * `fixed_exp[i] = -1` for `i=1..n`. (Stores fixed exponent if `e_g == e_l`).\n     * `exp_g_val = {}`, `exp_l_val = {}`. Store `e_g` and `e_l` for `p` for each component.\n     * `has_fixed_exp = {}`. `has_fixed_exp[root]` is true if `root`'s component has a fixed exponent.\n\n     * For each edge `(u, v)` with `g_uv, l_uv`:\n       * `e_g = prime_factors_map[g_uv].get(p, 0)`\n       * `e_l = prime_factors_map[l_uv].get(p, 0)`\n\n       * If `e_g == e_l`:\n         * For `k` in `{u, v}`:\n           If `fixed_exp[k] == -1`: `fixed_exp[k] = e_g`.\n           Else if `fixed_exp[k] != e_g`: `possible = false`; break (inner loop).\n       * Else (`e_g != e_l`):\n         // This is the 2-coloring part\n         // Node `i` means `exp(val[i], p) = e_g`\n         // Node `i+N` means `exp(val[i], p) = e_l`\n         // We need `exp(val[u], p)` and `exp(val[v], p)` to be different.\n         // So `u` must be `e_g` if `v` is `e_l`, and vice versa.\n         // This means `union(u, v+N)` and `union(u+N, v)`.\n         `root_u_0 = find(u)`, `root_u_1 = find(u+N)`\n         `root_v_0 = find(v)`, `root_v_1 = find(v+N)`\n\n         // Check for existing conflicts:\n         // If u is already forced to be e_g (e.g. u_0 and u_1 are merged), then no solution.\n         // If u is forced to be e_l (e.g. u_1 and u_0 are merged), then no solution.\n         // If v is forced...\n         // Actually, the DSU will handle this. `find(u) == find(u+N)` implies conflict.\n\n         // Union `u` with `v+N` (u is e_g, v is e_l)\n         // Union `u+N` with `v` (u is e_l, v is e_g)\n         `union(u, v+N)`\n         `union(u+N, v)`\n\n         If `find(u) == find(u+N)`: `possible = false`; break (inner loop).\n         If `find(v) == find(v+N)`: `possible = false`; break (inner loop).\n\n     If `!possible`, break (outer loop).\n\n     // After processing all edges for prime `p`:\n     // Assign exponents based on DSU and `fixed_exp`.\n     For `i=1..n`:\n       If `fixed_exp[i] != -1`:\n         // This node's exponent is fixed.\n         // Check consistency with DSU.\n         // If `find(i)` is same as `find(i+N)`, conflict.\n         // If `find(i)` is same as `find(root_of_i_0)` and `find(i+N)` is same as `find(root_of_i_1)`.\n         // We need to pick `exp(val[i], p) = fixed_exp[i]`.\n         // This means we are effectively setting `i` to `fixed_exp[i]`.\n         // If `fixed_exp[i] == e_g`, then `i` is `i_0`. If `fixed_exp[i] == e_l`, then `i` is `i_1`.\n         // This needs to be done carefully.\n         // Let's modify the DSU to store the actual exponent values.\n\n**Revised DSU approach (Simpler):**\n\nFor each prime `p`:\n  `parent[i]` and `relative_xor[i]` for `i=1..n`.\n  `relative_xor[i]` stores `exp(val[i], p) % 2 == exp(val[parent[i]], p) % 2`.\n  `relative_xor[i] = 0` if they have same parity, `1` if different.\n  Initialize `parent[i]=i`, `relative_xor[i]=0`.\n  `abs_exp[i]` stores the actual `exp(val[i], p)`. Initialize `abs_exp[i] = -1`.\n\n  `find_set(i)`:\n    If `parent[i] == i`: return `(i, 0)`\n    `root, root_xor_diff = find_set(parent[i])`\n    `parent[i] = root`\n    `relative_xor[i] = (relative_xor[i] + root_xor_diff) % 2`\n    return `(root, relative_xor[i])`\n\n  For each edge `(u, v)` with `g_uv, l_uv`:\n    `e_g = prime_factors_map[g_uv].get(p, 0)`\n    `e_l = prime_factors_map[l_uv].get(p, 0)`\n\n    If `e_g == e_l`:\n      For `k` in `{u, v}`:\n        If `abs_exp[k] == -1`: `abs_exp[k] = e_g`.\n        Else if `abs_exp[k] != e_g`: `possible = false`; break (inner loop).\n    Else (`e_g != e_l`):\n      `root_u, xor_u = find_set(u)`\n      `root_v, xor_v = find_set(v)`\n      `required_xor = (e_g % 2 != e_l % 2) ? 1 : 0`. (No, this is wrong. `min(E_u, E_v) = e_g` and `max(E_u, E_v) = e_l`. So `E_u` and `E_v` must be `e_g` and `e_l` in some order. Thus `E_u % 2 != E_v % 2` if `e_g % 2 != e_l % 2`.)\n      `required_parity_diff = (e_g % 2 != e_l % 2)`\n\n      If `root_u != root_v`:\n        `parent[root_v] = root_u`\n        `relative_xor[root_v] = (xor_u + required_parity_diff + xor_v) % 2`. (This means `E_{root_v} % 2 == E_{root_u} % 2 + (xor_u + required_parity_diff + xor_v) % 2`).\n        This is `E_u % 2 = E_{root_u} % 2 + xor_u`. `E_v % 2 = E_{root_v} % 2 + xor_v`.\n        We need `E_u % 2 != E_v % 2` (if `required_parity_diff` is 1) or `E_u % 2 == E_v % 2` (if `required_parity_diff` is 0).\n        So `(E_{root_u} % 2 + xor_u) % 2 != (E_{root_v} % 2 + xor_v) % 2`.\n        Let `E_{root_v} % 2 = E_{root_u} % 2 + x`. Then `(xor_u + x) % 2 != xor_v % 2`.\n        `x = (xor_v - xor_u + required_parity_diff) % 2`.\n        `relative_xor[root_v] = x`.\n\n      Else (`root_u == root_v`):\n        If `(xor_u + xor_v) % 2 != required_parity_diff`: `possible = false`; break (inner loop).\n    If `!possible`, break (outer loop).\n\n  // After processing all edges for prime `p`:\n  // Now, for each component, we need to assign a base exponent `E_{root_i}`.\n  // Then `exp(val[i], p) = E_{root_i} + diff_i`.\n  // We need to ensure `min(exp(val[i],p), exp(val[j],p)) = e_g` for all edges.\n  // The DSU only tracks parity. We need actual exponents.\n\nThis problem is harder than just 2-coloring for parity. We need to assign specific exponents.\n\n**Final Attempt: DSU with value propagation and conflict detection.**\n\nFor each lawn `i`, `val[i]` is what we want to find.\n`ans[i]` stores the current value for `val[i]`. Initialize `ans[i] = 0`.\n`adj[i]` stores list of `(neighbor, g, l)` for lawn `i`.\n\nIterate `i` from 1 to `N`:\n  If `ans[i] == 0`: // `i` is not yet assigned, start a new component\n    `q = deque()`\n    `q.append(i)`\n    `ans[i] = 1` // Tentative assignment. This will be adjusted later.\n    `component_nodes = [i]`\n\n    While `q`:\n      `u = q.popleft()`\n      For `(v, g_uv, l_uv)` in `adj[u]`:\n        If `l_uv % g_uv != 0`: `possible = false`; break (inner loops).\n        If `ans[v] == 0`: // `v` is unassigned\n          `product_uv = g_uv * l_uv`\n          If `product_uv % ans[u] != 0`: `possible = false`; break.\n          `candidate_v = product_uv // ans[u]`\n          If `GCD(ans[u], candidate_v) != g_uv` or `LCM(ans[u], candidate_v) != l_uv`:\n            `possible = false`; break.\n          `ans[v] = candidate_v`\n          `q.append(v)`\n          `component_nodes.append(v)`\n        Else: // `v` is already assigned\n          If `GCD(ans[u], ans[v]) != g_uv` or `LCM(ans[u], ans[v]) != l_uv`:\n            `possible = false`; break.\n      If `!possible`, break (inner loops).\n    If `!possible`, break (outer loop).\n\n  // After a component is processed, `ans` values are relative to `ans[root]=1`.\n  // We need to find a `K` such that `ans[j] * K` for all `j` in `component_nodes` satisfy all conditions.\n  // For each edge `(u, v)` in the component:\n  // `GCD(ans[u]*K, ans[v]*K) = g_uv`\n  // `K * GCD(ans[u], ans[v]) = g_uv` => `K = g_uv / GCD(ans[u], ans[v])`.\n  // This `K` must be the same for all edges in the component.\n  // Let `K_uv = g_uv / GCD(ans[u], ans[v])`.\n  // All `K_uv` must be equal. If not, `possible = false`.\n  // Also, `K` must be an integer. So `g_uv` must be divisible by `GCD(ans[u], ans[v])`.\n  // And `LCM(ans[u]*K, ans[v]*K) = l_uv`\n  // `K * LCM(ans[u], ans[v]) = l_uv` => `K = l_uv / LCM(ans[u], ans[v])`.\n  // This `K` must also be consistent.\n\n  `current_K = -1`\n  For `u` in `component_nodes`:\n    For `(v, g_uv, l_uv)` in `adj[u]`:\n      If `u < v`: // Process each edge once\n        `g_current_nodes = GCD(ans[u], ans[v])`\n        `l_current_nodes = LCM(ans[u], ans[v])`\n        If `g_uv % g_current_nodes != 0`: `possible = false`; break (inner loops).\n        `k_candidate_g = g_uv // g_current_nodes`\n        If `l_uv % l_current_nodes != 0`: `possible = false`; break (inner loops).\n        `k_candidate_l = l_uv // l_current_nodes`\n\n        If `k_candidate_g != k_candidate_l`: `possible = false`; break.\n\n        If `current_K == -1`: `current_K = k_candidate_g`\n        Else if `current_K != k_candidate_g`: `possible = false`; break.\n    If `!possible`, break (inner loops).\n  If `!possible`, break (outer loop).\n\n  // Apply `current_K` to all nodes in the component\n  If `current_K == -1`: `current_K = 1` // For isolated nodes or components with no edges.\n  For `u` in `component_nodes`:\n    `ans[u] *= current_K`\n\nIf `!possible`, print \"NO\". Else print \"YES\" and `ans`.\n\n**Edge Case:** `N=1, M=0`. Output `YES\\n1`. My algorithm handles this. `ans[1]=0`, then `ans[1]=1`. `component_nodes=[1]`. `current_K` remains -1, then becomes 1. `ans[1]` becomes 1. Correct.\n\n**Constraints Check:**\n`GCD, LCM <= 10^6`. `ans[u]` can be up to `10^6`. `g*l` can be `10^12`. This will overflow standard 32-bit integers. Python handles large integers automatically.\n`N=100`, `M=N*(N-1)/2` approx `5000`.\nBFS/DFS for each component: `O(N+M)`. Sum over all components is `O(N+M)`.\nInside BFS, `GCD` and `LCM` calls. `GCD` is `log(max_val)`. `LCM` is `O(log(max_val))`.\n`g*l` can be `10^12`. `ans[u]` can be `10^6`. `product_uv // ans[u]` can be `10^6`.\nThe step to find `K`: For each component, iterate `component_nodes` and their edges. Total `O(M * log(max_val))`.\nTotal time complexity seems to be `O(M * log(max_val))`. This should be efficient enough.\n\n**GCD and LCM helper functions:**\n```python\nimport math\n\ndef gcd(a, b):\n    return math.gcd(a, b)\n\ndef lcm(a, b):\n    if a == 0 or b == 0:\n        return 0\n    return (a * b) // gcd(a, b)\n```\n\nThe `lcm` function needs to be careful about `a*b` overflowing if not using Python's arbitrary precision integers. Since Python handles large ints, this is fine.\n\n**Example 1: `2 1`, `1 2 1 3`**\n`n=2, m=1`. Edge `(1, 2)`, `g=1, l=3`.\n`ans = [0, 0]` (0-indexed for convenience, problem is 1-indexed)\n`i=0`: `ans[0]==0`.\n  `q = deque([0])`, `ans[0]=1`, `component_nodes=[0]`\n  `u=0`:\n    Edge `(0, 1)` with `g=1, l=3`.\n    `l % g == 0` (3%1==0). OK.\n    `ans[1]==0`.\n    `product_uv = 1*3 = 3`.\n    `product_uv % ans[0] == 0` (3%1==0). OK.\n    `candidate_v = 3 // 1 = 3`.\n    `GCD(ans[0], candidate_v) == GCD(1, 3) == 1`. Matches `g_uv`. OK.\n    `LCM(ans[0], candidate_v) == LCM(1, 3) == 3`. Matches `l_uv`. OK.\n    `ans[1]=3`. `q.append(1)`. `component_nodes=[0, 1]`.\n  `u=1`:\n    Edge `(1, 0)` with `g=1, l=3`.\n    `l % g == 0`. OK.\n    `ans[0]` is not 0.\n    `GCD(ans[1], ans[0]) == GCD(3, 1) == 1`. Matches `g_uv`. OK.\n    `LCM(ans[1], ans[0]) == LCM(3, 1) == 3`. Matches `l_uv`. OK.\n  Queue empty.\n  `current_K = -1`.\n  `u=0`:\n    Edge `(0, 1)`: `g_current_nodes = GCD(ans[0], ans[1]) = GCD(1, 3) = 1`.\n    `l_current_nodes = LCM(ans[0], ans[1]) = LCM(1, 3) = 3`.\n    `g_uv=1, l_uv=3`.\n    `g_uv % g_current_nodes == 0` (1%1==0). OK.\n    `k_candidate_g = 1 // 1 = 1`.\n    `l_uv % l_current_nodes == 0` (3%3==0). OK.\n    `k_candidate_l = 3 // 3 = 1`.\n    `k_candidate_g == k_candidate_l`. OK.\n    `current_K = 1`.\n  `u=1`: No new edges (already processed `(0,1)`).\n  Apply `current_K=1`: `ans[0]=1*1=1`, `ans[1]=3*1=3`.\n`i=1`: `ans[1]` is not 0. Skip.\nPrint `YES`, `1 3`. Correct.\n\n**Example 2: `3 2`, `3 2 1 2`, `3 1 1 10`**\n`n=3, m=2`. Edges: `(2, 3, g=1, l=2)`, `(1, 3, g=1, l=10)`. (1-indexed lawns)\n`ans = [0,0,0]`\n`i=0`: `ans[0]==0`.\n  `q = deque([0])`, `ans[0]=1`, `component_nodes=[0]`\n  `u=0`: (lawn 1)\n    Edge `(0, 2)` (lawn 1 and 3) with `g=1, l=10`.\n    `ans[2]==0`. `product_uv=10`. `candidate_v=10`.\n    `GCD(1, 10)=1`, `LCM(1, 10)=10`. OK.\n    `ans[2]=10`. `q.append(2)`. `component_nodes=[0, 2]`.\n  `u=2`: (lawn 3)\n    Edge `(2, 0)` (lawn 3 and 1) with `g=1, l=10`. Already processed.\n    Edge `(2, 1)` (lawn 3 and 2) with `g=1, l=2`.\n    `ans[1]==0`. `product_uv=1*2=2`. `ans[2]=10`. `product_uv % ans[2] != 0` (2%10 != 0).\n    `possible = false`. Break.\n\nThis is a problem! My initial `ans[0]=1` choice might be wrong.\nThe problem is that `ans[u]` must be a divisor of `g_uv * l_uv`. Here `ans[2]=10` is not a divisor of `g_uv * l_uv = 2`.\nThe `ans[i]` values are not just `1` for the root. They are `1` initially, but then `K` is multiplied.\nThe `ans[i]` values assigned during BFS/DFS are *relative* values.\nIf `ans[0]=1` leads to a conflict, it means `ans[0]` cannot be `1 * K`. It must be some other `X * K`.\n\nLet's rethink the `ans[i]` initialization.\nThe value `ans[i]` should be `X_i` where `X_i` is one of the factors of `l_uv / g_uv` for some edge.\nFor an edge `(u, v)` with `g, l`, we have `val[u] = g * x_u`, `val[v] = g * x_v`, where `x_u * x_v = l/g` and `GCD(x_u, x_v) = 1`.\nSo `val[u]` must be `g * (factor of l/g)`.\n\nThe crucial observation from the problem statement: \"numbers on the roads on the initial map were no less that 1 and did not exceed 10^6\". This means `mushrooms[i]` values are also within `[1, 10^6]`.\n\nThe values `val[u]` and `val[v]` for an edge `(u, v)` are `g_uv * x` and `g_uv * y` where `x * y = l_uv / g_uv` and `GCD(x, y) = 1`.\nThis means `x` and `y` are coprime factors of `l_uv / g_uv`.\nThere are `2^k` such pairs `(x, y)` where `k` is the number of distinct prime factors of `l_uv / g_uv`.\nFor `N=100`, `2^k` can be too many. `10^6` has at most 7 distinct prime factors (`2*3*5*7*11*13*17 = 510510`). So `2^7 = 128` pairs.\n\nWe can try assigning a value to `ans[i]` by picking one of the `g_uv * x` values for an adjacent edge.\nIf `ans[i]` is unassigned:\n  Pick an arbitrary adjacent edge `(i, j)` with `g, l`.\n  Calculate `P = l / g`. Find all coprime factor pairs `(x, y)` of `P`.\n  For each such pair `(x, y)`:\n    Try `ans[i] = g * x`.\n    Run BFS/DFS from `i` to assign values in the component.\n    If successful, verify `K` and apply.\n    If conflict, backtrack and try `ans[i] = g * y` (if `y != x`).\n    If all options fail, then `ans[i]` cannot be determined this way.\n\nThis is a search problem.\n`N` is small. We can try all possible values for `ans[1]`.\nIf `ans[1]` is fixed, then all values in its connected component are fixed.\nThe possible values for `ans[1]` are divisors of `LCM(g_1j * l_1j)` for all `j` connected to 1.\nMore specifically, for an edge `(1, j)` with `g, l`, `ans[1]` must be a divisor of `g*l` and a multiple of `g`.\nSo `ans[1]` must be of the form `g * x` where `x` is a divisor of `l/g`.\nThe number of divisors of `10^6` can be large. `720720` has `240` divisors.\n`max_val = 10^6`.\n`D(N)` is max `240` for `N <= 10^6`.\nIf we try `ans[1]` from `240` options, and each BFS is `M log MaxVal`.\nTotal `240 * M * log MaxVal`. `240 * 5000 * 20` is `2.4 * 10^7`. This might be acceptable.\n\n**Algorithm with Backtracking (DFS):**\n\n1. Precompute divisors for numbers up to `10^6`.\n2. `adj[u]` stores `(v, g, l)`.\n3. `ans[i] = 0` for `i=1..N`. `final_ans[i] = 0`.\n4. `visited[i] = false`.\n5. `dfs(u)` function:\n   * If `visited[u]`, return `true`.\n   * `visited[u] = true`.\n   * For `(v, g_uv, l_uv)` in `adj[u]`:\n     * If `l_uv % g_uv != 0`: return `false`.\n     * If `ans[v] == 0`: // `v` unassigned\n       * `product_uv = g_uv * l_uv`.\n       * If `product_uv % ans[u] != 0`: return `false`. // `ans[u]` must divide `g*l`\n       * `candidate_v = product_uv // ans[u]`.\n       * If `GCD(ans[u], candidate_v) != g_uv` or `LCM(ans[u], candidate_v) != l_uv`: return `false`.\n       * `ans[v] = candidate_v`.\n       * If `not dfs(v)`: return `false`. // Propagate and check\n     Else: // `v` assigned\n       If `GCD(ans[u], ans[v]) != g_uv` or `LCM(ans[u], ans[v]) != l_uv`: return `false`.\n   `visited[u] = false`. // Backtrack visited state for other branches\n   return `true`.\n\nMain loop:\n`possible = false`.\nFor `i` from 1 to `N`:\n  If `final_ans[i] == 0`: // Unassigned component\n    `component_root = i`.\n    `potential_start_values = set()`\n    If `adj[i]` is empty: `potential_start_values.add(1)`.\n    Else:\n      For `(v, g_iv, l_iv)` in `adj[i]`:\n        `P = l_iv // g_iv`.\n        `divs = get_divisors(P)`.\n        For `x` in `divs`:\n          `val = g_iv * x`.\n          If `val <= 10^6`: `potential_start_values.add(val)`.\n\n    `found_component_ans = false`.\n    For `start_val` in `potential_start_values`:\n      `ans_copy = list(ans)` // Save current state of `ans`\n      `visited_copy = list(visited)` // Save current state of `visited`\n      `ans[component_root] = start_val`.\n      If `dfs(component_root)`:\n        // Check consistency for the entire component after DFS\n        `K_val = -1`.\n        `component_nodes = []`\n        For `j` from 1 to `N`:\n          If `ans[j] != 0`: `component_nodes.append(j)`\n        \n        `all_K_consistent = true`.\n        For `u` in `component_nodes`:\n          For `(v, g_uv, l_uv)` in `adj[u]`:\n            If `u < v`:\n              `g_current_nodes = GCD(ans[u], ans[v])`\n              `l_current_nodes = LCM(ans[u], ans[v])`\n              If `g_uv % g_current_nodes != 0` or `l_uv % l_current_nodes != 0`:\n                `all_K_consistent = false`; break\n              `k_candidate_g = g_uv // g_current_nodes`\n              `k_candidate_l = l_uv // l_current_nodes`\n              If `k_candidate_g != k_candidate_l`: `all_K_consistent = false`; break\n              If `K_val == -1`: `K_val = k_candidate_g`\n              Else if `K_val != k_candidate_g`: `all_K_consistent = false`; break\n          If `not all_K_consistent`: break\n        \n        If `all_K_consistent`:\n          If `K_val == -1`: `K_val = 1`\n          For `j` in `component_nodes`:\n            `final_ans[j] = ans[j] * K_val`\n          `found_component_ans = true`; break // Found a valid assignment for this component\n      \n      `ans = ans_copy` // Restore `ans` for next `start_val` attempt\n      `visited = visited_copy` // Restore `visited`\n    \n    If `not found_component_ans`:\n      `possible = false`; break // No `start_val` worked for this component\n\nIf `possible`: print \"YES\", `final_ans`. Else: print \"NO\".\n\nThe `get_divisors` function can be precomputed. For `P <= 10^6`, max divisors is `240` for `720720`.\n`potential_start_values` can have at most `240` elements.\nThe DFS itself visits each node/edge once per `start_val` attempt.\nTotal complexity: `N * MaxDivisors * (N+M) * log(MaxVal)`.\n`100 * 240 * (100+5000) * 20` approx `100 * 240 * 5100 * 20` approx `2.4 * 10^8`. This might be too slow. `log(MaxVal)` is for GCD/LCM.\n\nThe `ans` array should be reset for each `start_val` attempt.\n`dfs` needs to know which `ans` values are part of the current component's assignment.\nInstead of `ans_copy`, pass `ans` and `visited` to `dfs` and let it return the list of assigned nodes.\n`dfs(u, current_ans, current_visited, component_nodes_list)`\n\nLet's refine the `dfs` for a component:\n`solve_component(root_node)`:\n  `potential_start_values = set()`\n  If `adj[root_node]` is empty: `potential_start_values.add(1)`.\n  Else:\n    For `(v, g_rv, l_rv)` in `adj[root_node]`:\n      `P = l_rv // g_rv`.\n      `divs = get_divisors(P)`.\n      For `x` in `divs`:\n        `val = g_rv * x`.\n        If `val <= 10^6`: `potential_start_values.add(val)`.\n\n  For `start_val` in `potential_start_values`:\n    `current_ans_component = [0] * (N+1)`\n    `current_ans_component[root_node] = start_val`\n    `q = deque([root_node])`\n    `component_nodes = [root_node]`\n    `is_consistent_bfs = true`\n\n    While `q`:\n      `u = q.popleft()`\n      For `(v, g_uv, l_uv)` in `adj[u]`:\n        If `l_uv % g_uv != 0`: `is_consistent_bfs = false`; break\n        If `current_ans_component[v] == 0`:\n          `product_uv = g_uv * l_uv`\n          If `product_uv % current_ans_component[u] != 0`: `is_consistent_bfs = false`; break\n          `candidate_v = product_uv // current_ans_component[u]`\n          If `candidate_v > 10**6`: `is_consistent_bfs = false`; break # Value too large\n          If `GCD(current_ans_component[u], candidate_v) != g_uv` or `LCM(current_ans_component[u], candidate_v) != l_uv`:\n            `is_consistent_bfs = false`; break\n          `current_ans_component[v] = candidate_v`\n          `q.append(v)`\n          `component_nodes.append(v)`\n        Else:\n          If `GCD(current_ans_component[u], current_ans_component[v]) != g_uv` or `LCM(current_ans_component[u], current_ans_component[v]) != l_uv`:\n            `is_consistent_bfs = false`; break\n      If `not is_consistent_bfs`: break\n    \n    If `not is_consistent_bfs`: continue // Try next `start_val`\n\n    // BFS was consistent, now find K\n    `K_val = -1`\n    `all_K_consistent = true`\n    For `u` in `component_nodes`:\n      For `(v, g_uv, l_uv)` in `adj[u]`:\n        If `u < v`:\n          `g_current_nodes = GCD(current_ans_component[u], current_ans_component[v])`\n          `l_current_nodes = LCM(current_ans_component[u], current_ans_component[v])`\n          If `g_uv % g_current_nodes != 0` or `l_uv % l_current_nodes != 0`:\n            `all_K_consistent = false`; break\n          `k_candidate_g = g_uv // g_current_nodes`\n          `k_candidate_l = l_uv // l_current_nodes`\n          If `k_candidate_g != k_candidate_l`: `all_K_consistent = false`; break\n          If `K_val == -1`: `K_val = k_candidate_g`\n          Else if `K_val != k_candidate_g`: `all_K_consistent = false`; break\n      If `not all_K_consistent`: break\n    \n    If `all_K_consistent`:\n      If `K_val == -1`: `K_val = 1`\n      For `j` in `component_nodes`:\n        If `current_ans_component[j] * K_val > 10**6`:\n          `all_K_consistent = false`; break\n        `final_ans[j] = current_ans_component[j] * K_val`\n      If `all_K_consistent`: return `true` // Found solution for this component\n  \n  return `false` // No `start_val` worked for this component\n\nMain loop:\n`final_ans = [0] * (N+1)`\n`possible = true`\nFor `i` from 1 to `N`:\n  If `final_ans[i] == 0`:\n    If `not solve_component(i)`:\n      `possible = false`; break\nIf `possible`: print \"YES\", `final_ans[1:]`. Else: print \"NO\".\n\nThis refined algorithm seems robust. The precomputation of divisors is `O(MAX_VAL * sqrt(MAX_VAL))` or `O(MAX_VAL * log(MAX_VAL))` using a sieve-like approach. `10^6 * log(10^6)` is fine.\nThe overall complexity is `N * MaxDivisors * (N+M) * log(MaxVal)`.\n`100 * 240 * (100+5000) * 20` is `2.4 * 10^8`. This is pushing it for a 2-second time limit, but might pass if average case is faster or constants are small. The number of nodes in a component might be small, and `MaxDivisors` is worst case.\n\nLet's optimize `get_divisors`.\n`divs = []`\n`for x from 1 to sqrt(P)`:\n  `if P % x == 0`:\n    `divs.add(x)`\n    `divs.add(P // x)`\nThis is `O(sqrt(P))`.\n`P` can be up to `10^6`. `sqrt(10^6) = 1000`.\nSo `MaxDivisors` is not the number of divisors, but `sqrt(P)`.\n`N * sqrt(Max_P) * (N+M) * log(MaxVal)`.\n`100 * 1000 * 5100 * 20` is `10^2 * 10^3 * 5 * 10^3 * 2 * 10^1 = 10^{10}`. This is definitely too slow.\n\nThe `potential_start_values` must be `g * x` where `x` is a divisor of `l/g`.\nAnd `x` and `y = (l/g)/x` must be coprime.\nThis means `x` must be formed by collecting some prime factors of `l/g` and `y` by the remaining.\nSo `x` can only be one of `2^k` values, where `k` is number of distinct prime factors of `l/g`. `k <= 7`.\nSo `potential_start_values` has at most `2^7 * N` elements (if we collect from all adjacent edges).\nBetter: for an edge `(u, v)`, `val[u]` must be `g_uv * x` and `val[v]` must be `g_uv * y`.\nThe `potential_start_values` should be `g_uv * x` where `x` is a coprime factor of `l_uv / g_uv`.\nFor each `root_node`, we can generate these `2^k` candidate values for `root_node` based on *one* of its adjacent edges.\nMax `2^7 = 128` candidates.\nSo complexity becomes `N * 128 * (N+M) * log(MaxVal)`.\n`100 * 128 * 5100 * 20` approx `1.3 * 10^9`. Still too slow.\n\nWait, `get_divisors` for `P` only considers coprime factors.\n`get_coprime_factors(P)`:\n  `prime_factors = get_distinct_prime_factors(P)`\n  `factors = []`\n  `for each subset of prime_factors`:\n    `product = 1`\n    `for p in subset`:\n      `product *= p^(exponent of p in P)`\n    `factors.add(product)`\n  This generates `2^k` values.\n  `k <= 7` for numbers up to `10^6`. So `2^7 = 128` factors. This is correct.\n\nSo `potential_start_values` has at most `128` elements for one edge.\nIf `potential_start_values` is constructed from *all* adjacent edges of `root_node`, it could be `degree(root_node) * 128`. Max degree is `N-1`. So `100 * 128` values.\n`100 * 100 * 5100 * 20` approx `10^2 * 10^2 * 5 * 10^3 * 2 * 10^1 = 10^{10}`. Still too slow.\n\nThe number of unique `g_uv * x` values that can possibly be `val[root_node]` is what matters.\nFor each edge `(u,v)`, `val[u]` must be `g_uv * x` where `x` is a coprime factor of `l_uv/g_uv`.\nSo `val[u]` must be in `S_u = Union_{ (u,v) in adj } { g_uv * x | x is coprime factor of l_uv/g_uv }`.\nThe size of `S_u` is at most `(N-1) * 128`.\nThe number of distinct values in `S_u` could be smaller.\nThe maximum number of distinct values for `g * x` can be large.\nA number `X <= 10^6` can have `GCD(X, Y)` and `LCM(X, Y)` constraints.\nThe actual values `mushrooms[i]` must be divisors of `LCM`s and multiples of `GCD`s.\nThe number of divisors of `10^6` is at most `240`.\nSo for each `i`, `mushrooms[i]` must be a divisor of `l_ij` for all neighbors `j`.\nAnd `mushrooms[i]` must be a multiple of `g_ij` for all neighbors `j`.\nSo `mushrooms[i]` must be a multiple of `LCM(g_ij)` and a divisor of `GCD(l_ij)`.\nLet `L_i = LCM(g_ij)` over all `j` connected to `i`.\nLet `G_i = GCD(l_ij)` over all `j` connected to `i`.\nThen `mushrooms[i]` must be a multiple of `L_i` and a divisor of `G_i`.\nSo `mushrooms[i]` must be of the form `L_i * k` where `L_i * k` divides `G_i`.\nThis means `k` must divide `G_i / L_i`.\nThe number of divisors of `G_i / L_i` is at most 240.\nSo `potential_start_values` for `root_node` has at most `240` elements.\nThis is the key.\nThe overall complexity becomes `N * 240 * (N+M) * log(MaxVal)`.\n`100 * 240 * 5100 * 20` approx `2.4 * 10^8`. This is the maximum. It might pass.\n\nFinal check on logic:\n`L_i = 1`, `G_i = 10^6`. `k` can be any divisor of `10^6`. Up to 240 options.\n`L_i = 10^6`, `G_i = 10^6`. `k` must be 1. 1 option.\nThis is correct.\n\nNeed to precompute divisors for numbers up to `10^6`.\nA simple way:\n`divisors_list = [[] for _ in range(MAX_VAL + 1)]`\n`for i in range(1, MAX_VAL + 1):`\n  `for j in range(i, MAX_VAL + 1, i):`\n    `divisors_list[j].append(i)`\nThis is `O(MAX_VAL * log(MAX_VAL))`.\n\n```python\nimport math\nimport sys\nfrom collections import deque\n\n# Standard GCD and LCM functions\ndef gcd(a, b):\n    return math.gcd(a, b)\n\ndef lcm(a, b):\n    if a == 0 or b == 0:\n        return 0\n    # Use // for integer division, Python handles large integers automatically\n    # Check for potential overflow if a*b is too large before division,\n    # but for competitive programming, Python's arbitrary precision is usually relied upon.\n    # Max value for a, b is 10^6, so a*b is 10^12, fits in 64-bit int.\n    # Python ints handle this fine.\n    return (a * b) // gcd(a, b)\n\n# Precompute divisors for numbers up to MAX_VAL\nMAX_VAL = 10**6\ndivisors_cache = [[] for _ in range(MAX_VAL + 1)]\n\ndef precompute_divisors():\n    for i in range(1, MAX_VAL + 1):\n        for j in range(i, MAX_VAL + 1, i):\n            divisors_cache[j].append(i)\n\n# Global variables for the problem\nN = 0\nM = 0\nadj = []\nfinal_ans = []\n\n# Function to solve for a connected component starting from root_node\ndef solve_component(root_node):\n    global final_ans\n\n    # Determine potential start values for the root_node\n    # val[root_node] must be a multiple of LCM of all adjacent GCDs\n    # and a divisor of GCD of all adjacent LCMs\n    lcm_of_g = 1\n    gcd_of_l = MAX_VAL + 1 # Use a value larger than any possible LCM\n\n    if not adj[root_node]: # Isolated node\n        potential_start_values = [1]\n    else:\n        for v, g_val, l_val in adj[root_node]:\n            lcm_of_g = lcm(lcm_of_g, g_val)\n            gcd_of_l = gcd(gcd_of_l, l_val)\n        \n        if gcd_of_l % lcm_of_g != 0:\n            return False # No integer k such that L_i * k divides G_i\n        \n        factor_k_limit = gcd_of_l // lcm_of_g\n        potential_start_values = []\n        for k in divisors_cache[factor_k_limit]:\n            candidate_val = lcm_of_g * k\n            if candidate_val <= MAX_VAL:\n                potential_start_values.append(candidate_val)\n    \n    # Try each potential start value for the root_node\n    for start_val in potential_start_values:\n        current_ans_component = [0] * (N + 1)\n        current_ans_component[root_node] = start_val\n        \n        q = deque([root_node])\n        component_nodes = [root_node]\n        \n        is_consistent_bfs = True\n\n        while q:\n            u = q.popleft()\n            \n            for v, g_uv, l_uv in adj[u]:\n                if l_uv % g_uv != 0: # LCM must be divisible by GCD\n                    is_consistent_bfs = False\n                    break\n                \n                if current_ans_component[v] == 0: # Neighbor v is unassigned\n                    product_uv = g_uv * l_uv\n                    \n                    if product_uv % current_ans_component[u] != 0: # ans[u] must divide g*l\n                        is_consistent_bfs = False\n                        break\n                    \n                    candidate_v = product_uv // current_ans_component[u]\n                    \n                    if candidate_v > MAX_VAL or candidate_v < 1: # Value out of range\n                        is_consistent_bfs = False\n                        break\n                    \n                    if gcd(current_ans_component[u], candidate_v) != g_uv or \\\n                       lcm(current_ans_component[u], candidate_v) != l_uv:\n                        is_consistent_bfs = False\n                        break\n                    \n                    current_ans_component[v] = candidate_v\n                    q.append(v)\n                    component_nodes.append(v)\n                else: # Neighbor v is already assigned\n                    if gcd(current_ans_component[u], current_ans_component[v]) != g_uv or \\\n                       lcm(current_ans_component[u], current_ans_component[v]) != l_uv:\n                        is_consistent_bfs = False\n                        break\n            \n            if not is_consistent_bfs:\n                break # Break from inner while loop\n        \n        if not is_consistent_bfs:\n            continue # Try next start_val\n\n        # If BFS was consistent, copy values to final_ans\n        for node in component_nodes:\n            final_ans[node] = current_ans_component[node]\n        return True # Found a valid assignment for this component\n\n    return False # No start_val worked for this component\n\ndef main():\n    global N, M, adj, final_ans\n\n    precompute_divisors()\n\n    line1 = sys.stdin.readline().split()\n    N = int(line1[0])\n    M = int(line1[1])\n\n    adj = [[] for _ in range(N + 1)]\n    for _ in range(M):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l))\n    \n    final_ans = [0] * (N + 1)\n    \n    possible = True\n    for i in range(1, N + 1):\n        if final_ans[i] == 0: # If lawn i hasn't been assigned yet\n            if not solve_component(i):\n                possible = False\n                break\n    \n    if possible:\n        sys.stdout.write(\"YES\\n\")\n        sys.stdout.write(\" \".join(map(str, final_ans[1:])) + \"\\n\")\n    else:\n        sys.stdout.write(\"NO\\n\")\n\nif __name__ == \"__main__\":\n    main()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\nimport sys\nfrom collections import deque\n\n# Standard GCD and LCM functions\ndef gcd(a, b):\n    return math.gcd(a, b)\n\ndef lcm(a, b):\n    if a == 0 or b == 0:\n        return 0\n    # Use // for integer division, Python handles large integers automatically\n    # Check for potential overflow if a*b is too large before division,\n    # but for competitive programming, Python's arbitrary precision is usually relied upon.\n    # Max value for a, b is 10^6, so a*b is 10^12, fits in 64-bit int.\n    # Python ints handle this fine.\n    return (a * b) // gcd(a, b)\n\n# Precompute divisors for numbers up to MAX_VAL\nMAX_VAL = 10**6\ndivisors_cache = [[] for _ in range(MAX_VAL + 1)]\n\ndef precompute_divisors():\n    for i in range(1, MAX_VAL + 1):\n        for j in range(i, MAX_VAL + 1, i):\n            divisors_cache[j].append(i)\n\n# Global variables for the problem\nN = 0\nM = 0\nadj = []\nfinal_ans = []\n\n# Function to solve for a connected component starting from root_node\ndef solve_component(root_node):\n    global final_ans\n\n    # Determine potential start values for the root_node\n    # val[root_node] must be a multiple of LCM of all adjacent GCDs\n    # and a divisor of GCD of all adjacent LCMs\n    lcm_of_g = 1\n    gcd_of_l = MAX_VAL + 1 # Use a value larger than any possible LCM\n\n    if not adj[root_node]: # Isolated node\n        potential_start_values = [1]\n    else:\n        for v, g_val, l_val in adj[root_node]:\n            lcm_of_g = lcm(lcm_of_g, g_val)\n            gcd_of_l = gcd(gcd_of_l, l_val)\n        \n        if gcd_of_l % lcm_of_g != 0:\n            return False # No integer k such that L_i * k divides G_i\n        \n        factor_k_limit = gcd_of_l // lcm_of_g\n        potential_start_values = []\n        for k in divisors_cache[factor_k_limit]:\n            candidate_val = lcm_of_g * k\n            if candidate_val <= MAX_VAL:\n                potential_start_values.append(candidate_val)\n    \n    # Try each potential start value for the root_node\n    for start_val in potential_start_values:\n        current_ans_component = [0] * (N + 1)\n        current_ans_component[root_node] = start_val\n        \n        q = deque([root_node])\n        component_nodes = [root_node]\n        \n        is_consistent_bfs = True\n\n        while q:\n            u = q.popleft()\n            \n            for v, g_uv, l_uv in adj[u]:\n                if l_uv % g_uv != 0: # LCM must be divisible by GCD\n                    is_consistent_bfs = False\n                    break\n                \n                if current_ans_component[v] == 0: # Neighbor v is unassigned\n                    product_uv = g_uv * l_uv\n                    \n                    if product_uv % current_ans_component[u] != 0: # ans[u] must divide g*l\n                        is_consistent_bfs = False\n                        break\n                    \n                    candidate_v = product_uv // current_ans_component[u]\n                    \n                    if candidate_v > MAX_VAL or candidate_v < 1: # Value out of range\n                        is_consistent_bfs = False\n                        break\n                    \n                    if gcd(current_ans_component[u], candidate_v) != g_uv or \\\n                       lcm(current_ans_component[u], candidate_v) != l_uv:\n                        is_consistent_bfs = False\n                        break\n                    \n                    current_ans_component[v] = candidate_v\n                    q.append(v)\n                    component_nodes.append(v)\n                else: # Neighbor v is already assigned\n                    if gcd(current_ans_component[u], current_ans_component[v]) != g_uv or \\\n                       lcm(current_ans_component[u], current_ans_component[v]) != l_uv:\n                        is_consistent_bfs = False\n                        break\n            \n            if not is_consistent_bfs:\n                break # Break from inner while loop\n        \n        if not is_consistent_bfs:\n            continue # Try next start_val\n\n        # If BFS was consistent, copy values to final_ans\n        for node in component_nodes:\n            final_ans[node] = current_ans_component[node]\n        return True # Found a valid assignment for this component\n\n    return False # No start_val worked for this component\n\ndef main():\n    global N, M, adj, final_ans\n\n    precompute_divisors()\n\n    line1 = sys.stdin.readline().split()\n    N = int(line1[0])\n    M = int(line1[1])\n\n    adj = [[] for _ in range(N + 1)]\n    for _ in range(M):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l))\n    \n    final_ans = [0] * (N + 1)\n    \n    possible = True\n    for i in range(1, N + 1):\n        if final_ans[i] == 0: # If lawn i hasn't been assigned yet\n            if not solve_component(i):\n                possible = False\n                break\n    \n    if possible:\n        sys.stdout.write(\"YES\\n\")\n        sys.stdout.write(\" \".join(map(str, final_ans[1:])) + \"\\n\")\n    else:\n        sys.stdout.write(\"NO\\n\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 552,
        "completion_token_count": 18677,
        "thoughts_token_count": 816
    }
}