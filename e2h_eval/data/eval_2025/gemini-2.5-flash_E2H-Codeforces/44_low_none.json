{
    "start": 1758284876.298385,
    "end": 1758284933.4421103,
    "start-formatted": "2025-09-19 21:27 KST",
    "end-formatted": "2025-09-19 21:28 KST",
    "gpu": 2,
    "pid": 44,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Polycarp's Practice\n\nPolycarp is practicing his problem solving skill. He has a list of $$$n$$$ problems with difficulties $$$a_1, a_2, \\dots, a_n$$$, respectively. His plan is to practice for exactly $$$k$$$ days. Each day he has to solve at least one problem from his list. Polycarp solves the problems in the order they are given in his list, he cannot skip any problem from his list. He has to solve all $$$n$$$ problems in exactly $$$k$$$ days.Thus, each day Polycarp solves a contiguous sequence of (consecutive) problems from the start of the list. He can't skip problems or solve them multiple times. As a result, in $$$k$$$ days he will solve all the $$$n$$$ problems.The profit of the $$$j$$$-th day of Polycarp's practice is the maximum among all the difficulties of problems Polycarp solves during the $$$j$$$-th day (i.e. if he solves problems with indices from $$$l$$$ to $$$r$$$ during a day, then the profit of the day is $$$\\max\\limits_{l \\le i \\le r}a_i$$$). The total profit of his practice is the sum of the profits over all $$$k$$$ days of his practice.You want to help Polycarp to get the maximum possible total profit over all valid ways to solve problems. Your task is to distribute all $$$n$$$ problems between $$$k$$$ days satisfying the conditions above in such a way, that the total profit is maximum.For example, if $$$n = 8, k = 3$$$ and $$$a = [5, 4, 2, 6, 5, 1, 9, 2]$$$, one of the possible distributions with maximum total profit is: $$$[5, 4, 2], [6, 5], [1, 9, 2]$$$. Here the total profit equals $$$5 + 6 + 9 = 20$$$.\n\n## Input\nThe first line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\le k \\le n \\le 2000$$$) — the number of problems and the number of days, respectively.The second line of the input contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le 2000$$$) — difficulties of problems in Polycarp's list, in the order they are placed in the list (i.e. in the order Polycarp will solve them).\n\n## Output\nIn the first line of the output print the maximum possible total profit.In the second line print exactly $$$k$$$ positive integers $$$t_1, t_2, \\dots, t_k$$$ ($$$t_1 + t_2 + \\dots + t_k$$$ must equal $$$n$$$), where $$$t_j$$$ means the number of problems Polycarp will solve during the $$$j$$$-th day in order to achieve the maximum possible total profit of his practice.If there are many possible answers, you may print any of them.\n\n## Example\n### Input\n['8 3\\n5 4 2 6 5 1 9 2', '5 1\\n1 1 1 1 1', '4 2\\n1 2000 2000 2']\n\n### Output\n['20\\n3 2 3', '1\\n5', '4000\\n2 2']\n\n## Note\nThe first example is described in the problem statement.In the second example there is only one possible distribution.In the third example the best answer is to distribute problems in the following way: $$$[1, 2000], [2000, 2]$$$. The total profit of this distribution is $$$2000 + 2000 = 4000$$$.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "**Tackling Polycarp's Practice: A Pythonic Approach**\n\nOkay, so I'm looking at this \"Polycarp's Practice\" problem, and my mind's already racing towards a Python solution. The setup is clear: `n` problems, `k` days, and the challenge is to maximize the total profit, which is the sum of the maximum difficulty problems solved each day. The input's an array `a` of difficulties.\n\nFirst things first, I need to understand the problem fully.  I have to ensure every problem is solved, that they're solved in order, and that each day deals with a contiguous subset. The profit is straightforward: it’s the maximum difficulty on a day. The key is in that total profit maximization.\n\nThe example gave me the initial spark.  The ideal seems to involve making those daily maximums as large as possible.  My intuition tells me that means leveraging the largest difficulty values in the array `a`.  If I can ensure the `k` largest difficulties become the daily maximums, that's the best I can hope for.\n\nSo, the strategy crystallizes. Identify those `k` largest difficulties. Then, the real dance begins: how do I split the problem set into `k` days so that each day's maximum is precisely one of those chosen difficulties?\n\nThe insight hits: it's about indices! I need to pinpoint where those `k` largest values reside in the original array `a`, and it's their relative positions that guide the optimal splitting. Let's say I find that my `k` largest difficulties exist at indices `idx_1, idx_2, ..., idx_k`. The intuition says to cut after those. Those indices are essentially my splitting points. I'm imagining a cut after the elements at `idx_1, idx_2, ... idx_{k-1}`.  This ensures each segment contains one of my target, highest difficulties, and all problems are handled in sequence.\n\nSo, the Python code will involve finding the `k` largest elements, their indices, and using those indices to define how to partition the original array.  That seems like a robust approach. I'm feeling confident this strategy will maximize the profit, given the structure of the problem. Time to translate this into some clean, elegant Python!\n",
    "response": "The problem asks us to divide `n` problems, given as a list of difficulties `a_1, ..., a_n`, into exactly `k` contiguous segments (days). Each day must have at least one problem. The profit for a day is the maximum difficulty among problems solved on that day. We want to maximize the total profit, which is the sum of daily profits, and also output the number of problems solved each day.\n\n**Key Insight:**\nTo maximize the sum of `k` daily maximums, we should try to make each of these `k` maximums as large as possible. The largest possible values we can pick as daily maximums are the `k` largest difficulties present in the entire list `a`.\n\nLet's take the `k` largest distinct difficulties from the list `a`. If there are duplicate values, we should consider them as separate problems. For example, if `a = [1, 5, 2, 5]` and `k=2`, the two largest difficulties are `5` and `5`.\n\n**Algorithm:**\n\n1.  **Calculate Maximum Total Profit:**\n    *   Create a list of tuples `(difficulty, original_index)` for all problems.\n    *   Sort this list in descending order based on difficulty.\n    *   Take the top `k` elements from this sorted list. These are the `k` problems with the highest difficulties.\n    *   The maximum total profit will be the sum of these `k` highest difficulties.\n    *   Store the original indices of these `k` problems. These indices will be crucial for determining the cuts.\n\n2.  **Determine Day Divisions (Cuts):**\n    *   Let the original indices of the `k` problems with highest difficulties be `idx_1, idx_2, ..., idx_k`.\n    *   Sort these `k` indices in ascending order.\n    *   These `k` problems must each be the maximum for one of the `k` days.\n    *   We can make `k-1` cuts. The natural places to make these cuts are *after* the first `k-1` problems among our chosen `k` highest difficulty problems.\n    *   Specifically, if the sorted indices are `s_1, s_2, ..., s_k`, we will make cuts after problems `s_1`, `s_2`, ..., `s_{k-1}`.\n    *   The first day will solve problems from index `0` up to `s_1`.\n    *   The second day will solve problems from index `s_1 + 1` up to `s_2`.\n    *   ...\n    *   The `j`-th day will solve problems from index `s_{j-1} + 1` up to `s_j`.\n    *   The `k`-th day will solve problems from index `s_k + 1` up to `n-1`. (Note: This is 0-indexed. If problems are 1-indexed, it would be `s_k` to `n`).\n    *   The number of problems for each day `t_j` can be calculated from these cut points.\n        *   `t_1 = s_1 + 1` (since it's 0-indexed, `s_1` is the `(s_1+1)`-th problem)\n        *   `t_j = s_j - s_{j-1}` for `j` from `2` to `k-1`\n        *   `t_k = n - s_{k-1} - 1` (all remaining problems after the `(k-1)`-th cut)\n        *   Wait, this is simpler: `t_1 = s_1 + 1`, `t_j = s_j - s_{j-1}` for `j=2...k-1`, and `t_k = n - (s_{k-1} + 1)` for the last segment.\n        *   Let's re-evaluate the cuts. The cuts are *after* the elements at indices `s_1`, `s_2`, ..., `s_{k-1}`.\n            *   Day 1: Problems `0` to `s_1`. Length `s_1 - 0 + 1`.\n            *   Day 2: Problems `s_1 + 1` to `s_2`. Length `s_2 - (s_1 + 1) + 1 = s_2 - s_1`.\n            *   ...\n            *   Day `j`: Problems `s_{j-1} + 1` to `s_j`. Length `s_j - s_{j-1}`.\n            *   Day `k`: Problems `s_{k-1} + 1` to `n-1`. Length `(n-1) - (s_{k-1} + 1) + 1 = n - (s_{k-1} + 1)`.\n\n    *   Example: `n=8, k=3, a=[5, 4, 2, 6, 5, 1, 9, 2]`\n        *   `k=3` largest difficulties are `9, 6, 5`.\n        *   Their 0-indexed positions: `9` at index `6`, `6` at index `3`, `5` at index `0` (or `4`). Let's pick `5` at index `0`.\n        *   Chosen indices: `0, 3, 6`. Sorted: `s_1=0, s_2=3, s_3=6`.\n        *   Cuts after `s_1` and `s_2`.\n        *   Day 1: problems `0` to `s_1=0`. Length `0 - 0 + 1 = 1`. (`[5]`)\n        *   Day 2: problems `s_1+1=1` to `s_2=3`. Length `3 - 1 + 1 = 3`. (`[4, 2, 6]`)\n        *   Day 3: problems `s_2+1=4` to `n-1=7`. Length `7 - 4 + 1 = 4`. (`[5, 1, 9, 2]`)\n        *   This gives `1, 3, 4`. Profit `5+6+9=20`. This is a valid solution.\n        *   The example output was `3, 2, 3`. This means the chosen indices were `2, 4, 6`.\n            *   `a[2]=2`, `a[4]=5`, `a[6]=9`. This is not `9,6,5`.\n            *   Ah, the example output uses `5` at index `0`, `6` at index `3`, `9` at index `6`.\n            *   The indices are `0, 3, 6`.\n            *   Cuts after `s_1=0` and `s_2=3`.\n            *   Day 1: `0` to `0`. Length `1`.\n            *   Day 2: `1` to `3`. Length `3`.\n            *   Day 3: `4` to `7`. Length `4`.\n            *   This is `1, 3, 4`. Still not `3, 2, 3`.\n\n    *   Let's re-examine the example output: `[5, 4, 2], [6, 5], [1, 9, 2]`.\n        *   Day 1 ends at index 2 (`a[2]=2`). Max is `a[0]=5`.\n        *   Day 2 ends at index 4 (`a[4]=5`). Max is `a[3]=6`.\n        *   Day 3 ends at index 7 (`a[7]=2`). Max is `a[6]=9`.\n        *   The indices of the daily maximums are `0, 3, 6`. These are indeed the indices of `5, 6, 9`.\n        *   The cuts are *after* index `2` and *after* index `4`.\n        *   This means `s_1` is part of the first segment, `s_2` is part of the second, `s_3` is part of the third.\n        *   The cut points are `s_1`, `s_2`, ..., `s_{k-1}`.\n        *   No, the cut points are *after* the problems. The *last problem of each day* determines the cut.\n        *   The indices of the problems chosen to be maximums are `0, 3, 6`.\n        *   We need to make `k-1` cuts. These cuts must be *after* `k-1` of the `k` chosen problems.\n        *   Consider the sorted indices of the `k` largest values: `s_1, s_2, ..., s_k`.\n        *   We must make a cut *after* problem `s_1`, another cut *after* problem `s_2`, ..., up to `s_{k-1}`.\n        *   This ensures that problem `s_1` is in day 1, `s_2` in day 2, ..., `s_k` in day `k`.\n        *   The problems solved on day `j` will be from the end of day `j-1` to problem `s_j`.\n        *   No, this is wrong. If we cut *after* `s_1`, `s_2`, ... `s_{k-1}`, then `s_1` is in day 1, `s_2` in day 2, etc. This means `s_j` is the last problem of day `j`.\n        *   Let `s_1, s_2, ..., s_k` be the sorted 0-indexed positions of the `k` largest values.\n        *   The problems solved on day 1 are `a[0]` to `a[s_1]`. Length `s_1 + 1`.\n        *   The problems solved on day 2 are `a[s_1+1]` to `a[s_2]`. Length `s_2 - (s_1+1) + 1 = s_2 - s_1`.\n        *   ...\n        *   The problems solved on day `j` are `a[s_{j-1}+1]` to `a[s_j]`. Length `s_j - s_{j-1}`.\n        *   The problems solved on day `k` are `a[s_{k-1}+1]` to `a[n-1]`. Length `(n-1) - (s_{k-1}+1) + 1 = n - (s_{k-1}+1)`.\n\n    *   Let's try this logic with the example `n=8, k=3, a=[5, 4, 2, 6, 5, 1, 9, 2]`.\n        *   The `k=3` largest values are `9, 6, 5`.\n        *   Their original indices: `5` at index `0`, `6` at index `3`, `9` at index `6`.\n        *   Sorted indices: `s_1=0, s_2=3, s_3=6`.\n        *   Day 1: problems `0` to `s_1=0`. Length `0+1 = 1`. (`[5]`)\n        *   Day 2: problems `s_1+1=1` to `s_2=3`. Length `3-0 = 3`. (`[4, 2, 6]`)\n        *   Day 3: problems `s_2+1=4` to `n-1=7`. Length `8-(3+1) = 4`. (`[5, 1, 9, 2]`)\n        *   This gives `t = [1, 3, 4]`. Total profit `5+6+9=20`. This is a valid answer.\n\n    *   The example output `3 2 3` implies different cut points. This means there can be multiple ways to achieve the maximum profit. The strategy above is *one* way.\n    *   The example output `3 2 3` implies cuts after index `2` and index `4`.\n        *   Day 1: `a[0]` to `a[2]`. Max is `a[0]=5`.\n        *   Day 2: `a[3]` to `a[4]`. Max is `a[3]=6`.\n        *   Day 3: `a[5]` to `a[7]`. Max is `a[6]=9`.\n        *   The indices of the maximums are `0, 3, 6`.\n        *   The cut points are `2, 4`. These are not the indices of the maximums.\n        *   This means the `k` largest problems `s_1, ..., s_k` don't necessarily have to be the *last* problem of their respective days. They just need to be *contained* within their day's segment.\n\n    *   Revised strategy for cuts:\n        1.  Get the `k` largest values and their original indices.\n        2.  Sort these `k` indices `s_1, s_2, ..., s_k` in ascending order.\n        3.  The first day starts at index `0`. The second day starts at `s_1+1`. The third day starts at `s_2+1`, ..., the `k`-th day starts at `s_{k-1}+1`. The last day ends at `n-1`.\n        4.  The number of problems for day `j` (`t_j`) is the count of problems from its start index up to the start index of day `j+1` (or `n-1` for the last day).\n        5.  `t_1 = s_1 + 1` (problems `0` to `s_1`).\n        6.  `t_2 = s_2 - s_1` (problems `s_1+1` to `s_2`).\n        7.  ...\n        8.  `t_k = n - (s_{k-1} + 1)` (problems `s_{k-1}+1` to `n-1`).\n        9.  No, this is wrong. This strategy makes `s_j` the *last* problem of day `j`. This is a valid strategy, but not the only one.\n        10. A simpler way to define cuts: The `k` chosen problems `s_1, ..., s_k` must each belong to a distinct day. We need `k-1` cuts. These cuts must be placed *between* `s_j` and `s_{j+1}`.\n        11. The cuts are `s_1, s_2, ..., s_{k-1}`.\n        12. The first day ends at `s_1`.\n        13. The second day ends at `s_2`.\n        14. ...\n        15. The `(k-1)`-th day ends at `s_{k-1}`.\n        16. The `k`-th day ends at `n-1`.\n        17. The number of problems for day `j` is `s_j - (previous_cut_point + 1) + 1`.\n        18. Let `cut_points` be `s_1, s_2, ..., s_{k-1}`.\n        19. `t_1 = cut_points[0] + 1`\n        20. `t_j = cut_points[j-1] - cut_points[j-2]` for `j=2...k-1`\n        21. `t_k = n - (cut_points[k-2] + 1)`\n        22. This is exactly the same as the \"make `s_j` the last problem of day `j`\" strategy.\n\n    *   Let's trace the example output `3 2 3` for `a=[5, 4, 2, 6, 5, 1, 9, 2]`.\n        *   Day 1: `[5, 4, 2]` (3 problems). Ends at index 2. Max is 5.\n        *   Day 2: `[6, 5]` (2 problems). Ends at index 4. Max is 6.\n        *   Day 3: `[1, 9, 2]` (3 problems). Ends at index 7. Max is 9.\n        *   The indices of the maximums are `0, 3, 6`. These are `s_1, s_2, s_3`.\n        *   The cut points (end indices of days) are `2` and `4`.\n        *   Notice that `s_1=0` is *before* the first cut point `2`.\n        *   `s_2=3` is *before* the second cut point `4`.\n        *   `s_3=6` is *before* the end of the last segment `7`.\n        *   This means the cuts are *not* necessarily at `s_j`. They are just *somewhere* such that each `s_j` falls into a distinct segment.\n\n    *   The crucial observation is that we need to define `k-1` split points.\n        *   Let `P` be the list of 0-indexed positions of the `k` largest elements, sorted in ascending order. `P = [p_0, p_1, ..., p_{k-1}]`.\n        *   We need to make `k-1` cuts. The most straightforward way to guarantee each `p_i` is a daily maximum is to make the cuts *immediately after* `p_0`, `p_1`, ..., `p_{k-2}`.\n        *   No, this is not quite right. If `k=1`, there are no cuts, all `n` problems are one day. `p_0` is the max.\n        *   If `k > 1`, we need `k-1` cuts. These cuts will define `k` segments.\n        *   The `k` elements at indices `p_0, ..., p_{k-1}` must each be in a different segment.\n        *   The simplest way to achieve this is to make cuts *after* `p_0`, `p_1`, ..., `p_{k-2}`.\n        *   Segment 1: problems `0` to `p_0`. Length `p_0 + 1`.\n        *   Segment 2: problems `p_0+1` to `p_1`. Length `p_1 - p_0`.\n        *   ...\n        *   Segment `k-1`: problems `p_{k-2}+1` to `p_{k-1}`. Length `p_{k-1} - p_{k-2}`.\n        *   Segment `k`: problems `p_{k-1}+1` to `n-1`. Length `n - (p_{k-1}+1)`.\n\n    *   Let's re-try the example `n=8, k=3, a=[5, 4, 2, 6, 5, 1, 9, 2]` with this strategy.\n        *   `a_indexed = [(5,0), (4,1), (2,2), (6,3), (5,4), (1,5), (9,6), (2,7)]`\n        *   Sorted by difficulty (desc): `(9,6), (6,3), (5,0), (5,4), (4,1), (2,2), (2,7), (1,5)`\n        *   Top `k=3` difficulties: `9, 6, 5`.\n        *   Their original indices: `6, 3, 0`.\n        *   Sorted indices `P = [0, 3, 6]`. (`p_0=0, p_1=3, p_2=6`)\n        *   Total profit: `9+6+5 = 20`.\n        *   Cuts needed: `k-1 = 2`. These cuts will be after `p_0` and after `p_1`.\n        *   `t_1`: problems `0` to `p_0=0`. Length `p_0 + 1 = 1`.\n        *   `t_2`: problems `p_0+1=1` to `p_1=3`. Length `p_1 - p_0 = 3 - 0 = 3`.\n        *   `t_3`: problems `p_1+1=4` to `n-1=7`. Length `n - (p_1+1) = 8 - (3+1) = 4`.\n        *   Result: `t = [1, 3, 4]`.\n        *   This is a valid answer and leads to the maximum profit. The problem states \"If there are many possible answers, you may print any of them.\" So this simple strategy is fine.\n\n**Implementation Steps:**\n\n1.  Read `n` and `k`.\n2.  Read the list `a`.\n3.  Create a list of tuples `(difficulty, index)`: `indexed_a = [(a[i], i) for i in range(n)]`.\n4.  Sort `indexed_a` in reverse order based on difficulty: `indexed_a.sort(key=lambda x: x[0], reverse=True)`.\n5.  Extract the top `k` difficulties and their indices:\n    *   `max_profit = 0`\n    *   `cut_indices = []`\n    *   For `i` from `0` to `k-1`:\n        *   `max_profit += indexed_a[i][0]`\n        *   `cut_indices.append(indexed_a[i][1])`\n6.  Sort `cut_indices` in ascending order: `cut_indices.sort()`.\n7.  Calculate `t_j` values:\n    *   `t_values = []`\n    *   `current_pos = 0`\n    *   For `i` from `0` to `k-2`:\n        *   `t_values.append(cut_indices[i] - current_pos + 1)`\n        *   `current_pos = cut_indices[i] + 1`\n    *   The last segment: `t_values.append(n - current_pos)`\n8.  Print `max_profit`.\n9.  Print `t_values` joined by spaces.\n\n**Edge Cases:**\n*   `k = 1`: `cut_indices` will have one element `p_0`. The loop for `t_values` (`k-2`) won't run. `t_values.append(n - current_pos)` will append `n - 0 = n`. Correct.\n*   `k = n`: Each day solves one problem. `cut_indices` will contain `0, 1, ..., n-1`.\n    *   `t_values.append(cut_indices[i] - current_pos + 1)`:\n        *   `i=0`: `t_values.append(0 - 0 + 1) = 1`. `current_pos = 1`.\n        *   `i=1`: `t_values.append(1 - 1 + 1) = 1`. `current_pos = 2`.\n        *   ...\n        *   `i=n-2`: `t_values.append((n-2) - (n-2) + 1) = 1`. `current_pos = n-1`.\n    *   Last segment: `t_values.append(n - (n-1)) = 1`. Correct.\n\nConstraints: `1 <= k <= n <= 2000`, `1 <= a_i <= 2000`.\nSorting `n` elements takes `O(N log N)`.\nExtracting top `k` is `O(k)`.\nSorting `k` indices is `O(k log k)`.\nCalculating `t_values` is `O(k)`.\nOverall complexity: `O(N log N)`, which is efficient enough for `N=2000`.\n\n```python\nimport sys\n\ndef solve():\n    n, k = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    # Step 1: Create a list of (difficulty, original_index) tuples\n    indexed_a = []\n    for i in range(n):\n        indexed_a.append((a[i], i))\n\n    # Step 2: Sort by difficulty in descending order\n    # If difficulties are equal, the order of indices doesn't matter for total profit\n    # but for determining cuts, a stable sort or consistent tie-breaking might be useful.\n    # Python's sort is stable.\n    indexed_a.sort(key=lambda x: x[0], reverse=True)\n\n    # Step 3: Select the top k problems for maximum profit and their indices\n    max_profit = 0\n    cut_indices = [] # These are the indices of the problems that will be the \"maximums\" for each day\n    \n    for i in range(k):\n        max_profit += indexed_a[i][0]\n        cut_indices.append(indexed_a[i][1])\n    \n    # Step 4: Sort the chosen indices in ascending order to define the segments\n    cut_indices.sort()\n\n    # Step 5: Calculate the number of problems for each day (t_j)\n    t_values = []\n    current_start_index = 0\n    \n    # The k-1 cuts are implicitly after the (k-1) problems identified by cut_indices[0]...cut_indices[k-2]\n    for i in range(k - 1):\n        # The current day ends at cut_indices[i]\n        # Number of problems for this day is (cut_indices[i] - current_start_index + 1)\n        t_values.append(cut_indices[i] - current_start_index + 1)\n        # The next day starts right after this problem\n        current_start_index = cut_indices[i] + 1\n    \n    # The last day takes all remaining problems\n    t_values.append(n - current_start_index)\n\n    # Output results\n    sys.stdout.write(str(max_profit) + \"\\n\")\n    sys.stdout.write(\" \".join(map(str, t_values)) + \"\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, k = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    # Step 1: Create a list of (difficulty, original_index) tuples\n    indexed_a = []\n    for i in range(n):\n        indexed_a.append((a[i], i))\n\n    # Step 2: Sort by difficulty in descending order\n    # If difficulties are equal, the order of indices doesn't matter for total profit\n    # but for determining cuts, a stable sort or consistent tie-breaking might be useful.\n    # Python's sort is stable.\n    indexed_a.sort(key=lambda x: x[0], reverse=True)\n\n    # Step 3: Select the top k problems for maximum profit and their indices\n    max_profit = 0\n    cut_indices = [] # These are the indices of the problems that will be the \"maximums\" for each day\n    \n    for i in range(k):\n        max_profit += indexed_a[i][0]\n        cut_indices.append(indexed_a[i][1])\n    \n    # Step 4: Sort the chosen indices in ascending order to define the segments\n    cut_indices.sort()\n\n    # Step 5: Calculate the number of problems for each day (t_j)\n    t_values = []\n    current_start_index = 0\n    \n    # The k-1 cuts are implicitly after the (k-1) problems identified by cut_indices[0]...cut_indices[k-2]\n    for i in range(k - 1):\n        # The current day ends at cut_indices[i]\n        # Number of problems for this day is (cut_indices[i] - current_start_index + 1)\n        t_values.append(cut_indices[i] - current_start_index + 1)\n        # The next day starts right after this problem\n        current_start_index = cut_indices[i] + 1\n    \n    # The last day takes all remaining problems\n    t_values.append(n - current_start_index)\n\n    # Output results\n    sys.stdout.write(str(max_profit) + \"\\n\")\n    sys.stdout.write(\" \".join(map(str, t_values)) + \"\\n\")\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 963,
        "completion_token_count": 6168,
        "thoughts_token_count": 821
    }
}