{
    "start": 1758284927.2900388,
    "end": 1758284966.6385891,
    "start-formatted": "2025-09-19 21:28 KST",
    "end-formatted": "2025-09-19 21:29 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "**Breaking Down the Mushroom Strife Problem**\n\nOkay, so I'm looking at this \"Mushroom Strife\" problem, and it's a classic graph problem with a number theory twist.  We've got these lawns represented as nodes, and roads connecting them as edges.  Each edge comes with the GCD and LCM of the mushroom counts on the connected lawns.  The goal is to figure out the number of mushrooms on *each* lawn, or declare it impossible.  The mushroom count is constrained between 1 and 10^6, which is important.\n\nThe crux of the problem lies in that crucial GCD and LCM relationship: `GCD(a, b) * LCM(a, b) = a * b`.  Knowing the GCD and LCM instantly gives me the product of the mushroom counts on connected lawns.\n\nLet's break it down further. If we have two lawns, `u` and `v`, with mushroom counts `a` and `b`, and their edge gives us `GCD = g` and `LCM = l`, then we know `a * b = g * l`.  Crucially, both `a` and `b` must be multiples of `g`. So we can represent them as `a = g * x` and `b = g * y`, where `GCD(x, y) = 1`. Substituting this gives us a way to relate g, l, x, and y:  `x * y = l / g`.\n\nThis is where the constraints kick in.  We have conditions:\n\n1.  `l` must be divisible by `g` -- otherwise, it's an immediate \"impossible\" scenario.\n2.  If `P = l / g`, we need to find `x` and `y` such that `x * y = P` and `GCD(x, y) = 1`.\n3.  `a = g * x` and `b = g * y` have to be within the range [1, 10^6].\n\nThe problem structure lends itself to a graph-based approach. We can think of each lawn as a node and try to assign a value (mushroom count) to each node.\n\n**Fixing a Lawn's Value**\nNow, here's an interesting idea. Let's say we *fix* the value of a lawn, `u`.  If we know the mushroom count `val[u]` on lawn `u`, we can potentially determine the count on any neighbor `v`.  For an edge (u, v) with GCD = g and LCM = l,  we know `val[u] * val[v] = g * l`, so `val[v] = (g * l) / val[u]`.\n\nHowever, for this value to be valid, we need to check three conditions.\n1. `val[v]` must be an integer -- so `val[u]` must divide `g * l`.\n2. `GCD(val[u], val[v])` must equal `g`.\n3. `LCM(val[u], val[v])` must equal `l`.\n\nSo this graph structure, combined with these constraints based on the number-theoretic relationships, presents a structured path to build a solution. Time to start coding this up.\n",
    "response": "```python\nimport sys\nimport math\n\n# Function to calculate GCD\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\n# Function to calculate LCM\ndef lcm(a, b):\n    if a == 0 or b == 0:\n        return 0\n    return (a * b) // gcd(a, b)\n\n# Function to find prime factors of a number\n# Returns a dictionary: {prime_factor: exponent}\ndef prime_factorize(n):\n    factors = {}\n    d = 2\n    temp = n\n    while d * d <= temp:\n        while temp % d == 0:\n            factors[d] = factors.get(d, 0) + 1\n            temp //= d\n        d += 1\n    if temp > 1:\n        factors[temp] = factors.get(temp, 0) + 1\n    return factors\n\n# Global variables for graph and values\nadj = []\nvalues = []\nvisited = []\npossible = True\nMAX_VAL = 10**6\n\n# DFS function to propagate values and check consistency\n# u: current node\n# val_u: value assigned to node u\n# current_factor_map: dictionary of prime factors and their exponents for val_u\ndef dfs(u, val_u, current_factor_map):\n    global possible\n    if not possible:\n        return\n\n    values[u] = val_u\n    visited[u] = True\n\n    for v, g, l in adj[u]:\n        if not possible:\n            return\n\n        # Check basic GCD/LCM property\n        if l % g != 0:\n            possible = False\n            return\n        \n        # Calculate expected product P = g * l\n        # Use division to avoid overflow if g*l is large, though problem constraints make this less likely (10^6 * 10^6 = 10^12)\n        # We need val_u * val_v = g * l\n        # So val_v = (g * l) // val_u\n        \n        if (g * l) % val_u != 0: # val_u must divide g*l\n            possible = False\n            return\n\n        val_v = (g * l) // val_u\n\n        if not (1 <= val_v <= MAX_VAL):\n            possible = False\n            return\n\n        if visited[v]:\n            # If neighbor v is already visited, check consistency\n            if values[v] != val_v:\n                possible = False\n                return\n            # Also check GCD and LCM with the fixed values\n            if gcd(val_u, values[v]) != g or lcm(val_u, values[v]) != l:\n                possible = False\n                return\n        else:\n            # If neighbor v is not visited, check if val_v satisfies GCD and LCM\n            if gcd(val_u, val_v) != g or lcm(val_u, val_v) != l:\n                possible = False\n                return\n            \n            # Recurse for v\n            dfs(v, val_v, current_factor_map)\n\n\ndef solve():\n    global adj, values, visited, possible\n\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    edges = []\n\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l))\n        edges.append((u, v, g, l)) # Store edges for initial checks\n\n    values = [0] * (n + 1)\n    visited = [False] * (n + 1)\n    possible = True\n\n    for u, v, g, l in edges:\n        if l % g != 0:\n            possible = False\n            break\n    if not possible:\n        sys.stdout.write(\"NO\\n\")\n        return\n\n    # Try to assign values using prime factorization for connected components\n    for i in range(1, n + 1):\n        if not possible:\n            break\n        if not visited[i]:\n            # Start a new DFS traversal for a connected component\n            # If the component has edges, we need to determine relative values\n            # If it's an isolated node, we can assign 1.\n            \n            # Find all prime factors involved in this component\n            component_primes = {}\n            q = [i]\n            component_nodes = set()\n            component_edges = []\n            component_nodes.add(i)\n            q_idx = 0\n            while q_idx < len(q):\n                curr = q[q_idx]\n                q_idx += 1\n                for neighbor, g_edge, l_edge in adj[curr]:\n                    component_edges.append((curr, neighbor, g_edge, l_edge))\n                    if neighbor not in component_nodes:\n                        component_nodes.add(neighbor)\n                        q.append(neighbor)\n                    \n                    # Add prime factors of g_edge and l_edge to component_primes\n                    for val in [g_edge, l_edge]:\n                        for p, exp in prime_factorize(val).items():\n                            component_primes[p] = max(component_primes.get(p, 0), exp)\n            \n            if not component_edges: # Isolated node\n                if not (1 <= 1 <= MAX_VAL):\n                    possible = False\n                    break\n                values[i] = 1\n                visited[i] = True\n                continue\n\n            # For each prime p, we have `val[x] = p^exp_x * ...`\n            # `GCD(val[u], val[v]) = p^min(exp_u, exp_v) * ...`\n            # `LCM(val[u], val[v]) = p^max(exp_u, exp_v) * ...`\n            # Let `exp[x][p]` be the exponent of prime `p` in `val[x]`.\n            # We need to find `exp[x][p]` for all nodes `x` in the component and all relevant primes `p`.\n            \n            # For each prime factor p in component_primes:\n            # We need to assign `exp[node][p]` values.\n            # This is a 2-coloring problem on the graph for each prime.\n            \n            # For a prime `p`, let `exp_u` be `exp[u][p]` and `exp_v` be `exp[v][p]`.\n            # For an edge (u, v) with GCD_edge `g_uv` and LCM_edge `l_uv`:\n            # `min(exp_u, exp_v) = exp[g_uv][p]`\n            # `max(exp_u, exp_v) = exp[l_uv][p]`\n            # This implies `exp[g_uv][p] + exp[l_uv][p] = exp_u + exp_v`.\n            \n            # We can fix `exp[start_node][p]` to some value (e.g., 0) and propagate.\n            # The actual values of `exp[node][p]` might need to be shifted later.\n            \n            # This approach is more complex than needed for \"easy\" problem.\n            # A simpler approach: try all divisors of g_first and l_first for the first edge.\n            \n            # Simplified approach: Fix the value for the starting node `i` to 1.\n            # This might not be optimal, but if a solution exists, one where `values[i]` is 1\n            # (or some other small value) might be found.\n            # If `values[i]` is `X`, then `values[v]` will be `(g*l)/X`.\n            # The whole component effectively gets scaled by `X` (or `1/X`).\n            # We need to find `X` such that all values are integers and within range.\n            \n            # Let's try fixing `values[i]` to 1 initially.\n            # Then, after DFS, we find the minimum `val_min = min(values[x] for x in component_nodes)`\n            # and scale all values by `1 / val_min` (if val_min is not 1).\n            # Then check if all values are integers and within range.\n            \n            # This doesn't quite work because the values could be non-integers if we fix values[i]=1\n            # and then values[v] = (g*l)/1.\n            # The relative values are fixed by the GCD/LCM property.\n            # For any node `x` in the component, `val[x] = k * initial_val[x]` for some `k`.\n            # We need to find the largest `k` such that `k * initial_val[x]` is an integer for all `x`\n            # and `k * initial_val[x]` is within `[1, MAX_VAL]`.\n            \n            # Let `initial_val[i] = 1`.\n            # For each `v` connected to `u`, `initial_val[v] = (g*l) / initial_val[u]`.\n            # These `initial_val`s might be fractional.\n            # To make them integers, we need to multiply all `initial_val`s by some `S`.\n            # `S` must be the LCM of all denominators of `initial_val[x]`.\n            # Let `initial_val[x] = num_x / den_x`.\n            # `S = LCM(den_x)`.\n            # Then `val[x] = S * initial_val[x]`.\n            # This `val[x]` is the \"base\" integer value.\n            # We can then scale `val[x]` by some integer `k`.\n            # So `final_val[x] = k * S * initial_val[x]`.\n            # We need to find `k` such that `1 <= k * S * initial_val[x] <= MAX_VAL` for all `x`.\n            # The smallest such `k` is 1. The largest `k` is `floor(MAX_VAL / (S * initial_val[x]))` for all `x`.\n            # We just need to check if `k=1` works.\n            \n            # Let's use `fractions.Fraction` to handle potential fractional values.\n            # Or, more simply, use prime exponents.\n            \n            # For each prime `p` appearing in any `g` or `l` in the component:\n            # We want to find `exp[node][p]` for each node.\n            # Fix `exp[i][p] = 0` for all `p`.\n            # Propagate `exp[v][p] = exp[g_uv][p] + exp[l_uv][p] - exp[u][p]`.\n            # This determines `exp[node][p]` relative to `exp[i][p]`.\n            # Let `relative_exp[node][p]` be these values. They can be negative.\n            # Let `min_exp_p = min(relative_exp[node][p] for node in component_nodes)`.\n            # Then `actual_exp[node][p] = relative_exp[node][p] - min_exp_p`.\n            # This ensures all exponents are non-negative and at least one node has `exp[node][p] = 0`.\n            # Now, `val[node] = product(p^actual_exp[node][p])`.\n            # These are the smallest possible integer values for the component.\n            # Check if they are consistent and within range.\n            \n            # Initialize component_exponents for this component\n            # component_exponents[node_id][prime_factor] = exponent\n            component_exponents = {node: {} for node in component_nodes}\n            \n            # For each prime p involved in this component:\n            for p in component_primes:\n                # Use a temporary visited array for this prime's exponent calculation\n                temp_visited_prime = {node: False for node in component_nodes}\n                \n                # Stack for DFS for this prime\n                stack = [(i, 0)] # (node, current_exponent_for_p)\n                temp_visited_prime[i] = True\n                component_exponents[i][p] = 0\n                \n                while stack:\n                    u_prime, exp_u_prime = stack.pop()\n                    \n                    for v_prime, g_edge, l_edge in adj[u_prime]:\n                        if v_prime not in component_nodes: # Should not happen if component_nodes is correctly built\n                            continue\n                        \n                        exp_g_prime = prime_factorize(g_edge).get(p, 0)\n                        exp_l_prime = prime_factorize(l_edge).get(p, 0)\n                        \n                        # min(exp_u_prime, exp_v_prime) = exp_g_prime\n                        # max(exp_u_prime, exp_v_prime) = exp_l_prime\n                        # This implies exp_u_prime + exp_v_prime = exp_g_prime + exp_l_prime\n                        \n                        exp_v_prime_calc = exp_g_prime + exp_l_prime - exp_u_prime\n                        \n                        if temp_visited_prime[v_prime]:\n                            # Consistency check\n                            if component_exponents[v_prime][p] != exp_v_prime_calc:\n                                possible = False\n                                break\n                        else:\n                            component_exponents[v_prime][p] = exp_v_prime_calc\n                            temp_visited_prime[v_prime] = True\n                            stack.append((v_prime, exp_v_prime_calc))\n                    if not possible:\n                        break\n                if not possible:\n                    break\n            if not possible:\n                break\n            \n            # After determining all relative exponents for all primes:\n            # Calculate the smallest possible integer values for each node in the component\n            # by shifting exponents such that they are all non-negative.\n            \n            # Find the minimum exponent for each prime across all nodes in the component\n            min_exponents_for_primes = {}\n            for p in component_primes:\n                min_exponents_for_primes[p] = min(component_exponents[node][p] for node in component_nodes)\n            \n            # Calculate the base values for each node\n            base_values = {node: 1 for node in component_nodes}\n            for node in component_nodes:\n                for p in component_primes:\n                    actual_exp = component_exponents[node][p] - min_exponents_for_primes[p]\n                    base_values[node] *= (p ** actual_exp)\n            \n            # Now, check consistency and ranges for these base_values\n            # These base_values are the smallest possible positive integers that satisfy the relative properties.\n            # We need to find a scaling factor `k` such that `1 <= k * base_values[node] <= MAX_VAL`.\n            \n            max_scale_factor = MAX_VAL + 1 # Effectively infinity\n            \n            for node in component_nodes:\n                if base_values[node] == 0: # Should not happen with positive values\n                    possible = False\n                    break\n                if base_values[node] > MAX_VAL:\n                    max_scale_factor = 0 # Cannot even scale by 1\n                    break\n                max_scale_factor = min(max_scale_factor, MAX_VAL // base_values[node])\n            \n            if not possible:\n                break\n            \n            if max_scale_factor < 1: # No valid scaling factor k exists\n                possible = False\n                break\n            \n            # Choose k=1 (the smallest possible scaling factor)\n            # If any solution exists, this is one of them.\n            k = 1\n            for node in component_nodes:\n                values[node] = k * base_values[node]\n                visited[node] = True # Mark as visited for the main loop\n            \n            # Final consistency check for the component using the calculated values\n            for u_comp in component_nodes:\n                for v_comp, g_edge, l_edge in adj[u_comp]:\n                    if v_comp not in component_nodes: # Edge leads outside component, ignore\n                        continue\n                    \n                    val_u_comp = values[u_comp]\n                    val_v_comp = values[v_comp]\n                    \n                    if not (1 <= val_u_comp <= MAX_VAL and 1 <= val_v_comp <= MAX_VAL):\n                        possible = False\n                        break\n                    if gcd(val_u_comp, val_v_comp) != g_edge or lcm(val_u_comp, val_v_comp) != l_edge:\n                        possible = False\n                        break\n                if not possible:\n                    break\n            \n    if not possible:\n        sys.stdout.write(\"NO\\n\")\n    else:\n        sys.stdout.write(\"YES\\n\")\n        sys.stdout.write(\" \".join(map(str, values[1:])) + \"\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport math\n\n# Function to calculate GCD\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\n# Function to calculate LCM\ndef lcm(a, b):\n    if a == 0 or b == 0:\n        return 0\n    return (a * b) // gcd(a, b)\n\n# Function to find prime factors of a number\n# Returns a dictionary: {prime_factor: exponent}\ndef prime_factorize(n):\n    factors = {}\n    d = 2\n    temp = n\n    while d * d <= temp:\n        while temp % d == 0:\n            factors[d] = factors.get(d, 0) + 1\n            temp //= d\n        d += 1\n    if temp > 1:\n        factors[temp] = factors.get(temp, 0) + 1\n    return factors\n\n# Global variables for graph and values\nadj = []\nvalues = []\nvisited = []\npossible = True\nMAX_VAL = 10**6\n\n# DFS function to propagate values and check consistency\n# u: current node\n# val_u: value assigned to node u\n# current_factor_map: dictionary of prime factors and their exponents for val_u\ndef dfs(u, val_u, current_factor_map):\n    global possible\n    if not possible:\n        return\n\n    values[u] = val_u\n    visited[u] = True\n\n    for v, g, l in adj[u]:\n        if not possible:\n            return\n\n        # Check basic GCD/LCM property\n        if l % g != 0:\n            possible = False\n            return\n        \n        # Calculate expected product P = g * l\n        # Use division to avoid overflow if g*l is large, though problem constraints make this less likely (10^6 * 10^6 = 10^12)\n        # We need val_u * val_v = g * l\n        # So val_v = (g * l) // val_u\n        \n        if (g * l) % val_u != 0: # val_u must divide g*l\n            possible = False\n            return\n\n        val_v = (g * l) // val_u\n\n        if not (1 <= val_v <= MAX_VAL):\n            possible = False\n            return\n\n        if visited[v]:\n            # If neighbor v is already visited, check consistency\n            if values[v] != val_v:\n                possible = False\n                return\n            # Also check GCD and LCM with the fixed values\n            if gcd(val_u, values[v]) != g or lcm(val_u, values[v]) != l:\n                possible = False\n                return\n        else:\n            # If neighbor v is not visited, check if val_v satisfies GCD and LCM\n            if gcd(val_u, val_v) != g or lcm(val_u, val_v) != l:\n                possible = False\n                return\n            \n            # Recurse for v\n            dfs(v, val_v, current_factor_map)\n\n\ndef solve():\n    global adj, values, visited, possible\n\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    edges = []\n\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        adj[u].append((v, g, l))\n        adj[v].append((u, g, l))\n        edges.append((u, v, g, l)) # Store edges for initial checks\n\n    values = [0] * (n + 1)\n    visited = [False] * (n + 1)\n    possible = True\n\n    for u, v, g, l in edges:\n        if l % g != 0:\n            possible = False\n            break\n    if not possible:\n        sys.stdout.write(\"NO\\n\")\n        return\n\n    # Try to assign values using prime factorization for connected components\n    for i in range(1, n + 1):\n        if not possible:\n            break\n        if not visited[i]:\n            # Start a new DFS traversal for a connected component\n            # If the component has edges, we need to determine relative values\n            # If it's an isolated node, we can assign 1.\n            \n            # Find all prime factors involved in this component\n            component_primes = {}\n            q = [i]\n            component_nodes = set()\n            component_edges = []\n            component_nodes.add(i)\n            q_idx = 0\n            while q_idx < len(q):\n                curr = q[q_idx]\n                q_idx += 1\n                for neighbor, g_edge, l_edge in adj[curr]:\n                    component_edges.append((curr, neighbor, g_edge, l_edge))\n                    if neighbor not in component_nodes:\n                        component_nodes.add(neighbor)\n                        q.append(neighbor)\n                    \n                    # Add prime factors of g_edge and l_edge to component_primes\n                    for val in [g_edge, l_edge]:\n                        for p, exp in prime_factorize(val).items():\n                            component_primes[p] = max(component_primes.get(p, 0), exp)\n            \n            if not component_edges: # Isolated node\n                if not (1 <= 1 <= MAX_VAL):\n                    possible = False\n                    break\n                values[i] = 1\n                visited[i] = True\n                continue\n\n            # For each prime p, we have `val[x] = p^exp_x * ...`\n            # `GCD(val[u], val[v]) = p^min(exp_u, exp_v) * ...`\n            # `LCM(val[u], val[v]) = p^max(exp_u, exp_v) * ...`\n            # Let `exp[x][p]` be the exponent of prime `p` in `val[x]`.\n            # We need to find `exp[x][p]` for all nodes `x` in the component and all relevant primes `p`.\n            \n            # For each prime factor p in component_primes:\n            # We need to assign `exp[node][p]` values.\n            # This is a 2-coloring problem on the graph for each prime.\n            \n            # For a prime `p`, let `exp_u` be `exp[u][p]` and `exp_v` be `exp[v][p]`.\n            # For an edge (u, v) with GCD_edge `g_uv` and LCM_edge `l_uv`:\n            # `min(exp_u, exp_v) = exp[g_uv][p]`\n            # `max(exp_u, exp_v) = exp[l_uv][p]`\n            # This implies `exp[g_uv][p] + exp[l_uv][p] = exp_u + exp_v`.\n            \n            # We can fix `exp[start_node][p]` to some value (e.g., 0) and propagate.\n            # The actual values of `exp[node][p]` might need to be shifted later.\n            \n            # This approach is more complex than needed for \"easy\" problem.\n            # A simpler approach: try all divisors of g_first and l_first for the first edge.\n            \n            # Simplified approach: Fix the value for the starting node `i` to 1.\n            # This might not be optimal, but if a solution exists, one where `values[i]` is 1\n            # (or some other small value) might be found.\n            # If `values[i]` is `X`, then `values[v]` will be `(g*l)/X`.\n            # The whole component effectively gets scaled by `X` (or `1/X`).\n            # We need to find `X` such that all values are integers and within range.\n            \n            # Let's try fixing `values[i]` to 1 initially.\n            # Then, after DFS, we find the minimum `val_min = min(values[x] for x in component_nodes)`\n            # and scale all values by `1 / val_min` (if val_min is not 1).\n            # Then check if all values are integers and within range.\n            \n            # This doesn't quite work because the values could be non-integers if we fix values[i]=1\n            # and then values[v] = (g*l)/1.\n            # The relative values are fixed by the GCD/LCM property.\n            # For any node `x` in the component, `val[x] = k * initial_val[x]` for some `k`.\n            # We need to find the largest `k` such that `k * initial_val[x]` is an integer for all `x`\n            # and `k * initial_val[x]` is within `[1, MAX_VAL]`.\n            \n            # Let `initial_val[i] = 1`.\n            # For each `v` connected to `u`, `initial_val[v] = (g*l) / initial_val[u]`.\n            # These `initial_val`s might be fractional.\n            # To make them integers, we need to multiply all `initial_val`s by some `S`.\n            # `S` must be the LCM of all denominators of `initial_val[x]`.\n            # Let `initial_val[x] = num_x / den_x`.\n            # `S = LCM(den_x)`.\n            # Then `val[x] = S * initial_val[x]`.\n            # This `val[x]` is the \"base\" integer value.\n            # We can then scale `val[x]` by some integer `k`.\n            # So `final_val[x] = k * S * initial_val[x]`.\n            # We need to find `k` such that `1 <= k * S * initial_val[x] <= MAX_VAL` for all `x`.\n            # The smallest such `k` is 1. The largest `k` is `floor(MAX_VAL / (S * initial_val[x]))` for all `x`.\n            # We just need to check if `k=1` works.\n            \n            # Let's use `fractions.Fraction` to handle potential fractional values.\n            # Or, more simply, use prime exponents.\n            \n            # For each prime `p` appearing in any `g` or `l` in the component:\n            # We want to find `exp[node][p]` for each node.\n            # Fix `exp[i][p] = 0` for all `p`.\n            # Propagate `exp[v][p] = exp[g_uv][p] + exp[l_uv][p] - exp[u][p]`.\n            # This determines `exp[node][p]` relative to `exp[i][p]`.\n            # Let `relative_exp[node][p]` be these values. They can be negative.\n            # Let `min_exp_p = min(relative_exp[node][p] for node in component_nodes)`.\n            # Then `actual_exp[node][p] = relative_exp[node][p] - min_exp_p`.\n            # This ensures all exponents are non-negative and at least one node has `exp[node][p] = 0`.\n            # Now, `val[node] = product(p^actual_exp[node][p])`.\n            # These are the smallest possible integer values for the component.\n            # Check if they are consistent and within range.\n            \n            # Initialize component_exponents for this component\n            # component_exponents[node_id][prime_factor] = exponent\n            component_exponents = {node: {} for node in component_nodes}\n            \n            # For each prime p involved in this component:\n            for p in component_primes:\n                # Use a temporary visited array for this prime's exponent calculation\n                temp_visited_prime = {node: False for node in component_nodes}\n                \n                # Stack for DFS for this prime\n                stack = [(i, 0)] # (node, current_exponent_for_p)\n                temp_visited_prime[i] = True\n                component_exponents[i][p] = 0\n                \n                while stack:\n                    u_prime, exp_u_prime = stack.pop()\n                    \n                    for v_prime, g_edge, l_edge in adj[u_prime]:\n                        if v_prime not in component_nodes: # Should not happen if component_nodes is correctly built\n                            continue\n                        \n                        exp_g_prime = prime_factorize(g_edge).get(p, 0)\n                        exp_l_prime = prime_factorize(l_edge).get(p, 0)\n                        \n                        # min(exp_u_prime, exp_v_prime) = exp_g_prime\n                        # max(exp_u_prime, exp_v_prime) = exp_l_prime\n                        # This implies exp_u_prime + exp_v_prime = exp_g_prime + exp_l_prime\n                        \n                        exp_v_prime_calc = exp_g_prime + exp_l_prime - exp_u_prime\n                        \n                        if temp_visited_prime[v_prime]:\n                            # Consistency check\n                            if component_exponents[v_prime][p] != exp_v_prime_calc:\n                                possible = False\n                                break\n                        else:\n                            component_exponents[v_prime][p] = exp_v_prime_calc\n                            temp_visited_prime[v_prime] = True\n                            stack.append((v_prime, exp_v_prime_calc))\n                    if not possible:\n                        break\n                if not possible:\n                    break\n            if not possible:\n                break\n            \n            # After determining all relative exponents for all primes:\n            # Calculate the smallest possible integer values for each node in the component\n            # by shifting exponents such that they are all non-negative.\n            \n            # Find the minimum exponent for each prime across all nodes in the component\n            min_exponents_for_primes = {}\n            for p in component_primes:\n                min_exponents_for_primes[p] = min(component_exponents[node][p] for node in component_nodes)\n            \n            # Calculate the base values for each node\n            base_values = {node: 1 for node in component_nodes}\n            for node in component_nodes:\n                for p in component_primes:\n                    actual_exp = component_exponents[node][p] - min_exponents_for_primes[p]\n                    base_values[node] *= (p ** actual_exp)\n            \n            # Now, check consistency and ranges for these base_values\n            # These base_values are the smallest possible positive integers that satisfy the relative properties.\n            # We need to find a scaling factor `k` such that `1 <= k * base_values[node] <= MAX_VAL`.\n            \n            max_scale_factor = MAX_VAL + 1 # Effectively infinity\n            \n            for node in component_nodes:\n                if base_values[node] == 0: # Should not happen with positive values\n                    possible = False\n                    break\n                if base_values[node] > MAX_VAL:\n                    max_scale_factor = 0 # Cannot even scale by 1\n                    break\n                max_scale_factor = min(max_scale_factor, MAX_VAL // base_values[node])\n            \n            if not possible:\n                break\n            \n            if max_scale_factor < 1: # No valid scaling factor k exists\n                possible = False\n                break\n            \n            # Choose k=1 (the smallest possible scaling factor)\n            # If any solution exists, this is one of them.\n            k = 1\n            for node in component_nodes:\n                values[node] = k * base_values[node]\n                visited[node] = True # Mark as visited for the main loop\n            \n            # Final consistency check for the component using the calculated values\n            for u_comp in component_nodes:\n                for v_comp, g_edge, l_edge in adj[u_comp]:\n                    if v_comp not in component_nodes: # Edge leads outside component, ignore\n                        continue\n                    \n                    val_u_comp = values[u_comp]\n                    val_v_comp = values[v_comp]\n                    \n                    if not (1 <= val_u_comp <= MAX_VAL and 1 <= val_v_comp <= MAX_VAL):\n                        possible = False\n                        break\n                    if gcd(val_u_comp, val_v_comp) != g_edge or lcm(val_u_comp, val_v_comp) != l_edge:\n                        possible = False\n                        break\n                if not possible:\n                    break\n            \n    if not possible:\n        sys.stdout.write(\"NO\\n\")\n    else:\n        sys.stdout.write(\"YES\\n\")\n        sys.stdout.write(\" \".join(map(str, values[1:])) + \"\\n\")\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 551,
        "completion_token_count": 4033,
        "thoughts_token_count": 783
    }
}