{
    "start": 1758011831.0242996,
    "end": 1758011952.3304958,
    "start-formatted": "2025-09-16 17:37 KST",
    "end-formatted": "2025-09-16 17:39 KST",
    "gpu": 2,
    "pid": 8,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "**Alright, here's my breakdown of this \"Flawed Flow\" problem, as I see it:**\n\nOkay, so the user wants a Python solution for a tricky graph problem. Essentially, we've got an undirected graph where each edge has a flow capacity. The goal is to direct these edges while satisfying specific conditions: flow conservation (except for the source and sink), no cycles, and the source has no incoming flow, while the sink has no outgoing flow (which is essentially what a normal max-flow looks like).\n\nFirst, I re-evaluated the constraints. The key is \"no cycles.\" That screams topological ordering to me. We need a directed acyclic graph (DAG) where the flow balances at each intermediate node. The sink part is strongly suggested by the problem, and typical max-flow principles.\n\nNext, I worked through flow balance for any node `v` and realized there are two important properties. First, for the intermediate nodes, the sum of incoming flow must equal the outgoing flow. Second, for the source and sink, there is an incoming constraint and an outgoing constraint, respectively. This gives me a \"net flow\" idea - if we direct an edge, we add or subtract from a node's net flow. \n\nI initially thought about balancing this net flow with the incoming and outgoing edges but realized the no-cycles constraint complicates things. My first thought, 2-SAT or max-flow, is probably overkill.\n\nI thought about greedy approaches but realized that this won't work in general, especially when considering the \"no cycles\" condition.\n\nI had the key realization that if we use the source and sink as an initial guide, and then try to make sure each node has the incoming and outcoming flow equal, in the end, we can easily violate the acyclic property.\n\nThen, I came up with an iterative approach. If we can control this \"net flow\" for each node, which is `in_flow - out_flow`, the problem becomes simpler. The key thing is to fix this by using a queue to control how each node is processed and making sure any net flow imbalance is fixed before dealing with a node.\n\nThe problem requires a topological ordering, which suggests a processing order. I considered Kahn's algorithm or DFS. The basic algorithm should be: the edges from the source need to be directed away from the source; the edges to the sink need to be directed to the sink.\n\nThen, to direct the remaining edges, we process nodes in some order. For each node, we try to satisfy the in-flow and out-flow constraint. The topological sort is not directly used here, but the principle \"don't create cycles\" is enforced via this iteration order.\n\nThe algorithm can be summarized as:\n1.  Initialize flow balance and directions.\n2.  Process edges connected to the source and sink.\n3.  Process intermediate nodes in an order, using a queue or something like a topological sort.\n4.  Direct remaining edges to balance flow for intermediate nodes, making sure no cycles are generated.\n\nThis sounds like a plan. Let's start coding.\n",
    "response": "The problem asks us to direct each edge of a given undirected graph, which has associated flow volumes, such that several conditions are met:\n1.  **Flow Conservation:** For any intermediate vertex `v` (1 < `v` < `n`), the sum of flow on incoming edges equals the sum of flow on outgoing edges.\n2.  **Source (Vertex 1):** Vertex 1 has no incoming edges. All flow on edges connected to 1 must be outgoing.\n3.  **Sink (Vertex n):** Although not explicitly stated, in a standard max-flow context where 1 is the source and `n` is the sink, `n` must have no outgoing edges. All flow on edges connected to `n` must be incoming. This is a consequence of flow conservation for intermediate nodes and the source having only outgoing flow.\n4.  **Acyclicity:** The resulting directed graph must not have cycles.\n\nThe problem guarantees that a solution always exists.\n\nLet's define `balance[v]` for each vertex `v` as `(sum of flow into v) - (sum of flow out of v)`.\nBased on the conditions:\n*   For `1 < v < n`, we need `balance[v] = 0`.\n*   For `v = 1`, `balance[1]` must be negative (total outgoing flow).\n*   For `v = n`, `balance[n]` must be positive (total incoming flow).\n\nThe acyclicity condition is crucial. It implies that we can process vertices in a topological order. Since we don't know the directions beforehand to determine a topological order, we can use a queue-based approach similar to Kahn's algorithm for topological sort, but adapted for flow.\n\n**Algorithm:**\n\n1.  **Initialization:**\n    *   `ans_directions`: An array of size `m` to store the direction for each edge. Initialize with -1 (undetermined). `0` means `a_i -> b_i`, `1` means `b_i -> a_i`.\n    *   `adj`: An adjacency list where `adj[u]` stores tuples `(v, capacity, edge_index)` for all neighbors `v` of `u`.\n    *   `edges_info`: A list of tuples `(u, v, capacity)` for each edge, indexed by `edge_index`.\n    *   `balance`: An array of size `n+1`, initialized to 0. This will track the `(incoming flow - outgoing flow)` for each vertex.\n    *   `degree`: An array of size `n+1`, initialized to 0. This will track the number of *undirected* edges incident to each vertex.\n\n2.  **Build Graph and Initial Degrees:**\n    *   Read `n` and `m`.\n    *   For each edge `i` from `0` to `m-1`:\n        *   Read `u, v, c`.\n        *   Store `(u, v, c)` in `edges_info[i]`.\n        *   Add `(v, c, i)` to `adj[u]` and `(u, c, i)` to `adj[v]`.\n        *   Increment `degree[u]` and `degree[v]`.\n\n3.  **Process Intermediate Nodes (1 < v < n) using a Queue:**\n    *   Create a `deque` called `q`.\n    *   For each vertex `v` from `2` to `n-1`:\n        *   If `degree[v] == 1`: This means `v` has only one undirected edge remaining. To satisfy `balance[v] = 0`, this edge's direction is determined. Add `v` to `q`.\n\n    *   **Main Loop:** While `q` is not empty:\n        *   Dequeue a vertex `u`.\n        *   If `u == 1` or `u == n`, continue (these nodes don't need `balance[u]=0`).\n        *   Find the single remaining undirected edge connected to `u`. Let this edge be `(u, v)` with capacity `c` and index `idx`.\n            *   Iterate through `adj[u]`. If `ans_directions[edge_index]` is -1 for an edge `(neighbor, cap, edge_index)`, that's our undirected edge.\n            *   Let `v = neighbor`, `c = cap`, `idx = edge_index`.\n        *   **Direct the edge:**\n            *   If `balance[u]` is 0, it means `u` needs no net flow. This implies the flow must enter `u` through this edge and immediately leave `u` through this same edge, which is not possible. This scenario means `u` must have already had its balance set to 0. If `balance[u]` is not 0, it means `u` has a net flow that needs to be balanced.\n            *   The problem guarantees a solution exists. For an intermediate node `u` (1 < `u` < `n`), its final `balance[u]` must be 0. If `u` has only one remaining undirected edge `(u, v)` with capacity `c`, then to make `balance[u]` zero, this edge must be directed such that it cancels out the current `balance[u]`.\n            *   If `balance[u] > 0`: `u` has more incoming flow than outgoing. To balance it, the edge `(u, v)` must be directed `u -> v` (outgoing from `u`). This decreases `balance[u]` by `c` and increases `balance[v]` by `c`.\n            *   If `balance[u] < 0`: `u` has more outgoing flow than incoming. To balance it, the edge `(u, v)` must be directed `v -> u` (incoming to `u`). This increases `balance[u]` by `c` and decreases `balance[v]` by `c`.\n            *   If `balance[u] == 0`: This is the tricky part. If `u` is an intermediate node and `balance[u]` is already 0, and it has only one undirected edge, then that edge must be directed in a way that doesn't change `balance[u]`. This implies `c` must be 0, which is not allowed. The only way `balance[u]` could be 0 and `degree[u]` is 1 is if `u` was already processed or should not be processed. However, the logic `degree[v] == 1` means it *just became* 1, meaning its other edges got directed.\n            *   A more robust way: for `1 < u < n`, we want `balance[u]` to be 0. If `u` is dequeued, it means it has `degree[u] == 1`. Let `(u, v)` be its last undirected edge. `balance[u]` now represents `(fixed_in_flow - fixed_out_flow)`. To make the final `balance[u]` zero, we must direct `(u, v)` to compensate for `balance[u]`.\n                *   If `balance[u] != 0`:\n                    *   If `balance[u] > 0`: Direct `u -> v`. `ans_directions[idx] = 0` if `u` is `edges_info[idx][0]`, else `1`.\n                    *   If `balance[u] < 0`: Direct `v -> u`. `ans_directions[idx] = 1` if `u` is `edges_info[idx][0]`, else `0`.\n                    *   Apply changes: `balance[u]` becomes 0. `balance[v]` is updated.\n                *   If `balance[u] == 0`: This implies that all previous edges connected to `u` were balanced, and this last edge `(u, v)` must also be balanced. However, `balance[u]` is defined as `(in - out)`, and we need it to be 0. If `balance[u]` is already 0, and there's a remaining edge, it means the total capacity of all incident edges to `u` is 0. This is not possible as `c_i >= 1`.\n                *   The total flow on edges incident to `u` (let it be `S_u`) must be even, so `S_u/2` must be incoming and `S_u/2` outgoing. `balance[u]` is `in_actual - out_actual`. `S_u = in_actual + out_actual`. We need `in_actual = out_actual = S_u/2`.\n                *   The actual value we need to achieve is `0`. So for the last edge `(u,v)` with capacity `c`:\n                    *   If `balance[u] != 0`:\n                        *   If `edges_info[idx][0] == u`:\n                            *   If `balance[u] > 0`: Direct `u -> v` (`ans_directions[idx] = 0`). `balance[v] += c`.\n                            *   Else (`balance[u] < 0`): Direct `v -> u` (`ans_directions[idx] = 1`). `balance[v] -= c`.\n                        *   Else (`edges_info[idx][1] == u`):\n                            *   If `balance[u] > 0`: Direct `u -> v` (`ans_directions[idx] = 1`). `balance[v] += c`.\n                            *   Else (`balance[u] < 0`): Direct `v -> u` (`ans_directions[idx] = 0`). `balance[v] -= c`.\n                        *   `balance[u]` is now effectively 0.\n                    *   This logic works because the problem guarantees a solution.\n        *   Decrement `degree[v]`.\n        *   If `1 < v < n` and `degree[v] == 1`, add `v` to `q`.\n\n    This queue-based approach essentially \"peels off\" nodes from the graph that have only one remaining undirected edge. For such a node `u` (1 < `u` < `n`), the direction of that single edge is uniquely determined to satisfy `balance[u] = 0`. Once directed, this edge is removed from consideration, reducing the `degree` of its neighbor `v`. If `v` then becomes a node with `degree[v] == 1`, it's added to the queue. This process continues until all intermediate nodes have their balance satisfied.\n\n4.  **Handle Source (1) and Sink (n):**\n    The queue process handles intermediate nodes. The source `1` and sink `n` are special.\n    *   For vertex 1: All incident edges must be directed `1 -> X`.\n    *   For vertex `n`: All incident edges must be directed `X -> n`.\n    We can process these nodes after the main queue loop, or integrate them.\n    A simple way to integrate:\n    Initialize `balance` for `1` and `n` differently.\n    `balance[1]` should be `0 - total_outgoing_flow`.\n    `balance[n]` should be `total_incoming_flow - 0`.\n    This means we can initialize `balance[1]` to a very large positive number and `balance[n]` to a very large negative number, so they are never balanced.\n    Or, more simply, just ensure that when `u` or `v` is 1 or `n`, we don't try to make `balance[u]` or `balance[v]` zero.\n\n    Let's refine the `degree` and `balance` updates for the main loop:\n    When an edge `(u, v)` (original `(A_idx, B_idx)` with capacity `C_idx`) is directed:\n    *   `ans_directions[idx]` is set.\n    *   `degree[u]` and `degree[v]` are conceptually decremented (we don't need to explicitly decrement them for `u` since `u` is done, but `v` needs it).\n    *   If `edges_info[idx][0] == u`: (meaning `u` is `A_idx`, `v` is `B_idx`)\n        *   If directed `u -> v`: `balance[u] -= C_idx`, `balance[v] += C_idx`.\n        *   If directed `v -> u`: `balance[u] += C_idx`, `balance[v] -= C_idx`.\n    *   Else (`edges_info[idx][1] == u`): (meaning `u` is `B_idx`, `v` is `A_idx`)\n        *   If directed `u -> v`: `balance[u] -= C_idx`, `balance[v] += C_idx`.\n        *   If directed `v -> u`: `balance[u] += C_idx`, `balance[v] -= C_idx`.\n\n    The problem states \"vertex 1 has no incoming edges\". This means all edges connected to 1 must be directed away from 1.\n    Similarly, all edges connected to `n` must be directed towards `n`.\n    These rules are absolute and must be applied first.\n\n    **Revised Algorithm (Combining initial fixed edges with queue):**\n\n    1.  **Initialization:** Same as above.\n        `adj = [[] for _ in range(n + 1)]`\n        `edges_info = []`\n        `ans_directions = [-1] * m`\n        `balance = [0] * (n + 1)`\n        `current_degree = [0] * (n + 1)` (This tracks the number of *undetermined* edges)\n\n    2.  **Read Input and Populate Structures:**\n        For `i` from `0` to `m-1`:\n            `u, v, c = map(int, sys.stdin.readline().split())`\n            `edges_info.append((u, v, c))`\n            `adj[u].append((v, c, i))`\n            `adj[v].append((u, c, i))`\n            `current_degree[u] += 1`\n            `current_degree[v] += 1`\n\n    3.  **Initial Queue Population & Fixed Edges:**\n        `q = deque()`\n        For `v` from `1` to `n`:\n            If `v == 1` or `v == n`:\n                # Process edges connected to source/sink first\n                For `neighbor, c, idx` in `adj[v]`:\n                    If `ans_directions[idx] == -1`: # If edge not yet directed\n                        `u_orig, v_orig, _ = edges_info[idx]`\n                        If `v == 1`: # Edge connected to source\n                            If `u_orig == 1`: `ans_directions[idx] = 0` (1 -> neighbor)\n                            Else: `ans_directions[idx] = 1` (1 -> neighbor)\n                            `balance[neighbor] += c`\n                            `balance[1] -= c`\n                        Else: # v == n, Edge connected to sink\n                            If `u_orig == n`: `ans_directions[idx] = 1` (neighbor -> n)\n                            Else: `ans_directions[idx] = 0` (neighbor -> n)\n                            `balance[neighbor] -= c`\n                            `balance[n] += c`\n                        `current_degree[v] -= 1`\n                        `current_degree[neighbor] -= 1`\n                        If `1 < neighbor < n` and `current_degree[neighbor] == 1`:\n                            `q.append(neighbor)`\n            Else: # Intermediate node\n                If `current_degree[v] == 1`:\n                    `q.append(v)`\n\n    4.  **Main Queue Processing (Intermediate Nodes):**\n        While `q`:\n            `u = q.popleft()`\n            If `u == 1` or `u == n`: continue # Already handled or not relevant for balance=0\n            If `current_degree[u] != 1`: continue # Already processed or not ready\n\n            # Find the single remaining undirected edge for u\n            `v_neighbor, c_cap, idx_edge = -1, -1, -1`\n            For `neighbor, cap, edge_idx` in `adj[u]`:\n                If `ans_directions[edge_idx] == -1`:\n                    `v_neighbor, c_cap, idx_edge = neighbor, cap, edge_idx`\n                    break\n\n            # Direct this edge to make balance[u] = 0\n            `u_orig, v_orig, _ = edges_info[idx_edge]`\n            If `u_orig == u`: # u is the first vertex in edge_info\n                If `balance[u] < 0`: # u needs incoming flow\n                    `ans_directions[idx_edge] = 1` # v_neighbor -> u\n                    `balance[u] += c_cap`\n                    `balance[v_neighbor] -= c_cap`\n                Else: # u needs outgoing flow (or balance[u] >= 0)\n                    `ans_directions[idx_edge] = 0` # u -> v_neighbor\n                    `balance[u] -= c_cap`\n                    `balance[v_neighbor] += c_cap`\n            Else: # u is the second vertex in edge_info\n                If `balance[u] < 0`: # u needs incoming flow\n                    `ans_directions[idx_edge] = 0` # v_neighbor -> u\n                    `balance[u] += c_cap`\n                    `balance[v_neighbor] -= c_cap`\n                Else: # u needs outgoing flow (or balance[u] >= 0)\n                    `ans_directions[idx_edge] = 1` # u -> v_neighbor\n                    `balance[u] -= c_cap`\n                    `balance[v_neighbor] += c_cap`\n\n            `current_degree[u] -= 1`\n            `current_degree[v_neighbor] -= 1`\n\n            If `1 < v_neighbor < n` and `current_degree[v_neighbor] == 1`:\n                `q.append(v_neighbor)`\n\n    5.  **Output:**\n        Print each element in `ans_directions`.\n\nThis refined approach handles the special conditions for source/sink first, then uses the queue to resolve intermediate nodes. The logic for directing the last edge to balance `balance[u]` relies on the guarantee that a solution exists. If `balance[u]` is negative, `u` needs flow in, so the edge is directed into `u`. If `balance[u]` is positive, `u` needs flow out, so the edge is directed out of `u`. Note that `balance[u]` should never be 0 at this point for an intermediate node `u` with `current_degree[u] == 1` and `c_cap > 0`, because if it were, the total incident flow would be `0`, which is impossible.\n\nExample of edge direction logic with `u_orig, v_orig`:\nEdge `idx` is `(u_orig, v_orig)` with capacity `c_cap`.\nWe are processing node `u`. Its neighbor is `v_neighbor`.\nIf `u_orig == u`:\n  `u` is the `A_i` in `(A_i, B_i)`.\n  If we want `u -> v_neighbor`: `ans_directions[idx] = 0`.\n  If we want `v_neighbor -> u`: `ans_directions[idx] = 1`.\nIf `v_orig == u`:\n  `u` is the `B_i` in `(A_i, B_i)`.\n  If we want `u -> v_neighbor`: `ans_directions[idx] = 1`.\n  If we want `v_neighbor -> u`: `ans_directions[idx] = 0`.\n\nThis logic is correctly implemented in step 4.\n\n```python\nimport sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    edges_info = [] # Stores (u, v, c) for each edge, indexed by original order\n    ans_directions = [-1] * m # 0 for u->v, 1 for v->u\n    \n    # balance[v] = sum_incoming_flow - sum_outgoing_flow\n    # For 1 < v < n, we want balance[v] = 0\n    balance = [0] * (n + 1)\n    \n    # current_degree[v] stores the number of undirected edges incident to v\n    current_degree = [0] * (n + 1)\n\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        edges_info.append((u, v, c))\n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n        current_degree[u] += 1\n        current_degree[v] += 1\n\n    q = deque()\n\n    # First pass: Process edges connected to source (1) or sink (n)\n    # And populate the queue with intermediate nodes that have only one remaining undirected edge\n    \n    # Set of processed edges indices to avoid double processing\n    processed_edges = set()\n\n    for v_node in range(1, n + 1):\n        if v_node == 1 or v_node == n:\n            for neighbor, c_cap, idx_edge in adj[v_node]:\n                if idx_edge not in processed_edges:\n                    u_orig, v_orig, _ = edges_info[idx_edge]\n                    \n                    if v_node == 1: # Edge connected to source 1\n                        # All edges from 1 must be outgoing\n                        if u_orig == 1: # Original edge was (1, neighbor)\n                            ans_directions[idx_edge] = 0 # 1 -> neighbor\n                            balance[neighbor] += c_cap\n                            balance[1] -= c_cap\n                        else: # Original edge was (neighbor, 1)\n                            ans_directions[idx_edge] = 1 # 1 -> neighbor\n                            balance[neighbor] += c_cap\n                            balance[1] -= c_cap\n                    else: # v_node == n, Edge connected to sink n\n                        # All edges to n must be incoming\n                        if u_orig == n: # Original edge was (n, neighbor)\n                            ans_directions[idx_edge] = 1 # neighbor -> n\n                            balance[neighbor] -= c_cap\n                            balance[n] += c_cap\n                        else: # Original edge was (neighbor, n)\n                            ans_directions[idx_edge] = 0 # neighbor -> n\n                            balance[neighbor] -= c_cap\n                            balance[n] += c_cap\n                    \n                    current_degree[v_node] -= 1\n                    current_degree[neighbor] -= 1\n                    processed_edges.add(idx_edge)\n                    \n                    # If neighbor is an intermediate node and now has only one undirected edge, add to queue\n                    if 1 < neighbor < n and current_degree[neighbor] == 1:\n                        q.append(neighbor)\n        else: # Intermediate node\n            if current_degree[v_node] == 1:\n                q.append(v_node)\n\n    # Main loop: Process intermediate nodes to satisfy balance[u] = 0\n    while q:\n        u = q.popleft()\n\n        if u == 1 or u == n: # Source/Sink are not processed this way\n            continue\n        \n        # If current_degree[u] is not 1, it means this node was already processed\n        # or its degree changed since it was added to the queue\n        if current_degree[u] != 1: \n            continue\n\n        # Find the single remaining undirected edge for u\n        v_neighbor = -1\n        c_cap = -1\n        idx_edge = -1\n        \n        for neighbor, cap, edge_idx in adj[u]:\n            if ans_directions[edge_idx] == -1: # Found the undirected edge\n                v_neighbor, c_cap, idx_edge = neighbor, cap, edge_idx\n                break\n        \n        if idx_edge == -1: # Should not happen if current_degree[u] is truly 1\n            continue\n\n        u_orig, v_orig, _ = edges_info[idx_edge]\n\n        # Direct this edge to make balance[u] = 0\n        # If balance[u] is negative, u needs incoming flow\n        # If balance[u] is positive, u needs outgoing flow\n        \n        if u_orig == u: # u is the first vertex in edge_info (u_orig, v_orig)\n            if balance[u] < 0: # u needs incoming flow (v_neighbor -> u)\n                ans_directions[idx_edge] = 1 \n                balance[u] += c_cap\n                balance[v_neighbor] -= c_cap\n            else: # u needs outgoing flow (u -> v_neighbor)\n                ans_directions[idx_edge] = 0\n                balance[u] -= c_cap\n                balance[v_neighbor] += c_cap\n        else: # u is the second vertex in edge_info (u_orig, v_orig)\n            if balance[u] < 0: # u needs incoming flow (v_neighbor -> u)\n                ans_directions[idx_edge] = 0\n                balance[u] += c_cap\n                balance[v_neighbor] -= c_cap\n            else: # u needs outgoing flow (u -> v_neighbor)\n                ans_directions[idx_edge] = 1\n                balance[u] -= c_cap\n                balance[v_neighbor] += c_cap\n        \n        current_degree[u] -= 1 # This edge is now directed\n        current_degree[v_neighbor] -= 1\n\n        # If v_neighbor is an intermediate node and now has only one undirected edge, add to queue\n        if 1 < v_neighbor < n and current_degree[v_neighbor] == 1:\n            q.append(v_neighbor)\n\n    # Output the directions\n    for i in range(m):\n        sys.stdout.write(str(ans_directions[i]) + '\\n')\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    adj = [[] for _ in range(n + 1)]\n    edges_info = [] # Stores (u, v, c) for each edge, indexed by original order\n    ans_directions = [-1] * m # 0 for u->v, 1 for v->u\n    \n    # balance[v] = sum_incoming_flow - sum_outgoing_flow\n    # For 1 < v < n, we want balance[v] = 0\n    balance = [0] * (n + 1)\n    \n    # current_degree[v] stores the number of undirected edges incident to v\n    current_degree = [0] * (n + 1)\n\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        edges_info.append((u, v, c))\n        adj[u].append((v, c, i))\n        adj[v].append((u, c, i))\n        current_degree[u] += 1\n        current_degree[v] += 1\n\n    q = deque()\n\n    # First pass: Process edges connected to source (1) or sink (n)\n    # And populate the queue with intermediate nodes that have only one remaining undirected edge\n    \n    # Set of processed edges indices to avoid double processing\n    processed_edges = set()\n\n    for v_node in range(1, n + 1):\n        if v_node == 1 or v_node == n:\n            for neighbor, c_cap, idx_edge in adj[v_node]:\n                if idx_edge not in processed_edges:\n                    u_orig, v_orig, _ = edges_info[idx_edge]\n                    \n                    if v_node == 1: # Edge connected to source 1\n                        # All edges from 1 must be outgoing\n                        if u_orig == 1: # Original edge was (1, neighbor)\n                            ans_directions[idx_edge] = 0 # 1 -> neighbor\n                            balance[neighbor] += c_cap\n                            balance[1] -= c_cap\n                        else: # Original edge was (neighbor, 1)\n                            ans_directions[idx_edge] = 1 # 1 -> neighbor\n                            balance[neighbor] += c_cap\n                            balance[1] -= c_cap\n                    else: # v_node == n, Edge connected to sink n\n                        # All edges to n must be incoming\n                        if u_orig == n: # Original edge was (n, neighbor)\n                            ans_directions[idx_edge] = 1 # neighbor -> n\n                            balance[neighbor] -= c_cap\n                            balance[n] += c_cap\n                        else: # Original edge was (neighbor, n)\n                            ans_directions[idx_edge] = 0 # neighbor -> n\n                            balance[neighbor] -= c_cap\n                            balance[n] += c_cap\n                    \n                    current_degree[v_node] -= 1\n                    current_degree[neighbor] -= 1\n                    processed_edges.add(idx_edge)\n                    \n                    # If neighbor is an intermediate node and now has only one undirected edge, add to queue\n                    if 1 < neighbor < n and current_degree[neighbor] == 1:\n                        q.append(neighbor)\n        else: # Intermediate node\n            if current_degree[v_node] == 1:\n                q.append(v_node)\n\n    # Main loop: Process intermediate nodes to satisfy balance[u] = 0\n    while q:\n        u = q.popleft()\n\n        if u == 1 or u == n: # Source/Sink are not processed this way\n            continue\n        \n        # If current_degree[u] is not 1, it means this node was already processed\n        # or its degree changed since it was added to the queue\n        if current_degree[u] != 1: \n            continue\n\n        # Find the single remaining undirected edge for u\n        v_neighbor = -1\n        c_cap = -1\n        idx_edge = -1\n        \n        for neighbor, cap, edge_idx in adj[u]:\n            if ans_directions[edge_idx] == -1: # Found the undirected edge\n                v_neighbor, c_cap, idx_edge = neighbor, cap, edge_idx\n                break\n        \n        if idx_edge == -1: # Should not happen if current_degree[u] is truly 1\n            continue\n\n        u_orig, v_orig, _ = edges_info[idx_edge]\n\n        # Direct this edge to make balance[u] = 0\n        # If balance[u] is negative, u needs incoming flow\n        # If balance[u] is positive, u needs outgoing flow\n        \n        if u_orig == u: # u is the first vertex in edge_info (u_orig, v_orig)\n            if balance[u] < 0: # u needs incoming flow (v_neighbor -> u)\n                ans_directions[idx_edge] = 1 \n                balance[u] += c_cap\n                balance[v_neighbor] -= c_cap\n            else: # u needs outgoing flow (u -> v_neighbor)\n                ans_directions[idx_edge] = 0\n                balance[u] -= c_cap\n                balance[v_neighbor] += c_cap\n        else: # u is the second vertex in edge_info (u_orig, v_orig)\n            if balance[u] < 0: # u needs incoming flow (v_neighbor -> u)\n                ans_directions[idx_edge] = 0\n                balance[u] += c_cap\n                balance[v_neighbor] -= c_cap\n            else: # u needs outgoing flow (u -> v_neighbor)\n                ans_directions[idx_edge] = 1\n                balance[u] -= c_cap\n                balance[v_neighbor] += c_cap\n        \n        current_degree[u] -= 1 # This edge is now directed\n        current_degree[v_neighbor] -= 1\n\n        # If v_neighbor is an intermediate node and now has only one undirected edge, add to queue\n        if 1 < v_neighbor < n and current_degree[v_neighbor] == 1:\n            q.append(v_neighbor)\n\n    # Output the directions\n    for i in range(m):\n        sys.stdout.write(str(ans_directions[i]) + '\\n')\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 745,
        "completion_token_count": 6049,
        "thoughts_token_count": 7170
    }
}