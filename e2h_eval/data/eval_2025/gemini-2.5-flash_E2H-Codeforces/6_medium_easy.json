{
    "start": 1758011744.4175236,
    "end": 1758011828.6758285,
    "start-formatted": "2025-09-16 17:35 KST",
    "end-formatted": "2025-09-16 17:37 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "**Algorithm Design for Competitive Programming Problem**\n\nOkay, so I'm tackling this competitive programming problem. The goal is to find the cheapest pair of non-overlapping vouchers whose durations add up to `x`.  I've got `n` vouchers, each with a start time `li`, end time `ri`, and cost `costi`. The \"non-overlapping\" part is key – either one voucher must end before the other begins.  A naive, `O(n^2)` brute-force solution is out of the question, so I need something more efficient.\n\nHere's how my mind is working: I need an `O(n log n)` or `O(n)` solution. I'm thinking about sorting, sweep-line algorithms, and data structures to help me out.\n\nI start by considering what \"non-overlapping\" really means and what my constraints are. I'm focusing on the condition `ri < lj` or `rj < li` - one ends before the other starts.  It's clear that brute force will be too slow, so I start to imagine ways to optimize this.\n\nI start to think about what variables I can use for key data structures and if I can use any of them for sorting.\n\nLet's assume `ri < lj`. I need to find the minimum cost. For that, I need to know the duration for voucher `i`, then I can use `x` to get the duration of the other voucher (`j`).\n\nI consider sorting by start time `li`, by end time `ri`, or by duration. I eventually lean towards sorting by *start time* (`li`) so I can see vouchers with a starting bound.\n\nI realize a sweep-line approach might be useful. I'm envisioning iterating through \"time\" or, more precisely, possible start or end days.\n\nI start to group vouchers by duration. But, I quickly realize that I still need a way to efficiently check whether there is an overlapping day and that `ri < lj` is the best condition to use.\n\nThe next approach would be to have events at the voucher. Either a start event, or an end event. I'm trying to decide if there are any efficient lookups, or whether the sort is required for a more effective algorithm.\n\nI keep coming back to a need for a data structure for efficient lookups, especially for the \"min cost for a given duration that has ended.\" I'm mentally experimenting with segment trees, Fenwick trees, and dictionaries. I'm stuck trying to balance the storage of `min_cost_by_end_day[d][r]`, which would be `O(2*10^5 * 2 * 10^5)`, far too much.\n\nNow I am at a point to implement. Sorting the vouchers first. Then iterating, doing efficient lookups based on duration and end time for a given fixed voucher.\n",
    "response": "The problem asks us to find two distinct, non-overlapping vouchers `i` and `j` such that the sum of their durations `(ri - li + 1) + (rj - lj + 1)` is exactly `x`, and their total cost `costi + costj` is minimized. If no such pair exists, we should print -1.\n\nLet's denote the duration of a voucher `k` as `d_k = r_k - l_k + 1`.\nThe conditions are:\n1.  `i != j`\n2.  Non-overlapping: `r_i < l_j` or `r_j < l_i`.\n3.  Total duration: `d_i + d_j = x`.\n4.  Minimize `cost_i + cost_j`.\n\nWithout loss of generality, let's assume `r_i < l_j`. The other case `r_j < l_i` is symmetric. We can find the minimum for `r_i < l_j` and then consider the `r_j < l_i` case (which means we swap the roles of `i` and `j`).\n\nThe maximum coordinate for `l_k` and `r_k` is `MAX_COORD = 2 * 10^5`.\nThe maximum duration `d_k` is also `MAX_COORD`.\nThe total duration `x` is up to `2 * 10^5`.\n\nA brute-force `O(N^2)` approach is too slow for `N = 2 * 10^5`. We need a more efficient approach, likely `O(N log N)` or `O(N * MAX_COORD)`.\n\nLet's use a sweep-line approach. We can iterate through all possible days `current_day` from `1` to `MAX_COORD`.\nAt each `current_day`, we can consider two types of vouchers:\n1.  Vouchers that *end* on `current_day - 1`. These are candidates for voucher `i` (where `r_i = current_day - 1`).\n2.  Vouchers that *start* on `current_day`. These are candidates for voucher `j` (where `l_j = current_day`).\n\nTo efficiently query for the minimal cost, we need a data structure.\nLet `min_cost_ending_at_day[duration]` be an array (or a map/dictionary) where `min_cost_ending_at_day[d]` stores the minimum cost of a voucher with duration `d` that has *already ended* (i.e., its `r` value is less than `current_day`).\n\nThis approach needs to be refined. `min_cost_ending_at_day[d]` should store the minimum cost for any voucher of duration `d` that ends at or before the current sweep position.\n\nLet's use an array `min_cost_for_duration[d]` which will store the minimum cost found so far for a voucher of duration `d` that has *already ended*. We initialize all entries to infinity.\n\nWe can process vouchers grouped by their start day.\n1.  Create a list of all vouchers.\n2.  Sort the vouchers based on their start day `l_k`. If `l_k` are equal, sort by `r_k`.\n3.  Initialize `min_total_cost = infinity`.\n4.  Initialize `min_cost_for_duration = array of size (x+1)` with infinity. This array will store `min_cost_for_duration[d] = min(cost_k)` for all vouchers `k` encountered so far such that `r_k < l_current_voucher` and `d_k = d`.\n\nThe issue with the previous sweep-line idea is that `min_cost_for_duration[d]` needs to be updated with `min(cost)` for vouchers that *end* at `current_day - 1`, and then queried for vouchers that *start* at `current_day`. This suggests two passes or a more complex sweep-line.\n\nLet's use a single sweep-line over days `t` from `1` to `MAX_COORD`.\nWe need to group vouchers by their `l` and `r` values.\n`vouchers_starting_at[t]` will store `(r, cost, duration)` for vouchers starting at `t`.\n`vouchers_ending_at[t]` will store `(l, cost, duration)` for vouchers ending at `t`.\n\nInitialize `min_total_cost = infinity`.\nInitialize `min_cost_of_prev_voucher_by_duration[d] = infinity` for `d` from `1` to `x`. This array will store the minimum cost of a voucher with duration `d` that has ended *before* `current_day`.\n\nIterate `current_day` from `1` to `MAX_COORD`:\n1.  **Process vouchers starting at `current_day`**:\n    For each voucher `(r_j, cost_j, d_j)` in `vouchers_starting_at[current_day]`:\n    a.  Calculate the required duration for the first voucher: `d_i = x - d_j`.\n    b.  If `1 <= d_i < x`:\n        If `min_cost_of_prev_voucher_by_duration[d_i]` is not infinity, it means we found a voucher `i` that ended before `current_day` with duration `d_i`.\n        Update `min_total_cost = min(min_total_cost, cost_j + min_cost_of_prev_voucher_by_duration[d_i])`.\n\n2.  **Process vouchers ending at `current_day`**:\n    For each voucher `(l_i, cost_i, d_i)` in `vouchers_ending_at[current_day]`:\n    a.  Update `min_cost_of_prev_voucher_by_duration[d_i] = min(min_cost_of_prev_voucher_by_duration[d_i], cost_i)`.\n    This effectively stores the minimum cost for a voucher of duration `d_i` that ends *on or before* `current_day`. Since `min_cost_of_prev_voucher_by_duration` is only used for queries for vouchers starting *after* `current_day`, this ensures the `r_i < l_j` condition.\n\nAfter the loop, if `min_total_cost` is still infinity, it means no such pair was found. Otherwise, `min_total_cost` holds the answer.\n\n**Data Structures for Implementation:**\n*   `vouchers_starting_at`: A list of lists, `vouchers_starting_at[t]` stores `(r, cost, duration)` tuples. Max size `MAX_COORD + 1`.\n*   `vouchers_ending_at`: Similar, `vouchers_ending_at[t]` stores `(l, cost, duration)` tuples. Max size `MAX_COORD + 1`.\n*   `min_cost_of_prev_voucher_by_duration`: An array of size `x + 1`, initialized to a large value (infinity).\n\n**Complexity Analysis:**\n*   **Preprocessing (grouping vouchers)**: Iterate through `N` vouchers, calculate duration, and append to `vouchers_starting_at` and `vouchers_ending_at`. `O(N)`.\n*   **Sweep-line**: Loop `current_day` from `1` to `MAX_COORD`.\n    *   Inside the loop, for vouchers starting at `current_day`: Each voucher is processed once across the entire sweep. The inner calculations are `O(1)`. Total `O(N)`.\n    *   Inside the loop, for vouchers ending at `current_day`: Each voucher is processed once across the entire sweep. The inner calculations are `O(1)`. Total `O(N)`.\n*   **Space**: `vouchers_starting_at` and `vouchers_ending_at` store `N` vouchers total, distributed among `MAX_COORD` lists. `O(N + MAX_COORD)` space. `min_cost_of_prev_voucher_by_duration` takes `O(x)` space. Total `O(N + MAX_COORD + x)`.\n\nGiven `N, x, MAX_COORD <= 2 * 10^5`, this approach has a time complexity of `O(N + MAX_COORD)` and space complexity of `O(N + MAX_COORD + x)`, which is efficient enough.\n\n**Example Walkthrough (First Sample):**\n`n = 4, x = 5`\nVouchers:\n1. `(1, 3, 4)` -> `d=3`\n2. `(1, 2, 5)` -> `d=2`\n3. `(5, 6, 1)` -> `d=2`\n4. `(1, 2, 4)` -> `d=2`\n\n`MAX_COORD = 6` (max `r` is 6)\n`min_total_cost = infinity`\n`min_cost_of_prev_voucher_by_duration = [inf, inf, inf, inf, inf, inf]` (for durations 0 to 5)\n\n`vouchers_starting_at`:\n`1: [(3, 4, 3), (2, 5, 2), (2, 4, 2)]`\n`5: [(6, 1, 2)]`\nOthers empty.\n\n`vouchers_ending_at`:\n`2: [(1, 5, 2), (1, 4, 2)]`\n`3: [(1, 4, 3)]`\n`6: [(5, 1, 2)]`\nOthers empty.\n\nSweep:\n`current_day = 1`:\n  Starting at 1: `(3, 4, 3), (2, 5, 2), (2, 4, 2)`\n    - `(r=3, cost=4, d=3)`: `d_j=3`. `d_i = 5-3=2`. `min_cost_of_prev_voucher_by_duration[2]` is inf. No update.\n    - `(r=2, cost=5, d=2)`: `d_j=2`. `d_i = 5-2=3`. `min_cost_of_prev_voucher_by_duration[3]` is inf. No update.\n    - `(r=2, cost=4, d=2)`: `d_j=2`. `d_i = 5-2=3`. `min_cost_of_prev_voucher_by_duration[3]` is inf. No update.\n  Ending at 1: (empty)\n\n`current_day = 2`:\n  Starting at 2: (empty)\n  Ending at 2: `(1, 5, 2), (1, 4, 2)`\n    - `(l=1, cost=5, d=2)`: `min_cost_of_prev_voucher_by_duration[2] = min(inf, 5) = 5`.\n    - `(l=1, cost=4, d=2)`: `min_cost_of_prev_voucher_by_duration[2] = min(5, 4) = 4`.\n\n`current_day = 3`:\n  Starting at 3: (empty)\n  Ending at 3: `(1, 4, 3)`\n    - `(l=1, cost=4, d=3)`: `min_cost_of_prev_voucher_by_duration[3] = min(inf, 4) = 4`.\n\n`current_day = 4`:\n  Starting at 4: (empty)\n  Ending at 4: (empty)\n\n`current_day = 5`:\n  Starting at 5: `(6, 1, 2)`\n    - `(r=6, cost=1, d=2)`: `d_j=2`. `d_i = 5-2=3`.\n      `min_cost_of_prev_voucher_by_duration[3]` is 4.\n      `min_total_cost = min(inf, 1 + 4) = 5`.\n  Ending at 5: (empty)\n\n`current_day = 6`:\n  Starting at 6: (empty)\n  Ending at 6: `(5, 1, 2)`\n    - `(l=5, cost=1, d=2)`: `min_cost_of_prev_voucher_by_duration[2] = min(4, 1) = 1`.\n\nEnd sweep. `min_total_cost = 5`.\n\nFinal check: Voucher 1 `(1,3,4)` has `d=3`. Voucher 3 `(5,6,1)` has `d=2`.\n`r1=3`, `l3=5`. `r1 < l3` (3 < 5), so non-overlapping.\n`d1+d3 = 3+2 = 5 = x`.\n`cost1+cost3 = 4+1 = 5`. This matches.\n\n```python\nimport sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n\n    # Max coordinate can be 2 * 10^5, so arrays need to go up to this value.\n    # Using 200001 for 0-indexed arrays to cover up to 200000.\n    MAX_COORD = 200001 \n\n    # vouchers_starting_at[l] stores a list of (r, cost, duration) for vouchers starting on day l\n    vouchers_starting_at = [[] for _ in range(MAX_COORD)]\n    # vouchers_ending_at[r] stores a list of (l, cost, duration) for vouchers ending on day r\n    vouchers_ending_at = [[] for _ in range(MAX_COORD)]\n\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        duration = r - l + 1\n        \n        # Store vouchers. Note: max duration can be MAX_COORD, so x can be up to MAX_COORD.\n        # If duration >= x, it cannot be part of a pair summing to x with another positive duration.\n        # However, we still need to add it to the ending/starting lists as it might be 'i' or 'j'.\n        vouchers_starting_at[l].append((r, cost, duration))\n        vouchers_ending_at[r].append((l, cost, duration))\n\n    # Initialize min_total_cost to a very large value (infinity)\n    min_total_cost = float('inf')\n\n    # min_cost_of_prev_voucher_by_duration[d] stores the minimum cost of a voucher\n    # with duration 'd' that has finished by the current_day.\n    # Array size x+1 to cover durations from 1 to x.\n    min_cost_of_prev_voucher_by_duration = [float('inf')] * (x + 1)\n\n    # Sweep through all possible days\n    for current_day in range(1, MAX_COORD): # current_day can go up to MAX_COORD-1 for ending vouchers\n                                            # and MAX_COORD for starting vouchers.\n                                            # MAX_COORD is 2*10^5 + 1, so range up to 2*10^5.\n        # Phase 1: Process vouchers that start on current_day\n        # These are potential 'j' vouchers. We look for a previous 'i' voucher.\n        for r_j, cost_j, d_j in vouchers_starting_at[current_day]:\n            required_d_i = x - d_j\n            \n            # Check if required_d_i is a valid duration (positive and less than x)\n            if 1 <= required_d_i < x:\n                # If we have found a previous voucher 'i' with required_d_i duration\n                # that ended before current_day, update min_total_cost.\n                if min_cost_of_prev_voucher_by_duration[required_d_i] != float('inf'):\n                    min_total_cost = min(min_total_cost, cost_j + min_cost_of_prev_voucher_by_duration[required_d_i])\n\n        # Phase 2: Process vouchers that end on current_day\n        # These are potential 'i' vouchers. Update the min_cost_of_prev_voucher_by_duration array.\n        for l_i, cost_i, d_i in vouchers_ending_at[current_day]:\n            # Only consider vouchers whose duration is less than x,\n            # as the other voucher must also have a positive duration.\n            if d_i < x:\n                min_cost_of_prev_voucher_by_duration[d_i] = min(min_cost_of_prev_voucher_by_duration[d_i], cost_i)\n\n    if min_total_cost == float('inf'):\n        sys.stdout.write(\"-1\\n\")\n    else:\n        sys.stdout.write(str(min_total_cost) + \"\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n\n    # Max coordinate can be 2 * 10^5, so arrays need to go up to this value.\n    # Using 200001 for 0-indexed arrays to cover up to 200000.\n    MAX_COORD = 200001 \n\n    # vouchers_starting_at[l] stores a list of (r, cost, duration) for vouchers starting on day l\n    vouchers_starting_at = [[] for _ in range(MAX_COORD)]\n    # vouchers_ending_at[r] stores a list of (l, cost, duration) for vouchers ending on day r\n    vouchers_ending_at = [[] for _ in range(MAX_COORD)]\n\n    for _ in range(n):\n        l, r, cost = map(int, sys.stdin.readline().split())\n        duration = r - l + 1\n        \n        # Store vouchers. Note: max duration can be MAX_COORD, so x can be up to MAX_COORD.\n        # If duration >= x, it cannot be part of a pair summing to x with another positive duration.\n        # However, we still need to add it to the ending/starting lists as it might be 'i' or 'j'.\n        vouchers_starting_at[l].append((r, cost, duration))\n        vouchers_ending_at[r].append((l, cost, duration))\n\n    # Initialize min_total_cost to a very large value (infinity)\n    min_total_cost = float('inf')\n\n    # min_cost_of_prev_voucher_by_duration[d] stores the minimum cost of a voucher\n    # with duration 'd' that has finished by the current_day.\n    # Array size x+1 to cover durations from 1 to x.\n    min_cost_of_prev_voucher_by_duration = [float('inf')] * (x + 1)\n\n    # Sweep through all possible days\n    for current_day in range(1, MAX_COORD): # current_day can go up to MAX_COORD-1 for ending vouchers\n                                            # and MAX_COORD for starting vouchers.\n                                            # MAX_COORD is 2*10^5 + 1, so range up to 2*10^5.\n        # Phase 1: Process vouchers that start on current_day\n        # These are potential 'j' vouchers. We look for a previous 'i' voucher.\n        for r_j, cost_j, d_j in vouchers_starting_at[current_day]:\n            required_d_i = x - d_j\n            \n            # Check if required_d_i is a valid duration (positive and less than x)\n            if 1 <= required_d_i < x:\n                # If we have found a previous voucher 'i' with required_d_i duration\n                # that ended before current_day, update min_total_cost.\n                if min_cost_of_prev_voucher_by_duration[required_d_i] != float('inf'):\n                    min_total_cost = min(min_total_cost, cost_j + min_cost_of_prev_voucher_by_duration[required_d_i])\n\n        # Phase 2: Process vouchers that end on current_day\n        # These are potential 'i' vouchers. Update the min_cost_of_prev_voucher_by_duration array.\n        for l_i, cost_i, d_i in vouchers_ending_at[current_day]:\n            # Only consider vouchers whose duration is less than x,\n            # as the other voucher must also have a positive duration.\n            if d_i < x:\n                min_cost_of_prev_voucher_by_duration[d_i] = min(min_cost_of_prev_voucher_by_duration[d_i], cost_i)\n\n    if min_total_cost == float('inf'):\n        sys.stdout.write(\"-1\\n\")\n    else:\n        sys.stdout.write(str(min_total_cost) + \"\\n\")\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 798,
        "completion_token_count": 3993,
        "thoughts_token_count": 6603
    }
}