{
    "start": 1758294816.1055117,
    "end": 1758294898.4327822,
    "start-formatted": "2025-09-20 00:13 KST",
    "end-formatted": "2025-09-20 00:14 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "**Okay, let's break down this competitive programming problem and my thought process.**  The core challenge is finding the fewest edges to make an odd-length cycle in a graph, and then figuring out how many ways we can do it.  First, if the graph already has an odd cycle, the answer is simple: `t = 0` (no new edges needed), and there's only one way to achieve this. We can easily detect this by attempting a 2-coloring; a conflict means an odd cycle exists.\n\nIf the graph *is* bipartite, we have to add edges to force an odd cycle.  A bipartite graph splits into two color sets. The key insight here is that adding an edge within a color set creates an odd cycle.  So, if the graph is bipartite, we need to add exactly one edge (`t = 1`). The number of ways (`w`) to do this depends on how many vertices of the same color we have in each connected component, and we calculate this count as `(cnt0 * (cnt0 - 1) / 2) + (cnt1 * (cnt1 - 1) / 2)` and sum those for each component.\n\nThe tricky part comes when we can't create that odd cycle by adding just one edge within any component. That means our components are really simple (just single vertices, or edges themselves).  Then `t = 2`.  To form an odd cycle with two edges, you *must* connect three vertices where two are within the same connected component, and the third is in another connected component, or they are within different connected components. With two edges, it's about adding those connections across separate connected parts of the original graph to force a path which combines and forms an odd cycle, thus, the number of ways to pick different components.\n",
    "response": "The problem asks us to find the minimum number of edges `t` to add to a given undirected graph to form a simple cycle of odd length, and `w`, the number of ways to do so. A simple cycle is one where each vertex appears at most once. Loops and parallel edges are not allowed to be added.\n\nThe core concept is that a graph contains an odd cycle if and only if it is not bipartite. Our strategy will be to first check if the graph already contains an odd cycle. If not, we determine the minimum number of edges to add to make it non-bipartite, and count the ways.\n\n**Step 1: Check for existing odd cycles (t = 0)**\nWe can use a 2-coloring algorithm (like BFS or DFS) to check if the graph is bipartite. We iterate through all connected components. For each unvisited vertex, start a BFS/DFS. Assign it color 0. Its neighbors get color 1, their neighbors get color 0, and so on.\nIf, at any point, we try to assign a color to a vertex that already has a different color, or if we find an edge connecting two vertices of the same color, then the graph is not bipartite and contains an odd cycle.\nIn this case, `t = 0` and `w = 1` (there's only one way to add zero edges).\n\n**Step 2: If the graph is bipartite, calculate counts for t = 1**\nIf the graph is successfully 2-colored, it is bipartite. We need to add at least one edge.\nTo form an odd cycle by adding a single edge `(u, v)` to a bipartite graph, `u` and `v` must belong to the same partition set (i.e., have the same color). If we add such an edge, it will complete an odd cycle with any path between `u` and `v` in the original graph (which must have even length because `u` and `v` have the same color).\nFor each connected component `C_i` that was successfully 2-colored, let `N_{i,0}` be the number of vertices colored 0 and `N_{i,1}` be the number of vertices colored 1.\nThe number of ways to pick two distinct vertices of the same color within `C_i` is `(N_{i,0} * (N_{i,0} - 1) / 2) + (N_{i,1} * (N_{i,1} - 1) / 2)`.\nSince the graph is bipartite, no such pair `(u,v)` (where `u,v` have the same color) can already be an edge.\nLet `W_1` be the sum of these counts over all connected components.\nIf `W_1 > 0`, then `t = 1` and `w = W_1`.\n\n**Step 3: If t = 1 is not possible, calculate counts for t = 2**\nIf `W_1 = 0`, it means that for every connected component `C_i`, `N_{i,0} < 2` and `N_{i,1} < 2`. This implies that each connected component is either a single vertex (e.g., `N_{i,0}=1, N_{i,1}=0`) or a single edge (e.g., `N_{i,0}=1, N_{i,1}=1`). In this scenario, we cannot form an odd cycle by adding just one edge within any component.\nWe must add at least two edges. The minimum will be `t = 2`.\nTo form an odd cycle with two added edges, we can connect three distinct vertices `u, v, x` such that `u` and `v` are in the same connected component `C_i`, `u` and `v` have different colors, and `x` is in a different connected component `C_j` (`j != i`). We then add edges `(u, x)` and `(v, x)`.\nThe cycle formed is `u - ... - v - (v, x) - x - (x, u) - u`.\nThe path `u - ... - v` (in `C_i`) has odd length because `u` and `v` have different colors.\nThe total cycle length is `(odd_path_length) + 1 + 1 = odd + 2 = odd`.\nThis strategy works. We need to count the number of ways to pick such `u, v, x`.\n\nLet `k` be the number of connected components.\nLet `V_i` be the set of vertices in component `C_i`.\nLet `N_v = n` be the total number of vertices.\n\nThe number of ways `w` to choose `u, v, x` as described:\n1. Choose a component `C_i`.\n2. Choose `u \\in C_i` and `v \\in C_i` such that `u` and `v` have different colors. The number of such pairs is `N_{i,0} * N_{i,1}`.\n3. Choose `x` from any other component `C_j` where `j \\ne i`. The number of choices for `x` is `N_v - |V_i|`.\n4. We must ensure that `(u,x)` and `(v,x)` are not existing edges. In a bipartite graph where components are single vertices or single edges, this condition is always met if `x` is in a different component.\n   - If `C_i` is a single vertex, `N_{i,0} * N_{i,1} = 0`, so no `u,v` pair.\n   - If `C_i` is a single edge `(u,v)`, then `N_{i,0}=1, N_{i,1}=1`. There is `1 * 1 = 1` way to pick `u,v` (the endpoints of the edge).\n   So, for each component `C_i` that is a single edge, it contributes `1 * (N_v - 2)` ways.\n   Sum this over all components that are single edges. Let this be `W_2`.\n\nThis `W_2` counts ordered triplets `(u,v,x)`. The edges added are `(u,x)` and `(v,x)`.\nThe set of added edges is `{ (u,x), (v,x) }`.\nIf we pick `(u,v)` as the edge in `C_i`, and `x` from `C_j`, we add `(u,x)` and `(v,x)`.\nIf we pick `(v,u)` as the edge in `C_i`, and `x` from `C_j`, we add `(v,x)` and `(u,x)`. This gives the same set of edges.\nSo `W_2` is the correct number of ways.\nIf `W_2 > 0`, then `t = 2` and `w = W_2`.\n\n**Step 4: If t = 2 is not possible, calculate counts for t = 3**\nIf `W_2 = 0`, it means there are no components that are single edges. All components must be single vertices.\nIn this case, we need to add three edges to form an odd cycle. The simplest odd cycle is a triangle.\nWe need to pick three distinct vertices `u, v, x` and add edges `(u,v)`, `(v,x)`, `(x,u)`.\nSince all components are single vertices, no edges exist in the graph. So any choice of three distinct vertices will work.\nThe number of ways to choose 3 distinct vertices from `n` vertices is `n * (n-1) * (n-2) / 6`.\nIf `n < 3`, we cannot form a triangle, so `t` would be impossible. However, the problem statement implies `n` is large enough.\nIf `n >= 3`, then `t = 3` and `w = n * (n-1) * (n-2) / 6`.\n\n**Implementation details:**\n- Use an adjacency list for the graph.\n- Use a `color` array initialized to -1 (unvisited).\n- Use a `visited` array or modify `color` to indicate visited.\n- Maintain `is_bipartite` flag.\n- During BFS/DFS, if `is_bipartite` becomes false, break and return `t=0, w=1`.\n- If a component is bipartite, store its `N_{i,0}` and `N_{i,1}` counts.\n- Sum `N_{i,0} * (N_{i,0} - 1) / 2 + N_{i,1} * (N_{i,1} - 1) / 2` for `W_1`.\n- Count components that are single edges for `W_2`. A component `C_i` is a single edge if `|V_i|=2`.\n  In our 2-coloring, if a component has `N_{i,0}=1` and `N_{i,1}=1`, it's a single edge.\n  The number of vertices in such a component is 2. `N_v - |V_i| = N_v - 2`.\n  So `W_2` is the count of components with `N_{i,0}=1, N_{i,1}=1` multiplied by `(N_v - 2)`.\n\nLet's refine the `W_2` calculation.\n`W_2` is the number of ways to pick two distinct vertices `u, v` from the same component `C_i` such that `u` and `v` have different colors, AND pick a third vertex `x` from a *different* component `C_j`.\nThe condition `W_1 = 0` implies that for every component `C_i`, `N_{i,0} \\le 1` and `N_{i,1} \\le 1`.\nThis means `C_i` can only be:\n  - A single vertex: `(N_{i,0}=1, N_{i,1}=0)` or `(N_{i,0}=0, N_{i,1}=1)`. In this case, `N_{i,0} * N_{i,1} = 0`.\n  - A single edge: `(N_{i,0}=1, N_{i,1}=1)`. In this case, `N_{i,0} * N_{i,1} = 1`.\nSo, `W_2` is the sum, over all components `C_i` that are single edges, of `1 * (N_v - |V_i|)`.\nSince `|V_i|=2` for a single edge component, this is `1 * (N_v - 2)`.\nSo, `W_2 = (count of single-edge components) * (N_v - 2)`.\nThis is correct.\n\n**Final check on `t=3`:**\nIf `W_2 = 0`, it means there are no components that are single edges. All components are single vertices.\nThis means `m=0` (no edges initially).\nSo `t=3` and `w = n * (n-1) * (n-2) / 6`. This is the number of ways to choose 3 vertices and add 3 edges to form a triangle.\n\n**Edge cases:**\n- `n < 3`:\n  - If `n=1` or `n=2`: A cycle of length > 1 is impossible. The problem says \"consisting of more than one vertex\". Smallest odd cycle is 3 vertices. So if `n < 3`, `t=3` is impossible.\n  However, the problem constraints `1 <= a_i, b_i <= n` and `n, m` up to `2 * 10^5`. So `n` can be `1` or `2`.\n  If `n=1` or `n=2`, no odd cycle can be formed. The problem statement implies a solution always exists.\n  Let's assume `n >= 3` for `t=3` to be possible. If `n < 3`, then `t=3` is impossible. The problem states \"form a simple cycle of an odd length, consisting of more than one vertex\". The smallest such cycle has length 3. So if `n < 3`, this is impossible.\n  A competitive programming problem usually implies that a solution always exists for valid inputs.\n  Let's consider the problem constraints: `n, m <= 2 * 10^5`.\n  If `n=1`, `t=3` is not possible.\n  If `n=2`, `t=3` is not possible.\n  Let's assume the problem implicitly means `n >= 3` when `t=3` is the answer. Or, if `n < 3` and `t=3` is the theoretical answer, the problem setter might be okay with `0` ways.\n  Example 3: `3 0`. Output: `3 1`. `n=3, m=0`. All vertices are single components. `W_1=0, W_2=0`. So `t=3`. `w = 3 * 2 * 1 / 6 = 1`. This matches. So `n * (n-1) * (n-2) / 6` is the correct formula.\n\n```python\nimport sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    adj = [[] for _ in range(n + 1)]\n    edges_set = set() # To quickly check if an edge exists\n\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n        edges_set.add(tuple(sorted((u, v))))\n\n    colors = [-1] * (n + 1) # -1: unvisited, 0: color 0, 1: color 1\n    visited_component = [False] * (n + 1) # To track if a vertex has been part of a processed component\n\n    is_graph_bipartite = True\n    \n    # Store counts for t=1 and t=2 calculations\n    w1_count = 0\n    single_edge_components_count = 0 \n\n    for i in range(1, n + 1):\n        if colors[i] == -1: # If vertex i is unvisited, start a new BFS for a component\n            q = deque()\n            q.append(i)\n            colors[i] = 0\n            \n            current_component_nodes = []\n            component_color_counts = [0, 0] # [count_color_0, count_color_1]\n            \n            component_bipartite = True\n\n            # BFS for current component\n            head = 0\n            q_list = [i] # Use a list as a queue for easier iteration later if needed\n            while head < len(q_list):\n                u = q_list[head]\n                head += 1\n                current_component_nodes.append(u)\n                component_color_counts[colors[u]] += 1\n\n                for v in adj[u]:\n                    if colors[v] == -1:\n                        colors[v] = 1 - colors[u]\n                        q_list.append(v)\n                    elif colors[v] == colors[u]:\n                        # Found an odd cycle in the original graph\n                        is_graph_bipartite = False\n                        component_bipartite = False\n                        break # Break from inner for loop\n                if not component_bipartite:\n                    break # Break from inner while loop\n            \n            if not component_bipartite:\n                # If any component is not bipartite, the whole graph is not bipartite\n                # t=0, w=1\n                print(0, 1)\n                return\n            \n            # If the component is bipartite, contribute to t=1 and t=2 counts\n            # For t=1: ways to add an edge within this component to form an odd cycle\n            w1_count += (component_color_counts[0] * (component_color_counts[0] - 1) // 2)\n            w1_count += (component_color_counts[1] * (component_color_counts[1] - 1) // 2)\n\n            # For t=2: check if this component is a single edge\n            if component_color_counts[0] == 1 and component_color_counts[1] == 1:\n                single_edge_components_count += 1\n            \n    # If we reached here, the entire graph is bipartite\n    \n    # Case t=1:\n    if w1_count > 0:\n        print(1, w1_count)\n        return\n\n    # Case t=2:\n    # This implies all components are either single vertices or single edges.\n    # Since w1_count is 0, no component has N_0 >= 2 or N_1 >= 2.\n    # So, components are (1,0), (0,1), or (1,1) (single vertex or single edge).\n    # We need to find two vertices u,v in same component with different colors, and x in another component.\n    # This means C_i must be a single edge (N_0=1, N_1=1).\n    # Number of ways = (number of single-edge components) * (n - 2)\n    \n    # If n < 2, there cannot be a single edge component.\n    # If n=0 or n=1: single_edge_components_count will be 0.\n    # If n=2 and m=1 (1-2 edge): single_edge_components_count = 1. w2_count = 1 * (2-2) = 0.\n    # So (n-2) applies only if n >= 2.\n    \n    w2_count = 0\n    if n >= 2: # Need at least 2 vertices for a single edge component\n        # Each single edge component (u-v) contributes 1 way to pick (u,v) (different colors)\n        # And (n-2) ways to pick x from other components.\n        w2_count = single_edge_components_count * (n - 2)\n    \n    if w2_count > 0:\n        print(2, w2_count)\n        return\n\n    # Case t=3:\n    # If we reached here, all components are single vertices. (m=0)\n    # We need to add 3 edges to form a triangle.\n    # This is possible if n >= 3.\n    # Number of ways to choose 3 vertices from n: nC3 = n * (n-1) * (n-2) / 6\n    if n < 3:\n        # If n < 3, it's impossible to form a cycle of length 3 or more.\n        # The problem guarantees a solution. This implies n >= 3 when we reach this case.\n        # For example, if n=2, m=0, w1_count=0, w2_count=0. Then t=3 is theoretically the answer\n        # but w=0. Example 3 (3 0 -> 3 1) suggests n >= 3 for this case.\n        # So we can assume n >= 3 here.\n        pass # This case won't be reached with n<3 if a solution is guaranteed.\n    \n    w3_count = n * (n - 1) * (n - 2) // 6\n    print(3, w3_count)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    adj = [[] for _ in range(n + 1)]\n    edges_set = set() # To quickly check if an edge exists\n\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n        edges_set.add(tuple(sorted((u, v))))\n\n    colors = [-1] * (n + 1) # -1: unvisited, 0: color 0, 1: color 1\n    visited_component = [False] * (n + 1) # To track if a vertex has been part of a processed component\n\n    is_graph_bipartite = True\n    \n    # Store counts for t=1 and t=2 calculations\n    w1_count = 0\n    single_edge_components_count = 0 \n\n    for i in range(1, n + 1):\n        if colors[i] == -1: # If vertex i is unvisited, start a new BFS for a component\n            q = deque()\n            q.append(i)\n            colors[i] = 0\n            \n            current_component_nodes = []\n            component_color_counts = [0, 0] # [count_color_0, count_color_1]\n            \n            component_bipartite = True\n\n            # BFS for current component\n            head = 0\n            q_list = [i] # Use a list as a queue for easier iteration later if needed\n            while head < len(q_list):\n                u = q_list[head]\n                head += 1\n                current_component_nodes.append(u)\n                component_color_counts[colors[u]] += 1\n\n                for v in adj[u]:\n                    if colors[v] == -1:\n                        colors[v] = 1 - colors[u]\n                        q_list.append(v)\n                    elif colors[v] == colors[u]:\n                        # Found an odd cycle in the original graph\n                        is_graph_bipartite = False\n                        component_bipartite = False\n                        break # Break from inner for loop\n                if not component_bipartite:\n                    break # Break from inner while loop\n            \n            if not component_bipartite:\n                # If any component is not bipartite, the whole graph is not bipartite\n                # t=0, w=1\n                print(0, 1)\n                return\n            \n            # If the component is bipartite, contribute to t=1 and t=2 counts\n            # For t=1: ways to add an edge within this component to form an odd cycle\n            w1_count += (component_color_counts[0] * (component_color_counts[0] - 1) // 2)\n            w1_count += (component_color_counts[1] * (component_color_counts[1] - 1) // 2)\n\n            # For t=2: check if this component is a single edge\n            if component_color_counts[0] == 1 and component_color_counts[1] == 1:\n                single_edge_components_count += 1\n            \n    # If we reached here, the entire graph is bipartite\n    \n    # Case t=1:\n    if w1_count > 0:\n        print(1, w1_count)\n        return\n\n    # Case t=2:\n    # This implies all components are either single vertices or single edges.\n    # Since w1_count is 0, no component has N_0 >= 2 or N_1 >= 2.\n    # So, components are (1,0), (0,1), or (1,1) (single vertex or single edge).\n    # We need to find two vertices u,v in same component with different colors, and x in another component.\n    # This means C_i must be a single edge (N_0=1, N_1=1).\n    # Number of ways = (number of single-edge components) * (n - 2)\n    \n    # If n < 2, there cannot be a single edge component.\n    # If n=0 or n=1: single_edge_components_count will be 0.\n    # If n=2 and m=1 (1-2 edge): single_edge_components_count = 1. w2_count = 1 * (2-2) = 0.\n    # So (n-2) applies only if n >= 2.\n    \n    w2_count = 0\n    if n >= 2: # Need at least 2 vertices for a single edge component\n        # Each single edge component (u-v) contributes 1 way to pick (u,v) (different colors)\n        # And (n-2) ways to pick x from other components.\n        w2_count = single_edge_components_count * (n - 2)\n    \n    if w2_count > 0:\n        print(2, w2_count)\n        return\n\n    # Case t=3:\n    # If we reached here, all components are single vertices. (m=0)\n    # We need to add 3 edges to form a triangle.\n    # This is possible if n >= 3.\n    # Number of ways to choose 3 vertices from n: nC3 = n * (n-1) * (n-2) / 6\n    if n < 3:\n        # If n < 3, it's impossible to form a cycle of length 3 or more.\n        # The problem guarantees a solution. This implies n >= 3 when we reach this case.\n        # For example, if n=2, m=0, w1_count=0, w2_count=0. Then t=3 is theoretically the answer\n        # but w=0. Example 3 (3 0 -> 3 1) suggests n >= 3 for this case.\n        # So we can assume n >= 3 here.\n        pass # This case won't be reached with n<3 if a solution is guaranteed.\n    \n    w3_count = n * (n - 1) * (n - 2) // 6\n    print(3, w3_count)\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 594,
        "completion_token_count": 4542,
        "thoughts_token_count": 6148
    }
}