{
    "start": 1758294734.525005,
    "end": 1758294816.1048713,
    "start-formatted": "2025-09-20 00:12 KST",
    "end-formatted": "2025-09-20 00:13 KST",
    "gpu": 2,
    "pid": 57,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Olympiad\n\nA boy named Vasya has taken part in an Olympiad. His teacher knows that in total Vasya got at least x points for both tours of the Olympiad. The teacher has the results of the first and the second tour of the Olympiad but the problem is, the results have only points, no names. The teacher has to know Vasya's chances.Help Vasya's teacher, find two numbers — the best and the worst place Vasya could have won. Note that the total results' table sorts the participants by the sum of points for both tours (the first place has the participant who has got the most points). If two or more participants have got the same number of points, it's up to the jury to assign places to them according to their choice. It is guaranteed that each participant of the Olympiad participated in both tours of the Olympiad.\n\n## Input\nThe first line contains two space-separated integers n, x (1 ≤ n ≤ 105; 0 ≤ x ≤ 2·105) — the number of Olympiad participants and the minimum number of points Vasya earned.The second line contains n space-separated integers: a1, a2, ..., an (0 ≤ ai ≤ 105) — the participants' points in the first tour.The third line contains n space-separated integers: b1, b2, ..., bn (0 ≤ bi ≤ 105) — the participants' points in the second tour.The participants' points are given in the arbitrary order. It is guaranteed that Vasya was present in the Olympiad — there are two integers i, j (1 ≤ i, j ≤ n) such, that ai + bj ≥ x.\n\n## Output\nPrint two space-separated integers — the best and the worst place Vasya could have got on the Olympiad.\n\n## Example\n### Input\n['5 2\\n1 1 1 1 1\\n1 1 1 1 1', '6 7\\n4 3 5 6 4 4\\n8 6 0 4 3 4']\n\n### Output\n['1 5', '1 5']\n\n## Note\nIn the first text sample all 5 participants earn 2 points each in any case. Depending on the jury's decision, Vasya can get the first (the best) as well as the last (the worst) fifth place.In the second test sample in the best case scenario Vasya wins again: he can win 12 points and become the absolute winner if the total results' table looks like that — {4:8, 6:4, 3:6, 4:4, 4:3, 5:0}.In this table all participants are sorted by decreasing points and we can see how much a participant earned in the first and in the second tour.In the worst case scenario Vasya can get the fifth place if the table looks like that — {4:8, 4:6, 6:4, 5:4, 4:3, 3:0}, and he earned 4 and 3 points in the first and second tours, correspondingly.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "**Analyzing Vasya's Olympiad Chances**\n\nAlright, let's break this down. The challenge here is to figure out the best and worst possible ranks Vasya could achieve, given his minimum total score, the total number of participants, and everyone's scores from two rounds. The twist? We don't know who scored what in each round, only the total scores.\n\nMy initial thought is to tackle this by figuring out how to construct the most and least advantageous scenarios for Vasya, considering the jury's ability to arbitrarily assign places in the event of ties. The core is the pairing of scores from the two rounds, and the fact that we can match any score from round one with any score from round two. This means we have to consider *all* possible score pairings.\n\nFor the best-case scenario (best possible rank, meaning smallest number, so likely 1), it seems like we need to make sure Vasya gets the highest possible score, which means matching the highest score from the first round with the highest score from the second. The problem statement guarantees he could achieve at least a certain score, so this highest score is a possible match. Because the jury can break ties, we can always place Vasya in rank 1 if he gets the highest possible score.\n\nNow for the tricky part: the worst-case scenario. This means making Vasya's rank as high as possible. Here, we want to give him the lowest possible score that still meets the minimum requirement, and then arrange the remaining scores to maximize the number of other participants who score as high as possible or higher. This essentially means minimizing Vasya's score and strategically pairing the remaining scores to make him look comparatively worse.\n\nWe're going to approach this by fixing Vasya's score, minimizing it while still meeting the minimum point requirement, and then use a greedy algorithm to pair the other scores to maximize the number of participants who score better. This means that if Vasya's score, which we minimized at the first round, gets the same score on the total rank, the remaining people scoring higher can be maximized (so the best place with same ranks as Vasya is minimized)\n\nUltimately, we have two key strategies: one to maximize Vasya's score and ensure his place, and a second to minimize his score and then minimize his rank via the optimal rearrangement of other participants' scores.\n",
    "response": "The problem asks us to find the best and worst possible ranks Vasya could achieve in an Olympiad, given the scores from two tours for `n` participants and a minimum total score `x` that Vasya achieved. The key challenge is that we don't know which specific scores belong to Vasya, nor how the scores from the first tour (`A`) are paired with scores from the second tour (`B`) for any participant. We must consider all possible valid pairings.\n\n**1. Best Place for Vasya:**\n\nTo achieve the best possible rank (i.e., the smallest rank number, ideally 1st), Vasya needs to maximize his total score. The maximum possible total score any participant can achieve is `max(A) + max(B)`.\nThe problem guarantees that \"there are two integers i, j (1 <= i, j <= n) such, that ai + bj >= x\". This implies that the sum `max(A) + max(B)` must also be greater than or equal to `x` (since `max(A) + max(B)` is the largest possible sum).\nTherefore, we can always assume that Vasya is the participant who achieved `max(A) + max(B)` points. No other participant can score higher than this.\nIf other participants also achieve `max(A) + max(B)` points (e.g., if all `a_i` and `b_j` are the same), the problem states that \"If two or more participants have got the same number of points, it's up to the jury to assign places to them according to their choice.\" In this scenario, the jury can choose to assign Vasya the 1st place.\nThus, Vasya's best possible place is always **1**.\n\n**2. Worst Place for Vasya:**\n\nTo achieve the worst possible rank (i.e., the largest rank number), we need to:\na. Choose a pair of scores `(a_i, b_j)` for Vasya such that `a_i + b_j >= x`, and this sum is as small as possible. Let this minimum possible score be `S_target`.\nb. Arrange the remaining `n-1` scores from `A` and `B` for the other `n-1` participants such that as many of them as possible score *at least* `S_target` points.\nc. Vasya's rank will then be `1 + (number of participants who scored strictly more than S_target) + (number of participants who scored S_target and are ranked before Vasya)`. Due to the jury's decision for ties, to maximize Vasya's rank, we assume all participants who score `S_target` are ranked before him, except for himself. So, if `k` participants (including Vasya) score `S_target` or more, Vasya can be ranked `k`-th.\n\nLet's break down the steps for finding the worst place:\n\n**Step 1: Find `S_target` (Vasya's minimum possible score >= x)**\nSort both arrays `A` and `B` in ascending order.\nIterate through each `a_i` in sorted `A`. For each `a_i`, we want to find the smallest `b_j` in sorted `B` such that `a_i + b_j >= x`. This is equivalent to `b_j >= x - a_i`. We can find such `b_j` efficiently using binary search (`bisect_left`) on `B`.\n`S_target` will be the minimum of all `a_i + b_j` found this way.\nInitialize `S_target = infinity`.\nFor `a_val` in `A`:\n  `required_b = x - a_val`\n  Find `idx = bisect_left(B, required_b)`\n  If `idx < n` (meaning a suitable `b_j` exists):\n    `S_target = min(S_target, a_val + B[idx])`\nThis `S_target` is the lowest score Vasya could possibly get while still satisfying the `x` points condition.\n\n**Step 2: Maximize the count of participants scoring at least `S_target`**\nNow, we need to find the maximum number of pairs `(a_k, b_l)` that can be formed from all available scores (all `n` `a`'s and all `n` `b`'s) such that `a_k + b_l >= S_target`. This is a classic greedy matching problem.\nSort `A` and `B` in ascending order.\nUse two pointers: `ptr_a` starting at `0` (smallest `a`) and `ptr_b` starting at `n-1` (largest `b`).\nInitialize `count = 0`.\nWhile `ptr_a < n` and `ptr_b >= 0`:\n  If `A[ptr_a] + B[ptr_b] >= S_target`:\n    This pair `(A[ptr_a], B[ptr_b])` contributes to a score of at least `S_target`. We use these scores.\n    `count++`\n    `ptr_a++`\n    `ptr_b--`\n  Else (`A[ptr_a] + B[ptr_b] < S_target`):\n    The current `A[ptr_a]` is too small to reach `S_target` even with the largest available `B[ptr_b]`. Therefore, `A[ptr_a]` cannot form a pair that sums to `S_target` with any of the remaining `B` scores. To maximize the count, we should pair `A[ptr_a]` with some `B` score that will result in a sum less than `S_target`, and move on to a larger `A` score.\n    `ptr_a++`\nThe `count` obtained here represents the maximum number of participants who can achieve a score of at least `S_target`. Vasya is one of these participants. To make his rank as bad as possible, we assume he is ranked last among these `count` participants.\nTherefore, Vasya's worst possible place is `count`.\n\n**Example Walkthrough (Second Example):**\n`n=6, x=7`\n`A = [4, 3, 5, 6, 4, 4]` -> Sorted `A = [3, 4, 4, 4, 5, 6]`\n`B = [8, 6, 0, 4, 3, 4]` -> Sorted `B = [0, 3, 4, 4, 6, 8]`\n\n**Best Place:** 1 (as per logic above).\n\n**Worst Place:**\n**Step 1: Find `S_target`**\nInitialize `S_target = infinity`.\n- For `a_val = 3` (from `A`): `required_b = 7 - 3 = 4`. `bisect_left(B, 4)` returns index 2 (`B[2]=4`). `3 + 4 = 7`. `S_target = min(inf, 7) = 7`.\n- For `a_val = 4` (from `A`): `required_b = 7 - 4 = 3`. `bisect_left(B, 3)` returns index 1 (`B[1]=3`). `4 + 3 = 7`. `S_target = min(7, 7) = 7`.\n- (Other values of `a_val` will result in sums >= 7, but `S_target` will remain 7).\nSo, `S_target = 7`.\n\n**Step 2: Maximize count of participants scoring at least `S_target=7`**\n`A = [3, 4, 4, 4, 5, 6]`\n`B = [0, 3, 4, 4, 6, 8]`\n`ptr_a = 0`, `ptr_b = 5`, `count = 0`.\n1. `A[0]+B[5] = 3+8 = 11`. `11 >= 7`. `count = 1`. `ptr_a = 1`, `ptr_b = 4`.\n2. `A[1]+B[4] = 4+6 = 10`. `10 >= 7`. `count = 2`. `ptr_a = 2`, `ptr_b = 3`.\n3. `A[2]+B[3] = 4+4 = 8`. `8 >= 7`. `count = 3`. `ptr_a = 3`, `ptr_b = 2`.\n4. `A[3]+B[2] = 4+4 = 8`. `8 >= 7`. `count = 4`. `ptr_a = 4`, `ptr_b = 1`.\n5. `A[4]+B[1] = 5+3 = 8`. `8 >= 7`. `count = 5`. `ptr_a = 5`, `ptr_b = 0`.\n6. `A[5]+B[0] = 6+0 = 6`. `6 < 7`. `ptr_a = 6`.\nLoop ends because `ptr_a = 6` (which is `n`).\nThe maximum count of participants scoring at least `S_target=7` is `5`.\nSo, Vasya's worst place is **5**.\n\nOutput: `1 5`. This matches the example output.\n\n**Complexity:**\n- Sorting `A` and `B`: `O(N log N)`\n- Finding `S_target`: `N` iterations, each with `bisect_left` on `B` (size `N`). Total `O(N log N)`.\n- Finding `count`: `N` iterations with two pointers. Total `O(N)`.\nOverall time complexity: `O(N log N)`.\nSpace complexity: `O(N)` for storing `A` and `B`.\nGiven `N <= 10^5`, `N log N` is efficient enough.\n\n```python\nimport sys\nimport bisect\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    # Best place is always 1st\n    # Vasya can always choose the highest score from A and highest from B.\n    # The problem guarantees that some a_i + b_j >= x.\n    # Thus, max(A) + max(B) must also be >= x.\n    # If Vasya gets max(A) + max(B) points, no one can score higher.\n    # With jury's discretion for ties, Vasya can be assigned 1st place.\n    best_place = 1\n\n    # Worst place calculation\n    # Step 1: Find S_target, the minimum score Vasya could get while still satisfying >= x points.\n    a.sort()\n    b.sort()\n\n    s_target = float('inf')\n    for val_a in a:\n        # We need b_j such that val_a + b_j >= x => b_j >= x - val_a\n        required_b = x - val_a\n        \n        # Find the smallest b_j in sorted B that is >= required_b\n        idx = bisect.bisect_left(b, required_b)\n        \n        if idx < n:\n            # If such a b_j exists, consider this sum as a candidate for S_target\n            s_target = min(s_target, val_a + b[idx])\n\n    # Step 2: Maximize the number of participants who score at least S_target.\n    # This will be Vasya's worst rank (if he's last among those who meet the criteria).\n    \n    # Use two pointers to find the maximum number of pairs (a_i, b_j)\n    # such that a_i + b_j >= s_target, using each score at most once.\n    \n    ptr_a = 0\n    ptr_b = n - 1\n    count_above_or_equal = 0\n\n    while ptr_a < n and ptr_b >= 0:\n        if a[ptr_a] + b[ptr_b] >= s_target:\n            # This pair meets the target. Count it and use both elements.\n            count_above_or_equal += 1\n            ptr_a += 1\n            ptr_b -= 1\n        else:\n            # a[ptr_a] is too small to reach s_target even with the largest available b[ptr_b].\n            # So, a[ptr_a] cannot form a pair >= s_target with any remaining b.\n            # Move to the next largest a[ptr_a].\n            ptr_a += 1\n            \n    worst_place = count_above_or_equal\n\n    sys.stdout.write(f\"{best_place} {worst_place}\\n\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nimport bisect\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    # Best place is always 1st\n    # Vasya can always choose the highest score from A and highest from B.\n    # The problem guarantees that some a_i + b_j >= x.\n    # Thus, max(A) + max(B) must also be >= x.\n    # If Vasya gets max(A) + max(B) points, no one can score higher.\n    # With jury's discretion for ties, Vasya can be assigned 1st place.\n    best_place = 1\n\n    # Worst place calculation\n    # Step 1: Find S_target, the minimum score Vasya could get while still satisfying >= x points.\n    a.sort()\n    b.sort()\n\n    s_target = float('inf')\n    for val_a in a:\n        # We need b_j such that val_a + b_j >= x => b_j >= x - val_a\n        required_b = x - val_a\n        \n        # Find the smallest b_j in sorted B that is >= required_b\n        idx = bisect.bisect_left(b, required_b)\n        \n        if idx < n:\n            # If such a b_j exists, consider this sum as a candidate for S_target\n            s_target = min(s_target, val_a + b[idx])\n\n    # Step 2: Maximize the number of participants who score at least S_target.\n    # This will be Vasya's worst rank (if he's last among those who meet the criteria).\n    \n    # Use two pointers to find the maximum number of pairs (a_i, b_j)\n    # such that a_i + b_j >= s_target, using each score at most once.\n    \n    ptr_a = 0\n    ptr_b = n - 1\n    count_above_or_equal = 0\n\n    while ptr_a < n and ptr_b >= 0:\n        if a[ptr_a] + b[ptr_b] >= s_target:\n            # This pair meets the target. Count it and use both elements.\n            count_above_or_equal += 1\n            ptr_a += 1\n            ptr_b -= 1\n        else:\n            # a[ptr_a] is too small to reach s_target even with the largest available b[ptr_b].\n            # So, a[ptr_a] cannot form a pair >= s_target with any remaining b.\n            # Move to the next largest a[ptr_a].\n            ptr_a += 1\n            \n    worst_place = count_above_or_equal\n\n    sys.stdout.write(f\"{best_place} {worst_place}\\n\")\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 863,
        "completion_token_count": 2992,
        "thoughts_token_count": 8190
    }
}