{
    "start": 1758011930.044303,
    "end": 1758012004.2820494,
    "start-formatted": "2025-09-16 17:38 KST",
    "end-formatted": "2025-09-16 17:40 KST",
    "gpu": 2,
    "pid": 8,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "**Tackling the \"Flawed Flow\" Problem**\n\nAlright, let's dive into this \"Flawed Flow\" problem. My goal is to determine the direction of flow on each edge of an undirected graph, ensuring the result is a Directed Acyclic Graph (DAG) and that flow is conserved at all intermediate nodes. We're given the graph's structure with `n` vertices and `m` edges, along with the flow volume for each edge. Vertices 1 and `n` are the source and sink, respectively.\n\nKey constraints: flow must be conserved at all vertices except for the source and sink; the source has no incoming edges; and the resulting directed graph must be acyclic.  The guarantee that a solution exists is a huge help here.\n\nThe \"no cycles\" condition is the trickiest. It screams \"topological sort!\"  Since vertex 1 has no incoming edges, it *must* be the first in at least one topological ordering. This tells me that all edges connected to vertex 1 have to be outgoing, which gives me a starting point. Let's call the `degree` of a node the sum of the capacities of its incident edges.\n\nI'm thinking about flow balance.  I'll maintain a `current_balance` for each vertex, tracking the difference between incoming and outgoing flow. Initially, it's zero for all vertices except the source.  Edges leaving the source get fixed directions, and I update the `current_balance` accordingly.\n\nThe plan is to use a queue-based approach for topological ordering.  I'll start with the source (vertex 1), fix its outgoing edges and update balance for its neighbors. Then, for any other node, if it becomes unbalanced (more incoming than outgoing flow), it *must* send out flow to satisfy conservation and make its `current_balance` equal to zero.  \n\nThe main loop's logic works like this:\n\n1.  I start with edges leaving vertex 1. Set the direction and update flow balances.\n2.  I maintain a queue of unbalanced nodes.\n3.  While the queue isn't empty:\n    *   Dequeue a node and push its excess flow to unprocessed neighbors. This step is where I fix an edge's direction so that all flow is eventually pushed to its destination and flow conservation holds.\n    *   If a neighboring node becomes unbalanced, I add it to the queue.\n\nThis will implicitly build a DAG. The greedy choice of pushing from an unbalanced node ensures the absence of cycles because we are always \"moving forward\" towards the sink.\n\nThe time and space complexity look pretty good for this problem and the expected size of the input. I can probably implement this with an adjacency list, some arrays to keep track of balances and edge processing, and a queue for managing the topology. I'll need to be careful with indexing the original edges and mapping the directions correctly.\n",
    "response": "The problem asks us to determine the direction of flow for each edge in an undirected graph, given the flow volume through it. We are given `n` vertices and `m` edges, with vertices 1 and `n` being the source and sink, respectively. The solution must satisfy three conditions:\n1.  **Flow Conservation:** For any intermediate vertex `v` (1 < `v` < `n`), the sum of flow on incoming edges must equal the sum of flow on outgoing edges.\n2.  **Source Constraint:** Vertex 1 (the source) must have no incoming edges. This implies all edges incident to vertex 1 must be directed away from it.\n3.  **Acyclicity:** The resulting directed graph must not contain any cycles (i.e., it must be a Directed Acyclic Graph, DAG).\n\nThe problem guarantees that a solution always exists, and the graph is connected.\n\nThis problem can be solved using a greedy approach based on maintaining flow balances and a queue, similar to a topological sort. The \"no cycles\" condition is implicitly handled by always pushing flow forward from nodes that have a surplus.\n\n**Algorithm:**\n\n1.  **Initialization:**\n    *   Store the input edges along with their original index. For each edge `i` connecting `a_i` and `b_i` with flow `c_i`, we'll store `(a_i, b_i, c_i)` in an `input_edges` list.\n    *   Create an adjacency list `adj`. For each vertex `u`, `adj[u]` will store tuples `(v, c, edge_idx, u_is_first_in_input_pair)`. `u_is_first_in_input_pair` is a boolean indicating if `u` was `a_i` in the original `(a_i, b_i)` pair for `edge_idx`. This helps in correctly setting the output direction.\n    *   Initialize `current_balance[v] = 0` for all vertices `v`. This array will track `sum(incoming_flow) - sum(outgoing_flow)` based on edges whose directions have been decided.\n    *   Initialize `result_directions[edge_idx] = -1` for all edges. This will store `0` for `a_i -> b_i` and `1` for `b_i -> a_i`.\n    *   Initialize `edges_processed[edge_idx] = False` for all edges.\n    *   Create a queue `Q` and a set `in_queue` to keep track of vertices that need to distribute flow and are already in the queue.\n\n2.  **Process Source (Vertex 1):**\n    *   Iterate through all edges `(1, v)` incident to vertex 1.\n    *   According to condition 2, all such edges must be directed `1 -> v`.\n    *   For each edge `(1, v)` with flow `c` and index `edge_idx`:\n        *   Set `result_directions[edge_idx]` to `0` (if `1` was `a_i`) or `1` (if `1` was `b_i`).\n        *   Mark `edges_processed[edge_idx] = True`.\n        *   Add `c` to `current_balance[v]` (as flow enters `v`).\n        *   If `v` is an intermediate vertex (1 < `v` < `n`) and `current_balance[v]` becomes positive, add `v` to `Q` and `in_queue` if not already present.\n    *   `current_balance[1]` will become negative, which is expected as it's the source.\n\n3.  **Process Intermediate Vertices (1 < `v` < `n`):**\n    *   While `Q` is not empty:\n        *   Dequeue a vertex `u` from `Q` and remove it from `in_queue`.\n        *   Let `flow_to_distribute = current_balance[u]`. This is the surplus flow `u` has received and needs to send out.\n        *   Reset `current_balance[u] = 0`. (We assume `u` will distribute all its `flow_to_distribute` through its remaining undirected edges).\n        *   Iterate through all unprocessed edges `(u, v)` incident to `u` (with flow `c`, index `edge_idx`, and `u_is_first_in_input_pair` flag):\n            *   If `flow_to_distribute` is `0`, `u` has already distributed all its surplus, so we can stop processing its edges.\n            *   Direct the edge `u -> v`.\n            *   Set `result_directions[edge_idx]` to `0` (if `u_is_first_in_input_pair` is `True`, meaning `u` was `a_i`) or `1` (if `u_is_first_in_input_pair` is `False`, meaning `u` was `b_i`).\n            *   Mark `edges_processed[edge_idx] = True`.\n            *   Add `c` to `current_balance[v]` (flow enters `v`).\n            *   Subtract `c` from `flow_to_distribute`.\n            *   If `v` is an intermediate vertex (1 < `v` < `n`) and `current_balance[v]` becomes positive, add `v` to `Q` and `in_queue` if not already present.\n        *   The problem guarantee ensures that `flow_to_distribute` will always become `0` after processing enough edges.\n\n4.  **Output:**\n    *   Print the values in `result_directions` for each edge.\n\n**Example Walkthrough (First Sample):**\n`n=3, m=3`\nEdges:\n0: (3, 2, 10)\n1: (1, 2, 10)\n2: (3, 1, 5)\n\n`input_edges = [(3,2,10), (1,2,10), (3,1,5)]`\n\n`adj` construction:\n`adj[1] = [(2, 10, 1, True), (3, 5, 2, False)]`\n`adj[2] = [(3, 10, 0, False), (1, 10, 1, False)]`\n`adj[3] = [(2, 10, 0, True), (1, 5, 2, True)]`\n\n`current_balance = [0,0,0,0]`\n`result_directions = [-1,-1,-1]`\n`edges_processed = [F,F,F]`\n`Q = deque()`, `in_queue = set()`\n\n**Step 2: Process Source (Vertex 1)**\n*   Edge `(1, 2)` (flow 10, index 1, `1_is_first_in_input_pair=True`):\n    *   `result_directions[1] = 0` (1 -> 2).\n    *   `edges_processed[1] = True`.\n    *   `current_balance[2] += 10`. (`current_balance = [0,0,10,0]`)\n    *   `v=2` is intermediate. `current_balance[2] > 0`. Add `2` to `Q` and `in_queue`. `Q=[2]`, `in_queue={2}`.\n*   Edge `(3, 1)` (flow 5, index 2, `1_is_first_in_input_pair=False`):\n    *   `result_directions[2] = 1` (1 -> 3).\n    *   `edges_processed[2] = True`.\n    *   `current_balance[3] += 5`. (`current_balance = [0,0,10,5]`)\n    *   `v=3` is the sink, so no action for `Q`.\n\n**Step 3: Process Intermediate Vertices**\n*   `Q=[2]`. Dequeue `u=2`. Remove `2` from `in_queue`.\n    *   `flow_to_distribute = current_balance[2] = 10`.\n    *   `current_balance[2] = 0`.\n    *   Iterate `adj[2]`:\n        *   Edge `(3, 2)` (flow 10, index 0, `2_is_first_in_input_pair=False`):\n            *   `edges_processed[0]` is `False`. `flow_to_distribute=10 > 0`.\n            *   Direct `2 -> 3`.\n            *   `result_directions[0] = 1` (since `2` is `b_i`, `b_i -> a_i` is `2 -> 3`).\n            *   `edges_processed[0] = True`.\n            *   `current_balance[3] += 10`. (`current_balance = [0,0,0,15]`)\n            *   `v=3` is the sink.\n            *   `flow_to_distribute -= 10`. (`flow_to_distribute = 0`).\n        *   Edge `(1, 2)` (flow 10, index 1, `2_is_first_in_input_pair=False`):\n            *   `edges_processed[1]` is `True`. Skip.\n\n*   `Q` is empty. Loop terminates.\n\n**Final `result_directions`:** `[1, 0, 1]` (matches example output).\n\n**Complexity:**\n*   Time: `O(N+M)` because each vertex is enqueued/dequeued at most once, and each edge is processed at most once.\n*   Space: `O(N+M)` for adjacency lists, balance array, and other data structures.\n\n```python\nimport sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    # Store edges with original index to map results correctly\n    # input_edges[i] = (u, v, c)\n    input_edges = []\n    \n    # Adjacency list: adj[u] stores (v, c, edge_idx, u_is_first_in_input_pair)\n    # u_is_first_in_input_pair is True if u was a_i in the input (a_i, b_i, c_i)\n    adj = [[] for _ in range(n + 1)]\n\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        input_edges.append((u, v, c))\n        adj[u].append((v, c, i, True))  # u is a_i\n        adj[v].append((u, c, i, False)) # v is b_i\n\n    # current_balance[v] = sum(flow_in) - sum(flow_out) for decided edges\n    current_balance = [0] * (n + 1)\n    \n    # result_directions[i] = 0 if flow is input_edges[i][0] -> input_edges[i][1]\n    # result_directions[i] = 1 if flow is input_edges[i][1] -> input_edges[i][0]\n    result_directions = [-1] * m\n    \n    # Keep track of processed edges\n    edges_processed = [False] * m\n\n    # Queue for vertices with positive balance that need to push flow out\n    q = deque()\n    in_queue = set() # To avoid adding same vertex multiple times\n\n    # --- Step 2: Process Source (Vertex 1) ---\n    # All edges incident to vertex 1 must be outgoing.\n    # We iterate through a copy of adj[1] because we might modify adj[1] indirectly\n    # if we processed an edge from the other end. But here, we only process adj[1]\n    # so direct iteration is fine.\n    for v, c, edge_idx, u_is_first_in_input_pair in adj[1]:\n        if edges_processed[edge_idx]:\n            continue\n\n        # Direction must be 1 -> v\n        if u_is_first_in_input_pair: # 1 was a_i, so 1 -> v means a_i -> b_i\n            result_directions[edge_idx] = 0\n        else: # 1 was b_i, so 1 -> v means b_i -> a_i\n            result_directions[edge_idx] = 1\n        \n        edges_processed[edge_idx] = True\n        current_balance[v] += c\n\n        # If v is an intermediate node and has a surplus, add to queue\n        if 1 < v < n and current_balance[v] > 0 and v not in in_queue:\n            q.append(v)\n            in_queue.add(v)\n\n    # --- Step 3: Process Intermediate Vertices ---\n    while q:\n        u = q.popleft()\n        in_queue.remove(u)\n\n        flow_to_distribute = current_balance[u]\n        current_balance[u] = 0 # Reset balance as u is about to distribute all its surplus\n\n        # Iterate through neighbors of u to push out flow\n        # We need to iterate through a copy because elements might be removed conceptually\n        # from adj[u] (by marking edges_processed)\n        for v, c, edge_idx, u_is_first_in_input_pair in list(adj[u]):\n            if edges_processed[edge_idx]:\n                continue\n            \n            if flow_to_distribute == 0:\n                break # All surplus flow has been distributed\n\n            # Direct u -> v\n            if u_is_first_in_input_pair: # u was a_i, so u -> v means a_i -> b_i\n                result_directions[edge_idx] = 0\n            else: # u was b_i, so u -> v means b_i -> a_i\n                result_directions[edge_idx] = 1\n            \n            edges_processed[edge_idx] = True\n            current_balance[v] += c\n            flow_to_distribute -= c\n\n            # If v is an intermediate node and now has a surplus, add to queue\n            if 1 < v < n and current_balance[v] > 0 and v not in in_queue:\n                q.append(v)\n                in_queue.add(v)\n    \n    # --- Step 4: Output results ---\n    for i in range(m):\n        sys.stdout.write(str(result_directions[i]) + '\\n')\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    # Store edges with original index to map results correctly\n    # input_edges[i] = (u, v, c)\n    input_edges = []\n    \n    # Adjacency list: adj[u] stores (v, c, edge_idx, u_is_first_in_input_pair)\n    # u_is_first_in_input_pair is True if u was a_i in the input (a_i, b_i, c_i)\n    adj = [[] for _ in range(n + 1)]\n\n    for i in range(m):\n        u, v, c = map(int, sys.stdin.readline().split())\n        input_edges.append((u, v, c))\n        adj[u].append((v, c, i, True))  # u is a_i\n        adj[v].append((u, c, i, False)) # v is b_i\n\n    # current_balance[v] = sum(flow_in) - sum(flow_out) for decided edges\n    current_balance = [0] * (n + 1)\n    \n    # result_directions[i] = 0 if flow is input_edges[i][0] -> input_edges[i][1]\n    # result_directions[i] = 1 if flow is input_edges[i][1] -> input_edges[i][0]\n    result_directions = [-1] * m\n    \n    # Keep track of processed edges\n    edges_processed = [False] * m\n\n    # Queue for vertices with positive balance that need to push flow out\n    q = deque()\n    in_queue = set() # To avoid adding same vertex multiple times\n\n    # --- Step 2: Process Source (Vertex 1) ---\n    # All edges incident to vertex 1 must be outgoing.\n    # We iterate through a copy of adj[1] because we might modify adj[1] indirectly\n    # if we processed an edge from the other end. But here, we only process adj[1]\n    # so direct iteration is fine.\n    for v, c, edge_idx, u_is_first_in_input_pair in adj[1]:\n        if edges_processed[edge_idx]:\n            continue\n\n        # Direction must be 1 -> v\n        if u_is_first_in_input_pair: # 1 was a_i, so 1 -> v means a_i -> b_i\n            result_directions[edge_idx] = 0\n        else: # 1 was b_i, so 1 -> v means b_i -> a_i\n            result_directions[edge_idx] = 1\n        \n        edges_processed[edge_idx] = True\n        current_balance[v] += c\n\n        # If v is an intermediate node and has a surplus, add to queue\n        if 1 < v < n and current_balance[v] > 0 and v not in in_queue:\n            q.append(v)\n            in_queue.add(v)\n\n    # --- Step 3: Process Intermediate Vertices ---\n    while q:\n        u = q.popleft()\n        in_queue.remove(u)\n\n        flow_to_distribute = current_balance[u]\n        current_balance[u] = 0 # Reset balance as u is about to distribute all its surplus\n\n        # Iterate through neighbors of u to push out flow\n        # We need to iterate through a copy because elements might be removed conceptually\n        # from adj[u] (by marking edges_processed)\n        for v, c, edge_idx, u_is_first_in_input_pair in list(adj[u]):\n            if edges_processed[edge_idx]:\n                continue\n            \n            if flow_to_distribute == 0:\n                break # All surplus flow has been distributed\n\n            # Direct u -> v\n            if u_is_first_in_input_pair: # u was a_i, so u -> v means a_i -> b_i\n                result_directions[edge_idx] = 0\n            else: # u was b_i, so u -> v means b_i -> a_i\n                result_directions[edge_idx] = 1\n            \n            edges_processed[edge_idx] = True\n            current_balance[v] += c\n            flow_to_distribute -= c\n\n            # If v is an intermediate node and now has a surplus, add to queue\n            if 1 < v < n and current_balance[v] > 0 and v not in in_queue:\n                q.append(v)\n                in_queue.add(v)\n    \n    # --- Step 4: Output results ---\n    for i in range(m):\n        sys.stdout.write(str(result_directions[i]) + '\\n')\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 746,
        "completion_token_count": 3417,
        "thoughts_token_count": 6189
    }
}