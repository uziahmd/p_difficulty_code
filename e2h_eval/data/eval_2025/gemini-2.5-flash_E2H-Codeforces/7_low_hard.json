{
    "start": 1758009324.7501538,
    "end": 1758009389.1035278,
    "start-formatted": "2025-09-16 16:55 KST",
    "end-formatted": "2025-09-16 16:56 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "**Breaking Down the Snowflake Problem**\n\nOkay, so I'm tackling this \"Rudolf and Snowflakes\" problem. The core of it is figuring out if a given number of vertices, `n`, can form a snowflake structure.  This snowflake builds outwards from a central vertex. First, we connect the center to `k` other vertices. Then, we can repeatedly connect each of those \"outer\" vertices to *another* `k` new ones. This latter step has to happen at least once.\n\nMy initial thought is to analyze the structure and work out a vertex count. Let's call the number of times we perform the \"outward connection\" step `d`.  Since it *has* to happen, `d` has to be greater than or equal to 1.\n\nSo here's the breakdown I've got in mind:\n\n*   **Stage 0:** Just the center, so 1 vertex.\n*   **Stage 1:** We've done that initial connection to `k` vertices. Total is now `1 + k`.\n*   **Stage 2:**  We do the `d=1` \"outward\" step. Those `k` vertices from Stage 1 each sprout `k` more vertices, giving us `k * k = k^2` new ones. The total is now `1 + k + k^2`.\n*   **Stage 3:** If we perform the outward step a *second* time (`d=2`), each of those `k^2` new vertices from Stage 2 spawns another `k` vertices, giving us `k^3`.  The total vertex count becomes `1 + k + k^2 + k^3`.\n\nThis pattern clearly forms a geometric series.  If we perform that outward step `d` times, the total number of vertices `N` will be:  `1 + k + k^2 + ... + k^(d+1)`.  That sums to `(k^(d+2) - 1) / (k - 1)`.\n\nNow I need to remember the constraints:  `k` has to be greater than 1, `d` has to be at least 1, and the total vertex count `n` can go up to 10^18. So, the key is to determine if I can express `n` as `1 + k + k^2 + ... + k^m` for some valid `k` (greater than 1) and `m` (greater than or equal to 2, since `m = d + 1` and `d` is at least 1).\n\nI think I'll start by looking at small values of `m`. Let's say `m = 2`. Then `n = 1 + k + k^2`.  I can rearrange this into a quadratic equation in `k`: `k^2 + k + (1 - n) = 0`.  Using the quadratic formula, I get `k = (-1 +/- sqrt(4n - 3)) / 2`.  For `k` to be an integer, `4n - 3` must be a perfect square. This feels like a good starting point for testing. I think if I can find a perfect square there, I've got a snowflake!\n\n",
    "response": "The problem asks us to determine if a given number of vertices `n` can form a snowflake. A snowflake is constructed as follows:\n1. Start with 1 central vertex.\n2. Connect the central vertex to `k` new vertices, where `k > 1`.\n3. Each vertex connected to only one other vertex (a leaf) is connected to `k` more new vertices. This step must be performed at least once.\n\nLet's count the vertices:\n- Initially: 1 vertex (the center).\n- After step 2: `1 + k` vertices. The `k` new vertices are leaves.\n- After step 3 (first time): Each of the `k` leaves from the previous stage gets `k` new vertices. So, `k * k = k^2` new vertices are added. Total: `1 + k + k^2` vertices. These `k^2` new vertices are now leaves.\n- After step 3 (second time): Each of the `k^2` leaves from the previous stage gets `k` new vertices. So, `k^2 * k = k^3` new vertices are added. Total: `1 + k + k^2 + k^3` vertices.\n\nIf step 3 is performed `d` times, the total number of vertices `n` will be the sum of a geometric series:\n`n = 1 + k + k^2 + ... + k^(d+1)`\n\nSince step 3 must be performed at least once, `d >= 1`. This implies that the highest power of `k` in the sum, `d+1`, must be at least `2`. Let `m = d+1`. Then `m >= 2`.\nThe sum can be written as `n = (k^(m+1) - 1) / (k - 1)`.\n\nWe need to check if for a given `n`, there exist integers `k > 1` and `m >= 2` satisfying this equation.\n\nThere are two main cases to consider:\n\n**Case 1: `m = 2`**\nIn this case, `n = 1 + k + k^2`.\nRearranging, we get `k^2 + k + (1 - n) = 0`.\nThis is a quadratic equation for `k`. Using the quadratic formula:\n`k = (-1 +/- sqrt(1 - 4 * (1 - n))) / 2`\n`k = (-1 +/- sqrt(1 - 4 + 4n)) / 2`\n`k = (-1 +/- sqrt(4n - 3)) / 2`\n\nFor `k` to be a valid integer greater than 1:\n1. `4n - 3` must be a perfect square. Let `S = sqrt(4n - 3)`.\n2. `(-1 + S)` must be an even positive number. This means `S` must be odd and `S > 1`.\n   If `S` is odd, `S-1` is even.\n   If `S > 1`, then `k = (S-1)/2 > 0`.\n   Since `n >= 1`, `4n - 3 >= 1`, so `S >= 1`.\n   If `S = 1`, then `4n - 3 = 1 => 4n = 4 => n = 1`. In this case, `k = (1-1)/2 = 0`, which is not `k > 1`. So `n=1` is not a snowflake.\n   For `n > 1`, `4n - 3 > 1`, so `S > 1`.\n   Thus, if `4n - 3` is a perfect square `S^2` where `S` is odd and `S > 1`, then `k = (S-1)/2` will be an integer greater than 1, and `n` is a snowflake.\n\n**Case 2: `m > 2`**\nIn this case, `n = 1 + k + k^2 + ... + k^m`.\nSince `k > 1`, we know `k^m < n`. This implies `k < n^(1/m)`.\nAlso, `n > k^m`.\nSince `m >= 3` (as `m > 2`), `k < n^(1/3)`.\nGiven `n <= 10^18`, `k < (10^18)^(1/3) = 10^6`.\nThis means `k` can be at most `10^6 - 1`.\nWe can iterate through possible values of `k` from `2` up to `10^6`. For each `k`:\nWe need to find if there is an `m >= 3` such that `n = (k^(m+1) - 1) / (k - 1)`.\nRearranging, `n * (k - 1) + 1 = k^(m+1)`.\nLet `target = n * (k - 1) + 1`. We need to check if `target` is a perfect power of `k`, specifically `k^(m+1)` for some `m+1 >= 3`.\nWe can find `m+1` by taking `log_k(target)`. Or, we can compute powers of `k`: `k^2, k^3, k^4, ...` until the power exceeds `target` or equals `target`.\nSince `target` can be up to `10^18 * 10^6 = 10^24`, and `k >= 2`, `m+1` can be at most `log_2(10^24) approx 24 * log_2(10) approx 24 * 3.32 approx 79.6`. So `m+1` is small.\n\nThe maximum value of `k` to check is `10^6`. For each `k`, we compute `target = n * (k - 1) + 1`.\nThen, we can use binary search to find `x` such that `k^x = target`. This `x` would be `m+1`.\nThe binary search range for `x` would be `[3, 60]` (since `2^60 > 10^18` and `k^x = target` where `target` can be up to `n*(k-1)+1`, for `n=10^18, k=2`, `target` is `10^18+1`, so `m+1` up to 60).\nIf `k^x == target` for some `x >= 3`, then `n` is a snowflake.\n\n**Combined strategy:**\n1. Handle `n=1,2,3` explicitly (they are not snowflakes).\n2. Check Case 1: Calculate `S = sqrt(4n - 3)`. If `S` is an integer, `S > 1`, and `S` is odd, then `n` is a snowflake.\n3. If not, check Case 2: Iterate `k` from `2` up to `10^6`. For each `k`:\n   Calculate `target = n * (k - 1) + 1`.\n   Use binary search to find `x` in range `[3, 60]` such that `k^x == target`.\n   In Python, `pow(k, x)` is efficient.\n   If such `x` is found, `n` is a snowflake.\n4. If neither case yields a snowflake, output \"NO\".\n\n**Optimization for Case 2:**\nInstead of `k` up to `10^6`, we can observe that `k < n^(1/3)` for `m=3`, `k < n^(1/4)` for `m=4`, etc.\nThe maximum `m` is about 60 (for `k=2`).\nWe can iterate `m` from `3` up to `60`. For each `m`:\nWe need to find `k` such that `n = (k^(m+1) - 1) / (k - 1)`.\nThis equation is monotonically increasing with `k`. We can use binary search for `k`.\nThe range for `k` is `[2, n^(1/m)]`.\nFor example, if `m=3`, `k` is up to `n^(1/3)`. If `n=10^18`, `k` is up to `10^6`.\nIf `m=60`, `k` is up to `n^(1/60)`. If `n=10^18`, `k` is up to `(10^18)^(1/60) = (10^3)^(1/10) approx 2`.\nThe upper bound for `k` in binary search can be `2 * 10^9` (roughly `n` itself, but practically `n^(1/2)` is enough since `k^2 < n`). A safe upper bound for `k` can be `min(2 * 10^9, int(n**(1/m)) + 2)`.\nA simple upper bound for `k` can be `2*10^9` (for `n=10^18`, `k` can't be larger than `sqrt(n)` for `m=2`, or `n^(1/3)` for `m=3`). `10^9` is a safe upper bound for `k` to ensure `k^2` doesn't overflow `long long` in C++ or `n` in Python. `k` can be up to `10^9` if `n` is `10^18` and `m=1` (but `m>=2`). Since `m>=2`, `k^2 < n`, so `k < sqrt(n)`. Thus `k < sqrt(10^18) = 10^9`.\n\n**Revised strategy (preferred for efficiency):**\n1. Handle `n=1,2,3,4,5,6` explicitly:\n   `n=1,2,3,4,5,6` are all \"NO\". (Example `k=2, m=2` gives `1+2+4=7`).\n   This covers small `n` where `4n-3` might be small.\n2. Check Case 1: `n = 1 + k + k^2`.\n   Calculate `val = 4n - 3`.\n   Calculate `S = isqrt(val)`. (integer square root)\n   If `S * S == val` and `S > 1` and `S % 2 == 1` (meaning `S` is odd), then `k = (S - 1) / 2` is an integer `> 1`. Output \"YES\".\n3. Check Case 2: `n = 1 + k + ... + k^m` for `m >= 3`.\n   Iterate `m` from `3` up to `60` (since `2^60 > 10^18`).\n   For each `m`, we need to find `k` such that `n = (k^(m+1) - 1) / (k - 1)`.\n   We can use binary search for `k`.\n   Lower bound for `k`: `low = 2`.\n   Upper bound for `k`: `high = int(n**(1.0/m)) + 2`. A safer upper bound is `2 * 10^9` or `10^9` which is `sqrt(10^18)`. Let's use `2 * 10^9` for safety.\n   Inside binary search:\n     `mid = (low + high) // 2`.\n     Calculate `current_sum = 1 + mid + mid^2 + ... + mid^m`.\n     This sum can be computed by `(pow(mid, m + 1) - 1) // (mid - 1)`.\n     Be careful with `mid - 1 = 0` if `mid = 1`, but `k > 1` so `mid >= 2`.\n     If `current_sum == n`, output \"YES\" and break.\n     If `current_sum < n`, then `k` is too small, so `low = mid + 1`.\n     If `current_sum > n`, then `k` is too large, so `high = mid - 1`.\n   The loop for `m` should continue only if `n` hasn't been found.\n\nExample for binary search bounds:\nIf `n = 10^18` and `m = 3`: `k` can be up to `(10^18)^(1/3) = 10^6`.\nIf `n = 10^18` and `m = 59`: `k` can be up to `(10^18)^(1/59) approx 2.07`. So `k` can only be `2`.\nThe `high` bound `int(n**(1.0/m)) + 2` is generally good. For `m=3`, it's `10^6+2`. For `m=59`, it's `2+2=4`. This is much tighter than `2*10^9`.\n\nFinal check on edge cases and constraints:\n- `n=1`: `4*1-3=1`, `S=1`. `S` is not `>1`. \"NO\". Correct.\n- `n=2`: `4*2-3=5`. Not square. \"NO\". Correct.\n- `n=3`: `4*3-3=9`, `S=3`. `S>1`, `S` is odd. `k=(3-1)/2=1`. Not `k>1`. \"NO\". Correct.\n- `n=6`: `4*6-3=21`. Not square. \"NO\". Correct.\n- `n=13`: `4*13-3=49`, `S=7`. `S>1`, `S` is odd. `k=(7-1)/2=3`. `k=3` is valid. So `n=13` is `1+3+3^2`. \"YES\". Correct.\n- `n=15`: `4*15-3=57`. Not square.\n  Check `m >= 3`:\n  `m=3`: `n=1+k+k^2+k^3`. `k` up to `15^(1/3) approx 2.46`. So `k=2`.\n  `1+2+2^2+2^3 = 1+2+4+8 = 15`. Yes, `k=2, m=3`. \"YES\". Correct.\n- `n=255`: `4*255-3=1017`. Not square.\n  Check `m >= 3`:\n  `m=3`: `k` up to `255^(1/3) approx 6.34`.\n    `k=2`: `1+2+4+8 = 15 != 255`.\n    `k=3`: `1+3+9+27 = 40 != 255`.\n    `k=4`: `1+4+16+64 = 85 != 255`.\n    `k=5`: `1+5+25+125 = 156 != 255`.\n    `k=6`: `1+6+36+216 = 259 > 255`. So no `k` for `m=3`.\n  `m=4`: `k` up to `255^(1/4) approx 3.98`.\n    `k=2`: `1+2+4+8+16 = 31 != 255`.\n    `k=3`: `1+3+9+27+81 = 121 != 255`.\n  `m=5`: `k` up to `255^(1/5) approx 3.03`.\n    `k=2`: `1+2+4+8+16+32 = 63 != 255`.\n    `k=3`: `1+3+9+27+81+243 = 364 > 255`.\n  `m=6`: `k` up to `255^(1/6) approx 2.5`.\n    `k=2`: `1+2+4+8+16+32+64 = 127 != 255`.\n  `m=7`: `k` up to `255^(1/7) approx 2.2`.\n    `k=2`: `1+2+4+8+16+32+64+128 = 255`. Yes, `k=2, m=7`. \"YES\". Correct.\n\nThe maximum `m` for `k=2` is `m=59` for `n=2^60-1`.\nThe binary search for `k` for each `m` is efficient.\nNumber of test cases `t = 10^4`.\nFor each test case:\n- `isqrt` is `O(log N)`.\n- Loop `m` from `3` to `60` (approx 58 iterations).\n- Inside loop, binary search for `k` takes `log(sqrt(N))` iterations (approx `log(10^9) = 30` iterations).\n- Each iteration calculates `pow(mid, m+1)` which is `O(log(m+1))`.\nTotal complexity: `O(log N + M_max * log(K_max) * log(M_max))`.\n`log(10^18) + 60 * log(10^9) * log(60) approx 60 + 60 * 30 * 6 = 10860`. This is very fast.\n\n```python\nimport math\n\n# Function to calculate integer square root\ndef isqrt(n):\n    if n < 0:\n        raise ValueError(\"isqrt() argument must be non-negative\")\n    if n == 0:\n        return 0\n    x = int(math.sqrt(n))\n    # Adjust if x*x is slightly off due to floating point precision\n    if x * x > n:\n        x -= 1\n    while (x + 1) * (x + 1) <= n:\n        x += 1\n    return x\n\n# Function to check if n can be represented as 1 + k + k^2 + ... + k^m\ndef solve():\n    n = int(input())\n\n    # Small values of n that cannot be snowflakes\n    # For n=1,2,3,4,5,6, the answer is NO.\n    # The smallest snowflake is 1+2+2^2 = 7 (k=2, m=2)\n    # The next smallest is 1+3+3^2 = 13 (k=3, m=2)\n    # The next smallest is 1+2+2^2+2^3 = 15 (k=2, m=3)\n    if n < 7:\n        print(\"NO\")\n        return\n\n    # Case 1: m = 2 (n = 1 + k + k^2)\n    # k^2 + k + (1 - n) = 0\n    # Discriminant D = 1 - 4 * (1 - n) = 4n - 3\n    # k = (-1 + sqrt(D)) / 2\n    val = 4 * n - 3\n    s_val = isqrt(val)\n    if s_val * s_val == val:  # Check if 4n-3 is a perfect square\n        if s_val > 1 and (s_val - 1) % 2 == 0: # Check if s_val is odd and > 1\n            k = (s_val - 1) // 2\n            if k > 1: # k must be > 1\n                print(\"YES\")\n                return\n\n    # Case 2: m >= 3 (n = 1 + k + k^2 + ... + k^m)\n    # Iterate m from 3 up to a reasonable maximum.\n    # For k=2, m=59, sum is 2^60 - 1 which is > 10^18. So m up to 59 is enough.\n    for m in range(3, 60):\n        # Binary search for k\n        # Lower bound for k is 2\n        # Upper bound for k: k^m < n => k < n^(1/m).\n        # A safe upper bound for k can be n^(1/m) + a small constant.\n        # For n=10^18, m=3, k_max approx 10^6.\n        # For n=10^18, m=59, k_max approx 2.\n        # A simple upper bound that works for all m: 2 * 10**9 (since k < sqrt(n) for m>=2)\n        low = 2\n        high = int(n**(1.0/m)) + 2 # Tighter upper bound\n        if high > 2 * 10**9: # Cap it if n is very large and m is small\n            high = 2 * 10**9\n\n        found_k = False\n        while low <= high:\n            k_val = (low + high) // 2\n            if k_val < 2: # Ensure k > 1\n                k_val = 2\n                low = 2\n                continue\n            \n            # Calculate sum 1 + k_val + ... + k_val^m\n            # Sum = (k_val^(m+1) - 1) / (k_val - 1)\n            # Check for potential overflow before computing pow(k_val, m+1)\n            # If k_val^(m+1) would exceed n*(k_val-1)+1, then it's too large.\n            # A rough check: if k_val^m > n, then sum will likely be > n.\n            # This check is important as pow(k_val, m+1) can exceed 10^18*2*10^9 (10^27)\n            # Python handles large integers, but we want to avoid unnecessary large computations.\n            \n            # Use safe power calculation to prevent overflow for intermediate terms\n            current_term = 1\n            current_sum = 1\n            overflow = False\n            for _ in range(m):\n                # Check for overflow before multiplying\n                if n // k_val < current_term: # current_term * k_val would exceed n\n                    overflow = True\n                    break\n                current_term *= k_val\n                if n - current_term < current_sum: # current_sum + current_term would exceed n\n                    overflow = True\n                    break\n                current_sum += current_term\n            \n            if overflow:\n                # current_sum is too large, try smaller k_val\n                high = k_val - 1\n            elif current_sum == n:\n                print(\"YES\")\n                return\n            elif current_sum < n:\n                # current_sum is too small, try larger k_val\n                low = k_val + 1\n            else: # current_sum > n\n                # current_sum is too large, try smaller k_val\n                high = k_val - 1\n\n    print(\"NO\")\n\n\nnum_test_cases = int(input())\nfor _ in range(num_test_cases):\n    solve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\n# Function to calculate integer square root\ndef isqrt(n):\n    if n < 0:\n        raise ValueError(\"isqrt() argument must be non-negative\")\n    if n == 0:\n        return 0\n    x = int(math.sqrt(n))\n    # Adjust if x*x is slightly off due to floating point precision\n    if x * x > n:\n        x -= 1\n    while (x + 1) * (x + 1) <= n:\n        x += 1\n    return x\n\n# Function to check if n can be represented as 1 + k + k^2 + ... + k^m\ndef solve():\n    n = int(input())\n\n    # Small values of n that cannot be snowflakes\n    # For n=1,2,3,4,5,6, the answer is NO.\n    # The smallest snowflake is 1+2+2^2 = 7 (k=2, m=2)\n    # The next smallest is 1+3+3^2 = 13 (k=3, m=2)\n    # The next smallest is 1+2+2^2+2^3 = 15 (k=2, m=3)\n    if n < 7:\n        print(\"NO\")\n        return\n\n    # Case 1: m = 2 (n = 1 + k + k^2)\n    # k^2 + k + (1 - n) = 0\n    # Discriminant D = 1 - 4 * (1 - n) = 4n - 3\n    # k = (-1 + sqrt(D)) / 2\n    val = 4 * n - 3\n    s_val = isqrt(val)\n    if s_val * s_val == val:  # Check if 4n-3 is a perfect square\n        if s_val > 1 and (s_val - 1) % 2 == 0: # Check if s_val is odd and > 1\n            k = (s_val - 1) // 2\n            if k > 1: # k must be > 1\n                print(\"YES\")\n                return\n\n    # Case 2: m >= 3 (n = 1 + k + k^2 + ... + k^m)\n    # Iterate m from 3 up to a reasonable maximum.\n    # For k=2, m=59, sum is 2^60 - 1 which is > 10^18. So m up to 59 is enough.\n    for m in range(3, 60):\n        # Binary search for k\n        # Lower bound for k is 2\n        # Upper bound for k: k^m < n => k < n^(1/m).\n        # A safe upper bound for k can be n^(1/m) + a small constant.\n        # For n=10^18, m=3, k_max approx 10^6.\n        # For n=10^18, m=59, k_max approx 2.\n        # A simple upper bound that works for all m: 2 * 10**9 (since k < sqrt(n) for m>=2)\n        low = 2\n        high = int(n**(1.0/m)) + 2 # Tighter upper bound\n        if high > 2 * 10**9: # Cap it if n is very large and m is small\n            high = 2 * 10**9\n\n        found_k = False\n        while low <= high:\n            k_val = (low + high) // 2\n            if k_val < 2: # Ensure k > 1\n                k_val = 2\n                low = 2\n                continue\n            \n            # Calculate sum 1 + k_val + ... + k_val^m\n            # Sum = (k_val^(m+1) - 1) / (k_val - 1)\n            # Check for potential overflow before computing pow(k_val, m+1)\n            # If k_val^(m+1) would exceed n*(k_val-1)+1, then it's too large.\n            # A rough check: if k_val^m > n, then sum will likely be > n.\n            # This check is important as pow(k_val, m+1) can exceed 10^18*2*10^9 (10^27)\n            # Python handles large integers, but we want to avoid unnecessary large computations.\n            \n            # Use safe power calculation to prevent overflow for intermediate terms\n            current_term = 1\n            current_sum = 1\n            overflow = False\n            for _ in range(m):\n                # Check for overflow before multiplying\n                if n // k_val < current_term: # current_term * k_val would exceed n\n                    overflow = True\n                    break\n                current_term *= k_val\n                if n - current_term < current_sum: # current_sum + current_term would exceed n\n                    overflow = True\n                    break\n                current_sum += current_term\n            \n            if overflow:\n                # current_sum is too large, try smaller k_val\n                high = k_val - 1\n            elif current_sum == n:\n                print(\"YES\")\n                return\n            elif current_sum < n:\n                # current_sum is too small, try larger k_val\n                low = k_val + 1\n            else: # current_sum > n\n                # current_sum is too large, try smaller k_val\n                high = k_val - 1\n\n    print(\"NO\")\n\n\nnum_test_cases = int(input())\nfor _ in range(num_test_cases):\n    solve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 568,
        "completion_token_count": 5517,
        "thoughts_token_count": 793
    }
}