{
    "start": 1758284932.415666,
    "end": 1758284979.117342,
    "start-formatted": "2025-09-19 21:28 KST",
    "end-formatted": "2025-09-19 21:29 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "**Breaking Down the Mushroom Strife Problem**\n\nOkay, so I'm looking at this \"Mushroom Strife\" problem, and it's a classic graph problem with a number theory twist.  We've got lawns (vertices) and roads (edges) connecting them.  Each road gives us the GCD and LCM of the number of mushrooms on the connected lawns.  The goal is to figure out the number of mushrooms on *each* lawn, or declare it impossible.  The mushroom count is constrained between 1 and 10^6, which is important.\n\nMy first thought is, let's denote the mushroom count on lawn *u* as *x<sub>u</sub>* and on lawn *v* as *x<sub>v</sub>*.  For a road connecting *u* and *v* with given GCD (*g*) and LCM (*l*), we have two key equations: `gcd(x<sub>u</sub>, x<sub>v</sub>) = g` and `lcm(x<sub>u</sub>, x<sub>v</sub>) = l`.\n\nNow, that fundamental property: `gcd(a, b) * lcm(a, b) = a * b` is jumping out. This directly translates to `g * l = x<sub>u</sub> * x<sub>v</sub>` for each edge. Also, knowing that `gcd(x<sub>u</sub>, x<sub>v</sub>) = g` implies both *x<sub>u</sub>* and *x<sub>v</sub>* are multiples of *g*.  So, I can write *x<sub>u</sub>* as *g * a* and *x<sub>v</sub>* as *g * b* where *a* and *b* are integers, and most importantly, `gcd(a, b) = 1`.\n\nSubstituting those into `g * l = x<sub>u</sub> * x<sub>v</sub>` gets me `g * l = g<sup>2</sup> * a * b`, simplifying to `l = g * a * b`, or `l / g = a * b`.  Let's call `l / g` as *P*. The constraint that `gcd(a, b) = 1` seems key. So, the original problem is now about finding *a* and *b* where *a * b = P* and `gcd(a, b) = 1`.  And of course, if *l* isn't divisible by *g* to begin with, it's immediately \"NO\".\n\nThe constraints are important: `1 <= g, l <= 10^6` and `1 <= x<sub>i</sub> <= 10^6`. This tells me prime factorization within that range is reasonable.\n\n**The Graph Interpretation**\n\nThis is where the graph comes in handy. If I fix a value, say *x<sub>u</sub>* at lawn *u*, the equations directly give me information on *x<sub>v</sub>* for any connected lawn. If I have *x<sub>u</sub> = g * a*, then I know *x<sub>v</sub>* must be *g * (P / a)*, where *P = l / g*.  To ensure our GCD condition holds, we need `gcd(g * a, g * (P / a)) = g`. That means `gcd(a, P / a) = 1`. So *a* and *P / a* must be relatively prime. This is the heart of the solution. For a valid solution, I'll need a way to efficiently find suitable *a* and *b* given a specific *P*, keeping in mind they should form relatively prime factors of *P*.\n",
    "response": "```python\nimport sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    if n == 0: # Should not happen based on constraints (1 <= n) but good practice.\n        print(\"YES\")\n        print()\n        return\n\n    # Adjacency list for the graph\n    adj = [[] for _ in range(n + 1)]\n    \n    # Store required P values for each edge\n    # P_vals[u][v] = P for edge (u, v)\n    P_vals = {} \n    \n    # Store required factors of P for each edge\n    # For edge (u, v) with GCD g and LCM l, P = l/g.\n    # We need x_u = g * a and x_v = g * (P/a) where a * (P/a) = P and gcd(a, P/a) = 1.\n    # The set of prime factors of a must be disjoint from the set of prime factors of P/a.\n    # This means 'a' must be formed by taking a subset of prime power factors of P.\n    # For example, if P = p1^k1 * p2^k2, then 'a' could be p1^k1 or p2^k2 or p1^k1*p2^k2 or 1.\n    # In general, 'a' can be any square-free divisor of P.\n    # No, this is incorrect. If P = 12 = 2^2 * 3.\n    # Possible (a, P/a) pairs with gcd(a, P/a)=1:\n    # (1, 12) - x_u = g, x_v = 12g\n    # (3, 4) - x_u = 3g, x_v = 4g\n    # This means 'a' can be 1 or 3.\n    # 'a' must be a divisor of P such that all prime factors of 'a' appear in 'P' with the same exponent as in 'a',\n    # and for any prime factor 'p' of 'a', 'p' does not divide 'P/a'.\n    # This implies that if 'p^k' is a prime power factor of 'P', then 'p^k' must either entirely belong to 'a' or entirely to 'P/a'.\n    # So, 'a' must be a product of some full prime power factors of P.\n    # Example: P = 72 = 2^3 * 3^2.\n    # Possible 'a' values: 1, 2^3=8, 3^2=9, 2^3*3^2=72.\n    # Corresponding (a, P/a) pairs: (1, 72), (8, 9), (9, 8), (72, 1).\n    # The set of possible 'a' values for a given P is the set of all divisors of P that are formed by multiplying distinct prime power factors of P.\n    # Let's call these \"split factors\".\n    \n    # Precompute prime factors for numbers up to 10^6\n    MAX_VAL = 10**6\n    min_prime_factor = [0] * (MAX_VAL + 1)\n    primes = []\n    for i in range(2, MAX_VAL + 1):\n        if min_prime_factor[i] == 0:\n            min_prime_factor[i] = i\n            primes.append(i)\n        for p in primes:\n            if p > min_prime_factor[i] or i * p > MAX_VAL:\n                break\n            min_prime_factor[i * p] = p\n\n    # Function to get prime factorization of a number\n    def get_prime_factorization(num):\n        factors = {}\n        temp = num\n        while temp > 1:\n            p = min_prime_factor[temp]\n            count = 0\n            while temp % p == 0:\n                temp //= p\n                count += 1\n            factors[p] = count\n        return factors\n\n    # Function to get all \"split factors\" for a number P\n    # A split factor 'a' is such that a | P and gcd(a, P/a) = 1.\n    # This means 'a' must be formed by multiplying some complete prime power factors of P.\n    # E.g., if P = p1^k1 * p2^k2, then 'a' can be 1, p1^k1, p2^k2, p1^k1*p2^k2.\n    def get_split_factors(P):\n        if P == 1:\n            return {1}\n        \n        prime_powers = []\n        for p, k in get_prime_factorization(P).items():\n            prime_powers.append(p**k)\n        \n        split_factors = {1}\n        for pp in prime_powers:\n            new_factors = set()\n            for sf in split_factors:\n                new_factors.add(sf * pp)\n            split_factors.update(new_factors)\n        return split_factors\n\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n\n        if l % g != 0:\n            print(\"NO\")\n            return\n\n        P = l // g\n        \n        # Store (g, P) for each edge\n        adj[u].append((v, g, P))\n        adj[v].append((u, g, P))\n        \n        # For efficient lookup of P_vals\n        if u > v: u, v = v, u # Normalize (u,v) to (min(u,v), max(u,v))\n        P_vals[(u, v)] = P\n\n    # Array to store the assigned mushroom counts\n    ans = [0] * (n + 1)\n    \n    # Array to track visited nodes in DFS/BFS\n    visited = [False] * (n + 1)\n\n    # Iterate through all nodes to handle disconnected components\n    for i in range(1, n + 1):\n        if not visited[i]:\n            # Start a BFS/DFS from node i\n            # We need to assign a value to a node and then propagate\n            # Let's try to assign a value to the starting node `i`.\n            # If `i` has no neighbors, `ans[i]` can be 1 (or any value <= 10^6).\n            # If `i` has neighbors, its value must be consistent.\n            \n            # The strategy is to assign a \"base\" value to the first node in a component,\n            # and then express all other values in that component relative to this base.\n            # However, the values `x_u` are not multiplicative relative to each other directly.\n            # `x_u = g * a`, `x_v = g * (P/a)`.\n            # The values `a` and `P/a` are multiplicative factors of `P`.\n            # We can pick `x_u` to be `g` or `g*P`.\n            # Let's try assigning `x_i = g_0 * a_0` for some `a_0`\n            # For a connected component, once one node's value is fixed, all other nodes' values are determined.\n            # If we fix `x_u`, then for an edge `(u,v)` with `g,l`, `x_v` is determined by `x_v = (g*l)/x_u`.\n            # We also need to check `gcd(x_u, x_v) = g`.\n            \n            # Use a queue for BFS\n            q = []\n\n            # If node i has no edges, it can be 1.\n            if not adj[i]:\n                ans[i] = 1\n                visited[i] = True\n                continue\n\n            # For a connected component, pick an arbitrary start node `i`.\n            # We need to determine `x_i`.\n            # `x_i` must be a multiple of `g` for every adjacent edge `(i, v)`.\n            # So `x_i` must be a multiple of `lcm(g_1, g_2, ...)`.\n            # Let `x_i = K * LCM_of_all_g_s`.\n            # The problem states \"any one\" valid assignment.\n            # A simpler approach: try fixing `x_i` to one of its \"candidate\" values.\n            # What are candidate values for `x_i`?\n            # For each edge `(i, v)` with `g_iv, P_iv`: `x_i = g_iv * a_iv` where `a_iv` is a split factor of `P_iv`.\n            # We can try to pick `x_i` as `g_iv` for some arbitrary neighbor `v`.\n            # Or, more generally, `x_i` must be `g_edge * a` for some `a` that is a split factor of `P_edge`.\n            \n            # Let's try to assign `x_i` to `g_first_edge`.\n            # If `i` has neighbors, pick the first neighbor `v_0` with `g_0, P_0`.\n            # `x_i` could be `g_0` or `g_0 * P_0`.\n            # Let's try `x_i = g_0`.\n            \n            # A more robust approach for BFS:\n            # We need to find `x_u` values.\n            # For each edge `(u, v)` with `g, l`, we have `x_u = g * a` and `x_v = g * (P/a)`.\n            # This implies `x_u / g` and `x_v / g` are factors `a` and `P/a` such that `a * (P/a) = P` and `gcd(a, P/a) = 1`.\n            # We can try to assign `x_u` values that are powers of 2 times `g` (or `g * P`).\n            # This is not a good idea. Instead, we can try to find candidate values for `x_u`.\n            # If `x_u` is known, `x_v` is `g*l/x_u`.\n            # We also need to check `gcd(x_u, x_v) = g` and `lcm(x_u, x_v) = l`.\n            # The `lcm` condition is automatically satisfied if `x_u * x_v = g*l`.\n            # The `gcd` condition needs `gcd(x_u, (g*l)/x_u) = g`.\n            # This is equivalent to `gcd(x_u/g, (l/g)/(x_u/g)) = 1`.\n            # Let `A_u = x_u/g_uv` and `A_v = x_v/g_uv`. Then `A_u * A_v = P_uv` and `gcd(A_u, A_v) = 1`.\n            \n            # Let's use a BFS to propagate values.\n            # When we visit a node `u` for the first time, we need to assign `x_u`.\n            # If `u` is the start of a component (i.e., `i` in the outer loop), we can try to pick a candidate for `x_i`.\n            # What are the candidates for `x_i`? For each neighbor `v` with `g_iv, P_iv`, `x_i` must be `g_iv * a`\n            # where `a` is a split factor of `P_iv`.\n            # There can be multiple choices. If one choice leads to a contradiction, we need to backtrack.\n            # This suggests a search (DFS with backtracking) or a system of equations.\n            \n            # A key observation: if `x_u` is known, `x_v` is uniquely determined.\n            # If we fix `x_u`, then `x_v = (g * l) / x_u`.\n            # We must verify `gcd(x_u, x_v) = g` and `1 <= x_v <= 10^6`.\n            # So for the first node `i` in a component, we can try to guess `x_i`.\n            # What are the possible values for `x_i`?\n            # For each neighbor `v` of `i`, `x_i` must be `g_iv * a` where `a` is a split factor of `P_iv`.\n            # Let `S_i` be the intersection of all such sets of possible values for `x_i`.\n            # If `S_i` is empty, then no solution. If `S_i` has multiple values, pick one.\n            # This is still complex.\n\n            # Let's simplify. For a connected component, if we fix `x_root` for an arbitrary root `root`,\n            # then all other `x_u` values are determined.\n            # We just need to check if the determined values are consistent.\n            # What should `x_root` be?\n            # `x_root` must be a multiple of `g` for every edge `(root, v)`.\n            # `x_root` must satisfy `1 <= x_root <= 10^6`.\n            # For any edge `(u, v)` with `g, P`: `x_u = g * a`, `x_v = g * (P/a)`.\n            # This means `x_u` must be a divisor of `g*P = l`.\n            # So `x_u` must be a divisor of `l` for all incident edges.\n            # And `x_u` must be a multiple of `g` for all incident edges.\n            \n            # Let `x_u = f_u`.\n            # For an edge `(u, v)` with `g, l`:\n            # `f_u = g * a`\n            # `f_v = g * b`\n            # `a * b = P = l/g`\n            # `gcd(a, b) = 1`\n            \n            # This structure means that if we know `x_u`, we know `x_u/g`. Let this be `A_u`.\n            # Then `x_v/g = P/A_u`.\n            # We can define `x_u = g_u * K_u` for some `g_u` and `K_u`.\n            # Consider `x_u = g_u * a_u` and `x_v = g_v * a_v`.\n            # This suggests that we can try to assign a value to `x_i` based on its first neighbor.\n            \n            # Let's try a specific strategy:\n            # For each connected component, pick an arbitrary root `r`.\n            # For each neighbor `v` of `r` with `g_rv, l_rv`, `x_r` must be `g_rv * a` where `a` is a split factor of `P_rv = l_rv/g_rv`.\n            # We can try to set `x_r = g_rv` for the first neighbor `v`.\n            # Then propagate using BFS.\n            \n            # Let's try this:\n            # Initialize `ans` with -1 (unassigned).\n            # For each connected component:\n            # Pick an unvisited node `u`.\n            # If `u` has no neighbors, set `ans[u] = 1`. Mark `u` visited. Continue.\n            # If `u` has neighbors, pick the first neighbor `v` with `g, l`.\n            # Get `P = l // g`.\n            # Get all split factors `SF_P` of `P`.\n            # Try `x_u = g * a` for each `a` in `SF_P`.\n            # This is essentially trying different values for `x_u`.\n            # Since `n` can be up to 10^5, and `P` can have many split factors, this might be too slow if we have to backtrack a lot.\n            # The maximum number of distinct prime factors for a number up to 10^6 is small (e.g., 2*3*5*7*11*13*17 = 510510).\n            # So `P` can have at most 7 distinct prime factors. This means `2^7 = 128` split factors.\n            # So, for the root of each component, we might try up to 128 possibilities.\n            # The BFS/DFS itself is O(N+M). So `128 * (N+M)` might be acceptable.\n\n            # Store the current assignment for the component in `current_ans`\n            # `current_ans` will be `ans` if successful.\n            \n            # Find the first unvisited node `start_node`\n            start_node = i\n            \n            # Get split factors for the first edge (if any)\n            if not adj[start_node]:\n                ans[start_node] = 1\n                visited[start_node] = True\n                continue\n            \n            # Pick an arbitrary neighbor to define the initial `P`\n            first_neighbor_v, first_g, first_P = adj[start_node][0]\n            \n            # Get all candidate values for `x_start_node` based on the first edge\n            candidate_x_values = set()\n            for a in get_split_factors(first_P):\n                val = first_g * a\n                if 1 <= val <= MAX_VAL:\n                    candidate_x_values.add(val)\n            \n            found_solution_for_component = False\n            \n            for initial_x_val in candidate_x_values:\n                temp_ans = [0] * (n + 1) # Temporary assignment for this trial\n                temp_visited = [False] * (n + 1)\n                \n                q = []\n                \n                temp_ans[start_node] = initial_x_val\n                temp_visited[start_node] = True\n                q.append(start_node)\n                \n                is_valid_trial = True\n                \n                head = 0\n                while head < len(q):\n                    u = q[head]\n                    head += 1\n\n                    if temp_ans[u] == 0: # Should not happen if logic is correct\n                        is_valid_trial = False\n                        break\n\n                    for v, g_uv, P_uv in adj[u]:\n                        if temp_ans[v] == 0: # v is unassigned\n                            # Calculate x_v\n                            # x_u * x_v = g_uv * l_uv = g_uv * (g_uv * P_uv)\n                            # x_v = (g_uv * g_uv * P_uv) / x_u\n                            \n                            # Check if x_u is a multiple of g_uv\n                            if temp_ans[u] % g_uv != 0:\n                                is_valid_trial = False\n                                break\n                            \n                            # Calculate A_u = x_u / g_uv\n                            A_u = temp_ans[u] // g_uv\n                            \n                            # Check if A_u is a divisor of P_uv\n                            if P_uv % A_u != 0:\n                                is_valid_trial = False\n                                break\n                            \n                            # Calculate A_v = P_uv / A_u\n                            A_v = P_uv // A_u\n                            \n                            # Check gcd(A_u, A_v) = 1\n                            # This is the crucial check for the split factors.\n                            # We need a GCD function.\n                            def gcd(a, b):\n                                while b:\n                                    a, b = b, a % b\n                                return a\n                                \n                            if gcd(A_u, A_v) != 1:\n                                is_valid_trial = False\n                                break\n                            \n                            # Calculate x_v = g_uv * A_v\n                            x_v = g_uv * A_v\n                            \n                            # Check bounds for x_v\n                            if not (1 <= x_v <= MAX_VAL):\n                                is_valid_trial = False\n                                break\n                            \n                            temp_ans[v] = x_v\n                            temp_visited[v] = True\n                            q.append(v)\n                        else: # v is already assigned, check consistency\n                            # x_u and x_v are already assigned\n                            # Check if gcd(x_u, x_v) == g_uv and lcm(x_u, x_v) == g_uv * P_uv\n                            \n                            # Check if x_u is multiple of g_uv and x_v is multiple of g_uv\n                            if temp_ans[u] % g_uv != 0 or temp_ans[v] % g_uv != 0:\n                                is_valid_trial = False\n                                break\n                            \n                            # Check gcd\n                            if gcd(temp_ans[u], temp_ans[v]) != g_uv:\n                                is_valid_trial = False\n                                break\n                            \n                            # Check lcm\n                            # lcm(a,b) = (a*b)/gcd(a,b)\n                            # We need (temp_ans[u] * temp_ans[v]) / g_uv == g_uv * P_uv\n                            # This is equivalent to temp_ans[u] * temp_ans[v] == g_uv * g_uv * P_uv\n                            # Which is temp_ans[u] * temp_ans[v] == g_uv * l_uv\n                            # Since we derived x_v = (g_uv * l_uv) / x_u, this check is implicitly satisfied\n                            # if x_v was derived from x_u.\n                            # But here we are checking consistency of two independently derived values.\n                            # So, (temp_ans[u] * temp_ans[v]) must equal (g_uv * (g_uv * P_uv))\n                            # For large numbers, (a*b)/gcd can overflow if a*b is too big.\n                            # But here MAX_VAL = 10^6, so a*b can be 10^12. Python handles large integers.\n                            # The product (g_uv * P_uv) is l_uv. So we need temp_ans[u] * temp_ans[v] == g_uv * l_uv.\n                            if (temp_ans[u] * temp_ans[v]) != (g_uv * (g_uv * P_uv)):\n                                is_valid_trial = False\n                                break\n                    \n                    if not is_valid_trial:\n                        break\n                \n                if is_valid_trial:\n                    # This trial worked for the component. Copy to final ans.\n                    for node_in_component in range(1, n + 1):\n                        if temp_visited[node_in_component]:\n                            ans[node_in_component] = temp_ans[node_in_component]\n                            visited[node_in_component] = True\n                    found_solution_for_component = True\n                    break # Break from trying different initial_x_val for this component\n            \n            if not found_solution_for_component:\n                print(\"NO\")\n                return\n\n    # If we reached here, all components were successfully processed.\n    print(\"YES\")\n    print(*(ans[1:]))\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n\n    if n == 0: # Should not happen based on constraints (1 <= n) but good practice.\n        print(\"YES\")\n        print()\n        return\n\n    # Adjacency list for the graph\n    adj = [[] for _ in range(n + 1)]\n    \n    # Store required P values for each edge\n    # P_vals[u][v] = P for edge (u, v)\n    P_vals = {} \n    \n    # Store required factors of P for each edge\n    # For edge (u, v) with GCD g and LCM l, P = l/g.\n    # We need x_u = g * a and x_v = g * (P/a) where a * (P/a) = P and gcd(a, P/a) = 1.\n    # The set of prime factors of a must be disjoint from the set of prime factors of P/a.\n    # This means 'a' must be formed by taking a subset of prime power factors of P.\n    # For example, if P = p1^k1 * p2^k2, then 'a' could be p1^k1 or p2^k2 or p1^k1*p2^k2 or 1.\n    # In general, 'a' can be any square-free divisor of P.\n    # No, this is incorrect. If P = 12 = 2^2 * 3.\n    # Possible (a, P/a) pairs with gcd(a, P/a)=1:\n    # (1, 12) - x_u = g, x_v = 12g\n    # (3, 4) - x_u = 3g, x_v = 4g\n    # This means 'a' can be 1 or 3.\n    # 'a' must be a divisor of P such that all prime factors of 'a' appear in 'P' with the same exponent as in 'a',\n    # and for any prime factor 'p' of 'a', 'p' does not divide 'P/a'.\n    # This implies that if 'p^k' is a prime power factor of 'P', then 'p^k' must either entirely belong to 'a' or entirely to 'P/a'.\n    # So, 'a' must be a product of some full prime power factors of P.\n    # Example: P = 72 = 2^3 * 3^2.\n    # Possible 'a' values: 1, 2^3=8, 3^2=9, 2^3*3^2=72.\n    # Corresponding (a, P/a) pairs: (1, 72), (8, 9), (9, 8), (72, 1).\n    # The set of possible 'a' values for a given P is the set of all divisors of P that are formed by multiplying distinct prime power factors of P.\n    # Let's call these \"split factors\".\n    \n    # Precompute prime factors for numbers up to 10^6\n    MAX_VAL = 10**6\n    min_prime_factor = [0] * (MAX_VAL + 1)\n    primes = []\n    for i in range(2, MAX_VAL + 1):\n        if min_prime_factor[i] == 0:\n            min_prime_factor[i] = i\n            primes.append(i)\n        for p in primes:\n            if p > min_prime_factor[i] or i * p > MAX_VAL:\n                break\n            min_prime_factor[i * p] = p\n\n    # Function to get prime factorization of a number\n    def get_prime_factorization(num):\n        factors = {}\n        temp = num\n        while temp > 1:\n            p = min_prime_factor[temp]\n            count = 0\n            while temp % p == 0:\n                temp //= p\n                count += 1\n            factors[p] = count\n        return factors\n\n    # Function to get all \"split factors\" for a number P\n    # A split factor 'a' is such that a | P and gcd(a, P/a) = 1.\n    # This means 'a' must be formed by multiplying some complete prime power factors of P.\n    # E.g., if P = p1^k1 * p2^k2, then 'a' can be 1, p1^k1, p2^k2, p1^k1*p2^k2.\n    def get_split_factors(P):\n        if P == 1:\n            return {1}\n        \n        prime_powers = []\n        for p, k in get_prime_factorization(P).items():\n            prime_powers.append(p**k)\n        \n        split_factors = {1}\n        for pp in prime_powers:\n            new_factors = set()\n            for sf in split_factors:\n                new_factors.add(sf * pp)\n            split_factors.update(new_factors)\n        return split_factors\n\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n\n        if l % g != 0:\n            print(\"NO\")\n            return\n\n        P = l // g\n        \n        # Store (g, P) for each edge\n        adj[u].append((v, g, P))\n        adj[v].append((u, g, P))\n        \n        # For efficient lookup of P_vals\n        if u > v: u, v = v, u # Normalize (u,v) to (min(u,v), max(u,v))\n        P_vals[(u, v)] = P\n\n    # Array to store the assigned mushroom counts\n    ans = [0] * (n + 1)\n    \n    # Array to track visited nodes in DFS/BFS\n    visited = [False] * (n + 1)\n\n    # Iterate through all nodes to handle disconnected components\n    for i in range(1, n + 1):\n        if not visited[i]:\n            # Start a BFS/DFS from node i\n            # We need to assign a value to a node and then propagate\n            # Let's try to assign a value to the starting node `i`.\n            # If `i` has no neighbors, `ans[i]` can be 1 (or any value <= 10^6).\n            # If `i` has neighbors, its value must be consistent.\n            \n            # The strategy is to assign a \"base\" value to the first node in a component,\n            # and then express all other values in that component relative to this base.\n            # However, the values `x_u` are not multiplicative relative to each other directly.\n            # `x_u = g * a`, `x_v = g * (P/a)`.\n            # The values `a` and `P/a` are multiplicative factors of `P`.\n            # We can pick `x_u` to be `g` or `g*P`.\n            # Let's try assigning `x_i = g_0 * a_0` for some `a_0`\n            # For a connected component, once one node's value is fixed, all other nodes' values are determined.\n            # If we fix `x_u`, then for an edge `(u,v)` with `g,l`, `x_v` is determined by `x_v = (g*l)/x_u`.\n            # We also need to check `gcd(x_u, x_v) = g`.\n            \n            # Use a queue for BFS\n            q = []\n\n            # If node i has no edges, it can be 1.\n            if not adj[i]:\n                ans[i] = 1\n                visited[i] = True\n                continue\n\n            # For a connected component, pick an arbitrary start node `i`.\n            # We need to determine `x_i`.\n            # `x_i` must be a multiple of `g` for every adjacent edge `(i, v)`.\n            # So `x_i` must be a multiple of `lcm(g_1, g_2, ...)`.\n            # Let `x_i = K * LCM_of_all_g_s`.\n            # The problem states \"any one\" valid assignment.\n            # A simpler approach: try fixing `x_i` to one of its \"candidate\" values.\n            # What are candidate values for `x_i`?\n            # For each edge `(i, v)` with `g_iv, P_iv`: `x_i = g_iv * a_iv` where `a_iv` is a split factor of `P_iv`.\n            # We can try to pick `x_i` as `g_iv` for some arbitrary neighbor `v`.\n            # Or, more generally, `x_i` must be `g_edge * a` for some `a` that is a split factor of `P_edge`.\n            \n            # Let's try to assign `x_i` to `g_first_edge`.\n            # If `i` has neighbors, pick the first neighbor `v_0` with `g_0, P_0`.\n            # `x_i` could be `g_0` or `g_0 * P_0`.\n            # Let's try `x_i = g_0`.\n            \n            # A more robust approach for BFS:\n            # We need to find `x_u` values.\n            # For each edge `(u, v)` with `g, l`, we have `x_u = g * a` and `x_v = g * (P/a)`.\n            # This implies `x_u / g` and `x_v / g` are factors `a` and `P/a` such that `a * (P/a) = P` and `gcd(a, P/a) = 1`.\n            # We can try to assign `x_u` values that are powers of 2 times `g` (or `g * P`).\n            # This is not a good idea. Instead, we can try to find candidate values for `x_u`.\n            # If `x_u` is known, `x_v` is `g*l/x_u`.\n            # We also need to check `gcd(x_u, x_v) = g` and `lcm(x_u, x_v) = l`.\n            # The `lcm` condition is automatically satisfied if `x_u * x_v = g*l`.\n            # The `gcd` condition needs `gcd(x_u, (g*l)/x_u) = g`.\n            # This is equivalent to `gcd(x_u/g, (l/g)/(x_u/g)) = 1`.\n            # Let `A_u = x_u/g_uv` and `A_v = x_v/g_uv`. Then `A_u * A_v = P_uv` and `gcd(A_u, A_v) = 1`.\n            \n            # Let's use a BFS to propagate values.\n            # When we visit a node `u` for the first time, we need to assign `x_u`.\n            # If `u` is the start of a component (i.e., `i` in the outer loop), we can try to pick a candidate for `x_i`.\n            # What are the candidates for `x_i`? For each neighbor `v` with `g_iv, P_iv`, `x_i` must be `g_iv * a`\n            # where `a` is a split factor of `P_iv`.\n            # There can be multiple choices. If one choice leads to a contradiction, we need to backtrack.\n            # This suggests a search (DFS with backtracking) or a system of equations.\n            \n            # A key observation: if `x_u` is known, `x_v` is uniquely determined.\n            # If we fix `x_u`, then `x_v = (g * l) / x_u`.\n            # We must verify `gcd(x_u, x_v) = g` and `1 <= x_v <= 10^6`.\n            # So for the first node `i` in a component, we can try to guess `x_i`.\n            # What are the possible values for `x_i`?\n            # For each neighbor `v` of `i`, `x_i` must be `g_iv * a` where `a` is a split factor of `P_iv`.\n            # Let `S_i` be the intersection of all such sets of possible values for `x_i`.\n            # If `S_i` is empty, then no solution. If `S_i` has multiple values, pick one.\n            # This is still complex.\n\n            # Let's simplify. For a connected component, if we fix `x_root` for an arbitrary root `root`,\n            # then all other `x_u` values are determined.\n            # We just need to check if the determined values are consistent.\n            # What should `x_root` be?\n            # `x_root` must be a multiple of `g` for every edge `(root, v)`.\n            # `x_root` must satisfy `1 <= x_root <= 10^6`.\n            # For any edge `(u, v)` with `g, P`: `x_u = g * a`, `x_v = g * (P/a)`.\n            # This means `x_u` must be a divisor of `g*P = l`.\n            # So `x_u` must be a divisor of `l` for all incident edges.\n            # And `x_u` must be a multiple of `g` for all incident edges.\n            \n            # Let `x_u = f_u`.\n            # For an edge `(u, v)` with `g, l`:\n            # `f_u = g * a`\n            # `f_v = g * b`\n            # `a * b = P = l/g`\n            # `gcd(a, b) = 1`\n            \n            # This structure means that if we know `x_u`, we know `x_u/g`. Let this be `A_u`.\n            # Then `x_v/g = P/A_u`.\n            # We can define `x_u = g_u * K_u` for some `g_u` and `K_u`.\n            # Consider `x_u = g_u * a_u` and `x_v = g_v * a_v`.\n            # This suggests that we can try to assign a value to `x_i` based on its first neighbor.\n            \n            # Let's try a specific strategy:\n            # For each connected component, pick an arbitrary root `r`.\n            # For each neighbor `v` of `r` with `g_rv, l_rv`, `x_r` must be `g_rv * a` where `a` is a split factor of `P_rv = l_rv/g_rv`.\n            # We can try to set `x_r = g_rv` for the first neighbor `v`.\n            # Then propagate using BFS.\n            \n            # Let's try this:\n            # Initialize `ans` with -1 (unassigned).\n            # For each connected component:\n            # Pick an unvisited node `u`.\n            # If `u` has no neighbors, set `ans[u] = 1`. Mark `u` visited. Continue.\n            # If `u` has neighbors, pick the first neighbor `v` with `g, l`.\n            # Get `P = l // g`.\n            # Get all split factors `SF_P` of `P`.\n            # Try `x_u = g * a` for each `a` in `SF_P`.\n            # This is essentially trying different values for `x_u`.\n            # Since `n` can be up to 10^5, and `P` can have many split factors, this might be too slow if we have to backtrack a lot.\n            # The maximum number of distinct prime factors for a number up to 10^6 is small (e.g., 2*3*5*7*11*13*17 = 510510).\n            # So `P` can have at most 7 distinct prime factors. This means `2^7 = 128` split factors.\n            # So, for the root of each component, we might try up to 128 possibilities.\n            # The BFS/DFS itself is O(N+M). So `128 * (N+M)` might be acceptable.\n\n            # Store the current assignment for the component in `current_ans`\n            # `current_ans` will be `ans` if successful.\n            \n            # Find the first unvisited node `start_node`\n            start_node = i\n            \n            # Get split factors for the first edge (if any)\n            if not adj[start_node]:\n                ans[start_node] = 1\n                visited[start_node] = True\n                continue\n            \n            # Pick an arbitrary neighbor to define the initial `P`\n            first_neighbor_v, first_g, first_P = adj[start_node][0]\n            \n            # Get all candidate values for `x_start_node` based on the first edge\n            candidate_x_values = set()\n            for a in get_split_factors(first_P):\n                val = first_g * a\n                if 1 <= val <= MAX_VAL:\n                    candidate_x_values.add(val)\n            \n            found_solution_for_component = False\n            \n            for initial_x_val in candidate_x_values:\n                temp_ans = [0] * (n + 1) # Temporary assignment for this trial\n                temp_visited = [False] * (n + 1)\n                \n                q = []\n                \n                temp_ans[start_node] = initial_x_val\n                temp_visited[start_node] = True\n                q.append(start_node)\n                \n                is_valid_trial = True\n                \n                head = 0\n                while head < len(q):\n                    u = q[head]\n                    head += 1\n\n                    if temp_ans[u] == 0: # Should not happen if logic is correct\n                        is_valid_trial = False\n                        break\n\n                    for v, g_uv, P_uv in adj[u]:\n                        if temp_ans[v] == 0: # v is unassigned\n                            # Calculate x_v\n                            # x_u * x_v = g_uv * l_uv = g_uv * (g_uv * P_uv)\n                            # x_v = (g_uv * g_uv * P_uv) / x_u\n                            \n                            # Check if x_u is a multiple of g_uv\n                            if temp_ans[u] % g_uv != 0:\n                                is_valid_trial = False\n                                break\n                            \n                            # Calculate A_u = x_u / g_uv\n                            A_u = temp_ans[u] // g_uv\n                            \n                            # Check if A_u is a divisor of P_uv\n                            if P_uv % A_u != 0:\n                                is_valid_trial = False\n                                break\n                            \n                            # Calculate A_v = P_uv / A_u\n                            A_v = P_uv // A_u\n                            \n                            # Check gcd(A_u, A_v) = 1\n                            # This is the crucial check for the split factors.\n                            # We need a GCD function.\n                            def gcd(a, b):\n                                while b:\n                                    a, b = b, a % b\n                                return a\n                                \n                            if gcd(A_u, A_v) != 1:\n                                is_valid_trial = False\n                                break\n                            \n                            # Calculate x_v = g_uv * A_v\n                            x_v = g_uv * A_v\n                            \n                            # Check bounds for x_v\n                            if not (1 <= x_v <= MAX_VAL):\n                                is_valid_trial = False\n                                break\n                            \n                            temp_ans[v] = x_v\n                            temp_visited[v] = True\n                            q.append(v)\n                        else: # v is already assigned, check consistency\n                            # x_u and x_v are already assigned\n                            # Check if gcd(x_u, x_v) == g_uv and lcm(x_u, x_v) == g_uv * P_uv\n                            \n                            # Check if x_u is multiple of g_uv and x_v is multiple of g_uv\n                            if temp_ans[u] % g_uv != 0 or temp_ans[v] % g_uv != 0:\n                                is_valid_trial = False\n                                break\n                            \n                            # Check gcd\n                            if gcd(temp_ans[u], temp_ans[v]) != g_uv:\n                                is_valid_trial = False\n                                break\n                            \n                            # Check lcm\n                            # lcm(a,b) = (a*b)/gcd(a,b)\n                            # We need (temp_ans[u] * temp_ans[v]) / g_uv == g_uv * P_uv\n                            # This is equivalent to temp_ans[u] * temp_ans[v] == g_uv * g_uv * P_uv\n                            # Which is temp_ans[u] * temp_ans[v] == g_uv * l_uv\n                            # Since we derived x_v = (g_uv * l_uv) / x_u, this check is implicitly satisfied\n                            # if x_v was derived from x_u.\n                            # But here we are checking consistency of two independently derived values.\n                            # So, (temp_ans[u] * temp_ans[v]) must equal (g_uv * (g_uv * P_uv))\n                            # For large numbers, (a*b)/gcd can overflow if a*b is too big.\n                            # But here MAX_VAL = 10^6, so a*b can be 10^12. Python handles large integers.\n                            # The product (g_uv * P_uv) is l_uv. So we need temp_ans[u] * temp_ans[v] == g_uv * l_uv.\n                            if (temp_ans[u] * temp_ans[v]) != (g_uv * (g_uv * P_uv)):\n                                is_valid_trial = False\n                                break\n                    \n                    if not is_valid_trial:\n                        break\n                \n                if is_valid_trial:\n                    # This trial worked for the component. Copy to final ans.\n                    for node_in_component in range(1, n + 1):\n                        if temp_visited[node_in_component]:\n                            ans[node_in_component] = temp_ans[node_in_component]\n                            visited[node_in_component] = True\n                    found_solution_for_component = True\n                    break # Break from trying different initial_x_val for this component\n            \n            if not found_solution_for_component:\n                print(\"NO\")\n                return\n\n    # If we reached here, all components were successfully processed.\n    print(\"YES\")\n    print(*(ans[1:]))\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 551,
        "completion_token_count": 5515,
        "thoughts_token_count": 921
    }
}