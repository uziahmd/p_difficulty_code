{
    "start": 1758284893.3121798,
    "end": 1758284973.1598656,
    "start-formatted": "2025-09-19 21:28 KST",
    "end-formatted": "2025-09-19 21:29 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "**Breaking Down the Odd Cycle Problem**\n\nOkay, so I'm looking at this competitive programming problem, and I need a Python solution. The core of it is finding the minimum edges needed (`t`) and the number of ways (`w`) to add edges to create a simple odd cycle in a given graph.\n\nMy initial thought is to analyze the conditions. An odd cycle exists if and only if the graph isn't bipartite. So, the problem boils down to making the graph non-bipartite with the least number of new edges.\n\nFirst, let's consider the simplest case: if the input graph *already* has an odd cycle, then `t` is 0, and there's only one way to do it (`w` = 1). We need a good way to check for the presence of an odd cycle. BFS or DFS seems like a reasonable approach to check for bipartiteness. I can assign colors during the traversal. If an edge connects two nodes of the same color, boom, it's not bipartite, and there's an odd cycle.\n\nIf the initial graph *is* bipartite, then things get more interesting. I need to figure out how many edges to add. Think about connected components. Each component can either be bipartite or non-bipartite. The key insight is that adding an edge within the *same* bipartite component, specifically between two vertices of the *same* color, guarantees the creation of an odd cycle. This path length will be even so even + 1 = odd.\n\nMy plan is to iterate through each connected component and try to 2-color it using BFS.\n*   If a component is non-bipartite, I can set `t = 0` and `w = 1` immediately, then I'm done.\n*   If the component *is* bipartite, I need to store the two color sets (e.g., `color_0` and `color_1`).\n\nIf, after checking all components, everything is bipartite, I know I need to add *at least* one edge.\n\nFor `t = 1`, I'm looking to add an edge between two vertices of the same color *within* a bipartite component.  I can express this using set notation:  if I have sets `C_0` and `C_1` (vertices of color 0 and 1, respectively), adding an edge between any two nodes in `C_0` or any two nodes in `C_1` creates an odd cycle. Now, let's think about the number of ways (`w`) I can do this. The number of pairs in C0 is C0 * (C0-1) / 2 and the same for C1. Summing the results gives me the total.\n",
    "response": "The problem asks us to find the minimum number of edges `t` to add to a given graph to form a simple cycle of odd length, and `w`, the number of ways to do so. A simple cycle means each vertex occurs at most once.\n\nKey properties of odd cycles:\n1.  A graph contains an odd cycle if and only if it is not bipartite.\n2.  If a graph is bipartite, its vertices can be partitioned into two sets, say `U` and `V`, such that all edges connect a vertex in `U` to a vertex in `V`.\n3.  Adding an edge between two vertices of the same partition set (e.g., both in `U` or both in `V`) in a bipartite graph will create an odd cycle. The length of the path between these two vertices within the original bipartite graph must be even (since they are in the same partition set), so adding one edge makes the cycle length odd (even + 1).\n\nWe can determine `t` and `w` by analyzing the bipartiteness of the connected components of the given graph.\n\n**Algorithm:**\n\n1.  **Initialization:**\n    *   `visited` array to keep track of visited vertices during BFS/DFS.\n    *   `color` array to store the color (0 or 1) of each vertex in a bipartite component. Initialize to -1 (uncolored).\n    *   `t = infinity` (or a large number)\n    *   `w = 0`\n    *   `num_bipartite_components = 0`\n    *   `total_nodes = n`\n    *   `non_isolated_nodes = 0` (nodes that are part of some connected component with at least one edge)\n\n2.  **Iterate through Connected Components:**\n    For each vertex `i` from 1 to `n`:\n    If `i` has not been visited:\n        *   Start a BFS/DFS from `i` to find its connected component.\n        *   During the traversal, try to 2-color the component.\n        *   Maintain `count_0` (number of vertices colored 0) and `count_1` (number of vertices colored 1) for the current component.\n        *   `is_bipartite_component = True`\n\n        **BFS/DFS for Bipartiteness:**\n        *   Use a queue for BFS (or recursion stack for DFS). Add `i` to the queue and color it 0.\n        *   While the queue is not empty:\n            *   Dequeue `u`. Increment `non_isolated_nodes` (if `u` is not isolated).\n            *   For each neighbor `v` of `u`:\n                *   If `v` is uncolored: Color `v` with `1 - color[u]`, enqueue `v`.\n                *   If `v` is already colored and `color[v] == color[u]`: The component is not bipartite. Set `is_bipartite_component = False` and break from inner loop (or mark for early exit in DFS).\n\n        **After checking a component:**\n        *   If `is_bipartite_component` is `False`:\n            *   The graph already contains an odd cycle.\n            *   The minimum edges to add is `t = 0`.\n            *   The number of ways is `w = 1`.\n            *   We can immediately print `0 1` and exit.\n        *   If `is_bipartite_component` is `True`:\n            *   This component is bipartite.\n            *   Increment `num_bipartite_components`.\n            *   Store `count_0` and `count_1` for this component. These will be used later if `t > 0`.\n\n3.  **If no odd cycle found (`t` is still `infinity`):**\n    This means the entire graph is bipartite (or a collection of bipartite components and isolated vertices). We need to add at least one edge.\n\n    *   **Case `t = 1`:**\n        We can form an odd cycle by adding an edge between two vertices of the same color within *any* bipartite connected component.\n        Iterate through all bipartite components found in step 2:\n            For a component with `c0` vertices of color 0 and `c1` vertices of color 1:\n                *   Number of ways to pick two vertices of color 0: `c0 * (c0 - 1) / 2`.\n                *   Number of ways to pick two vertices of color 1: `c1 * (c1 - 1) / 2`.\n                *   Add these to `w_1_ways`.\n        If `w_1_ways > 0`:\n            *   `t = 1`\n            *   `w = w_1_ways`\n            *   Print `1 w` and exit.\n\n    *   **Case `t = 2`:**\n        If `t = 1` was not possible (i.e., `w_1_ways` was 0, meaning all bipartite components had `c0 < 2` and `c1 < 2`, so they were paths/stars with at most 2 nodes in each partition, or just isolated nodes), we need to add at least two edges.\n        We can form an odd cycle by connecting two *different* bipartite connected components.\n        Pick two distinct bipartite components, say `C_i` and `C_j`.\n        Pick a vertex `u` from `C_i` and `v` from `C_j`. Add edge `(u, v)`.\n        This merges `C_i` and `C_j`. The resulting component is still bipartite.\n        To form an odd cycle, we need to add *another* edge.\n        The minimum number of edges to connect two bipartite components and then form an odd cycle is 2.\n        For example, take `u_1` from `C_i` (color 0), `v_1` from `C_j` (color 0), `u_2` from `C_i` (color 1), `v_2` from `C_j` (color 1).\n        Add `(u_1, v_1)` and `(u_2, v_2)`. Now `u_1` and `u_2` are connected by a path of length 1 in `C_i`, and by `u_1-v_1-v_2-u_2` which has length 3. So `1+3=4` (even cycle).\n        This approach is incorrect.\n\n        Correct `t=2` strategy:\n        Connect two bipartite components `C_i` and `C_j` with an edge `(u, v)`, where `u \\in C_i` and `v \\in C_j`. This creates a new larger bipartite component.\n        Then, add another edge `(x, y)` within this new component such that `x` and `y` have the same color.\n        The minimum number of edges to achieve this is `t = 2`.\n        The number of ways for `t=2`:\n        We need to pick two distinct bipartite components.\n        Number of ways to pick two bipartite components: `num_bipartite_components * (num_bipartite_components - 1) / 2`.\n        For each pair of chosen components `C_i` and `C_j`:\n            Let `|C_i|` be the number of vertices in `C_i`, and `|C_j|` be the number of vertices in `C_j`.\n            The first edge can be added in `|C_i| * |C_j|` ways.\n            After adding `(u, v)`, `C_i` and `C_j` merge. The new component has `|C_i| + |C_j|` vertices.\n            The number of ways to pick `x, y` of same color *within* this new component:\n                If `u` was color 0 in `C_i` and `v` was color 0 in `C_j`, we can think of `C_j`'s coloring being flipped.\n                This is getting complicated.\n            A simpler perspective for `t=2`:\n            We need to connect two distinct vertices `u` and `v` that are in different connected components. Let `u` be in `Comp_A` and `v` be in `Comp_B`.\n            After adding `(u, v)`, `Comp_A` and `Comp_B` merge into a single component. This new component is bipartite.\n            To create an odd cycle, we need to add a second edge `(x, y)` such that `x` and `y` are of the same color in this *new* merged component.\n            The number of ways to connect two components and form an odd cycle:\n            Pick any two vertices `u` and `v` from different components. Add edge `(u, v)`. There are `(n - non_isolated_nodes) * non_isolated_nodes` ways if one is isolated, `(n - non_isolated_nodes) * (n - non_isolated_nodes - 1) / 2` if both are isolated, and `(total_nodes - num_bipartite_components) * num_bipartite_components` if one is a component and one is isolated.\n            This case is `t=2` because we need to connect two components, and then form an odd cycle within the resulting component.\n            The simplest way to get `t=2` is to pick two distinct nodes `u` and `v`. Add `(u,v)`. Then pick two distinct nodes `x` and `y`. Add `(x,y)`.\n            This is equivalent to: Pick two distinct bipartite components `C_i` and `C_j`. Pick `u \\in C_i` and `v \\in C_j`. Add edge `(u,v)`. Now `C_i` and `C_j` are merged into one large bipartite component. Now add another edge `(x, y)` between two vertices of the same color in this new component. This is not quite right.\n            The problem asks for minimum edges. If `t=1` is not possible, it means all bipartite components are \"small\" (e.g. `K_1`, `K_2`).\n            If there are at least two bipartite components, say `C_1` and `C_2`, we can pick any vertex `u` from `C_1` and any vertex `v` from `C_2`. Add edge `(u, v)`. Now `C_1` and `C_2` are merged into a single bipartite component.\n            To form an odd cycle, we need to add another edge `(x, y)` such that `x` and `y` have the same color.\n            This is only possible if the merged component has at least 3 vertices.\n            The number of ways for `t=2`:\n            Pick two distinct bipartite components `C_i` and `C_j`.\n            Pick any vertex `u` from `C_i` and any vertex `v` from `C_j`. Add edge `(u, v)`.\n            Now, the merged component is bipartite. The number of ways to add an edge `(x, y)` between same-colored vertices in this new component is `(count_0_new * (count_0_new - 1) / 2) + (count_1_new * (count_1_new - 1) / 2)`.\n            This is also complex.\n\n            Simpler `t=2` approach:\n            We need to connect two vertices `u` and `v` that are in different connected components. Let `u` be in `Comp_A` and `v` be in `Comp_B`.\n            Add edge `(u, v)`.\n            Then, we need to add another edge `(x, y)` to form an odd cycle.\n            If `Comp_A` and `Comp_B` are both bipartite, and we connect them, the resulting component is bipartite.\n            To make it non-bipartite, we need to add an edge between two vertices of the same color.\n            This implies we need to pick two vertices `u` and `v` from different components, and another two vertices `x` and `y` from different components, such that `(u,v)` and `(x,y)` are the added edges.\n            The crucial observation for `t=2` is that we can connect two *distinct* bipartite components, say `C_i` and `C_j`, by adding two edges `(u, v)` and `(x, y)` such that `u, x \\in C_i` and `v, y \\in C_j`.\n            If `u` and `x` have different colors in `C_i`, and `v` and `y` have different colors in `C_j`, then `u-v-y-x-u` forms an odd cycle of length 4+1=5.\n            This requires `C_i` to have at least two vertices, and `C_j` to have at least two vertices.\n            The number of ways:\n            Pick two distinct bipartite components `C_i` and `C_j`.\n            Pick two distinct vertices `u, x` from `C_i`.\n            Pick two distinct vertices `v, y` from `C_j`.\n            Add edges `(u, v)` and `(x, y)`.\n            Number of ways to pick `u, x` from `C_i`: `|C_i| * (|C_i| - 1) / 2`.\n            Number of ways to pick `v, y` from `C_j`: `|C_j| * (|C_j| - 1) / 2`.\n            Total ways for this pair of components: `(|C_i| * (|C_i| - 1) / 2) * (|C_j| * (|C_j| - 1) / 2)`.\n            Sum this over all pairs of distinct bipartite components.\n            This is `t=2`.\n            Let `S_comp` be the sum of `|C| * (|C| - 1) / 2` for all bipartite components `C`.\n            Then `w_2_ways = S_comp * (S_comp - 1) / 2`. (This is if we connect two pairs of nodes, one pair from one component and one pair from another).\n\n            A simpler `t=2` strategy:\n            Take any two distinct bipartite components `C_i` and `C_j`.\n            Pick any vertex `u` from `C_i` and any vertex `v` from `C_j`. Add edge `(u, v)`.\n            Now, `C_i` and `C_j` form a single bipartite component.\n            To make an odd cycle, we need to add another edge `(x, y)` such that `x` and `y` are in the same partition set of this new component.\n            This is possible if `num_bipartite_components >= 2`.\n            Let `N_bip` be the number of vertices in all bipartite components.\n            Let `N_iso` be the number of isolated vertices.\n            Let `N_total = N_bip + N_iso`.\n            Ways to pick `u` from `C_i` and `v` from `C_j` (where `C_i` and `C_j` are distinct bipartite components):\n            `total_bip_nodes = sum(|C_k| for all bipartite C_k)`\n            `w_2_ways = total_bip_nodes * (total_bip_nodes - 1) / 2 - sum(|C_k| * (|C_k| - 1) / 2 for all bipartite C_k)`\n            This counts pairs of nodes `(u, v)` that are in different bipartite components.\n            Each such pair forms a potential first edge.\n            If we add `(u,v)`, the two components merge.\n            The total number of vertices in bipartite components `sum_sizes = sum(|C_k| for all bipartite C_k)`.\n            The number of ways to choose 2 vertices from this set of vertices is `sum_sizes * (sum_sizes - 1) / 2`.\n            Subtract from this the pairs that are *within* the same component (which would lead to `t=1` if they were same-colored).\n            This is `sum_sizes * (sum_sizes - 1) / 2 - sum(|C_k| * (|C_k| - 1) / 2 for all bipartite C_k)`.\n            This is the number of ways to connect two *distinct* bipartite components with one edge.\n            Each such connection results in a larger bipartite component.\n            To make an odd cycle, we need to add *another* edge.\n            This is `t=2`.\n            The number of ways is `sum_sizes * (sum_sizes - 1) / 2 - sum(|C_k| * (|C_k| - 1) / 2 for all bipartite C_k)`\n            This is the number of ways to pick two vertices from different bipartite components. Let this be `W_diff_comp_pairs`.\n            Each such pair `(u,v)` forms a path of length 1.\n            If we add an edge `(u,v)`, the resulting component is still bipartite.\n            We need to add a second edge `(x,y)` to form an odd cycle.\n            The total number of available nodes is `n`.\n            If `num_bipartite_components >= 2`:\n                `t = 2`\n                `w = (total_nodes - isolated_nodes) * isolated_nodes` (connect a non-isolated to an isolated)\n                `w += (isolated_nodes * (isolated_nodes - 1) / 2)` (connect two isolated)\n                `w += total_bip_nodes * (total_bip_nodes - 1) / 2 - sum(|C_k| * (|C_k| - 1) / 2 for all bipartite C_k)` (connect two non-isolated from different components)\n                This sum is `n * (n - 1) / 2 - m_initial - w_1_ways`.\n                This is `n * (n - 1) / 2` (total possible edges) minus `m_initial` (existing edges) minus `w_1_ways` (edges that would cause `t=1`).\n                This is the total number of ways to add one edge such that it doesn't create an odd cycle (i.e., it either keeps the graph bipartite or is `t=1` but we already handled that).\n                This is the number of ways to add one edge that connects two different components. Each such edge creates a larger bipartite component.\n                Let `W_1_merge = (n * (n - 1) // 2) - m_initial - w_1_ways`.\n                If `W_1_merge > 0` and `num_bipartite_components >= 2`:\n                    `t = 2`\n                    `w = W_1_merge`.\n                    This counts the number of ways to add an edge that merges two components. Each such edge creates a larger bipartite component.\n                    This is the number of ways to add one edge `(u, v)` where `u` and `v` are in different connected components.\n                    After adding this edge, the graph is still bipartite. We need to add *another* edge.\n                    This is wrong. The question asks for the minimum number of edges to form an odd cycle.\n                    If `t=1` is not possible, we need at least 2 edges.\n                    If we have at least two bipartite components, say `C_A` and `C_B`.\n                    Pick `u \\in C_A`, `v \\in C_B`. Add `(u,v)`.\n                    Pick `x \\in C_A`, `y \\in C_B`. Add `(x,y)`.\n                    If `u` and `x` are of different colors in `C_A`, and `v` and `y` are of different colors in `C_B` (after potentially flipping colors of `C_B` for `(u,v)`), then `u-v-y-x-u` forms an odd cycle.\n                    The number of ways to do this:\n                    `ways_t2 = num_bipartite_components * (num_bipartite_components - 1) // 2` (pairs of components)\n                    For each pair `(C_i, C_j)`:\n                        `ways_nodes = |C_i| * |C_j| * (|C_i| - 1) * (|C_j| - 1) / 4` (this is `(c0_i*c1_j + c1_i*c0_j) * (c0_i*c1_j + c1_i*c0_j - 1) / 2` but this is complex)\n                    A simpler way for `t=2`:\n                    We need two distinct bipartite components.\n                    Let `N_bip_nodes` be the total number of vertices in all bipartite components (excluding isolated vertices).\n                    Let `N_iso_nodes` be the number of isolated vertices.\n                    Total number of vertices `n`.\n                    If `num_bipartite_components >= 2`:\n                        `t = 2`\n                        `w = N_bip_nodes * (N_bip_nodes - 1) // 2 - w_1_ways_if_any`\n                        This is the number of pairs of nodes `(u,v)` such that `u,v` are in different bipartite components.\n                        But this is for adding one edge. We need two edges.\n                        The number of ways to add two edges `(u,v)` and `(x,y)` where `u,x` are in `C_i` and `v,y` are in `C_j`:\n                        `w = (sum of |C_k| for all bipartite C_k) * (sum of |C_k| for all bipartite C_k - 1) / 2`\n                        This is the total number of pairs of nodes within the bipartite components.\n                        Subtract pairs within the same component: `sum(|C_k| * (|C_k| - 1) / 2)`.\n                        This is `W_diff_comp_pairs`.\n                        Each such pair forms a path of length 1.\n                        If we add `(u, v)` and `(x, y)` from `C_i` and `C_j` respectively, `u,x \\in C_i`, `v,y \\in C_j`.\n                        This forms an odd cycle if `u` and `x` have different colors in `C_i` AND `v` and `y` have different colors in `C_j`.\n                        Number of ways to pick `u,x` of different colors in `C_i`: `c0_i * c1_i`.\n                        Number of ways to pick `v,y` of different colors in `C_j`: `c0_j * c1_j`.\n                        Total ways for `C_i, C_j`: `(c0_i * c1_i) * (c0_j * c1_j)`.\n                        Sum this over all pairs of distinct bipartite components. This is `t=2`.\n                        `w_2_ways = (sum(c0_k * c1_k for all bipartite C_k))^2 / 2`\n                        No, it's `(sum(c0_k * c1_k))^2 - sum((c0_k * c1_k)^2) / 2`\n                        It's `(sum(c0_k * c1_k)) * (sum(c0_k * c1_k) - 1) / 2` if we pick two distinct pairs.\n                        Let `P_k = c0_k * c1_k`. We want `sum(P_i * P_j)` for `i < j`.\n                        This is `(sum(P_k))^2 - sum(P_k^2) / 2`.\n                        This means `t=2` and `w = sum_{i<j} (c0_i * c1_i * c0_j * c1_j)`. This can be computed as `(sum(c0_k * c1_k for all k))^2 - sum((c0_k * c1_k)^2 for all k)) / 2`.\n                        This is the correct `t=2` logic.\n\n    *   **Case `t = 3`:**\n        If `t=1` and `t=2` are not possible.\n        This means:\n        1.  No component has `c0 >= 2` or `c1 >= 2` (so `w_1_ways = 0`).\n        2.  There are not enough components to form `t=2` (i.e., `num_bipartite_components < 2`). This implies `num_bipartite_components` is 0 or 1.\n            If `num_bipartite_components = 0`, all vertices are isolated.\n            If `num_bipartite_components = 1`, there's one bipartite component and `n-num_nodes_in_comp` isolated nodes.\n            In this scenario, we must have `n >= 3`.\n            We need to pick three vertices `u, v, x` and add edges `(u, v), (v, x), (x, u)`. This forms a triangle, which is an odd cycle.\n            The number of ways to do this is `n * (n - 1) * (n - 2) / 6`.\n            This is `t = 3`.\n            `w = n * (n - 1) * (n - 2) // 6`.\n            This is the total number of ways to pick 3 vertices and connect them in a cycle.\n            This assumes no edges exist, but we must subtract existing edges.\n            However, since `t=0`, `t=1`, `t=2` were not possible, it means the graph is \"sparse\" enough that we can always find 3 nodes to connect.\n            The problem states \"simple cycle of odd length\". A triangle is the smallest odd cycle.\n            If `t=0, t=1, t=2` are not possible, it means the graph has no odd cycles, no way to add 1 edge to make an odd cycle (e.g. `K_1` or `K_2` components), and no way to add 2 edges to make an odd cycle (e.g. only one component, or components are all `K_1` or `K_2`).\n            In this case, `t=3` is the only option, by picking three distinct vertices `u, v, x` and adding edges `(u, v), (v, x), (x, u)`.\n            This requires `n >= 3`. The number of ways is `C(n, 3)`.\n            This is the general fallback. The problem implies we can always form a cycle.\n\n**Summary of cases:**\n\n1.  **Check for `t = 0`:**\n    Perform BFS/DFS for bipartiteness on all connected components.\n    If any component is found to be non-bipartite:\n        Print `0 1` and exit.\n\n2.  **If all components are bipartite (or isolated nodes):**\n    Calculate `w_1_ways`:\n    `w_1_ways = sum(c0_k * (c0_k - 1) // 2 + c1_k * (c1_k - 1) // 2 for all bipartite components C_k)`.\n    If `w_1_ways > 0`:\n        Print `1 w_1_ways` and exit.\n\n3.  **If `t = 0` and `t = 1` are not possible:**\n    Calculate `w_2_ways`:\n    Let `P_k = c0_k * c1_k` for each bipartite component `C_k`.\n    `sum_P = sum(P_k for all bipartite components C_k)`.\n    `sum_P_sq = sum(P_k * P_k for all bipartite components C_k)`.\n    `w_2_ways = (sum_P * sum_P - sum_P_sq) // 2`.\n    If `w_2_ways > 0`:\n        Print `2 w_2_ways` and exit.\n\n4.  **If `t = 0`, `t = 1`, and `t = 2` are not possible:**\n    This means `n >= 3` must hold.\n    Print `3 (n * (n - 1) * (n - 2) // 6)` and exit.\n\n**Example Walkthroughs:**\n\n*   **Example 1:**\n    `4 4`\n    `1 2`\n    `1 3`\n    `4 2`\n    `4 3`\n    Graph: `1-2`, `1-3`, `4-2`, `4-3`.\n    Component 1: `1,2,3,4`.\n    BFS from 1:\n    `color[1]=0`\n    `color[2]=1` (from 1)\n    `color[3]=1` (from 1)\n    `color[4]=0` (from 2)\n    Neighbor of 4 is 3. `color[4]=0`, `color[3]=1`. OK.\n    This component is bipartite.\n    `C_0 = {1, 4}`, `C_1 = {2, 3}`.\n    `c0 = 2`, `c1 = 2`.\n    `w_1_ways = (2 * (2-1) // 2) + (2 * (2-1) // 2) = 1 + 1 = 2`.\n    Output: `1 2`. Correct.\n\n*   **Example 2:**\n    `3 3`\n    `1 2`\n    `2 3`\n    `3 1`\n    Graph: `1-2`, `2-3`, `3-1`. This is a triangle `K_3`.\n    BFS from 1:\n    `color[1]=0`\n    `color[2]=1` (from 1)\n    `color[3]=1` (from 2)\n    Neighbor of 3 is 1. `color[3]=1`, `color[1]=0`. OK.\n    Neighbor of 3 is 2. `color[3]=1`, `color[2]=1`. `color[3] == color[2]`. Not bipartite!\n    Output: `0 1`. Correct.\n\n*   **Example 3:**\n    `3 0`\n    Graph: `1`, `2`, `3` (three isolated vertices).\n    BFS from 1: `color[1]=0`. `c0=1, c1=0`. Bipartite.\n    BFS from 2: `color[2]=0`. `c0=1, c1=0`. Bipartite.\n    BFS from 3: `color[3]=0`. `c0=1, c1=0`. Bipartite.\n    All components are bipartite.\n    `w_1_ways = (1*(0)//2 + 0*( -1)//2) * 3 = 0`.\n    `t=1` not possible.\n    `w_2_ways`:\n    Components: `C_1={1}, C_2={2}, C_3={3}`.\n    `P_1 = c0_1 * c1_1 = 1 * 0 = 0`.\n    `P_2 = c0_2 * c1_2 = 1 * 0 = 0`.\n    `P_3 = c0_3 * c1_3 = 1 * 0 = 0`.\n    `sum_P = 0`.\n    `sum_P_sq = 0`.\n    `w_2_ways = (0 * 0 - 0) // 2 = 0`.\n    `t=2` not possible.\n    Fallback to `t=3`:\n    `n = 3`.\n    `w = 3 * (3-1) * (3-2) // 6 = 3 * 2 * 1 // 6 = 1`.\n    Output: `3 1`. Correct.\n\n**Implementation Details:**\n\n*   Use an adjacency list for the graph.\n*   `visited` and `color` arrays should be 1-indexed for convenience (or adjust to 0-indexed).\n*   BFS is generally easier to implement than DFS for bipartiteness check.\n*   Be careful with integer division (`//`).\n*   The maximum `n` is 1000, so `O(N+M)` for BFS is fine. `N^3` for `t=3` ways is `1000^3` which is too large. `C(N,3)` is `N*(N-1)*(N-2)/6`. `1000*999*998/6` is about `1.6 * 10^8`, which is acceptable for `w`.\n\n```python\nimport sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n\n    visited = [False] * (n + 1)\n    color = [-1] * (n + 1) # -1: uncolored, 0: color A, 1: color B\n\n    bipartite_components_info = [] # Stores (count_0, count_1) for each bipartite component\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            q = deque()\n            q.append(i)\n            visited[i] = True\n            color[i] = 0\n            \n            current_component_is_bipartite = True\n            current_c0 = 0\n            current_c1 = 0\n            \n            component_nodes = [] # To iterate and count after BFS\n            component_nodes.append(i)\n\n            head = 0 # Manual queue for slightly better performance than deque for this problem size\n            while head < len(q):\n                u = q[head]\n                head += 1\n\n                if color[u] == 0:\n                    current_c0 += 1\n                else:\n                    current_c1 += 1\n\n                for v in adj[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        color[v] = 1 - color[u]\n                        q.append(v)\n                        component_nodes.append(v)\n                    elif color[v] == color[u]:\n                        current_component_is_bipartite = False\n            \n            # After BFS for a component\n            if not current_component_is_bipartite:\n                # Found an odd cycle in the initial graph\n                print(\"0 1\")\n                return\n            \n            # If the component is bipartite, store its coloring info\n            # We need to re-count c0, c1 because the BFS counts them as they are dequeued\n            # And if a component is not bipartite, current_c0/c1 might be incomplete.\n            # So, re-count for bipartite components\n            temp_c0 = 0\n            temp_c1 = 0\n            for node in component_nodes:\n                if color[node] == 0:\n                    temp_c0 += 1\n                else:\n                    temp_c1 += 1\n            bipartite_components_info.append((temp_c0, temp_c1))\n\n    # If we reached here, no odd cycle exists in the initial graph (t > 0)\n\n    # Case t = 1: Add one edge to form an odd cycle\n    # This requires adding an edge between two vertices of the same color within a bipartite component.\n    w_t1 = 0\n    for c0, c1 in bipartite_components_info:\n        w_t1 += c0 * (c0 - 1) // 2 # Ways to pick 2 from color 0\n        w_t1 += c1 * (c1 - 1) // 2 # Ways to pick 2 from color 1\n    \n    if w_t1 > 0:\n        print(f\"1 {w_t1}\")\n        return\n\n    # Case t = 2: Add two edges to form an odd cycle\n    # This requires picking two distinct bipartite components (C_i, C_j),\n    # then picking two distinct vertices u, x from C_i, and two distinct vertices v, y from C_j.\n    # Add edges (u,v) and (x,y). This forms an odd cycle if u,x have different colors in C_i\n    # and v,y have different colors in C_j.\n    # Number of ways to pick u,x of different colors in C_i is c0_i * c1_i.\n    # Number of ways to pick v,y of different colors in C_j is c0_j * c1_j.\n    # We sum (c0_i * c1_i) * (c0_j * c1_j) for all distinct pairs (C_i, C_j).\n    \n    # Let P_k = c0_k * c1_k for component k.\n    # We want sum_{i<j} (P_i * P_j).\n    # This is ( (sum P_k)^2 - sum (P_k^2) ) / 2\n    \n    sum_P = 0\n    sum_P_sq = 0\n    for c0, c1 in bipartite_components_info:\n        P_k = c0 * c1\n        sum_P += P_k\n        sum_P_sq += P_k * P_k\n    \n    w_t2 = (sum_P * sum_P - sum_P_sq) // 2\n\n    if w_t2 > 0:\n        print(f\"2 {w_t2}\")\n        return\n\n    # Case t = 3: Add three edges to form an odd cycle (a triangle)\n    # This is the fallback if t=0, t=1, t=2 are not possible.\n    # It requires picking 3 distinct vertices and connecting them into a triangle.\n    # This is possible if n >= 3.\n    # The number of ways to pick 3 vertices from n is C(n, 3).\n    \n    # We must ensure that n >= 3. If n < 3, it's impossible to form any cycle.\n    # The problem statement implies a cycle can always be formed.\n    # If n < 3, this implies edge cases that might not be covered by current logic.\n    # For competitive programming, usually constraints ensure n >= 3 if t=3 is expected.\n    # The smallest cycle is 3 vertices. If n < 3, a cycle is impossible.\n    # But for n=0,1,2, no cycle can be formed. The problem statement guarantees n>=1.\n    # If n=1,2, no cycle. Output for n=1,2 is undefined by the problem.\n    # Assuming n >= 3 when we reach this point.\n    \n    w_t3 = n * (n - 1) * (n - 2) // 6\n    print(f\"3 {w_t3}\")\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n\n    visited = [False] * (n + 1)\n    color = [-1] * (n + 1) # -1: uncolored, 0: color A, 1: color B\n\n    bipartite_components_info = [] # Stores (count_0, count_1) for each bipartite component\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            q = deque()\n            q.append(i)\n            visited[i] = True\n            color[i] = 0\n            \n            current_component_is_bipartite = True\n            current_c0 = 0\n            current_c1 = 0\n            \n            component_nodes = [] # To iterate and count after BFS\n            component_nodes.append(i)\n\n            head = 0 # Manual queue for slightly better performance than deque for this problem size\n            while head < len(q):\n                u = q[head]\n                head += 1\n\n                if color[u] == 0:\n                    current_c0 += 1\n                else:\n                    current_c1 += 1\n\n                for v in adj[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        color[v] = 1 - color[u]\n                        q.append(v)\n                        component_nodes.append(v)\n                    elif color[v] == color[u]:\n                        current_component_is_bipartite = False\n            \n            # After BFS for a component\n            if not current_component_is_bipartite:\n                # Found an odd cycle in the initial graph\n                print(\"0 1\")\n                return\n            \n            # If the component is bipartite, store its coloring info\n            # We need to re-count c0, c1 because the BFS counts them as they are dequeued\n            # And if a component is not bipartite, current_c0/c1 might be incomplete.\n            # So, re-count for bipartite components\n            temp_c0 = 0\n            temp_c1 = 0\n            for node in component_nodes:\n                if color[node] == 0:\n                    temp_c0 += 1\n                else:\n                    temp_c1 += 1\n            bipartite_components_info.append((temp_c0, temp_c1))\n\n    # If we reached here, no odd cycle exists in the initial graph (t > 0)\n\n    # Case t = 1: Add one edge to form an odd cycle\n    # This requires adding an edge between two vertices of the same color within a bipartite component.\n    w_t1 = 0\n    for c0, c1 in bipartite_components_info:\n        w_t1 += c0 * (c0 - 1) // 2 # Ways to pick 2 from color 0\n        w_t1 += c1 * (c1 - 1) // 2 # Ways to pick 2 from color 1\n    \n    if w_t1 > 0:\n        print(f\"1 {w_t1}\")\n        return\n\n    # Case t = 2: Add two edges to form an odd cycle\n    # This requires picking two distinct bipartite components (C_i, C_j),\n    # then picking two distinct vertices u, x from C_i, and two distinct vertices v, y from C_j.\n    # Add edges (u,v) and (x,y). This forms an odd cycle if u,x have different colors in C_i\n    # and v,y have different colors in C_j.\n    # Number of ways to pick u,x of different colors in C_i is c0_i * c1_i.\n    # Number of ways to pick v,y of different colors in C_j is c0_j * c1_j.\n    # We sum (c0_i * c1_i) * (c0_j * c1_j) for all distinct pairs (C_i, C_j).\n    \n    # Let P_k = c0_k * c1_k for component k.\n    # We want sum_{i<j} (P_i * P_j).\n    # This is ( (sum P_k)^2 - sum (P_k^2) ) / 2\n    \n    sum_P = 0\n    sum_P_sq = 0\n    for c0, c1 in bipartite_components_info:\n        P_k = c0 * c1\n        sum_P += P_k\n        sum_P_sq += P_k * P_k\n    \n    w_t2 = (sum_P * sum_P - sum_P_sq) // 2\n\n    if w_t2 > 0:\n        print(f\"2 {w_t2}\")\n        return\n\n    # Case t = 3: Add three edges to form an odd cycle (a triangle)\n    # This is the fallback if t=0, t=1, t=2 are not possible.\n    # It requires picking 3 distinct vertices and connecting them into a triangle.\n    # This is possible if n >= 3.\n    # The number of ways to pick 3 vertices from n is C(n, 3).\n    \n    # We must ensure that n >= 3. If n < 3, it's impossible to form any cycle.\n    # The problem statement implies a cycle can always be formed.\n    # If n < 3, this implies edge cases that might not be covered by current logic.\n    # For competitive programming, usually constraints ensure n >= 3 if t=3 is expected.\n    # The smallest cycle is 3 vertices. If n < 3, a cycle is impossible.\n    # But for n=0,1,2, no cycle can be formed. The problem statement guarantees n>=1.\n    # If n=1,2, no cycle. Output for n=1,2 is undefined by the problem.\n    # Assuming n >= 3 when we reach this point.\n    \n    w_t3 = n * (n - 1) * (n - 2) // 6\n    print(f\"3 {w_t3}\")\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 603,
        "completion_token_count": 9209,
        "thoughts_token_count": 791
    }
}