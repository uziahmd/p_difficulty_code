{
    "start": 1758285046.3089218,
    "end": 1758285069.181514,
    "start-formatted": "2025-09-19 21:30 KST",
    "end-formatted": "2025-09-19 21:31 KST",
    "gpu": 2,
    "pid": 30,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# TV Game\n\nThere is a new TV game on BerTV. In this game two players get a number A consisting of 2n digits. Before each turn players determine who will make the next move. Each player should make exactly n moves. On it's turn i-th player takes the leftmost digit of A and appends it to his or her number Si. After that this leftmost digit is erased from A. Initially the numbers of both players (S1 and S2) are «empty». Leading zeroes in numbers A, S1, S2 are allowed. In the end of the game the first player gets S1 dollars, and the second gets S2 dollars.One day Homer and Marge came to play the game. They managed to know the number A beforehand. They want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize. Help them.\n\n## Input\nThe first line contains integer n (1 ≤ n ≤ 18). The second line contains integer A consisting of exactly 2n digits. This number can have leading zeroes.\n\n## Output\nOutput the line of 2n characters «H» and «M» — the sequence of moves of Homer and Marge, which gives them maximum possible total prize. Each player must make exactly n moves. If there are several solutions, output any of them.\n\n## Example\n### Input\n['2\\n1234', '2\\n9911']\n\n### Output\n['HHMM', 'HMHM']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "**Initial Thoughts and Problem Decomposition**\n\nOkay, so I'm tackling this \"TV Game\" problem. The core of it seems straightforward: two players, Homer and Marge, are competing to maximize the sum of their numbers. They're given a number `A` with an even number of digits (`2n`), and they take turns consuming digits from the left.  The goal is to determine the optimal sequence of moves to maximize the combined sum of their resulting numbers, `S1` (Homer) and `S2` (Marge).  The constraint on the size of `n` is important to note - this will influence my choice of algorithm.\n\n**Understanding the Gameplay and Examples**\n\nThe problem description is clear.  I need to consider all possible sequences of moves (H or M).  I've already started sketching out how this would work: keep track of `S1` and `S2` as digits are removed from the beginning of `A`, which is crucial. The example cases are helpful for confirming my understanding of the rules and to establish a sanity check for my implementation. `HHMM` looks promising for a strategy where higher digits are taken first. But the second example suggests this isn't universally true - the best strategy isn't necessarily just taking the largest digits possible.\n\n**Forming a Plan and Strategy**\n\nThe main challenge seems to be the combinatorial explosion of possibilities with each turn. I'll need to explore different sequences efficiently. It looks like the key is figuring out the most advantageous digit to take at each turn, and this depends on the *current* state of the game, i.e., how many digits each player has. If I can figure out the structure of a good move, I can hopefully reduce the complexity of the solution. The core problem is finding a way to efficiently explore the space of possible move sequences without exhaustively checking all possibilities, which will become computationally prohibitive for even moderate values of `n`. Dynamic programming or a recursive approach with memoization might be viable options here.\n",
    "response": "```python\nimport sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n    a_str = sys.stdin.readline().strip()\n\n    # dp[i][j] stores a tuple: (max_total_sum, sequence_of_moves)\n    # where i is the number of moves Homer has made,\n    # and j is the number of moves Marge has made.\n    # The current index in a_str is i + j.\n    \n    # Initialize DP table\n    # The size of dp table is (n+1) x (n+1)\n    dp = [[(0, \"\") for _ in range(n + 1)] for _ in range(n + 1)]\n\n    # Iterate through the total number of moves from 0 to 2n-1\n    for total_moves in range(2 * n):\n        # Iterate through possible counts of Homer's moves (h_moves)\n        # h_moves can range from max(0, total_moves - n) to min(n, total_moves)\n        # This ensures m_moves = total_moves - h_moves is also <= n\n        for h_moves in range(max(0, total_moves - n), min(n, total_moves) + 1):\n            m_moves = total_moves - h_moves\n            \n            # We are calculating dp[h_moves][m_moves] based on previous states.\n            # However, the loop structure iterates 'total_moves' first.\n            # This means we are building up the DP table layer by layer,\n            # where each layer corresponds to a fixed 'total_moves'.\n            # When we are at 'total_moves', we are considering adding the digit a_str[total_moves].\n            # We need to look at dp[h_moves-1][m_moves] and dp[h_moves][m_moves-1].\n            \n            # The digit being considered for the current turn (total_moves)\n            current_digit = int(a_str[total_moves])\n            \n            # Option 1: Homer takes the current digit\n            # This is possible if Homer has made less than n moves so far (h_moves < n)\n            # and if this is not the very first move (h_moves > 0)\n            if h_moves > 0: # Homer must have made h_moves, so previous state was h_moves-1\n                prev_h_moves = h_moves - 1\n                prev_m_moves = m_moves\n                \n                prev_sum, prev_seq = dp[prev_h_moves][prev_m_moves]\n                \n                # The value of the digit depends on its position in Homer's number.\n                # If Homer has already made prev_h_moves moves, this digit will be at position prev_h_moves.\n                # Its value contribution is current_digit * (10^(n - 1 - prev_h_moves))\n                # Note: n - 1 - prev_h_moves is the exponent for the 'ones' place if we count from right.\n                # The problem statement says \"appends it to his or her number Si\",\n                # which implies it's appended to the right.\n                # So if S1 = \"d1d2\", and Homer takes 'd3', S1 becomes \"d1d2d3\".\n                # The value of 'd3' is just d3.\n                # No, this is wrong. It means S1 is a number like 123.\n                # If H takes '1', S1=\"1\". If H takes '2', S1=\"12\". If H takes '3', S1=\"123\".\n                # The value is 100*1 + 10*2 + 1*3.\n                # The current digit `current_digit` contributes to the `(n - h_moves)`-th position from the left\n                # (0-indexed, so `n - h_moves - 1` if it was 0-indexed exponent).\n                # Example: n=2. Homer makes 2 moves.\n                # H takes '1'. S1=\"1\". h_moves=1. Position in S1 is 0. Exponent is 2-1-0 = 1.\n                # H takes '2'. S1=\"12\". h_moves=2. Position in S1 is 1. Exponent is 2-2-1 = -1? No.\n                # It's `n - h_moves` where h_moves is the *new* count of moves.\n                # If S1 has length `L`, and a digit `d` is appended, `S1_new = S1_old * 10 + d`.\n                # This means the value of `d` is `d`.\n                # The value of `S1` is `int(S1_string)`.\n                # So, if Homer takes the `k`-th digit (0-indexed from A),\n                # and this is his `p`-th digit (0-indexed) for S1,\n                # then its contribution to S1's value is `digit * 10^(n-1-p)`.\n                # `p` is `prev_h_moves`.\n                \n                homer_val_contribution = current_digit * (10**(n - 1 - prev_h_moves))\n                \n                new_sum = prev_sum + homer_val_contribution\n                new_seq = prev_seq + \"H\"\n                \n                # Update dp[h_moves][m_moves] if this path is better\n                if new_sum > dp[h_moves][m_moves][0]:\n                    dp[h_moves][m_moves] = (new_sum, new_seq)\n\n            # Option 2: Marge takes the current digit\n            # This is possible if Marge has made less than n moves so far (m_moves < n)\n            # and if this is not the very first move (m_moves > 0)\n            if m_moves > 0: # Marge must have made m_moves, so previous state was m_moves-1\n                prev_h_moves = h_moves\n                prev_m_moves = m_moves - 1\n                \n                prev_sum, prev_seq = dp[prev_h_moves][prev_m_moves]\n\n                # The value of the digit depends on its position in Marge's number.\n                # If Marge has already made prev_m_moves moves, this digit will be at position prev_m_moves.\n                # Its value contribution is current_digit * (10^(n - 1 - prev_m_moves))\n                marge_val_contribution = current_digit * (10**(n - 1 - prev_m_moves))\n\n                new_sum = prev_sum + marge_val_contribution\n                new_seq = prev_seq + \"M\"\n                \n                # Update dp[h_moves][m_moves] if this path is better\n                if new_sum > dp[h_moves][m_moves][0]:\n                    dp[h_moves][m_moves] = (new_sum, new_seq)\n                \n    # The final answer is at dp[n][n]\n    print(dp[n][n][1])\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n    a_str = sys.stdin.readline().strip()\n\n    # dp[i][j] stores a tuple: (max_total_sum, sequence_of_moves)\n    # where i is the number of moves Homer has made,\n    # and j is the number of moves Marge has made.\n    # The current index in a_str is i + j.\n    \n    # Initialize DP table\n    # The size of dp table is (n+1) x (n+1)\n    dp = [[(0, \"\") for _ in range(n + 1)] for _ in range(n + 1)]\n\n    # Iterate through the total number of moves from 0 to 2n-1\n    for total_moves in range(2 * n):\n        # Iterate through possible counts of Homer's moves (h_moves)\n        # h_moves can range from max(0, total_moves - n) to min(n, total_moves)\n        # This ensures m_moves = total_moves - h_moves is also <= n\n        for h_moves in range(max(0, total_moves - n), min(n, total_moves) + 1):\n            m_moves = total_moves - h_moves\n            \n            # We are calculating dp[h_moves][m_moves] based on previous states.\n            # However, the loop structure iterates 'total_moves' first.\n            # This means we are building up the DP table layer by layer,\n            # where each layer corresponds to a fixed 'total_moves'.\n            # When we are at 'total_moves', we are considering adding the digit a_str[total_moves].\n            # We need to look at dp[h_moves-1][m_moves] and dp[h_moves][m_moves-1].\n            \n            # The digit being considered for the current turn (total_moves)\n            current_digit = int(a_str[total_moves])\n            \n            # Option 1: Homer takes the current digit\n            # This is possible if Homer has made less than n moves so far (h_moves < n)\n            # and if this is not the very first move (h_moves > 0)\n            if h_moves > 0: # Homer must have made h_moves, so previous state was h_moves-1\n                prev_h_moves = h_moves - 1\n                prev_m_moves = m_moves\n                \n                prev_sum, prev_seq = dp[prev_h_moves][prev_m_moves]\n                \n                # The value of the digit depends on its position in Homer's number.\n                # If Homer has already made prev_h_moves moves, this digit will be at position prev_h_moves.\n                # Its value contribution is current_digit * (10^(n - 1 - prev_h_moves))\n                # Note: n - 1 - prev_h_moves is the exponent for the 'ones' place if we count from right.\n                # The problem statement says \"appends it to his or her number Si\",\n                # which implies it's appended to the right.\n                # So if S1 = \"d1d2\", and Homer takes 'd3', S1 becomes \"d1d2d3\".\n                # The value of 'd3' is just d3.\n                # No, this is wrong. It means S1 is a number like 123.\n                # If H takes '1', S1=\"1\". If H takes '2', S1=\"12\". If H takes '3', S1=\"123\".\n                # The value is 100*1 + 10*2 + 1*3.\n                # The current digit `current_digit` contributes to the `(n - h_moves)`-th position from the left\n                # (0-indexed, so `n - h_moves - 1` if it was 0-indexed exponent).\n                # Example: n=2. Homer makes 2 moves.\n                # H takes '1'. S1=\"1\". h_moves=1. Position in S1 is 0. Exponent is 2-1-0 = 1.\n                # H takes '2'. S1=\"12\". h_moves=2. Position in S1 is 1. Exponent is 2-2-1 = -1? No.\n                # It's `n - h_moves` where h_moves is the *new* count of moves.\n                # If S1 has length `L`, and a digit `d` is appended, `S1_new = S1_old * 10 + d`.\n                # This means the value of `d` is `d`.\n                # The value of `S1` is `int(S1_string)`.\n                # So, if Homer takes the `k`-th digit (0-indexed from A),\n                # and this is his `p`-th digit (0-indexed) for S1,\n                # then its contribution to S1's value is `digit * 10^(n-1-p)`.\n                # `p` is `prev_h_moves`.\n                \n                homer_val_contribution = current_digit * (10**(n - 1 - prev_h_moves))\n                \n                new_sum = prev_sum + homer_val_contribution\n                new_seq = prev_seq + \"H\"\n                \n                # Update dp[h_moves][m_moves] if this path is better\n                if new_sum > dp[h_moves][m_moves][0]:\n                    dp[h_moves][m_moves] = (new_sum, new_seq)\n\n            # Option 2: Marge takes the current digit\n            # This is possible if Marge has made less than n moves so far (m_moves < n)\n            # and if this is not the very first move (m_moves > 0)\n            if m_moves > 0: # Marge must have made m_moves, so previous state was m_moves-1\n                prev_h_moves = h_moves\n                prev_m_moves = m_moves - 1\n                \n                prev_sum, prev_seq = dp[prev_h_moves][prev_m_moves]\n\n                # The value of the digit depends on its position in Marge's number.\n                # If Marge has already made prev_m_moves moves, this digit will be at position prev_m_moves.\n                # Its value contribution is current_digit * (10^(n - 1 - prev_m_moves))\n                marge_val_contribution = current_digit * (10**(n - 1 - prev_m_moves))\n\n                new_sum = prev_sum + marge_val_contribution\n                new_seq = prev_seq + \"M\"\n                \n                # Update dp[h_moves][m_moves] if this path is better\n                if new_sum > dp[h_moves][m_moves][0]:\n                    dp[h_moves][m_moves] = (new_sum, new_seq)\n                \n    # The final answer is at dp[n][n]\n    print(dp[n][n][1])\n\nsolve()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 431,
        "completion_token_count": 1686,
        "thoughts_token_count": 839
    }
}