{
    "start": 1758294944.8323984,
    "end": 1758295013.096837,
    "start-formatted": "2025-09-20 00:15 KST",
    "end-formatted": "2025-09-20 00:16 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "**Okay, here's my understanding of the problem and the solution:**\n\nI'm tackling a competitive programming challenge.  My goal is to figure out two things: the smallest number of nodes (`n`) needed to build a specific kind of directed graph, and the most unidirectional pairs of nodes possible within that graph.  This graph has to be \"p-reachable,\" which means there need to be exactly *p* ordered pairs of nodes (u, v) where u is smaller than v, and there's a path from u to v and also from v back to u.  These pairs, where u and v are reachable from each other, are what contribute to the value `p`.  Unidirectional pairs mean that there's a path from one node to another, but no path in the reverse direction.\n\nTo find the minimum `n`, I've realized it's all about grouping nodes into strongly connected components (SCCs).  If I have a group of `k` nodes in an SCC, I get `k*(k-1)/2` pairs where nodes are mutually reachable (u < v).  To minimize the total number of nodes, I want to pack as many nodes as possible into a single, big SCC, and then use smaller SCCs to account for any remaining pairs, but the greedy approach minimizes the number of nodes. I need the biggest SCC first, then the next biggest and so on.\n\nThe main idea is to greedily build SCCs to cover `p`. I repeatedly find the largest SCC size that I can use without exceeding the required number of reachable pairs `p`. The math is pretty straightforward, I repeatedly calculate the largest integer `k` such that `k * (k - 1) / 2` is less than or equal to the current remaining `p` value, and use that `k` as a SCC size. The number of nodes `n` is then the sum of all the SCC sizes I found using the greedy method.\n\nFor maximizing the unidirectional pairs, it turns out that I want to create a special structure in the graph. The maximum number of unidirectional pairs happens when the graph's SCCs are arranged in a specific \"linear\" order. I take the SCCs that I calculated for minimum `n`, and construct a directed graph where there's a path from one SCC to the next in a linear \"line\" but with no cycles between them, so that unidirectional pairs are maximized.  This way, any pair (u, v) where *u* comes from an SCC that is earlier in the linear order than *v*'s SCC will have a path but cannot go back, making it unidirectional.\n\nMathematically, the number of unidirectional pairs comes out to be `(n^2 - sum of the squares of all SCC sizes) / 2`.  So, I just need to compute the sum of squares and plug it into that formula, and I will have my answer. In the implementation, I found a way to use the integer square root function, which speeds up the calculation.",
    "response": "The problem asks us to find two values for a given integer `p`:\n1. The minimum number of nodes `n` required to create a directed graph that has exactly `p` ordered pairs of nodes `(u, v)` such that `u < v` and `u` and `v` are reachable from each other.\n2. Among all such graphs with the minimum number of nodes `n`, the maximum possible number of unidirectional pairs of nodes. An ordered pair `(u, v)` is unidirectional if `u != v`, there's a path from `u` to `v`, and no path from `v` to `u`.\n\nLet's break down the definitions and solve each part.\n\n**Part 1: Minimum number of nodes `n`**\n\nThe condition \"u and v are reachable from each other\" means that `u` and `v` belong to the same Strongly Connected Component (SCC). If an SCC has `k` nodes, then any two distinct nodes `u, v` within this SCC are mutually reachable. The number of ordered pairs `(u, v)` with `u < v` from this SCC is `k * (k - 1) / 2`.\n\nIf a graph has multiple SCCs with sizes `k_1, k_2, ..., k_m`, the total number of `u < v` pairs where `u` and `v` are mutually reachable is `sum_{i=1 to m} (k_i * (k_i - 1) / 2)`. The total number of nodes in the graph is `n = sum_{i=1 to m} k_i`.\n\nTo minimize `n` for a given `p`, we should try to use as few SCCs as possible, and each SCC should be as large as possible. This is because the function `f(k) = k * (k - 1) / 2` grows quadratically, meaning larger `k` values are more \"efficient\" in producing pairs relative to the number of nodes `k`.\n\nThis leads to a greedy strategy:\n1. Start with `current_p = p` and `min_n = 0`. Initialize an empty list `scc_sizes` to store the sizes of the SCCs.\n2. While `current_p > 0`:\n   a. Find the largest integer `k` such that `k * (k - 1) / 2 <= current_p`. This `k` represents the size of the next SCC we will form.\n   b. The inequality `k * (k - 1) / 2 <= current_p` can be rewritten as `k^2 - k - 2 * current_p <= 0`. The positive root of `x^2 - x - 2 * current_p = 0` is `x = (1 + sqrt(1 + 8 * current_p)) / 2`. Since the quadratic opens upwards, `k` must be less than or equal to this root. Thus, `k = floor((1 + sqrt(1 + 8 * current_p)) / 2)`.\n   c. Add `k` to `min_n`.\n   d. Add `k` to `scc_sizes`.\n   e. Subtract `k * (k - 1) / 2` from `current_p`.\n3. After the loop, `min_n` will hold the minimum number of nodes.\n\nExample: `p = 4`\n- `current_p = 4`. `k = floor((1 + sqrt(1 + 8*4))/2) = floor((1 + sqrt(33))/2) = floor((1 + 5.74)/2) = 3`.\n- `min_n = 3`. `scc_sizes = [3]`. `current_p = 4 - (3 * 2 / 2) = 4 - 3 = 1`.\n- `current_p = 1`. `k = floor((1 + sqrt(1 + 8*1))/2) = floor((1 + 3)/2) = 2`.\n- `min_n = 3 + 2 = 5`. `scc_sizes = [3, 2]`. `current_p = 1 - (2 * 1 / 2) = 1 - 1 = 0`.\n- Loop ends. `min_n = 5`.\n\n**Part 2: Maximum number of unidirectional pairs**\n\nA pair `(u, v)` is unidirectional if `u != v`, there's a path `u -> v`, and no path `v -> u`. This occurs when `u` and `v` are in different SCCs, say `u \\in C_i` and `v \\in C_j`, and there is a path from `C_i` to `C_j` in the condensation graph (DAG of SCCs), but no path from `C_j` to `C_i`.\n\nTo maximize the number of unidirectional pairs, we should arrange the SCCs (`C_1, C_2, ..., C_m` with sizes `k_1, k_2, ..., k_m` from Part 1) in a linear fashion, forming a \"chain\" in the condensation graph: `C_1 -> C_2 -> ... -> C_m`.\nIn this arrangement, for any `i < j`, there is a path from any node in `C_i` to any node in `C_j`. Since they are distinct SCCs, there's no path from `C_j` to `C_i`.\nThus, all `k_i * k_j` pairs `(u, v)` where `u \\in C_i` and `v \\in C_j` for `i < j` are unidirectional.\n\nThe total number of such unidirectional pairs is `sum_{1 <= i < j <= m} (k_i * k_j)`.\nThis sum can be calculated using the identity:\n`(sum_{i=1 to m} k_i)^2 = sum_{i=1 to m} k_i^2 + 2 * sum_{1 <= i < j <= m} (k_i * k_j)`.\nSince `sum_{i=1 to m} k_i = min_n`, we have:\n`min_n^2 = sum_{i=1 to m} k_i^2 + 2 * (max_unidirectional_pairs)`.\nTherefore, `max_unidirectional_pairs = (min_n^2 - sum_{i=1 to m} k_i^2) / 2`.\n\nWe already have `min_n` and the list `scc_sizes` (which are `k_i` values). We just need to calculate `sum_{i=1 to m} k_i^2`.\n\nExample: `p = 4`\n- From Part 1, `min_n = 5` and `scc_sizes = [3, 2]`.\n- `sum_k_sq = 3^2 + 2^2 = 9 + 4 = 13`.\n- `max_unidirectional_pairs = (5^2 - 13) / 2 = (25 - 13) / 2 = 12 / 2 = 6`.\n\n**Edge Case: `p = 0`**\n- If `p = 0`, no mutually reachable pairs are needed. This can be achieved with `0` nodes.\n- `min_n = 0`. `scc_sizes` is empty. `sum_k_sq = 0`.\n- `max_unidirectional_pairs = (0^2 - 0) / 2 = 0`.\n- Output: `0 0`.\n\nThe maximum value of `p` is `2 * 10^5`.\n`min_n` will be at most around `633` (since `633 * 632 / 2` is approximately `2 * 10^5`).\n`min_n^2` will be around `633^2 approx 4 * 10^5`.\n`sum_k_sq` will also be in a similar range.\nAll calculations fit within standard integer types. Python's arbitrary-precision integers handle this automatically.\n\n```python\nimport math\n\ndef solve():\n    p = int(input())\n\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    min_n = 0\n    scc_sizes = [] # Stores the k_i values\n\n    current_p = p\n    while current_p > 0:\n        # Find the largest integer k such that k*(k-1)/2 <= current_p\n        # This is equivalent to k <= (1 + sqrt(1 + 8*current_p)) / 2\n        # math.isqrt computes the integer square root (floor(sqrt(x)))\n        k = (1 + math.isqrt(1 + 8 * current_p)) // 2\n        \n        min_n += k\n        scc_sizes.append(k)\n        current_p -= (k * (k - 1)) // 2\n\n    sum_k_sq = 0\n    for k_val in scc_sizes:\n        sum_k_sq += k_val * k_val\n    \n    # The maximum number of unidirectional pairs is achieved by arranging\n    # the SCCs in a line (C_1 -> C_2 -> ... -> C_m).\n    # For any u in C_i and v in C_j with i < j, (u,v) is a unidirectional pair.\n    # The total number of such pairs is sum_{i < j} (k_i * k_j).\n    # This can be calculated as ((sum k_i)^2 - sum k_i^2) / 2.\n    # Here, sum k_i = min_n.\n    max_unidirectional_pairs = (min_n * min_n - sum_k_sq) // 2\n\n    print(min_n, max_unidirectional_pairs)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef solve():\n    p = int(input())\n\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    min_n = 0\n    scc_sizes = [] # Stores the k_i values\n\n    current_p = p\n    while current_p > 0:\n        # Find the largest integer k such that k*(k-1)/2 <= current_p\n        # This is equivalent to k <= (1 + sqrt(1 + 8*current_p)) / 2\n        # math.isqrt computes the integer square root (floor(sqrt(x)))\n        k = (1 + math.isqrt(1 + 8 * current_p)) // 2\n        \n        min_n += k\n        scc_sizes.append(k)\n        current_p -= (k * (k - 1)) // 2\n\n    sum_k_sq = 0\n    for k_val in scc_sizes:\n        sum_k_sq += k_val * k_val\n    \n    # The maximum number of unidirectional pairs is achieved by arranging\n    # the SCCs in a line (C_1 -> C_2 -> ... -> C_m).\n    # For any u in C_i and v in C_j with i < j, (u,v) is a unidirectional pair.\n    # The total number of such pairs is sum_{i < j} (k_i * k_j).\n    # This can be calculated as ((sum k_i)^2 - sum k_i^2) / 2.\n    # Here, sum k_i = min_n.\n    max_unidirectional_pairs = (min_n * min_n - sum_k_sq) // 2\n\n    print(min_n, max_unidirectional_pairs)\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 483,
        "completion_token_count": 2271,
        "thoughts_token_count": 7481
    }
}