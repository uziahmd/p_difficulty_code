{
    "start": 1758293717.833888,
    "end": 1758293793.7054417,
    "start-formatted": "2025-09-19 23:55 KST",
    "end-formatted": "2025-09-19 23:56 KST",
    "gpu": 2,
    "pid": 28,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vasily the Bear and Beautiful Strings\n\nVasily the Bear loves beautiful strings. String s is beautiful if it meets the following criteria:   String s only consists of characters 0 and 1, at that character 0 must occur in string s exactly n times, and character 1 must occur exactly m times.  We can obtain character g from string s with some (possibly, zero) number of modifications. The character g equals either zero or one. A modification of string with length at least two is the following operation: we replace two last characters from the string by exactly one other character. This character equals one if it replaces two zeros, otherwise it equals zero. For example, one modification transforms string \"01010\" into string \"0100\", two modifications transform it to \"011\". It is forbidden to modify a string with length less than two.Help the Bear, count the number of beautiful strings. As the number of beautiful strings can be rather large, print the remainder after dividing the number by 1000000007 (109 + 7). \n\n## Input\nThe first line of the input contains three space-separated integers n, m, g (0 ≤ n, m ≤ 105, n + m ≥ 1, 0 ≤ g ≤ 1).\n\n## Output\nPrint a single integer — the answer to the problem modulo 1000000007 (109 + 7).\n\n## Example\n### Input\n['1 1 0', '2 2 0', '1 1 1']\n\n### Output\n['2', '4', '0']\n\n## Note\nIn the first sample the beautiful strings are: \"01\", \"10\".In the second sample the beautiful strings are: \"0011\", \"1001\", \"1010\", \"1100\".In the third sample there are no beautiful strings.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "",
    "response": "```python\nimport sys\n\nMOD = 1000000007\n\ndef solve():\n    n, m, g = map(int, sys.stdin.readline().split())\n\n    if n == 0:\n        if m == 1:\n            if g == 1:\n                print(1)\n            else:\n                print(0)\n        else:\n            if g == 0:\n                print(0)\n            else:\n                print(0)\n        return\n\n    if m == 0:\n        if n == 1:\n            if g == 0:\n                print(1)\n            else:\n                print(0)\n        else:\n            if g == 0:\n                print(1)\n            else:\n                print(0)\n        return\n\n    fact = [1] * (n + m + 1)\n    inv_fact = [1] * (n + m + 1)\n\n    for i in range(1, n + m + 1):\n        fact[i] = (fact[i-1] * i) % MOD\n\n    inv_fact[n + m] = pow(fact[n + m], MOD - 2, MOD)\n    for i in range(n + m - 1, -1, -1):\n        inv_fact[i] = (inv_fact[i+1] * (i+1)) % MOD\n\n    def nCr_mod_p(n_val, r_val):\n        if r_val < 0 or r_val > n_val:\n            return 0\n        num = fact[n_val]\n        den = (inv_fact[r_val] * inv_fact[n_val - r_val]) % MOD\n        return (num * den) % MOD\n\n    ans = 0\n\n    # Case 1: The final character is 0\n    # This happens if the number of 1s in the string is even.\n    # The number of 1s in the string is m.\n    # If m is even, the final character is 0.\n    if m % 2 == 0:\n        if g == 0:\n            # We need to choose positions for n zeros and m ones.\n            # Total strings: (n+m) choose n or (n+m) choose m.\n            ans = (ans + nCr_mod_p(n + m, n)) % MOD\n\n    # Case 2: The final character is 1\n    # This happens if the number of 1s in the string is odd.\n    # The number of 1s in the string is m.\n    # If m is odd, the final character is 1.\n    if m % 2 == 1:\n        if g == 1:\n            # We need to choose positions for n zeros and m ones.\n            # Total strings: (n+m) choose n or (n+m) choose m.\n            ans = (ans + nCr_mod_p(n + m, n)) % MOD\n\n    # Additional strings when g=0 and n > 0.\n    # These are strings where the effective number of zeros is reduced by one.\n    # This happens if the last character is 0 and the second to last character is 0.\n    # This effectively means we are looking for strings that reduce to '0' and the number of 1s is even.\n    # The condition for the final character to be 0 is that the number of 1s is even.\n    # If m is even, and g is 0, we've already counted all strings.\n    # The problem is subtle: \"character g from string s with some (possibly, zero) number of modifications.\"\n    # This means the final character of the reduction process.\n    # The parity of 1s determines the final character.\n    # The number of 0s doesn't change the parity of the final character.\n    # If the number of 1s is even, the final character is 0.\n    # If the number of 1s is odd, the final character is 1.\n\n    # This seems to be the standard interpretation of the \"XOR sum\" of the string.\n    # The operation is:\n    # 00 -> 1\n    # 01 -> 0\n    # 10 -> 0\n    # 11 -> 0\n\n    # Let's analyze the operation:\n    # f(s...xy) = f(s...z) where z is result of xy.\n    # 00 -> 1\n    # 01 -> 0\n    # 10 -> 0\n    # 11 -> 0\n\n    # This is NOT XOR. This is specific.\n    # Let's track the \"value\" of the string.\n    # If we have a string, say S.\n    # If S ends with 00, it becomes S'1.\n    # If S ends with 01, it becomes S'0.\n    # If S ends with 10, it becomes S'0.\n    # If S ends with 11, it becomes S'0.\n\n    # Let's consider the state (number of 0s, number of 1s, last character).\n    # This is too complex.\n    # The problem can be rephrased: what is the value of the final character?\n    # Let's consider the values of the characters from left to right.\n    # Suppose we have a sequence of characters c1, c2, ..., ck.\n    # We combine ck-1 and ck to get z_k. Then combine ck-2 and z_k to get z_k-1, etc.\n    # This is like a reduction from right to left.\n    # Let's denote the operation as op(x, y).\n    # op(0,0) = 1\n    # op(0,1) = 0\n    # op(1,0) = 0\n    # op(1,1) = 0\n\n    # Let's try to find a pattern.\n    # 00 -> 1\n    # 000 -> 01 -> 0\n    # 0000 -> 001 -> 00 -> 1\n    # 00000 -> 0001 -> 000 -> 01 -> 0\n    # For a string of only 0s:\n    # length 1: 0\n    # length 2: 1\n    # length 3: 0\n    # length 4: 1\n    # length k: (k-1) % 2 == 0 => 1, (k-1) % 2 == 1 => 0. This is 1 if k is even, 0 if k is odd.\n    # More precisely, if k zeros:\n    # 0_k -> op(0, 0_{k-1})\n    # op(x, y) = 1 if x=0, y=0. Else 0.\n    # So if string is 00...0 (k times).\n    # The result is 1 if k is even, 0 if k is odd.\n    # This means if n 0s and m 1s.\n    # If n = 1, m = 1, g = 0. Strings: 01, 10.\n    # 01 -> 0 (op(0,1))\n    # 10 -> 0 (op(1,0))\n    # Both give 0. Count = 2. Matches example.\n\n    # If n = 2, m = 2, g = 0. Strings: 0011, 0101, 0110, 1001, 1010, 1100.\n    # 0011 -> 00(0) -> 0(1) -> 0.\n    # 0101 -> 01(0) -> 0(0) -> 1. This is not 0.\n    # This interpretation of the operation is wrong.\n    # \"replace two last characters from the string by exactly one other character\"\n    # \"01010\" -> \"0100\" (replaces 10 with 0) -> \"011\" (replaces 00 with 1)\n    # The example \"01010\" -> \"0100\" means op(1,0) = 0.\n    # The example \"0100\" -> \"011\" means op(0,0) = 1.\n    # This matches my op definition: op(0,0)=1, op(0,1)=0, op(1,0)=0, op(1,1)=0.\n\n    # Let's re-evaluate 0101 -> 01(0) -> 0(0) -> 1. This gives 1.\n    # What strings give 0 for (2,2,0)?\n    # 0011 -> 00(0) -> 0(1) -> 0. Yes.\n    # 1001 -> 10(0) -> 1(1) -> 0. Yes.\n    # 1010 -> 10(0) -> 1(0) -> 0. Yes.\n    # 1100 -> 11(1) -> 1(0) -> 0. Yes.\n    # 0101 -> 01(0) -> 0(0) -> 1. No.\n    # 0110 -> 01(0) -> 0(0) -> 1. No.\n    # So 4 strings for (2,2,0). Matches example.\n\n    # The value of the final character depends on the number of 1s and the number of 0s.\n    # Let's define f(S) as the result of reducing string S.\n    # f(S + '00') = f(S + '1')\n    # f(S + '01') = f(S + '0')\n    # f(S + '10') = f(S + '0')\n    # f(S + '11') = f(S + '0')\n\n    # Notice that if the string contains at least one '1', and it's not '00',\n    # then the last two characters reduce to '0' (unless it's '00').\n    # Let's track the \"parity\" of 0s.\n    # If the string has m ones.\n    # If m > 0:\n    #   The last '1' will always combine with something to its right (or be the last character).\n    #   If the string ends with '10', '01', '11', the last two combine to '0'.\n    #   So if there's any '1' involved in the last operation, the result is '0'.\n    #   The only way to get '1' is if the last operation is '00' -> '1'.\n    #   This implies that the reduced string must eventually become '00'.\n\n    # Consider the parity of the number of 1s.\n    # Let N0 be the number of 0s, N1 be the number of 1s.\n    # The operation (x,y) -> z can be seen as:\n    # z = 1 if x=0, y=0\n    # z = 0 otherwise\n    # This is equivalent to z = (1-x)(1-y). (where 0,1 are actual numbers)\n    # The final character is 1 if and only if the string reduces to \"00\" at some point,\n    # and then that \"00\" becomes \"1\", and then that \"1\" doesn't combine with anything else to become \"0\".\n    # This means the final character is 1 if and only if the string reduces to \"00\" and then that \"1\" is the final character.\n    # This means the string must reduce to a sequence of length 2, which is \"00\".\n    # And then this \"00\" becomes \"1\".\n\n    # The key insight for this type of problem is often to find an invariant or a simple property.\n    # Let's consider the sum modulo 2. This is XOR.\n    # op(0,0)=1, op(0,1)=0, op(1,0)=0, op(1,1)=0\n    # This is NOT XOR.\n    # (x AND y) is 1 if x=1, y=1.\n    # (x OR y) is 1 if x=1 or y=1.\n    # This operation is (NOT x) AND (NOT y).\n    # Let's say we have a string S = c_1 c_2 ... c_k.\n    # The reduction is c_1 c_2 ... c_{k-2} op(c_{k-1}, c_k).\n    # Let v(S) be the final value.\n    # v(S) = v(c_1 ... c_{k-2} op(c_{k-1}, c_k)).\n    # This is right-associative.\n    # v(c_1, c_2, ..., c_k) = op(c_1, op(c_2, ..., op(c_{k-1}, c_k)...)). This is not how it works.\n    # It's op(op(...op(c_1,c_2)...), c_k). This is left-associative.\n    # The problem statement says \"replace two last characters\". This is right-associative reduction.\n    # S = c_1 c_2 ... c_k.\n    # S_1 = c_1 c_2 ... c_{k-2} op(c_{k-1}, c_k)\n    # S_2 = c_1 c_2 ... c_{k-3} op(c_{k-2}, op(c_{k-1}, c_k))\n    # ...\n    # S_{k-1} = op(c_1, op(c_2, ..., op(c_{k-1}, c_k)...)).\n    # This is a common pattern for problems where the operation is applied to the end.\n\n    # Let's analyze op(x,y) = (1-x)(1-y).\n    # Let F(c_1, ..., c_k) = op(c_1, F(c_2, ..., c_k)) where F(c_k) = c_k.\n    # F(c_k) = c_k\n    # F(c_{k-1}, c_k) = op(c_{k-1}, c_k)\n    # F(c_{k-2}, c_{k-1}, c_k) = op(c_{k-2}, op(c_{k-1}, c_k))\n    # Let R_i = F(c_i, ..., c_k).\n    # R_k = c_k\n    # R_{k-1} = op(c_{k-1}, R_k)\n    # R_{k-2} = op(c_{k-2}, R_{k-1})\n    # ...\n    # R_1 = op(c_1, R_2)\n\n    # What if any c_i is 1?\n    # If R_j = 1 for some j, then R_{j-1} = op(c_{j-1}, 1) = (1-c_{j-1})(1-1) = 0.\n    # If R_j = 0 for some j, then R_{j-1} = op(c_{j-1}, 0) = (1-c_{j-1})(1-0) = 1-c_{j-1}.\n    # So if R_j = 0, then R_{j-1} is c_{j-1} flipped.\n\n    # Let's trace R_i from R_k = c_k backwards.\n    # R_k = c_k\n    # R_{k-1} = op(c_{k-1}, c_k)\n    # R_{k-2} = op(c_{k-2}, op(c_{k-1}, c_k))\n    # R_{k-3} = op(c_{k-3}, op(c_{k-2}, op(c_{k-1}, c_k)))\n\n    # If there is any '1' in the string:\n    # Let c_j be the rightmost '1'.\n    # Then c_{j+1}, ..., c_k must all be '0'.\n    # R_k = c_k = 0\n    # R_{k-1} = op(c_{k-1}, c_k) = op(0,0) = 1 (if k-1 is 0)\n    # R_j = c_j = 1\n    # R_{j-1} = op(c_{j-1}, R_j) = op(c_{j-1}, 1) = 0.\n    # R_{j-2} = op(c_{j-2}, R_{j-1}) = op(c_{j-2}, 0) = 1 - c_{j-2}.\n    # R_{j-3} = op(c_{j-3}, R_{j-2}) = op(c_{j-3}, 1-c_{j-2}).\n    # If 1-c_{j-2} is 1, then R_{j-3} is 0.\n    # If 1-c_{j-2} is 0, then R_{j-3} is 1-c_{j-3}.\n\n    # This is equivalent to:\n    # The final character is 0 if there is any '1' in the string, AND\n    # the number of '0's to the left of the leftmost '1' (say, `l` of them) is odd.\n    # The final character is 1 if there is any '1' in the string, AND\n    # the number of '0's to the left of the leftmost '1' (say, `l` of them) is even.\n    # This is for the case where m > 0.\n\n    # Let's verify this hypothesis.\n    # If the string contains at least one '1'. Let the first '1' be at index `i` (1-indexed).\n    # c_1 c_2 ... c_{i-1} c_i ... c_k\n    # where c_1 = ... = c_{i-1} = 0, and c_i = 1.\n    # Let S' = c_i ... c_k.\n    # The final value is op(0, op(0, ... op(0, v(S')) ... )). There are i-1 zeros.\n    # v(S') must be 0, because S' starts with 1, so op(1, ...) = 0.\n    # So v(S') = 0.\n    # Then we have op(0, op(0, ..., op(0, 0)...)).\n    # This is op(0, op(0, ..., op(0, 0)))\n    # op(0,0) = 1\n    # op(0,1) = 0\n    # op(0,0) = 1\n    # op(0,1) = 0\n    # ...\n    # This means that after `l` zeros, if the value is `v`, then the new value is `1-v` if `l` is odd, `v` if `l` is even.\n    # No, it's:\n    # op(0, v) = 1 if v=0, 0 if v=1. So it flips v.\n    # So if there are `l` zeros before the first 1:\n    # R_i = v(c_i ... c_k)\n    # R_{i-1} = op(c_{i-1}, R_i) = op(0, R_i) = 1 - R_i\n    # R_{i-2} = op(c_{i-2}, R_{i-1}) = op(0, 1 - R_i) = 1 - (1 - R_i) = R_i\n    # R_{i-3} = op(c_{i-3}, R_{i-2}) = op(0, R_i) = 1 - R_i\n    # So R_1 will be R_i if (i-1) is even, and 1 - R_i if (i-1) is odd.\n\n    # What is R_i = v(c_i ... c_k) if c_i=1?\n    # R_i = op(1, v(c_{i+1} ... c_k)).\n    # Since op(1, X) = 0 for any X, R_i must be 0.\n    # So if there is at least one '1' in the string, R_i = 0 for the first '1'.\n    # Then the final value is 0 if (i-1) is even, and 1 if (i-1) is odd.\n    # (i-1) is the number of leading zeros.\n    # So if m > 0:\n    #   Final char is 0 if number of leading zeros is even.\n    #   Final char is 1 if number of leading zeros is odd.\n\n    # Let's summarize:\n    # Case 1: m = 0 (string is all zeros)\n    #   n=1: \"0\" -> 0\n    #   n=2: \"00\" -> 1\n    #   n=3: \"000\" -> \"01\" -> 0\n    #   n=4: \"0000\" -> \"001\" -> \"00\" -> 1\n    #   Result is 1 if n is even, 0 if n is odd. (This is (n+1)%2 == 0)\n    #   This is equivalent to: (n % 2 == 0) -> 1, (n % 2 == 1) -> 0.\n\n    # Case 2: m > 0 (string contains at least one '1')\n    #   Let `k` be the number of leading zeros.\n    #   If `k` is even, result is 0.\n    #   If `k` is odd, result is 1.\n\n    # Now let's count strings based on these conditions.\n\n    # If m = 0:\n    #   If g = 0: (n must be odd)\n    #     If n % 2 == 1: ans = 1 (string is \"0...0\")\n    #     Else: ans = 0\n    #   If g = 1: (n must be even)\n    #     If n % 2 == 0: ans = 1 (string is \"0...0\")\n    #     Else: ans = 0\n    # This is correct for n=1, m=0, g=0 -> ans=1 (\"0\").\n    # n=2, m=0, g=0 -> ans=0.\n    # n=2, m=0, g=1 -> ans=1 (\"00\").\n\n    # If m > 0:\n    #   We need to count strings with `k` leading zeros.\n    #   `k` can range from 0 to `n`.\n    #   If `k = n`, then the string is \"0...01...1\". The first '1' is at index n+1.\n    #   Number of leading zeros is `n`.\n    #   If `k < n`, then the string starts with `k` zeros, then a '1'.\n    #   The remaining `n-k` zeros and `m-1` ones can be placed anywhere in the remaining `n+m-1-k` positions.\n    #   Number of ways to place them: C(n+m-1-k, n-k).\n\n    #   If g = 0: we need an even number of leading zeros.\n    #     Sum C(n+m-1-k, n-k) for k = 0, 2, 4, ... up to n.\n    #   If g = 1: we need an odd number of leading zeros.\n    #     Sum C(n+m-1-k, n-k) for k = 1, 3, 5, ... up to n.\n\n    # Let S(target_g) be the sum.\n    # Total combinations for C(N, K) where N = n+m-1-k, K = n-k.\n    # N - K = m-1.\n    # So we are summing C(N, m-1).\n    # Let N_total = n+m-1.\n    # We are summing C(N_total - k, m-1) for k in {0, ..., n}.\n    # Let j = N_total - k. Then k = N_total - j.\n    # When k=0, j=N_total. When k=n, j=m-1.\n    # So we are summing C(j, m-1) for j from m-1 to N_total.\n    # The parity condition is on k.\n    # k is even => N_total - j is even => j and N_total have same parity.\n    # k is odd => N_total - j is odd => j and N_total have different parity.\n\n    # Let's count the number of strings with `k` leading zeros.\n    # String is `0...0` (k times) `1` (1 time) `...` (remaining n-k zeros, m-1 ones)\n    # Number of ways = C((n-k) + (m-1), n-k) = C(n+m-k-1, n-k).\n    # This is for k < n.\n    # If k = n: String is `0...0` (n times) `1` (1 time) `...` (remaining m-1 ones).\n    # This is `0...01...1`. Number of ways = 1.\n    # The formula C(n+m-n-1, n-n) = C(m-1, 0) = 1. So the formula works for k=n too.\n\n    # So the sum is Sum_{k=0 to n} C(n+m-k-1, n-k) where k has the required parity.\n    # Let `p = m-1`.\n    # We need to sum C(n+p-k, n-k) for k = 0, ..., n with correct parity.\n    # This is equivalent to summing C(n+p-k, p) for k = 0, ..., n with correct parity.\n    # Let `i = n-k`. Then `k = n-i`.\n    # When k=0, i=n. When k=n, i=0.\n    # Sum_{i=0 to n} C(p+i, p) where (n-i) has required parity.\n    # This is Sum_{i=0 to n} C(p+i, i) where (n-i) has required parity.\n\n    # We need to calculate S_even = Sum_{i=0 to n, (n-i) even} C(p+i, i)\n    # And S_odd = Sum_{i=0 to n, (n-i) odd} C(p+i, i)\n\n    # This is a known identity: Sum_{i=0 to N} C(R+i, i) = C(R+N+1, N). (Hockey-stick identity)\n    # This gives the total sum.\n    # We need sums for alternating parities.\n    # S_total = Sum_{i=0 to n} C(p+i, i) = C(p+n+1, n).\n\n    # Consider the sum: Sum_{i=0 to n} (-1)^i C(p+i, i).\n    # This is not directly useful.\n\n    # Let's use the generating function approach for C(N, K) sums.\n    # C(N, K) = [x^K] (1+x)^N.\n    # C(p+i, i) = [x^i] (1+x)^(p+i).\n    # We need to sum [x^i] (1+x)^(p+i) for i with certain parity.\n\n    # Another approach:\n    # Sum_{k=0 to n} C(n+m-k-1, n-k)\n    # This is Sum_{k=0 to n} C(n+m-k-1, m-1)\n    # Let N' = n+m-1.\n    # Sum_{k=0 to n} C(N'-k, m-1).\n    # Let j = N'-k.\n    # Sum_{j=N'-n to N'} C(j, m-1).\n    # This is Sum_{j=m-1 to N'} C(j, m-1).\n    # Using hockey-stick identity: Sum_{i=r to N} C(i, r) = C(N+1, r+1).\n    # So Sum_{j=m-1 to N'} C(j, m-1) = C(N'+1, m).\n    # This is C(n+m, m). This is the total number of strings.\n\n    # This means that the total count of strings with m > 0 is C(n+m, m).\n    # This makes sense, as for any string with n 0s and m 1s, if m > 0,\n    # the final character is determined by the parity of leading zeros.\n    # And all strings are covered by this.\n\n    # So, for m > 0:\n    # We need to count strings where the number of leading zeros `k` has a certain parity.\n    # `k` is the number of zeros before the first '1'.\n    # If the string is `0^k 1 ...`\n    # The number of such strings is C( (n-k) + (m-1), (n-k) ) = C(n+m-k-1, m-1).\n    # Let `target_parity_k = g`. (0 for even, 1 for odd)\n\n    # We need to sum C(n+m-k-1, m-1) for k from 0 to n such that k % 2 == target_parity_k.\n    # Let S = Sum_{k=0 to n} C(n+m-k-1, m-1)\n    # Let S_even = Sum_{k=0 to n, k even} C(n+m-k-1, m-1)\n    # Let S_odd = Sum_{k=0 to n, k odd} C(n+m-k-1, m-1)\n    # We know S_even + S_odd = C(n+m, m).\n\n    # Consider the identity:\n    # Sum_{i=0 to N} C(R+i, i) = C(R+N+1, N)\n    # Sum_{i=0 to N} C(R+i, i) (-1)^i = C(R, N) if N is even, -C(R, N) if N is odd? No, this is wrong.\n    # Identity: Sum_{k=0 to N} (-1)^k C(M-k, R) = C(M-N-1, R-1) if N is even.\n    # This is not exactly what we have.\n\n    # Let's use a simpler approach.\n    # Consider the sum:\n    # A = C(X, Y) + C(X-1, Y) + C(X-2, Y) + ... + C(X-N, Y)\n    # where X = n+m-1, Y = m-1, N = n.\n    # This sum is C(X+1, Y+1) - C(X-N, Y+1) = C(n+m, m) - C(m-1, m).\n    # C(m-1, m) is 0. So the total sum is C(n+m, m). This is correct.\n\n    # We need to compute S_even and S_odd.\n    # S_even = C(n+m-1, m-1) + C(n+m-3, m-1) + ...\n    # S_odd = C(n+m-2, m-1) + C(n+m-4, m-1) + ...\n\n    # Let A = C(N, K) + C(N-2, K) + C(N-4, K) + ...\n    # Let B = C(N-1, K) + C(N-3, K) + C(N-5, K) + ...\n    # We know A+B = C(N+1, K+1). (This is if N is the largest term, and terms go down to K)\n    # This sum is C(N+1, K+1).\n    # We need to sum C(n+m-1-k, m-1) for k=0...n.\n    # Let R = m-1.\n    # Sum_{k=0 to n} C(n+R-k, R).\n    # Let i = n-k.\n    # Sum_{i=0 to n} C(R+i, R).\n    # We need to sum C(R+i, R) where (n-i) has required parity.\n    # Let f(i) = C(R+i, R).\n    # We want Sum_{i=0 to n, (n-i)%2==0} f(i) or Sum_{i=0 to n, (n-i)%2==1} f(i).\n\n    # Consider the identity:\n    # Sum_{i=0 to N} C(i+R, R) = C(N+R+1, R+1).\n    # Sum_{i=0 to N} (-1)^i C(i+R, R) = (-1)^N C(R, N+1) (if R >= N+1) or 0 (if R < N+1)?\n    # No, this is not simple.\n\n    # The problem might be simpler for n > 0, m > 0.\n    # The final value depends on the parity of the number of leading zeros.\n    # This is equivalent to (position of first '1' - 1) % 2.\n    # If there are no '1's, it's just n % 2.\n    # For n > 0, m > 0:\n    # The number of strings where first '1' is at position `k+1` (i.e., `k` leading zeros) is C(n+m-k-1, m-1).\n    # We need to sum these for `k` having the required parity.\n\n    # Let's consider the total sum:\n    # Total = C(n+m, m)\n    # We need S_even (for g=0) and S_odd (for g=1).\n    # S_even = Sum_{k=0 to n, k even} C(n+m-k-1, m-1)\n    # S_odd = Sum_{k=0 to n, k odd} C(n+m-k-1, m-1)\n\n    # Let N_total = n+m-1. R = m-1.\n    # S_even = Sum_{k=0 to n, k even} C(N_total-k, R)\n    # S_odd = Sum_{k=0 to n, k odd} C(N_total-k, R)\n\n    # We know that:\n    # Sum_{j=0 to N} C(M-j, R) = C(M+1, R+1) - C(M-N, R+1).\n    # This is for a full range.\n    # For alternating sums:\n    # Sum_{j=0 to N} C(M-j, R) = S_even + S_odd.\n    # Sum_{j=0 to N} (-1)^j C(M-j, R) = S_even - S_odd.\n\n    # Let M_prime = n+m-1. R_prime = m-1.\n    # S_even + S_odd = Sum_{k=0 to n} C(M_prime-k, R_prime)\n    # = C(M_prime+1, R_prime+1) - C(M_prime-n, R_prime+1)\n    # = C(n+m, m) - C(m-1, m) = C(n+m, m). (Since C(m-1,m)=0)\n\n    # S_even - S_odd = Sum_{k=0 to n} (-1)^k C(M_prime-k, R_prime)\n    # This sum is: C(M_prime, R_prime) - C(M_prime-1, R_prime) + C(M_prime-2, R_prime) - ... + (-1)^n C(M_prime-n, R_prime).\n    # This is a known identity for alternating sums of binomial coefficients.\n    # Sum_{k=0 to N} (-1)^k C(M-k, R) = C(M-N-1, R-1) * (-1)^N.\n    # No, this is not it.\n    # The identity is: Sum_{i=0 to k} (-1)^i C(n-i, r) = (-1)^k C(n-k-1, r-1).\n    # Here M_prime-k is decreasing. So this is Sum_{k=0 to n} (-1)^k C( (n+m-1)-k, m-1).\n    # Let N = n+m-1. Let R = m-1.\n    # Sum_{k=0 to n} (-1)^k C(N-k, R) = (-1)^n C(N-n-1, R-1) = (-1)^n C(m-2, m-2).\n    # This is (-1)^n * 1 = (-1)^n if m-2 >= 0 (i.e. m >= 2).\n    # If m=1, then R=0. C(N-k, 0) = 1.\n    # Sum_{k=0 to n} (-1)^k * 1 = 1 if n is even, 0 if n is odd. This is (n%2==0).\n\n    # Let's analyze the S_even - S_odd sum more carefully.\n    # Sum_{k=0 to n} (-1)^k C(n+m-1-k, m-1)\n    # Case m=1: R_prime = 0.\n    # Sum_{k=0 to n} (-1)^k C(n+1-k-1, 0) = Sum_{k=0 to n} (-1)^k C(n-k, 0)\n    # = Sum_{k=0 to n} (-1)^k * 1\n    # If n is even, sum is 1.\n    # If n is odd, sum is 0.\n    # So for m=1: S_even - S_odd = (n % 2 == 0 ? 1 : 0).\n\n    # Case m >= 2: R_prime = m-1 >= 1.\n    # Sum_{k=0 to n} (-1)^k C( (n+m-1)-k, m-1 )\n    # This is C(n+m-1, m-1) - C(n+m-2, m-1) + ... + (-1)^n C(m-1, m-1).\n    # This identity is Sum_{j=0 to k} (-1)^j C(N-j, R) = (-1)^k C(N-k-1, R-1).\n    # Here N = n+m-1, R = m-1, k = n.\n    # So S_even - S_odd = (-1)^n C( (n+m-1)-n-1, (m-1)-1 )\n    # = (-1)^n C(m-2, m-2).\n    # If m-2 < 0 (i.e. m=1), C(m-2, m-2) is usually 0. But C(X,X)=1.\n    # If m=1, then m-2 = -1. C(-1, -1) is not defined by this formula.\n    # So for m=1, S_even - S_odd is (n%2==0 ? 1 : 0).\n    # For m >= 2, C(m-2, m-2) = 1. So S_even - S_odd = (-1)^n.\n\n    # So we have two equations:\n    # 1) S_even + S_odd = C(n+m, m)\n    # 2) S_even - S_odd = Value_diff\n\n    # If m=1: Value_diff = (1 if n is even else 0)\n    #   2 * S_even = C(n+1, 1) + Value_diff = (n+1) + (1 if n is even else 0)\n    #   If n is even: 2 * S_even = n+1+1 = n+2. S_even = (n+2)/2.\n    #   If n is odd: 2 * S_even = n+1+0 = n+1. S_even = (n+1)/2.\n    #   This is floor((n+2)/2)\n    #   2 * S_odd = C(n+1, 1) - Value_diff = (n+1) - (1 if n is even else 0)\n    #   If n is even: 2 * S_odd = n+1-1 = n. S_odd = n/2.\n    #   If n is odd: 2 * S_odd = n+1-0 = n+1. S_odd = (n+1)/2.\n    #   This is ceil(n/2)\n    #   All these are integers. We need to divide by 2 (mod MOD). (MOD+1)/2 is inverse of 2.\n\n    # If m >= 2: Value_diff = (-1)^n\n    #   2 * S_even = C(n+m, m) + (-1)^n\n    #   2 * S_odd = C(n+m, m) - (-1)^n\n    #   S_even = (C(n+m, m) + (-1)^n) * inv_2 % MOD\n    #   S_odd = (C(n+m, m) - (-1)^n + MOD) * inv_2 % MOD\n\n    # Final result for n > 0, m > 0:\n    # If g = 0 (even number of leading zeros): ans = S_even\n    # If g = 1 (odd number of leading zeros): ans = S_odd\n\n    # Let's put it all together.\n\n    inv_2 = pow(2, MOD - 2, MOD)\n\n    if m == 0:\n        if n % 2 == g: # n is odd if g=0, n is even if g=1\n            ans = 1\n        else:\n            ans = 0\n    elif m == 1:\n        # S_even is for g=0, S_odd is for g=1\n        if n % 2 == 0: # n is even\n            S_even = (n + 2) // 2\n            S_odd = n // 2\n        else: # n is odd\n            S_even = (n + 1) // 2\n            S_odd = (n + 1) // 2\n        \n        if g == 0:\n            ans = S_even\n        else:\n            ans = S_odd\n    else: # m >= 2\n        total_strings = nCr_mod_p(n + m, m)\n        if n % 2 == 0: # n is even\n            value_diff = 1\n        else: # n is odd\n            value_diff = MOD - 1 # -1 mod MOD\n\n        S_even = (total_strings + value_diff) % MOD * inv_2 % MOD\n        S_odd = (total_strings - value_diff + MOD) % MOD * inv_2 % MOD\n\n        if g == 0:\n            ans = S_even\n        else:\n            ans = S_odd\n\n    print(ans)\n\nsolve()\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\nMOD = 1000000007\n\ndef solve():\n    n, m, g = map(int, sys.stdin.readline().split())\n\n    if n == 0:\n        if m == 1:\n            if g == 1:\n                print(1)\n            else:\n                print(0)\n        else:\n            if g == 0:\n                print(0)\n            else:\n                print(0)\n        return\n\n    if m == 0:\n        if n == 1:\n            if g == 0:\n                print(1)\n            else:\n                print(0)\n        else:\n            if g == 0:\n                print(1)\n            else:\n                print(0)\n        return\n\n    fact = [1] * (n + m + 1)\n    inv_fact = [1] * (n + m + 1)\n\n    for i in range(1, n + m + 1):\n        fact[i] = (fact[i-1] * i) % MOD\n\n    inv_fact[n + m] = pow(fact[n + m], MOD - 2, MOD)\n    for i in range(n + m - 1, -1, -1):\n        inv_fact[i] = (inv_fact[i+1] * (i+1)) % MOD\n\n    def nCr_mod_p(n_val, r_val):\n        if r_val < 0 or r_val > n_val:\n            return 0\n        num = fact[n_val]\n        den = (inv_fact[r_val] * inv_fact[n_val - r_val]) % MOD\n        return (num * den) % MOD\n\n    ans = 0\n\n    # Case 1: The final character is 0\n    # This happens if the number of 1s in the string is even.\n    # The number of 1s in the string is m.\n    # If m is even, the final character is 0.\n    if m % 2 == 0:\n        if g == 0:\n            # We need to choose positions for n zeros and m ones.\n            # Total strings: (n+m) choose n or (n+m) choose m.\n            ans = (ans + nCr_mod_p(n + m, n)) % MOD\n\n    # Case 2: The final character is 1\n    # This happens if the number of 1s in the string is odd.\n    # The number of 1s in the string is m.\n    # If m is odd, the final character is 1.\n    if m % 2 == 1:\n        if g == 1:\n            # We need to choose positions for n zeros and m ones.\n            # Total strings: (n+m) choose n or (n+m) choose m.\n            ans = (ans + nCr_mod_p(n + m, n)) % MOD\n\n    # Additional strings when g=0 and n > 0.\n    # These are strings where the effective number of zeros is reduced by one.\n    # This happens if the last character is 0 and the second to last character is 0.\n    # This effectively means we are looking for strings that reduce to '0' and the number of 1s is even.\n    # The condition for the final character to be 0 is that the number of 1s is even.\n    # If m is even, and g is 0, we've already counted all strings.\n    # The problem is subtle: \"character g from string s with some (possibly, zero) number of modifications.\"\n    # This means the final character of the reduction process.\n    # The parity of 1s determines the final character.\n    # The number of 0s doesn't change the parity of the final character.\n    # If the number of 1s is even, the final character is 0.\n    # If the number of 1s is odd, the final character is 1.\n\n    # This seems to be the standard interpretation of the \"XOR sum\" of the string.\n    # The operation is:\n    # 00 -> 1\n    # 01 -> 0\n    # 10 -> 0\n    # 11 -> 0\n\n    # Let's analyze the operation:\n    # f(s...xy) = f(s...z) where z is result of xy.\n    # 00 -> 1\n    # 01 -> 0\n    # 10 -> 0\n    # 11 -> 0\n\n    # This is NOT XOR. This is specific.\n    # Let's track the \"value\" of the string.\n    # If we have a string, say S.\n    # If S ends with 00, it becomes S'1.\n    # If S ends with 01, it becomes S'0.\n    # If S ends with 10, it becomes S'0.\n    # If S ends with 11, it becomes S'0.\n\n    # Let's consider the state (number of 0s, number of 1s, last character).\n    # This is too complex.\n    # The problem can be rephrased: what is the value of the final character?\n    # Let's consider the values of the characters from left to right.\n    # Suppose we have a sequence of characters c1, c2, ..., ck.\n    # We combine ck-1 and ck to get z_k. Then combine ck-2 and z_k to get z_k-1, etc.\n    # This is like a reduction from right to left.\n    # Let's denote the operation as op(x, y).\n    # op(0,0) = 1\n    # op(0,1) = 0\n    # op(1,0) = 0\n    # op(1,1) = 0\n\n    # Let's try to find a pattern.\n    # 00 -> 1\n    # 000 -> 01 -> 0\n    # 0000 -> 001 -> 00 -> 1\n    # 00000 -> 0001 -> 000 -> 01 -> 0\n    # For a string of only 0s:\n    # length 1: 0\n    # length 2: 1\n    # length 3: 0\n    # length 4: 1\n    # length k: (k-1) % 2 == 0 => 1, (k-1) % 2 == 1 => 0. This is 1 if k is even, 0 if k is odd.\n    # More precisely, if k zeros:\n    # 0_k -> op(0, 0_{k-1})\n    # op(x, y) = 1 if x=0, y=0. Else 0.\n    # So if string is 00...0 (k times).\n    # The result is 1 if k is even, 0 if k is odd.\n    # This means if n 0s and m 1s.\n    # If n = 1, m = 1, g = 0. Strings: 01, 10.\n    # 01 -> 0 (op(0,1))\n    # 10 -> 0 (op(1,0))\n    # Both give 0. Count = 2. Matches example.\n\n    # If n = 2, m = 2, g = 0. Strings: 0011, 0101, 0110, 1001, 1010, 1100.\n    # 0011 -> 00(0) -> 0(1) -> 0.\n    # 0101 -> 01(0) -> 0(0) -> 1. This is not 0.\n    # This interpretation of the operation is wrong.\n    # \"replace two last characters from the string by exactly one other character\"\n    # \"01010\" -> \"0100\" (replaces 10 with 0) -> \"011\" (replaces 00 with 1)\n    # The example \"01010\" -> \"0100\" means op(1,0) = 0.\n    # The example \"0100\" -> \"011\" means op(0,0) = 1.\n    # This matches my op definition: op(0,0)=1, op(0,1)=0, op(1,0)=0, op(1,1)=0.\n\n    # Let's re-evaluate 0101 -> 01(0) -> 0(0) -> 1. This gives 1.\n    # What strings give 0 for (2,2,0)?\n    # 0011 -> 00(0) -> 0(1) -> 0. Yes.\n    # 1001 -> 10(0) -> 1(1) -> 0. Yes.\n    # 1010 -> 10(0) -> 1(0) -> 0. Yes.\n    # 1100 -> 11(1) -> 1(0) -> 0. Yes.\n    # 0101 -> 01(0) -> 0(0) -> 1. No.\n    # 0110 -> 01(0) -> 0(0) -> 1. No.\n    # So 4 strings for (2,2,0). Matches example.\n\n    # The value of the final character depends on the number of 1s and the number of 0s.\n    # Let's define f(S) as the result of reducing string S.\n    # f(S + '00') = f(S + '1')\n    # f(S + '01') = f(S + '0')\n    # f(S + '10') = f(S + '0')\n    # f(S + '11') = f(S + '0')\n\n    # Notice that if the string contains at least one '1', and it's not '00',\n    # then the last two characters reduce to '0' (unless it's '00').\n    # Let's track the \"parity\" of 0s.\n    # If the string has m ones.\n    # If m > 0:\n    #   The last '1' will always combine with something to its right (or be the last character).\n    #   If the string ends with '10', '01', '11', the last two combine to '0'.\n    #   So if there's any '1' involved in the last operation, the result is '0'.\n    #   The only way to get '1' is if the last operation is '00' -> '1'.\n    #   This implies that the reduced string must eventually become '00'.\n\n    # Consider the parity of the number of 1s.\n    # Let N0 be the number of 0s, N1 be the number of 1s.\n    # The operation (x,y) -> z can be seen as:\n    # z = 1 if x=0, y=0\n    # z = 0 otherwise\n    # This is equivalent to z = (1-x)(1-y). (where 0,1 are actual numbers)\n    # The final character is 1 if and only if the string reduces to \"00\" at some point,\n    # and then that \"00\" becomes \"1\", and then that \"1\" doesn't combine with anything else to become \"0\".\n    # This means the final character is 1 if and only if the string reduces to \"00\" and then that \"1\" is the final character.\n    # This means the string must reduce to a sequence of length 2, which is \"00\".\n    # And then this \"00\" becomes \"1\".\n\n    # The key insight for this type of problem is often to find an invariant or a simple property.\n    # Let's consider the sum modulo 2. This is XOR.\n    # op(0,0)=1, op(0,1)=0, op(1,0)=0, op(1,1)=0\n    # This is NOT XOR.\n    # (x AND y) is 1 if x=1, y=1.\n    # (x OR y) is 1 if x=1 or y=1.\n    # This operation is (NOT x) AND (NOT y).\n    # Let's say we have a string S = c_1 c_2 ... c_k.\n    # The reduction is c_1 c_2 ... c_{k-2} op(c_{k-1}, c_k).\n    # Let v(S) be the final value.\n    # v(S) = v(c_1 ... c_{k-2} op(c_{k-1}, c_k)).\n    # This is right-associative.\n    # v(c_1, c_2, ..., c_k) = op(c_1, op(c_2, ..., op(c_{k-1}, c_k)...)). This is not how it works.\n    # It's op(op(...op(c_1,c_2)...), c_k). This is left-associative.\n    # The problem statement says \"replace two last characters\". This is right-associative reduction.\n    # S = c_1 c_2 ... c_k.\n    # S_1 = c_1 c_2 ... c_{k-2} op(c_{k-1}, c_k)\n    # S_2 = c_1 c_2 ... c_{k-3} op(c_{k-2}, op(c_{k-1}, c_k))\n    # ...\n    # S_{k-1} = op(c_1, op(c_2, ..., op(c_{k-1}, c_k)...)).\n    # This is a common pattern for problems where the operation is applied to the end.\n\n    # Let's analyze op(x,y) = (1-x)(1-y).\n    # Let F(c_1, ..., c_k) = op(c_1, F(c_2, ..., c_k)) where F(c_k) = c_k.\n    # F(c_k) = c_k\n    # F(c_{k-1}, c_k) = op(c_{k-1}, c_k)\n    # F(c_{k-2}, c_{k-1}, c_k) = op(c_{k-2}, op(c_{k-1}, c_k))\n    # Let R_i = F(c_i, ..., c_k).\n    # R_k = c_k\n    # R_{k-1} = op(c_{k-1}, R_k)\n    # R_{k-2} = op(c_{k-2}, R_{k-1})\n    # ...\n    # R_1 = op(c_1, R_2)\n\n    # What if any c_i is 1?\n    # If R_j = 1 for some j, then R_{j-1} = op(c_{j-1}, 1) = (1-c_{j-1})(1-1) = 0.\n    # If R_j = 0 for some j, then R_{j-1} = op(c_{j-1}, 0) = (1-c_{j-1})(1-0) = 1-c_{j-1}.\n    # So if R_j = 0, then R_{j-1} is c_{j-1} flipped.\n\n    # Let's trace R_i from R_k = c_k backwards.\n    # R_k = c_k\n    # R_{k-1} = op(c_{k-1}, c_k)\n    # R_{k-2} = op(c_{k-2}, op(c_{k-1}, c_k))\n    # R_{k-3} = op(c_{k-3}, op(c_{k-2}, op(c_{k-1}, c_k)))\n\n    # If there is any '1' in the string:\n    # Let c_j be the rightmost '1'.\n    # Then c_{j+1}, ..., c_k must all be '0'.\n    # R_k = c_k = 0\n    # R_{k-1} = op(c_{k-1}, c_k) = op(0,0) = 1 (if k-1 is 0)\n    # R_j = c_j = 1\n    # R_{j-1} = op(c_{j-1}, R_j) = op(c_{j-1}, 1) = 0.\n    # R_{j-2} = op(c_{j-2}, R_{j-1}) = op(c_{j-2}, 0) = 1 - c_{j-2}.\n    # R_{j-3} = op(c_{j-3}, R_{j-2}) = op(c_{j-3}, 1-c_{j-2}).\n    # If 1-c_{j-2} is 1, then R_{j-3} is 0.\n    # If 1-c_{j-2} is 0, then R_{j-3} is 1-c_{j-3}.\n\n    # This is equivalent to:\n    # The final character is 0 if there is any '1' in the string, AND\n    # the number of '0's to the left of the leftmost '1' (say, `l` of them) is odd.\n    # The final character is 1 if there is any '1' in the string, AND\n    # the number of '0's to the left of the leftmost '1' (say, `l` of them) is even.\n    # This is for the case where m > 0.\n\n    # Let's verify this hypothesis.\n    # If the string contains at least one '1'. Let the first '1' be at index `i` (1-indexed).\n    # c_1 c_2 ... c_{i-1} c_i ... c_k\n    # where c_1 = ... = c_{i-1} = 0, and c_i = 1.\n    # Let S' = c_i ... c_k.\n    # The final value is op(0, op(0, ... op(0, v(S')) ... )). There are i-1 zeros.\n    # v(S') must be 0, because S' starts with 1, so op(1, ...) = 0.\n    # So v(S') = 0.\n    # Then we have op(0, op(0, ..., op(0, 0)...)).\n    # This is op(0, op(0, ..., op(0, 0)))\n    # op(0,0) = 1\n    # op(0,1) = 0\n    # op(0,0) = 1\n    # op(0,1) = 0\n    # ...\n    # This means that after `l` zeros, if the value is `v`, then the new value is `1-v` if `l` is odd, `v` if `l` is even.\n    # No, it's:\n    # op(0, v) = 1 if v=0, 0 if v=1. So it flips v.\n    # So if there are `l` zeros before the first 1:\n    # R_i = v(c_i ... c_k)\n    # R_{i-1} = op(c_{i-1}, R_i) = op(0, R_i) = 1 - R_i\n    # R_{i-2} = op(c_{i-2}, R_{i-1}) = op(0, 1 - R_i) = 1 - (1 - R_i) = R_i\n    # R_{i-3} = op(c_{i-3}, R_{i-2}) = op(0, R_i) = 1 - R_i\n    # So R_1 will be R_i if (i-1) is even, and 1 - R_i if (i-1) is odd.\n\n    # What is R_i = v(c_i ... c_k) if c_i=1?\n    # R_i = op(1, v(c_{i+1} ... c_k)).\n    # Since op(1, X) = 0 for any X, R_i must be 0.\n    # So if there is at least one '1' in the string, R_i = 0 for the first '1'.\n    # Then the final value is 0 if (i-1) is even, and 1 if (i-1) is odd.\n    # (i-1) is the number of leading zeros.\n    # So if m > 0:\n    #   Final char is 0 if number of leading zeros is even.\n    #   Final char is 1 if number of leading zeros is odd.\n\n    # Let's summarize:\n    # Case 1: m = 0 (string is all zeros)\n    #   n=1: \"0\" -> 0\n    #   n=2: \"00\" -> 1\n    #   n=3: \"000\" -> \"01\" -> 0\n    #   n=4: \"0000\" -> \"001\" -> \"00\" -> 1\n    #   Result is 1 if n is even, 0 if n is odd. (This is (n+1)%2 == 0)\n    #   This is equivalent to: (n % 2 == 0) -> 1, (n % 2 == 1) -> 0.\n\n    # Case 2: m > 0 (string contains at least one '1')\n    #   Let `k` be the number of leading zeros.\n    #   If `k` is even, result is 0.\n    #   If `k` is odd, result is 1.\n\n    # Now let's count strings based on these conditions.\n\n    # If m = 0:\n    #   If g = 0: (n must be odd)\n    #     If n % 2 == 1: ans = 1 (string is \"0...0\")\n    #     Else: ans = 0\n    #   If g = 1: (n must be even)\n    #     If n % 2 == 0: ans = 1 (string is \"0...0\")\n    #     Else: ans = 0\n    # This is correct for n=1, m=0, g=0 -> ans=1 (\"0\").\n    # n=2, m=0, g=0 -> ans=0.\n    # n=2, m=0, g=1 -> ans=1 (\"00\").\n\n    # If m > 0:\n    #   We need to count strings with `k` leading zeros.\n    #   `k` can range from 0 to `n`.\n    #   If `k = n`, then the string is \"0...01...1\". The first '1' is at index n+1.\n    #   Number of leading zeros is `n`.\n    #   If `k < n`, then the string starts with `k` zeros, then a '1'.\n    #   The remaining `n-k` zeros and `m-1` ones can be placed anywhere in the remaining `n+m-1-k` positions.\n    #   Number of ways to place them: C(n+m-1-k, n-k).\n\n    #   If g = 0: we need an even number of leading zeros.\n    #     Sum C(n+m-1-k, n-k) for k = 0, 2, 4, ... up to n.\n    #   If g = 1: we need an odd number of leading zeros.\n    #     Sum C(n+m-1-k, n-k) for k = 1, 3, 5, ... up to n.\n\n    # Let S(target_g) be the sum.\n    # Total combinations for C(N, K) where N = n+m-1-k, K = n-k.\n    # N - K = m-1.\n    # So we are summing C(N, m-1).\n    # Let N_total = n+m-1.\n    # We are summing C(N_total - k, m-1) for k in {0, ..., n}.\n    # Let j = N_total - k. Then k = N_total - j.\n    # When k=0, j=N_total. When k=n, j=m-1.\n    # So we are summing C(j, m-1) for j from m-1 to N_total.\n    # The parity condition is on k.\n    # k is even => N_total - j is even => j and N_total have same parity.\n    # k is odd => N_total - j is odd => j and N_total have different parity.\n\n    # Let's count the number of strings with `k` leading zeros.\n    # String is `0...0` (k times) `1` (1 time) `...` (remaining n-k zeros, m-1 ones)\n    # Number of ways = C((n-k) + (m-1), n-k) = C(n+m-k-1, n-k).\n    # This is for k < n.\n    # If k = n: String is `0...0` (n times) `1` (1 time) `...` (remaining m-1 ones).\n    # This is `0...01...1`. Number of ways = 1.\n    # The formula C(n+m-n-1, n-n) = C(m-1, 0) = 1. So the formula works for k=n too.\n\n    # So the sum is Sum_{k=0 to n} C(n+m-k-1, n-k) where k has the required parity.\n    # Let `p = m-1`.\n    # We need to sum C(n+p-k, n-k) for k = 0, ..., n with correct parity.\n    # This is equivalent to summing C(n+p-k, p) for k = 0, ..., n with correct parity.\n    # Let `i = n-k`. Then `k = n-i`.\n    # When k=0, i=n. When k=n, i=0.\n    # Sum_{i=0 to n} C(p+i, p) where (n-i) has required parity.\n    # This is Sum_{i=0 to n} C(p+i, i) where (n-i) has required parity.\n\n    # We need to calculate S_even = Sum_{i=0 to n, (n-i) even} C(p+i, i)\n    # And S_odd = Sum_{i=0 to n, (n-i) odd} C(p+i, i)\n\n    # This is a known identity: Sum_{i=0 to N} C(R+i, i) = C(R+N+1, N). (Hockey-stick identity)\n    # This gives the total sum.\n    # We need sums for alternating parities.\n    # S_total = Sum_{i=0 to n} C(p+i, i) = C(p+n+1, n).\n\n    # Consider the sum: Sum_{i=0 to n} (-1)^i C(p+i, i).\n    # This is not directly useful.\n\n    # Let's use the generating function approach for C(N, K) sums.\n    # C(N, K) = [x^K] (1+x)^N.\n    # C(p+i, i) = [x^i] (1+x)^(p+i).\n    # We need to sum [x^i] (1+x)^(p+i) for i with certain parity.\n\n    # Another approach:\n    # Sum_{k=0 to n} C(n+m-k-1, n-k)\n    # This is Sum_{k=0 to n} C(n+m-k-1, m-1)\n    # Let N' = n+m-1.\n    # Sum_{k=0 to n} C(N'-k, m-1).\n    # Let j = N'-k.\n    # Sum_{j=N'-n to N'} C(j, m-1).\n    # This is Sum_{j=m-1 to N'} C(j, m-1).\n    # Using hockey-stick identity: Sum_{i=r to N} C(i, r) = C(N+1, r+1).\n    # So Sum_{j=m-1 to N'} C(j, m-1) = C(N'+1, m).\n    # This is C(n+m, m). This is the total number of strings.\n\n    # This means that the total count of strings with m > 0 is C(n+m, m).\n    # This makes sense, as for any string with n 0s and m 1s, if m > 0,\n    # the final character is determined by the parity of leading zeros.\n    # And all strings are covered by this.\n\n    # So, for m > 0:\n    # We need to count strings where the number of leading zeros `k` has a certain parity.\n    # `k` is the number of zeros before the first '1'.\n    # If the string is `0^k 1 ...`\n    # The number of such strings is C( (n-k) + (m-1), (n-k) ) = C(n+m-k-1, m-1).\n    # Let `target_parity_k = g`. (0 for even, 1 for odd)\n\n    # We need to sum C(n+m-k-1, m-1) for k from 0 to n such that k % 2 == target_parity_k.\n    # Let S = Sum_{k=0 to n} C(n+m-k-1, m-1)\n    # Let S_even = Sum_{k=0 to n, k even} C(n+m-k-1, m-1)\n    # Let S_odd = Sum_{k=0 to n, k odd} C(n+m-k-1, m-1)\n    # We know S_even + S_odd = C(n+m, m).\n\n    # Consider the identity:\n    # Sum_{i=0 to N} C(R+i, i) = C(R+N+1, N)\n    # Sum_{i=0 to N} C(R+i, i) (-1)^i = C(R, N) if N is even, -C(R, N) if N is odd? No, this is wrong.\n    # Identity: Sum_{k=0 to N} (-1)^k C(M-k, R) = C(M-N-1, R-1) if N is even.\n    # This is not exactly what we have.\n\n    # Let's use a simpler approach.\n    # Consider the sum:\n    # A = C(X, Y) + C(X-1, Y) + C(X-2, Y) + ... + C(X-N, Y)\n    # where X = n+m-1, Y = m-1, N = n.\n    # This sum is C(X+1, Y+1) - C(X-N, Y+1) = C(n+m, m) - C(m-1, m).\n    # C(m-1, m) is 0. So the total sum is C(n+m, m). This is correct.\n\n    # We need to compute S_even and S_odd.\n    # S_even = C(n+m-1, m-1) + C(n+m-3, m-1) + ...\n    # S_odd = C(n+m-2, m-1) + C(n+m-4, m-1) + ...\n\n    # Let A = C(N, K) + C(N-2, K) + C(N-4, K) + ...\n    # Let B = C(N-1, K) + C(N-3, K) + C(N-5, K) + ...\n    # We know A+B = C(N+1, K+1). (This is if N is the largest term, and terms go down to K)\n    # This sum is C(N+1, K+1).\n    # We need to sum C(n+m-1-k, m-1) for k=0...n.\n    # Let R = m-1.\n    # Sum_{k=0 to n} C(n+R-k, R).\n    # Let i = n-k.\n    # Sum_{i=0 to n} C(R+i, R).\n    # We need to sum C(R+i, R) where (n-i) has required parity.\n    # Let f(i) = C(R+i, R).\n    # We want Sum_{i=0 to n, (n-i)%2==0} f(i) or Sum_{i=0 to n, (n-i)%2==1} f(i).\n\n    # Consider the identity:\n    # Sum_{i=0 to N} C(i+R, R) = C(N+R+1, R+1).\n    # Sum_{i=0 to N} (-1)^i C(i+R, R) = (-1)^N C(R, N+1) (if R >= N+1) or 0 (if R < N+1)?\n    # No, this is not simple.\n\n    # The problem might be simpler for n > 0, m > 0.\n    # The final value depends on the parity of the number of leading zeros.\n    # This is equivalent to (position of first '1' - 1) % 2.\n    # If there are no '1's, it's just n % 2.\n    # For n > 0, m > 0:\n    # The number of strings where first '1' is at position `k+1` (i.e., `k` leading zeros) is C(n+m-k-1, m-1).\n    # We need to sum these for `k` having the required parity.\n\n    # Let's consider the total sum:\n    # Total = C(n+m, m)\n    # We need S_even (for g=0) and S_odd (for g=1).\n    # S_even = Sum_{k=0 to n, k even} C(n+m-k-1, m-1)\n    # S_odd = Sum_{k=0 to n, k odd} C(n+m-k-1, m-1)\n\n    # Let N_total = n+m-1. R = m-1.\n    # S_even = Sum_{k=0 to n, k even} C(N_total-k, R)\n    # S_odd = Sum_{k=0 to n, k odd} C(N_total-k, R)\n\n    # We know that:\n    # Sum_{j=0 to N} C(M-j, R) = C(M+1, R+1) - C(M-N, R+1).\n    # This is for a full range.\n    # For alternating sums:\n    # Sum_{j=0 to N} C(M-j, R) = S_even + S_odd.\n    # Sum_{j=0 to N} (-1)^j C(M-j, R) = S_even - S_odd.\n\n    # Let M_prime = n+m-1. R_prime = m-1.\n    # S_even + S_odd = Sum_{k=0 to n} C(M_prime-k, R_prime)\n    # = C(M_prime+1, R_prime+1) - C(M_prime-n, R_prime+1)\n    # = C(n+m, m) - C(m-1, m) = C(n+m, m). (Since C(m-1,m)=0)\n\n    # S_even - S_odd = Sum_{k=0 to n} (-1)^k C(M_prime-k, R_prime)\n    # This sum is: C(M_prime, R_prime) - C(M_prime-1, R_prime) + C(M_prime-2, R_prime) - ... + (-1)^n C(M_prime-n, R_prime).\n    # This is a known identity for alternating sums of binomial coefficients.\n    # Sum_{k=0 to N} (-1)^k C(M-k, R) = C(M-N-1, R-1) * (-1)^N.\n    # No, this is not it.\n    # The identity is: Sum_{i=0 to k} (-1)^i C(n-i, r) = (-1)^k C(n-k-1, r-1).\n    # Here M_prime-k is decreasing. So this is Sum_{k=0 to n} (-1)^k C( (n+m-1)-k, m-1).\n    # Let N = n+m-1. Let R = m-1.\n    # Sum_{k=0 to n} (-1)^k C(N-k, R) = (-1)^n C(N-n-1, R-1) = (-1)^n C(m-2, m-2).\n    # This is (-1)^n * 1 = (-1)^n if m-2 >= 0 (i.e. m >= 2).\n    # If m=1, then R=0. C(N-k, 0) = 1.\n    # Sum_{k=0 to n} (-1)^k * 1 = 1 if n is even, 0 if n is odd. This is (n%2==0).\n\n    # Let's analyze the S_even - S_odd sum more carefully.\n    # Sum_{k=0 to n} (-1)^k C(n+m-1-k, m-1)\n    # Case m=1: R_prime = 0.\n    # Sum_{k=0 to n} (-1)^k C(n+1-k-1, 0) = Sum_{k=0 to n} (-1)^k C(n-k, 0)\n    # = Sum_{k=0 to n} (-1)^k * 1\n    # If n is even, sum is 1.\n    # If n is odd, sum is 0.\n    # So for m=1: S_even - S_odd = (n % 2 == 0 ? 1 : 0).\n\n    # Case m >= 2: R_prime = m-1 >= 1.\n    # Sum_{k=0 to n} (-1)^k C( (n+m-1)-k, m-1 )\n    # This is C(n+m-1, m-1) - C(n+m-2, m-1) + ... + (-1)^n C(m-1, m-1).\n    # This identity is Sum_{j=0 to k} (-1)^j C(N-j, R) = (-1)^k C(N-k-1, R-1).\n    # Here N = n+m-1, R = m-1, k = n.\n    # So S_even - S_odd = (-1)^n C( (n+m-1)-n-1, (m-1)-1 )\n    # = (-1)^n C(m-2, m-2).\n    # If m-2 < 0 (i.e. m=1), C(m-2, m-2) is usually 0. But C(X,X)=1.\n    # If m=1, then m-2 = -1. C(-1, -1) is not defined by this formula.\n    # So for m=1, S_even - S_odd is (n%2==0 ? 1 : 0).\n    # For m >= 2, C(m-2, m-2) = 1. So S_even - S_odd = (-1)^n.\n\n    # So we have two equations:\n    # 1) S_even + S_odd = C(n+m, m)\n    # 2) S_even - S_odd = Value_diff\n\n    # If m=1: Value_diff = (1 if n is even else 0)\n    #   2 * S_even = C(n+1, 1) + Value_diff = (n+1) + (1 if n is even else 0)\n    #   If n is even: 2 * S_even = n+1+1 = n+2. S_even = (n+2)/2.\n    #   If n is odd: 2 * S_even = n+1+0 = n+1. S_even = (n+1)/2.\n    #   This is floor((n+2)/2)\n    #   2 * S_odd = C(n+1, 1) - Value_diff = (n+1) - (1 if n is even else 0)\n    #   If n is even: 2 * S_odd = n+1-1 = n. S_odd = n/2.\n    #   If n is odd: 2 * S_odd = n+1-0 = n+1. S_odd = (n+1)/2.\n    #   This is ceil(n/2)\n    #   All these are integers. We need to divide by 2 (mod MOD). (MOD+1)/2 is inverse of 2.\n\n    # If m >= 2: Value_diff = (-1)^n\n    #   2 * S_even = C(n+m, m) + (-1)^n\n    #   2 * S_odd = C(n+m, m) - (-1)^n\n    #   S_even = (C(n+m, m) + (-1)^n) * inv_2 % MOD\n    #   S_odd = (C(n+m, m) - (-1)^n + MOD) * inv_2 % MOD\n\n    # Final result for n > 0, m > 0:\n    # If g = 0 (even number of leading zeros): ans = S_even\n    # If g = 1 (odd number of leading zeros): ans = S_odd\n\n    # Let's put it all together.\n\n    inv_2 = pow(2, MOD - 2, MOD)\n\n    if m == 0:\n        if n % 2 == g: # n is odd if g=0, n is even if g=1\n            ans = 1\n        else:\n            ans = 0\n    elif m == 1:\n        # S_even is for g=0, S_odd is for g=1\n        if n % 2 == 0: # n is even\n            S_even = (n + 2) // 2\n            S_odd = n // 2\n        else: # n is odd\n            S_even = (n + 1) // 2\n            S_odd = (n + 1) // 2\n        \n        if g == 0:\n            ans = S_even\n        else:\n            ans = S_odd\n    else: # m >= 2\n        total_strings = nCr_mod_p(n + m, m)\n        if n % 2 == 0: # n is even\n            value_diff = 1\n        else: # n is odd\n            value_diff = MOD - 1 # -1 mod MOD\n\n        S_even = (total_strings + value_diff) % MOD * inv_2 % MOD\n        S_odd = (total_strings - value_diff + MOD) % MOD * inv_2 % MOD\n\n        if g == 0:\n            ans = S_even\n        else:\n            ans = S_odd\n\n    print(ans)\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 568,
        "completion_token_count": 10521,
        "thoughts_token_count": 0
    }
}