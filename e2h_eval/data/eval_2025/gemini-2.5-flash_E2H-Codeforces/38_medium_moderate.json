{
    "start": 1758294842.4217641,
    "end": 1758294903.1685445,
    "start-formatted": "2025-09-20 00:14 KST",
    "end-formatted": "2025-09-20 00:15 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "**Problem Decomposition and Strategic Approach**\n\nOkay, so I'm tackling a programming challenge that wants me to find two things about a special kind of graph: the smallest number of nodes it can have, and then the biggest possible number of \"unidirectional pairs\" *within* that smallest graph. First, I need to figure out what the heck a \"p-reachable directed graph\" is. Turns out it's a directed graph with a particular number, *p*, of ordered pairs of nodes where you can get from one to the other and back again – these are called \"reachable from each other.\"  A \"unidirectional pair,\" on the other hand, is a pair where you can go one way, but not the reverse.\n\nMy goal is to minimize the number of nodes in the graph and, for that minimum number, maximize the unidirectional pairs.  I can see that the \"p-reachable\" bit is the key constraint, so I'll start there.  \n\n**Analyzing Reachability and Strongly Connected Components**\n\nThe \"reachable from each other\" pairs are all about strongly connected components (SCCs) in the graph. If two nodes are in the same SCC, they are reachable from each other, and if we count pairs (u,v) where u<v, we are counting a k * (k-1) / 2 where k is the size of the component.\n\nSo, to get exactly *p* reachable pairs, I have to figure out how to arrange the SCCs and what sizes they need to be. The smaller the total number of nodes I can get while still hitting *p*, the better. I can minimize the total number of nodes by making the SCCs as large as possible.\n\nThis sounds like a greedy algorithm is in order. Start with the biggest possible SCC that doesn't put us over *p* reachable pairs, then repeat until we've used up *p*. The goal is to come up with a strategy for sizing these SCCs to achieve the smallest possible total number of nodes, `n_min`.\n\n**Optimizing for Minimum Nodes**\n\nSince the function `k * (k - 1) / 2` grows faster than `k`, I can see that using larger SCCs will lead to smaller node counts compared to many smaller SCCs. Using pre-computed values for f(k), which is `k * (k-1) / 2`, for a range of k should do it.\n\n**Maximizing Unidirectional Pairs**\n\nNow, with my `n_min` and list of sizes of the SCCs, I need to maximize the number of unidirectional pairs.  To get the most unidirectional pairs, it seems that there should be some structure. It turns out that arranging the SCCs in a chain is the answer. That is, if I arrange the SCCs such that there is only an edge going from one SCC to another if the index of the former is lower.  This way, any node in an SCC with a lower index can reach any node in an SCC with a higher index, but not the other way around.  Each unidirectional pair will be of the form (u,v) where u is in C_i, v is in C_j, and i < j. \n\nNow the fun part: finding a formula for the max count of the unidirectional pairs.  This is where I can use the sum `n_min ^ 2 - sum(k_i^2)`. Here, `k_i` is the size of each SCC.\n\n**Implementation and Graph Construction**\n\nTo build the solution, first I'll use the greedy algorithm to find my minimum number of nodes, `n_min`, and the sizes of the SCCs, represented by the array scc_sizes. Next, I apply the formula `n_min^2 - sum(k_i^2)` to compute the maximum number of unidirectional pairs.\n\nI think I've got a solid plan. Now to code it up!\n",
    "response": "The problem asks us to find two values for a given integer `p`:\n1. The minimum number of nodes `n` required to create a `p`-reachable directed graph.\n2. The maximum number of unidirectional pairs of nodes among all such `p`-reachable directed graphs with the minimum number of nodes `n`.\n\nLet's first understand the definitions:\n- A pair of nodes `(u, v)` is \"reachable from each other\" if there's a path from `u` to `v` and a path from `v` to `u`. This means `u` and `v` belong to the same Strongly Connected Component (SCC).\n- A graph is `p`-reachable if it contains exactly `p` ordered pairs `(u, v)` such that `u < v` and `u` and `v` are reachable from each other.\n- An ordered pair `(u, v)` is \"unidirectional\" if `u \\neq v`, there's a path from `u` to `v`, and there's no path from `v` to `u`. This implies `u` and `v` are in different SCCs, and `v` is reachable from `u`.\n\n**Part 1: Minimum number of nodes `n`**\n\nLet the graph have `m` SCCs with sizes `k_1, k_2, ..., k_m`.\nIf an SCC has `k` nodes, any pair `(u, v)` within this SCC (where `u < v`) satisfies the \"reachable from each other\" condition. The number of such pairs is `k * (k - 1) / 2`.\nThe total number of `p`-reachable pairs in the graph is the sum of `k_i * (k_i - 1) / 2` for all SCCs.\nWe want to minimize the total number of nodes `n = sum(k_i)`.\n\nTo minimize `n` for a fixed `p`, we should make the SCCs as large as possible. This is because the function `f(k) = k * (k - 1) / 2` (number of pairs within an SCC of size `k`) grows quadratically with `k`, while `k` (number of nodes) grows linearly. For a given number of pairs, larger `k` values are more \"efficient\" in terms of nodes.\nFor example, to get 3 pairs:\n- One SCC of size `k=3`: `3 * (3-1) / 2 = 3` pairs. `n = 3` nodes.\n- Three SCCs of size `k=2`: `3 * (2 * (2-1) / 2) = 3 * 1 = 3` pairs. `n = 2 + 2 + 2 = 6` nodes.\nClearly, 3 nodes is better.\n\nSo, a greedy strategy works:\nStart with `n_min = 0` and `p_remaining = p`.\nMaintain a list `scc_sizes` to store the sizes of the SCCs.\nWhile `p_remaining > 0`:\n  Find the largest integer `k` such that `k * (k - 1) / 2 <= p_remaining`.\n  Add `k` to `n_min`.\n  Subtract `k * (k - 1) / 2` from `p_remaining`.\n  Add `k` to `scc_sizes`.\n\nThe maximum value of `p` is `2 * 10^5`.\nIf `k * (k - 1) / 2 \\approx 2 * 10^5`, then `k^2 \\approx 4 * 10^5`, so `k \\approx \\sqrt{4 * 10^5} \\approx 632`.\nWe can precompute `k * (k - 1) / 2` for `k` up to about 633 to quickly find the largest `k`.\n\n**Example for `p=4`:**\n1. `p_remaining = 4`. Largest `k` such that `k * (k - 1) / 2 <= 4` is `k=3` (`3 * 2 / 2 = 3`).\n   `n_min = 3`. `p_remaining = 4 - 3 = 1`. `scc_sizes = [3]`.\n2. `p_remaining = 1`. Largest `k` such that `k * (k - 1) / 2 <= 1` is `k=2` (`2 * 1 / 2 = 1`).\n   `n_min = 3 + 2 = 5`. `p_remaining = 1 - 1 = 0`. `scc_sizes = [3, 2]`.\nResult: `n_min = 5`.\n\n**Part 2: Maximum number of unidirectional pairs**\n\nLet the SCCs found be `C_1, C_2, ..., C_m` with sizes `k_1, k_2, ..., k_m`. The total number of nodes is `n_min = sum(k_i)`.\nTo maximize unidirectional pairs, we should connect these SCCs in a way that creates paths in one direction but not the other. The most effective way is to arrange them in a linear chain (a topological sort): `C_1 -> C_2 -> ... -> C_m`.\nThis can be achieved by adding a single edge from an arbitrary node in `C_i` to an arbitrary node in `C_{i+1}` for all `i` from `1` to `m-1`. Within each SCC, we can make it a cycle (e.g., `1 -> 2 -> ... -> k -> 1`).\n\nIn such a chain:\n- For any `u \\in C_i` and `v \\in C_j`:\n  - If `i < j`: `u` can reach `v` (via the inter-SCC edges). `v` cannot reach `u` (because edges only go from lower-indexed SCCs to higher-indexed ones). So `(u, v)` is a unidirectional pair. There are `k_i * k_j` such pairs.\n  - If `i > j`: `v` can reach `u`. `u` cannot reach `v`. So `(v, u)` is a unidirectional pair. There are `k_j * k_i` such pairs.\n  - If `i = j`: `u` and `v` are in the same SCC. No unidirectional pairs between them.\n\nThe total number of ordered pairs of distinct nodes `(u, v)` in the graph is `n_min * (n_min - 1)`.\nThe number of pairs `(u, v)` where `u` and `v` are in the *same* SCC is `sum(k_i * (k_i - 1))`. These are not unidirectional.\nThe number of pairs `(u, v)` where `u` and `v` are in *different* SCCs is `n_min * (n_min - 1) - sum(k_i * (k_i - 1))`.\nAlternatively, this is `n_min^2 - sum(k_i^2)`.\nEach such pair `(u, v)` (where `u \\in C_i, v \\in C_j, i \\neq j`) contributes to exactly one unidirectional pair. If `i < j`, then `(u,v)` is unidirectional. If `j < i`, then `(v,u)` is unidirectional.\nSo, the total number of unidirectional pairs is `sum_{i \\neq j} (k_i * k_j)`.\nThis sum can be computed as `(sum k_i)^2 - sum(k_i^2)`.\nSince `sum k_i = n_min`, the maximum number of unidirectional pairs is `n_min^2 - sum(k_i^2 for k_i in scc_sizes)`.\n\n**Example for `p=4` (continued):**\n`n_min = 5`. `scc_sizes = [3, 2]`.\n`sum(k_i^2) = 3^2 + 2^2 = 9 + 4 = 13`.\nMaximum unidirectional pairs = `n_min^2 - sum(k_i^2)` = `5^2 - 13 = 25 - 13 = 12`.\n\nLet's check the examples:\n- `p=3`:\n  - `n_min = 3`. `scc_sizes = [3]`.\n  - `sum(k_i^2) = 3^2 = 9`.\n  - Max unidirectional pairs = `3^2 - 9 = 0`.\n  - Output: `3 0`. Matches.\n- `p=4`:\n  - `n_min = 5`. `scc_sizes = [3, 2]`.\n  - `sum(k_i^2) = 3^2 + 2^2 = 9 + 4 = 13`.\n  - Max unidirectional pairs = `5^2 - 13 = 12`.\n  - Output: `5 12`. Wait, example output is `5 6`. My formula is `n_min^2 - sum(k_i^2)`. The example output implies `(n_min^2 - sum(k_i^2)) / 2`.\n\nLet's re-read carefully: \"an ordered pair of nodes `(u, v)` ... unidirectional if `u \\neq v`, there exists a path from `u` to `v`, and there are no paths from `v` to `u`.\"\nMy previous interpretation of `sum_{i < j} (k_i * k_j)` for the linear chain `C_1 -> C_2 -> ... -> C_m` was correct.\nIf `u \\in C_i` and `v \\in C_j`:\n- If `i < j`: `(u,v)` is unidirectional.\n- If `i > j`: `(v,u)` is unidirectional. `(u,v)` is NOT unidirectional because there is a path `v -> u`.\nThe total set of unidirectional pairs is `{(u,v) | u \\in C_i, v \\in C_j, i < j}`.\nThe number of such pairs is indeed `sum_{i < j} (k_i * k_j)`.\nAnd `sum_{i < j} (k_i * k_j) = ((sum k_i)^2 - sum(k_i^2)) / 2`.\nThis means the formula is `(n_min^2 - sum(k_i^2 for k_i in scc_sizes)) / 2`.\n\nLet's recheck `p=4` with this formula:\n`n_min = 5`. `scc_sizes = [3, 2]`.\n`sum(k_i^2) = 3^2 + 2^2 = 9 + 4 = 13`.\nMax unidirectional pairs = `(5^2 - 13) / 2 = (25 - 13) / 2 = 12 / 2 = 6`.\nThis matches the example output `5 6`.\n\nThe reasoning is solid now.\n\n**Edge case `p=0`:**\n- `n_min = 0`. `scc_sizes = []`.\n- `sum(k_i^2)` for an empty list is `0`.\n- Max unidirectional pairs = `(0^2 - 0) / 2 = 0`.\n- Output: `0 0`. Matches.\n\n**Implementation details:**\n- Precompute `k * (k - 1) / 2` values. A list `scc_pairs_count[k]` can store this. Max `k` is ~633.\n- Iterate `k` downwards from `k_max` to find the largest `k` for `p_remaining`.\n- `k_max` can be found by solving `k * (k-1) / 2 = 2 * 10^5`. `k^2 - k - 4 * 10^5 = 0`. `k = (1 + sqrt(1 + 16 * 10^5)) / 2`. `k \\approx (1 + sqrt(1.6 * 10^6)) / 2 \\approx (1 + 1264.9) / 2 \\approx 632.9`. So `k_max = 633` is sufficient.\n\n```python\nimport math\n\ndef solve():\n    p = int(input())\n\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    # Precompute k * (k - 1) / 2 values\n    # Max k for p = 2 * 10^5 is approx 633\n    max_k = 0\n    # k * (k-1)/2 <= 2*10^5 => k^2 - k - 4*10^5 <= 0\n    # Roots of k^2 - k - 4*10^5 = 0 are (1 +/- sqrt(1 + 16*10^5))/2\n    # (1 + sqrt(1 + 1600000))/2 = (1 + sqrt(1600001))/2 approx (1 + 1264.91)/2 approx 632.95\n    # So max k is 632. We can go up to 633 or 634 to be safe.\n    \n    # Store k_val -> k_val * (k_val - 1) / 2\n    scc_pairs_map = {}\n    for k_val in range(2, 635): # k must be at least 2 for pairs\n        scc_pairs_map[k_val] = k_val * (k_val - 1) // 2\n        if scc_pairs_map[k_val] > p: # Optimization: stop if pairs exceed max p\n            break\n        max_k = k_val # Keep track of the largest k that could be used\n\n    n_min = 0\n    scc_sizes = []\n    p_remaining = p\n\n    # Greedy approach to find minimum n and SCC sizes\n    # Iterate k downwards from max_k\n    for k_val in range(max_k, 1, -1):\n        while p_remaining >= scc_pairs_map[k_val]:\n            n_min += k_val\n            p_remaining -= scc_pairs_map[k_val]\n            scc_sizes.append(k_val)\n        if p_remaining == 0:\n            break\n\n    # Calculate max unidirectional pairs\n    # Formula: (n_min^2 - sum(k_i^2)) / 2\n    sum_k_sq = 0\n    for k_val in scc_sizes:\n        sum_k_sq += k_val * k_val\n    \n    max_unidirectional_pairs = (n_min * n_min - sum_k_sq) // 2\n\n    print(n_min, max_unidirectional_pairs)\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef solve():\n    p = int(input())\n\n    if p == 0:\n        print(\"0 0\")\n        return\n\n    # Precompute k * (k - 1) / 2 values\n    # Max k for p = 2 * 10^5 is approx 633\n    max_k = 0\n    # k * (k-1)/2 <= 2*10^5 => k^2 - k - 4*10^5 <= 0\n    # Roots of k^2 - k - 4*10^5 = 0 are (1 +/- sqrt(1 + 16*10^5))/2\n    # (1 + sqrt(1 + 1600000))/2 = (1 + sqrt(1600001))/2 approx (1 + 1264.91)/2 approx 632.95\n    # So max k is 632. We can go up to 633 or 634 to be safe.\n    \n    # Store k_val -> k_val * (k_val - 1) / 2\n    scc_pairs_map = {}\n    for k_val in range(2, 635): # k must be at least 2 for pairs\n        scc_pairs_map[k_val] = k_val * (k_val - 1) // 2\n        if scc_pairs_map[k_val] > p: # Optimization: stop if pairs exceed max p\n            break\n        max_k = k_val # Keep track of the largest k that could be used\n\n    n_min = 0\n    scc_sizes = []\n    p_remaining = p\n\n    # Greedy approach to find minimum n and SCC sizes\n    # Iterate k downwards from max_k\n    for k_val in range(max_k, 1, -1):\n        while p_remaining >= scc_pairs_map[k_val]:\n            n_min += k_val\n            p_remaining -= scc_pairs_map[k_val]\n            scc_sizes.append(k_val)\n        if p_remaining == 0:\n            break\n\n    # Calculate max unidirectional pairs\n    # Formula: (n_min^2 - sum(k_i^2)) / 2\n    sum_k_sq = 0\n    for k_val in scc_sizes:\n        sum_k_sq += k_val * k_val\n    \n    max_unidirectional_pairs = (n_min * n_min - sum_k_sq) // 2\n\n    print(n_min, max_unidirectional_pairs)\n\nsolve()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 483,
        "completion_token_count": 3485,
        "thoughts_token_count": 5430
    }
}