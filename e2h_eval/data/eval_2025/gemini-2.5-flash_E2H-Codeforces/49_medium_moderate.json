{
    "start": 1758294844.3245082,
    "end": 1758294934.6681788,
    "start-formatted": "2025-09-20 00:14 KST",
    "end-formatted": "2025-09-20 00:15 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "**Algorithm for the Mushroom Strife Problem**\n\nOkay, so I've got this competitive programming problem, and I need to come up with a Python solution for the \"Mushroom Strife\" problem. We're dealing with a graph where the edges represent roads, and each road has GCD and LCM constraints on the number of mushrooms on the connected lawns. I've broken down the problem and have a good grasp of the key constraints.\n\n**Understanding the Core Mathematics**\n\nFirst things first, it's critical that the product of the GCD and LCM of two numbers equals their product. `GCD(a, b) * LCM(a, b) = a * b`. That's fundamental here.\n\nThe GCD must divide the LCM for any valid solution. If this doesn't hold, we have no answer and can bail. Let `g` be the GCD and `l` be the LCM for an edge. We can express the number of mushrooms on lawns `u` and `v` as `x_u = g * a` and `x_v = g * b` where `GCD(a, b) = 1`. Then, `l = g * a * b`, which implies `a * b = l / g`. Also, `g * l = x_u * x_v`. `x_u` must be a multiple of `g`, and also has to divide `l`. So `x_u = g * a`, where `a` is a divisor of `l/g`, and `GCD(a, l/g)` should be equal to 1. Now, `x_v = (g * l) / x_u`. Also, for any given node `i` we must combine all such constraints from all edges it is part of, to find feasible ranges for mushrooms counts.\n\nEssentially, for a lawn to have a valid mushroom count, it needs to be a multiple of the LCM of the GCDs of the edges connected to it and be a divisor of the GCD of the LCMs of the edges.\n\n**Prime Factorization is the Key**\n\nSince the numbers are within a range of 10^6, prime factorization is the way to go. It seems like the best approach.  Let's consider the prime factors.\n\nFor each edge `(u, v)` with `g, l`, and a prime `p`:\n*   `min(e_u(p), e_v(p)) = e_g(p)` (exponent of `p` in `g`)\n*   `max(e_u(p), e_v(p)) = e_l(p)` (exponent of `p` in `l`)\n\nSo, for each prime, `e_u(p)` and `e_v(p)` must be equal to `e_g(p)` and `e_l(p)`, either directly or swapped. This is the crucial insight that should lead to a solution. We need to decide a value for each node for each prime. This is where things get interesting. We have two possibilities for each node for each prime factor - this implies a 2-coloring-like structure.\n\n**Building a Graph for Exponent Assignment**\n\nFor a fixed prime `p`, and an edge `(u, v)`:\n\n*   If `e_g(p) == e_l(p)`, then `e_u(p) == e_v(p)`. So, the exponents are forced. We can propagate this across the graph using DSU or DFS/BFS.\n*   If `e_g(p) < e_l(p)`, then `e_u(p)` and `e_v(p)` must take values of `e_g(p)` or `e_l(p)`, but in opposite order. This is like a \"not equal\" constraint between `u` and `v`. This forms a 2-coloring problem.\n\nI'm thinking of building a separate graph for each prime. The nodes are the lawns, and the edges are determined by this equality/inequality relationship.\n\n**The Implementation Plan**\n\nMy approach would be as follows:\n\n1.  **Preprocessing:**\n    *   Sieve of Eratosthenes to pre-compute primes.\n    *   A function `get_prime_factorization()` to decompose a number into its prime factors with exponents.\n\n2.  **Edge Processing:**\n    *   Iterate through each edge `(u, v, g, l)`.\n    *   Check if `l % g == 0`. If not, return \"NO\".\n\n3.  **Prime-Specific Graph Construction and Propagation:**\n    *   For each prime `p` encountered in `g` or `l`:\n        *   Create an",
    "response": "The problem asks us to restore the number of mushrooms on `n` lawns given `m` roads. For each road connecting lawns `u` and `v`, we are given `g = GCD(x_u, x_v)` and `l = LCM(x_u, x_v)`, where `x_i` is the number of mushrooms on lawn `i`. We need to find any valid assignment of `x_i` or report that none exists. The values `x_i`, `g`, `l` are between 1 and 10^6.\n\n**Key Mathematical Property:**\nFor any two positive integers `a` and `b`, `GCD(a, b) * LCM(a, b) = a * b`.\nThis implies that for an edge `(u, v)` with given `g` and `l`:\n1. `x_u * x_v = g * l`.\n2. `l` must be a multiple of `g`. If `l % g != 0`, no solution exists.\n\n**Prime Factorization Approach:**\nLet `x_i = product(p_k^{e_i(p_k)})` be the prime factorization of `x_i`.\nSimilarly, `g = product(p_k^{e_g(p_k)})` and `l = product(p_k^{e_l(p_k)})`.\nFor each prime `p_k`:\n`min(e_u(p_k), e_v(p_k)) = e_g(p_k)`\n`max(e_u(p_k), e_v(p_k)) = e_l(p_k)`\n\nThis implies that for each prime `p_k`, the set `{e_u(p_k), e_v(p_k)}` must be equal to the set `{e_g(p_k), e_l(p_k)}`.\nSpecifically:\n* If `e_g(p_k) > e_l(p_k)`, this is impossible (GCD exponent cannot be greater than LCM exponent). This is covered by `l % g != 0`.\n* If `e_g(p_k) == e_l(p_k)`, then `e_u(p_k)` and `e_v(p_k)` must both be equal to `e_g(p_k)`.\n* If `e_g(p_k) < e_l(p_k)`, then one of `e_u(p_k), e_v(p_k)` must be `e_g(p_k)` and the other must be `e_l(p_k)`. They must be \"different\".\n\nThis problem can be solved by determining the exponent `e_i(p)` for each lawn `i` and each prime `p` that appears in any `g` or `l`. We can process each prime independently.\n\n**Algorithm Steps:**\n\n**1. Precomputation:**\n   * Find all primes up to `MAX_VAL = 10^6` using a Sieve of Eratosthenes. Store them in a list `primes`.\n   * Create a `min_prime_factor` array (or `lp` in some sieve implementations) to quickly find prime factors for any number up to `MAX_VAL`. This allows efficient prime factorization.\n   * `get_prime_factorization(num)`: A function that takes an integer `num` and returns a dictionary `{prime: exponent}`.\n\n**2. Data Structures for Graph and Exponents:**\n   * `adj_nodes[i]`: A list of neighbors for lawn `i`.\n   * `adj_edge_data[u][v]`: Stores `(g, l)` for the edge `(u, v)`. This is a dictionary of dictionaries for efficient lookup.\n   * `all_primes_set`: A set to collect all unique prime factors encountered in any `g` or `l` from the input.\n   * `exp_map[i][p]`: A dictionary of dictionaries, `exp_map[node_idx][prime]` stores the determined exponent of `prime` for `node_idx`. Initialize all values to -1 (undetermined).\n   * `q`: A `deque` for BFS-like propagation of fixed exponents. Each element is `(node_idx, prime)`.\n\n**3. Initial Pass - Constraints and Fixed Exponents:**\n   * Read `n` and `m`.\n   * For each edge `(u, v, g, l)`:\n     * Add `v` to `adj_nodes[u]` and `u` to `adj_nodes[v]`.\n     * Store `(g, l)` in `adj_edge_data[u][v]` and `adj_edge_data[v][u]`.\n     * If `l % g != 0`, print \"NO\" and exit.\n     * Get prime factorizations `factors_g` and `factors_l` for `g` and `l`.\n     * Add all primes from `factors_g` and `factors_l` to `all_primes_set`.\n     * For each prime `p` in `factors_g` or `factors_l`:\n       * `eg = factors_g.get(p, 0)`\n       * `el = factors_l.get(p, 0)`\n       * If `eg == el`:\n         * This means `e_u(p)` and `e_v(p)` must both be `eg`.\n         * Check for conflicts: If `exp_map[u][p]` is already set to a different value, print \"NO\" and exit. Same for `v`.\n         * If `exp_map[u][p]` is -1, set it to `eg` and add `(u, p)` to `q`.\n         * If `exp_map[v][p]` is -1, set it to `eg` and add `(v, p)` to `q`.\n\n**4. Propagation of Fixed Exponents (BFS):**\n   * While `q` is not empty:\n     * Dequeue `(curr_node, curr_prime)`.\n     * `curr_exp_val = exp_map[curr_node][curr_prime]`.\n     * For each `neighbor_node` in `adj_nodes[curr_node]`:\n       * Get `(g_adj, l_adj)` from `adj_edge_data[curr_node][neighbor_node]`.\n       * Get `factors_g_adj` and `factors_l_adj`.\n       * `eg_adj = factors_g_adj.get(curr_prime, 0)`\n       * `el_adj = factors_l_adj.get(curr_prime, 0)`\n       * If `eg_adj == el_adj`:\n         * If `curr_exp_val != eg_adj`, print \"NO\" and exit (conflict).\n         * If `exp_map[neighbor_node][curr_prime]` is -1, set it to `eg_adj` and enqueue `(neighbor_node, curr_prime)`.\n         * Else if `exp_map[neighbor_node][curr_prime] != eg_adj`, print \"NO\" and exit (conflict).\n       * Else (`eg_adj < el_adj`):\n         * `curr_exp_val` must be either `eg_adj` or `el_adj`. If not, print \"NO\" and exit.\n         * Determine `neighbor_exp_val`: if `curr_exp_val == eg_adj`, then `neighbor_exp_val = el_adj`; else `neighbor_exp_val = eg_adj`.\n         * If `exp_map[neighbor_node][curr_prime]` is -1, set it to `neighbor_exp_val` and enqueue `(neighbor_node, curr_prime)`.\n         * Else if `exp_map[neighbor_node][curr_prime] != neighbor_exp_val`, print \"NO\" and exit (conflict).\n\n**5. Handling Undetermined Exponents (2-Coloring on Components):**\n   * For each prime `p` in `all_primes_set`:\n     * For each node `i` from 1 to `n`:\n       * If `exp_map[i][p]` is still -1:\n         * This node is part of a connected component for prime `p` where exponents are not yet fixed. We need to make an arbitrary choice for one node in this component and propagate it.\n         * Find an incident edge `(i, j)` where `e_g(p) < e_l(p)` (an \"alternating\" edge).\n         * If such an edge exists:\n           * Arbitrarily set `exp_map[i][p]` to `e_g(p)` from that edge. Add `(i, p)` to `q`.\n           * Run another BFS-like propagation (similar to step 4) to determine exponents for the rest of this component. If any conflict arises, print \"NO\" and exit.\n         * If no such alternating edge exists for node `i` (meaning all incident edges forced `eg == el`, or no incident edges for prime `p`), then `e_i(p)` can be 0 without affecting any constraints. Set `exp_map[i][p] = 0`.\n\n**6. Constructing Final `x_i` Values:**\n   * Initialize `ans_x[i] = 1` for all `i`.\n   * For each node `i` from 1 to `n`:\n     * For each prime `p` in `all_primes_set`:\n       * `ans_x[i] *= (p ** exp_map[i][p])`.\n   * Print \"YES\".\n   * Print `ans_x[1], ans_x[2], ..., ans_x[n]`.\n\n**Edge Cases and Constraints:**\n* `n=1, m=0`: `ans_x[1]` can be 1.\n* `x_i` values must be between 1 and 10^6. The problem statement guarantees initial values were in this range. Our construction should also produce values in this range if a solution exists, because we are using the given `g, l` values. The maximum exponent for any prime `p` in `10^6` is small (e.g., `2^19 < 10^6 < 2^20`).\n\n**Time Complexity:**\n* Sieve: `O(MAX_VAL log log MAX_VAL)`.\n* Prime factorization: For each `g, l`, `O(log MAX_VAL)` using `min_prime_factor`. Total for `m` edges: `O(m log MAX_VAL)`.\n* Graph construction: `O(n + m)`.\n* BFS propagation: Each `(node, prime)` pair is enqueued at most once. The number of primes in `all_primes_set` is `O(MAX_VAL / log MAX_VAL)` (number of primes up to `MAX_VAL`). Max value of `n` is `10^5`. So, total `O(n * num_primes_in_set)` states. For each state, we iterate over neighbors. Max degree is `n-1`. Total `O(sum(degree_u * num_primes_in_factors(g_uv, l_uv)))`. This is roughly `O(m * log MAX_VAL * log MAX_VAL)` or `O(m * log MAX_VAL * average_degree_of_prime_graph)`.\n  A more precise bound for the BFS part: Each edge `(u, v)` (and its associated `g, l`) is processed for each prime `p` that divides `g` or `l`. The total number of `(p, (u,v))` pairs is `sum_{edge (u,v)} (num_prime_factors(g_uv) + num_prime_factors(l_uv))`. Since `num_prime_factors(N)` is `O(log N)`, this is `O(m log MAX_VAL)`. Each such pair leads to constant work (checking/setting exponent, enqueuing). So the BFS part is efficient.\n* Final `x_i` construction: `O(n * num_primes_in_set)`.\n\nOverall complexity should be dominated by sieve and `O(m log MAX_VAL + n * num_primes_in_set)`. Given `n, m <= 10^5` and `MAX_VAL = 10^6`, this is feasible. `num_primes_in_set` is about 78498. `log MAX_VAL` is about 20.\n\n```python\nimport sys\nfrom collections import deque\n\n# Max value for numbers (10^6)\nMAX_VAL = 10**6\n\n# Sieve of Eratosthenes to precompute primes and smallest prime factor (SPF)\nspf = [0] * (MAX_VAL + 1)\nprimes = []\n\ndef sieve():\n    for i in range(2, MAX_VAL + 1):\n        if spf[i] == 0:  # i is prime\n            spf[i] = i\n            primes.append(i)\n        for p in primes:\n            if p > spf[i] or i * p > MAX_VAL:\n                break\n            spf[i * p] = p\n\n# Function to get prime factorization of a number\ndef get_prime_factorization(n_val):\n    factors = {}\n    if n_val == 0: # Should not happen based on constraints (1 <= GCD, LCM)\n        return factors\n    temp_n = n_val\n    while temp_n > 1:\n        p = spf[temp_n]\n        count = 0\n        while temp_n % p == 0:\n            count += 1\n            temp_n //= p\n        factors[p] = count\n    return factors\n\ndef solve():\n    sieve() # Precompute primes and SPF\n\n    n, m = map(int, sys.stdin.readline().split())\n\n    edges = []\n    adj_nodes = [[] for _ in range(n + 1)]\n    adj_edge_data = {} # (u, v) -> (g, l)\n\n    all_primes_set = set()\n\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        edges.append((u, v, g, l))\n\n        adj_nodes[u].append(v)\n        adj_nodes[v].append(u)\n        \n        # Store edge data in a consistent way (e.g., u < v)\n        # Or use a dictionary of dictionaries for direct lookup\n        if u not in adj_edge_data:\n            adj_edge_data[u] = {}\n        if v not in adj_edge_data:\n            adj_edge_data[v] = {}\n        adj_edge_data[u][v] = (g, l)\n        adj_edge_data[v][u] = (g, l)\n\n        if l % g != 0:\n            sys.stdout.write(\"NO\\n\")\n            return\n\n        factors_g = get_prime_factorization(g)\n        factors_l = get_prime_factorization(l)\n\n        all_primes_set.update(factors_g.keys())\n        all_primes_set.update(factors_l.keys())\n\n    # exp_map[node_idx][prime] stores the exponent for that prime at that node\n    # Initialize with -1 (undetermined)\n    exp_map = {i: {p: -1 for p in all_primes_set} for i in range(1, n + 1)}\n\n    q = deque()\n\n    # First pass: Process fixed exponents (where eg == el) and add to queue\n    for u, v, g, l in edges:\n        factors_g = get_prime_factorization(g)\n        factors_l = get_prime_factorization(l)\n\n        for p in all_primes_set:\n            eg = factors_g.get(p, 0)\n            el = factors_l.get(p, 0)\n\n            if eg == el:\n                # Both u and v must have exponent eg for prime p\n                if exp_map[u][p] != -1 and exp_map[u][p] != eg:\n                    sys.stdout.write(\"NO\\n\")\n                    return\n                if exp_map[u][p] == -1:\n                    exp_map[u][p] = eg\n                    q.append((u, p))\n\n                if exp_map[v][p] != -1 and exp_map[v][p] != eg:\n                    sys.stdout.write(\"NO\\n\")\n                    return\n                if exp_map[v][p] == -1:\n                    exp_map[v][p] = eg\n                    q.append((v, p))\n\n    # Propagation of fixed exponents using BFS\n    while q:\n        curr_node, curr_prime = q.popleft()\n        curr_exp_val = exp_map[curr_node][curr_prime]\n\n        for neighbor_node in adj_nodes[curr_node]:\n            g_adj, l_adj = adj_edge_data[curr_node][neighbor_node]\n            factors_g_adj = get_prime_factorization(g_adj)\n            factors_l_adj = get_prime_factorization(l_adj)\n\n            eg_adj = factors_g_adj.get(curr_prime, 0)\n            el_adj = factors_l_adj.get(curr_prime, 0)\n\n            if eg_adj == el_adj:\n                if curr_exp_val != eg_adj:\n                    sys.stdout.write(\"NO\\n\")\n                    return\n                if exp_map[neighbor_node][curr_prime] == -1:\n                    exp_map[neighbor_node][curr_prime] = eg_adj\n                    q.append((neighbor_node, curr_prime))\n                elif exp_map[neighbor_node][curr_prime] != eg_adj:\n                    sys.stdout.write(\"NO\\n\")\n                    return\n            else: # eg_adj < el_adj, alternating case\n                if curr_exp_val != eg_adj and curr_exp_val != el_adj:\n                    sys.stdout.write(\"NO\\n\")\n                    return\n                \n                neighbor_exp_val = el_adj if curr_exp_val == eg_adj else eg_adj\n\n                if exp_map[neighbor_node][curr_prime] == -1:\n                    exp_map[neighbor_node][curr_prime] = neighbor_exp_val\n                    q.append((neighbor_node, curr_prime))\n                elif exp_map[neighbor_node][curr_prime] != neighbor_exp_val:\n                    sys.stdout.write(\"NO\\n\")\n                    return\n\n    # Handle undetermined exponents (connected components without fixed values)\n    # This involves making arbitrary choices for alternating edges\n    for p in all_primes_set:\n        for i in range(1, n + 1):\n            if exp_map[i][p] == -1:\n                # This node is part of an uncolored component for prime p\n                # Try to find an alternating edge to make an initial choice\n                found_alternating_edge = False\n                initial_eg = -1\n                \n                # Check neighbors to see if there's an alternating edge to base choice on\n                for neighbor_node in adj_nodes[i]:\n                    g_ij, l_ij = adj_edge_data[i][neighbor_node]\n                    factors_g_ij = get_prime_factorization(g_ij)\n                    factors_l_ij = get_prime_factorization(l_ij)\n                    \n                    eg_ij = factors_g_ij.get(p, 0)\n                    el_ij = factors_l_ij.get(p, 0)\n\n                    if eg_ij < el_ij:\n                        found_alternating_edge = True\n                        initial_eg = eg_ij # Arbitrarily pick eg for current node\n                        break\n                \n                if found_alternating_edge:\n                    exp_map[i][p] = initial_eg\n                    q.append((i, p))\n\n                    # Propagate this new choice\n                    while q:\n                        curr_node, curr_prime = q.popleft()\n                        curr_exp_val = exp_map[curr_node][curr_prime]\n\n                        for neighbor_node in adj_nodes[curr_node]:\n                            g_adj, l_adj = adj_edge_data[curr_node][neighbor_node]\n                            factors_g_adj = get_prime_factorization(g_adj)\n                            factors_l_adj = get_prime_factorization(l_adj)\n\n                            eg_adj = factors_g_adj.get(curr_prime, 0)\n                            el_adj = factors_l_adj.get(curr_prime, 0)\n\n                            if eg_adj == el_adj:\n                                if curr_exp_val != eg_adj:\n                                    sys.stdout.write(\"NO\\n\")\n                                    return\n                                if exp_map[neighbor_node][curr_prime] == -1:\n                                    exp_map[neighbor_node][curr_prime] = eg_adj\n                                    q.append((neighbor_node, curr_prime))\n                                elif exp_map[neighbor_node][curr_prime] != eg_adj:\n                                    sys.stdout.write(\"NO\\n\")\n                                    return\n                            else: # eg_adj < el_adj, alternating case\n                                if curr_exp_val != eg_adj and curr_exp_val != el_adj:\n                                    sys.stdout.write(\"NO\\n\")\n                                    return\n                                \n                                neighbor_exp_val = el_adj if curr_exp_val == eg_adj else eg_adj\n\n                                if exp_map[neighbor_node][curr_prime] == -1:\n                                    exp_map[neighbor_node][curr_prime] = neighbor_exp_val\n                                    q.append((neighbor_node, curr_prime))\n                                elif exp_map[neighbor_node][curr_prime] != neighbor_exp_val:\n                                    sys.stdout.write(\"NO\\n\")\n                                    return\n                else:\n                    # No alternating edge for this node and prime, so it doesn't affect anything.\n                    # Default to exponent 0 (meaning the prime is not a factor)\n                    exp_map[i][p] = 0\n\n    # Construct final x_i values\n    ans_x = [1] * (n + 1)\n    for i in range(1, n + 1):\n        for p in all_primes_set:\n            if exp_map[i][p] != -1: # Should always be determined by now\n                ans_x[i] *= (p ** exp_map[i][p])\n        # If a node has no incident edges, its value can be 1 (or any value, but 1 is simplest).\n        # This is implicitly handled as exp_map[i][p] for all p would be 0 if no incident edges involving p.\n        # If all_primes_set is empty (no edges), all ans_x will be 1.\n\n    # Verification (Optional, but good for confidence)\n    for u, v, g, l in edges:\n        calc_g = 1\n        calc_l = 1\n        \n        # Calculate GCD and LCM from ans_x[u] and ans_x[v]\n        # Using prime factorizations for GCD/LCM is more robust than math.gcd/math.lcm\n        # as the numbers can be large.\n        \n        factors_u = get_prime_factorization(ans_x[u])\n        factors_v = get_prime_factorization(ans_x[v])\n        \n        all_factors_uv = set(factors_u.keys()).union(factors_v.keys())\n        \n        for p in all_factors_uv:\n            exp_u = factors_u.get(p, 0)\n            exp_v = factors_v.get(p, 0)\n            calc_g *= (p ** min(exp_u, exp_v))\n            calc_l *= (p ** max(exp_u, exp_v))\n            \n        if calc_g != g or calc_l != l:\n            # This should not happen if the logic is correct\n            sys.stdout.write(\"NO\\n\")\n            return\n\n    sys.stdout.write(\"YES\\n\")\n    sys.stdout.write(\" \".join(map(str, ans_x[1:])) + \"\\n\")\n\n\nsolve()\n\n```",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\n# Max value for numbers (10^6)\nMAX_VAL = 10**6\n\n# Sieve of Eratosthenes to precompute primes and smallest prime factor (SPF)\nspf = [0] * (MAX_VAL + 1)\nprimes = []\n\ndef sieve():\n    for i in range(2, MAX_VAL + 1):\n        if spf[i] == 0:  # i is prime\n            spf[i] = i\n            primes.append(i)\n        for p in primes:\n            if p > spf[i] or i * p > MAX_VAL:\n                break\n            spf[i * p] = p\n\n# Function to get prime factorization of a number\ndef get_prime_factorization(n_val):\n    factors = {}\n    if n_val == 0: # Should not happen based on constraints (1 <= GCD, LCM)\n        return factors\n    temp_n = n_val\n    while temp_n > 1:\n        p = spf[temp_n]\n        count = 0\n        while temp_n % p == 0:\n            count += 1\n            temp_n //= p\n        factors[p] = count\n    return factors\n\ndef solve():\n    sieve() # Precompute primes and SPF\n\n    n, m = map(int, sys.stdin.readline().split())\n\n    edges = []\n    adj_nodes = [[] for _ in range(n + 1)]\n    adj_edge_data = {} # (u, v) -> (g, l)\n\n    all_primes_set = set()\n\n    for _ in range(m):\n        u, v, g, l = map(int, sys.stdin.readline().split())\n        edges.append((u, v, g, l))\n\n        adj_nodes[u].append(v)\n        adj_nodes[v].append(u)\n        \n        # Store edge data in a consistent way (e.g., u < v)\n        # Or use a dictionary of dictionaries for direct lookup\n        if u not in adj_edge_data:\n            adj_edge_data[u] = {}\n        if v not in adj_edge_data:\n            adj_edge_data[v] = {}\n        adj_edge_data[u][v] = (g, l)\n        adj_edge_data[v][u] = (g, l)\n\n        if l % g != 0:\n            sys.stdout.write(\"NO\\n\")\n            return\n\n        factors_g = get_prime_factorization(g)\n        factors_l = get_prime_factorization(l)\n\n        all_primes_set.update(factors_g.keys())\n        all_primes_set.update(factors_l.keys())\n\n    # exp_map[node_idx][prime] stores the exponent for that prime at that node\n    # Initialize with -1 (undetermined)\n    exp_map = {i: {p: -1 for p in all_primes_set} for i in range(1, n + 1)}\n\n    q = deque()\n\n    # First pass: Process fixed exponents (where eg == el) and add to queue\n    for u, v, g, l in edges:\n        factors_g = get_prime_factorization(g)\n        factors_l = get_prime_factorization(l)\n\n        for p in all_primes_set:\n            eg = factors_g.get(p, 0)\n            el = factors_l.get(p, 0)\n\n            if eg == el:\n                # Both u and v must have exponent eg for prime p\n                if exp_map[u][p] != -1 and exp_map[u][p] != eg:\n                    sys.stdout.write(\"NO\\n\")\n                    return\n                if exp_map[u][p] == -1:\n                    exp_map[u][p] = eg\n                    q.append((u, p))\n\n                if exp_map[v][p] != -1 and exp_map[v][p] != eg:\n                    sys.stdout.write(\"NO\\n\")\n                    return\n                if exp_map[v][p] == -1:\n                    exp_map[v][p] = eg\n                    q.append((v, p))\n\n    # Propagation of fixed exponents using BFS\n    while q:\n        curr_node, curr_prime = q.popleft()\n        curr_exp_val = exp_map[curr_node][curr_prime]\n\n        for neighbor_node in adj_nodes[curr_node]:\n            g_adj, l_adj = adj_edge_data[curr_node][neighbor_node]\n            factors_g_adj = get_prime_factorization(g_adj)\n            factors_l_adj = get_prime_factorization(l_adj)\n\n            eg_adj = factors_g_adj.get(curr_prime, 0)\n            el_adj = factors_l_adj.get(curr_prime, 0)\n\n            if eg_adj == el_adj:\n                if curr_exp_val != eg_adj:\n                    sys.stdout.write(\"NO\\n\")\n                    return\n                if exp_map[neighbor_node][curr_prime] == -1:\n                    exp_map[neighbor_node][curr_prime] = eg_adj\n                    q.append((neighbor_node, curr_prime))\n                elif exp_map[neighbor_node][curr_prime] != eg_adj:\n                    sys.stdout.write(\"NO\\n\")\n                    return\n            else: # eg_adj < el_adj, alternating case\n                if curr_exp_val != eg_adj and curr_exp_val != el_adj:\n                    sys.stdout.write(\"NO\\n\")\n                    return\n                \n                neighbor_exp_val = el_adj if curr_exp_val == eg_adj else eg_adj\n\n                if exp_map[neighbor_node][curr_prime] == -1:\n                    exp_map[neighbor_node][curr_prime] = neighbor_exp_val\n                    q.append((neighbor_node, curr_prime))\n                elif exp_map[neighbor_node][curr_prime] != neighbor_exp_val:\n                    sys.stdout.write(\"NO\\n\")\n                    return\n\n    # Handle undetermined exponents (connected components without fixed values)\n    # This involves making arbitrary choices for alternating edges\n    for p in all_primes_set:\n        for i in range(1, n + 1):\n            if exp_map[i][p] == -1:\n                # This node is part of an uncolored component for prime p\n                # Try to find an alternating edge to make an initial choice\n                found_alternating_edge = False\n                initial_eg = -1\n                \n                # Check neighbors to see if there's an alternating edge to base choice on\n                for neighbor_node in adj_nodes[i]:\n                    g_ij, l_ij = adj_edge_data[i][neighbor_node]\n                    factors_g_ij = get_prime_factorization(g_ij)\n                    factors_l_ij = get_prime_factorization(l_ij)\n                    \n                    eg_ij = factors_g_ij.get(p, 0)\n                    el_ij = factors_l_ij.get(p, 0)\n\n                    if eg_ij < el_ij:\n                        found_alternating_edge = True\n                        initial_eg = eg_ij # Arbitrarily pick eg for current node\n                        break\n                \n                if found_alternating_edge:\n                    exp_map[i][p] = initial_eg\n                    q.append((i, p))\n\n                    # Propagate this new choice\n                    while q:\n                        curr_node, curr_prime = q.popleft()\n                        curr_exp_val = exp_map[curr_node][curr_prime]\n\n                        for neighbor_node in adj_nodes[curr_node]:\n                            g_adj, l_adj = adj_edge_data[curr_node][neighbor_node]\n                            factors_g_adj = get_prime_factorization(g_adj)\n                            factors_l_adj = get_prime_factorization(l_adj)\n\n                            eg_adj = factors_g_adj.get(curr_prime, 0)\n                            el_adj = factors_l_adj.get(curr_prime, 0)\n\n                            if eg_adj == el_adj:\n                                if curr_exp_val != eg_adj:\n                                    sys.stdout.write(\"NO\\n\")\n                                    return\n                                if exp_map[neighbor_node][curr_prime] == -1:\n                                    exp_map[neighbor_node][curr_prime] = eg_adj\n                                    q.append((neighbor_node, curr_prime))\n                                elif exp_map[neighbor_node][curr_prime] != eg_adj:\n                                    sys.stdout.write(\"NO\\n\")\n                                    return\n                            else: # eg_adj < el_adj, alternating case\n                                if curr_exp_val != eg_adj and curr_exp_val != el_adj:\n                                    sys.stdout.write(\"NO\\n\")\n                                    return\n                                \n                                neighbor_exp_val = el_adj if curr_exp_val == eg_adj else eg_adj\n\n                                if exp_map[neighbor_node][curr_prime] == -1:\n                                    exp_map[neighbor_node][curr_prime] = neighbor_exp_val\n                                    q.append((neighbor_node, curr_prime))\n                                elif exp_map[neighbor_node][curr_prime] != neighbor_exp_val:\n                                    sys.stdout.write(\"NO\\n\")\n                                    return\n                else:\n                    # No alternating edge for this node and prime, so it doesn't affect anything.\n                    # Default to exponent 0 (meaning the prime is not a factor)\n                    exp_map[i][p] = 0\n\n    # Construct final x_i values\n    ans_x = [1] * (n + 1)\n    for i in range(1, n + 1):\n        for p in all_primes_set:\n            if exp_map[i][p] != -1: # Should always be determined by now\n                ans_x[i] *= (p ** exp_map[i][p])\n        # If a node has no incident edges, its value can be 1 (or any value, but 1 is simplest).\n        # This is implicitly handled as exp_map[i][p] for all p would be 0 if no incident edges involving p.\n        # If all_primes_set is empty (no edges), all ans_x will be 1.\n\n    # Verification (Optional, but good for confidence)\n    for u, v, g, l in edges:\n        calc_g = 1\n        calc_l = 1\n        \n        # Calculate GCD and LCM from ans_x[u] and ans_x[v]\n        # Using prime factorizations for GCD/LCM is more robust than math.gcd/math.lcm\n        # as the numbers can be large.\n        \n        factors_u = get_prime_factorization(ans_x[u])\n        factors_v = get_prime_factorization(ans_x[v])\n        \n        all_factors_uv = set(factors_u.keys()).union(factors_v.keys())\n        \n        for p in all_factors_uv:\n            exp_u = factors_u.get(p, 0)\n            exp_v = factors_v.get(p, 0)\n            calc_g *= (p ** min(exp_u, exp_v))\n            calc_l *= (p ** max(exp_u, exp_v))\n            \n        if calc_g != g or calc_l != l:\n            # This should not happen if the logic is correct\n            sys.stdout.write(\"NO\\n\")\n            return\n\n    sys.stdout.write(\"YES\\n\")\n    sys.stdout.write(\" \".join(map(str, ans_x[1:])) + \"\\n\")\n\n\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 552,
        "completion_token_count": 5687,
        "thoughts_token_count": 7231
    }
}