{
    "start": 1758094565.6119587,
    "end": 1758094588.8653016,
    "start-formatted": "2025-09-17 16:36 KST",
    "end-formatted": "2025-09-17 16:36 KST",
    "gpu": 2,
    "pid": 9,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Selling Souvenirs\n\nAfter several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.This morning, as usual, Petya will come to the market. Petya has n different souvenirs to sell; ith souvenir is characterised by its weight wi and cost ci. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than m, and total cost is maximum possible.Help Petya to determine maximum possible total cost.\n\n## Input\nThe first line contains two integers n and m (1 ≤ n ≤ 100000, 1 ≤ m ≤ 300000) — the number of Petya's souvenirs and total weight that he can carry to the market.Then n lines follow. ith line contains two integers wi and ci (1 ≤ wi ≤ 3, 1 ≤ ci ≤ 109) — the weight and the cost of ith souvenir.\n\n## Output\nPrint one number — maximum possible total cost of souvenirs that Petya can carry to the market.\n\n## Example\n### Input\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\n### Output\n['0', '3', '10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "Could not extract thought.",
    "response": "import sys\n\ndata = sys.stdin.read().strip().split()\nif not data:\n    sys.exit(0)\nit = iter(data)\nout_lines = []\n# The input may contain multiple test cases concatenated as in examples.\n# We will parse until exhaustion: each test case starts with n m then n pairs.\nwhile True:\n    try:\n        n = int(next(it))\n        m = int(next(it))\n    except StopIteration:\n        break\n    w1 = []\n    w2 = []\n    w3 = []\n    for _ in range(n):\n        w = int(next(it)); c = int(next(it))\n        if w == 1:\n            w1.append(c)\n        elif w == 2:\n            w2.append(c)\n        else:\n            w3.append(c)\n    w1.sort(reverse=True)\n    w2.sort(reverse=True)\n    w3.sort(reverse=True)\n    pref1 = [0]\n    for v in w1:\n        pref1.append(pref1[-1] + v)\n    pref2 = [0]\n    for v in w2:\n        pref2.append(pref2[-1] + v)\n    pref3 = [0]\n    for v in w3:\n        pref3.append(pref3[-1] + v)\n    ans = 0\n    # try k 3-weight items\n    max_k = min(len(w3), m // 3)\n    for k in range(max_k + 1):\n        weight3 = 3 * k\n        val3 = pref3[k]\n        rem = m - weight3\n        # consider taking x items of weight2 (each 2) and y of weight1 (each 1)\n        # For each possible x from 0..min(len(w2), rem//2) compute best using pref arrays.\n        # We can try best x by checking both x and maybe greedily use top singles: but iterate over x.\n        max_x = min(len(w2), rem // 2)\n        best12 = 0\n        # optimize by trying all x but that's up to m/2 ~150k; but len(w2) <= n <=1e5 and for each k up to m/3 ~1e5 worst-case -> too big.\n        # Instead precompute best total for capacities up to m using combination of weight1 and weight2 once.\n        # So break: compute dp_best[cap] for cap 0..m as max cost using only w1 and w2.\n        # We'll compute once outside loop.\n        pass\n\n    # Precompute best for capacities using w1 and w2\n    cap_max = m\n    best_cap = [0] * (cap_max + 1)\n    # Start with zero, then consider taking up to all weight2 items greedily by count\n    # For x from 0..len(w2): weight = 2*x, value = pref2[x]; fill best_cap[weight] = value\n    for x in range(len(pref2)):\n        wt = 2 * x\n        if wt <= cap_max:\n            best_cap[wt] = pref2[x]\n    # For each capacity, we can add weight1 items (1 each)\n    # For capacity c, best is max over t from 0..min(len(w1), c) of pref1[t] + best_cap[c - t]\n    # We can compute for each c by trying t up to min(len(w1), c). That's O(m * len(w1)) might be big.\n    # Better approach: build array best2 where best2[wt] is max value using only w2 for weight exact wt (only even wts).\n    # Then for capacities we can consider using y weight1 items and remaining capacity for best2 (which is even).\n    # For a given c, number of weight1 taken y can be 0..min(len(w1), c). remaining r = c - y, but best2 defined only for even r.\n    # So we can precompute for every r the best2[r] (taking floor to even), by taking best2_even[r] = best2[r - (r%2)]\n    best2_even = [0] * (cap_max + 1)\n    # fill best2_even for even indices\n    for wt in range(0, cap_max + 1, 2):\n        idx = wt // 2\n        if idx < len(pref2):\n            best2_even[wt] = pref2[idx]\n        else:\n            best2_even[wt] = pref2[-1]\n    # make best2_even non-decreasing with weight (since with more capacity you can ignore extra)\n    for i in range(1, cap_max + 1):\n        if best2_even[i] < best2_even[i-1]:\n            best2_even[i] = best2_even[i-1]\n    # Now compute best_cap[c]\n    for c in range(cap_max + 1):\n        maxv = 0\n        max_y = min(len(w1), c)\n        # iterate y small maybe large; but sum over c of max_y is large. Instead iterate over y once and update caps.\n        # We'll do convolution: for y from 0..len(w1): add pref1[y] to capacities c where c>=y: candidate = pref1[y] + best2_even[c - y]\n        # We'll compute by for each y update best_cap[c] using best2_even shifted.\n        pass\n    # Implement updating best_cap by scanning y\n    best_cap = [0] * (cap_max + 1)\n    for y in range(0, len(pref1)):\n        add = pref1[y]\n        # for c from y..cap_max: candidate = add + best2_even[c - y]\n        # so we can set best_cap[c] = max(best_cap[c], add + best2_even[c - y])\n        # do loop\n        for c in range(y, cap_max + 1):\n            val = add + best2_even[c - y]\n            if val > best_cap[c]:\n                best_cap[c] = val\n    # Now iterate k\n    ans = 0\n    for k in range(0, min(len(w3), m // 3) + 1):\n        wgt = 3 * k\n        val = pref3[k]\n        rem = m - wgt\n        total = val + best_cap[rem]\n        if total > ans:\n            ans = total\n    out_lines.append(str(ans))\n\nsys.stdout.write(\"\\n\".join(out_lines))",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndata = sys.stdin.read().strip().split()\nif not data:\n    sys.exit(0)\nit = iter(data)\nout_lines = []\n# The input may contain multiple test cases concatenated as in examples.\n# We will parse until exhaustion: each test case starts with n m then n pairs.\nwhile True:\n    try:\n        n = int(next(it))\n        m = int(next(it))\n    except StopIteration:\n        break\n    w1 = []\n    w2 = []\n    w3 = []\n    for _ in range(n):\n        w = int(next(it)); c = int(next(it))\n        if w == 1:\n            w1.append(c)\n        elif w == 2:\n            w2.append(c)\n        else:\n            w3.append(c)\n    w1.sort(reverse=True)\n    w2.sort(reverse=True)\n    w3.sort(reverse=True)\n    pref1 = [0]\n    for v in w1:\n        pref1.append(pref1[-1] + v)\n    pref2 = [0]\n    for v in w2:\n        pref2.append(pref2[-1] + v)\n    pref3 = [0]\n    for v in w3:\n        pref3.append(pref3[-1] + v)\n    ans = 0\n    # try k 3-weight items\n    max_k = min(len(w3), m // 3)\n    for k in range(max_k + 1):\n        weight3 = 3 * k\n        val3 = pref3[k]\n        rem = m - weight3\n        # consider taking x items of weight2 (each 2) and y of weight1 (each 1)\n        # For each possible x from 0..min(len(w2), rem//2) compute best using pref arrays.\n        # We can try best x by checking both x and maybe greedily use top singles: but iterate over x.\n        max_x = min(len(w2), rem // 2)\n        best12 = 0\n        # optimize by trying all x but that's up to m/2 ~150k; but len(w2) <= n <=1e5 and for each k up to m/3 ~1e5 worst-case -> too big.\n        # Instead precompute best total for capacities up to m using combination of weight1 and weight2 once.\n        # So break: compute dp_best[cap] for cap 0..m as max cost using only w1 and w2.\n        # We'll compute once outside loop.\n        pass\n\n    # Precompute best for capacities using w1 and w2\n    cap_max = m\n    best_cap = [0] * (cap_max + 1)\n    # Start with zero, then consider taking up to all weight2 items greedily by count\n    # For x from 0..len(w2): weight = 2*x, value = pref2[x]; fill best_cap[weight] = value\n    for x in range(len(pref2)):\n        wt = 2 * x\n        if wt <= cap_max:\n            best_cap[wt] = pref2[x]\n    # For each capacity, we can add weight1 items (1 each)\n    # For capacity c, best is max over t from 0..min(len(w1), c) of pref1[t] + best_cap[c - t]\n    # We can compute for each c by trying t up to min(len(w1), c). That's O(m * len(w1)) might be big.\n    # Better approach: build array best2 where best2[wt] is max value using only w2 for weight exact wt (only even wts).\n    # Then for capacities we can consider using y weight1 items and remaining capacity for best2 (which is even).\n    # For a given c, number of weight1 taken y can be 0..min(len(w1), c). remaining r = c - y, but best2 defined only for even r.\n    # So we can precompute for every r the best2[r] (taking floor to even), by taking best2_even[r] = best2[r - (r%2)]\n    best2_even = [0] * (cap_max + 1)\n    # fill best2_even for even indices\n    for wt in range(0, cap_max + 1, 2):\n        idx = wt // 2\n        if idx < len(pref2):\n            best2_even[wt] = pref2[idx]\n        else:\n            best2_even[wt] = pref2[-1]\n    # make best2_even non-decreasing with weight (since with more capacity you can ignore extra)\n    for i in range(1, cap_max + 1):\n        if best2_even[i] < best2_even[i-1]:\n            best2_even[i] = best2_even[i-1]\n    # Now compute best_cap[c]\n    for c in range(cap_max + 1):\n        maxv = 0\n        max_y = min(len(w1), c)\n        # iterate y small maybe large; but sum over c of max_y is large. Instead iterate over y once and update caps.\n        # We'll do convolution: for y from 0..len(w1): add pref1[y] to capacities c where c>=y: candidate = pref1[y] + best2_even[c - y]\n        # We'll compute by for each y update best_cap[c] using best2_even shifted.\n        pass\n    # Implement updating best_cap by scanning y\n    best_cap = [0] * (cap_max + 1)\n    for y in range(0, len(pref1)):\n        add = pref1[y]\n        # for c from y..cap_max: candidate = add + best2_even[c - y]\n        # so we can set best_cap[c] = max(best_cap[c], add + best2_even[c - y])\n        # do loop\n        for c in range(y, cap_max + 1):\n            val = add + best2_even[c - y]\n            if val > best_cap[c]:\n                best_cap[c] = val\n    # Now iterate k\n    ans = 0\n    for k in range(0, min(len(w3), m // 3) + 1):\n        wgt = 3 * k\n        val = pref3[k]\n        rem = m - wgt\n        total = val + best_cap[rem]\n        if total > ans:\n            ans = total\n    out_lines.append(str(ans))\n\nsys.stdout.write(\"\\n\".join(out_lines))",
    "score": 0,
    "metadata": {
        "prompt_token_count": 421,
        "completion_token_count": 1387,
        "thoughts_token_count": 0
    }
}