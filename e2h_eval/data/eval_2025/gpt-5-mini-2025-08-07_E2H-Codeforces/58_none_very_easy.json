{
    "start": 1758294605.3740551,
    "end": 1758294630.1738772,
    "start-formatted": "2025-09-20 00:10 KST",
    "end-formatted": "2025-09-20 00:10 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "Could not extract thought.",
    "response": "import sys\nfrom collections import deque, defaultdict\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    it = iter(data)\n    out_lines = []\n    while True:\n        try:\n            n = int(next(it))\n        except StopIteration:\n            break\n        m = int(next(it))\n        g = [[] for _ in range(n)]\n        for _ in range(m):\n            a = int(next(it)) - 1\n            b = int(next(it)) - 1\n            g[a].append(b)\n            g[b].append(a)\n        # Check if any odd cycle exists: BFS 2-color each component\n        color = [-1]*n\n        has_odd = False\n        for s in range(n):\n            if color[s] != -1: continue\n            if not g[s]:\n                color[s]=0\n                continue\n            q = deque([s]); color[s]=0\n            while q:\n                v = q.popleft()\n                for to in g[v]:\n                    if color[to]==-1:\n                        color[to]=color[v]^1\n                        q.append(to)\n                    elif color[to]==color[v]:\n                        has_odd = True\n        if has_odd:\n            out_lines.append(\"0 1\")\n            continue\n        # Graph is bipartite. Need minimal edges to create odd cycle (>1 vertex)\n        # If there is any isolated vertex, adding 2 edges (to make triangle impossible since no parallel) Actually minimal is 3 when no edges?\n        # Known solution: If there is any pair of vertices not connected and in same component? Use cases:\n        # From CF: answer t = 1 if there exists a pair of vertices in same component with distance >=2 and not connected by edge? Actually simpler:\n        # If there exists any pair of vertices in same component whose distance >=2, adding one edge between vertices of same color creates odd cycle? For bipartite, adding edge between same color in same component creates odd cycle (since path between them is even length >=2). So t=1 possible if there exists pair of same-color vertices in same component not already adjacent.\n        # Count such possible edges.\n        # Else, t=2 if there exists any component with >=2 vertices (i.e., any edge exists) else t=3.\n        comp = [-1]*n\n        comps = []\n        cid = 0\n        for i in range(n):\n            if comp[i]!=-1: continue\n            q=deque([i]); comp[i]=cid; nodes=[i]\n            while q:\n                v=q.popleft()\n                for to in g[v]:\n                    if comp[to]==-1:\n                        comp[to]=cid\n                        q.append(to); nodes.append(to)\n            comps.append(nodes); cid+=1\n        # Build adjacency set\n        adjset = [set(nei) for nei in g]\n        one_count = 0\n        for nodes in comps:\n            # for each color class in component, count pairs not edges\n            if len(nodes)<=1: continue\n            # group by color\n            cnt = [0,0]\n            for v in nodes:\n                cnt[color[v]] += 1\n            # total possible same-color pairs minus existing edges between same colors (which are zero in bipartite)\n            # number of potential edges between same color = C(cnt[0],2)+C(cnt[1],2)\n            # but some of these may already be edges? impossible in bipartite, so all are valid if not exist already\n            # need ensure they are not already edges; edges only across colors so none exist\n            one_count += cnt[0]*(cnt[0]-1)//2 + cnt[1]*(cnt[1]-1)//2\n        if one_count>0:\n            out_lines.append(\"1 \" + str(one_count))\n            continue\n        # No possible t=1. Check if any component has at least 2 vertices (i.e., there is at least one edge)\n        has_edge_component = any(len(nodes)>=2 for nodes in comps)\n        if not has_edge_component:\n            # all isolated vertices: need 3 edges to make triangle among 3 distinct vertices: choose 3 vertices -> form triangle by adding 3 edges\n            if n < 3:\n                out_lines.append(\"3 0\")\n            else:\n                ways = n*(n-1)*(n-2)//6\n                out_lines.append(\"3 \" + str(ways))\n        else:\n            # t = 2: choose an edge (u,v) and a vertex w in different component? Known result: number of ways = sum over components of size s: s*(n-s) - existing edges? But from CF: ways = number of pairs of vertices in different components such that... Simpler: It's number of pairs of vertices (u,v) not connected by edge. But formula from problem: when no same-color pair in same component, graph is a disjoint union of complete bipartite graphs K_{a,b} with no intra-color missing? Actually in bipartite forest of isolated edges? For CF standard solution: when t=2, ways = number of pairs of vertices in different components choose any two and connect appropriately? To be safe, brute compute count of unordered pairs of vertices not connected by edge and not in same component? Wait.\n            # From typical solutions: if no same-color pair in same component, then every component is a complete bipartite graph. Then adding 2 edges to create odd cycle: count is sum over components of (size0*size1*(n - size0 - size1)) + sum over components of C(size0,2)+C(size1,2)??? This is messy.\n            # Simpler approach: brute force count ways to add 2 edges among non-existing edges and test if odd cycle appears. For n up to? Problem constraints unspecified; but CF original n<=100? Likely small. We'll implement brute for safety up to n<=100.\n            N = n\n            missing = []\n            for i in range(N):\n                for j in range(i+1,N):\n                    if j not in adjset[i]:\n                        missing.append((i,j))\n            ways2 = 0\n            L = len(missing)\n            if L==0:\n                out_lines.append(\"2 0\")\n            else:\n                # try all pairs of missing edges\n                # Build bitset adjacency for quick cycle detection after adding edges\n                for a in range(L):\n                    u1,v1 = missing[a]\n                    for b in range(a, L):\n                        u2,v2 = missing[b]\n                        if a==b:\n                            # adding same edge twice not allowed\n                            continue\n                        # cannot add parallel edges but missing ensures distinct; also edges sets equal check\n                        # create new graph adjacency\n                        gg = [set(nei) for nei in adjset]\n                        gg[u1].add(v1); gg[v1].add(u1)\n                        gg[u2].add(v2); gg[v2].add(u2)\n                        # check odd cycle exists\n                        color2 = [-1]*N\n                        found = False\n                        for s in range(N):\n                            if color2[s]!=-1: continue\n                            q=deque([s]); color2[s]=0\n                            while q and not found:\n                                v=q.popleft()\n                                for to in gg[v]:\n                                    if color2[to]==-1:\n                                        color2[to]=color2[v]^1\n                                        q.append(to)\n                                    elif color2[to]==color2[v]:\n                                        found = True\n                                        break\n                            if found: break\n                        if found:\n                            ways2 += 1\n                out_lines.append(\"2 \" + str(ways2))\n    sys.stdout.write(\"\\n\".join(out_lines))\n\nif __name__ == \"__main__\":\n    main()",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque, defaultdict\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    it = iter(data)\n    out_lines = []\n    while True:\n        try:\n            n = int(next(it))\n        except StopIteration:\n            break\n        m = int(next(it))\n        g = [[] for _ in range(n)]\n        for _ in range(m):\n            a = int(next(it)) - 1\n            b = int(next(it)) - 1\n            g[a].append(b)\n            g[b].append(a)\n        # Check if any odd cycle exists: BFS 2-color each component\n        color = [-1]*n\n        has_odd = False\n        for s in range(n):\n            if color[s] != -1: continue\n            if not g[s]:\n                color[s]=0\n                continue\n            q = deque([s]); color[s]=0\n            while q:\n                v = q.popleft()\n                for to in g[v]:\n                    if color[to]==-1:\n                        color[to]=color[v]^1\n                        q.append(to)\n                    elif color[to]==color[v]:\n                        has_odd = True\n        if has_odd:\n            out_lines.append(\"0 1\")\n            continue\n        # Graph is bipartite. Need minimal edges to create odd cycle (>1 vertex)\n        # If there is any isolated vertex, adding 2 edges (to make triangle impossible since no parallel) Actually minimal is 3 when no edges?\n        # Known solution: If there is any pair of vertices not connected and in same component? Use cases:\n        # From CF: answer t = 1 if there exists a pair of vertices in same component with distance >=2 and not connected by edge? Actually simpler:\n        # If there exists any pair of vertices in same component whose distance >=2, adding one edge between vertices of same color creates odd cycle? For bipartite, adding edge between same color in same component creates odd cycle (since path between them is even length >=2). So t=1 possible if there exists pair of same-color vertices in same component not already adjacent.\n        # Count such possible edges.\n        # Else, t=2 if there exists any component with >=2 vertices (i.e., any edge exists) else t=3.\n        comp = [-1]*n\n        comps = []\n        cid = 0\n        for i in range(n):\n            if comp[i]!=-1: continue\n            q=deque([i]); comp[i]=cid; nodes=[i]\n            while q:\n                v=q.popleft()\n                for to in g[v]:\n                    if comp[to]==-1:\n                        comp[to]=cid\n                        q.append(to); nodes.append(to)\n            comps.append(nodes); cid+=1\n        # Build adjacency set\n        adjset = [set(nei) for nei in g]\n        one_count = 0\n        for nodes in comps:\n            # for each color class in component, count pairs not edges\n            if len(nodes)<=1: continue\n            # group by color\n            cnt = [0,0]\n            for v in nodes:\n                cnt[color[v]] += 1\n            # total possible same-color pairs minus existing edges between same colors (which are zero in bipartite)\n            # number of potential edges between same color = C(cnt[0],2)+C(cnt[1],2)\n            # but some of these may already be edges? impossible in bipartite, so all are valid if not exist already\n            # need ensure they are not already edges; edges only across colors so none exist\n            one_count += cnt[0]*(cnt[0]-1)//2 + cnt[1]*(cnt[1]-1)//2\n        if one_count>0:\n            out_lines.append(\"1 \" + str(one_count))\n            continue\n        # No possible t=1. Check if any component has at least 2 vertices (i.e., there is at least one edge)\n        has_edge_component = any(len(nodes)>=2 for nodes in comps)\n        if not has_edge_component:\n            # all isolated vertices: need 3 edges to make triangle among 3 distinct vertices: choose 3 vertices -> form triangle by adding 3 edges\n            if n < 3:\n                out_lines.append(\"3 0\")\n            else:\n                ways = n*(n-1)*(n-2)//6\n                out_lines.append(\"3 \" + str(ways))\n        else:\n            # t = 2: choose an edge (u,v) and a vertex w in different component? Known result: number of ways = sum over components of size s: s*(n-s) - existing edges? But from CF: ways = number of pairs of vertices in different components such that... Simpler: It's number of pairs of vertices (u,v) not connected by edge. But formula from problem: when no same-color pair in same component, graph is a disjoint union of complete bipartite graphs K_{a,b} with no intra-color missing? Actually in bipartite forest of isolated edges? For CF standard solution: when t=2, ways = number of pairs of vertices in different components choose any two and connect appropriately? To be safe, brute compute count of unordered pairs of vertices not connected by edge and not in same component? Wait.\n            # From typical solutions: if no same-color pair in same component, then every component is a complete bipartite graph. Then adding 2 edges to create odd cycle: count is sum over components of (size0*size1*(n - size0 - size1)) + sum over components of C(size0,2)+C(size1,2)??? This is messy.\n            # Simpler approach: brute force count ways to add 2 edges among non-existing edges and test if odd cycle appears. For n up to? Problem constraints unspecified; but CF original n<=100? Likely small. We'll implement brute for safety up to n<=100.\n            N = n\n            missing = []\n            for i in range(N):\n                for j in range(i+1,N):\n                    if j not in adjset[i]:\n                        missing.append((i,j))\n            ways2 = 0\n            L = len(missing)\n            if L==0:\n                out_lines.append(\"2 0\")\n            else:\n                # try all pairs of missing edges\n                # Build bitset adjacency for quick cycle detection after adding edges\n                for a in range(L):\n                    u1,v1 = missing[a]\n                    for b in range(a, L):\n                        u2,v2 = missing[b]\n                        if a==b:\n                            # adding same edge twice not allowed\n                            continue\n                        # cannot add parallel edges but missing ensures distinct; also edges sets equal check\n                        # create new graph adjacency\n                        gg = [set(nei) for nei in adjset]\n                        gg[u1].add(v1); gg[v1].add(u1)\n                        gg[u2].add(v2); gg[v2].add(u2)\n                        # check odd cycle exists\n                        color2 = [-1]*N\n                        found = False\n                        for s in range(N):\n                            if color2[s]!=-1: continue\n                            q=deque([s]); color2[s]=0\n                            while q and not found:\n                                v=q.popleft()\n                                for to in gg[v]:\n                                    if color2[to]==-1:\n                                        color2[to]=color2[v]^1\n                                        q.append(to)\n                                    elif color2[to]==color2[v]:\n                                        found = True\n                                        break\n                            if found: break\n                        if found:\n                            ways2 += 1\n                out_lines.append(\"2 \" + str(ways2))\n    sys.stdout.write(\"\\n\".join(out_lines))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 569,
        "completion_token_count": 1648,
        "thoughts_token_count": 0
    }
}