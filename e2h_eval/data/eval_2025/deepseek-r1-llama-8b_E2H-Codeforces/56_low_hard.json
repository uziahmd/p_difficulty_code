{
    "start": 1758278122.029361,
    "end": 1758278366.9447036,
    "start-formatted": "2025-09-19 19:35 KST",
    "end-formatted": "2025-09-19 19:39 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read it carefully.\n\nThe problem is about assigning Rebel spaceships to guard B bases such that every base has exactly one guardian and each spaceship is assigned to exactly one base. So it's a perfect matching between R ships and B bases.\n\nBut there's a catch: the paths from each base to its assigned spaceship shouldn't intersect. The paths are straight lines in 2D space, and we need to make sure none of them cross each other.\n\nHmm, how to model this? I think this is similar to checking if a bipartite graph is matchable and whether the edges (representing non-intersecting paths) form a matching.\n\nWait, but how do we determine if two paths intersect? Because for any two pairs of points (ship A to base X and ship B to base Y), their line segments should not cross.\n\nSo, for a given matching, we need to ensure that all the corresponding line segments don't intersect with each other.\n\nThis sounds computationally heavy because for each possible matching, we'd have to check all pairs of line segments. But since R and B can be up to 10 each, the maximum number of possible matchings could be manageable.\n\nWait, wait. Wait, no. R and B can be up to 10, but the problem states that R and B can be different. For example, R=3 and B=3 as in the sample input. So the number of possible perfect matchings would be 3! = 6 in that case. But if R and B are equal, like both 5, then it's 5! = 120 possibilities. Hmm, 10! is 3,628,800 which might be manageable for small constraints. But what if R is 10 and B is 10? Then 10! is 3.6 million, which is acceptable for a brute-force approach.\n\nBut wait, perhaps we can find a smarter way. Let me think.\n\nAnother approach: model this as a bipartite graph where one partition is the ships and the other is the bases. An edge exists between a ship and a base if the line segment connecting them doesn't intersect any other existing edges in the current partial matching. Or maybe more accurately, when considering adding an edge to the matching, we must ensure that it doesn't create any intersections with the existing edges.\n\nWait, but building the graph incrementally like that might complicate things. Alternatively, for each possible permutation (matching) of ships to bases, we can check if all the corresponding line segments are pairwise non-intersecting.\n\nYes, that seems feasible. Because the number of permutations is manageable for R and B up to 10 each.\n\nSo the plan is:\n\n1. Read all the ship positions and base positions.\n2. Generate all possible perfect matchings between ships and bases. That is, all possible bijections from ships to bases.\n3. For each matching, check if all the line segments (ship to base) are pairwise non-crossing.\n4. If any matching satisfies this, output 'Yes'; otherwise, 'No'.\n\nBut how to efficiently generate and check all possible matchings?\n\nFirst, generating all possible matchings: for R ships and B bases, we need a perfect matching only if R == B. Wait, wait, looking back at the problem statement. It says \"R Rebel spaceships to guard B bases\". So for a perfect matching, the number of ships and bases must be equal. Because each base must have exactly one guard, and each guard comes from a ship. So R must equal B. Oh right! Because the problem says R and B can be up to 10, but the first condition is that the assignment is a perfect matching. So if R != B, then it's impossible. So the first thing to check is whether R equals B. If not, output 'No' immediately.\n\nAh, right. So step 0: check if R == B. If not, output 'No'.\n\nSo in the sample input, the second case has R=3, B=2. So R != B, thus output is 'No'.\n\nSo that's an early exit condition.\n\nNow, assuming R == B, we need to proceed.\n\nSo, for the case where R == B, we can proceed as follows:\n\nGenerate all possible permutations of the ships to assign to the bases. Each permutation represents a possible matching.\n\nFor each permutation, we collect the line segments (ship i to base j for each i in permutation) and check if any two line segments intersect.\n\nIf any permutation's line segments are all non-intersecting, then the answer is 'Yes'. Otherwise, it's 'No'.\n\nSo the key steps are:\n\n- Check if R == B. If not, 'No'.\n- Else, generate all possible permutations of the ships to bases.\n- For each permutation:\n   - For every pair of line segments in the permutation, check if they intersect.\n   - If any",
    "response": "To solve this problem, we need to determine if it is possible to assign Rebel spaceships to guard B bases such that each base has exactly one guardian and each spaceship is assigned to exactly one base. Additionally, the paths from each base to its assigned spaceship must not intersect.\n\n### Approach\n1. **Check Equality**: First, check if the number of Rebel spaceships (R) is equal to the number of bases (B). If they are not equal, output \"No\" immediately because a perfect matching is impossible.\n2. **Generate Permutations**: If R equals B, generate all possible permutations of assigning ships to bases. Each permutation represents a potential matching.\n3. **Check Non-Intersecting Paths**: For each permutation, check if all corresponding line segments (from ships to bases) are non-intersecting. This involves checking every pair of line segments in the permutation to ensure they do not cross each other.\n\n### Solution Code\n```python\nimport sys\nfrom itertools import permutations\n\ndef readints():\n    return list(map(int, sys.stdin.readline().split()))\n\n# Read input\nR_B = sys.stdin.readline().strip()\nR, B = map(int, R_B.split())\n\nships = []\nbases = []\nfor _ in range(R):\n    x, y = map(int, sys.stdin.readline().split())\n    ships.append((x, y))\nfor _ in range(B):\n    x, y = map(int, sys.stdin.readline().split())\n    bases.append((x, y))\n\nif R != B:\n    print(\"No\")\n    sys.exit()\n\n# Function to check if two line segments AB and CD intersect\ndef ccw(A, B, C, D):\n    return (B[0] - A[0])*(D[1] - C[1]) - (B[1] - A[1])*(D[0] - C[0])\n\ndef segments_intersect(s1, s2):\n    A, B = s1\n    C, D = s2\n    return ccw(A, B, C, D) == 0 and ccw(C, D, A, B) == 0\n\n# Check for all pairs in a matching\ndef is_valid(matching):\n    segments = [(matching[i], bases[i]) for i in range(R)]\n    for i in range(len(segments)):\n        for j in range(i+1, len(segments)):\n            seg1 = segments[i]\n            seg2 = segments[j]\n            if segments_intersect(seg1, seg2):\n                return False\n    return True\n\n# Generate all possible matchings\nfor perm in permutations(range(R)):\n    if is_valid(perm):\n        print(\"Yes\")\n        sys.exit()\n\nprint(\"No\")\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into coordinates for ships and bases.\n2. **Equality Check**: If the number of ships does not equal the number of bases, output \"No\".\n3. **Permutation Generation**: Using permutations, generate all possible ways to assign ships to bases.\n4. **Intersection Check**: For each permutation, check if any two line segments intersect. If a valid permutation is found where no segments intersect, output \"Yes\". If no valid permutation is found after checking all possibilities, output \"No\".\n\nThis approach ensures that we efficiently check all possible assignments and validate them against the non-intersecting constraint.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom itertools import permutations\n\ndef readints():\n    return list(map(int, sys.stdin.readline().split()))\n\n# Read input\nR_B = sys.stdin.readline().strip()\nR, B = map(int, R_B.split())\n\nships = []\nbases = []\nfor _ in range(R):\n    x, y = map(int, sys.stdin.readline().split())\n    ships.append((x, y))\nfor _ in range(B):\n    x, y = map(int, sys.stdin.readline().split())\n    bases.append((x, y))\n\nif R != B:\n    print(\"No\")\n    sys.exit()\n\n# Function to check if two line segments AB and CD intersect\ndef ccw(A, B, C, D):\n    return (B[0] - A[0])*(D[1] - C[1]) - (B[1] - A[1])*(D[0] - C[0])\n\ndef segments_intersect(s1, s2):\n    A, B = s1\n    C, D = s2\n    return ccw(A, B, C, D) == 0 and ccw(C, D, A, B) == 0\n\n# Check for all pairs in a matching\ndef is_valid(matching):\n    segments = [(matching[i], bases[i]) for i in range(R)]\n    for i in range(len(segments)):\n        for j in range(i+1, len(segments)):\n            seg1 = segments[i]\n            seg2 = segments[j]\n            if segments_intersect(seg1, seg2):\n                return False\n    return True\n\n# Generate all possible matchings\nfor perm in permutations(range(R)):\n    if is_valid(perm):\n        print(\"Yes\")\n        sys.exit()\n\nprint(\"No\")",
    "score": -1,
    "metadata": {
        "prompt_token_count": 462,
        "completion_token_count": 695,
        "thoughts_token_count": 1025
    }
}