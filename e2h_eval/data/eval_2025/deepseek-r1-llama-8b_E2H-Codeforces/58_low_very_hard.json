{
    "start": 1758278641.7101214,
    "end": 1758278945.6421075,
    "start-formatted": "2025-09-19 19:44 KST",
    "end-formatted": "2025-09-19 19:49 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read it carefully.\n\nThe problem is about Vitaly and a graph theory problem. The task is to find the minimum number of edges to add to form a simple cycle of odd length, more than one vertex, and each vertex occurs at most once in the cycle. Also, we need to find the number of ways to do this.\n\nHmm. So the first thing I need to figure out is what's required for a graph to have such a cycle. And how to compute t and w.\n\nLet me think about the structure of the problem. We need to find cycles that are odd-length. For example, triangles (length 3), pentagons (5), etc. Since the cycle has to be simple, no repeated vertices.\n\nSo, given a graph, what's the minimal number of edges to add to create such a cycle?\n\nI remember that a cycle requires at least three nodes connected in a loop. So the first step is to check if the graph already has any such cycles. If not, then adding edges is necessary.\n\nWait, but the problem says \"each vertex occurs at most once\" in the cycle, which is just saying it's a simple cycle. So the main point is whether the graph has any odd-length cycles.\n\nBut wait, maybe the graph is bipartite. Because bipartite graphs don't have any odd-length cycles. So if the graph is bipartite, adding edges might not help. Or wait, no: because adding edges could connect two parts in a way that creates an odd cycle.\n\nWait, but the original graph may not be connected. So perhaps the first thing to do is to determine the bipartition of each connected component, and see if any component is non-bipartite (has an odd cycle). Because if any component has an odd cycle, then adding zero edges is sufficient, right?\n\nWait, no. Because the problem requires forming a cycle consisting of more than one vertex. So even if a component has a cycle, but it's even-length, then adding edges to make it odd might be needed.\n\nWait, no. Because if the component is itself already containing an odd-length cycle, then that's the minimal case—t=0, because the cycle already exists.\n\nSo the first thing is to check if the graph already contains any odd-length cycles. If yes, then t is 0, w is the number of such cycles.\n\nIf the graph doesn't have any odd-length cycles, then we need to find the minimal number of edges to add to create such a cycle.\n\nWait, but how? Because adding edges can create new cycles.\n\nHmm. So the approach would be:\n\n1. Determine if the graph has any existing odd-length cycles. If yes, then t=0, w is the count of such cycles.\n\n2. If not, then the graph must be bipartite. Because a graph without any odd-length cycles is bipartite. Because any cycle in a bipartite graph is even-length.\n\nWait, is that correct? Yes, because in a bipartite graph, you can't have an odd-length cycle. So if the graph is bipartite, then all cycles are even-length.\n\nSo if the graph is bipartite, then we need to find the minimal number of edges to add to create an odd-length cycle.\n\nBut how?\n\nWell, in a bipartite graph, adding an edge between two nodes in certain partitions can create an odd-length cycle.\n\nWait, but the minimal way is to find a pair of nodes u and v such that u is in partition A and v is in partition B, and their path lengths differ by an odd number. Or perhaps, the minimal way is to connect two nodes across partitions in such a way that a triangle is formed, but since the graph was bipartite, that's impossible. Wait, no, because adding an edge between two nodes u and v can create a cycle.\n\nWait, for example, consider a bipartition into sets X and Y. Suppose u is in X and v is in Y, and there's a path from u to v of even length. Adding an edge between u and v will create a cycle of length even + 1 = odd. So that's the minimal way: add one edge between u and v where the shortest path between them is even.\n\nSo the minimal t is 1, and the number of ways is the number of such pairs (u, v) where u is in X, v is in Y, and the distance between u and v is even.\n\nWait, but not exactly. Because some pairs may not have a path at all. So for those, adding the edge directly would create a cycle of length 2 (but that's not allowed as the cycle must consist of more than one vertex). Oh wait, no. Because a cycle of length 2 is just an edge, which is not a cycle. So the edge u-v added when they are not connected",
    "response": "To solve this problem, we need to determine the minimum number of edges to add to a graph to form a simple cycle of odd length and count the number of ways to achieve this. The graph is bipartite if it does not contain any odd-length cycles.\n\n### Approach\n1. **Check for Existing Odd-Length Cycles**: If the graph already contains an odd-length cycle, the minimum number of edges to add (t) is 0, and the number of ways (w) is the count of such cycles.\n2. **Bipartite Check**: If the graph is bipartite, it means all cycles are even-length. In this case, we need to find pairs of vertices from different partitions such that the shortest path between them has an even length. Adding an edge between such a pair will create an odd-length cycle.\n3. **Count Pairs**: For each pair of vertices (u, v) where u is in partition X and v is in partition Y, check if the shortest path between them is even. Count all such valid pairs to determine the number of ways to form the cycle.\n\n### Solution Code\n```python\nimport sys\nfrom collections import deque\n\ndef is_bipartite(n, adj):\n    color = [-1] * (n + 1)\n    for i in range(1, n+1):\n        if color[i] == -1:\n            queue = deque()\n            queue.append(i)\n            color[i] = 0\n            while queue:\n                u = queue.popleft()\n                for v in adj[u]:\n                    if color[v] == -1:\n                        color[v] = color[u] ^ 1\n                        queue.append(v)\n                    elif color[v] == color[u]:\n                        return False, None\n    return True, color\n\ndef bfs_shortest_path(start, end, adj, visited):\n    q = deque()\n    q.append((start, 0))\n    visited[start] = True\n    while q:\n        u, d = q.popleft()\n        if u == end:\n            return d\n        for v in adj[u]:\n            if not visited[v]:\n                visited[v] = True\n                q.append((v, d + 1))\n    return -1\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    m = int(input[ptr])\n    ptr += 1\n    adj = [[] for _ in range(n+1)]\n    for _ in range(m):\n        a = int(input[ptr])\n        ptr += 1\n        b = int(input[ptr])\n        ptr += 1\n        adj[a].append(b)\n        adj[b].append(a)\n    \n    # Check if the graph is bipartite and get coloring\n    is_bipartite_flag, color = is_bipartite(n, adj)\n    if not is_bipartite_flag:\n        # There exists an odd cycle already\n        t = 0\n        w = 0\n        print(f\"{t} {w}\")\n        return\n    \n    # Now, graph is bipartite; need to find pairs with even distance\n    # Partitions are color 0 and 1\n    part0 = [i for i in range(1, n+1) if color[i] == 0]\n    part1 = [i for i in range(1, n+1) if color[i] == 1]\n    \n    # For each node in part0, find nodes in part1 reachable via even distance\n    count = 0\n    for u in part0:\n        for v in part1:\n            if u == v:\n                continue\n            dist = bfs_shortest_path(u, v, adj, [False]*(n+1))\n            if dist != -1 and dist % 2 == 0:\n                count += 1\n    # But wait, each pair (u, v) and (v, u) are considered same, but in our counting above, they are treated as two separate entries?\n    # No, because for each u in part0 and v in part1, u != v, and (u, v) is considered once.\n    # Wait, no: the code counts (u, v) for all u in part0, v in part1, u != v, and where the distance is even.\n    # So each unordered pair is counted twice if both directions have even distance? Or is it the same?\n\n    # Actually, the distance from u to v is the same as from v to u in an undirected graph. So for each unordered pair (u, v), if the distance is even, it's counted once in the loop as (u, v) and once as (v, u). But in reality, adding the edge u-v is one way, not two. So we need to count each unordered pair once.\n\n    # So the count needs to be divided by 2.\n\n    count = count // 2\n    t = 1\n    w = count\n    print(f\"{t} {w}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Bipartite Check**: The function `is_bipartite` checks if the graph is bipartite using BFS and returns the coloring if it is bipartite.\n2. **Shortest Path Calculation**: Using BFS, the shortest path between nodes is calculated to determine if adding an edge can form an odd-length cycle.\n3. **Count Valid Pairs**: For each node in partition X, nodes in partition Y are checked to see if the shortest path has an even length. Each valid pair is counted and divided by 2 to avoid double-counting.\n4. **Output Result**: The minimum number of edges to add (t) is 1, and the number of ways (w) is the count of valid pairs.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef is_bipartite(n, adj):\n    color = [-1] * (n + 1)\n    for i in range(1, n+1):\n        if color[i] == -1:\n            queue = deque()\n            queue.append(i)\n            color[i] = 0\n            while queue:\n                u = queue.popleft()\n                for v in adj[u]:\n                    if color[v] == -1:\n                        color[v] = color[u] ^ 1\n                        queue.append(v)\n                    elif color[v] == color[u]:\n                        return False, None\n    return True, color\n\ndef bfs_shortest_path(start, end, adj, visited):\n    q = deque()\n    q.append((start, 0))\n    visited[start] = True\n    while q:\n        u, d = q.popleft()\n        if u == end:\n            return d\n        for v in adj[u]:\n            if not visited[v]:\n                visited[v] = True\n                q.append((v, d + 1))\n    return -1\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    m = int(input[ptr])\n    ptr += 1\n    adj = [[] for _ in range(n+1)]\n    for _ in range(m):\n        a = int(input[ptr])\n        ptr += 1\n        b = int(input[ptr])\n        ptr += 1\n        adj[a].append(b)\n        adj[b].append(a)\n    \n    # Check if the graph is bipartite and get coloring\n    is_bipartite_flag, color = is_bipartite(n, adj)\n    if not is_bipartite_flag:\n        # There exists an odd cycle already\n        t = 0\n        w = 0\n        print(f\"{t} {w}\")\n        return\n    \n    # Now, graph is bipartite; need to find pairs with even distance\n    # Partitions are color 0 and 1\n    part0 = [i for i in range(1, n+1) if color[i] == 0]\n    part1 = [i for i in range(1, n+1) if color[i] == 1]\n    \n    # For each node in part0, find nodes in part1 reachable via even distance\n    count = 0\n    for u in part0:\n        for v in part1:\n            if u == v:\n                continue\n            dist = bfs_shortest_path(u, v, adj, [False]*(n+1))\n            if dist != -1 and dist % 2 == 0:\n                count += 1\n    # But wait, each pair (u, v) and (v, u) are considered same, but in our counting above, they are treated as two separate entries?\n    # No, because for each u in part0 and v in part1, u != v, and (u, v) is considered once.\n    # Wait, no: the code counts (u, v) for all u in part0, v in part1, u != v, and where the distance is even.\n    # So each unordered pair is counted twice if both directions have even distance? Or is it the same?\n\n    # Actually, the distance from u to v is the same as from v to u in an undirected graph. So for each unordered pair (u, v), if the distance is even, it's counted once in the loop as (u, v) and once as (v, u). But in reality, adding the edge u-v is one way, not two. So we need to count each unordered pair once.\n\n    # So the count needs to be divided by 2.\n\n    count = count // 2\n    t = 1\n    w = count\n    print(f\"{t} {w}\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 570,
        "completion_token_count": 1239,
        "thoughts_token_count": 1025
    }
}