{
    "start": 1758278565.5813065,
    "end": 1758278849.6933799,
    "start-formatted": "2025-09-19 19:42 KST",
    "end-formatted": "2025-09-19 19:47 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read it carefully.\n\nThe problem is about Vitaly and a graph theory problem. The task is to find the minimum number of edges to add to form a simple cycle of odd length, more than one vertex, and each vertex occurs at most once in the cycle. Also, we need to find the number of ways to do this.\n\nHmm. So the first thing I need to figure out is what's required for a graph to have such a cycle. And how to compute t and w.\n\nLet me think about the structure of the problem. We need to find cycles that are odd-length. So, any cycle with 3,5,7,... vertices.\n\nBut the minimal t would correspond to the smallest possible such cycle. Because adding fewer edges is better.\n\nWait, but t is the minimal number of edges to add. So perhaps the minimal t is 1, if there exists an existing edge between two nodes that can form a triangle with another path.\n\nWait, no. For example, if the graph has a triangle (3-node cycle), then t is 0 because it already exists. But wait, the output expects t=1 and w=2 in the first sample. Wait, let me look back.\n\nWait the first sample input is:\n\n4 4\n\nEdges: 1-2, 1-3, 4-2, 4-3.\n\nSo the graph is two separate triangles? No, wait 4 nodes. Let me draw it:\n\nNodes 1,2,3 form a triangle (edges 1-2, 1-3, 4-2, 4-3). Wait, no. Wait the edges are 1-2, 1-3, 4-2, 4-3. So nodes 1,2,4 are connected via 1-2-4, but also 4 is connected to 3. So node 3 is connected to 4 and 1. So the component containing 1,2,3,4 is a complete bipartite graph K_{2,2}, which is a square. So the existing edges form a 4-cycle. But the problem requires an odd-length cycle. So in this case, the existing graph doesn't have any odd-length cycles, right?\n\nSo in this case, t is 1 because adding one edge can create a triangle. Like adding an edge between 2 and 3 would create a triangle 1-2-3, but wait, does that form a cycle? Or maybe adding 2-3 and 2-1? Wait no, wait 1-2 is already present. Wait, in the sample, the output is t=1 and w=2. So after adding one edge, you can form a cycle of length 3.\n\nWait, perhaps in the first sample, adding either 2-3 or 3-1 would create a triangle. Wait, but in the initial graph, 1 is connected to 2 and 3, and 4 is connected to 2 and 3. So adding edge 2-3 would make a triangle between 1-2-3-1, but wait 2 is connected to both 1 and 3 now. So that forms a cycle of length 3. Similarly, adding edge 3-1 is already present, so perhaps I'm misunderstanding.\n\nWait no, 1 is already connected to 3. So adding 2-3 would connect 2 and 3, forming a triangle.\n\nSo the minimal t is 1. And the number of ways is 2, as there are two possible edges to add: 2-3 and 3-4? Or wait, perhaps other possibilities.\n\nWait no, in the sample, the output is '1 2', meaning t=1 and w=2. So that suggests that adding one edge in two different ways can create a 3-cycle.\n\nSo the approach is: for each possible way to create a cycle by adding edges, find the minimal t, and count the number of ways to do it.\n\nSo how do I model this?\n\nI think the key is to find all possible pairs of paths that can form an odd-length cycle when combined.\n\nWait, but considering all possible combinations might be computationally expensive, especially for large n and m.\n\nAlternative approach: consider each connected component of the graph. For each component, determine whether it can contribute to forming an odd-length cycle. If not, perhaps we can connect it with another component in a way that creates such a cycle.\n\nBut since the graph isn't necessarily connected, we can have multiple components. So, perhaps for each pair of components, we can see if connecting them in some way would form an odd cycle.\n\nBut that might get complicated. Maybe it's easier to consider each component separately and see if it already contains an odd cycle. If not, then perhaps we need to connect two components in",
    "response": "To solve this problem, we need to determine the minimum number of edges to add to a graph to form a simple cycle of odd length and count the number of ways to achieve this. The solution involves analyzing each connected component of the graph to check for existing odd-length cycles and determining if additional edges can be added to form such cycles.\n\n### Approach\n1. **Graph Components**: First, we identify all connected components in the graph. Each component is treated separately.\n2. **Odd-Length Cycles Check**: For each component, we check if it contains an odd-length cycle. If a component already has such a cycle, no edges need to be added for that component.\n3. **Component Pairing**: If a component does not have an odd-length cycle, we consider pairing it with another component to form an odd-length cycle by adding edges between them.\n4. **Edge Addition Calculation**: Calculate the minimum number of edges required to form an odd-length cycle and count the number of ways to do so by considering possible connections between components.\n\n### Solution Code\n```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef main():\n    sys.setrecursionlimit(1 << 25)\n    n, m = map(int, sys.stdin.readline().split())\n    edges = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b = map(int, sys.stdin.readline().split())\n        a -= 1\n        b -= 1\n        edges[a].append(b)\n        edges[b].append(a)\n\n    visited = [False] * n\n    components = []\n    for i in range(n):\n        if not visited[i]:\n            q = deque()\n            q.append(i)\n            visited[i] = True\n            comp = []\n            while q:\n                u = q.popleft()\n                comp.append(u)\n                for v in edges[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        q.append(v)\n            components.append(comp)\n\n    odd_cycle = False\n    min_t = float('inf')\n    ways = 0\n\n    for comp in components:\n        if len(comp) < 2:\n            continue\n        comp_set = set(comp)\n        visited_nodes = set()\n        for u in comp:\n            visited_nodes.add(u)\n            for v in edges[u]:\n                if v in visited_nodes:\n                    continue\n                path = [u]\n                current = v\n                while current != u and current not in visited_nodes:\n                    visited_nodes.add(current)\n                    path.append(current)\n                    current = edges[current][0] if edges[current] else None\n                    if not current:\n                        break\n                if current == u:\n                    if (len(path) - 1) % 2 == 1:\n                        odd_cycle = True\n                        break\n        if odd_cycle:\n            break\n\n    if odd_cycle:\n        print(0, 1)\n        return\n\n    for i in range(len(components)):\n        for j in range(i + 1, len(components)):\n            comp1 = components[i]\n            comp2 = components[j]\n            if len(comp1) == 0 or len(comp2) == 0:\n                continue\n            if len(comp1) + len(comp2) < 2:\n                continue\n            size1 = len(comp1)\n            size2 = len(comp2)\n            if (size1 + size2) % 2 == 0:\n                continue\n            if size1 == 1 and size2 == 1:\n                t_add = 1\n                ways += 1\n                if t_add < min_t:\n                    min_t = t_add\n                if min_t == t_add:\n                    ways = 1\n            elif size1 >= 2 and size2 >= 2:\n                t_add = 1\n                ways += 1\n                if t_add < min_t:\n                    min_t = t_add\n                if min_t == t_add:\n                    ways = 1\n            else:\n                t_add = 2\n                ways += 1\n                if t_add < min_t:\n                    min_t = t_add\n                if min_t == t_add:\n                    ways = 1\n\n    if min_t == float('inf'):\n        print(\"Impossible\")\n        return\n\n    print(f\"{min_t} {ways}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\nThe solution first identifies all connected components in the graph. It then checks each component for the presence of an odd-length cycle. If any component has such a cycle, the minimum number of edges to add is zero, and there is exactly one way to form the cycle. If not, the solution considers pairs of components to determine the minimum edges needed to form an odd-length cycle by connecting them. The result is the minimum number of edges required and the number of ways to achieve this configuration.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    sys.setrecursionlimit(1 << 25)\n    n, m = map(int, sys.stdin.readline().split())\n    edges = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b = map(int, sys.stdin.readline().split())\n        a -= 1\n        b -= 1\n        edges[a].append(b)\n        edges[b].append(a)\n\n    visited = [False] * n\n    components = []\n    for i in range(n):\n        if not visited[i]:\n            q = deque()\n            q.append(i)\n            visited[i] = True\n            comp = []\n            while q:\n                u = q.popleft()\n                comp.append(u)\n                for v in edges[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        q.append(v)\n            components.append(comp)\n\n    odd_cycle = False\n    min_t = float('inf')\n    ways = 0\n\n    for comp in components:\n        if len(comp) < 2:\n            continue\n        comp_set = set(comp)\n        visited_nodes = set()\n        for u in comp:\n            visited_nodes.add(u)\n            for v in edges[u]:\n                if v in visited_nodes:\n                    continue\n                path = [u]\n                current = v\n                while current != u and current not in visited_nodes:\n                    visited_nodes.add(current)\n                    path.append(current)\n                    current = edges[current][0] if edges[current] else None\n                    if not current:\n                        break\n                if current == u:\n                    if (len(path) - 1) % 2 == 1:\n                        odd_cycle = True\n                        break\n        if odd_cycle:\n            break\n\n    if odd_cycle:\n        print(0, 1)\n        return\n\n    for i in range(len(components)):\n        for j in range(i + 1, len(components)):\n            comp1 = components[i]\n            comp2 = components[j]\n            if len(comp1) == 0 or len(comp2) == 0:\n                continue\n            if len(comp1) + len(comp2) < 2:\n                continue\n            size1 = len(comp1)\n            size2 = len(comp2)\n            if (size1 + size2) % 2 == 0:\n                continue\n            if size1 == 1 and size2 == 1:\n                t_add = 1\n                ways += 1\n                if t_add < min_t:\n                    min_t = t_add\n                if min_t == t_add:\n                    ways = 1\n            elif size1 >= 2 and size2 >= 2:\n                t_add = 1\n                ways += 1\n                if t_add < min_t:\n                    min_t = t_add\n                if min_t == t_add:\n                    ways = 1\n            else:\n                t_add = 2\n                ways += 1\n                if t_add < min_t:\n                    min_t = t_add\n                if min_t == t_add:\n                    ways = 1\n\n    if min_t == float('inf'):\n        print(\"Impossible\")\n        return\n\n    print(f\"{min_t} {ways}\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 570,
        "completion_token_count": 1004,
        "thoughts_token_count": 1025
    }
}