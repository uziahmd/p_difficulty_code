{
    "start": 1758288701.212778,
    "end": 1758291156.7273283,
    "start-formatted": "2025-09-19 22:31 KST",
    "end-formatted": "2025-09-19 23:12 KST",
    "gpu": 2,
    "pid": 30,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# TV Game\n\nThere is a new TV game on BerTV. In this game two players get a number A consisting of 2n digits. Before each turn players determine who will make the next move. Each player should make exactly n moves. On it's turn i-th player takes the leftmost digit of A and appends it to his or her number Si. After that this leftmost digit is erased from A. Initially the numbers of both players (S1 and S2) are «empty». Leading zeroes in numbers A, S1, S2 are allowed. In the end of the game the first player gets S1 dollars, and the second gets S2 dollars.One day Homer and Marge came to play the game. They managed to know the number A beforehand. They want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize. Help them.\n\n## Input\nThe first line contains integer n (1 ≤ n ≤ 18). The second line contains integer A consisting of exactly 2n digits. This number can have leading zeroes.\n\n## Output\nOutput the line of 2n characters «H» and «M» — the sequence of moves of Homer and Marge, which gives them maximum possible total prize. Each player must make exactly n moves. If there are several solutions, output any of them.\n\n## Example\n### Input\n['2\\n1234', '2\\n9911']\n\n### Output\n['HHMM', 'HMHM']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read it carefully.\n\nThe problem is about a TV game where two players, Homer and Marge, take turns picking digits from a string A. The string A has exactly 2n digits. They each make exactly n moves. On each turn, the current player takes the leftmost digit of A, appends it to their number, and then that digit is removed from A. The goal is to maximize the sum of their numbers, S1 and S2, which are the sums of the digits each has collected. We need to output the sequence of moves (H for Homer, M for Marge) that achieves this maximum.\n\nHmm, how do I approach this? Well, let's think about what maximizes S1 + S2. Since each move adds a digit to either S1 or S2, the total sum is the sum of all digits in A. So the order in which the digits are assigned doesn't affect the total sum. Wait, that can't be right. Because the way you assign them might affect how the digits are grouped. But no, because regardless of the order, the sum is fixed. So why is the problem asking for the optimal sequence?\n\nWait wait, maybe I'm misunderstanding the problem. Oh right, S1 is the sum of the digits in Homer's Si, and S2 is the sum for Marge. So the sum S1 + S2 is fixed as the sum of all digits in A. So any sequence will give the same total. But the problem says to maximize their total prize, which is the same as maximizing S1 + S2. But that's always fixed, so perhaps I misunderstood the problem statement.\n\nWait, no, the problem says to maximize their total prize, which is S1 + S2. But since the sum of all digits is fixed, that's not changing. So why is there an optimal sequence? Maybe I'm missing something.\n\nWait, perhaps the problem is to maximize the sum of their individual numbers, but that's the same as the sum of all digits. So maybe the problem is to maximize the sum of their individual numbers, but that's already fixed. So perhaps the problem is to find a way to split the digits into two sequences of n digits each, such that the sum of the first sequence plus the second is maximum. But that's just the sum of all digits. So maybe I'm misunderstanding the problem.\n\nWait, looking back: the output is the sequence of H and M, such that when each H picks the leftmost digit, appending to S1, and M does the same for S2, the sum of S1 and S2 is maximized. But since the sum is fixed, the order doesn't matter. So perhaps the problem is to maximize the sum of S1 and S2, which is the same as the sum of all digits. So perhaps the actual goal is to arrange the digits into two sequences of n digits each, in the order they are picked, such that the sum of S1 and S2 is as large as possible. But since the sum is fixed, perhaps the problem is to choose the order of selection such that the individual sums S1 and S2 are as large as possible. Or maybe the problem is to maximize the minimum of S1 and S2.\n\nWait, perhaps the problem is to maximize the sum of S1 and S2, but that's fixed. So perhaps the actual goal is to arrange the moves so that the sum of the digits in S1 is as large as possible, but since S2 is the remaining digits, perhaps we need to balance the choices between the two players to maximize both.\n\nWait, perhaps the problem is to maximize S1 + S2, but since that's fixed, perhaps the problem is to maximize the sum of the digits in S1 and S2, which is fixed. So the problem reduces to finding a way to split the digits into two groups of n digits each, such that the sum of the two groups is as large as possible, but that's fixed. So perhaps the problem is just to find a way to split the digits into two equal parts, regardless of their order, but the order in which they are picked affects the sequence.\n\nWait, perhaps the problem is to arrange the digits in such a way that the sum of S1 is as large as possible, given that the order of taking the digits must be the leftmost at each step. Because each time you take the leftmost digit, the order is determined by the initial string.\n\nAh! So the key is that the digits are taken in the order of the original string A. So for example, if A is '1234', then the first digit taken is '1', then '2', then '3', then '4'. Each player alternately takes the next available digit, building their own number. So the order in which the digits are added is fixed as per the original string. The only choice is who takes which digit.\n\nSo our task is to decide for each position whether it's taken by Homer (H) or Marge (M), such that each gets exactly n digits, and the sum of their numbers is maximized. But since the sum is fixed, perhaps we're trying to maximize some other aspect, like the product or something else. Wait, no— the problem says \"maximize their total prize\", which is S1 + S2, which is fixed. So perhaps the problem is to maximize the sum of S1 and S2, but that's fixed, so any arrangement would work. So why is the sample input giving a specific sequence?\n\nWait, looking at the sample input:\n\nInput:\nn=2\nA=1234\n\nSample Output:\nHHMM\n\nSo the sequence is H, H, M, M.\n\nLet's see: the digits are taken in order 1, 2, 3, 4.\n\nIn this case:\n\n- First move: H takes 1 → S1 = 1\n- Second move: H takes 2 → S1 = 3\n- Third move: M takes 3 → S2 =3\n- Fourth move: M takes4 → S2 =7\nTotal S1=3, S2=7. Sum is 10.\n\nAlternatively, if the sequence was HMHM:\n\nDigits taken in order 1 (H), 2 (M), 3 (H),4 (M).\n\nS1 =1+3=4, S2=2+4=6. Sum is 10.\n\nAnother option: HMHM gives S1=1+3=4, S2=2+4=6, same sum.\n\nWait, but why is the sample output HHMM? Because perhaps that's one of the possible optimal sequences.\n\nWait, but in the sample input given, the output is different. Oh, wait no, the sample input is probably different. Looking at the sample input, perhaps it's a different A.\n\nWait the user provided an example with input:\n\n['2\\n1234', '2\\n9911']\n\nWait, perhaps I got the sample wrong. Anyway, perhaps the key is that the order in which the digits are taken is fixed as the original string, and the decision is which player takes each digit. The goal is to maximize S1 + S2, but that's fixed. So perhaps the problem is to arrange the digits so that the sum is as large as possible, but that's fixed. So perhaps the problem is to maximize the minimum of S1 and S2.\n\nAlternatively, perhaps the problem is to maximize the sum of the squares of S1 and S2, but that's not stated.\n\nWait, perhaps I misread the problem statement. Let me re-read it.\n\nThe problem says: \"find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize.\"\n\nTotal prize is S1 + S2. Since that's fixed, perhaps the problem is to maximize the sum of S1 and S2, but that's fixed, so any sequence is acceptable. But that can't be, because the sample shows a particular sequence.\n\nWait, perhaps the problem is to maximize the sum of the digits in S1, regardless of S2, but since S1 and S2 are both part of the output, but the sum is fixed, perhaps the problem is to choose the assignment to maximize the individual S1, but that's not the case.\n\nAlternatively, perhaps the problem is to arrange the assignments so that the sum of the digits in S1 is as large as possible, but that would require assigning higher digits to S1. However, the order is fixed as per A.\n\nWait, perhaps the problem is that the sum of S1 and S2 is fixed, but the way the digits are assigned affects the individual sums. So for example, if we can assign larger digits to S1, S1 could be larger, but S2 would be smaller. But since the total is fixed, perhaps the problem is to choose the assignment that maximizes S1, but that's not the case because the problem states to maximize the total.\n\nWait, perhaps the problem is to maximize the sum of S1 and S2, but that's fixed, so the problem is to maximize the product S1 * S2, but that's not stated.\n\nHmm, perhaps I'm overcomplicating this. Let me think again.\n\nEach digit is taken in the order of A. For each position i (from 0 to 2n-1), the digit is assigned to either S1 or S2, based on whether it's an even or odd step (since each player makes exactly n moves). Wait, no— the players alternate turns. So the first digit is taken by the first player, second by the second, third by the first, fourth by the second, and so on.\n\nWait, no— because each player must make exactly n moves. So for 2n digits, the first n digits are taken by the first player, and the last n by the second? Or is it that each player takes every other digit, starting with the first player.\n\nWait, the problem says each player should make exactly n moves. So for 2n digits, each player takes exactly n digits. So the assignment is that the first player takes the 1st, 3rd, 5th, etc., up to the (2n-1)th digit. The second player takes the 2nd, 4th, etc., up to the 2nth digit. So the sequence is fixed as H, M, H, M, etc., but the sample input shows a different pattern.\n\nWait, that can't be right because the sample shows a different output. So perhaps I'm misunderstanding how the turns proceed.\n\nWait, perhaps the players determine who goes first. So the first player is either H or M, and then they alternate. But the problem allows them to choose who goes first each turn. So the sequence can be arranged as needed.\n\nOh! That's a crucial point I missed. So the players can choose who goes first each turn. So for example, the first move can be H, the second could be M, but perhaps after that, the players can swap who goes next. But wait, the problem says: \"each player should make exactly n moves.\" So the total number of moves is 2n, with each player making n moves. So the initial arrangement can be that the first player is H, then M, then H, etc. Or perhaps M first, then H, etc. But the problem says that each player must make exactly n moves, so the total number is 2n, which is even. So the initial choice is whether the first player is H or M.\n\nBut wait, the problem statement says: \"before each turn players determine who will make the next move.\" So each turn, the players can choose who will take the next digit. So it's possible that the same player takes multiple consecutive digits.\n\nSo the choice is, for each digit, whether it's assigned to H or M. But the constraint is that each must have exactly n digits.\n\nSo the problem becomes: assign each digit to H or M, ensuring that exactly n are assigned to each, such that the sum of H's digits plus M's digits is as large as possible. Wait, but that's fixed because the sum is the sum of all digits.\n\nWait, that can't be. So perhaps the problem is to choose the assignment that allows H and M to have their digits arranged in such a way that the sum of their numbers is maximized. But since the sum is fixed, perhaps the problem is to maximize the individual sums S1 and S2. But that's not possible because S1 + S2 is fixed.\n\nWait, maybe the problem is to maximize the product of S1 and S2. But the problem statement says the total prize is S1 + S2. So perhaps the problem is just to assign the digits optimally, but the sum is fixed.\n\nWait, perhaps the problem is to arrange the digits into two sequences of n digits each, such that the sum of the two sequences is fixed, but the way the digits are assigned affects the individual sums. For example, if you give more high-value digits to one player, their sum increases, but the other's decreases. But since the total is fixed, perhaps the goal is to maximize the minimal sum between S1 and S2.\n\nAlternatively, perhaps the problem is to maximize the sum of S1 minus S2, but the problem says to maximize the total.\n\nI'm getting stuck here. Let's think differently.\n\nWhat's the objective function? It's S1 + S2, which is the sum of all digits. So the maximum is fixed as the sum of all digits. So the problem reduces to finding a way to assign the digits to H and M, each exactly n, such that the sum is fixed, but perhaps the individual sums are as large as possible. But that's not directly helpful.\n\nWait, perhaps the problem is to maximize the sum of the digits of S1, regardless of S2. But that's not the case because the problem says to maximize the total, which is fixed.\n\nAlternatively, perhaps the problem is to maximize the sum of the digits in S1 plus the sum of the digits in S2, which is fixed, so the problem is trivial. But that can't be, as the sample shows a specific output.\n\nSo perhaps I'm misunderstanding the problem.\n\nWait, the problem says that the players take turns choosing the next digit, but they can decide who goes first. So for example, the first move can be made by either player, then the next, etc., as long as each ends up with exactly n moves.\n\nWait, but the total number of moves is 2n, so each player must make exactly n moves. So the initial decision is who takes the first move, and then they alternate or not as needed.\n\nNo, that can't be right. Because if the first player is H, then the next is M, then H, etc., but that would require 2n moves. But since each player must make n moves, the initial assignment must allow for each to take n digits.\n\nWait, perhaps the initial assignment is to choose the first player, and then each subsequent move is chosen by the players. So for example, H starts, then M, then H, then M, etc., leading to each having n moves. Or perhaps the players can decide each time who takes the next digit.\n\nSo the problem is to decide, for each position, whether it's H or M, subject to the constraint that exactly n positions are H and n are M.\n\nSo the goal is to assign H and M to each position, with exactly n H's and n M's, such that the sum S1 + S2 is maximized. But since that sum is fixed, perhaps the problem is to assign the digits in a way that S1 is as large as possible, but that's not necessarily true because S2 can vary.\n\nWait, perhaps the problem is to arrange the digits in such a way that the sum of the digits assigned to H is as large as possible. Because S2 is the sum of the remaining digits, which may be smaller. But since S1 + S2 is fixed, perhaps the problem is to maximize S1, thus minimizing S2.\n\nBut the problem says to maximize the total, which is fixed, so perhaps any assignment is acceptable. But the sample shows a specific output, so perhaps the problem is to maximize the sum of the digits in S1.\n\nWait, in the sample, the sum of S1 is 3, S2 is 7, total 10. If another arrangement had S1=4 and S2=6, that's also sum 10. So perhaps the problem is to choose the arrangement that maximizes the sum of S1 and S2, but since that's fixed, perhaps it's to maximize the product S1*S2, but that's not stated.\n\nHmm, perhaps I'm missing the actual problem statement. Let me re-examine it.\n\nProblem Statement:\n\nTwo players, Homer and Marge, play a game with a number A consisting of 2n digits. They take turns picking the leftmost digit, appending it to their respective numbers. Each makes exactly n moves. The goal is to find the sequence of moves (H or M for each step) that maximizes their total prize, which is S1 + S2.\n\nSo the problem is to choose the order of H and M such that the sum S1 + S2 is as large as possible. But since the sum is fixed, perhaps the problem is to find any arrangement where the digits are assigned to maximize some other metric, but the problem states that the sum is the target.\n\nWait, perhaps the problem is to maximize the sum of S1 and S2, but since that's fixed, perhaps the problem is to find any valid sequence. But the sample shows a specific output, so perhaps the problem is to find a way to assign the digits to H and M such that the sum is fixed, but the individual sums are as large as possible.\n\nAlternatively, perhaps the problem is to maximize the sum of the digits multiplied by their place values, but that's not indicated in the problem statement.\n\nWait, the problem statement says that S1 and S2 are the numbers formed by the digits taken. So S1 is the concatenation of the digits assigned to H, and S2 is the concatenation for M. So S1 and S2 are treated as numbers, not as sums of their digits. Oh! That's a crucial point I missed.\n\nWait, the problem says, \"the first player gets S1 dollars, and the second gets S2 dollars.\" So S1 is the number formed by the digits taken by H, and S2 is the number formed by the digits taken by M. So the sum S1 + S2 is the sum of these two numbers. Now that's a different problem.\n\nAh! So now the problem is to assign each digit to H or M such that the sum of the numbers formed by their digits is as large as possible.\n\nThis changes everything.\n\nSo the problem is to split the digits into two groups of n digits each, and form two numbers S1 and S2, such that their sum is maximized.\n\nBut how to achieve that.\n\nFor example, in the sample input:\n\nA is '1234', n=2.\n\nWe need to split into two groups of two digits each.\n\nIf H takes 1 and 2, making 12, M takes 3 and4, making 34. Sum is 46.\n\nAlternatively, if H takes 1 and3, M takes 2 and4. H's number is 13, M's is 24. Sum is 37.\n\nOr H takes 1 and4, M takes 2 and3: H's number is 14, M's is 23. Sum is 37.\n\nOr H takes 12 and M takes 34: sum 46.\n\nAnother option: H takes 13, M takes 24: sum 37.\n\nAnother option: H takes 1, 3, M takes 2,4: sum 13+24=37.\n\nAnother option: H takes 1,4, M takes 2,3: sum 14+23=37.\n\nWait, but 34 is 34, which is 30+4=34. So 12+34=46.\n\nIs that the maximum possible?\n\nYes, because any other split gives a lower sum.\n\nSo the optimal split is to have H take the first two digits, forming 12, and M take the last two, forming 34.\n\nWhich gives the maximum sum.\n\nSo the sequence is H, H, M, M.\n\nWhich is the sample output.\n\nNow, the problem is to find such a split.\n\nSo the task is to find a way to partition the digits into two groups of n each, such that the sum of the two numbers formed is as large as possible.\n\nHow can we model this?\n\nWell, the sum of two numbers can be thought of as:\n\nsum = num1 + num2.\n\nTo maximize this sum, we need to arrange the digits in such a way that the highest possible digits are placed in the most significant positions of both numbers.\n\nSo, the strategy would be to greedily assign the largest remaining digits to the highest possible positions in either num1 or num2.\n\nBut since each player can only have n digits, and the order in which the digits are taken is fixed as per the original string (left to right), perhaps the problem is to determine which digits are assigned to which player in such a way that the most significant digits are given to the players' numbers as early as possible.\n\nWait, but the players take the digits in order, so each digit is added to the end of their respective numbers. So for example, the first digit is the most significant digit of their number, the next is the next most significant, etc.\n\nSo for the maximum sum, each digit should be placed in the earliest possible position in the largest possible number.\n\nThus, for each digit, we want it to be in the leftmost position of the largest possible number.\n\nSo the approach is to choose, for each digit, whether to add it to H's or M's number, such that the overall sum is maximized.\n\nBut how to model this.\n\nAn alternative approach is to think of the problem as a dynamic programming problem. At each step, we can choose to assign the current digit to H or M, and track the current state of both numbers. The state would include the current lengths of H's and M's numbers, as well as the last digits for leading zeros.\n\nWait, but n can be up to 18, which means 2n is 36 digits. So a dynamic programming approach with O(2n * n^2) time complexity could be feasible.\n\nLet me outline the approach.\n\nWe can model the state as (h_digits, m_digits), where h_digits is a tuple representing the digits in H's number, and similarly for m_digits. But this would be too memory-intensive for 36 digits.\n\nAlternatively, we can model the state as the current positions in H's and M's numbers, and track the last digits added.\n\nWait, perhaps the state can be represented by the current count of digits used for H and M, and the last digits of each. Because when adding a new digit, it's appended to the end of the respective number, so the position is determined by how many digits have been added so far.\n\nSo the state can be (h_pos, m_pos, h_last, m_last), where h_pos is the number of digits in H's number, m_pos is the number for M, and h_last and m_last are the last digits added to each.\n\nAt each step, we can choose to assign the current digit to H or M, and update the state accordingly.\n\nThe DP transition would be:\n\nFor each state (h, m, h_last, m_last), and for the current digit d:\n\nOption 1: Assign to H.\n\n- New h_pos is h+1.\n- New h_last is d.\n- New state is (h+1, m, d, m_last).\n- The cost is the value of the new H's number plus the current M's number.\n\nOption 2: Assign to M.\n\n- New m_pos is m+1.\n- New m_last is d.\n- New state is (h, m+1, h_last, d).\n- The cost is the value of the new H's number plus the new M's number.\n\nThe initial state is (0,0, -1, -1), meaning both have no digits.\n\nAt each step, we process the next digit in the string A, and for each possible state, we compute the best possible cost.\n\nWait, but the digits are processed in order, so the state must process them in sequence.\n\nSo the DP can be built step by step, processing each digit in order.\n\nSo for each digit, we consider all possible states before processing it and update the states after processing it.\n\nThe final answer is the maximum sum achieved after all digits are processed.\n\nAdditionally, we need to track the path (sequence of H and M assignments) that leads to this maximum sum.\n\nSo the steps are:\n\n1. Read the input string A, and convert it into a list of characters (digits).\n\n2. Initialize a DP table, where each state is represented by (h_pos, m_pos, h_last, m_last), and the value is the maximum sum achievable up to that state.\n\n3. For each digit in A, in order, update the DP table by considering assigning the digit to H or M.\n\n4. After processing all digits, backtrack through the DP to find the path that led to the maximum sum.\n\nBut how to represent the state efficiently.\n\nConsidering that n can be up to 18, h_pos and m_pos can each range from 0 to n.\n\nh_last and m_last can be 0-9, but for the initial state, they are -1 or some invalid value.\n\nThe size of the state space is (n+1) * (n+1) * 10 * 10 = (19)^2 * 10^2 = around 36100, which is manageable.\n\nProcessing 36 digits, each step updating the DP, so total steps are 36 * 36100 ≈ 1.3 million operations, which is acceptable.\n\nSo the plan is:\n\n- Use dynamic programming to track the maximum sum achievable for each possible state (h_pos, m_pos, h_last, m_last).\n\n- For each state, and for the current digit, compute the possible transitions to the next state, and update the maximum sum accordingly.\n\n- Once all digits are processed, reconstruct the path to find the sequence of H and M assignments.\n\nNow, implementing this.\n\nFirst, represent the DP as a dictionary or a 4-dimensional array. However, in Python, using a dictionary for each step might be efficient enough.\n\nAt each step, we have a current DP dictionary. For each state in the current DP, and for each possible assignment (H or M) of the current digit, we compute the new state and update the next DP accordingly.\n\nLet me outline the steps in code.\n\nInitialize the DP:\n\ncurrent_dp = { (0,0, None, None): 0 }\n\nBut wait, h_pos and m_pos start at 0, and h_last and m_last are None initially.\n\nWait, but perhaps it's better to represent the last digits as None or some special value.\n\nBut for the purposes of the DP, perhaps we can represent the last digits as strings or integers. For the initial state, h_last and m_last can be a special value indicating that no digits have been added yet.\n\nThen, for each digit in A:\n\n    next_dp = {}\n    for state in current_dp:\n        h_pos, m_pos, h_last, m_last = state\n        current_sum = current_dp[state]\n\n        # Option 1: Assign current digit to H\n        if h_pos < n:\n            new_h_pos = h_pos + 1\n            new_h_last = str(digit)\n            # The value added is the new_h_last * 10^{new_h_pos-1} ?\n\n            # Wait, no. Because the number is built by appending the digit, so each new digit increases the length by 1, and the digit is added to the end.\n\n            # So the value contributed by adding this digit to H's number depends on its position.\n\n            # For example, if H's number currently has h_pos digits, adding a new digit d will make it h_pos+1 digits. The new number is (previous number)*10 + d.\n\n            # So the change in sum is (prev_H_number * 10 + d) - prev_H_number = prev_H_number * 9 + d.\n\n            # But tracking the exact value of each number is difficult because it can be very large (up to 10^36). So instead, we need to track the sum incrementally.\n\n            # Wait, but in the DP, the sum is the sum of the two numbers. So when adding a digit to H's number, the sum increases by (current H's number + new digit * 10^{k}) where k is the number of digits added so far to H.\n\n            # Hmm, but this seems tricky because the actual value of H's number depends on the order of the digits.\n\n            # This suggests that the DP needs to track not just the sum, but also the exact value of each number.\n\n            # But that's impossible because the numbers can be up to 1e36, which is way beyond standard integer representation.\n\n            # So, perhaps the problem requires a different approach.\n\nAlternative Idea: The maximum sum is achieved when the two numbers are as large as possible, considering their digit assignments.\n\nWait, but the sum is S1 + S2, where S1 is the number formed by the digits assigned to H, and S2 is the number formed by the digits assigned to M.\n\nSo to maximize S1 + S2, we need to arrange the digits in such a way that the higher digits are placed as much as possible in the higher places of both numbers.\n\nSo for the first digit (most significant), assign it to the number that can make the largest contribution. But since both numbers are being built, perhaps the first digit should go to the first player, as adding it to their number will contribute more.\n\nBut it's unclear. Alternatively, perhaps the maximum sum is achieved by greedily assigning the largest remaining digit to the largest possible number.\n\nWait, perhaps the optimal strategy is to arrange the digits in such a way that the two numbers are as large as possible.\n\nSo, for each position, we want to assign the current digit to the number that can benefit the most from it.\n\nBut how to model that.\n\nAnother approach is to realize that the sum of two numbers is equal to the sum of their digits multiplied by appropriate powers of 10. To maximize this sum, we should arrange the digits so that the higher digits are in higher positions across both numbers.\n\nSo, for the first digit (most significant), we should assign it to the number that can have the largest possible impact.\n\nBut it's unclear which number that would be.\n\nAlternatively, perhaps the optimal strategy is to arrange the digits such that the two numbers are as balanced as possible in terms of their magnitudes.\n\nWait, for example, if the digits are [9,9,1,1], n=2.\n\nIf we assign 9 to H and 9 to M, then their numbers are 99 and 11, sum 110.\n\nAlternatively, if we assign 91 to H and 99 to M, then sum is 90 + 99 = 189, which is larger.\n\nSo, the initial idea of putting the largest digits first is better.\n\nWait, but in that case, the maximum sum is achieved by assigning the largest digits to the highest possible positions in either number.\n\nSo the approach is to arrange the digits in descending order, and assign them alternately to H and M, starting with the player who can get the maximum benefit.\n\nBut this is vague.\n\nPerhaps, the correct approach is to model the problem as a dynamic programming problem, where for each position, we decide whether to assign it to H or M, and keep track of the current state (how many digits each has, and the last digits of each number).\n\nThe state can be represented as (h_pos, m_pos, h_last, m_last), where h_pos is the number of digits in H's number, m_pos is the same for M, h_last is the last digit added to H's number, and m_last is the last digit added to M's.\n\nThe value of the state is the maximum sum achievable up to that point.\n\nAt each step, for each state, and for the current digit, we can branch into two possibilities: assign to H or to M, and compute the resulting state and the new sum.\n\nThe key is that when you assign a digit to a player, it's added to their number, which increases their number by (digit * 10^{k}), where k is the number of digits already present in their number.\n\nWait, but calculating the sum incrementally would require knowing the current value of each number, which is impractical due to size.\n\nSo, perhaps we can model the sum as the sum of the contributions of the digits so far.\n\nFor example, when a digit is added to H's number, the contribution is (current value of H's number) * 10 + d. So the change in sum is (current H's number * 10 + d) - current H's number = current H's number *9 +d.\n\nSimilarly for M's number.\n\nBut again, this requires knowing the current value of each number, which is not feasible to track in the state.\n\nAlternative Idea: Instead of tracking the actual numbers, track the sum incrementally.\n\nWait, but each digit's contribution depends on its position. So for a given digit d, if it's the i-th digit added to a number, its contribution is d * 10^{i-1}.\n\nThus, the total sum is the sum of all digits' contributions.\n\nSo, for the dynamic programming approach, perhaps the state can include the current number of digits for H and M, and for each, the last digit added. Then, when adding a new digit, the contribution can be computed as the digit multiplied by 10^{current_length}, and then added to the sum.\n\nBut how to model this in the DP.\n\nEach state can track:\n\n- h_count: number of digits in H's number.\n\n- m_count: number of digits in M's number.\n\n- h_last: last digit added to H's number (or None if none).\n\n- m_last: last digit added to M's number (or None if none).\n\nThe value of the state is the maximum sum achieved so far.\n\nWhen processing a new digit, say d, for each state, we can consider two options: assign to H or to M.\n\nIf assigning to H:\n\n- The new h_count is h_count +1.\n\n- The contribution is d * 10^{h_count}.\n\n- The new sum is current_sum + contribution.\n\nSimilarly for M.\n\nSo the state transition is:\n\nFor each state in current_dp:\n\n    if h_count < n:\n\n        new_h_count = h_count +1\n\n        contribution = d * (10 ** new_h_count)\n\n        new_sum = current_sum + contribution\n\n        new_state = (new_h_count, m_count, d, m_last)\n\n        if this state is not in next_dp or new_sum is larger than existing, update next_dp[new_state] = max(existing, new_sum)\n\n    similarly for m_count <n.\n\nWait, but wait:\n\nActually, when adding a digit to H's number, the contribution is d multiplied by 10 raised to the number of digits already in H's number before adding this digit.\n\nBecause each digit added increases the number's length by one, and the digit is added to the end, which is the next higher place.\n\nSo for example:\n\nH's number is empty (h_count=0). Adding d=3: contribution is 3*10^0=3.\n\nH's number is 1 (h_count=1). Adding d=5: contribution is 5*10^1=50.\n\nSo yes, the contribution is d * 10^{h_count}.\n\nSo the DP state must include h_count and m_count to calculate this.\n\nThus, the DP can be modeled as follows:\n\n- For each state (h_count, m_count, h_last, m_last), and for each digit in order, compute the new state and the new sum.\n\nSo, the initial state is (0,0, None, None), sum 0.\n\nFor each digit d in A:\n\n    for each state in current_dp:\n\n        h_c, m_c, h_l, m_l = state\n\n        current_sum = current_dp[state]\n\n        # Assign to H, if possible\n        if h_c <n:\n            new_h_c = h_c +1\n            contribution = d * (10 ** new_h_c)\n            new_sum = current_sum + contribution\n            new_state = (new_h_c, m_c, d, m_l)\n            if new_state not in next_dp or new_sum > next_dp[new_state]:\n                next_dp[new_state] = new_sum\n\n        # Assign to M, if possible\n        if m_c <n:\n            new_m_c = m_c +1\n            contribution = d * (10 ** new_m_c)\n            new_sum = current_sum + contribution\n            new_state = (h_c, new_m_c, h_l, d)\n            if new_state not in next_dp or new_sum > next_dp[new_state]:\n                next_dp[new_state] = new_sum\n\n    current_dp = next_dp.copy()\n\nAfter processing all digits, the maximum sum is the maximum value among all states in current_dp.\n\nOnce the maximum sum is found, we need to reconstruct the path that led to it.\n\nReconstruction involves backtracking from the final state to the initial state, keeping track of the choices made at each step (whether to assign to H or M).\n\nBut how to track the path. We can modify the DP to store not only the sum but also the choice made (H or M) that led to the state.\n\nAlternatively, during the reconstruction phase, for each state, we can try both possibilities (assigning to H or M) and see which one led to the current state.\n\nBut that can be computationally expensive, but for n up to 18, it's manageable.\n\nSo, the plan is:\n\nImplement a DP that tracks for each state (h_c, m_c, h_l, m_l) the maximum sum achievable.\n\nProcess each digit, updating the DP.\n\nOnce all digits are processed, find the state with the maximum sum.\n\nThen, backtrack from that state to determine the sequence of choices (H or M) for each digit.\n\nNow, implementing this.\n\nFirst, let's think about the data structures.\n\nIn Python, dictionaries can be used to represent the DP states.\n\nEach state is a tuple (h_c, m_c, h_l, m_l), where h_c and m_c are integers, and h_l and m_l are either None or integers.\n\nThe value stored",
    "response": "To solve this problem, we need to determine the optimal sequence of moves for Homer and Marge in a TV game such that their total prize, which is the sum of the numbers they form from the digits they collect, is maximized. Each player must make exactly `n` moves, and the digits are taken from the leftmost end of the given string `A`.\n\n### Approach\nThe key insight is to use dynamic programming (DP) to track the maximum possible sum of the numbers formed by Homer (H) and Marge (M). The approach involves:\n\n1. **State Representation**: Each state in our DP will be represented by a tuple `(h_c, m_c, h_l, m_l)`, where:\n   - `h_c` is the count of digits collected by Homer.\n   - `m_c` is the count of digits collected by Marge.\n   - `h_l` is the last digit added to Homer's number.\n   - `m_l` is the last digit added to Marge's number.\n\n2. **Transition Between States**: For each digit in the string `A`, we consider two possible transitions:\n   - Assigning the digit to Homer, if he hasn't collected all `n` digits yet.\n   - Assigning the digit to Marge, if she hasn't collected all `n` digits yet.\n\n3. **Maximize the Sum**: For each transition, we calculate the new sum by considering the contribution of the current digit to the respective player's number. The contribution of a digit `d` at position `i` is `d * 10^i`, where `i` is the number of digits already collected by the player before adding `d`.\n\n4. **Backtracking to Find the Path**: After processing all digits, we backtrack from the state with the maximum sum to reconstruct the sequence of moves that led to it.\n\n### Solution Code\n```python\ndef main():\n    import sys\n    n = int(sys.stdin.readline())\n    A = sys.stdin.readline().strip()\n    digits = list(A)\n    \n    # DP state: (h_count, m_count, h_last, m_last) -> max_sum\n    from collections import defaultdict\n    current_dp = defaultdict(int)\n    current_dp[(0, 0, None, None)] = 0\n    \n    for d_char in digits:\n        d = int(d_char)\n        next_dp = defaultdict(int)\n        for state in current_dp:\n            h_c, m_c, h_l, m_l = state\n            current_sum = current_dp[state]\n            \n            # Assign to H\n            if h_c < n:\n                new_h_c = h_c + 1\n                contribution = d * (10 ** new_h_c)\n                new_sum = current_sum + contribution\n                new_state = (new_h_c, m_c, d, m_l)\n                if new_state not in next_dp or new_sum > next_dp[new_state]:\n                    next_dp[new_state] = new_sum\n            \n            # Assign to M\n            if m_c < n:\n                new_m_c = m_c + 1\n                contribution = d * (10 ** new_m_c)\n                new_sum = current_sum + contribution\n                new_state = (h_c, new_m_c, h_l, d)\n                if new_state not in next_dp or new_sum > next_dp[new_state]:\n                    next_dp[new_state] = new_sum\n        \n        current_dp = next_dp\n    \n    # Find the maximum sum state\n    max_sum = -1\n    best_state = None\n    for state in current_dp:\n        if current_dp[state] > max_sum:\n            max_sum = current_dp[state]\n            best_state = state\n    \n    # Reconstruct the path\n    path = []\n    h_c, m_c, h_l, m_l = best_state\n    while h_c > 0 or m_c > 0:\n        if h_c > 0:\n            # Check if current digit was assigned to H\n            found = False\n            for state in current_dp:\n                if state[0] == h_c-1 and state[1] == m_c and state[2] == h_l and state[3] == m_l:\n                    prev_h_c, prev_m_c, prev_h_l, prev_m_l = state\n                    if (prev_h_c, prev_m_c, prev_h_l, prev_m_l) in current_dp:\n                        path.append('H')\n                        h_c, m_c, h_l, m_l = prev_h_c, prev_m_c, prev_h_l, prev_m_l\n                        found = True\n                        break\n            if not found:\n                # Assigned to M\n                path.append('M')\n        else:\n            # Last digit assigned to M\n            path.append('M')\n    \n    # Since the digits are processed in order, the path is built in reverse\n    path = path[::-1]\n    \n    # Convert to 'H'/'M' string\n    print(''.join(path))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input consists of an integer `n` and a string `A` of `2n` digits.\n2. **Initialization**: We initialize a DP dictionary to keep track of the maximum sum achievable for each state.\n3. **Processing Digits**: For each digit in `A`, we update the DP states by considering both possible assignments (to Homer or Marge).\n4. **Finding Maximum Sum**: After processing all digits, we identify the state with the maximum sum.\n5. **Reconstructing the Path**: Using backtracking, we determine the sequence of moves that led to the maximum sum and print the result.\n\nThis approach efficiently explores all possible ways to assign digits to maximize the total prize using dynamic programming, ensuring that each player makes exactly `n` moves.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n    n = int(sys.stdin.readline())\n    A = sys.stdin.readline().strip()\n    digits = list(A)\n    \n    # DP state: (h_count, m_count, h_last, m_last) -> max_sum\n    from collections import defaultdict\n    current_dp = defaultdict(int)\n    current_dp[(0, 0, None, None)] = 0\n    \n    for d_char in digits:\n        d = int(d_char)\n        next_dp = defaultdict(int)\n        for state in current_dp:\n            h_c, m_c, h_l, m_l = state\n            current_sum = current_dp[state]\n            \n            # Assign to H\n            if h_c < n:\n                new_h_c = h_c + 1\n                contribution = d * (10 ** new_h_c)\n                new_sum = current_sum + contribution\n                new_state = (new_h_c, m_c, d, m_l)\n                if new_state not in next_dp or new_sum > next_dp[new_state]:\n                    next_dp[new_state] = new_sum\n            \n            # Assign to M\n            if m_c < n:\n                new_m_c = m_c + 1\n                contribution = d * (10 ** new_m_c)\n                new_sum = current_sum + contribution\n                new_state = (h_c, new_m_c, h_l, d)\n                if new_state not in next_dp or new_sum > next_dp[new_state]:\n                    next_dp[new_state] = new_sum\n        \n        current_dp = next_dp\n    \n    # Find the maximum sum state\n    max_sum = -1\n    best_state = None\n    for state in current_dp:\n        if current_dp[state] > max_sum:\n            max_sum = current_dp[state]\n            best_state = state\n    \n    # Reconstruct the path\n    path = []\n    h_c, m_c, h_l, m_l = best_state\n    while h_c > 0 or m_c > 0:\n        if h_c > 0:\n            # Check if current digit was assigned to H\n            found = False\n            for state in current_dp:\n                if state[0] == h_c-1 and state[1] == m_c and state[2] == h_l and state[3] == m_l:\n                    prev_h_c, prev_m_c, prev_h_l, prev_m_l = state\n                    if (prev_h_c, prev_m_c, prev_h_l, prev_m_l) in current_dp:\n                        path.append('H')\n                        h_c, m_c, h_l, m_l = prev_h_c, prev_m_c, prev_h_l, prev_m_l\n                        found = True\n                        break\n            if not found:\n                # Assigned to M\n                path.append('M')\n        else:\n            # Last digit assigned to M\n            path.append('M')\n    \n    # Since the digits are processed in order, the path is built in reverse\n    path = path[::-1]\n    \n    # Convert to 'H'/'M' string\n    print(''.join(path))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 411,
        "completion_token_count": 1213,
        "thoughts_token_count": 8193
    }
}