{
    "start": 1758103519.9209235,
    "end": 1758103653.4580152,
    "start-formatted": "2025-09-17 19:05 KST",
    "end-formatted": "2025-09-17 19:07 KST",
    "gpu": 2,
    "pid": 6,
    "use_openrouter": false,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read it carefully.\n\nThe problem is about Leha choosing two vouchers for his vacation. The conditions are that the sum of their durations is exactly x days, and they don't overlap. Also, we need to find the minimal total cost for such pairs.\n\nHmm. So each voucher has a start day li, end day ri, and cost costi. The duration is ri - li + 1. We need two vouchers i and j (i ≠ j) where the sum of their durations is x, and they don't overlap. The total cost should be as small as possible.\n\nFirst, I need to think about how to approach this.\n\nLet me outline the steps:\n\n1. For each voucher, calculate its duration. Then, for each pair of vouchers, check if the sum of their durations equals x.\n2. For those pairs, check if they are non-overlapping. That is, one ends before the other starts.\n3. Among all such valid pairs, find the one with the minimal total cost.\n\nBut wait, n can be up to 2e5. So iterating over all possible pairs is O(n^2), which is 4e10 operations—way too slow. That won't work. So I need a smarter approach.\n\nSo, what can I do? Hmm.\n\nIdea: Group vouchers by their duration. For a given duration d, collect all vouchers with duration d. Then, for each possible pair of durations (d1, d2) where d1 + d2 = x, I can look within these groups to find compatible vouchers.\n\nYes, that makes sense. Because for each possible pair of durations adding up to x, I can process each voucher of the first duration and each voucher of the second duration, checking if they don't overlap.\n\nBut even that could be time-consuming if not handled properly. So let's think about how to structure it.\n\nFor each duration d, create a list of vouchers with duration d. Then, for each possible d1 and d2 where d1 + d2 = x, iterate through all vouchers of d1 and d2, and for each pair, check if they are non-overlapping.\n\nBut even then, for each pair of d1 and d2, the number of vouchers could be large, leading to O(n^2) in the worst case.\n\nWait, but perhaps for each d, we can sort the vouchers by their end times. Then, for a voucher in d1, we can perform a binary search in the sorted list of d2 to find all vouchers that end before the start of this voucher.\n\nAlternatively, for each voucher, we can find all possible vouchers of another duration that don't overlap with it and add up to x.\n\nAnother approach: For each voucher, determine what duration it needs from another voucher to sum to x. Then, for that required duration, find the voucher that doesn't overlap and has the minimal cost.\n\nSo for voucher A (duration d_a, end e_a), we need a voucher B (duration d_b, where d_a + d_b = x) that starts after e_a or ends before the start of A. Wait no: for A and B to not overlap, either B's end is before A's start, or A's end is before B's start.\n\nWait, no. Two intervals [li, ri] and [lj, rj] are non-overlapping if either ri < lj or rj < li.\n\nSo for each voucher A, we can look for vouchers B in the group of duration d_b = x - d_a. Then, for each such B, check if B ends before A starts or A ends before B starts.\n\nBut again, doing this naively for each A and B is O(n^2), which is too slow.\n\nSo the key is to pre-process the data in a way that allows us to quickly find, for a given A, all B's that are compatible and have the right duration.\n\nHmm.\n\nSo here's a plan:\n\n- Preprocess all vouchers into a dictionary where the key is the duration, and the value is a list of tuples containing (li, ri, costi).\n\n- For each voucher A in the list, compute the required duration d = x - duration(A). If d is negative, skip since it's impossible.\n\n- Then, look up all vouchers in the group d. For each such voucher B, check if A and B are non-overlapping.\n\n- Keep track of the minimal cost when such a pair is found.\n\nBut even this may be O(n * k), where k is the average number of vouchers per duration. Since n is 2e5, and each group could have up to 2e5 elements, this would be O(4e10) in the worst case. That's definitely too slow.\n\nWe need a way to optimize this.\n\nAlternative idea: For each duration d, sort the vouchers by their end times. Then, for",
    "response": "To solve this problem, we need to find two non-overlapping vouchers such that their combined duration equals the total vacation duration and their total cost is minimized. The approach involves efficiently grouping and searching for compatible vouchers using sorting and binary search.\n\n### Approach\n1. **Group Vouchers by Duration**: First, we group all vouchers by their duration. This helps in quickly accessing all vouchers of a specific duration when needed.\n2. **Check for Valid Duration Pairs**: For each voucher, determine the required duration of the second voucher such that their combined duration equals the total vacation duration.\n3. **Sort Vouchers**: For each duration group, sort the vouchers by their end time. This allows us to use binary search to efficiently find non-overlapping vouchers.\n4. **Binary Search for Non-overlapping Vouchers**: For each voucher, use binary search on the sorted list of vouchers of the required duration to find the earliest ending voucher that does not overlap with the current one. Track the minimum cost for valid pairs.\n\n### Solution Code\n```python\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    n, x = map(int, sys.stdin.readline().split())\n    vouchers = []\n    for _ in range(n):\n        l, r, c = map(int, sys.stdin.readline().split())\n        duration = r - l + 1\n        vouchers.append((l, r, c, duration))\n    \n    # Group vouchers by their duration\n    duration_groups = defaultdict(list)\n    for v in vouchers:\n        duration_groups[v[3]].append(v)\n    \n    min_cost = float('inf')\n    \n    # Iterate through each voucher as the first part\n    for i in range(n):\n        l1, r1, c1, d1 = vouchers[i]\n        required_d = x - d1\n        if required_d < 0:\n            continue\n        if required_d not in duration_groups:\n            continue\n        \n        # We need to find vouchers in required_d that don't overlap with this voucher\n        # Sort the vouchers in required_d by their end time\n        group = duration_groups[required_d]\n        group.sort(key=lambda x: x[1])\n        \n        # For each voucher in group, check if it doesn't overlap with current voucher\n        # Binary search to find the latest end <= l1 - 1\n        left = 0\n        right = len(group) - 1\n        best = None\n        while left <= right:\n            mid = (left + right) // 2\n            if group[mid][1] < l1:\n                best = mid\n                left = mid + 1\n            else:\n                right = mid - 1\n        if best is not None:\n            # Check if the found voucher ends before the current starts\n            l2, r2, c2, d2 = group[best]\n            if r2 < l1:\n                total_cost = c1 + c2\n                if total_cost < min_cost:\n                    min_cost = total_cost\n            # Also, check the next voucher in case there are multiple non-overlapping\n            if best + 1 < len(group):\n                l2_next, r2_next, c2_next, d2_next = group[best + 1]\n                if r2_next < l1:\n                    total_cost = c1 + c2_next\n                    if total_cost < min_cost:\n                        min_cost = total_cost\n        # Now check for vouchers that start after the current ends\n        # Find the first voucher where l2 >= r1 + 1\n        left = 0\n        right = len(group) - 1\n        best_after = None\n        while left <= right:\n            mid = (left + right) // 2\n            if group[mid][0] >= r1 + 1:\n                best_after = mid\n                right = mid - 1\n            else:\n                left = mid + 1\n        if best_after is not None:\n            l2, r2, c2, d2 = group[best_after]\n            if l2 > r1:\n                total_cost = c1 + c2\n                if total_cost < min_cost:\n                    min_cost = total_cost\n            # Check the previous voucher in case there are multiple non-overlapping\n            if best_after - 1 >= 0:\n                l2_prev, r2_prev, c2_prev, d2_prev = group[best_after - 1]\n                if l2_prev > r1:\n                    total_cost = c1 + c2_prev\n                    if total_cost < min_cost:\n                        min_cost = total_cost\n    \n    if min_cost != float('inf'):\n        print(min_cost)\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\nThe solution involves grouping vouchers by their duration and using sorting and binary search to efficiently find non-overlapping pairs. By iterating through each voucher and checking against possible pairs in the required duration group, we ensure that we find the minimal cost without overlapping. This approach optimizes the search process, making it feasible to handle the problem constraints efficiently.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import defaultdict\n\ndef main():\n    n, x = map(int, sys.stdin.readline().split())\n    vouchers = []\n    for _ in range(n):\n        l, r, c = map(int, sys.stdin.readline().split())\n        duration = r - l + 1\n        vouchers.append((l, r, c, duration))\n    \n    # Group vouchers by their duration\n    duration_groups = defaultdict(list)\n    for v in vouchers:\n        duration_groups[v[3]].append(v)\n    \n    min_cost = float('inf')\n    \n    # Iterate through each voucher as the first part\n    for i in range(n):\n        l1, r1, c1, d1 = vouchers[i]\n        required_d = x - d1\n        if required_d < 0:\n            continue\n        if required_d not in duration_groups:\n            continue\n        \n        # We need to find vouchers in required_d that don't overlap with this voucher\n        # Sort the vouchers in required_d by their end time\n        group = duration_groups[required_d]\n        group.sort(key=lambda x: x[1])\n        \n        # For each voucher in group, check if it doesn't overlap with current voucher\n        # Binary search to find the latest end <= l1 - 1\n        left = 0\n        right = len(group) - 1\n        best = None\n        while left <= right:\n            mid = (left + right) // 2\n            if group[mid][1] < l1:\n                best = mid\n                left = mid + 1\n            else:\n                right = mid - 1\n        if best is not None:\n            # Check if the found voucher ends before the current starts\n            l2, r2, c2, d2 = group[best]\n            if r2 < l1:\n                total_cost = c1 + c2\n                if total_cost < min_cost:\n                    min_cost = total_cost\n            # Also, check the next voucher in case there are multiple non-overlapping\n            if best + 1 < len(group):\n                l2_next, r2_next, c2_next, d2_next = group[best + 1]\n                if r2_next < l1:\n                    total_cost = c1 + c2_next\n                    if total_cost < min_cost:\n                        min_cost = total_cost\n        # Now check for vouchers that start after the current ends\n        # Find the first voucher where l2 >= r1 + 1\n        left = 0\n        right = len(group) - 1\n        best_after = None\n        while left <= right:\n            mid = (left + right) // 2\n            if group[mid][0] >= r1 + 1:\n                best_after = mid\n                right = mid - 1\n            else:\n                left = mid + 1\n        if best_after is not None:\n            l2, r2, c2, d2 = group[best_after]\n            if l2 > r1:\n                total_cost = c1 + c2\n                if total_cost < min_cost:\n                    min_cost = total_cost\n            # Check the previous voucher in case there are multiple non-overlapping\n            if best_after - 1 >= 0:\n                l2_prev, r2_prev, c2_prev, d2_prev = group[best_after - 1]\n                if l2_prev > r1:\n                    total_cost = c1 + c2_prev\n                    if total_cost < min_cost:\n                        min_cost = total_cost\n    \n    if min_cost != float('inf'):\n        print(min_cost)\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 678,
        "completion_token_count": 1066,
        "thoughts_token_count": 1025
    }
}