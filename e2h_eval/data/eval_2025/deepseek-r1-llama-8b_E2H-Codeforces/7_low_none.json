{
    "start": 1758103653.4584324,
    "end": 1758103789.0475972,
    "start-formatted": "2025-09-17 19:07 KST",
    "end-formatted": "2025-09-17 19:09 KST",
    "gpu": 2,
    "pid": 7,
    "use_openrouter": false,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read it carefully.\n\nThe problem is about determining whether a snowflake graph with n vertices exists. The snowflake graph is defined in a specific way. Let me try to understand the structure.\n\nThe snowflake graph starts with one vertex. Then, the initial vertex is connected to k new vertices, where k>1. So after this step, there are 1 + k = k+1 vertices. Then, each vertex that has only one edge (so those k new ones) must each connect to k more new vertices. This last step must be done at least once. So the minimal case is when each of those k nodes adds another k leaves, making a total of 1 +k +k^2.\n\nWait, let's think: initial node has degree k. Each of the k nodes then adds k children. So each of those k nodes will have degree k+1 (since they're connected to the initial node and their own k children). But wait, no—because each of those k nodes is only connected to the initial node before adding their children. So adding k children gives them a degree of k+1, but for the snowflake structure, perhaps each of these can't add any more children? Or do we continue expanding?\n\nNo, the process is that each vertex with exactly one edge (so the initial node's children, and any subsequent level's children as well) must add k new vertices. And this step is done at least once. So the process is recursive.\n\nSo the snowflake graph is built in layers. The first layer is the center (1 node), the second layer has k nodes, the third layer has k^2 nodes, and so on. But wait, how many layers are there?\n\nWait, the initial step adds k nodes—so the tree has depth 2. Then, each of those k nodes must add k children, which makes depth 3. But the problem says that the step must be done at least once. So the minimal structure is when the process is done once beyond the initial step. So the minimal structure is the initial node plus two layers: center, then k nodes, then each of those has k children, leading to 1 + k + k² nodes.\n\nSo the total number of nodes is 1 + k*(m), where m is the number of layers beyond the initial. Wait, maybe not exactly. Let's model the number of nodes at each step.\n\nLet me think recursively. Let f(m) be the total number of nodes after m steps. The initial step is 1 node. Then, each step adds a layer of k times the previous layer. Wait, maybe it's better to model it as each expansion step adds a new layer. For example:\n\n- After step 0: 1 node.\n- Step 1: add k children to the initial node. Total nodes: 1 +k = k+1.\n- Step 2: each of the k nodes adds k children. So total added in this step: k*k =k². Total nodes now: 1 +k +k² = (k+1)^2 -1? No, wait 1 +k +k² = (k³ -1)/(k-1) when m=3 steps? Maybe not. Alternatively, perhaps each step i adds k^i nodes, except the initial step.\n\nWait, perhaps the total number of nodes is a sum of a geometric series. Let's see:\n\nEach time, we add a layer. The initial node is layer 0. Layer 1 has k nodes. Layer 2 has k² nodes. Layer 3 has k³ nodes, etc. But wait, the problem requires that the process is done at least once beyond the initial step. So the minimal structure is layer 0 (1 node) + layer 1 (k nodes) + layer 2 (k² nodes). So the total is 1 +k +k².\n\nBut the problem allows for more layers. So the total number of nodes is 1 +k*(m) where m is the sum from i=1 to d of k^i, but wait no. Let me think again.\n\nWait, the process is that each node with degree 1 (i.e., each node in the current outermost layer) adds k children. So each step adds a new layer. So the number of nodes is 1 + k + k² + ... +k^d, where d is the number of layers beyond the initial. Wait, but no, because the initial step is just adding k nodes (layer 1), then each node in layer 1 adds k nodes (layer 2), each node in layer 2 adds k nodes (layer 3), and so on. So the total number of nodes is 1 + k*(1 + k +k² + ... +k^{m}) ), where m is the number of expansion steps",
    "response": "To solve this problem, we need to determine if a snowflake graph with `n` vertices can exist. The snowflake graph is defined in a specific way, starting with one central node and expanding outward in layers.\n\n### Approach\n1. **Understanding the Snowflake Structure**: The snowflake graph starts with one central node. Each subsequent layer adds `k` new nodes per existing node in the previous layer. This process must be done at least once beyond the initial step.\n2. **Geometric Series Sum**: The total number of nodes in a snowflake graph after `m` expansion steps (including the initial step) can be represented as a sum of a geometric series. Specifically, it is `1 + k * (k^m - 1) / (k - 1)`.\n3. **Check for Valid `n`**: For each test case, we check if `n` can be expressed in the form of the geometric series sum mentioned above for some integer `m` greater than or equal to 1 and `k` greater than 1.\n\n### Solution Code\n```python\nimport sys\n\ndef is_snowflake(n):\n    if n < 3:\n        return False\n    # We need to find integers k >1 and m >=1 such that n = 1 + k*(k^m -1)/(k-1)\n    # Let's try possible m values. Since k >=2, m can't be too large.\n    max_m = 60  # since 2^60 is way larger than 1e18\n    for m in range(1, max_m+1):\n        # Solve for k: n = 1 + k * (k^m -1)/(k-1)\n        # Let s = k^{m}\n        # Then n-1 = k*(s-1)/(k-1)\n        # Let's denote t = k-1, so k = t+1\n        # So n-1 = (t+1)*(s-1)/t, where s = (t+1)^m\n        # Rearranged: (n-1)*t = (t+1)*((t+1)^m -1)\n        # This seems complex, but perhaps we can iterate possible t (k-1)\n        # Try t from 1 up to some limit, and see if the equation holds.\n        # But t can't be too large, since k has to be at least 2.\n        # Let's compute the maximum possible t.\n        # For a given m, solve for t: (n-1) = (t+1)*( (t+1)^m -1 ) / t\n        # We can approximate (t+1)^m ≈ t^m for small t, so (n-1) ≈ (t+1)*(t^m) / t = (t+1) * t^{m-1}\n        # So t^{m} <= (n-1)*t/(t+1) <= (n-1)*t\n        # Which implies t <= (n-1)^{1/(m-1)}\n        # So for each m, t_max is about min( (n-1)^(1/(m-1)), something else)\n        # Let's try t from 1 to t_max, and see if any satisfies the equation.\n        # But for m up to 60, even t=1e6 may be too much, but since t is small for large m.\n        # Alternatively, for each m, compute possible t and check.\n        low = 1\n        high = 1\n        # Find an upper bound for t\n        while True:\n            if high > (n-1)**(1/(m)) * 2:\n                break\n            if (high + 1) > (n-1)**(1/(m)):\n                break\n            high *= 2\n        for t in range(1, high+1):\n            if t == 0:\n                continue\n            numerator = (t+1) * ((t+1)**m - 1)\n            denominator = t\n            if numerator % denominator != 0:\n                continue\n            val = numerator // denominator\n            if val == n-1:\n                return True\n    return False\n\nt = int(sys.stdin.readline())\nfor _ in range(t):\n    n = int(sys.stdin.readline().strip())\n    if n == 1:\n        print(\"NO\")\n        continue\n    if is_snowflake(n):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n```\n\n### Explanation\nThe solution involves checking if a given number `n` can be represented as the sum of a geometric series corresponding to the structure of a snowflake graph. For each test case, we iterate over possible values of `m` (number of expansion steps) and `k` (nodes added per step) to determine if such a structure exists. If it does, we output \"YES\"; otherwise, we output \"NO\".",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef is_snowflake(n):\n    if n < 3:\n        return False\n    # We need to find integers k >1 and m >=1 such that n = 1 + k*(k^m -1)/(k-1)\n    # Let's try possible m values. Since k >=2, m can't be too large.\n    max_m = 60  # since 2^60 is way larger than 1e18\n    for m in range(1, max_m+1):\n        # Solve for k: n = 1 + k * (k^m -1)/(k-1)\n        # Let s = k^{m}\n        # Then n-1 = k*(s-1)/(k-1)\n        # Let's denote t = k-1, so k = t+1\n        # So n-1 = (t+1)*(s-1)/t, where s = (t+1)^m\n        # Rearranged: (n-1)*t = (t+1)*((t+1)^m -1)\n        # This seems complex, but perhaps we can iterate possible t (k-1)\n        # Try t from 1 up to some limit, and see if the equation holds.\n        # But t can't be too large, since k has to be at least 2.\n        # Let's compute the maximum possible t.\n        # For a given m, solve for t: (n-1) = (t+1)*( (t+1)^m -1 ) / t\n        # We can approximate (t+1)^m ≈ t^m for small t, so (n-1) ≈ (t+1)*(t^m) / t = (t+1) * t^{m-1}\n        # So t^{m} <= (n-1)*t/(t+1) <= (n-1)*t\n        # Which implies t <= (n-1)^{1/(m-1)}\n        # So for each m, t_max is about min( (n-1)^(1/(m-1)), something else)\n        # Let's try t from 1 to t_max, and see if any satisfies the equation.\n        # But for m up to 60, even t=1e6 may be too much, but since t is small for large m.\n        # Alternatively, for each m, compute possible t and check.\n        low = 1\n        high = 1\n        # Find an upper bound for t\n        while True:\n            if high > (n-1)**(1/(m)) * 2:\n                break\n            if (high + 1) > (n-1)**(1/(m)):\n                break\n            high *= 2\n        for t in range(1, high+1):\n            if t == 0:\n                continue\n            numerator = (t+1) * ((t+1)**m - 1)\n            denominator = t\n            if numerator % denominator != 0:\n                continue\n            val = numerator // denominator\n            if val == n-1:\n                return True\n    return False\n\nt = int(sys.stdin.readline())\nfor _ in range(t):\n    n = int(sys.stdin.readline().strip())\n    if n == 1:\n        print(\"NO\")\n        continue\n    if is_snowflake(n):\n        print(\"YES\")\n    else:\n        print(\"NO\")",
    "score": 0,
    "metadata": {
        "prompt_token_count": 526,
        "completion_token_count": 1051,
        "thoughts_token_count": 1025
    }
}