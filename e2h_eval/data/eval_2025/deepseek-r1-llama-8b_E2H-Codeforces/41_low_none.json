{
    "start": 1758278110.2559905,
    "end": 1758278886.4618785,
    "start-formatted": "2025-09-19 19:35 KST",
    "end-formatted": "2025-09-19 19:48 KST",
    "gpu": 2,
    "pid": 41,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Zoning Restrictions Again\n\nYou are planning to build housing on a street. There are $$$n$$$ spots available on the street on which you can build a house. The spots are labeled from $$$1$$$ to $$$n$$$ from left to right. In each spot, you can build a house with an integer height between $$$0$$$ and $$$h$$$.In each spot, if a house has height $$$a$$$, you will gain $$$a^2$$$ dollars from it.The city has $$$m$$$ zoning restrictions. The $$$i$$$-th restriction says that the tallest house from spots $$$l_i$$$ to $$$r_i$$$ (inclusive) must be at most $$$x_i$$$.You would like to build houses to maximize your profit. Determine the maximum profit possible.\n\n## Input\nThe first line contains three integers $$$n$$$, $$$h$$$, and $$$m$$$ ($$$1 \\leq n,h,m \\leq 50$$$) — the number of spots, the maximum height, and the number of restrictions.Each of the next $$$m$$$ lines contains three integers $$$l_i$$$, $$$r_i$$$, and $$$x_i$$$ ($$$1 \\leq l_i \\leq r_i \\leq n$$$, $$$0 \\leq x_i \\leq h$$$) — left and right limits (inclusive) of the $$$i$$$-th restriction and the maximum possible height in that range.\n\n## Output\nPrint a single integer, the maximum profit you can make.\n\n## Example\n### Input\n['3 3 3\\n1 1 1\\n2 2 3\\n3 3 2', '4 10 2\\n2 3 8\\n3 4 7']\n\n### Output\n['14', '262']\n\n## Note\nIn the first example, there are $$$3$$$ houses, the maximum height of a house is $$$3$$$, and there are $$$3$$$ restrictions. The first restriction says the tallest house between $$$1$$$ and $$$1$$$ must be at most $$$1$$$. The second restriction says the tallest house between $$$2$$$ and $$$2$$$ must be at most $$$3$$$. The third restriction says the tallest house between $$$3$$$ and $$$3$$$ must be at most $$$2$$$.In this case, it is optimal to build houses with heights $$$[1, 3, 2]$$$. This fits within all the restrictions. The total profit in this case is $$$1^2 + 3^2 + 2^2 = 14$$$.In the second example, there are $$$4$$$ houses, the maximum height of a house is $$$10$$$, and there are $$$2$$$ restrictions. The first restriction says the tallest house from $$$2$$$ to $$$3$$$ must be at most $$$8$$$. The second restriction says the tallest house from $$$3$$$ to $$$4$$$ must be at most $$$7$$$.In this case, it's optimal to build houses with heights $$$[10, 8, 7, 7]$$$. We get a profit of $$$10^2+8^2+7^2+7^2 = 262$$$. Note that there are two restrictions on house $$$3$$$ and both of them must be satisfied. Also, note that even though there isn't any explicit restrictions on house $$$1$$$, we must still limit its height to be at most $$$10$$$ ($$$h=10$$$).\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read it carefully.\n\nThe problem is about building houses on a street with certain restrictions and maximizing the profit. Each house contributes a squared value of its height to the total profit. But there are m restrictions that limit the maximum height in specific ranges.\n\nHmm, so the goal is to assign heights to each spot such that all restrictions are satisfied, and the sum of squares is maximized.\n\nLet me think about how to model this. It seems like a dynamic programming problem because for each spot, the choice of height depends on the previous choices, especially considering overlapping restrictions.\n\nWait, but n and m are up to 50, which isn't too bad. So maybe a DP approach where the state represents the current position and some information about the constraints that apply to future spots.\n\nAlternatively, perhaps we can model it by considering all the constraints as intervals and ensuring that for each interval, the maximum height in that interval doesn't exceed the given x_i. So for each spot, the height can't be higher than any of the constraints that include it, plus the global h.\n\nWait, no. The global h is the maximum allowed for each spot, but each spot's height must satisfy all the constraints that cover it. So for each spot i, the maximum possible height it can have is the minimum of all x_j where l_j ≤ i ≤ r_j, and also h.\n\nSo first, for each spot i, compute the maximum possible height it can have without violating any constraints. But wait, that's not necessarily true because the constraints are about the maximum in their intervals. For example, if a spot is covered by multiple constraints, the height must be at most the minimum of all those constraints' x_i, but also cannot exceed h.\n\nWait, no. Because each constraint is an upper bound on the maximum in its interval. So for a particular spot i, it's part of several intervals. Each such interval has an x_i restriction. So the spot's height must be <= all those x_i's, right? Because for each of those intervals, the maximum (which includes this spot) must be <= x_i. So the spot's height can't exceed any of the x_i's from the constraints covering it, nor can it exceed h.\n\nSo for spot i, the maximum possible height is min( h, the minimum x_j among all constraints that include i ). If there are no constraints covering i, then the max is h.\n\nWait, no. Wait, the constraints are that for each i, the height can't be higher than the minimum of all x_j for constraints that include i, and also can't exceed h. Because, for example, if a spot is only covered by one constraint x=3, then its height can be up to 3. If it's covered by two constraints, say x=2 and x=3, then the height can be up to 2, because the maximum of that spot can't exceed both constraints.\n\nSo yes, for each spot i, the maximum allowed height is the minimum between h and the minimum x_j across all constraints that include i.\n\nBut wait, that's just the constraints. However, when assigning heights, the maximum in each interval must be <= x_i. So even if a spot is not directly limited by a constraint, other spots in the same interval might have a lower maximum.\n\nNo, wait. Suppose a spot is not covered by any constraint. Then its maximum height is h, unless some other spot in the same interval is constrained.\n\nWait, no. Each constraint is about the maximum in its interval. So for a spot i, if it's not covered by any constraint, then the only limitation is the global h. So its height can be up to h.\n\nBut if a spot is covered by multiple constraints, then the maximum height is the minimum of all x_j's for those constraints, and also h.\n\nSo for each spot, the maximum possible height is the minimum of h and the minimum of all x_j's for constraints that include i. Because each x_j is an upper bound on the maximum of their interval, which includes i. So the height at i can't be higher than any of those x_j's.\n\nSo the first step is to precompute for each spot i the maximum allowed height as min_h = min(h, min(x_j for all j where i is in [l_j, r_j])).\n\nWait, but for a spot i that is not covered by any constraint, min_h would be h.\n\nYes.\n\nOnce we have this min_h for each spot, the next problem is to assign heights to each spot such that:\n\n1. For each spot i, height a_i <= min_h[i].\n\n2. For each constraint j, the maximum a_i in [l_j, r_j] is <= x_j.\n\nBecause the constraints may overlap, it's possible that the maximum in a certain interval is determined by a spot within that interval that is constrained by multiple x's",
    "response": "To solve this problem, we need to maximize the profit from building houses on a street while adhering to zoning restrictions. Each house contributes to the profit based on its height squared, and each restriction limits the maximum height in specific ranges.\n\n### Approach\n1. **Understand Constraints**: Each restriction specifies a range `[l_i, r_i]` and a maximum height `x_i` within that range. The height of any house in this range must not exceed `x_i`.\n2. **Determine Maximum Height for Each Spot**: For each spot, compute the maximum allowable height considering all applicable constraints. This is the minimum of `h` (the global maximum height) and the smallest `x_i` from all constraints covering that spot.\n3. **Dynamic Programming**: Use dynamic programming to keep track of the maximum profit achievable up to each spot, considering the maximum height allowed by the constraints.\n\n### Solution Code\n```python\nn, h, m = map(int, input().split())\nconstraints = []\nfor _ in range(m):\n    l, r, x = map(int, input().split())\n    constraints.append((l-1, r-1, x))  # converting to 0-based\n\nmax_heights = [h] * n\nfor i in range(n):\n    min_x = h\n    for (l, r, x) in constraints:\n        if l <= i <= r:\n            if x < min_x:\n                min_x = x\n    max_heights[i] = min(min_x, h)\n\n# Now, model the problem as selecting a_i for each position i, where a_i <= max_heights[i], and for each constraint (l, r, x), the maximum a_i in [l, r] is <= x.\n\n# To model this, we can think of it as intervals with overlapping constraints.\n\n# Another approach is to precompute for each position the earliest constraint that affects it, but perhaps a better way is to model it using DP.\n\ndp = [[0]*(n+1) for _ in range(n)]\nfor i in range(n):\n    for j in range(i+1):\n        dp[i][j] = 0\n\nfor i in range(n):\n    for j in range(i+1, n+1):\n        current_max = max_heights[i]\n        if i == j-1:\n            # Only the current position\n            max_val = 0\n            for (l, r, x) in constraints:\n                if l <= i <= r:\n                    if x < current_max:\n                        current_max = x\n            dp[i][j] = max(dp[i][j-1], (current_max)**2 + dp[i-1][j-1])\n        else:\n            # Find the best possible a_i such that all constraints are satisfied\n            # But this might be complicated, so perhaps an alternative approach is needed.\n            pass\n\n# Wait, maybe a better approach is to model the constraints as intervals and ensure that for each interval [l, r], the maximum a_i in that interval is <= x.\n\n# So perhaps a better way is to use a segment tree or interval-based DP.\n\n# Alternatively, since n is small (<=50), we can model it using a DP state where for each position i, we track the maximum a_i chosen, and for each constraint, ensure that the maximum in their intervals is <= x.\n\n# Let me think about the DP state.\n\n# Let's define dp[i][k] as the maximum profit achievable up to position i, where the height at i is k.\n\n# Then, for each i, we can choose a height a_i up to max_heights[i], and for each constraint that ends at i, ensure that the maximum in that constraint's range is <= x.\n\n# However, tracking all possible maximums for all constraints is tricky. So perhaps another approach is needed.\n\n# Another idea: for each position, the maximum height is constrained by the earliest ending constraint that includes it. So we can process the constraints in a way that updates the maximum allowed height for each position.\n\n# Wait, but the initial approach I took computes the maximum allowed height for each position, which is the minimum of h and the minimum x of all constraints covering it.\n\n# So, once we have this max_heights array, the problem reduces to choosing a_i <= max_heights[i] for each i, and ensuring that for each constraint (l, r, x), the maximum a_i in [l, r] is <= x.\n\n# This seems similar to a problem where we have multiple interval constraints, and we need to choose values in such a way that all constraints are satisfied.\n\n# Since n is small, perhaps a brute-force approach with memoization could work, but even better would be a DP approach.\n\n# Let me think about the DP approach.\n\n# We can model the DP as follows: dp[i][k] represents the maximum profit up to position i, where the height at position i is exactly k.\n\n# For each position i, we can try all possible heights from 0 to max_heights[i]. For each possible height k, we look back to the previous positions and find the best possible configuration.\n\n# Additionally, for each constraint that ends at i, we need to ensure that the maximum height in that constraint's range is <= x.\n\n# So, for each constraint (l, r, x), when processing position i, if r = i, then we need to ensure that the maximum height in [l, i] is <= x.\n\n# How can we track this? Well, for each position i, after choosing a_i, we can check all constraints that end at i. For each such constraint, the maximum of a_l ... a_r must be <= x.\n\n# So, for the DP state, we need to track, for each position i, the maximum height in all constraints ending at i.\n\n# This seems computationally intensive, but given the constraints (n=50, h=50), it might be manageable.\n\n# So, let's proceed.\n\n# The DP state can be defined as:\n\n# dp[i][a_i] = maximum profit up to position i, with a_i being the height at position i.\n\n# But since a_i can vary from 0 to max_heights[i], and n is small, this is feasible.\n\n# Initialization: dp[0][0] = 0^2 = 0 (assuming 0-based indexing).\n\n# For each position i from 0 to n-1:\n\n#   For each possible a_i in 0..max_heights[i]:\n\n#       For each possible a_{i-1} in 0..max_heights[i-1]:\n\n#           If i == 0:\n\n#               if a_0 > max_heights[0]: skip\n\n#               else: dp[0][a_0] = a_0^2\n\n#           Else:\n\n#               Take the maximum between choosing a_i and the best possible from i-1.\n\n#               But also, for all constraints ending at i, ensure that the maximum in their ranges is <= x.\n\n# Wait, but how do we handle the constraints? Because each constraint may span multiple positions.\n\n# Perhaps, for each constraint, we need to ensure that within its range, the maximum a_i is <= x.\n\n# So, when processing a position i, for all constraints ending at i, we need to check if the maximum a_j in [l, i] is <= x.\n\n# Therefore, during the DP transition, after setting a_i, we need to verify all constraints that end at i.\n\n# So, the DP state needs to include information about the maximum in all intervals ending at the current position.\n\n# But this seems too complex. An alternative approach is to precompute for each position i the latest constraint ending at i, and enforce that the maximum up to i satisfies that constraint.\n\n# Hmm, perhaps a better way is to model the problem differently.\n\n# Another Idea: For each position, determine the tightest constraint (smallest x) that applies to it. The height at each position cannot exceed this value. Then, the problem becomes selecting heights that satisfy all these per-position constraints and also satisfy the interval constraints.\n\n# Wait, but the interval constraints may overlap, so the per-position constraints are derived from the minimum of all applicable x's. However, this alone might not suffice because the maximum in an interval could be determined by a position outside the per-position constraints.\n\n# For example, suppose we have two intervals: [1, 2] with x=3 and [2, 3] with x=2. The per-position constraints would be 3 for position 1, 2 for position 2, and 3 for position 3. But the interval [1, 2] requires that the maximum of positions 1 and 2 is <=3, which is already satisfied. The interval [2,3] requires that the maximum of positions 2 and 3 is <=2, which means position 3 can't exceed 2, so the per-position constraint for 3 is updated to 2.\n\n# So, perhaps the per-position constraints are sufficient to capture all necessary constraints, but I'm not entirely sure. It depends on whether all constraints are covered by the per-position constraints.\n\n# Wait, no. Consider a case where there are two overlapping constraints: one on [1,3] with x=4, and another on [2,3] with x=3. The per-position constraints for positions 2 and 3 would be min(4,3)=3, but the first constraint requires that the maximum in [1,3] is <=4. However, the second constraint requires that the maximum in [2,3] is <=3. So the per-position constraints are correct.\n\n# Another example: Suppose a constraint [1,3] with x=3 and another [2,3] with x=2. The per-position constraints for 1 is 3, 2 is 2, and 3 is 2. But the maximum in [1,3] is 3, which is allowed because the first constraint allows it. However, the second constraint requires that the maximum in [2,3] is <=2, so position 2 must be <=2 and position 3 must be <=2.\n\n# So in this case, the per-position constraints correctly reflect the required maximums.\n\n# Therefore, perhaps the per-position constraints are sufficient, and the problem can be reduced to choosing a_i <= max_heights[i] for each i, ensuring that for every constraint [l, r, x], the maximum a_i in [l, r] is <=x.\n\n# Now, how do we ensure this?\n\n# One approach is to model the problem as a graph where each state represents the current position and the maximum height chosen so far for the relevant intervals. However, this seems complex.\n\n# Another approach is to realize that for each constraint, the maximum a_i in [l, r] must be <=x. So, for each constraint, the maximum height in that interval is the maximum of all a_i in [l, r], which must be <=x.\n\n# Thus, the problem can be viewed as a series of constraints on the maximum values within certain intervals. This is similar to the problem of scheduling jobs with interval constraints.\n\n# Given the small constraints (n=50, m=50), a dynamic programming approach where we track the maximum height in the current interval is feasible.\n\n# Let's try to model the DP state as follows:\n\n# dp[i][k] = maximum profit up to position i, where the maximum height in the interval [i, r] for some constraints ending at i is k.\n\n# But this might not capture all constraints. Alternatively, we can model the DP state as the current position and the maximum height chosen so far, ensuring that all constraints are satisfied up to that point.\n\n# Another Idea: For each position i, after choosing a_i, we need to ensure that for all constraints ending at i, the maximum a_j in [l, i] is <=x. So, during the DP transition, for each constraint ending at i, we need to check if the maximum in [l, i] is acceptable.\n\n# However, this can be computationally expensive as we need to check all constraints ending at each i.\n\n# Given the small constraints, perhaps it's manageable.\n\n# Let's proceed with this approach.\n\n# Initialize the DP table.\n\n# dp[i][a_i] = maximum profit up to position i, where a_i is the height chosen for position i.\n\n# For each position i from 0 to n-1:\n\n#   For each possible a_i from 0 to max_heights[i]:\n\n#       For each possible a_prev from 0 to max_heights[i-1]:\n\n#           new_profit = dp[i-1][a_prev] + a_i^2\n\n#           Check all constraints that end at i:\n\n#               For each such constraint (l, i, x):\n\n#                   current_max = max(a[l ... i])\n\n#                   if current_max > x: this choice is invalid\n\n#           If all constraints are satisfied, update dp[i][a_i] = max(new_profit, current value)\n\n# But checking the maximum in each interval for each transition is O(n^2) for each i, leading to O(n^3 * m) time, which is acceptable for n=50.\n\n# So, let's implement this.\n\n# Now, code-wise:\n\nInitialize the DP table as a list of dictionaries or a 2D array.\n\nBut since n is small, a 2D array is manageable.\n\nSo, let's create a 2D array `dp` where `dp[i][k]` represents the maximum profit up to position `i` with height `k` at position `i`.\n\nWe'll initialize `dp[0][k]` for all valid `k` as `k^2`.\n\nThen, for each position `i` from 1 to n-1:\n\n   For each possible height `k` at `i` (from 0 to max_heights[i]):\n\n       For each possible previous height `prev_k` at `i-1` (from 0 to max_heights[i-1]):\n\n           if choosing `k` at `i` doesn't violate any constraints ending at `i`, then:\n\n               new_profit = dp[i-1][prev_k] + k^2\n\n               if new_profit > dp[i][k], update dp[i][k]\n\nAdditionally, for each constraint ending at `i`, we need to check that the maximum in that interval is <=x.\n\nWait, but how do we efficiently check the maximum in each interval? For each constraint ending at `i`, which is (l, i, x), we need to ensure that the maximum a_j in [l, i] is <=x.\n\nSo, during the DP transition, for each possible a_i, we need to check all constraints ending at `i` and see if any of them would be violated by the current a_i and the previous choices.\n\nBut how can we track the maximum in [l, i]? It's the maximum of a_l, a_{l+1}, ..., a_i.\n\nThis suggests that for each constraint ending at `i`, we need to know the maximum a_j in [l, i], which depends on the choices made for positions l to i.\n\nThus, the DP state must somehow track, for each interval ending at `i`, the maximum a_j in that interval.\n\nThis complicates the state representation.\n\nAn alternative approach is to realize that for each constraint ending at `i`, the maximum in [l, i] is determined by the maximum of a_l, a_{l+1}, ..., a_i.\n\nThus, for each constraint ending at `i`, the maximum can be computed as the maximum of the current a_i and the maximum from the previous step in the same constraint.\n\nWait, perhaps we can model the DP state as including, for each interval ending at `i`, the current maximum for that interval.\n\nBut this seems too memory-intensive.\n\nGiven the time constraints, perhaps a better approach is to precompute for each position `i` the earliest constraint ending at `i`, and enforce that the maximum in that constraint is <=x.\n\nAlternatively, perhaps we can process the constraints in a way that ensures that for each interval [l, r], the maximum a_i in that interval is <=x.\n\nBut I'm not seeing a clear path forward, so perhaps it's better to refer to the initial approach and see if it can be implemented.\n\nIn the initial approach, the per-position constraints are computed, but the interval constraints may not be fully captured. However, in the sample inputs, this approach works.\n\nBut wait, in the sample input 2:\n\nThe constraints are:\n\n2 3 8 → affects positions 1 and 2 (0-based)\n3 4 7 → affects positions 3 and 4 (0-based)\n\nThe per-position constraints would be:\n\npos 0: only constraint is 10 (since no constraints cover it)\npos 1: min(10, 8) =8\npos 2: min(10, 8,7) =7\npos 3: min(10,7) =7\npos4: min(10,7) =7\n\nBut in the optimal solution, pos 0 is 10, pos1 is 8, pos2 is7, pos3 is7, pos4 is7.\n\nWhich fits all constraints.\n\nSo, the per-position constraints seem sufficient here.\n\nAnother test case: suppose we have a single constraint [1,3] with x=3, and another [2,3] with x=2.\n\nPer-position constraints would be:\n\npos0: 3 (since [1,3] covers it)\npos1: min(3,2)=2\npos2: min(3,2)=2\n\nBut the first constraint [1,3] requires that the maximum of pos0, pos1, pos2 is <=3, which is satisfied if pos0 is 3, pos1 and pos2 are 2.\n\nThe second constraint [2,3] requires that the maximum of pos1 and pos2 is <=2, which is satisfied.\n\nSo, the per-position constraints correctly capture all necessary constraints.\n\nThus, perhaps the per-position constraints are sufficient, and the problem can be reduced to assigning a_i <= max_heights[i] for each i, and then the sum of squares is maximized.\n\nBut wait, what if a constraint is [1,3] with x=3, and another [2,3] with x=3. Then the per-position constraints for pos1 and pos2 would be 3.\n\nBut the maximum in [1,3] is 3, which is allowed, and the maximum in [2,3] is 3, which is allowed.\n\nBut what if there's another constraint [2,3] with x=2? Then pos1 and pos2 would have max_heights of 2.\n\nSo, the per-position approach seems to capture all necessary constraints.\n\nTherefore, the problem can be simplified to choosing a_i as high as possible (to maximize the sum of squares) without exceeding the per-position maximums.\n\nThus, the solution is to assign each spot the maximum possible height based on its per-position maximum, ensuring that all interval constraints are satisfied.\n\nWait, but how do we ensure that the interval constraints are satisfied? Because the per-position approach captures the minimal of all constraints, but the maximum in an interval may still be higher than x if other spots in the interval have higher a_i.\n\nWait, no. Because the per-position maximum is the minimal of all x's for constraints covering that spot. So for any interval [l, r], the maximum a_i in that interval cannot exceed the minimal x among all constraints covering that interval.\n\nWait, no. Suppose a spot is covered by multiple constraints. The per-position maximum is the minimal x across all constraints covering it. So for any spot in [l, r], a_i cannot exceed the minimal x of all constraints covering it. Therefore, the maximum a_i in [l, r] is at most the minimal x of all constraints covering any spot in [l, r].\n\nBut the constraint for [l, r] is that the maximum must be <=x. So, if the minimal x across all constraints covering [l, r] is <=x, then it's satisfied.\n\nWait, perhaps not. Because the constraints are separate; each has its own x. So, for a particular interval [l, r], the maximum a_i in that interval must be <=x for that specific constraint.\n\nBut the per-position approach ensures that for each spot, a_i is <= the minimal x of all constraints covering it. So, for any spot in [l, r], a_i is <=x of all constraints that include it, including the specific [l, r] constraint. Thus, the maximum a_i in [l, r] will be <=x, because a_i for each spot is <= the x of the [l, r] constraint (since it's part of that constraint's coverage).\n\nWait, no. Because a spot could be covered by multiple constraints, including the [l, r] one. So, the per-position maximum for each spot in [l, r] is <=x, because the [l, r] constraint contributes x to their per-position maximum.\n\nYes! Because for any spot in [l, r], the per-position maximum is the minimal of h and all x's from constraints covering it, including the [l, r] constraint. So, for the [l, r] constraint, the maximum a_i in [l, r] is <=x.\n\nThus, the per-position constraints ensure that all interval constraints are satisfied.\n\nTherefore, the problem reduces to choosing a_i as high as possible (up to max_heights[i]) to maximize the sum of squares.\n\nSo, the optimal solution is to set each a_i to its max_heights[i], as this maximizes each term a_i^2.\n\nWait, but what if a_i is set to max_heights[i], but some constraints are still violated?\n\nNo, because the per-position max_heights[i] is the minimal of h and all x's from constraints covering i. So, setting a_i to max_heights[i] ensures that all constraints are satisfied.\n\nThus, the maximum profit is simply the sum of squares of max_heights[i] for each i.\n\nSo, the solution is straightforward:\n\n1. For each spot i, compute the maximum allowed height as the minimum of h and the minimum x from all constraints covering i.\n2. Sum the squares of these heights.\n\nLet me test this with the sample inputs.\n\nSample Input 1:\n\n3 3 3\n1 1 1 → covers spot 0\n2 2 3 → covers spot 1\n3 3 2 → covers spot 2\n\nCompute max_heights:\n\nspot 0: min(3, 1) = 1\nspot 1: min(3, 3) =3\nspot 2: min(3, 2) =2\n\nSum of squares: 1 +9 +4=14 → matches sample.\n\nSample Input 2:\n\n4 10 2\n2 3 8 → covers spots 1,2\n3 4 7 → covers spots 3,4\n\nCompute max_heights:\n\nspot 0: 10 (no constraints)\nspot 1: min(10,8)=8\nspot 2: min(10,8,7)=7\nspot 3: min(10,7)=7\nspot 4: min(10,7)=7\n\nSum of squares: 100 +64 +49 +49=262 → matches sample.\n\nThus, the solution is to compute the max_heights array as described and sum the squares.\n\nSo, the code can be written as follows:\n\nRead n, h, m.\n\nFor each spot i (0-based), compute max_heights[i] as the minimum of h and the minimum x from all constraints that include i.\n\nSum the squares of these max_heights.\n\nSo, the code is straightforward.\n\nNow, implementing this in Python:\n\nRead n, h, m.\n\nCreate an array constraints, storing tuples (l, r, x), converted to 0-based indices.\n\nFor each i in 0..n-1:\n\n   min_x = h\n\n   for each constraint in constraints:\n\n       if l <= i <= r:\n\n           if x < min_x:\n\n               min_x = x\n\n   max_heights[i] = min(min_x, h)\n\nCompute the sum of squares.\n\nPrint the sum.\n\nWait, but wait: in the constraints, l and r are 1-based. So when reading, we need to subtract 1 to make them 0-based.\n\nYes.\n\nSo, the code should be:\n\nn, h, m = map(int, input().split())\n\nconstraints = []\nfor _ in range(m):\n    l, r, x = map(int, input().split())\n    constraints.append( (l-1, r-1, x) )\n\nmax_heights = [h] * n\n\nfor i in range(n):\n    min_x = h\n    for (l, r, x) in constraints:\n        if l <= i <= r:\n            if x < min_x:\n                min_x = x\n    max_heights[i] = min(min_x, h)\n\ntotal = sum( a*a for a in max_heights )\n\nprint(total)\n\nWait, but in the first sample input, the code gives 14 as expected.\n\nIn the second sample, it gives 100 +64 +49 +49= 262.\n\nYes.\n\nThus, this code should solve the problem correctly.\n\nI think this approach is correct, as it satisfies all constraints and maximizes the sum of squares.\n",
    "ground_truth": "N/A",
    "extracted_answer": "n, h, m = map(int, input().split())\nconstraints = []\nfor _ in range(m):\n    l, r, x = map(int, input().split())\n    constraints.append((l-1, r-1, x))  # converting to 0-based\n\nmax_heights = [h] * n\nfor i in range(n):\n    min_x = h\n    for (l, r, x) in constraints:\n        if l <= i <= r:\n            if x < min_x:\n                min_x = x\n    max_heights[i] = min(min_x, h)\n\n# Now, model the problem as selecting a_i for each position i, where a_i <= max_heights[i], and for each constraint (l, r, x), the maximum a_i in [l, r] is <= x.\n\n# To model this, we can think of it as intervals with overlapping constraints.\n\n# Another approach is to precompute for each position the earliest constraint that affects it, but perhaps a better way is to model it using DP.\n\ndp = [[0]*(n+1) for _ in range(n)]\nfor i in range(n):\n    for j in range(i+1):\n        dp[i][j] = 0\n\nfor i in range(n):\n    for j in range(i+1, n+1):\n        current_max = max_heights[i]\n        if i == j-1:\n            # Only the current position\n            max_val = 0\n            for (l, r, x) in constraints:\n                if l <= i <= r:\n                    if x < current_max:\n                        current_max = x\n            dp[i][j] = max(dp[i][j-1], (current_max)**2 + dp[i-1][j-1])\n        else:\n            # Find the best possible a_i such that all constraints are satisfied\n            # But this might be complicated, so perhaps an alternative approach is needed.\n            pass\n\n# Wait, maybe a better approach is to model the constraints as intervals and ensure that for each interval [l, r], the maximum a_i in that interval is <= x.\n\n# So perhaps a better way is to use a segment tree or interval-based DP.\n\n# Alternatively, since n is small (<=50), we can model it using a DP state where for each position i, we track the maximum a_i chosen, and for each constraint, ensure that the maximum in their intervals is <= x.\n\n# Let me think about the DP state.\n\n# Let's define dp[i][k] as the maximum profit achievable up to position i, where the height at i is k.\n\n# Then, for each i, we can choose a height a_i up to max_heights[i], and for each constraint that ends at i, ensure that the maximum in that constraint's range is <= x.\n\n# However, tracking all possible maximums for all constraints is tricky. So perhaps another approach is needed.\n\n# Another idea: for each position, the maximum height is constrained by the earliest ending constraint that includes it. So we can process the constraints in a way that updates the maximum allowed height for each position.\n\n# Wait, but the initial approach I took computes the maximum allowed height for each position, which is the minimum of h and the minimum x of all constraints covering it.\n\n# So, once we have this max_heights array, the problem reduces to choosing a_i <= max_heights[i] for each i, and ensuring that for each constraint (l, r, x), the maximum a_i in [l, r] is <= x.\n\n# This seems similar to a problem where we have multiple interval constraints, and we need to choose values in such a way that all constraints are satisfied.\n\n# Since n is small, perhaps a brute-force approach with memoization could work, but even better would be a DP approach.\n\n# Let me think about the DP approach.\n\n# We can model the DP as follows: dp[i][k] represents the maximum profit up to position i, where the height at position i is exactly k.\n\n# For each position i, we can try all possible heights from 0 to max_heights[i]. For each possible height k, we look back to the previous positions and find the best possible configuration.\n\n# Additionally, for each constraint that ends at i, we need to ensure that the maximum height in that constraint's range is <= x.\n\n# So, for each constraint (l, r, x), when processing position i, if r = i, then we need to ensure that the maximum height in [l, i] is <= x.\n\n# How can we track this? Well, for each position i, after choosing a_i, we can check all constraints that end at i. For each such constraint, the maximum of a_l ... a_r must be <= x.\n\n# So, for the DP state, we need to track, for each position i, the maximum height in all constraints ending at i.\n\n# This seems computationally intensive, but given the constraints (n=50, h=50), it might be manageable.\n\n# So, let's proceed.\n\n# The DP state can be defined as:\n\n# dp[i][a_i] = maximum profit up to position i, with a_i being the height at position i.\n\n# But since a_i can vary from 0 to max_heights[i], and n is small, this is feasible.\n\n# Initialization: dp[0][0] = 0^2 = 0 (assuming 0-based indexing).\n\n# For each position i from 0 to n-1:\n\n#   For each possible a_i in 0..max_heights[i]:\n\n#       For each possible a_{i-1} in 0..max_heights[i-1]:\n\n#           If i == 0:\n\n#               if a_0 > max_heights[0]: skip\n\n#               else: dp[0][a_0] = a_0^2\n\n#           Else:\n\n#               Take the maximum between choosing a_i and the best possible from i-1.\n\n#               But also, for all constraints ending at i, ensure that the maximum in their ranges is <= x.\n\n# Wait, but how do we handle the constraints? Because each constraint may span multiple positions.\n\n# Perhaps, for each constraint, we need to ensure that within its range, the maximum a_i is <= x.\n\n# So, when processing a position i, for all constraints ending at i, we need to check if the maximum a_j in [l, i] is <= x.\n\n# Therefore, during the DP transition, after setting a_i, we need to verify all constraints that end at i.\n\n# So, the DP state needs to include information about the maximum in all intervals ending at the current position.\n\n# But this seems too complex. An alternative approach is to precompute for each position i the latest constraint ending at i, and enforce that the maximum up to i satisfies that constraint.\n\n# Hmm, perhaps a better way is to model the problem differently.\n\n# Another Idea: For each position, determine the tightest constraint (smallest x) that applies to it. The height at each position cannot exceed this value. Then, the problem becomes selecting heights that satisfy all these per-position constraints and also satisfy the interval constraints.\n\n# Wait, but the interval constraints may overlap, so the per-position constraints are derived from the minimum of all applicable x's. However, this alone might not suffice because the maximum in an interval could be determined by a position outside the per-position constraints.\n\n# For example, suppose we have two intervals: [1, 2] with x=3 and [2, 3] with x=2. The per-position constraints would be 3 for position 1, 2 for position 2, and 3 for position 3. But the interval [1, 2] requires that the maximum of positions 1 and 2 is <=3, which is already satisfied. The interval [2,3] requires that the maximum of positions 2 and 3 is <=2, which means position 3 can't exceed 2, so the per-position constraint for 3 is updated to 2.\n\n# So, perhaps the per-position constraints are sufficient to capture all necessary constraints, but I'm not entirely sure. It depends on whether all constraints are covered by the per-position constraints.\n\n# Wait, no. Consider a case where there are two overlapping constraints: one on [1,3] with x=4, and another on [2,3] with x=3. The per-position constraints for positions 2 and 3 would be min(4,3)=3, but the first constraint requires that the maximum in [1,3] is <=4. However, the second constraint requires that the maximum in [2,3] is <=3. So the per-position constraints are correct.\n\n# Another example: Suppose a constraint [1,3] with x=3 and another [2,3] with x=2. The per-position constraints for 1 is 3, 2 is 2, and 3 is 2. But the maximum in [1,3] is 3, which is allowed because the first constraint allows it. However, the second constraint requires that the maximum in [2,3] is <=2, so position 2 must be <=2 and position 3 must be <=2.\n\n# So in this case, the per-position constraints correctly reflect the required maximums.\n\n# Therefore, perhaps the per-position constraints are sufficient, and the problem can be reduced to choosing a_i <= max_heights[i] for each i, ensuring that for every constraint [l, r, x], the maximum a_i in [l, r] is <=x.\n\n# Now, how do we ensure this?\n\n# One approach is to model the problem as a graph where each state represents the current position and the maximum height chosen so far for the relevant intervals. However, this seems complex.\n\n# Another approach is to realize that for each constraint, the maximum a_i in [l, r] must be <=x. So, for each constraint, the maximum height in that interval is the maximum of all a_i in [l, r], which must be <=x.\n\n# Thus, the problem can be viewed as a series of constraints on the maximum values within certain intervals. This is similar to the problem of scheduling jobs with interval constraints.\n\n# Given the small constraints (n=50, m=50), a dynamic programming approach where we track the maximum height in the current interval is feasible.\n\n# Let's try to model the DP state as follows:\n\n# dp[i][k] = maximum profit up to position i, where the maximum height in the interval [i, r] for some constraints ending at i is k.\n\n# But this might not capture all constraints. Alternatively, we can model the DP state as the current position and the maximum height chosen so far, ensuring that all constraints are satisfied up to that point.\n\n# Another Idea: For each position i, after choosing a_i, we need to ensure that for all constraints ending at i, the maximum a_j in [l, i] is <=x. So, during the DP transition, for each constraint ending at i, we need to check if the maximum in [l, i] is acceptable.\n\n# However, this can be computationally expensive as we need to check all constraints ending at each i.\n\n# Given the small constraints, perhaps it's manageable.\n\n# Let's proceed with this approach.\n\n# Initialize the DP table.\n\n# dp[i][a_i] = maximum profit up to position i, where a_i is the height chosen for position i.\n\n# For each position i from 0 to n-1:\n\n#   For each possible a_i from 0 to max_heights[i]:\n\n#       For each possible a_prev from 0 to max_heights[i-1]:\n\n#           new_profit = dp[i-1][a_prev] + a_i^2\n\n#           Check all constraints that end at i:\n\n#               For each such constraint (l, i, x):\n\n#                   current_max = max(a[l ... i])\n\n#                   if current_max > x: this choice is invalid\n\n#           If all constraints are satisfied, update dp[i][a_i] = max(new_profit, current value)\n\n# But checking the maximum in each interval for each transition is O(n^2) for each i, leading to O(n^3 * m) time, which is acceptable for n=50.\n\n# So, let's implement this.\n\n# Now, code-wise:\n\nInitialize the DP table as a list of dictionaries or a 2D array.\n\nBut since n is small, a 2D array is manageable.\n\nSo, let's create a 2D array `dp` where `dp[i][k]` represents the maximum profit up to position `i` with height `k` at position `i`.\n\nWe'll initialize `dp[0][k]` for all valid `k` as `k^2`.\n\nThen, for each position `i` from 1 to n-1:\n\n   For each possible height `k` at `i` (from 0 to max_heights[i]):\n\n       For each possible previous height `prev_k` at `i-1` (from 0 to max_heights[i-1]):\n\n           if choosing `k` at `i` doesn't violate any constraints ending at `i`, then:\n\n               new_profit = dp[i-1][prev_k] + k^2\n\n               if new_profit > dp[i][k], update dp[i][k]\n\nAdditionally, for each constraint ending at `i`, we need to check that the maximum in that interval is <=x.\n\nWait, but how do we efficiently check the maximum in each interval? For each constraint ending at `i`, which is (l, i, x), we need to ensure that the maximum a_j in [l, i] is <=x.\n\nSo, during the DP transition, for each possible a_i, we need to check all constraints ending at `i` and see if any of them would be violated by the current a_i and the previous choices.\n\nBut how can we track the maximum in [l, i]? It's the maximum of a_l, a_{l+1}, ..., a_i.\n\nThis suggests that for each constraint ending at `i`, we need to know the maximum a_j in [l, i], which depends on the choices made for positions l to i.\n\nThus, the DP state must somehow track, for each interval ending at `i`, the maximum a_j in that interval.\n\nThis complicates the state representation.\n\nAn alternative approach is to realize that for each constraint ending at `i`, the maximum in [l, i] is determined by the maximum of a_l, a_{l+1}, ..., a_i.\n\nThus, for each constraint ending at `i`, the maximum can be computed as the maximum of the current a_i and the maximum from the previous step in the same constraint.\n\nWait, perhaps we can model the DP state as including, for each interval ending at `i`, the current maximum for that interval.\n\nBut this seems too memory-intensive.\n\nGiven the time constraints, perhaps a better approach is to precompute for each position `i` the earliest constraint ending at `i`, and enforce that the maximum in that constraint is <=x.\n\nAlternatively, perhaps we can process the constraints in a way that ensures that for each interval [l, r], the maximum a_i in that interval is <=x.\n\nBut I'm not seeing a clear path forward, so perhaps it's better to refer to the initial approach and see if it can be implemented.\n\nIn the initial approach, the per-position constraints are computed, but the interval constraints may not be fully captured. However, in the sample inputs, this approach works.\n\nBut wait, in the sample input 2:\n\nThe constraints are:\n\n2 3 8 → affects positions 1 and 2 (0-based)\n3 4 7 → affects positions 3 and 4 (0-based)\n\nThe per-position constraints would be:\n\npos 0: only constraint is 10 (since no constraints cover it)\npos 1: min(10, 8) =8\npos 2: min(10, 8,7) =7\npos 3: min(10,7) =7\npos4: min(10,7) =7\n\nBut in the optimal solution, pos 0 is 10, pos1 is 8, pos2 is7, pos3 is7, pos4 is7.\n\nWhich fits all constraints.\n\nSo, the per-position constraints seem sufficient here.\n\nAnother test case: suppose we have a single constraint [1,3] with x=3, and another [2,3] with x=2.\n\nPer-position constraints would be:\n\npos0: 3 (since [1,3] covers it)\npos1: min(3,2)=2\npos2: min(3,2)=2\n\nBut the first constraint [1,3] requires that the maximum of pos0, pos1, pos2 is <=3, which is satisfied if pos0 is 3, pos1 and pos2 are 2.\n\nThe second constraint [2,3] requires that the maximum of pos1 and pos2 is <=2, which is satisfied.\n\nSo, the per-position constraints correctly capture all necessary constraints.\n\nThus, perhaps the per-position constraints are sufficient, and the problem can be reduced to assigning a_i <= max_heights[i] for each i, and then the sum of squares is maximized.\n\nBut wait, what if a constraint is [1,3] with x=3, and another [2,3] with x=3. Then the per-position constraints for pos1 and pos2 would be 3.\n\nBut the maximum in [1,3] is 3, which is allowed, and the maximum in [2,3] is 3, which is allowed.\n\nBut what if there's another constraint [2,3] with x=2? Then pos1 and pos2 would have max_heights of 2.\n\nSo, the per-position approach seems to capture all necessary constraints.\n\nTherefore, the problem can be simplified to choosing a_i as high as possible (to maximize the sum of squares) without exceeding the per-position maximums.\n\nThus, the solution is to assign each spot the maximum possible height based on its per-position maximum, ensuring that all interval constraints are satisfied.\n\nWait, but how do we ensure that the interval constraints are satisfied? Because the per-position approach captures the minimal of all constraints, but the maximum in an interval may still be higher than x if other spots in the interval have higher a_i.\n\nWait, no. Because the per-position maximum is the minimal of all x's for constraints covering that spot. So for any interval [l, r], the maximum a_i in that interval cannot exceed the minimal x among all constraints covering that interval.\n\nWait, no. Suppose a spot is covered by multiple constraints. The per-position maximum is the minimal x across all constraints covering it. So for any spot in [l, r], a_i cannot exceed the minimal x of all constraints covering it. Therefore, the maximum a_i in [l, r] is at most the minimal x of all constraints covering any spot in [l, r].\n\nBut the constraint for [l, r] is that the maximum must be <=x. So, if the minimal x across all constraints covering [l, r] is <=x, then it's satisfied.\n\nWait, perhaps not. Because the constraints are separate; each has its own x. So, for a particular interval [l, r], the maximum a_i in that interval must be <=x for that specific constraint.\n\nBut the per-position approach ensures that for each spot, a_i is <= the minimal x of all constraints covering it. So, for any spot in [l, r], a_i is <=x of all constraints that include it, including the specific [l, r] constraint. Thus, the maximum a_i in [l, r] will be <=x, because a_i for each spot is <= the x of the [l, r] constraint (since it's part of that constraint's coverage).\n\nWait, no. Because a spot could be covered by multiple constraints, including the [l, r] one. So, the per-position maximum for each spot in [l, r] is <=x, because the [l, r] constraint contributes x to their per-position maximum.\n\nYes! Because for any spot in [l, r], the per-position maximum is the minimal of h and all x's from constraints covering it, including the [l, r] constraint. So, for the [l, r] constraint, the maximum a_i in [l, r] is <=x.\n\nThus, the per-position constraints ensure that all interval constraints are satisfied.\n\nTherefore, the problem reduces to choosing a_i as high as possible (up to max_heights[i]) to maximize the sum of squares.\n\nSo, the optimal solution is to set each a_i to its max_heights[i], as this maximizes each term a_i^2.\n\nWait, but what if a_i is set to max_heights[i], but some constraints are still violated?\n\nNo, because the per-position max_heights[i] is the minimal of h and all x's from constraints covering i. So, setting a_i to max_heights[i] ensures that all constraints are satisfied.\n\nThus, the maximum profit is simply the sum of squares of max_heights[i] for each i.\n\nSo, the solution is straightforward:\n\n1. For each spot i, compute the maximum allowed height as the minimum of h and the minimum x from all constraints covering i.\n2. Sum the squares of these heights.\n\nLet me test this with the sample inputs.\n\nSample Input 1:\n\n3 3 3\n1 1 1 → covers spot 0\n2 2 3 → covers spot 1\n3 3 2 → covers spot 2\n\nCompute max_heights:\n\nspot 0: min(3, 1) = 1\nspot 1: min(3, 3) =3\nspot 2: min(3, 2) =2\n\nSum of squares: 1 +9 +4=14 → matches sample.\n\nSample Input 2:\n\n4 10 2\n2 3 8 → covers spots 1,2\n3 4 7 → covers spots 3,4\n\nCompute max_heights:\n\nspot 0: 10 (no constraints)\nspot 1: min(10,8)=8\nspot 2: min(10,8,7)=7\nspot 3: min(10,7)=7\nspot 4: min(10,7)=7\n\nSum of squares: 100 +64 +49 +49=262 → matches sample.\n\nThus, the solution is to compute the max_heights array as described and sum the squares.\n\nSo, the code can be written as follows:\n\nRead n, h, m.\n\nFor each spot i (0-based), compute max_heights[i] as the minimum of h and the minimum x from all constraints that include i.\n\nSum the squares of these max_heights.\n\nSo, the code is straightforward.\n\nNow, implementing this in Python:\n\nRead n, h, m.\n\nCreate an array constraints, storing tuples (l, r, x), converted to 0-based indices.\n\nFor each i in 0..n-1:\n\n   min_x = h\n\n   for each constraint in constraints:\n\n       if l <= i <= r:\n\n           if x < min_x:\n\n               min_x = x\n\n   max_heights[i] = min(min_x, h)\n\nCompute the sum of squares.\n\nPrint the sum.\n\nWait, but wait: in the constraints, l and r are 1-based. So when reading, we need to subtract 1 to make them 0-based.\n\nYes.\n\nSo, the code should be:\n\nn, h, m = map(int, input().split())\n\nconstraints = []\nfor _ in range(m):\n    l, r, x = map(int, input().split())\n    constraints.append( (l-1, r-1, x) )\n\nmax_heights = [h] * n\n\nfor i in range(n):\n    min_x = h\n    for (l, r, x) in constraints:\n        if l <= i <= r:\n            if x < min_x:\n                min_x = x\n    max_heights[i] = min(min_x, h)\n\ntotal = sum( a*a for a in max_heights )\n\nprint(total)\n\nWait, but in the first sample input, the code gives 14 as expected.\n\nIn the second sample, it gives 100 +64 +49 +49= 262.\n\nYes.\n\nThus, this code should solve the problem correctly.\n\nI think this approach is correct, as it satisfies all constraints and maximizes the sum of squares.",
    "score": -1,
    "metadata": {
        "prompt_token_count": 803,
        "completion_token_count": 5865,
        "thoughts_token_count": 1025
    }
}