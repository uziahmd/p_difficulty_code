{
    "start": 1758278105.5495374,
    "end": 1758278318.9155545,
    "start-formatted": "2025-09-19 19:35 KST",
    "end-formatted": "2025-09-19 19:38 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read it carefully.\n\nThe problem is about assigning Rebel spaceships to guard B bases such that every base has exactly one guardian and each spaceship is assigned to exactly one base. So it's a perfect matching between R spaceships and B bases.\n\nBut there's an additional constraint: the paths from a base to its spaceship shouldn't intersect any other path. These paths are straight lines in the galaxy plane (2D). So, for any two paths, their corresponding lines can't cross each other.\n\nHmm. So the assignment must not only be a perfect matching but also ensure that none of the connecting lines cross each other.\n\nSo, how do I approach this?\n\nFirst, I need to model the problem. The key is to find a bipartite matching where the edges don't cross any other edges when drawn as straight lines.\n\nWait, but how to represent this condition computationally? Because checking all possible permutations could be expensive, especially since R and B can be up to 10 each, making the total possible matchings 10! = 3,628,800 which is manageable, but for each permutation, I need to check if any two lines cross.\n\nWait, but wait. If R equals B, because it's a perfect matching, right? So R must equal B for a perfect matching to exist. Wait no, the first paragraph says R and B can be different? Wait, the problem says \"assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base.\" Oh, that's a perfect matching. So R must equal B; otherwise, it's impossible. So the first thing I should check is whether R equals B. Because a perfect matching requires equal numbers on both sides.\n\nWait, looking at the input example: the first case has R=3, B=3, so it works. The second case has R=2 and B=3, so it's impossible. So the output is 'No' because no perfect matching exists.\n\nWait, the sample input seems to have two test cases. Let me look again.\n\nSample Input:\n\n3 3\n... spaceship coordinates\n...\n2 1\n1 0\n2 2\n3 1\n\nAnd the outputs are Yes and No. So the first case is R=3, B=3, possible. The second case is R=2, B=3, which isn't possible because you can't have a perfect matching when R != B.\n\nSo the first step is to check if R != B. If they're not equal, immediately output 'No'.\n\nWait, but wait: what if R < B? Then we can't assign all R spaceships to B bases. So yes, the problem reduces to only considering cases where R == B.\n\nSo that's the first check. If R != B, output 'No'.\n\nNow, assuming R == B, the next step is to find a perfect matching where the lines connecting the matched points don't cross any others.\n\nSo the problem is: given R points (spaceships) and R points (bases), find a bijection (permutation) such that no two edges (lines) in the permutation cross each other.\n\nHow can we model this? It seems similar to finding a non-crossing perfect matching.\n\nAh, right. So the problem is equivalent to finding a non-crossing perfect matching between two sets of points. This is a well-known problem in computational geometry.\n\nSo the plan is:\n\n1. Check if R != B. If so, output 'No'.\n2. Else, generate all possible permutations of the bases, assigning each spaceship to a base in order.\n3. For each permutation, check if the lines between the spaceships and bases form a non-crossing set.\n4. If any permutation satisfies the condition, output 'Yes'. Otherwise, output 'No'.\n\nBut wait, generating all permutations is O(R!) which for R=10 is about 3.6 million. For each permutation, we need to check all pairs of lines to see if any cross. That could be O(R^2) per permutation. So for R=10, 3.6e6 * 100 = 3.6e8 operations. Hmm, that might be acceptable for Python, but perhaps we can optimize.\n\nAlternatively, perhaps we can model this as a graph where edges are allowed only if the line between two points doesn't cross any other line. But I'm not sure.\n\nWait, another approach: for each possible permutation, we can model the edges and then check if any two edges cross. If none cross, then it's a valid solution.\n\nSo the steps are:\n\n- For each permutation p of the bases:\n   - For i from 0 to R-1:\n      - Create the line between spaceship[i] and base[p[i]]\n   - Check if any two lines in this set cross each other. If none do, return 'Yes'.\n-",
    "response": "To solve this problem, we need to determine if it is possible to assign Rebel spaceships to guard B bases such that each base has exactly one guardian and each spaceship is assigned to exactly one base. Additionally, the paths from the bases to their assigned spaceships should not intersect in the galaxy plane.\n\n### Approach\n1. **Check for Perfect Matching Feasibility**: First, check if the number of Rebel spaceships (R) is equal to the number of bases (B). If they are not equal, it is impossible to form a perfect matching, and we immediately output \"No\".\n\n2. **Generate Permutations**: If R equals B, generate all possible permutations of the bases. Each permutation represents a potential bijection between spaceships and bases.\n\n3. **Check for Non-Crossing Paths**: For each permutation, create lines between each spaceship and its assigned base. Check if any two lines intersect. If a permutation exists where none of the lines intersect, output \"Yes\". If all permutations are checked and none satisfy the non-crossing condition, output \"No\".\n\n### Solution Code\n```python\nimport sys\nfrom itertools import permutations\n\ndef readints():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef cross(o, a, b):\n    # Check if line segment OA crosses AB\n    # o, a, b are tuples (x,y)\n    ax = a[0] - o[0]\n    ay = a[1] - o[1]\n    bx = b[0] - o[0]\n    by = b[1] - o[1]\n    \n    abx = b[0] - a[0]\n    aby = b[1] - a[1]\n    \n    det1 = ax * aby - ay * abx\n    det2 = bx * ay - by * ax\n    \n    if det1 * det2 < 0:\n        return True\n    return False\n\ndef main():\n    data = sys.stdin.read().split()\n    ptr = 0\n    R = int(data[ptr])\n    ptr +=1\n    B = int(data[ptr])\n    ptr +=1\n    \n    if R != B:\n        print(\"No\")\n        return\n    \n    ships = []\n    for _ in range(R):\n        x = int(data[ptr])\n        y = int(data[ptr+1])\n        ships.append( (x, y) )\n        ptr +=2\n    \n    bases = []\n    for _ in range(B):\n        x = int(data[ptr])\n        y = int(data[ptr+1])\n        bases.append( (x, y) )\n        ptr +=2\n    \n    found = False\n    for perm in permutations(range(B)):\n        edges = []\n        for i in range(R):\n            s = ships[i]\n            b = bases[perm[i]]\n            edges.append( (s, b) )\n        \n        # Check all pairs for crossing\n        valid = True\n        for i in range(len(edges)):\n            for j in range(i+1, len(edges)):\n                s1, b1 = edges[i]\n                s2, b2 = edges[j]\n                \n                # Check if the line s1-b1 crosses s2-b2\n                if cross(s1, b1, s2, b2):\n                    valid = False\n                    break\n            if not valid:\n                break\n        \n        if valid:\n            found = True\n            break\n    \n    print(\"Yes\" if found else \"No\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Reading Input**: The input is read and parsed into coordinates for spaceships and bases.\n- **Perfect Matching Check**: If the number of spaceships does not match the number of bases, output \"No\".\n- **Permutation Generation**: Generate all possible permutations of bases to explore every possible bijection.\n- **Non-Crossing Check**: For each permutation, check if the connecting lines between spaceships and bases intersect. If a valid permutation is found, output \"Yes\"; otherwise, after checking all permutations, output \"No\".\n\nThis approach ensures that we efficiently check all possible assignments and validate them against the non-crossing constraint, providing a solution that handles all edge cases within the problem constraints.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom itertools import permutations\n\ndef readints():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef cross(o, a, b):\n    # Check if line segment OA crosses AB\n    # o, a, b are tuples (x,y)\n    ax = a[0] - o[0]\n    ay = a[1] - o[1]\n    bx = b[0] - o[0]\n    by = b[1] - o[1]\n    \n    abx = b[0] - a[0]\n    aby = b[1] - a[1]\n    \n    det1 = ax * aby - ay * abx\n    det2 = bx * ay - by * ax\n    \n    if det1 * det2 < 0:\n        return True\n    return False\n\ndef main():\n    data = sys.stdin.read().split()\n    ptr = 0\n    R = int(data[ptr])\n    ptr +=1\n    B = int(data[ptr])\n    ptr +=1\n    \n    if R != B:\n        print(\"No\")\n        return\n    \n    ships = []\n    for _ in range(R):\n        x = int(data[ptr])\n        y = int(data[ptr+1])\n        ships.append( (x, y) )\n        ptr +=2\n    \n    bases = []\n    for _ in range(B):\n        x = int(data[ptr])\n        y = int(data[ptr+1])\n        bases.append( (x, y) )\n        ptr +=2\n    \n    found = False\n    for perm in permutations(range(B)):\n        edges = []\n        for i in range(R):\n            s = ships[i]\n            b = bases[perm[i]]\n            edges.append( (s, b) )\n        \n        # Check all pairs for crossing\n        valid = True\n        for i in range(len(edges)):\n            for j in range(i+1, len(edges)):\n                s1, b1 = edges[i]\n                s2, b2 = edges[j]\n                \n                # Check if the line s1-b1 crosses s2-b2\n                if cross(s1, b1, s2, b2):\n                    valid = False\n                    break\n            if not valid:\n                break\n        \n        if valid:\n            found = True\n            break\n    \n    print(\"Yes\" if found else \"No\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 463,
        "completion_token_count": 874,
        "thoughts_token_count": 1025
    }
}