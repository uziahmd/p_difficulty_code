{
    "start": 1758103524.4704762,
    "end": 1758103639.7741315,
    "start-formatted": "2025-09-17 19:05 KST",
    "end-formatted": "2025-09-17 19:07 KST",
    "gpu": 2,
    "pid": 6,
    "use_openrouter": false,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read it carefully.\n\nThe problem is about Leha choosing two vouchers for his vacation such that their durations sum up exactly to x days, and they don't overlap. Also, the total cost should be as minimal as possible. If it's not possible, we return -1.\n\nHmm, let's think about how to approach this.\n\nFirst, each voucher has a start day li, end day ri, and cost costi. The duration is ri - li + 1. So for two vouchers i and j, the sum of their durations should be exactly x.\n\nAlso, the vouchers must not intersect. That means either the first ends before the second starts (ri_i < lj) or the second ends before the first starts (rj < li).\n\nSo, the plan is:\n\n1. For each possible pair of vouchers (i, j), check if their durations add up to x.\n2. Ensure that they are non-overlapping.\n3. Among all such pairs, find the one with the minimum total cost.\n\nBut wait, n can be up to 2e5, so checking all possible pairs is O(n^2), which is 4e10 operations—way too slow. So we need a smarter approach.\n\nWe need a way to group the vouchers by their duration, so that for each voucher i of duration d, we can look for vouchers j of duration x - d.\n\nYes, that makes sense. So for each voucher i, compute its duration d_i. Then, for each possible d_j = x - d_i, we can look for vouchers j where d_j is x - d_i and voucher j doesn't overlap with i.\n\nBut even this approach could be time-consuming because for each i, we might have many j's to check.\n\nWait, but for each i, we can process it by considering the other vouchers j with duration x - d_i. But how do we efficiently find the minimal cost j that doesn't overlap with i?\n\nHmm, perhaps pre-sorting the vouchers in a certain way can help.\n\nLet me think: For each possible duration d, we can keep track of all vouchers with that duration, sorted by their end times. Then, for a voucher i of duration d, we need vouchers j of duration (x - d) whose end times are either before i's start or after i's end.\n\nWait, no. Wait, for a voucher j to not overlap with i, j's end must be before i's start OR j's start must be after i's end.\n\nWait, no, actually, the condition is that either j's end is before i's start (so j is entirely before i) or j's start is after i's end (so j is entirely after i).\n\nSo for a given i, any j that satisfies either:\n\n- j's end <= i's start - 1\nOR\n- j's start >= i's end + 1\n\nThen, j can be paired with i.\n\nSo for each i, we can split the search into two parts: j's that end before i starts, and j's that start after i ends.\n\nSo, the approach would be:\n\n1. Preprocess the vouchers:\n   a. Group them by their duration. So for each d, have a list of vouchers with duration d, sorted by end time and start time.\n\n2. For each voucher i:\n   a. Compute d_i = duration of i.\n   b. Compute required_d = x - d_i. If required_d < 0, skip.\n   c. Look for vouchers j with duration required_d.\n      i. For j's that end before i starts: find all j in required_d where rj <= li - 1. We need the minimal cost among these j's.\n      ii. For j's that start after i ends: find all j in required_d where lj >= ri + 1. Again, find the minimal cost among these j's.\n   d. If either of these exists, calculate the total cost (i's cost + minimal j's cost) and keep track of the global minimum.\n\nBut how to efficiently perform steps c.i and c.ii for each i?\n\nSince vouchers are sorted, we can use binary search.\n\nFor c.i: For j's in required_d, we need rj <= li - 1. So for each j in required_d, if rj is <= li - 1, it's a candidate. We can sort the j's in required_d by rj, and for a given li, find the maximum rj that is <= li - 1, then find the minimal cost up to that point.\n\nSimilarly, for c.ii: lj >= ri + 1. So for j's in required_d, we can sort them by lj, and for a given ri, find the minimal lj that is >= ri + 1, then find the minimal cost from there on.\n\nAlternatively, perhaps we can",
    "response": "To solve this problem, we need to find two non-overlapping vouchers such that their combined duration equals the total vacation duration and their total cost is minimized. The approach involves efficiently searching for valid pairs of vouchers using sorting and binary search.\n\n### Approach\n1. **Group Vouchers by Duration**: Group each voucher by its duration. This allows us to quickly access all vouchers with a specific duration when needed.\n2. **Sort Vouchers**: For each duration group, sort the vouchers based on their end times and start times. This helps in efficiently finding non-overlapping vouchers using binary search.\n3. **Iterate Over Each Voucher**: For each voucher, determine the required duration of the second voucher to sum up to the total vacation duration. Use binary search to find the minimal cost voucher that either ends before the current voucher starts or starts after the current voucher ends.\n\n### Solution Code\n```python\nimport bisect\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    x = int(input[idx + 1])\n    idx += 2\n\n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        r = int(input[idx + 1])\n        c = int(input[idx + 2])\n        vouchers.append((l, r, c))\n        idx += 3\n\n    from collections import defaultdict\n    duration_map = defaultdict(list)\n    for v in vouchers:\n        d = v[1] - v[0] + 1\n        duration_map[d].append(v)\n\n    min_total = float('inf')\n\n    for i in range(n):\n        li, ri, ci = vouchers[i]\n        d_i = ri - li + 1\n        required_d = x - d_i\n        if required_d < 0:\n            continue\n\n        if required_d not in duration_map:\n            continue\n\n        j_list = duration_map[required_d]\n        j_list.sort(key=lambda x: x[1])\n\n        # Case 1: j ends before i starts\n        target_r = li - 1\n        pos = bisect.bisect_right([j[1] for j in j_list], target_r)\n        candidates = j_list[:pos]\n        if candidates:\n            min_cost = min(c[2] for c in candidates)\n            total = ci + min_cost\n            if total < min_total:\n                min_total = total\n\n        # Case 2: j starts after i ends\n        target_l = ri + 1\n        l_values = [j[0] for j in j_list]\n        pos = bisect.bisect_left(l_values, target_l)\n        candidates = j_list[pos:]\n        if candidates:\n            min_cost = min(c[2] for c in candidates)\n            total = ci + min_cost\n            if total < min_total:\n                min_total = total\n\n    if min_total != float('inf'):\n        print(min_total)\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Grouping by Duration**: We group vouchers by their duration to quickly access all possible candidates for the second voucher.\n- **Sorting**: Sorting each group by end times and start times allows efficient binary search operations.\n- **Binary Search**: For each voucher, we use binary search to find the minimal cost voucher that either ends before the current voucher starts or starts after the current voucher ends, ensuring non-overlapping and minimal total cost.\n\nThis approach efficiently narrows down the search space, making it feasible to handle the problem within acceptable time limits even for large inputs.",
    "ground_truth": "N/A",
    "extracted_answer": "import bisect\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    x = int(input[idx + 1])\n    idx += 2\n\n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        r = int(input[idx + 1])\n        c = int(input[idx + 2])\n        vouchers.append((l, r, c))\n        idx += 3\n\n    from collections import defaultdict\n    duration_map = defaultdict(list)\n    for v in vouchers:\n        d = v[1] - v[0] + 1\n        duration_map[d].append(v)\n\n    min_total = float('inf')\n\n    for i in range(n):\n        li, ri, ci = vouchers[i]\n        d_i = ri - li + 1\n        required_d = x - d_i\n        if required_d < 0:\n            continue\n\n        if required_d not in duration_map:\n            continue\n\n        j_list = duration_map[required_d]\n        j_list.sort(key=lambda x: x[1])\n\n        # Case 1: j ends before i starts\n        target_r = li - 1\n        pos = bisect.bisect_right([j[1] for j in j_list], target_r)\n        candidates = j_list[:pos]\n        if candidates:\n            min_cost = min(c[2] for c in candidates)\n            total = ci + min_cost\n            if total < min_total:\n                min_total = total\n\n        # Case 2: j starts after i ends\n        target_l = ri + 1\n        l_values = [j[0] for j in j_list]\n        pos = bisect.bisect_left(l_values, target_l)\n        candidates = j_list[pos:]\n        if candidates:\n            min_cost = min(c[2] for c in candidates)\n            total = ci + min_cost\n            if total < min_total:\n                min_total = total\n\n    if min_total != float('inf'):\n        print(min_total)\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 687,
        "completion_token_count": 756,
        "thoughts_token_count": 1025
    }
}