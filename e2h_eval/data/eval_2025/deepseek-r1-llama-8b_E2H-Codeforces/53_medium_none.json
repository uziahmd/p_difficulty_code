{
    "start": 1758283479.8480484,
    "end": 1758284764.1857693,
    "start-formatted": "2025-09-19 21:04 KST",
    "end-formatted": "2025-09-19 21:26 KST",
    "gpu": 2,
    "pid": 53,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# You're Given a String...\n\nYou're given a string of lower-case Latin letters. Your task is to find the length of its longest substring that can be met in the string at least twice. These occurrences can overlap (see sample test 2).\n\n## Input\nThe first input line contains the string. It's guaranteed, that the string is non-empty, consists of lower-case Latin letters, and its length doesn't exceed 100.\n\n## Output\nOutput one number — length of the longest substring that can be met in the string at least twice.\n\n## Example\n### Input\n['abcd', 'ababa', 'zzz']\n\n### Output\n['0', '3', '2']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "Okay, I have to solve this problem where I'm given a string, and I need to find the length of the longest substring that appears at least twice. The occurrences can overlap. Hmm, let me think about how to approach this.\n\nSo, the input is a single string, which can be up to 100 characters long. My goal is to check all possible substrings of the string, starting from the longest possible down to the shortest, and see if any of them appear more than once. Once I find the maximum length that satisfies this condition, I return it.\n\nWait, but how do I efficiently check for substrings? Since the string isn't too long, maybe a brute-force approach is acceptable here. Because 100 characters, the maximum substring length is 99, then 98, etc., and for each length, I can generate all possible substrings and check if any appears more than once.\n\nBut wait, generating all possible substrings and checking their occurrence could be time-consuming. However, given the small input size, this should be manageable.\n\nLet me outline the steps:\n\n1. Iterate over possible substring lengths starting from the maximum possible (length of string -1) down to 1.\n2. For each length L:\n   a. Generate all possible substrings of length L in the string.\n   b. Check if any of these substrings appears more than once in the list.\n   c. If yes, return L as the answer.\n3. If no such L is found for L >=1, return 0. But wait, the problem says the string is non-empty, so there's always at least one substring (like single characters). But for example, if the string has all unique characters, then the maximum would be 0 because no substring appears more than once except for length 0, which isn't considered here.\n\nWait, no. Wait, the problem statement says \"find the length of its longest substring that can be met in the string at least twice.\" So if the entire string is unique, then the answer is 0, because the only way a substring appears twice is if it's zero-length, which isn't counted. Or perhaps I'm misunderstanding.\n\nLooking back at the examples: the third input is 'zzz', and the output is 2. So the substrings are 'zz' appearing at positions 0-1 and 1-2. So the maximum is 2.\n\nIn the case where the string is 'abcd', the output is 0. Because all substrings of length 3 or 4 are unique, and even for smaller lengths, like 3, each is unique. So in this case, the maximum is 0.\n\nSo the process is: for each possible length L starting from the largest possible down to 1, check all substrings of that length. For each L, collect all substrings of that length and see if any appears more than once. If yes, return L.\n\nSo the plan is:\n\nLoop L from min_length down to 1:\n\nmin_length is len(string) - 1.\n\nWait, no, len(string) can be n. The maximum possible substring is of length n-1, since any longer would not fit. Wait, no, the substring can be of any length from 1 to n-1, because a substring cannot be equal to the entire string unless it's exactly length n, but then it's the same string.\n\nWait, no. The substring must appear at least twice. So for the entire string, it's only once, so it's not considered. So for each L from (n-1) down to 1:\n\n- For each L, get all substrings of length L.\n\n- For each substring, check if it appears again somewhere else in the string.\n\nIf any substring of length L occurs more than once, then the answer is L. So we can return it immediately.\n\nSo the steps are:\n\nFor L in range(len(s)-1, 0, -1):\n\n   substrs = [s[i:i+L] for i in range(0, len(s) - L + 1)]\n\n   create a set of these substrs.\n\n   if any substring appears more than once (i.e., the length of the set is less than the number of substrs), then return L.\n\nIf none found after checking all L down to 1, return 0.\n\nWait, but for L= len(s), it's just one substring. So we don't consider L=len(s).\n\nSo let's adjust:\n\nThe loop starts from L = len(s) -1 down to 1.\n\nSo for each L in that range:\n\n   collect all possible substrings of length L.\n\n   for each substring, keep track of how many times it occurs.\n\n   if any substring occurs two or more times, then return L.\n\nSo the algorithm can be implemented as follows.\n\nNow, considering the sample inputs:\n\nSample 1:\n\nInput: 'abcd'\n\nLength is 4.\n\nCheck L=3:\n\nSubstrings are 'abc', 'bcd'.\n\nNo duplicates. So move on.\n\nL=2: 'ab', 'bc', 'cd' — all unique.\n\nL=1: 'a', 'b', 'c', 'd' — all unique.\n\nSo output is 0.\n\nSample 2:\n\nInput: 'ababa'\n\nLength is 5.\n\nCheck L=4: substrings 'abab', 'baba' — no duplicates.\n\nL=3: substrings 'aba', 'bab', 'aba' — 'aba' appears twice. So return 3.\n\nSample 3:\n\nInput: 'zzz'.\n\nL=2: substrings 'zz' (positions 0-1 and 1-2). So both are 'zz'. So return 2.\n\nAnother test case: 'aaaaa'.\n\nFor L=4: substrings 'aaaa', 'aaaa' — returns 4.\n\nWait, but for L=4, the number of substrings is 2 (positions 0-3 and 1-4). Both are 'aaaa' — so yes.\n\nSo the algorithm works.\n\nSo now, how to implement this in Python.\n\nFirst, read the input string.\n\nThen, for L in range(len(s)-1, 0, -1):\n\n   generate all substrings of length L.\n\n   create a dictionary or a set to track their counts.\n\n   if any substring is found more than once, return L.\n\nIf none found, return 0.\n\nWait, but in code, for each L, I can iterate through the substrings and use a set. As soon as I find a duplicate, I can break and return.\n\nAlternatively, for each L, for each substring, check if it exists in the rest of the substrings.\n\nBut that might be O(L^2 * n) for each L, which is acceptable for n=100.\n\nSo the code steps:\n\nRead s.\n\nmax_len = 0\n\nfor L in range(len(s)-1, 0, -1):\n\n    seen = set()\n\n    for i in range(len(s) - L +1):\n\n        substr = s[i:i+L]\n\n        if substr in seen:\n\n            # found duplicate, return L\n\n            print(L)\n\n            exit()\n\n        seen.add(substr)\n\n    # after checking all substrs for this L, if none found, continue.\n\nAfter all L, if nothing found, return 0.\n\nWait, but for the first example 'abcd', the code will loop L=3, then 2, then 1.\n\nFor L=3, the substrings are 'abc' and 'bcd' — no duplicates.\n\nFor L=2: 'ab', 'bc', 'cd' — no duplicates.\n\nFor L=1: 'a', 'b', 'c', 'd' — no duplicates. So after all loops, return 0.\n\nYes.\n\nAnother test case: 'ababab'.\n\nFor L=5: substrings are 'ababa' and 'baba' — no duplicates.\n\nL=4: 'abab', 'baba' — no.\n\nL=3: 'aba', 'bab', 'aba' → 'aba' appears again. So return 3.\n\nSo the code works.\n\nBut what about the efficiency?\n\nFor each L, for each possible substring, we check if it's in the seen set.\n\nThis is O(n) per L, which is acceptable.\n\nSo, the code can be written as:\n\nRead s.\n\nn = len(s)\n\nif n == 0:\n\n    print(0)\n\nelse:\n\n    for L in range(n-1, 0, -1):\n\n        substrs = []\n\n        seen = set()\n\n        for i in range(n - L +1):\n\n            substr = s[i:i+L]\n\n            if substr in seen:\n\n                print(L)\n\n                exit()\n\n            seen.add(substr)\n\n    print(0)\n\nWait, but in the code above, for each L, we check all substrings and see if any is in the seen set. But the moment a duplicate is found, we can return L immediately.\n\nYes, that's correct.\n\nTesting this code:\n\nTest case 1: 'abcd' → no duplicates, returns 0.\n\nTest case 2: 'ababa' → at L=3, 'aba' is found again, returns 3.\n\nTest case 3: 'zzz' → at L=2, 'zz' appears again, returns 2.\n\nAnother test case: 'aaaaa' → for L=4, the substrings are 'aaaa' (positions 0-3 and 1-4). So during the loop, when i=0, substr is 'aaaa' added to seen. Then i=1, substr is 'aaaa' which is in seen → returns 4.\n\nWhat about a string like 'abba'? Let's see.\n\nPossible substrings of L=3:\n\n'abb' and 'bba' → no duplicates.\n\nL=2: 'ab', 'bb', 'ba'.\n\nAt i=0: 'ab' added.\n\ni=1: 'bb' added.\n\ni=2: 'ba' added. No duplicates.\n\nL=1: 'a', 'b', 'b', 'a' → when i=0, 'a' is added. i=1, 'b' added. i=2: 'b' is already present → returns 1.\n\nSo the code correctly returns 1.\n\nAnother test case: 'abcabc'.\n\nL=5: substrings 'abcab' and 'bcabc' → no duplicates.\n\nL=4: 'abca', 'bcab' → no.\n\nL=3: 'abc', 'cab', 'abc' → 'abc' is in seen after i=0. When i=2, substr is 'abc' → found. So returns 3.\n\nYes.\n\nSo the code seems to handle all cases.\n\nWait, but in the code, for L in range(n-1, 0, -1), which for n=5 is 4,3,2,1.\n\nBut when n=1, the code would run with L=0, but the loop doesn't execute. So for n=1, the code returns 0, which is correct because you can't have a substring that appears twice.\n\nAnother edge case: n=2, 'aa' → L=1: 'a' appears twice. So returns 1.\n\nYes.\n\nAnother case: 'a' → returns 0.\n\nSo the code handles all these cases.\n\nI think this approach is correct and efficient enough for the problem constraints.\n",
    "response": "To solve this problem, we need to determine the length of the longest substring that appears at least twice in a given string. The occurrences of the substring can overlap.\n\n### Approach\nThe approach involves checking all possible substrings of the given string starting from the longest possible down to the shortest. For each length, we generate all possible substrings and check if any of them appear more than once. The first length for which this condition is met is our answer.\n\n1. **Iterate Over Possible Substring Lengths**: Start from the maximum possible length (which is one less than the string length) and decrease down to 1.\n2. **Generate Substrings**: For each length, generate all possible substrings of that length.\n3. **Check for Duplicates**: Use a set to track substrings and check if any substring appears more than once.\n4. **Return Result**: If a duplicate substring is found, return the current length as the result. If no duplicates are found for any length, return 0.\n\n### Solution Code\n```python\ns = input().strip()\nn = len(s)\nif n <= 1:\n    print(0)\nelse:\n    for L in range(n-1, 0, -1):\n        seen = set()\n        for i in range(n - L + 1):\n            substr = s[i:i+L]\n            if substr in seen:\n                print(L)\n                exit()\n            seen.add(substr)\n    print(0)\n```\n\n### Explanation\n1. **Reading Input**: The input string is read and its length is determined.\n2. **Edge Case Handling**: If the string length is 1 or less, immediately return 0 since no substring can appear twice.\n3. **Loop Through Lengths**: Iterate from the longest possible substring length down to 1.\n4. **Generate Substrings**: For each length, generate all possible substrings and store them in a set to track seen substrings.\n5. **Check for Duplicates**: For each substring, check if it has been seen before. If a duplicate is found, print the current length and exit.\n6. **No Duplicates Found**: If no duplicates are found for any length, print 0.\n\nThis approach efficiently checks each possible substring length and ensures that we find the longest valid substring quickly, leveraging the constraints provided.",
    "ground_truth": "N/A",
    "extracted_answer": "s = input().strip()\nn = len(s)\nif n <= 1:\n    print(0)\nelse:\n    for L in range(n-1, 0, -1):\n        seen = set()\n        for i in range(n - L + 1):\n            substr = s[i:i+L]\n            if substr in seen:\n                print(L)\n                exit()\n            seen.add(substr)\n    print(0)",
    "score": 1,
    "metadata": {
        "prompt_token_count": 227,
        "completion_token_count": 478,
        "thoughts_token_count": 2401
    }
}