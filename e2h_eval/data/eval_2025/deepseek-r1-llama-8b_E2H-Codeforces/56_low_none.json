{
    "start": 1758278115.835972,
    "end": 1758278333.5204306,
    "start-formatted": "2025-09-19 19:35 KST",
    "end-formatted": "2025-09-19 19:38 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read it carefully.\n\nThe problem is called Guard Duty. The task is to determine whether it's possible to assign R Rebel spaceships to B bases in such a way that each base has exactly one guardian and each spaceship has exactly one assigned base. Also, the paths from each base to its assigned spaceship shouldn't intersect any other such paths. So, the key here is to ensure that the matching between spaceships and bases forms non-intersecting straight lines.\n\nHmm, how to model this? Well, the first thing that comes to mind is that this is a bipartite matching problem. We need to find a perfect matching between the two sets: rebels (spaceships) and bases. But not just any matching—only those that result in no two edges crossing.\n\nWait, but the condition about the paths not intersecting adds another layer. So even if there's a perfect matching, it might not satisfy the geometric constraint.\n\nSo the plan is:\n\n1. Check if R equals B. Because if R != B, it's impossible to have a perfect matching. So the first step is to check if they are equal. If not, output 'No'.\n\n2. Then, for all possible perfect matchings between the two sets, check if any of them results in non-intersecting paths.\n\nBut wait, how do we generate all possible perfect matchings? Since R and B can be up to 10, the maximum number of possibilities is 10! = 3,628,800 which is manageable. So generating all permutations where each base is matched to a unique spaceship is feasible.\n\nOnce we have a permutation, we need to check if any two edges (paths) in the matching cross each other.\n\nHow to check for path intersections?\n\nEach edge is a straight line between a spaceship (rebel) and a base (imperial). So for each pair of edges in the matching, we need to check if their connecting lines intersect anywhere except possibly at the endpoints.\n\nWait, but the problem says that no three points are colinear, and no two points coincide. So any intersection must be between two distinct edges.\n\nSo for each permutation (matching), we can represent the edges as lines, then check for any pair of lines whether they cross each other.\n\nWait, but how to represent lines and check for intersections? Each line connects a spaceship to a base. So for a given matching, we have B lines.\n\nWe need to check if any two lines among these B intersect in their interior; i.e., the intersection point is not an endpoint.\n\nSo, for each pair of lines (L1, L2) in the matching, determine if they intersect at a point that is not either of the two endpoints.\n\nIf any such pair exists, the matching is invalid. Otherwise, it's valid.\n\nSo the approach is:\n\n- For each possible permutation of the bases assigning to the spaceships (but wait, no—wait, the permutation is from spaceships to bases, right?), since each spaceship is assigned to exactly one base and vice versa.\n\nWait, the problem says: each base must have exactly one guardian and each spaceship exactly one assigned. So the assignment is a bijection from spaceships to bases. So for each possible bijection, we have a matching.\n\nSo the steps are:\n\n1. Read R and B. If R != B, output 'No' because a perfect matching is impossible.\n\n2. Read the R spaceship coordinates into a list.\n\n3. Read the B base coordinates into another list.\n\n4. Generate all possible bijections (permutations) from the spaceship indices to the base indices.\n\n5. For each permutation, create a list of edges (each edge is a line segment between a spaceship and a base).\n\n6. For each pair of edges in this list, check if their line segments intersect at a point that is not an endpoint.\n\n7. If for any permutation, none of the edges cross each other, then output 'Yes'. Otherwise, after checking all permutations, output 'No'.\n\nNow, how to implement this efficiently.\n\nFirst, generating all permutations: in Python, using itertools.permutations. But since we're matching R spaceships to B bases, but when R == B, it's a permutation of size B.\n\nWait, wait: the number of spaceships is R, the number of bases is B. So when R == B, each spaceship is matched to a base, and each base is matched to exactly one spaceship. So the permutation is for the R spaceships to choose which B bases they go to, but since R = B, it's a full permutation.\n\nBut in Python, itertools.permutations returns all possible orderings, but perhaps it's better to think in terms of selecting subsets.\n\nAlternatively, since the bases are to be matched one-to-one with the spaceships, the permutation represents the mapping from spaceships to bases. So for each possible permutation of the bases, we can assign the i-th spaceship to the permutation[i] base",
    "response": "To solve this problem, we need to determine if it is possible to assign Rebel spaceships to Imperial bases such that each base has exactly one guardian and each spaceship has exactly one assigned base. Additionally, the paths from each base to its assigned spaceship must not intersect.\n\n### Approach\n1. **Check for Perfect Matching**: First, check if the number of spaceships (R) is equal to the number of bases (B). If they are not equal, output \"No\" because a perfect matching is impossible.\n2. **Generate Permutations**: For each possible permutation of bases, which represents a bijection from spaceships to bases, generate the edges connecting spaceships to bases.\n3. **Check for Intersections**: For each permutation, check if any two edges (lines) connecting spaceships to bases intersect at a point other than their endpoints. If a permutation exists where no edges intersect, output \"Yes\". If none exist, output \"No\".\n\n### Solution Code\n```python\nimport sys\nfrom itertools import permutations\n\ndef readints():\n    return list(map(int, sys.stdin.readline().split()))\n\nR, B = map(int, sys.stdin.readline().split())\nspaceships = []\nfor _ in range(R):\n    x, y = map(int, sys.stdin.readline().split())\n    spaceships.append((x, y))\nbases = []\nfor _ in range(B):\n    x, y = map(int, sys.stdin.readline().split())\n    bases.append((x, y))\n\nif R != B:\n    print(\"No\")\n    sys.exit()\n\ndef lines_intersect(a1, a2, b1, b2):\n    x1, y1 = a1\n    x2, y2 = a2\n    x3, y3 = b1\n    x4, y4 = b2\n\n    denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)\n    if denominator == 0:\n        return False\n\n    u = (x1 * y3 + y1 * x4 - x2 * y3 - y2 * x4) / denominator\n    v = (x1 * y4 - y1 * x4 + x2 * y3 - y2 * x3) / denominator\n\n    return (u, v)\n\ndef segments_intersect(s1, s2):\n    a1, a2 = s1\n    b1, b2 = s2\n    line1 = (a1, a2)\n    line2 = (b1, b2)\n    return lines_intersect(a1, a2, b1, b2) and not (line_intersect_end(line1, line2))\n\ndef line_intersect_end(l1, l2):\n    a, b = l1\n    c, d = l2\n    if (c == a or c == b) and (d == a or d == b):\n        return True\n    return False\n\nfound = False\nfor perm in permutations(range(B), R):\n    edges = []\n    for i in range(R):\n        ship = spaceships[i]\n        base = bases[perm[i]]\n        edges.append( (ship, base) )\n    valid = True\n    for i in range(len(edges)):\n        for j in range(i+1, len(edges)):\n            e1 = edges[i]\n            e2 = edges[j]\n            if segments_intersect(e1, e2):\n                valid = False\n                break\n        if not valid:\n            break\n    if valid:\n        found = True\n        break\n\nprint(\"Yes\" if found else \"No\")\n```\n\n### Explanation\n- **Reading Input**: The code reads the number of spaceships and bases, followed by their coordinates.\n- **Perfect Matching Check**: It checks if the number of spaceships equals the number of bases. If not, it immediately outputs \"No\".\n- **Generating Permutations**: Using `itertools.permutations`, it generates all possible bijections from spaceships to bases.\n- **Checking Intersections**: For each permutation, it creates edges and checks if any two edges intersect. If a valid permutation is found where no edges intersect, it outputs \"Yes\". If no such permutation exists, it outputs \"No\".\n\nThis approach ensures that we efficiently check all possible assignments and verify the geometric constraint of non-intersecting paths.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom itertools import permutations\n\ndef readints():\n    return list(map(int, sys.stdin.readline().split()))\n\nR, B = map(int, sys.stdin.readline().split())\nspaceships = []\nfor _ in range(R):\n    x, y = map(int, sys.stdin.readline().split())\n    spaceships.append((x, y))\nbases = []\nfor _ in range(B):\n    x, y = map(int, sys.stdin.readline().split())\n    bases.append((x, y))\n\nif R != B:\n    print(\"No\")\n    sys.exit()\n\ndef lines_intersect(a1, a2, b1, b2):\n    x1, y1 = a1\n    x2, y2 = a2\n    x3, y3 = b1\n    x4, y4 = b2\n\n    denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)\n    if denominator == 0:\n        return False\n\n    u = (x1 * y3 + y1 * x4 - x2 * y3 - y2 * x4) / denominator\n    v = (x1 * y4 - y1 * x4 + x2 * y3 - y2 * x3) / denominator\n\n    return (u, v)\n\ndef segments_intersect(s1, s2):\n    a1, a2 = s1\n    b1, b2 = s2\n    line1 = (a1, a2)\n    line2 = (b1, b2)\n    return lines_intersect(a1, a2, b1, b2) and not (line_intersect_end(line1, line2))\n\ndef line_intersect_end(l1, l2):\n    a, b = l1\n    c, d = l2\n    if (c == a or c == b) and (d == a or d == b):\n        return True\n    return False\n\nfound = False\nfor perm in permutations(range(B), R):\n    edges = []\n    for i in range(R):\n        ship = spaceships[i]\n        base = bases[perm[i]]\n        edges.append( (ship, base) )\n    valid = True\n    for i in range(len(edges)):\n        for j in range(i+1, len(edges)):\n            e1 = edges[i]\n            e2 = edges[j]\n            if segments_intersect(e1, e2):\n                valid = False\n                break\n        if not valid:\n            break\n    if valid:\n        found = True\n        break\n\nprint(\"Yes\" if found else \"No\")",
    "score": 0,
    "metadata": {
        "prompt_token_count": 454,
        "completion_token_count": 903,
        "thoughts_token_count": 1025
    }
}