{
    "start": 1758289724.7531476,
    "end": 1758291236.7336986,
    "start-formatted": "2025-09-19 22:48 KST",
    "end-formatted": "2025-09-19 23:13 KST",
    "gpu": 2,
    "pid": 30,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# TV Game\n\nThere is a new TV game on BerTV. In this game two players get a number A consisting of 2n digits. Before each turn players determine who will make the next move. Each player should make exactly n moves. On it's turn i-th player takes the leftmost digit of A and appends it to his or her number Si. After that this leftmost digit is erased from A. Initially the numbers of both players (S1 and S2) are «empty». Leading zeroes in numbers A, S1, S2 are allowed. In the end of the game the first player gets S1 dollars, and the second gets S2 dollars.One day Homer and Marge came to play the game. They managed to know the number A beforehand. They want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize. Help them.\n\n## Input\nThe first line contains integer n (1 ≤ n ≤ 18). The second line contains integer A consisting of exactly 2n digits. This number can have leading zeroes.\n\n## Output\nOutput the line of 2n characters «H» and «M» — the sequence of moves of Homer and Marge, which gives them maximum possible total prize. Each player must make exactly n moves. If there are several solutions, output any of them.\n\n## Example\n### Input\n['2\\n1234', '2\\n9911']\n\n### Output\n['HHMM', 'HMHM']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read it carefully.\n\nThe problem is about a TV game where two players, Homer and Marge, take turns picking digits from a string A. The string A has exactly 2n digits. They each make exactly n moves. On each turn, the current player takes the leftmost digit of A, appends it to their number, and then that digit is removed from A. The goal is to find the sequence of moves (H or M) that maximizes the sum of both players' numbers. And if there are multiple such sequences, any can be outputted.\n\nHmm, right. So, for each step, the player whose turn it is adds the leftmost digit to their own number. We need to decide the order of H and M such that the total is as large as possible.\n\nLet me think about how to model this. Since each move depends on choosing the next digit, which affects the future options, it's a dynamic programming problem. But wait, n can be up to 18, so 2n is 36. The number of states could be manageable.\n\nWait, what defines the state here? The current position in the string, how many moves each player has made so far. Because at each step, we choose whether it's Homer or Marge's turn, and then take the first digit.\n\nWait, but the selection isn't arbitrary. It's determined by the initial arrangement and the choices made. So the key is to model the state as the current index in the string and the number of moves each player has made so far.\n\nYes. So, the state can be represented by (i, h, m), where i is the current position in the string A, h is the number of moves Homer has made, and m is the number for Marge. Since each must make exactly n moves, the maximum h is n, same for m. But since h + m = i, because each move consumes one digit. Wait, no. Because each move is taking one digit, so the total digits taken would be i. Since 2n is the length, i ranges from 0 to 2n.\n\nWait, the initial state is i=0, h=0, m=0. Each move increases either h or m by 1, and i increases by 1. When i reaches 2n, we're done.\n\nOur goal is to maximize the sum of the numbers formed by S1 and S2.\n\nBut how do we compute the sum? For each step, when a digit is added to S1 or S2, it contributes to their respective number. So the contribution of each digit depends on the position it is placed in S1 or S2.\n\nWait, the numbers are built digit by digit. So the first digit picked is the most significant digit for each player. So, for example, if the first digit is 9, assigning it to S1 gives more value than assigning it to S2.\n\nSo the key is to assign higher digits to the earlier positions of S1 and S2.\n\nBut the problem is that each choice affects the subsequent choices. So it's a matter of selecting for each step whether to take the digit for H or M, such that the overall sum is maximized.\n\nThis seems like a problem that can be solved with dynamic programming. The state will be the current index and how many H and M moves have been made so far. Then, for each state, we can try both options (assign to H or M) and choose the one that gives the maximum total.\n\nBut wait, considering the size of the problem: n can be up to 18, so 2n is 36. The number of possible states is 36 * (n+1) * (n+1). For n=18, that's 36*19*19 = around 13,000, which is manageable.\n\nEach state needs to track the current sum of S1 and S2. Hmm, but the sum can be very large. For 36 digits, each up to 9, the maximum sum is 999...99 (36 times), which is a huge number. Storing the exact sum might not be feasible due to memory constraints.\n\nWait, but perhaps we don't need to store the exact sum. Instead, for each state, we can keep track of the maximum possible sum achievable from that state onwards. That way, we can avoid storing all possible sums, just keeping the maximum.\n\nSo the DP approach would work as follows:\n\n- dp[i][h][m] represents the maximum sum achievable starting from index i, with h moves assigned to H and m moves assigned to M.\n\nFor each state (i, h, m), we can transition to (i+1, h+1, m) by assigning the next digit to H, or to (i+1, h, m+1) by assigning it to M.\n\nThe value of dp[i][h][m] would be the sum of the digits chosen so far plus the maximum of the two transitions.\n\nWait, but how do we calculate the contribution of the current digit to the sum? Because when we assign the digit to H, it's added to the h-th position of S1. Similarly for M.\n\nAh, right. So for each digit, its contribution is determined by the number of digits already in S1 and S2 when it's added.\n\nWait, let's say that at the current step, when processing digit d, the next digit is added to either S1 or S2. The value contributed by d is d multiplied by 10^k, where k is the current length of the respective number before adding d.\n\nFor example, suppose S1 has h digits so far, then adding d to S1 would make it h+1 digits, contributing d * 10^h.\n\nSimilarly for S2: if m digits are already present, adding d to S2 would contribute d * 10^m.\n\nSo, the contribution depends on whether we choose H or M.\n\nTherefore, for each state (i, h, m), when we process the digit A[i], the next digit is A[i], and we can choose to assign it to H or M.\n\nSo, for each state, the next digit is A[i]. So, the current digit is fixed based on the state's i.\n\nWait, no. Because in each step, we process the next digit, which is A[i], and then move to i+1.\n\nSo, in the DP transition, for state (i, h, m), the next digit is A[i], and the choice is to add it to H's number or M's.\n\nThus, the contribution for adding to H is d * 10^h, and to M is d * 10^m.\n\nThen, for each state, we can compute the maximum sum by choosing the best option between assigning to H or M.\n\nSo, the recurrence relation would be:\n\ndp[i][h][m] = max(\n    (d * 10^h) + dp[i+1][h+1][m],\n    (d * 10^m) + dp[i+1][h][m+1]\n)\n\nAnd the base case is when i == 2n, the sum is zero.\n\nWait, but when i reaches 2n, the process is complete. So the base case is when i == 2n, return 0.\n\nSo, the DP can be memoized as follows.\n\nNow, the challenge is to implement this efficiently.\n\nBut for n=18, 36 steps, and h and m up to 18 each, the number of states is 36 * 19 * 19 = 136, 296? Wait, 36 * 19 *19 is 36 * 361 = 12996. That's manageable.\n\nBut how do we represent the DP table? As a 3-dimensional array.\n\nIn Python, for 2n=36, the indices go from 0 to 35.\n\nWe can precompute the powers of 10 up to 18, since h and m can be up to 18. So 10^0 to 10^18.\n\nWait, but in the problem statement, S1 and S2 can have leading zeros. So the length of S1 can be up to n, same for S2.\n\nSo, for each digit assignment, the exponent is determined by the current length of the respective number.\n\nSo, in code, for each state (i, h, m), the current digit is A[i], and the choice is to add to H or M.\n\nSo, for each state, we can compute the two possible transitions and take the maximum.\n\nBut for memoization, perhaps using a dictionary or a memo table is better.\n\nAlternatively, since the state is small, a recursive approach with memoization can be used.\n\nBut in Python, recursive approaches can hit stack limits for large n. So perhaps an iterative DP approach is better.\n\nSo, the plan is:\n\n1. Precompute the powers of 10 up to 18, since h and m can be up to 18.\n\n2. Read the input, which is the string A of 2n digits.\n\n3. Initialize a 3D DP array, with dimensions (2n+1) x (n+1) x (n+1). The value is the maximum sum achievable from that state.\n\n4. Fill the DP array from the end backwards.\n\n5. For each state (i, h, m), compute the maximum between assigning the current digit to H or M.\n\n6. Once the DP is filled, reconstruct the sequence of moves (H or M) that leads to the maximum sum.\n\nWait, but reconstructing the path is another issue. How do we track which choices were made?\n\nSo, perhaps during the DP filling, we can also track the path, i.e., for each state, record whether the last choice was H or M. Then, once the DP is filled, we can backtrack from the final state (i=2n, h=n, m=n) to determine the sequence.\n\nBut this requires storing additional information, which may complicate things.\n\nAlternatively, since the DP is filled in a certain order, perhaps we can use a parent pointer approach.\n\nBut for now, let's focus on filling the DP first.\n\nLet me outline the steps in code:\n\n- Precompute pow10 up to 18.\n\npow10 = [1] * (n+1)\nfor i in range(1, n+1):\n    pow10[i] = pow10[i-1] * 10\n\nBut wait, for h=0, the length is 0, so 10^0 is 1, which is correct.\n\n- Read A as a string.\n\nA = input().strip()\n\n- Initialize the DP table. Since in Python, 3D arrays can be represented as a list of lists of lists.\n\nBut for efficiency, perhaps a memoization function with lru_cache could be used. However, since the state variables include i, h, m, which are all integers, and n is up to 18, recursion depth would be up to 36, which is acceptable.\n\nWait, but even with n=18, the recursion depth is 36, which is manageable.\n\nSo, perhaps a memoization-based approach is easier to write.\n\nBut let's think about how to structure the function.\n\nDefine a function that, given the current index i, the number of H moves h, and M moves m, returns the maximum sum possible.\n\nIf i == 2n: return 0.\n\nElse, get the current digit d = A[i].\n\nCompute the contribution of adding d to H: d * (10^h) plus the result of recursively calling with i+1, h+1, m.\n\nCompute the contribution of adding d to M: d * (10^m) plus the result of recursively calling with i+1, h, m+1.\n\nReturn the maximum of the two.\n\nBut wait, this would be a recursive solution with memoization.\n\nYes.\n\nSo, implementing this function with memoization is straightforward.\n\nOnce the maximum sum is computed, the next step is to reconstruct the sequence of H and M.\n\nReconstruction is needed because we need to output the sequence of moves.\n\nSo, the problem is, after computing the maximum sum, we need to determine the choices made at each step.\n\nHow?\n\nWe can track the choices made by backtracking through the DP function calls.\n\nBut in the memoization approach, the function only knows the maximum sum, not the path taken to reach it.\n\nSo, perhaps we can modify the function to also return the sequence of choices that led to the maximum sum.\n\nAlternatively, during the DP computation, for each state, we can store not only the maximum sum but also the choice (H or M) that was made to achieve it.\n\nBut this complicates the DP storage.\n\nAlternatively, once the DP is filled, we can start from the end and reconstruct the path step by step.\n\nSo, the steps would be:\n\n- After filling the DP table, we know that the optimal choice is to assign the last digit to either H or M, whichever gave the maximum sum.\n\nWait, but the DP stores the maximum sum, but not the path. So, perhaps during the DP fill, for each state, we can also store the choice (H or M) that was optimal.\n\nSo, modifying the DP to store two things: the maximum sum and the best action (H or M) that achieves it.\n\nThis way, during the reconstruction, we can follow the path.\n\nSo, let's adjust the DP to have two tables: dp_sum[i][h][m] and dp_choice[i][h][m], which indicates whether the last digit was assigned to H or M.\n\nSo, the recurrence becomes:\n\nd = A[i]\n\noption1 = d * (10^h) + dp_sum[i+1][h+1][m]\noption2 = d * (10^m) + dp_sum[i+1][h][m+1]\n\nif option1 > option2:\n    dp_sum[i][h][m] = option1\n    dp_choice[i][h][m] = 'H'\nelse:\n    dp_sum[i][h][m] = option2\n    dp_choice[i][h][m] = 'M'\n\nThen, to reconstruct the sequence, we can start from i=2n, h=n, m=n.\n\nWait, no. Because when i=2n, the process is complete, so the last digit is processed at i=2n-1. So, the starting point for reconstruction is i=2n-1, h=..., etc.\n\nWait, the base case is when i=2n, which returns 0 and no choice. So the reconstruction starts from i=2n-1, and goes down to i=0.\n\nWait, but the initial state is i=0, h=0, m=0.\n\nSo, for reconstruction:\n\ncurrent_i = 2n - 1\ncurrent_h = 0\ncurrent_m = 0\n\nBut wait, no. Because the initial state is (i=0, h=0, m=0). So the first choice is to assign the first digit to H or M.\n\nWait, perhaps the initial state is (i=0, h=0, m=0), and the first digit is A[0].\n\nSo, during reconstruction, we start from the end (i=2n), which is the base case.\n\nWait, perhaps I'm getting confused.\n\nLet me clarify:\n\nAt each step, the state is (i, h, m), representing that we've processed i digits, and H has made h moves, M has made m moves.\n\nThe process continues until i reaches 2n.\n\nSo, the initial state is (0, 0, 0).\n\nThe last step is when i is 2n-1, because after that, i becomes 2n, and the process stops.\n\nSo, to reconstruct the path, we can start from i=2n-1, h = ..., m = ... ?\n\nWait, no. Wait, when i=2n-1, the next step is i=2n, which is the base case.\n\nSo, the last decision is made at i=2n-1.\n\nSo, for reconstruction, we start at i=2n-1, h and m values that correspond to the last possible step.\n\nWait, but how do we know the h and m values at i=2n-1?\n\nBecause, the total number of moves is 2n, and the last move is the 2n-th digit.\n\nWait, perhaps the initial state is i=0, h=0, m=0.\n\nAfter 2n steps, i=2n, h=n, m=n.\n\nSo, during reconstruction, we start from i=2n, but that's the base case. So, to reconstruct the path, we need to go back from i=2n-1 to i=0.\n\nSo, the algorithm is:\n\nInitialize i = 2n-1, h = n-1, m = n-1? Or wait, perhaps not.\n\nWait, during the DP, the state (i, h, m) is such that h + m = i.\n\nBecause each move increments either h or m by 1.\n\nSo, for i=0, h=0, m=0.\n\nFor i=1, h can be 0 and m=1, or h=1 and m=0.\n\nSo, for any state (i, h, m), h + m = i.\n\nThus, for i=2n-1, h + m = 2n-1.\n\nBut the total number of moves is 2n. So, when i=2n-1, the next move will be the 2n-th digit, which is i=2n.\n\nSo, to reconstruct the path, we can start from i=2n-1, and determine whether the last digit was assigned to H or M.\n\nThen, we can proceed to i=2n-2, and so on.\n\nBut wait, how do we know the h and m values for each i?\n\nBecause for each state (i, h, m), h + m = i.\n\nSo, for i=2n-1, h + m = 2n-1.\n\nBut since the total moves are n each, the final state is i=2n, h=n, m=n.\n\nSo, the last step is i=2n-1, which leads to i=2n.\n\nSo, during reconstruction:\n\ncurrent_i = 2n-1\ncurrent_h = n-1  ? Because h + m = current_i, but h can be anything as long as it's less than or equal to n.\n\nWait, perhaps not. Because in the state (2n-1, h, m), h + m = 2n-1.\n\nBut the final state is (2n, n, n), so the previous state must be (2n-1, n-1, n), or (2n-1, n, n-1).\n\nSo, during reconstruction, for each step, we look at the state (current_i, h, m), and determine whether the last digit was assigned to H or M.\n\nWait, but how do we know the h and m for the previous step?\n\nNo, wait, during the DP, for each state, we track the best choice (H or M) that led to the maximum sum.\n\nSo, during reconstruction, starting from the end (i=2n-1), we can see whether the last digit was assigned to H or M, and then proceed to the previous state.\n\nBut wait, perhaps the way to reconstruct is to build the sequence in reverse.\n\nSo, let's see:\n\nWe start with the last digit (i=2n-1), and decide whether it was assigned to H or M.\n\nThen, for each step back, we subtract 1 from h or m accordingly.\n\nBut since h + m = i, and the next step is i-1, we can find h and m for the previous step.\n\nSo, the steps would be:\n\nsequence = []\ni = 2n - 1\nh_prev = ?\nm_prev = ?\n\nWait, perhaps we can reconstruct the path by iterating from i=2n-1 down to 0.\n\nAt each step:\n\n- Check the choice (H or M) for state (i, h, m).\n- Add 'H' or 'M' to the sequence.\n- Update h and m to (h-1, m) if the choice was H, or (h, m-1) if M.\n\nWait, but how do we get the initial h and m for i=2n-1?\n\nBecause for i=2n-1, the sum h + m = 2n-1.\n\nBut in the final state, h = n and m =n, so for i=2n-1, h could be n-1 and m =n, or h =n and m =n-1.\n\nWhich one is it?\n\nHmm, perhaps during the DP, for each state, the choice is stored, but not the h and m.\n\nSo, perhaps during the reconstruction, we can find the h and m for each i by knowing that for i, h + m = i.\n\nSo, during reconstruction, for each state (i, h, m), the next state is (i+1, h+1, m) if H was chosen, or (i+1, h, m+1) if M was chosen.\n\nSo, during the reconstruction, we can start from (2n, n, n) as the end state, and then go back to (2n-1, h, m).\n\nWait, perhaps the initial state for reconstruction is (2n, n, n). But that's the base case, which doesn't have a choice. So, the previous state is (2n-1, h', m').\n\nWait, perhaps the reconstruction starts from i=2n-1, h = n-1, m =n.\n\nBecause, when you assign the last digit to H, h becomes n, but that's for i=2n. Wait, maybe I'm getting mixed up.\n\nAlternatively, perhaps the way to handle this is to realize that for each state (i, h, m), the next state is (i+1, h+1, m) if H was chosen, or (i+1, h, m+1) if M was chosen.\n\nSo, during reconstruction, starting from (2n, n, n), which is the end, we can look back to (2n-1, h', m').\n\nBut how?\n\nWait, perhaps the way to reconstruct is to start from (2n, n, n), and then for each step, go back to the previous state.\n\nWait, but (2n, n, n) is the end, so the previous step is (2n-1, h, m), where either h =n-1 and m =n, or h =n and m =n-1.\n\nSo, during reconstruction, for each step, we determine whether the last choice was H or M, and then update h and m accordingly.\n\nBut without knowing the previous state, this is tricky.\n\nAn alternative approach is to track the path during the DP computation.\n\nSo, during the DP, for each state, we can store the choice that was made to reach the maximum sum.\n\nSo, for each state (i, h, m), we store whether the last digit was assigned to H or M.\n\nThen, during reconstruction, we can start from (2n-1, h, m) and trace back.\n\nBut how?\n\nWait, perhaps the way to reconstruct the sequence is as follows:\n\n1. Start from i=2n-1, h = ?, m = ?.\n\nBut since h + m = i, and in the final state (i=2n), h =n, m =n, then for i=2n-1, h + m = 2n-1.\n\nSo, if the last digit was assigned to H, then the previous state is (2n-1, h_prev, m_prev) where h_prev = h_current -1, m_prev = m_current.\n\nWait, perhaps it's better to think in terms of the choice.\n\nIf the last digit was assigned to H, then the previous state is (i-1, h-1, m).\n\nSimilarly, if it was assigned to M, the previous state is (i-1, h, m-1).\n\nSo, for each step during reconstruction, we can determine whether the last digit was H or M, and then update h and m accordingly.\n\nThus, the steps are:\n\n- Initialize i = 2n-1, h = n-1, m =n.\n\nWait, because if the last digit was assigned to H, then h was increased by 1 to become n.\n\nSimilarly, if it was assigned to M, then m was increased by 1 to become n.\n\nSo, for i=2n-1, the possible h is n-1, and m is n, or h is n, m is n-1.\n\nBut how do we know which one is the case?\n\nWe can check the choice stored in dp_choice[i][h][m].\n\nWait, but in the state (i, h, m), the choice tells us whether the current digit was assigned to H or M.\n\nSo, for i=2n-1, the choice is stored in dp_choice[i][h][m], and then we can determine whether to subtract 1 from h or m.\n\nThus, the reconstruction can be done as follows:\n\nsequence = []\ni = 2n -1\nh = n-1  # assume that the last digit was assigned to H\nm = n\n\n# Now, check if the choice was H or M\nchoice = dp_choice[i][h][m]\n\nif choice == 'H':\n    sequence.append('H')\n    # The previous state is (i-1, h-1, m)\n    i -= 1\n    h -= 1\nelse:\n    sequence.append('M')\n    # The previous state is (i-1, h, m-1)\n    i -= 1\n    m -= 1\n\nWait, but how do we know the initial h and m for i=2n-1?\n\nBecause for i=2n-1, the sum h + m = 2n-1.\n\nBut in the final state, h =n, m =n, so for i=2n-1, the sum is 2n-1, so h + m = 2n-1.\n\nSo, for i=2n-1, possible h and m are:\n\nh =n-1, m =n → sum 2n-1.\n\nOR\n\nh =n, m =n-1 → sum 2n-1.\n\nSo, the initial guess is h =n-1, m =n.\n\nBut this is an assumption; perhaps it's better to find h and m such that h + m = i, and that h <=n, m <=n.\n\nWait, but during the DP, for each state (i, h, m), the transitions are to (i+1, h+1, m) or (i+1, h, m+1). So, for i=2n-1, the previous state can be either (2n-2, h-1, m) or (2n-2, h, m-1).\n\nSo, during reconstruction, we can start with h =n-1 and m =n, then check whether the choice was H or M.\n\nIf it was H, then the previous state is (2n-2, n-2, n).\n\nIf it was M, the previous state is (2n-2, n-1, n-1).\n\nWait, perhaps this is getting complicated.\n\nAn alternative approach is to reconstruct the sequence step by step, starting from i=2n-1, and for each step, determine whether the last digit was H or M, and then adjust h and m accordingly.\n\nBut in code, how can we handle this?\n\nI think the best way is to precompute the DP tables, including the choice, and then perform a loop from i=2n-1 down to 0, appending the choice each time.\n\nWait, but for each i, how do we get h and m?\n\nAlternatively, perhaps during the reconstruction, for each i, we can compute the possible h and m based on the previous step.\n\nBut perhaps it's easier to write a helper function that, given i, returns the best choice for that state.\n\nBut I'm not sure.\n\nAlternatively, perhaps the DP can be memoized with a cache, and during the reconstruction, for each i, we can query the best choice.\n\nBut again, the problem is that the DP depends on the current state, which includes h and m.\n\nSo, perhaps the way to proceed is:\n\n- Precompute the DP tables for dp_sum and dp_choice.\n\n- Then, for the reconstruction, start from i=2n-1, and with h and m being such that h + m = i.\n\nBut how to find the initial h and m for i=2n-1?\n\nWait, perhaps the initial h and m are n-1 and n, or n and n-1.\n\nSo, in code, for each possible initial h and m, we can check which one gives the correct sum.\n\nBut that's computationally expensive.\n\nAlternatively, perhaps the initial h and m can be determined by checking which of the two possibilities (h =n-1, m =n) or (h =n, m =n-1) gives the correct choice.\n\nBut perhaps in practice, for i=2n-1, the choice is stored in dp_choice[i][n-1][n], or dp_choice[i][n][n-1}.\n\nSo, during reconstruction, we can start with i=2n-1, and h and m are such that h + m = 2n-1.\n\nBut in code, perhaps the following steps:\n\nInitialize i = 2n-1\n\nh = n-1\n\nm = n\n\nThen, check if dp_choice[i][h][m] exists.\n\nIf yes, append the choice to the sequence.\n\nThen, set i = i-1, and depending on the choice, adjust h and m.\n\nElse, try h =n, m =n-1.\n\nBut this seems hacky.\n\nAlternatively, perhaps in the DP, for each i, the choice is stored, and during reconstruction, for each i, we can query the choice for (i, h, m) where h + m = i.\n\nBut again, the code is getting complex.\n\nPerhaps, instead of trying to manage the DP tables, I can think of the problem differently.\n\nEach digit is added to either S1 or S2. The order in which the digits are added matters for their contribution.\n\nSo, the problem is to assign each digit to either S1 or S2 in such a way that the sum is maximized.\n\nEach digit is added to either S1 or S2, and the earlier digits have higher exponents.\n\nThus, the optimal strategy is to assign the largest possible digits to the earliest possible positions in S1 and S2.\n\nBut S1 and S2 have n digits each. So, the first n digits should be distributed between S1 and S2 in a way that maximizes the sum.\n\nWait, perhaps the optimal assignment is to select the top n digits to be the first digits of S1 and S2, but that's probably not correct.\n\nAlternatively, perhaps the digits should be divided into two groups, each of size n, such that the sum of their contributions is maximized.\n\nBut how?\n\nAnother approach: for each digit, assign it to the player who can give it the highest possible multiplier.\n\nSo, for the earliest digits, assign them to S1 or S2, whichever gives a higher contribution.\n\nBut the problem is that the assignments are interdependent. Once a digit is assigned to S1, it's no longer available for S2.\n\nSo, perhaps a greedy approach won't work, but dynamic programming is needed.\n\nThus, the initial approach with DP is the way to go.\n\nSo, let's proceed.\n\nImplementing the DP with memoization.\n\nIn Python, functions can't modify global variables, but for memoization, using lru_cache is suitable.\n\nBut for large n, the recursion depth may be a problem. But n is up to 18, so 2n is 36 steps. So, the recursion depth is 36, which is manageable.\n\nSo, the plan is:\n\n1. Read n and A.\n\n2. Precompute pow10[0..n].\n\n3. Implement a recursive function with memoization to compute the maximum sum for a given i, h, m.\n\n4. During the DP, for each state, compute the maximum sum by trying both possible choices.\n\n5. After computing the maximum sum, reconstruct the path by backtracking through the DP.\n\nSo, in code:\n\nImplement a memoized function:\n\nfrom functools import lru_cache\n\ndef max_sum(i, h, m):\n    if i == 2*n:\n        return 0\n    if (i, h, m) in memo:\n        return memo[(i, h, m)]\n    d = A[i]\n    option1 = int(d) * (10 ** h) + max_sum(i+1, h+1, m)\n    option2 = int(d) * (10 ** m) + max_sum(i+1, h, m+1)\n    if option1 >= option2:\n        res = option1\n        choice = 'H'\n    else:\n        res = option2\n        choice = 'M'\n    memo[(i, h, m)] = res\n    return res\n\nBut wait, this function doesn't track the choices, so it only returns the maximum sum.\n\nThus, for reconstruction, we need to track the choices made.\n\nSo, perhaps we can modify the function to return both the sum and the choice.\n\nBut that complicates the memoization.\n\nAlternatively, we can have two separate memo tables: one for the sum, and another for the choice.\n\nBut in Python, using lru_cache may not be suitable for mutable types, but in this case, the state is (i, h, m), which are integers, so it's fine.\n\nSo, perhaps the function can be modified to return the maximum sum and the choice.\n\nBut this is not straightforward, because the choice depends on the subproblems.\n\nAlternatively, perhaps during the DP computation, for each state, we can store both the sum and the choice.\n\nBut with the help of memoization, perhaps the function can return both.\n\nWait, but the function needs to return the maximum sum, and the choice is part of that decision.\n\nSo, perhaps the function can return a tuple (sum, choice), and in the memoization, we store these tuples.\n\nBut how?\n\nLet me think:\n\ndef dfs(i, h, m):\n    if i == 2n:\n        return (0, None)\n    if (i, h, m) in memo:\n        return memo[(i, h, m)]\n    d = A[i]\n    option1_sum = int(d) * (10 ** h) + dfs(i+1, h+1, m)[0]\n    option1_choice = 'H'\n    option2_sum = int(d) * (10 ** m) + dfs(i+1, h, m+1)[0]\n    option2_choice = 'M'\n    if option1_sum > option2_sum:\n        res_sum = option1_sum\n        res_choice = option1_choice\n    else:\n        res_sum = option2_sum\n        res_choice = option2_choice\n    memo[(i, h, m)] = (res_sum, res_choice)\n    return (res_sum, res_choice)\n\nThis way, for each state, we store both the maximum sum and the choice.\n\nBut the memoization in Python can handle tuples as keys.\n\nSo, in code, this can be implemented.\n\nOnce the maximum sum is computed, the next step is to reconstruct the sequence.\n\nTo do this, we can use the memo table to backtrack from the end.\n\nSo, the steps are:\n\n- Compute the maximum sum using dfs(0, 0, 0).\n\n- Then, reconstruct the sequence by starting from i=2n-1, h =n-1, m =n.\n\nWait, but how do we get the initial h and m for i=2n-1?\n\nBecause for i=2n-1, the state is (i, h, m) where h + m = i.\n\nIn the final state (i=2n), h =n, m =n.\n\nThus, for i=2n-1, the state could be (2n-1, n-1, n) or (2n-1, n, n-1).\n\nSo, during reconstruction, we can try both possibilities and see which one leads to the correct sum.\n\nBut this may not be efficient.\n\nAlternatively, perhaps during reconstruction, for each step, we can determine whether the choice was H or M by checking the sum.\n\nWait, perhaps not.\n\nAn alternative approach is to start from i=2n-1, and for each possible (h, m), check if (i, h, m) is in the memo, and whether the choice leads to the correct sum.\n\nBut perhaps it's easier to implement a loop that, for each i from 2n-1 down to 0, determines the choice and appends it to the sequence.\n\nBut how to find the correct h and m for each i.\n\nWait, perhaps the initial h and m for i=2n-1 can be derived from the fact that h + m = 2n-1.\n\nSo, for i=2n-1, h can be anything from 0 to min(n, 2n-1).\n\nBut since h + m = i, and the final state is (2n, n, n), the previous state must be (2n-1, h, m) where h =n-1, m =n, or h =n, m =n-1.\n\nSo, during reconstruction:\n\nstart with i = 2n-1\n\nh =n-1\n\nm =n\n\nthen, check if (i, h, m) is a valid state.\n\nIf the choice stored in the memo is 'H', then the last digit was assigned to H, so the next state is (i-1, h-1, m).\n\nElse, it was assigned to M, so the next state is (i-1, h, m-1).\n\nBut how do we know whether the choice was 'H' or 'M' for (i, h, m)?\n\nWe can access the memo for (i, h, m) and get the choice.\n\nSo, the reconstruction code would",
    "response": "To solve this problem, we need to determine the optimal sequence of moves for Homer and Marge in a TV game such that their total prize is maximized. The game involves taking turns to pick digits from a given string, and each player must make exactly `n` moves.\n\n### Approach\nThe problem can be efficiently solved using dynamic programming (DP) with memoization. The key idea is to use a recursive function with memoization to explore all possible sequences of moves and keep track of the maximum sum achievable at each step.\n\n1. **Dynamic Programming with Memoization**: We define a recursive function `dfs(i, h, m)` that returns the maximum sum achievable starting from the `i-th` digit, with `h` moves made by Homer and `m` moves by Marge. The function uses memoization to store results of previously computed states to avoid redundant calculations.\n\n2. **State Representation**: Each state is represented by `(i, h, m)`, where `i` is the current position in the string, and `h` and `m` are the number of moves made by Homer and Marge, respectively. The function computes the maximum sum by considering both possible moves (assigning the current digit to Homer or Marge) and choosing the one that yields the higher sum.\n\n3. **Reconstruction of Moves**: After computing the maximum sum, we reconstruct the sequence of moves by backtracking from the final state `(2n, n, n)` to the initial state `(0, 0, 0)`. This involves checking the choice made at each step and adjusting the counts of moves accordingly.\n\n### Solution Code\n```python\nfrom functools import lru_cache\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    n = int(input[0])\n    A = input[1].strip()\n    \n    pow10 = [1] * (n + 1)\n    for i in range(1, n + 1):\n        pow10[i] = pow10[i - 1] * 10\n    \n    @lru_cache(maxsize=None)\n    def dfs(i, h, m):\n        if i == len(A):\n            return (0, None)\n        \n        d = A[i]\n        option1_sum = int(d) * pow10[h] + dfs(i + 1, h + 1, m)[0]\n        option1_choice = 'H'\n        \n        option2_sum = int(d) * pow10[m] + dfs(i + 1, h, m + 1)[0]\n        option2_choice = 'M'\n        \n        if option1_sum >= option2_sum:\n            return (option1_sum, option1_choice)\n        else:\n            return (option2_sum, option2_choice)\n    \n    total_sum, choice = dfs(0, 0, 0)\n    \n    sequence = []\n    i = len(A) - 1\n    h = n - 1\n    m = n\n    \n    while i >= 0:\n        current_sum, current_choice = dfs(i, h, m)\n        sequence.append(current_choice)\n        if current_choice == 'H':\n            h -= 1\n        else:\n            m -= 1\n        i -= 1\n    \n    print(''.join(reversed(sequence)))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input consists of an integer `n` and a string `A` of length `2n`. These are read and processed to initialize the necessary variables.\n\n2. **Precompute Powers of 10**: Since each digit's contribution depends on its position, we precompute powers of 10 up to `n` to efficiently calculate contributions during the DP step.\n\n3. **Recursive Function with Memoization**: The `dfs` function is defined to compute the maximum sum starting from position `i` with `h` and `m` moves. It uses memoization to store results of previously computed states.\n\n4. **Backtracking for Move Reconstruction**: After computing the maximum sum, the function backtracks from the final state to reconstruct the sequence of moves. This is done by checking the choice made at each step and adjusting the move counts accordingly.\n\nThis approach ensures that we explore all possible sequences of moves efficiently and find the one that maximizes the total prize for Homer and Marge.",
    "ground_truth": "N/A",
    "extracted_answer": "from functools import lru_cache\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    n = int(input[0])\n    A = input[1].strip()\n    \n    pow10 = [1] * (n + 1)\n    for i in range(1, n + 1):\n        pow10[i] = pow10[i - 1] * 10\n    \n    @lru_cache(maxsize=None)\n    def dfs(i, h, m):\n        if i == len(A):\n            return (0, None)\n        \n        d = A[i]\n        option1_sum = int(d) * pow10[h] + dfs(i + 1, h + 1, m)[0]\n        option1_choice = 'H'\n        \n        option2_sum = int(d) * pow10[m] + dfs(i + 1, h, m + 1)[0]\n        option2_choice = 'M'\n        \n        if option1_sum >= option2_sum:\n            return (option1_sum, option1_choice)\n        else:\n            return (option2_sum, option2_choice)\n    \n    total_sum, choice = dfs(0, 0, 0)\n    \n    sequence = []\n    i = len(A) - 1\n    h = n - 1\n    m = n\n    \n    while i >= 0:\n        current_sum, current_choice = dfs(i, h, m)\n        sequence.append(current_choice)\n        if current_choice == 'H':\n            h -= 1\n        else:\n            m -= 1\n        i -= 1\n    \n    print(''.join(reversed(sequence)))\n\nif __name__ == \"__main__\":\n    main()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 410,
        "completion_token_count": 901,
        "thoughts_token_count": 8193
    }
}