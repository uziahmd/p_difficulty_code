{
    "start": 1758278762.0956686,
    "end": 1758279131.7329888,
    "start-formatted": "2025-09-19 19:46 KST",
    "end-formatted": "2025-09-19 19:52 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read it carefully.\n\nThe problem is about restoring the number of laughy mushrooms on each lawn based on the information from some roads. Each road gives two numbers: the GCD and LCM of the two lawns it connects. My task is to determine if there's a possible arrangement of mushroom counts that satisfies all these constraints. If yes, output the counts; otherwise, output NO.\n\nHmm. So each edge between two nodes (lawns) has a GCD and LCM. For each such edge, the two numbers (GCD and LCM) must satisfy certain conditions based on the actual values of the mushrooms on the connected nodes.\n\nLet me think about the properties of GCD and LCM. For two numbers a and b, we know that GCD(a, b) * LCM(a, b) = a * b. Also, GCD(a, b) divides both a and b, and LCM(a, b) is a multiple of both.\n\nSo for each edge, given G and L, the two nodes u and v must have values a and b such that GCD(a, b) = G and LCM(a, b) = L. Also, G and L must satisfy G * L = a * b. Wait, no, wait: GCD(a,b)*LCM(a,b) = a*b. So for any a and b, this product holds.\n\nBut in this problem, each edge gives us G and L, which are the GCD and LCM of the two connected nodes. So for each edge, the two nodes' a and b must satisfy that their GCD is exactly G and LCM is exactly L.\n\nWait, but what if the G and L provided in the input don't satisfy G * something = a * b? Because for a and b, G * L should equal a*b. So for each edge, G and L must be compatible in that way.\n\nWait, for example, if G=2 and L=3, then a and b must be multiples of 2 and 3, respectively, and their product must be 6 (since 2*3=6). So possible pairs are (2,3), (3,2), (6,1) etc.—but wait, no. Because 6 and 1 have GCD 1 and LCM 6, not 2 and 3. So actually, the only possible pairs are when a = G * x and b = G * y, where x and y are coprime integers, because G is the GCD. Then, the LCM would be G*x*y. So for each edge, the G and L must satisfy that L = G * x * y, where x and y are coprime positive integers.\n\nWait, but the problem says that each edge's GCD and LCM are given as part of the input. So for each edge, I can compute the possible pairs (a, b) that satisfy GCD(a,b)=g and LCM(a,b)=l.\n\nSo for each edge, let's say g and l. Then, a and b must satisfy:\n\na = g * x\nb = g * y\n\nwhere x and y are coprimes (since GCD(x, y) = 1), and the LCM(a, b) is g * x * y. But since the edge's LCM is l, this implies that l must be equal to g * x * y. So, l must be divisible by g. If not, then it's impossible.\n\nSo first step: for each edge, check if l % g != 0. If yes, output NO.\n\nAlso, l must be >= g, because x and y are at least 1.\n\nWait, but in the problem statement, the initial map's edges had GCD and LCM no less than 1 and no more than 106. So for each edge, we need to verify that l is a multiple of g. Otherwise, it's impossible.\n\nWait, no. Because suppose g=2 and l=4. Then, x and y could be 2 and 1, but then their product is 2, making LCM 4. So that works.\n\nWait, but x and y are coprimes. So if x and y are 2 and 2, their GCD is 2, which is not 1. So x and y must be coprimes.\n\nSo for each edge, after ensuring l is divisible by g, we can factor out g, and find all possible pairs (x, y) such that x and y are coprimes, and x*y = l/g.\n\nEach such pair represents a possible (a, b) for the two nodes connected by the edge.\n\nSo the approach is to model this as a system of equations, where each node's value is a variable, and each edge imposes",
    "response": "To solve this problem, we need to determine if it is possible to restore the number of laughy mushrooms on each lawn based on the given roads and their respective GCD and LCM values. If possible, we should output the restored values; otherwise, we should indicate that it's impossible.\n\n### Approach\n1. **Input Parsing**: Read the number of lawns and roads, followed by the details of each road which includes the two lawns it connects and their respective GCD and LCM values.\n2. **Check Feasibility**: For each road, verify if the given GCD (g) and LCM (l) satisfy the condition where l must be a multiple of g. If any road fails this check, output \"NO\".\n3. **Graph Construction**: Construct a graph where each node represents a lawn and edges represent the constraints from the roads.\n4. **Backtracking with BFS**: Use a backtracking approach combined with Breadth-First Search (BFS) to explore possible values for each lawn. Start from one node and propagate constraints through connected nodes, ensuring all edge constraints are satisfied.\n5. **Output Result**: If a valid assignment is found, print the values; otherwise, print \"NO\".\n\n### Solution Code\n```python\nimport sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    m = int(input[idx+1])\n    idx += 2\n    edges = []\n    for _ in range(m):\n        u = int(input[idx])-1  # convert to 0-based\n        v = int(input[idx+1])-1\n        g = int(input[idx+2])\n        l = int(input[idx+3])\n        edges.append( (u, v, g, l) )\n        idx +=4\n    \n    # Check if any edge has l < g\n    for u, v, g, l in edges:\n        if l < g:\n            print(\"NO\")\n            return\n    \n    # Check if for any edge, l is not divisible by g\n    possible = True\n    for u, v, g, l in edges:\n        if l % g != 0:\n            possible = False\n            break\n    if not possible:\n        print(\"NO\")\n        return\n    \n    # Now, build the constraints for each edge\n    # For each edge (u, v), the possible a and b are g*x and g*y, with x*y = l/g and gcd(x,y)=1\n    # We can represent this as u: x, v: y or u: y, v: x\n    # So for each edge, we have two possibilities for x and y\n    \n    # Let's create a list of possible factors for each edge\n    factor_list = []\n    for u, v, g, l in edges:\n        product = l // g\n        factors = []\n        for i in range(1, int(product**0.5)+1):\n            if product % i == 0:\n                j = product // i\n                if i == 1 or j == 1:\n                    factors.append( (i, j) )\n                else:\n                    if i <= j:\n                        factors.append( (i, j) )\n                    else:\n                        factors.append( (j, i) )\n        factor_list.append(factors)\n    \n    # Now, assign variables to each node, initially None\n    values = [None] * n\n    \n    # Try to assign starting from node 0\n    q = deque()\n    q.append( (0, None) )  # (current node, current value)\n    \n    while q:\n        u, val = q.popleft()\n        if val is None:\n            if values[u] is not None:\n                continue\n            # Try all possible factors for the first edge connected to u\n            for factors in factor_list[u]:\n                # Assign u's value as g*f1, then v's as g*f2\n                g_u = g * factors[0]\n                g_v = g * factors[1]\n                # Check if u's value is compatible with existing assignments\n                if values[u] is not None:\n                    if g_u != values[u]:\n                        continue\n                values[u] = g_u\n                values[v] = g_v\n                # Enqueue the connected node\n                q.append( (v, g_v) )\n                # Also, enqueue other possibilities if any\n                # But since we're using BFS, we'll process them in order\n                # Break after processing the first factor (since others might conflict)\n                break\n        else:\n            if values[u] != val:\n                continue\n            # For this node, process all edges\n            for edge in edges:\n                if edge[0] == u:\n                    u_edge, v_edge, g_edge, l_edge = edge\n                    # Find the index in factor_list where this edge is\n                    idx = -1\n                    for i, e in enumerate(edges):\n                        if e[0] == u_edge and e[1] == v_edge and e[2] == g_edge and e[3] == l_edge:\n                            idx = i\n                            break\n                    if idx == -1:\n                        continue\n                    factors = factor_list[idx]\n                    expected_val = val\n                    for f1, f2 in factors:\n                        if expected_val == g_edge * f1:\n                            if values[v_edge] == g_edge * f2:\n                                break\n                        elif expected_val == g_edge * f2:\n                            if values[v_edge] == g_edge * f1:\n                                break\n                    else:\n                        # None of the factors match, backtrack\n                        values[u] = None\n                        values[v_edge] = None\n                        continue\n            # Continue to next node\n    if None in values:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(' '.join(map(str, values)))\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\nThe solution involves parsing the input and checking each edge for validity. For each edge, we ensure that the LCM is a multiple of the GCD. We then construct a graph and use a backtracking approach with BFS to explore possible values for each node, ensuring all constraints are satisfied. If a valid assignment is found, it is printed; otherwise, \"NO\" is printed. This approach efficiently explores possible values while respecting the constraints imposed by each edge.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    m = int(input[idx+1])\n    idx += 2\n    edges = []\n    for _ in range(m):\n        u = int(input[idx])-1  # convert to 0-based\n        v = int(input[idx+1])-1\n        g = int(input[idx+2])\n        l = int(input[idx+3])\n        edges.append( (u, v, g, l) )\n        idx +=4\n    \n    # Check if any edge has l < g\n    for u, v, g, l in edges:\n        if l < g:\n            print(\"NO\")\n            return\n    \n    # Check if for any edge, l is not divisible by g\n    possible = True\n    for u, v, g, l in edges:\n        if l % g != 0:\n            possible = False\n            break\n    if not possible:\n        print(\"NO\")\n        return\n    \n    # Now, build the constraints for each edge\n    # For each edge (u, v), the possible a and b are g*x and g*y, with x*y = l/g and gcd(x,y)=1\n    # We can represent this as u: x, v: y or u: y, v: x\n    # So for each edge, we have two possibilities for x and y\n    \n    # Let's create a list of possible factors for each edge\n    factor_list = []\n    for u, v, g, l in edges:\n        product = l // g\n        factors = []\n        for i in range(1, int(product**0.5)+1):\n            if product % i == 0:\n                j = product // i\n                if i == 1 or j == 1:\n                    factors.append( (i, j) )\n                else:\n                    if i <= j:\n                        factors.append( (i, j) )\n                    else:\n                        factors.append( (j, i) )\n        factor_list.append(factors)\n    \n    # Now, assign variables to each node, initially None\n    values = [None] * n\n    \n    # Try to assign starting from node 0\n    q = deque()\n    q.append( (0, None) )  # (current node, current value)\n    \n    while q:\n        u, val = q.popleft()\n        if val is None:\n            if values[u] is not None:\n                continue\n            # Try all possible factors for the first edge connected to u\n            for factors in factor_list[u]:\n                # Assign u's value as g*f1, then v's as g*f2\n                g_u = g * factors[0]\n                g_v = g * factors[1]\n                # Check if u's value is compatible with existing assignments\n                if values[u] is not None:\n                    if g_u != values[u]:\n                        continue\n                values[u] = g_u\n                values[v] = g_v\n                # Enqueue the connected node\n                q.append( (v, g_v) )\n                # Also, enqueue other possibilities if any\n                # But since we're using BFS, we'll process them in order\n                # Break after processing the first factor (since others might conflict)\n                break\n        else:\n            if values[u] != val:\n                continue\n            # For this node, process all edges\n            for edge in edges:\n                if edge[0] == u:\n                    u_edge, v_edge, g_edge, l_edge = edge\n                    # Find the index in factor_list where this edge is\n                    idx = -1\n                    for i, e in enumerate(edges):\n                        if e[0] == u_edge and e[1] == v_edge and e[2] == g_edge and e[3] == l_edge:\n                            idx = i\n                            break\n                    if idx == -1:\n                        continue\n                    factors = factor_list[idx]\n                    expected_val = val\n                    for f1, f2 in factors:\n                        if expected_val == g_edge * f1:\n                            if values[v_edge] == g_edge * f2:\n                                break\n                        elif expected_val == g_edge * f2:\n                            if values[v_edge] == g_edge * f1:\n                                break\n                    else:\n                        # None of the factors match, backtrack\n                        values[u] = None\n                        values[v_edge] = None\n                        continue\n            # Continue to next node\n    if None in values:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(' '.join(map(str, values)))\n\nif __name__ == '__main__':\n    main()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 536,
        "completion_token_count": 1347,
        "thoughts_token_count": 1025
    }
}