{
    "start": 1758103527.3096979,
    "end": 1758103651.7986023,
    "start-formatted": "2025-09-17 19:05 KST",
    "end-formatted": "2025-09-17 19:07 KST",
    "gpu": 2,
    "pid": 6,
    "use_openrouter": false,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read it carefully.\n\nThe problem is about Leha choosing two vouchers for his vacation. The goal is to find the minimal total cost of two non-overlapping vouchers whose durations sum exactly to x. If it's not possible, output -1.\n\nHmm. Let me break down the requirements.\n\nEach voucher has li, ri, costi. The duration is ri - li + 1. We need two vouchers i and j (i != j) that don't overlap. They don't intersect if either ri < lj or rj < li. So they can't be overlapping at all. Their combined duration should be exactly x. And we need the sum of their costs to be as small as possible.\n\nSo, the steps I need to take are:\n\n1. Read n and x.\n2. For each voucher, compute its duration.\n3. Find all pairs of vouchers where the sum of their durations is x.\n4. Among those pairs, check if they are non-overlapping.\n5. Among all such valid pairs, find the one with the minimal total cost.\n6. Output that minimal cost, or -1 if none exist.\n\nBut wait, considering n can be up to 2e5, checking all possible pairs directly would be O(n^2), which is 4e10 operations—way too slow. So I need a more efficient approach.\n\nLet me think about how to structure this.\n\nFirst, for each voucher, I can note its duration and other details. Then, for each voucher i, I can look for vouchers j that have duration x - di, and are either before i or after i without overlapping.\n\nBut even that might be too slow if done naively. So perhaps we can pre-process the vouchers in some way.\n\nAlternative idea: group vouchers by their duration. For each voucher, the required complementary duration is x - current duration. So for each voucher i with duration d_i, we look for vouchers j with duration x - d_i. Then, among all such j, we need to find the one that doesn't overlap with i and has the smallest cost.\n\nBut how do we efficiently find the j that doesn't overlap and has the minimal cost?\n\nAnother thought: for each possible duration d, we can keep track of all vouchers of that duration, sorted by their end times and start times. Then, for each voucher i, we can quickly find the best possible j.\n\nWait, maybe for each voucher, I can precompute the earliest ending time and the latest starting time for the required duration.\n\nAlternatively, let's try to model this.\n\nFor each voucher i, with duration di, the required duration is dj = x - di. So we need to find any voucher j with duration dj that doesn't overlap with i.\n\nBut how to find such j's quickly?\n\nLet's think about how the vouchers can be arranged in time.\n\nEach voucher j has a start (li) and end (ri). Voucher i and j must not overlap, meaning either j ends before i starts or i ends before j starts.\n\nSo for a given i, any j that ends before li (so j's ri <= li - 1) or starts after ri (so j's li >= ri + 1).\n\nNow, for each i, we can compute the minimal cost j that satisfies either of these conditions and has duration dj.\n\nSo, the plan is:\n\n- Preprocess the vouchers into a data structure where for each duration, we have a list of vouchers, sorted by their end time and start time.\n\nThen, for each voucher i, calculate the needed duration dj. Then, for all j with duration dj, find the minimal cost j that doesn't overlap with i.\n\nBut even this could be time-consuming because for each i, we have to process potentially many j's.\n\nWait, but the minimal cost is what we're after. So for each i, among all possible j's that satisfy the duration and non-overlapping condition, we want the one with the smallest cost.\n\nSo, perhaps for each possible duration, we can pre-sort the vouchers by their end times. Then, for a given i, we can find the earliest ending j with duration dj, and see if it ends before i starts. Or, similarly, for the latest starting j.\n\nWait, but for each i, we need j's that either end before i starts, or start after i ends.\n\nSo for each i, the j's are in two groups:\n\nGroup 1: j ends before i starts. So j's ri <= li - 1.\n\nGroup 2: j starts after i ends. So j's li >= ri + 1.\n\nFor each group, we can find the minimal cost j that satisfies the duration condition.\n\nSo, here's the approach:\n\n1. Preprocess all vouchers into a dictionary where the key is the duration, and the value is a list of tuples (li, ri, costi), sorted by ri (end time) and li (",
    "response": "To solve this problem, we need to find two non-overlapping vouchers such that their combined duration is exactly x days and their total cost is minimized. If no such pair exists, we should return -1.\n\n### Approach\n1. **Preprocessing**: We first compute the duration for each voucher and store them in a dictionary where the key is the duration and the value is a list of tuples containing the start day, end day, and cost of the voucher.\n2. **Sorting**: For each duration, we sort the vouchers based on their end day and start day to facilitate efficient searching.\n3. **Binary Search**: For each voucher, we determine the required complementary duration that, when added to the current voucher's duration, equals x. Using binary search, we efficiently find the minimal cost voucher in the complementary duration that either ends before the current voucher starts or starts after the current voucher ends.\n\n### Solution Code\n```python\nimport bisect\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    ptr = 0\n    n, x = int(input[ptr]), int(input[ptr+1])\n    ptr += 2\n    vouchers = []\n    duration_map = {}\n    for _ in range(n):\n        li = int(input[ptr])\n        ri = int(input[ptr+1])\n        cost = int(input[ptr+2])\n        ptr +=3\n        d = ri - li + 1\n        vouchers.append( (li, ri, cost) )\n        if d not in duration_map:\n            duration_map[d] = []\n        duration_map[d].append( (li, ri, cost) )\n    \n    # Pre-sort the vouchers in each duration group by end time and start time\n    for d in duration_map:\n        # Sort by end time\n        duration_map[d].sort(key=lambda x: x[1])\n        # Sort by start time\n        duration_map[d].sort(key=lambda x: x[0])\n    \n    min_cost = float('inf')\n    for i in range(n):\n        li, ri, cost_i = vouchers[i]\n        d_i = ri - li + 1\n        needed_d = x - d_i\n        if needed_d <= 0:\n            continue\n        if needed_d not in duration_map:\n            continue\n        # Find all vouchers with duration needed_d\n        candidates = duration_map[needed_d]\n        # Check for j ending before li\n        # Binary search for the largest j.end <= li-1\n        # We have candidates sorted by end time\n        left, right = 0, len(candidates)\n        while left < right:\n            mid = (left + right) // 2\n            if candidates[mid][1] <= li - 1:\n                left = mid + 1\n            else:\n                right = mid\n        # The best candidate is at left-1\n        if left > 0:\n            j = candidates[left-1]\n            if j[1] <= li -1:\n                total_cost = cost_i + j[2]\n                if total_cost < min_cost:\n                    min_cost = total_cost\n        \n        # Now check for j starting after ri\n        # Find the first j.start >= ri + 1\n        pos = bisect.bisect_left( [j[0] for j in candidates], ri + 1)\n        if pos < len(candidates):\n            j = candidates[pos]\n            total_cost = cost_i + j[2]\n            if total_cost < min_cost:\n                min_cost = total_cost\n    \n    if min_cost == float('inf'):\n        print(-1)\n    else:\n        print(min_cost)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into the number of vouchers and the vacation duration. Each voucher is stored with its start day, end day, and cost.\n2. **Duration Grouping**: Vouchers are grouped by their duration using a dictionary. Each group is then sorted by both the end day and start day to facilitate efficient searching.\n3. **Finding Complementary Duration**: For each voucher, we compute the required complementary duration that, when added to the current voucher's duration, equals x.\n4. **Binary Search for Minimal Cost**: Using binary search, we find the minimal cost voucher in the complementary duration group that either ends before the current voucher starts or starts after the current voucher ends. This ensures we efficiently find the optimal pair of vouchers without overlapping and with the minimal total cost.",
    "ground_truth": "N/A",
    "extracted_answer": "import bisect\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    ptr = 0\n    n, x = int(input[ptr]), int(input[ptr+1])\n    ptr += 2\n    vouchers = []\n    duration_map = {}\n    for _ in range(n):\n        li = int(input[ptr])\n        ri = int(input[ptr+1])\n        cost = int(input[ptr+2])\n        ptr +=3\n        d = ri - li + 1\n        vouchers.append( (li, ri, cost) )\n        if d not in duration_map:\n            duration_map[d] = []\n        duration_map[d].append( (li, ri, cost) )\n    \n    # Pre-sort the vouchers in each duration group by end time and start time\n    for d in duration_map:\n        # Sort by end time\n        duration_map[d].sort(key=lambda x: x[1])\n        # Sort by start time\n        duration_map[d].sort(key=lambda x: x[0])\n    \n    min_cost = float('inf')\n    for i in range(n):\n        li, ri, cost_i = vouchers[i]\n        d_i = ri - li + 1\n        needed_d = x - d_i\n        if needed_d <= 0:\n            continue\n        if needed_d not in duration_map:\n            continue\n        # Find all vouchers with duration needed_d\n        candidates = duration_map[needed_d]\n        # Check for j ending before li\n        # Binary search for the largest j.end <= li-1\n        # We have candidates sorted by end time\n        left, right = 0, len(candidates)\n        while left < right:\n            mid = (left + right) // 2\n            if candidates[mid][1] <= li - 1:\n                left = mid + 1\n            else:\n                right = mid\n        # The best candidate is at left-1\n        if left > 0:\n            j = candidates[left-1]\n            if j[1] <= li -1:\n                total_cost = cost_i + j[2]\n                if total_cost < min_cost:\n                    min_cost = total_cost\n        \n        # Now check for j starting after ri\n        # Find the first j.start >= ri + 1\n        pos = bisect.bisect_left( [j[0] for j in candidates], ri + 1)\n        if pos < len(candidates):\n            j = candidates[pos]\n            total_cost = cost_i + j[2]\n            if total_cost < min_cost:\n                min_cost = total_cost\n    \n    if min_cost == float('inf'):\n        print(-1)\n    else:\n        print(min_cost)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 687,
        "completion_token_count": 938,
        "thoughts_token_count": 1025
    }
}