{
    "start": 1758278577.7467906,
    "end": 1758278876.9950266,
    "start-formatted": "2025-09-19 19:42 KST",
    "end-formatted": "2025-09-19 19:47 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read it carefully.\n\nThe problem is about Vitaly and a graph. We need to find the minimum number of edges to add to form a simple cycle of odd length, more than one vertex, and each vertex in the cycle occurs at most once. Also, we need to find the number of ways to do this.\n\nHmm. So, the input is an undirected graph with n vertices and m edges. The graph isn't necessarily connected, no loops or parallel edges.\n\nFirst, I need to understand what constitutes a valid cycle here. A cycle is a path where you start and end at the same vertex without repeating any other vertices. And the length must be odd, like 3,5, etc. Also, the cycle should consist of more than one vertex, so the smallest allowed is a triangle (length 3).\n\nSo, the goal is to find the minimal t edges to add to create such a cycle, and w is the number of ways to do that.\n\nWait, but how? Let's think.\n\nWhat's the approach here?\n\nI remember that for a graph to have a cycle, it must be possible to have at least one cycle. But since the graph is undirected and has no loops or multiple edges, cycles can exist in its components.\n\nBut wait, the problem says to form a simple cycle of odd length. So, perhaps the first thing is to check whether the graph already has such a cycle. If it does, then t is 0, because no edges need to be added.\n\nOtherwise, we need to find the minimal number of edges to add to create such a cycle.\n\nLet me think about the possible cases.\n\nCase 1: The graph already contains an odd-length cycle. Then t=0, w=1.\n\nCase 2: The graph doesn't have any odd-length cycles. Then, we need to find the minimal edges to add.\n\nWait, but when adding edges, they can connect different components or parts of the graph to form a cycle.\n\nHmm, perhaps the key is to find the structure of the graph and determine what's needed to form an odd cycle.\n\nAnother thought: the parity of the degrees of the vertices. Because in a graph, the sum of degrees is even. But I'm not sure if that's directly applicable here.\n\nWait, perhaps the problem can be broken down into two parts:\n\n1. Check if the graph has any existing odd-length cycle. If yes, output t=0, w=1.\n\n2. Else, compute the minimal edges needed to add to create such a cycle, and the number of ways.\n\nSo, first step is to find whether the graph has any odd-length cycle.\n\nBut how?\n\nWe can perform a DFS or BFS to detect cycles, keeping track of the length. However, since n can be up to maybe 1e5 or something, but in reality, given that it's a programming competition problem, probably n is manageable.\n\nWait, but what's the maximum n here? The problem statement doesn't specify, but in competitive programming, sometimes constraints are tight.\n\nAlternatively, perhaps the way to approach this is through considering the bipartition of the graph. Because a bipartite graph cannot contain any odd-length cycles. So, if the graph is bipartite, then any cycle it has is even-length. Hence, if the graph is bipartite, it's impossible to have an odd cycle, so we need to add edges to make it non-bipartite.\n\nWait, no. Because adding edges can change the bipartition.\n\nWait, if the graph is bipartite, adding an edge between two nodes of the same partition would create an odd-length cycle. Because in a bipartite graph, all cycles are even. So, adding any edge within a partition will create an odd cycle.\n\nSo, in that case, the minimal t is 1, and the number of ways depends on how many such edges can be added.\n\nWait, let's think. Suppose the graph is bipartite. To create an odd cycle, we can add an edge between two nodes in the same partition. Each such edge addition will create exactly one new odd cycle.\n\nBut wait, adding one edge may create multiple cycles. Or perhaps only one.\n\nWait, no. Adding an edge can create a cycle of odd length. For example, consider a bipartition (A, B). Suppose I have a chain A1 - A2 - ... - Ak - Bk+1 - ... - Bm - B1 - A1. Wait, maybe not. Alternatively, perhaps the simplest case is a tree, which is bipartitioned.\n\nFor example, in a tree, which is bipartite. Adding an edge between two nodes in the same partition will create exactly one cycle, which is of length 2 plus the path length between them. Hmm, but the path in the tree is of certain length, so the total cycle length would be odd or even?\n\n",
    "response": "To solve this problem, we need to determine the minimum number of edges to add to a given graph to form a simple cycle of odd length and the number of ways to achieve this. The graph is undirected, has no loops or parallel edges, and may not be connected.\n\n### Approach\n1. **Check for Existing Odd-Length Cycles**: First, we check if the graph already contains an odd-length cycle. If it does, the minimum number of edges to add (t) is 0, and there is exactly one way to achieve this (w = 1).\n\n2. **Graph Bipartiteness Check**: If the graph is bipartite, it means all cycles in the graph are of even length. To form an odd-length cycle, we need to add an edge within the same partition. This will create exactly one new odd-length cycle. Thus, t = 1 and w depends on the number of such edges that can be added.\n\n3. **Non-Bipartite Graph Handling**: If the graph is not bipartite, it already contains at least one odd-length cycle. Therefore, t = 0 and w = 1.\n\n4. **Counting Ways for Bipartite Graphs**: For bipartite graphs, count the number of valid edges within each partition that can be added to form an odd-length cycle. Each valid edge addition creates exactly one new odd-length cycle.\n\n### Solution Code\n```python\nimport sys\nfrom collections import deque\n\ndef is_bipartite(n, adj):\n    color = [-1] * (n + 1)\n    for i in range(1, n+1):\n        if color[i] == -1:\n            queue = deque()\n            queue.append(i)\n            color[i] = 0\n            while queue:\n                u = queue.popleft()\n                for v in adj[u]:\n                    if color[v] == -1:\n                        color[v] = color[u] ^ 1\n                        queue.append(v)\n                    elif color[v] == color[u]:\n                        return False\n    return True\n\ndef count_odd_cycles(adj):\n    visited = [False] * (len(adj) + 1)\n    for i in range(1, len(adj)+1):\n        if not visited[i]:\n            stack = [(i, iter(adj[i]))]\n            path = []\n            found_cycle = False\n            while stack and not found_cycle:\n                u, neighbors = stack[-1]\n                try:\n                    v = next(neighbors)\n                    if visited[v]:\n                        if v in path:\n                            idx = path.index(v)\n                            cycle_length = len(path) - idx\n                            if cycle_length % 2 != 0:\n                                found_cycle = True\n                                break\n                        else:\n                            continue\n                    else:\n                        visited[v] = True\n                        path.append(v)\n                        stack.append((v, iter(adj[v])))\n                except StopIteration:\n                    path.pop()\n    return found_cycle\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr +=1\n    m = int(input[ptr])\n    ptr +=1\n    adj = [[] for _ in range(n+1)]\n    for _ in range(m):\n        a = int(input[ptr])\n        ptr +=1\n        b = int(input[ptr])\n        ptr +=1\n        adj[a].append(b)\n        adj[b].append(a)\n    \n    if count_odd_cycles(adj):\n        print(\"0 1\")\n        return\n    \n    if is_bipartite(n, adj):\n        partitions = {}\n        color = [-1]*(n+1)\n        for i in range(1, n+1):\n            if color[i] == -1:\n                queue = deque()\n                queue.append(i)\n                color[i] = 0\n                while queue:\n                    u = queue.popleft()\n                    for v in adj[u]:\n                        if color[v] == -1:\n                            color[v] = color[u] ^ 1\n                            queue.append(v)\n                        elif color[v] == color[u]:\n                            pass\n                for node in range(1, n+1):\n                    if color[node] == 0:\n                        if 0 not in partitions:\n                            partitions[0] = []\n                        partitions[0].append(node)\n                    else:\n                        if 1 not in partitions:\n                            partitions[1] = []\n                        partitions[1].append(node)\n        \n        same_partition = 0\n        for key in partitions:\n            same_partition += len(partitions[key]) * (len(partitions[key])-1) // 2\n        \n        print(f\"1 {same_partition}\")\n    else:\n        print(\"0 1\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\nThe solution first checks if the graph already contains an odd-length cycle using depth-first search (DFS). If it does, it immediately returns the result. If the graph is bipartite, it calculates the number of valid edges within each partition that can be added to form an odd-length cycle. If the graph is non-bipartite, it confirms the presence of an odd-length cycle and returns the result accordingly.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef is_bipartite(n, adj):\n    color = [-1] * (n + 1)\n    for i in range(1, n+1):\n        if color[i] == -1:\n            queue = deque()\n            queue.append(i)\n            color[i] = 0\n            while queue:\n                u = queue.popleft()\n                for v in adj[u]:\n                    if color[v] == -1:\n                        color[v] = color[u] ^ 1\n                        queue.append(v)\n                    elif color[v] == color[u]:\n                        return False\n    return True\n\ndef count_odd_cycles(adj):\n    visited = [False] * (len(adj) + 1)\n    for i in range(1, len(adj)+1):\n        if not visited[i]:\n            stack = [(i, iter(adj[i]))]\n            path = []\n            found_cycle = False\n            while stack and not found_cycle:\n                u, neighbors = stack[-1]\n                try:\n                    v = next(neighbors)\n                    if visited[v]:\n                        if v in path:\n                            idx = path.index(v)\n                            cycle_length = len(path) - idx\n                            if cycle_length % 2 != 0:\n                                found_cycle = True\n                                break\n                        else:\n                            continue\n                    else:\n                        visited[v] = True\n                        path.append(v)\n                        stack.append((v, iter(adj[v])))\n                except StopIteration:\n                    path.pop()\n    return found_cycle\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr +=1\n    m = int(input[ptr])\n    ptr +=1\n    adj = [[] for _ in range(n+1)]\n    for _ in range(m):\n        a = int(input[ptr])\n        ptr +=1\n        b = int(input[ptr])\n        ptr +=1\n        adj[a].append(b)\n        adj[b].append(a)\n    \n    if count_odd_cycles(adj):\n        print(\"0 1\")\n        return\n    \n    if is_bipartite(n, adj):\n        partitions = {}\n        color = [-1]*(n+1)\n        for i in range(1, n+1):\n            if color[i] == -1:\n                queue = deque()\n                queue.append(i)\n                color[i] = 0\n                while queue:\n                    u = queue.popleft()\n                    for v in adj[u]:\n                        if color[v] == -1:\n                            color[v] = color[u] ^ 1\n                            queue.append(v)\n                        elif color[v] == color[u]:\n                            pass\n                for node in range(1, n+1):\n                    if color[node] == 0:\n                        if 0 not in partitions:\n                            partitions[0] = []\n                        partitions[0].append(node)\n                    else:\n                        if 1 not in partitions:\n                            partitions[1] = []\n                        partitions[1].append(node)\n        \n        same_partition = 0\n        for key in partitions:\n            same_partition += len(partitions[key]) * (len(partitions[key])-1) // 2\n        \n        print(f\"1 {same_partition}\")\n    else:\n        print(\"0 1\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 570,
        "completion_token_count": 1073,
        "thoughts_token_count": 1025
    }
}