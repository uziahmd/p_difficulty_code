{
    "start": 1758279432.6545606,
    "end": 1758279701.4301393,
    "start-formatted": "2025-09-19 19:57 KST",
    "end-formatted": "2025-09-19 20:01 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "Okay, I have to solve this problem where I need to find the minimum number of nodes required to create a p-reachable directed graph and then determine the maximum number of unidirectional pairs among all such graphs with that minimum node count.\n\nLet me first understand what a p-reachable directed graph is. So, a p-reachable graph has exactly p ordered pairs (u, v) such that u < v, u and v are reachable from each other. These pairs are called bidirectional pairs because you can go both ways between u and v.\n\nWait, no, wait. Wait, the problem says that an ordered pair (u, v) is unidirectional if u != v, there's a path from u to v, and no path from v to u. So for the p-reachable part, we're counting the number of such unordered pairs {u, v} where u and v are mutually reachable. Because in each such pair, there are two ordered pairs: (u, v) and (v, u), but if they are both present, they would contribute 0 to the unidirectional count. But for the p, it's about the number of unordered pairs, since each such pair contributes exactly one to p.\n\nSo the p is the count of unordered pairs {u, v} where u < v and they are mutually reachable. So for each such pair, we add 1 to p.\n\nSo our goal is to construct a directed graph with exactly p such pairs, using as few nodes as possible. Then, among all such minimal-node graphs, find the one that maximizes the number of unidirectional ordered pairs.\n\nHmm.\n\nLet me think about how to model this. Let's denote the number of unordered pairs as p. So for example, when p=3, the sample input shows that 3 nodes are needed, and the maximum unidirectional pairs is 0.\n\nWait, in the sample input, when p=3, the output is 3 0. So the graph has 3 nodes and 0 unidirectional pairs. How is that?\n\nIn that case, perhaps the graph is a single strongly connected component. Because if the entire graph is strongly connected, then every pair of nodes is mutually reachable, but each unordered pair only contributes 1 to p. For n nodes, the maximum possible p is C(n,2), which is n*(n-1)/2. But in the sample, for p=3, n=3, so C(3,2)=3, which matches. So the graph is a triangle where every node can reach every other node, so all 3 unordered pairs are counted, hence p=3.\n\nBut then the number of unidirectional pairs is zero because for every pair (u, v), if u can reach v and v can reach u, then (u, v) and (v, u) are both present, contributing zero to the unidirectional count.\n\nSo for the first part of the problem, when given p, find the minimal n such that C(n-1, 2) + 1 = p? Or wait, maybe not. Let's see.\n\nWait, let's think about the structure of the graph that minimizes the number of nodes. To minimize n, we want to have as many edges as possible within a strongly connected component because that way, each new edge adds more to p without increasing n.\n\nWait, no. Wait, the more edges you have, the more unordered pairs you get. Because each edge (u, v) contributes to the p if u and v form a new unordered pair. So to maximize p per node, you want a complete graph, where every pair is connected in both directions. So for n nodes, the maximum p is C(n, 2). But in our problem, p can be any value up to that. So to minimize n for a given p, we need to arrange the edges such that we have exactly p unordered pairs.\n\nWait, but perhaps the minimal n is such that the sum of the first k integers equals p. Hmm, no, that's for something else.\n\nWait, let's think differently. The minimal n is such that the maximum possible p for n-1 nodes is less than or equal to p, and adding another node allows us to reach p.\n\nAlternatively, perhaps the minimal n is the smallest integer n where the sum from i=1 to m of (i choose 2) is >= p, but that's probably not correct.\n\nWait, let's consider how to build a graph that uses as few nodes as possible to reach p. Each time we add a node, we can connect it to existing nodes in a way that increases p by a certain amount.\n\nWait, let's see:\n\nSuppose we start with a single node. Then p is zero.\n\nIf we add another node, now we have two nodes. If we make them strongly connected (i.e., both edges exist), then the unordered pair is counted once",
    "response": "To solve this problem, we need to determine the minimum number of nodes required to create a p-reachable directed graph and then find the maximum number of unidirectional pairs among all such graphs with that minimum node count.\n\n### Approach\n1. **Understanding p-reachable Graphs**: A p-reachable graph has exactly `p` unordered pairs (u, v) where u < v and both nodes are mutually reachable. These pairs contribute to the count of bidirectional edges in the graph.\n\n2. **Minimizing Nodes**: The goal is to construct a graph with the fewest nodes possible such that the number of bidirectional pairs equals `p`. This can be achieved by forming a complete graph where every node is strongly connected, allowing each new node to contribute the maximum number of new bidirectional pairs.\n\n3. **Maximizing Unidirectional Pairs**: Once the minimal number of nodes is determined, we need to maximize the number of unidirectional pairs. This is achieved by ensuring that as many edges as possible are unidirectional, meaning only one direction of traversal exists between nodes.\n\n### Solution Code\n```python\nimport math\n\ndef compute_min_nodes(p):\n    if p == 0:\n        return (0, 0)\n    # Find the smallest n where C(n-1, 2) + 1 <= p\n    # Because for n-1 nodes, we can have C(n-1, 2) pairs, and adding one more node\n    # allows us to reach p.\n    n = 1\n    total = 0\n    while True:\n        next_total = total + n * (n - 1) // 2\n        if next_total >= p:\n            break\n        n += 1\n        total = next_total\n    # Now, check if we can adjust with the same n or need to go higher\n    if total == p:\n        min_nodes = n\n    else:\n        # We might have to take n+1\n        if next_total - total < p:\n            # Wait, no, because next_total is the sum up to n, which is C(n, 2). So perhaps I'm not on the right track.\n            # Let me think differently.\n            # For n nodes, the maximum p is C(n,2).\n            # We need to find the smallest n where C(n,2) >= p.\n            # Because any p up to C(n,2) can be formed by a complete graph.\n            # So the minimal n is the smallest integer where n*(n-1)/2 >= p.\n            # Wait, perhaps I made a mistake earlier.\n            # Let me recompute:\n            # Find the smallest n where n*(n-1)/2 >= p.\n            # So for example, when p=3: n=3 since 3*2/2=3 >=3.\n            # When p=4: 3*2/2=3 <4, so n=4 since 4*3/2=6>=4.\n            # So correct approach: find minimal n where C(n,2)>=p.\n            # So let's recalculate:\n            n = 0\n            while True:\n                if n*(n-1)//2 >= p:\n                    break\n                n +=1\n            min_nodes = n\n            # Now, the number of bidirectional pairs is C(n,2), but we need exactly p.\n            # So to get exactly p, perhaps the minimal nodes is n, but sometimes we can have fewer nodes.\n            # Wait, for example, if p=3, n=3 gives C(3,2)=3, which is exactly p.\n            # So in general, the minimal nodes is the smallest n such that C(n,2) >=p.\n            # Wait no, because if p=4, n=4 gives C(4,2)=6, which is more than 4. So how do we get exactly 4?\n            # Oh wait, because the graph doesn't have to be a complete graph. It can have some edges missing, but still ensure that the number of bidirectional pairs is exactly p.\n            # So the minimal n is the smallest n where the maximal possible p (C(n,2)) is at least p.\n            # But how? Because we can have a graph where some edges are missing, but the total bidirectional pairs are p.\n            # So the minimal n is the minimal n where C(n-1,2)+1 <= p < C(n,2)+1.\n            # Hmm, maybe I'm overcomplicating it.\n            # Let me try to find for given p, the minimal n where the sum of the first k integers is >= p.\n            # Alternatively, considering that each new node can add up to (k) new bidirectional pairs, where k is the number of existing nodes.\n            # Wait, but in a complete graph, each new node adds k new edges, which contribute k new bidirectional pairs.\n            # So the total bidirectional pairs after adding m nodes is sum_{i=1 to m} i*(i-1)/2.\n            # Wait, no. Because when you have m nodes, the total number of bidirectional pairs is m*(m-1)/2. So for example, 3 nodes give 3 pairs, 4 nodes give 6, etc.\n            # So for a given p, the minimal n is the smallest n where n*(n-1)/2 >= p.\n            # So for p=3, n=3 is sufficient. For p=4, n=4 is needed because 3*(3-1)/2=3<4, but 4*3/2=6>=4.\n            # So the minimal nodes is the smallest n where n choose 2 is >=p.\n            # So the function to compute min_nodes is to find the smallest n where n(n-1)/2 >= p.\n            # Then, once n is found, the number of bidirectional pairs is exactly p, but perhaps there are ways to arrange the edges such that the number is p.\n\n    # Now, after determining min_nodes, calculate the maximum unidirectional pairs.\n    # The maximum unidirectional pairs occurs when the graph is a DAG, with a topological order where each edge goes from an earlier node to a later node, but without any cycles.\n    # In such a case, the number of unidirectional pairs is equal to the number of edges in the graph minus the number of bidirectional pairs.\n    # But wait, in a DAG, there are no cycles, so every edge is unidirectional.\n    # However, in our case, the graph is not necessarily a DAG. We want to maximize the number of unidirectional pairs, so we should arrange the edges such that as many as possible are unidirectional.\n\n    # Wait, no. If the graph is strongly connected, then all edges are bidirectional, contributing zero to unidirectional pairs. So to maximize unidirectional pairs, the graph should have as few bidirectional edges as possible.\n\n    # So the strategy is to form a graph where as many edges as possible are unidirectional. This can be achieved by making the graph a DAG, where edges only go in one direction. However, in a DAG, the number of edges can be maximized without any cycles, thus maximizing unidirectional pairs.\n\n    # So for a graph with n nodes arranged in a linear order, the maximum number of edges is n*(n-1)/2 (if it's a complete DAG, like a complete bipartite graph with edges pointing in one direction). But wait, in a complete DAG, all edges point in the same direction, so the number of unidirectional pairs is equal to the total number of edges, which is n*(n-1)/2.\n\n    # Wait, no. Because in a complete DAG, every pair (u, v) with u < v has an edge from u to v, but none from v to u. So the number of unidirectional pairs is exactly the number of edges, which is n*(n-1)/2.\n\n    # However, in our problem, the graph must be p-reachable, meaning it has exactly p bidirectional pairs. But in a complete DAG, there are zero bidirectional pairs. So if the graph is a complete DAG, then p=0.\n\n    # So, to handle cases where p>0, we need a graph that has some bidirectional edges and as many unidirectional edges as possible.\n\n    # Therefore, the approach is to create a graph where the majority of edges are unidirectional, while having exactly p bidirectional edges.\n\n    # So, the minimal number of nodes is determined by finding the smallest n where n*(n-1)/2 >= p. Then, to maximize unidirectional pairs, the graph should have as many edges as possible in one direction, while keeping exactly p bidirectional edges.\n\n    # Thus, the maximum number of unidirectional pairs is (n*(n-1)/2) - p, because the total edges in a complete DAG is n*(n-1)/2, and we subtract the p bidirectional edges.\n\n    # Wait, but in reality, the graph may not be a complete DAG. For example, if p is not zero, we need to have exactly p bidirectional edges, and the rest as unidirectional.\n\n    # Therefore, the maximum number of unidirectional pairs is the total number of possible edges (n*(n-1)) minus the number of edges that are bidirectional. Since each bidirectional edge contributes two ordered pairs, but only one to p.\n\n    # Wait, perhaps I should model it as follows:\n\n    # The total number of ordered pairs (u, v) where u != v is n*(n-1). Each bidirectional edge (u, v) contributes two ordered pairs, but only one to p. So the number of unidirectional pairs is the total number of ordered pairs minus twice the number of bidirectional edges.\n\n    # So, the maximum number of unidirectional pairs is (n*(n-1)) - 2*p.\n\n    # But wait, in the sample input where p=3, n=3. The total ordered pairs are 3*2=6. The bidirectional pairs are 3. So unidirectional pairs are 6 - 2*3 = 0, which matches the sample.\n\n    # Another example: if p=4, n=5. Total ordered pairs is 5*4=20. Suppose we have 4 bidirectional pairs. Then unidirectional pairs would be 20 - 2*4 = 12. So the maximum is 12.\n\n    # So yes, the formula seems to hold: unidirectional_pairs = n*(n-1) - 2*p.\n\n    # Therefore, the steps are:\n\n    # 1. Find the minimal n such that n*(n-1)/2 >= p. This ensures that we can have p bidirectional pairs.\n\n    # 2. Calculate the maximum number of unidirectional pairs as n*(n-1) - 2*p.\n\n    # Special Cases:\n\n    # - If p=0: The graph can be a DAG with no bidirectional edges, and the maximum unidirectional pairs is n*(n-1). But since p=0, the minimal nodes is 1 (no edges), and the unidirectional pairs are 0.\n\n    # So, putting it all together:\n\n    # Compute the minimal n where n*(n-1)/2 >= p.\n\n    # Then, if p=0, output (1, 0).\n\n    # Else, output (n, n*(n-1) - 2*p).\n\n    # Now, implement this logic.\n\n    if p == 0:\n        return (1, 0)\n    \n    # Compute minimal n\n    n = 0\n    while True:\n        if n * (n - 1) // 2 >= p:\n            break\n        n += 1\n    \n    # Now, compute unidirectional pairs\n    max_uni = n * (n - 1) - 2 * p\n    return (n, max_uni)\n\n# Read input\np = int(input())\n# Compute result\nif p == 0:\n    print(\"1 0\")\nelse:\n    n = 1\n    while True:\n        if n * (n - 1) // 2 >= p:\n            break\n        n += 1\n    max_uni = n * (n - 1) - 2 * p\n    print(f\"{n} {max_uni}\")\n```\n\n### Explanation\n1. **Reading Input**: The input is read as an integer `p`.\n2. **Handling Special Case for p=0**: If `p` is zero, the output is directly `(1, 0)` because a single node trivially satisfies the condition with zero bidirectional pairs.\n3. **Finding Minimal Nodes**: The code iterates to find the smallest `n` such that the number of bidirectional pairs in a complete graph of `n` nodes is at least `p`.\n4. **Calculating Maximum Unidirectional Pairs**: Using the formula `n*(n-1) - 2*p`, the code calculates the maximum number of unidirectional pairs possible in a graph with `n` nodes and exactly `p` bidirectional pairs.\n\nThis approach ensures that we efficiently determine the minimal number of nodes and the maximum unidirectional pairs using straightforward mathematical computations.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef compute_min_nodes(p):\n    if p == 0:\n        return (0, 0)\n    # Find the smallest n where C(n-1, 2) + 1 <= p\n    # Because for n-1 nodes, we can have C(n-1, 2) pairs, and adding one more node\n    # allows us to reach p.\n    n = 1\n    total = 0\n    while True:\n        next_total = total + n * (n - 1) // 2\n        if next_total >= p:\n            break\n        n += 1\n        total = next_total\n    # Now, check if we can adjust with the same n or need to go higher\n    if total == p:\n        min_nodes = n\n    else:\n        # We might have to take n+1\n        if next_total - total < p:\n            # Wait, no, because next_total is the sum up to n, which is C(n, 2). So perhaps I'm not on the right track.\n            # Let me think differently.\n            # For n nodes, the maximum p is C(n,2).\n            # We need to find the smallest n where C(n,2) >= p.\n            # Because any p up to C(n,2) can be formed by a complete graph.\n            # So the minimal n is the smallest integer where n*(n-1)/2 >= p.\n            # Wait, perhaps I made a mistake earlier.\n            # Let me recompute:\n            # Find the smallest n where n*(n-1)/2 >= p.\n            # So for example, when p=3: n=3 since 3*2/2=3 >=3.\n            # When p=4: 3*2/2=3 <4, so n=4 since 4*3/2=6>=4.\n            # So correct approach: find minimal n where C(n,2)>=p.\n            # So let's recalculate:\n            n = 0\n            while True:\n                if n*(n-1)//2 >= p:\n                    break\n                n +=1\n            min_nodes = n\n            # Now, the number of bidirectional pairs is C(n,2), but we need exactly p.\n            # So to get exactly p, perhaps the minimal nodes is n, but sometimes we can have fewer nodes.\n            # Wait, for example, if p=3, n=3 gives C(3,2)=3, which is exactly p.\n            # So in general, the minimal nodes is the smallest n such that C(n,2) >=p.\n            # Wait no, because if p=4, n=4 gives C(4,2)=6, which is more than 4. So how do we get exactly 4?\n            # Oh wait, because the graph doesn't have to be a complete graph. It can have some edges missing, but still ensure that the number of bidirectional pairs is exactly p.\n            # So the minimal n is the smallest n where the maximal possible p (C(n,2)) is at least p.\n            # But how? Because we can have a graph where some edges are missing, but the total bidirectional pairs are p.\n            # So the minimal n is the minimal n where C(n-1,2)+1 <= p < C(n,2)+1.\n            # Hmm, maybe I'm overcomplicating it.\n            # Let me try to find for given p, the minimal n where the sum of the first k integers is >= p.\n            # Alternatively, considering that each new node can add up to (k) new bidirectional pairs, where k is the number of existing nodes.\n            # Wait, but in a complete graph, each new node adds k new edges, which contribute k new bidirectional pairs.\n            # So the total bidirectional pairs after adding m nodes is sum_{i=1 to m} i*(i-1)/2.\n            # Wait, no. Because when you have m nodes, the total number of bidirectional pairs is m*(m-1)/2. So for example, 3 nodes give 3 pairs, 4 nodes give 6, etc.\n            # So for a given p, the minimal n is the smallest n where n*(n-1)/2 >= p.\n            # So for p=3, n=3 is sufficient. For p=4, n=4 is needed because 3*(3-1)/2=3<4, but 4*3/2=6>=4.\n            # So the minimal nodes is the smallest n where n choose 2 is >=p.\n            # So the function to compute min_nodes is to find the smallest n where n(n-1)/2 >= p.\n            # Then, once n is found, the number of bidirectional pairs is exactly p, but perhaps there are ways to arrange the edges such that the number is p.\n\n    # Now, after determining min_nodes, calculate the maximum unidirectional pairs.\n    # The maximum unidirectional pairs occurs when the graph is a DAG, with a topological order where each edge goes from an earlier node to a later node, but without any cycles.\n    # In such a case, the number of unidirectional pairs is equal to the number of edges in the graph minus the number of bidirectional pairs.\n    # But wait, in a DAG, there are no cycles, so every edge is unidirectional.\n    # However, in our case, the graph is not necessarily a DAG. We want to maximize the number of unidirectional pairs, so we should arrange the edges such that as many as possible are unidirectional.\n\n    # Wait, no. If the graph is strongly connected, then all edges are bidirectional, contributing zero to unidirectional pairs. So to maximize unidirectional pairs, the graph should have as few bidirectional edges as possible.\n\n    # So the strategy is to form a graph where as many edges as possible are unidirectional. This can be achieved by making the graph a DAG, where edges only go in one direction. However, in a DAG, the number of edges can be maximized without any cycles, thus maximizing unidirectional pairs.\n\n    # So for a graph with n nodes arranged in a linear order, the maximum number of edges is n*(n-1)/2 (if it's a complete DAG, like a complete bipartite graph with edges pointing in one direction). But wait, in a complete DAG, all edges point in the same direction, so the number of unidirectional pairs is equal to the total number of edges, which is n*(n-1)/2.\n\n    # Wait, no. Because in a complete DAG, every pair (u, v) with u < v has an edge from u to v, but none from v to u. So the number of unidirectional pairs is exactly the number of edges, which is n*(n-1)/2.\n\n    # However, in our problem, the graph must be p-reachable, meaning it has exactly p bidirectional pairs. But in a complete DAG, there are zero bidirectional pairs. So if the graph is a complete DAG, then p=0.\n\n    # So, to handle cases where p>0, we need a graph that has some bidirectional edges and as many unidirectional edges as possible.\n\n    # Therefore, the approach is to create a graph where the majority of edges are unidirectional, while having exactly p bidirectional edges.\n\n    # So, the minimal number of nodes is determined by finding the smallest n where n*(n-1)/2 >= p. Then, to maximize unidirectional pairs, the graph should have as many edges as possible in one direction, while keeping exactly p bidirectional edges.\n\n    # Thus, the maximum number of unidirectional pairs is (n*(n-1)/2) - p, because the total edges in a complete DAG is n*(n-1)/2, and we subtract the p bidirectional edges.\n\n    # Wait, but in reality, the graph may not be a complete DAG. For example, if p is not zero, we need to have exactly p bidirectional edges, and the rest as unidirectional.\n\n    # Therefore, the maximum number of unidirectional pairs is the total number of possible edges (n*(n-1)) minus the number of edges that are bidirectional. Since each bidirectional edge contributes two ordered pairs, but only one to p.\n\n    # Wait, perhaps I should model it as follows:\n\n    # The total number of ordered pairs (u, v) where u != v is n*(n-1). Each bidirectional edge (u, v) contributes two ordered pairs, but only one to p. So the number of unidirectional pairs is the total number of ordered pairs minus twice the number of bidirectional edges.\n\n    # So, the maximum number of unidirectional pairs is (n*(n-1)) - 2*p.\n\n    # But wait, in the sample input where p=3, n=3. The total ordered pairs are 3*2=6. The bidirectional pairs are 3. So unidirectional pairs are 6 - 2*3 = 0, which matches the sample.\n\n    # Another example: if p=4, n=5. Total ordered pairs is 5*4=20. Suppose we have 4 bidirectional pairs. Then unidirectional pairs would be 20 - 2*4 = 12. So the maximum is 12.\n\n    # So yes, the formula seems to hold: unidirectional_pairs = n*(n-1) - 2*p.\n\n    # Therefore, the steps are:\n\n    # 1. Find the minimal n such that n*(n-1)/2 >= p. This ensures that we can have p bidirectional pairs.\n\n    # 2. Calculate the maximum number of unidirectional pairs as n*(n-1) - 2*p.\n\n    # Special Cases:\n\n    # - If p=0: The graph can be a DAG with no bidirectional edges, and the maximum unidirectional pairs is n*(n-1). But since p=0, the minimal nodes is 1 (no edges), and the unidirectional pairs are 0.\n\n    # So, putting it all together:\n\n    # Compute the minimal n where n*(n-1)/2 >= p.\n\n    # Then, if p=0, output (1, 0).\n\n    # Else, output (n, n*(n-1) - 2*p).\n\n    # Now, implement this logic.\n\n    if p == 0:\n        return (1, 0)\n    \n    # Compute minimal n\n    n = 0\n    while True:\n        if n * (n - 1) // 2 >= p:\n            break\n        n += 1\n    \n    # Now, compute unidirectional pairs\n    max_uni = n * (n - 1) - 2 * p\n    return (n, max_uni)\n\n# Read input\np = int(input())\n# Compute result\nif p == 0:\n    print(\"1 0\")\nelse:\n    n = 1\n    while True:\n        if n * (n - 1) // 2 >= p:\n            break\n        n += 1\n    max_uni = n * (n - 1) - 2 * p\n    print(f\"{n} {max_uni}\")",
    "score": 0,
    "metadata": {
        "prompt_token_count": 475,
        "completion_token_count": 2840,
        "thoughts_token_count": 1025
    }
}