{
    "start": 1758282061.725815,
    "end": 1758283947.605011,
    "start-formatted": "2025-09-19 20:41 KST",
    "end-formatted": "2025-09-19 21:12 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read it carefully.\n\nThe problem is about finding a non-negative integer k such that the least common multiple (LCM) of a+k and b+k is as small as possible. And if there are multiple k's that give the same minimal LCM, we choose the smallest one.\n\nHmm, right. So first, I need to understand what affects the LCM when we add k to both a and b. Let's denote x = a + k and y = b + k. Then, since y - x = (b +k) - (a +k) = b - a. So the difference between x and y is fixed; it's equal to |a - b|. Wait, no—wait, because a and b can be in any order. But in any case, the difference remains the same.\n\nWait, but let's think: The LCM of x and y is (x*y)/gcd(x,y). So to minimize this, perhaps we can find x and y that share a large GCD.\n\nBut x and y differ by d = |a - b|. Because x = a +k, y = b +k, so y -x = b -a. So if a >= b, then d = a -b, else d = b -a. Let me compute d as the absolute difference between a and b.\n\nSo d = |a - b|. So x and y are two numbers that are d apart. So the problem reduces to finding two numbers x and y where y = x + d, and x >= a (since k is non-negative), and y >= b (but depending on whether a is larger than b or not).\n\nWait, wait. Let me clarify:\n\nIf a <= b, then adding k to both will keep the order the same. So x = a +k, y = b +k. So y = x + (b -a) = x + d, where d = b - a.\n\nSimilarly, if a > b, then y = x + (a -b) = x + d, but here d would be negative, but since we take absolute value, d is positive.\n\nSo regardless of which is larger, the difference between x and y is fixed as d. So the problem is to find x and x +d such that their LCM is minimized.\n\nSo the key is to find x such that x and x+d have a large GCD. Because the LCM is (x*(x+d))/gcd(x, x+d). So to minimize this, we need to maximize the GCD.\n\nSo the optimal x should be such that gcd(x, x+d) is as large as possible.\n\nSo the problem now becomes: find x >= max(a, b) ? No, wait. Because k is non-negative, so x = a +k must be >= a, and similarly y = b +k >= b. But wait, no—because if a < b, then x could be less than b. For example, if a=5, b=10, then for k=0, x=5, y=10. But maybe choosing a smaller x would be better? Or is that impossible?\n\nWait, no. Because k is non-negative, x can't be less than a. Because x = a +k, so x starts at a and increases. Similarly for y. So for the case where a < b, x can be a, a+1, etc., but y will always be >= b.\n\nWait, no. Because if a is 5 and b is 10, then y = 10 +k, which is always >=10. x is 5 +k, which is >=5. So for any k>=0, x and y are such that y = x +5.\n\nSo the difference is 5.\n\nWe need to find x >=5 such that x and x+5 have maximum GCD. Because the LCM is (x*(x+5))/g, where g is the GCD.\n\nWait, but to minimize the LCM, we need to maximize the GCD. So the optimal x is the one that has the largest possible g dividing x and x+d.\n\nSo how do we find x that maximizes g, where g divides both x and x +d.\n\nBut x and x +d have a GCD of g, so g must divide (x +d -x) =d. So g is a divisor of d.\n\nTherefore, to find the maximum possible g, which is a divisor of d, and for each such g, find the smallest x >= a (or some lower bound) that is divisible by g.\n\nWait, perhaps the steps are:\n\n1. Compute d = |a - b|.\n\n2. If d is zero, then a == b. So x = a +k, y = a +k. So LCM is x. To minimize x, choose the smallest possible x, which is a. So k=0.\n\n3. Else, for d>0, find all divisors of d, including 1 and d.\n\n4. For each possible divisor g (starting from the largest), check if there exists an x >= ... such that x is congruent to 0 mod g, and x +d is also congruent to 0 mod g (which is automatically true since x and x+d have GCD g).\n\nWait, but x needs to satisfy x >= a and x >= ... well, since x = a +k, k >=0, x must be >=a. Also, y = x +d must be >=b.\n\nWait, no. Because y = x +d. Since d is |a - b|, let's say d = b -a if a < b. So y = x + (b -a). But since x >=a, and d is positive, y will be >= a + (b -a) = b. So y is always >=b, so that condition is satisfied.\n\nSo for x >= a, y >=b is automatically satisfied.\n\nSo the constraints are x >= a, and x +d >=b. Which, given that d is positive, is always true.\n\nSo our main constraint is x >=a.\n\nSo, for each divisor g of d, we can find the minimal x >=a that is divisible by g. Then, for each such x, compute the LCM (x*(x+d)/g) and track the minimal LCM and the corresponding x.\n\nWait, but perhaps not all divisors are possible. We need to find x >=a such that x is a multiple of g.\n\nSo the plan is:\n\n- Compute all possible divisors of d.\n\n- For each divisor g (in descending order, to find the maximum possible g quickly), find the smallest x >=a such that x is a multiple of g.\n\n- For that x, compute the LCM of x and x+d, which is (x * (x +d)) / g.\n\n- Keep track of the minimal LCM and the corresponding x.\n\n- Also, note that for x being a multiple of g, but not necessarily the smallest, perhaps a larger x might have a higher g. Wait, no. Because we're considering all possible divisors g, and for each, the smallest x is the earliest possible candidate.\n\nWait, perhaps not. Because for a given g, the x can be a multiple of g >=a. So the smallest x for g is ceil(a/g)*g. Wait, no, it's the smallest multiple of g that is >=a.\n\nFor example, if a=6 and g=3, the smallest x is 6. If a=7 and g=3, x=9.\n\nYes.\n\nSo, the steps are:\n\n1. Compute d = abs(a - b).\n\n2. If d is zero, return k=0.\n\n3. Else, generate all the divisors of d.\n\n4. Sort the divisors in descending order.\n\n5. For each divisor g in this order:\n\n   a. Compute the minimal x that is a multiple of g and >=a.\n\n      i. If a % g ==0, x =a.\n\n      ii. Else, x = ((a // g) +1 ) * g.\n\n   b. Check if x >=a.\n\n   c. Compute the LCM for x and x+d.\n\n   d. Keep track of the minimal LCM and the corresponding k, which is x -a.\n\n6. After checking all divisors, also consider the case where g=1, which is trivial.\n\nWait, but why step 5 covers all possible cases? Because for any possible x >=a, the maximum possible g is a divisor of d. So by enumerating all possible g (divisors of d) and for each, computing the minimal x, we can find the optimal x.\n\nAdditionally, after processing all divisors, the minimal LCM is found.\n\nBut wait, what about the case where d=0? Well, that's handled separately.\n\nNow, the question is: How to efficiently generate all divisors of d.\n\nBecause d can be up to 1e9, the number of divisors is manageable. The maximum number of divisors for a number up to 1e9 is around 1e5 (for 735134400 which has 1344 divisors). But 1e5 is manageable.\n\nSo, the plan is:\n\nCompute all the divisors of d, then for each in descending order, compute x and the LCM, and track the minimal.\n\nOnce all divisors are processed, pick the minimal LCM, and among those, the smallest k.\n\nWait, but sometimes, for different g's, the same x may be considered. But since we process the g's in descending order, the first occurrence of the minimal LCM is likely to be the best.\n\nWait, no. Because for a larger g, the x is computed as the minimal multiple, which gives a larger g, leading to a smaller LCM. So processing from largest g down ensures that once a certain x is considered, any later x for smaller g's will have a larger LCM. So the first time we find the minimal possible LCM is when the g is as large as possible.\n\nBut to confirm, let's think: for each g, the x is chosen as the minimal possible, so for each g, the x is as small as possible. Thus, for a larger g, the x is as small as possible, which may lead to a better (smaller) LCM.\n\nWait, but perhaps for a larger g, the x is smaller, so the LCM is smaller. So processing from largest g to smallest is the way to go, because once you find a certain LCM, you can compare and see if it's the minimal.\n\nAlternatively, perhaps processing in order of g from largest to smallest, and for each, compute the x, compute the LCM, and track the minimal.\n\nWait, but even if a larger g leads to a smaller x, perhaps the LCM is larger. Hmm, perhaps not. For example, let's say d is 6. The divisors are 6,3,2,1.\n\nSuppose a is 10.\n\nFor g=6: x is 12 (if 10%6 !=0, which it isn't, so x=12). x+d=18. LCM(12,18)=36.\n\nFor g=3: x is 12 (since 10%3=1, so x=12). x+6=18, same as above, LCM is 36.\n\nWait, but wait: 12 and 18 have GCD 6, so their LCM is (12*18)/6=36.\n\nAlternatively, for g=6, x=12, same result.\n\nWait, but for g=6, x=12 is the same as for g=3. So perhaps in this case, the same x is considered for multiple g's.\n\nSo perhaps, processing all divisors and considering all possible x's is needed.\n\nBut that's okay, because we can process all possibilities, and for each, compute the LCM.\n\nNow, the algorithm is:\n\nCompute all divisors of d.\n\nSort the divisors in descending order.\n\nFor each g in this list:\n\n   x = smallest multiple of g >= a.\n\n   compute current_gcd = gcd(x, x +d) --> which is g.\n\n   current_lcm = (x * (x +d)) // g.\n\n   track the minimal lcm and the corresponding k=x -a.\n\nAlso, after processing all divisors, we need to consider the case where g=1, which is already covered.\n\nWait, but what about when d is 0? Then, a ==b, so x = a +k, y = a +k. So LCM is x. So the minimal x is a, k=0.\n\nSo the initial case is handled.\n\nAnother edge case: when a =1, b=1e9.\n\nThen d=999,999,999.\n\nThe divisors are all factors of 999,999,999.\n\nBut for each g, we find x >=a=1.\n\nBut for the maximum g, which is 999,999,999, x is 1 if 1 is a multiple of 999,999,999, which it's not. So x is 999,999,999.\n\nThen, x +d is 1,999,999,998.\n\nThe GCD is 999,999,999, so the LCM is (999,999,999 * 1,999,999,998) / 999,999,999 = 1,999,999,998.\n\nWhich is a very large number.\n\nBut perhaps a smaller g gives a better result.\n\nAlternatively, perhaps the optimal is to choose x = a, which is 1.\n\nIn that case, x =1, y=1 +d =1e9 +1.\n\nTheir GCD is 1, so LCM is 1e9+1.\n\nWhich is worse than 1,999,999,998? No, 1e9+1 is about 1e9, which is less than 2e9. So perhaps x=1 is better.\n\nWait, but in this case, the optimal is to choose x=1, giving LCM 1e9+1, which is better than x=999,999,999.\n\nSo, perhaps my approach is not considering all possible x's, but only those that are multiples of a divisor of d.\n\nWait, but wait: the x in this example is 1, which is not a multiple of any divisor of d except 1.\n\nSo, when g=1, x is the smallest multiple of 1 >=a, which is 1.\n\nSo, the code will process g=1, and compute x=1, then compute LCM(1, 1e9+1) = (1 * (1e9 +1)) /1 = 1e9+1.\n\nWhich is indeed better.\n\nSo, in this case, the code correctly finds that x=1 is the optimal.\n\nBut wait, how? Because for other g's, like 3, the x is 3, which is greater than 1, leading to a larger LCM.\n\nSo, the approach is correct.\n\nThus, the steps are:\n\n1. Compute d.\n\n2. If d is zero, return k=0.\n\n3. Else, compute all the divisors of d.\n\n4. Sort them in descending order.\n\n5. For each g in this sorted list:\n\n   a. Compute x as the smallest multiple of g >=a.\n\n   b. Compute y =x +d.\n\n   c. Compute current_gcd = g.\n\n   d. Compute current_lcm = (x * y) // g.\n\n   e. Keep track of the minimal lcm and the corresponding k.\n\n6. After processing all g's, the minimal lcm and the corresponding k are found.\n\nSo, the next step is to write code that implements this.\n\nNow, the problem is to implement this in Python.\n\nLet's think about the functions needed.\n\nFirst, a function to compute all the divisors of a given number n.\n\nHow to compute the divisors of n:\n\nWe can factorize n into its prime factors, then generate all possible products of these factors.\n\nBut for n up to 1e9, trial division is feasible.\n\nSo, the function to get the divisors of n:\n\ndef get_divisors(n):\n    if n ==0:\n        return []\n    divisors = set()\n    i =1\n    while i*i <=n:\n        if n%i ==0:\n            divisors.add(i)\n            divisors.add(n//i)\n        i +=1\n    return sorted(divisors, reverse=True)\n\nWait, but this may miss some divisors if n is not square, but no, because for every i that divides n, n/i is added.\n\nWait, but in the case where i^2 =n, then i and n/i are the same, but the set takes care of duplicates.\n\nYes.\n\nSo, the function works.\n\nThen, for each g in the sorted list of divisors, compute x.\n\nx is the smallest multiple of g >=a.\n\nWhich is: if a %g ==0, x=a. Else, x = ((a //g)+1)*g.\n\nOnce x is computed, compute y =x +d.\n\nThen, compute the current_gcd as g.\n\nCompute current_lcm as (x * y) //g.\n\nThen, compare with the current minimal lcm.\n\nNow, the initial minimal lcm can be set to a very high value, like infinity.\n\nBut wait, what about when d is zero? We handle that first.\n\nNow, let's think about the example given.\n\nSample Input 1: 6 10\n\nSo, a=6, b=10, d=4.\n\nDivisors of 4 are 4,2,1.\n\nProcessing g=4:\n\nx is the smallest multiple of 4 >=6.\n\n6%4=2, so x=8.\n\ny=12.\n\nCurrent_gcd=4.\n\ncurrent_lcm= (8*12)/4 =24.\n\nProcessing g=2:\n\nx is smallest multiple of 2 >=6, which is 6.\n\ny=6+4=10.\n\ngcd is 2.\n\nlcm= (6*10)/2=30.\n\nProcessing g=1:\n\nx=6.\n\ny=10.\n\ngcd=1.\n\nlcm=60.\n\nSo the minimal is 24, achieved at x=8, which is k=2.\n\nWhich matches the sample.\n\nAnother sample: 21 31 → output is 9.\n\nCompute d=10.\n\nDivisors of 10 are 10,5,2,1.\n\nProcessing g=10:\n\nx is 21. 21%10=1, so x=30.\n\ny=40.\n\nlcm=30*40 /10=120.\n\ng=5: x=25 (since 21%5=1 → x=25).\n\ny=35.\n\ngcd is5.\n\nlcm= (25*35)/5=175.\n\nWhich is larger than 120.\n\ng=2: x=22.\n\ny=32.\n\ngcd=2.\n\nlcm= 22*32/2=352.\n\ng=1: x=21.\n\ny=31.\n\nlcm=21*31=651.\n\nSo the minimal is 120, achieved at x=30, which is k=9.\n\nAnother sample:5 10 → output 0.\n\nBecause d=5.\n\nDivisors are 5,1.\n\ng=5: x=5.\n\ny=10.\n\nlcm=10.\n\ng=1: x=5.\n\ny=10.\n\nSame lcm.\n\nSo, the minimal is 10, achieved at x=5, k=0.\n\nSo the code seems to handle this.\n\nNow, another test case: a=1, b=1e9.\n\nd=999,999,999.\n\nDivisors include 999,999,999, 333,333, etc.\n\nProcessing g=999,999,999.\n\nx=1e9.\n\ny=1e9 +999,999,999.\n\nWait, no. Wait, a=1, so x must be >=1.\n\nSo for g=999,999,999, x is 999,999,999.\n\ny=999,999,999 +999,999,999 = 1,999,999,998.\n\nlcm is (999,999,999 * 1,999,999,998) / 999,999,999 = 1,999,999,998.\n\nBut for g=1, x=1.\n\ny=1 +999,999,999=1e9.\n\nlcm= 1e9.\n\nWhich is smaller than 1,999,999,998.\n\nSo the code would process all the divisors, and for each, compute x.\n\nWhen g=1, x=1, lcm=1e9.\n\nWhich is better than others.\n\nThus, the code correctly selects the minimal.\n\nSo, the code will proceed correctly.\n\nNow, the code structure:\n\nRead a and b.\n\nCompute d=abs(a-b).\n\nIf d==0:\n\n   print(0)\n\nElse:\n\n   Compute all divisors of d.\n\n   Sort them in descending order.\n\n   Initialize min_lcm to a very large value, say float('inf').\n\n   best_k = 0.\n\n   for g in divisors:\n\n       x = a if a % g ==0 else ( (a //g ) +1 ) * g\n\n       y = x +d\n\n       current_gcd = g\n\n       current_lcm = (x * y) // current_gcd\n\n       if current_lcm < min_lcm or (current_lcm == min_lcm and x < previous_x):\n\n           min_lcm = current_lcm\n\n           best_k = x -a\n\n   After processing all, print best_k.\n\nWait, but what about the case where x is the same for multiple g's. For example, in the first sample, g=4 and g=2 both produce x=8 and x=6, respectively.\n\nWait, no, in the first sample, for g=4, x is 8, for g=2, x is 6.\n\nSo in that case, the code correctly picks the minimal.\n\nBut wait, for the first sample, the minimal lcm is 24, achieved at x=8.\n\nBut when processing g=2, x=6, which gives a larger LCM.\n\nSo the code correctly tracks the minimal.\n\nBut what about when for a certain g, the x is the same as another g's x but the LCM is the same.\n\nWait, in the third sample, a=5, b=10, d=5.\n\ndivisors are 5,1.\n\nfor g=5: x=5.\n\nlcm= (5*10)/5=10.\n\nfor g=1: x=5.\n\nlcm=50.\n\nso the minimal is 10.\n\nThus, the code correctly returns k=0.\n\nNow, the code seems correct.\n\nBut wait, another test case: a=3, b=6.\n\nd=3.\n\ndivisors are 3,1.\n\nprocessing g=3: x=3.\n\ny=6.\n\nlcm=6.\n\nprocessing g=1: x=3.\n\ny=6.\n\nlcm=6.\n\nSo, the code will choose the same k, which is 0.\n\nBut since both g's give the same lcm, the code will pick the x from the first processed g, which is 3.\n\nSo, the k is 0.\n\nBut according to the problem statement, if there are multiple k's, choose the smallest.\n\nIn this case, k=0 is the only option.\n\nThus, correct.\n\nAnother test case: a=4, b=6.\n\nd=2.\n\ndivisors are 2,1.\n\ng=2: x=4.\n\ny=6.\n\nlcm=12.\n\ng=1: x=4.\n\ny=6.\n\nlcm=12.\n\nSo, same.\n\nThus, k=0.\n\nBut what if a=4, b=7.\n\nd=3.\n\ndivisors are 3,1.\n\ng=3: x=6.\n\ny=9.\n\nlcm= (6*9)/3=18.\n\ng=1: x=4.\n\ny=7.\n\nlcm=28.\n\nThus, the minimal is 18, k=2.\n\nWhich is correct.\n\nNow, the code needs to handle all these cases.\n\nPotential issues:\n\n1. Handling d=0.\n\n2. When a is 0.\n\nWait, no, because a and b are given as >=1.\n\nWait, the input constraints are 1<=a,b <=1e9.\n\nSo a and b are always at least 1.\n\nSo, no problem.\n\nAnother issue: when a is 0, but the code doesn't need to handle that.\n\nThus, the code is correct.\n\nNow, the code:\n\nImplementing the steps.\n\nRead a and b.\n\nCompute d=abs(a-b).\n\nIf d==0: print 0.\n\nElse:\n\nCompute all divisors of d.\n\nSort them in descending order.\n\nInitialize min_lcm to a large value, and best_k=0.\n\nLoop over each g in the divisors:\n\n   x = a if a %g ==0 else ((a//g)+1)*g.\n\n   y =x +d.\n\n   current_lcm = (x*y) //g.\n\n   if current_lcm < min_lcm or (current_lcm == min_lcm and x < best_x):\n\n       min_lcm = current_lcm\n\n       best_k = x -a\n\n       best_x =x\n\nWait, perhaps we should track the best_x as well.\n\nBecause, if two different g's give the same lcm, but x is smaller, we need to pick the x that is smaller.\n\nBecause the problem says, if multiple k's give the same minimal lcm, choose the smallest k.\n\nBut x -a is the k, so the smallest x corresponds to the smallest k.\n\nThus, in the code, when a new x gives the same lcm as the current min, but x is smaller than the previous best_x, we update best_k.\n\nWait, but wait:\n\nNo, because the current x is computed based on g. So for a certain g, x may be smaller than the previous best_x, leading to a smaller k.\n\nWait, but the problem is that for two different g's, the x's can vary, and perhaps a larger g leads to a smaller x.\n\nWait, no. Because for a larger g, x is the smallest multiple of g >=a, which is possibly larger than x for a smaller g.\n\nWait, for example, a=5, d=4.\n\ndivisors are 4,2,1.\n\ng=4: x=5 if 5%4=1, so x=8.\n\ng=2: x=6.\n\ng=1: x=5.\n\nThus, for g=4, x is 8, which is larger than for g=2.\n\nThus, in general, larger g's may lead to larger x's.\n\nWait, that depends on a and g.\n\nSo, the x for a larger g can be either larger or smaller than x for a smaller g.\n\nWait, for example:\n\na=7, d=6.\n\ndivisors are 6,3,2,1.\n\ng=6: a=7, 7%6=1, x=12.\n\ng=3: a=7%3=1, x=9.\n\ng=2: a=7%2=1, x=8.\n\ng=1: x=7.\n\nSo, x decreases as g decreases.\n\nSo, in this case, the x for g=3 is 9, which is larger than x for g=2 (8), but smaller than x for g=6 (12) and g=1 (7).\n\nThus, for smaller g's, x can be smaller.\n\nThus, when processing the divisors in descending order, the code may miss x's that are smaller but come from smaller g's.\n\nBut in the code, all g's are processed, so for each, the x is computed, and the current_lcm is compared.\n\nThus, the code will find the minimal lcm.\n\nBut, for example, in the case where a=7 and d=6, the minimal x is 7, which is for g=1.\n\nThus, the code will process all g's, including 1, and compute x=7, which may give a better LCM.\n\nSo, the code is correct.\n\nThus, the code should proceed as follows.\n\nNow, implementing in Python:\n\nRead a and b.\n\nCompute d=abs(a-b).\n\nIf d==0:\n\n   print(0)\n\nElse:\n\n   divisors = get_divisors(d).\n\n   sorted in descending order.\n\n   min_lcm = infinity.\n\n   best_k = 0.\n\n   best_x = None.\n\n   for g in divisors:\n\n       if g ==0:\n\n           continue # but d is non-zero.\n\n       # Compute x.\n\n       if a %g ==0:\n\n           x =a\n\n       else:\n\n           x = ((a //g) +1)*g\n\n       # compute y.\n\n       y =x +d\n\n       # compute current_lcm.\n\n       current_gcd =g\n\n       current_lcm = (x * y) // current_gcd\n\n       # compare.\n\n       if current_lcm < min_lcm:\n\n           min_lcm = current_lcm\n\n           best_k = x -a\n\n           best_x =x\n\n       elif current_lcm == min_lcm:\n\n           # if current x is smaller than best_x, update.\n\n           if x < best_x:\n\n               best_k = x -a\n\n               best_x =x\n\n   print(best_k)\n\nWait, but what if d is 1?\n\nLike a=2, b=3.\n\nd=1.\n\ndivisors are 1.\n\ng=1.\n\nx=2.\n\ny=3.\n\nlcm=6.\n\nThus, k=0.\n\nWhich is correct.\n\nAnother test case: a=8, b=12.\n\nd=4.\n\ndivisors are 4,2,1.\n\ng=4: x=8.\n\ny=12.\n\nlcm=24.\n\ng=2: x=8.\n\ny=12.\n\nlcm=24.\n\ng=1: x=8.\n\ny=12.\n\nlcm=24.\n\nSo, the code will pick the same k=0.\n\nWhich is correct.\n\nThus, the code seems correct.\n\nNow, the code needs to handle a and b as input.\n\nIn Python, reading from stdin.\n\nBut the input is given as a single line, with two integers.\n\nSo, code:\n\nimport sys\n\ndef get_divisors(n):\n\n    if n ==0:\n\n        return []\n\n    divisors = set()\n\n    i=1\n\n    while i*i <=n:\n\n        if n%i ==0:\n\n            divisors.add(i)\n\n            divisors.add(n//i)\n\n        i +=1\n\n    return sorted(divisors, reverse=True)\n\na, b = map(int, sys.stdin.readline().split())\n\nd = abs(a -b)\n\nif d ==0:\n\n    print(0)\n\nelse:\n\n    divisors = get_divisors(d)\n\n    min_lcm = float('inf')\n\n    best_k = 0\n\n    best_x = None\n\n    for g in divisors:\n\n        if a %g ==0:\n\n            x = a\n\n        else:\n\n            x = ((a //g ) +1) *g\n\n        y =x +d\n\n        current_lcm = (x * y) // g\n\n        if current_lcm < min_lcm:\n\n            min_lcm = current_lcm\n\n            best_k = x -a\n\n            best_x =x\n\n        elif current_lcm == min_lcm:\n\n            if x < best_x:\n\n                best_k = x -a\n\n                best_x =x\n\n    print(best_k)\n\nWait, but in the code, for the case where multiple g's produce the same min_lcm, but x is smaller.\n\nThus, the code correctly updates best_k and best_x.\n\nTesting the sample input:\n\nSample Input 1:\n\n['6 10', '21 31', '5 10']\n\nWait, no, in the problem statement, the input is given as three lines, but the sample shows:\n\nInput:\n\n6 10\n\n21 31\n\n5 10\n\nOutput:\n\n2\n\n9\n\n0\n\nSo, the code should process each line.\n\nBut in the code, the input is read as a single line.\n\nWait, no: the code reads a and b from a single line.\n\nSo, for multiple test cases, the code needs to read each line.\n\nThus, the code should be adjusted to read all lines, split into pairs.\n\nWait, no, the problem statement says, \"the only line contains two integers a and b\".\n\nWait, no, looking back:\n\nProblem statement says:\n\nInput\n\nThe only line contains two integers a and b (1 ≤ a, b ≤ 1e9).\n\nAh, so the code should read a single line with two integers.\n\nThus, the code is correct as written.\n\nBut in the problem statement's sample input, it's presented as three separate lines, but that's perhaps a formatting error.\n\nThus, the code is correct.\n\nAnother thing: the get_divisors function is correct.\n\nTesting for n=4: returns [4,2,1].\n\nTesting for n=6: returns [6,3,2,1].\n\nTesting for n=12: returns [12,6,4,3,2,1].\n\nYes.\n\nThus, the code should work.\n\nSo, the final code is as written.\n",
    "response": "To solve this problem, we need to find a non-negative integer \\( k \\) such that the least common multiple (LCM) of \\( a + k \\) and \\( b + k \\) is minimized. If there are multiple values of \\( k \\) that yield the same minimal LCM, we should choose the smallest \\( k \\).\n\n### Approach\n1. **Understand the Problem**: The goal is to minimize the LCM of two numbers \\( a + k \\) and \\( b + k \\). The difference between these two numbers is fixed as \\( d = |a - b| \\). Therefore, we need to find two numbers \\( x \\) and \\( x + d \\) such that their LCM is minimized.\n\n2. **Divisors Insight**: The LCM of two numbers can be minimized by maximizing their greatest common divisor (GCD). Since \\( x \\) and \\( x + d \\) must have a GCD that is a divisor of \\( d \\), we consider all divisors of \\( d \\).\n\n3. **Compute Divisors**: Generate all divisors of \\( d \\) and sort them in descending order. This allows us to check the largest possible GCD first, which helps in minimizing the LCM.\n\n4. **Evaluate Each Divisor**: For each divisor \\( g \\) of \\( d \\), compute the smallest \\( x \\) such that \\( x \\) is a multiple of \\( g \\) and \\( x \\geq a \\). Calculate the corresponding LCM and track the minimum LCM and the corresponding \\( k \\).\n\n5. **Edge Cases**: Handle the case where \\( a \\) equals \\( b \\) separately, as this simplifies the problem to finding the smallest \\( k = 0 \\).\n\n### Solution Code\n```python\nimport sys\n\ndef get_divisors(n):\n    if n == 0:\n        return []\n    divisors = set()\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n        i += 1\n    return sorted(divisors, reverse=True)\n\na, b = map(int, sys.stdin.readline().split())\nd = abs(a - b)\n\nif d == 0:\n    print(0)\nelse:\n    divisors = get_divisors(d)\n    min_lcm = float('inf')\n    best_k = 0\n    best_x = None\n\n    for g in divisors:\n        if a % g == 0:\n            x = a\n        else:\n            x = ((a // g) + 1) * g\n        y = x + d\n        current_lcm = (x * y) // g\n        if current_lcm < min_lcm:\n            min_lcm = current_lcm\n            best_k = x - a\n            best_x = x\n        elif current_lcm == min_lcm:\n            if x < best_x:\n                best_k = x - a\n                best_x = x\n\n    print(best_k)\n```\n\n### Explanation\n1. **Reading Input**: The code reads the integers \\( a \\) and \\( b \\) from standard input.\n2. **Compute Difference**: Calculate \\( d \\) as the absolute difference between \\( a \\) and \\( b \\).\n3. **Handle Special Case**: If \\( d \\) is zero, \\( a \\) and \\( b \\) are equal, so the answer is \\( k = 0 \\).\n4. **Generate Divisors**: Compute all divisors of \\( d \\) and sort them in descending order.\n5. **Evaluate Each Divisor**: For each divisor \\( g \\), compute the smallest \\( x \\) that is a multiple of \\( g \\) and greater than or equal to \\( a \\). Calculate the corresponding LCM and update the minimum LCM and \\( k \\) if a smaller LCM is found or if the same LCM is found with a smaller \\( x \\).\n6. **Output Result**: Print the smallest \\( k \\) that achieves the minimal LCM.\n\nThis approach efficiently finds the optimal \\( k \\) by leveraging the properties of divisors and their impact on the LCM, ensuring the solution is both correct and efficient.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef get_divisors(n):\n    if n == 0:\n        return []\n    divisors = set()\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n        i += 1\n    return sorted(divisors, reverse=True)\n\na, b = map(int, sys.stdin.readline().split())\nd = abs(a - b)\n\nif d == 0:\n    print(0)\nelse:\n    divisors = get_divisors(d)\n    min_lcm = float('inf')\n    best_k = 0\n    best_x = None\n\n    for g in divisors:\n        if a % g == 0:\n            x = a\n        else:\n            x = ((a // g) + 1) * g\n        y = x + d\n        current_lcm = (x * y) // g\n        if current_lcm < min_lcm:\n            min_lcm = current_lcm\n            best_k = x - a\n            best_x = x\n        elif current_lcm == min_lcm:\n            if x < best_x:\n                best_k = x - a\n                best_x = x\n\n    print(best_k)",
    "score": 1,
    "metadata": {
        "prompt_token_count": 391,
        "completion_token_count": 888,
        "thoughts_token_count": 7096
    }
}