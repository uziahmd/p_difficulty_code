{
    "start": 1758278099.9287937,
    "end": 1758278276.597926,
    "start-formatted": "2025-09-19 19:34 KST",
    "end-formatted": "2025-09-19 19:37 KST",
    "gpu": 2,
    "pid": 21,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko Finds Grapes\n\nOn a random day, Neko found $$$n$$$ treasure chests and $$$m$$$ keys. The $$$i$$$-th chest has an integer $$$a_i$$$ written on it and the $$$j$$$-th key has an integer $$$b_j$$$ on it. Neko knows those chests contain the powerful mysterious green Grapes, thus Neko wants to open as many treasure chests as possible.The $$$j$$$-th key can be used to unlock the $$$i$$$-th chest if and only if the sum of the key number and the chest number is an odd number. Formally, $$$a_i + b_j \\equiv 1 \\pmod{2}$$$. One key can be used to open at most one chest, and one chest can be opened at most once.Find the maximum number of chests Neko can open.\n\n## Input\nThe first line contains integers $$$n$$$ and $$$m$$$ ($$$1 \\leq n, m \\leq 10^5$$$) — the number of chests and the number of keys.The second line contains $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$1 \\leq a_i \\leq 10^9$$$) — the numbers written on the treasure chests.The third line contains $$$m$$$ integers $$$b_1, b_2, \\ldots, b_m$$$ ($$$1 \\leq b_i \\leq 10^9$$$) — the numbers written on the keys.\n\n## Output\nPrint the maximum number of chests you can open.\n\n## Example\n### Input\n['5 4\\n9 14 6 2 11\\n8 4 7 20', '5 1\\n2 4 6 8 10\\n5', '1 4\\n10\\n20 30 40 50']\n\n### Output\n['3', '1', '0']\n\n## Note\nIn the first example, one possible way to unlock $$$3$$$ chests is as follows:  Use first key to unlock the fifth chest,  Use third key to unlock the second chest,  Use fourth key to unlock the first chest. In the second example, you can use the only key to unlock any single chest (note that one key can't be used twice).In the third example, no key can unlock the given chest.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read it carefully.\n\nThe problem is about Neko finding treasure chests and keys. Each chest has a number a_i, each key has b_j. The goal is to open as many chests as possible by using the keys in a certain way.\n\nThe condition for unlocking is that the sum of a_i and b_j must be odd. So, a_i + b_j ≡ 1 mod 2. Which means one is even and the other is odd. Because an even plus an odd gives an odd sum.\n\nSo, each key can be used once to unlock one chest, and each chest can only be unlocked once.\n\nHmm, so the approach here is to find the maximum number of chests we can unlock by matching the keys appropriately.\n\nLet me think about how to model this.\n\nFirst, let's categorize the chests into two groups: those with even a_i and those with odd a_i.\n\nSimilarly, for the keys, we'll categorize them into even and odd based on their b_j values.\n\nBecause for a key to unlock a chest, the parity (even or odd) of the key and chest must be different.\n\nSo, for example, if a key is even, it can only unlock chests with odd a_i. And vice versa.\n\nSo, the strategy would be:\n\n- Count the number of even and odd keys.\n- Count the number of even and odd chests.\n- Then, determine how to pair them optimally.\n\nWait, but the optimal pairing isn't just the maximum possible because each key can only be used once, and each chest too.\n\nSo, perhaps the steps are:\n\n1. Separate the a array into even_a and odd_a counts.\n2. Similarly, separate the b array into even_b and odd_b counts.\n3. Then, decide how to pair the keys to chests to maximize the number of chests opened.\n\nBut how?\n\nLet's think about the possible scenarios.\n\nEach even key can only pair with an odd chest, and each odd key can only pair with an even chest.\n\nSo, the maximum number of chests we can unlock is determined by how we match these.\n\nWait, but each key can only be used once. So, the maximum possible is the minimum between the sum of even_b and odd_b, but constrained by the available chests.\n\nWait, no. Wait, let's see:\n\nSuppose we have:\n\nEven chests: E\nOdd chests: O\n\nEven keys: K_e\nOdd keys: K_o\n\nTo unlock even chests, we need keys that are odd (because even + odd = odd, which satisfies the condition). So, for each even chest, we can assign an odd key.\n\nSimilarly, to unlock odd chests, we need even keys.\n\nSo, the total number of chests we can unlock is the sum of:\n\nmin(E, K_o) + min(O, K_e)\n\nBut wait, that's not correct because each key is used exactly once, and each chest is used once.\n\nWait, maybe not. Because when you use a key for a chest, you can't reuse it. So the total is the maximum number such that:\n\nnumber of even chests assigned to odd keys: let's say x.\n\nnumber of odd chests assigned to even keys: y.\n\nWe want x ≤ K_o, y ≤ K_e, and x + y cannot exceed the total chests.\n\nWait, no. Because each assignment uses up a key and a chest.\n\nWait, perhaps the maximum possible is the sum of:\n\nthe number of even chests that can be unlocked by odd keys, plus the number of odd chests that can be unlocked by even keys.\n\nBut since each key can be used at most once, the total number of assignments is limited by the minimum between the number of available keys and chests in each category.\n\nAlternatively, perhaps the maximum is the minimum of the sum of the two possible pairings.\n\nWait, let me think differently. Let's model this as:\n\nWe have two types of chests: even and odd.\n\nWe have two types of keys: even and odd.\n\nFor even chests, they can be unlocked by odd keys.\n\nFor odd chests, they can be unlocked by even keys.\n\nSo, the maximum number of even chests we can unlock is the minimum between the number of even chests (E) and the number of odd keys (K_o).\n\nSimilarly, the maximum number of odd chests we can unlock is the minimum between the number of odd chests (O) and the number of even keys (K_e).\n\nBut wait, that's not necessarily the case because the sum of these two might be more than the total number of keys, but the sum can't exceed the sum of the available keys.\n\nWait, no. Because each key can only be used once. So, the total number of chests unlocked is equal to the number of even chests unlocked plus the number of odd chests unlocked. But the sum can't exceed the total number of keys, because each requires a key.\n\nWait, no, because each chest uses a key",
    "response": "To solve this problem, we need to determine the maximum number of treasure chests that Neko can open using the given keys. The condition for opening a chest is that the sum of the key number and the chest number must be odd.\n\n### Approach\n1. **Categorize Chests and Keys**: Separate the chests into two groups based on whether their numbers are even or odd. Similarly, separate the keys into even and odd groups.\n2. **Count Even and Odd**: Count the number of even and odd chests and keys.\n3. **Determine Pairings**: For each type of chest (even or odd), determine how many keys of the opposite parity can unlock them. This involves:\n   - Using odd keys to unlock even chests.\n   - Using even keys to unlock odd chests.\n4. **Calculate Maximum Opened Chests**: The maximum number of chests that can be opened is the sum of the minimum possible pairings from both categories.\n\n### Solution Code\n```python\nn, m = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\neven_a = 0\nodd_a = 0\nfor num in a:\n    if num % 2 == 0:\n        even_a += 1\n    else:\n        odd_a += 1\n\neven_b = 0\nodd_b = 0\nfor num in b:\n    if num % 2 == 0:\n        even_b += 1\n    else:\n        odd_b += 1\n\n# To unlock even_a chests: need odd_b keys\nmax_even_chests = min(even_a, odd_b)\n\n# To unlock odd_a chests: need even_b keys\nmax_odd_chests = min(odd_a, even_b)\n\ntotal = max_even_chests + max_odd_chests\n\nprint(total)\n```\n\n### Explanation\n1. **Categorization**: We first categorize each chest and key into even or odd. This helps us understand which keys can unlock which chests based on their parity.\n2. **Counting**: We count how many even and odd chests and keys there are. This gives us the raw materials needed to form pairs.\n3. **Pairing Strategy**: \n   - Even chests can only be unlocked by odd keys, so we use the minimum of the count of even chests and odd keys.\n   - Odd chests can only be unlocked by even keys, so we use the minimum of the count of odd chests and even keys.\n4. **Summing Up**: The total number of chests that can be unlocked is the sum of the maximum possible pairings from both categories.\n\nThis approach ensures that we efficiently use the available keys and chests to maximize the number of chests opened, adhering to the constraints provided.",
    "ground_truth": "N/A",
    "extracted_answer": "n, m = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\neven_a = 0\nodd_a = 0\nfor num in a:\n    if num % 2 == 0:\n        even_a += 1\n    else:\n        odd_a += 1\n\neven_b = 0\nodd_b = 0\nfor num in b:\n    if num % 2 == 0:\n        even_b += 1\n    else:\n        odd_b += 1\n\n# To unlock even_a chests: need odd_b keys\nmax_even_chests = min(even_a, odd_b)\n\n# To unlock odd_a chests: need even_b keys\nmax_odd_chests = min(odd_a, even_b)\n\ntotal = max_even_chests + max_odd_chests\n\nprint(total)",
    "score": 1,
    "metadata": {
        "prompt_token_count": 584,
        "completion_token_count": 575,
        "thoughts_token_count": 1025
    }
}