{
    "start": 1758141094.3063374,
    "end": 1758142306.4772713,
    "start-formatted": "2025-09-18 05:31 KST",
    "end-formatted": "2025-09-18 05:51 KST",
    "gpu": 2,
    "pid": 8,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read it carefully.\n\nThe problem is about determining the direction of each edge in a flow network such that the resulting graph satisfies certain conditions. The goal is to make sure that for each vertex v (except the source and sink), the sum of incoming edges equals the sum of outgoing edges. Also, the source has no incoming edges, and there are no cycles in the directed graph.\n\nHmm. So the given graph is undirected, and we need to assign directions to each edge to form a directed acyclic graph (DAG) with a valid max flow.\n\nWait, but how do we determine the directions? It feels like this is related to the concept of residual graphs and maybe something like finding a DAG that preserves the max flow structure.\n\nLet me think. In a max flow, the residual graph (which is directed) doesn't have any cycles, right? Because cycles would mean augmenting paths. So perhaps the residual graph already is a DAG. But wait, in the original problem statement, the algorithm's flaw is that it only provides the flow volumes but not the directions. So I guess the idea is to construct a direction assignment such that when you compute the flow again on this directed graph, you get the same maximum flow.\n\nBut how do I ensure all the conditions are met?\n\nI remember that for a flow network, the direction of each edge in the residual graph can be determined based on the potential function. Oh right, like using a BFS to find the levels and then assigning directions according to which vertex is at a higher level.\n\nWait, yes! That's the approach. Here's the plan:\n\n1. Compute the max flow from the source to the sink.\n2. For each vertex, calculate its distance (level) from the source using BFS on the residual graph.\n3. For each edge, if ai is at a lower level than bi, then the edge should be directed from ai to bi. Otherwise, it's directed from bi to ai.\n4. This ensures that for every edge, the flow goes from a lower level to a higher level, which avoids cycles because there's no way to go back up in levels.\n\nBut wait, the problem says that the given graph is connected and a solution exists. So this approach should work.\n\nSo the steps I need to take are:\n\n- Read the input and build the graph.\n- Compute the max flow from 1 to n.\n- Once the flow is computed, build the residual graph.\n- Perform BFS from the source (vertex 1) on the residual graph to assign levels to each vertex.\n- For each original edge (ai, bi) with flow ci, check the levels of ai and bi:\n   - If level[ai] < level[bi], then the edge is directed from ai to bi (so di is 0).\n   - Else, it's directed from bi to ai (di is 1).\n\nWait, but what about the edge directions in the original undirected graph? Because the original edge could have been used in either direction in the flow.\n\nYes, exactly. So by using the level-based approach, we're ensuring that the flow respects the direction that contributes to the overall maximum flow without creating cycles.\n\nSo the main steps are: compute max flow, compute levels, assign directions based on levels.\n\nNow, the challenge is to implement this efficiently. Since n can be up to 2e5 and m up to 2e5, we need an efficient implementation.\n\nSo, let's outline the steps in code:\n\n1. Read n and m.\n2. Read m edges, each as (ai, bi, ci). Note that each edge is undirected, and the order matters for the output. We'll need to process them in the order they were given.\n3. Build the flow network. Each edge will be represented as a forward and backward edge in the adjacency list for the Dinic's algorithm.\n4. Run Dinic's algorithm to compute the max flow from 1 to n. This will give us the flow values for each edge.\n5. Then, perform BFS on the residual graph starting from the source (vertex 1) to compute the levels of each vertex.\n6. For each original edge, determine the direction based on the levels of the two vertices. Assign di accordingly.\n\nWait, but in the Dinic's algorithm, each edge has a 'flow' value, but in the residual graph, the edges are split into forward and backward edges. So perhaps during the BFS step, we consider only the forward edges in the residual graph to compute the levels.\n\nYes, because the residual graph represents the possible paths for flow, and the BFS on it gives the correct levels.\n\nSo, after computing the max flow, for each original edge (u, v, c), we need to see in which direction it was used in the flow. But how? Because each edge in the original undirected graph is either part of the residual graph in the forward or reverse direction.\n\nWait, perhaps the BFS on the residual graph's forward edges will assign the levels correctly. For each vertex, the level is the shortest distance from the source in the residual graph. Then, for each edge u-v with capacity c, if u is at a lower level than v, then the edge is directed u->v; else, v->u.\n\nThat makes sense because in the residual graph, an edge u->v (if it's present) would represent that you can push flow from u to v, which would mean the level of u is one less than v.\n\nSo the plan is solid.\n\nNow, the next step is to implement this.\n\nFirst, I need to implement Dinic's algorithm. Since the number of nodes is up to 2e5, and edges up to 2e5, the Dinic's implementation needs to be efficient, with proper data structures.\n\nIn Python, implementing Dinic's can be a bit tricky due to speed concerns, but for 2e5 edges, it's manageable with a fast implementation.\n\nOnce the max flow is computed, I proceed to build the residual graph for BFS.\n\nWait, but in the Dinic's algorithm, each edge is stored as a pair of forward and backward edges. So the residual graph includes both. So during the BFS, we need to traverse only the forward edges in the residual graph, because those are the ones that can contribute to the flow.\n\nSo the BFS is performed on the forward edges of the residual graph.\n\nOnce the BFS is done, for each original edge, we look at the levels of its endpoints. If the level of u is less than v, then the edge is directed u->v. Else, v->u.\n\nWait, but what about the case where u and v have the same level? That can't happen, because in the BFS, each node is visited once, and the level is assigned as the minimum distance. So u and v can't have the same level if they are adjacent via a residual edge.\n\nWait, no. Because the residual graph is directed, but in our case, the BFS uses the forward edges only. So if u is at level k and v is at level k, but there's a forward edge from u to v, then v's level would be k+1. So u and v can't have the same level if they are connected by a forward edge.\n\nWait, no. Let's say u is at level k, and v is also at level k. Suppose there's a forward edge from u to v. Then during BFS, when processing u, we enqueue v with level k+1. So v's level is correctly set to k+1. So, u and v can't have the same level if they are connected by a forward edge.\n\nBut what if the edge is a reverse edge? Like, suppose the residual graph has a backward edge from u to v, but not a forward edge. Then u and v might have the same level.\n\nBut in that case, the edge is not part of the forward direction in the residual graph, so the BFS won't include it. So, in that case, the edge's direction would be from v to u.\n\nSo, to restate: for each original edge, if in the residual graph there's a forward edge from u to v, then u's level is less than v's level. So the edge is directed u->v. Otherwise, it's directed v->u.\n\nSo the process is:\n\n- For each original edge (u, v, c), check if there's a forward edge from u to v in the residual graph.\n   - If yes, then the direction is u to v (di = 0).\n   - Else, the direction is v to u (di = 1).\n\nWait, but how do I check if there's a forward edge from u to v in the residual graph?\n\nBecause the original edge (u, v) may have been split into two edges in the residual graph: one in each direction.\n\nSo, in the Dinic's implementation, each edge is represented with a 'rev' pointer, which points to the reverse edge.\n\nSo, for each original edge u-v, in the Dinic's graph, there are two edges: one from u to v (forward) and one from v to u (backward). The forward edge has a capacity equal to the original c, and the backward edge has a capacity zero initially.\n\nWait, no. Wait, when building the graph for Dinic, each edge is added as a forward and a reverse edge. The forward edge has the given capacity, and the reverse edge has capacity zero.\n\nSo, for each original edge, the forward edge is u->v with capacity c, and the reverse is v->u with capacity 0.\n\nSo, when performing the BFS, we only follow the forward edges. So for the BFS, each time we process an edge, we only add the forward edges.\n\nThus, for each original edge, if during the BFS, we could reach v from u via a forward edge, then u must have a lower level than v.\n\nWait, but how do I know whether the original edge was used in the forward direction in the residual graph?\n\nWait, perhaps I'm overcomplicating. For each original edge (u, v, c), the direction in the residual graph is determined by whether u is at a lower level than v.\n\nBecause the BFS on the forward edges of the residual graph ensures that if there's a path from u to v, then the level of v is level[u] + 1.\n\nWait, no. Because the BFS is on the residual graph, which is directed, but in our case, the residual graph's forward edges are the only ones considered.\n\nSo, in the residual graph, the edges are the forward edges of the original flow network.\n\nWait, no. The residual graph includes both forward and backward edges, but during BFS, we process only the forward edges.\n\nSo, in the BFS, for each edge in the residual graph, if it's a forward edge (from u to v), then v's level is at least one more than u's.\n\nSo, for each original edge (u, v), the direction in the flow is determined by whether u's level is less than v's level. Because if u can reach v via a forward edge in the residual graph, then u's level is less than v's level.\n\nTherefore, for each original edge (u, v, c), if level[u] < level[v], then the edge is directed u->v (di=0), else v->u (di=1).\n\nSo, the steps are:\n\n1. Read the input and build the Dinic's graph.\n\n2. Compute the max flow.\n\n3. BFS on the residual graph's forward edges to compute levels.\n\n4. For each original edge, compare the levels of the two vertices and assign di accordingly.\n\nBut wait, how do I know whether u and v are connected via a forward edge in the residual graph? Because if they are, then the BFS will have processed it, and the levels will be correct.\n\nYes, so the comparison of levels directly gives us the direction.\n\nSo, the next thing is to implement this.\n\nNow, the code structure:\n\nFirst, implement Dinic's algorithm. Then, compute the levels via BFS.\n\nIn Python, implementing Dinic's for 2e5 nodes and edges can be a bit slow, but it's manageable with some optimizations.\n\nSo, here's the plan for the code:\n\nRead n and m.\n\nThen read m lines, each with ai, bi, ci.\n\nBuild the Dinic's graph. Each edge is added as a forward and reverse edge.\n\nCompute the max flow from 1 to n.\n\nThen, perform BFS on the residual graph's forward edges, starting from 1. Assign levels to each node.\n\nFor each original edge, check if level[ai] < level[bi]. If so, direction is ai -> bi (output 0). Else, direction is bi -> ai (output 1).\n\nNow, the problem is handling the Dinic's implementation correctly.\n\nIn Dinic's algorithm, each edge is represented as an object with 'to', 'rev' (the reverse edge index), 'cap' (current capacity), and 'flow'.\n\nSo, for each original edge (u, v, c), we add an edge from u to v with capacity c, and another edge from v to u with capacity 0. The 'rev' of the first edge is the index of the second, and vice versa.\n\nWhen building the graph, for each original edge, we add these two edges.\n\nThen, during BFS, for each node, we process all its outgoing edges (only forward edges) and update the levels.\n\nWait, no. Wait, the BFS is on the residual graph's forward edges only. So, during BFS, for each node u, we look at all the edges leaving u (i.e., forward edges) and process them.\n\nSo, the code for BFS is similar to standard BFS:\n\nInitialize level array to -1.\n\nqueue = deque()\n\nlevel[1] = 0\n\nqueue.append(1)\n\nwhile queue not empty:\n\n   u = queue.popleft()\n\n   for each edge in graph[u]:\n\n       if edge.cap > 0 and level[edge.to] == -1:\n\n           level[edge.to] = level[u] + 1\n\n           queue.append(edge.to)\n\nThis way, we only traverse the forward edges.\n\nYes.\n\nSo, the code proceeds as follows.\n\nNow, the problem is to implement the Dinic's algorithm correctly.\n\nPotential issues:\n\n- Implementing the graph as an adjacency list, where each entry is a list of Edge objects.\n\n- For each original edge, adding two edges: one forward and one reverse.\n\nImplementing the BFS correctly.\n\nNow, let's think about the sample input.\n\nSample Input 1:\n\n3 3\n\n3 2 10\n\n1 2 10\n\n3 1 5\n\nSo, the edges are:\n\nEdge 1: 3-2, 10\n\nEdge 2: 1-2, 10\n\nEdge 3: 3-1,5\n\nAfter building the Dinic's graph, the max flow is 15.\n\nThen, BFS from 1.\n\nLevels:\n\n1 is 0.\n\nFrom 1, we have edge to 2 (forward, cap 10). So 2's level is 1.\n\nFrom 3, looking at edge 3-1 (capacity 5, but it's a reverse edge in the residual graph?), wait no.\n\nWait, the initial edge is 3-1,5. So, in Dinic's graph, there's a forward edge from 3 to 1 (cap 5) and a reverse edge from 1 to 3 (cap 0).\n\nSo, during BFS, starting from 1, we process the edges from 1.\n\n1 has an edge to 2 (forward, cap 10). So 2 is level 1.\n\nThen, 2's edges: in the Dinic's graph, for example, edge 2-3 with cap 10. So during BFS, we process 2's forward edges. So 3 is reachable via 2, but what's the level?\n\nWait, wait, 1 has edge to 2, which is level 1. Then, 2 has edge to 3, which is forward edge (since 2 is the source and 3 is the sink in this case). So 3's level would be 2.\n\nWait, but in the sample, the edge 3-1 is 5. So in the residual graph, 3 can reach 1 via the reverse edge (since 3 has a forward edge to 1, which has cap 5). But during BFS, since the forward edge is 3->1, and in the BFS, we process forward edges only.\n\nWait, perhaps I'm getting confused. Let's try to simulate the BFS.\n\nIn the sample, after computing the flow, the levels would be:\n\n1: 0\n\n2: 1 (from 1)\n\n3: 1 (from 1 via edge 3-1?)\n\nWait, no. Because the edge 3-1 is a forward edge in the Dinic's graph. So during BFS, 3's level would be 1, because 1 can reach 3 via the forward edge 3->1? No, because in the BFS, we process edges from 1, and 1's edges are 1->2.\n\nWait, perhaps I'm getting this wrong. Let's think differently.\n\nIn the Dinic's graph, after running the BFS, the level of 1 is 0.\n\nLooking at the edges from 1: it has a forward edge to 2, which is cap 10. So 2 is at level 1.\n\nNow, looking at the edges from 2: it has a forward edge to 3, cap 10. So 3's level is 2.\n\nBut then, 3 has a forward edge to 1, cap 5. So during BFS, when processing 3, we look at the edge 3->1. However, 1 is already at level 0, which is less than 3's level (2). So the BFS does not process this edge further.\n\nSo the levels are:\n\n1: 0\n\n2: 1\n\n3: 2\n\nWait, but in the sample, the output shows that edge 3-2 is directed as 1 (direction 1, meaning 2->3), edge 1-2 is directed as 0 (1->2), and edge 3-1 is directed as 1 (3->1? Or wait, the output is ['1\\n0\\n1', ...] which corresponds to edge 3-2 being directed 2->3 (since output is 1, meaning di is 1, which is direction bi->ai).\n\nWait, let me see:\n\nOriginal edges:\n\n1. 3 2 10 → output is 1: so di is 1, meaning direction is 2→3.\n\n2. 1 2 10 → output is 0: direction is 1→2.\n\n3. 3 1 5 → output is 1: direction is 1→3? Wait, no. Because the output is di. So for each edge, if di is 0, it's ai→bi; else, bi→ai.\n\nSo for the third edge, 3 1 5: ai is 3, bi is 1. If di is 1, then the direction is 1→3.\n\nBut in the sample explanation, it says that 5 units pass directly from source to sink. Hmm.\n\nWait, perhaps the levels are:\n\n1 is level 0.\n\n2 is level 1.\n\n3 is level 2.\n\nSo for each edge:\n\nEdge 3-2 (ci=10): 3 is level 2, 2 is level 1. So 3's level is higher than 2's. So direction is 2→3, so di is 1.\n\nEdge 1-2 (ci=10): 1's level is 0, 2's level is 1. So direction is 1→2, di is 0.\n\nEdge 3-1 (ci=5): 3 is level 2, 1 is level 0. So direction is 1→3, di is 1.\n\nSo the outputs are 1, 0, 1.\n\nWhich matches the sample output.\n\nSo the approach works.\n\nAnother test case is given, but perhaps it's better to proceed.\n\nSo now, the code.\n\nImplement Dinic's:\n\nWe'll represent the graph as an adjacency list. Each entry for a node is a list of Edge objects.\n\nEach Edge has:\n\n- to: destination node.\n\n- rev: the index of the reverse edge in the adjacency list of 'to'.\n\n- cap: remaining capacity.\n\nWe'll have a list of Edge for each node.\n\nImplementing the Dinic's code:\n\nAdd edges as per the input.\n\nThen, run the Dinic's algorithm to compute the max flow.\n\nOnce the flow is computed, perform BFS on the forward edges of the residual graph.\n\nCompute levels.\n\nThen, for each original edge, determine the direction based on the levels of the two nodes.\n\nNow, the code.\n\nBut in Python, with 2e5 nodes and edges, how efficient is this?\n\nWell, Dinic's algorithm in Python can handle 2e5 edges, but it's tight. So, the code needs to be optimized.\n\nPotential optimizations:\n\n- Using adjacency lists implemented as lists, not dictionaries.\n\n- Using a deque for BFS.\n\n- Properly handling the levels.\n\nSo, code steps:\n\nRead n and m.\n\nRead m edges into a list, say 'edges'.\n\nBuild the Dinic's graph:\n\ngraph = [[] for _ in range(n+1)]\n\nfor each edge in edges:\n\n   u = ai, v = bi, c = ci.\n\n   add to graph[u]: Edge(v, len(graph[v]), c)\n\n   add to graph[v]: Edge(u, len(graph[u])-1, 0)  # reverse edge.\n\nWait, no. Because len(graph[v]) is the current length, which is the index for the new edge.\n\nWait, perhaps I should create a helper class for Edge.\n\nAlternatively, represent each edge as an object with 'to', 'rev', and 'cap'.\n\nIn Python, perhaps using a list of tuples, but for easier handling, perhaps a helper class.\n\nAlternatively, use a list of dictionaries.\n\nBut for efficiency, perhaps better to use a list of objects.\n\nSo, perhaps define a class Edge:\n\nclass Edge:\n\n    def __init__(self, to, rev, cap):\n\n        self.to = to\n\n        self.rev = rev\n\n        self.cap = cap\n\nThen, for each u, v, c:\n\ngraph[u].append( Edge(v, len(graph[v]), c) )\n\ngraph[v].append( Edge(u, len(graph[u])-1, 0) )\n\nWait, because the reverse edge is added after the forward edge, so the rev index for the forward edge is len(graph[v]) before adding the reverse.\n\nWait, for example, when we add the forward edge to u, it's the next index in graph[v]. Then, the reverse edge is added as the next index in graph[u].\n\nSo, when building the graph, for each edge (u, v, c):\n\nadd to graph[u]: Edge(v, len(graph[v]), c)\n\nthen, add to graph[v]: Edge(u, len(graph[u])-1, 0)\n\nYes.\n\nSo, the code for building the graph is:\n\nedges = []\n\nn, m = map(int, input().split())\n\nfor _ in range(m):\n\n    u, v, c = map(int, input().split())\n\n    edges.append( (u, v, c) )\n\ngraph = [[] for _ in range(n+1)]\n\nfor i in range(m):\n\n    u, v, c = edges[i]\n\n    # add forward edge to u's adjacency list\n\n    rev_u = len(graph[u])\n\n    graph[u].append( Edge(v, len(graph[v]), c) )\n\n    # add reverse edge to v's adjacency list\n\n    rev_v = len(graph[v])\n\n    graph[v].append( Edge(u, rev_u, 0) )\n\nWait, no. Because when adding the forward edge to u, the reverse edge is added to v's list. The rev for the forward edge is len(graph[v]) before adding. Similarly, when adding the reverse edge to v, the rev for the reverse edge is len(graph[u])-1.\n\nWait, perhaps the code is:\n\nfor each edge (u, v, c):\n\n    # add to u's list: forward edge to v, rev is the index of the reverse edge in v's list.\n\n    forward = Edge(v, len(graph[v]), c)\n\n    graph[u].append(forward)\n\n    # add to v's list: reverse edge to u, rev is the index of the forward edge in u's list.\n\n    reverse = Edge(u, len(graph[u])-1, 0)\n\n    graph[v].append(reverse)\n\nYes, that's correct.\n\nNow, the Dinic's algorithm.\n\nImplement the standard Dinic's:\n\nclass Edge:\n\n    def __init__(self, to, rev, cap):\n\n        self.to = to\n\n        self.rev = rev\n\n        self.cap = cap\n\ndef max_flow(s, t):\n\n    n = ... ?\n\n    level = [ -1 ] * (n+1)\n\n    ptr = [0]*(n+1)\n\n    while bfs(s, t, level, ptr):\n\n        for v in range(s, t+1):\n\n            if level[v] != -1:\n\n                h = dfs(v, t, level, ptr)\n\n                while h >0:\n\n                    e = graph[v][ptr[v]]\n\n                    e.cap -= h\n\n                    graph[e.to][e.rev].cap += h\n\n                    ptr[v] += 1\n\n                    h = e.cap\n\n                    v = e.to\n\n    return total_flow.\n\nWait, but the 'n' in the Dinic's function is the number of nodes. So, in our case, n is given.\n\nWait, but in the Dinic's function, the graph is passed as a parameter, and s and t are the source and sink.\n\nSo, in the code, the function 'max_flow' will need the graph, s, t, and n.\n\nWait, perhaps it's better to pass all necessary variables.\n\nAlternatively, in the code, the Dinic's function is inside the main code, so it can access the graph, etc.\n\nBut in Python, functions can't modify variables in the outer scope unless they are mutable and declared nonlocal. So, perhaps it's better to encapsulate the Dinic's algorithm within a class.\n\nAlternatively, just implement it with the necessary parameters.\n\nSo, the code outline:\n\nRead n and m.\n\nRead edges into 'edges' list.\n\nBuild the graph.\n\nRun max_flow(1, n) and get the result.\n\nThen, perform BFS on the forward edges to compute levels.\n\nThen, for each original edge, determine di based on levels.\n\nNow, the BFS for levels:\n\nWe can do this with a queue, similar to the Dinic's BFS.\n\nlevel = [ -1 ] * (n+1)\n\nfrom collections import deque\n\nq = deque()\n\nq.append(1)\n\nlevel[1] = 0\n\nwhile q:\n\n    u = q.popleft()\n\n    for edge in graph[u]:\n\n        if edge.cap > 0 and level[edge.to] == -1:\n\n            level[edge.to] = level[u] + 1\n\n            q.append(edge.to)\n\nOnce this is done, for each original edge (u, v, c), check if level[u] < level[v]. If so, di is 0 (u→v). Else, di is 1 (v→u).\n\nWait, no. Because the edge could be in the original list as (v, u, c), but that's not possible since the input is given as (ai, bi) which are unordered.\n\nWait, no. The input edges are given as (ai, bi), but in the code, when building the graph, for each edge, both u and v are treated as in the input.\n\nWait, no. The edges are stored as (u, v, c), but in the code, for each edge (u, v, c), when adding to the graph, the forward edge is u→v, and the reverse is v→u.\n\nSo, when processing the original edges, each is stored as (u, v, c) in the edges list. So, when we process each edge, we have to check the levels of u and v as per their original positions.\n\nWait, no. Because the original edges are stored as (ai, bi, ci), and in the code, for each original edge, u is ai, v is bi.\n\nSo, for each edge in the edges list, u is ai, v is bi.\n\nThus, for each original edge, the code must compare level[u] and level[v], and assign di based on that.\n\nSo, in the code:\n\nfor u, v, c in edges:\n\n    if level[u] < level[v]:\n\n        print(0)\n\n    else:\n\n        print(1)\n\nWait, but in the sample input, the first edge is 3 2 10. After BFS, level[3] is 2, level[2] is 1. So 3's level is higher than 2's. So di is 1.\n\nWhich matches the sample.\n\nYes.\n\nNow, let's think about the second test case.\n\nBut perhaps that's beyond the point.\n\nPotential corner cases:\n\n- Edges that form a cycle but are directed in a way that doesn't form a cycle in the directed graph.\n\nBut the problem statement says that the solution exists, so the code can rely on the levels to avoid cycles.\n\nAnother corner case: when a node has multiple edges to another node. The level assignment must ensure that the direction is consistent.\n\nSo, the code seems solid.\n\nNow, the final step is to write the code.\n\nBut in Python, implementing the Dinic's algorithm with 2e5 nodes and edges can be time-consuming. So, the code must be optimized.\n\nAlternative approaches: Use a more efficient BFS and DFS implementation, perhaps with iterative methods instead of recursive.\n\nBut in any case, the code must be written.\n\nSo, putting it all together:\n\nRead the input, build the graph.\n\nCompute the max flow.\n\nCompute the levels via BFS.\n\nFor each original edge, output 0 or 1 based on the levels.\n\nNow, the code:\n\nRead n and m.\n\nedges = list of tuples (u, v, c).\n\nBuild the graph as a list of Edge objects.\n\nImplement Dinic's algorithm.\n\nBut in Python, implementing the Edge class and the Dinic's algorithm may be slow for 2e5 edges.\n\nAlternative approach: use adjacency lists with tuples representing edges, but perhaps it's manageable.\n\nBut for the purposes of this problem, perhaps the code can be written as follows.\n\nWait, but in Python, using classes for edges may be slower than using a list of tuples. So, perhaps for efficiency, we can represent each edge as a tuple with (to, rev, cap), but in practice, using a list of dictionaries or tuples may be more efficient.\n\nAlternatively, perhaps we can represent the graph as a list of lists, where each entry is a dictionary with 'to', 'rev', 'cap'.\n\nBut for the sake of time, perhaps proceed with the Edge class.\n\nSo, here's the code:\n\nimport sys\nfrom collections import deque\n\nclass Edge:\n    def __init__(self, to, rev, cap):\n        self.to = to\n        self.rev = rev\n        self.cap = cap\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr +=1\n    m = int(input[ptr])\n    ptr +=1\n    edges = []\n    for _ in range(m):\n        u = int(input[ptr])\n        ptr +=1\n        v = int(input[ptr])\n        ptr +=1\n        c = int(input[ptr])\n        ptr +=1\n        edges.append( (u, v, c) )\n\n    # Build the graph\n    graph = [[] for _ in range(n+1)]\n    for i in range(m):\n        u, v, c = edges[i]\n        # Add forward edge to u\n        forward = Edge(v, len(graph[v]), c)\n        graph[u].append(forward)\n        # Add reverse edge to v\n        reverse = Edge(u, len(graph[u])-1, 0)\n        graph[v].append(reverse)\n\n    # Compute max flow\n    def max_flow(s, t):\n        n = s\n        level = [ -1 ] * (n+1)\n        ptr = [0]*(n+1)\n        flow = 0\n\n        def bfs():\n            q = deque()\n            level[:] = [-1]*(n+1)\n            level[s] = 0\n            q.append(s)\n            while q:\n                u = q.popleft()\n                for edge in graph[u]:\n                    if edge.cap > 0 and level[edge.to] == -1:\n                        level[edge.to] = level[u]+1\n                        q.append(edge.to)\n                        if edge.to == t:\n                            return True\n            return False\n\n        def dfs(u):\n            for edge in graph[u]:\n                if edge.cap > 0 and level[edge.to] == level[u]+1:\n                    min_flow = min(edge.cap, dfs(edge.to))\n                    edge.cap -= min_flow\n                    graph[edge.to][edge.rev].cap += min_flow\n                    return min_flow\n            return 0\n\n        while bfs():\n            f = dfs(s)\n            if f ==0:\n                break\n            flow +=f\n        return flow\n\n    maxf = max_flow(1, n)\n\n    # Compute levels via BFS on forward edges\n    level = [ -1 ]*(n+1)\n    q = deque()\n    level[1] =0\n    q.append(1)\n    while q:\n        u = q.popleft()\n        for edge in graph[u]:\n            if edge.cap >0 and level[edge.to] == -1:\n                level[edge.to] = level[u]+1\n                q.append(edge.to)\n\n    # Now, for each original edge, determine di\n    for u, v, c in edges:\n        if level[u] < level[v]:\n            print(0)\n        else:\n            print(1)\n\nBut wait, in the Dinic's function, the 'n' is the number of nodes. So in the function, 'n' is passed as the source's value, which is 1 in this case.\n\nBut in the Dinic's function, the graph is built for all nodes, so the 'n' variable inside the function is incorrect.\n\nWait, in the code above, the 'n' variable is set to s, which is 1. That's incorrect.\n\nAh, yes, that's a bug.\n\nSo, the Dinic's function is incorrect.\n\nHow to fix it.\n\nWe need to pass the correct number of nodes to the Dinic's function.\n\nBut in the code, the Dinic's function is defined inside the main function, and the graph is built outside.\n\nSo, the 'n' variable inside the Dinic's function should be the number of nodes, which is the global n variable.\n\nSo, the code for the Dinic's function should be:\n\ndef max_flow(s, t):\n    global n\n    level = [ -1 ] * (n+1)\n    ptr = [0]*(n+1)\n    flow = 0\n\n    def bfs():\n        q = deque()\n        level[:] = [-1]*(n+1)\n        level[s] = 0\n        q.append(s)\n        while q:\n            u = q.popleft()\n            for edge in graph[u]:\n                if edge.cap > 0 and level[edge.to] == -1:\n                    level[edge.to] = level[u]+1\n                    q.append(edge.to)\n                    if edge.to == t:\n                        return True\n        return False\n\n    def dfs(u):\n        for edge in graph[u]:\n            if edge.cap > 0 and level[edge.to] == level[u]+1:\n                min_flow = min(edge.cap, dfs(edge.to))\n                edge.cap -= min_flow\n                graph[edge.to][edge.rev].cap += min_flow\n                return min_flow\n        return 0\n\n    while bfs():\n        f = dfs(s)\n        if f ==0:\n            break\n        flow +=f\n    return flow\n\nYes, that's the correct approach.\n\nSo, the code needs to be updated.\n\nThus, the complete code is as above.\n\nTesting this code with the sample input:\n\nSample Input 1:\n\n3 3\n\n3 2 10\n\n1 2 10\n\n3 1 5\n\nThe code should compute max flow as 15.\n\nThen, the BFS assigns levels:\n\n1: 0\n\n2: 1 (from 1)\n\n3: 2 (from 2)\n\nSo, the edges:\n\nEdge 3-2: 3's level is 2 > 2's level 1 → di=1.\n\nEdge 1-2: 1's level is 0 < 2's level 1 → di=0.\n\nEdge 3-1: 3's level is 2 > 1's level 0 → di=1.\n\nWhich matches the sample output.\n\nAnother test case is given, but perhaps it's not needed for now.\n\nThus, the code should be correct.\n",
    "response": "To solve this problem, we need to determine the direction of each edge in a flow network such that the resulting graph satisfies specific conditions. The goal is to ensure that for each vertex (except the source and sink), the sum of incoming edges equals the sum of outgoing edges, the source has no incoming edges, and the graph does not have cycles.\n\n### Approach\n1. **Problem Analysis**: The given undirected graph needs to be converted into a directed graph where each edge's direction ensures maximum flow without cycles. This can be achieved by using the concept of residual graphs and BFS to determine the levels of each vertex from the source.\n\n2. **Max Flow Computation**: Use Dinic's algorithm to compute the maximum flow from the source (vertex 1) to the sink (vertex n). This will help us understand how flow is distributed through the graph.\n\n3. **Residual Graph and Levels**: After computing the max flow, construct the residual graph. Perform BFS on this residual graph starting from the source to determine the level (distance) of each vertex from the source. This helps in determining the direction of each edge based on the levels of its endpoints.\n\n4. **Edge Direction Determination**: For each original edge, if the level of the starting vertex is less than the level of the ending vertex, direct the edge from the starting vertex to the ending vertex. Otherwise, direct it in the reverse direction.\n\n### Solution Code\n```python\nimport sys\nfrom collections import deque\n\nclass Edge:\n    def __init__(self, to, rev, cap):\n        self.to = to\n        self.rev = rev\n        self.cap = cap\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr +=1\n    m = int(input[ptr])\n    ptr +=1\n    edges = []\n    for _ in range(m):\n        u = int(input[ptr])\n        ptr +=1\n        v = int(input[ptr])\n        ptr +=1\n        c = int(input[ptr])\n        ptr +=1\n        edges.append( (u, v, c) )\n\n    # Build the graph\n    graph = [[] for _ in range(n+1)]\n    for i in range(m):\n        u, v, c = edges[i]\n        # Add forward edge to u\n        forward = Edge(v, len(graph[v]), c)\n        graph[u].append(forward)\n        # Add reverse edge to v\n        reverse = Edge(u, len(graph[u])-1, 0)\n        graph[v].append(reverse)\n\n    # Compute max flow\n    def max_flow(s, t):\n        nonlocal n\n        level = [-1] * (n + 1)\n        ptr = [0] * (n + 1)\n        flow = 0\n\n        def bfs():\n            q = deque()\n            level[:] = [-1] * (n + 1)\n            level[s] = 0\n            q.append(s)\n            while q:\n                u = q.popleft()\n                for edge in graph[u]:\n                    if edge.cap > 0 and level[edge.to] == -1:\n                        level[edge.to] = level[u] + 1\n                        q.append(edge.to)\n                        if edge.to == t:\n                            return True\n            return False\n\n        def dfs(u):\n            for edge in graph[u]:\n                if edge.cap > 0 and level[edge.to] == level[u] + 1:\n                    min_flow = min(edge.cap, dfs(edge.to))\n                    edge.cap -= min_flow\n                    graph[edge.to][edge.rev].cap += min_flow\n                    return min_flow\n            return 0\n\n        while bfs():\n            f = dfs(s)\n            if f == 0:\n                break\n            flow += f\n        return flow\n\n    maxf = max_flow(1, n)\n\n    # Compute levels via BFS on forward edges\n    level = [-1] * (n + 1)\n    q = deque()\n    level[1] = 0\n    q.append(1)\n    while q:\n        u = q.popleft()\n        for edge in graph[u]:\n            if edge.cap > 0 and level[edge.to] == -1:\n                level[edge.to] = level[u] + 1\n                q.append(edge.to)\n\n    # Now, for each original edge, determine di\n    for u, v, c in edges:\n        if level[u] < level[v]:\n            print(0)\n        else:\n            print(1)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Reading Input**: The input is read and parsed into vertices and edges.\n- **Graph Construction**: The graph is built using adjacency lists where each edge is represented as a forward and reverse edge.\n- **Max Flow Calculation**: Dinic's algorithm is used to compute the maximum flow from the source to the sink.\n- **Level Calculation**: BFS is performed on the residual graph to determine the level of each vertex from the source.\n- **Edge Direction**: For each edge, the direction is determined based on the levels of its endpoints, ensuring the flow is directed correctly without cycles.\n\nThis approach efficiently converts the undirected graph into a directed acyclic graph (DAG) that respects the maximum flow conditions.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\nclass Edge:\n    def __init__(self, to, rev, cap):\n        self.to = to\n        self.rev = rev\n        self.cap = cap\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr +=1\n    m = int(input[ptr])\n    ptr +=1\n    edges = []\n    for _ in range(m):\n        u = int(input[ptr])\n        ptr +=1\n        v = int(input[ptr])\n        ptr +=1\n        c = int(input[ptr])\n        ptr +=1\n        edges.append( (u, v, c) )\n\n    # Build the graph\n    graph = [[] for _ in range(n+1)]\n    for i in range(m):\n        u, v, c = edges[i]\n        # Add forward edge to u\n        forward = Edge(v, len(graph[v]), c)\n        graph[u].append(forward)\n        # Add reverse edge to v\n        reverse = Edge(u, len(graph[u])-1, 0)\n        graph[v].append(reverse)\n\n    # Compute max flow\n    def max_flow(s, t):\n        nonlocal n\n        level = [-1] * (n + 1)\n        ptr = [0] * (n + 1)\n        flow = 0\n\n        def bfs():\n            q = deque()\n            level[:] = [-1] * (n + 1)\n            level[s] = 0\n            q.append(s)\n            while q:\n                u = q.popleft()\n                for edge in graph[u]:\n                    if edge.cap > 0 and level[edge.to] == -1:\n                        level[edge.to] = level[u] + 1\n                        q.append(edge.to)\n                        if edge.to == t:\n                            return True\n            return False\n\n        def dfs(u):\n            for edge in graph[u]:\n                if edge.cap > 0 and level[edge.to] == level[u] + 1:\n                    min_flow = min(edge.cap, dfs(edge.to))\n                    edge.cap -= min_flow\n                    graph[edge.to][edge.rev].cap += min_flow\n                    return min_flow\n            return 0\n\n        while bfs():\n            f = dfs(s)\n            if f == 0:\n                break\n            flow += f\n        return flow\n\n    maxf = max_flow(1, n)\n\n    # Compute levels via BFS on forward edges\n    level = [-1] * (n + 1)\n    q = deque()\n    level[1] = 0\n    q.append(1)\n    while q:\n        u = q.popleft()\n        for edge in graph[u]:\n            if edge.cap > 0 and level[edge.to] == -1:\n                level[edge.to] = level[u] + 1\n                q.append(edge.to)\n\n    # Now, for each original edge, determine di\n    for u, v, c in edges:\n        if level[u] < level[v]:\n            print(0)\n        else:\n            print(1)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 659,
        "completion_token_count": 1101,
        "thoughts_token_count": 7881
    }
}