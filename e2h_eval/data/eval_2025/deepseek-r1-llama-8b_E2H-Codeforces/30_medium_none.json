{
    "start": 1758288478.4998624,
    "end": 1758290887.974904,
    "start-formatted": "2025-09-19 22:27 KST",
    "end-formatted": "2025-09-19 23:08 KST",
    "gpu": 2,
    "pid": 30,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# TV Game\n\nThere is a new TV game on BerTV. In this game two players get a number A consisting of 2n digits. Before each turn players determine who will make the next move. Each player should make exactly n moves. On it's turn i-th player takes the leftmost digit of A and appends it to his or her number Si. After that this leftmost digit is erased from A. Initially the numbers of both players (S1 and S2) are «empty». Leading zeroes in numbers A, S1, S2 are allowed. In the end of the game the first player gets S1 dollars, and the second gets S2 dollars.One day Homer and Marge came to play the game. They managed to know the number A beforehand. They want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize. Help them.\n\n## Input\nThe first line contains integer n (1 ≤ n ≤ 18). The second line contains integer A consisting of exactly 2n digits. This number can have leading zeroes.\n\n## Output\nOutput the line of 2n characters «H» and «M» — the sequence of moves of Homer and Marge, which gives them maximum possible total prize. Each player must make exactly n moves. If there are several solutions, output any of them.\n\n## Example\n### Input\n['2\\n1234', '2\\n9911']\n\n### Output\n['HHMM', 'HMHM']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read it carefully.\n\nThe problem is about a TV game where two players, Homer and Marge, take turns picking digits from a string A. The string A has exactly 2n digits. They each make exactly n moves. On each turn, the current player takes the leftmost digit of A, appends it to their number, and then that digit is removed from A. The goal is to maximize the sum of their numbers, S1 and S2, which are the sums of the digits each has collected. We need to output the sequence of moves (H for Homer, M for Marge) that achieves this maximum.\n\nHmm. So, the task is to decide for each position whether it's H or M such that when you split the digits into two parts, each part of size n, the sum of the digits in each part is as large as possible.\n\nWait, no. Because the order in which they pick affects the distribution. For example, if the first digit is very high, assigning it to H might give a higher overall sum than to M. But also, the second digit is next, but the assignment depends on how the prior choices affect the rest.\n\nSo, the approach needs to model this as a decision tree. At each step, choose whether the current digit goes to H or M, considering the impact on the remaining digits.\n\nThis sounds like a dynamic programming problem. Since n can be up to 18, the total number of digits is 36, which is manageable with certain DP approaches.\n\nLet me think about how to model this.\n\nAt any state, we can represent the current position in the string, how many digits each player has taken so far, and some information about the current state. But since the sum is what matters, perhaps we can model the DP state based on the current index, and the number of digits taken by H and M so far.\n\nYes. So the state would be (pos, h, m), where pos is the current position in the string, h is the number of digits taken by H so far, and m is the number taken by M. Since each move alternates between the players, h and m must satisfy |h - m| <= 1, because each player takes turns.\n\nWait, because each move, one digit is taken. So after k steps, the counts for H and M would be either equal or differ by one, depending on who starts. Wait, no—since the initial counts are zero, after each step, one more digit is added. So for even steps, both have the same count; for odd steps, H has one more than M if he started first.\n\nWait, wait. Let's see: the order is determined by the sequence of moves. Since the players alternate turns, starting with whoever is chosen first. So the first digit goes to either H or M. Then the second to the other, etc.\n\nBut the problem allows us to choose the order of moves, i.e., decide at each step whether H or M picks the next digit. So the sequence is a permutation of H and M of length 2n, but each player appears exactly n times.\n\nWait, no. Each player makes exactly n moves. So the sequence is a string of 2n characters, each 'H' or 'M', with exactly n of each.\n\nSo the problem is to arrange the 2n digits into two strings of length n each, such that when the digits are taken in the order given by the sequence, the sum of H's digits is as large as possible plus the sum of M's digits is as large as possible.\n\nWait, no. Because the sum is the sum of the digits in each player's string. So the total is S1 + S2, which is the sum of all digits. So to maximize the sum, it's equivalent to maximize S1 + S2, which is fixed because all digits are summed. Wait, no! Because S1 + S2 is the sum of all digits, so it's fixed regardless of the assignment. So the problem is to maximize the sum of S1 and S2, which is fixed, but wait, no—wait, S1 is the sum of H's digits, S2 is the sum of M's digits. So S1 + S2 is the sum of all digits, which is fixed. So maximizing S1 + S2 is not the goal; rather, perhaps the problem is to maximize something else.\n\nWait, no. The problem says, \"maximize their total prize.\" Their total prize is S1 + S2, which is the sum of all digits. But that sum is fixed, so that can't be the goal. Wait, maybe I'm misunderstanding the problem. Oh, wait, maybe the prize is S1 dollars and S2 dollars. So the total is S1 + S2, but that's fixed. So perhaps the problem is to maximize the difference between S1 and S2? Or wait, perhaps the problem is to maximize the sum of the individual prizes, but since S1 + S2 is fixed, maybe the problem is to maximize S1 * S2 or something else. Hmm, but looking back at the problem statement:\n\n\"In the end of the game the first player gets S1 dollars, and the second gets S2 dollars.\"\n\nSo the output is the sequence of moves that maximizes their total prize, which is S1 + S2. But S1 + S2 is fixed as the sum of all digits. So why is the problem to find the sequence that maximizes this?\n\nWait, that can't be right. So perhaps I'm missing something. Maybe the problem is to maximize the sum of S1 and S2, but that's fixed, so the problem must be to maximize the difference between S1 and S2. Or perhaps the problem is to maximize the sum of S1 and S2 in a way that depends on the order of taking the digits.\n\nWait, perhaps I'm misunderstanding. Let me re-read the problem statement.\n\nNo, the sum S1 + S2 is fixed as the sum of all digits. So the problem's objective is to maximize S1 + S2, which is already fixed. Therefore, perhaps the problem is to maximize the sum of S1 and S2, which is fixed, but the question is about which sequence leads to that maximum. But that doesn't make sense because the sum is fixed regardless of the order.\n\nWait, that can't be. So perhaps I've misunderstood the problem.\n\nWait, perhaps the problem is to maximize the product of S1 and S2. Or perhaps the sum of S1 squared plus S2 squared, but the problem statement isn't clear.\n\nWait, looking back: the problem says, \"maximizes their total prize.\" So S1 is the amount for Homer, S2 for Marge. So the total prize is S1 + S2, which is fixed. So the problem must be to maximize something else.\n\nAh! Wait, perhaps it's the sum of the squares of S1 and S2. Or perhaps it's to maximize the maximum of S1 and S2. Or perhaps the problem is to maximize the sum of S1 and S2, but since that's fixed, the problem is trivial, which is impossible.\n\nWait, perhaps I've made a mistake in understanding the problem. Let me read again.\n\nNo, the problem says that the prize is S1 and S2. So the total is S1 + S2, which is fixed. So perhaps the problem is to find a way to assign the digits to H and M such that S1 is as large as possible, given that S2 is determined by the assignment.\n\nWait, but then the problem becomes to maximize S1, because S2 is the sum of the remaining digits.\n\nWait, but the problem requires that both make exactly n moves. So it's a matter of partitioning the 2n digits into two groups of n digits each, such that the sum of each group is as large as possible.\n\nWait, but that's not correct because the order in which digits are picked affects which group they end up in. Because the selection is done in a specific order, and each player takes the next available digit on their turn.\n\nWait, but the problem allows us to choose the order of H and M's turns. So the order is determined by the sequence, and each digit is assigned to H or M based on whether it's their turn when that digit is taken.\n\nSo the goal is to select a permutation of H and M of length 2n, with exactly n H's and n M's, such that when the digits are processed in that order, the sum of H's digits plus the sum of M's digits is maximized. But as I thought before, S1 + S2 is fixed, so the problem must be to maximize the individual sums, perhaps.\n\nWait, perhaps the problem is to maximize the minimum of S1 and S2. Or perhaps it's to maximize the product S1 * S2. But the problem statement doesn't say that.\n\nAlternatively, perhaps the problem is to maximize the sum of S1 and S2, which is fixed, but the way the digits are taken affects how much each player gets. So perhaps the problem is to find a way to assign the digits to H and M such that the sum of their individual totals is as high as possible. But that's the same as the sum being fixed.\n\nWait, perhaps I'm overcomplicating this. Let me think differently.\n\nEach time a player takes a digit, it adds to their sum. So the earlier digits are more valuable because they can contribute to more significant positions in the number, but in this problem, each digit is just added as a number, regardless of its position. So the order in which digits are picked only determines which player gets which digit. So the problem reduces to assigning the digits to H and M, each getting n digits, such that the sum of all digits is S1 + S2, which is fixed. So the problem's objective is to maximize something else.\n\nWait, perhaps the problem is to maximize the maximum of S1 and S2. Or perhaps the problem is to maximize the difference between S1 and S2.\n\nBut the problem statement says, \"maximizes their total prize.\" So perhaps the problem is to maximize S1 + S2, which is fixed, but that's not possible. So perhaps the problem is to find a way to split the digits into two groups of n each, such that the sum of the two groups is as large as possible, but that's fixed. So perhaps the problem is to arrange the digits in a way that when the players take them in the given order, the sum of H's digits is as large as possible, or M's.\n\nWait, perhaps the problem is to maximize S1 + S2, which is fixed, but the way the digits are assigned affects which player gets which digits. So the problem is to find a way to assign the digits to H and M in such a way that the sum of their individual digits is as large as possible. But again, that's fixed.\n\nI think I'm stuck here. Let me read the problem statement again.\n\nThe problem says, \"they want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize.\"\n\nWait, perhaps the total prize is S1 + S2, but since that's fixed, the problem must be to maximize the maximum of S1 and S2. Or perhaps to maximize S1 * S2.\n\nBut the problem statement isn't clear. Wait, perhaps I should look at the sample input and output to get a clue.\n\nSample Input:\nn=2\nA=1234\n\nSample Output:\nHHMM\n\nHomer's digits: 1, 2 → sum 3\nMarge's digits: 3,4 → sum 7\nTotal is 10.\n\nAnother possible arrangement could be HMHM:\nHomer takes 1,3; Marge takes 2,4 → sum 4 and 6 → total 10.\n\nWait, but according to the sample output, the output is HHMM, which gives H 3 and M 7.\n\nBut perhaps there's another arrangement where S1 is larger. Like HMMH: H takes 1,3; M takes 2,4. Sum is 4 and 6, same as before.\n\nWait, but in the sample output, it's giving HHMM. Why?\n\nBecause perhaps the sum S1 is 3, S2 is 7. Another arrangement could be HMHM, which gives S1 4, S2 6, but the total is still 10. But the problem statement says to maximize their total prize, which is 10 in all cases.\n\nSo the sample seems to have multiple solutions. The problem's output is to choose any of them.\n\nWait, but the sample shows that the output is HHMM, which gives H 3, M 7.\n\nSo why is that the best? Because perhaps the problem is to maximize the sum of the digits, which is fixed, but perhaps to find the arrangement that allows both players to have as large a sum as possible. But that's unclear.\n\nAlternatively, perhaps the problem is to maximize the sum of the two individual sums, but that's fixed. So perhaps the problem is to maximize the sum of the individual digits, which is fixed, but the way to do that is to distribute the digits in such a way that both players get as high as possible digits.\n\nWait, maybe the problem is to maximize the sum of the digits, which is fixed, but the way to achieve it is to have as many high digits as possible in both players' sequences. So perhaps the problem is to arrange the digits so that the highest digits go to both players as early as possible, thus allowing the lower digits to be assigned later.\n\nHmm, perhaps the way to model this is to always choose the next digit for the player whose current sum is smaller. That way, we balance the sums, ensuring that both players get as many high digits as possible.\n\nAlternatively, perhaps the optimal strategy is to greedily assign each digit to the player who currently has the smaller sum, to balance the totals.\n\nSo, thinking along these lines, perhaps a dynamic programming approach where the state is the current position, and the sum of H and M so far, and we track the maximum possible sum for the remaining digits.\n\nWait, but the state would be too big. Because for each position, the sum of H and M can be up to 9*36 = 324. So for 36 positions and possible sum pairs, the state space is manageable.\n\nWait, let's model the DP state as follows:\n\ndp[pos][h_sum][m_sum] = the maximum possible total sum (which is fixed) minus the remaining digits. But perhaps the state can track the current sum of H and M, and the current position, and the maximum value.\n\nWait, perhaps the DP state is (current index, h_sum, m_sum), representing the sum of H's digits so far and M's sum so far. The transition would be, for the current digit, choose whether to assign it to H or M, update the sums, and proceed to the next position.\n\nBut since the sum is fixed, the total sum is known. So the DP can track the current h_sum and m_sum, and the maximum of h_sum + m_sum is fixed, so perhaps we don't need to track it.\n\nWait, perhaps the DP is to track the current h_sum and m_sum, and for each state, determine the maximum possible h_sum + m_sum, but that's fixed. So perhaps the problem is to find a path through the digits that allows the largest possible h_sum and m_sum, but that's not the case.\n\nAlternatively, perhaps the problem is to maximize the minimum of h_sum and m_sum.\n\nWait, perhaps the problem is to maximize the sum of h_sum and m_sum, which is fixed, but perhaps the way to do it is to assign the digits in a way that each player gets as high as possible digits early on, allowing the other to collect higher ones later.\n\nAlternatively, perhaps the problem is to find a way to assign the digits to H and M such that the sum of their individual digits is as large as possible, but that's fixed.\n\nWait, I'm getting stuck. Let me think about the problem differently.\n\nSince the sum S1 + S2 is fixed, perhaps the problem is to maximize the product S1 * S2. Because that would make the total as large as possible. So the goal is to split the digits into two groups of n each, such that the product of their sums is maximized.\n\nThat makes sense. Because for a fixed sum, the product is maximized when the two numbers are as close as possible. So perhaps the problem is to split the digits into two groups with sums as close as possible.\n\nBut the sample input shows that in the case of 1234, the sum is 10, and the maximum product is 3 *7 =21, while 4*6=24, but 24 is larger. So why does the sample output choose HHMM?\n\nWait, the sample input is n=2, A=1234.\n\nIn the sample output, the sequence is HHMM. So the digits are taken in order 1,2,3,4.\n\nHomer takes 1 and 2: sum 3.\n\nMarge takes 3 and 4: sum 7.\n\nProduct is 21.\n\nBut if the sequence is HMHM, H takes 1,3: sum 4.\n\nM takes 2,4: sum 6.\n\nProduct is 24, which is higher.\n\nBut the sample output is HHMM. So that suggests that the problem's goal is not to maximize the product, but something else.\n\nAlternatively, perhaps the problem is to maximize the sum of S1 and S2, but that's fixed. So perhaps the problem is to maximize the maximum of S1 and S2.\n\nIn the sample, HHMM gives S1=3, S2=7 → max is 7.\n\nIf the sequence were HMHM, S1=4, S2=6 → max is 6. So 7 is larger than 6. So the sample chooses the sequence that gives the higher maximum.\n\nSo perhaps the problem's objective is to maximize the maximum of S1 and S2.\n\nThat makes sense. So the goal is to assign the digits in such a way that the maximum of S1 and S2 is as large as possible.\n\nIn the sample, assigning the higher digits to one player gives a higher maximum.\n\nSo now the problem is clearer: we need to assign the digits to H and M in such a way that the maximum of their sums is as large as possible.\n\nSo our goal is to split the digits into two groups of n each, such that the maximum of their sums is as large as possible.\n\nThat's a different objective function.\n\nNow, how to model this.\n\nWe can model it using dynamic programming. The state will be the current position, the number of digits taken by H and M so far, and the sum of H and M's digits.\n\nBut since the sum can be up to 9*36=324, and the position is up to 36, the state space is manageable.\n\nAt each step, for the current digit, we can choose to assign it to H or M, provided that the number of digits taken by each doesn't exceed n.\n\nSo, the DP state can be represented as:\n\ndp[i][h][m] = maximum possible maximum(S1, S2) given that we've processed the first i digits, H has h digits, M has m digits, and the current digit is A[i].\n\nWait, but the processing is in the order of the sequence. So the order in which digits are taken affects which digits are assigned to whom.\n\nSo, the problem is similar to building a decision tree where each node represents the current position in the string, the number of digits each player has taken so far, and the current sum of each.\n\nThe transitions would involve choosing whether to assign the current digit to H or M, provided that the count doesn't exceed n for either.\n\nThe DP will track, for each state, the maximum possible maximum of the two sums.\n\nSo, for each state (i, h, m), the maximum of the two sums is stored.\n\nThe base case is when i == 2n, where the maximum is the maximum of the two sums.\n\nFor each state, we can try both options: assign the current digit to H or to M, provided that h < n or m < n respectively.\n\nThe recurrence is:\n\nif we assign to H:\nnew_h = h + int(A[i])\nnew_m = m\nsum_h = new_h\nsum_m = new_m\ncurrent_max = max(sum_h, sum_m)\nif dp[i+1][new_h][new_m] < current_max:\n    dp[i+1][new_h][new_m] = current_max\n\nSimilarly for assigning to M.\n\nWait, but for each state, the current_max is the maximum between the new sums. However, the actual maximum could be determined at the end when all digits are processed.\n\nSo, the DP state needs to track the current sum for H and M, and the current position. The value stored is the maximum of the two sums achievable from that state onward.\n\nThus, the transition is:\n\nfor each state (i, h, m):\n   if we assign A[i] to H:\n       new_h = h + value\n       new_m = m\n       next_state = (i+1, new_h, new_m)\n       next_max = max(new_h, new_m)\n       if dp[next_state] < next_max:\n           update dp[next_state]\n   else:\n       similar for M.\n\nSo, the DP can be implemented as follows:\n\n- Initialize the DP table with all -infinity, except the starting state (0,0,0) with max sum 0.\n\n- For each state, consider assigning the current digit to H or M, if allowed.\n\n- Update the DP accordingly.\n\nFinally, after processing all digits, the maximum of the two sums is determined.\n\nSo, the plan is:\n\n1. Convert the input string A into a list of integers.\n\n2. Initialize a 3-dimensional DP array, where dp[i][h][m] represents the maximum possible maximum sum achievable starting from the i-th digit, with h digits assigned to H and m to M.\n\n3. Iterate through each digit, updating the DP states by considering assigning the digit to H or M.\n\n4. After processing all digits, the answer is the maximum of the two sums.\n\nBut since the DP's value is the maximum sum, we can represent it as the maximum of the two sums at each step.\n\nWait, perhaps the DP can store the maximum of the two sums, and for each state, we can calculate the new maximum based on the previous.\n\nSo, the initial state is (0,0,0) with max_sum 0.\n\nThen, for each step, for each possible state, we try assigning the current digit to H or M.\n\nFor example, suppose current digit is d.\n\nIf we assign to H:\n\nnew_h = h + d\n\nnew_m = m\n\nnew_max = max(new_h, new_m)\n\nCompare this new_max to the existing value in dp[i+1][new_h][new_m]. If it's larger, update it.\n\nSimilarly for assigning to M.\n\nSo, the DP transition is:\n\nfor each state (i, h, m) in the current step:\n\n   for each possible action (assign to H or M):\n\n       if action is H:\n\n           if h < n:\n\n               new_h = h + d_i\n\n               new_m = m\n\n               next_max = max(new_h, new_m)\n\n               if dp[i+1][new_h][new_m] < next_max:\n\n                   dp[i+1][new_h][new_m] = next_max\n\n       else:\n\n           if m < n:\n\n               new_m = m + d_i\n\n               new_h = h\n\n               next_max = max(new_h, new_m)\n\n               if dp[i+1][new_h][new_m] < next_max:\n\n                   dp[i+1][new_h][new_m] = next_max\n\nWe proceed in a top-down manner, perhaps using memoization.\n\nBut for n up to 18, the digits are 36, and h and m can be up to 18 each. So the state space is 36 * 19 * 19, which is about 36*361 = ~13,000 states. Each state has two transitions, so it's manageable.\n\nSo, the steps are:\n\n- Read n and the string A.\n\n- Precompute the list of digits as integers.\n\n- Initialize a memoization structure (like a dictionary) for the DP.\n\n- Use recursion with memoization to compute the maximum possible maximum sum.\n\nBut recursion may be tricky here due to stack depth, so perhaps an iterative approach is better.\n\nAlternatively, we can use memoization via a 3D array.\n\nIn Python, for a 3D array, we can create a list of lists of lists.\n\nBut with 36 positions, and h and m up to 18, the array size is 36 x 19 x 19.\n\nSo, the code outline is:\n\nn = int(input())\nA = input().strip()\n\ndigits = [int(c) for c in A]\n\nINF = float('-inf')\n\ndp = [[[INF for _ in range(n+1)] for __ in range(n+1)] for ___ in range(len(digits)+1)]\n\ndp[0][0][0] = 0\n\nfor i in range(len(digits)):\n    for h in range(n+1):\n        for m in range(n+1):\n            if dp[i][h][m] == INF:\n                continue\n            current_max = dp[i][h][m]\n            # Assign to H\n            if h < n:\n                new_h = h + digits[i]\n                new_m = m\n                next_max = max(new_h, new_m)\n                if next_max > dp[i+1][new_h][new_m]:\n                    dp[i+1][new_h][new_m] = next_max\n            # Assign to M\n            if m < n:\n                new_m = m + digits[i]\n                new_h = h\n                next_max = max(new_h, new_m)\n                if next_max > dp[i+1][new_h][new_m]:\n                    dp[i+1][new_h][new_m] = next_max\n\n# Now, after processing all digits, find the maximum possible max.\n\nresult = 0\nfor h in range(n+1):\n    for m in range(n+1):\n        if dp[len(digits)][h][m] > result:\n            result = dp[len(digits)][h][m]\n\n# Now, reconstruct the sequence of moves.\n\n# To reconstruct, we need to backtrack from the final state.\n\n# We need to find a path from (len(digits), h_final, m_final) back to (0,0,0).\n\n# So, we'll start from the end and backtrack.\n\n# We can keep track of the decisions made at each step.\n\n# Create a parent pointer for each state.\n\nparent = [[[None for _ in range(n+1)] for __ in range(n+1)] for ___ in range(len(digits)+1)]\n\ncurrent_h, current_m = n, n\nfor i in reversed(range(len(digits))):\n    for h in range(n+1):\n        for m in range(n+1):\n            if dp[i][h][m] == INF:\n                continue\n            if i == len(digits)-1:\n                # last digit\n                # assign to H or M\n                if h < n:\n                    new_h = h + digits[i]\n                    new_m = m\n                    if dp[i+1][new_h][new_m] == max(new_h, new_m):\n                        if parent[i][h][m] is None:\n                            parent[i][h][m] = ('H' if new_h > new_m else 'M')\n                else:\n                    # m must be <n\n                    new_m = m + digits[i]\n                    new_h = h\n                    if dp[i+1][new_h][new_m] == max(new_h, new_m):\n                        if parent[i][h][m] is None:\n                            parent[i][h][m] = ('M' if new_m > new_h else 'H')\n            else:\n                # check both possibilities\n                # assign to H\n                if h < n:\n                    new_h = h + digits[i]\n                    new_m = m\n                    next_max = max(new_h, new_m)\n                    if dp[i+1][new_h][new_m] == next_max:\n                        if parent[i][h][m] is None:\n                            if new_h > new_m:\n                                parent[i][h][m] = 'H'\n                            else:\n                                parent[i][h][m] = 'M'\n                # assign to M\n                if m < n:\n                    new_m = m + digits[i]\n                    new_h = h\n                    next_max = max(new_h, new_m)\n                    if dp[i+1][new_h][new_m] == next_max:\n                        if parent[i][h][m] is None:\n                            if new_m > new_h:\n                                parent[i][h][m] = 'M'\n                            else:\n                                parent[i][h][m] = 'H'\n\n# Now, reconstruct the sequence.\n\nsequence = []\ncurrent_h, current_m = n, n\n\nfor i in range(len(digits)-1, -1, -1):\n    for h in range(n+1):\n        for m in range(n+1):\n            if dp[i][h][m] == INF:\n                continue\n            if (h == current_h) and (m == current_m):\n                # found the state\n                if parent[i][h][m] is None:\n                    # this is the initial state, but wait, we're going backward.\n                    # So the current state is (i, h, m), and the next step is i-1.\n                    # Wait, perhaps the initial state is (0,0,0), and we build the sequence backward.\n                    # So, in the reconstruction, we start from i= len(digits)-1, h=n, m=n, and trace back to (0,0,0).\n                    # For each step, the decision is whether it was H or M.\n                    # So, the code above may have issues. Perhaps a better way is to reconstruct from (len(digits), h, m) to (0,0,0).\n\n# Alternative approach for reconstruction:\n\ncurrent_pos = len(digits)\ncurrent_h = n\ncurrent_m = n\n\nsequence = []\nwhile current_pos > 0:\n    # Try possible h and m values that could lead to current_h and current_m.\n    for h in range(n+1):\n        for m in range(n+1):\n            if dp[current_pos-1][h][m] == max(h, m) and (h + digits[current_pos-1], m) == (current_h, current_m):\n                # Check if assigning current digit to H or M led to current_h and current_m.\n                if h + digits[current_pos-1] == current_h and m == current_m:\n                    # It was assigned to H.\n                    sequence.append('H')\n                else:\n                    # Assigned to M.\n                    sequence.append('M')\n                current_pos -= 1\n                break\n        else:\n            continue\n        break\n\nsequence.reverse()\n\nprint(''.join(sequence))\n\nWait, but the reconstruction part is tricky. Let me think.\n\nWe need to find the path from (0,0,0) to (len(A), h_final, m_final), and record each decision (H or M) along the way.\n\nSo, during the DP processing, for each state (i, h, m), we can note whether the next state came from H or M.\n\nBut in practice, for each state (i, h, m), the next state is (i+1, h', m'), where h' is h or h+digit, and similarly for m'.\n\nSo, for each state, we can track the action that led to it.\n\nThus, during the DP processing, for each state (i, h, m), we can record the action (H or M) that was taken to reach it from (i-1, ...).\n\nOnce the DP is filled, we can start from the final state (2n, n, n) and backtrack, determining the actions taken at each step.\n\nSo, the code for reconstruction would be:\n\nstart from (i=2n, h=n, m=n). The action that led to this state is whether the last digit was assigned to H or M.\n\nWait, no: the last digit is at position 2n-1, so when i reaches 2n, all digits have been processed.\n\nThus, to find the action that led to the final state, we look at i=2n-1, and see what action (H or M) was taken.\n\nSo, the reconstruction process would be:\n\n- Start from i=2n, h=n, m=n.\n\n- For each i from 2n-1 down to 0:\n\n   For each possible h and m, check if (i, h, m) is a state that could transition into (i+1, h', m').\n\n   For each possible h' and m' that are reachable from (i, h, m):\n\n      If the action was H, then append 'H' to the sequence.\n\n      Else, append 'M'.\n\nBut this seems complicated.\n\nAn alternative approach is to create a parent array that, for each state (i, h, m), stores the action that was taken to reach it.\n\nThus, during the DP processing, whenever we update a state (i+1, new_h, new_m), we also record the action that led to it.\n\nSo, during the DP:\n\nif we assign to H:\n\n   new_h = h + digits[i]\n\n   new_m = m\n\n   if dp[i+1][new_h][new_m] < next_max:\n\n       dp[i+1][new_h][new_m] = next_max\n\n       parent[(i+1, new_h, new_m)] = 'H'\n\nSimilarly for M.\n\nThen, once the DP is filled, we can start from (len(A), n, n) and backtrack.\n\nBut wait, the state (len(A), n, n) is the terminal state. How did we get here?\n\nIt means that in the last step, the (len(A)-1)th digit was assigned to H or M.\n\nSo, for each possible (h, m) that could reach (n, n) from (len(A)-1, h', m'):\n\n   if the action was H, then h' = h + digit, m' = m.\n\nSo, h' must be n, m' must be n.\n\nThus, for the last step:\n\npossible_prev_h = n - digit[-1]\n\npossible_prev_m = n\n\nif possible_prev_h >=0 and possible_prev_m >=0:\n\n   check if dp[len(A)-1][possible_prev_h][possible_prev_m] is a valid state.\n\n   if yes, then the action was 'H'.\n\nSimilarly, possible_prev_m = n - digit[-1], possible_prev_h = n.\n\nIf that's a valid state, action was 'M'.\n\nBut this is getting complicated.\n\nPerhaps, during the DP processing, for each state (i, h, m), we can track the action that led to it.\n\nBut perhaps it's easier to precompute the parent pointers.\n\nSo, the code steps:\n\n1. Initialize the DP table.\n\n2. Process each digit, updating the DP.\n\n3. After filling the DP, reconstruct the path.\n\nReconstruction steps:\n\nStart from (2n, n, n). The action that led here is the one taken at position 2n-1.\n\nSo, for each possible (h, m) that could transition into (n, n) at i=2n-1:\n\nif action was H:\n\n   h_prev = h - digits[i]\n\n   m_prev = m\n\n   if h_prev >=0 and m_prev >=0 and dp[i][h_prev][m_prev] is valid.\n\nSimilarly for M.\n\nOnce the action is found, add it to the sequence.\n\nThen, move to i=2n-2, and repeat.\n\nContinue until i=0.\n\nThis seems feasible.\n\nSo, in code:\n\nsequence = []\n\ncurrent_i = len(digits) - 1  # last digit\n\ncurrent_h = n\n\ncurrent_m = n\n\nwhile current_i >= 0:\n\n    for h in range(n+1):\n\n        for m in range(n+1):\n\n            if h + digits[current_i] == current_h and m == current_m:\n\n                # this digit was assigned to H\n\n                sequence.append('H')\n\n                break\n\n            elif m + digits[current_i] == current_m and h == current_h:\n\n                # assigned to M\n\n                sequence.append('M')\n\n                break\n\n        else:\n\n            continue\n\n        break\n\n    current_i -= 1\n\n    sequence.reverse()\n\nWait, no. Because current_i starts at len(digits)-1, and we're working backwards.\n\nWait, perhaps:\n\nWe start at i = len(digits) -1.\n\nWe have current_h = n, current_m =n.\n\nWe look for the state (i, h_prev, m_prev) that could transition to (i+1, current_h, current_m).\n\nWhich would mean, for the digit at i, if it was assigned to H, then h_prev + digit = current_h, and m_prev = current_m.\n\nOr, if it was assigned to M, then m_prev + digit = current_m, and h_prev = current_h.\n\nSo, for i:\n\ndigit = digits[i]\n\nWe can compute h_prev = current_h - digit.\n\nIf h_prev >=0 and m_prev = current_m, and dp[i][h_prev][current_m] is a valid state, then the action was H.\n\nElse, check if m_prev = current_m - digit, and h_prev = current_h. Then, action was M.\n\nSo, in code:\n\ndigit = digits[i]\n\nh_prev = current_h - digit\n\nm_prev = current_m\n\nif h_prev >=0 and m_prev >=0:\n\n    if dp[i][h_prev][m_prev] != INF:\n\n        sequence.append('H')\n\n        current_h = h_prev\n\n        current_m = m_prev\n\n        i -=1\n\nelse:\n\n    m_prev = current_m - digit\n\n    h_prev = current_h\n\n    if h_prev >=0 and m_prev >=0:\n\n        if dp[i][h_prev][m_prev] != INF:\n\n            sequence.append('M')\n\n            current_h = h_prev\n\n            current_m = m_prev\n\n            i -=1\n\nBut this may not work for all cases, especially when multiple possibilities exist.\n\nAlternatively, perhaps for each state, we can track the action that led to it.\n\nThus, during the DP processing, for each state (i, h,",
    "response": "To solve this problem, we need to determine the sequence of moves for Homer and Marge in a TV game such that their total prize is maximized. The goal is to maximize the maximum of their individual sums of digits collected.\n\n### Approach\n1. **Problem Analysis**: The problem involves two players taking turns to pick digits from a string. Each player must make exactly `n` moves. The objective is to maximize the maximum sum of the digits collected by either player.\n2. **Dynamic Programming (DP) Approach**: We use a 3D DP array where `dp[i][h][m]` represents the maximum possible sum achievable starting from the i-th digit, with `h` digits assigned to Homer and `m` digits assigned to Marge.\n3. **State Transition**: For each digit, we consider assigning it to either Homer or Marge, updating the DP state accordingly. The transition involves checking both possibilities (assigning to H or M) and updating the DP table if the new state yields a higher maximum sum.\n4. **Reconstruction**: After filling the DP table, we backtrack from the terminal state to reconstruct the sequence of moves. This involves checking which player picked each digit based on the DP transitions.\n\n### Solution Code\n```python\nn = int(input())\nA = input().strip()\n\ndigits = [int(c) for c in A]\nlength = len(digits)\n\nINF = float('-inf')\n\n# Initialize DP table\ndp = [[[INF for _ in range(n+1)] for __ in range(n+1)] for ___ in range(length + 1)]\ndp[0][0][0] = 0\n\nfor i in range(length):\n    current_digit = digits[i]\n    for h in range(n+1):\n        for m in range(n+1):\n            if dp[i][h][m] == INF:\n                continue\n            current_max = dp[i][h][m]\n            # Assign to H\n            if h < n:\n                new_h = h + current_digit\n                new_m = m\n                next_max = max(new_h, new_m)\n                if next_max > dp[i+1][new_h][new_m]:\n                    dp[i+1][new_h][new_m] = next_max\n            # Assign to M\n            if m < n:\n                new_m = m + current_digit\n                new_h = h\n                next_max = max(new_h, new_m)\n                if next_max > dp[i+1][new_h][new_m]:\n                    dp[i+1][new_h][new_m] = next_max\n\n# Reconstruct the sequence\nsequence = []\ncurrent_i = length - 1\ncurrent_h = n\ncurrent_m = n\n\nwhile current_i >= 0:\n    found = False\n    for h in range(n+1):\n        for m in range(n+1):\n            if dp[current_i][h][m] != INF:\n                # Check if assigning this digit led to current_h and current_m\n                if (h + digits[current_i] == current_h and m == current_m) or \\\n                   (m + digits[current_i] == current_m and h == current_h):\n                    if (h + digits[current_i] == current_h and m == current_m):\n                        sequence.append('H')\n                        current_h = h\n                        current_m = m\n                        found = True\n                        break\n                    else:\n                        sequence.append('M')\n                        current_h = h\n                        current_m = m\n                        found = True\n                        break\n        if found:\n            break\n    current_i -= 1\n    sequence.reverse()\n\nprint(''.join(sequence))\n```\n\n### Explanation\n1. **Initialization**: The DP table is initialized with `-inf` to represent unreachable states, except for the starting state `dp[0][0][0]` which is 0.\n2. **DP Table Filling**: For each digit, we consider both possible assignments (to Homer or Marge) and update the DP table accordingly to track the maximum possible sum from each state.\n3. **Reconstruction**: Starting from the terminal state, we backtrack through the DP table to determine the sequence of moves by checking which assignment led to the current state.\n4. **Output**: The reconstructed sequence of moves is printed as the result.\n\nThis approach ensures that we efficiently compute the optimal sequence of moves using dynamic programming and backtracking, ensuring the maximum possible prize for both players.",
    "ground_truth": "N/A",
    "extracted_answer": "n = int(input())\nA = input().strip()\n\ndigits = [int(c) for c in A]\nlength = len(digits)\n\nINF = float('-inf')\n\n# Initialize DP table\ndp = [[[INF for _ in range(n+1)] for __ in range(n+1)] for ___ in range(length + 1)]\ndp[0][0][0] = 0\n\nfor i in range(length):\n    current_digit = digits[i]\n    for h in range(n+1):\n        for m in range(n+1):\n            if dp[i][h][m] == INF:\n                continue\n            current_max = dp[i][h][m]\n            # Assign to H\n            if h < n:\n                new_h = h + current_digit\n                new_m = m\n                next_max = max(new_h, new_m)\n                if next_max > dp[i+1][new_h][new_m]:\n                    dp[i+1][new_h][new_m] = next_max\n            # Assign to M\n            if m < n:\n                new_m = m + current_digit\n                new_h = h\n                next_max = max(new_h, new_m)\n                if next_max > dp[i+1][new_h][new_m]:\n                    dp[i+1][new_h][new_m] = next_max\n\n# Reconstruct the sequence\nsequence = []\ncurrent_i = length - 1\ncurrent_h = n\ncurrent_m = n\n\nwhile current_i >= 0:\n    found = False\n    for h in range(n+1):\n        for m in range(n+1):\n            if dp[current_i][h][m] != INF:\n                # Check if assigning this digit led to current_h and current_m\n                if (h + digits[current_i] == current_h and m == current_m) or \\\n                   (m + digits[current_i] == current_m and h == current_h):\n                    if (h + digits[current_i] == current_h and m == current_m):\n                        sequence.append('H')\n                        current_h = h\n                        current_m = m\n                        found = True\n                        break\n                    else:\n                        sequence.append('M')\n                        current_h = h\n                        current_m = m\n                        found = True\n                        break\n        if found:\n            break\n    current_i -= 1\n    sequence.reverse()\n\nprint(''.join(sequence))",
    "score": -1,
    "metadata": {
        "prompt_token_count": 402,
        "completion_token_count": 913,
        "thoughts_token_count": 8193
    }
}