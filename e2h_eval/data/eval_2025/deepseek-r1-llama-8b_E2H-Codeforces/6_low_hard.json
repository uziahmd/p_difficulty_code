{
    "start": 1758103527.3398376,
    "end": 1758103649.7720737,
    "start-formatted": "2025-09-17 19:05 KST",
    "end-formatted": "2025-09-17 19:07 KST",
    "gpu": 2,
    "pid": 6,
    "use_openrouter": false,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read it carefully.\n\nThe problem is about Leha choosing two vouchers such that their durations add up exactly to x, they don't overlap, and the total cost is as small as possible. If it's not possible, we return -1.\n\nHmm. Let me break down the requirements.\n\nFirst, each voucher has a start day li, end day ri, and cost costi. The duration is ri - li + 1. We need two vouchers i and j (i ≠ j) where:\n\n1. The sum of their durations is exactly x.\n2. They don't intersect. That means either ri < lj or rj < li. So one ends before the other starts.\n\nOur goal is to find the minimal total cost for such a pair. If no such pair exists, output -1.\n\nSo how do I approach this?\n\nI think the first step is to process all possible pairs of vouchers and check the conditions. But with n up to 2e5, checking all O(n^2) pairs is impossible. So we need an efficient way.\n\nWait, but x can be up to 2e5, which is manageable. Maybe we can group vouchers by their duration and then look for pairs that add up to x.\n\nYes. So for each voucher, we can compute its duration d = ri - li + 1. Then, for each voucher i with duration d, we need to find a voucher j with duration x - d, and ensure that i and j are non-overlapping.\n\nBut how to efficiently find j that satisfies the non-overlapping condition and has the right duration.\n\nLet me think about the structure:\n\nFor each voucher i, I need to find all vouchers j where:\n\n- duration of j is x - duration of i\n- j doesn't overlap with i.\n\nSo for each i, I can look into the required duration (x - d_i), and among those vouchers, find the ones that don't overlap with i and have the minimal cost.\n\nBut how to store the vouchers in a way that allows quick querying based on their start and end times.\n\nHmm. Let's consider that for each possible duration k (from 1 to x), we can have a list of all vouchers with duration k. Then, for a voucher i with duration d, we look into the list for x - d.\n\nBut even that might not be enough because we need to check for non-overlapping. So perhaps for each possible duration k, we can pre-sort the vouchers in some way to allow quick checks.\n\nWait, maybe we can model this as follows:\n\nFor each voucher i, let's find all vouchers j where:\n\n- j's duration is x - d_i\n- j starts after i ends, or j ends before i starts.\n\nSo for each i, we need to find j's in the x-d_i group that either:\n\nCase 1: j starts >= i's end + 1 (so j is after i)\nOR\nCase 2: j ends <= i's start - 1 (so j is before i)\n\nWe can represent each voucher by their start and end times.\n\nSo, for each i, when looking for j's in the required duration group, we can split the j's into two parts:\n\na) Those that end before i starts (ri_j <= li_i - 1)\nb) Those that start after i ends (li_j >= ri_i + 1)\n\nAnd for each of these, we can keep track of the minimal cost.\n\nWait, but for each i, how do we efficiently query these two groups from the x - d_i list?\n\nAn idea is to, for each duration k, store the list of vouchers sorted by their end time and their start time. Then, for a given i, we can perform binary searches to find the minimal cost voucher in both cases.\n\nAlternatively, for each k, we can pre-process the vouchers and build structures that allow quickly finding the minimal cost for certain ranges.\n\nHmm.\n\nAnother approach: For each possible duration k, maintain a list of vouchers with duration k, sorted by their end time. Then, for a given i, to find j's that end before i's start, we can look into the k = x -d_i group and find all j's where ri_j <= li_i -1. Among these, find the one with the minimal cost.\n\nSimilarly, for j's that start after i's end, we can look into the same group and find j's where li_j >= ri_i +1, again picking the minimal cost.\n\nSo, for each i, the steps are:\n\n1. Compute required duration k = x - d_i.\n\n   If k is less than 0, skip (since durations are positive).\n\n2. If there are no vouchers in the k group, continue.\n\n3. For case a (j ends before i starts):\n\n   We need to find all j in k group where ri_j <= li_i -1.\n\n",
    "response": "To solve this problem, we need to find two non-overlapping vouchers such that their combined duration equals the given vacation duration `x` and their total cost is minimized. If no such pair exists, we return `-1`.\n\n### Approach\n1. **Group Vouchers by Duration**: First, we group all vouchers by their duration. This allows us to quickly find pairs of vouchers whose durations sum up to `x`.\n2. **Sort Vouchers**: For each duration group, we sort vouchers based on their end time and start time. This helps in efficiently finding non-overlapping vouchers using binary search.\n3. **Check Non-Overlapping Conditions**: For each voucher, we check for possible pairs in the required duration group that either end before the current voucher starts or start after the current voucher ends. We use binary search to find the minimal cost vouchers that meet these conditions.\n\n### Solution Code\n```python\nimport bisect\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n, x = int(input[idx]), int(input[idx+1])\n    idx += 2\n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        r = int(input[idx+1])\n        c = int(input[idx+2])\n        idx += 3\n        vouchers.append((l, r, c))\n    \n    # Group by duration\n    duration_map = {}\n    for v in vouchers:\n        d = v[1] - v[0] + 1\n        if d not in duration_map:\n            duration_map[d] = []\n        duration_map[d].append(v)\n    \n    # Pre-sort each group\n    for d in duration_map:\n        duration_map[d].sort(key=lambda x: (x[0], x[1]))\n        # Also create a sorted list of end times for binary searching\n        ends = [v[1] for v in duration_map[d]]\n        starts = [v[0] for v in duration_map[d]]\n        duration_map[d] = (ends, starts, duration_map[d])\n    \n    min_cost = float('inf')\n    for i in range(n):\n        l_i, r_i, c_i = vouchers[i]\n        d_i = r_i - l_i + 1\n        required_d = x - d_i\n        if required_d <= 0:\n            continue\n        if required_d not in duration_map:\n            continue\n        \n        ends_list, starts_list, group = duration_map[required_d]\n        # Case 1: j ends before i starts (ri_j <= li_i -1)\n        pos = bisect.bisect_right(ends_list, l_i - 1) - 1\n        if pos >= 0:\n            min_c = min(c_i + group[pos][2], min_cost)\n            if min_c < min_cost:\n                min_cost = min_c\n        \n        # Case 2: j starts after i ends (li_j >= ri_i +1)\n        pos = bisect.bisect_left(starts_list, r_i + 1)\n        if pos < len(starts_list):\n            min_c = min(c_i + group[pos][2], min_cost)\n            if min_c < min_cost:\n                min_cost = min_c\n    \n    if min_cost != float('inf'):\n        print(min_cost)\n    else:\n        print(-1)\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into a list of vouchers.\n2. **Grouping by Duration**: Vouchers are grouped by their duration to facilitate quick lookup of required pairs.\n3. **Sorting**: Each group of vouchers with the same duration is sorted based on their start and end times to enable efficient binary search operations.\n4. **Binary Search for Non-Overlapping Pairs**: For each voucher, we check two cases: vouchers ending before the current voucher starts and vouchers starting after the current voucher ends. Using binary search, we efficiently find the minimal cost vouchers that meet these conditions.\n5. **Result Calculation**: The minimal cost is tracked and printed, or `-1` if no valid pairs are found.\n\nThis approach ensures that we efficiently find the optimal pair of vouchers without checking all possible pairs, making the solution feasible for large inputs.",
    "ground_truth": "N/A",
    "extracted_answer": "import bisect\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n, x = int(input[idx]), int(input[idx+1])\n    idx += 2\n    vouchers = []\n    for _ in range(n):\n        l = int(input[idx])\n        r = int(input[idx+1])\n        c = int(input[idx+2])\n        idx += 3\n        vouchers.append((l, r, c))\n    \n    # Group by duration\n    duration_map = {}\n    for v in vouchers:\n        d = v[1] - v[0] + 1\n        if d not in duration_map:\n            duration_map[d] = []\n        duration_map[d].append(v)\n    \n    # Pre-sort each group\n    for d in duration_map:\n        duration_map[d].sort(key=lambda x: (x[0], x[1]))\n        # Also create a sorted list of end times for binary searching\n        ends = [v[1] for v in duration_map[d]]\n        starts = [v[0] for v in duration_map[d]]\n        duration_map[d] = (ends, starts, duration_map[d])\n    \n    min_cost = float('inf')\n    for i in range(n):\n        l_i, r_i, c_i = vouchers[i]\n        d_i = r_i - l_i + 1\n        required_d = x - d_i\n        if required_d <= 0:\n            continue\n        if required_d not in duration_map:\n            continue\n        \n        ends_list, starts_list, group = duration_map[required_d]\n        # Case 1: j ends before i starts (ri_j <= li_i -1)\n        pos = bisect.bisect_right(ends_list, l_i - 1) - 1\n        if pos >= 0:\n            min_c = min(c_i + group[pos][2], min_cost)\n            if min_c < min_cost:\n                min_cost = min_c\n        \n        # Case 2: j starts after i ends (li_j >= ri_i +1)\n        pos = bisect.bisect_left(starts_list, r_i + 1)\n        if pos < len(starts_list):\n            min_c = min(c_i + group[pos][2], min_cost)\n            if min_c < min_cost:\n                min_cost = min_c\n    \n    if min_cost != float('inf'):\n        print(min_cost)\n    else:\n        print(-1)\n\nif __name__ == '__main__':\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 686,
        "completion_token_count": 894,
        "thoughts_token_count": 1025
    }
}