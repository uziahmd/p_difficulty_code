{
    "start": 1758103987.215018,
    "end": 1758104173.0322964,
    "start-formatted": "2025-09-17 19:13 KST",
    "end-formatted": "2025-09-17 19:16 KST",
    "gpu": 2,
    "pid": 9,
    "use_openrouter": false,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Selling Souvenirs\n\nAfter several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.This morning, as usual, Petya will come to the market. Petya has n different souvenirs to sell; ith souvenir is characterised by its weight wi and cost ci. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than m, and total cost is maximum possible.Help Petya to determine maximum possible total cost.\n\n## Input\nThe first line contains two integers n and m (1 ≤ n ≤ 100000, 1 ≤ m ≤ 300000) — the number of Petya's souvenirs and total weight that he can carry to the market.Then n lines follow. ith line contains two integers wi and ci (1 ≤ wi ≤ 3, 1 ≤ ci ≤ 109) — the weight and the cost of ith souvenir.\n\n## Output\nPrint one number — maximum possible total cost of souvenirs that Petya can carry to the market.\n\n## Example\n### Input\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\n### Output\n['0', '3', '10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read it carefully.\n\nThe problem is about Petya selling souvenirs. He has n souvenirs, each with a weight and a cost. He wants to choose a subset where the total weight doesn't exceed m, and the total cost is as large as possible.\n\nHmm, right. So it's a classic knapsack problem. But wait, the constraints might make a standard approach infeasible. Let me think about the input sizes.\n\nThe constraints are n up to 1e5 and m up to 3e5. Oh, that's a lot. The standard dynamic programming approach for knapsack, which is O(nm), would be way too slow here. For example, 1e5 * 3e5 is 3e10 operations—way beyond what can be handled in acceptable time.\n\nSo I need a more efficient approach. Let's see: since each item has a small weight (wi is 1, 2, or 3), maybe I can group them by their weights and find an optimal way to select items from each group.\n\nYes! That makes sense. Because the weight is limited to 3, perhaps we can handle each weight class separately and then combine the results.\n\nLet me think about how to structure this.\n\nEach item is either weight 1, 2, or 3. So let's split all items into three groups: group1 contains all weight 1 items, group2 weight 2, group3 weight 3.\n\nFor each group, we can sort the items in descending order of cost. Then, for each group, we can precompute prefix sums, which represent the maximum cost achievable by taking the top k items of that group.\n\nOnce we have these prefix sums, the problem becomes selecting a number of items from each group such that the sum of their weights is <= m, and the sum of their costs is maximized.\n\nSo the plan is:\n\n1. Separate the items into three groups based on their weights.\n2. Sort each group in descending order of cost.\n3. Compute prefix sums for each group. For group i (weight w_i), the j-th element in the prefix sum array represents the maximum cost of taking j items from group i.\n4. Now, find the best combination across all three groups, ensuring that the total weight (sum of selected items' weights) is <= m, and the total cost is maximized.\n\nBut how do I efficiently find the combination across all groups?\n\nThis feels like a variation of the unbounded knapsack problem, but with items being taken from each group in a way that depends on their order.\n\nWait, maybe we can model this as a problem where for each possible total weight up to m, we track the maximum cost. But since m can be up to 3e5, perhaps we can use a DP approach where we iterate over each group and update the DP accordingly.\n\nLet me outline the steps more precisely:\n\n- For each group (group1, group2, group3):\n   - Sort the items in descending order of cost.\n   - Compute the prefix sums. For example, group1's prefix sum will have entries for 0, 1, 2, ..., k items, where k is the size of group1. Similarly for others.\n\nOnce I have these prefix sums, the problem reduces to choosing a certain number of items from each group such that the sum of their weights is <= m, and the sum of their costs is maximized.\n\nThe key is to find, for each possible weight limit, the maximum cost. So let's model this with a DP array where dp[j] represents the maximum cost achievable with a total weight of exactly j.\n\nWe'll initialize dp[0] = 0, and all other dp[j] to 0 initially.\n\nThen, for each group, we'll process it and update the dp array.\n\nFor example, starting with group1 (weight 1):\n\nFor each possible number of items taken from group1, say t, the total weight added is t*1, and the cost is the prefix sum up to t.\n\nWe can loop through t from 0 to the maximum possible for group1 (without exceeding m). For each t, we add t to the current weight and see if it improves the dp.\n\nWait, but processing each group one by one and updating the dp array in a way that considers all possible numbers of items taken from that group.\n\nAlternatively, for each group, we can consider adding 0, 1, 2, ... up to some maximum number of items from that group, and for each possible count, we can compute the weight and cost, then update the dp accordingly.\n\nBut how to do this efficiently.\n\nAnother approach is to use a knapsack-like DP where for each group, we consider adding items in a way similar to the bounded knapsack problem.\n\nWait, but since the items in each group are already sorted in descending",
    "response": "To solve this problem, we need to determine the maximum possible total cost of souvenirs that Petya can carry to the market without exceeding a given weight limit. This is a classic knapsack problem with specific constraints on the weights of the items.\n\n### Approach\n1. **Categorize Items by Weight**: Since each item has a weight of either 1, 2, or 3, we can categorize the items into three groups based on their weights.\n2. **Sort and Compute Prefix Sums**: For each group, sort the items in descending order of their cost and compute prefix sums. The prefix sum array for a group will help us quickly determine the maximum cost achievable by taking the top k items from that group.\n3. **Dynamic Programming (DP) Approach**: Use a DP array where `dp[j]` represents the maximum cost achievable with a total weight of exactly j. Initialize this array with zeros. For each group, update the DP array by considering all possible numbers of items taken from that group, ensuring the total weight does not exceed the limit.\n\n### Solution Code\n```python\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    m = int(input[idx+1])\n    idx +=2\n\n    group1 = []\n    group2 = []\n    group3 = []\n    for _ in range(n):\n        w = int(input[idx])\n        c = int(input[idx+1])\n        idx +=2\n        if w == 1:\n            group1.append(c)\n        elif w ==2:\n            group2.append(c)\n        else:\n            group3.append(c)\n\n    # Sort each group in descending order\n    group1.sort(reverse=True)\n    group2.sort(reverse=True)\n    group3.sort(reverse=True)\n\n    # Compute prefix sums for each group\n    def compute_prefix(arr):\n        prefix = [0]\n        s =0\n        for x in arr:\n            s +=x\n            prefix.append(s)\n        return prefix\n    prefix1 = compute_prefix(group1)\n    prefix2 = compute_prefix(group2)\n    prefix3 = compute_prefix(group3)\n\n    # Now, use DP to find the maximum cost\n    dp = [0]*(m+1)\n    # Process group1 (weight 1)\n    max_take1 = min(len(group1), m)\n    for t in range(0, max_take1+1):\n        if t ==0:\n            continue\n        weight = t*1\n        if weight > m:\n            break\n        cost = prefix1[t]\n        if cost > dp[weight]:\n            dp[weight] = cost\n        # Also consider combinations where we take more than t items from other groups\n        for j in range(m - weight +1):\n            if dp[j] + cost > dp[j + weight]:\n                dp[j + weight] = dp[j] + cost\n\n    # Process group2 (weight 2)\n    max_take2 = min(len(group2), m//2)\n    for t in range(0, max_take2+1):\n        if t ==0:\n            continue\n        weight = t*2\n        if weight > m:\n            break\n        cost = prefix2[t]\n        for j in range(m - weight +1):\n            if dp[j] + cost > dp[j + weight]:\n                dp[j + weight] = dp[j] + cost\n\n    # Process group3 (weight 3)\n    max_take3 = min(len(group3), m//3)\n    for t in range(0, max_take3+1):\n        if t ==0:\n            continue\n        weight = t*3\n        if weight > m:\n            break\n        cost = prefix3[t]\n        for j in range(m - weight +1):\n            if dp[j] + cost > dp[j + weight]:\n                dp[j + weight] = dp[j] + cost\n\n    print(max(dp))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n- **Categorization and Sorting**: We categorize the items into three groups based on their weights and sort each group by cost in descending order to maximize the cost efficiently.\n- **Prefix Sums**: By computing prefix sums for each group, we can quickly determine the maximum cost for taking the top k items from any group.\n- **Dynamic Programming**: Using a DP array, we iteratively update the maximum cost for each possible weight up to m, considering all possible numbers of items taken from each group. This ensures that we find the optimal solution within the given constraints efficiently.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    m = int(input[idx+1])\n    idx +=2\n\n    group1 = []\n    group2 = []\n    group3 = []\n    for _ in range(n):\n        w = int(input[idx])\n        c = int(input[idx+1])\n        idx +=2\n        if w == 1:\n            group1.append(c)\n        elif w ==2:\n            group2.append(c)\n        else:\n            group3.append(c)\n\n    # Sort each group in descending order\n    group1.sort(reverse=True)\n    group2.sort(reverse=True)\n    group3.sort(reverse=True)\n\n    # Compute prefix sums for each group\n    def compute_prefix(arr):\n        prefix = [0]\n        s =0\n        for x in arr:\n            s +=x\n            prefix.append(s)\n        return prefix\n    prefix1 = compute_prefix(group1)\n    prefix2 = compute_prefix(group2)\n    prefix3 = compute_prefix(group3)\n\n    # Now, use DP to find the maximum cost\n    dp = [0]*(m+1)\n    # Process group1 (weight 1)\n    max_take1 = min(len(group1), m)\n    for t in range(0, max_take1+1):\n        if t ==0:\n            continue\n        weight = t*1\n        if weight > m:\n            break\n        cost = prefix1[t]\n        if cost > dp[weight]:\n            dp[weight] = cost\n        # Also consider combinations where we take more than t items from other groups\n        for j in range(m - weight +1):\n            if dp[j] + cost > dp[j + weight]:\n                dp[j + weight] = dp[j] + cost\n\n    # Process group2 (weight 2)\n    max_take2 = min(len(group2), m//2)\n    for t in range(0, max_take2+1):\n        if t ==0:\n            continue\n        weight = t*2\n        if weight > m:\n            break\n        cost = prefix2[t]\n        for j in range(m - weight +1):\n            if dp[j] + cost > dp[j + weight]:\n                dp[j + weight] = dp[j] + cost\n\n    # Process group3 (weight 3)\n    max_take3 = min(len(group3), m//3)\n    for t in range(0, max_take3+1):\n        if t ==0:\n            continue\n        weight = t*3\n        if weight > m:\n            break\n        cost = prefix3[t]\n        for j in range(m - weight +1):\n            if dp[j] + cost > dp[j + weight]:\n                dp[j + weight] = dp[j] + cost\n\n    print(max(dp))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 450,
        "completion_token_count": 960,
        "thoughts_token_count": 1025
    }
}