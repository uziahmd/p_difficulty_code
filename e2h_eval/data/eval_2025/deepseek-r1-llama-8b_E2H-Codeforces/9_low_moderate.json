{
    "start": 1758103868.8149903,
    "end": 1758103991.254139,
    "start-formatted": "2025-09-17 19:11 KST",
    "end-formatted": "2025-09-17 19:13 KST",
    "gpu": 2,
    "pid": 9,
    "use_openrouter": false,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Selling Souvenirs\n\nAfter several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.This morning, as usual, Petya will come to the market. Petya has n different souvenirs to sell; ith souvenir is characterised by its weight wi and cost ci. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than m, and total cost is maximum possible.Help Petya to determine maximum possible total cost.\n\n## Input\nThe first line contains two integers n and m (1 ≤ n ≤ 100000, 1 ≤ m ≤ 300000) — the number of Petya's souvenirs and total weight that he can carry to the market.Then n lines follow. ith line contains two integers wi and ci (1 ≤ wi ≤ 3, 1 ≤ ci ≤ 109) — the weight and the cost of ith souvenir.\n\n## Output\nPrint one number — maximum possible total cost of souvenirs that Petya can carry to the market.\n\n## Example\n### Input\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\n### Output\n['0', '3', '10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read it carefully.\n\nThe problem is about Petya selling souvenirs. He has n souvenirs, each with a weight and a cost. He wants to choose a subset of them such that the total weight doesn't exceed m, and the total cost is as large as possible. My task is to find this maximum possible cost.\n\nHmm. The constraints are n up to 1e5 and m up to 3e5. So we need an efficient solution because brute force won't work here.\n\nLet me think about how to approach this. Since each souvenir has a weight of either 1, 2, or 3, maybe we can group them by their weights and handle each group separately.\n\nWait, that's a good point. Because the weights are only 1, 2, or 3, perhaps we can process each group (weight 1, 2, 3) in a way that maximizes the cost without exceeding the total allowed weight.\n\nSo first, I'll separate the souvenirs into three groups based on their weights. Then, for each group, I can sort the items in descending order of cost. This way, when selecting, we pick the most valuable items first.\n\nBut how do we combine these groups optimally?\n\nI remember that for knapsack problems where the number of items is large but the weights are small, we can use a dynamic programming approach with some optimizations.\n\nIn this case, since the maximum m is 3e5, a standard 0-1 knapsack approach would be O(nm), which is not feasible because n is up to 1e5 and m up to 3e5. That would result in 3e10 operations, which is way too slow.\n\nWait, but since the weights are limited to 1, 2, 3, maybe there's a smarter way. For each possible remaining weight, we can track the maximum cost achievable. But even then, with m being 3e5, that's manageable if we can update the DP efficiently.\n\nAlternatively, perhaps we can model this as a bounded knapsack problem, where for each group (weight 1, 2, 3), we can take as many as we want, but each item contributes its own cost. But wait, no, each item is unique; you can't take multiple copies of the same item. So it's more like a 0-1 knapsack for each group, but the groups are processed together.\n\nHmm. So maybe we can model this as a 0-1 knapsack problem where each item belongs to one of the three groups, and the weight is known. But again, with n=1e5, it's not feasible to process each item individually.\n\nAnother idea: For each group, we can precompute a list of the best possible costs for taking k items from that group, where k is up to the size of the group. Then, for each possible number of items taken from each group, we can compute the total cost and check if the total weight is within m.\n\nWait, but even that might not be efficient enough. Let's think differently.\n\nSince the weights are small (only 1, 2, 3), perhaps we can model the DP state as the number of items taken from each group, but that's probably too memory-intensive.\n\nWait, another approach: We can model the DP as a 4-dimensional array, but considering the maximum m and the possible combinations. But I'm not sure.\n\nAlternatively, let's think about the problem as a variation of the unbounded knapsack problem, but with items grouped by their weights. For each weight w (1, 2, 3), we have a list of items sorted in descending order of cost. Then, for each possible weight up to m, we can determine the maximum cost by choosing items from each group.\n\nWait, but each group is a set of items, each contributing a certain cost and a certain weight. So for each group, the problem is similar to the unbounded knapsack, but since each item is unique, it's more like a 0-1 knapsack for each group.\n\nBut again, processing each item in each group is expensive. So perhaps we can find a way to represent the best possible for each possible count in each group.\n\nWait, here's an idea inspired by the \"knuth's optimization\" for the knapsack problem. Since the items in each group are sorted in decreasing order, for each group, the best option is to take the top k items. So for group 1 (weight 1), if we take k items, the total weight is k and the cost is the sum of the top k items. Similarly for group 2 and 3.\n\nSo for each group, precompute a prefix sum array. For example, for group 1, create an array s1 where",
    "response": "To solve this problem, we need to determine the maximum possible total cost of souvenirs that Petya can carry to the market without exceeding a given weight limit. The souvenirs are categorized by their weights into three groups: weight 1, weight 2, and weight 3.\n\n### Approach\n1. **Categorize Souvenirs**: Separate the souvenirs into three groups based on their weights (1, 2, or 3).\n2. **Sort and Precompute Costs**: For each group, sort the souvenirs in descending order of their costs and precompute prefix sums for the top k items in each group.\n3. **Dynamic Programming with Group Processing**: Use dynamic programming to keep track of the maximum cost achievable for each possible weight up to the limit m. Process each group separately and update the DP array to reflect the best possible combinations from each group.\n\n### Solution Code\n```python\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    m = int(input[idx+1])\n    idx += 2\n\n    group1 = []\n    group2 = []\n    group3 = []\n\n    for _ in range(n):\n        w = int(input[idx])\n        c = int(input[idx+1])\n        idx += 2\n        if w == 1:\n            group1.append(c)\n        elif w == 2:\n            group2.append(c)\n        else:\n            group3.append(c)\n\n    # Sort each group in descending order and compute prefix sums\n    group1.sort(reverse=True)\n    group2.sort(reverse=True)\n    group3.sort(reverse=True)\n\n    prefix1 = [0]\n    for c in group1:\n        prefix1.append(prefix1[-1] + c)\n    \n    prefix2 = [0]\n    for c in group2:\n        prefix2.append(prefix2[-1] + c)\n    \n    prefix3 = [0]\n    for c in group3:\n        prefix3.append(prefix3[-1] + c)\n\n    # Now, process each group and update dp\n    dp = [0] * (m + 1)\n    for i in range(len(prefix1)):\n        for j in range(m - i + 1):\n            dp[j] = max(dp[j], prefix1[i] + (dp[j - i] if j - i >= 0 else 0))\n\n    for i in range(len(prefix2)):\n        for j in range(m - i + 1):\n            dp[j] = max(dp[j], prefix2[i] + (dp[j - i] if j - i >= 0 else 0))\n\n    for i in range(len(prefix3)):\n        for j in range(m - i + 1):\n            dp[j] = max(dp[j], prefix3[i] + (dp[j - i] if j - i >= 0 else 0))\n\n    print(dp[m])\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Categorization**: Souvenirs are grouped by their weights into three lists: `group1`, `group2`, and `group3`.\n2. **Sorting and Prefix Sums**: Each group is sorted by cost in descending order, and prefix sums are computed to quickly get the total cost of the top k items in each group.\n3. **Dynamic Programming**: We use a DP array where `dp[j]` represents the maximum cost achievable with a total weight of j. We iterate through each group and update the DP array to reflect the best possible combinations of items from each group without exceeding the weight limit m.\n\nThis approach efficiently combines the sorted lists and uses dynamic programming to find the optimal solution within the given constraints.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    m = int(input[idx+1])\n    idx += 2\n\n    group1 = []\n    group2 = []\n    group3 = []\n\n    for _ in range(n):\n        w = int(input[idx])\n        c = int(input[idx+1])\n        idx += 2\n        if w == 1:\n            group1.append(c)\n        elif w == 2:\n            group2.append(c)\n        else:\n            group3.append(c)\n\n    # Sort each group in descending order and compute prefix sums\n    group1.sort(reverse=True)\n    group2.sort(reverse=True)\n    group3.sort(reverse=True)\n\n    prefix1 = [0]\n    for c in group1:\n        prefix1.append(prefix1[-1] + c)\n    \n    prefix2 = [0]\n    for c in group2:\n        prefix2.append(prefix2[-1] + c)\n    \n    prefix3 = [0]\n    for c in group3:\n        prefix3.append(prefix3[-1] + c)\n\n    # Now, process each group and update dp\n    dp = [0] * (m + 1)\n    for i in range(len(prefix1)):\n        for j in range(m - i + 1):\n            dp[j] = max(dp[j], prefix1[i] + (dp[j - i] if j - i >= 0 else 0))\n\n    for i in range(len(prefix2)):\n        for j in range(m - i + 1):\n            dp[j] = max(dp[j], prefix2[i] + (dp[j - i] if j - i >= 0 else 0))\n\n    for i in range(len(prefix3)):\n        for j in range(m - i + 1):\n            dp[j] = max(dp[j], prefix3[i] + (dp[j - i] if j - i >= 0 else 0))\n\n    print(dp[m])\n\nif __name__ == \"__main__\":\n    main()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 451,
        "completion_token_count": 776,
        "thoughts_token_count": 1025
    }
}