{
    "start": 1758141329.325822,
    "end": 1758142666.1343946,
    "start-formatted": "2025-09-18 05:35 KST",
    "end-formatted": "2025-09-18 05:57 KST",
    "gpu": 2,
    "pid": 8,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read it carefully.\n\nThe problem is about determining the direction of each edge in a flow network such that the resulting graph satisfies certain conditions. The goal is to make sure that for each vertex v (except the source and sink), the sum of incoming edges equals the sum of outgoing edges. Also, the source has no incoming edges, and there are no cycles in the directed graph.\n\nHmm. So the given graph is undirected, and we need to assign directions to each edge to form a directed acyclic graph (DAG) with a valid max flow.\n\nWait, but how do we determine the directions? It feels like this is related to the concept of residual graphs and maybe something like finding a DAG that preserves the max flow structure.\n\nLet me think. In a max flow, the residual graph (which is directed) doesn't have any cycles, right? Because cycles would mean augmenting paths. So perhaps the residual graph already is a DAG. But wait, in the original problem statement, the algorithm's flaw is that it only provides the flow volumes but not the directions. So I guess the idea is to construct a direction assignment such that when you compute the flow again on this directed graph, you get the same maximum flow.\n\nBut how?\n\nAnother thought: Each edge in the original undirected graph must be directed either way or the other, depending on whether it's part of the residual graph. Because in a max flow, edges are split into forward and backward edges in the residual graph. So perhaps for each edge, if in the residual graph it's a forward edge, it's directed ai→bi; otherwise, it's bi→ai.\n\nWait, no. The residual graph is directed, and each original undirected edge is replaced by two possible directed edges, one in each direction, with capacities equal to the flow in the original direction. So for each original edge, if it's directed as ai→bi in the residual graph, then the capacity is ci, and the reverse edge bi→ai has capacity 0. Otherwise, if the residual graph has bi→ai, then the reverse is ai→bi with capacity 0.\n\nWait, but how does that help us here? Because the original problem is to assign directions to each edge (each original undirected edge is assigned a direction, either ai→bi or bi→ai) such that when the flow is computed, it's the maximum possible.\n\nSo perhaps the approach is to find a way to assign the directions so that the residual graph is acyclic and meets the required conditions.\n\nWait, but the problem requires that for each vertex v (not source or sink), the sum of incoming flows equals the sum of outgoing flows. Also, the source has no incoming edges.\n\nThis sounds like the graph needs to be balanced except for the source and sink. Wait, but how?\n\nWait, let's model this. For each vertex v (2<=v<=n-1), the sum of incoming edges' ci must equal the sum of outgoing edges' ci. For vertex 1, sum of incoming is zero, sum of outgoing is whatever. For vertex n, sum of incoming equals sum of outgoing.\n\nSo the total flow from the source is the sum of all outgoing edges from the source. The total flow to the sink is the sum of all incoming edges to the sink. But according to the problem statement, the solution is a valid maximum flow.\n\nBut how to model the direction assignments.\n\nAnother approach: Since the given graph is connected, and the solution exists, perhaps the way to direct the edges is based on the BFS levels from the source. Like, in a DAG, you can order the nodes level by level, and direct edges from lower levels to higher levels.\n\nWait, but that might not always work, because some edges could carry more flow than others.\n\nAlternatively, perhaps the direction should be determined based on which side has a higher potential. Or maybe using a BFS-like approach where we assign directions based on the shortest path from the source.\n\nWait, another thought: The problem resembles building a DAG where each edge is directed from a node closer to the source to a node farther away. Because that way, you don't have cycles, and the flow can pass through without getting stuck.\n\nSo, perhaps the way to proceed is:\n\n1. Assign directions such that all edges are directed away from the source. But that can't be right, because in some cases, like a cycle, you can't have all edges directed away.\n\nWait, but the given graph is a connected undirected graph, but after assigning directions, it becomes a DAG. So the graph must have a topological order.\n\nSo, perhaps the solution is to perform a BFS starting from the source, and for each node, process its edges in such a way that edges go from earlier layers to later layers.\n\nBut how to decide the direction for each original undirected edge.\n\nWait, here's an idea: For each edge (u, v), if u is in a lower level (earlier in the BFS order) than v, then direct it from u to v. Otherwise, direct it from v to u. But what defines the levels?\n\nSo, steps:\n\n- Perform BFS starting from the source (node 1). This will give each node a distance from the source.\n\n- For each edge (u, v), if dist[u] < dist[v], then direct it as u→v. Else, direct it as v→u.\n\nThis way, all edges are directed in a way that respects the BFS order, ensuring no cycles and the flow can go from source to sink.\n\nBut will this assignment satisfy the balance condition for all intermediate nodes?\n\nNot necessarily. Because for a node v, the sum of incoming edges may not equal the sum of outgoing edges.\n\nWait, but considering that the flow in the graph must be a maximum, perhaps this method ensures that the flow is correctly distributed.\n\nWait, but perhaps this approach is similar to creating a layered graph where each layer is processed in order, ensuring that the flow can pass through without getting stuck.\n\nAnother thought: The problem requires that for each internal node, the sum of incoming edges equals the sum of outgoing edges. Which implies that the graph is balanced, meaning that for every node except the source and sink, in-degree equals out-degree. But in a DAG, the only nodes with unequal in-degree and out-degree are the source (in-degree 0, out-degree positive) and the sink (out-degree 0, in-degree positive). So our directed graph must satisfy this.\n\nSo how can we assign directions to edges to achieve this.\n\nHmm. Let's think about the flow conservation for each node except source and sink. The sum of incoming edges equals sum of outgoing edges.\n\nWhich suggests that for each such node v, the total flow entering equals the total flow exiting.\n\nBut how does that affect the direction of edges.\n\nWait, perhaps the way to ensure this is to have the edges directed in a way that for each node, the sum of the flows going out minus the sum of flows coming in equals the net flow, but in our case, the net is zero.\n\nWait, but for the source, the sum of outgoing is non-zero, and sum of incoming is zero.\n\nFor the sink, sum of outgoing is zero, sum of incoming is non-zero.\n\nSo, perhaps the problem is similar to finding a flow that is balanced except at the source and sink.\n\nBut how to model the directions.\n\nAnother approach: The problem can be transformed into finding a DAG where the edges are directed such that the flow along them, when computed, satisfies the balance conditions.\n\nBut how to find such a DAG.\n\nWait, perhaps the correct approach is to use a method called \"minimum s-t cut\" and then assign directions based on the residual graph.\n\nBecause, in a max-flow problem, the residual graph is a DAG, and the directions in the residual graph indicate the flow direction.\n\nSo, perhaps the solution is to compute the residual graph of the max flow, and then for each original undirected edge, check which direction is present in the residual graph. If it's present, then that's the direction we need to assign. Otherwise, assign the opposite direction.\n\nBut wait, the residual graph may have multiple edges, but in reality, each original undirected edge is represented as two directed edges in the residual graph.\n\nSo, for each original edge (u, v) with flow c, in the residual graph, there will be a directed edge u→v with capacity c, and a directed edge v→u with capacity 0. So, if in the residual graph, the edge u→v exists (with capacity >0), then we should direct the original edge as u→v. Otherwise, it's directed as v→u.\n\nThus, the plan is:\n\n1. Compute the max flow from source 1 to sink n.\n\n2. For each original edge (u, v), check in the residual graph whether there's a directed edge u→v with capacity >0. If yes, then in the output, this edge is directed as u→v (di=0). Otherwise, it's directed as v→u (di=1).\n\nBut wait, this approach assumes that the residual graph is a DAG, which it is since it has no cycles. So, the directions assigned in this way would ensure that the flow is correctly routed, and the resulting directed graph is a DAG.\n\nBut how to compute the residual graph.\n\nWait, but implementing this would require that we first compute the max flow, then build the residual graph, and for each original edge, determine the direction based on whether u→v is present.\n\nBut for large n and m, this might be computationally intensive, especially since the constraints are up to 2e5 edges.\n\nWait, but the standard algorithms for max flow, like Dinic's algorithm, can handle up to 2e5 edges efficiently. So perhaps this approach is feasible.\n\nSo the steps for the solution would be:\n\n- Read the input, build the graph.\n\n- Compute the max flow from 1 to n.\n\n- For each original edge (u, v), determine if it's directed as u→v in the residual graph. To do this, for each edge in the residual graph, if u→v exists (and has capacity >0), then output di=0. Else, di=1.\n\nBut how to represent the residual graph.\n\nIn Dinic's implementation, each edge in the residual graph has a reverse edge. So, perhaps for each original undirected edge, we can create two directed edges in the graph, both ways.\n\nSo during the max flow computation, the residual graph will have these directed edges, and their presence can be checked.\n\nBut how to extract for each original edge whether it's present in the residual graph.\n\nWait, perhaps for each original edge (u, v) with flow c, in the residual graph, the edge u→v has capacity c, and v→u has capacity 0. So, during the BFS for level assignment, if the edge u→v is part of the residual graph, then it's directed as u→v.\n\nWait, but how to track which original edges are present in the residual graph.\n\nAlternatively, during the BFS, for each node, we can keep track of the edges that are part of the residual graph. But that might be tricky.\n\nWait, perhaps after computing the max flow, for each original edge (u, v), we can check whether u is reachable from v in the residual graph. If yes, then the flow is directed as u→v. Because, in the residual graph, if v can reach u, then the reverse edge is present.\n\nWait, no. Wait, in the residual graph, if u→v is present, then v cannot reach u via that edge, but perhaps via other paths.\n\nHmm, perhaps the correct approach is to consider the level assignment during BFS. Because in a DAG, the nodes can be ordered in such a way that all edges go from earlier to later layers. So, for each edge (u, v), if u is in an earlier layer than v, then the edge is directed u→v. Otherwise, v→u.\n\nSo, combining the two approaches, perhaps the way to determine the direction is to perform a BFS from the source and assign directions based on the BFS levels.\n\nBut wait, does this always lead to the correct flow directions?\n\nI'm not entirely sure, but perhaps it's worth trying.\n\nSo, let's outline the steps:\n\n1. Perform BFS from the source (node 1) to assign levels to all nodes.\n\n2. For each original edge (u, v), if level[u] < level[v], then direct it as u→v. Else, direct it as v→u.\n\n3. Then, check if the resulting directed graph satisfies the balance conditions.\n\nBut how to implement this, and why would it work.\n\nWell, the BFS ordering ensures that all edges are directed from lower levels to higher levels, which prevents cycles because a cycle would require a node to have a higher level than a node it's connected to, which isn't possible.\n\nMoreover, the flow would then naturally push through the directed edges, ensuring that the max flow is achieved.\n\nBut does this method ensure that the sum of incoming and outgoing flows are balanced for each internal node?\n\nHmm, perhaps not directly. So maybe this approach works, but I'm not 100% sure.\n\nWait, but let's think about the example given.\n\nIn the first sample input:\n\n3 vertices, 3 edges.\n\nEdges:\n\n3-2 with 10\n\n1-2 with 10\n\n3-1 with 5.\n\nThe output is:\n\n1\n0\n1\n\nWhich corresponds to:\n\nEdge 1: 3→2 → di=1.\n\nEdge 2: 1→2 → di=0.\n\nEdge 3: 1→3 → di=1.\n\nWait, no, the output is '1\\n0\\n1' which is for each edge:\n\nFirst edge (3-2): di=1, so 2→3.\n\nSecond edge (1-2): di=0, 1→2.\n\nThird edge (3-1): di=1, so 1→3.\n\nWait, so the directions are:\n\n2→3 (edge 1)\n\n1→2 (edge 2)\n\n1→3 (edge 3).\n\nSo the flow would go from 1 to 2 and 3. From 2, it goes to 3. From 3, no outgoing edges except to 2, but since the edge is directed as 2→3, which is part of the flow.\n\nWait, but in the sample explanation, the flow is 10 units through the path 1→2→3 and 5 units directly from 1→3.\n\nHmm. So the sum for node 2 is 10 incoming (from 1) and 10 outgoing (to 3). So it's balanced.\n\nNode 3 has 10 incoming (from 2 and 1) and no outgoing.\n\nYes, that's correct.\n\nSo in this case, the BFS levels would be:\n\n1 is level 0.\n\n2 is level 1.\n\n3 is level 2.\n\nSo for edge 1: 3-2, u=3 (level 2), v=2 (level 1). So since level[u] > level[v], the direction is 2→3. So di=1.\n\nFor edge 2: 1-2, levels are 0 and 1. So direction 1→2, di=0.\n\nFor edge 3: 3-1, u=3 (level 2), v=1 (level 0). So direction 1→3, di=1.\n\nWhich matches the sample.\n\nSo this approach seems to work.\n\nAnother test case: let's see the second sample.\n\nSample Input:\n\n4 5\n\n1 2 10\n\n1 3 10\n\n2 3 5\n\n4 2 15\n\n3 4 5\n\nThe output is:\n\n0\n\n0\n\n1\n\n1\n\n0\n\nWait, the edges are numbered 1 to 5.\n\nSo for each edge, the di is as follows.\n\nLet's list them:\n\nEdge 1: 1-2, di=0 → 1→2.\n\nEdge 2: 1-3, di=0 → 1→3.\n\nEdge 3: 2-3, di=1 → 3→2.\n\nEdge 4:4-2, di=1 → 2→4.\n\nEdge 5:3-4, di=0 →3→4.\n\nSo the directed edges are:\n\n1→2, 1→3, 3→2, 2→4, 3→4.\n\nNow, let's compute the balance for each node.\n\nNode 1: outflow is 10+10=20. No inflow.\n\nNode 2: inflow is 10 (from 1). Outflow is 5 (to 3) + 15 (to 4) = 20. So 10 in, 20 out. Wait, that's not balanced.\n\nWait, but this contradicts the problem's condition. So perhaps my approach is incorrect.\n\nWait, perhaps I made a mistake in interpreting the output.\n\nWait, the output for the sample is:\n\n['0\\n0\\n1\\n1\\n0']\n\nSo each line corresponds to an edge.\n\nEdge 1: 1 2 10 → di=0 → 1→2.\n\nEdge 2: 1 3 10 → di=0 →1→3.\n\nEdge 3: 2 3 5 → di=1 →3→2.\n\nEdge 4:4 2 15 → di=1 →2→4.\n\nEdge5:3 4 5 → di=0 →3→4.\n\nSo the directed edges are:\n\n1→2, 1→3, 3→2, 2→4, 3→4.\n\nNow, node 2: inflows are 10 (from 1) and 5 (from 3?), wait no.\n\nWait, node 2 is receiving from 1 (10) and sending to 4 (15). So inflow is 10, outflow is 15. So difference is -5.\n\nWhich violates the condition. So this suggests that the approach of directing based on BFS levels may not always work.\n\nBut according to the problem statement, a solution exists. So perhaps the initial approach is wrong.\n\nHmm, this is confusing.\n\nAlternative Idea:\n\nThe problem requires that the directed graph is a DAG, and the flow through it is a valid maximum flow.\n\nIn the sample, perhaps the flow is 10 from 1→2→4 (total 25?), but I'm not sure.\n\nWait, but the sample says that the flow is 25. Because the output says the first test case's output has 10 and 5, totaling 15, but perhaps that's a different case.\n\nWait, perhaps the BFS-based approach is not sufficient, and we need to find another way.\n\nAlternative Plan:\n\nWe need to assign directions such that the residual graph is a DAG, and the flow is maximized.\n\nBut how to model this.\n\nAnother Idea: The problem can be approached by finding a minimum cut between the source and sink, then directing edges in a way that the residual graph is a DAG.\n\nWait, but I'm not sure.\n\nAlternatively, the problem can be seen as finding a directed acyclic graph (DAG) that includes all the edges, with the directions chosen such that the sum of flows entering each internal node equals the sum leaving. Additionally, the maximum flow from source to sink is achieved.\n\nBut how.\n\nAnother Idea: The problem is equivalent to finding a DAG where for each edge u→v, the flow from u to v is such that for all v, the sum of incoming flows equals the sum of outgoing flows, except for the source and sink.\n\nBut how to construct such a DAG.\n\nWait, perhaps the correct approach is to assign the direction for each edge (u, v) as u→v if and only if u is in the unique path from the source to v in some spanning tree of the graph.\n\nBut I'm not sure.\n\nWait, perhaps the correct way is to find a spanning tree where the edges are directed from the source to the leaves, ensuring that the flow can pass through the tree without cycles.\n\nBut again, not sure.\n\nAlternative Approach:\n\nEach edge (u, v) can be considered as a potential forward or backward edge in the residual graph.\n\nThe key observation is that for the flow to be maximum, the residual graph must be a DAG.\n\nSo, the directions must form a DAG.\n\nMoreover, the flow through each node must balance, which implies that the in-degree equals the out-degree for all internal nodes.\n\nWait, but in a DAG, this is only possible if the source has in-degree zero and the sink has out-degree zero, which aligns with the problem's conditions.\n\nSo, the problem reduces to finding a DAG where the edges are directed such that the flow is maximum.\n\nBut how.\n\nWait, perhaps the way to model this is by using a BFS-based approach to assign levels, but ensuring that the edges are directed from lower levels to higher levels, which ensures the in-degree and out-degree balance.\n\nBut how.\n\nWait, let's think differently. For each node v (except 1 and n), the sum of incoming edges' ci must equal the sum of outgoing edges' ci.\n\nWhich means, for each node v, the total flow into v must equal the total flow out of v.\n\nSo, the net flow through v is zero.\n\nThis is similar to saying that the graph is a flow conservation graph, except for the source and sink.\n\nSo, the problem is to assign directions to the edges such that the flow is conserved for all internal nodes, and the graph is a DAG.\n\nThus, the directed graph must satisfy:\n\n- For all v ≠ 1, n: sum_{u→v} ci = sum_{v→u'} ci'.\n\nWait, no. Because the sum of incoming edges (ci) must equal the sum of outgoing edges (cj) for each v ≠ 1, n.\n\nSo, the problem is to assign directions such that this is true, and the graph is a DAG.\n\nBut how to compute this.\n\nPerhaps the way to model this is to have the directed edges form a DAG where the flow can be pushed through the edges, and for each internal node, the flow in equals the flow out.\n\nBut how to find such a direction assignment.\n\nAlternative Idea: The problem is essentially asking to find a flow decomposition of the graph, where each edge is assigned a direction, forming a DAG, and for each node except source and sink, the sum of incoming and outgoing flows are equal.\n\nThis seems similar to the concept of a flow-conserving DAG.\n\nBut I'm not familiar with a specific algorithm for this.\n\nAnother Idea: Since the problem gives us the max flow, perhaps the directions are determined by the residual graph.\n\nSo, the approach would be:\n\n1. Compute the max flow from source to sink.\n\n2. For each original undirected edge (u, v), check if it's part of the residual graph as u→v with capacity >0.\n\nIf yes, then direct the edge as u→v (output 0). Else, direct as v→u (output 1).\n\nThis would ensure that the residual graph is a DAG, and the flow directions are correct.\n\nBut how to implement this.\n\nIn code, for each edge in the original graph, we need to determine whether u→v is present in the residual graph.\n\nBut in the Dinic's algorithm implementation, the residual graph is stored as a collection of edges, each with their own information.\n\nSo, for each original edge, we can check if u→v is present in the residual graph.\n\nBut how.\n\nWait, perhaps for each original edge (u, v), during the BFS or DFS for level assignment, we can mark the direction.\n\nAlternatively, during the BFS for level assignment in Dinic's algorithm, we can note the directions.\n\nWait, but perhaps it's easier to compute the BFS levels and then assign directions based on those levels.\n\nBut as shown earlier, the sample seems to work with that approach, but the second sample might not.\n\nWait, in the second sample, perhaps the BFS levels are:\n\n1: level 0.\n\n2: level 1.\n\n3: level 2.\n\n4: level 3.\n\nSo for each edge:\n\nEdge 1: 1-2. Levels 0 and 1. So 1→2, di=0.\n\nEdge 2: 1-3. Levels 0 and 2. So 1→3, di=0.\n\nEdge3: 2-3. Levels 1 and 2. So 2→3 is not possible, because 2 is level 1 and 3 is level 2. So 2<3, so edge is directed as 2→3, di=1.\n\nWait, no. Wait, if u is 2 (level 1) and v is 3 (level 2), then u's level is less than v's, so the edge is directed as 2→3, di=0? Or wait, the edge is (u, v) = 2,3. So in the output, if the direction is 2→3, then di is 0. But the sample output for edge 3 is 1, which means the direction is 3→2.\n\nWait, that's conflicting.\n\nWait, perhaps the approach is to assign the direction as u→v if and only if u is in a higher level than v. Because in the BFS level order, higher levels are processed later.\n\nWait, no, perhaps the direction is u→v if u is in a lower level than v, which would make the edge point from earlier to later in the BFS order.\n\nSo, for edge 3: 2-3, u=2 (level 1), v=3 (level 2). So u's level is less than v's, so the edge is directed as 2→3. So di is 0.\n\nBut according to the sample output, di is 1, meaning direction is 3→2.\n\nSo this approach would not match the sample.\n\nSo, perhaps the BFS-based approach is not correct.\n\nThus, perhaps the correct approach is to use the residual graph from the max flow computation.\n\nSo, to proceed, the plan is:\n\n1. Compute the max flow from 1 to n.\n\n2. For each original edge (u, v), check if u→v is present in the residual graph. If yes, assign di=0 (u→v). Else, assign di=1 (v→u).\n\nThis would ensure that the residual graph is a DAG, and the flow directions are correct.\n\nBut how to implement this.\n\nImplementing this requires that for each edge (u, v), we can determine whether u→v is present in the residual graph.\n\nIn Dinic's algorithm, the residual graph is represented as a list of adjacency lists, where each edge has a reverse edge.\n\nSo, for each original edge (u, v), we can look into the adjacency list of u in the residual graph to see if there's an edge from u to v.\n\nBut wait, the original edge (u, v) may have been added in either direction during the BFS.\n\nWait, but in Dinic's algorithm, each edge is represented as a forward and a backward edge.\n\nSo, for each original edge (u, v), in the residual graph, the forward edge u→v is present if the original edge was used in the flow direction.\n\nThus, for each original edge (u, v), we can check whether u→v is present in the residual graph. If yes, then the direction is u→v, else v→u.\n\nBut in code, how to check that.\n\nIn Dinic's implementation, each edge is stored as a struct (or a class) with attributes to, rev (reverse edge), capacity.\n\nSo, for each original edge (u, v, c), we can add two edges in the graph: one from u to v with capacity c, and one from v to u with capacity 0.\n\nThen, during the BFS phase of Dinic's algorithm, the level array is built, and the blocking flow is computed.\n\nAfter the max flow is computed, the residual graph is built.\n\nSo, for each original edge (u, v, c), we can check whether the forward edge (u to v) has a capacity greater than zero. If yes, then the direction is u→v (di=0). Else, the direction is v→u (di=1).\n\nYes, this makes sense.\n\nSo, the steps in code are:\n\n1. Read n, m.\n\n2. Read m edges, and for each, add both directions (u→v and v→u) to the graph, with capacities c and 0 respectively.\n\n3. Compute the max flow from 1 to n using Dinic's algorithm.\n\n4. For each original edge, check the capacity of the u→v edge in the residual graph. If capacity >0, then di=0. Else, di=1.\n\nBut wait, in the Dinic's implementation, after computing the max flow, the residual graph is such that each edge's capacity represents the remaining capacity.\n\nSo, for each original edge (u, v), the forward edge (u→v) in the residual graph has capacity equal to the flow value if it was used in the max flow.\n\nBut in the problem statement, each original edge has a given flow volume ci. So, in the residual graph, the forward edge u→v will have capacity ci if the flow passed through it, else 0.\n\nWait, no. The original edge (u, v) has flow ci, so in the residual graph, the forward edge u→v has capacity ci, and the reverse edge v→u has capacity 0.\n\nWait, yes. Because the original edge is being split into two edges, and the flow is subtracted from the forward edge.\n\nSo, for each original edge (u, v), the forward edge in the residual graph has capacity equal to the flow ci. The reverse edge has capacity 0.\n\nSo, for each original edge, if the forward edge has capacity >0, then the direction is u→v (di=0). Else, direction is v→u (di=1).\n\nThus, for each original edge, we can simply check if the forward edge's capacity is positive.\n\nBut wait, the Dinic's algorithm returns the total flow, but each edge's residual capacity is adjusted accordingly.\n\nSo, during the computation, for each edge, the forward and reverse capacities are set.\n\nSo, in code, for each original edge (u, v, c), we can find the corresponding edge in the graph and check if the forward capacity is >0.\n\nThus, the plan is solid.\n\nNow, the challenge is to implement this in Python.\n\nBut considering that m can be up to 2e5, the code must be efficient.\n\nImplementing Dinic's algorithm in Python for 2e5 edges and nodes is manageable, but may be tight.\n\nBut let's proceed.\n\nSo, the steps in code are:\n\n- Read n and m.\n\n- Read m lines, each as u, v, c.\n\n- For each edge, add it to the graph as a bidirectional edge, with forward capacity c, reverse 0.\n\n- Compute the max flow from 1 to n.\n\n- For each original edge, determine the direction based on whether the forward edge has capacity >0.\n\nNow, the main issue is how to represent the edges.\n\nIn Dinic's algorithm, each edge is represented as an object with attributes to, rev (the reverse edge), and capacity.\n\nSo, for each edge in the original list, we can loop through all edges in the graph to find the ones that correspond to (u, v, c).\n\nBut that could be time-consuming for large m.\n\nAlternative Idea: During the initial reading of edges, for each (u, v, c), store it in a list. Then, for each edge in the graph, when adding to the graph, we can refer back to the index in the list.\n\nBut perhaps a better approach is to create a dictionary that maps each (u, v) pair to the index in the edges list.\n\nWait, but in the Dinic's graph, each edge is stored as an object with 'to', 'rev', and 'cap'. So, for each original edge (u, v, c), in the Dinic's graph, we can find the edge from u to v and see if its cap is greater than zero.\n\nBut to find the edge, perhaps we can loop through all edges in the graph and for each, check if it's from u to v, and if its cap is >0.\n\nBut for m=2e5, this would take O(m^2) time, which is not feasible.\n\nAlternative Idea: Perhaps during the creation of the graph, for each original edge, we can store the index in the edges list.\n\nWait, but for each edge (u, v, c), we add two edges: u→v with c, and v→u with 0.\n\nThus, for each original edge, in the graph, the forward edge is at position i, and the reverse is at position i+1.\n\nBut I'm not sure.\n\nAlternatively, perhaps during the graph construction, for each original edge (u, v, c), we can note that the forward edge is the one added first, and the reverse is added next.\n\nSo, for each original edge, when adding to the graph, we can store the index of the forward edge.\n\nBut this might complicate things.\n\nAnother Idea: After building the graph, for each original edge (u, v, c), we can iterate through all edges in the graph and check if any edge has 'u' as 'to' and 'v' as 'from', and has a capacity >0.\n\nBut for m=2e5, this would be O(m * m), which is 4e10 operations, which is impossible.\n\nThus, this approach is not feasible.\n\nAlternative Idea: Instead of building the graph with all edges, perhaps for each original edge, during the addition, we can create a separate data structure that maps (u, v) to the edge.\n\nBut even then, for each original edge, checking the forward edge's capacity would require looking it up.\n\nThus, perhaps the only way is to process each original edge and check in the graph whether the forward edge (u→v) has a capacity >0.\n\nBut to avoid O(m^2), perhaps during the initial graph construction, for each original edge (u, v, c), we can store the forward edge's index in a list.\n\nSo, during the graph creation, for each original edge, we can create the forward edge, and also note its index.\n\nThus, for each original edge, we can quickly find whether the forward edge has capacity>0.\n\nSo, the steps would be:\n\n- Read all original edges and store them in a list 'edges_original'.\n\n- For each edge in 'edges_original', add two edges to the graph: one from u to v with capacity c, and one from v to u with capacity 0.\n\n- For each edge in 'edges_original', store the index of the forward edge in a separate list, say 'forward_indices'.\n\nThus, for each original edge i, the forward edge is at index 'forward_indices[i]'.\n\nThen, after computing the max flow, for each original edge i, check if the forward edge's capacity is >0. If yes, direction is 0; else, direction is 1.\n\nYes, this would be efficient.\n\nSo, the plan is:\n\n1. Read n and m.\n\n2. Read m edges, store as a list.\n\n3. For each edge, add to the graph as a forward and reverse edge.\n\n4. Record the index of the forward edge for each original edge.\n\n5. Run Dinic's algorithm to compute the max flow.\n\n6. For each original edge, check if the forward edge's capacity is >0. If yes, output 0; else, output 1.\n\nThus, this approach is feasible.\n\nNow, the code:\n\nImplementing this in Python.\n\nWe'll need a Dinic's implementation that can handle large graphs.\n\nHere's the code outline:\n\n- Implement the Edge class.\n\n- Read n and m.\n\n- Read m edges, store as a list.\n\n- For each edge, create a forward edge and a reverse edge.\n\n- For each original edge, record the index of the forward edge.\n\n- Build the graph.\n\n- Compute the max flow.\n\n- For each original edge, check the forward edge's capacity.\n\nNow, the code:\n\nBut let's write it step by step.\n\nFirst, the Edge class:\n\nclass Edge:\n    def __init__(self, to, rev, capacity):\n        self.to = to\n        self.rev = rev\n        self.cap = capacity\n\nThen, the Dinic's implementation:\n\nclass Dinic:\n    def __init__(self, n):\n        self.size = n\n        self.graph = [[] for _ in range(n)]\n\n    def add_edge(self, fr, to, cap):\n        forward = Edge(to, len(self.graph[to]), cap)\n        backward = Edge(fr, len(self.graph[fr]), 0)\n        self.graph[fr].append(forward)\n        self.graph[to].append(backward)\n\n    def bfs_level(self, s, t, level):\n        q = deque()\n        level[:] = [-1]*self.size\n        level[s] = 0\n        q.append(s)\n        while q:\n            v = q.popleft()\n            for edge in self.graph[v]:\n                if edge.cap > 0 and level[edge.to] == -1:\n                    level[edge.to] = level[v]+1\n                    q.append(edge.to)\n                    if edge.to == t:\n                        return\n        return\n\n    def dfs_flow(self, v, t, flow, level, ptr):\n        if v == t:\n            return flow\n        while ptr[v] < len(self.graph[v]):\n            edge = self.graph[v][ptr[v]]\n            if edge.cap > 0 and level[v] < level[edge.to]:\n                min_flow = min(flow, edge.cap)\n                result = self.dfs_flow(edge.to, t, min_flow, level, ptr)\n                if result > 0:\n                    edge.cap -= result\n                    self.graph[edge.to][edge.rev].cap += result\n                    return result\n            ptr[v] += 1\n        return 0\n\n    def max_flow(self, s, t):\n        flow = 0\n        level = [-1]*self.size\n        while True:\n            self.bfs_level(s, t, level)\n            if level[t] == -1:\n                return flow\n            ptr = [0]*self.size\n            while True:\n                f = self.dfs_flow(s, t, float('inf'), level, ptr)\n                if f == 0:\n                    break\n                flow += f\n            level = [-1]*self.size\n        return flow\n\nWait, but in the Dinic's implementation, the 'graph",
    "response": "To solve this problem, we need to determine the direction of each edge in a flow network such that the resulting graph satisfies certain conditions. The goal is to ensure that for each vertex (except the source and sink), the sum of incoming edges equals the sum of outgoing edges, the source has no incoming edges, and the graph does not have cycles.\n\n### Approach\n1. **Problem Analysis**: The given graph is undirected, and we need to assign directions to each edge to form a directed acyclic graph (DAG) with a valid maximum flow. Each edge's direction must be determined such that the resulting graph meets the balance conditions for flow conservation.\n\n2. **Intuition**: The problem can be approached by using the concept of residual graphs from max-flow algorithms. In a max-flow problem, the residual graph (which is directed) is a DAG, and each original undirected edge is represented as two directed edges in the residual graph.\n\n3. **Algorithm Selection**: We use Dinic's algorithm to compute the maximum flow from the source to the sink. After computing the max flow, we determine the direction of each original edge based on whether it is present in the residual graph.\n\n4. **Steps**:\n   - Read the input and construct the graph.\n   - Use Dinic's algorithm to compute the maximum flow.\n   - For each original edge, check if it is present in the residual graph as a forward edge. If it is, direct the edge accordingly; otherwise, direct it in the reverse direction.\n\n### Solution Code\n```python\nimport sys\nfrom collections import deque\n\nclass Edge:\n    def __init__(self, to, rev, cap):\n        self.to = to\n        self.rev = rev\n        self.cap = cap\n\nclass Dinic:\n    def __init__(self, n):\n        self.size = n\n        self.graph = [[] for _ in range(n)]\n    \n    def add_edge(self, fr, to, cap):\n        forward = Edge(to, len(self.graph[to]), cap)\n        backward = Edge(fr, len(self.graph[fr]), 0)\n        self.graph[fr].append(forward)\n        self.graph[to].append(backward)\n    \n    def bfs_level(self, s, t, level):\n        q = deque()\n        level[:] = [-1] * self.size\n        level[s] = 0\n        q.append(s)\n        while q:\n            v = q.popleft()\n            for edge in self.graph[v]:\n                if edge.cap > 0 and level[edge.to] == -1:\n                    level[edge.to] = level[v] + 1\n                    q.append(edge.to)\n                    if edge.to == t:\n                        return\n    \n    def dfs_flow(self, v, t, flow, level, ptr):\n        if v == t:\n            return flow\n        while ptr[v] < len(self.graph[v]):\n            edge = self.graph[v][ptr[v]]\n            if edge.cap > 0 and level[v] < level[edge.to]:\n                min_flow = min(flow, edge.cap)\n                result = self.dfs_flow(edge.to, t, min_flow, level, ptr)\n                if result > 0:\n                    edge.cap -= result\n                    self.graph[edge.to][edge.rev].cap += result\n                    return result\n            ptr[v] += 1\n        return 0\n    \n    def max_flow(self, s, t):\n        flow = 0\n        level = [-1] * self.size\n        while True:\n            self.bfs_level(s, t, level)\n            if level[t] == -1:\n                return flow\n            ptr = [0] * self.size\n            while True:\n                f = self.dfs_flow(s, t, float('inf'), level, ptr)\n                if f == 0:\n                    break\n                flow += f\n            level = [-1] * self.size\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n\n    edges_original = []\n    for _ in range(m):\n        u = int(input[idx])\n        idx += 1\n        v = int(input[idx])\n        idx += 1\n        c = int(input[idx])\n        idx += 1\n        edges_original.append( (u, v, c) )\n\n    # Create Dinic's graph\n    dinic = Dinic(n)\n    forward_indices = [0]*m\n    for i in range(m):\n        u, v, c = edges_original[i]\n        forward_idx = dinic.add_edge(u-1, v-1, c)\n        forward_indices[i] = forward_idx\n\n    # Compute max flow\n    maxf = dinic.max_flow(0, n-1)\n\n    # Prepare output\n    output = []\n    for i in range(m):\n        u, v, c = edges_original[i]\n        edge = dinic.graph[u-1][forward_indices[i]]\n        if edge.cap > 0:\n            output.append('0')\n        else:\n            output.append('1')\n    \n    print('\\n'.join(output))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into vertices and edges.\n2. **Graph Construction**: The graph is constructed using an adjacency list where each edge is added in both directions with appropriate capacities.\n3. **Max Flow Calculation**: Using Dinic's algorithm, the maximum flow from the source to the sink is computed.\n4. **Direction Determination**: For each original edge, the direction is determined based on whether the forward edge in the residual graph has a positive capacity. If it does, the edge is directed from the original start to end; otherwise, it is directed in the reverse direction.\n\nThis approach ensures that the resulting directed graph is a DAG and satisfies the flow conservation conditions for all internal nodes.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\nclass Edge:\n    def __init__(self, to, rev, cap):\n        self.to = to\n        self.rev = rev\n        self.cap = cap\n\nclass Dinic:\n    def __init__(self, n):\n        self.size = n\n        self.graph = [[] for _ in range(n)]\n    \n    def add_edge(self, fr, to, cap):\n        forward = Edge(to, len(self.graph[to]), cap)\n        backward = Edge(fr, len(self.graph[fr]), 0)\n        self.graph[fr].append(forward)\n        self.graph[to].append(backward)\n    \n    def bfs_level(self, s, t, level):\n        q = deque()\n        level[:] = [-1] * self.size\n        level[s] = 0\n        q.append(s)\n        while q:\n            v = q.popleft()\n            for edge in self.graph[v]:\n                if edge.cap > 0 and level[edge.to] == -1:\n                    level[edge.to] = level[v] + 1\n                    q.append(edge.to)\n                    if edge.to == t:\n                        return\n    \n    def dfs_flow(self, v, t, flow, level, ptr):\n        if v == t:\n            return flow\n        while ptr[v] < len(self.graph[v]):\n            edge = self.graph[v][ptr[v]]\n            if edge.cap > 0 and level[v] < level[edge.to]:\n                min_flow = min(flow, edge.cap)\n                result = self.dfs_flow(edge.to, t, min_flow, level, ptr)\n                if result > 0:\n                    edge.cap -= result\n                    self.graph[edge.to][edge.rev].cap += result\n                    return result\n            ptr[v] += 1\n        return 0\n    \n    def max_flow(self, s, t):\n        flow = 0\n        level = [-1] * self.size\n        while True:\n            self.bfs_level(s, t, level)\n            if level[t] == -1:\n                return flow\n            ptr = [0] * self.size\n            while True:\n                f = self.dfs_flow(s, t, float('inf'), level, ptr)\n                if f == 0:\n                    break\n                flow += f\n            level = [-1] * self.size\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx += 1\n    m = int(input[idx])\n    idx += 1\n\n    edges_original = []\n    for _ in range(m):\n        u = int(input[idx])\n        idx += 1\n        v = int(input[idx])\n        idx += 1\n        c = int(input[idx])\n        idx += 1\n        edges_original.append( (u, v, c) )\n\n    # Create Dinic's graph\n    dinic = Dinic(n)\n    forward_indices = [0]*m\n    for i in range(m):\n        u, v, c = edges_original[i]\n        forward_idx = dinic.add_edge(u-1, v-1, c)\n        forward_indices[i] = forward_idx\n\n    # Compute max flow\n    maxf = dinic.max_flow(0, n-1)\n\n    # Prepare output\n    output = []\n    for i in range(m):\n        u, v, c = edges_original[i]\n        edge = dinic.graph[u-1][forward_indices[i]]\n        if edge.cap > 0:\n            output.append('0')\n        else:\n            output.append('1')\n    \n    print('\\n'.join(output))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 658,
        "completion_token_count": 1233,
        "thoughts_token_count": 8193
    }
}