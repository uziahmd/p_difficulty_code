{
    "start": 1758278909.3164344,
    "end": 1758279451.8426895,
    "start-formatted": "2025-09-19 19:48 KST",
    "end-formatted": "2025-09-19 19:57 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read it carefully.\n\nThe problem is about restoring the number of laughy mushrooms on each lawn based on the information from some roads. Each road gives two numbers: the GCD and LCM of the two lawns it connects. My task is to determine if there's a possible arrangement of mushrooms that satisfies all these constraints and output it, or say it's impossible.\n\nHmm, let's think about how to model this. It feels like a graph problem where each node (lawn) has a value, and edges impose constraints between pairs of nodes. So, for each edge, the GCD of the two nodes' values must equal the given GCD, and the LCM must equal the given LCM.\n\nWait, but wait. The GCD and LCM are related in a specific way. For any two numbers a and b, GCD(a,b) * LCM(a,b) = a*b. So for each edge, the product of the given GCD and LCM must equal the product of the two nodes' values.\n\nSo for each edge, the equation is:\nGCD(e) * LCM(e) = x_u * x_v\n\nWhere x_u and x_v are the values at the two ends of the edge.\n\nThis seems crucial. So for each edge, we can compute x_u * x_v as GCD*LCM. Let's denote this product as K. So x_u * x_v = K.\n\nBut then, each edge imposes that the product of the two nodes is K. So how do we model this?\n\nThis looks like a problem where variables are connected through multiplicative constraints. Maybe we can model this as a system of equations where each equation is x_u * x_v = K_e for each edge e.\n\nBut solving such a system might be tricky. How can we represent this? Perhaps using Union-Find with some additional structure, but I'm not sure.\n\nAlternatively, since each variable is the count of mushrooms, which are positive integers, perhaps we can model this with some kind of BFS or DFS approach, assigning values as we go and checking for consistency.\n\nWait, but the problem requires that all edges must be satisfied. So, for each connected component, the variables are interdependent. So maybe we can model each connected component as a system where variables are determined relative to a root.\n\nAnother thought: For each connected component, we can assign a value to one node, and express all other nodes' values in terms of this root. Then, we can check if all edges in the component are satisfied.\n\nLet me try to formalize this. Suppose we pick a root node, say r, and assign it a value x_r. Then, for each node u in the component, we can write x_u = k_u * x_r, where k_u is some integer >=1.\n\nWait, but what's the reasoning behind that? Because for any node u, all edges connected to it must satisfy x_u * x_v = K_e for each edge (u, v). So, substituting x_v = k_v * x_r into x_u * x_v = K_e, and since x_u = k_u * x_r, we get:\n\nk_u * x_r * k_v * x_r = K_e → x_r^2 * k_u k_v = K_e.\n\nBut K_e is fixed for each edge. So for each edge (u, v), K_e must equal x_r squared times the product of k_u and k_v.\n\nHmm, this suggests that for each edge, K_e must be divisible by x_r squared. But since x_r is a variable, perhaps this approach isn't directly applicable.\n\nAlternatively, perhaps for each connected component, we can find all possible x_r (the root's value) such that all edges are satisfied, and then assign x_u accordingly.\n\nBut this could be computationally expensive, especially since x_r can vary.\n\nWait, but the constraints are that for each edge, x_u * x_v = K_e. So for any connected component, the product of all x's in the component must be equal to the product of all K_e's along a spanning tree of the component. Wait, because each edge contributes a factor of K_e, and each node's x is multiplied once in the spanning tree edges. So the product of all K_e's in the spanning tree would be equal to the product of x_u's.\n\nWait, that's an interesting point. Let's think: if you have a connected component with nodes connected by edges, then the product of all the x's in the component is equal to the product of all the K_e's for the edges, but only considering a set of edges that form a spanning tree. Because each node is included exactly once in the product.\n\nBut since any spanning tree will have (n-1) edges for n nodes, the product of K_e's for these (n-1) edges should equal the product",
    "response": "To solve this problem, we need to determine if it is possible to restore the number of laughy mushrooms on each lawn based on the given roads and their respective GCD and LCM values. If possible, we must output the arrangement; otherwise, we should indicate that it is impossible.\n\n### Approach\n1. **Graph Representation**: Represent the lawns as nodes and the roads as edges in a graph. Each edge has two attributes: GCD and LCM.\n2. **Constraints Check**: For each edge, the product of the GCD and LCM must equal the product of the mushrooms on the two connected lawns. This gives us the equation:\n   \\[\n   \\text{GCD}(u, v) \\times \\text{LCM}(u, v) = x_u \\times x_v\n   \\]\n   where \\(x_u\\) and \\(x_v\\) are the number of mushrooms on lawns \\(u\\) and \\(v\\).\n3. **Union-Find Data Structure**: Use Union-Find to manage connected components of the graph. Each component can be processed independently.\n4. **Component Processing**: For each connected component, assign a root node and express all other nodes' values relative to the root. This involves checking if all constraints within the component can be satisfied.\n5. **Cycle Check**: Ensure there are no cycles that violate the constraints. If any cycle violates the constraints, the arrangement is impossible.\n\n### Solution Code\n```python\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    sys.setrecursionlimit(1 << 25)\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    m = int(input[idx+1])\n    idx +=2\n\n    edges = []\n    for _ in range(m):\n        u = int(input[idx])-1\n        v = int(input[idx+1])-1\n        gcd = int(input[idx+2])\n        lcm = int(input[idx+3])\n        idx +=4\n        edges.append( (u, v, gcd, lcm) )\n\n    # Build adjacency list\n    adj = [[] for _ in range(n)]\n    for u, v, g, l in edges:\n        adj[u].append( (v, g, l) )\n        adj[v].append( (u, g, l) )\n\n    # Union-Find structure\n    parent = list(range(n))\n    rank = [1]*n\n\n    def find(u):\n        while parent[u] != u:\n            parent[u] = parent[parent[u]]\n            u = parent[u]\n        return u\n\n    def union(u, v):\n        u_root = find(u)\n        v_root = find(v)\n        if u_root == v_root:\n            return False\n        if rank[u_root] < rank[v_root]:\n            parent[u_root] = v_root\n            rank[v_root] *= rank[u_root]\n        else:\n            parent[v_root] = u_root\n            rank[u_root] *= v_root\n        return True\n\n    # For each component, try to assign values\n    possible = True\n    components = defaultdict(list)\n    for i in range(n):\n        components[find(i)].append(i)\n\n    # For each component, try to assign values\n    for comp in components.values():\n        if len(comp) == 0:\n            continue\n        # Try to assign root value\n        root = comp[0]\n        root_val = 1\n        valid = True\n        # Create a dictionary to hold the current x values\n        x = {}\n        for node in comp:\n            x[node] = 1\n        # Assign root_val to root\n        x[root] = root_val\n        # BFS to process all nodes\n        from collections import deque\n        q = deque()\n        q.append(root)\n        visited = set()\n        visited.add(root)\n        while q:\n            u = q.popleft()\n            for v, g, l in adj[u]:\n                if v not in visited:\n                    visited.add(v)\n                    q.append(v)\n        # Now check all edges in the component\n        for u, v, g, l in edges:\n            if find(u) != find(v):\n                continue\n            if u not in x or v not in x:\n                possible = False\n                break\n            if x[u] * x[v] != g * l:\n                possible = False\n                break\n        if not possible:\n            break\n        # Also, check if any cycles exist\n        # Extract all edges in the component\n        comp_edges = []\n        for u, v, g, l in edges:\n            if find(u) == find(v):\n                comp_edges.append( (u, v, g, l) )\n        # Check if the component forms a bipartite graph\n        # But more importantly, ensure that the product constraints are consistent\n        # So for each edge in the component, x_u * x_v = g * l\n        # We have already checked this, but also ensure that the product constraints are consistent with the tree structure\n        # So we can model it as a system of equations\n        # Let's try to model this as a graph where each node is connected to others via x_u = k * x_root\n        # Then for each edge (u, v), x_u * x_v = K_e\n        # Substituting x_u = k_u * x_root, x_v = k_v * x_root\n        # So (k_u * x_root) * (k_v * x_root) = K_e => x_root^2 * k_u k_v = K_e\n        # So for each edge, K_e must be divisible by x_root squared\n        # But since x_root is variable, perhaps this approach isn't feasible\n        # Alternatively, for each component, find all possible x_root such that all edges are satisfied\n        # But this could be computationally expensive\n        # Instead, note that the product of all x's in the component is equal to the product of all K_e's along a spanning tree\n        # Because each edge contributes K_e = x_u * x_v, and in a spanning tree, each node is included exactly once\n        # So the product of all K_e's in the spanning tree equals the product of all x's in the component\n        # Let's compute the product of all K_e's for the component\n        # And then see if the product can be represented as x_root raised to some power times the product of the k's\n        # Wait, maybe this is getting too complicated\n        # Another approach: for each component, collect all the edges, and for each edge, compute K = GCD * LCM\n        # Then, the product of all K's in the component must be equal to x_root^(degree -1) multiplied by the product of the k's\n        # Hmm, perhaps not directly helpful\n        # Maybe it's better to model each component as a system where each x is expressed in terms of the root x_root\n        # For example, in a component with nodes A-B-C, we can have x_A = a, x_B = b, x_C = c\n        # From edge A-B: a*b = K1\n        # From edge B-C: b*c = K2\n        # From edge A-C: a*c = K3\n        # Solving these, we get a = sqrt(K1), c = sqrt(K2), etc., but it's not straightforward\n        # Alternatively, note that the product of all x's in the component must be equal to the product of all K's in a spanning tree\n        # So for the component, let S be the set of edges in a spanning tree\n        # Then, product of x's = product of K_e for e in S\n        # Since in a spanning tree, each node appears exactly once, the product of x's is the product of K_e's for the edges in the tree\n        # So for the component, compute the product of K_e for all edges in the component, then check if it can be represented as x_root^(n-1) * something\n        # Wait, but how?\n        # Maybe the key insight is that for each component, the product of all K_e's must be equal to x_root^(n-1) * product of k's, where k's are variables determined by the edges\n        # This is getting too abstract. Perhaps instead, for each component, we can compute the product of all K_e's for its edges, and then determine if this product can be expressed as x_root^(c) multiplied by some other factors, where c is the number of edges minus the number of nodes plus one.\n\n        # For each component, the number of edges is E, number of nodes is N.\n        # The product of all K_e's is P.\n        # The product P must be equal to x_root^(E - (N -1)) ) because in a spanning tree, E_tree = N-1, so P = x_root^(E - (N-1)) ) * ... ?\n\n        # Alternatively, for each component, compute the product of all K_e's for its edges, and see if this product can be factored into x_root^(some exponent) multiplied by other factors.\n\n        # But this might not be straightforward. Perhaps it's better to consider that for each component, the product of all K_e's must be a perfect square if the component has cycles, but I'm not sure.\n\n        # Given the complexity, perhaps the best approach is to model each component as a graph where each edge imposes x_u * x_v = K_e, and then use BFS to assign x values relative to a root, ensuring consistency across all edges.\n\n        # So, for each component, pick a root, assign x_root, then propagate the values through BFS, checking at each step if the constraints are satisfied.\n\n        # If any inconsistency is found during this process, mark the entire arrangement as impossible.\n\n    if not possible:\n        print(\"NO\")\n    else:\n        # Assign values\n        x = []\n        for i in range(n):\n            x.append(1)\n        # Now, for each component, process again to assign x\n        for comp in components.values():\n            if len(comp) == 0:\n                continue\n            root = comp[0]\n            root_val = 1\n            x[root] = root_val\n            # BFS to process all nodes in the component\n            visited = set()\n            visited.add(root)\n            q = deque([root])\n            while q:\n                u = q.popleft()\n                for v, g, l in adj[u]:\n                    if v not in visited:\n                        visited.add(v)\n                        q.append(v)\n                        # Assign x[v] based on x[u]\n                        # x[v] = K / x[u]\n                        # But K is g * l\n                        # Also, x[v] must be an integer\n                        if g == 0 or l == 0:\n                            possible = False\n                            break\n                        if x[u] * x[v] != g * l:\n                            possible = False\n                            break\n                        x[v] = (g * l) // x[u]\n                if not possible:\n                    break\n            if not possible:\n                break\n        if not possible:\n            print(\"NO\")\n        else:\n            print(\"YES\")\n            print(' '.join(map(str, x)))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\nThe solution involves constructing a graph where each node represents a lawn and each edge represents a road with given GCD and LCM values. Using a Union-Find data structure, we manage connected components of the graph. For each component, we attempt to assign values to the nodes starting from a root node, ensuring that all edge constraints are satisfied. If any inconsistency is found during this process, the arrangement is deemed impossible. Otherwise, we output the restored values for each lawn.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import defaultdict\n\ndef main():\n    sys.setrecursionlimit(1 << 25)\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    m = int(input[idx+1])\n    idx +=2\n\n    edges = []\n    for _ in range(m):\n        u = int(input[idx])-1\n        v = int(input[idx+1])-1\n        gcd = int(input[idx+2])\n        lcm = int(input[idx+3])\n        idx +=4\n        edges.append( (u, v, gcd, lcm) )\n\n    # Build adjacency list\n    adj = [[] for _ in range(n)]\n    for u, v, g, l in edges:\n        adj[u].append( (v, g, l) )\n        adj[v].append( (u, g, l) )\n\n    # Union-Find structure\n    parent = list(range(n))\n    rank = [1]*n\n\n    def find(u):\n        while parent[u] != u:\n            parent[u] = parent[parent[u]]\n            u = parent[u]\n        return u\n\n    def union(u, v):\n        u_root = find(u)\n        v_root = find(v)\n        if u_root == v_root:\n            return False\n        if rank[u_root] < rank[v_root]:\n            parent[u_root] = v_root\n            rank[v_root] *= rank[u_root]\n        else:\n            parent[v_root] = u_root\n            rank[u_root] *= v_root\n        return True\n\n    # For each component, try to assign values\n    possible = True\n    components = defaultdict(list)\n    for i in range(n):\n        components[find(i)].append(i)\n\n    # For each component, try to assign values\n    for comp in components.values():\n        if len(comp) == 0:\n            continue\n        # Try to assign root value\n        root = comp[0]\n        root_val = 1\n        valid = True\n        # Create a dictionary to hold the current x values\n        x = {}\n        for node in comp:\n            x[node] = 1\n        # Assign root_val to root\n        x[root] = root_val\n        # BFS to process all nodes\n        from collections import deque\n        q = deque()\n        q.append(root)\n        visited = set()\n        visited.add(root)\n        while q:\n            u = q.popleft()\n            for v, g, l in adj[u]:\n                if v not in visited:\n                    visited.add(v)\n                    q.append(v)\n        # Now check all edges in the component\n        for u, v, g, l in edges:\n            if find(u) != find(v):\n                continue\n            if u not in x or v not in x:\n                possible = False\n                break\n            if x[u] * x[v] != g * l:\n                possible = False\n                break\n        if not possible:\n            break\n        # Also, check if any cycles exist\n        # Extract all edges in the component\n        comp_edges = []\n        for u, v, g, l in edges:\n            if find(u) == find(v):\n                comp_edges.append( (u, v, g, l) )\n        # Check if the component forms a bipartite graph\n        # But more importantly, ensure that the product constraints are consistent\n        # So for each edge in the component, x_u * x_v = g * l\n        # We have already checked this, but also ensure that the product constraints are consistent with the tree structure\n        # So we can model it as a system of equations\n        # Let's try to model this as a graph where each node is connected to others via x_u = k * x_root\n        # Then for each edge (u, v), x_u * x_v = K_e\n        # Substituting x_u = k_u * x_root, x_v = k_v * x_root\n        # So (k_u * x_root) * (k_v * x_root) = K_e => x_root^2 * k_u k_v = K_e\n        # So for each edge, K_e must be divisible by x_root squared\n        # But since x_root is variable, perhaps this approach isn't feasible\n        # Alternatively, for each component, find all possible x_root such that all edges are satisfied\n        # But this could be computationally expensive\n        # Instead, note that the product of all x's in the component is equal to the product of all K_e's along a spanning tree\n        # Because each edge contributes K_e = x_u * x_v, and in a spanning tree, each node is included exactly once\n        # So the product of all K_e's in the spanning tree equals the product of all x's in the component\n        # Let's compute the product of all K_e's for the component\n        # And then see if the product can be represented as x_root raised to some power times the product of the k's\n        # Wait, maybe this is getting too complicated\n        # Another approach: for each component, collect all the edges, and for each edge, compute K = GCD * LCM\n        # Then, the product of all K's in the component must be equal to x_root^(degree -1) multiplied by the product of the k's\n        # Hmm, perhaps not directly helpful\n        # Maybe it's better to model each component as a system where each x is expressed in terms of the root x_root\n        # For example, in a component with nodes A-B-C, we can have x_A = a, x_B = b, x_C = c\n        # From edge A-B: a*b = K1\n        # From edge B-C: b*c = K2\n        # From edge A-C: a*c = K3\n        # Solving these, we get a = sqrt(K1), c = sqrt(K2), etc., but it's not straightforward\n        # Alternatively, note that the product of all x's in the component must be equal to the product of all K's in a spanning tree\n        # So for the component, let S be the set of edges in a spanning tree\n        # Then, product of x's = product of K_e for e in S\n        # Since in a spanning tree, each node appears exactly once, the product of x's is the product of K_e's for the edges in the tree\n        # So for the component, compute the product of K_e for all edges in the component, then check if it can be represented as x_root^(n-1) * something\n        # Wait, but how?\n        # Maybe the key insight is that for each component, the product of all K_e's must be equal to x_root^(n-1) * product of k's, where k's are variables determined by the edges\n        # This is getting too abstract. Perhaps instead, for each component, we can compute the product of all K_e's for its edges, and then determine if this product can be expressed as x_root^(c) multiplied by some other factors, where c is the number of edges minus the number of nodes plus one.\n\n        # For each component, the number of edges is E, number of nodes is N.\n        # The product of all K_e's is P.\n        # The product P must be equal to x_root^(E - (N -1)) ) because in a spanning tree, E_tree = N-1, so P = x_root^(E - (N-1)) ) * ... ?\n\n        # Alternatively, for each component, compute the product of all K_e's for its edges, and see if this product can be factored into x_root^(some exponent) multiplied by other factors.\n\n        # But this might not be straightforward. Perhaps it's better to consider that for each component, the product of all K_e's must be a perfect square if the component has cycles, but I'm not sure.\n\n        # Given the complexity, perhaps the best approach is to model each component as a graph where each edge imposes x_u * x_v = K_e, and then use BFS to assign x values relative to a root, ensuring consistency across all edges.\n\n        # So, for each component, pick a root, assign x_root, then propagate the values through BFS, checking at each step if the constraints are satisfied.\n\n        # If any inconsistency is found during this process, mark the entire arrangement as impossible.\n\n    if not possible:\n        print(\"NO\")\n    else:\n        # Assign values\n        x = []\n        for i in range(n):\n            x.append(1)\n        # Now, for each component, process again to assign x\n        for comp in components.values():\n            if len(comp) == 0:\n                continue\n            root = comp[0]\n            root_val = 1\n            x[root] = root_val\n            # BFS to process all nodes in the component\n            visited = set()\n            visited.add(root)\n            q = deque([root])\n            while q:\n                u = q.popleft()\n                for v, g, l in adj[u]:\n                    if v not in visited:\n                        visited.add(v)\n                        q.append(v)\n                        # Assign x[v] based on x[u]\n                        # x[v] = K / x[u]\n                        # But K is g * l\n                        # Also, x[v] must be an integer\n                        if g == 0 or l == 0:\n                            possible = False\n                            break\n                        if x[u] * x[v] != g * l:\n                            possible = False\n                            break\n                        x[v] = (g * l) // x[u]\n                if not possible:\n                    break\n            if not possible:\n                break\n        if not possible:\n            print(\"NO\")\n        else:\n            print(\"YES\")\n            print(' '.join(map(str, x)))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 544,
        "completion_token_count": 2498,
        "thoughts_token_count": 1025
    }
}