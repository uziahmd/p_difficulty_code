{
    "start": 1758278100.3423526,
    "end": 1758278307.4443283,
    "start-formatted": "2025-09-19 19:35 KST",
    "end-formatted": "2025-09-19 19:38 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read it carefully.\n\nThe problem is about assigning Rebel spaceships to guard B bases such that every base has exactly one guardian and each spaceship is assigned to exactly one base. So it's a perfect matching between R ships and B bases.\n\nBut there's a catch: the paths from each base to its assigned spaceship shouldn't intersect. The paths are straight lines in 2D space, and we need to make sure none of them cross each other.\n\nHmm, how to model this? I think this is similar to checking if a bipartite graph is matchable and whether the edges (representing non-intersecting paths) form a matching.\n\nWait, but how do we determine if two paths intersect? Because for any two pairs of points (ship A to base X and ship B to base Y), their line segments should not cross.\n\nSo, for a given matching, we need to ensure that all the corresponding line segments don't intersect with each other.\n\nThe approach I can think of is:\n\n1. Generate all possible perfect matchings between R ships and B bases.\n2. For each perfect matching, check if all the line segments (from ship to base) are non-intersecting.\n3. If any such matching exists, output \"Yes\". Otherwise, \"No\".\n\nBut wait, R and B can be up to 10, so R might be equal to B. Wait, the problem says R and B are both up to 10, but the input ensures that no two points are the same and no three are colinear. So, when R != B, it's impossible to have a perfect matching, right? Because a perfect matching requires R == B since each ship is assigned to exactly one base and vice versa.\n\nWait, looking back at the problem statement: the first line gives R and B, and it's guaranteed that the assignment is a perfect matching. So for the assignment to be possible, R must equal B. Because each ship must be assigned to exactly one base and each base to exactly one ship. So, if R != B, it's automatically impossible, hence output \"No\".\n\nSo first step: check if R == B. If not, output \"No\".\n\nIf R equals B, proceed to find a perfect matching where all the line segments are non-intersecting.\n\nNow, the main challenge is to generate all possible perfect matchings and check for each if the corresponding segments don't intersect.\n\nHow many perfect matchings are there? For R = B = 10, the number is 10! which is 3,628,800. That's manageable for a brute-force approach because even 3 million iterations are acceptable for Python, especially considering each iteration's processing is minimal.\n\nSo the plan is:\n\n- Read R and B. If they are not equal, output \"No\".\n- Else, collect all the ship coordinates and base coordinates.\n- Generate all possible permutations of B bases for the R ships.\n- For each permutation:\n   - Check if the permutation represents a perfect matching (which it will, since R = B, but perhaps not necessary).\n   - For each pair in the permutation, create a line segment between ship i and base j.\n   - Check if any two line segments intersect.\n   - If no intersections, return \"Yes\".\n- If none of the permutations satisfy the condition, return \"No\".\n\nNow, the key part is implementing the function to check if two line segments intersect.\n\nI remember that the standard way to check if two line segments AB and CD intersect is using the cross product method. The line segments AB and CD intersect if and only if the points C and D are on opposite sides of AB, and A and B are on opposite sides of CD.\n\nWait, more precisely, the algorithm is as follows:\n\nGiven two line segments AB and CD.\n\nCompute the orientation of four points: A, B, C and A, B, D.\n\nThe line segments AB and CD intersect if and only if:\n\n- The orientations of (A,B,C) and (A,B,D) are different, meaning C and D are on opposite sides of AB.\n\nAND\n\n- The orientations of (C,D,A) and (C,D,B) are different, meaning A and B are on opposite sides of CD.\n\nBut also, the endpoints can lie on the other segment, but according to the problem statement, no three points are colinear, so that case isn't possible here.\n\nWait, the problem statement says that no three points are on the same line. So, the line segments can't be overlapping or colinear. So, the above condition is sufficient.\n\nSo, the steps for the function:\n\ndef segments_intersect(a, b, c, d):\n    # Compute orientation of (a,b,c)\n    def ccw(a, b, c):\n        return (b[0]-a[0])*(c[1]-a[1]) - (b[1]-a[1])*(c[0]-a",
    "response": "To solve this problem, we need to determine if it is possible to assign Rebel spaceships to guard B bases such that each base has exactly one guardian and each spaceship is assigned to exactly one base. Additionally, the paths from each base to its assigned spaceship must not intersect.\n\n### Approach\n1. **Check for Perfect Matching**: First, check if the number of Rebel spaceships (R) is equal to the number of bases (B). If they are not equal, output \"No\" because a perfect matching is impossible.\n2. **Generate All Possible Matchings**: For R = B, generate all possible permutations of B bases for the R spaceships. Each permutation represents a potential assignment of ships to bases.\n3. **Check for Non-Intersecting Paths**: For each permutation, create line segments between each ship and its assigned base. Check if any two line segments intersect. If none intersect, output \"Yes\". If all permutations result in intersecting segments, output \"No\".\n\n### Solution Code\n```python\nimport sys\nfrom itertools import permutations\n\ndef readints():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef ccw(a, b, c):\n    return (b[0]-a[0])*(c[1]-a[1]) - (b[1]-a[1])*(c[0]-a[0])\n\ndef segments_intersect(a, b, c, d):\n    # Check if AB intersects CD\n    ccw1 = ccw(a, b, c)\n    ccw2 = ccw(a, b, d)\n    if ccw1 * ccw2 > 0:\n        return False\n    ccw3 = ccw(c, d, a)\n    ccw4 = ccw(c, d, b)\n    if ccw3 * ccw4 > 0:\n        return False\n    return True\n\ndef main():\n    R_B = sys.stdin.readline().strip()\n    while R_B == '':\n        R_B = sys.stdin.readline().strip()\n    R, B = map(int, R_B.split())\n    \n    if R != B:\n        print(\"No\")\n        return\n    \n    ships = []\n    for _ in range(R):\n        x, y = map(int, sys.stdin.readline().split())\n        ships.append((x, y))\n    \n    bases = []\n    for _ in range(B):\n        x, y = map(int, sys.stdin.readline().split())\n        bases.append((x, y))\n    \n    # Generate all possible matchings\n    for perm in permutations(bases):\n        match = {}\n        for i in range(R):\n            ship = ships[i]\n            base = perm[i]\n            match[ship] = base\n        \n        # Check all pairs of segments\n        conflict = False\n        for i in range(R):\n            for j in range(i+1, R):\n                ship_i = ships[i]\n                base_i = match[ship_i]\n                ship_j = ships[j]\n                base_j = match[ship_j]\n                \n                if segments_intersect(ship_i, base_i, ship_j, base_j):\n                    conflict = True\n                    break\n            if conflict:\n                break\n        if not conflict:\n            print(\"Yes\")\n            return\n    \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into the coordinates of the ships and bases.\n2. **Checking for Perfect Matching**: If R is not equal to B, we immediately output \"No\".\n3. **Generating Permutations**: We use permutations to generate all possible ways to assign ships to bases.\n4. **Intersection Check**: For each permutation, we check if any two line segments between ships and their assigned bases intersect using the cross product method to determine orientation.\n5. **Output Result**: If any valid permutation is found where no segments intersect, we output \"Yes\". If none are found, we output \"No\".",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom itertools import permutations\n\ndef readints():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef ccw(a, b, c):\n    return (b[0]-a[0])*(c[1]-a[1]) - (b[1]-a[1])*(c[0]-a[0])\n\ndef segments_intersect(a, b, c, d):\n    # Check if AB intersects CD\n    ccw1 = ccw(a, b, c)\n    ccw2 = ccw(a, b, d)\n    if ccw1 * ccw2 > 0:\n        return False\n    ccw3 = ccw(c, d, a)\n    ccw4 = ccw(c, d, b)\n    if ccw3 * ccw4 > 0:\n        return False\n    return True\n\ndef main():\n    R_B = sys.stdin.readline().strip()\n    while R_B == '':\n        R_B = sys.stdin.readline().strip()\n    R, B = map(int, R_B.split())\n    \n    if R != B:\n        print(\"No\")\n        return\n    \n    ships = []\n    for _ in range(R):\n        x, y = map(int, sys.stdin.readline().split())\n        ships.append((x, y))\n    \n    bases = []\n    for _ in range(B):\n        x, y = map(int, sys.stdin.readline().split())\n        bases.append((x, y))\n    \n    # Generate all possible matchings\n    for perm in permutations(bases):\n        match = {}\n        for i in range(R):\n            ship = ships[i]\n            base = perm[i]\n            match[ship] = base\n        \n        # Check all pairs of segments\n        conflict = False\n        for i in range(R):\n            for j in range(i+1, R):\n                ship_i = ships[i]\n                base_i = match[ship_i]\n                ship_j = ships[j]\n                base_j = match[ship_j]\n                \n                if segments_intersect(ship_i, base_i, ship_j, base_j):\n                    conflict = True\n                    break\n            if conflict:\n                break\n        if not conflict:\n            print(\"Yes\")\n            return\n    \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 462,
        "completion_token_count": 817,
        "thoughts_token_count": 1025
    }
}