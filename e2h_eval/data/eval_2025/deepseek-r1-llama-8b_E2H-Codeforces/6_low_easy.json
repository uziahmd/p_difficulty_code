{
    "start": 1758103527.711085,
    "end": 1758103657.6806514,
    "start-formatted": "2025-09-17 19:05 KST",
    "end-formatted": "2025-09-17 19:07 KST",
    "gpu": 2,
    "pid": 6,
    "use_openrouter": false,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read it carefully.\n\nThe problem is about Leha choosing two vouchers for his vacation. The conditions are that the sum of their durations is exactly x days, and they don't overlap. Also, he wants to minimize the total cost.\n\nHmm, let me break it down. Each voucher has a start day li, end day ri, and cost costi. The duration is ri - li + 1. We need two vouchers i and j (i != j) such that:\n\n1. Their combined duration equals x.\n2. They don't overlap. So either voucher i ends before voucher j starts, or vice versa.\n3. The total cost is as small as possible.\n\nThe output should be the minimal total cost, or -1 if it's impossible.\n\nSo first, I need to find all pairs of vouchers where the sum of their durations is x. Then, among those pairs, check if they are non-overlapping, and find the one with the smallest total cost.\n\nBut wait, how do I efficiently find these pairs? Because n can be up to 2e5, checking all possible pairs would be O(n^2), which is 4e10 operations—way too slow.\n\nI need a smarter approach.\n\nLet me think about the properties required for two vouchers i and j.\n\nSuppose voucher i has duration d1 = (ri - li + 1), voucher j has duration d2 = (rj - lj + 1). So d1 + d2 = x.\n\nFor them not to overlap, either:\n- r_i < l_j → i comes before j\nOR\n- r_j < l_i → j comes before i\n\nAlso, since d1 + d2 = x, each voucher's duration is fixed once the other is known.\n\nWait, but for a given x, d1 can vary from 1 to x-1, because d2 would then be x - d1.\n\nSo perhaps for each voucher i, I can compute what d2 needs to be (x - d1), and look for vouchers j that have that duration and don't overlap with i.\n\nBut even that might not be efficient, since for each i, there could be many j's to check.\n\nAlternatively, maybe we can pre-process the vouchers by their durations. For each possible duration d, store all vouchers with that duration. Then, for each voucher i, look for vouchers j of duration x - d1, and check if they don't overlap.\n\nBut again, the problem is how to efficiently find j's that don't overlap with i.\n\nHmm, perhaps we can structure the data in a way that allows us to quickly query for vouchers j that have a certain duration and either end before i starts or start after i ends.\n\nWait, let's think about it step by step.\n\nFirst, group all vouchers by their duration. So for each d, we have a list of vouchers with that duration.\n\nThen, for each voucher i, compute d1 = duration of i. Then, d2 must be x - d1. If d2 is zero or negative, skip.\n\nSo, for each i, we can look into the group of vouchers with duration d2.\n\nNow, within that group, we need to find a voucher j that doesn't overlap with i.\n\nHow?\n\nEach voucher j in the d2 group can either end before i starts, or start after i ends.\n\nSo for each i, we can consider two cases:\n\n1. Find a j where j's end < i's start. So j is completely before i.\n   In this case, j's ri < i's li.\n\n2. Find a j where j's start > i's end. So j is completely after i.\n   In this case, j's li > i's ri.\n\nWe need to find the minimal cost voucher j in each case, and add it to i's cost if possible.\n\nBut how do we quickly find the minimal cost j for each condition?\n\nAh, perhaps for each duration d, we can keep track of the minimal cost vouchers in two categories: those that end as early as possible, and those that start as late as possible.\n\nWait, no. Let me think differently.\n\nFor each duration d, we can precompute:\n\n- The minimal cost of any voucher with duration d that ends before a certain point. Or, for a given li, the minimal cost of vouchers j where j's ri <= some value.\n\nSimilarly, for vouchers that start after a certain point.\n\nWait, perhaps for each d, we can pre-sort the vouchers in two ways:\n\na) Sort them by their end time (ri) and keep track of the minimal cost up to each point.\n\nb) Sort them by their start time (li) and keep track of the minimal cost beyond each point.\n\nThis way, when processing a voucher i, we can quickly find the minimal cost j in the d2 group that satisfies either j ends before i starts or j starts",
    "response": "To solve this problem, we need to find two non-overlapping vouchers such that their combined duration equals the given vacation duration `x` and their total cost is minimized. \n\n### Approach\n1. **Group Vouchers by Duration**: First, we group all vouchers by their duration. This helps us quickly access all vouchers of a specific duration when needed.\n2. **Precompute Minimal Costs**: For each duration, we precompute two arrays:\n   - The minimal cost of vouchers ending before a certain point.\n   - The minimal cost of vouchers starting after a certain point.\n3. **Check Each Voucher**: For each voucher, compute the required duration for the second voucher and check if there exists a voucher in the required duration group that does not overlap with the current voucher. Use the precomputed arrays to efficiently find the minimal cost.\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    n, x = map(int, sys.stdin.readline().split())\n    vouchers = []\n    for _ in range(n):\n        l, r, c = map(int, sys.stdin.readline().split())\n        vouchers.append((l, r, c))\n    \n    from collections import defaultdict\n    duration_map = defaultdict(list)\n    for l, r, c in vouchers:\n        d = r - l + 1\n        duration_map[d].append((l, r, c))\n    \n    # Preprocess for each duration: sort by end and keep min cost up to each end\n    processed = {}\n    for d in duration_map:\n        lst = sorted(duration_map[d], key=lambda x: x[1])\n        min_cost_before = []\n        current_min = float('inf')\n        for i in range(len(lst)):\n            if lst[i][1] < lst[i][0]:\n                continue\n            if lst[i][2] < current_min:\n                current_min = lst[i][2]\n            min_cost_before.append((lst[i][1], current_min))\n            current_min = min(current_min, lst[i][2])\n        processed[d] = min_cost_before\n    \n    # Similarly preprocess for start time\n    for d in duration_map:\n        lst = sorted(duration_map[d], key=lambda x: x[0])\n        min_cost_after = []\n        current_min = float('inf')\n        for i in range(len(lst)):\n            if lst[i][0] > lst[i][1]:\n                continue\n            if lst[i][2] < current_min:\n                current_min = lst[i][2]\n            min_cost_after.append((lst[i][0], current_min))\n            current_min = min(current_min, lst[i][2])\n        processed[d] = min_cost_after\n    \n    min_total = float('inf')\n    \n    for idx in range(n):\n        l_i, r_i, c_i = vouchers[idx]\n        d1 = r_i - l_i + 1\n        d2 = x - d1\n        if d2 <= 0:\n            continue\n        \n        if d2 not in processed:\n            continue\n        \n        # Case 1: j ends before i starts\n        min_cost_before = processed[d2]\n        low = 0\n        high = len(min_cost_before) - 1\n        res = -1\n        while low <= high:\n            mid = (low + high) // 2\n            if min_cost_before[mid][0] >= l_i:\n                res = min(res, min_cost_before[mid][1])\n                high = mid - 1\n            else:\n                low = mid + 1\n        \n        # Case 2: j starts after i ends\n        min_cost_after = processed[d2]\n        low = 0\n        high = len(min_cost_after) - 1\n        res2 = -1\n        while low <= high:\n            mid = (low + high) // 2\n            if min_cost_after[mid][0] > r_i:\n                res2 = min(res2, min_cost_after[mid][1])\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        if res != -1:\n            min_total = min(min_total, res + c_i)\n        if res2 != -1:\n            min_total = min(min_total, res2 + c_i)\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Grouping by Duration**: We group vouchers by their duration to quickly access all vouchers of a specific duration.\n2. **Preprocessing**: For each duration, we preprocess two arrays:\n   - One sorted by the end time of vouchers, storing the minimum cost up to each point.\n   - Another sorted by the start time of vouchers, storing the minimum cost beyond each point.\n3. **Efficient Search**: For each voucher, we determine the required duration for the second voucher and use binary search on the preprocessed arrays to find the minimal cost voucher that does not overlap with the current voucher. This ensures our solution is efficient even for large inputs.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    n, x = map(int, sys.stdin.readline().split())\n    vouchers = []\n    for _ in range(n):\n        l, r, c = map(int, sys.stdin.readline().split())\n        vouchers.append((l, r, c))\n    \n    from collections import defaultdict\n    duration_map = defaultdict(list)\n    for l, r, c in vouchers:\n        d = r - l + 1\n        duration_map[d].append((l, r, c))\n    \n    # Preprocess for each duration: sort by end and keep min cost up to each end\n    processed = {}\n    for d in duration_map:\n        lst = sorted(duration_map[d], key=lambda x: x[1])\n        min_cost_before = []\n        current_min = float('inf')\n        for i in range(len(lst)):\n            if lst[i][1] < lst[i][0]:\n                continue\n            if lst[i][2] < current_min:\n                current_min = lst[i][2]\n            min_cost_before.append((lst[i][1], current_min))\n            current_min = min(current_min, lst[i][2])\n        processed[d] = min_cost_before\n    \n    # Similarly preprocess for start time\n    for d in duration_map:\n        lst = sorted(duration_map[d], key=lambda x: x[0])\n        min_cost_after = []\n        current_min = float('inf')\n        for i in range(len(lst)):\n            if lst[i][0] > lst[i][1]:\n                continue\n            if lst[i][2] < current_min:\n                current_min = lst[i][2]\n            min_cost_after.append((lst[i][0], current_min))\n            current_min = min(current_min, lst[i][2])\n        processed[d] = min_cost_after\n    \n    min_total = float('inf')\n    \n    for idx in range(n):\n        l_i, r_i, c_i = vouchers[idx]\n        d1 = r_i - l_i + 1\n        d2 = x - d1\n        if d2 <= 0:\n            continue\n        \n        if d2 not in processed:\n            continue\n        \n        # Case 1: j ends before i starts\n        min_cost_before = processed[d2]\n        low = 0\n        high = len(min_cost_before) - 1\n        res = -1\n        while low <= high:\n            mid = (low + high) // 2\n            if min_cost_before[mid][0] >= l_i:\n                res = min(res, min_cost_before[mid][1])\n                high = mid - 1\n            else:\n                low = mid + 1\n        \n        # Case 2: j starts after i ends\n        min_cost_after = processed[d2]\n        low = 0\n        high = len(min_cost_after) - 1\n        res2 = -1\n        while low <= high:\n            mid = (low + high) // 2\n            if min_cost_after[mid][0] > r_i:\n                res2 = min(res2, min_cost_after[mid][1])\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        if res != -1:\n            min_total = min(min_total, res + c_i)\n        if res2 != -1:\n            min_total = min(min_total, res2 + c_i)\n    \n    if min_total == float('inf'):\n        print(-1)\n    else:\n        print(min_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 686,
        "completion_token_count": 1052,
        "thoughts_token_count": 1025
    }
}