{
    "start": 1758286563.5272856,
    "end": 1758288728.9143763,
    "start-formatted": "2025-09-19 21:56 KST",
    "end-formatted": "2025-09-19 22:32 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read it carefully.\n\nThe problem is about restoring the number of laughy mushrooms on each lawn based on the information from some roads. Each road gives us two numbers: the GCD and LCM of the mushrooms on the two connected lawns. We need to determine if such an arrangement is possible and, if yes, find one possible configuration.\n\nHmm. So, the input gives me n (number of lawns) and m (number of known roads). For each road, I get four numbers: u, v, g, l, meaning that the GCD of the mushrooms at u and v is g, and their LCM is l. Also, no loops or multiple edges between any two lawns.\n\nMy task is to assign a value to each lawn (from 1 to n) such that for every given road, the GCD and LCM conditions are satisfied. If there are multiple possible assignments, any is acceptable.\n\nFirst, I need to model this as a system of equations. Because for each edge, we have:\n\nFor nodes u and v:\ng = gcd(a_u, a_v)\nl = lcm(a_u, a_v)\n\nBut wait, since lcm(a, b) = (a*b)/gcd(a,b), right? So, for each edge, l must equal (a_u * a_v)/g. Or, alternatively, a_u and a_v must satisfy both the GCD and LCM.\n\nSo, for each edge, the pair (a_u, a_v) must be such that gcd(a_u, a_v) = g and lcm(a_u, a_v) = l. Also, note that g must divide both a_u and a_v, and l must be a multiple of both.\n\nWait, but what if g doesn't divide a_u or a_v? Then it can't be the case. So, for each edge, the values assigned to u and v must satisfy both the GCD and LCM constraints.\n\nBut how do I model this? It seems like a graph where each node has variables (the number of mushrooms) and edges impose constraints on those variables.\n\nThis feels like a problem that can be modeled with a graph where each node's value is a variable, and each edge enforces certain constraints on these variables. The constraints are that the pair (a_u, a_v) must satisfy both their GCD and LCM being the given g and l.\n\nI think the way to approach this is to model it as a system of equations and then check for consistency. But how?\n\nAlternatively, perhaps we can represent each variable in terms of its prime factors. But considering that the numbers can be up to 106, which isn't too large, maybe we can represent each a_i as a product of primes with exponents.\n\nWait, another approach: For each edge, the possible pairs (a_u, a_v) that satisfy the GCD and LCM can be determined. Once I know the possible options for a_u and a_v, I can model this as a graph where each edge represents a constraint that a_u and a_v must be one of the possible pairs.\n\nBut with multiple edges, the constraints might conflict. So, the problem reduces to checking if the constraints form a consistent system and, if so, assigning values accordingly.\n\nThis sounds like a problem that can be modeled using a Union-Find (Disjoint Set Union) data structure with some additional constraints. However, the constraints here are not just simple relationships but more complex ones because each edge involves two variables.\n\nWait, but Union-Find is good for handling relationships where the variables are linked in a way that allows them to be merged into a component. However, in this case, each edge has two variables and imposes certain conditions on their relationship.\n\nSo, perhaps we can model this using a graph where each node is a variable, and each edge represents the possible transitions between variables based on the constraints.\n\nWait, maybe I can model this as a bipartite graph where each node is a variable, and edges represent the possible relationships. Alternatively, perhaps each edge can be represented as a constraint that a_u and a_v must satisfy, and these constraints must be compatible across all edges.\n\nAnother thought: For each edge, the possible (a_u, a_v) pairs can be determined as all pairs where gcd(a_u, a_v) = g and lcm(a_u, a_v) = l. Let's find all possible such pairs.\n\nLet's denote a and b as a_u and a_v. Then, we have:\n\ngcd(a, b) = g\nlcm(a, b) = l\n\nWhich implies that a and b must be multiples of g. Let a = g * x, b = g * y. Then, the gcd(x, y) must be 1, because the overall gcd is g. Also, the lcm of a and b is (a*b)/gcd(a,b) = (g x * g y)/g = g x y. So, the lcm is g x y. And according to the edge, this must equal l. So, l = g x y. Therefore, x y = l / g.\n\nSo, x and y are coprime integers whose product is l/g. Also, x and y must be positive integers.\n\nSo, for each edge, the possible (x, y) pairs are all pairs of divisors of (l/g) that multiply to (l/g) and are coprime.\n\nThus, for each edge, the possible (x, y) are the factor pairs of k = l/g, where x and y are coprimes, x <= y (to avoid duplicates?), but order matters because a_u could be x*g and a_v could be y*g, or vice versa.\n\nWait, but the direction matters because the nodes are labeled. So, for each edge, the (a_u, a_v) can be in either order, but each assignment must be consistent with all other edges.\n\nSo, the idea is that for each edge, the possible (a_u, a_v) is a pair (g*x, g*y), where x and y are coprime and x*y = l/g. So, the possible options are all such pairs, and for each edge, the two nodes must be assigned to these values in either order.\n\nBut this can quickly become complex as each node can have multiple possibilities, and the constraints must be satisfied across all edges.\n\nThis seems similar to a system of equations where each equation relates two variables. So, perhaps we can model this as a graph where each node has possible values, and each edge between nodes u and v constrains the possible pairs of values for u and v.\n\nGiven that n can be up to... Wait, what is the constraint on n and m? The problem statement doesn't specify, but looking at the sample input, n can be up to, say, 3 or 4, but perhaps in general, it's up to 10^5 or something. But the code needs to be efficient.\n\nWait, but in the problem statement, the initial map had roads with numbers between 1 and 106, but Pasha has only m roads left. So, perhaps n can be up to 10^5, but m could be up to 1e5 as well.\n\nWait, but the constraints per edge are that the GCD and LCM are between 1 and 106. So, the actual a_i values can't be larger than, say, 1e5 or something, but perhaps it's manageable.\n\nBut for the purposes of solving this, perhaps a BFS approach is feasible. We can model each node's possible values as a set, and for each edge, propagate the constraints.\n\nWait, but even that may be computationally expensive if the graph is large.\n\nAlternatively, perhaps we can model this as a system where each variable can take certain values, and for each edge, the possible pairs (u, v) are constrained. This seems like a problem that can be approached using a constraint satisfaction approach.\n\nBut with n up to 1e5, a backtracking approach is impossible. So, perhaps we can model this as a bipartitioning problem, where each variable is a node, and each edge defines constraints between two variables.\n\nWait, but each edge has multiple possible constraints. For example, an edge can have several (x, y) pairs that (u, v) can take.\n\nThis suggests that each edge introduces a set of possible (u, v) pairs, and the entire graph must have a consistent assignment where all edges' constraints are satisfied.\n\nSo, perhaps the solution is to model this as a graph where each node can have multiple possible values, and for each edge, we check if any combination of the current possible values of u and v satisfies the edge's constraints.\n\nBut how do we manage this efficiently?\n\nAn alternative approach is to represent each variable's possible values as a set, and for each edge, compute the intersection of possible pairs for the current edge and the existing possibilities for the nodes.\n\nWait, let's think in terms of variables and possible values.\n\nEach variable a_i can have a set of possible values. Initially, each a_i can be any positive integer. For each edge, we process it and update the possible values for the two connected nodes.\n\nBut processing each edge would require that for each possible value of u and v, the pair must satisfy the GCD and LCM constraints.\n\nThis approach could work, but the problem is that for each edge, the possible values could grow exponentially, making it impractical for large n and m.\n\nSo, perhaps a better approach is needed.\n\nWait, but what if we model each variable as a node, and for each edge, create constraints between the variables. But since each edge imposes that the two variables must be a certain way, perhaps we can model this with some kind of directed graph where each edge represents a transformation between possible values.\n\nAlternatively, perhaps for each variable, we can represent the possible values as a set, and for each edge, we compute the allowed transitions between the sets of the two variables.\n\nWait, but how? Let's think about each edge: for each possible value of u, what values of v are allowed based on the edge's constraints.\n\nSo, for a given edge (u, v, g, l), and for a current possible value of u, say a, we can compute the possible values of v.\n\nSince a and v must satisfy:\n\ngcd(a, v) = g\n\nand\n\nlcm(a, v) = l.\n\nWait, but earlier analysis shows that v must be g * y, where y is a divisor of (l/g), and y is coprime with x, where x is a/g. So, for each a, the possible v's are g * y, where y is a divisor of (l/g) that is coprime with (a/g).\n\nBut a can vary, so for each a, we can compute the possible v's.\n\nBut this seems complicated because for each edge and each possible a_u, we have to generate possible a_v's.\n\nBut given that the a_i's can be up to 1e5 or higher, this approach may not be feasible for large n and m.\n\nHmm, perhaps another angle. Since for each edge, a_u and a_v must be multiples of g, and their product divided by g must be equal to l. So, perhaps a_u can be written as g * x, a_v as g * y, where x and y are coprimes, and x * y = (l/g). So, for each edge, the possible (x, y) pairs are the factor pairs of (l/g) where x and y are coprimes.\n\nSo, for each edge, the possible (x, y) pairs are known. Then, for each variable, we can track the possible x and y values, but I'm not sure.\n\nAlternatively, for each variable, perhaps we can represent it as a value that is a multiple of some base, and then the constraints can be expressed in terms of these bases.\n\nWait, perhaps each variable can be expressed as a product of primes, and for each edge, the primes must satisfy certain conditions based on the GCD and LCM.\n\nBut considering that the a_i's can be up to 1e5, and m can be up to 1e5, perhaps this is manageable.\n\nWait, but for each variable, the number of possible prime factors is limited, so perhaps this is feasible.\n\nAlternatively, perhaps the variables can be represented in terms of their prime factors, and the constraints can be checked on the exponents.\n\nBut this seems complicated.\n\nAnother idea: For each edge, the product of the two variables divided by their GCD equals their LCM. So, (a_u * a_v) / g = l.\n\nWhich means that a_u * a_v = g * l.\n\nSo, for each edge, a_u * a_v must equal g * l.\n\nAh! That's a crucial point.\n\nSo, for each edge, a_u * a_v = g * l.\n\nThat's a big simplification.\n\nBecause, for each edge, the product of the two variables is fixed as g * l. So, regardless of the other constraints, this product must hold.\n\nSo, now the problem reduces to assigning values to each variable such that for every edge (u, v), a_u * a_v = g * l.\n\nAdditionally, for each edge, the GCD of a_u and a_v must be exactly g, and their LCM must be exactly l.\n\nWait, but wait: If a_u * a_v = g * l, and the GCD is g, then the LCM is (a_u * a_v) / g = l. So, the LCM condition is automatically satisfied if the product is correct and the GCD is correct.\n\nSo, the key is that for each edge, a_u * a_v = g * l, and gcd(a_u, a_v) = g.\n\nSo, the problem is to assign each a_i such that for every edge, a_u * a_v = g * l, and the GCD of a_u and a_v is exactly g.\n\nSo, the first condition is a_u * a_v = g * l.\n\nNow, the second condition is that the GCD of a_u and a_v is g.\n\nBut since a_u and a_v are multiples of g, let's factor that out.\n\nLet a_u = g * x, a_v = g * y.\n\nThen, the product is g^2 * x * y = g * l => x * y = l / g.\n\nAnd the GCD of a_u and a_v is g * gcd(x, y) = g.\n\nSo, gcd(x, y) must be 1.\n\nSo, for each edge, the variables x and y must be coprimes, and their product is (l/g).\n\nSo, for each edge, x and y are coprimes, x * y = (l/g).\n\nTherefore, the problem reduces to finding x and y for each edge such that x and y are coprimes and x*y = (l/g), and then assigning a_u = g*x and a_v = g*y, or vice versa.\n\nBut the issue is that these assignments must be consistent across all edges.\n\nSo, the problem is now to assign each variable a_i a value such that for every edge (u, v, g, l), a_u * a_v = g * l, and the a_i's must be such that when you factor out g from each edge's a_u and a_v, the product of the remaining factors is l/g, and they are coprimes.\n\nSo, how can we model this? It seems like a system of multiplicative constraints.\n\nHmm. Another approach: Each variable a_i can be represented as a product of primes, and for each edge, the product of a_u and a_v is fixed.\n\nBut this might not directly help, as the problem is multiplicative and involves products.\n\nWait, perhaps we can model this as a graph where each node's value is a variable, and each edge represents the product of the two variables being equal to a certain value.\n\nBut for more than two variables, this becomes tricky. For example, if a chain of edges connects variables u, v, w, etc., then the product of u and v is a certain value, the product of v and w is another, which would imply that u * w is equal to the product of those two values divided by v squared. Hmm, but this can lead to inconsistencies.\n\nWait, but in reality, each edge's product is independent. So, perhaps it's possible to model this as a system of equations where each equation is a_u * a_v = K, for some K.\n\nBut with multiple equations, this could form a system that may or may not be solvable.\n\nBut with n variables and m equations, it's a nonlinear system, which is difficult to solve in general.\n\nHowever, perhaps we can find a way to represent this in a way that allows us to find a solution.\n\nAnother thought: Since each edge requires a_u * a_v = K, perhaps we can represent each a_i in terms of its logarithm. Then, the product becomes a sum, which can be linear. But I'm not sure if that helps.\n\nWait, but for each edge (u, v, g, l), a_u * a_v = g*l.\n\nSo, each edge adds a multiplicative equation.\n\nBut this is a nonlinear system. Solving this is challenging.\n\nAlternative Idea: Assign a variable to each node and express each equation as a ratio. For example, for each edge (u, v), a_u / a_v = (g*l) / a_v². But that doesn't seem helpful.\n\nHmm. Maybe the problem can be reduced to checking if all edges are consistent, i.e., their product constraints form a consistent multiplicative graph.\n\nWait, perhaps we can represent each variable as a product of primes, and for each edge, the product of the two variables is fixed. So, the variables are linked in a way that their product is fixed.\n\nBut this seems too vague.\n\nAlternative Approach: Let's think in terms of variables and their possible assignments.\n\nEach variable a_i can be any positive integer, but for each edge, a_u * a_v must equal g*l.\n\nSo, for a connected component of variables, the product of all variables in the component must be the product of all the edge products divided by some factors.\n\nWait, no. For a connected component, the product of all variables in the component depends on the edges. For example, if we have edges u-v and v-w, then u*v = k1 and v*w =k2. So, u*w = (k1 * k2)/(v²). So, the product of u, v, w is (k1 * k2) / v².\n\nBut this is getting complicated.\n\nPerhaps the way to proceed is as follows:\n\nWe can model each variable as a value, and for each edge, enforce that a_u * a_v = g*l. Additionally, we can model the GCD conditions.\n\nWait, but the GCD condition is automatically handled once a_u and a_v are multiples of g, and their product is g*l.\n\nWait, because a_u = g * x, a_v = g * y, and x * y = l/g. So, the GCD of a_u and a_v is g * gcd(x, y). To have this equal to g, we need that x and y are coprimes.\n\nSo, for each edge, the x and y must be coprimes and their product must be l/g.\n\nSo, the problem now is to assign x and y to each edge, ensuring that:\n\nx * y = (l/g)\n\nand\n\ngcd(x, y) = 1\n\nMoreover, the variables must be assigned consistently across all edges.\n\nSo, perhaps we can model this as a graph where each edge enforces that the x and y are coprimes and their product is (l/g).\n\nBut how do we model this for multiple edges and variables?\n\nWait, perhaps we can model each variable as being a product of primes, and the edges impose that certain variables must be related in specific ways.\n\nAlternatively, perhaps we can model this using a Union-Find data structure, but with some additional information attached to each node to capture the relationships.\n\nWait, but the Union-Find structure is typically used for managing equivalence classes, not for handling multiplicative constraints. So, perhaps a different approach is needed.\n\nAnother Idea: Since each edge requires that a_u * a_v = g*l, perhaps we can represent each a_i as a ratio relative to a base variable. For example, a_i can be expressed as a product of ratios defined along the edges.\n\nBut again, this seems tricky.\n\nWait, perhaps for each variable, we can represent it as a fraction, but since a_i are positive integers, that might not help directly.\n\nAlternative Plan: Let's consider that each variable can be represented as a product of primes. For each edge, the product of the two variables is fixed. So, the variables are linked multiplicatively.\n\nBut this is similar to constraints in a system where each variable is a node, and each edge represents a multiplicative equation between two variables.\n\nSo, the problem reduces to solving a system of multiplicative equations.\n\nThis is a system where each equation is of the form a_u * a_v = K_uv, where K_uv is known.\n\nTo find a solution, perhaps we can model each variable as a product of primes, and for each edge, the equation a_u * a_v = K_uv must be satisfied.\n\nBut how to model this in code?\n\nAn alternative approach is to model each variable as a rational number, but since a_i must be integers, this might not be straightforward.\n\nWait, but perhaps each variable can be represented as a product of primes raised to certain exponents. Then, the multiplicative equations can be translated into additive equations on the exponents.\n\nYes! That's a promising direction.\n\nBecause if we represent each a_i as a product of primes, then the exponents of the primes in a_i can be treated as additive variables. Then, each multiplicative equation becomes a system of additive equations on the exponents.\n\nFor example, suppose a_i = p1^e1 * p2^e2 * ... * pn^en.\n\nSimilarly, a_j = p1^f1 * p2^f2 * ... * pn^fn.\n\nThen, a_i * a_j = p1^(e1+f1) * p2^(e2 + f2) * ... * pn^(en + fn).\n\nSo, each multiplicative equation can be broken down into additive equations for each prime.\n\nThis way, each multiplicative equation can be represented as a set of additive constraints on the exponents of the primes.\n\nThis approach could allow us to model the problem using linear algebra, specifically over the exponents of the primes.\n\nBut the problem is that the number of primes involved can be large, making this approach computationally intensive.\n\nWait, but in practice, the maximum a_i is 1e5, so the primes involved are up to 1e5. However, factoring each a_i into primes is manageable.\n\nBut even then, the number of primes could be high, leading to a large number of variables (exponents) per node.\n\nSo, perhaps this approach is feasible for small n and m but not for larger cases.\n\nHmm.\n\nAlternative Idea: Perhaps we can model each variable as a single integer, and for each edge, we can compute the possible values of the variables and see if they can be assigned in a way that satisfies all edges.\n\nBut with n and m up to 1e5, this approach might not be feasible due to time constraints.\n\nWait, but perhaps the number of possible values per variable is manageable. For example, each variable can have a limited number of possible values based on the edges connected to it.\n\nSo, for each variable, we can maintain a set of possible values. For each edge connected to it, the possible values must satisfy the product constraints with their neighbors.\n\nBut even this approach can become computationally expensive if the number of possible values per variable is high.\n\nWait, but let's think about the sample input.\n\nSample Input 1:\n\n1 0\n\nNo edges, so any value is possible for the single lawn. So, output is 'YES\\n1'.\n\nSample Output 1: YES\\n1.\n\nSample Input 2:\n\n2 1\n\nEdge between 1 and 2: GCD is 1, LCM is 3.\n\nSo, a_1 * a_2 = 1*3=3.\n\nAlso, GCD(a_1, a_2)=1.\n\nSo, possible pairs (a1, a2) are (1,3), (3,1).\n\nSo, possible assignments: [1,3] or [3,1].\n\nSo, the output is YES\\n1 3.\n\nSample Input 3:\n\n3 3\n\nEdges:\n\n3 2 → GCD 2, LCM 1.\n\nWait, but wait: The GCD is 2, so a3 and a2 must be multiples of 2.\n\nWait, but wait, the edge is between 3 and 2.\n\nSo, a3 * a2 = 2*1 = 2.\n\nAnd GCD(a3, a2) = 2.\n\nSo, a3 and a2 must be multiples of 2, and their product is 2.\n\nSo, possible (a2, a3) pairs are (1,2) and (2,1), but wait, 1 and 2 are not multiples of 2. So, that's impossible.\n\nWait, no: GCD(a3, a2) must be 2, so a3 and a2 must be multiples of 2. So, a3 = 2 * x, a2 = 2 * y, with x and y coprimes and x*y= 1/2? No, wait, the product a3*a2 = 2*1=2.\n\nSo, a3 * a2 = 2.\n\nSo, a3 = 2x, a2=2y. So, 4xy = 2 → xy = 0.5, which is not possible since x and y must be integers.\n\nSo, this edge is invalid, hence the output is NO.\n\nWait, but in the sample input, the third test case has the following edges:\n\n3 2: GCD 2, LCM 1.\n\nWait, but 2 is the GCD, which implies that a3 and a2 must be multiples of 2. Their product is 2*1=2. So, a3 * a2 = 2.\n\nBut if a3 and a2 are multiples of 2, then their product is at least 4, which is larger than 2. So, this is impossible. Hence, the answer is NO.\n\nBut according to the sample input, it's the third test case, which outputs 'NO'.\n\nSo, the approach for this problem is to model each variable's possible values, and for each edge, check if the variables can be assigned values that satisfy the product and GCD constraints.\n\nBut how to implement this.\n\nPerhaps the way to proceed is to model each variable's possible values as a set, and for each edge, compute the possible pairs of variables that satisfy the edge's constraints, and then intersect the current possible sets.\n\nSo, for each variable, we maintain a set of possible values. For each edge, we look at the current possible values of u and v, and for each pair (x, y) where x is in u's possible values, y is in v's possible values, check if x*y equals g*l and the GCD of x and y is g.\n\nWait, but that's not correct because a_u and a_v are variables, not x and y. Wait, no: a_u is x * g, a_v is y * g.\n\nWait, no: Wait, for each edge, a_u = g * x, a_v = g * y, where x and y are coprimes and x*y = (l/g).\n\nSo, for each edge, the possible (x, y) pairs are determined by the edge's parameters.\n\nSo, for each edge, we can precompute all possible (x, y) pairs that satisfy x * y = l/g and gcd(x, y) = 1.\n\nThen, for each variable u and v, the possible a_u and a_v values are determined by the union of all possible (x, y) pairs across all edges connected to u and v.\n\nWait, but this seems too vague.\n\nAlternative Plan:\n\nWe can model the problem as a graph where each node has a set of possible values. For each edge, we process the possible (x, y) pairs and update the possible values of the connected nodes.\n\nWe can represent each node's possible values as a set, initially containing all positive integers. For each edge, we process it and update the possible values of the two nodes.\n\nProcessing an edge (u, v, g, l):\n\nCompute k = l / g. So, x * y must equal k, and gcd(x, y) = 1.\n\nFind all possible pairs (x, y) that satisfy this.\n\nFor each such pair, the possible a_u is g * x, and a_v is g * y.\n\nBut wait, the edge could be processed in either direction, so for each (x, y), u could have a_u = g x, v could have a_v = g y.\n\nBut also, for each (y, x), u could have a_u = g y, v could have a_v = g x.\n\nSo, for each possible (x, y) pair, we add g x to u's possible values and g y to v's possible values. Additionally, we need to consider the reverse: adding g y to u's possible values and g x to v's possible values.\n\nWait, but that's redundant because (x, y) and (y, x) are separate pairs unless x=y.\n\nSo, for each (x, y) in the possible pairs, we add (g x, g y) and (g y, g x) as possibilities.\n\nWait, no, because for each edge, the possible (a_u, a_v) can be (g x, g y) or (g y, g x), depending on which node is u and which is v.\n\nWait, perhaps for each edge, the possible (a_u, a_v) is either (g x, g y) or (g y, g x), but in the context of the edge being between u and v.\n\nSo, for each possible (x, y) pair, the edge (u, v) can have a_u = g x and a_v = g y, or a_u = g y and a_v = g x.\n\nBut this depends on the direction of the edge.\n\nWait, perhaps for each edge, the possible (a_u, a_v) is any of the possible (g x, g y) pairs, where x and y are as described.\n\nSo, for each edge, the possible (a_u, a_v) is (g x, g y) for each (x, y) in the possible pairs.\n\nSo, for each edge, we can precompute all possible (a_u, a_v) pairs and then, for each node, update their possible values based on the edges.\n\nBut this approach could quickly lead to an explosion of possible values, especially for edges with many possible (x, y) pairs.\n\nHmm. So, perhaps this approach is not feasible for large m.\n\nAlternative Idea: Since each a_i is determined by the product constraints of its edges, perhaps each connected component can be processed separately.\n\nIn a connected component, the variables are linked through their edges, so the product constraints form a system that can be solved.\n\nBut how?\n\nPerhaps, in a connected component, the product of all variables is determined by the product of all edge constants.\n\nWait, for a connected component, each edge contributes a factor of g * l. So, the product of all a_i in the component is the product of (g * l) for each edge, raised to some power based on the structure of the component.\n\nWait, perhaps not. Because each variable is involved in multiple edges, so the product of all variables is the product of (g * l) for each edge, divided by the product of a_i squared for each variable, as each variable appears in two edges.\n\nWait, for example, in a chain u - v - w, the product of u * v * w is (g_uv * l_uv) * (g_vw * l_vw) ) / (v^2), assuming u is connected to v and v is connected to w.\n\nSo, u * v * w = (g_uv * l_uv) * (g_vw * l_vw) ) / (v^2).\n\nWhich implies that u * w = (g_uv * l_uv * g_vw * l_vw) ) / (v^2).\n\nBut this is getting complicated.\n\nAnother Idea: Let's assume that for each variable, a_i can be represented as a product of some base variable's value. For example, choose a root variable and express all other variables in terms of it.\n\nBut I'm not sure how this would work with multiplicative constraints.\n\nAlternatively, perhaps we can assign a value to one variable and express the others in terms of it. But this is only possible if the component is a tree, which it may not be.\n\nWait, but if the component is a tree, then assigning a value to the root allows us to compute the values of all other variables.\n\nBut if the component has cycles, then the product constraints must be consistent around the cycles.\n\nSo, for each cycle in the component, the product of the edges around the cycle must be consistent.\n\nSo, perhaps the steps are:\n\n1. For each connected component, perform a BFS or DFS to explore all nodes.\n\n2. For each node, track the possible values based on the edges.\n\n3. When a cycle is detected, check if the product constraints around the cycle are consistent.\n\n4. If any inconsistency is found, the problem is unsolvable.\n\n5. Otherwise, assign values based on the constraints.\n\nBut implementing this requires a way to track the possible values for each variable and ensure that all constraints are satisfied.\n\nBut again, this seems computationally expensive, especially for large graphs.\n\nAlternative Idea: Instead of tracking all possible values, perhaps we can find a unique solution by fixing one variable and computing the rest.\n\nBut this depends on the structure of the graph.\n\nWait, perhaps for each connected component, if it's a tree, then we can assign a value to one variable and compute the rest. But if there are cycles, the product must be consistent.\n\nBut how to handle this in code.\n\nHmm.\n\nAn alternative approach is to model each variable's value as a product of primes, and then for each edge, the product must match. This way, the problem becomes a system of equations on the exponents of the primes.\n\nBut the problem is that each variable can have multiple primes, and the system can be under-constrained or over-constrained.\n\nBut perhaps this is manageable.\n\nLet me try to outline this approach step by step.\n\nStep 1: For each variable, represent its value as a product of primes, where each prime's exponent is a non-negative integer.\n\nStep 2: For each edge, decompose the product constraint into additive equations on the exponents of the primes.\n\nFor example, if a_u = p1^e1 * p2^e2, and a_v = p1^f1 * p2^f2, then a_u * a_v = p1^(e1 + f1) * p2^(e2 + f2) = g * l.\n\nSo, for each prime pi, e_i + f_i must equal the exponent of pi in (g * l).\n\nBut wait, g and l are given as part of the edge, so for each edge, we can compute the exponents for each prime in g and l, sum them, and then for each prime, the sum of exponents in a_u and a_v must equal the sum in g*l.\n\nAdditionally, the GCD condition must be met: for each prime, the minimum of the exponents in a_u and a_v must equal the exponent in g.\n\nWait, because the GCD of a_u and a_v is g, which is p1^k1 * p2^k2 * ..., so for each prime pi, the minimum of the exponents in a_u and a_v must be equal to ki.\n\nSo, for each edge, for each prime pi:\n\nmin(ei, fi) = ki, where ki is the exponent of pi in g.\n\nei + fi = (exponent of pi in g) + (exponent of pi in l).\n\nWait, no. Wait, for each prime pi:\n\nThe exponent in a_u * a_v is equal to the exponent in g * l.\n\nWhich is, exponent_pi(g) + exponent_pi(l).\n\nSo, for each edge, for each prime pi:\n\ne_i (u) + e_i (v) = exponent_pi(g) + exponent_pi(l).\n\nAdditionally, min(e_i (u), e_i (v)) = exponent_pi(g).\n\nSo, for each prime pi in the factorization of g or l, we can write these equations.\n\nIf any prime is present in g or l but not in a_u or a_v, then their exponents must be zero in a_u and a_v.\n\nBut this complicates things further.\n\nSo, the approach is to model the exponents of each prime across all variables, ensuring that for each edge, the sum and min conditions are satisfied.\n\nBut how to implement this.\n\nThis seems like a system of linear equations, but for each prime.\n\nBut each variable has multiple primes, and each edge adds equations for each prime.\n\nThis could be manageable.\n\nBut the problem is that the number of primes can be very large, making this approach computationally expensive.\n\nBut perhaps for each edge, we can factorize g and l into their prime factors, and for each prime in either g or l, add the necessary constraints.\n\nSo, the plan is:\n\n- For each connected component, perform a BFS or DFS.\n\n- For each variable, represent its exponents for each relevant prime as variables.\n\n- For each edge, for each prime in g or l, add the sum and min constraints.\n\n- Solve the system of equations for each connected component.\n\nIf any component has no solution, output NO.\n\nOtherwise, assign the exponents and reconstruct the a_i's.\n\nThis seems feasible, but the implementation could be quite involved.\n\nBut given the time constraints, perhaps this is the way to go.\n\nSo, the steps are:\n\n1. Read the input.\n\n2. For each edge, compute the necessary constraints.\n\n3. For each connected component, build the system of equations based on the edges.\n\n4. Check for consistency in the system.\n\n5. If consistent, assign the exponents and compute the a_i's.\n\n6.",
    "response": "To solve this problem, we need to determine if it is possible to restore the number of laughy mushrooms on each lawn based on the given roads and their GCD and LCM values. If possible, we should provide any valid configuration.\n\n### Approach\nThe problem can be approached by modeling each lawn's mushroom count as a product of prime factors and using constraints derived from the given edges. Here are the key steps:\n\n1. **Graph Representation**: Treat each lawn as a node and each road as an edge with associated GCD and LCM values.\n2. **Prime Factorization**: For each edge, decompose the GCD and LCM into their prime factors.\n3. **System of Equations**: For each edge, derive equations based on the prime factors to ensure the product constraints and GCD conditions are satisfied.\n4. **Connected Components**: Process each connected component of the graph separately. For each component, use BFS or DFS to explore nodes and their constraints.\n5. **Check Consistency**: Ensure that all constraints within a connected component are consistent. If any inconsistency is found, output \"NO\".\n6. **Assign Values**: If consistent, assign values to each node based on the derived constraints and print the result.\n\n### Solution Code\n```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef factorize(n):\n    factors = defaultdict(int)\n    while n % 2 == 0:\n        factors[2] += 1\n        n //= 2\n    i = 3\n    while i * i <= n:\n        while n % i == 0:\n            factors[i] += 1\n            n //= i\n        i += 2\n    if n > 1:\n        factors[n] += 1\n    return factors\n\ndef get_primes(g, l):\n    primes_g = factorize(g)\n    primes_l = factorize(l)\n    all_primes = set(primes_g.keys()).union(set(primes_l.keys()))\n    return all_primes\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr +=1\n    m = int(input[ptr])\n    ptr +=1\n\n    edges = []\n    for _ in range(m):\n        u = int(input[ptr])\n        v = int(input[ptr+1])\n        g = int(input[ptr+2])\n        l = int(input[ptr+3])\n        ptr +=4\n        edges.append( (u-1, v-1, g, l) )  # 0-based\n\n    possible_values = [set() for _ in range(n)]\n\n    for u, v, g, l in edges:\n        k = l // g\n        if k != int(k):\n            continue  # invalid since l must be divisible by g\n        k = int(k)\n        if k ==0:\n            continue  # but l >=g >=1 implies k >=1\n        primes = get_primes(g, l)\n        pairs = []\n        temp = []\n        for x in primes:\n            temp.append(x)\n        from itertools import product\n        for divisors in product(temp, repeat=2):\n            x, y = divisors\n            if x * y != k:\n                continue\n            if gcd(x, y) !=1:\n                continue\n            pairs.append( (x, y) )\n        for (x, y) in pairs:\n            a_u = g * x\n            a_v = g * y\n            possible_values[u].add(a_u)\n            possible_values[v].add(a_v)\n            a_v_swap = g * y\n            a_u_swap = g * x\n            possible_values[u].add(a_u_swap)\n            possible_values[v].add(a_v_swap)\n\n    for i in range(n):\n        possible_values[i].discard(0)\n        if not possible_values[i]:\n            print(\"NO\")\n            return\n\n    visited = [False]*n\n    for i in range(n):\n        if not visited[i]:\n            q = deque()\n            q.append(i)\n            visited[i] = True\n            component = []\n            while q:\n                u = q.popleft()\n                component.append(u)\n                for edge in edges:\n                    if edge[0] == u:\n                        v = edge[1]\n                        if not visited[v]:\n                            visited[v] = True\n                            q.append(v)\n                    if edge[1] == u:\n                        v = edge[0]\n                        if not visited[v]:\n                            visited[v] = True\n                            q.append(v)\n            for u in component:\n                possible = possible_values[u]\n                if not possible:\n                    print(\"NO\")\n                    return\n\n            primes = set()\n            for edge in edges:\n                if edge[0] in component or edge[1] in component:\n                    u, v, g, l = edge\n                    if g !=0 or l !=0:\n                        primes.update(get_primes(g, l))\n            prime_list = sorted(primes)\n            prime_index = {p:i for i,p in enumerate(prime_list)}\n            num_primes = len(prime_list)\n            exponent = [defaultdict(int) for _ in range(num_primes)]\n\n            for edge in edges:\n                u, v, g, l = edge\n                if u not in component or v not in component:\n                    continue\n                if g ==0 or l ==0:\n                    continue\n                if u not in component or v not in component:\n                    continue\n                factors_g = factorize(g)\n                factors_l = factorize(l)\n                for p in prime_list:\n                    ag = factors_g.get(p, 0)\n                    al = factors_l.get(p, 0)\n                    sum_ag_al = ag + al\n                    total = sum_ag_al\n                    exponents_u = exponent[prime_index[p]][u]\n                    exponents_v = exponent[prime_index[p]][v]\n                    if exponents_u + exponents_v != total:\n                        print(\"NO\")\n                        return\n                    if min(exponents_u, exponents_v) != ag:\n                        print(\"NO\")\n                        return\n\n            for u in component:\n                for p in prime_list:\n                    exponents_u = exponent[prime_index[p]][u]\n                    possible_a = 1\n                    for p in prime_list:\n                        possible_a *= p**exponents_u[p]\n                    if possible_a not in possible_values[u]:\n                        print(\"NO\")\n                        return\n\n            assignment = {}\n            for u in component:\n                a = 0\n                for p in prime_list:\n                    a *= p**exponent[prime_index[p]][u]\n                assignment[u] = a\n\n            for u in component:\n                for edge in edges:\n                    if edge[0] == u:\n                        v = edge[1]\n                        g = edge[2]\n                        l = edge[3]\n                        if assignment[u] * assignment[v] != g * l:\n                            print(\"NO\")\n                            return\n                        if gcd(assignment[u], assignment[v]) != g:\n                            print(\"NO\")\n                            return\n\n    a = [0]*n\n    for i in range(n):\n        a[i] = 1\n        for edge in edges:\n            u, v, g, l = edge\n            if u == i:\n                a[v] = l // (g * (a[u] // g)) if (a[u] % g) ==0 else None\n            if v == i:\n                a[u] = l // (g * (a[v] // g)) if (a[v] % g) ==0 else None\n    for i in range(n):\n        if a[i] is None:\n            print(\"NO\")\n            return\n    print(\"YES\")\n    print(' '.join(map(str, a)))\n\ngcd = lambda x, y: x if y ==0 else y if x ==0 else (x if x < y else y)\nsolve()\n```\n\n### Explanation\nThe solution involves factorizing the GCD and LCM values into their prime factors and deriving constraints for each edge. Using BFS, each connected component is explored to ensure all constraints are met. If any inconsistency is found during this process, the solution outputs \"NO\". If consistent, the values for each lawn are computed and printed. This approach ensures that all constraints are satisfied efficiently.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import defaultdict, deque\n\ndef factorize(n):\n    factors = defaultdict(int)\n    while n % 2 == 0:\n        factors[2] += 1\n        n //= 2\n    i = 3\n    while i * i <= n:\n        while n % i == 0:\n            factors[i] += 1\n            n //= i\n        i += 2\n    if n > 1:\n        factors[n] += 1\n    return factors\n\ndef get_primes(g, l):\n    primes_g = factorize(g)\n    primes_l = factorize(l)\n    all_primes = set(primes_g.keys()).union(set(primes_l.keys()))\n    return all_primes\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr +=1\n    m = int(input[ptr])\n    ptr +=1\n\n    edges = []\n    for _ in range(m):\n        u = int(input[ptr])\n        v = int(input[ptr+1])\n        g = int(input[ptr+2])\n        l = int(input[ptr+3])\n        ptr +=4\n        edges.append( (u-1, v-1, g, l) )  # 0-based\n\n    possible_values = [set() for _ in range(n)]\n\n    for u, v, g, l in edges:\n        k = l // g\n        if k != int(k):\n            continue  # invalid since l must be divisible by g\n        k = int(k)\n        if k ==0:\n            continue  # but l >=g >=1 implies k >=1\n        primes = get_primes(g, l)\n        pairs = []\n        temp = []\n        for x in primes:\n            temp.append(x)\n        from itertools import product\n        for divisors in product(temp, repeat=2):\n            x, y = divisors\n            if x * y != k:\n                continue\n            if gcd(x, y) !=1:\n                continue\n            pairs.append( (x, y) )\n        for (x, y) in pairs:\n            a_u = g * x\n            a_v = g * y\n            possible_values[u].add(a_u)\n            possible_values[v].add(a_v)\n            a_v_swap = g * y\n            a_u_swap = g * x\n            possible_values[u].add(a_u_swap)\n            possible_values[v].add(a_v_swap)\n\n    for i in range(n):\n        possible_values[i].discard(0)\n        if not possible_values[i]:\n            print(\"NO\")\n            return\n\n    visited = [False]*n\n    for i in range(n):\n        if not visited[i]:\n            q = deque()\n            q.append(i)\n            visited[i] = True\n            component = []\n            while q:\n                u = q.popleft()\n                component.append(u)\n                for edge in edges:\n                    if edge[0] == u:\n                        v = edge[1]\n                        if not visited[v]:\n                            visited[v] = True\n                            q.append(v)\n                    if edge[1] == u:\n                        v = edge[0]\n                        if not visited[v]:\n                            visited[v] = True\n                            q.append(v)\n            for u in component:\n                possible = possible_values[u]\n                if not possible:\n                    print(\"NO\")\n                    return\n\n            primes = set()\n            for edge in edges:\n                if edge[0] in component or edge[1] in component:\n                    u, v, g, l = edge\n                    if g !=0 or l !=0:\n                        primes.update(get_primes(g, l))\n            prime_list = sorted(primes)\n            prime_index = {p:i for i,p in enumerate(prime_list)}\n            num_primes = len(prime_list)\n            exponent = [defaultdict(int) for _ in range(num_primes)]\n\n            for edge in edges:\n                u, v, g, l = edge\n                if u not in component or v not in component:\n                    continue\n                if g ==0 or l ==0:\n                    continue\n                if u not in component or v not in component:\n                    continue\n                factors_g = factorize(g)\n                factors_l = factorize(l)\n                for p in prime_list:\n                    ag = factors_g.get(p, 0)\n                    al = factors_l.get(p, 0)\n                    sum_ag_al = ag + al\n                    total = sum_ag_al\n                    exponents_u = exponent[prime_index[p]][u]\n                    exponents_v = exponent[prime_index[p]][v]\n                    if exponents_u + exponents_v != total:\n                        print(\"NO\")\n                        return\n                    if min(exponents_u, exponents_v) != ag:\n                        print(\"NO\")\n                        return\n\n            for u in component:\n                for p in prime_list:\n                    exponents_u = exponent[prime_index[p]][u]\n                    possible_a = 1\n                    for p in prime_list:\n                        possible_a *= p**exponents_u[p]\n                    if possible_a not in possible_values[u]:\n                        print(\"NO\")\n                        return\n\n            assignment = {}\n            for u in component:\n                a = 0\n                for p in prime_list:\n                    a *= p**exponent[prime_index[p]][u]\n                assignment[u] = a\n\n            for u in component:\n                for edge in edges:\n                    if edge[0] == u:\n                        v = edge[1]\n                        g = edge[2]\n                        l = edge[3]\n                        if assignment[u] * assignment[v] != g * l:\n                            print(\"NO\")\n                            return\n                        if gcd(assignment[u], assignment[v]) != g:\n                            print(\"NO\")\n                            return\n\n    a = [0]*n\n    for i in range(n):\n        a[i] = 1\n        for edge in edges:\n            u, v, g, l = edge\n            if u == i:\n                a[v] = l // (g * (a[u] // g)) if (a[u] % g) ==0 else None\n            if v == i:\n                a[u] = l // (g * (a[v] // g)) if (a[v] % g) ==0 else None\n    for i in range(n):\n        if a[i] is None:\n            print(\"NO\")\n            return\n    print(\"YES\")\n    print(' '.join(map(str, a)))\n\ngcd = lambda x, y: x if y ==0 else y if x ==0 else (x if x < y else y)\nsolve()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 536,
        "completion_token_count": 1727,
        "thoughts_token_count": 8193
    }
}