{
    "start": 1758103901.3663,
    "end": 1758104043.6576498,
    "start-formatted": "2025-09-17 19:11 KST",
    "end-formatted": "2025-09-17 19:14 KST",
    "gpu": 2,
    "pid": 9,
    "use_openrouter": false,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Selling Souvenirs\n\nAfter several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.This morning, as usual, Petya will come to the market. Petya has n different souvenirs to sell; ith souvenir is characterised by its weight wi and cost ci. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than m, and total cost is maximum possible.Help Petya to determine maximum possible total cost.\n\n## Input\nThe first line contains two integers n and m (1 ≤ n ≤ 100000, 1 ≤ m ≤ 300000) — the number of Petya's souvenirs and total weight that he can carry to the market.Then n lines follow. ith line contains two integers wi and ci (1 ≤ wi ≤ 3, 1 ≤ ci ≤ 109) — the weight and the cost of ith souvenir.\n\n## Output\nPrint one number — maximum possible total cost of souvenirs that Petya can carry to the market.\n\n## Example\n### Input\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\n### Output\n['0', '3', '10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read it carefully.\n\nThe problem is about Petya selling souvenirs at the market. He has n different souvenirs, each with a weight wi and cost ci. He wants to choose a subset such that the total weight doesn't exceed m, and the total cost is as large as possible.\n\nHmm, the input is n and m, followed by n lines of wi and ci. The output is the maximum possible total cost.\n\nSo, thinking about how to model this. It's a classic knapsack problem, but with some constraints.\n\nWait, what's the size here? n can be up to 1e5, and m up to 3e5. Oh, right, standard dynamic programming approaches for knapsack might not work here because the time complexity would be too high.\n\nBecause in the 0-1 knapsack, the DP approach is O(n*m), which for n=1e5 and m=3e5 would be 3e10 operations—way too slow.\n\nSo, we need a more efficient approach. Given that the weights are small (each wi is 1, 2, or 3), maybe we can exploit that.\n\nLet me think: since the maximum weight per item is 3, perhaps we can group items by their weights and process them in a way that allows us to compute the maximum cost without checking every possibility.\n\nAnother thought: For each weight category (1, 2, 3), we can sort the items in descending order of cost. Then, when building the knapsack, we can take the top k items for each weight and precompute prefix sums.\n\nWait, here's an idea. Since the maximum possible weight is m, and the maximum weight per item is 3, the number of items we can take for each category isn't going to be more than m//weight. But since m can be 3e5, taking all possible combinations might still be tricky.\n\nBut considering that each item's weight is 1, 2, or 3, perhaps we can use a three-dimensional DP approach. Let's see:\n\nWe can keep track of the maximum cost for a total weight up to w, considering items of weight 1, 2, and 3, but only adding one type at a time.\n\nWait, another approach is to use unbounded knapsack but with small weights. Or maybe, since the weight is limited, we can represent the DP state based on the counts of each weight category.\n\nAlternatively, let's try this approach:\n\n1. Separate the items into three groups based on their weight: group1 (w=1), group2 (w=2), group3 (w=3).\n\n2. Sort each group in descending order of cost. This way, when we take items from a group, we take the most valuable ones first.\n\n3. Precompute prefix sums for each group. So for group1, the sum after taking i items is sum1[i], which is the total cost for taking the top i items of weight 1.\n\nSame for group2 and group3.\n\n4. Now, the problem reduces to selecting a certain number of items from each group such that the total weight (number of items taken from group1 * 1 + group2 *2 + group3*3) <= m. We want the sum of the selected items' costs to be as large as possible.\n\nThis sounds manageable. Because the number of items taken from each group is bounded by the maximum possible given the weight.\n\nFor group1: max possible is min(k where k*1 <=m, len(group1)).\n\nSimilarly for group2: min(k where k*2<=m, len(group2)).\n\nGroup3: min(k where k*3<=m, len(group3)).\n\nSo, we can iterate over all possible numbers of items taken from group3, then group2, and then group1. But even that could be time-consuming if done naively.\n\nWait, but the number of possible items taken from group3 can be up to min(len(group3), m//3). For group3, m can be up to 3e5, so len(group3) can be up to 1e5, making the possible values for group3's count up to 3e5/3 = 1e5. Hmm, but 1e5 is manageable.\n\nWait, no: group3's count can be up to min(m //3, len(group3)). So if len(group3) is 1e5 and m is 3e5, then group3's count can be up to 1e5. Similarly for group2: m//2 can be up to 1.5e5, but again len(group2) is 1e5.\n\nSo, the triple loop would be O(a*b*c), where a, b, c are up to 1e",
    "response": "To solve this problem, we need to determine the maximum possible total cost of souvenirs that Petya can carry to the market without exceeding a given weight limit. This is a classic knapsack problem with constraints on the number of items and their weights.\n\n### Approach\n1. **Problem Analysis**: The problem is a variation of the 0-1 knapsack problem where each item has a weight of either 1, 2, or 3, and a cost. Given the constraints, a direct dynamic programming approach would be too slow, so we need an optimized solution.\n\n2. **Grouping by Weight**: We group the items into three categories based on their weights: weight 1, weight 2, and weight 3. This allows us to handle each group separately and efficiently.\n\n3. **Sorting and Prefix Sums**: For each group, we sort the items in descending order of their cost. We then compute prefix sums for each group, which gives us the maximum cost achievable by taking the top k items from each group.\n\n4. **Iterative Combination**: We iterate over all possible numbers of items taken from the weight 3 group, then for each of these, we iterate over possible numbers of items from the weight 2 group. For each combination, we determine the maximum number of items that can be taken from the weight 1 group without exceeding the weight limit. The total cost is computed using the prefix sums and the maximum is tracked.\n\n### Solution Code\n```python\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    m = int(input[idx+1])\n    idx += 2\n\n    group1 = []\n    group2 = []\n    group3 = []\n\n    for _ in range(n):\n        w = int(input[idx])\n        c = int(input[idx+1])\n        idx += 2\n        if w == 1:\n            group1.append(c)\n        elif w == 2:\n            group2.append(c)\n        else:\n            group3.append(c)\n\n    # Sort each group in descending order and compute prefix sums\n    group1.sort(reverse=True)\n    group2.sort(reverse=True)\n    group3.sort(reverse=True)\n\n    prefix1 = [0]\n    sum_ = 0\n    for c in group1:\n        sum_ += c\n        prefix1.append(sum_)\n\n    prefix2 = [0]\n    sum_ = 0\n    for c in group2:\n        sum_ += c\n        prefix2.append(sum_)\n\n    prefix3 = [0]\n    sum_ = 0\n    for c in group3:\n        sum_ += c\n        prefix3.append(sum_)\n\n    max_cost = 0\n\n    # Iterate over possible counts for group3\n    max_take3 = min(len(group3), m // 3)\n    for take3 in range(0, max_take3 + 1):\n        remaining_weight = m - take3 * 3\n        if remaining_weight < 0:\n            continue\n\n        # Now iterate over possible counts for group2\n        max_take2 = min(len(group2), remaining_weight // 2)\n        for take2 in range(0, max_take2 + 1):\n            remaining_weight2 = remaining_weight - take2 * 2\n            if remaining_weight2 < 0:\n                continue\n\n            # The remaining weight can take up to remaining_weight2 items of weight1\n            max_take1 = min(len(group1), remaining_weight2)\n            current_total = prefix3[take3] + prefix2[take2] + prefix1[min(max_take1, len(prefix1)-1)]\n            if current_total > max_cost:\n                max_cost = current_total\n\n    print(max_cost)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into groups based on the weight of the souvenirs.\n2. **Sorting and Prefix Sums**: Each group is sorted by cost in descending order, and prefix sums are computed to quickly get the maximum cost for any number of items taken from each group.\n3. **Iterating Over Combinations**: For each possible number of items taken from the heaviest group (weight 3), we consider all possible numbers from the next heaviest group (weight 2), and then determine the maximum number of items from the lightest group (weight 1) that fit within the remaining weight limit. The total cost is computed using the prefix sums, and the maximum cost is tracked.\n\nThis approach efficiently handles the problem constraints and ensures that the solution is computed in a reasonable time frame.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    m = int(input[idx+1])\n    idx += 2\n\n    group1 = []\n    group2 = []\n    group3 = []\n\n    for _ in range(n):\n        w = int(input[idx])\n        c = int(input[idx+1])\n        idx += 2\n        if w == 1:\n            group1.append(c)\n        elif w == 2:\n            group2.append(c)\n        else:\n            group3.append(c)\n\n    # Sort each group in descending order and compute prefix sums\n    group1.sort(reverse=True)\n    group2.sort(reverse=True)\n    group3.sort(reverse=True)\n\n    prefix1 = [0]\n    sum_ = 0\n    for c in group1:\n        sum_ += c\n        prefix1.append(sum_)\n\n    prefix2 = [0]\n    sum_ = 0\n    for c in group2:\n        sum_ += c\n        prefix2.append(sum_)\n\n    prefix3 = [0]\n    sum_ = 0\n    for c in group3:\n        sum_ += c\n        prefix3.append(sum_)\n\n    max_cost = 0\n\n    # Iterate over possible counts for group3\n    max_take3 = min(len(group3), m // 3)\n    for take3 in range(0, max_take3 + 1):\n        remaining_weight = m - take3 * 3\n        if remaining_weight < 0:\n            continue\n\n        # Now iterate over possible counts for group2\n        max_take2 = min(len(group2), remaining_weight // 2)\n        for take2 in range(0, max_take2 + 1):\n            remaining_weight2 = remaining_weight - take2 * 2\n            if remaining_weight2 < 0:\n                continue\n\n            # The remaining weight can take up to remaining_weight2 items of weight1\n            max_take1 = min(len(group1), remaining_weight2)\n            current_total = prefix3[take3] + prefix2[take2] + prefix1[min(max_take1, len(prefix1)-1)]\n            if current_total > max_cost:\n                max_cost = current_total\n\n    print(max_cost)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 442,
        "completion_token_count": 972,
        "thoughts_token_count": 1025
    }
}