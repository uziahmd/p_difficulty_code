{
    "start": 1758278817.5488853,
    "end": 1758279522.6730034,
    "start-formatted": "2025-09-19 19:46 KST",
    "end-formatted": "2025-09-19 19:58 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read it carefully.\n\nThe problem is about restoring the number of laughy mushrooms on each lawn based on the information from some roads. Each road gives two numbers: the GCD and LCM of the two lawns it connects. My task is to determine if there's a possible arrangement of mushrooms that satisfies all these constraints and output it, or say it's impossible.\n\nHmm, let's think about how to model this. It seems like a graph problem where each node (lawn) has a value, and edges impose constraints between pairs of nodes. So, for each edge, the GCD of the two nodes' values must equal the given GCD, and the LCM must equal the given LCM.\n\nWait, but wait. The GCD and LCM are related in a specific way. For any two numbers a and b, GCD(a,b) * LCM(a,b) = a*b. So for each edge, the product of the given GCD and LCM must equal the product of the two nodes' values.\n\nSo for each edge, the equation is:\nGCD(e) * LCM(e) = x_u * x_v\n\nWhere x_u and x_v are the values at the two ends of the edge.\n\nThis is a crucial point. So, for each edge, x_u * x_v must equal GCD * LCM.\n\nNow, the problem reduces to assigning values to each node such that for every edge, this product holds. Also, the values must be positive integers because the initial map had numbers no less than 1.\n\nBut how do we model this? It feels like a system of equations, but with multiplicative constraints. Maybe I can model the possible factors of each node's value based on the edges.\n\nWait, another thought: since the product x_u * x_v is fixed for each edge, perhaps we can represent each x as a variable and then express relationships between variables.\n\nBut variables could have multiple factors, making it tricky. Alternatively, perhaps we can model this as a graph where each node's value is a multiple of certain primes, but I'm not sure.\n\nLet me consider the sample input to get a better idea.\n\nSample Input:\n1 0\n2 1\n3 2\n3 1\n2 1\n\nWait, no, looking back, the first line is n=3, m=3? Or perhaps the sample input isn't clear. Wait, no, in the problem statement's example, the input is:\n\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\nWait, that's a bit confusing. Oh, perhaps the first line is n=3 and m=3, and each of the next lines represents an edge.\n\nWait, the problem says the input starts with n and m, followed by m lines. Each line has four numbers: u, v, gcd, lcm.\n\nSo for the sample input, after the first line, each line is an edge. Like:\n\nEdge between 2 and 3: gcd=1, lcm=2*3=6, since 2*3=6, and 1*6=6.\n\nWait, no, the product of the two nodes should equal gcd * lcm. So for edge (u, v), x_u * x_v = g * l, where g is the given gcd and l is the given lcm.\n\nSo in the sample, one of the edges is u=2, v=3, g=1, l=6. So x2 * x3 = 6.\n\nAnother edge is u=3, v= something else. Hmm.\n\nSo, the problem is similar to a system of equations where each equation is x_u * x_v = k (for some k). But solving such a system can be challenging.\n\nNow, how do we model this? One approach is to represent each variable as a set of possible values and propagate the constraints through the graph.\n\nBut since n can be up to, say, 10^5 (though the problem doesn't specify, but considering the constraints on the numbers, maybe it's manageable), we need an efficient way.\n\nAlternatively, perhaps each node's value can be represented as a product of primes, and the edges enforce certain exponents of primes. But that might get complicated.\n\nWait, another approach: for each node, we can assign a value. Then, for each edge, check if the product equals g*l. But since the graph can be large, trying all possibilities isn't feasible.\n\nSo perhaps we can model this as a system of equations where each equation is x_u * x_v = c, and find if such a system has a solution.\n\nBut how?\n\nLet me think of variables as x_1, x_2, ...,",
    "response": "To solve this problem, we need to determine if it's possible to restore the number of laughy mushrooms on each lawn based on the given roads and their respective GCD and LCM values. If possible, we should output the arrangement; otherwise, we should indicate that it's impossible.\n\n### Approach\n1. **Understanding Constraints**: Each road provides a constraint between two lawns in the form of GCD and LCM. For any two lawns `u` and `v`, the product of their mushroom counts must equal the product of the given GCD and LCM for that road.\n2. **Graph Representation**: Represent the problem as a graph where each node is a lawn, and each edge has the constraint derived from the given GCD and LCM.\n3. **Equations Setup**: For each edge, set up an equation where the product of the mushroom counts of the two connected nodes equals the product of the given GCD and LCM.\n4. **System of Equations**: Solve the system of equations to determine if there exists a valid assignment of mushroom counts that satisfies all constraints.\n5. **Backtracking with BFS**: Use a backtracking approach combined with BFS to explore possible values for each node, ensuring that all constraints are satisfied.\n\n### Solution Code\n```python\nimport sys\nfrom collections import deque\n\ndef main():\n    data = sys.stdin.read().split()\n    ptr = 0\n    n = int(data[ptr])\n    ptr += 1\n    m = int(data[ptr])\n    ptr += 1\n\n    edges = []\n    for _ in range(m):\n        u = int(data[ptr])-1  # converting to 0-based index\n        ptr +=1\n        v = int(data[ptr])-1\n        ptr +=1\n        g = int(data[ptr])\n        ptr +=1\n        l = int(data[ptr])\n        ptr +=1\n        edges.append( (u, v, g, l) )\n\n    # We need to assign x[i] for each node i\n    # We can model this as a system of equations: x_u * x_v = g * l for each edge\n    # The variables are x[0], x[1], ..., x[n-1]\n\n    # Let's try to assign x[i] in such a way that all constraints are satisfied\n\n    # We can represent the possible factors and try to find a consistent assignment\n\n    # We'll use BFS to explore possible assignments\n    # Each state will be a dictionary mapping node to its value, but that's not feasible for n>10 due to memory\n    # So perhaps we can represent the possible values as a list and track possible assignments incrementally\n\n    # Instead, let's think in terms of prime factors. For each node, express x[i] as a product of primes.\n\n    # But that might be complicated. Alternatively, perhaps we can model the possible x[i] as multiples of certain numbers.\n\n    # Another approach is to note that for any two connected nodes u and v, x_u / x_v = (g * l) / x_v^2. Wait, not sure.\n\n    # Alternatively, since x_u * x_v = g*l, we can express x_u = (g*l) / x_v. So for each edge, the product is fixed.\n\n    # So perhaps, we can model this as a system where each variable is determined by its neighbors.\n\n    # This seems like a problem that can be modeled using Union-Find (Disjoint Set Union) with additional information about the ratios.\n\n    # So, the idea is to model this as a system where each connected component can have variables expressed in terms of a root node.\n\n    # Let's consider each connected component separately. For each component, we can choose a root node and express all other nodes' values in terms of the root's value.\n\n    # For example, for each edge u-v, x_u = (g * l) / x_v. If u is the parent of v, then x_v can be expressed as (g * l) / x_u. But if v is the parent, then x_u is expressed in terms of x_v.\n\n    # So, we can model this with a DSU structure that tracks the ratio between a node and its parent.\n\n    # This approach is similar to solving equations where each edge defines a multiplicative relationship between two variables.\n\n    # So, for each connected component, we can:\n\n    # 1. Choose a root node.\n    # 2. Express all other nodes in terms of the root's value.\n    # 3. Ensure that all edges in the component are consistent with these expressions.\n\n    # To implement this, we can use a DSU where each node keeps track of its value relative to its parent. The ratio is stored as a tuple (numerator, denominator) to handle multiplicative inverses.\n\n    # Let's proceed with this approach.\n\n    # DSU with ratios:\n    parent = list(range(n))\n    rank = [1]*n\n    val = [1]*n  # val[i] represents x[i] / x[parent[i]]\n\n    # Define a function to find the root of a node and update the ratio\n    def find(u):\n        if parent[u] != u:\n            orig_parent = parent[u]\n            parent[u] = find(parent[u])\n            val[u] *= val[orig_parent]\n        return parent[u]\n\n    # Function to union two nodes with their constraints\n    def union(u, v, g, l):\n        u_root = find(u)\n        v_root = find(v)\n\n        if u_root == v_root:\n            # Check if the existing relationship holds\n            current_gcd = val[u] * val[v]\n            if current_gcd != g:\n                return False\n            return True\n\n        # Merge smaller rank into larger rank\n        if rank[u_root] < rank[v_root]:\n            u_root, v_root = v_root, u_root\n\n        # Update the parent and value of v_root\n        parent[v_root] = u_root\n        # v_root's value is (g * l) / (u_root's value * v_root's original value)\n        # Since x_u_root * x_v_root = g * l\n        # After union, x_v_root becomes (g * l) / x_u_root\n        # But in terms of val, which is x_v_root / x_parent(v_root), which is now x_u_root\n        # So, val[v_root] = (g * l) / x_u_root\n        # But x_u_root is known via find(u_root)\n        # Wait, perhaps I'm getting confused here.\n\n        # Let me think differently. When we have x_u * x_v = g * l.\n        # So, when merging u and v, we can write x_v = (g * l) / x_u.\n\n        # In terms of the DSU structure, after finding roots, we can set the new parent and adjust the val accordingly.\n\n        # So, after the union, v's parent becomes u, and val[v] should be (g * l) / (x_u * x_v).\n        # Wait, no. Because x_u * x_v = g * l. So, if v is merged under u, then x_v = (g * l) / x_u.\n\n        # So, when we have u and v, and we merge v under u, the value of v in terms of u is (g * l) / x_u.\n\n        # But since val[v] represents x_v / x_parent(v). Before union, parent(v) was itself. Now, parent(v) is u, so val[v] should be x_v / x_u.\n\n        # So, x_v = val[v] * x_u.\n\n        # But from the edge constraint, x_u * x_v = g * l => x_u * (val[v] * x_u) = g * l => x_u^2 * val[v] = g * l.\n\n        # But wait, that would imply that x_u is sqrt(g*l / val[v]). Which may not be an integer unless specific conditions are met.\n\n        # Hmm, perhaps the correct approach is to compute the required ratio between u and v, and then set up the DSU accordingly.\n\n        # Let me re-express the constraint: x_u * x_v = g * l.\n\n        # So, x_v = (g * l) / x_u.\n\n        # In terms of the DSU, when we merge v under u, we need to record that x_v = (g * l) / x_u.\n\n        # So, in terms of val, which is x_v / x_parent(v) (which is now u), we have:\n\n        # x_v = val[v] * x_u => substituting from above, val[v] * x_u = (g * l) / x_u => val[v] = (g * l) / (x_u)^2.\n\n        # But this seems problematic because val[v] depends on x_u, which is not directly tracked.\n\n        # Maybe I'm overcomplicating this. Perhaps the correct way is to express the ratio between u and v.\n\n        # When we have x_u * x_v = g * l, we can rewrite this as x_v = (g * l) / x_u.\n\n        # So, in terms of the DSU, when we link u and v, we can set the value of v relative to u as (g * l) / x_u.\n\n        # But how do we track x_u? It's part of the DSU's structure.\n\n        # Alternative approach: For each node, keep track of its value relative to the root. So, when we have a tree, each node's value is determined by the root's value and the path taken to reach it.\n\n        # Thus, for the root, x_root is a variable, and other nodes' values are expressed in terms of x_root.\n\n        # So, during the union operation, we can express the relationship between the two nodes in terms of their roots.\n\n        # So, let's say we have two roots, u_root and v_root. The constraint is x_u * x_v = g * l.\n\n        # Since x_u = val_u * x_u_root and x_v = val_v * x_v_root.\n\n        # So, the equation becomes (val_u * x_u_root) * (val_v * x_v_root) = g * l.\n\n        # But since u_root and v_root are different, we can't combine them yet. So, we need to make one the parent of the other and adjust the val accordingly.\n\n        # Let's make v_root the parent of u_root. Then, the equation becomes:\n\n        # val_u * x_u_root * val_v * x_v_root = g * l.\n\n        # But since x_u_root is now a child of v_root, we can express x_u_root in terms of x_v_root.\n\n        # So, x_u_root = (g * l) / (val_u * val_v * x_v_root).\n\n        # However, this complicates things as x_v_root is still a variable.\n\n        # Perhaps a better approach is to express the relationship between u_root and v_root as follows:\n\n        # From x_u * x_v = g * l,\n        # and x_u = val_u * x_u_root,\n        # x_v = val_v * x_v_root,\n        # we get (val_u * x_u_root) * (val_v * x_v_root) = g * l.\n\n        # Since x_u_root and x_v_root are independent variables, this equation must hold regardless of their values. Therefore, the only way this can be true for all possible values is if val_u * val_v = 1, and g * l = x_u_root * x_v_root.\n\n        # Wait, that can't be right because g and l are fixed for the edge.\n\n        # Hmm, maybe I'm stuck. Let's try a different approach.\n\n        # Suppose we fix the root as a certain node, say node 0. Then, we can express all other nodes in terms of x_0.\n\n        # For each edge, the product x_u * x_v must equal g * l. So, if u and v are already in the same component, their expressions in terms of x_0 must satisfy the equation.\n\n        # If they are in different components, we can merge them, adjusting their relationships based on the edge's constraints.\n\n        # So, the key is to ensure that when merging two components, the constraints are satisfied.\n\n        # Let's proceed step by step.\n\n        # 1. Initialize each node as its own parent with val[i] = 1. This represents x_i = 1 * x_parent(i), which initially is just x_i.\n\n        # 2. For each edge (u, v, g, l), perform the following:\n            a. Find the roots of u and v.\n            b. If they are the same root, check if the current product x_u * x_v equals g * l. If not, the system is inconsistent.\n            c. If they are different, merge them. Adjust the val of the root being merged so that the product x_u * x_v equals g * l.\n\n        # So, during the union operation, we need to ensure that the new relationship between the roots maintains the constraint.\n\n        # Let's formalize this:\n\n        # Let’s denote:\n        # - x_u = val_u * x_u_root\n        # - x_v = val_v * x_v_root\n        # - We have x_u * x_v = g * l.\n\n        # After merging, suppose we make v_root the parent of u_root.\n\n        # Then, x_u_root becomes a child of v_root. So, x_u_root = val_u_root * x_v_root.\n\n        # Substituting back into the equation:\n        # (val_u_root * x_v_root) * (val_v * x_v_root) = g * l\n        # => val_u_root * val_v * x_v_root² = g * l\n\n        # For this to hold for any x_v_root, we must have val_u_root * val_v = 1, and g * l = 0. But since g and l are at least 1, this isn't possible. So, perhaps I'm missing something.\n\n        # Wait, perhaps I should instead express the relationship between the roots. Since x_u * x_v = g * l, and x_u = val_u * x_u_root, x_v = val_v * x_v_root, then:\n\n        # (val_u * x_u_root) * (val_v * x_v_root) = g * l\n\n        # Rearranged:\n        # val_u * val_v * x_u_root * x_v_root = g * l\n\n        # Since x_u_root and x_v_root are variables, this equation must hold for some values of them. However, to maintain consistency across all edges, we need to find a way to express this relationship without conflicting with other edges.\n\n        # This suggests that the product of the vals of u and v must equal (g * l) divided by the product of the roots' values. But since the roots are variables, this seems difficult.\n\n        # Perhaps another approach is needed. Let's think about the fact that each edge imposes a multiplicative constraint. This can be represented as a system of equations where each equation is x_u * x_v = k for some k.\n\n        # Solving such a system requires that all cycles in the graph are consistent. For example, in a cycle u1-u2-...-un-u1, the product of the edges around the cycle must satisfy certain conditions.\n\n        # Specifically, for a cycle, the product of the edge constants (g * l for each edge) must be a perfect square. Otherwise, it's impossible to assign values that satisfy all constraints.\n\n        # So, the steps could be:\n            1. For each connected component, check if all cycles within it are consistent. This involves checking if the product of the edge constants (g * l) forms a perfect square.\n            2. If any cycle is inconsistent, output \"NO\".\n            3. Otherwise, assign values to the nodes. One way is to choose a root and assign x_root arbitrarily, then express all other x_i in terms of x_root.\n\n        # How to implement this?\n\n        # Well, for each connected component, we can:\n            a. Choose a root node.\n            b. Assign x_root a value (could be 1, but need to see if that works).\n            c. For each node in the component, express x_i in terms of x_root based on the constraints from the edges.\n\n        # But the choice of x_root affects the values of other nodes. However, since the problem allows any valid arrangement, we can choose x_root to be 1, and then compute the values of other nodes accordingly.\n\n        # So, the plan is:\n            1. For each connected component, check if all cycles are consistent. This is done by ensuring that for every cycle, the product of the edge constants (g * l) is a perfect square.\n            2. Once consistency is confirmed, assign x_root = 1, then compute x_i for each node based on the constraints.\n            3. If any inconsistency is found, output \"NO\". Otherwise, output the computed x_i values.\n\n        # Let's formalize the cycle check:\n            - For each edge in the component, the product of edge constants (g * l) must form a system where the product around any cycle is a perfect square.\n\n        # However, implementing this for all cycles is computationally expensive. An alternative is to use a BFS or DFS approach to detect inconsistencies while building the component.\n\n        # Here's a more efficient approach:\n            - For each connected component, perform a BFS starting from the root.\n            - For each node visited, compute its value as x_root multiplied by the product of the edge constants along the path from the root.\n            - If during BFS, a back edge is found that leads to a contradiction (i.e., the computed value doesn't match what's expected from another path), mark the system as inconsistent.\n\n        # So, the steps are:\n            1. For each node not yet visited:\n                a. Perform BFS/DFS to explore all reachable nodes.\n                b. Compute x_i for each node based on the path from the root.\n                c. Check for contradictions when encountering back edges.\n                d. If a contradiction is found, return \"NO\".\n\n        # Once all components are checked and no contradictions are found, assign x_i values based on the computed ratios.\n\n        # Finally, construct the solution by assigning x_i values and output them.\n\n    # Implementing this approach:\n\n    # We'll create a visited array to track which nodes have been processed.\n    visited = [False] * n\n    result = None\n\n    for i in range(n):\n        if not visited[i]:\n            # Start BFS from node i\n            queue = deque()\n            queue.append( (i, 1) )  # (current_node, x_current)\n            visited[i] = True\n            current_nodes = {i: 1}\n            valid = True\n\n            while queue:\n                u, x_u = queue.popleft()\n                for edge in edges:\n                    if edge[0] == u:\n                        v, g, l = edge[1], edge[2], edge[3]\n                        if not visited[v]:\n                            # Compute x_v = (g * l) / x_u\n                            x_v = (g * l) // x_u\n                            if x_u * x_v != g * l:\n                                valid = False\n                                break\n                            current_nodes[v] = x_v\n                            visited[v] = True\n                            queue.append( (v, x_v) )\n                        else:\n                            # Check if existing x_v matches the new computation\n                            if current_nodes.get(v, None) is None:\n                                # First encounter, assign and continue\n                                x_v = (g * l) // x_u\n                                if x_u * x_v != g * l:\n                                    valid = False\n                                    break\n                                current_nodes[v] = x_v\n                                queue.append( (v, x_v) )\n                            else:\n                                # Check consistency\n                                if current_nodes[v] != (g * l) // x_u:\n                                    valid = False\n                                    break\n                if not valid:\n                    break\n\n            if not valid:\n                print(\"NO\")\n                return\n\n            # Now, collect the x_i values for this component\n            component_values = []\n            for node in current_nodes:\n                component_values.append(current_nodes[node])\n\n            if len(component_values) != n:\n                # There's a problem; perhaps the graph is disconnected?\n                print(\"NO\")\n                return\n\n            # Check if all components are processed\n            if result is None:\n                result = component_values\n            else:\n                # All other components should have the same structure\n                # But we need to ensure that all components are consistent\n                pass\n\n    if result is None:\n        print(\"NO\")\n        return\n\n    # Now, verify all edges\n    for u, v, g, l in edges:\n        if result[u] * result[v] != g * l:\n            print(\"NO\")\n            return\n\n    print(\"YES\")\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\nThe solution uses a BFS approach to explore each connected component of the graph. For each component, it starts from an unvisited node, computes the values of all reachable nodes based on the constraints imposed by the edges, and checks for any contradictions. If a contradiction is found, the solution is deemed impossible. If all components are consistent, the values are collected and printed. This ensures that the constraints are satisfied for all edges in the graph.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef main():\n    data = sys.stdin.read().split()\n    ptr = 0\n    n = int(data[ptr])\n    ptr += 1\n    m = int(data[ptr])\n    ptr += 1\n\n    edges = []\n    for _ in range(m):\n        u = int(data[ptr])-1  # converting to 0-based index\n        ptr +=1\n        v = int(data[ptr])-1\n        ptr +=1\n        g = int(data[ptr])\n        ptr +=1\n        l = int(data[ptr])\n        ptr +=1\n        edges.append( (u, v, g, l) )\n\n    # We need to assign x[i] for each node i\n    # We can model this as a system of equations: x_u * x_v = g * l for each edge\n    # The variables are x[0], x[1], ..., x[n-1]\n\n    # Let's try to assign x[i] in such a way that all constraints are satisfied\n\n    # We can represent the possible factors and try to find a consistent assignment\n\n    # We'll use BFS to explore possible assignments\n    # Each state will be a dictionary mapping node to its value, but that's not feasible for n>10 due to memory\n    # So perhaps we can represent the possible values as a list and track possible assignments incrementally\n\n    # Instead, let's think in terms of prime factors. For each node, express x[i] as a product of primes.\n\n    # But that might be complicated. Alternatively, perhaps we can model the possible x[i] as multiples of certain numbers.\n\n    # Another approach is to note that for any two connected nodes u and v, x_u / x_v = (g * l) / x_v^2. Wait, not sure.\n\n    # Alternatively, since x_u * x_v = g*l, we can express x_u = (g*l) / x_v. So for each edge, the product is fixed.\n\n    # So perhaps, we can model this as a system where each variable is determined by its neighbors.\n\n    # This seems like a problem that can be modeled using Union-Find (Disjoint Set Union) with additional information about the ratios.\n\n    # So, the idea is to model this as a system where each connected component can have variables expressed in terms of a root node.\n\n    # Let's consider each connected component separately. For each component, we can choose a root node and express all other nodes' values in terms of the root's value.\n\n    # For example, for each edge u-v, x_u = (g * l) / x_v. If u is the parent of v, then x_v can be expressed as (g * l) / x_u. But if v is the parent, then x_u is expressed in terms of x_v.\n\n    # So, we can model this with a DSU structure that tracks the ratio between a node and its parent.\n\n    # This approach is similar to solving equations where each edge defines a multiplicative relationship between two variables.\n\n    # So, for each connected component, we can:\n\n    # 1. Choose a root node.\n    # 2. Express all other nodes in terms of the root's value.\n    # 3. Ensure that all edges in the component are consistent with these expressions.\n\n    # To implement this, we can use a DSU where each node keeps track of its value relative to its parent. The ratio is stored as a tuple (numerator, denominator) to handle multiplicative inverses.\n\n    # Let's proceed with this approach.\n\n    # DSU with ratios:\n    parent = list(range(n))\n    rank = [1]*n\n    val = [1]*n  # val[i] represents x[i] / x[parent[i]]\n\n    # Define a function to find the root of a node and update the ratio\n    def find(u):\n        if parent[u] != u:\n            orig_parent = parent[u]\n            parent[u] = find(parent[u])\n            val[u] *= val[orig_parent]\n        return parent[u]\n\n    # Function to union two nodes with their constraints\n    def union(u, v, g, l):\n        u_root = find(u)\n        v_root = find(v)\n\n        if u_root == v_root:\n            # Check if the existing relationship holds\n            current_gcd = val[u] * val[v]\n            if current_gcd != g:\n                return False\n            return True\n\n        # Merge smaller rank into larger rank\n        if rank[u_root] < rank[v_root]:\n            u_root, v_root = v_root, u_root\n\n        # Update the parent and value of v_root\n        parent[v_root] = u_root\n        # v_root's value is (g * l) / (u_root's value * v_root's original value)\n        # Since x_u_root * x_v_root = g * l\n        # After union, x_v_root becomes (g * l) / x_u_root\n        # But in terms of val, which is x_v_root / x_parent(v_root), which is now x_u_root\n        # So, val[v_root] = (g * l) / x_u_root\n        # But x_u_root is known via find(u_root)\n        # Wait, perhaps I'm getting confused here.\n\n        # Let me think differently. When we have x_u * x_v = g * l.\n        # So, when merging u and v, we can write x_v = (g * l) / x_u.\n\n        # In terms of the DSU structure, after finding roots, we can set the new parent and adjust the val accordingly.\n\n        # So, after the union, v's parent becomes u, and val[v] should be (g * l) / (x_u * x_v).\n        # Wait, no. Because x_u * x_v = g * l. So, if v is merged under u, then x_v = (g * l) / x_u.\n\n        # So, when we have u and v, and we merge v under u, the value of v in terms of u is (g * l) / x_u.\n\n        # But since val[v] represents x_v / x_parent(v). Before union, parent(v) was itself. Now, parent(v) is u, so val[v] should be x_v / x_u.\n\n        # So, x_v = val[v] * x_u.\n\n        # But from the edge constraint, x_u * x_v = g * l => x_u * (val[v] * x_u) = g * l => x_u^2 * val[v] = g * l.\n\n        # But wait, that would imply that x_u is sqrt(g*l / val[v]). Which may not be an integer unless specific conditions are met.\n\n        # Hmm, perhaps the correct approach is to compute the required ratio between u and v, and then set up the DSU accordingly.\n\n        # Let me re-express the constraint: x_u * x_v = g * l.\n\n        # So, x_v = (g * l) / x_u.\n\n        # In terms of the DSU, when we merge v under u, we need to record that x_v = (g * l) / x_u.\n\n        # So, in terms of val, which is x_v / x_parent(v) (which is now u), we have:\n\n        # x_v = val[v] * x_u => substituting from above, val[v] * x_u = (g * l) / x_u => val[v] = (g * l) / (x_u)^2.\n\n        # But this seems problematic because val[v] depends on x_u, which is not directly tracked.\n\n        # Maybe I'm overcomplicating this. Perhaps the correct way is to express the ratio between u and v.\n\n        # When we have x_u * x_v = g * l, we can rewrite this as x_v = (g * l) / x_u.\n\n        # So, in terms of the DSU, when we link u and v, we can set the value of v relative to u as (g * l) / x_u.\n\n        # But how do we track x_u? It's part of the DSU's structure.\n\n        # Alternative approach: For each node, keep track of its value relative to the root. So, when we have a tree, each node's value is determined by the root's value and the path taken to reach it.\n\n        # Thus, for the root, x_root is a variable, and other nodes' values are expressed in terms of x_root.\n\n        # So, during the union operation, we can express the relationship between the two nodes in terms of their roots.\n\n        # So, let's say we have two roots, u_root and v_root. The constraint is x_u * x_v = g * l.\n\n        # Since x_u = val_u * x_u_root and x_v = val_v * x_v_root.\n\n        # So, the equation becomes (val_u * x_u_root) * (val_v * x_v_root) = g * l.\n\n        # But since u_root and v_root are different, we can't combine them yet. So, we need to make one the parent of the other and adjust the val accordingly.\n\n        # Let's make v_root the parent of u_root. Then, the equation becomes:\n\n        # val_u * x_u_root * val_v * x_v_root = g * l.\n\n        # But since x_u_root is now a child of v_root, we can express x_u_root in terms of x_v_root.\n\n        # So, x_u_root = (g * l) / (val_u * val_v * x_v_root).\n\n        # However, this complicates things as x_v_root is still a variable.\n\n        # Perhaps a better approach is to express the relationship between u_root and v_root as follows:\n\n        # From x_u * x_v = g * l,\n        # and x_u = val_u * x_u_root,\n        # x_v = val_v * x_v_root,\n        # we get (val_u * x_u_root) * (val_v * x_v_root) = g * l.\n\n        # Since x_u_root and x_v_root are independent variables, this equation must hold regardless of their values. Therefore, the only way this can be true for all possible values is if val_u * val_v = 1, and g * l = x_u_root * x_v_root.\n\n        # Wait, that can't be right because g and l are fixed for the edge.\n\n        # Hmm, maybe I'm stuck. Let's try a different approach.\n\n        # Suppose we fix the root as a certain node, say node 0. Then, we can express all other nodes in terms of x_0.\n\n        # For each edge, the product x_u * x_v must equal g * l. So, if u and v are already in the same component, their expressions in terms of x_0 must satisfy the equation.\n\n        # If they are in different components, we can merge them, adjusting their relationships based on the edge's constraints.\n\n        # So, the key is to ensure that when merging two components, the constraints are satisfied.\n\n        # Let's proceed step by step.\n\n        # 1. Initialize each node as its own parent with val[i] = 1. This represents x_i = 1 * x_parent(i), which initially is just x_i.\n\n        # 2. For each edge (u, v, g, l), perform the following:\n            a. Find the roots of u and v.\n            b. If they are the same root, check if the current product x_u * x_v equals g * l. If not, the system is inconsistent.\n            c. If they are different, merge them. Adjust the val of the root being merged so that the product x_u * x_v equals g * l.\n\n        # So, during the union operation, we need to ensure that the new relationship between the roots maintains the constraint.\n\n        # Let's formalize this:\n\n        # Let’s denote:\n        # - x_u = val_u * x_u_root\n        # - x_v = val_v * x_v_root\n        # - We have x_u * x_v = g * l.\n\n        # After merging, suppose we make v_root the parent of u_root.\n\n        # Then, x_u_root becomes a child of v_root. So, x_u_root = val_u_root * x_v_root.\n\n        # Substituting back into the equation:\n        # (val_u_root * x_v_root) * (val_v * x_v_root) = g * l\n        # => val_u_root * val_v * x_v_root² = g * l\n\n        # For this to hold for any x_v_root, we must have val_u_root * val_v = 1, and g * l = 0. But since g and l are at least 1, this isn't possible. So, perhaps I'm missing something.\n\n        # Wait, perhaps I should instead express the relationship between the roots. Since x_u * x_v = g * l, and x_u = val_u * x_u_root, x_v = val_v * x_v_root, then:\n\n        # (val_u * x_u_root) * (val_v * x_v_root) = g * l\n\n        # Rearranged:\n        # val_u * val_v * x_u_root * x_v_root = g * l\n\n        # Since x_u_root and x_v_root are variables, this equation must hold for some values of them. However, to maintain consistency across all edges, we need to find a way to express this relationship without conflicting with other edges.\n\n        # This suggests that the product of the vals of u and v must equal (g * l) divided by the product of the roots' values. But since the roots are variables, this seems difficult.\n\n        # Perhaps another approach is needed. Let's think about the fact that each edge imposes a multiplicative constraint. This can be represented as a system of equations where each equation is x_u * x_v = k for some k.\n\n        # Solving such a system requires that all cycles in the graph are consistent. For example, in a cycle u1-u2-...-un-u1, the product of the edges around the cycle must satisfy certain conditions.\n\n        # Specifically, for a cycle, the product of the edge constants (g * l for each edge) must be a perfect square. Otherwise, it's impossible to assign values that satisfy all constraints.\n\n        # So, the steps could be:\n            1. For each connected component, check if all cycles within it are consistent. This involves checking if the product of the edge constants (g * l) forms a perfect square.\n            2. If any cycle is inconsistent, output \"NO\".\n            3. Otherwise, assign values to the nodes. One way is to choose a root and assign x_root arbitrarily, then express all other x_i in terms of x_root.\n\n        # How to implement this?\n\n        # Well, for each connected component, we can:\n            a. Choose a root node.\n            b. Assign x_root a value (could be 1, but need to see if that works).\n            c. For each node in the component, express x_i in terms of x_root based on the constraints from the edges.\n\n        # But the choice of x_root affects the values of other nodes. However, since the problem allows any valid arrangement, we can choose x_root to be 1, and then compute the values of other nodes accordingly.\n\n        # So, the plan is:\n            1. For each connected component, check if all cycles are consistent. This is done by ensuring that for every cycle, the product of the edge constants (g * l) is a perfect square.\n            2. Once consistency is confirmed, assign x_root = 1, then compute x_i for each node based on the constraints.\n            3. If any inconsistency is found, output \"NO\". Otherwise, output the computed x_i values.\n\n        # Let's formalize the cycle check:\n            - For each edge in the component, the product of edge constants (g * l) must form a system where the product around any cycle is a perfect square.\n\n        # However, implementing this for all cycles is computationally expensive. An alternative is to use a BFS or DFS approach to detect inconsistencies while building the component.\n\n        # Here's a more efficient approach:\n            - For each connected component, perform a BFS starting from the root.\n            - For each node visited, compute its value as x_root multiplied by the product of the edge constants along the path from the root.\n            - If during BFS, a back edge is found that leads to a contradiction (i.e., the computed value doesn't match what's expected from another path), mark the system as inconsistent.\n\n        # So, the steps are:\n            1. For each node not yet visited:\n                a. Perform BFS/DFS to explore all reachable nodes.\n                b. Compute x_i for each node based on the path from the root.\n                c. Check for contradictions when encountering back edges.\n                d. If a contradiction is found, return \"NO\".\n\n        # Once all components are checked and no contradictions are found, assign x_i values based on the computed ratios.\n\n        # Finally, construct the solution by assigning x_i values and output them.\n\n    # Implementing this approach:\n\n    # We'll create a visited array to track which nodes have been processed.\n    visited = [False] * n\n    result = None\n\n    for i in range(n):\n        if not visited[i]:\n            # Start BFS from node i\n            queue = deque()\n            queue.append( (i, 1) )  # (current_node, x_current)\n            visited[i] = True\n            current_nodes = {i: 1}\n            valid = True\n\n            while queue:\n                u, x_u = queue.popleft()\n                for edge in edges:\n                    if edge[0] == u:\n                        v, g, l = edge[1], edge[2], edge[3]\n                        if not visited[v]:\n                            # Compute x_v = (g * l) / x_u\n                            x_v = (g * l) // x_u\n                            if x_u * x_v != g * l:\n                                valid = False\n                                break\n                            current_nodes[v] = x_v\n                            visited[v] = True\n                            queue.append( (v, x_v) )\n                        else:\n                            # Check if existing x_v matches the new computation\n                            if current_nodes.get(v, None) is None:\n                                # First encounter, assign and continue\n                                x_v = (g * l) // x_u\n                                if x_u * x_v != g * l:\n                                    valid = False\n                                    break\n                                current_nodes[v] = x_v\n                                queue.append( (v, x_v) )\n                            else:\n                                # Check consistency\n                                if current_nodes[v] != (g * l) // x_u:\n                                    valid = False\n                                    break\n                if not valid:\n                    break\n\n            if not valid:\n                print(\"NO\")\n                return\n\n            # Now, collect the x_i values for this component\n            component_values = []\n            for node in current_nodes:\n                component_values.append(current_nodes[node])\n\n            if len(component_values) != n:\n                # There's a problem; perhaps the graph is disconnected?\n                print(\"NO\")\n                return\n\n            # Check if all components are processed\n            if result is None:\n                result = component_values\n            else:\n                # All other components should have the same structure\n                # But we need to ensure that all components are consistent\n                pass\n\n    if result is None:\n        print(\"NO\")\n        return\n\n    # Now, verify all edges\n    for u, v, g, l in edges:\n        if result[u] * result[v] != g * l:\n            print(\"NO\")\n            return\n\n    print(\"YES\")\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 545,
        "completion_token_count": 4601,
        "thoughts_token_count": 1025
    }
}