{
    "start": 1758279657.9534268,
    "end": 1758279851.2364242,
    "start-formatted": "2025-09-19 20:00 KST",
    "end-formatted": "2025-09-19 20:04 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "Okay, I have to solve this problem where I need to find the minimum number of nodes required to create a p-reachable directed graph and then determine the maximum number of unidirectional pairs among all such graphs with that minimum node count.\n\nLet me first understand what a p-reachable directed graph is. So, a p-reachable graph has exactly p ordered pairs (u, v) such that u < v, u and v are reachable from each other. These pairs are called bidirectional pairs because you can go both ways between u and v.\n\nWait, no, wait. Wait, the problem says that an ordered pair (u, v) is unidirectional if u != v, there's a path from u to v, and no path from v to u. So for the p-reachable part, we're counting the number of such unordered pairs {u, v} where u and v are reachable both ways. Because in the definition, the ordered pair is considered as (u, v), but for being p-reachable, it's based on unordered pairs where u and v are reachable from each other, and u < v. Hmm, no, wait: the p is the count of ordered pairs (u, v) where u < v and they are reachable in both directions. Or wait, no. Wait, the problem statement says: \"exactly p ordered pairs of nodes (u, v) such that u < v and u and v are reachable from each other.\" So each such pair contributes one to p. So for example, if u and v form a mutual pair (can reach each other both ways), then (u, v) and (v, u) would not both be counted because u < v, so only (u, v) counts. But in the case where u and v are connected both ways, the pair (u, v) is counted once, but (v, u) is not because u < v implies u comes before v.\n\nWait no, let me read it again: \"p is the number of ordered pairs (u, v) such that u ≠ v, there exists a path from u to v, and there are no paths from v to u.\" Oh right! Wait, no: for the p-reachable part, it's the number of ordered pairs (u, v) where u < v and u and v are reachable from each other. Wait no, no, wait: the problem says p is the number of ordered pairs (u, v) where u < v and u and v are reachable from each other. So it's about ordered pairs where u is less than v, and u can reach v, and v can reach u. So each such pair contributes 1 to p.\n\nSo, for example, if u and v are in a mutual relationship (each can reach the other), and u < v, then this pair is counted once towards p. Similarly, for any such pair (u, v), if u can reach v and v can reach u, and u < v, then it's counted.\n\nWait, but in an undirected graph, every edge contributes to such a pair. But in a directed graph, it's possible for u to reach v but not v to reach u. So, for the p count, it's the number of such mutual pairs where u < v.\n\nSo, the problem is asking for the minimal number of nodes needed in a directed graph to have exactly p such pairs. Then, among all such minimal-node graphs, find the maximum number of unidirectional pairs.\n\nHmm.\n\nFirst, I need to model this. Let's think about how to construct a graph with minimal nodes to achieve exactly p such pairs.\n\nWhat's the structure that gives the maximum number of mutual pairs? Well, a complete DAG where each component is a single strongly connected component (SCC). Because in such a case, each pair within the SCC contributes to p. So, the more nodes in an SCC, the more such pairs.\n\nWait, but for a directed graph, an SCC is a maximal subset where every node can reach every other. So, in an SCC of size k, the number of such pairs is C(k, 2), since for every u < v in the SCC, (u, v) is counted once.\n\nBut wait, in a directed graph, the number of such ordered pairs (u, v) where u < v and u can reach v and v can reach u is equal to the number of edges in the underlying undirected graph of the SCC, except that it's the number of edges in the transitive reduction. No, wait, maybe not. Actually, in an SCC, any pair u, v can reach each other, regardless of direction. So the number of such ordered pairs is the number of unordered pairs in the SCC, which is C(k, 2).\n\nSo, each SCC contributes C(k, 2) to p.\n\nTherefore, the total p is the sum over all SCCs",
    "response": "To solve this problem, we need to determine the minimum number of nodes required to create a p-reachable directed graph and then find the maximum number of unidirectional pairs among such graphs.\n\n### Approach\n1. **Understanding p-reachable Graphs**: A p-reachable graph has exactly `p` ordered pairs `(u, v)` such that `u < v`, `u` can reach `v`, and `v` can reach `u`. This means each pair contributes to `p`.\n\n2. **Constructing the Graph**: To minimize the number of nodes, we should use strongly connected components (SCCs). Each SCC of size `k` contributes `C(k, 2)` pairs to `p`. We need to find the smallest number of nodes such that the sum of these contributions equals `p`.\n\n3. **Finding Minimum Nodes**: The minimal number of nodes is determined by finding the largest possible `k` such that the sum of combinations `C(k_i, 2)` for each SCC equals `p`.\n\n4. **Maximizing Unidirectional Pairs**: Among all such graphs with the minimum nodes, we need to maximize the number of unidirectional pairs. This is achieved by arranging the graph into as few SCCs as possible, each as large as possible.\n\n### Solution Code\n```python\nimport math\n\ndef compute_min_nodes(p):\n    if p == 0:\n        return (0, 0)\n    \n    # Find the maximal k where C(k,2) <= p\n    k = 1\n    while True:\n        cnt = k * (k - 1) // 2\n        if cnt > p:\n            break\n        k += 1\n    \n    # Now, find the minimal number of nodes\n    remaining = p\n    min_nodes = k\n    sccs = []\n    while remaining > 0:\n        max_possible = k\n        take = min(remaining, max_possible * (max_possible - 1) // 2)\n        sccs.append(take)\n        remaining -= take\n        if take == 0:\n            break\n        k -= 1\n    \n    # If we have some remaining, add another SCC\n    if remaining > 0:\n        sccs.append(remaining)\n        min_nodes += 1\n    \n    # Wait, perhaps I made a mistake in the above logic. Let's think again.\n    # Another approach: the minimal nodes is the largest k where C(k,2) <= p, but maybe adding smaller SCCs can give more.\n    # For example, if p is not a perfect triangle number.\n    # Alternative approach: find the largest k where C(k,2) <= p, then see how much more is needed.\n    # Let's re-calculate correctly.\n\n    # Find the maximum m such that m*(m-1)/2 <= p\n    m = 1\n    while True:\n        cm = m * (m - 1) // 2\n        if cm > p:\n            m -= 1\n            break\n        else:\n            m += 1\n    \n    total = 0\n    count = 0\n    current_m = m\n    while total < p:\n        contribution = current_m * (current_m - 1) // 2\n        if contribution == 0:\n            break\n        take = min(contribution, p - total)\n        count += 1\n        total += take\n        if take < contribution:\n            current_m -= 1\n    \n    # If after that, total is less than p, we need to add individual nodes\n    if total < p:\n        count += 1\n        total += p - total\n    \n    # So the minimal nodes is count + (if there's any leftover)\n    # Wait no, because each take is C(m, 2), which is the number of pairs in an SCC of size m+1.\n    # Hmm, perhaps my initial approach was incorrect. Let's think differently.\n\n    # The minimal number of nodes is the smallest n such that the sum of C(k_i, 2) >= p.\n    # But wait, we need exactly p. So perhaps the minimal nodes is the smallest n where the sum of C(k_i, 2) is >= p, but we might need to adjust.\n\n    # Alternatively, perhaps the minimal number of nodes is the smallest n where the sum of C(k_i, 2) over i is exactly p.\n\n    # Let me think about small examples.\n\n    # For example, when p=3: the maximum C(k,2) <=3 is k=3, C(3,2)=3. So one SCC of size 3 gives exactly 3, so min nodes is 3.\n\n    # When p=4: C(3,2)=3 <4, so we need one more. So either add another SCC of size 2 (which contributes 1), making total 4. So nodes would be 3+2=5? Or perhaps another way.\n\n    # Wait, but let me think again. How do I model this?\n\n    # Let me consider that each SCC of size m contributes C(m,2) to p. So the minimal number of nodes is the minimal number such that the sum of C(m_i, 2) equals p.\n\n    # So to minimize the number of nodes, we should maximize the size of each SCC.\n\n    # So, for p=4:\n\n    # The largest C(m,2) <=4 is m=3, C(3,2)=3. Then, remaining is 1. So we can add an SCC of size 2, which contributes 1. So total nodes 3+2=5.\n\n    # For p=6: C(4,2)=6, so one SCC of size 4, nodes=4.\n\n    # So, the approach is to find the maximum m where C(m,2) <=p. Then, subtract that from p, and see if we can form other SCCs.\n\n    # So, here's the algorithm:\n\n    # 1. Find the largest m where C(m,2) <= p.\n\n    # 2. Subtract C(m,2) from p, call it rem.\n\n    # 3. If rem is zero, the minimal nodes is m.\n\n    # 4. Else, the rem must be formed by adding smaller SCCs. Since each new SCC of size k contributes C(k,2).\n\n    #   For rem, the minimal way is to take the next possible k, which is m-1.\n\n    #   So, if rem can be formed by C(k,2) for k <= m-1, then add one more SCC of size k.\n\n    #   If not, perhaps multiple smaller SCCs are needed.\n\n    # Wait, but what's the minimal number of nodes? Because each new SCC uses more nodes but contributes less to p.\n\n    # Hmm, perhaps the minimal nodes can be found by finding the largest m where C(m,2) <= p, then check if the remaining can be covered by adding another SCC of size m-1.\n\n    # For example, p=4:\n\n    # m=3, C(3,2)=3. rem=1.\n\n    # Can rem=1 be formed by C(k,2) where k<=2? Yes, k=2, C(2,2)=1. So add one more SCC of size 2. Total nodes=3+2=5.\n\n    # For p=5:\n\n    # m=3, C(3,2)=3. rem=2.\n\n    # Can rem=2 be formed by C(k,2)? Yes, k=2, C(2,2)=1, but rem is 2, which requires two such contributions. So, we need two SCCs of size 2. But each contributes 1, so 1+1=2. So total nodes=3+2+2=7.\n\n    # Wait, but wait: 3+2+2 is 7 nodes, but maybe a better arrangement exists.\n\n    # Alternatively, perhaps it's better to have one SCC of size 3 (contributing 3) and another of size 3 (another 3), but that would exceed p=5. No.\n\n    # So, for p=5, minimal nodes is 3 + 2*2=7.\n\n    # So the approach is:\n\n    # Find the largest m where C(m,2) <= p.\n\n    # rem = p - C(m,2)\n\n    # if rem ==0: nodes = m\n\n    # else:\n\n    #   try to find the largest k where C(k,2) <= rem.\n\n    #   if such k exists, add k nodes, and total nodes is m + k.\n\n    #   else, add 1 node and increase rem by C(1,2)=0, which doesn't help. So perhaps we need to split into multiple smaller SCCs.\n\n    # Wait, but C(k,2) is the number of pairs contributed by an SCC of size k. So for rem=1, we can take k=2, which contributes 1. For rem=2, we can take two k=2, each contributing 1, so total 2.\n\n    # So the minimal nodes for p=5 is 3 (from C(3,2)=3) plus 2*2=4 nodes, totaling 7.\n\n    # So the general approach is:\n\n    # Find the largest m where C(m,2) <= p.\n\n    # rem = p - C(m,2)\n\n    # if rem ==0: nodes = m\n\n    # else:\n\n    #   for each possible k starting from m-1 down to 2:\n\n    #       if C(k,2) <= rem:\n\n    #           add k nodes, rem -= C(k,2)\n\n    #           if rem ==0: break\n\n    #       else:\n\n    #           continue\n\n    #   if rem >0:\n\n    #       add 1 node (since C(1,2)=0, but we can't contribute anything else)\n\n    # So the minimal nodes is m + sum of added k's.\n\n    # Now, let's implement this.\n\n    # Compute m:\n\n    m = 1\n\n    while True:\n\n        cm = m * (m-1) // 2\n\n        if cm > p:\n\n            m -=1\n\n            break\n\n        else:\n\n            m +=1\n\n    # Now, m is the largest where C(m,2) <= p.\n\n    rem = p - (m * (m-1) // 2)\n\n    if rem ==0:\n\n        min_nodes = m\n\n    else:\n\n        # Try to take the largest possible k for rem.\n\n        # Start from m-1 down to 2.\n\n        added = 0\n\n        for k in range(m-1, 1, -1):\n\n            ck = k * (k-1) // 2\n\n            if ck <= rem:\n\n                added += k\n\n                rem -= ck\n\n                if rem ==0:\n\n                    break\n\n        if rem >0:\n\n            added +=1\n\n        min_nodes = m + added\n\n    # Now, for the second part: maximum unidirectional pairs.\n\n    # The maximum unidirectional pairs is achieved by having as many edges as possible pointing in one direction within the SCCs.\n\n    # Wait, no: unidirectional pairs are those where (u, v) is present but (v, u) is not. So in a single SCC, since all pairs are bidirectional, there are zero unidirectional pairs.\n\n    # Therefore, to maximize unidirectional pairs, the graph should consist of as many directed edges as possible without forming mutual connections.\n\n    # Wait, but the problem requires that the graph is p-reachable, which requires certain mutual pairs.\n\n    # So, to maximize unidirectional pairs, the graph should have as many edges as possible going in one direction, while still maintaining the required p pairs.\n\n    # Hmm, this seems tricky.\n\n    # Let's think about the structure that maximizes unidirectional pairs.\n\n    # Suppose we have a DAG where each node points to all higher-numbered nodes. Then, each node u has edges to v for v > u, but no edges back. In this case, the number of bidirectional pairs is zero, but the number of unidirectional pairs is high.\n\n    # However, in our case, the graph must have p bidirectional pairs. So perhaps we can arrange the graph such that as many edges as possible are unidirectional outside of the required p pairs.\n\n    # Wait, but the p pairs are the ones that are bidirectional. So to maximize unidirectional pairs, we want as few edges as possible between the nodes not part of the p pairs.\n\n    # So, perhaps the optimal structure is a complete DAG where all the p pairs are in a single SCC, and the rest of the graph is arranged to have as many edges as possible pointing in one direction.\n\n    # Wait, perhaps the maximum number of unidirectional pairs is achieved when the graph is a transitive tournament on the minimal nodes. But I'm not sure.\n\n    # Alternatively, perhaps the maximum number of unidirectional pairs is equal to the total possible edges minus the edges in the SCCs.\n\n    # Let's consider the total possible edges in a directed graph with n nodes: n*(n-1).\n\n    # The edges in the SCCs: each SCC of size k contributes k*(k-1) edges (since every pair is bidirectional, but in a directed graph, each edge is counted once in each direction). Wait, no: in a directed graph, each edge is counted once. So for a strongly connected component of size k, the number of edges is at least k (like a cycle), but could be more. However, to maximize unidirectional pairs, we need as few edges as possible within the SCCs and as many as possible outside.\n\n    # Wait, but the p pairs are the number of bidirectional pairs (u, v) where u < v and both can reach each other. So, for each such pair, there must be at least two edges: u→v and v→u.\n\n    # So, to maximize unidirectional pairs, we should minimize the number of edges within the SCCs beyond the necessary ones for reachability, and maximize the edges outside the SCCs in a way that creates as many unidirectional pairs as possible.\n\n    # This is getting complicated. Perhaps the maximum number of unidirectional pairs is simply the total possible edges minus twice the number of bidirectional edges (since each bidirectional edge contributes two directed edges).\n\n    # Wait, no. Let me clarify:\n\n    # Each bidirectional pair (u, v) adds two edges: u→v and v→u. So, the number of directed edges in the SCC is 2 * C(k, 2), where C(k, 2) is the number of bidirectional pairs.\n\n    # The total possible directed edges in a graph with n nodes is n*(n-1).\n\n    # So, the number of directed edges in the SCCs is sum_{i} 2*C(s_i, 2), where s_i is the size of each SCC.\n\n    # The number of unidirectional pairs is the total directed edges minus the edges in the SCCs minus the edges in the unidirectional parts.\n\n    # Wait, no. Let me think differently.\n\n    # Each edge is either part of a bidirectional pair or an unidirectional pair.\n\n    # For the edges in the SCCs, each bidirectional pair contributes two directed edges. So, for each SCC of size k, there are k*(k-1) directed edges (since every pair is bidirectional, requiring two edges).\n\n    # For the non-SCC edges, they can be arranged in a way that maximizes unidirectional pairs. That is, we can arrange them as a DAG where each edge points in one direction, creating as many unidirectional pairs as possible.\n\n    # So, the maximum number of unidirectional pairs is:\n\n    # Total directed edges - 2 * sum(C(k_i, 2)) \n\n    # Because each bidirectional pair contributes two edges, and the rest are unidirectional, contributing one each.\n\n    # Wait, no. Wait, in a directed graph, the number of directed edges is E. The number of bidirectional edges is B, each contributing two directed edges. The number of unidirectional edges is U, each contributing one.\n\n    # So, E = 2B + U.\n\n    # The total possible directed edges is n*(n-1). So, U = E - 2B.\n\n    # But the problem is that the graph is not necessarily a complete graph, so E could be less than n*(n-1). So, to maximize U, we need to maximize E while minimizing B.\n\n    # But how?\n\n    # Hmm, perhaps the maximum number of unidirectional pairs is achieved when the graph is a transitive tournament on the minimal nodes, except for the required p pairs.\n\n    # Alternatively, perhaps the maximum unidirectional pairs is the total possible edges in a complete DAG minus the edges required for the p pairs.\n\n    # I'm not entirely sure, but perhaps the formula can be derived as follows:\n\n    # The maximum number of unidirectional pairs is (total_possible_edges - 2 * p).\n\n    # Because each of the p pairs contributes two edges (u→v and v→u), and the rest of the edges can be arranged in a way that maximizes unidirectional pairs.\n\n    # Let's test this with the example given.\n\n    # Example 1:\n\n    # Input: 3\n\n    # Output: 3 0\n\n    # Explanation: The graph has 3 nodes forming a single SCC, contributing 3 bidirectional pairs. The total possible edges is 3*2=6. So, the number of unidirectional edges is 6 - 2*3 =0.\n\n    # Which matches the output.\n\n    # Example 2:\n\n    # Input:4\n\n    # Output:5 6\n\n    # Let's see:\n\n    # Minimal nodes is 5.\n\n    # The p is 4. So the number of bidirectional pairs is 4.\n\n    # Total possible edges:5*4=20.\n\n    # So, unidirectional edges:20 - 2*4=12. But the output is 6.\n\n    # Wait, this contradicts the hypothesis.\n\n    # Wait, perhaps the formula is not correct.\n\n    # Let me think again. Maybe the maximum unidirectional pairs is the number of edges in the DAG part, which is a transitive tournament.\n\n    # So, for minimal nodes, after building the required SCCs, the rest of the edges can be arranged as a DAG where each edge points in one direction, contributing to unidirectional pairs.\n\n    # So, the maximum unidirectional pairs is the number of edges in the DAG part, which is a complete DAG.\n\n    # So, the total unidirectional pairs is the number of edges in the DAG.\n\n    # So, for the example where p=4 and minimal nodes is5:\n\n    # The graph has one SCC of size3 (contributing 3 bidirectional pairs) and one SCC of size2 (contributing1). So p=4.\n\n    # The total possible edges is5*4=20.\n\n    # The edges in the SCCs:3*2=6 (for size3) and 2*1=2 (for size2). So total edges in SCCs is8.\n\n    # So, the remaining edges are 20-8=12. These 12 edges can be arranged as unidirectional, giving 12 unidirectional pairs.\n\n    # But the sample output says6.\n\n    # Wait, this suggests that the formula is incorrect.\n\n    # Let me check the sample input:\n\n    # For p=4, the output is5 nodes and6 unidirectional pairs.\n\n    # So, in this case, the maximum unidirectional pairs is6.\n\n    # So, how is that possible?\n\n    # Let's think about the structure.\n\n    # The graph has 5 nodes. One SCC of size3 (nodes1,2,3), which forms a cycle, contributing3 bidirectional pairs. Another SCC of size2 (nodes4,5), contributing1 bidirectional pair. So total p=4.\n\n    # Now, the edges between the SCCs: we can have edges from the larger SCC to the smaller, but to maximize unidirectional pairs, we should arrange them in a way that as many edges as possible go one way.\n\n    # So, edges from SCC3 to SCC2 can be all directed one way, say from3 to4, 3 to5, 2 to4, 2 to5, 1 to4, 1 to5. So 6 edges, all unidirectional.\n\n    # Thus, the unidirectional pairs are6.\n\n    # So, the maximum unidirectional pairs is the number of edges between the SCCs, arranged in a way that they are all unidirectional.\n\n    # So, in this case, the number of edges between the two SCCs is3*2=6, all unidirectional.\n\n    # So, the maximum unidirectional pairs is the product of the sizes of the two SCCs, plus any edges within their own SCCs that are unidirectional.\n\n    # Wait, but within the SCCs, all edges are bidirectional, contributing to the p count.\n\n    # So, the unidirectional pairs come only from the edges between the SCCs, arranged as unidirectional.\n\n    # So, the maximum unidirectional pairs is the sum over all pairs of SCCs, multiplying the size of one by the size of the other, and summing all such products.\n\n    # Wait, but that would be the number of possible edges between the SCCs. If we arrange them all in one direction, that's the maximum unidirectional pairs.\n\n    # So, the formula for maximum unidirectional pairs is the sum for each pair of SCCs A and B, of |A| * |B|.\n\n    # Because each edge between A and B can be directed from A to B, contributing |A|*|B| unidirectional pairs.\n\n    # So, the maximum unidirectional pairs is the sum over all i < j of (size_i * size_j).\n\n    # Because in a DAG, you can arrange all edges from smaller-indexed components to larger-indexed components, maximizing the number of unidirectional pairs.\n\n    # So, the steps to compute the maximum unidirectional pairs are:\n\n    # 1. After determining the minimal nodes and the sizes of each SCC, compute the sum of the product of sizes of each pair of SCCs.\n\n    # For example, if the SCCs are of sizes a, b, c, then the maximum unidirectional pairs is a*b + a*c + b*c.\n\n    # So, for the sample p=4, the sizes are3 and2. So 3*2=6, which matches the output.\n\n    # For p=3, the sizes are3. So no pairs of different SCCs, so the maximum unidirectional pairs is0.\n\n    # So, the plan is:\n\n    # - Determine the minimal nodes and the sizes of each SCC.\n\n    # - Compute the sum of the product of the sizes of each pair of SCCs.\n\n    # So, in code, after computing the sizes of each SCC, we can calculate the sum of the products.\n\n    # Now, implementing this.\n\n    # Function to compute the minimal nodes:\n\n    def compute_min_nodes(p):\n        if p ==0:\n            return (0,0)\n        m=1\n        while True:\n            cm = m*(m-1)//2\n            if cm > p:\n                m-=1\n                break\n            else:\n                m +=1\n        rem = p - (m*(m-1)//2)\n        if rem ==0:\n            min_nodes = m\n        else:\n            added =0\n            for k in range(m-1, 1, -1):\n                ck = k*(k-1)//2\n                if ck <= rem:\n                    added +=k\n                    rem -=ck\n                    if rem ==0:\n                        break\n            if rem >0:\n                added +=1\n            min_nodes = m + added\n        return min_nodes\n\n    # Now, function to compute the maximum unidirectional pairs.\n\n    def compute_max_unidirectional(sizes):\n        res =0\n        for i in range(len(sizes)):\n            for j in range(i+1, len(sizes)):\n                res += sizes[i] * sizes[j]\n        return res\n\n    # Now, putting it all together.\n\n    p = int(input().strip())\n    if p ==0:\n        print(\"0 0\")\n        exit()\n\n    # Compute minimal nodes.\n    m =1\n    while True:\n        cm = m*(m-1)//2\n        if cm > p:\n            m -=1\n            break\n        else:\n            m +=1\n    rem = p - (m*(m-1)//2)\n    if rem ==0:\n        min_nodes = m\n    else:\n        added =0\n        for k in range(m-1, 1, -1):\n            ck = k*(k-1)//2\n            if ck <= rem:\n                added +=k\n                rem -=ck\n                if rem ==0:\n                    break\n        if rem >0:\n            added +=1\n        min_nodes = m + added\n\n    # Compute the sizes of each SCC.\n    # For minimal nodes, the sizes are the largest possible first, then smaller.\n    # So, the sizes list is constructed as [m, k1, k2, ...], where each ki is as large as possible.\n\n    # So, for example, for p=4, sizes are [3,2].\n\n    # To construct the sizes list:\n\n    # Initialize sizes list with m.\n    sizes = [m]\n    rem = p - (m*(m-1)//2)\n    if rem !=0:\n        # Now, find the next possible k.\n        k = m-1\n        while True:\n            ck = k*(k-1)//2\n            if ck <= rem:\n                sizes.append(k)\n                rem -= ck\n                if rem ==0:\n                    break\n                k -=1\n            else:\n                # Take as much as possible.\n                take = min(rem, k*(k-1)//2)\n                sizes.append(take)\n                rem -= take\n                break\n        if rem >0:\n            # Add 1 more, but it contributes 0 to p.\n            sizes.append(1)\n    else:\n        # rem is 0, no more.\n        pass\n\n    # Now, compute the maximum unidirectional pairs.\n    max_uni = 0\n    for i in range(len(sizes)):\n        for j in range(i+1, len(sizes)):\n            max_uni += sizes[i] * sizes[j]\n\n    print(f\"{min_nodes} {max_uni}\")\n\n### Explanation\nThe solution involves two main parts: determining the minimum number of nodes required and finding the maximum number of unidirectional pairs. The minimal nodes are calculated by finding the largest SCC size that contributes to `p` and then adding smaller SCCs as needed. The maximum unidirectional pairs are computed by considering the sum of products of sizes of each pair of SCCs.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef compute_min_nodes(p):\n    if p == 0:\n        return (0, 0)\n    \n    # Find the maximal k where C(k,2) <= p\n    k = 1\n    while True:\n        cnt = k * (k - 1) // 2\n        if cnt > p:\n            break\n        k += 1\n    \n    # Now, find the minimal number of nodes\n    remaining = p\n    min_nodes = k\n    sccs = []\n    while remaining > 0:\n        max_possible = k\n        take = min(remaining, max_possible * (max_possible - 1) // 2)\n        sccs.append(take)\n        remaining -= take\n        if take == 0:\n            break\n        k -= 1\n    \n    # If we have some remaining, add another SCC\n    if remaining > 0:\n        sccs.append(remaining)\n        min_nodes += 1\n    \n    # Wait, perhaps I made a mistake in the above logic. Let's think again.\n    # Another approach: the minimal nodes is the largest k where C(k,2) <= p, but maybe adding smaller SCCs can give more.\n    # For example, if p is not a perfect triangle number.\n    # Alternative approach: find the largest k where C(k,2) <= p, then see how much more is needed.\n    # Let's re-calculate correctly.\n\n    # Find the maximum m such that m*(m-1)/2 <= p\n    m = 1\n    while True:\n        cm = m * (m - 1) // 2\n        if cm > p:\n            m -= 1\n            break\n        else:\n            m += 1\n    \n    total = 0\n    count = 0\n    current_m = m\n    while total < p:\n        contribution = current_m * (current_m - 1) // 2\n        if contribution == 0:\n            break\n        take = min(contribution, p - total)\n        count += 1\n        total += take\n        if take < contribution:\n            current_m -= 1\n    \n    # If after that, total is less than p, we need to add individual nodes\n    if total < p:\n        count += 1\n        total += p - total\n    \n    # So the minimal nodes is count + (if there's any leftover)\n    # Wait no, because each take is C(m, 2), which is the number of pairs in an SCC of size m+1.\n    # Hmm, perhaps my initial approach was incorrect. Let's think differently.\n\n    # The minimal number of nodes is the smallest n such that the sum of C(k_i, 2) >= p.\n    # But wait, we need exactly p. So perhaps the minimal nodes is the smallest n where the sum of C(k_i, 2) is >= p, but we might need to adjust.\n\n    # Alternatively, perhaps the minimal number of nodes is the smallest n where the sum of C(k_i, 2) over i is exactly p.\n\n    # Let me think about small examples.\n\n    # For example, when p=3: the maximum C(k,2) <=3 is k=3, C(3,2)=3. So one SCC of size 3 gives exactly 3, so min nodes is 3.\n\n    # When p=4: C(3,2)=3 <4, so we need one more. So either add another SCC of size 2 (which contributes 1), making total 4. So nodes would be 3+2=5? Or perhaps another way.\n\n    # Wait, but let me think again. How do I model this?\n\n    # Let me consider that each SCC of size m contributes C(m,2) to p. So the minimal number of nodes is the minimal number such that the sum of C(m_i, 2) equals p.\n\n    # So to minimize the number of nodes, we should maximize the size of each SCC.\n\n    # So, for p=4:\n\n    # The largest C(m,2) <=4 is m=3, C(3,2)=3. Then, remaining is 1. So we can add an SCC of size 2, which contributes 1. So total nodes 3+2=5.\n\n    # For p=6: C(4,2)=6, so one SCC of size 4, nodes=4.\n\n    # So, the approach is to find the maximum m where C(m,2) <=p. Then, subtract that from p, and see if we can form other SCCs.\n\n    # So, here's the algorithm:\n\n    # 1. Find the largest m where C(m,2) <= p.\n\n    # 2. Subtract C(m,2) from p, call it rem.\n\n    # 3. If rem is zero, the minimal nodes is m.\n\n    # 4. Else, the rem must be formed by adding smaller SCCs. Since each new SCC of size k contributes C(k,2).\n\n    #   For rem, the minimal way is to take the next possible k, which is m-1.\n\n    #   So, if rem can be formed by C(k,2) for k <= m-1, then add one more SCC of size k.\n\n    #   If not, perhaps multiple smaller SCCs are needed.\n\n    # Wait, but what's the minimal number of nodes? Because each new SCC uses more nodes but contributes less to p.\n\n    # Hmm, perhaps the minimal nodes can be found by finding the largest m where C(m,2) <= p, then check if the remaining can be covered by adding another SCC of size m-1.\n\n    # For example, p=4:\n\n    # m=3, C(3,2)=3. rem=1.\n\n    # Can rem=1 be formed by C(k,2) where k<=2? Yes, k=2, C(2,2)=1. So add one more SCC of size 2. Total nodes=3+2=5.\n\n    # For p=5:\n\n    # m=3, C(3,2)=3. rem=2.\n\n    # Can rem=2 be formed by C(k,2)? Yes, k=2, C(2,2)=1, but rem is 2, which requires two such contributions. So, we need two SCCs of size 2. But each contributes 1, so 1+1=2. So total nodes=3+2+2=7.\n\n    # Wait, but wait: 3+2+2 is 7 nodes, but maybe a better arrangement exists.\n\n    # Alternatively, perhaps it's better to have one SCC of size 3 (contributing 3) and another of size 3 (another 3), but that would exceed p=5. No.\n\n    # So, for p=5, minimal nodes is 3 + 2*2=7.\n\n    # So the approach is:\n\n    # Find the largest m where C(m,2) <= p.\n\n    # rem = p - C(m,2)\n\n    # if rem ==0: nodes = m\n\n    # else:\n\n    #   try to find the largest k where C(k,2) <= rem.\n\n    #   if such k exists, add k nodes, and total nodes is m + k.\n\n    #   else, add 1 node and increase rem by C(1,2)=0, which doesn't help. So perhaps we need to split into multiple smaller SCCs.\n\n    # Wait, but C(k,2) is the number of pairs contributed by an SCC of size k. So for rem=1, we can take k=2, which contributes 1. For rem=2, we can take two k=2, each contributing 1, so total 2.\n\n    # So the minimal nodes for p=5 is 3 (from C(3,2)=3) plus 2*2=4 nodes, totaling 7.\n\n    # So the general approach is:\n\n    # Find the largest m where C(m,2) <= p.\n\n    # rem = p - C(m,2)\n\n    # if rem ==0: nodes = m\n\n    # else:\n\n    #   for each possible k starting from m-1 down to 2:\n\n    #       if C(k,2) <= rem:\n\n    #           add k nodes, rem -= C(k,2)\n\n    #           if rem ==0: break\n\n    #       else:\n\n    #           continue\n\n    #   if rem >0:\n\n    #       add 1 node (since C(1,2)=0, but we can't contribute anything else)\n\n    # So the minimal nodes is m + sum of added k's.\n\n    # Now, let's implement this.\n\n    # Compute m:\n\n    m = 1\n\n    while True:\n\n        cm = m * (m-1) // 2\n\n        if cm > p:\n\n            m -=1\n\n            break\n\n        else:\n\n            m +=1\n\n    # Now, m is the largest where C(m,2) <= p.\n\n    rem = p - (m * (m-1) // 2)\n\n    if rem ==0:\n\n        min_nodes = m\n\n    else:\n\n        # Try to take the largest possible k for rem.\n\n        # Start from m-1 down to 2.\n\n        added = 0\n\n        for k in range(m-1, 1, -1):\n\n            ck = k * (k-1) // 2\n\n            if ck <= rem:\n\n                added += k\n\n                rem -= ck\n\n                if rem ==0:\n\n                    break\n\n        if rem >0:\n\n            added +=1\n\n        min_nodes = m + added\n\n    # Now, for the second part: maximum unidirectional pairs.\n\n    # The maximum unidirectional pairs is achieved by having as many edges as possible pointing in one direction within the SCCs.\n\n    # Wait, no: unidirectional pairs are those where (u, v) is present but (v, u) is not. So in a single SCC, since all pairs are bidirectional, there are zero unidirectional pairs.\n\n    # Therefore, to maximize unidirectional pairs, the graph should consist of as many directed edges as possible without forming mutual connections.\n\n    # Wait, but the problem requires that the graph is p-reachable, which requires certain mutual pairs.\n\n    # So, to maximize unidirectional pairs, the graph should have as many edges as possible going in one direction, while still maintaining the required p pairs.\n\n    # Hmm, this seems tricky.\n\n    # Let's think about the structure that maximizes unidirectional pairs.\n\n    # Suppose we have a DAG where each node points to all higher-numbered nodes. Then, each node u has edges to v for v > u, but no edges back. In this case, the number of bidirectional pairs is zero, but the number of unidirectional pairs is high.\n\n    # However, in our case, the graph must have p bidirectional pairs. So perhaps we can arrange the graph such that as many edges as possible are unidirectional outside of the required p pairs.\n\n    # Wait, but the p pairs are the ones that are bidirectional. So to maximize unidirectional pairs, we want as few edges as possible between the nodes not part of the p pairs.\n\n    # So, perhaps the optimal structure is a complete DAG where all the p pairs are in a single SCC, and the rest of the graph is arranged to have as many edges as possible pointing in one direction.\n\n    # Wait, perhaps the maximum number of unidirectional pairs is achieved when the graph is a transitive tournament on the minimal nodes. But I'm not sure.\n\n    # Alternatively, perhaps the maximum number of unidirectional pairs is equal to the total possible edges minus the edges in the SCCs.\n\n    # Let's consider the total possible edges in a directed graph with n nodes: n*(n-1).\n\n    # The edges in the SCCs: each SCC of size k contributes k*(k-1) edges (since every pair is bidirectional, but in a directed graph, each edge is counted once in each direction). Wait, no: in a directed graph, each edge is counted once. So for a strongly connected component of size k, the number of edges is at least k (like a cycle), but could be more. However, to maximize unidirectional pairs, we need as few edges as possible within the SCCs and as many as possible outside.\n\n    # Wait, but the p pairs are the number of bidirectional pairs (u, v) where u < v and both can reach each other. So, for each such pair, there must be at least two edges: u→v and v→u.\n\n    # So, to maximize unidirectional pairs, we should minimize the number of edges within the SCCs beyond the necessary ones for reachability, and maximize the edges outside the SCCs in a way that creates as many unidirectional pairs as possible.\n\n    # This is getting complicated. Perhaps the maximum number of unidirectional pairs is simply the total possible edges minus twice the number of bidirectional edges (since each bidirectional edge contributes two directed edges).\n\n    # Wait, no. Let me clarify:\n\n    # Each bidirectional pair (u, v) adds two edges: u→v and v→u. So, the number of directed edges in the SCC is 2 * C(k, 2), where C(k, 2) is the number of bidirectional pairs.\n\n    # The total possible directed edges in a graph with n nodes is n*(n-1).\n\n    # So, the number of directed edges in the SCCs is sum_{i} 2*C(s_i, 2), where s_i is the size of each SCC.\n\n    # The number of unidirectional pairs is the total directed edges minus the edges in the SCCs minus the edges in the unidirectional parts.\n\n    # Wait, no. Let me think differently.\n\n    # Each edge is either part of a bidirectional pair or an unidirectional pair.\n\n    # For the edges in the SCCs, each bidirectional pair contributes two directed edges. So, for each SCC of size k, there are k*(k-1) directed edges (since every pair is bidirectional, requiring two edges).\n\n    # For the non-SCC edges, they can be arranged in a way that maximizes unidirectional pairs. That is, we can arrange them as a DAG where each edge points in one direction, creating as many unidirectional pairs as possible.\n\n    # So, the maximum number of unidirectional pairs is:\n\n    # Total directed edges - 2 * sum(C(k_i, 2)) \n\n    # Because each bidirectional pair contributes two edges, and the rest are unidirectional, contributing one each.\n\n    # Wait, no. Wait, in a directed graph, the number of directed edges is E. The number of bidirectional edges is B, each contributing two directed edges. The number of unidirectional edges is U, each contributing one.\n\n    # So, E = 2B + U.\n\n    # The total possible directed edges is n*(n-1). So, U = E - 2B.\n\n    # But the problem is that the graph is not necessarily a complete graph, so E could be less than n*(n-1). So, to maximize U, we need to maximize E while minimizing B.\n\n    # But how?\n\n    # Hmm, perhaps the maximum number of unidirectional pairs is achieved when the graph is a transitive tournament on the minimal nodes, except for the required p pairs.\n\n    # Alternatively, perhaps the maximum unidirectional pairs is the total possible edges in a complete DAG minus the edges required for the p pairs.\n\n    # I'm not entirely sure, but perhaps the formula can be derived as follows:\n\n    # The maximum number of unidirectional pairs is (total_possible_edges - 2 * p).\n\n    # Because each of the p pairs contributes two edges (u→v and v→u), and the rest of the edges can be arranged in a way that maximizes unidirectional pairs.\n\n    # Let's test this with the example given.\n\n    # Example 1:\n\n    # Input: 3\n\n    # Output: 3 0\n\n    # Explanation: The graph has 3 nodes forming a single SCC, contributing 3 bidirectional pairs. The total possible edges is 3*2=6. So, the number of unidirectional edges is 6 - 2*3 =0.\n\n    # Which matches the output.\n\n    # Example 2:\n\n    # Input:4\n\n    # Output:5 6\n\n    # Let's see:\n\n    # Minimal nodes is 5.\n\n    # The p is 4. So the number of bidirectional pairs is 4.\n\n    # Total possible edges:5*4=20.\n\n    # So, unidirectional edges:20 - 2*4=12. But the output is 6.\n\n    # Wait, this contradicts the hypothesis.\n\n    # Wait, perhaps the formula is not correct.\n\n    # Let me think again. Maybe the maximum unidirectional pairs is the number of edges in the DAG part, which is a transitive tournament.\n\n    # So, for minimal nodes, after building the required SCCs, the rest of the edges can be arranged as a DAG where each edge points in one direction, contributing to unidirectional pairs.\n\n    # So, the maximum unidirectional pairs is the number of edges in the DAG part, which is a complete DAG.\n\n    # So, the total unidirectional pairs is the number of edges in the DAG.\n\n    # So, for the example where p=4 and minimal nodes is5:\n\n    # The graph has one SCC of size3 (contributing 3 bidirectional pairs) and one SCC of size2 (contributing1). So p=4.\n\n    # The total possible edges is5*4=20.\n\n    # The edges in the SCCs:3*2=6 (for size3) and 2*1=2 (for size2). So total edges in SCCs is8.\n\n    # So, the remaining edges are 20-8=12. These 12 edges can be arranged as unidirectional, giving 12 unidirectional pairs.\n\n    # But the sample output says6.\n\n    # Wait, this suggests that the formula is incorrect.\n\n    # Let me check the sample input:\n\n    # For p=4, the output is5 nodes and6 unidirectional pairs.\n\n    # So, in this case, the maximum unidirectional pairs is6.\n\n    # So, how is that possible?\n\n    # Let's think about the structure.\n\n    # The graph has 5 nodes. One SCC of size3 (nodes1,2,3), which forms a cycle, contributing3 bidirectional pairs. Another SCC of size2 (nodes4,5), contributing1 bidirectional pair. So total p=4.\n\n    # Now, the edges between the SCCs: we can have edges from the larger SCC to the smaller, but to maximize unidirectional pairs, we should arrange them in a way that as many edges as possible go one way.\n\n    # So, edges from SCC3 to SCC2 can be all directed one way, say from3 to4, 3 to5, 2 to4, 2 to5, 1 to4, 1 to5. So 6 edges, all unidirectional.\n\n    # Thus, the unidirectional pairs are6.\n\n    # So, the maximum unidirectional pairs is the number of edges between the SCCs, arranged in a way that they are all unidirectional.\n\n    # So, in this case, the number of edges between the two SCCs is3*2=6, all unidirectional.\n\n    # So, the maximum unidirectional pairs is the product of the sizes of the two SCCs, plus any edges within their own SCCs that are unidirectional.\n\n    # Wait, but within the SCCs, all edges are bidirectional, contributing to the p count.\n\n    # So, the unidirectional pairs come only from the edges between the SCCs, arranged as unidirectional.\n\n    # So, the maximum unidirectional pairs is the sum over all pairs of SCCs, multiplying the size of one by the size of the other, and summing all such products.\n\n    # Wait, but that would be the number of possible edges between the SCCs. If we arrange them all in one direction, that's the maximum unidirectional pairs.\n\n    # So, the formula for maximum unidirectional pairs is the sum for each pair of SCCs A and B, of |A| * |B|.\n\n    # Because each edge between A and B can be directed from A to B, contributing |A|*|B| unidirectional pairs.\n\n    # So, the maximum unidirectional pairs is the sum over all i < j of (size_i * size_j).\n\n    # Because in a DAG, you can arrange all edges from smaller-indexed components to larger-indexed components, maximizing the number of unidirectional pairs.\n\n    # So, the steps to compute the maximum unidirectional pairs are:\n\n    # 1. After determining the minimal nodes and the sizes of each SCC, compute the sum of the product of sizes of each pair of SCCs.\n\n    # For example, if the SCCs are of sizes a, b, c, then the maximum unidirectional pairs is a*b + a*c + b*c.\n\n    # So, for the sample p=4, the sizes are3 and2. So 3*2=6, which matches the output.\n\n    # For p=3, the sizes are3. So no pairs of different SCCs, so the maximum unidirectional pairs is0.\n\n    # So, the plan is:\n\n    # - Determine the minimal nodes and the sizes of each SCC.\n\n    # - Compute the sum of the product of the sizes of each pair of SCCs.\n\n    # So, in code, after computing the sizes of each SCC, we can calculate the sum of the products.\n\n    # Now, implementing this.\n\n    # Function to compute the minimal nodes:\n\n    def compute_min_nodes(p):\n        if p ==0:\n            return (0,0)\n        m=1\n        while True:\n            cm = m*(m-1)//2\n            if cm > p:\n                m-=1\n                break\n            else:\n                m +=1\n        rem = p - (m*(m-1)//2)\n        if rem ==0:\n            min_nodes = m\n        else:\n            added =0\n            for k in range(m-1, 1, -1):\n                ck = k*(k-1)//2\n                if ck <= rem:\n                    added +=k\n                    rem -=ck\n                    if rem ==0:\n                        break\n            if rem >0:\n                added +=1\n            min_nodes = m + added\n        return min_nodes\n\n    # Now, function to compute the maximum unidirectional pairs.\n\n    def compute_max_unidirectional(sizes):\n        res =0\n        for i in range(len(sizes)):\n            for j in range(i+1, len(sizes)):\n                res += sizes[i] * sizes[j]\n        return res\n\n    # Now, putting it all together.\n\n    p = int(input().strip())\n    if p ==0:\n        print(\"0 0\")\n        exit()\n\n    # Compute minimal nodes.\n    m =1\n    while True:\n        cm = m*(m-1)//2\n        if cm > p:\n            m -=1\n            break\n        else:\n            m +=1\n    rem = p - (m*(m-1)//2)\n    if rem ==0:\n        min_nodes = m\n    else:\n        added =0\n        for k in range(m-1, 1, -1):\n            ck = k*(k-1)//2\n            if ck <= rem:\n                added +=k\n                rem -=ck\n                if rem ==0:\n                    break\n        if rem >0:\n            added +=1\n        min_nodes = m + added\n\n    # Compute the sizes of each SCC.\n    # For minimal nodes, the sizes are the largest possible first, then smaller.\n    # So, the sizes list is constructed as [m, k1, k2, ...], where each ki is as large as possible.\n\n    # So, for example, for p=4, sizes are [3,2].\n\n    # To construct the sizes list:\n\n    # Initialize sizes list with m.\n    sizes = [m]\n    rem = p - (m*(m-1)//2)\n    if rem !=0:\n        # Now, find the next possible k.\n        k = m-1\n        while True:\n            ck = k*(k-1)//2\n            if ck <= rem:\n                sizes.append(k)\n                rem -= ck\n                if rem ==0:\n                    break\n                k -=1\n            else:\n                # Take as much as possible.\n                take = min(rem, k*(k-1)//2)\n                sizes.append(take)\n                rem -= take\n                break\n        if rem >0:\n            # Add 1 more, but it contributes 0 to p.\n            sizes.append(1)\n    else:\n        # rem is 0, no more.\n        pass\n\n    # Now, compute the maximum unidirectional pairs.\n    max_uni = 0\n    for i in range(len(sizes)):\n        for j in range(i+1, len(sizes)):\n            max_uni += sizes[i] * sizes[j]\n\n    print(f\"{min_nodes} {max_uni}\")\n\n### Explanation\nThe solution involves two main parts: determining the minimum number of nodes required and finding the maximum number of unidirectional pairs. The minimal nodes are calculated by finding the largest SCC size that contributes to `p` and then adding smaller SCCs as needed. The maximum unidirectional pairs are computed by considering the sum of products of sizes of each pair of SCCs.",
    "score": -1,
    "metadata": {
        "prompt_token_count": 476,
        "completion_token_count": 5818,
        "thoughts_token_count": 1025
    }
}