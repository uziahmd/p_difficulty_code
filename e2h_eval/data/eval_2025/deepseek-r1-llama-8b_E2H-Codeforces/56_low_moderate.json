{
    "start": 1758278105.079031,
    "end": 1758278309.444062,
    "start-formatted": "2025-09-19 19:35 KST",
    "end-formatted": "2025-09-19 19:38 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read it carefully.\n\nThe problem is about assigning Rebel spaceships to guard B bases such that every base has exactly one guardian and each spaceship is assigned to exactly one base. So it's a perfect matching between R spaceships and B bases.\n\nBut the key constraint here is that the paths from a base to its spaceship shouldn't intersect any other path. These paths are straight lines in the galaxy plane. So, no two paths can cross each other.\n\nHmm, how to model this? I think this is similar to checking if a bipartite graph is such that all edges form non-crossing lines when drawn on a plane.\n\nWait, but how do we represent this condition? Because for any two edges (u1, v1) and (u2, v2), the lines connecting them shouldn't cross each other. So, if we have a matching where all these lines don't cross, then the answer is yes.\n\nSo the problem reduces to finding a perfect matching in a bipartite graph where the edges are such that their corresponding line segments do not cross each other.\n\nBut wait, how do I construct this bipartite graph? Because the edges are determined by the positions of the spaceships and bases.\n\nLet me think: Each spaceship is connected to certain bases via an edge if the line segment between them doesn't cross any other existing edges in the matching.\n\nWait, no. Actually, for a given matching, all the edges (lines) must not cross each other. So the entire set of edges in the matching must be non-crossing.\n\nSo, the approach is to find a perfect matching between spaceships and bases where all the edges are non-crossing.\n\nNow, the question is, how do I represent this condition in code?\n\nHmm, perhaps the problem can be modeled as follows:\n\n- The bipartite graph has R spaceships on one side and B bases on the other.\n- An edge exists between a spaceship S_i and base B_j if the line segment from S_i to B_j does not cross any other line segments in the matching.\n\nWait, but that's a bit circular because the presence of edges depends on the other edges. So, perhaps a better way is to model the problem as trying all possible perfect matchings and checking if any of them satisfy the non-crossing condition.\n\nBut with R and B up to 10, the maximum number of perfect matchings could be 10! / (5!5!) if R=10 and B=5, which is manageable. Wait, 10 choose 5 is 252, and then multiplied by 4! =24, giving 6048 possibilities. Hmm, that's acceptable for a brute-force approach.\n\nSo the plan is:\n\n1. Generate all possible perfect matchings between spaceships and bases.\n2. For each matching, check if all the corresponding line segments are non-crossing.\n3. If any such matching exists, output \"Yes\"; otherwise, output \"No\".\n\nSo the steps are:\n\n- Read the input: R and B, then R spaceship coordinates, then B base coordinates.\n- Generate all possible permutations of B bases, choosing exactly R of them (but wait, since R and B might not be equal. Oh right, the problem statement says it's a perfect matching, so R must equal B. Because each spaceship is assigned to exactly one base, and vice versa. So in the input, R and B are given, and they must be equal for a perfect matching to exist. Or wait, the problem says \"the assignment is a perfect matching\", so R must equal B. But the problem statement says \"1 ≤ R, B ≤ 10\". So the code should first check if R == B. Otherwise, it's impossible, output No.\n\nWait, looking back at the problem statement: It says \"the assignment is a perfect matching.\" So yes, R must equal B. So if R != B, the output is immediately No.\n\nSo the first thing to do is check if R == B. If not, output No.\n\nOtherwise, proceed.\n\nSo next, for each possible perfect matching (which is a bijection between spaceships and bases), we need to check if the corresponding line segments are non-crossing.\n\nHow to check if a set of line segments is non-crossing?\n\nFor a given matching, we can collect all the line segments (from each spaceship to its assigned base). Then, we need to ensure that no two segments cross each other.\n\nAn efficient way to check for non-crossing is to use the concept of monotonicity based on angles or order of points.\n\nAlternatively, another approach is to compute the convex hull of all points and see if the segments can be drawn without crossing. But I'm not sure.\n\nWait, perhaps a better way is to sort the line segments based on their endpoints and then check for any intersection.\n\nBut even that may be computationally expensive if done naively. Since the number of segments",
    "response": "To solve this problem, we need to determine if it is possible to assign Rebel spaceships to guard B bases such that each base has exactly one guardian and each spaceship is assigned to exactly one base. Additionally, the paths from each base to its assigned spaceship must not intersect any other paths.\n\n### Approach\n1. **Check for Perfect Matching**: First, check if the number of spaceships (R) is equal to the number of bases (B). If they are not equal, output \"No\" because a perfect matching is impossible.\n2. **Generate All Possible Perfect Matchings**: Since R and B can be up to 10, we can generate all possible permutations of bases to form a perfect matching with the spaceships. This is feasible as the maximum number of permutations is manageable.\n3. **Check for Non-Crossing Paths**: For each permutation (perfect matching), check if the corresponding line segments between spaceships and bases do not intersect. This can be done by ensuring that for any two segments, they do not cross each other in the plane.\n\n### Solution Code\n```python\nimport sys\nfrom itertools import permutations\n\ndef readints():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef cross(o, a, b):\n    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n\ndef segments_cross(s1, s2):\n    a, b = s1\n    c, d = s2\n    return cross(a, b, c) * cross(c, d, a) < 0\n\ndef main():\n    data = sys.stdin.read().split()\n    ptr = 0\n    R = int(data[ptr])\n    ptr += 1\n    B = int(data[ptr])\n    ptr += 1\n    spaceships = []\n    for _ in range(R):\n        x = int(data[ptr])\n        y = int(data[ptr+1])\n        spaceships.append((x, y))\n        ptr += 2\n    bases = []\n    for _ in range(B):\n        x = int(data[ptr])\n        y = int(data[ptr+1])\n        bases.append((x, y))\n        ptr += 2\n    if R != B:\n        print(\"No\")\n        return\n    for perm in permutations(bases):\n        match = {}\n        for i in range(R):\n            match[spaceships[i]] = perm[i]\n        segments = []\n        for s, b in match.items():\n            segments.append((s, b))\n        valid = True\n        for i in range(len(segments)):\n            for j in range(i+1, len(segments)):\n                if segments_cross(segments[i], segments[j]):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into coordinates for spaceships and bases.\n2. **Perfect Matching Check**: If the number of spaceships does not equal the number of bases, the answer is immediately \"No\".\n3. **Generating Permutations**: We use permutations to generate all possible ways to assign each spaceship to a base.\n4. **Checking Non-Crossing Segments**: For each permutation, we check if the line segments between spaceships and their assigned bases intersect. If any permutation is found where segments do not intersect, we print \"Yes\". If no such permutation exists, we print \"No\".\n\nThis approach efficiently checks all possible assignments and ensures that the constraints are met, providing a correct solution within feasible limits for the given problem constraints.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom itertools import permutations\n\ndef readints():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef cross(o, a, b):\n    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n\ndef segments_cross(s1, s2):\n    a, b = s1\n    c, d = s2\n    return cross(a, b, c) * cross(c, d, a) < 0\n\ndef main():\n    data = sys.stdin.read().split()\n    ptr = 0\n    R = int(data[ptr])\n    ptr += 1\n    B = int(data[ptr])\n    ptr += 1\n    spaceships = []\n    for _ in range(R):\n        x = int(data[ptr])\n        y = int(data[ptr+1])\n        spaceships.append((x, y))\n        ptr += 2\n    bases = []\n    for _ in range(B):\n        x = int(data[ptr])\n        y = int(data[ptr+1])\n        bases.append((x, y))\n        ptr += 2\n    if R != B:\n        print(\"No\")\n        return\n    for perm in permutations(bases):\n        match = {}\n        for i in range(R):\n            match[spaceships[i]] = perm[i]\n        segments = []\n        for s, b in match.items():\n            segments.append((s, b))\n        valid = True\n        for i in range(len(segments)):\n            for j in range(i+1, len(segments)):\n                if segments_cross(segments[i], segments[j]):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            print(\"Yes\")\n            return\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 463,
        "completion_token_count": 786,
        "thoughts_token_count": 1025
    }
}