{
    "start": 1758103766.8498743,
    "end": 1758103913.3547,
    "start-formatted": "2025-09-17 19:09 KST",
    "end-formatted": "2025-09-17 19:11 KST",
    "gpu": 2,
    "pid": 8,
    "use_openrouter": false,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Flawed Flow\n\nEmuskald considers himself a master of flow algorithms. Now he has completed his most ingenious program yet — it calculates the maximum flow in an undirected graph. The graph consists of n vertices and m edges. Vertices are numbered from 1 to n. Vertices 1 and n being the source and the sink respectively.However, his max-flow algorithm seems to have a little flaw — it only finds the flow volume for each edge, but not its direction. Help him find for each edge the direction of the flow through this edges. Note, that the resulting flow should be correct maximum flow.More formally. You are given an undirected graph. For each it's undirected edge (ai, bi) you are given the flow volume ci. You should direct all edges in such way that the following conditions hold:  for each vertex v (1 < v < n), sum of ci of incoming edges is equal to the sum of ci of outcoming edges;  vertex with number 1 has no incoming edges;  the obtained directed graph does not have cycles. \n\n## Input\nThe first line of input contains two space-separated integers n and m (2 ≤ n ≤ 2·105, n - 1 ≤ m ≤ 2·105), the number of vertices and edges in the graph. The following m lines contain three space-separated integers ai, bi and ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 1 ≤ ci ≤ 104), which means that there is an undirected edge from ai to bi with flow volume ci.It is guaranteed that there are no two edges connecting the same vertices; the given graph is connected; a solution always exists.\n\n## Output\nOutput m lines, each containing one integer di, which should be 0 if the direction of the i-th edge is ai → bi (the flow goes from vertex ai to vertex bi) and should be 1 otherwise. The edges are numbered from 1 to m in the order they are given in the input.If there are several solutions you can print any of them.\n\n## Example\n### Input\n['3 3\\n3 2 10\\n1 2 10\\n3 1 5', '4 5\\n1 2 10\\n1 3 10\\n2 3 5\\n4 2 15\\n3 4 5']\n\n### Output\n['1\\n0\\n1', '0\\n0\\n1\\n1\\n0']\n\n## Note\nIn the first test case, 10 flow units pass through path , and 5 flow units pass directly from source to sink: .\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "Okay, so I have this programming problem to solve. Let's read it carefully.\n\nThe problem is about determining the direction of each edge in a flow network such that the resulting graph satisfies certain conditions. The goal is to make sure that for each vertex v (except the source and sink), the sum of incoming edges equals the sum of outgoing edges. Also, the source has no incoming edges, and there are no cycles in the directed graph.\n\nHmm. So the input gives me an undirected graph with n vertices and m edges. Each edge has a capacity ci. I need to assign a direction to each edge (0 or 1, where 0 means ai→bi, 1 means bi→ai) such that all the conditions are met.\n\nWait, but how do I approach this? It feels like a maximum flow problem, but in this case, the directions are what's needed.\n\nWait, maybe I should model this as building a directed graph that's a DAG (no cycles) and satisfies the flow conservation at each internal node, except the source and sink which have constraints too.\n\nWait, the source is vertex 1 and the sink is vertex n. So for all other nodes, the sum of outgoing edges equals the sum of incoming edges. For the source, no incoming edges, so all its outgoing edges must balance accordingly. Similarly, the sink must have all its incoming edges sum up, but no outgoing.\n\nSo, perhaps the way to model this is to find a directed acyclic graph (DAG) where:\n\n- The source has all its edges directed away from it.\n- The sink has all its edges directed towards it.\n- All internal nodes have equal in-degree and out-degree, except for possibly the source and sink.\n\nWait, but the source can have any number of outgoing edges, but zero incoming. The sink can have any number of incoming edges, but zero outgoing.\n\nWait, no. Because for the source, since it's the start point, all edges leaving it contribute to the flow. But for the sink, all edges entering it contribute, and none leave because otherwise, they would create a cycle or violate the flow conservation.\n\nBut wait, in a standard max-flow setup, the sink can have multiple incoming edges but no outgoing ones. So perhaps the directed graph we're building is a DAG where edges are oriented such that the flow goes from the source to the sink, without any cycles.\n\nSo, how do I model this? Maybe using a BFS-like approach, starting from the source and assigning directions based on some criteria.\n\nAlternatively, think about the residual graph. In a flow network, the residual graph is used to find augmenting paths. The direction of the original edges determines the residual capacities. So perhaps the problem reduces to finding a way to orient the edges such that the residual graph has no cycles, and the flow is preserved.\n\nWait, but the problem says that the given graph is connected and that a solution exists. So perhaps the solution is to find a DAG where each edge is directed in a way that allows for a valid flow.\n\nAnother approach: Since the flow must be maximum, the edges' directions must form a DAG that allows for a maximum flow. Wait, but the problem doesn't mention the flow being maximum, just that the direction makes the flow correct. Oh wait, no: the note says that the resulting flow should be correct maximum flow. So perhaps the directions are part of the maximum flow's structure.\n\nWait, but the maximum flow algorithm computes the maximum possible flow, regardless of edge directions. But here, the directions are part of the problem's output, so perhaps the solution is to find a way to direct the edges such that the flow through them is consistent with a maximum flow.\n\nHmm. So the problem is similar to determining the residual graph of a maximum flow, but we have to construct it based on the given edges.\n\nWait, perhaps the way to do this is to compute the maximum flow first and then determine the direction of each edge in the residual graph.\n\nYes! Because the residual graph is a DAG when the flow is maximum. So if I compute the maximum flow, the residual graph will have no cycles and will represent the flow direction.\n\nWait, that makes sense. Because in a maximum flow, the residual graph has no augmenting paths, hence it's a DAG. So for each original edge (u, v) with flow c, if the residual is s, then the direction in the residual graph is u→v if s>0, meaning that the flow is going from u to v. Otherwise, it's v→u.\n\nWait, but in our problem, the edge's direction is determined by whether it's part of the flow's forward or backward path.\n\nSo the plan is:\n\n1. Compute the maximum flow from source (1) to sink (n) using a standard algorithm like Dinic's.\n2. For each edge, determine the direction based on whether the flow is in the forward or reverse direction in the residual graph.\n\nWait, but how does that help with",
    "response": "To solve this problem, we need to determine the direction of each edge in a flow network such that the resulting graph satisfies specific conditions. The goal is to ensure that for each vertex (except the source and sink), the sum of incoming edges equals the sum of outgoing edges, the source has no incoming edges, and the graph does not have cycles.\n\n### Approach\n1. **Problem Analysis**: The problem requires us to direct edges in an undirected graph such that the resulting directed graph (DAG) meets specific flow conservation conditions. The solution must ensure that the graph remains acyclic and correctly routes flow from the source to the sink.\n\n2. **Intuition**: The key insight is to model the problem using the concept of residual graphs from maximum flow algorithms. A maximum flow's residual graph is a DAG, which can be used to determine the direction of each edge.\n\n3. **Algorithm Selection**: We use Dinic's algorithm to compute the maximum flow from the source (vertex 1) to the sink (vertex n). This algorithm efficiently handles graphs with many vertices and edges, making it suitable for this problem.\n\n4. **Direction Determination**: After computing the maximum flow, we examine the residual graph. For each edge, if the residual capacity is positive, the edge direction is from the source to the sink in the original graph; otherwise, it is reversed.\n\n### Solution Code\n```python\nimport sys\nfrom collections import deque\n\nclass Edge:\n    def __init__(self, to, rev, capacity):\n        self.to = to\n        self.rev = rev\n        self.capacity = capacity\n\nclass Dinic:\n    def __init__(self, n):\n        self.size = n\n        self.graph = [[] for _ in range(n)]\n    \n    def add_edge(self, fr, to, cap):\n        forward = Edge(to, len(self.graph[to]), cap)\n        backward = Edge(fr, len(self.graph[fr]), 0)\n        self.graph[fr].append(forward)\n        self.graph[to].append(backward)\n    \n    def bfs_level(self, s, t, level):\n        q = deque()\n        level[:] = [-1] * self.size\n        level[s] = 0\n        q.append(s)\n        while q:\n            v = q.popleft()\n            for edge in self.graph[v]:\n                if edge.capacity > 0 and level[edge.to] == -1:\n                    level[edge.to] = level[v] + 1\n                    q.append(edge.to)\n                    if edge.to == t:\n                        return\n        return\n    \n    def dfs_flow(self, v, t, upTo, iter_, level):\n        if v == t:\n            return upTo\n        for i in range(iter_[v], len(self.graph[v])):\n            edge = self.graph[v][i]\n            if edge.capacity > 0 and level[v] < level[edge.to]:\n                d = self.dfs_flow(edge.to, t, min(upTo, edge.capacity), iter_, level)\n                if d > 0:\n                    edge.capacity -= d\n                    self.graph[edge.to][edge.rev].capacity += d\n                    return d\n            iter_[v] += 1\n        return 0\n    \n    def max_flow(self, s, t):\n        flow = 0\n        level = [-1] * self.size\n        while True:\n            self.bfs_level(s, t, level)\n            if level[t] == -1:\n                return flow\n            iter_ = [0] * self.size\n            while True:\n                f = self.dfs_flow(s, t, float('inf'), iter_, level)\n                if f == 0:\n                    break\n                flow += f\n            level = [-1] * self.size\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx +=1\n    m = int(input[idx])\n    idx +=1\n    edges = []\n    for _ in range(m):\n        a = int(input[idx])-1\n        idx +=1\n        b = int(input[idx])-1\n        idx +=1\n        c = int(input[idx])\n        idx +=1\n        edges.append( (a, b, c) )\n    \n    dinic = Dinic(n)\n    for a, b, c in edges:\n        dinic.add_edge(a, b, c)\n    \n    maxf = dinic.max_flow(0, n-1)\n    \n    for a, b, c in edges:\n        u = a\n        v = b\n        if dinic.graph[u][0].to == v and dinic.graph[u][0].capacity > 0:\n            print(0)\n        else:\n            print(1)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into vertices and edges.\n2. **Graph Construction**: Using Dinic's algorithm, we construct the graph and add edges with their respective capacities.\n3. **Max Flow Calculation**: Compute the maximum flow from the source to the sink using Dinic's algorithm.\n4. **Edge Direction Determination**: For each edge, determine its direction based on the residual graph. If the edge contributes to the forward flow, it is directed from the source to the sink; otherwise, it is reversed.\n\nThis approach ensures that the resulting directed graph is a valid DAG and satisfies all the given flow conservation conditions.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\nclass Edge:\n    def __init__(self, to, rev, capacity):\n        self.to = to\n        self.rev = rev\n        self.capacity = capacity\n\nclass Dinic:\n    def __init__(self, n):\n        self.size = n\n        self.graph = [[] for _ in range(n)]\n    \n    def add_edge(self, fr, to, cap):\n        forward = Edge(to, len(self.graph[to]), cap)\n        backward = Edge(fr, len(self.graph[fr]), 0)\n        self.graph[fr].append(forward)\n        self.graph[to].append(backward)\n    \n    def bfs_level(self, s, t, level):\n        q = deque()\n        level[:] = [-1] * self.size\n        level[s] = 0\n        q.append(s)\n        while q:\n            v = q.popleft()\n            for edge in self.graph[v]:\n                if edge.capacity > 0 and level[edge.to] == -1:\n                    level[edge.to] = level[v] + 1\n                    q.append(edge.to)\n                    if edge.to == t:\n                        return\n        return\n    \n    def dfs_flow(self, v, t, upTo, iter_, level):\n        if v == t:\n            return upTo\n        for i in range(iter_[v], len(self.graph[v])):\n            edge = self.graph[v][i]\n            if edge.capacity > 0 and level[v] < level[edge.to]:\n                d = self.dfs_flow(edge.to, t, min(upTo, edge.capacity), iter_, level)\n                if d > 0:\n                    edge.capacity -= d\n                    self.graph[edge.to][edge.rev].capacity += d\n                    return d\n            iter_[v] += 1\n        return 0\n    \n    def max_flow(self, s, t):\n        flow = 0\n        level = [-1] * self.size\n        while True:\n            self.bfs_level(s, t, level)\n            if level[t] == -1:\n                return flow\n            iter_ = [0] * self.size\n            while True:\n                f = self.dfs_flow(s, t, float('inf'), iter_, level)\n                if f == 0:\n                    break\n                flow += f\n            level = [-1] * self.size\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    n = int(input[idx])\n    idx +=1\n    m = int(input[idx])\n    idx +=1\n    edges = []\n    for _ in range(m):\n        a = int(input[idx])-1\n        idx +=1\n        b = int(input[idx])-1\n        idx +=1\n        c = int(input[idx])\n        idx +=1\n        edges.append( (a, b, c) )\n    \n    dinic = Dinic(n)\n    for a, b, c in edges:\n        dinic.add_edge(a, b, c)\n    \n    maxf = dinic.max_flow(0, n-1)\n    \n    for a, b, c in edges:\n        u = a\n        v = b\n        if dinic.graph[u][0].to == v and dinic.graph[u][0].capacity > 0:\n            print(0)\n        else:\n            print(1)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 659,
        "completion_token_count": 1128,
        "thoughts_token_count": 1025
    }
}