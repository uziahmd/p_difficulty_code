{
    "start": 1758299431.6370642,
    "end": 1758303128.13362,
    "start-formatted": "2025-09-20 01:30 KST",
    "end-formatted": "2025-09-20 02:32 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\n Okay, we are given an integer p (0 <= p <= 200000). We need to:\n 1. Find the minimum number of nodes n such that there exists a directed graph with n nodes that is p-reachable.\n    - Note: The graph must have exactly p ordered pairs (u, v) with u < v and u and v being mutually reachable.\n\n 2. Among all graphs with the minimum number of nodes that are p-reachable, find the maximum number of unidirectional pairs (u, v) (with u != v, a path from u to v but not from v to u).\n\n Observation for part 1:\n\n What does it mean for a directed graph to be p-reachable?\n    It has exactly p unordered pairs {u, v} (or ordered pairs (u, v) with u < v) that are mutually reachable.\n\n In a strongly connected component (SCC), every pair of nodes (u, v) with u < v is mutually reachable? \n    Actually, note: the condition is for u < v, but in the problem, the mutual reachability is defined for an unordered pair? \n    However, note the definition: \"an ordered pair (u, v) in a directed graph unidirectional if u≠v, there exists a path from u to v and no path from v to u.\"\n    And then: \"p-reachable if it contains exactly p ordered pairs of nodes (u, v) such that u < v and u and v are reachable from each other.\"\n\n But wait: the problem says \"exactly p ordered pairs (u, v) such that u < v\" meaning that we are counting the unordered pairs as one (since u < v) and requiring mutual reachability.\n\n So, if we have a set S of k nodes that form a strongly connected component, then the number of pairs (u, v) with u < v and mutual reachability within this component is C(k,2) = k*(k-1)//2.\n\n However, note: the entire graph might have multiple strongly connected components. The condition is that the graph is p-reachable, meaning the total number of such pairs (across the whole graph) is p.\n\n How can we arrange the graph so that the total number of mutual pairs is p?\n\n Consider: if we break the graph into strongly connected components (SCCs) and arrange them in a linear order (so that there is a directed edge from every node in an earlier component to every node in a later component, but not backwards), then two nodes are mutually reachable only if they are in the same SCC.\n\n Therefore, the total number of mutual pairs is the sum over each SCC of C(size_i, 2).\n\n Now, we want the graph to have exactly p mutual pairs (with u < v) and we want the minimum number of nodes.\n\n So, we are to represent p as a sum of triangular numbers: T(k) = k*(k-1)//2, and we want to use as few nodes as possible.\n\n But note: we can also have isolated nodes? Actually, if we have a node by itself, then it forms a component of size 1, which contributes 0. So we can ignore them for the count of mutual pairs. However, we are allowed to have multiple components. \n\n However, the problem requires the graph to be p-reachable, meaning exactly p pairs (each being a mutual pair). So we must have the sum of C(size_i, 2) over all components equal to p.\n\n We can choose the SCCs arbitrarily (and the rest of the graph structure as long as the mutual pairs are only within the SCCs). But note: the problem doesn't require the entire graph to be strongly connected, just that the mutual pairs (for u<v) are exactly p.\n\n So, we need to decompose p into a sum of distinct triangular numbers (but note: we can use the same triangular number multiple times? Actually, the components are independent. However, we cannot use the same node twice. Each node belongs to exactly one component.\n\n Therefore, we are to represent p as a sum of some triangular numbers (each triangular number corresponding to a component of size k, contributing T(k)).\n\n But note: the entire graph must be built on n nodes. The total number of nodes is the sum of the sizes of the SCCs.\n\n We want to minimize n (the total number of nodes) such that p can be written as the sum of T(k_i) for some positive integers k_i (each k_i>=1) and the sum of k_i is n.\n\n However, we are allowed to break the graph arbitrarily. But note: we cannot use a component of size k more than once? Actually, we can have multiple components of the same size.\n\n Example: p=3. \n   We can have two components: one of size 2 (contributing 1) and one of size 2 (contrib",
    "response": "\nTo solve this problem, we need to determine the minimum number of nodes required to create a directed graph that is exactly p-reachable, and among all such graphs with the minimum number of nodes, find the maximum number of unidirectional node pairs.\n\n### Approach\n1. **Understanding p-Reachable Graphs**: A directed graph is p-reachable if it contains exactly p ordered pairs (u, v) where u < v and u and v are mutually reachable. This means we need to decompose the integer p into a sum of triangular numbers (each triangular number T(k) = k*(k-1)/2 represents a strongly connected component of size k).\n\n2. **Minimizing Nodes**: The goal is to minimize the total number of nodes (sum of sizes of all components) while ensuring the sum of their triangular numbers equals p. This involves finding the smallest set of integers (component sizes) whose triangular numbers sum to p.\n\n3. **Maximizing Unidirectional Pairs**: For the graph with the minimum number of nodes, we need to maximize the number of unidirectional pairs. Unidirectional pairs exist between nodes in different components if there is a path from one component to another but not vice versa. The maximum number of such pairs is achieved when the components are arranged in a linear order, and edges are directed from earlier to later components.\n\n### Solution Code\n```python\ndef main():\n    p = int(input().strip())\n    \n    if p == 0:\n        print(\"0 0\")\n        return\n        \n    arr = []\n    n = 0\n    remaining = p\n    k = 1\n    while remaining > 0:\n        t_val = k * (k - 1) // 2\n        if t_val <= remaining:\n            remaining -= t_val\n            arr.append(k)\n            k += 1\n        else:\n            break\n            \n    total_nodes = sum(arr)\n    \n    # Now, to compute the maximum unidirectional pairs.\n    # The graph has several SCCs (with sizes given by arr). \n    # We arrange these components in a line (from left to right). \n    # Then, for each component i (with size s_i), the number of unidirectional pairs from its nodes to nodes in subsequent components is s_i * (total_nodes - s_i).\n    # But note: within each component, there are no unidirectional pairs (since they are strongly connected). Also, edges only go from left to right.\n    # Therefore, the total unidirectional pairs is the sum over all components of (size_i * (total_nodes - size_i)).\n    \n    total_unidirectional = 0\n    for size in arr:\n        total_unidirectional += size * (total_nodes - size)\n        \n    print(f\"{total_nodes} {total_unidirectional}\")\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Input Handling**: The code reads the integer `p` which represents the required number of mutual reachability pairs.\n2. **Special Case Handling**: If `p` is 0, the solution immediately outputs \"0 0\" since no nodes or edges are needed.\n3. **Triangular Number Decomposition**: The code decomposes `p` into a sum of triangular numbers by iteratively subtracting the largest possible triangular number from `p` until `p` is reduced to zero. Each triangular number corresponds to a component size in the graph.\n4. **Node Calculation**: The total number of nodes is the sum of all component sizes derived from the triangular decomposition.\n5. **Unidirectional Pairs Calculation**: For each component, the number of unidirectional pairs is calculated as the product of its size and the number of nodes outside it. Summing these products gives the total maximum unidirectional pairs in the graph.\n6. **Output**: The code prints the minimum number of nodes and the maximum number of unidirectional pairs.\n\nThis approach efficiently decomposes the problem into manageable parts, leveraging mathematical insights to minimize the graph's node count and maximize the desired unidirectional pairs.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    p = int(input().strip())\n    \n    if p == 0:\n        print(\"0 0\")\n        return\n        \n    arr = []\n    n = 0\n    remaining = p\n    k = 1\n    while remaining > 0:\n        t_val = k * (k - 1) // 2\n        if t_val <= remaining:\n            remaining -= t_val\n            arr.append(k)\n            k += 1\n        else:\n            break\n            \n    total_nodes = sum(arr)\n    \n    # Now, to compute the maximum unidirectional pairs.\n    # The graph has several SCCs (with sizes given by arr). \n    # We arrange these components in a line (from left to right). \n    # Then, for each component i (with size s_i), the number of unidirectional pairs from its nodes to nodes in subsequent components is s_i * (total_nodes - s_i).\n    # But note: within each component, there are no unidirectional pairs (since they are strongly connected). Also, edges only go from left to right.\n    # Therefore, the total unidirectional pairs is the sum over all components of (size_i * (total_nodes - size_i)).\n    \n    total_unidirectional = 0\n    for size in arr:\n        total_unidirectional += size * (total_nodes - size)\n        \n    print(f\"{total_nodes} {total_unidirectional}\")\n\nif __name__ == '__main__':\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 474,
        "completion_token_count": 849,
        "thoughts_token_count": 1023
    }
}