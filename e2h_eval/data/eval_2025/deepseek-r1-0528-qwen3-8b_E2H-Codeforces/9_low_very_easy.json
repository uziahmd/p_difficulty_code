{
    "start": 1758093372.3056953,
    "end": 1758094979.164032,
    "start-formatted": "2025-09-17 16:16 KST",
    "end-formatted": "2025-09-17 16:42 KST",
    "gpu": 2,
    "pid": 9,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Selling Souvenirs\n\nAfter several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.This morning, as usual, Petya will come to the market. Petya has n different souvenirs to sell; ith souvenir is characterised by its weight wi and cost ci. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than m, and total cost is maximum possible.Help Petya to determine maximum possible total cost.\n\n## Input\nThe first line contains two integers n and m (1 ≤ n ≤ 100000, 1 ≤ m ≤ 300000) — the number of Petya's souvenirs and total weight that he can carry to the market.Then n lines follow. ith line contains two integers wi and ci (1 ≤ wi ≤ 3, 1 ≤ ci ≤ 109) — the weight and the cost of ith souvenir.\n\n## Output\nPrint one number — maximum possible total cost of souvenirs that Petya can carry to the market.\n\n## Example\n### Input\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\n### Output\n['0', '3', '10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\n Okay, we are given up to 100000 souvenirs, each with weight 1, 2, or 3 and a cost (which can be up to 10^9).\n We want to choose a subset such that the total weight <= m (which can be up to 300000) and maximize total cost.\n\n Since the weights are only 1, 2, or 3, we can break the souvenirs into three groups:\n   Group1: weight=1, list of costs\n   Group2: weight=2, list of costs\n   Group3: weight=3, list of costs\n\n Then, the problem becomes: we can take any number of items from each group, but the total weight must be <= m.\n\n Let:\n   x1 = number of items from Group1 (each adds 1)\n   x2 = number of items from Group2 (each adds 2)\n   x3 = number of items from Group3 (each adds 3)\n\n Then the total weight is: w = x1 + 2*x2 + 3*x3 <= m.\n\n The total cost is: c = (sum of chosen Group1 items) + (sum of chosen Group2 items) + (sum of chosen Group3 items)\n\n However, note: we are allowed to choose any subset from each group independently. But within a group, we want to choose the most expensive ones because they give the highest cost per weight? Actually, we want to maximize the total cost, so for each group we should sort the items in descending order and then take the top k (but we don't have to take contiguous top k necessarily, but since we want maximum sum, we would take the largest ones).\n\n But note: the entire set of souvenirs might be large, and we cannot iterate over all possible x1, x2, x3 (because n is up to 100000, and m up to 300000, and the counts in each group can be large).\n\n Alternative approach:\n\n Precompute for each group:\n   Sort the group by cost descending.\n   Precompute prefix sums: so that for group i, we can get the total cost of taking the top k items (for k from 0 to size_i).\n\n Then, note that the total weight is x1 + 2*x2 + 3*x3 <= m, and x1, x2, x3 are nonnegative integers and at most the sizes of their groups.\n\n We can iterate over x3 (the number of group3 items) from 0 to min(len(group3), m//3). For each x3, we have used 3*x3 weight, so remaining weight is m - 3*x3.\n\n Then, we need to distribute the remaining weight between group1 and group2. Let r = m - 3*x3.\n\n Now, for group2, we can take at most floor(r/2) items. But note: we can also leave some weight unused, but we want to maximize the total cost.\n\n We can consider that we take as many as possible from group2, but wait: maybe we don't want to take too many from group2 because then we might not have room for group1 which has high cost items? Actually, we have to combine.\n\n However, note: the cost in each group is independent. So for a fixed x3, we have:\n\n   Let R = r = m - 3*x3\n   Then, we can take x2 from [0, floor(R/2)] and then x1 from [0, R - 2*x2] (since each group1 item is weight 1).\n\n But note: we cannot exceed the available items in group1 and group2.\n\n Alternatively, we can precompute for group1 and group2 the maximum total cost for a given remaining weight (from 0 to max_possible). However, the remaining weight for group1 and group2 combined is up to 300000, but we have two groups.\n\n Another idea: use dynamic programming for group1 and group2 together? But note that we have already fixed x3, so we can think of the problem as: given two arrays (group1 and group2) and a total weight limit R, what is the maximum sum we can get if we take items from both (with group1: weight 1, group2: weight 2) without exceeding R?\n\n But note: we have sorted each group and computed prefix sums. We can do:\n\n   For group1, we have an array A1 (sorted descending) and prefix1[i] = sum of first i items (i from 0 to len(A1)).\n   Similarly, for group2, A2 and prefix2[j] for j from 0 to len(A2).\n\n Then, for a fixed x3, we have R = m - 3",
    "response": "\nTo solve this problem, we need to maximize the total cost of souvenirs that Petya can carry to the market without exceeding a given weight limit. The souvenirs are categorized by their weights (1, 2, or 3), which allows us to break down the problem into manageable parts.\n\n### Approach\n1. **Categorize Souvenirs**: Separate the souvenirs into three groups based on their weights (1, 2, or 3). Each group will be processed independently.\n2. **Sort and Prefix Sums**: For each group, sort the souvenirs in descending order of their costs and compute prefix sums. This allows us to quickly access the maximum cost achievable by taking any number of items from the group.\n3. **Iterate Over Possible Items**: For each possible number of items from the third group (weight 3), calculate the remaining weight available for the first two groups. Then, for the remaining weight, determine the optimal combination of items from the first two groups (weights 1 and 2) that maximizes the total cost without exceeding the remaining weight.\n4. **Combine Results**: For each combination of items from the three groups, compute the total cost and keep track of the maximum value encountered.\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(0)\n        return\n        \n    n = int(data[0])\n    m = int(data[1])\n    index = 2\n    groups = {1: [], 2: [], 3: []}\n    \n    for i in range(n):\n        w = int(data[index])\n        c = int(data[index + 1])\n        index += 2\n        groups[w].append(c)\n        \n    for key in groups:\n        groups[key].sort(reverse=True)\n        groups[key] = groups[key][:100000]\n        \n    group1 = groups[1]\n    group2 = groups[2]\n    group3 = groups[3]\n    \n    len1 = len(group1)\n    len2 = len(group2)\n    len3 = len(group3)\n    \n    prefix1 = [0]\n    for i in range(len1):\n        prefix1.append(prefix1[-1] + group1[i])\n        \n    prefix2 = [0]\n    for i in range(len2):\n        prefix2.append(prefix2[-1] + group2[i])\n        \n    prefix3 = [0]\n    for i in range(len3):\n        prefix3.append(prefix2[-1] + group3[i])\n        \n    max_total = 0\n    \n    for x3 in range(len3 + 1):\n        if 3 * x3 > m:\n            break\n        rem = m - 3 * x3\n        if rem < 0:\n            continue\n            \n        current_cost3 = prefix3[x3]\n        if current_cost3 < max_total:\n            continue\n            \n        R = rem\n        max_cost_here = current_cost3\n        \n        for x2 in range(min(len2, R // 2) + 1):\n            if 2 * x2 > R:\n                break\n            rem2 = R - 2 * x2\n            if x2 > len2:\n                continue\n            cost2 = prefix2[x2]\n            if cost2 < max_total:\n                continue\n            current_cost = current_cost3 + cost2\n            if rem2 < 0:\n                continue\n                \n            x1 = min(rem2, len1)\n            cost1 = prefix1[x1]\n            total_cost = current_cost + cost1\n            if total_cost > max_total:\n                max_total = total_cost\n                \n    print(max_total)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Input Handling**: The input is read and parsed into the number of souvenirs `n` and the maximum weight `m`. Each souvenir's weight and cost are then categorized into one of three groups based on their weight.\n2. **Sorting and Prefix Sums**: Each group is sorted in descending order of cost, and prefix sums are computed to facilitate quick summation of the top `k` items in each group.\n3. **Combination Calculation**: For each possible number of items from the third group (weight 3), the remaining weight is calculated. This remaining weight is then used to determine the optimal number of items from the second group (weight 2) and subsequently from the first group (weight 1).\n4. **Maximization**: The total cost for each valid combination of items from all three groups is computed, and the maximum value encountered during this process is printed as the result.\n\nThis approach efficiently narrows down the problem by leveraging the constraints on item weights and using prefix sums to optimize the calculation of maximum costs, ensuring optimal performance even for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(0)\n        return\n        \n    n = int(data[0])\n    m = int(data[1])\n    index = 2\n    groups = {1: [], 2: [], 3: []}\n    \n    for i in range(n):\n        w = int(data[index])\n        c = int(data[index + 1])\n        index += 2\n        groups[w].append(c)\n        \n    for key in groups:\n        groups[key].sort(reverse=True)\n        groups[key] = groups[key][:100000]\n        \n    group1 = groups[1]\n    group2 = groups[2]\n    group3 = groups[3]\n    \n    len1 = len(group1)\n    len2 = len(group2)\n    len3 = len(group3)\n    \n    prefix1 = [0]\n    for i in range(len1):\n        prefix1.append(prefix1[-1] + group1[i])\n        \n    prefix2 = [0]\n    for i in range(len2):\n        prefix2.append(prefix2[-1] + group2[i])\n        \n    prefix3 = [0]\n    for i in range(len3):\n        prefix3.append(prefix2[-1] + group3[i])\n        \n    max_total = 0\n    \n    for x3 in range(len3 + 1):\n        if 3 * x3 > m:\n            break\n        rem = m - 3 * x3\n        if rem < 0:\n            continue\n            \n        current_cost3 = prefix3[x3]\n        if current_cost3 < max_total:\n            continue\n            \n        R = rem\n        max_cost_here = current_cost3\n        \n        for x2 in range(min(len2, R // 2) + 1):\n            if 2 * x2 > R:\n                break\n            rem2 = R - 2 * x2\n            if x2 > len2:\n                continue\n            cost2 = prefix2[x2]\n            if cost2 < max_total:\n                continue\n            current_cost = current_cost3 + cost2\n            if rem2 < 0:\n                continue\n                \n            x1 = min(rem2, len1)\n            cost1 = prefix1[x1]\n            total_cost = current_cost + cost1\n            if total_cost > max_total:\n                max_total = total_cost\n                \n    print(max_total)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 477,
        "completion_token_count": 1015,
        "thoughts_token_count": 1023
    }
}