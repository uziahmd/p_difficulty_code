{
    "start": 1758294378.435583,
    "end": 1758296564.7804112,
    "start-formatted": "2025-09-20 00:06 KST",
    "end-formatted": "2025-09-20 00:42 KST",
    "gpu": 2,
    "pid": 41,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Zoning Restrictions Again\n\nYou are planning to build housing on a street. There are $$$n$$$ spots available on the street on which you can build a house. The spots are labeled from $$$1$$$ to $$$n$$$ from left to right. In each spot, you can build a house with an integer height between $$$0$$$ and $$$h$$$.In each spot, if a house has height $$$a$$$, you will gain $$$a^2$$$ dollars from it.The city has $$$m$$$ zoning restrictions. The $$$i$$$-th restriction says that the tallest house from spots $$$l_i$$$ to $$$r_i$$$ (inclusive) must be at most $$$x_i$$$.You would like to build houses to maximize your profit. Determine the maximum profit possible.\n\n## Input\nThe first line contains three integers $$$n$$$, $$$h$$$, and $$$m$$$ ($$$1 \\leq n,h,m \\leq 50$$$) — the number of spots, the maximum height, and the number of restrictions.Each of the next $$$m$$$ lines contains three integers $$$l_i$$$, $$$r_i$$$, and $$$x_i$$$ ($$$1 \\leq l_i \\leq r_i \\leq n$$$, $$$0 \\leq x_i \\leq h$$$) — left and right limits (inclusive) of the $$$i$$$-th restriction and the maximum possible height in that range.\n\n## Output\nPrint a single integer, the maximum profit you can make.\n\n## Example\n### Input\n['3 3 3\\n1 1 1\\n2 2 3\\n3 3 2', '4 10 2\\n2 3 8\\n3 4 7']\n\n### Output\n['14', '262']\n\n## Note\nIn the first example, there are $$$3$$$ houses, the maximum height of a house is $$$3$$$, and there are $$$3$$$ restrictions. The first restriction says the tallest house between $$$1$$$ and $$$1$$$ must be at most $$$1$$$. The second restriction says the tallest house between $$$2$$$ and $$$2$$$ must be at most $$$3$$$. The third restriction says the tallest house between $$$3$$$ and $$$3$$$ must be at most $$$2$$$.In this case, it is optimal to build houses with heights $$$[1, 3, 2]$$$. This fits within all the restrictions. The total profit in this case is $$$1^2 + 3^2 + 2^2 = 14$$$.In the second example, there are $$$4$$$ houses, the maximum height of a house is $$$10$$$, and there are $$$2$$$ restrictions. The first restriction says the tallest house from $$$2$$$ to $$$3$$$ must be at most $$$8$$$. The second restriction says the tallest house from $$$3$$$ to $$$4$$$ must be at most $$$7$$$.In this case, it's optimal to build houses with heights $$$[10, 8, 7, 7]$$$. We get a profit of $$$10^2+8^2+7^2+7^2 = 262$$$. Note that there are two restrictions on house $$$3$$$ and both of them must be satisfied. Also, note that even though there isn't any explicit restrictions on house $$$1$$$, we must still limit its height to be at most $$$10$$$ ($$$h=10$$$).\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\n We are given n, h, m and then m lines of l, r, x.\n Since n, m <= 50, we can use dynamic programming or iterate over possibilities, but note that the restrictions might be overlapping and we need to satisfy all.\n\n However, note that the constraints are small (n, m up to 50) but the height is up to 50 and the number of restrictions is 50. We cannot try all 50^50 possibilities.\n\n Approach:\n\n We can think of the following:\n\n Each house has a height between 0 and h. The profit is the sum of squares. We have m restrictions: for each restriction i, the maximum height in [l_i, r_i] must be <= x_i.\n\n We can use state space reduction by considering the restrictions and the fact that the restrictions are about contiguous intervals.\n\n Idea: \n 1. Preprocess the restrictions: for each spot j (from 1 to n), we can compute the minimum allowed height? Actually, no. Instead, we can think of the restrictions as imposing an upper bound on the maximum height in an interval. \n\n However, note: the problem is that if we set a house too high, it might break a restriction. But if we set it too low, we lose profit.\n\n Alternate idea: since n is at most 50, we can consider iterating over the houses and using DP that considers the restrictions.\n\n But note: there are m restrictions, and we need to ensure that every restriction is satisfied. We can also note that the restrictions are independent but overlapping.\n\n Another idea: use the concept of \"events\" and then use DP that goes from left to right and keeps track of the active restrictions.\n\n However, note that the restrictions are given as (l_i, r_i, x_i). The constraint is that for each restriction i, the maximum height in [l_i, r_i] is <= x_i.\n\n We can also note: the profit function is separable (each house's contribution is independent) but the constraints are global (over intervals).\n\n We can try to use linear programming relaxation? But n, m are small (<=50) but the heights are integers from 0 to h (h<=50). So we can use DP with state being the current position and the last few restrictions? But the restrictions are defined over intervals and we don't know which ones are active until we cover their entire interval.\n\n Alternatively, we can precompute the effect of each restriction: for each position, we can know what is the tightest restriction that applies to it? Actually, for each spot j, we can define:\n   Let R(j) = the minimum x_i such that j is in [l_i, r_i]. Then the height at j must be at most R(j)? Not exactly: because one restriction might only say that the maximum in [l_i, r_i] is <= x_i, so if j is in multiple intervals, then the height at j must be at most the minimum x_i for which j is in [l_i, r_i]? But wait: no. Consider two restrictions:\n        Restriction 1: [1,3] -> max <= 5\n        Restriction 2: [2,4] -> max <= 3\n    Then house at position 2 must be <= min(5,3)=3? Actually, yes, because if house2 is 4, then the first restriction is broken (since 4>5? no, wait: the first restriction says the entire segment [1,3] must have max<=5, so 4 is okay for the first, but the second requires <=3, so indeed 4 breaks the second. Therefore, the house at position 2 must be <=3.\n\n However, note: the restrictions are independent. The condition for a restriction i is that the maximum height in [l_i, r_i] is <= x_i. Therefore, if a house is included in a restriction, its height must be <= x_i for that restriction? Actually, no: because the entire interval must have maximum <= x_i, so if a house is at position j which is in [l_i, r_i], then the height at j must be <= x_i? Yes, because otherwise the maximum would exceed x_i. \n\n Therefore, for each house j, let M_j = min{ x_i | j is in [l_i, r_i] } (if there is no restriction covering j, then M_j = infinity? but wait, we have the global constraint that the house cannot exceed h. Actually, we are allowed to have any height from 0 to h, but if there's a restriction that covers j, then we must not exceed the minimum x_i of the restrictions that cover j. However, note: we might have multiple restrictions and they can have different x_i. Also, if there's no restriction covering j, then the only constraint is that",
    "response": "\nTo solve this problem, we need to maximize the profit from building houses on a street while adhering to certain zoning restrictions. The profit is calculated as the sum of the squares of the heights of the houses built on each spot. The constraints specify that the tallest house in certain intervals must not exceed a given height.\n\n### Approach\n1. **Problem Analysis**: The problem involves selecting heights for each house such that all zoning restrictions are satisfied. Each restriction requires that the maximum height in a specified interval does not exceed a certain value. The goal is to maximize the sum of the squares of these heights.\n2. **Key Insight**: For each position, the maximum allowable height is determined by the most restrictive (smallest) upper bound from all overlapping restrictions. If no restrictions apply to a position, the maximum height is simply the global maximum height `h`.\n3. **Algorithm Selection**: Given the constraints (n, m ≤ 50), we can use dynamic programming (DP) to efficiently explore possible height assignments. The DP state will track the current position and the last few decisions to ensure all restrictions are met without exhaustive search.\n4. **Complexity Analysis**: The DP approach processes each position once, and for each position, it considers possible height assignments while checking active restrictions. The complexity is manageable due to the small input size (n ≤ 50, h ≤ 50).\n\n### Solution Code\n```python\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    n = int(data[0])\n    h_global = int(data[1])\n    m = int(data[2])\n    \n    restrictions = []\n    index = 3\n    for _ in range(m):\n        l = int(data[index])\n        r = int(data[index+1])\n        x_val = int(data[index+2])\n        index += 3\n        restrictions.append((l, r, x_val))\n    \n    max_heights = [float('inf')] * (n + 1)\n    for (l, r, x_val) in restrictions:\n        for j in range(l, r + 1):\n            if x_val < max_heights[j]:\n                max_heights[j] = x_val\n    \n    for j in range(1, n + 1):\n        if max_heights[j] == float('inf'):\n            max_heights[j] = h_global\n    \n    dp = [[-1] * (max_heights[j] + 1) for j in range(n + 1)]\n    \n    for height in range(0, max_heights[1] + 1):\n        dp[1][height] = height * height\n    \n    for pos in range(2, n + 1):\n        current_max_allowed = max_heights[pos]\n        for prev_max in range(0, current_max_allowed + 1):\n            best_prev = -1\n            for prev_height in range(0, current_max_allowed + 1):\n                if dp[pos - 1][prev_height] != -1:\n                    if prev_height >= best_prev:\n                        best_prev = prev_height\n            if best_prev == -1:\n                continue\n            for height in range(0, current_max_allowed + 1):\n                total_profit = best_prev + height * height\n                if dp[pos][height] < total_profit:\n                    dp[pos][height] = total_profit\n    \n    result = max(dp[n])\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into the number of spots `n`, the global maximum height `h_global`, and the number of restrictions `m`. Each restriction is stored as a tuple of `(l, r, x_val)`.\n2. **Determine Maximum Heights**: For each position, the maximum allowable height is determined by the smallest `x_val` from all restrictions that include that position. If no restrictions apply, the global maximum height `h_global` is used.\n3. **Dynamic Programming Setup**: A DP table is initialized where `dp[i][h]` represents the maximum profit achievable up to the `i-th` position with the `h-th` height at that position.\n4. **Base Case**: The first position's profit is initialized for all possible heights (from 0 to its maximum allowed height).\n5. **DP Table Population**: For each subsequent position, the DP table is updated by considering all valid heights (those not exceeding the position's maximum allowed height) and ensuring that previous positions' heights do not violate any restrictions. The profit is accumulated by adding the square of the current height to the best profit from the previous position.\n6. **Result Extraction**: The maximum value in the last row of the DP table gives the highest possible profit, which is printed as the result.\n\nThis approach efficiently navigates the constraints using dynamic programming, leveraging the problem's structure to avoid brute-force search while ensuring all restrictions are respected.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    n = int(data[0])\n    h_global = int(data[1])\n    m = int(data[2])\n    \n    restrictions = []\n    index = 3\n    for _ in range(m):\n        l = int(data[index])\n        r = int(data[index+1])\n        x_val = int(data[index+2])\n        index += 3\n        restrictions.append((l, r, x_val))\n    \n    max_heights = [float('inf')] * (n + 1)\n    for (l, r, x_val) in restrictions:\n        for j in range(l, r + 1):\n            if x_val < max_heights[j]:\n                max_heights[j] = x_val\n    \n    for j in range(1, n + 1):\n        if max_heights[j] == float('inf'):\n            max_heights[j] = h_global\n    \n    dp = [[-1] * (max_heights[j] + 1) for j in range(n + 1)]\n    \n    for height in range(0, max_heights[1] + 1):\n        dp[1][height] = height * height\n    \n    for pos in range(2, n + 1):\n        current_max_allowed = max_heights[pos]\n        for prev_max in range(0, current_max_allowed + 1):\n            best_prev = -1\n            for prev_height in range(0, current_max_allowed + 1):\n                if dp[pos - 1][prev_height] != -1:\n                    if prev_height >= best_prev:\n                        best_prev = prev_height\n            if best_prev == -1:\n                continue\n            for height in range(0, current_max_allowed + 1):\n                total_profit = best_prev + height * height\n                if dp[pos][height] < total_profit:\n                    dp[pos][height] = total_profit\n    \n    result = max(dp[n])\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 822,
        "completion_token_count": 1025,
        "thoughts_token_count": 1023
    }
}