{
    "start": 1758089447.5124557,
    "end": 1758092071.0451696,
    "start-formatted": "2025-09-17 15:10 KST",
    "end-formatted": "2025-09-17 15:54 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\n Okay, we are given up to 10^4 test cases, each with an integer n (from 1 to 10^18).\n We need to determine if there exists an integer k > 1 such that a snowflake graph with n vertices exists.\n\n According to the problem, the snowflake is constructed in layers (steps). The initial step (step 0) has 1 vertex.\n Then, step 1: the initial vertex is connected to k new vertices -> total vertices = 1 + k.\n Then, step 2: each vertex that is connected to only one other vertex (i.e., the k leaves from step 1) is connected to k new vertices. \n   So we add k * k vertices. Total vertices = 1 + k + k^2.\n Then step 3: each leaf from step 2 (which are k*k vertices) will connect to k new vertices -> add k^3. Total vertices = 1 + k + k^2 + k^3.\n\n However, note the problem says: \"Each vertex that is connected to only one other vertex is connected by edges to k more new vertices. This step should be done at least once.\" \n But note: the process can be stopped at any step? Actually, the problem says \"at least once\", meaning we must do the expansion at least once (so at least two layers beyond the root? Let's clarify):\n\n - Step 0: 1 vertex (root)\n - Step 1: add k vertices -> total 1+k (this is the first expansion, so the process has been done at least once? Actually, note: the rule says \"Then, more vertices are added to the graph. The initial vertex is connected by edges to k new vertices.\" and then \"Each vertex that is connected to only one other vertex is connected by edges to k more new vertices. This step should be done at least once.\"\n\n But note: the construction steps:\n\n   Step 0: 1 vertex (root). The root is connected to 0 other vertices initially.\n\n   Then, we do:\n      Step 1: the root (which is the only vertex) is connected to k new vertices. Now the root has degree k (>=2) and the k new leaves have degree 1.\n\n   Then, we must do the second step (because the problem says \"This step should be done at least once\"): we take each leaf (each of the k leaves) and connect each to k new vertices. Now, the leaves from step1 become non-leaves (they now have degree k+1) and we get k*k new leaves.\n\n   However, note: the problem does not require that we stop at a particular step. It can be built with any number of expansions (layers) as long as the expansion is done at least once (meaning we have at least two layers: the root and then at least one expansion from the root and then at least one expansion from the leaves of the first expansion).\n\n   But wait: the example smallest snowflake for k=4 has 1 + 4 + 4*4 = 1+4+16 = 21? Actually, the example figure might show a snowflake with multiple arms. However, note the example input: \n        Input: 13 -> Output: YES, because 13 = 1 + 3 + 9 (k=3, but wait: k=3 would give 1 + 3 + 9 = 13). \n\n   However, let me re-read: the problem says \"The smallest possible snowflake for k = 4\" is shown. The smallest for k=4 would be 1 + 4 + 4^2 = 21.\n\n   But note: we can stop after the first expansion? The problem says \"This step should be done at least once\", meaning the entire process (starting from the initial vertex and expanding at least once) must be done. However, the expansion step is defined as connecting the leaves to k new vertices. The first expansion (from the root) is the initial step. Then the next expansion is the step that must be done at least once? Or is the first expansion considered as the first step and then the second expansion is the one that must be done at least once?\n\n   Actually, the problem states: \"Then, more vertices are added to the graph. The initial vertex is connected by edges to k new vertices.\" Then, \"Each vertex that is connected to only one other vertex is connected by edges to k more new vertices. This step should be done at least once.\"\n\n   So the initial expansion (the root to k) is mandatory, and then the next expansion (on the leaves) is also mandatory at least once. Therefore, the minimal snowflake has at least two expansions (layers beyond the root). \n\n   However, wait: the example input includes 6. How can 6 be represented?\n        n=6: we can have k=5? Then the minimal structure would be 1 + 5 + 5^2 = 31, which is too big. Alternatively, maybe we don't have to use the same k for all expansions? But note the problem says: \"the initial vertex is connected by edges to k new vertices\" and then \"each vertex that is connected to only one other vertex\" is connected to k new vertices. So k must be fixed.\n\n   But note: the problem does not say we must use the same k for all layers. However, the description uses the same k throughout. So we assume k is fixed.\n\n   However, looking at the example: \n        Input: 6 -> Output: NO.\n\n   How about if we have two layers? Then the total number of vertices is 1 + k + k^2. We need 1 + k + k^2 = 6. \n        k^2 + k + 1 = 6 -> k^2 + k -5 =0 -> no integer k>1 solution.\n\n   What if we have more than two layers? Then we have three layers: 1 + k + k^2 + k^3. For k=2: 1+2+4+8=15 -> too big. k=1 is not allowed. So three layers doesn't work for 6.\n\n   But wait, what if we stop at one layer? Then total vertices = 1+k. Then k=5 gives 6. However, the problem says the expansion step (the one that adds k new vertices for each leaf) must be done at least once. The first expansion (from the root) is the initial step, and then we must do the expansion on the leaves at least once. So stopping at one layer (only the root and its k children) is not allowed because the expansion of the leaves must be done at least once.\n\n   Therefore, the minimal number of vertices is 1 + k + k^2 (two expansions). \n\n   However, note: the problem does not specify that the process must stop after a fixed number of layers. We can choose the number of layers (say m) arbitrarily as long as m>=2 (since the expansion step is done at least once). Then the total number of vertices is:\n\n        n = 1 + k + k^2 + ... + k^(m-1)\n\n   This is a geometric series: n = (k^m - 1) / (k-1)\n\n   But note: the problem says \"at least once\" meaning we must do the expansion step (the one that adds the second layer) at least once. So m>=2 (with m being the number of layers including the root? Actually, the root is the first layer, then the next is the second, etc.)\n\n   Alternatively, we can think: the root is the center. Then the first ring (layer 1) has k vertices. Then the second ring (layer 2) has k^2 vertices, and so on until layer m-1 (because the root is layer0). Then the total layers (excluding the root) is m-1, but the expansion step is done (m-1) times? Actually, the problem says:\n\n        Step0: root\n        Step1: connect root to k new -> expansion1 (so we did one expansion from the root)\n        Then we must do the expansion step (on the leaves) at least once -> expansion2.\n\n   So we have at least two expansions (from the root and then from the leaves). Therefore, the total layers (including the root) is 3? Actually, the root is the center, then the first expansion (from the root) produces layer1, and the second expansion (from the leaves of layer1) produces layer2. So the total layers (if we count the root as layer0) are 3 (layers0,1,2). Then the total vertices is 1 + k + k^2.\n\n   But note: the problem does not say we cannot do more than two expansions. We can do m expansions (m>=2) and then the total vertices is:\n\n        n = 1 + k + k^2 + ... + k^m\n\n   However, wait: the expansion step is defined as: \"Each vertex that is connected to only one other vertex is connected by edges to k more new vertices.\" This happens in multiple steps. After the first expansion (from the root), we have k leaves (each has degree 1). Then we expand each of these k leaves, getting k^2 new leaves. Then we could expand those again, getting k^3, etc.\n\n   So the formula for the total vertices is:\n\n        n = 1 + k * (1 + k + k^2 + ... + k^(m-1))   ??? \n\n   Actually, let me break down:\n\n        Layer0: 1 vertex (root)\n        Layer1: k vertices (children of root) -> total so far: 1+k\n        Layer2: k*k vertices (each leaf from layer1 expands to k) -> total: 1+k+k^2\n        Layer3: k^3 vertices -> total: 1+k+k^2+k^3\n\n   So the total number of vertices is the sum_{i=0}^{m-1} k^i + 1? Actually, wait: the root is included, and then we have layers 1 to m (if we count the root as layer0, then layers 1 to m). Alternatively, the exponent goes from 0 to m (with the root being the 0th power) but then we have:\n\n        n = 1 + k + k^2 + ... + k^m\n\n   However, note: the root is the 0th term? Actually, the root is the center and is not part of any expansion. The expansions are:\n\n        Expansion1: adds k^1\n        Expansion2: adds k^2\n        ...\n        Expansion m: adds k^m\n\n   Then the total is: 1 + k^1 + k^2 + ... + k^m.\n\n   But note: the expansion step must be done at least once. The first expansion (k^1) is done, and then at least one more expansion (so m>=2). So the minimal form is m=2: 1 + k + k^2.\n\n   However, the problem does not specify that we must use the same k for every expansion. But the definition uses the same k. So we assume k is fixed.\n\n   Therefore, the problem reduces to: for a given n, does there exist an integer k>1 and an integer m>=2 such that:\n\n        n = 1 + k + k^2 + ... + k^m\n\n   But note: the series is a geometric series. We can write:\n\n        n = (k^(m+1) - k) / (k-1)   ? Let me check:\n\n        Sum_{i=0}^{m} k^i = (k^(m+1)-1)/(k-1)\n\n        However, our series starts at k^1 (we have the root and then k^1, k^2,...,k^m) but wait: the root is 1 (which is k^0) and then we add k^1, k^2, ... k^m. So actually:\n\n        n = 1 + k + k^2 + ... + k^m = (k^(m+1)-1)/(k-1)\n\n   But note: the root is included, and then we have m+1 terms (from k^0 to k^m). However, the expansion steps: we did m expansions (from the root and then m-1 more for the leaves?) and the root is the starting point. Actually, the expansion steps are m (from the root to the m-th layer). Then the total layers (including the root) is m+1. But wait, the problem says the expansion step (the one that adds the leaves) is done at least once. The root expansion is the first expansion (adding the first layer) and then the second expansion (adding the second layer) is the mandatory one. So we have at least two layers (the root and two layers of expansion). Therefore, the total layers (including the root) is 3 (root, layer1, layer2). Then the total vertices is:\n\n        n = 1 + k + k^2.\n\n   This is the same as (k^3-1)/(k-1) = 1 + k + k^2.\n\n   So the formula is: n = (k^(m+1)-1)/(k-1) for some integers k>1 and m>=2 (where m is the number of expansion steps, and the total layers including the root is m+1).\n\n   However, note: the problem does not fix m. We are allowed to have any m>=2. Also, note that k must be an integer greater than 1.\n\n   But note: we are allowed to have different m? Yes, but we are only given n.\n\n   Alternative approach: note that the minimal configuration (m=2) is n = 1 + k + k^2. We can also have m=3: n = 1 + k + k^2 + k^3, etc.\n\n   However, note that the problem does not require the entire snowflake to be built with the same k for every expansion? Actually, the problem defines k as the same for the entire construction.\n\n   But the problem is: given n, does there exist k>1 and m>=2 (integer m) such that n = (k^(m+1)-1)/(k-1).\n\n   However, note that m can be very large and k can be as small as 2. But n can be up to 10^18. We cannot iterate over m and k blindly.\n\n   Let's analyze:\n\n        n = (k^(m+1)-1)/(k-1)   =>  n*(k-1) = k^(m+1)-1.\n\n   We know that for fixed k, the value of n grows very quickly with m. Similarly, for fixed m, k must be such that k^(m+1) = n*(k-1)+1.\n\n   Since n can be up to 10^18, and t up to 10000, we need an efficient way.\n\n   Observation:\n\n   There are two types of representations:\n\n     1. The snowflake can be represented by a base-k expansion (geometric series) with at least two layers (so m>=2, meaning the series has at least three terms: 1, k, k^2).\n\n     2. Alternatively, we can consider breaking the problem into:\n\n        Case 1: n is small. Then we can iterate over k from 2 up to some limit and check for small exponents.\n\n        Case 2: n is large. Then we note that the base k must be at least 2, and the exponent m+1 is at least 3.\n\n   However, note that the problem does not require the entire snowflake to be built with a fixed k. But wait, the definition uses the same k throughout.\n\n   Alternate Insight:\n\n   Note that the formula for the snowflake is the same as the number of nodes in a rooted tree where each node (except the leaves) has exactly k children, and we have m+1 levels (with the root at level0 and the leaves at level m). Then the total nodes is:\n\n        n = 1 + k + k^2 + ... + k^m = (k^(m+1)-1)/(k-1)\n\n   But note: the problem says \"at least once\" meaning m>=2 (because the expansion step is done at least once, and the first expansion is from the root and then at least one more expansion from the leaves). So m>=2.\n\n   However, note: the example n=13: 1 + k + k^2 = 13 -> k^2+k+1=13 -> k^2+k-12=0 -> k=( -1±sqrt(1+48) )/2 = ( -1±7 )/2 -> k=3 (since k>1). So k=3, m=2.\n\n   Another example: n=15: 1+k+k^2+k^3 = 15 -> k^3+k^2+k+1=15 -> k=2: 1+2+4+8=15 -> yes.\n\n   But note: we can also represent 15 with k=2 and m=3 (which is the same as above).\n\n   However, note: we can also represent 15 with k=15? That would be m=2: 1+15+15^2 = 1+15+225=241 -> too big.\n\n   So we must consider that k is the base and the exponent is variable.\n\n   How to solve?\n\n   We can consider two cases:\n\n     Case 1: m=2 (minimal expansion, two expansions: root and two layers). Then n = 1 + k + k^2 = k^2+k+1.\n\n        We need to check if there exists an integer k>1 such that k^2+k+1 = n.\n\n        Then k^2+k+1-n=0 -> discriminant D = 1-4*(1-n)=4*n-3. Then k = [-1±sqrt(4*n-3)]/2. We require the positive root to be an integer.\n\n        Conditions: \n          - 4*n-3 must be a perfect square, and\n          - the positive root must be an integer greater than 1.\n\n     Case 2: m>=3. Then the representation is n = (k^(m+1)-1)/(k-1) for some k>=2 and m>=3.\n\n        But note: the problem does not require that the expansion is done exactly two times, so we must consider all m>=2. However, note that when m=2 we already covered. So we need to check for m>=3.\n\n        However, note: the same n might be represented by different m and k? But the problem only asks for existence.\n\n        But note: we can also consider the possibility that the snowflake has only two layers (m=2) or more. \n\n   But wait: is it possible that a number n can be represented in two different ways (different k and m)? Then we only need one.\n\n   However, we must avoid checking for all m and k because n can be up to 10^18.\n\n   Alternative approach for the general case (m>=2):\n\n        Note: the equation n = (k^(m+1)-1)/(k-1) can be rewritten as:\n\n            k^(m+1) = n*(k-1)+1\n\n        We can try to fix the exponent (m+1) and solve for k. But note: m+1 can be from 3 to ... until k^3 exceeds 10^18. However, the base k is at least 2, so the exponent m+1 must be at most around 60 (since 2^60 is about 1e18).\n\n        Steps:\n\n        We know m>=2, so exponent = m+1 >= 3.\n\n        Then we can iterate over exponents e from 3 up to, say, 60 (or until k^e <= n*(k-1)+1, but we don't know k). Alternatively, we can iterate over bases k from 2 to ... until the geometric series with exponent e=3 (minimal) is greater than n.\n\n        But note: for a fixed exponent e (which is m+1, so e>=3), we have:\n\n            k^e = n*(k-1)+1\n\n        Rearranged: k^e - n*k + (n-1) = 0.\n\n        However, solving for k for each e is difficult.\n\n        Another idea: note that k must be at least 2 and the exponent e is at least 3. The left side (k^e) grows very fast. So for a fixed e, we can find k by binary search? But note that n can be as large as 10^18, and e is at least 3 and at most about 60.\n\n        Alternatively, we can note that for a fixed e, we can solve for k:\n\n            k^e = n*(k-1)+1\n\n        We can try to express k as approximately the (e-1)-th root of n*e (by ignoring the lower order terms). But note the equation is:\n\n            k^e - n*k + (n-1) = 0\n\n        However, we can rearrange:\n\n            k^e = n*k - (1-n)\n\n        Since n is large, k is roughly the (e-1)-th root of n*e. But note: the equation is nonlinear.\n\n        Alternatively, we can iterate over k for each exponent e? But k can be as large as n (if e=2, then k~sqrt(n); but for e>=3, k is much smaller). For example, for e=3: k^3 = n*(k-1)+1 -> k^3 - n*k + (n-1)=0. The root k is roughly the cube root of n*e (which is about n^(1/3)), so for n=10^18, k is about 1e6 for e=3? Actually, no: for e=3, k^3 ~ n*k, so k^2 ~ n -> k ~ sqrt(n) = 1e9, which is too many to iterate.\n\n        We need a better approach.\n\n        Let me consider: for a fixed exponent e (>=3), the equation is:\n\n            k^e = n*(k-1)+1\n\n        We can try to solve for k by iterating over k from 2 to the e-th root of n*(k-1)+1? That is not helpful.\n\n        Alternatively, we can use the fact that k must be an integer and that the function f(k) = (k^e - 1) / (k-1) must equal n. We can compute the value of the geometric series for a given k and e, and compare to n.\n\n        But how to choose k? The base k must be at least 2 and the value of the series is increasing with k and with e.\n\n        We can iterate over exponents e from 3 to 60 (since 2^60 is about 1e18, so the base k for exponent 60 is at least 2 and the value for k=2 and e=60 is (2^61-1)/1 which is about 2^61, which is 2e18, so we can set e from 3 to 60).\n\n        For each e, we want to know if there exists an integer k>=2 such that:\n\n            (k^e - 1) / (k-1) = n\n\n        But note: we cannot iterate k from 2 to a very high value (like 1e9) for each e (and we have up to 60 exponents, and 10^4 test cases) because that would be 60 * 10^4 * (number of k) which is too slow.\n\n        We need to invert the problem: for a fixed e, we can solve for k by binary search. The left side is a strictly increasing function in k (for k>=2). We can set:\n\n            low = 2\n            high = ?\n\n        We need an upper bound for k. Note: the geometric series with e terms (exponent e means we have e terms: from k^0 to k^(e-1)):\n\n            n = 1 + k + k^2 + ... + k^(e-1)\n\n        But note: our exponent e is the number of layers? Actually, in our equation, we defined e = m+1 (the exponent in the numerator). Then the series has e terms (from k^0 to k^(e-1)). So:\n\n            n = (k^e - 1) / (k-1)\n\n        We can set an upper bound for k: since k^e <= n*(k-1)+1, and for k>=2, we have k^e <= n*k (approximately). Then k^(e-1) <= n. So k <= n^(1/(e-1)).\n\n        Therefore, for a fixed e, k is at most around n^(1/(e-1)). For example, for e=3, k <= sqrt(n) which is 1e9 for n=10^18. Then for each test case and for each e from 3 to 60, we would do a binary search over k from 2 to n^(1/(e-1)), which for e=3 is 1e9, and then we do 60 * (log2(1e9)) operations per test case, which is about 60 * 30 = 1800 operations per test case, and we have up to 10^4 test cases -> 10^4 * 1800 = 18e6, which is acceptable in Python? Maybe, but wait: the exponent e goes from 3 to 60, but for large e (say e=60) the upper bound for k is n^(1/59) which is 10^(18/59) ~ 10^(0.3) which is about 2, so the binary search for e=60 would only run a few iterations. But for e=3, we have to do about 30 iterations (binary search) and for e=4: n^(1/3) is 1e6, so about 20 iterations, and so on. The total number of iterations per test case would be the sum_{e=3}^{60} (number of binary search steps for e). \n\n        However, note: we must check for each exponent e from 3 to 60, and for each test case. And we have up to 10^4 test cases. The worst-case exponent (e=3) requires about 30 steps, and there are 58 exponents (from 3 to 60) -> 58 * 30 = 1740 steps per test case. Then 10^4 * 1740 = 17.4e6, which is acceptable in Python.\n\n        But note: computing k^e for k and e can be heavy? Especially for k near 1e9 and e=3: we do (1e9)^3 = 1e27, which is too big for integers? Actually, n is up to 10^18, and k is at most sqrt(n) (for e=3) which is 1e9, and 1e9^3 is 1e27, which is too big to store in a Python int? Actually, Python ints can handle that, but the operation might be slow. However, we are doing binary search and the numbers are huge, but note: the exponentiation for k=1e9 and e=3 is 1e27, which is a big integer, but we are doing this for each candidate k in the binary search? Actually, in the binary search we are going to do about 30 iterations per exponent, and each iteration we do one exponentiation (k^e) and then compute (k^e-1)//(k-1) and compare to n. But note: we can compute the geometric series without doing the full exponentiation? Actually, we can use the formula: (k^e - 1) // (k-1) = 1 + k + k^2 + ... + k^(e-1). But wait, we are using the formula to check equality to n. Alternatively, we can use:\n\n            total = (pow(k, e) - 1) // (k-1)\n\n        But note: k^e might be too big for e=3 and k=1e9 (1e27) and then we do pow(k, e) which is 1e27, which is acceptable in Python? But 10^4 test cases * 58 exponents * 30 candidates per exponent * (one exponentiation per candidate) -> 10^4 * 58 * 30 * (cost of one exponentiation). The cost of exponentiation for base k (which is an integer) and exponent e (from 3 to 60) is O(e) multiplications? Actually, pow(k, e) for e fixed and k being an integer of size up to 1e9 (for e=3) is cheap because e is small (max 60). But wait, k can be as large as 10^9 (for e=3) and e=60: then k^e is (10^9)^60 = 10^540, which is impossible to store. But note: for a fixed e, we set an upper bound for k: k_max = floor(n^(1/(e-1))) + 1. For e=60, k_max is about 2 (as I said) so we only check k=2 and k=3? Actually, for e=60, k_max = floor(n^(1/59)) + 1. For n=10^18, (10^18)^(1/59) is 10^(18/59) ≈ 10^0.305 ≈ 2.02. So k_max=3. Then we only check k=2 and k=3 for e=60.\n\n        So we can do:\n\n          For each test case:\n            if n <= 1: then NO (but note n>=1, and for n=1: the minimal snowflake requires at least two expansions? Actually, the root alone is one vertex, but the expansion must be done at least once. However, the root alone is the initial state, then we must add at least k new vertices (k>1) and then expand the leaves at least once. So n=1 is invalid. Similarly, n=2: minimal snowflake requires at least 1+k+k^2 = 1+2+4=7 (if k=2) or if k=3 then 1+3+9=13, so 2 is too small. So n=1 and n=2 are NO.\n\n            We already know that for n=1,2,3,6: NO.\n\n            We can handle:\n\n            Step 1: Check the minimal case (two expansions, i.e., m=2, so n = 1+k+k^2) by solving the quadratic.\n\n            Step 2: If not found, then check for exponents e from 3 to 60 (inclusive) and for each exponent e, we do:\n\n                low = 2\n                high = min(10**18, int(round(n**(1/(e-1)))) + 10)   # But careful: we must set an upper bound. Alternatively, we can set high = 2\n                Actually, we set high = the maximum k such that the geometric series (with e terms) is <= n. But note: the geometric series is (k^e-1)//(k-1). Alternatively, we can set high = 2 while (pow(high, e-1) <= n) [because the last term is k^(e-1) and the whole series is about k^(e-1) (actually the series is dominated by the last term)]. But note: we have:\n\n                    n = 1 + k + k^2 + ... + k^(e-1) < e * k^(e-1)\n\n                So k^(e-1) > n/e, so k > (n/e)^(1/(e-1))\n\n                We can set high = 2\n                while (pow(high, e) - 1) // (high-1) <= n:\n                    high *= 2\n\n                Then do binary search between low and high.\n\n            However, we can set high = 2\n            while (1 + high + high**2 + ... + high**(e-1)) <= n:\n                high *= 2\n\n            But we don't want to compute the entire series for each doubling. Alternatively, we can use:\n\n                We know that for base k, the series has e terms: the largest term is k^(e-1). So we require k^(e-1) <= n (because the series is at least k^(e-1)). Then k <= n**(1/(e-1)).\n\n            So we set high = int(n**(1/(e-1))) + 10   [but n**(1/(e-1)) might be fractional, so we use integer conversion]\n\n            However, for very large e (like 60) and n=10^18, n**(1/59) is about 2, so we set high=3. For e=3, n**(1/2) is about 1e9, so we set high = 10**9+10, which is too big to iterate.\n\n            We cannot iterate from 2 to 10**9 for e=3. We must use binary search.\n\n            Steps for fixed exponent e:\n\n                Let low = 2, high = min(10**18, int(round(n**(1/(e-1)))) + 100)   # But note: k must be integer and we are only interested in k such that the geometric series equals n.\n\n                Actually, we can set:\n\n                    high = 2\n                    # We can find an upper bound: k^(e-1) <= n => k <= n**(1/(e-1))\n                    # But we can also note that the geometric series is increasing in k, so we can set:\n                    #   high = 2\n                    #   while (geometric_series(high, e) <= n):\n                    #       high *= 2\n\n                Then, within [low, high], we do binary search for k such that geometric_series(k, e) == n.\n\n            But note: the geometric_series(k, e) = (k^e - 1) // (k-1)   [for k>=2, and integer k]\n\n            However, we must be cautious with the division: (k^e-1) must be divisible by (k-1). Actually, the formula is exact because k^e mod (k-1) is 1 (by properties of geometric series modulo k-1). But wait: k^e mod (k-1): note that k ≡ 1 (mod k-1), so k^e ≡ 1^e (mod k-1). Therefore, (k^e-1) is divisible by (k-1).\n\n            But note: the geometric series formula is an integer.\n\n            However, the problem is that k^e might be too big to compute for e=3 and k=1e9 (which is 1e27). But we are only doing this for e from 3 to 60, and k is bounded by n**(1/(e-1)), so for e=3, k is up to about 1e9, and 1e9^3 = 1e27 which is a big integer but Python can handle it. However, we are doing this for each candidate k in the binary search? Actually, no: in the binary search we are going to do about log2(high-low) iterations, and for each candidate k we compute k^e. But the number of candidates is logarithmic (about 30 for e=3). And we have 58 exponents per test case. But 10^4 test cases * 58 * 30 = 17.4e6, and each computation is an exponentiation of a number that might be up to 1e9 (for e=3) and exponent 3 (which is cheap) or for e=60, k is small (like 2 or 3) and 3^60 is about 3.5e28, which is acceptable.\n\n            However, for e=3 and k=1e9, we compute (1e9)**3 = 1e27, which is acceptable in terms of representation but might be slow? We can use pow(k, e) which is efficient for small exponents (e<=60). \n\n            But note: 10^4 test cases * 58 exponents * 30 binary search steps * (one exponentiation) = 17.4e6 exponentiations. Each exponentiation for base k (which is an integer) and exponent e (from 3 to 60) is O(log e) multiplications. But e is at most 60, so it's one or two multiplications (using exponentiation by squaring). \n\n            However, the base k can be very large",
    "response": "\nTo solve this problem, we need to determine whether a given number of vertices \\( n \\) can form a snowflake graph as defined by Rudolf. The snowflake graph is constructed in layers, starting from a single vertex (the root), and each subsequent layer expands by connecting each leaf node from the previous layer to \\( k \\) new nodes, where \\( k > 1 \\). The expansion must be done at least once, meaning the graph must have at least two layers beyond the root.\n\n### Approach\n1. **Problem Analysis**: The key observation is that the total number of vertices \\( n \\) in the snowflake graph must satisfy the equation \\( n = \\frac{k^{m+1} - 1}{k - 1} \\) for some integer \\( k > 1 \\) and \\( m \\geq 2 \\). This equation represents a geometric series sum where each term corresponds to a layer in the snowflake construction.\n2. **Insight**: For each test case, we need to check if \\( n \\) can be expressed as the sum of a geometric series with base \\( k > 1 \\) and at least three terms (since \\( m \\geq 2 \\)).\n3. **Algorithm Selection**:\n   - **Case 1 (Two Layers)**: Check if \\( n \\) fits the minimal snowflake configuration with exactly two expansions (i.e., \\( n = 1 + k + k^2 \\)). This involves solving a quadratic equation for \\( k \\).\n   - **Case 2 (More Layers)**: For configurations with more than two expansions, iterate over possible exponents \\( e \\) (from 3 to 60) and use binary search to find a base \\( k \\) such that the geometric series sum equals \\( n \\). The binary search bounds are determined by the maximum possible \\( k \\) for each exponent, derived from \\( n \\).\n4. **Complexity Analysis**: The approach efficiently checks each test case by leveraging mathematical properties and binary search, ensuring it handles the constraints (up to \\( 10^{18} \\) and \\( 10^4 \\) test cases) within feasible time complexity.\n\n### Solution Code\n```python\nimport math\n\ndef is_perfect_square(x):\n    if x < 0:\n        return False\n    s = math.isqrt(x)\n    return s * s == x\n\ndef solve_case(n):\n    if n <= 2:\n        return \"NO\"\n    \n    # Case 1: Two expansions (m=2)\n    # n = 1 + k + k^2 -> k^2 + k + 1 - n = 0\n    # Discriminant D = 1 - 4*(1-n) = 4*n - 3\n    D = 4 * n - 3\n    if is_perfect_square(D):\n        s = math.isqrt(D)\n        k = (s - 1) // 2\n        if k > 1 and (k * k + k + 1 == n):\n            return \"YES\"\n            \n    # Case 2: More than two expansions (m>=3)\n    # Exponent e from 3 to 60 (inclusive)\n    for e in range(3, 61):\n        low = 2\n        high = 2\n        while True:\n            terms = [pow(high, i) for i in range(e)]\n            total_terms = sum(terms)\n            if total_terms < n:\n                high *= 2\n            elif total_terms >= n:\n                break\n        else:\n            continue\n        \n        found = False\n        while low <= high:\n            mid = (low + high) // 2\n            try:\n                total_val = (pow(mid, e) - 1) // (mid - 1)\n            except ZeroDivisionError:\n                continue\n            if total_val == n:\n                found = True\n                break\n            elif total_val < n:\n                low = mid + 1\n            else:\n                high = mid - 1\n                \n        if found:\n            return \"YES\"\n            \n    return \"NO\"\n\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    t = int(data[0])\n    out_lines = []\n    index = 1\n    for _ in range(t):\n        n = int(data[index]); index += 1\n        res = solve_case(n)\n        out_lines.append(res)\n        \n    print(\"\\n\".join(out_lines))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Case 1 Handling**: The code first checks if \\( n \\) can be formed with exactly two expansions (layers) by solving the quadratic equation \\( k^2 + k + 1 = n \\). If the discriminant \\( 4n - 3 \\) is a perfect square and the solution \\( k \\) is an integer greater than 1, it returns \"YES\".\n2. **Case 2 Handling**: For larger \\( n \\), the code checks all possible exponents \\( e \\) from 3 to 60. For each exponent, it uses binary search to find a base \\( k \\) such that the sum of the geometric series \\( 1 + k + k^2 + \\ldots + k^{e-1} \\) equals \\( n \\). The binary search bounds are dynamically adjusted to efficiently locate \\( k \\).\n3. **Output**: For each test case, the result (\"YES\" or \"NO\") is collected and printed at the end. The solution efficiently handles large values of \\( n \\) by leveraging mathematical insights and binary search, ensuring optimal performance.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\n\ndef is_perfect_square(x):\n    if x < 0:\n        return False\n    s = math.isqrt(x)\n    return s * s == x\n\ndef solve_case(n):\n    if n <= 2:\n        return \"NO\"\n    \n    # Case 1: Two expansions (m=2)\n    # n = 1 + k + k^2 -> k^2 + k + 1 - n = 0\n    # Discriminant D = 1 - 4*(1-n) = 4*n - 3\n    D = 4 * n - 3\n    if is_perfect_square(D):\n        s = math.isqrt(D)\n        k = (s - 1) // 2\n        if k > 1 and (k * k + k + 1 == n):\n            return \"YES\"\n            \n    # Case 2: More than two expansions (m>=3)\n    # Exponent e from 3 to 60 (inclusive)\n    for e in range(3, 61):\n        low = 2\n        high = 2\n        while True:\n            terms = [pow(high, i) for i in range(e)]\n            total_terms = sum(terms)\n            if total_terms < n:\n                high *= 2\n            elif total_terms >= n:\n                break\n        else:\n            continue\n        \n        found = False\n        while low <= high:\n            mid = (low + high) // 2\n            try:\n                total_val = (pow(mid, e) - 1) // (mid - 1)\n            except ZeroDivisionError:\n                continue\n            if total_val == n:\n                found = True\n                break\n            elif total_val < n:\n                low = mid + 1\n            else:\n                high = mid - 1\n                \n        if found:\n            return \"YES\"\n            \n    return \"NO\"\n\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    t = int(data[0])\n    out_lines = []\n    index = 1\n    for _ in range(t):\n        n = int(data[index]); index += 1\n        res = solve_case(n)\n        out_lines.append(res)\n        \n    print(\"\\n\".join(out_lines))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 548,
        "completion_token_count": 1191,
        "thoughts_token_count": 8191
    }
}