{
    "start": 1758294356.849024,
    "end": 1758294652.774238,
    "start-formatted": "2025-09-20 00:05 KST",
    "end-formatted": "2025-09-20 00:10 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\n Okay, we are given R and B (number of rebels and bases) and then R lines for rebels and B lines for bases.\n Since R, B are at most 10, we can use a combinatorial approach.\n\n However, note: We require a perfect matching (so R must equal B? Actually the problem says \"every base has exactly one guardian and each spaceship has exactly one assigned base\", meaning that the assignment is a bijection. So we must have R = B? But wait, the input says two integers R and B. The example input first line is \"3 3\".\n\n Let me re-read: \"The first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10)\". Then there are R lines for rebels and B lines for bases.\n\n And the condition: any two straight paths (from a base to its assigned spaceship) do not intersect.\n\n But note: the problem does not explicitly say that R must equal B. However, a perfect matching requires |R| = |B|. So if R != B, then it's impossible.\n\n Steps:\n 1. If R != B, output 'No'.\n 2. Otherwise, we have R = B points (rebels and bases). We need to assign each base to one rebel and vice versa such that the straight lines (segments from base to rebel) do not intersect.\n\n However, note: the problem says \"any two (straight) paths\" meaning that if we draw all the segments, they should not cross.\n\n But note: the problem does not specify that the bases and rebels are distinct sets. However, the input guarantees no two points coincide and no three points are collinear.\n\n Important: We are allowed to have two non-intersecting segments even if they share an endpoint? The problem says \"paths\" from a base to its assigned spaceship. So endpoints are shared by exactly one segment. The condition is about two different paths (i.e., two different segments) not intersecting. So if two segments only meet at endpoints, that is allowed.\n\n How to solve?\n We can try to find a perfect matching (a permutation of bases to rebels) such that the set of segments (from base i to rebel j) do not cross.\n\n Observation: In the plane, non-crossing segments can be thought of as forming a planar graph. Moreover, we can fix an ordering of the rebels (or bases) and then consider the order in which the bases appear relative to the rebels.\n\n Alternatively, we can use a recursive backtracking (with R! possibilities, and R<=10 -> 10! = 3628800 which is acceptable in worst-case for small R=10? But wait, R=B and up to 10, so we have to try all permutations. However, 10! is 3.6e6, which is acceptable in Python if we implement efficiently.\n\n But note: We have to check for non-intersecting segments. How to check for non-intersecting segments?\n\n Conditions for two segments (A-B and C-D) to intersect (if they are not adjacent in the drawing) is given by the standard method: using the orientation (cross product) to check if they cross.\n\n However, note: our segments are defined by two sets of points: bases and rebels. We are going to assign each base to a unique rebel.\n\n Steps for checking non-intersection for a set of segments:\n\n We have n segments (n = R = B). We can check for every pair of segments (i, j) and (k, l) (with i,j,k,l being indices of the segments) whether they cross. But note: two segments that share a common endpoint (like a base or a rebel) do not cross (because they only meet at the endpoint). So we have to consider two segments that do not share a common endpoint.\n\n However, note: the entire set of segments must be pairwise non-intersecting (except at endpoints).\n\n But note: the problem says \"any two (straight) paths\". This means that we are considering every pair of paths (each path being a segment from base to rebel). Therefore, we must check that for every pair of segments (in the matching) that do not share a common endpoint, they do not intersect.\n\n However, there is a catch: if two segments share an endpoint, they are allowed. So we only need to check pairs of segments that are disjoint (no common endpoint).\n\n Algorithm for checking two segments (p1, q1) and (p2, q2) for intersection (without sharing endpoints) is well known:\n\n Let segment1 = (base_i, rebel_j) and segment2 = (base_k, rebel_l) and assume that {i, k} and {j, l} are disjoint (meaning the four points are distinct).\n\n Then, we can use the orientation method:\n\n   o1 = orientation",
    "response": "\nTo solve this problem, we need to determine if there exists a perfect matching between a set of Rebel spaceships and bases such that the straight-line segments connecting each base to its assigned spaceship do not intersect. The solution involves checking all possible permutations of assignments and verifying if any permutation satisfies the non-intersecting condition.\n\n### Approach\n1. **Problem Analysis**: The problem requires assigning each base to exactly one rebel spaceship such that the connecting segments do not intersect. The key observation is that for any two segments to not intersect, they must not cross each other in the plane. This involves checking all pairs of segments in the matching to ensure they only meet at their endpoints (if at all).\n\n2. **Intuition**: Since the number of rebels and bases (R and B) is small (up to 10), we can use a brute-force approach by generating all possible permutations of assignments. For each permutation, we check if the corresponding segments intersect. If any permutation satisfies the condition, the answer is \"Yes\"; otherwise, it's \"No\".\n\n3. **Algorithm Selection**: The solution involves:\n   - **Generating Permutations**: Use itertools.permutations to generate all possible assignments of bases to rebels.\n   - **Checking Segment Intersections**: For each permutation, verify that no two segments intersect except possibly at their endpoints. This is done using the orientation method to determine if segments cross.\n\n4. **Complexity Analysis**: The worst-case time complexity is O((R!) * (R^2)), where R is the number of rebels (and bases). Given that R is at most 10, the maximum number of permutations is 10! = 3,628,800, which is manageable for modern computers.\n\n### Solution Code\n```python\nimport itertools\n\ndef orientation(a, b, c):\n    val = (b[1] - a[1]) * (c[0] - b[0]) - (b[0] - a[0]) * (c[1] - b[1])\n    if val == 0:\n        return 0\n    elif val > 0:\n        return 1\n    else:\n        return 2\n\ndef do_segments_intersect(a, b, c, d):\n    o1 = orientation(a, b, c)\n    o2 = orientation(a, b, d)\n    o3 = orientation(c, d, a)\n    o4 = orientation(c, d, b)\n    \n    if o1 != o2 and o3 != o4:\n        return True\n        \n    if o1 == 0 and on_segment(a, b, c):\n        return True\n    if o2 == 0 and on_segment(a, b, d):\n        return True\n    if o3 == 0 and on_segment(c, d, a):\n        return True\n    if o4 == 0 and on_segment(c, d, b):\n        return True\n        \n    return False\n\ndef on_segment(a, b, c):\n    x1 = min(a[0], b[0])\n    x2 = max(a[0], b[0])\n    y1 = min(a[1], b[1])\n    y2 = max(a[1], b[1])\n    if x1 <= c[0] <= x2 and y1 <= c[1] <= y2:\n        return True\n    return False\n\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"No\")\n        return\n        \n    idx = 0\n    R = int(data[idx]); idx += 1\n    B = int(data[idx]); idx += 1\n    \n    rebels = []\n    for _ in range(R):\n        x = int(data[idx]); y = int(data[idx+1]); idx += 2\n        rebels.append((x, y))\n        \n    bases = []\n    for _ in range(B):\n        x = int(data[idx]); y = data[idx+1]; idx += 2\n        bases.append((x, int(y)))\n        \n    if R != B:\n        print(\"No\")\n        return\n        \n    n = R\n    points_rebel = rebels\n    points_base = bases\n    \n    if n == 0:\n        print(\"Yes\")\n        return\n        \n    bases_perm = list(itertools.permutations(points_base))\n    \n    for perm in bases_perm:\n        valid = True\n        for i in range(n):\n            for j in range(i+1, n):\n                seg1 = (points_rebel[i], perm[i])\n                seg2 = (points_rebel[j], perm[j])\n                if do_segments_intersect(seg1[0], seg1[1], seg2[0], seg2[1]):\n                    valid = False\n                    break\n            if not valid:\n                break\n                \n        if valid:\n            print(\"Yes\")\n            return\n            \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read from standard input, parsing the number of rebels (R) and bases (B), followed by their coordinates.\n2. **Initial Check**: If the number of rebels does not equal the number of bases, output \"No\" immediately since a perfect matching is impossible.\n3. **Permutation Generation**: All possible permutations of base assignments are generated. Each permutation represents a potential matching between bases and rebels.\n4. **Intersection Check**: For each permutation, the code checks if any two segments (from the matching) intersect. The `orientation` function determines the relative position of three points, and `do_segments_intersect` uses this to check if two segments cross.\n5. **Output Result**: If any permutation is found where all segments do not intersect, \"Yes\" is printed; otherwise, \"No\" is printed after all permutations are checked.\n\nThis approach efficiently checks all possible assignments, leveraging combinatorial generation and geometric intersection checks to solve the problem within feasible computational limits.",
    "ground_truth": "N/A",
    "extracted_answer": "import itertools\n\ndef orientation(a, b, c):\n    val = (b[1] - a[1]) * (c[0] - b[0]) - (b[0] - a[0]) * (c[1] - b[1])\n    if val == 0:\n        return 0\n    elif val > 0:\n        return 1\n    else:\n        return 2\n\ndef do_segments_intersect(a, b, c, d):\n    o1 = orientation(a, b, c)\n    o2 = orientation(a, b, d)\n    o3 = orientation(c, d, a)\n    o4 = orientation(c, d, b)\n    \n    if o1 != o2 and o3 != o4:\n        return True\n        \n    if o1 == 0 and on_segment(a, b, c):\n        return True\n    if o2 == 0 and on_segment(a, b, d):\n        return True\n    if o3 == 0 and on_segment(c, d, a):\n        return True\n    if o4 == 0 and on_segment(c, d, b):\n        return True\n        \n    return False\n\ndef on_segment(a, b, c):\n    x1 = min(a[0], b[0])\n    x2 = max(a[0], b[0])\n    y1 = min(a[1], b[1])\n    y2 = max(a[1], b[1])\n    if x1 <= c[0] <= x2 and y1 <= c[1] <= y2:\n        return True\n    return False\n\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"No\")\n        return\n        \n    idx = 0\n    R = int(data[idx]); idx += 1\n    B = int(data[idx]); idx += 1\n    \n    rebels = []\n    for _ in range(R):\n        x = int(data[idx]); y = int(data[idx+1]); idx += 2\n        rebels.append((x, y))\n        \n    bases = []\n    for _ in range(B):\n        x = int(data[idx]); y = data[idx+1]; idx += 2\n        bases.append((x, int(y)))\n        \n    if R != B:\n        print(\"No\")\n        return\n        \n    n = R\n    points_rebel = rebels\n    points_base = bases\n    \n    if n == 0:\n        print(\"Yes\")\n        return\n        \n    bases_perm = list(itertools.permutations(points_base))\n    \n    for perm in bases_perm:\n        valid = True\n        for i in range(n):\n            for j in range(i+1, n):\n                seg1 = (points_rebel[i], perm[i])\n                seg2 = (points_rebel[j], perm[j])\n                if do_segments_intersect(seg1[0], seg1[1], seg2[0], seg2[1]):\n                    valid = False\n                    break\n            if not valid:\n                break\n                \n        if valid:\n            print(\"Yes\")\n            return\n            \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 471,
        "completion_token_count": 1238,
        "thoughts_token_count": 1023
    }
}