{
    "start": 1758301967.9659793,
    "end": 1758305496.9577327,
    "start-formatted": "2025-09-20 02:12 KST",
    "end-formatted": "2025-09-20 03:11 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\n Okay, we are given a graph with n nodes and m edges. Each edge (u, v) gives two numbers: gcd and lcm.\n Conditions:\n  For an edge (u, v): \n      Let the number of mushrooms at u be a, at v be b.\n      Then we have: gcd(a, b) = given_gcd, and lcm(a, b) = given_lcm.\n\n We know that for two numbers a and b, we have:\n      a * b = gcd(a, b) * lcm(a, b)\n\n However, note that a and b must be multiples of the gcd. So we can write:\n      a = g * x, b = g * y, where g = gcd, and then x and y must be coprime (gcd(x,y)=1).\n      Then, the LCM would be g * x * y (because x and y are coprime).\n\n Also, from the relation: \n      g * x * y = LCM   =>   x * y = LCM / g.\n\n Steps:\n\n 1. Check consistency for each edge:\n      - The given LCM must be divisible by the given GCD. If not, output \"NO\".\n      - Let T = LCM // GCD. Then we need to split T into two coprime factors x and y (for the two nodes). But note: the same node might appear in multiple edges.\n\n 2. However, we have a graph. The entire graph must be consistent.\n\n Approach:\n\n We can use the following idea:\n\n   For each edge (u, v, g, l):\n        Let T = l // g. Then, the product of the two normalized values (i.e., a/g and b/g) is T, and they must be coprime.\n\n   Moreover, the normalized value for a node (say node i) must be the same in every edge incident to it? Not exactly: but note that if two edges incident to node i share the same normalized value (in terms of the prime factors) then we can combine.\n\n Alternatively, we can assign to each node a normalized value (or factorize the entire system) but note that the constraints are up to 10^6 and n, m can be up to 200000, so we need an efficient method.\n\n Another idea:\n\n   We know that for any two adjacent nodes, the product of their normalized values (without the common gcd) must be T (the quotient). And the normalized values must be coprime to each other for adjacent nodes.\n\n   Actually, let's denote for node i: value[i] = the number of mushrooms (which is positive integer).\n\n   Then for edge (u, v): \n        value[u] * value[v] = g * l.\n\n   And also, the gcd(value[u], value[v]) must equal the given g.\n\n   But note: we don't know the exact value, but we know that the value must be multiples of g. So we can set base value for each node? \n\n   However, the problem is that we don't know which g to use for which node. But note: the gcd for an edge is the gcd of the two nodes. So the gcd for an edge must divide both node values.\n\n   How about we try to assign to each node a value that is the product of some primes? Actually, we can think of the entire graph as having constraints on the prime factors.\n\n   Important: Since the gcd is the same for all edges that are connected, the prime factors that appear in the gcd must be present in all nodes that are connected? Actually, no: the gcd of two adjacent nodes is given, so the common primes must be exactly those in the gcd? Not necessarily: the gcd is the product of the minimum exponents of the primes in the two nodes.\n\n   This problem is similar to \"Prime Factorization\" and \"Graph Labeling\" problems.\n\n   Alternate approach:\n\n   Step 1: Check for each edge that (l % g == 0) and then T = l // g.\n\n   Step 2: Then, for each edge, we can express the two nodes' values as:\n        value[u] = g * a, value[v] = g * b, and then a * b = T, and gcd(a,b)=1.\n\n   But note: the same node might appear in multiple edges. So we must ensure that the normalized value (a for node u) is consistent across edges.\n\n   However, we can set up equations for the entire graph. But note: the graph is undirected.\n\n   We can do:\n\n        Let d[u] be the normalized value for node u (so that the actual value is g_edge * d[u] for the edge? but wait: the gcd is fixed per edge). \n\n   Actually, the gcd for an edge is the gcd of the two normalized values multiplied by the base? Not exactly.\n\n   Let me",
    "response": "\nTo solve this problem, we need to determine if it's possible to restore the number of mushrooms on each lawn (vertex) in a forest map based on given roads (edges) that provide the greatest common divisor (GCD) and least common multiple (LCM) of the mushroom counts on connected lawns. The solution involves verifying the consistency of these GCD and LCM values across all edges and ensuring that the derived mushroom counts for each lawn are valid.\n\n### Approach\n1. **Check Edge Consistency**: For each edge, verify that the LCM is divisible by the GCD. If not, the arrangement is impossible.\n2. **Normalize Values**: For each edge, compute the quotient \\( T = \\text{LCM} / \\text{GCD} \\). This quotient must be factorable into two coprime integers representing the normalized values of the connected nodes.\n3. **Graph Traversal**: Use a graph traversal approach to ensure that the normalized values for each node are consistent across all incident edges. Each node's normalized value must satisfy the product condition with its neighbors and maintain coprimality where required.\n4. **Validation**: During traversal, validate that the derived normalized values for each node do not conflict with any other edges connected to it. If any inconsistency is found, the arrangement is impossible.\n\n### Solution Code\n```python\nimport sys\nfrom collections import deque\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"NO\")\n        return\n    \n    n = int(data[0])\n    m = int(data[1])\n    edges = []\n    index = 2\n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index+1])\n        g = int(data[index+2])\n        l = int(data[index+3])\n        index += 4\n        edges.append((u-1, v-1, g, l))\n    \n    graph = [[] for _ in range(n)]\n    for u, v, g, l in edges:\n        if l % g != 0:\n            print(\"NO\")\n            return\n            \n        graph[u].append((v, g, l))\n        graph[v].append((u, g, l))\n        \n    base_vals = [0] * n\n    T_vals = [0] * n\n    \n    for i in range(n):\n        if graph[i]:\n            _, g, l = graph[i][0]\n            T = l // g\n            base_vals[i] = g\n            T_vals[i] = T\n        else:\n            base_vals[i] = 0\n            T_vals[i] = 0\n            \n    visited = [False] * n\n    q = deque()\n    for i in range(n):\n        if not visited[i] and graph[i]:\n            q.append(i)\n            visited[i] = True\n            \n    parent = [-1] * n\n    while q:\n        node = q.popleft()\n        for neighbor, g, l in graph[node]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                parent[neighbor] = node\n                q.append(neighbor)\n                \n    result = [0] * n\n    for i in range(n):\n        if i == 0:\n            result[i] = 1\n            continue\n            \n        if parent[i] == -1:\n            continue\n            \n        p = parent[i]\n        if base_vals[p] == 0:\n            continue\n            \n        g_p, l_p = None, None\n        for nb, g_val, l_val in graph[p]:\n            if nb == i:\n                g_p = g_val\n                l_p = l_val\n                break\n                \n        T_p = l_p // g_p\n        \n        if base_vals[i] == 0:\n            base_vals[i] = base_vals[p]\n            T_vals[i] = T_p\n        \n        if base_vals[i] != base_vals[p]:\n            print(\"NO\")\n            return\n            \n        if T_vals[i] == 0:\n            T_vals[i] = T_p\n            \n        if result[p] == 0:\n            g_p = base_vals[p]\n            x = result[p] // g_p\n            y = result[i] // base_vals[i]\n            if x * y != T_p or gcd(x, y) != 1:\n                print(\"NO\")\n                return\n                \n    for i in range(n):\n        if T_vals[i] != 0:\n            x = result[i] // base_vals[i]\n            if x * x != T_vals[i]:\n                print(\"NO\")\n                return\n                \n    print(\"YES\")\n    for i in range(n):\n        if base_vals[i] == 0:\n            result[i] = 1\n        else:\n            if T_vals[i] == 0:\n                x = 1\n            else:\n                x = 1\n                for j in range(2, int(T_vals[i]**0.5)+1):\n                    cnt = 0\n                    while T_vals[i] % j == 0:\n                        cnt += 1\n                        T_vals[i] //= j\n                    if cnt > 0:\n                        x *= j\n                if T_vals[i] > 1:\n                    x *= T_vals[i]\n                    \n            result[i] = base_vals[i] * x\n            \n    print(\" \".join(map(str, result)))\n    \ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Input Parsing**: The input is read and parsed into the number of lawns (n) and roads (m), followed by the details of each road (connected lawns and their GCD/LCM values).\n2. **Edge Validation**: For each road, check if the LCM is divisible by the GCD. If not, output \"NO\" immediately as the arrangement is impossible.\n3. **Graph Construction**: Construct an adjacency list for the graph where each node points to its connected neighbors along with the GCD and LCM values of the connecting road.\n4. **Base Value Assignment**: Assign initial base values (GCD) and T values (LCM/GCD) to each node. Nodes with no edges are initialized to default values.\n5. **Graph Traversal**: Perform a BFS traversal to ensure connectivity and derive normalized values for each node. During traversal, check for consistency in the derived values by ensuring they meet the product and coprimality conditions specified by the edges.\n6. **Result Validation**: After traversal, validate that all derived values satisfy the conditions for each edge. If any inconsistency is found, output \"NO\". Otherwise, output \"YES\" followed by the restored mushroom counts for each lawn.\n\nThis approach efficiently checks for the feasibility of restoring the mushroom counts and ensures the solution adheres to the given constraints and conditions.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"NO\")\n        return\n    \n    n = int(data[0])\n    m = int(data[1])\n    edges = []\n    index = 2\n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index+1])\n        g = int(data[index+2])\n        l = int(data[index+3])\n        index += 4\n        edges.append((u-1, v-1, g, l))\n    \n    graph = [[] for _ in range(n)]\n    for u, v, g, l in edges:\n        if l % g != 0:\n            print(\"NO\")\n            return\n            \n        graph[u].append((v, g, l))\n        graph[v].append((u, g, l))\n        \n    base_vals = [0] * n\n    T_vals = [0] * n\n    \n    for i in range(n):\n        if graph[i]:\n            _, g, l = graph[i][0]\n            T = l // g\n            base_vals[i] = g\n            T_vals[i] = T\n        else:\n            base_vals[i] = 0\n            T_vals[i] = 0\n            \n    visited = [False] * n\n    q = deque()\n    for i in range(n):\n        if not visited[i] and graph[i]:\n            q.append(i)\n            visited[i] = True\n            \n    parent = [-1] * n\n    while q:\n        node = q.popleft()\n        for neighbor, g, l in graph[node]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                parent[neighbor] = node\n                q.append(neighbor)\n                \n    result = [0] * n\n    for i in range(n):\n        if i == 0:\n            result[i] = 1\n            continue\n            \n        if parent[i] == -1:\n            continue\n            \n        p = parent[i]\n        if base_vals[p] == 0:\n            continue\n            \n        g_p, l_p = None, None\n        for nb, g_val, l_val in graph[p]:\n            if nb == i:\n                g_p = g_val\n                l_p = l_val\n                break\n                \n        T_p = l_p // g_p\n        \n        if base_vals[i] == 0:\n            base_vals[i] = base_vals[p]\n            T_vals[i] = T_p\n        \n        if base_vals[i] != base_vals[p]:\n            print(\"NO\")\n            return\n            \n        if T_vals[i] == 0:\n            T_vals[i] = T_p\n            \n        if result[p] == 0:\n            g_p = base_vals[p]\n            x = result[p] // g_p\n            y = result[i] // base_vals[i]\n            if x * y != T_p or gcd(x, y) != 1:\n                print(\"NO\")\n                return\n                \n    for i in range(n):\n        if T_vals[i] != 0:\n            x = result[i] // base_vals[i]\n            if x * x != T_vals[i]:\n                print(\"NO\")\n                return\n                \n    print(\"YES\")\n    for i in range(n):\n        if base_vals[i] == 0:\n            result[i] = 1\n        else:\n            if T_vals[i] == 0:\n                x = 1\n            else:\n                x = 1\n                for j in range(2, int(T_vals[i]**0.5)+1):\n                    cnt = 0\n                    while T_vals[i] % j == 0:\n                        cnt += 1\n                        T_vals[i] //= j\n                    if cnt > 0:\n                        x *= j\n                if T_vals[i] > 1:\n                    x *= T_vals[i]\n                    \n            result[i] = base_vals[i] * x\n            \n    print(\" \".join(map(str, result)))\n    \ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\nif __name__ == '__main__':\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 552,
        "completion_token_count": 1433,
        "thoughts_token_count": 1023
    }
}