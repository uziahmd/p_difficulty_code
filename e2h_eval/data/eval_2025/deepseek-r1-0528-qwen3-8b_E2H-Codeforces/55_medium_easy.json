{
    "start": 1758308308.0564556,
    "end": 1758311732.4399931,
    "start-formatted": "2025-09-20 03:58 KST",
    "end-formatted": "2025-09-20 04:55 KST",
    "gpu": 2,
    "pid": 55,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Minimum Ternary String\n\nYou are given a ternary string (it is a string which consists only of characters '0', '1' and '2').You can swap any two adjacent (consecutive) characters '0' and '1' (i.e. replace \"01\" with \"10\" or vice versa) or any two adjacent (consecutive) characters '1' and '2' (i.e. replace \"12\" with \"21\" or vice versa).For example, for string \"010210\" we can perform the following moves:   \"010210\" $$$\\rightarrow$$$ \"100210\";  \"010210\" $$$\\rightarrow$$$ \"001210\";  \"010210\" $$$\\rightarrow$$$ \"010120\";  \"010210\" $$$\\rightarrow$$$ \"010201\". Note than you cannot swap \"02\" $$$\\rightarrow$$$ \"20\" and vice versa. You cannot perform any other operations with the given string excluding described above.You task is to obtain the minimum possible (lexicographically) string by using these swaps arbitrary number of times (possibly, zero).String $$$a$$$ is lexicographically less than string $$$b$$$ (if strings $$$a$$$ and $$$b$$$ have the same length) if there exists some position $$$i$$$ ($$$1 \\le i \\le |a|$$$, where $$$|s|$$$ is the length of the string $$$s$$$) such that for every $$$j < i$$$ holds $$$a_j = b_j$$$, and $$$a_i < b_i$$$.\n\n## Input\nThe first line of the input contains the string $$$s$$$ consisting only of characters '0', '1' and '2', its length is between $$$1$$$ and $$$10^5$$$ (inclusive).\n\n## Output\nPrint a single string â€” the minimum possible (lexicographically) string you can obtain by using the swaps described above arbitrary number of times (possibly, zero).\n\n## Example\n### Input\n['100210', '11222121', '20']\n\n### Output\n['001120', '11112222', '20']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\n Okay, we are allowed to swap adjacent '0' and '1', and adjacent '1' and '2'. Note that we cannot swap '0' and '2' directly.\n\n Observation:\n Since we can only swap '0' with '1' and '1' with '2', the relative order of the three digits (with respect to each other) is constrained by their inherent ordering: '0' < '1' < '2'.\n\n However, note that we can move a '0' arbitrarily to the left (by swapping with any preceding '1's or even '0's? Wait, but we cannot swap two zeros. But we can use the '1' as an intermediary. Similarly, we can move a '2' arbitrarily to the right (by swapping with any following '1's). But what about moving a '1'? It can be moved both left and right because it can swap with both '0' and '2'.\n\n However, note: we cannot swap two zeros or two twos or two ones. But we can use the fact that a '0' can move through a sequence of '1's to get to the left, and a '2' can move through a sequence of '1's to get to the right. Also, a '1' can move through zeros and twos.\n\n Actually, think of the swaps as being allowed for adjacent pairs that are either \"01\" (swap to \"10\") or \"12\" (swap to \"21\"). This means:\n\n - A '0' can only move to the left, because to move right it would have to swap with a '1' (if there is one on the right) but then we can also swap a '0' and '1' in either direction. However, if there is a '1' to the left, we can swap the '0' with the '1' and then the '0' moves right? Wait, no: the operation is defined for adjacent pairs. So:\n\n Operation 1: swap '0' and '1' when adjacent (so \"01\" becomes \"10\", meaning the '0' moves one to the right and the '1' one to the left).\n Operation 2: swap '1' and '2' (so \"12\" becomes \"21\", meaning the '1' moves one to the right and the '2' one to the left).\n\n But note: we can do these operations repeatedly. So:\n\n - A '0' can be moved to the left by swapping with a '1' (if there is a '1' immediately to the left, then we swap and the '0' moves left) but to move a '0' to the right we can use a '1' to the right? Actually, the operation \"01\" -> \"10\" moves the '0' to the right. Similarly, the operation \"10\" -> \"01\" moves the '0' to the left.\n\n However, wait: the problem says we can swap adjacent '0' and '1' (meaning we can replace \"01\" with \"10\" OR \"10\" with \"01\"). So we can move a '0' both left and right, as long as there is a '1' adjacent. Similarly, for '1' and '2'.\n\n But note: we cannot move a '0' through a '2' because we don't have an operation for \"02\". Similarly, we cannot move a '2' through a '0'. However, we can move a '0' through a sequence of '1's and a '2' through a sequence of '1's.\n\n Therefore, the key is that the relative order of the three types is fixed except that we can rearrange the positions of the digits arbitrarily as long as we preserve the following:\n\n - All the '0's must appear before all the '1's? Not necessarily. Consider: we can have a '0' that is originally after a '1', but we can move the '0' to the left past the '1' (if we swap them). Similarly, we can move a '2' to the right past a '1'.\n\n However, note that we cannot move a '0' to the right past a '2' without a '1' in between? Actually, we can use multiple swaps. For example, to move a '0' from the right side of a '2' to the left, we need to first move the '0' left until it meets a '1' (if there is one) and then use the '1' to break through the '2'? But wait, we can also move the '2' to the right and the '0' to the left independently? \n\n Alternatively, note that the graph of allowed swaps is connected for the entire string? Actually, we can consider the string as having three types and the allowed swaps are between consecutive numbers (in the ordering 0<1<2). This is similar to sorting with adjacent swaps for three distinct elements, but with restrictions.\n\n In fact, we can think of the problem as having three independent chains (for 0, 1, 2) and the operations allow:\n\n - A '0' can be swapped with a '1' (if they are adjacent) and then the '1' can be swapped with a '2' (if adjacent). This means that a '0' can effectively jump over a '2' if there is a '1' in between. But without a '1', a '0' cannot jump over a '2'.\n\n Therefore, we can model the problem as follows:\n\n We have three independent tokens: 0, 1, 2. The allowed swaps are between 0 and 1, and between 1 and 2. This is similar to a graph where each node (each character) can be moved, but the movement is constrained by the presence of the other type.\n\n How to achieve the lexicographically smallest string?\n\n Lexicographical order: '0' is smallest, then '1', then '2'.\n\n We want to push all the zeros to the front? But note: we can only swap adjacent zeros and ones, and ones and twos. We cannot swap zeros and twos. So we can separate the zeros from the twos only if there is at least one one in between? Actually, we can have zeros and twos interleaved arbitrarily with ones, but without ones we cannot have zeros and twos adjacent.\n\n However, note: we can rearrange the entire string arbitrarily as long as the relative order of the zeros, ones, and twos is such that:\n\n - The zeros can be placed arbitrarily to the left of the ones and the ones arbitrarily to the left of the twos? Actually, no. Because we cannot swap zeros and twos, but we can use the ones as intermediaries. However, the relative order of zeros and twos might be changed if there are ones in between.\n\n Example: \"02\" -> cannot be swapped. But if we have \"012\", we can swap the '0' and '1' to get \"102\", and then swap the '1' and '2' (if we had a '1' and then a '2')? Actually, in \"102\", we can swap the '0' and the '1' again to get back to \"012\", or we can swap the '0' and the next character? The next character is '2' but we cannot swap '0' and '2'. So from \"012\", we can only swap the first two to get \"102\", and from \"102\" we can swap the last two (the '0' and '2')? No, because the operation is only for swapping adjacent '0' and '1' or adjacent '1' and '2'. So in \"102\", we can swap the '0' and '1' (to go back) or swap the '0' and '2'? No, because they are not adjacent? Actually, in \"102\", the '0' is adjacent to the '1' (left) and the '2' (right). But we cannot swap the '0' and the '2' (because they are adjacent, but the operation doesn't allow swapping non-adjacent ones, and the operation for swapping '0' and '2' is not allowed). So the string \"102\" is stuck.\n\n But note: we can also move the '1' in \"102\": \n   - Swap the '1' and '0' (back to \"012\")\n   - Or, if we have a longer string, we can use other characters.\n\n However, the problem is that we cannot change the relative order of zeros and twos if they are separated by ones? Actually, we can break the separation by moving the ones away. But note: we can move the zeros arbitrarily to the left and the twos arbitrarily to the right, but the ones can be used to bridge the zeros and twos.\n\n Alternate approach:\n\n Since we can move zeros arbitrarily to the left (if there are ones to the left, we can swap the zero with the one and then the zero moves left, and the one moves right) and similarly, we can move twos arbitrarily to the right (by swapping with ones), but we cannot move a zero to the right past a two (without having ones to help? Actually, we can use ones to break the barrier). \n\n However, note that the problem is equivalent to having three independent stacks (or queues) for each digit, and the allowed swaps let you interleave the three stacks, but with the constraint that zeros can only be placed to the left of ones, and ones to the left of twos? Not exactly, because we can have a one that was originally to the left of a zero, but we can move the zero to the left past the one (so the one gets pushed to the right). Similarly, we can move a two to the right past a one.\n\n Actually, the minimal lexicographic string should have all zeros at the beginning, then all ones, then all twos? Not necessarily: because we can have zeros and ones arbitrarily mixed, and ones and twos arbitrarily mixed, but zeros and twos must not be adjacent unless there is a one separating them? However, we can break the adjacency by using ones as buffers.\n\n But note: we are allowed to perform arbitrary swaps. So we can rearrange the entire string arbitrarily as long as the relative order of the zeros and ones is preserved? No, because we can swap zeros and ones arbitrarily, so the zeros and ones can be rearranged arbitrarily. Similarly, the ones and twos can be rearranged arbitrarily. However, the zeros and twos cannot be swapped directly, but since we can use the ones as intermediaries, we can actually achieve any permutation of the three sets as long as the zeros come before the twos? \n\n Let me test:\n\n Example: \"20\" -> cannot be changed (since no adjacent 0 and 1 or 1 and 2). So the answer for \"20\" is \"20\".\n\n Example: \"02\" -> same.\n\n Example: \"012\": \n   We can form: \n      Original: 0 1 2\n      Swap 0 and 1: 1 0 2\n      Then swap 0 and 2? Not allowed.\n      Or swap 1 and 2: from 1 0 2, we can swap the 1 and 2? No, because the adjacent pair is (1,0) and (0,2). We cannot swap 1 and 2 if they are not adjacent. But we can swap the 0 and 2? No.\n\n      Alternatively, from 012, we can swap 1 and 2 first? No, because the adjacent pair is (0,1) and (1,2). So we can swap the (1,2) to get 021. Then from 021, we can swap the (0,2)? No. Or swap the (2,1) to get 012 again.\n\n      Actually, we can do:\n          Start: 012\n          Swap 0 and 1: 102\n          Then swap 0 and 2? Not adjacent, so we cannot. But wait, in 102, the two is at index 2 and the 0 is at index 1. They are adjacent? Yes, because the string is \"102\": the characters are at indices 0:'1', 1:'0', 2:'2'. So the '0' and '2' are adjacent. However, the operation does not allow swapping '0' and '2'. So we cannot swap them.\n\n      Therefore, from \"012\", we can only get two strings: \"012\" and \"102\" (and then from \"102\" we can swap the '0' and '1' again to get \"012\"). So we cannot get \"021\" from \"012\" by the allowed operations? Wait, how did I get 021? \n\n      Correction: In \"012\", if we swap the middle '1' and the last '2', we get \"021\". But wait, the operation is for adjacent '1' and '2'. So we can swap the '1' and '2' (which are adjacent in \"012\") to get \"021\". Then from \"021\", we can swap the '0' and '2'? No, but we can swap the '2' and '1' (if they become adjacent) but they are not adjacent. Actually, in \"021\", we have:\n        index0: '0', index1: '2', index2: '1'\n        Now, we can swap the '0' and '2'? No. But we can swap the '2' and '1' (because they are adjacent) to get \"012\". Or we can swap the '0' and the next character? The next is '2', which is not allowed.\n\n      So from \"012\", we can get:\n          \"012\" -> swap(0,1) -> \"102\"\n          \"012\" -> swap(1,2) -> \"021\"\n\n      Then from \"102\": swap(0,1) again -> \"012\", or swap(1,2) is not possible because the adjacent pairs are (1,0) and (0,2) -> no '1' and '2' adjacent? Actually, in \"102\", the two is at index2, and the '1' is at index0, so they are not adjacent. So we can only swap the first two (if we swap the '1' and '0') to get \"012\".\n\n      From \"021\": we can swap the last two (the '2' and '1') to get \"012\".\n\n      So the possible arrangements from \"012\" are: \"012\", \"102\", \"021\".\n\n      Now, lexicographical order: \n        \"012\": starts with '0'\n        \"102\": starts with '1'\n        \"021\": starts with '0'\n\n      Then we compare the second character: for \"012\" and \"021\", the second character is '1' and '2' respectively. So \"012\" is lex smaller than \"021\".\n\n      Therefore, the minimal string is \"012\".\n\n      But wait, we started from \"012\", and we can get \"012\", \"102\", \"021\". The smallest is \"012\".\n\n      What if we start with \"021\"? Then we can only get \"012\" and \"021\" (by swapping the last two). Then the minimal is \"012\".\n\n      So the goal is to arrange the string so that the zeros are as left as possible, then the ones, then the twos? But note: in the example above, we can have a zero and then a two without a one in between? Actually, no: we cannot swap a zero and a two, so if we have a zero and then a two, we cannot change that. But wait, we can break that by inserting a one? \n\n      However, the total multiset of characters is fixed. The operations are reversible and the set of achievable arrangements is all the arrangements that can be obtained by interleaving the three sequences (the zeros, ones, twos) but with the constraint that the zeros can only appear to the left of the ones (if we consider the original positions) but wait, we can move zeros arbitrarily to the left, and ones arbitrarily to the left of twos, but what about the relative order of zeros and ones? \n\n      Actually, note: we can swap zeros and ones arbitrarily (because we can swap adjacent ones and zeros as many times as we want). Similarly, we can swap ones and twos arbitrarily. But we cannot change the relative order of zeros and twos without having a one in between? \n\n      Let me think about the relative orders:\n\n      Consider two zeros and two ones and two twos. The operations are transpositions (swaps) that are allowed only between adjacent 0-1 and 1-2.\n\n      This problem is known to be solvable by considering the following:\n\n      We can independently sort the zeros and ones, and the ones and twos, but we have to combine them appropriately.\n\n      However, note that the lexicographical order is defined by the first character, then second, etc.\n\n      Another idea: \n\n      Since we can move zeros arbitrarily to the left (by swapping with ones) and twos arbitrarily to the right (by swapping with ones), the minimal lexicographical string will have:\n\n        All the zeros as far to the left as possible, then all the ones as far to the left as possible (but now we can also have some zeros and ones already placed, and then the twos.\n\n      But wait, we can also have ones that were originally to the left of zeros, and we can move zeros to the left so that zeros become the first characters. Similarly, we can move twos to the right.\n\n      Therefore, the minimal string is achieved by:\n\n        Step 1: Move all zeros to the leftmost positions (if we can, by swapping with ones that are to the right of the zeros).\n        Step 2: Then, among the remaining positions (after the zeros), we want to put the ones as left as possible, but note: we can also move ones from the right part (where there are twos) to the left (where there are zeros) but we already put zeros to the left. However, we can also use the ones to break the zeros and twos.\n\n      Actually, we can consider that the entire string can be rearranged arbitrarily as long as the relative order of zeros and ones is the same as in the original string? No, because we can swap zeros and ones arbitrarily (any number of adjacent swaps). Similarly, we can swap ones and twos arbitrarily.\n\n      But note: the zeros and ones can be arranged arbitrarily (any permutation of zeros and ones is achievable) because we can swap any two adjacent zeros and ones arbitrarily? Actually, no: we cannot swap two zeros or two ones. But we can use the ones as intermediaries to move zeros arbitrarily. Similarly, we can use zeros to help move ones? \n\n      However, the set of achievable arrangements is all those that have the same relative order for zeros and ones as in the original? Actually, no: we can reverse the order of zeros and ones arbitrarily? \n\n      Example: two zeros and two ones: \"0011\", \"0101\", \"0110\", \"1001\", \"1010\", \"1100\" are all achievable? \n\n      Let me try with \"01\":\n\n        We can swap to get \"10\". Then from \"10\", we can swap again to get \"01\". So we can swap arbitrarily.\n\n      Similarly, for three zeros and two ones, we can move the ones arbitrarily.\n\n      Therefore, the zeros and ones can be arranged arbitrarily (any permutation of zeros and ones is achievable). Similarly, the ones and twos can be arranged arbitrarily.\n\n      But what about zeros and twos? We cannot swap zeros and twos directly. However, we can use the ones as intermediaries. \n\n      Example: \"02\": cannot be swapped. But if we have \"012\", we can swap the 0 and 1 to get \"102\", and then swap the 1 and 2 (if we have a one and a two adjacent) to get \"021\" (wait, we did that earlier). \n\n      Actually, we can break the direct adjacency of a zero and a two by inserting a one. But note: the total number of ones is fixed.\n\n      The key: the zeros and twos can be rearranged arbitrarily if there is at least one one present? Because we can use the ones to break the barrier.\n\n      However, if there are no ones, then zeros and twos cannot be swapped. So the relative order of zeros and twos is fixed.\n\n      Therefore, the solution:\n\n      Let n0 = count of '0', n1 = count of '1', n2 = count of '2'\n\n      We can independently arrange the zeros and ones arbitrarily, and the ones and twos arbitrarily. But the zeros and twos cannot be swapped unless there is at least one one.\n\n      But note: the zeros and ones can be arranged arbitrarily, and the ones and twos can be arranged arbitrarily. However, the zeros and twos are linked through the ones.\n\n      Actually, the entire string can be rearranged arbitrarily if there is at least one '1'? Because we can use the ones to break the zeros and twos. But wait, consider: we have two zeros and two twos and one one. We can arrange the zeros and twos arbitrarily by moving the one around. \n\n      However, without ones, we cannot change the relative order of zeros and twos.\n\n      Therefore, the minimal lexicographical string is:\n\n        We want to put zeros at the beginning, then ones, then twos? But wait, we can also put zeros and then ones and then twos, but is that the minimal?\n\n        Example: \"012\" -> \"012\" is minimal.\n\n        Example: \"021\": we can rearrange to \"012\", which is minimal.\n\n        Example: \"102\": we can rearrange to \"012\", which is minimal.\n\n        Example: \"20\": cannot be rearranged because there is no one, so the relative order is fixed.\n\n        Example: \"02\": same.\n\n        Example: \"21\": same.\n\n        Example: \"12\": we can swap to \"21\", but that's worse. Actually, we want the minimal. For \"12\", we can swap to \"21\", but \"12\" is lex smaller than \"21\"? Actually, '1' < '2', so \"12\" is already minimal.\n\n        But wait, the allowed swap for \"12\" is to swap to \"21\", but we don't have to do that. We can leave it as \"12\". However, if we have more characters, we might be able to use the ones to move zeros to the left.\n\n      After analysis, note:\n\n        The operations allow us to independently sort the zeros and ones (i.e., put all zeros to the left of ones) and the ones and twos (put all ones to the left of twos). However, we cannot directly put zeros to the left of twos.\n\n        But note: we can put zeros to the left of twos if we use ones as intermediaries. However, the relative order of zeros and twos is not fixed unless there are no ones.\n\n        Actually, the minimal lexicographical string must be the one that has:\n\n          All zeros at the very beginning (if possible) and then all ones, then all twos.\n\n        But wait: if we have no ones, then we cannot change the zeros and twos. So the minimal string is the one that is already as left as possible for zeros, and then the rest.\n\n        However, we can also have zeros and ones arbitrarily arranged, and ones and twos arbitrarily arranged, but the zeros and twos cannot be arbitrarily arranged.\n\n        Actually, the minimal string is:\n\n          We can choose the positions for zeros, ones, and twos arbitrarily, except that the zeros must appear before the twos? Not exactly: the zeros can appear anywhere as long as we don't have a two that cannot be moved to the right. But we can move zeros to the left and twos to the right, and we can move ones arbitrarily.\n\n        There is a known solution for such problems: \n\n        We can use a bubble sort-like idea, but that would be too slow for n=10^5.\n\n        Alternatively, we can note that the allowed swaps are adjacent swaps for (0,1) and (1,2). This is similar to having three independent tokens and the ability to swap adjacent tokens of two adjacent types (like in a graph with edges between 0-1 and 1-2). \n\n        The minimal lexicographical arrangement is the one that is sorted in increasing order: \"0\" < \"1\" < \"2\". But we cannot swap zeros and twos. However, we can use the ones to break the zeros and twos.\n\n        Actually, we can achieve the sorted order (all zeros, then ones, then twos) if we have at least one '1'. Because we can move all zeros to the left (using the ones as stepping stones) and then move all ones to the left (relative to the twos) by swapping the ones with the twos.\n\n        But what if there are no ones? Then we cannot change the relative order of zeros and twos, so we must leave the string as is (but we can still rearrange zeros and twos that are separated by nothing? Actually, no, because we cannot swap zeros and twos). So the string remains with zeros and twos in their original relative order.\n\n        However, wait: without ones, we can still rearrange the zeros arbitrarily (by swapping zeros and ones? but there are no ones) and the twos arbitrarily (by swapping ones and twos? but there are no ones). So without ones, we cannot do any swaps. Therefore, the string is fixed.\n\n        But note: the problem allows swapping adjacent '0' and '1' and adjacent '1' and '2'. Without ones, we cannot do any swaps. So the string is fixed.\n\n        Therefore, the solution:\n\n          If there is at least one '1' in the string, then we can rearrange the entire string to be all zeros, then ones, then twos.\n\n          Why? Because:\n\n            - We can move every zero to the leftmost available position (by swapping with ones that are in the way).\n            - Then, we can move every one to the next available position (from the end of the zeros to the beginning of the twos) by swapping ones with zeros (if there are zeros left) or with twos (if there are twos). But wait, we don't want to move ones to the left of zeros? Actually, we are putting zeros first. Then, we move the ones to the left of the twos.\n\n          However, note: we can also have the possibility of zeros and twos being separated by ones. The sorted order (zeros then ones then twos) is the lexicographically smallest.\n\n        Example: \"012\" -> sorted order is \"012\", which is the minimal.\n\n        Example: \"021\": we can move the two to the right (past the one) to get \"012\". But wait, in \"021\", the two is between the zero and the one. We can swap the two and the one (adjacent) to get \"012\".\n\n        Example: \"102\": we can move the zero to the left (past the one) to get \"012\".\n\n        Example: \"210\": \n          We have a two, then a one, then a zero.\n          We can swap the two and the one (adjacent) to get \"102\", then swap the one and the zero (adjacent) to get \"012\".\n\n        Example: \"201\": \n          We have a two, then a zero, then a one.\n          We cannot swap the two and the zero (no operation for that). But we can swap the zero and the one to get \"210\", then swap the two and the one to get \"102\", then swap the one and the zero to get \"012\".\n\n        Therefore, if there is at least one '1', we can always get the sorted string (all zeros, then ones, then twos).\n\n        But wait: what if we have multiple ones? We can still do the same.\n\n        However, consider: \"10\" -> we can swap to \"01\", which is the sorted order (zeros then ones). Then the twos (if any) would be after the ones.\n\n        Therefore, the algorithm:\n\n          Count the frequency of '0', '1', '2'.\n\n          If there is no '1' in the string, then we cannot change the relative order of zeros and twos. But note: we can still rearrange the zeros arbitrarily (by swapping zeros and ones? but there are no ones) and the twos arbitrarily (by swapping ones and twos? but there are none). So we cannot do any swaps.\n\n          However, wait: without ones, we can still swap zeros and ones? No, because there are no ones. Similarly, we cannot swap ones and twos. So we cannot do any swaps.\n\n          Therefore, if there are no ones, we output the original string.\n\n          But wait, we can also have a string with only zeros and ones, or only ones and twos. Then we can swap the zeros and ones arbitrarily (if there is at least one '1')? Actually, if the string has no twos, then we can arrange the zeros and ones arbitrarily (because we can swap zeros and ones arbitrarily). Similarly, if there are no zeros, we can arrange the ones and twos arbitrarily.\n\n          Actually, the condition for being able to swap zeros and ones is the presence of at least one '1'. Similarly, the condition for being able to swap ones and twos is the presence of at least one '1'. \n\n          Therefore, if the string contains at least one '1', we can achieve the sorted string (all zeros, then ones, then twos). Otherwise, we cannot change the string.\n\n        But wait: what if the string has no ones, but has zeros and ones? Then there is at least one '1'. Similarly, if there are no ones, then the string consists only of zeros and twos.\n\n        So the algorithm:\n\n          Step 1: Check if the string contains at least one '1'.\n          Step 2: If yes, then we can rearrange the entire string to be zeros first, then ones, then twos. Then output the string: n0 times '0', then n1 times '1', then n2 times '2'.\n\n          But wait, is that the minimal? Yes, because lexicographical order: zeros are smallest, then ones, then twos.\n\n          Step 3: If no, then we cannot change the relative order of zeros and twos. But note: we can still rearrange zeros arbitrarily (if there are ones? no, because there are no ones) and twos arbitrarily (if there are ones? no). However, we can also rearrange the zeros and ones arbitrarily (if there are ones, then we can; but there are none). Similarly, we can rearrange ones and twos arbitrarily (if there are ones, then we can; but there are none). \n\n          But wait, what if the string has no ones, then we can only swap zeros and ones if there is a '1', which there isn't. Similarly, we cannot swap ones and twos. And we cannot swap zeros and twos. So we cannot do any swaps.\n\n          Therefore, we output the original string.\n\n        However, wait: the above reasoning is flawed because we can also have a string that is entirely zeros, or entirely ones, or entirely twos, or zeros and twos, etc.\n\n        Example: \"000\" -> no ones, so we output \"000\", which is correct.\n\n        Example: \"111\" -> no zeros and twos, but we can swap zeros and ones? There are no zeros, so we cannot. Similarly, we cannot swap ones and twos. But wait, the string \"111\" has no adjacent 0-1 or 1-2, so no swaps. But we can rearrange zeros and ones arbitrarily if there is at least one one and zeros? Actually, the presence of ones alone doesn't require zeros. Similarly, the presence of ones alone doesn't require twos.\n\n        Actually, the rule is: we can only swap adjacent 0-1 and 1-2. So in \"111\", there is nothing to swap.\n\n        But note: the problem states that we can swap adjacent '0' and '1' OR adjacent '1' and '2'. So if we have a string of only ones, we cannot do any swaps. Similarly, a string of only zeros: we cannot do any swaps (because we need a one to swap with). Same for twos.\n\n        Therefore, the condition for being able to change the string is the presence of at least one '1'. Then, we can rearrange the entire string arbitrarily (i.e., we can put all zeros first, then ones, then twos). But wait, what if the string has no zeros? Then we put zeros (none) then ones then twos. Similarly, if no ones, we cannot change.\n\n        But wait, what if the string has no ones, but has zeros and ones? Then there is at least one '1'. Actually, if the string contains at least one '1', then we can rearrange arbitrarily (because we can use the ones to break the zeros and twos). \n\n        Correction: the condition is the presence of at least one '1'. Then we can rearrange the entire string to the sorted order (zeros, then ones, then twos). \n\n        However, note: the sorted order is the minimal lexicographical string.\n\n        But wait: is the sorted order (all zeros, then ones, then twos) always achievable when there is at least one '1'? \n\n        Example: \"021\" has a '1', so we can rearrange to \"012\", which is the sorted order.\n\n        Example: \"210\" has a '1', so we can rearrange to \"012\".\n\n        Example: \"201\" has a '1', so we can rearrange to \"012\".\n\n        Example: \"000111222\" (already sorted) -> remains.\n\n        Example: \"222111000\" (reverse sorted) -> we can move the zeros to the left (using the ones) and the ones to the left of the twos.\n\n        Therefore, the solution:\n\n          Read the string s.\n\n          Let n0 = count of '0'\n          Let n1 = count of '1'\n          Let n2 = count of '2'\n\n          If there is at least one '1' in the string (i.e., n1 > 0):\n              Output: '0' * n0 + '1' * n1 + '2' * n2\n\n          Else:\n              Output: the original string s\n\n        However, wait: what if the string has no ones, but has zeros and ones? Then the condition (at least one '1') is true. But if there are no ones, then n1==0.\n\n        So the condition is: if n1 == 0, then output s; else output the sorted string.\n\n        But wait: what if the string is \"012\" and we have one '1'? Then we output \"012\", which is correct.\n\n        But consider: what if the string is \"102\" (which has a '1')? Then we output \"012\", which is the sorted string.\n\n        However, what if the string is \"000111222\" (already sorted) and has ones? Then we output \"000111222\", which is correct.\n\n        But wait, is that always the minimal? \n\n        Example: \"000111222\" is the same as the sorted string.\n\n        Example: \"0000\" (only zeros) -> no ones, so output the original string. But the original string is \"0000\", and we cannot change it because we need a one to swap. So that's correct.\n\n        Example: \"1111\" -> no zeros and twos, but we have ones. Then we output \"1111\", which is the sorted string (zeros:0, ones:4, twos:0). But wait, we can also rearrange the ones arbitrarily? Actually, the ones are identical, so it doesn't matter. But we can only swap adjacent ones? Actually, we cannot swap two ones (because the operation requires swapping a one with a zero or a two). So in a string of only ones, we cannot do any swaps. So the output is the original string. But wait, the sorted string is \"1111\", which is the same as the original. So that's okay.\n\n        However, consider: \"000111222\" is the same as the sorted string. But what if we have \"000222111\"? \n\n        This string has no ones? Actually, it does have ones. So we output \"000111222\".\n\n        But wait, the input \"000222111\" has three zeros, then three twos, then three ones. There is at least one '1' (three ones).",
    "response": "\nTo solve this problem, we need to find the lexicographically smallest string that can be obtained by performing a series of adjacent swaps on a ternary string consisting of characters '0', '1', and '2'. The allowed swaps are between adjacent '0' and '1' or between adjacent '1' and '2'. \n\n### Approach\n1. **Problem Analysis**: The key observation is that if the string contains at least one '1', we can rearrange all the '0's to the left, followed by all the '1's, and then all the '2's. This arrangement is the lexicographically smallest possible because '0' is the smallest character, followed by '1', and then '2'. However, if there are no '1's in the string, no swaps are possible, and the original string remains unchanged since we cannot swap '0' and '2' directly.\n\n2. **Algorithm Selection**: The solution involves checking for the presence of at least one '1' in the string. If found, we simply concatenate all '0's, then all '1's, and finally all '2's to form the result. Otherwise, we return the original string as no swaps can be performed.\n\n3. **Complexity Analysis**: The algorithm processes the string in linear time to count the occurrences of each character and checks for the presence of '1's. The overall time complexity is O(n), where n is the length of the string, making it efficient for large inputs (up to 10^5 characters).\n\n### Solution Code\n```python\ndef main():\n    s = input().strip()\n    n0 = s.count('0')\n    n1 = s.count('1')\n    n2 = s.count('2')\n    \n    if n1 == 0:\n        print(s)\n    else:\n        result = '0' * n0 + '1' * n1 + '2' * n2\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Input Handling**: The input string is read from standard input.\n2. **Character Counting**: The code counts the number of '0's, '1's, and '2's in the string.\n3. **Condition Check**: If there are no '1's in the string, the original string is printed because no swaps can be performed. Otherwise, the result is constructed by concatenating all '0's, followed by all '1's, and then all '2's, which is printed as the output.\n4. **Output**: The result is printed, which is the lexicographically smallest string achievable under the given constraints.\n\nThis approach efficiently leverages the allowed swaps to determine the optimal arrangement of characters, ensuring minimal lexicographical order with optimal performance.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    s = input().strip()\n    n0 = s.count('0')\n    n1 = s.count('1')\n    n2 = s.count('2')\n    \n    if n1 == 0:\n        print(s)\n    else:\n        result = '0' * n0 + '1' * n1 + '2' * n2\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 588,
        "completion_token_count": 582,
        "thoughts_token_count": 8191
    }
}