{
    "start": 1758298920.7004716,
    "end": 1758302314.7081528,
    "start-formatted": "2025-09-20 01:22 KST",
    "end-formatted": "2025-09-20 02:18 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\n Okay, we are to find:\n   t = the minimum number of edges to add to form a simple cycle of odd length (with more than one vertex)\n   w = the number of ways to add t edges to achieve that\n\n Conditions: \n   The graph is undirected, without parallel edges or loops, and not necessarily connected.\n\n Important: We cannot add parallel edges or loops.\n\n Observations:\n\n 1. Odd cycle: In an undirected graph, an odd cycle must have an odd number of edges (so the cycle length is odd).\n 2. We are allowed to add edges arbitrarily (without creating multiple edges or loops). But note: we want the minimum number of edges to add.\n\n Let's consider possibilities:\n\n Case 0: If the graph already contains an odd-length cycle, then t=0 and w=1? But wait, note: we are forming a cycle by adding edges. However, if the graph already has an odd cycle, then no edge needs to be added. But note: the problem says \"form a simple cycle of an odd length\". So if there is one, then we don't need to add any edge. However, the problem states: \"the minimum number of edges that must be added\".\n\n Therefore, if there is already an odd cycle, then t=0, and w=1? Actually, if there is at least one odd cycle, then we don't need to add any edge. But note: the problem might have multiple odd cycles, but that doesn't matter because we only require that after adding edges (possibly zero) we have at least one odd cycle.\n\n However, wait: the problem does not say that we must form an odd cycle by adding edges, but we can form one by adding edges. But if there is already an odd cycle, then we don't need to add any edge.\n\n But note: the problem says \"minimum number of edges that must be added\", so if the graph already has an odd cycle, then we don't need to add any.\n\n However, note: the example input '3 3\\n1 2\\n2 3\\n3 1' (a triangle) gives output '0 1'. So yes, if the graph has an odd cycle, then t=0 and w=1.\n\n What if the graph does not have an odd cycle?\n\n Then we must add at least one edge. But what are the possibilities?\n\n Note: We can also form an odd cycle by connecting two even components? Or by connecting two vertices from different cycles?\n\n Let's break down:\n\n - An odd cycle must have an odd number of edges and an odd number of vertices.\n\n Possibility 1: Adding one edge to form an odd cycle.\n\n How can one edge create an odd cycle?\n\n Example: Consider a graph with two triangles (each triangle is an odd cycle) but wait, if there are two triangles, then the graph already has an odd cycle. So we assume no odd cycle exists.\n\n Alternatively, consider a bipartite graph. In a bipartite graph, every cycle is even. So if the graph is bipartite, then it has no odd cycle. But note: the graph may not be connected, so we have multiple connected components, each of which is bipartite.\n\n Now, if we add an edge within a bipartite component: \n\n   Suppose we have a bipartite component with bipartition (A, B). Adding an edge between two nodes in A (or in B) would break the bipartiteness of that component, and might create an odd cycle.\n\n   Specifically, if we add an edge between two nodes u and v that are in the same part (say both in A) of a connected bipartite component, then consider the shortest path from u to v (which must go through B). Then the cycle formed by the path and the new edge would be of length (path_length + 1). Since the path_length is even (because u and v are in the same set, the distance between them is even), then the cycle length is odd.\n\n   Therefore, adding one edge within a single bipartite component (connecting two nodes in the same part) will create an odd cycle.\n\n   But note: if the entire graph is bipartite (each connected component is bipartite) and we are going to add one edge, then we can do this for every pair of nodes (u, v) that are in the same part in the same component.\n\n   However, we must avoid adding edges that are already present. But note: the input graph does not have parallel edges, so we know that the edge (u,v) is not present.\n\n   But wait: what if the graph is already complete? Then we cannot add any edge. However, the problem states that the graph does not have parallel edges or loops, but it might be sparse.\n\n   However, the problem says: \"It is prohibited to add loops or parallel edges.\" So we can only add edges",
    "response": "\nTo solve this problem, we need to determine the minimum number of edges (t) that must be added to a given undirected graph to form a simple cycle of odd length, and the number of ways (w) to add those edges. The solution involves analyzing the graph's structure, particularly its bipartite nature, to identify the conditions under which an odd cycle can be formed.\n\n### Approach\n1. **Check for Existing Odd Cycles**: If the graph already contains an odd-length cycle, no edges need to be added (t = 0, w = 1). This is determined by checking if any connected component of the graph is not bipartite.\n2. **Bipartite Graph Analysis**: If the graph is bipartite (all connected components are bipartite), then adding an edge within a single component between two nodes in the same partition will create an odd cycle. The minimum number of edges to add is 1 in this case.\n3. **Count Valid Edges**: For each bipartite connected component, count the number of non-existing edges between nodes in the same partition. The total number of ways to add one edge (w) is the sum of these counts across all components.\n4. **Disconnected Graph Handling**: If the graph is disconnected, the solution must consider all connected components separately. However, if any component is not bipartite, t remains 0 and w is 1.\n\n### Solution Code\n```python\nimport sys\nfrom collections import deque\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"0 0\")\n        return\n        \n    n = int(data[0])\n    m = int(data[1])\n    edges = []\n    index = 2\n    graph = [[] for _ in range(n+1)]\n    \n    for i in range(m):\n        u = int(data[index]); v = int(data[index+1]); index += 2\n        edges.append((u, v))\n        graph[u].append(v)\n        graph[v].append(u)\n        \n    visited = [False] * (n+1)\n    color = [-1] * (n+1)\n    is_bipartite = True\n    components = []\n\n    for i in range(1, n+1):\n        if not visited[i]:\n            q = deque([i])\n            visited[i] = True\n            color[i] = 0\n            comp_nodes = [i]\n            while q:\n                node = q.popleft()\n                for neighbor in graph[node]:\n                    if not visited[neighbor]:\n                        visited[neighbor] = True\n                        color[neighbor] = color[node] ^ 1\n                        comp_nodes.append(neighbor)\n                        q.append(neighbor)\n                    else:\n                        if color[neighbor] == color[node]:\n                            is_bipartite = False\n            components.append((comp_nodes, color))\n            \n    total_ways = 0\n    found_odd_cycle = False\n\n    for comp in components:\n        nodes = comp[0]\n        part0 = []\n        part1 = []\n        for node in nodes:\n            if color[node] == 0:\n                part0.append(node)\n            else:\n                part1.append(node)\n                \n        total_edges_in_comp = len(edges) - (len(edges) // (n+1)) * (n+1)   # Not needed, but example code for illustration\n        total_nodes = len(nodes)\n        max_edges_in_comp = total_nodes * (total_nodes - 1) // 2\n        existing_edges = len(edges) // 2   # Not accurate without tracking edges per component, but for illustration\n        \n        missing_edges_in_comp = max_edges_in_comp - existing_edges   # Not accurate, just for illustration\n        \n        same_color_edges = (len(part0)*(len(part0)-1)//2 + len(part1)*(len(part1)-1)//2)\n        total_ways += same_color_edges\n\n    if not is_bipartite:\n        print(\"0 1\")\n        return\n        \n    if n == 1:\n        print(\"0 0\")\n        return\n        \n    if n >= 3:\n        t = 1\n        w = total_ways\n        print(f\"{t} {w}\")\n    else:\n        print(\"0 0\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Graph Input Handling**: The input is read and parsed into a graph structure represented as an adjacency list.\n2. **Bipartite Check**: Using BFS, each connected component is checked for bipartiteness by attempting to color nodes with two colors. If any component cannot be colored without conflicts, it contains an odd cycle.\n3. **Edge Calculation**: For each bipartite component, the number of edges that can be added within the same partition to form an odd cycle is calculated. The sum of these edges across all components gives the total ways (w) to add one edge.\n4. **Output**: If an odd cycle exists, output (0, 1). Otherwise, output (1, w) where w is the total valid edges to add. Special cases (like a single-node graph) are handled separately.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"0 0\")\n        return\n        \n    n = int(data[0])\n    m = int(data[1])\n    edges = []\n    index = 2\n    graph = [[] for _ in range(n+1)]\n    \n    for i in range(m):\n        u = int(data[index]); v = int(data[index+1]); index += 2\n        edges.append((u, v))\n        graph[u].append(v)\n        graph[v].append(u)\n        \n    visited = [False] * (n+1)\n    color = [-1] * (n+1)\n    is_bipartite = True\n    components = []\n\n    for i in range(1, n+1):\n        if not visited[i]:\n            q = deque([i])\n            visited[i] = True\n            color[i] = 0\n            comp_nodes = [i]\n            while q:\n                node = q.popleft()\n                for neighbor in graph[node]:\n                    if not visited[neighbor]:\n                        visited[neighbor] = True\n                        color[neighbor] = color[node] ^ 1\n                        comp_nodes.append(neighbor)\n                        q.append(neighbor)\n                    else:\n                        if color[neighbor] == color[node]:\n                            is_bipartite = False\n            components.append((comp_nodes, color))\n            \n    total_ways = 0\n    found_odd_cycle = False\n\n    for comp in components:\n        nodes = comp[0]\n        part0 = []\n        part1 = []\n        for node in nodes:\n            if color[node] == 0:\n                part0.append(node)\n            else:\n                part1.append(node)\n                \n        total_edges_in_comp = len(edges) - (len(edges) // (n+1)) * (n+1)   # Not needed, but example code for illustration\n        total_nodes = len(nodes)\n        max_edges_in_comp = total_nodes * (total_nodes - 1) // 2\n        existing_edges = len(edges) // 2   # Not accurate without tracking edges per component, but for illustration\n        \n        missing_edges_in_comp = max_edges_in_comp - existing_edges   # Not accurate, just for illustration\n        \n        same_color_edges = (len(part0)*(len(part0)-1)//2 + len(part1)*(len(part1)-1)//2)\n        total_ways += same_color_edges\n\n    if not is_bipartite:\n        print(\"0 1\")\n        return\n        \n    if n == 1:\n        print(\"0 0\")\n        return\n        \n    if n >= 3:\n        t = 1\n        w = total_ways\n        print(f\"{t} {w}\")\n    else:\n        print(\"0 0\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 573,
        "completion_token_count": 1081,
        "thoughts_token_count": 1023
    }
}