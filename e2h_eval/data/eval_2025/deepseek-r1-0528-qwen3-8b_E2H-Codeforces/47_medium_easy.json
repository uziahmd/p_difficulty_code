{
    "start": 1758296843.2736375,
    "end": 1758300251.9955356,
    "start-formatted": "2025-09-20 00:47 KST",
    "end-formatted": "2025-09-20 01:44 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\n Okay, we are given two integers a and b (1 <= a, b <= 10^9). We are to find a non-negative integer k such that the LCM(a+k, b+k) is minimized, and if there are multiple k with the same minimal LCM, choose the smallest k.\n\n Observation:\n Let d = (a+k, b+k) be the greatest common divisor. Then note that d divides (b - a) because:\n   (a+k) - (b+k) = a - b.\n\n So, d must be a divisor of |a-b|. Also, note that k must satisfy:\n   k >= max(0, d - a) and similarly for b? Actually, we can write:\n\n   Let g = gcd(a+k, b+k). Then we have:\n      a+k = g * x\n      b+k = g * y\n   and then x and y must be coprime. Moreover, the LCM would be g * x * y.\n\n But note: k = g*x - a = g*y - b, so g*(x-y) = a-b. Therefore, g must divide (a-b). However, note that if a==b then k=0 gives LCM(a, a)=a, but wait, let's check:\n\n If a == b, then for any k, we have LCM(a+k, a+k) = a+k. We want to minimize a+k, so k=0 is the best.\n\n However, note: the problem says \"non-negative integer k\", so k>=0.\n\n Alternate approach:\n\n We know that the LCM of two numbers m and n is m*n / GCD(m,n). We want to minimize LCM(a+k, b+k) = (a+k)*(b+k) / GCD(a+k, b+k).\n\n But note: GCD(a+k, b+k) = GCD(a+k, (b+k) - (a+k)) = GCD(a+k, b-a). So the GCD is a divisor of (b-a) (assuming b>=a, without loss of generality, because if a>b, then we can swap by symmetry, but note: the problem doesn't specify which is bigger).\n\n Actually, we can assume without loss of generality that a <= b. But note: the input order is arbitrary.\n\n Steps:\n\n 1. If a == b, then we return 0.\n\n 2. Otherwise, let d = |a-b|. Then the GCD(a+k, b+k) must divide d. And note that k must be chosen so that (a+k) and (b+k) are divisible by some divisor of d.\n\n How to relate k and the divisors?\n\n We have: \n   GCD(a+k, b+k) = g, then g divides d. Then k must satisfy: k ≡ (-a) mod g and k ≡ (-b) mod g. But note that since g divides d, and d = b-a (assuming b>a), then the condition on k is that k ≡ (-a) mod g, and also note that k must be at least max(0, g - a) (if g > a then k must be at least g-a, but if g <= a then k>=0 is okay).\n\n However, we cannot iterate over all divisors of d and then for each divisor g, solve for k because d can be up to 10^9, and the number of divisors is about O(sqrt(d)) which is acceptable (since 10^9 has at most around 1344 divisors). But note: we have to consider negative divisors? Actually, divisors are positive. But note: what if we consider divisors of |a-b|, including both positive and negative? Actually, we only consider positive divisors because GCD is positive.\n\n But note: the equation is k ≡ (-a) mod g. This means k + a is divisible by g. Similarly, k+b is divisible by g. So k must be at least g - a (if a < g) and similarly for b. However, we are looking for the smallest k.\n\n However, note that the LCM expression: LCM(a+k, b+k) = (a+k)*(b+k)/g. We want to minimize this.\n\n Alternatively, we can consider the following:\n\n Let d = |a-b|. Then the possible GCDs are the divisors of d. For each divisor g (positive) of d, we can set:\n\n   k0 = (-a) mod g   [but note: we require k>=0, and we can set k0 = (g - a % g) % g, but wait: we need k such that (a+k) % g == 0. The smallest non-negative k for which (a+k) % g == 0 is: \n        k0 = (g - a % g) % g\n\n However, note: if a % g == 0, then k0=0. But also, note that k must satisfy (b+k) % g == 0 as well. But since g divides d = |a-b|, then (a+k) % g = (b+k) % g? \n\n Actually, because (a+k) - (b+k) = a-b, and g divides a-b, then (a+k) % g = (b+k) % g is not necessarily true. However, if g divides (a-b) then (a+k) % g = (b+k) % g? Not exactly, but note:\n\n   (a+k) - (b+k) = a-b, so if g divides a-b, then (a+k) ≡ (b+k) (mod g). Therefore, if (a+k) is divisible by g then (b+k) is also divisible by g.\n\n So for each divisor g of d (positive), we can compute:\n\n   k_candidate = (g - a % g) % g   [this gives the smallest k0>=0 such that (a+k0) is divisible by g]\n\n But note: there might be a constraint from b? Actually, since g divides d, then (a+k0) divisible by g implies (b+k0) divisible by g. So k0 is valid.\n\n Then the LCM for k0 is: \n   LCM0 = (a+k0)*(b+k0)//g\n\n However, note: the GCD of (a+k0, b+k0) might be more than g? Actually, we set g as the divisor we are considering, but the actual GCD might be a multiple of g. But wait: we are iterating over divisors of d, and the GCD must divide d. However, when we set k0 as above, the GCD will actually be at least g (because g divides both a+k0 and b+k0). But it might be larger. However, note that we are trying to set the GCD to be g, but the LCM formula we use is (a+k0)*(b+k0)//g, but the actual GCD might be greater than g. \n\n Let me clarify:\n\n   Let g0 = GCD(a+k0, b+k0). Then g0 divides d, and g0 is a divisor of d. Moreover, g0 divides (a+k0) and (b+k0). But we set k0 such that g divides (a+k0) and (b+k0). Then g divides g0, so g0 is a multiple of g. But then we are not using the correct GCD in our LCM calculation.\n\n This approach is flawed.\n\n Alternative Insight:\n\n Since the GCD of (a+k, b+k) must divide (a-b), we can consider for each divisor g of |a-b| (if a != b), then the condition is that g divides (a+k) and (b+k). Then k must be chosen so that k ≡ (-a) mod g and k ≡ (-b) mod g. But note that since g divides (a-b), the two congruences are consistent.\n\n Then the minimal k for divisor g is the minimal non-negative solution to:\n\n   k ≡ r (mod g)   where r = (-a) mod g.\n\n But note: the minimal k is r, unless r is negative then we adjust. Actually, we can compute:\n\n   k_min = (g - a % g) % g\n\n Then the LCM for this k is: (a+k_min)*(b+k_min)//gcd(a+k_min, b+k_min)\n\n However, the GCD(a+k_min, b+k_min) might be greater than g? Yes, because the GCD must be a divisor of |a-b|, and in fact, the GCD is the greatest common divisor of (a+k_min) and (b+k_min). But note: since we forced g to divide both, the GCD is at least g, but could be a multiple of g (if there is a larger divisor that divides both and also divides |a-b|). \n\n Therefore, we cannot use g as the GCD in the LCM formula. Instead, for each candidate k (which we get from each divisor g of |a-b|), we compute the actual GCD and then the LCM.\n\n However, note: the problem is that the number of divisors is not too big (at most 1344), so we can do:\n\n   candidates = set()\n   candidates.add(0)   # because k=0 is always a candidate.\n\n   d = abs(a-b)\n   if d == 0:\n        print(0)\n        exit(0)\n\n   Find all divisors g of d.\n\n   For each divisor g (positive) of d:\n        k0 = (g - a % g) % g   # This gives the smallest nonnegative k such that (a+k) is divisible by g.\n        # But note: we must also ensure that k0 is at least 0, and we are generating one candidate per divisor.\n\n        # However, we should also note that k0 might be negative? Our modulo operation ensures nonnegative.\n\n        # Then we compute the actual GCD for (a+k0) and (b+k0): g0 = gcd(a+k0, b+k0)\n        # Then LCM = (a+k0)*(b+k0) // g0\n\n        # But wait: is k0 the only candidate for this divisor? Actually, the general solution for k is k0 + t*g for t>=0. We are only interested in the smallest k for each divisor, because if we take a larger k, the numbers a+k and b+k become larger, so the LCM will likely be larger. However, note: sometimes a larger k might yield a larger divisor (so a better reduction) and hence a smaller LCM? Actually, no: the LCM is the product divided by the GCD. The product increases with k, but the GCD might be larger. However, the divisor g we are using is the divisor we fixed, but the actual GCD might be larger. \n\n        # Actually, we are iterating over divisors of |a-b|, and the actual GCD must be a divisor of |a-b|. So if we fix g, then the actual GCD will be a multiple of g (if there is a common factor beyond g). But note: we are not forcing the GCD to be exactly g, so we cannot use the divisor g to directly compute the LCM.\n\n        # However, we can compute the candidate k0 for each divisor and then compute the LCM for that k0. Then we compare the LCMs.\n\n        # But note: the candidate k0 we get from divisor g might not be the minimal k that leads to a divisor that is a multiple of g. Actually, we are generating one candidate per divisor, and the LCM for that candidate is (a+k0)*(b+k0)//gcd_value, where gcd_value is the actual GCD (which is the GCD of (a+k0) and (b+k0)).\n\n        # But then why iterate divisors? Because the actual GCD must be a divisor of d, so we are covering all possibilities.\n\n   However, there is a catch: the same k might be generated by multiple divisors. We can use a set to avoid duplicates.\n\n Steps:\n\n   Step 1: If a == b, output 0.\n\n   Step 2: Let d = abs(a-b). Collect all divisors of d.\n\n   Step 3: Initialize:\n        best_k = 0\n        best_lcm = lcm(a, b)   # which is (a*b)//gcd(a,b)\n\n   Step 4: For each divisor g in the divisors of d (including 1 and d):\n\n        k0 = (g - a % g) % g   [This gives the smallest nonnegative k such that (a+k) is divisible by g]\n\n        # But note: we can also consider the possibility that k0 is negative? The modulo operation with %g ensures nonnegative.\n\n        candidate_k = k0\n\n        # Now, we must compute the actual GCD for (a+candidate_k) and (b+candidate_k). Then the LCM is (a+candidate_k)*(b+candidate_k) // actual_gcd.\n\n        num1 = a + candidate_k\n        num2 = b + candidate_k\n        actual_gcd = math.gcd(num1, num2)\n        current_lcm = (num1 * num2) // actual_gcd\n\n        Then compare current_lcm with best_lcm. If current_lcm < best_lcm, update best_lcm and best_k = candidate_k.\n        If current_lcm == best_lcm and candidate_k < best_k, then update best_k = candidate_k.\n\n        But note: we must consider that the same k might appear from multiple divisors. We are using a set or we can use a dictionary to record the best_lcm for each k? Actually, we are iterating over divisors and we might get the same k multiple times. However, we don't need to record by k, we can simply update the best_k and best_lcm.\n\n   Step 5: Output best_k.\n\n However, note: is it possible that the minimal k does not come from a divisor of |a-b|? No, because the GCD must divide |a-b|, and the k we choose must make the GCD divide |a-b|. But note: the condition for the GCD is that it divides |a-b|, and we are iterating over all divisors. However, we are generating k0 for each divisor g (the divisor being the GCD? not necessarily). Actually, we are generating k0 for each divisor g (which is a divisor of |a-b|) such that g divides (a+k0). Then the actual GCD is a divisor of |a-b| (and divides both numbers) but might be a multiple of g. But note: we are not forcing the GCD to be g, so the candidate k0 we generate from divisor g might also be generated by a divisor h (where h divides g) and then the actual GCD might be h (or something else). \n\n But wait: we are iterating over every divisor. So even if the actual GCD is h (a divisor of g), we will also consider h and then generate a candidate k0' for h. And k0' might be different from k0.\n\n However, note: the condition for the divisor h is independent. The candidate k0 for divisor g is the smallest nonnegative k such that g divides (a+k). But if h divides g, then k0 is also a solution for h? Not necessarily, because:\n\n   k0 satisfies (a+k0) mod g = 0. Then (a+k0) mod h = 0? Not necessarily, because g is divisible by h, so if (a+k0) is divisible by g, then it is divisible by h. So k0 is also a solution for h.\n\n But then, we are going to get the same k0 from divisor h (if h divides g). However, the candidate k0 for divisor h is defined as (h - a % h) % h, which might be different from k0 (unless h divides g and g divides (a+k0)). \n\n Actually, the candidate k0 for divisor g is the smallest nonnegative k such that g divides (a+k). The candidate for divisor h (if h divides g) is the smallest nonnegative k such that h divides (a+k). But note: if g divides (a+k0), then h divides (a+k0) (because h divides g). Therefore, the candidate for h must be at most k0 (since k0 is a solution for h). But wait: the candidate for h is the smallest nonnegative solution. So if k0 is a solution for h, then the candidate for h is <= k0. Therefore, we might miss a smaller k for the divisor h.\n\n This indicates that we should iterate over the divisors and for each divisor, we consider the candidate k. But note: the set of divisors is the same (all divisors of d). The candidate k for divisor h is the smallest k such that h divides (a+k). And then the candidate k for divisor g (a multiple of h) is at least the candidate for h (if we consider the minimal solution for g, it might be a multiple of h, but note: the minimal solution for g is (g - a % g) % g, and the minimal solution for h is (h - a % h) % h, which is <= (g - a % g) % g? Not necessarily, because g is a multiple of h, but the modulo operation is independent.\n\n Example: a=6, b=10, d=4, divisors: [1,2,4].\n\n For g=1: k0 = (1-6%1)%1 = 0. Then we compute LCM(6,10)=30.\n For g=2: k0 = (2-6%2)%2 = (2-0)%2 = 0. Then LCM(6,10)=30.\n For g=4: k0 = (4-6%4)%4 = (4-2)%4 = 2. Then LCM(8,12)=24.\n\n But note: k=2 is the answer.\n\n However, we also have to consider that k=0 and k=2 are two candidates. The LCM for k=0 is 30, for k=2 is 24. So we pick k=2.\n\n But wait: what about k=1? Why didn't we consider k=1? \n\n   For k=1: \n        a+1=7, b+1=11, GCD(7,11)=1, LCM=77.\n\n   Why isn't k=1 considered? \n\n   Because the GCD(7,11)=1, which divides d=4. So we did consider divisor 1, and the candidate k0 for divisor 1 is 0, but we didn't consider k=1 for divisor 1? \n\n   Actually, for divisor 1, the candidate k0 is 0. But note: k=1 also satisfies the condition for divisor 1 (since 7 mod 1==0, but wait: any integer mod1 is 0). So the candidate k0 for divisor 1 is 0, but k=1 is also a solution for divisor 1. However, we are only taking the minimal k for each divisor. \n\n   The problem: we are only checking the minimal k for each divisor. But note: the LCM for k=1 is 77, which is worse than the LCM for k=0 (30) and k=2 (24). \n\n   However, we are missing the candidate k=1 because we only considered k0 (the minimal k for divisor 1). But note: the minimal k for divisor 1 is 0, and then we computed LCM for k=0. But k=1 is not the minimal k for divisor 1, so we don't consider it. \n\n   But wait: the divisor 1 condition is satisfied by every k, so we are only concerned with the minimal k for each divisor? Actually, the problem is that the LCM might be minimized at a k that is not minimal for the divisor? \n\n   However, note: the LCM expression is (a+k)*(b+k)/gcd(a+k, b+k). As k increases, the product (a+k)*(b+k) increases, and the gcd might change. But note: the gcd is at least 1, so the LCM is at least (a+k)*(b+k)/d_max (which is bounded by |a-b|). \n\n   But observe: the minimal k for divisor g is the smallest k that makes the gcd divisible by g. Then the LCM for that k is (a+k)*(b+k)/g0, where g0 is the actual gcd (which is at least g). \n\n   However, we are not forced to use the minimal k for each divisor. There might be a larger k that leads to a larger gcd (so the denominator is larger) and hence a smaller LCM. \n\n   Example: consider a=5, b=10. Then d=5, divisors=[1,5]. \n\n        k0 for divisor 1: (1-5%1)%1 -> 0. Then LCM(5,10)=10.\n        k0 for divisor 5: (5-5%5)%5 = (5-0)%5=0. Then LCM(5,10)=10.\n\n        But what if k=5?\n          Then a+5=10, b+5=15, GCD(10,15)=5, LCM= (10*15)/5 = 30 -> worse.\n\n        What if k=4?\n          Then a+4=9, b+4=14, GCD=1, LCM=126.\n\n        What if k=3?\n          Then 8 and 13, GCD=1, LCM=104.\n\n        k=2: 7 and 12, GCD=1, LCM=84.\n\n        k=1: 6 and 11, GCD=1, LCM=66.\n\n        k=0: 5 and 10, LCM=10.\n\n        So the minimal LCM is 10, achieved at k=0.\n\n   But consider another example: a=2, b=4, d=2, divisors=[1,2].\n\n        k0 for divisor1: 0 -> LCM(2,4)=4.\n        k0 for divisor2: (2-2%2)%2 = 0 -> LCM(2,4)=4.\n\n        Now try k=1: \n            3 and 5 -> GCD=1, LCM=15 -> worse.\n\n        k=2: \n            4 and 6 -> GCD=2, LCM=(4*6)//2=12.\n\n        k=3:\n            5 and 7 -> GCD=1, LCM=35.\n\n        So minimal is k=0.\n\n   But wait, the example in the problem: \"5 10\" gives k=0, and the example \"6 10\" gives k=2.\n\n   Why k=2 for 6 and 10? \n\n        Without any divisor (other than 1) we get k=0: LCM(6,10)=30.\n        With divisor 2: k0=0 -> LCM(6,10)=30.\n        With divisor 4: k0=2 -> LCM(8,12)=24.\n\n        So we found k=2.\n\n   Why didn't we consider k=1? Because k=1 is not a solution for any divisor (except divisor1, and for divisor1 we only consider k=0). But note: the divisor condition is necessary: the GCD must divide d. The GCD for k=1 is 1, which divides d=4. But we already considered divisor1 (g=1) and the minimal k for divisor1 is 0. However, we did not consider k=1 for divisor1 because we only took the minimal k (0) for divisor1. \n\n   But note: the LCM for k=1 is 77, which is worse than k=0 (30). So even though k=1 is valid, it is not beneficial.\n\n   However, there is a catch: the minimal k for divisor1 is 0, but what if we take k=1 for divisor1? Then we get a larger product and the same GCD (which is 1) so the LCM is larger. So we don't need to consider non-minimal ks for divisors.\n\n   But wait: what if a divisor g is not the actual GCD? Then the minimal k for divisor g is k0, and the LCM we compute for k0 uses the actual GCD (which might be larger than g). Then we are effectively considering a candidate k0 that might have an actual GCD larger than g, but we are not sure. However, we are iterating over all divisors, so the actual GCD (which is a divisor of d) will be considered when we iterate that divisor.\n\n   Therefore, the plan is:\n\n        Let S be the set of divisors of |a-b| (if a==b, then we output 0 and exit).\n\n        For each divisor g in S (positive divisors):\n\n            k0 = (g - a % g) % g   [minimal k for divisor g]\n\n            Then, we compute the actual GCD for (a+k0, b+k0) and the LCM.\n\n        Then we compare the LCMs and remember the smallest LCM and the smallest k that achieves that LCM.\n\n        Additionally, we must consider that k=0 is always there (from divisor1, unless a %1==0, which is always true, so k0=0 for divisor1). But note: what if a % g is 0? Then k0=0.\n\n        However, we must also note: the divisors include 1, so k0=0 is always considered.\n\n        But wait: what about k values that are not generated by any divisor? They must still have a GCD that divides d. So they are covered by the divisor being that GCD. But we are iterating over all divisors, so we cover all possible GCDs.\n\n        However, note: the candidate k0 for a divisor g is the minimal k such that g divides (a+k). Then the actual GCD for (a+k0, b+k0) is the GCD of the two numbers, which must be a divisor of d. But we don't know which divisor. We are computing it.\n\n        But note: we are iterating over every divisor, so we are considering every possible GCD. However, the same k might be generated by multiple divisors, but that's okay because we are comparing the LCMs.\n\n   But note: the problem constraints: a, b up to 10^9, so d can be up to 10^9. The number of divisors is about O(sqrt(d)), which is acceptable (around 10^3 to 10^4 divisors in worst-case? Actually, worst-case is about 1344 divisors for numbers with many divisors).\n\n   However, note: we must also consider that k0 might be very large? For example, if g is very close to a, then (a % g) might be a % g (if g>a, then a % g = a) so k0 = g - a. But note: g is a divisor of d, and d = |a-b|, which is at most 10^9, so g<=10^9. Then k0 = g - a, and if g is large (e.g., g = d) then k0 = d - a, which is |a-b| - a. Since |a-b| can be up to 10^9, then k0 can be up to 10^9. Then we are computing a+k0 = a + (d - a) = d, and b+k0 = b + (d - a). But note: d = |a-b|, so if a>=b then d = a-b, so k0 = (a-b) - a = -b, which is negative. But wait: we defined d = |a-b|, so if a>=b then d = a-b, then k0 = (g - a % g) % g. But if g = a-b (and a>=b) then a % g = a % (a-b) = (a-b + b) % (a-b) = b % (a-b). \n\n   Let me clarify: we must define d = |a-b|, and then consider positive divisors.\n\n   Actually, we can assume without loss of generality that a <= b. Then d = b - a, and then divisors are positive. Then for a divisor g of d, we compute:\n\n        k0 = (g - a % g) % g\n\n   But if a % g is 0, then k0=0.\n\n   However, note: if g is greater than a, then a % g = a, so k0 = (g - a) % g. But (g - a) is positive because g>a, so k0 = g - a.\n\n   Example: a=2, b=10 (then d=8). Consider divisor g=8 (which is d). Then k0 = (8 - 2%8) %8 = (8-2)%8=6.\n\n   Then we compute: \n        a+k0=2+6=8, b+k0=10+6=16, GCD(8,16)=8, LCM= (8*16)//8=16.\n\n   But is k=6 the best? \n\n        k=0: LCM(2,10)=10 -> wait, 10 is less than 16. So k=0 is better.\n\n   But wait, how did we get k=0? From divisor 1: k0=0.\n\n   So the method works.\n\n   However, we must note: the candidate k0 for divisor g might be negative? The modulo operation in Python for nonnegative g and a % g (which is in [0, g-1]) ensures that (g - a % g) is in [1, g], and then %g makes it in [0, g-1] (if (g - a % g) is positive, then modulo g is just (g - a % g) if (g - a % g) < g, which it is). \n\n   But wait: if a % g == 0, then (g - 0) % g = 0. If a % g !=0, then (g - a % g) is in [1, g-1], so modulo g is that value.\n\n   Therefore, k0 is always nonnegative and less than g.\n\n   But note: k0 must be at least 0, and we are only considering k0. However, there might be a k that is less than k0 and still satisfies that the GCD divides d? \n\n   Actually, the condition for divisor g is that g divides (a+k). The minimal nonnegative k is k0. Any k less than k0 does not satisfy (a+k) divisible by g. \n\n   Therefore, we are only considering the minimal k for each divisor.\n\n   However, the problem is: we are only considering one k per divisor (the minimal one). But note: the LCM for a given divisor g is defined by the candidate k0. And the actual GCD for k0 is the GCD of (a+k0, b+k0) which may be greater than g. Then we are effectively considering a candidate with a GCD that is a multiple of g. \n\n   But note: we are iterating over every divisor, so we are covering the actual GCD as well. For example, if the actual GCD is h (a divisor of d) then we will consider h (and then k0 for h). And the candidate k0 for h might be less than the candidate k0 for g (if h divides g) or not. \n\n   However, the same k0 might appear for multiple divisors. We are using a set? Actually, we are not. We are iterating and updating the best_k and best_lcm.\n\n   But note: the same k0 might be generated by multiple divisors. We don't want to do redundant calculations. However, the number of divisors is about 1344, so even if we recalculate the same k0, the total operations are 1344 * (cost of gcd) which is acceptable because gcd for numbers up to 2e9 (a+k0 and b+k0) is fast (logarithmic steps). But note: a+k0 and b+k0 can be up to 10^9 + 10^9 = 2e9, which is acceptable for the Euclidean algorithm (about 60 iterations).\n\n   However, we must consider that the same k0 might be generated by multiple divisors, but that's okay because we are storing the best_lcm and best_k.\n\n   But note: what if the minimal k is not generated by any divisor? \n\n   Actually, the minimal k must be such that the GCD of (a+k, b+k) is a divisor of d. Therefore, k must satisfy that the GCD divides d. Then the minimal k for the actual GCD (which is a divisor) is considered.\n\n   However, we are iterating over every divisor, so we are considering every possible GCD. But note: the minimal k for divisor g is k0. Then the candidate k0 is the minimal k that makes the GCD divisible by g. But the actual GCD might be a multiple of g, and then we are effectively considering the candidate for the divisor h (the actual GCD) as well. But note: the candidate k0 for divisor g is the same as the candidate k0 for divisor h (if h divides g)? Not necessarily.\n\n   Example: a=6, b=10, d=4. Divisors: 1,2,4.\n\n        For divisor 2: k0=0 -> then the actual GCD is gcd(6,10)=2, so we use divisor2 and get k0=0.\n        For divisor 4: k0=2 -> then the actual GCD is gcd(8,12)=4.\n\n        But note: the candidate k0 for divisor4 is 2, which is the same as the candidate k0 for divisor2? Not the same, but different.\n\n   Therefore, we are generating distinct k0s for distinct divisors.\n\n   But wait: consider divisor 1 and divisor2 for a=6, b=10:\n\n        divisor1: k0= (1-6%1)%1 -> 0 (because 6%1=0, so (1-0)%1=1%1=0)\n        divisor2: k0= (2-6%2)%2 = (2-0)%2=0\n\n        So k0=0 for both divisor1 and divisor2.\n\n        Then we compute for divisor1: \n            actual_gcd = gcd(6,10)=2, LCM= (6*10)//2 = 30.\n\n        Then for divisor2:\n            actual_gcd = gcd(6,10)=2, LCM=30.\n\n        Then we update best_k: \n            Initially, we set best_k=0, best_lcm=30 (from divisor1) and then divisor2 gives the same LCM and k=0 (same) so no update.\n\n        Then divisor4: k0=2, actual_gcd=4, LCM= (8*12)//4=24 -> update best_k=2, best_lcm=24.\n\n   So we get the correct answer.\n\n   However, we must note: we are iterating over divisors, and the same k0 might appear multiple times, but that's okay because the LCM calculation is the same for the same k0.\n\n   But wait: the same k0 might have been generated by multiple divisors, but the actual_gcd is the same? Then we are doing redundant work. \n\n   To optimize, we can use a set for k0 candidates. But the problem is that the same k0 might be generated by multiple divisors, and then we are recalculating the same LCM multiple times. Since the number of divisors is about 1344, and the gcd calculation is logarithmic, it's acceptable.\n\n   However, we can use memoization for k0: if we have already computed the LCM for a particular k0, then skip. But note: the same k0 might be generated by multiple divisors, so we can store (k0, LCM) and if we see the same k0 again, we know the LCM.\n\n   But note: the LCM for a fixed k0 is fixed. So we can do:\n\n        candidate_set = set()\n        best_k = 0\n        best_lcm = (a * b) // math.gcd(a, b)   # for k=0\n\n        Then for each divisor g, compute k0. If k0 is in candidate_set, skip. Else, add k0 to candidate_set, compute the LCM, and update.\n\n   But wait: what if k0 is negative? We said k0 is nonnegative.\n\n   However, note: the divisors are positive, and k0 is nonnegative.\n\n   But note: we must also consider that k0 might be very large (like g - a, and g can be up to 10^9, then k0 ~ 10^9). Then we have about 1344 distinct k0s, so storing them in a set is acceptable (memory",
    "response": "\nTo solve this problem, we need to find a non-negative integer \\( k \\) such that the least common multiple (LCM) of \\( a + k \\) and \\( b + k \\) is minimized. If multiple values of \\( k \\) yield the same minimal LCM, we should choose the smallest \\( k \\).\n\n### Approach\n1. **Problem Analysis**: The key observation here is that the GCD of \\( a + k \\) and \\( b + k \\) must be a divisor of the absolute difference between \\( a \\) and \\( b \\), i.e., \\( |a - b| \\). This is because the difference between \\( (a + k) \\) and \\( (b + k) \\) is \\( a - b \\), and any common divisor of \\( a + k \\) and \\( b + k \\) must divide this difference.\n\n2. **Intuition**: For each divisor \\( g \\) of \\( |a - b| \\), we can compute the smallest non-negative \\( k \\) such that \\( g \\) divides both \\( a + k \\) and \\( b + k \\). This \\( k \\) is given by \\( (g - (a \\% g)) \\% g \\). Once we have \\( k \\), we compute the actual GCD of \\( a + k \\) and \\( b + k \\), and then the LCM using the formula \\( \\text{LCM}(x, y) = \\frac{x \\times y}{\\text{GCD}(x, y)} \\).\n\n3. **Algorithm Selection**: We generate all positive divisors of \\( |a - b| \\). For each divisor \\( g \\), we compute the corresponding \\( k \\) and the LCM. We keep track of the minimal LCM encountered and the smallest \\( k \\) that achieves this LCM.\n\n4. **Complexity Analysis**: The number of divisors of \\( |a - b| \\) is \\( O(\\sqrt{d}) \\), where \\( d = |a - b| \\). For each divisor, we perform a constant amount of arithmetic operations and a GCD calculation, which is logarithmic in the size of the numbers. Thus, the overall complexity is manageable even for large \\( a \\) and \\( b \\) (up to \\( 10^9 \\)).\n\n### Solution Code\n```python\nimport math\nfrom sys import stdin\n\ndef main():\n    data = stdin.readline().split()\n    a = int(data[0])\n    b = int(data[1])\n    \n    if a == b:\n        print(0)\n        return\n        \n    d = abs(a - b)\n    divisors = set()\n    i = 1\n    while i * i <= d:\n        if d % i == 0:\n            divisors.add(i)\n            divisors.add(d // i)\n        i += 1\n        \n    best_k = 0\n    best_lcm = (a * b) // math.gcd(a, b)\n    \n    seen_ks = set()\n    for g in divisors:\n        k0 = (g - a % g) % g\n        if k0 in seen_ks:\n            continue\n        seen_ks.add(k0)\n        \n        num1 = a + k0\n        num2 = b + k0\n        current_gcd = math.gcd(num1, num2)\n        current_lcm = (num1 * num2) // current_gcd\n        \n        if current_lcm < best_lcm:\n            best_lcm = current_lcm\n            best_k = k0\n        elif current_lcm == best_lcm and k0 < best_k:\n            best_k = k0\n            \n    print(best_k)\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The code reads two integers \\( a \\) and \\( b \\) from standard input.\n2. **Special Case Handling**: If \\( a \\) equals \\( b \\), the answer is \\( 0 \\) because the LCM of \\( a \\) and \\( a \\) is \\( a \\), and increasing \\( k \\) only makes the LCM larger.\n3. **Divisor Calculation**: The code calculates all positive divisors of \\( |a - b| \\) by iterating up to the square root of \\( |a - b| \\).\n4. **Finding Minimal LCM**: For each divisor \\( g \\), it computes the smallest \\( k \\) such that \\( g \\) divides both \\( a + k \\) and \\( b + k \\). It then calculates the LCM for this \\( k \\) and updates the best solution if a smaller LCM is found or if the same LCM is found with a smaller \\( k \\).\n5. **Output**: The smallest \\( k \\) that minimizes the LCM is printed.\n\nThis approach efficiently narrows down the possible values of \\( k \\) by leveraging the divisors of the absolute difference between \\( a \\) and \\( b \\), ensuring optimal performance even for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\nfrom sys import stdin\n\ndef main():\n    data = stdin.readline().split()\n    a = int(data[0])\n    b = int(data[1])\n    \n    if a == b:\n        print(0)\n        return\n        \n    d = abs(a - b)\n    divisors = set()\n    i = 1\n    while i * i <= d:\n        if d % i == 0:\n            divisors.add(i)\n            divisors.add(d // i)\n        i += 1\n        \n    best_k = 0\n    best_lcm = (a * b) // math.gcd(a, b)\n    \n    seen_ks = set()\n    for g in divisors:\n        k0 = (g - a % g) % g\n        if k0 in seen_ks:\n            continue\n        seen_ks.add(k0)\n        \n        num1 = a + k0\n        num2 = b + k0\n        current_gcd = math.gcd(num1, num2)\n        current_lcm = (num1 * num2) // current_gcd\n        \n        if current_lcm < best_lcm:\n            best_lcm = current_lcm\n            best_k = k0\n        elif current_lcm == best_lcm and k0 < best_k:\n            best_k = k0\n            \n    print(best_k)\n\nif __name__ == '__main__':\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 396,
        "completion_token_count": 1064,
        "thoughts_token_count": 8191
    }
}