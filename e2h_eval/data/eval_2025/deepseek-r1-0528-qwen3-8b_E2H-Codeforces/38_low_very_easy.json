{
    "start": 1758299349.0738134,
    "end": 1758302761.8043294,
    "start-formatted": "2025-09-20 01:29 KST",
    "end-formatted": "2025-09-20 02:26 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\n Okay, we are given an integer p (0 <= p <= 200000). We need to:\n 1. Find the minimum number of nodes n such that there exists a directed graph with n nodes that is p-reachable.\n    - Note: The graph must have exactly p ordered pairs (u, v) with u < v and u and v being mutually reachable.\n\n 2. Among all graphs with the minimum number of nodes that are p-reachable, find the maximum number of unidirectional pairs (u, v) (with u != v, a path from u to v but not from v to u).\n\n Observation for part 1:\n\n What does it mean for a graph to be p-reachable?\n   We require that the graph has exactly p ordered pairs (u, v) (with u < v) such that u and v are mutually reachable.\n\n Note: In a directed graph, mutual reachability defines strongly connected components (SCCs). In fact, two nodes are in the same SCC if they are mutually reachable.\n\n However, note the problem says \"exactly p ordered pairs of nodes (u, v) such that u < v and u and v are reachable from each other\". \n But note: In an SCC, the entire component is strongly connected. The condition for being p-reachable is that the total number of unordered pairs (u, v) with u < v that are in the same SCC is p.\n\n However, note: the problem counts ordered pairs? Actually, the condition is: \"exactly p ordered pairs of nodes (u, v) such that u < v\" — wait, no: the problem says \"ordered pairs\" but then specifies \"u < v\". Actually, the condition is: \n   \"exactly p ordered pairs of nodes (u, v) such that u < v and u and v are reachable from each other\"\n\n So, it's counting the unordered pairs (since u < v) but the term \"ordered pair\" might be a bit misleading. But note: the problem says \"ordered pair\" at the beginning for the unidirectional definition, but here the condition for p-reachable is defined by counting pairs (u, v) with u < v.\n\n Actually, let me clarify: \n   In the p-reachable condition, we are counting unordered pairs (because we have u < v). But note the problem says \"ordered pairs of nodes (u, v)\" — wait, no: the condition for p-reachable is: \"exactly p ordered pairs of nodes (u, v) such that u < v\". \n\n But wait: an ordered pair (u, v) with u < v is just one specific ordering. So the condition is that the graph has exactly p edges (in the mutual reachability sense) in the underlying undirected graph? \n\n Actually, the mutual reachability condition is symmetric. So if we have an SCC with k nodes, then the number of unordered pairs (u, v) with u < v in that SCC is C(k,2) = k*(k-1)//2.\n\n Therefore, the entire graph is partitioned into several SCCs. Let the sizes of the SCCs be s1, s2, ..., sm. Then the total p is the sum over i of C(s_i, 2). \n\n However, note: the problem says \"exactly p\", and we are allowed to have any graph (so we can choose the SCC structure arbitrarily). We want the minimum number of nodes.\n\n So we have to represent p as the sum of triangular numbers (each triangular number T_k = k*(k-1)//2) and we want to minimize the total number of nodes (which is the sum of the k_i's) and also use as few SCCs as possible? Actually, we can combine the SCCs arbitrarily.\n\n But note: we cannot break an SCC arbitrarily because the mutual reachability condition requires that within an SCC, every pair (u, v) with u < v must be counted. And between different SCCs, there is no mutual reachability (unless we have cycles connecting them, but typically in a standard condensation graph (the DAG of SCCs) we don't have edges between SCCs that would create mutual reachability). \n\n However, the problem does not specify that the graph must be the condensation graph. But note: if we have two SCCs and we add edges from one to the other, then the mutual reachability condition still only holds within each SCC. So we can consider the graph as having a set of disjoint SCCs (i.e., a DAG of SCCs, but without any edges between them that would form a cycle or mutual reachability). \n\n Therefore, the problem reduces to: represent p as a sum of triangular numbers (each T_k = k*(k-1)//2) and minimize the total number of nodes (which is the sum of the k_i's). Moreover, we are allowed to use as many components",
    "response": "\nTo solve this problem, we need to determine the minimum number of nodes required to create a directed graph that is exactly p-reachable. Additionally, among all such graphs with the minimum number of nodes, we need to find the maximum number of unidirectional pairs of nodes.\n\n### Approach\n1. **Problem Analysis**:\n   - A directed graph is p-reachable if it contains exactly p ordered pairs (u, v) where u < v and u and v are mutually reachable. This means the graph must have exactly p mutual reachability pairs.\n   - The mutual reachability condition implies that nodes in the same strongly connected component (SCC) form a clique in terms of reachability. The number of mutual reachability pairs in an SCC of size k is given by the triangular number \\( T_k = k*(k-1)/2 \\).\n   - The goal is to partition the nodes into SCCs such that the sum of their triangular numbers equals p, and the total number of nodes is minimized.\n\n2. **Key Insight**:\n   - The problem reduces to expressing p as a sum of triangular numbers while minimizing the sum of the corresponding integers. Each triangular number \\( T_k \\) corresponds to a component of size k.\n   - We can use a greedy approach to decompose p into a sum of distinct triangular numbers, starting from the largest possible triangular number down to zero. This ensures the minimal total number of nodes.\n\n3. **Algorithm Selection**:\n   - **Triangular Number Decomposition**: Precompute triangular numbers up to a certain limit (since p can be up to 200,000, the maximum component size needed is around 900 as \\( T_{900} \\approx 400,000 \\)).\n   - **Greedy Matching**: For each p, find the largest triangular number less than or equal to p, subtract it from p, and repeat until p is exhausted. The sum of the indices of these triangular numbers gives the minimum number of nodes.\n\n4. **Unidirectional Pairs Calculation**:\n   - Once the minimal node count is determined, the maximum number of unidirectional pairs is calculated by considering all possible ordered pairs (u, v) where u ≠ v and there is a path from u to v but not from v to u. This is derived from the structure of the graph formed by the SCC decomposition.\n\n### Solution Code\n```python\ndef main():\n    p = int(input().strip())\n    \n    if p == 0:\n        print(\"0 0\")\n        return\n        \n    tri = []\n    k = 1\n    while True:\n        t_val = k * (k - 1) // 2\n        if t_val > 200000:\n            break\n        tri.append((k, t_val))\n        k += 1\n        \n    tri.reverse()\n    \n    total_nodes = 0\n    remaining = p\n    \n    for k, t_val in tri:\n        while remaining >= t_val:\n            remaining -= t_val\n            total_nodes += k\n            \n    while remaining != 0:\n        total_nodes += 1\n        remaining -= 0\n        \n    n = total_nodes\n    \n    # Calculate the maximum number of unidirectional pairs\n    max_unidirectional = 0\n    total_pairs = n * (n - 1)\n    for k, t_val in tri:\n        if t_val <= remaining:\n            continue\n        else:\n            break\n            \n    for k, t_val in tri:\n        if t_val == 0:\n            continue\n        max_unidirectional += k * (k - 1)\n        \n    for k in range(1, n + 1):\n        if k == 1:\n            continue\n        max_unidirectional -= k * (k - 1) // 2 * 2\n        \n    max_unidirectional //= 2\n    \n    print(f\"{n} {max_unidirectional}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Input Handling**: The code reads the integer p, which represents the number of required mutual reachability pairs.\n2. **Special Case Handling**: If p is zero, the solution immediately returns \"0 0\" since no nodes are needed.\n3. **Triangular Number Generation**: The code generates all triangular numbers up to a value greater than 200,000. These numbers represent the mutual reachability pairs for components of varying sizes.\n4. **Greedy Decomposition**: The algorithm decomposes p into a sum of the largest possible triangular numbers, adjusting the remaining value until p is fully decomposed. The sum of the indices of these triangular numbers gives the minimal node count.\n5. **Unidirectional Pairs Calculation**: The maximum number of unidirectional pairs is computed by considering all possible ordered pairs and subtracting those that do not meet the unidirectional condition. The result is printed along with the minimal node count.\n\nThis approach efficiently solves the problem by leveraging mathematical insights and greedy decomposition to minimize the node count and maximize unidirectional pairs.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    p = int(input().strip())\n    \n    if p == 0:\n        print(\"0 0\")\n        return\n        \n    tri = []\n    k = 1\n    while True:\n        t_val = k * (k - 1) // 2\n        if t_val > 200000:\n            break\n        tri.append((k, t_val))\n        k += 1\n        \n    tri.reverse()\n    \n    total_nodes = 0\n    remaining = p\n    \n    for k, t_val in tri:\n        while remaining >= t_val:\n            remaining -= t_val\n            total_nodes += k\n            \n    while remaining != 0:\n        total_nodes += 1\n        remaining -= 0\n        \n    n = total_nodes\n    \n    # Calculate the maximum number of unidirectional pairs\n    max_unidirectional = 0\n    total_pairs = n * (n - 1)\n    for k, t_val in tri:\n        if t_val <= remaining:\n            continue\n        else:\n            break\n            \n    for k, t_val in tri:\n        if t_val == 0:\n            continue\n        max_unidirectional += k * (k - 1)\n        \n    for k in range(1, n + 1):\n        if k == 1:\n            continue\n        max_unidirectional -= k * (k - 1) // 2 * 2\n        \n    max_unidirectional //= 2\n    \n    print(f\"{n} {max_unidirectional}\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 475,
        "completion_token_count": 1054,
        "thoughts_token_count": 1023
    }
}