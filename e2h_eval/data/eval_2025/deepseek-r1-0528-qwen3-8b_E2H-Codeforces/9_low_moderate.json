{
    "start": 1758093138.9926586,
    "end": 1758094926.7276366,
    "start-formatted": "2025-09-17 16:12 KST",
    "end-formatted": "2025-09-17 16:42 KST",
    "gpu": 2,
    "pid": 9,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Selling Souvenirs\n\nAfter several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.This morning, as usual, Petya will come to the market. Petya has n different souvenirs to sell; ith souvenir is characterised by its weight wi and cost ci. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than m, and total cost is maximum possible.Help Petya to determine maximum possible total cost.\n\n## Input\nThe first line contains two integers n and m (1 ≤ n ≤ 100000, 1 ≤ m ≤ 300000) — the number of Petya's souvenirs and total weight that he can carry to the market.Then n lines follow. ith line contains two integers wi and ci (1 ≤ wi ≤ 3, 1 ≤ ci ≤ 109) — the weight and the cost of ith souvenir.\n\n## Output\nPrint one number — maximum possible total cost of souvenirs that Petya can carry to the market.\n\n## Example\n### Input\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\n### Output\n['0', '3', '10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\n Okay, we are given up to 100000 souvenirs, each with weight in {1,2,3} and a cost (which can be up to 10^9). We have a maximum total weight m (up to 300000).\n\n Since the weights are only 1, 2, or 3, we can group the souvenirs by weight.\n\n Let:\n   type1 = list of costs for souvenirs with weight 1\n   type2 = list of costs for souvenirs with weight 2\n   type3 = list of costs for souvenirs with weight 3\n\n Then, we want to choose some number of items from each type such that:\n   x*1 + y*2 + z*3 <= m, and the total cost (sum of chosen x from type1, y from type2, z from type3) is maximized.\n\n However, note that we cannot use fractional items. We need to consider the best way to pick items from each group.\n\n Since the groups are independent, we can precompute for each group the maximum total cost for taking k items (for k from 0 to the size of the group) by sorting the group in descending order and then doing a prefix sum.\n\n But note: the total weight m is up to 300000, and the items are only three types. We can iterate over the number of items of each type? But the total weight might be large.\n\n Alternatively, we can iterate over the number of type3 items (which have the highest weight) because the total weight is limited, and then for each fixed z (number of type3 items), we have a remaining weight: w = m - 3*z. Then, we need to choose as many as possible from type2 and type1, but we want to maximize the total cost.\n\n However, note that we might not use all the remaining weight. We can use a two-pointer or knapSack style, but note that we have three types and the weights are small.\n\n Steps:\n\n 1. Group the items by weight.\n 2. For each group (type1, type2, type3), sort the list of costs in descending order and compute the prefix sums (so that we can quickly get the sum of the top k items).\n\n 3. Now, we can consider iterating over the number of type3 items (z) from 0 to min(len(type3), m//3). For each z, we have a remaining weight w = m - 3*z (if w<0, break). Then, we need to fill the remaining weight with type1 and type2.\n\n 4. How to fill the remaining weight? We can use dynamic programming for the two types? But note that the remaining weight can be up to 300000, and we have two types with weights 1 and 2.\n\n Alternatively, we can combine type1 and type2 into one problem: we have two kinds of items (weight 1 and weight 2) and we want to maximize the cost without exceeding the remaining weight w.\n\n We can do:\n   Let's say we take y items from type2, then the remaining weight for type1 is w - 2*y, and we must have w - 2*y >=0. Then the total cost from type2 is prefix2[y] (the best y items from type2) and from type1 is prefix1[min(len(type1), w-2*y)]? But wait, we have the entire type1 and type2 available, and we can use as many as we have.\n\n However, note: the remaining weight might not be exactly filled. We can also use a greedy approach for the two types.\n\n Actually, we can consider the two types together: we have two arrays (for type1 and type2) and we can use any number of each. The problem becomes: given two arrays (each sorted descending) and two types of items (with weight 1 and 2) and a total weight limit W, what is the maximum total cost?\n\n We can precompute for the combined system of type1 and type2:\n\n   Let W = m - 3*z (remaining weight)\n\n   We can use the following idea: \n     Let's denote by x the number of type1 items and y the number of type2 items, then x + 2*y <= W.\n\n   We can iterate y from 0 to floor(W/2) and then set x = W - 2*y, but then we have to make sure we don't exceed the available items in each type.\n\n   Alternatively, we can precompute an array dp[W'] for the two types (but W can be up to 300000) which is too big because we have 100000 items and W up to 300000.\n\n But",
    "response": "\nTo solve this problem, we need to maximize the total cost of souvenirs that Petya can carry to the market without exceeding a given weight limit. The souvenirs are categorized by their weights (1, 2, or 3), which simplifies the problem compared to a general knapsack problem.\n\n### Approach\n1. **Grouping and Sorting**: First, we group the souvenirs by their weights (1, 2, or 3). For each group, we sort the items in descending order of their costs. This allows us to select the most valuable items first when forming combinations.\n2. **Prefix Sums**: For each group, we compute prefix sums of the sorted costs. This helps in quickly determining the maximum cost achievable by selecting the top `k` items from any group.\n3. **Iterate Over Possible Combinations**: We iterate over possible numbers of type-3 items (the heaviest) that can be included without exceeding the weight limit. For each such count, we calculate the remaining weight available for type-1 and type-2 items.\n4. **Maximize Remaining Weight**: Using the remaining weight, we determine the optimal combination of type-1 and type-2 items by leveraging their prefix sums. The solution involves checking all feasible combinations where the sum of weights from these types does not exceed the remaining weight.\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(0)\n        return\n        \n    n = int(data[0])\n    m = int(data[1])\n    index = 2\n    type1 = []\n    type2 = []\n    type3 = []\n    \n    for i in range(n):\n        w = int(data[index])\n        c = int(data[index+1])\n        index += 2\n        if w == 1:\n            type1.append(c)\n        elif w == 2:\n            type2.append(c)\n        elif w == 3:\n            type3.append(c)\n            \n    type1.sort(reverse=True)\n    type2.sort(reverse=True)\n    type3.sort(reverse=True)\n    \n    prefix1 = [0]\n    for i in range(len(type1)):\n        prefix1.append(prefix1[-1] + type1[i])\n        \n    prefix2 = [0]\n    for i in range(len(type2)):\n        prefix2.append(prefix2[-1] + type2[i])\n        \n    prefix3 = [0]\n    for i in range(len(type3)):\n        prefix3.append(prefix3[-1] + type3[i])\n        \n    max_cost = 0\n    num_type3 = len(prefix3) - 1\n    for z in range(0, min(num_type3, m//3) + 1):\n        rem_weight = m - 3*z\n        if rem_weight < 0:\n            break\n            \n        best_remaining = 0\n        y_max = rem_weight // 2\n        y = min(len(prefix2) - 1, y_max)\n        while y >= 0:\n            weight_used_by_type2 = 2 * y\n            if weight_used_by_type2 > rem_weight:\n                y -= 1\n                continue\n            rem_after_type2 = rem_weight - weight_used_by_type2\n            x = min(len(prefix1) - 1, rem_after_type2)\n            if x < 0:\n                x = 0\n            total_here = prefix2[y] + prefix1[x]\n            if total_here > best_remaining:\n                best_remaining = total_here\n            y -= 1\n            \n        total_cost = prefix3[z] + best_remaining\n        if total_cost > max_cost:\n            max_cost = total_cost\n            \n    print(max_cost)\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Input Parsing**: The input is read and parsed into the number of souvenirs `n` and the maximum weight `m`. Each souvenir's weight and cost are then categorized into one of three lists based on their weight.\n2. **Sorting and Prefix Sums**: Each list of souvenirs is sorted in descending order of cost. Prefix sums are computed for each list to facilitate quick calculation of the sum of the top `k` items.\n3. **Combination Calculation**: For each possible count of type-3 items (from 0 to the maximum possible without exceeding `m`), the remaining weight is calculated. This remaining weight is then used to determine the optimal number of type-1 and type-2 items by iterating over possible counts of type-2 items and using the prefix sums to find the best corresponding count of type-1 items.\n4. **Result Determination**: The total cost for each combination of type-3, type-2, and type-1 items is computed, and the maximum value encountered during the iteration is printed as the result.\n\nThis approach efficiently narrows down the problem by leveraging the limited weight categories and uses sorting and prefix sums to optimize the selection of items, ensuring the solution is both correct and efficient.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(0)\n        return\n        \n    n = int(data[0])\n    m = int(data[1])\n    index = 2\n    type1 = []\n    type2 = []\n    type3 = []\n    \n    for i in range(n):\n        w = int(data[index])\n        c = int(data[index+1])\n        index += 2\n        if w == 1:\n            type1.append(c)\n        elif w == 2:\n            type2.append(c)\n        elif w == 3:\n            type3.append(c)\n            \n    type1.sort(reverse=True)\n    type2.sort(reverse=True)\n    type3.sort(reverse=True)\n    \n    prefix1 = [0]\n    for i in range(len(type1)):\n        prefix1.append(prefix1[-1] + type1[i])\n        \n    prefix2 = [0]\n    for i in range(len(type2)):\n        prefix2.append(prefix2[-1] + type2[i])\n        \n    prefix3 = [0]\n    for i in range(len(type3)):\n        prefix3.append(prefix3[-1] + type3[i])\n        \n    max_cost = 0\n    num_type3 = len(prefix3) - 1\n    for z in range(0, min(num_type3, m//3) + 1):\n        rem_weight = m - 3*z\n        if rem_weight < 0:\n            break\n            \n        best_remaining = 0\n        y_max = rem_weight // 2\n        y = min(len(prefix2) - 1, y_max)\n        while y >= 0:\n            weight_used_by_type2 = 2 * y\n            if weight_used_by_type2 > rem_weight:\n                y -= 1\n                continue\n            rem_after_type2 = rem_weight - weight_used_by_type2\n            x = min(len(prefix1) - 1, rem_after_type2)\n            if x < 0:\n                x = 0\n            total_here = prefix2[y] + prefix1[x]\n            if total_here > best_remaining:\n                best_remaining = total_here\n            y -= 1\n            \n        total_cost = prefix3[z] + best_remaining\n        if total_cost > max_cost:\n            max_cost = total_cost\n            \n    print(max_cost)\n\nif __name__ == '__main__':\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 477,
        "completion_token_count": 1054,
        "thoughts_token_count": 1023
    }
}