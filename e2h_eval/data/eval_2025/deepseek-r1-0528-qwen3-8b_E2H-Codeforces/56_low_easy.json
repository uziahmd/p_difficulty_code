{
    "start": 1758294369.4423823,
    "end": 1758296418.5224514,
    "start-formatted": "2025-09-20 00:06 KST",
    "end-formatted": "2025-09-20 00:40 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\n Okay, we are given R and B (number of rebels and bases) and then R lines for rebels and B lines for bases.\n Since R, B are at most 10, we can use combinatorial methods.\n\n Conditions:\n  - We must assign each base to exactly one rebel and each rebel to exactly one base (perfect matching).\n  - The straight paths (from base to its assigned spaceship) must not intersect (in the galaxy plane).\n\n Important: The problem does not require that the entire set of points is in general position (except no three collinear and no two coincide) but note that we have two sets: rebels and bases.\n\n However, note: the condition is that the straight paths (the line segments from a base to its assigned rebel) do not intersect.\n\n Observation: In 2D, non-intersecting straight line segments (when connecting two sets) is a well-known problem. But note: we are allowed to assign arbitrarily.\n\n However, note: the condition is that the paths (the segments) do not intersect. This is similar to non-crossing matching.\n\n But note: the example input might be:\n\n Example 1: \n   Rebels: [(0,0), (2,0), (3,1)]\n   Bases:  [(-2,1), (0,3), (2,2)]\n\n One possible matching is:\n   (-2,1) -> (0,0)\n   (0,3) -> (2,0)\n   (2,2) -> (3,1)\n\n And these segments do not cross.\n\n How to check for non-intersection? We can check two segments (A-B and C-D) do not intersect if they don't share an interior point.\n\n But note: the assignment is a perfect matching. We have to check that there exists a matching such that the segments do not cross.\n\n However, note: the problem does not require that the entire drawing is planar? Actually, the condition is that any two paths (from a base to its assigned spaceship) do not intersect. So the entire set of segments must be non-intersecting.\n\n But wait: the problem says \"any two (straight) paths\" meaning every pair of segments must not intersect? Actually, the problem says \"any two (straight) paths – from a base to its assigned spaceship – do not intersect\". So even if two segments share an endpoint (which they do, because the endpoints are distinct and each base and each rebel is used once) then the endpoints are distinct and so the only intersections we care about are in the interiors? Actually, the problem states \"do not intersect\" and in geometry, two segments that share an endpoint are considered to intersect at that endpoint. However, note the problem says \"paths\" and the assignment is between bases and rebels. Each segment goes from a base to a rebel. The endpoints are distinct and the segments are between different points. But wait: if two segments share an endpoint (like two segments starting from the same base or going to the same rebel) then they would share that endpoint. But the problem says \"every base has exactly one guardian\" and \"each spaceship has exactly one assigned base\", so each base is connected to one rebel and vice versa.\n\n Therefore, the segments are disjoint in terms of endpoints. So the condition is that the open segments (without the endpoints) do not cross.\n\n However, note: the problem does not specify whether endpoint sharing is allowed. But by the statement \"any two paths\" and the fact that the paths are from base to rebel, and each base and each rebel is used once, the segments only meet at endpoints if we consider the entire segment including endpoints. But note: two segments that are adjacent (i.e., sharing a common endpoint) are allowed? \n\n Let me read the problem again: \"any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane\".\n\n In standard geometric terms, two segments that share an endpoint do intersect at that endpoint. However, the problem might be intending to say that the interiors do not intersect. But note the example: if two segments share an endpoint, then they do intersect. Therefore, we must avoid even endpoint sharing? But wait, the endpoints are distinct: a base is connected to a rebel and no two bases share the same point, and no two rebels share the same point. Moreover, the bases and rebels are distinct sets (so no base is at the same location as a rebel). Therefore, the segments will never share an endpoint.\n\n Why? Because the endpoints are either a base or a rebel, and the sets are disjoint. The input guarantees: \"no two points coincide\" and \"no three points are on the same line\", but it doesn't say the two sets (rebels and bases) are disjoint. However, note: the problem says \"no two points coincide\", meaning overall? Then the entire set of R+B points are distinct.\n\n Therefore, the segments do not share endpoints. Then we",
    "response": "\nTo solve this problem, we need to determine if there exists a perfect matching between a set of Rebel spaceships and a set of bases such that the straight-line segments connecting each base to its assigned spaceship do not intersect. The solution involves checking all possible perfect matchings between the two sets and verifying the non-intersection condition for each.\n\n### Approach\n1. **Problem Analysis**: The problem requires checking if a perfect matching exists between two sets (rebels and bases) such that the line segments connecting each pair in the matching do not intersect. Given the constraints (R and B are at most 10), we can afford to check all possible permutations of assignments.\n2. **Key Insight**: For any two segments defined by points from the two sets, they intersect if the points are interleaved in a specific way. Specifically, for four distinct points A, B (from one set) and C, D (from the other set), the segments AC and BD intersect if the points A, B, C, D are in convex position and alternate around the convex hull.\n3. **Algorithm Selection**: We generate all possible permutations of assigning rebels to bases. For each permutation, we check if all corresponding segments intersect. If any permutation satisfies the condition, we output \"Yes\"; otherwise, we output \"No\".\n4. **Complexity Analysis**: The number of permutations is R! (factorial of R), which is manageable since R ≤ 10. For each permutation, we check all pairs of segments, leading to a total complexity of O(R! * R^2), which is feasible for the given constraints.\n\n### Solution Code\n```python\nimport itertools\n\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    idx = 0\n    R = int(data[idx])\n    idx += 1\n    B = int(data[idx])\n    idx += 1\n    \n    rebels = []\n    for _ in range(R):\n        x = int(data[idx])\n        y = int(data[idx+1])\n        idx += 2\n        rebels.append((x, y))\n        \n    bases = []\n    for _ in range(B):\n        x = int(data[idx])\n        y = int(data[idx+1])\n        idx += 2\n        bases.append((x, y))\n        \n    if R != B:\n        print(\"No\")\n        return\n        \n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        elif val > 0:\n            return 1\n        else:\n            return -1\n            \n    def do_segments_intersect(a, b, c, d):\n        o1 = orientation(a, b, c)\n        o2 = orientation(a, b, d)\n        o3 = orientation(c, d, a)\n        o4 = orientation(c, d, b)\n        \n        if o1 != o2 and o3 != o4:\n            return True\n            \n        if o1 == 0 and on_segment(a, b, c):\n            return True\n        if o2 == 0 and on_segment(a, b, d):\n            return True\n        if o3 == 0 and on_segment(c, d, a):\n            return True\n        if o4 == 0 and on_segment(c, d, b):\n            return True\n            \n        return False\n        \n    def on_segment(a, b, c):\n        if min(a[0], b[0]) <= c[0] <= max(a[0], b[0]) and min(a[1], b[1]) <= c[1] <= max(a[1], b[1]):\n            return True\n        return False\n        \n    all_permutations = list(itertools.permutations(range(B)))\n    \n    for perm in all_permutations:\n        valid = True\n        for i in range(B):\n            a = bases[i]\n            b = rebels[perm[i]]\n            for j in range(i + 1, B):\n                c = bases[j]\n                d = rebels[perm[j]]\n                if do_segments_intersect(a, b, c, d):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            print(\"Yes\")\n            return\n            \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into two lists: one for rebel coordinates and another for base coordinates.\n2. **Initial Check**: If the number of rebels (R) does not equal the number of bases (B), it's impossible to form a perfect matching, so the answer is immediately \"No\".\n3. **Orientation and Intersection Checks**: The `orientation` function determines the relative orientation of three points (collinear, clockwise, or counterclockwise). The `do_segments_intersect` function checks if two line segments intersect using orientation values and checks for collinearity with the `on_segment` function.\n4. **Permutations Check**: All permutations of base assignments to rebels are generated. For each permutation, every pair of segments is checked for intersection. If any permutation yields no intersections, \"Yes\" is printed; otherwise, after all permutations are checked, \"No\" is printed.\n\nThis approach efficiently checks all possible assignments and ensures the solution meets the problem's requirements.",
    "ground_truth": "N/A",
    "extracted_answer": "import itertools\n\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    idx = 0\n    R = int(data[idx])\n    idx += 1\n    B = int(data[idx])\n    idx += 1\n    \n    rebels = []\n    for _ in range(R):\n        x = int(data[idx])\n        y = int(data[idx+1])\n        idx += 2\n        rebels.append((x, y))\n        \n    bases = []\n    for _ in range(B):\n        x = int(data[idx])\n        y = int(data[idx+1])\n        idx += 2\n        bases.append((x, y))\n        \n    if R != B:\n        print(\"No\")\n        return\n        \n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        elif val > 0:\n            return 1\n        else:\n            return -1\n            \n    def do_segments_intersect(a, b, c, d):\n        o1 = orientation(a, b, c)\n        o2 = orientation(a, b, d)\n        o3 = orientation(c, d, a)\n        o4 = orientation(c, d, b)\n        \n        if o1 != o2 and o3 != o4:\n            return True\n            \n        if o1 == 0 and on_segment(a, b, c):\n            return True\n        if o2 == 0 and on_segment(a, b, d):\n            return True\n        if o3 == 0 and on_segment(c, d, a):\n            return True\n        if o4 == 0 and on_segment(c, d, b):\n            return True\n            \n        return False\n        \n    def on_segment(a, b, c):\n        if min(a[0], b[0]) <= c[0] <= max(a[0], b[0]) and min(a[1], b[1]) <= c[1] <= max(a[1], b[1]):\n            return True\n        return False\n        \n    all_permutations = list(itertools.permutations(range(B)))\n    \n    for perm in all_permutations:\n        valid = True\n        for i in range(B):\n            a = bases[i]\n            b = rebels[perm[i]]\n            for j in range(i + 1, B):\n                c = bases[j]\n                d = rebels[perm[j]]\n                if do_segments_intersect(a, b, c, d):\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            print(\"Yes\")\n            return\n            \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 479,
        "completion_token_count": 1141,
        "thoughts_token_count": 1023
    }
}