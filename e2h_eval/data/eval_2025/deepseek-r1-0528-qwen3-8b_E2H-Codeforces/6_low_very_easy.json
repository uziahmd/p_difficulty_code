{
    "start": 1758088074.2228146,
    "end": 1758089183.7378902,
    "start-formatted": "2025-09-17 14:47 KST",
    "end-formatted": "2025-09-17 15:06 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\n Okay, we are given: n, x and then n lines of (l, r, cost)\n We need to choose two distinct vouchers i and j such that:\n  1. Their durations add up to x: (r_i - l_i + 1) + (r_j - l_j + 1) = x\n  2. They do not intersect: either the first ends before the second starts (r_i < l_j) or the second ends before the first starts (r_j < l_i)\n\n Steps:\n\n Let d_i = duration of voucher i = (r_i - l_i + 1)\n\n We are looking for two vouchers i and j with:\n   d_i + d_j = x, and they are non-overlapping.\n\n We can try to group the vouchers by their duration. Then, for each duration d (which must be <= x), we look for a complementary duration (x-d) in another group.\n\n However, we also have the condition of non-overlapping. So even if two vouchers have durations adding to x, they might still overlap.\n\n Approach:\n\n 1. Precompute the duration for each voucher.\n\n 2. We can create a dictionary (or list of lists) mapping from duration to a list of (l, r, cost) for that duration.\n\n But note: the constraints are up to 200000 for n, and the days (l, r) can be up to 200000.\n\n Alternatively, we can think:\n\n Let's define for each duration d (from 1 to maybe 200000) we store the vouchers that have duration d.\n\n Then, for each voucher i with duration d, we want to find a voucher j with duration x-d (if exists) such that the two intervals [l_i, r_i] and [l_j, r_j] do not overlap.\n\n Conditions for non-overlap:\n   Either: r_i < l_j   OR   r_j < l_i\n\n Since we are considering two different vouchers, we must check both orders.\n\n But note: when we consider two groups (d and x-d), we can break the problem into two cases:\n\n Case 1: The voucher i (with duration d) is taken first (so it must end before the second starts) -> r_i < l_j.\n Case 2: The voucher j (with duration x-d) is taken first -> r_j < l_i.\n\n However, note that the two vouchers are independent and we don't know which one comes first. But the condition is symmetric.\n\n So for a given pair (i, j) with durations d and x-d, we require either:\n   r_i < l_j OR r_j < l_i.\n\n How to efficiently check this?\n\n Idea:\n\n We can precompute for each duration d, and for each voucher in that group, we store the interval [l, r] and the cost.\n\n Then, for each duration d, we want to quickly query for the other duration x-d:\n\n   In the group of duration x-d, we want to find a voucher j such that either:\n        Condition A: r_j > r_i   (if the first voucher is i, then we require r_j >= r_i+1? Actually, the condition is r_i < l_j, so l_j must be > r_i. And since j's start is at least l_j, then the condition is satisfied if l_j > r_i. But note: j's entire interval is [l_j, r_j]. Also, note that the duration of j is fixed (x-d). So from j's side, we know that r_j = l_j + (x-d) - 1.\n\n   Alternatively, we can restructure the problem: \n\n   We want to minimize the total cost = cost_i + cost_j.\n\n   We can do:\n\n   Step 1: Group by duration.\n\n   Step 2: For each duration d, we also want to organize the vouchers in the group by their start (or end) to quickly check the non-overlap condition.\n\n   However, note that the condition for non-overlap is about the intervals. We can preprocess each duration group by sorting the intervals by one of the endpoints (say start, or end) and then use binary search.\n\n   Specifically, for a fixed duration d, the voucher i has [l_i, r_i] = [l_i, l_i + d - 1].\n\n   Now, for the complementary duration group (x-d), we have vouchers j with [l_j, r_j] = [l_j, l_j + (x-d) - 1].\n\n   Condition for non-overlap: \n        Option 1: r_i < l_j   ->   l_i + d - 1 < l_j   => l_j > l_i + d - 1.\n        Option 2: r_j < l_i   ->   l_j + (x-d)",
    "response": "\nTo solve this problem, we need to find two distinct travel vouchers such that their combined duration equals exactly `x` days, they do not overlap in time, and their total cost is minimized. \n\n### Approach\n1. **Group Vouchers by Duration**: We first group all vouchers by their duration. This allows us to efficiently look up vouchers that, when combined with another voucher's duration, sum up to `x`.\n\n2. **Sort Intervals by Start Time**: For each duration group, we sort the vouchers by their start day (`l_i`). This helps in quickly determining non-overlapping intervals when checking for valid pairs.\n\n3. **Binary Search for Valid Pairs**: For each voucher in a duration group `d`, we look for vouchers in the complementary duration group `x - d`. Using binary search, we check if there exists a voucher in the complementary group that starts after the current voucher ends (ensuring no overlap) and has the minimal cost. Similarly, we check the reverse condition where the current voucher starts after the complementary voucher ends.\n\n4. **Minimize Total Cost**: For each valid pair found, we keep track of the minimum total cost encountered. If no such pair exists, we return `-1`.\n\n### Solution Code\n```python\nimport sys\nfrom bisect import bisect_right\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(-1)\n        return\n        \n    n = int(data[0])\n    x = int(data[1])\n    vouchers = []\n    index = 2\n    durations = {}\n    \n    for i in range(n):\n        l = int(data[index])\n        r = int(data[index+1])\n        cost_val = int(data[index+2])\n        index += 3\n        duration_val = r - l + 1\n        if duration_val not in durations:\n            durations[duration_val] = []\n        durations[duration_val].append((l, r, cost_val))\n        \n    groups = {}\n    for dur, lst in durations.items():\n        groups[dur] = sorted(lst, key=lambda x: x[0])\n        \n    comp_duration = x - 1\n    ans = float('inf')\n    \n    for dur, lst in groups.items():\n        comp = x - dur\n        if comp == 0 or comp < 0 or comp not in groups:\n            continue\n            \n        other_list = groups[comp]\n        if dur == comp:\n            left_list = lst\n        else:\n            left_list = lst\n            \n        for (l_i, r_i, cost_i) in left_list:\n            if dur != comp:\n                l_other, r_other, cost_other = other_list[0]\n                if r_i < l_other:\n                    total_cost = cost_i + cost_other\n                    if total_cost < ans:\n                        ans = total_cost\n                continue\n                \n            idx = bisect_right(other_list, (r_i + 1, 10**9, 10**9))\n            if idx > 0:\n                candidate = other_list[idx-1]\n                l_other, r_other, cost_other = candidate\n                if l_other > r_i:\n                    total_cost = cost_i + cost_other\n                    if total_cost < ans:\n                        ans = total_cost\n                    \n            if idx < len(other_list):\n                candidate = other_list[idx]\n                l_other, r_other, cost_other = candidate\n                if r_other < l_i:\n                    total_cost = cost_i + cost_other\n                    if total_cost < ans:\n                        ans = total_cost\n                        \n    if ans == float('inf'):\n        print(-1)\n    else:\n        print(ans)\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Input Parsing**: The input is read and parsed into individual vouchers, each characterized by their start day, end day, and cost. The duration of each voucher is calculated as `end_day - start_day + 1`.\n\n2. **Grouping by Duration**: Vouchers are grouped by their duration into a dictionary where keys are durations and values are lists of tuples (start_day, end_day, cost). Each list is then sorted by the start day to facilitate efficient searching.\n\n3. **Finding Complementary Durations**: For each duration `d`, the complementary duration is `x - d`. If such a duration exists, we proceed to find valid pairs between the current duration group and the complementary group.\n\n4. **Checking Non-Overlap Conditions**: For each voucher in the current group, we use binary search to find vouchers in the complementary group that either start after the current voucher ends or end before the current voucher starts. The total cost of such valid pairs is compared to the current minimum cost.\n\n5. **Output Result**: After processing all possible pairs, if a valid pair is found, the minimum cost is printed; otherwise, `-1` is printed indicating no solution exists.\n\nThis approach efficiently narrows down the search space using grouping and binary search, ensuring optimal performance even for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom bisect import bisect_right\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(-1)\n        return\n        \n    n = int(data[0])\n    x = int(data[1])\n    vouchers = []\n    index = 2\n    durations = {}\n    \n    for i in range(n):\n        l = int(data[index])\n        r = int(data[index+1])\n        cost_val = int(data[index+2])\n        index += 3\n        duration_val = r - l + 1\n        if duration_val not in durations:\n            durations[duration_val] = []\n        durations[duration_val].append((l, r, cost_val))\n        \n    groups = {}\n    for dur, lst in durations.items():\n        groups[dur] = sorted(lst, key=lambda x: x[0])\n        \n    comp_duration = x - 1\n    ans = float('inf')\n    \n    for dur, lst in groups.items():\n        comp = x - dur\n        if comp == 0 or comp < 0 or comp not in groups:\n            continue\n            \n        other_list = groups[comp]\n        if dur == comp:\n            left_list = lst\n        else:\n            left_list = lst\n            \n        for (l_i, r_i, cost_i) in left_list:\n            if dur != comp:\n                l_other, r_other, cost_other = other_list[0]\n                if r_i < l_other:\n                    total_cost = cost_i + cost_other\n                    if total_cost < ans:\n                        ans = total_cost\n                continue\n                \n            idx = bisect_right(other_list, (r_i + 1, 10**9, 10**9))\n            if idx > 0:\n                candidate = other_list[idx-1]\n                l_other, r_other, cost_other = candidate\n                if l_other > r_i:\n                    total_cost = cost_i + cost_other\n                    if total_cost < ans:\n                        ans = total_cost\n                    \n            if idx < len(other_list):\n                candidate = other_list[idx]\n                l_other, r_other, cost_other = candidate\n                if r_other < l_i:\n                    total_cost = cost_i + cost_other\n                    if total_cost < ans:\n                        ans = total_cost\n                        \n    if ans == float('inf'):\n        print(-1)\n    else:\n        print(ans)\n\nif __name__ == '__main__':\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 735,
        "completion_token_count": 1036,
        "thoughts_token_count": 1023
    }
}