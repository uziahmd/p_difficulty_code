{
    "start": 1758093320.9592323,
    "end": 1758094944.6835504,
    "start-formatted": "2025-09-17 16:15 KST",
    "end-formatted": "2025-09-17 16:42 KST",
    "gpu": 2,
    "pid": 9,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Selling Souvenirs\n\nAfter several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.This morning, as usual, Petya will come to the market. Petya has n different souvenirs to sell; ith souvenir is characterised by its weight wi and cost ci. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than m, and total cost is maximum possible.Help Petya to determine maximum possible total cost.\n\n## Input\nThe first line contains two integers n and m (1 ≤ n ≤ 100000, 1 ≤ m ≤ 300000) — the number of Petya's souvenirs and total weight that he can carry to the market.Then n lines follow. ith line contains two integers wi and ci (1 ≤ wi ≤ 3, 1 ≤ ci ≤ 109) — the weight and the cost of ith souvenir.\n\n## Output\nPrint one number — maximum possible total cost of souvenirs that Petya can carry to the market.\n\n## Example\n### Input\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\n### Output\n['0', '3', '10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\n Okay, we are given up to 100000 souvenirs, each with weight 1, 2, or 3 and a cost (which can be as large as 10^9). We have a maximum total weight m (up to 300000).\n\n Since the weights are only 1, 2, or 3, we can categorize the souvenirs by their weight.\n\n Let:\n   a = list of costs for souvenirs with weight 1\n   b = list of costs for souvenirs with weight 2\n   c = list of costs for souvenirs with weight 3\n\n Then, the total weight is: x*1 + y*2 + z*3 <= m, and the total cost is: sum(a_chosen) + sum(b_chosen) + sum(c_chosen).\n\n However, note that we are allowed to choose any subset from each category independently? But wait: we cannot exceed the total weight.\n\n However, note that the souvenirs are distinct items. But since the weight is fixed per souvenir, we can handle each category separately and then combine the possibilities.\n\n Steps:\n\n 1. We will group the souvenirs by weight. Since the same weight can appear multiple times, we'll create three lists (a, b, c) for weights 1, 2, 3.\n\n 2. For each group (a, b, c), we want to select some number of items (from 0 to the total available in that group) such that the total cost is maximized. However, note that we are constrained by the total weight.\n\n    But note: the total weight is the sum of the weights from the three groups. Since the weights are fixed (1,2,3), we can think:\n\n        Let x = number of weight-1 souvenirs chosen.\n        Let y = number of weight-2 souvenirs chosen.\n        Let z = number of weight-3 souvenirs chosen.\n\n        Then, x <= len(a), y <= len(b), z <= len(c), and x + 2y + 3z <= m.\n\n 3. However, we don't know the exact numbers but we can precompute the best way to choose k items from each group.\n\n    For a given group (say a, sorted in descending order), we can take the top k items (because we want to maximize the cost). So we can precompute:\n\n        prefix_a[k] = sum of the top k items in a (for k from 0 to len(a))\n        similarly for b and c.\n\n 4. Now, we need to consider all nonnegative integers x, y, z such that:\n        x + 2*y + 3*z <= m\n        x <= len(a), y <= len(b), z <= len(c)\n\n    And then the total cost is prefix_a[x] + prefix_b[y] + prefix_c[z].\n\n 5. But note: the constraints on m (up to 300000) and the fact that the length of a, b, c can be up to 100000, so we cannot iterate over all x, y, z.\n\n 6. Instead, we can use dynamic programming or two pointers? Or we can iterate over one variable and then the other?\n\n    Note: the total weight is the sum of three terms, and the weights are small (only 1,2,3). We can also note that the total weight equation is:\n\n        x + 2y + 3z <= m\n\n    Alternatively, we can fix z (the number of weight-3 items) from 0 to min(len(c), m//3). Then, for a fixed z, the remaining weight is m_remaining = m - 3*z.\n\n    Then, we need to choose x and y (with x from 0 to len(a), y from 0 to len(b)) such that x + 2*y <= m_remaining.\n\n    And we want to maximize prefix_a[x] + prefix_b[y] for the fixed z.\n\n    Then, we can do:\n\n        ans = 0\n        For z from 0 to min(len(c), m//3):\n            rem = m - 3*z\n            # Now, for the remaining weight, we want to maximize the sum from a and b.\n\n            We can precompute an array for the maximum value from a and b for a given total weight w (from 0 to rem) for the combination of a and b.\n\n            How to compute that? We can do:\n\n                Let dp[total_weight] = maximum cost from a and b for total weight up to total_weight (but note: we are only using 1 and 2).\n\n            Alternatively, we can iterate y from 0 to min(len(b), rem//2), then x can be at most rem - ",
    "response": "\nTo solve this problem, we need to maximize the total cost of souvenirs that Petya can carry without exceeding a given weight limit. The souvenirs have weights of either 1, 2, or 3, and their costs can be very large. \n\n### Approach\n1. **Categorize Souvenirs**: Group the souvenirs by their weights (1, 2, or 3) into three separate lists.\n2. **Sort and Prefix Sums**: For each group, sort the souvenirs in descending order of their costs and compute prefix sums. This allows us to quickly access the maximum cost achievable by selecting the top `k` items from any group.\n3. **Iterate Over Possible Weight Combinations**: For each possible number of weight-3 items (from 0 to the maximum possible), calculate the remaining weight available. Then, for the remaining weight, determine the optimal combination of weight-1 and weight-2 items by leveraging the prefix sums and possibly dynamic programming to efficiently explore all valid combinations without exceeding the remaining weight.\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    m = int(data[1])\n    index = 2\n    a_list = []\n    b_list = []\n    c_list = []\n    \n    for _ in range(n):\n        w = int(data[index])\n        c_val = int(data[index+1])\n        index += 2\n        if w == 1:\n            a_list.append(c_val)\n        elif w == 2:\n            b_list.append(c_val)\n        elif w == 3:\n            c_list.append(c_val)\n            \n    a_list.sort(reverse=True)\n    b_list.sort(reverse=True)\n    c_list.sort(reverse=True)\n    \n    len_a = len(a_list)\n    len_b = len(b_list)\n    len_c = len(c_list)\n    \n    prefix_a = [0]*(len_a+1)\n    for i in range(1, len_a+1):\n        prefix_a[i] = prefix_a[i-1] + a_list[i-1]\n        \n    prefix_b = [0]*(len_b+1)\n    for i in range(1, len_b+1):\n        prefix_b[i] = prefix_b[i-1] + b_list[i-1]\n        \n    prefix_c = [0]*(len_c+1)\n    for i in range(1, len_c+1):\n        prefix_c[i] = prefix_c[i-1] + c_list[i-1]\n        \n    best_ans = 0\n    \n    max_z = min(len_c, m // 3)\n    for z in range(max_z+1):\n        rem = m - 3*z\n        if rem < 0:\n            break\n            \n        current = prefix_c[z]\n        if rem == 0:\n            total = current\n            if total > best_ans:\n                best_ans = total\n            continue\n            \n        max_y = min(len_b, rem // 2)\n        max_x = rem\n        \n        dp_arr = [0] * (max_x + 1)\n        for y in range(1, max_y+1):\n            w_used_by_y = 2 * y\n            if w_used_by_y > max_x:\n                break\n            base = prefix_b[y]\n            for x in range(0, max_x - w_used_by_y + 1):\n                if dp_arr[x + w_used_by_y] < base + prefix_a[x]:\n                    dp_arr[x + w_used_by_y] = base + prefix_a[x]\n                    \n        for x in range(0, max_x + 1):\n            if dp_arr[x] > best_ans - current:\n                candidate = dp_arr[x] + current\n                if candidate > best_ans:\n                    best_ans = candidate\n                    \n    print(best_ans)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Categorization**: The input is read and souvenirs are categorized into three lists based on their weights (1, 2, or 3).\n2. **Sorting and Prefix Sums**: Each list is sorted in descending order of cost, and prefix sums are computed to facilitate quick calculation of the maximum cost for selecting the top `k` items from any list.\n3. **Dynamic Programming for Combination Optimization**: For each possible count of weight-3 items (from 0 to the maximum feasible number), the remaining weight is calculated. Using a dynamic programming array, the optimal combination of weight-1 and weight-2 items is found that maximizes the total cost without exceeding the remaining weight. The solution efficiently checks all valid combinations by leveraging the prefix sums and dynamic programming to avoid redundant calculations.\n4. **Output**: The maximum total cost encountered during the iterations is printed as the result.\n\nThis approach efficiently handles the constraints by breaking down the problem into manageable parts and using dynamic programming to explore combinations without excessive computation.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    m = int(data[1])\n    index = 2\n    a_list = []\n    b_list = []\n    c_list = []\n    \n    for _ in range(n):\n        w = int(data[index])\n        c_val = int(data[index+1])\n        index += 2\n        if w == 1:\n            a_list.append(c_val)\n        elif w == 2:\n            b_list.append(c_val)\n        elif w == 3:\n            c_list.append(c_val)\n            \n    a_list.sort(reverse=True)\n    b_list.sort(reverse=True)\n    c_list.sort(reverse=True)\n    \n    len_a = len(a_list)\n    len_b = len(b_list)\n    len_c = len(c_list)\n    \n    prefix_a = [0]*(len_a+1)\n    for i in range(1, len_a+1):\n        prefix_a[i] = prefix_a[i-1] + a_list[i-1]\n        \n    prefix_b = [0]*(len_b+1)\n    for i in range(1, len_b+1):\n        prefix_b[i] = prefix_b[i-1] + b_list[i-1]\n        \n    prefix_c = [0]*(len_c+1)\n    for i in range(1, len_c+1):\n        prefix_c[i] = prefix_c[i-1] + c_list[i-1]\n        \n    best_ans = 0\n    \n    max_z = min(len_c, m // 3)\n    for z in range(max_z+1):\n        rem = m - 3*z\n        if rem < 0:\n            break\n            \n        current = prefix_c[z]\n        if rem == 0:\n            total = current\n            if total > best_ans:\n                best_ans = total\n            continue\n            \n        max_y = min(len_b, rem // 2)\n        max_x = rem\n        \n        dp_arr = [0] * (max_x + 1)\n        for y in range(1, max_y+1):\n            w_used_by_y = 2 * y\n            if w_used_by_y > max_x:\n                break\n            base = prefix_b[y]\n            for x in range(0, max_x - w_used_by_y + 1):\n                if dp_arr[x + w_used_by_y] < base + prefix_a[x]:\n                    dp_arr[x + w_used_by_y] = base + prefix_a[x]\n                    \n        for x in range(0, max_x + 1):\n            if dp_arr[x] > best_ans - current:\n                candidate = dp_arr[x] + current\n                if candidate > best_ans:\n                    best_ans = candidate\n                    \n    print(best_ans)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 476,
        "completion_token_count": 1032,
        "thoughts_token_count": 1023
    }
}