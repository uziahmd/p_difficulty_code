{
    "start": 1758089244.1010733,
    "end": 1758090766.7483306,
    "start-formatted": "2025-09-17 15:07 KST",
    "end-formatted": "2025-09-17 15:32 KST",
    "gpu": 2,
    "pid": 7,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Rudolf and Snowflakes (hard version)\n\nThis is the hard version of the problem. The only difference is that in this version $$$n \\le 10^{18}$$$.One winter morning, Rudolf was looking thoughtfully out the window, watching the falling snowflakes. He quickly noticed a certain symmetry in the configuration of the snowflakes. And like a true mathematician, Rudolf came up with a mathematical model of a snowflake.He defined a snowflake as an undirected graph constructed according to the following rules:   Initially, the graph has only one vertex.  Then, more vertices are added to the graph. The initial vertex is connected by edges to $$$k$$$ new vertices ($$$k > 1$$$).  Each vertex that is connected to only one other vertex is connected by edges to $$$k$$$ more new vertices. This step should be done at least once. The smallest possible snowflake for $$$k = 4$$$ is shown in the figure.  After some mathematical research, Rudolf realized that such snowflakes may not have any number of vertices. Help Rudolf check whether a snowflake with $$$n$$$ vertices can exist.\n\n## Input\nThe first line of the input contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.Then follow the descriptions of the test cases.The first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 10^{18}$$$) — the number of vertices for which it is necessary to check the existence of a snowflake.\n\n## Output\nOutput $$$t$$$ lines, each of which is the answer to the corresponding test case — \"YES\" if there exists such $$$k > 1$$$ that a snowflake with the given number of vertices can be constructed; \"NO\" otherwise.\n\n## Example\n### Input\n['9\\n1\\n2\\n3\\n6\\n13\\n15\\n255\\n10101\\n1000000000000000000']\n\n### Output\n['NO\\nNO\\nNO\\nNO\\nYES\\nYES\\nYES\\nYES\\nNO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\n Okay, we are given up to 10,000 test cases and n can be as large as 10^18.\n\n Let's analyze the snowflake construction:\n\n Rule 1: Start with one vertex.\n Rule 2: The initial vertex is connected to k new vertices (k > 1). Now we have 1 + k vertices.\n Rule 3: Each vertex that is connected to only one other vertex (i.e., leaves) must be connected to k more new vertices. And this step should be done at least once.\n\n However, note that after the first expansion, we have one center and k leaves. Then, each of these k leaves will be connected to k new vertices (so each leaf produces k-1 new edges because one edge is already used to connect to the center? Actually, wait: the rule says \"Each vertex that is connected to only one other vertex\" (so the leaves) are connected to k more new vertices. But note: when we add the first layer, the center has degree k, and the leaves have degree 1.\n\n Then, for the second layer: we take each leaf (each has degree 1) and add k new edges from that leaf. So the leaf now becomes an internal node (with degree k+1) and adds k new vertices.\n\n But wait, the problem states that we do this step at least once. So we can have multiple layers.\n\n How many vertices do we have?\n\n Layer 0: 1 vertex (center)\n Layer 1: k vertices (attached to center)\n Layer 2: each of the k vertices in layer1 adds k new vertices -> so k*k = k^2 vertices\n\n However, wait: the problem says \"Each vertex that is connected to only one other vertex\" (which are the leaves from the previous step) must be expanded. But note: the center is not a leaf (unless k=1, but k>1) and after the first expansion, the center is connected to k edges so it is not a leaf. Then in the next expansion, the leaves (from layer1) become non-leaves because they are now connected to the center and k new ones, so their degree becomes k+1 (which is at least 3, since k>=2).\n\n But then what about the new vertices in layer2? They are leaves again? Yes, because they are connected only to one vertex (the one from layer1). Then if we do another expansion, we would add k new vertices for each of the k*k leaves from layer2.\n\n However, note: the problem says \"Each vertex that is connected to only one other vertex\" (leaves) must be expanded. But the process must be done at least once. We are allowed to do more than one expansion.\n\n Therefore, the total number of vertices after m layers (with m>=1) is:\n\n   Layer0: 1\n   Layer1: k\n   Layer2: k^2\n   ...\n   Layer i: k^i\n\n Then total vertices = 1 + k + k^2 + ... + k^m.\n\n But note: the problem says \"at least once\", meaning m>=1. So the smallest snowflake is after one expansion (m=1): n = 1+k.\n\n However, we are also allowed to have more than one expansion. So n can be the sum of a geometric series with base k (k>1) and m terms (m>=1).\n\n Therefore, we are to check: does there exist an integer k>1 and an integer m>=1 such that:\n\n      n = 1 + k + k^2 + ... + k^m\n\n Alternatively, we can write:\n\n      n = (k^(m+1) - 1) / (k-1)\n\n But note: k is an integer > 1, and m is an integer >=1.\n\n However, note that the expansion process: the first expansion (m=1) gives n = 1+k.\n\n But also note: the problem says \"at least once\", so m>=1. However, the example: \n   Input: 6 -> Output: NO, because 6 cannot be expressed as 1+k (with k>1) or 1+k+k^2 (with k>1) or more layers.\n\n Example: n=13 -> YES.\n\n Let's check:\n\n  For m=1: n = 1+k -> k=12. Then 1+12 = 13 -> valid.\n\n  So 13 is YES.\n\n  n=15: \n    m=1: 1+k=15 -> k=14 -> valid.\n\n  But wait, what about m=2? 1+k+k^2=15 -> k^2+k+1=15 -> k^2+k-14=0 -> k=( -1 ± sqrt(1+56)",
    "response": "\nTo solve this problem, we need to determine whether a given number of vertices \\( n \\) can form a snowflake graph as defined by Rudolf. The snowflake graph is constructed in layers, starting from a central vertex and expanding outward in geometric progression.\n\n### Approach\n1. **Problem Analysis**: The snowflake graph starts with one central vertex. Each subsequent layer adds \\( k \\) new vertices for each vertex in the previous layer that has only one connection (leaves). The total number of vertices after \\( m \\) layers (with \\( m \\geq 1 \\)) is given by the geometric series sum \\( 1 + k + k^2 + \\ldots + k^m \\). This sum can be expressed as \\( \\frac{k^{m+1} - 1}{k-1} \\), where \\( k > 1 \\).\n\n2. **Key Insight**: For \\( n \\) to be expressible as the sum of a geometric series with integer base \\( k > 1 \\) and at least one term (i.e., \\( m \\geq 1 \\)), we need to find integers \\( k \\) and \\( m \\) such that \\( n = \\frac{k^{m+1} - 1}{k-1} \\).\n\n3. **Algorithm Selection**: Given the constraints \\( 1 \\leq n \\leq 10^{18} \\) and up to \\( 10^4 \\) test cases, we need an efficient method. Direct computation for all possible \\( k \\) and \\( m \\) is infeasible. Instead, we observe:\n   - For \\( m = 1 \\), \\( n = 1 + k \\), so \\( k = n - 1 \\). Since \\( k > 1 \\), \\( n \\) must be at least 3.\n   - For \\( m \\geq 2 \\), \\( n \\) must satisfy \\( n = 1 + k + k^2 + \\ldots + k^m \\). Here, \\( k \\) can be found by solving the equation \\( n = \\frac{k^{m+1} - 1}{k-1} \\) for integer \\( k > 1 \\).\n\n4. **Optimization**: For each test case, we first check if \\( n \\) can be expressed as \\( 1 + k \\) (i.e., \\( k = n - 1 \\) and \\( k > 1 \\)). If not, we consider higher layers. However, due to the large value of \\( n \\), we limit our search for \\( m \\) to a reasonable range (up to 60 layers) because \\( 2^{60} \\) exceeds \\( 10^{18} \\).\n\n5. **Special Cases**: \n   - If \\( n \\leq 2 \\), it's impossible to form a valid snowflake (since \\( k > 1 \\) requires at least 3 vertices for \\( m = 1 \\)).\n   - For \\( n = 3 \\), \\( k = 2 \\) is valid.\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    data = sys.stdin.read().split()\n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index]); index += 1\n        \n        if n <= 2:\n            results.append(\"NO\")\n            continue\n            \n        # Check for m=1: n = 1 + k => k = n - 1\n        if n >= 3:\n            k1 = n - 1\n            if k1 > 1:\n                results.append(\"YES\")\n                continue\n                \n        found = False\n        # We'll consider m from 2 up to a limit (say 60)\n        m_max = 60\n        for m in range(2, m_max + 1):\n            low = 2\n            high = 10**18\n            while low <= high:\n                mid = (low + high) // 2\n                total = 1\n                power = 1\n                for i in range(m + 1):\n                    power *= mid\n                    if i == m:\n                        break\n                    total += power\n                    if total > n:\n                        break\n                if total == n:\n                    found = True\n                    break\n                elif total < n:\n                    low = mid + 1\n                else:\n                    high = mid - 1\n                    \n        if found:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n            \n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read in bulk for efficiency, especially given the constraints.\n2. **Initial Checks**: For each test case, if \\( n \\) is 2 or less, the answer is immediately \"NO\" because a valid snowflake requires at least 3 vertices.\n3. **Single Layer Check**: For \\( m = 1 \\), the solution checks if \\( n - 1 \\) is greater than 1. If yes, the answer is \"YES\".\n4. **Multi-Layer Search**: For \\( m \\geq 2 \\), the code performs a binary search to find if there exists an integer \\( k > 1 \\) such that the sum of the geometric series equals \\( n \\). The binary search is conducted over possible values of \\( k \\) (from 2 to \\( 10^{18} \\)), but the loop limits \\( m \\) to a maximum of 60 to avoid excessive computations.\n5. **Output**: The results for all test cases are collected and printed at the end.\n\nThis approach efficiently checks the feasibility of forming a snowflake graph for each given \\( n \\) by leveraging mathematical insights and binary search, ensuring optimal performance even for very large values of \\( n \\).",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index]); index += 1\n        \n        if n <= 2:\n            results.append(\"NO\")\n            continue\n            \n        # Check for m=1: n = 1 + k => k = n - 1\n        if n >= 3:\n            k1 = n - 1\n            if k1 > 1:\n                results.append(\"YES\")\n                continue\n                \n        found = False\n        # We'll consider m from 2 up to a limit (say 60)\n        m_max = 60\n        for m in range(2, m_max + 1):\n            low = 2\n            high = 10**18\n            while low <= high:\n                mid = (low + high) // 2\n                total = 1\n                power = 1\n                for i in range(m + 1):\n                    power *= mid\n                    if i == m:\n                        break\n                    total += power\n                    if total > n:\n                        break\n                if total == n:\n                    found = True\n                    break\n                elif total < n:\n                    low = mid + 1\n                else:\n                    high = mid - 1\n                    \n        if found:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n            \n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 557,
        "completion_token_count": 1260,
        "thoughts_token_count": 1023
    }
}