{
    "start": 1758294368.1445756,
    "end": 1758296043.8406515,
    "start-formatted": "2025-09-20 00:06 KST",
    "end-formatted": "2025-09-20 00:34 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\n Okay, we are given R and B (each between 1 and 10) and then R lines for rebels and B lines for bases.\n We need to assign each base to exactly one rebel and each rebel to exactly one base (perfect matching) such that:\n   - The straight line from the base to its assigned rebel does not intersect any other such line.\n\n Since the total number of points (R+B) is at most 20, we can consider using a combinatorial approach.\n\n However, note that the problem requires non-intersecting straight paths. This is similar to non-crossing matching in the plane.\n\n Observation: \n   We have two sets: rebels (R) and bases (B). We want to connect each rebel to one base without having two edges cross.\n\n But note: the problem says \"any two (straight) paths\" (from base to its assigned spaceship) do not intersect. \n\n Important: The matching is a set of |R|=|B| edges. We require that these edges do not cross.\n\n Steps:\n\n 1. If R != B, then it's impossible? Actually, the problem states \"every base has exactly one guardian and each spaceship has exactly one assigned base\", so we require a perfect matching. Therefore, if R != B, then no matching exists. However, the input guarantees 1<=R,B<=10, but they might be different. So we must check: only when R==B we can have a perfect matching.\n\n But wait, the example input: \n   First example: R=3, B=3 -> output Yes.\n   Second example: R=2, B=1 -> output No.\n\n So first condition: if R != B, then output 'No'.\n\n 2. Now, if R==B, we need to check if there exists a perfect matching (a bijection from rebels to bases) such that the edges drawn between each rebel and its base do not intersect.\n\n How to check for non-intersecting edges?\n\n Note: The edges are straight lines. Two edges (p1, q1) and (p2, q2) (where p1,p2 are rebels and q1,q2 are bases) do not intersect if they don't cross. \n\n There are two main ways:\n\n   a) We can use the concept of non-crossing matching. In computational geometry, we know that if we order the rebels and bases appropriately (for example, by x-coordinate) then we can use a greedy matching or dynamic programming to check if a non-crossing matching exists.\n\n   b) Alternatively, we can try all permutations (since R, B <= 10, the maximum R=B=10, so 10! = 3628800 which is acceptable for a computer). But note: we have R rebels and B bases, and R==B, so we would have to check all permutations of the bases for the rebels. However, we have 10! which is about 3.6e6, and for each permutation we check up to 5 pairs (if we break early) but actually we have to check all pairs for crossings? Actually, we need to check the entire set of edges: for a given matching (which is a list of edges) we must check that no two edges cross.\n\n However, note that if two edges cross, then the four endpoints (two rebels and two bases) form a quadrilateral with intersecting diagonals. We can use the following:\n\n   Given two edges (a, c) and (b, d) (where a,b are rebels and c,d are bases), they cross if and only if the two points a and b are separated by the line connecting c and d, and the two points c and d are separated by the line connecting a and b.\n\n But actually, we can use the orientation test (cross product) to check if two segments AB and CD intersect (in general, but note: we are only concerned with proper intersections, and our points are in general position: no three points collinear).\n\n However, note: the problem states that no three points are collinear. So we can use standard segment intersection.\n\n But wait: we are only drawing edges from rebels to bases. The entire graph is bipartite. We are not allowed to have edges crossing.\n\n Important: The edges are drawn from a rebel to a base, and we have two sets (so the graph is bipartite). The non-crossing condition is for the entire set.\n\n However, note: the edges are straight lines and we are only concerned with intersections between edges. Since the graph is bipartite, edges only go from rebels to bases, so two edges from different rebels to different bases might cross.\n\n Steps for checking a matching (a permutation):\n\n   For a given matching M: which maps each rebel i to base j (so we have edges (r_i, b_j)), we need to check that no two edges cross.\n\n   How",
    "response": "\nTo solve this problem, we need to determine if there exists a perfect matching between a set of Rebel spaceships and a set of bases such that the straight lines connecting each spaceship to its assigned base do not intersect. The solution involves checking all possible perfect matchings and verifying the non-intersection condition for each.\n\n### Approach\n1. **Problem Analysis**: The problem requires a perfect matching (one-to-one correspondence) between Rebels and bases where the connecting lines do not cross. Given the constraints (R and B are at most 10), a brute-force approach is feasible.\n2. **Key Insight**: For any two edges (lines connecting a Rebel to a base) to not intersect, they must form a non-crossing configuration. This can be checked using the orientation of the points involved.\n3. **Algorithm Selection**:\n   - **Check for Perfect Matching**: If the number of Rebels (R) is not equal to the number of bases (B), output \"No\".\n   - **Generate Permutations**: For R = B, generate all possible permutations of base assignments to Rebels.\n   - **Check Non-Intersection**: For each permutation, check if any pair of edges intersects by using the cross product to determine the orientation of four points.\n4. **Complexity Analysis**: The number of permutations is R! (up to 10! = 3,628,800 for R=10). For each permutation, checking all pairs of edges (O(R^2) operations per permutation) is manageable due to the small input size.\n\n### Solution Code\n```python\nimport sys\nfrom itertools import permutations\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"No\")\n        return\n    \n    it = iter(data)\n    R = int(next(it)); B = int(next(it))\n    \n    rebels = []\n    for _ in range(R):\n        x = int(next(it)); y = int(next(it))\n        rebels.append((x, y))\n        \n    bases = []\n    for _ in range(B):\n        x = int(next(it)); y = int(next(it))\n        bases.append((x, y))\n        \n    if R != B:\n        print(\"No\")\n        return\n        \n    def ccw(A, B, C, D):\n        # Cross product of vectors AB and AD\n        val = (B[0]-A[0])*(D[1]-A[1]) - (B[1]-A[1])*(D[0]-A[0])\n        return val > 0\n        \n    def segments_intersect(edge1, edge2):\n        A, B = edge1\n        C, D = edge2\n        o1 = ccw(A, B, C, D)\n        o2 = ccw(A, B, D, C)\n        o3 = ccw(C, D, A, B)\n        o4 = ccw(C, D, B, A)\n        \n        if (o1 != o2) and (o3 != o4):\n            return True\n            \n        return False\n        \n    n = R\n    bases_list = bases\n    found = False\n    \n    for perm in permutations(bases_list):\n        edges = []\n        for i in range(n):\n            edges.append( (rebels[i], perm[i]) )\n            \n        valid = True\n        for i in range(len(edges)):\n            for j in range(i+1, len(edges)):\n                if segments_intersect(edges[i], edges[j]):\n                    valid = False\n                    break\n            if not valid:\n                break\n                \n        if valid:\n            found = True\n            break\n            \n    print(\"Yes\" if found else \"No\")\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into the number of Rebels (R) and bases (B), followed by their respective coordinates.\n2. **Initial Check**: If R ≠ B, immediately output \"No\" since a perfect matching is impossible.\n3. **Cross Product Calculation**: The `ccw` function checks if three points are in counter-clockwise order using the cross product, which helps determine the orientation of points.\n4. **Edge Intersection Check**: The `segments_intersect` function uses the cross product to verify if two line segments intersect.\n5. **Permutation Check**: For each permutation of base assignments to Rebels, the code checks if any two connecting edges intersect. If no intersections are found for any permutation, it outputs \"Yes\"; otherwise, \"No\".\n\nThis approach efficiently checks all possible matchings and ensures the solution meets the non-intersecting edge condition.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom itertools import permutations\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"No\")\n        return\n    \n    it = iter(data)\n    R = int(next(it)); B = int(next(it))\n    \n    rebels = []\n    for _ in range(R):\n        x = int(next(it)); y = int(next(it))\n        rebels.append((x, y))\n        \n    bases = []\n    for _ in range(B):\n        x = int(next(it)); y = int(next(it))\n        bases.append((x, y))\n        \n    if R != B:\n        print(\"No\")\n        return\n        \n    def ccw(A, B, C, D):\n        # Cross product of vectors AB and AD\n        val = (B[0]-A[0])*(D[1]-A[1]) - (B[1]-A[1])*(D[0]-A[0])\n        return val > 0\n        \n    def segments_intersect(edge1, edge2):\n        A, B = edge1\n        C, D = edge2\n        o1 = ccw(A, B, C, D)\n        o2 = ccw(A, B, D, C)\n        o3 = ccw(C, D, A, B)\n        o4 = ccw(C, D, B, A)\n        \n        if (o1 != o2) and (o3 != o4):\n            return True\n            \n        return False\n        \n    n = R\n    bases_list = bases\n    found = False\n    \n    for perm in permutations(bases_list):\n        edges = []\n        for i in range(n):\n            edges.append( (rebels[i], perm[i]) )\n            \n        valid = True\n        for i in range(len(edges)):\n            for j in range(i+1, len(edges)):\n                if segments_intersect(edges[i], edges[j]):\n                    valid = False\n                    break\n            if not valid:\n                break\n                \n        if valid:\n            found = True\n            break\n            \n    print(\"Yes\" if found else \"No\")\n\nif __name__ == '__main__':\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 479,
        "completion_token_count": 959,
        "thoughts_token_count": 1023
    }
}