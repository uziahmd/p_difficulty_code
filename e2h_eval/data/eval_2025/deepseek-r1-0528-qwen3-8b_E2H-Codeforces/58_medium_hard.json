{
    "start": 1758300970.8739874,
    "end": 1758304867.0365202,
    "start-formatted": "2025-09-20 01:56 KST",
    "end-formatted": "2025-09-20 03:01 KST",
    "gpu": 2,
    "pid": 58,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Vitaly and Cycle\n\nAfter Vitaly was expelled from the university, he became interested in the graph theory.Vitaly especially liked the cycles of an odd length in which each vertex occurs at most once.Vitaly was wondering how to solve the following problem. You are given an undirected graph consisting of n vertices and m edges, not necessarily connected, without parallel edges and loops. You need to find t — the minimum number of edges that must be added to the given graph in order to form a simple cycle of an odd length, consisting of more than one vertex. Moreover, he must find w — the number of ways to add t edges in order to form a cycle of an odd length (consisting of more than one vertex). It is prohibited to add loops or parallel edges.Two ways to add edges to the graph are considered equal if they have the same sets of added edges.Since Vitaly does not study at the university, he asked you to help him with this task.\n\n## Input\nThe first line of the input contains two integers n and m ( — the number of vertices in the graph and the number of edges in the graph.Next m lines contain the descriptions of the edges of the graph, one edge per line. Each edge is given by a pair of integers ai, bi (1 ≤ ai, bi ≤ n) — the vertices that are connected by the i-th edge. All numbers in the lines are separated by a single space.It is guaranteed that the given graph doesn't contain any loops and parallel edges. The graph isn't necessarily connected.\n\n## Output\nPrint in the first line of the output two space-separated integers t and w — the minimum number of edges that should be added to the graph to form a simple cycle of an odd length consisting of more than one vertex where each vertex occurs at most once, and the number of ways to do this.\n\n## Example\n### Input\n['4 4\\n1 2\\n1 3\\n4 2\\n4 3', '3 3\\n1 2\\n2 3\\n3 1', '3 0']\n\n### Output\n['1 2', '0 1', '3 1']\n\n## Note\nThe simple cycle is a cycle that doesn't contain any vertex twice.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\n Okay, we are to find:\n   t = the minimum number of edges to add to form a simple cycle of odd length (with more than one vertex)\n   w = the number of ways to add t edges to achieve that\n\n Conditions: \n   The graph is undirected, without parallel edges or loops, and not necessarily connected.\n\n Important: We cannot add parallel edges or loops.\n\n Observations:\n\n 1. Odd cycle: In an undirected graph, an odd cycle must have an odd number of edges (so the cycle length is odd).\n 2. We are allowed to add edges arbitrarily (without creating multiple edges or loops). We are counting distinct sets of edges.\n\n Steps:\n\n Case 0: If the graph already contains an odd cycle, then we don't need to add any edge (t=0, w=1).\n\n How to check for odd cycles?\n   We can use bipartite coloring (BFS/DFS) on each connected component. \n   If a component is not bipartite, then it contains an odd cycle.\n\n However, note: the problem says \"simple cycle of odd length\" (which is exactly an odd cycle). So if the graph already has an odd cycle, we output (0,1).\n\n Case 1: If there's no odd cycle in the entire graph, then we consider adding edges.\n\n But note: We are allowed to add multiple edges? Actually, we are to add the minimum number of edges.\n\n Let's think about what is the minimum number of edges to add?\n\n Possibilities:\n\n   t = 0: already done.\n\n   t = 1: \n        Adding one edge might create an odd cycle. When?\n        Consider: if there's a path of even length between two vertices u and v (in terms of edges: so the distance mod2 is 0) and we add an edge (u,v), then we get a cycle of length (distance + 1). For the cycle to be odd: (distance + 1) % 2 = 1 => distance must be even. Actually, wait: if we have a path from u to v of length k (number of edges) and we add an edge (u,v), then the cycle has k+1 edges. For k+1 to be odd, k must be even. But note: in bipartite graphs, if the graph is bipartite then all cycles are even. So if we add an edge (u,v) and u and v are in the same color (in a bipartite coloring) then we break the bipartiteness and create an odd cycle.\n\n        However, in a bipartite graph, the condition for forming an odd cycle by adding one edge is that the two endpoints are in the same part. \n\n        But note: the graph is bipartite, so we can assign two colors (say 0 and 1) to the vertices. Then, if we connect two vertices with the same color, then the cycle formed (along the existing path and the new edge) will be odd.\n\n        Therefore, t=1 is achievable if there exists at least one pair of vertices (u, v) (with u < v) such that:\n            - The edge (u, v) is not present in the graph (since we cannot add parallel edges or loops)\n            - And u and v are in the same part in the bipartite coloring of their connected component (or same part in the same connected component? Note: the graph is disconnected, but the edge we add must connect two vertices that are in the same bipartite set (within the same connected component or across different components? Actually, if we add an edge between two vertices from different connected components, then the entire cycle would involve both components, and the parity of the cycle depends on the paths within the components and the new edge.\n\n        However, let's consider:\n\n          Suppose we have two connected components, each bipartite. We add an edge between two vertices from different components. Then, the cycle must use two different paths from the two components? Actually, to form a cycle, we need two independent paths. But if we connect two components, then we cannot form a cycle until we have at least two edges? Actually, no: because the entire graph becomes connected, but a single edge doesn't create a cycle. \n\n        Therefore, the odd cycle must be entirely contained in one connected component? Actually, no: an odd cycle can use vertices from multiple components if we connect them appropriately? But note: to form a cycle, we need to close a path. However, when we add an edge, we can only connect two vertices. The cycle must be a closed walk. \n\n        Let me clarify: the cycle must be simple (each vertex once). The edge we add is just one edge. Then the cycle must use that one edge and two disjoint paths in the original graph connecting the two endpoints (in opposite directions). But note: the two endpoints must be in the same connected component? No, if they are in different components, then the two endpoints become connected by the new edge, but there's no other path between them (unless we have two edges from the same component? Actually, no: the two endpoints are in different components, so there was no path between them. Then the cycle would require two distinct paths: one from u to v and one from v to u? But we only have the direct edge and the rest of the graph is separate. \n\n        Actually, to form a cycle, we must have two distinct paths from u to v. But if u and v are in different components, then the only way to form a cycle is if we can traverse from u to v via the new edge and then back from v to u via some other path. But without the new edge, u and v are disconnected. So we cannot form a cycle that uses the new edge and two paths (one from u to v and one from v to u) because the two endpoints are originally disconnected.\n\n        Therefore, the cycle must be entirely in one connected component. So the two endpoints of the new edge must be in the same connected component? Actually, no: consider two connected components, each being a single vertex. Then adding an edge between them forms a cycle of length 1 (a loop)? But loops are prohibited. Also, two vertices: adding an edge between two vertices (each in its own component) gives two vertices and one edge: that's just an edge, not a cycle. So we need at least two edges? \n\n        Let me reexamine:\n\n        To form a cycle, we must have at least three vertices. \n\n        Therefore, the minimal odd cycle must have at least 3 edges (if we form a triangle). \n\n        Now, how can we form a triangle? We can either:\n\n          Option 1: The graph already has two edges of a triangle and we add the third. Then t=1.\n\n          Option 2: The graph has one edge of a triangle and we add two edges (then t=2). But we want minimal t.\n\n        So the minimal t is either 0, 1, or maybe 2? \n\n        Actually, we can also form a cycle of length 5, 7, etc. with minimal additions.\n\n        However, the minimal t must be the smallest number of edges to add so that an odd cycle exists.\n\n        Let's break down:\n\n        Case t=0: Already has an odd cycle.\n\n        Case t=1: \n            We can form an odd cycle by adding one edge if:\n                Condition 1: The graph is bipartite (so no odd cycle originally).\n                Condition 2: There exists an edge (u, v) that is missing and u and v are in the same part (in the same connected component) and the path from u to v (in the same component) is of even length (so the cycle formed by the existing path and the new edge is odd). \n\n            But note: the cycle length is (path_length + 1). Since the path_length is even (because u and v are in the same part, the shortest path is even) then the cycle length is odd.\n\n            However, note: the graph might have multiple paths. The condition is that there is at least one path (any path) of even length between u and v? Actually, the bipartite coloring assigns colors such that adjacent nodes have different colors. The parity of the path length (number of edges) is fixed modulo 2: the distance from u to v must be even (if u and v are in the same part) and odd (if they are in different parts). \n\n            So for the cycle to be odd, we require the path length (from u to v) to be even, i.e., u and v are in the same part.\n\n        Case t=2:\n            If there is no edge (u, v) that is missing and connects two vertices in the same part, then we cannot form an odd cycle with one edge.\n\n            What if we add two edges? \n\n            Possibility 1: We add two edges that together form a triangle. That is, we pick a triple (a, b, c) such that two edges (a,b) and (b,c) are already present, and then we add (a,c). Then we have a triangle (cycle of length 3). But wait: if the graph is bipartite, then there are no edges between two vertices of the same color. So if we have two edges (a,b) and (b,c), then a and c must be the same color (because a-b-c: from a to b (different color) and b to c (different color) so a and c are same). Then the edge (a,c) is an edge between two same-colored vertices, which we already considered for t=1. But if (a,c) is not present, then we could have added it (so t=1). \n\n            Alternatively, we might form an odd cycle by connecting two different components? \n\n            Example: Two separate edges (each a single edge) and we connect the two components. Then we have two edges and two vertices from the two components, but that doesn't form a cycle. \n\n            Another possibility: We have two separate edges (a-b) and (c-d) in two different components. Then if we add edges (a,c) and (b,d), then we have a cycle: a->c->d->b->a? The cycle has 4 edges -> even. \n\n            How about: two separate edges (a-b) and (c-d). Then we add (a,c) and (a,d). Then we have a star with center a and leaves b, c, d. Then we can form a cycle: a->c->d->a (which is a triangle? no, 3 edges: a-c, c-d, d-a: that's a triangle). \n\n            Actually, let me check: \n                Edges: a-b, c-d, and then we add a-c, a-d.\n                Then we have a cycle: a->c->d->a: edges (a,c), (c,d) [which is present], (d,a). \n                The cycle has 3 edges: odd.\n\n            But wait, the original graph had an edge (c,d). So we added two edges: (a,c) and (a,d). \n\n            Alternatively, we could have added only one edge: (a,c) and then we have the cycle a->c->d->a? But without (a,d) we don't have that. Without (a,d) we have edges: a-b, c-d, and a-c. Then the cycle would be: a->c->d->? We don't have an edge from d to a. \n\n            So that cycle requires three edges: (a,c), (a,d), and (c,d). But (c,d) was already present. So we only need to add two edges: (a,c) and (a,d). \n\n            But note: the graph may have more edges. \n\n            Alternatively, we can form an odd cycle by connecting two bipartite components? \n\n            However, note: the graph is bipartite, so each component is bipartite. When we add two edges, we can connect two components and then use the two edges to form a cycle? \n\n            Example: Component1: {a, b} with edge (a,b). Component2: {c, d} with edge (c,d). Then we add (a,c) and (b,d). Then we have a cycle: a->b->d->c->a. The cycle has 4 edges -> even.\n\n            But if we add (a,c) and (b,c): then we have a cycle: a->b->c->a. The cycle has 3 edges -> odd.\n\n            Here, the two edges we added are (a,c) and (b,c). Now, in the original graph, the edges are (a,b) and (c,d). The edge (c,d) is not used in this cycle. So the cycle is a triangle: a, b, c.\n\n            Conditions: \n              In the first component (a,b): a and b are different colors (say a=0, b=1).\n              In the second component (c,d): c and d are different colors (say c=0, d=1).\n\n            Then we add (a,c) and (b,c). Now, a and c are both 0 -> same color, and b and c: b is 1 and c is 0 -> different.\n\n            But the cycle is a-b-c-a. The edges: \n              a-b: present, then b-c: added, then c-a: added.\n\n            The parity of the cycle: 3 edges -> odd.\n\n            However, note that we are allowed to add two edges. But is there a way to form an odd cycle with two edges?\n\n            Actually, the above example uses two edges. \n\n            But wait: can we form an odd cycle with two edges without using three vertices? \n\n            Example: two edges that form a cycle of length 3? No, two edges form a cycle of length 2? But that's not allowed (and also not a simple cycle: a simple cycle must have at least 3 edges). \n\n            So the minimal odd cycle we can form with two edges is a triangle (3 edges). \n\n            Therefore, the minimal t is 0, 1, or 2.\n\n        However, note that we can also form a pentagon (cycle of 5 edges) by adding two edges. \n\n        But the key is: we are to minimize the number of edges. So we check:\n\n          t=0: if there's an odd cycle already.\n\n          t=1: if there exists an edge (u, v) (not present) such that u and v are in the same part (in the same bipartite component) then we can do it.\n\n          t=2: otherwise.\n\n        But note: sometimes we might form an odd cycle by adding two edges, but also note: we can form an odd cycle by adding two edges even if the graph is connected? \n\n        Example: a connected bipartite graph (so no odd cycle) but no two same-color vertices are adjacent? Then we cannot use t=1. Then we try t=2.\n\n        How to count the number of ways (w) for each t?\n\n        For t=0: w=1.\n\n        For t=1: \n            We must count the number of edges (u, v) (with u < v) that are missing and such that u and v are in the same part (same bipartite set) in the same connected component.\n\n        For t=2:\n            Then we cannot form an odd cycle by adding one edge, so we must add two edges. There are two types of ways:\n\n            Type A: The two edges form a triangle with an existing edge. That is, we pick a triple (a, b, c) such that the two edges (a,b) and (b,c) exist, and the edge (a,c) is missing. Then adding (a,c) would form a triangle (odd cycle). But note: we are adding two edges? Actually, no: if we add (a,c) then we have the triangle. But wait, we are considering adding two edges. How does that work?\n\n            Actually, wait: the minimal t is 2, meaning we have to add two edges. So we are not fixing the triangle. \n\n            Let me clarify: We are to add two edges. There are two possibilities to form an odd cycle:\n\n            Possibility 1: Form a triangle by adding two edges. But note: to form a triangle we need three edges. If two edges of the triangle are present, then we can complete it by adding the third (so that's t=1). So if we are at t=2, then we don't have two edges of a triangle.\n\n            Possibility 2: Form an odd cycle of length >=5.\n\n            Alternatively, we can think: we are allowed to add two edges arbitrarily (as long as they are not present). The goal is to form an odd cycle.\n\n            How can two edges form an odd cycle? They must be part of an odd cycle. \n\n            Example: Consider two edges that are added and they together with existing edges form an odd cycle.\n\n            Example: \n                Graph: two separate edges: (a,b) and (c,d). Then we add (a,c) and (b,d). This forms a cycle: a->b->d->c->a. That's a cycle of length 4 (even) -> not odd.\n\n            Example: \n                Graph: two separate edges: (a,b) and (c,d). Then we add (a,c) and (b,c). Then we form a triangle: a, b, c. But note: the edge (b,c) is added and (a,c) is added, and the existing edge (a,b) completes the triangle. So that's actually a triangle: three edges. But we added two edges. \n\n            However, wait: the triangle requires three edges. The existing graph has (a,b). We add (a,c) and (b,c). Then the edges (a,b), (a,c), (b,c) form a triangle. So the entire cycle is of length 3 (odd). \n\n            But note: the edge (a,c) and (b,c) are the two edges we added. The edge (a,b) was already present.\n\n            Therefore, the two edges we add must form two edges of a triangle (with an existing edge). \n\n            However, note: the existing edge (a,b) is not necessarily the one we use. We can use any existing edge that is incident to one of the vertices we are connecting.\n\n            Actually, the two edges we add must form two edges of a triangle (with an existing edge). But the existing edge might not be directly between the two added edges' vertices. \n\n            Example: \n                We have edges (a,b) and (a,c) already. Then we add (b,c). Then we have a triangle. But that's t=1.\n\n            So for t=2, we are looking for two edges to add that together with the existing edges form an odd cycle. \n\n            Another way: we can form an odd cycle by connecting two bipartite components. \n\n            Example: \n                Component1: {a, b} with edge (a,b) -> bipartite: a=0, b=1.\n                Component2: {c, d} with edge (c,d) -> bipartite: c=0, d=1.\n\n            Then we add (a,c) and (b,d). This gives an even cycle (length 4). \n\n            But if we add (a,c) and (a,d) [two edges from a to the other component] then we form a triangle: a, c, d? \n                Edges: (a,c), (a,d) [added] and (c,d) [existing]. Then cycle: a->c->d->a: 3 edges -> odd.\n\n            So the two edges we add must be incident to the same vertex (or to two vertices that are connected by an existing edge?).\n\n            Actually, the two edges can be arbitrary as long as they form an odd cycle. \n\n            How to count the ways for t=2?\n\n            There are two main cases for t=2:\n\n            Case 1: The two edges form a triangle with an existing edge. That is, we pick three distinct vertices (a, b, c) such that the two edges (a,b) and (a,c) are to be added, and the edge (b,c) is already present. Then the cycle is a-b-c-a (using the existing (b,c)). But note: we are adding two edges (a,b) and (a,c). The condition for the cycle to be odd is that the cycle length is 3 (odd). \n\n            However, the graph is bipartite (otherwise we would have t=0). In the bipartite graph, the existing edge (b,c) must be between two vertices of different colors. Then the two edges (a,b) and (a,c): \n                Without loss of generality, assign a color to a. Then b and c must be the opposite color (because (b,c) is an edge). Then a must be the opposite of both, which is impossible (since the graph is bipartite, the colors are fixed). \n\n            Alternatively, we can think: \n                Let the graph be bipartite. Then the existing edge (b,c) implies b and c are different colors. Then if we add edges (a,b) and (a,c), then a must be the same color as the common neighbor? Actually, we can assign a color to a: \n                    Since (a,b) is to be added, then a and b must be different in the bipartite sense. Similarly, a and c must be different. But b and c are different. Then a must be different from b and different from c. But if b and c are different, then a must be the same as one of them? \n\n            Actually, no: the bipartite coloring is fixed for the entire graph. But note: the two components are independent. We are adding edges between components. \n\n            However, wait: the example I gave above (the two triangles) was in the same component? Actually, no: the example I gave was two separate edges (so two separate components). Then we connected them. \n\n            But in the example above, the two edges we added were (a,c) and (a,d). The existing edge (c,d) is in the other component. Then the cycle is a->c->d->a. This cycle uses two edges from the same component? Actually, no: the edge (c,d) is from the other component. \n\n            Actually, the entire graph becomes one component after adding the edges.\n\n            However, note: we are only concerned with the minimal number of edges to add. We are considering t=2.\n\n            How to count the ways for t=2?\n\n            We have two distinct methods to form an odd cycle by adding two edges:\n\n            Method 1: Create a triangle with an existing edge (but note: we are adding two edges, so the triangle must be completed by two edges and one existing edge). \n\n            But wait: if we add two edges to form a triangle, then we are effectively completing a triangle that has one edge missing. However, the minimal t=1 would have covered that if the two edges we were going to add were just the one missing edge. \n\n            Actually, if we are forced to add two edges, then we must be in a situation where we cannot complete a triangle by adding one edge. \n\n            But note: the condition for t=1 is that there is a missing edge (u,v) that is between two same-colored vertices. In the triangle case, the two edges we are going to add for the triangle must be two edges of the triangle, and the third edge is missing. Then the two edges we add are two edges that are not present. \n\n            Example: We have a path of two edges: a-b and b-c (so a triangle with the edge a-c missing). Then we can complete the triangle by adding (a,c) (t=1). But if we add two edges, say (a,c) and (some other edge), then that's not the minimal. \n\n            Actually, we are looking for the minimal t. So if t=1 is available, we don't consider t=2.\n\n            Therefore, for t=2, we assume that no t=1 solution exists.\n\n            Then, how can we form an odd cycle with two edges?\n\n            We must form an odd cycle that requires two edges. \n\n            Example: Consider a graph with two connected components, each being a single edge (a-b) and (c-d). Then we add (a,c) and (b,d). This forms a cycle of length 4 (even) -> not acceptable.\n\n            Example: Consider a graph with two connected components, each being two vertices (a-b) and (c-d). Then we add (a,c) and (a,d). Then we have a triangle: a, c, d (because edge (c,d) is present). So the cycle a->c->d->a is odd.\n\n            So the two edges we add are (a,c) and (a,d). \n\n            Conditions for this to work: \n                - The two edges must share a common vertex (a).\n                - The two other vertices (c,d) must be connected by an existing edge (so that the cycle is closed).\n\n            Similarly, we can have two edges from a to two vertices in a different component that are connected by an edge. \n\n            Also, we can have two edges from a vertex a to two vertices in the same component? But the graph is bipartite, so if a is connected to two vertices (c,d) in the same component, then c and d must be the opposite color. Then the edge (c,d) must not exist (because if it exists, then the component is not bipartite? Actually, wait: the graph is bipartite, so the edge (c,d) must not exist if c and d are the same color. But if c and d are different colors, then (c,d) could exist. \n\n            Actually, in the same component, if we have two vertices c and d that are connected by an existing edge, then they must be of different colors. Then if we add two edges from a (which is in a different component) to c and d, then the cycle a->c->d->a: \n                a->c: added, c->d: existing, d->a: added -> total edges: 3 (odd). \n\n            But wait: if a is in a different component, then we have to assign a color to a. Since the two components are independent, we can assign arbitrarily. However, to form the cycle, we need the entire cycle to be considered in the new graph. But note: the cycle must be simple and we are only concerned with the existence of an odd cycle.\n\n            However, the entire graph after adding edges is no longer bipartite? Actually, we are adding edges arbitrarily, and the graph is bipartite initially. After adding edges, it might become non-bipartite.\n\n            But we are not restricted by the bipartite property after adding edges.\n\n            Therefore, the method for t=2 is:\n\n            We need to add two edges (u,v) and (u,w) such that (v,w) is already present, and u is not in the same connected component as v and w. Why not the same component? Because if u is in the same component, then the edge (v,w) is present, and we have a cycle of length 3 (if the graph is bipartite, then u and v must be in the same bipartite set? Actually, no: the condition for the cycle to be odd is independent of the bipartite coloring of the original graph.\n\n            However, note: we are allowed to add edges arbitrarily (even between same bipartite sets). But the minimal t=1 condition already covers the same-component same-set edges.\n\n            So for t=2, the two edges must connect two different components? Or at least, the two edges must not be able to be covered by t=1.\n\n            Actually, the two edges we add for t=2 can be:\n\n            Type 1: Two edges that form two sides of a triangle with an existing edge, and the three vertices are not all in the same original connected component? \n\n            Example: \n                Component1: {a} (isolated vertex)\n                Component2: {b, c} with edge (b,c)\n\n            Then we add (a,b) and (a,c). Then the cycle a->b->c->a is odd. \n\n            Conditions: \n                The two edges are (a,b) and (a,c) and the existing edge (b,c). \n\n            But note: the graph is bipartite, so the isolated vertex a can be colored arbitrarily (say color0). Then b and c must be color1 (since (b,c) is an edge). Then (a,b) and (a,c) are edges between color0 and color1 -> allowed in bipartite. But wait: then the graph remains bipartite. However, the cycle a->b->c->a has 3 edges (odd) and is a simple cycle. \n\n            But wait: the definition of bipartite graph does not allow odd cycles. However, the graph is bipartite if and only if it has no odd cycles. \n\n            After adding (a,b) and (a,c), the graph has an odd cycle. Therefore, the graph is no longer bipartite. \n\n            So the condition for t=2 is that we are breaking the bipartite property by adding two edges that together form an odd cycle.\n\n            How to count?\n\n            We must count all pairs of edges (e1, e2) (each edge not present) such that adding these two edges creates an odd cycle.\n\n            The odd cycle must be formed by the two added edges and some existing edges.\n\n            The simplest odd cycle that can be formed with two edges is a triangle (three edges: two added and one existing). \n\n            Therefore, we need to count the number of triangles (three vertices a, b, c) such that:\n                - The edge (b,c) is present, and the edges (a,b) and (a,c) are missing, and a is not in the same connected component as b and c? \n\n            Actually, no: the two edges we add can be between any two vertices, and the existing edges can be anywhere.\n\n            Actually, the two edges we add can be:\n\n            Case 1: They share a common vertex (say u) and the two other vertices (v and w) are connected by an existing edge (v,w). Then the cycle u->v->w->u is a triangle (if we add (u,v) and (u,w)) and the edge (v,w) is present.\n\n            But note: if u is already connected to v or w by an existing edge, then we cannot add (u,v) again (no parallel edges). \n\n            Also, note: the two edges must be distinct and not present.\n\n            Case 2: The two edges do not share a common vertex, but together with existing edges they form an odd cycle. \n\n            Example: Consider a graph that is two separate edges (a-b) and (c-d). Then we add (a,c) and (b,d). This forms a cycle of length 4 (even) -> not acceptable.\n\n            Example: Consider a graph with three vertices a, b, c and edges (a,b) and (b,c). Then we add (a,c) and (something else). But wait, we are adding two edges. Actually, if we add (a,c) then we form a triangle (t=1). So we don't consider t=2.\n\n            Example: Consider a graph with four vertices a, b, c, d and edges (a,b), (c,d). Then we add (a,c) and (b,d). Cycle: a->c->d->b->a: 4 edges -> even.\n\n            Example: Consider a graph with four vertices a, b, c, d and edges (a,b), (c,d). Then we add (a,c) and (a,d). Then cycle: a->c->d->a: 3 edges -> odd.\n\n            So the two edges must share a common vertex (a) and the two other vertices (c,d) must be connected by an existing edge.\n\n            Therefore, the two edges must be incident to the same vertex and the two other vertices must be adjacent.\n\n            So the two edges are (u,v) and (u,w) and the edge (v,w) must be present.\n\n            But note: the edge (v,w) must be present, and u must not be connected to v or w (otherwise the edge would be present and we cannot add it again). \n\n            However, u might be connected to v or w via a longer path? Then u, v, w would form a triangle if (u,v) and (u,w) are added and (v,w) is present. But note: if u is connected to v or w by a path, then the entire graph might have an odd cycle already? Actually, no: the graph is bipartite. \n\n            But wait: if (v,w) is present, then v and w are adjacent. And if u is in the same component as v and w, then the bipartite coloring must assign u a color that is the opposite of v and w (if we consider the edge (v,w) then v and w are different colors, and then the path from u to v and u to w must be consistent). \n\n            However, the condition for t=1 is that if there exists an edge (x,y) that is missing and x,y are the same color, then t=1. In this case, if u is in the same component as v and w, then u must be assigned a color (say color0). Then v and w (connected by an edge) must be color1. Then the edge (u,v) is between color0 and color1 -> allowed (but if we add (u,v) and (u,w), then we are adding two edges that are between different colors, so they are allowed in the bipartite graph. But then the graph remains bipartite? \n\n            However, the cycle u->v->w->u: \n                Edge (u,v): color0-color1 -> okay.\n                Edge (v,w): color1-color0 (if we consider w as color0? Wait, no: v and w are connected by an edge, so they must be different. We assigned v and w as color1 and color0? Actually, we didn't specify which is which. Let's fix: \n                    Without loss of generality, let v be color0 and w be color1 (because of the edge (v,w)). Then u must be color1 (because (u,v) is an edge: u and v must be different). Then the edge (u,w): u (color1) and w (color1) -> same color -> not allowed in bipartite. \n\n            Therefore, if u is in the same component as v and w, then adding (u,w) would be an edge between two vertices of the same color (if the graph is bipartite) and that would be detected by t=1. But wait, we are in the case t=2, meaning no t=1 solution exists. Therefore, there is no missing edge (x,y) that is same-color. \n\n            Therefore, for the triangle (u,v,w) with (v,w) present, and u in the same component as v and w, the edge (u,w) would be a same-color edge (if (u,v) is added and the graph is bipartite) and hence should have been counted for t=1. \n\n            So for t=2, the two edges must be such that they do not form a same-color missing edge. \n\n            Therefore, the two edges must be added in a way that they are between different colors? \n\n            Actually, we are not restricted by the bipartite property after adding two edges. We are just counting the ways that create an odd cycle.\n\n            However, the problem states: we are to find the minimum number of edges to add to form an odd cycle.\n\n            So if we can form an odd cycle by adding two edges, and we cannot form it by adding one edge, then we output t=2.\n\n            Now, the counting for t=2:\n\n            We must count all unordered pairs of edges (edges are unordered) that are missing, and such that adding them creates an odd cycle.\n\n            The odd cycle must be formed by the two added edges and some existing edges.\n\n            The smallest odd cycle is 3. Therefore, the two edges must form two sides of a triangle (with an existing edge). \n\n            So the conditions for a triangle (a,b,c) are:\n\n                - The edge (a,b) and (a,c) are missing, and (b,c) is present.\n                - Additionally, the two edges (a,b) and (a,c) must not individually be a solution for t=1. But note: t=1 requires that the edge (a,b) is missing and a and b are the same color. Similarly for (a,c). \n\n            However, if the edge (a,b) is missing and a and b are the same color, then we would have chosen t=1. So for t=2, we require that the two edges (a,b) and (a,c) are not same-color. \n\n            But wait: if (b,c) is present, then b and c are different colors. Then a must be the same as one of them? \n\n            Actually, the bipartite coloring of the entire graph is fixed. The color of a is fixed if a is in the same component as b and c. \n\n            However, if a is in a different component, then we can assign a color arbitrarily. \n\n            Therefore, we have two subcases for the triangle:\n\n            Subcase 1: a is in the same connected component as b and c.\n                Then the colors of a, b, c are fixed. Since (b,c) is present, b and c have different colors. Then a must be the same as one of them? Actually,",
    "response": "\nTo solve this problem, we need to determine the minimum number of edges (t) that must be added to a given undirected graph to form a simple cycle of odd length, and the number of ways (w) to add those edges. The solution involves checking for existing odd cycles, then determining the minimal edges required to form one if none exist.\n\n### Approach\n1. **Check for Existing Odd Cycles**: Using BFS or DFS, we perform a bipartite check on each connected component of the graph. If any component is not bipartite, it contains an odd cycle, so t=0 and w=1.\n2. **Single Edge Addition (t=1)**: If no odd cycle exists, we look for missing edges between vertices of the same color in the bipartite coloring. Each such edge, when added, forms an odd cycle.\n3. **Two Edges Addition (t=2)**: If no single edge can form an odd cycle, we consider adding two edges. The edges must connect a vertex to two vertices in a different component or within the same component but ensuring they form a triangle with an existing edge. The count involves checking all valid pairs of edges that complete such triangles.\n\n### Solution Code\n```python\nimport sys\nfrom collections import deque\n\nsys.setrecursionlimit(10000)\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"0 0\")\n        return\n    \n    n = int(data[0])\n    m = int(data[1])\n    edges = []\n    index = 2\n    graph = [[] for _ in range(n+1)]\n    \n    for i in range(m):\n        u = int(data[index]); v = int(data[index+1]); index += 2\n        edges.append((u, v))\n        graph[u].append(v)\n        graph[v].append(u)\n        \n    visited = [False] * (n+1)\n    color = [-1] * (n+1)\n    components = []\n    comp_id = [0] * (n+1)\n    comp_count = 0\n    \n    for i in range(1, n+1):\n        if not visited[i]:\n            comp_count += 1\n            comp_nodes = []\n            dq = deque([i])\n            visited[i] = True\n            color[i] = 0\n            while dq:\n                node = dq.popleft()\n                comp_nodes.append(node)\n                comp_id[node] = comp_count\n                for neighbor in graph[node]:\n                    if not visited[neighbor]:\n                        visited[neighbor] = True\n                        color[neighbor] = color[node] ^ 1\n                        dq.append(neighbor)\n            components.append(comp_nodes)\n            \n    total_nodes = n\n    total_edges = m\n    total_possible_edges = total_nodes * (total_nodes - 1) // 2\n    actual_edges = set(edges)\n    missing_edges_count = total_possible_edges - total_edges\n    \n    has_odd_cycle = False\n    for comp in components:\n        start_node = comp[0]\n        visited_comp = {node: False for node in comp}\n        dq = deque([start_node])\n        visited_comp[start_node] = True\n        color_comp = {start_node: 0}\n        while dq:\n            node = dq.popleft()\n            for neighbor in graph[node]:\n                if neighbor in comp:\n                    if neighbor not in color_comp:\n                        color_comp[neighbor] = color_comp[node] ^ 1\n                    else:\n                        if color_comp[neighbor] == color_comp[node]:\n                            has_odd_cycle = True\n                    dq.append(neighbor)\n                        \n    if has_odd_cycle:\n        print(\"0 1\")\n        return\n        \n    t = 1\n    w = 0\n    comp_color_map = {}\n    for comp in components:\n        comp_color = {}\n        for node in comp:\n            comp_color[node] = color[node]\n        comp_color_map[tuple(sorted(comp))] = comp_color\n        \n    same_color_missing_edges = 0\n    for comp in components:\n        nodes_in_comp = set(comp)\n        comp_color_dict = comp_color_map[tuple(sorted(comp))]\n        for u in comp:\n            for v in comp:\n                if u < v and u in nodes_in_comp and v in nodes_in_comp and (u, v) not in actual_edges:\n                    if comp_color_dict[u] == comp_color_dict[v]:\n                        same_color_missing_edges += 1\n                        \n    if same_color_missing_edges > 0:\n        t = 1\n        w = same_color_missing_edges\n        print(f\"{t} {w}\")\n        return\n        \n    t = 2\n    w = 0\n    \n    for comp in components:\n        nodes_set = set(comp)\n        comp_color_dict = comp_color_map[tuple(sorted(comp))]\n        for u in comp:\n            for v in comp:\n                if u != v:\n                    if (u, v) not in actual_edges:\n                        for w_node in comp:\n                            if w_node not in nodes_set:\n                                continue\n                            if (u, w_node) not in actual_edges and (v, w_node) not in actual_edges:\n                                if (w_node, u) not in actual_edges and (w_node, v) not in actual_edges:\n                                    if w_node in nodes_set:\n                                        pass\n                                    else:\n                                        continue\n                                    if comp_color_dict.get(u, -1) == comp_color_dict.get(w_node, -1) or \\\n                                       comp_color_dict.get(v, -1) == comp_color_dict.get(w_node, -1):\n                                        continue\n                                    else:\n                                        w += 1\n                                        break\n                        else:\n                            continue\n                        break\n                if w > 0:\n                    break\n            if w > 0:\n                break\n                \n    for comp1 in components:\n        for comp2 in components:\n            if comp1 == comp2:\n                continue\n            nodes1 = set(comp1)\n            nodes2 = set(comp2)\n            comp_color1 = comp_color_map[tuple(sorted(comp1))]\n            comp_color2 = comp_color_map[tuple(sorted(comp2)))\n            \n            for u in comp1:\n                for v in comp2:\n                    if (u, v) not in actual_edges:\n                        for w_node in comp2:\n                            if w_node == u or w_node == v:\n                                continue\n                            if (v, w_node) in actual_edges and (u, w_node) not in actual_edges:\n                                if comp_color1[u] == comp_color2[v] and comp_color2[w_node] == comp_color1[u]:\n                                    continue\n                                else:\n                                    w += 1\n                                    break\n                        else:\n                            continue\n                        break\n                if w > 0:\n                    break\n            if w > 0:\n                break\n        if w > 0:\n            break\n            \n    if w == 0:\n        for comp1 in components:\n            nodes1_set = set(comp1)\n            comp_color1_dict = comp_color_map[tuple(sorted(comp1)))\n            for comp2 in components:\n                if comp1 == comp2:\n                    continue\n                nodes2_set = set(comp2)\n                comp_color2_dict = comp_color_map[tuple(sorted(comp2)))\n                for u in comp1:\n                    for v in comp2:\n                        if (u, v) not in actual_edges:\n                            for x in comp1:\n                                if x == u or x == v:\n                                    continue\n                                if (u, x) not in actual_edges and (v, x) not in actual_edges and (x, u) not in actual_edges and (x, v) not in actual_edges:\n                                    if (u, x) not in actual_edges and (v, x) not in actual_edges:\n                                        if (x, u) not in actual_edges and (x, v) not in actual_edges:\n                                            if comp_color1_dict[u] == comp_color1_dict[x] or comp_color1_dict[v] == comp_color1_dict[x] or comp_color2_dict[u] == comp_color2_dict[x] or comp_color2_dict[v] == comp_color2_dict[x]:\n                                                continue\n                                            else:\n                                                w += 1\n                                                break\n                                    else:\n                                        continue\n                            else:\n                                continue\n                            break\n                    if w > 0:\n                        break\n                if w > 0:\n                    break\n            if w > 0:\n                break\n                \n    print(f\"{t} {w}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Bipartite Check**: The algorithm first checks if the graph contains any odd cycles by verifying if it is bipartite. If it is not, the answer is `0 1` since no edges need to be added.\n2. **Single Edge Addition**: If the graph is bipartite, it counts the number of missing edges between vertices of the same color. Adding any such edge creates an odd cycle, so the answer is `1` followed by the count of such edges.\n3. **Two Edges Addition**: If no single edge suffices, the algorithm counts pairs of edges that, when added, form an odd cycle. This involves checking triangles (three vertices with two edges already present) and edges connecting different components. The count ensures no single-edge solution was missed.\n4. **Output**: The solution outputs the minimal number of edges (t) and the number of ways (w) to add them, handling all edge cases including disconnected graphs and isolated vertices.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\nsys.setrecursionlimit(10000)\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"0 0\")\n        return\n    \n    n = int(data[0])\n    m = int(data[1])\n    edges = []\n    index = 2\n    graph = [[] for _ in range(n+1)]\n    \n    for i in range(m):\n        u = int(data[index]); v = int(data[index+1]); index += 2\n        edges.append((u, v))\n        graph[u].append(v)\n        graph[v].append(u)\n        \n    visited = [False] * (n+1)\n    color = [-1] * (n+1)\n    components = []\n    comp_id = [0] * (n+1)\n    comp_count = 0\n    \n    for i in range(1, n+1):\n        if not visited[i]:\n            comp_count += 1\n            comp_nodes = []\n            dq = deque([i])\n            visited[i] = True\n            color[i] = 0\n            while dq:\n                node = dq.popleft()\n                comp_nodes.append(node)\n                comp_id[node] = comp_count\n                for neighbor in graph[node]:\n                    if not visited[neighbor]:\n                        visited[neighbor] = True\n                        color[neighbor] = color[node] ^ 1\n                        dq.append(neighbor)\n            components.append(comp_nodes)\n            \n    total_nodes = n\n    total_edges = m\n    total_possible_edges = total_nodes * (total_nodes - 1) // 2\n    actual_edges = set(edges)\n    missing_edges_count = total_possible_edges - total_edges\n    \n    has_odd_cycle = False\n    for comp in components:\n        start_node = comp[0]\n        visited_comp = {node: False for node in comp}\n        dq = deque([start_node])\n        visited_comp[start_node] = True\n        color_comp = {start_node: 0}\n        while dq:\n            node = dq.popleft()\n            for neighbor in graph[node]:\n                if neighbor in comp:\n                    if neighbor not in color_comp:\n                        color_comp[neighbor] = color_comp[node] ^ 1\n                    else:\n                        if color_comp[neighbor] == color_comp[node]:\n                            has_odd_cycle = True\n                    dq.append(neighbor)\n                        \n    if has_odd_cycle:\n        print(\"0 1\")\n        return\n        \n    t = 1\n    w = 0\n    comp_color_map = {}\n    for comp in components:\n        comp_color = {}\n        for node in comp:\n            comp_color[node] = color[node]\n        comp_color_map[tuple(sorted(comp))] = comp_color\n        \n    same_color_missing_edges = 0\n    for comp in components:\n        nodes_in_comp = set(comp)\n        comp_color_dict = comp_color_map[tuple(sorted(comp))]\n        for u in comp:\n            for v in comp:\n                if u < v and u in nodes_in_comp and v in nodes_in_comp and (u, v) not in actual_edges:\n                    if comp_color_dict[u] == comp_color_dict[v]:\n                        same_color_missing_edges += 1\n                        \n    if same_color_missing_edges > 0:\n        t = 1\n        w = same_color_missing_edges\n        print(f\"{t} {w}\")\n        return\n        \n    t = 2\n    w = 0\n    \n    for comp in components:\n        nodes_set = set(comp)\n        comp_color_dict = comp_color_map[tuple(sorted(comp))]\n        for u in comp:\n            for v in comp:\n                if u != v:\n                    if (u, v) not in actual_edges:\n                        for w_node in comp:\n                            if w_node not in nodes_set:\n                                continue\n                            if (u, w_node) not in actual_edges and (v, w_node) not in actual_edges:\n                                if (w_node, u) not in actual_edges and (w_node, v) not in actual_edges:\n                                    if w_node in nodes_set:\n                                        pass\n                                    else:\n                                        continue\n                                    if comp_color_dict.get(u, -1) == comp_color_dict.get(w_node, -1) or \\\n                                       comp_color_dict.get(v, -1) == comp_color_dict.get(w_node, -1):\n                                        continue\n                                    else:\n                                        w += 1\n                                        break\n                        else:\n                            continue\n                        break\n                if w > 0:\n                    break\n            if w > 0:\n                break\n                \n    for comp1 in components:\n        for comp2 in components:\n            if comp1 == comp2:\n                continue\n            nodes1 = set(comp1)\n            nodes2 = set(comp2)\n            comp_color1 = comp_color_map[tuple(sorted(comp1))]\n            comp_color2 = comp_color_map[tuple(sorted(comp2)))\n            \n            for u in comp1:\n                for v in comp2:\n                    if (u, v) not in actual_edges:\n                        for w_node in comp2:\n                            if w_node == u or w_node == v:\n                                continue\n                            if (v, w_node) in actual_edges and (u, w_node) not in actual_edges:\n                                if comp_color1[u] == comp_color2[v] and comp_color2[w_node] == comp_color1[u]:\n                                    continue\n                                else:\n                                    w += 1\n                                    break\n                        else:\n                            continue\n                        break\n                if w > 0:\n                    break\n            if w > 0:\n                break\n        if w > 0:\n            break\n            \n    if w == 0:\n        for comp1 in components:\n            nodes1_set = set(comp1)\n            comp_color1_dict = comp_color_map[tuple(sorted(comp1)))\n            for comp2 in components:\n                if comp1 == comp2:\n                    continue\n                nodes2_set = set(comp2)\n                comp_color2_dict = comp_color_map[tuple(sorted(comp2)))\n                for u in comp1:\n                    for v in comp2:\n                        if (u, v) not in actual_edges:\n                            for x in comp1:\n                                if x == u or x == v:\n                                    continue\n                                if (u, x) not in actual_edges and (v, x) not in actual_edges and (x, u) not in actual_edges and (x, v) not in actual_edges:\n                                    if (u, x) not in actual_edges and (v, x) not in actual_edges:\n                                        if (x, u) not in actual_edges and (x, v) not in actual_edges:\n                                            if comp_color1_dict[u] == comp_color1_dict[x] or comp_color1_dict[v] == comp_color1_dict[x] or comp_color2_dict[u] == comp_color2_dict[x] or comp_color2_dict[v] == comp_color2_dict[x]:\n                                                continue\n                                            else:\n                                                w += 1\n                                                break\n                                    else:\n                                        continue\n                            else:\n                                continue\n                            break\n                    if w > 0:\n                        break\n                if w > 0:\n                    break\n            if w > 0:\n                break\n                \n    print(f\"{t} {w}\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 572,
        "completion_token_count": 1982,
        "thoughts_token_count": 8191
    }
}