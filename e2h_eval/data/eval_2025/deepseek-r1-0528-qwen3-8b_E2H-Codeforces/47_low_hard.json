{
    "start": 1758296540.3311594,
    "end": 1758299471.8277888,
    "start-formatted": "2025-09-20 00:42 KST",
    "end-formatted": "2025-09-20 01:31 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\n Okay, we are given two integers a and b (1 <= a, b <= 10^9). We are to find a non-negative integer k such that the LCM(a+k, b+k) is minimized, and if there are multiple k with the same minimal LCM, choose the smallest k.\n\n Observation:\n Let d = (a+k) - (b+k) = a-b (constant). Then note that the two numbers are (a+k) and (b+k) and their difference is fixed (a-b). \n\n However, note: if a == b, then the two numbers are equal. Then for k=0, we have LCM(a, a) = a, and for any k>0, we have LCM(a+k, a+k) = a+k which is larger. So in this case, answer is 0.\n\n But when a != b, let g = gcd(a+k, b+k). Then note that the LCM is (a+k)*(b+k) / g.\n\n Alternatively, note that the two numbers are (a+k) and (b+k). Their difference is |a-b|. Also, the gcd of two numbers is always a divisor of their difference.\n\n Therefore, we can think: let d = |a-b| (without loss of generality, we can assume a>=b? but note k is nonnegative so we can consider symmetry). Actually, without loss of generality, we can set d = a-b if a>=b, or d = b-a if not. But note: the problem does not specify which is bigger.\n\n However, note: the problem says two integers a and b. They can be in any order.\n\n Alternate approach:\n\n Consider that for a fixed divisor g of d (the absolute difference), we can try to set k such that:\n   g divides both (a+k) and (b+k). Then g must divide d (the difference). \n\n Moreover, we require:\n   (a+k) % g == 0 and (b+k) % g == 0.\n\n But note: if g divides d, then we can set k such that k ≡ (-a) mod g and also k ≡ (-b) mod g. Since d is divisible by g, then these two congruences are consistent.\n\n Specifically, we can set k to be the smallest nonnegative solution to:\n   k ≡ (-a) mod g   and   k ≡ (-b) mod g.\n\n Since the two congruences are equivalent modulo g (because a-b is divisible by g), we can set k as the smallest nonnegative integer satisfying:\n   k ≡ r (mod g), where r = (-a) mod g, i.e., r = (g - a % g) % g? Actually, we want k such that (a+k) % g == 0, so k ≡ (-a) mod g, so k_min = (g - (a % g)) % g, but wait: if a % g == 0 then k_min=0, else k_min = g - (a % g). However, note that we also have the condition from b: but since g divides d, then (a % g) == (b % g) because d is divisible by g. So we only need one condition.\n\n But note: the problem asks for the k that minimizes the LCM. The LCM for a given g (which divides d) would be (a+k)*(b+k)/g. However, note that k is determined by g: k_min(g) is the smallest nonnegative k such that g divides (a+k) and (b+k). Then the two numbers become multiples of g. But note: the LCM might be expressed in terms of g and the quotients.\n\n However, note that the LCM is (a+k)*(b+k) / gcd(a+k, b+k). But we know that the gcd(a+k, b+k) must be a divisor of d. Moreover, the gcd might be larger than g? Actually, no: we are fixing g as a divisor of d, and we set k so that g divides both. But the actual gcd could be any common divisor, but note that the gcd must divide d, and we are iterating over divisors of d. However, the minimal LCM might come from a divisor that is not necessarily the gcd? Actually, we can use the following:\n\n Insight: The LCM of two numbers x and y is |x*y| / gcd(x,y). And note that x = a+k, y = b+k, and the difference is fixed (d). The product x*y = (a+k)*(b+k) is increasing with k (since k>=0). However, the gcd might change and we cannot simply minimize the product.\n\n Alternate Insight (known from similar problems):\n\n We note that the problem is symmetric in a and b. Without loss of generality, assume a",
    "response": "\nTo solve this problem, we need to find a non-negative integer \\( k \\) such that the least common multiple (LCM) of \\( a+k \\) and \\( b+k \\) is minimized. If multiple values of \\( k \\) yield the same minimal LCM, we should choose the smallest \\( k \\).\n\n### Approach\n1. **Problem Analysis**: The key observation here is that the difference between \\( a+k \\) and \\( b+k \\) is constant (\\( |a - b| \\)). The LCM of two numbers \\( x \\) and \\( y \\) can be expressed as \\( \\text{LCM}(x, y) = \\frac{x \\times y}{\\text{GCD}(x, y)} \\). To minimize the LCM, we need to maximize the GCD of \\( a+k \\) and \\( b+k \\), since their product increases with \\( k \\).\n\n2. **Insight**: The GCD of \\( a+k \\) and \\( b+k \\) must be a divisor of the absolute difference \\( d = |a - b| \\). Therefore, for each divisor \\( g \\) of \\( d \\), we can find the smallest \\( k \\) such that \\( g \\) divides both \\( a+k \\) and \\( b+k \\). This \\( k \\) is determined by solving the congruence \\( k \\equiv (-a) \\mod g \\) (or equivalently \\( k \\equiv (-b) \\mod g \\)).\n\n3. **Algorithm Selection**: \n   - Compute all divisors of \\( d = |a - b| \\).\n   - For each divisor \\( g \\), compute the smallest non-negative \\( k \\) that satisfies \\( k \\equiv (-a) \\mod g \\).\n   - Calculate the LCM for \\( a+k \\) and \\( b+k \\) using the computed \\( k \\).\n   - Track the \\( k \\) that results in the smallest LCM. If multiple \\( k \\) values yield the same minimal LCM, choose the smallest \\( k \\).\n\n4. **Edge Cases**: Handle cases where \\( a = b \\) separately, as the LCM is minimized when \\( k = 0 \\).\n\n### Solution Code\n```python\nimport math\nfrom functools import reduce\nimport sys\n\ndef get_divisors(n):\n    if n == 0:\n        return []\n    divisors = set()\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n        i += 1\n    return divisors\n\ndef main():\n    data = sys.stdin.readline().split()\n    a = int(data[0])\n    b = int(data[1])\n    \n    if a == b:\n        print(0)\n        return\n        \n    d = abs(a - b)\n    divisors = get_divisors(d)\n    candidates = {}\n    min_k = float('inf')\n    best_lcm = float('inf')\n    \n    for g in divisors:\n        r = (-a) % g\n        k = r\n        if k == 0:\n            candidates[k] = True\n            \n        x = a + k\n        y = b + k\n        current_gcd = math.gcd(x, y)\n        current_lcm = (x * y) // current_gcd\n        \n        if current_lcm < best_lcm:\n            best_lcm = current_lcm\n            min_k = k\n        elif current_lcm == best_lcm and k < min_k:\n            min_k = k\n            \n    print(min_k)\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input consists of two integers \\( a \\) and \\( b \\).\n2. **Special Case Handling**: If \\( a \\) equals \\( b \\), the solution is trivially \\( k = 0 \\).\n3. **Divisor Calculation**: Compute all divisors of the absolute difference \\( d = |a - b| \\).\n4. **Candidate Evaluation**: For each divisor \\( g \\), determine the smallest \\( k \\) such that \\( g \\) divides both \\( a+k \\) and \\( b+k \\). This \\( k \\) is found using modular arithmetic.\n5. **LCM Calculation**: For each candidate \\( k \\), compute the LCM of \\( a+k \\) and \\( b+k \\). Track the smallest LCM and the corresponding smallest \\( k \\).\n6. **Output**: Print the smallest \\( k \\) that minimizes the LCM.\n\nThis approach efficiently narrows down the problem to evaluating divisors of the difference between \\( a \\) and \\( b \\), leveraging mathematical insights to avoid brute-force checks and ensure optimal performance.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\nfrom functools import reduce\nimport sys\n\ndef get_divisors(n):\n    if n == 0:\n        return []\n    divisors = set()\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n        i += 1\n    return divisors\n\ndef main():\n    data = sys.stdin.readline().split()\n    a = int(data[0])\n    b = int(data[1])\n    \n    if a == b:\n        print(0)\n        return\n        \n    d = abs(a - b)\n    divisors = get_divisors(d)\n    candidates = {}\n    min_k = float('inf')\n    best_lcm = float('inf')\n    \n    for g in divisors:\n        r = (-a) % g\n        k = r\n        if k == 0:\n            candidates[k] = True\n            \n        x = a + k\n        y = b + k\n        current_gcd = math.gcd(x, y)\n        current_lcm = (x * y) // current_gcd\n        \n        if current_lcm < best_lcm:\n            best_lcm = current_lcm\n            min_k = k\n        elif current_lcm == best_lcm and k < min_k:\n            min_k = k\n            \n    print(min_k)\n\nif __name__ == '__main__':\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 396,
        "completion_token_count": 1003,
        "thoughts_token_count": 1023
    }
}