{
    "start": 1758092386.5629776,
    "end": 1758094071.7136476,
    "start-formatted": "2025-09-17 15:59 KST",
    "end-formatted": "2025-09-17 16:27 KST",
    "gpu": 2,
    "pid": 9,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Selling Souvenirs\n\nAfter several latest reforms many tourists are planning to visit Berland, and Berland people understood that it's an opportunity to earn money and changed their jobs to attract tourists. Petya, for example, left the IT corporation he had been working for and started to sell souvenirs at the market.This morning, as usual, Petya will come to the market. Petya has n different souvenirs to sell; ith souvenir is characterised by its weight wi and cost ci. Petya knows that he might not be able to carry all the souvenirs to the market. So Petya wants to choose a subset of souvenirs such that its total weight is not greater than m, and total cost is maximum possible.Help Petya to determine maximum possible total cost.\n\n## Input\nThe first line contains two integers n and m (1 ≤ n ≤ 100000, 1 ≤ m ≤ 300000) — the number of Petya's souvenirs and total weight that he can carry to the market.Then n lines follow. ith line contains two integers wi and ci (1 ≤ wi ≤ 3, 1 ≤ ci ≤ 109) — the weight and the cost of ith souvenir.\n\n## Output\nPrint one number — maximum possible total cost of souvenirs that Petya can carry to the market.\n\n## Example\n### Input\n['1 1\\n2 1', '2 2\\n1 3\\n2 2', '4 3\\n3 10\\n2 7\\n2 8\\n1 1']\n\n### Output\n['0', '3', '10']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\n Okay, we are given up to 100000 souvenirs, each with weight in {1,2,3} and a cost (which can be up to 10^9). We have a maximum total weight m (up to 300000).\n\n Since the weights are only 1, 2, or 3, we can group the souvenirs by weight.\n\n Let:\n   type1 = list of costs for souvenirs with weight 1\n   type2 = list of costs for souvenirs with weight 2\n   type3 = list of costs for souvenirs with weight 3\n\n Then, we want to choose some number of items from each type such that the total weight <= m and the total cost is maximized.\n\n However, note: we cannot use more than floor(m/weight) of a particular type, but also we have three types and the total weight must not exceed m.\n\n But note: the problem is similar to the bounded knapsack problem with small weights (only 1,2,3) and large capacity (m up to 300000). However, because the weights are so small and the capacity is large, we can use a dynamic programming that iterates over the three types and uses the fact that the capacity is large but the items are grouped by weight.\n\n Alternatively, we can consider:\n\n Let's define:\n   Let x1, x2, x3 be the number of items we take from type1, type2, type3 respectively.\n\n Then, the constraints are:\n   x1 + 2*x2 + 3*x3 <= m\n\n And we want to maximize:\n   sum_{i=1}^{x1} (a_i) + sum_{j=1}^{x2} (b_j) + sum_{k=1}^{x3} (c_k)\n\n But note: for each type, we have multiple items. However, within a type, we can sort the items by cost and then the best way to choose k items from that type is to take the k largest ones.\n\n So, for each type, we can precompute the prefix sums for the sorted list (in descending order) so that we know the total cost for taking the top k items.\n\n Steps:\n\n 1. Read n and m.\n 2. Read the next n lines, each containing two integers: wi and ci.\n\n 3. Separate the items into three lists: one for weight1, one for weight2, one for weight3.\n\n 4. For each list (type1, type2, type3), sort the list in descending order and compute the prefix sums (so that prefix[k] = sum of the first k items, i.e., the k largest).\n\n 5. Now, we are going to iterate over the possible numbers of type3 items (since type3 has the highest weight, it will limit the number choices) and then for each fixed x3, we consider the remaining weight m' = m - 3*x3 (if negative, skip). Then, we need to choose x1 and x2 such that x1 + 2*x2 <= m', and we want to maximize the cost from type1 and type2.\n\n Alternatively, we can fix x3 from 0 up to min(floor(m/3), len(type3)), and then for the remaining capacity (m_remaining = m - 3*x3) we need to combine type1 and type2.\n\n But note: the capacity remaining is m_remaining, and we can use any number of type1 and type2 as long as the total weight (x1 + 2*x2) <= m_remaining.\n\n However, we can also use a two-dimensional dynamic programming for the remaining two types? But the capacity m_remaining can be up to 300000 and we have two types, but note that the number of items in each type might be large (up to 100000) but the capacity is fixed.\n\n Actually, we can use the idea of \"unbounded knapsack\" for two types? But note: we have a bound on the number of items per type (because we can't use more than the available items). However, since we precomputed the prefix sums (which are the best k items), we can think of each type as having multiple copies of an item that gives a certain weight and value, but actually we are limited by the total number of items and their individual weights.\n\n Alternatively, we can use the following:\n\n For fixed x3, let R = m - 3*x3 (if R<0, break). Then we need to solve:\n\n   max_{x1, x2} { prefix1[x1] + prefix2[x2] } \n   subject to x1 + 2*x2 <= R, and 0<=x1<=len(type1), 0<=x2",
    "response": "\nTo solve this problem, we need to maximize the total cost of souvenirs that Petya can carry to the market without exceeding a given weight limit. The souvenirs are categorized by their weights (1, 2, or 3), which simplifies the problem compared to a general knapsack problem.\n\n### Approach\n1. **Categorize Souvenirs**: Group the souvenirs by their weights (1, 2, or 3) into three separate lists.\n2. **Sort and Prefix Sums**: For each group, sort the souvenirs in descending order of their costs and compute prefix sums. This allows us to quickly access the maximum cost achievable by selecting the top `k` items from any group.\n3. **Iterate Over Possible Counts of Heaviest Items**: Since items with weight 3 have the highest individual weight, we iterate over possible counts of these items (from 0 up to the maximum feasible count). For each count, calculate the remaining weight capacity after including these items.\n4. **Dynamic Programming for Remaining Capacity**: For the remaining weight, use dynamic programming to find the optimal combination of items from the weight-1 and weight-2 groups. This involves precomputing the best possible costs for all possible combinations of these two groups within the remaining weight capacity.\n5. **Maximize Total Cost**: For each iteration of the heaviest items, combine the precomputed best costs from the lighter items to determine the overall maximum cost.\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(0)\n        return\n        \n    n = int(data[0])\n    m_val = int(data[1])\n    \n    type1 = []\n    type2 = []\n    type3 = []\n    \n    index = 2\n    for _ in range(n):\n        w = int(data[index])\n        c = int(data[index + 1])\n        index += 2\n        if w == 1:\n            type1.append(c)\n        elif w == 2:\n            type2.append(c)\n        elif w == 3:\n            type3.append(c)\n            \n    type1.sort(reverse=True)\n    type2.sort(reverse=True)\n    type3.sort(reverse=True)\n    \n    len1 = len(type1)\n    len2 = len(type2)\n    len3 = len(type3)\n    \n    prefix1 = [0] * (len1 + 1)\n    prefix2 = [0] * (len2 + 1)\n    prefix3 = [0] * (len3 + 1)\n    \n    for i in range(1, len1 + 1):\n        prefix1[i] = prefix1[i - 1] + type1[i - 1]\n        \n    for i in range(1, len2 + 1):\n        prefix2[i] = prefix2[i - 1] + type2[i - 1]\n        \n    for i in range(1, len3 + 1):\n        prefix3[i] = prefix3[i - 1] + type3[i - 1]\n        \n    max_cost = 0\n    max_x3 = min(len3, m_val // 3)\n    \n    dp = [[0] * (min(len2, m_val // 2) + 1) for _ in range(len1 + 1)]\n    \n    for i in range(len1 + 1):\n        for j in range(min(len2, m_val // 2) + 1):\n            weight_used = i + 2 * j\n            if weight_used <= m_val:\n                if i < len1 and j < len2:\n                    dp[i][j] = max(prefix1[i] + dp[i+1][j], prefix2[j] + dp[i][j+1])\n                elif i < len1:\n                    dp[i][j] = prefix1[i]\n                elif j < len2:\n                    dp[i][j] = prefix2[j]\n                else:\n                    dp[i][j] = 0\n            else:\n                dp[i][j] = 0\n                \n    for x3 in range(max_x3 + 1):\n        rem = m_val - 3 * x3\n        if rem < 0:\n            break\n            \n        current_cost = prefix3[x3] + dp[0][0]\n        if current_cost > max_cost:\n            max_cost = current_cost\n            \n    print(max_cost)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Input Handling**: The input is read and parsed into the number of souvenirs `n` and the maximum weight capacity `m_val`.\n2. **Categorization**: Souvenirs are categorized into three lists based on their weights (1, 2, or 3).\n3. **Sorting and Prefix Sums**: Each category is sorted in descending order of cost, and prefix sums are computed to facilitate quick calculation of the total cost for selecting the top `k` items.\n4. **Dynamic Programming Setup**: A DP table is initialized to store the maximum cost achievable by combining items from the weight-1 and weight-2 categories for all possible counts of these items within the remaining weight capacity after selecting weight-3 items.\n5. **Iteration Over Weight-3 Items**: For each possible count of weight-3 items, the remaining weight capacity is calculated. The DP table is used to find the best combination of weight-1 and weight-2 items that fits within this remaining capacity.\n6. **Result Calculation**: The maximum total cost is updated by combining the cost from the selected weight-3 items with the best cost from the DP table for the remaining weight. The final result is printed.\n\nThis approach efficiently narrows down the problem using the constraints on item weights and leverages dynamic programming to explore optimal combinations without excessive computational overhead.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(0)\n        return\n        \n    n = int(data[0])\n    m_val = int(data[1])\n    \n    type1 = []\n    type2 = []\n    type3 = []\n    \n    index = 2\n    for _ in range(n):\n        w = int(data[index])\n        c = int(data[index + 1])\n        index += 2\n        if w == 1:\n            type1.append(c)\n        elif w == 2:\n            type2.append(c)\n        elif w == 3:\n            type3.append(c)\n            \n    type1.sort(reverse=True)\n    type2.sort(reverse=True)\n    type3.sort(reverse=True)\n    \n    len1 = len(type1)\n    len2 = len(type2)\n    len3 = len(type3)\n    \n    prefix1 = [0] * (len1 + 1)\n    prefix2 = [0] * (len2 + 1)\n    prefix3 = [0] * (len3 + 1)\n    \n    for i in range(1, len1 + 1):\n        prefix1[i] = prefix1[i - 1] + type1[i - 1]\n        \n    for i in range(1, len2 + 1):\n        prefix2[i] = prefix2[i - 1] + type2[i - 1]\n        \n    for i in range(1, len3 + 1):\n        prefix3[i] = prefix3[i - 1] + type3[i - 1]\n        \n    max_cost = 0\n    max_x3 = min(len3, m_val // 3)\n    \n    dp = [[0] * (min(len2, m_val // 2) + 1) for _ in range(len1 + 1)]\n    \n    for i in range(len1 + 1):\n        for j in range(min(len2, m_val // 2) + 1):\n            weight_used = i + 2 * j\n            if weight_used <= m_val:\n                if i < len1 and j < len2:\n                    dp[i][j] = max(prefix1[i] + dp[i+1][j], prefix2[j] + dp[i][j+1])\n                elif i < len1:\n                    dp[i][j] = prefix1[i]\n                elif j < len2:\n                    dp[i][j] = prefix2[j]\n                else:\n                    dp[i][j] = 0\n            else:\n                dp[i][j] = 0\n                \n    for x3 in range(max_x3 + 1):\n        rem = m_val - 3 * x3\n        if rem < 0:\n            break\n            \n        current_cost = prefix3[x3] + dp[0][0]\n        if current_cost > max_cost:\n            max_cost = current_cost\n            \n    print(max_cost)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 468,
        "completion_token_count": 1223,
        "thoughts_token_count": 1023
    }
}