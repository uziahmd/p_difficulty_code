{
    "start": 1758302666.1702633,
    "end": 1758306339.540777,
    "start-formatted": "2025-09-20 02:24 KST",
    "end-formatted": "2025-09-20 03:25 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\n Okay, we are given a graph with n nodes and m edges. Each edge has two numbers: gcd and lcm.\n\n We know that for an edge (u, v) with gcd = g and lcm = l, the numbers of mushrooms on u and v must satisfy:\n   Let the numbers be a and b.\n   Then, g = gcd(a, b) and l = lcm(a, b).\n\n Also, note the identity: a * b = g * l * gcd(a//g, b//g)   [But wait, actually we have: \n        a = g * a', b = g * b', and then lcm(a, b) = g * a' * b' / gcd(a', b')\n        So, g * a' * b' / gcd(a', b') = l  =>  a' * b' = (l / g) * gcd(a', b')? \n\n Alternatively, we can use:\n        a * b = g * l   [because: gcd(a,b)=g, then a = g * a', b = g * b', and then lcm(a,b)=g * a' * b' / gcd(a',b')=l.\n        But note: the product of two numbers is also equal to (gcd * lcm) if the two numbers are such that they don't share any prime factors beyond what is in the gcd? Actually, we have the identity: \n        a * b = gcd(a, b) * lcm(a, b)   always holds.\n\n However, there is a catch: from the gcd and lcm, we can recover the two numbers only up to the factors of the quotient (l/g). Specifically, we can set:\n        Let x = a // g, y = b // g. Then gcd(x, y) must divide (l // g) because the lcm is g * (x*y // gcd(x,y)) = l => x*y // gcd(x,y) = l // g.\n\n But note: we have the condition that the lcm must be divisible by the gcd. In fact, we must have g divides l, and also the condition that for the two numbers a and b, we have:\n        a = g * x, b = g * y, and then the lcm is g * (x*y // gcd(x,y)) = l.\n\n However, the problem does not require unique restoration. We just need to assign any one possibility.\n\n Steps:\n\n 1. Check for each edge: \n        - The gcd must divide the lcm (otherwise, invalid).\n        - Also, note that the product a*b must equal g*l. But wait, that identity holds, so we can use that.\n\n However, the problem is that we have multiple constraints from different edges. We have to assign a number to each node such that for every edge (u, v) with given (g, l), the two conditions hold:\n        gcd(a[u], a[v]) = g and lcm(a[u], a[v]) = l.\n\n How can we do this?\n\n Observation:\n        Since the identity holds: a[u] * a[v] = g * l, but note: actually, the identity is that for any two positive integers a and b: \n                a * b = gcd(a, b) * lcm(a, b)\n        Therefore, for each edge, the product of the two numbers must be g * l.\n\n So for each edge (u, v): \n        a[u] * a[v] = g * l.\n\n Now, we have a system of equations (each edge gives a constraint on the product) and also the gcd condition.\n\n However, note: the gcd condition might be more restrictive. For example, consider two edges incident to the same node. We can set up:\n\n        Let a[i] be the value at node i.\n\n        For each edge (i, j): \n            a[i] * a[j] = g * l\n\n        And for each edge (i, j): \n            gcd(a[i], a[j]) = g\n\n But note: from the product equation, we can write a[j] = (g*l) / a[i]. Then, the gcd condition becomes:\n            gcd(a[i], (g*l)//a[i]) = g.\n\n How to approach?\n\n Another idea: factorize the numbers? But the numbers can be up to 10^6, and n, m can be up to 10^5? Actually, the problem says n, m can be up to 10^5? The input constraints say: \"The first line contains two numbers n and m ()\" — it doesn't specify the range, but the example has small numbers. However, the problem states: \"It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106\" meaning the GCD and LCM are between 1 and 10^6.\n\n But note:",
    "response": "\nTo solve this problem, we need to determine if it's possible to restore the number of mushrooms on each lawn (vertex) in a forest map based on given roads (edges) with their respective GCD and LCM values. The solution involves verifying constraints derived from these values and ensuring consistency across all edges.\n\n### Approach\n1. **Problem Analysis**: The problem requires assigning a positive integer to each vertex such that for every edge connecting two vertices, the GCD and LCM of their assigned values match the given values. The key insight is leveraging the mathematical identity that for any two integers \\(a\\) and \\(b\\), \\(a \\times b = \\text{GCD}(a, b) \\times \\text{LCM}(a, b)\\). This allows us to derive potential values for adjacent vertices.\n\n2. **Key Insight**: For each edge, the product of the values at its endpoints must equal the product of the given GCD and LCM. Additionally, the GCD of these values must match the given GCD. This leads us to consider the greatest common divisor (GCD) as a base value, and then adjust the values by factors derived from the LCM.\n\n3. **Algorithm Selection**:\n   - **Graph Representation**: Represent the graph using an adjacency list where each node stores connected nodes and corresponding GCD/LCM pairs.\n   - **Value Assignment**: For each node, start with a base value (initially 1) and propagate values based on edges. For each edge, compute the required value for the neighbor node as \\((\\text{GCD} \\times \\text{LCM}) / \\text{current node's value}\\).\n   - **Validation**: After assigning values, verify that the GCD of connected nodes matches the given GCD. If any check fails, the arrangement is impossible.\n\n4. **Complexity Analysis**: The algorithm processes each edge once during assignment and validation. The complexity is linear with respect to the number of edges, \\(O(m)\\), making it efficient for large inputs.\n\n### Solution Code\n```python\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        print(\"NO\")\n        return\n    \n    it = iter(data)\n    n = int(next(it)); m = int(next(it))\n    \n    graph = defaultdict(list)\n    for _ in range(m):\n        u = int(next(it)); v = int(next(it))\n        g_val = int(next(it)); l_val = int(next(it))\n        graph[u].append((v, g_val, l_val))\n        graph[v].append((u, g_val, l_val))\n        \n    if m == 0:\n        print(\"YES\")\n        print(\" \".join([\"1\"] * n))\n        return\n        \n    ans = [0] * (n+1)\n    stack = []\n    for i in range(1, n+1):\n        stack.append(i)\n        break\n        \n    visited = [False] * (n+1)\n    parent = {}\n    for i in range(1, n+1):\n        visited[i] = False\n        \n    def dfs(node, base):\n        visited[node] = True\n        ans[node] = base\n        for neighbor, g_val, l_val in graph[node]:\n            if neighbor == parent.get(node, None):\n                continue\n            if visited[neighbor]:\n                if ans[neighbor] != (g_val * l_val) // base:\n                    print(\"NO\")\n                    return\n                continue\n            stack.append(neighbor)\n            parent[neighbor] = node\n            dfs(neighbor, (g_val * l_val) // base)\n            \n    try:\n        dfs(1, 1)\n    except RecursionError:\n        print(\"NO\")\n        return\n        \n    for i in range(1, n+1):\n        if not visited[i]:\n            stack.append(i)\n            parent[i] = None\n            dfs(i, 1)\n                \n    for i in range(1, n+1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n            \n    for u in range(1, n+1):\n        for v, g_val, l_val in graph[u]:\n            if gcd(ans[u], ans[v]) != g_val or (ans[u] * ans[v]) // gcd(ans[u], ans[v]) != l_val:\n                print(\"NO\")\n                return\n                \n    print(\"YES\")\n    print(\" \".join(map(str, ans[1:n+1])))\n    \ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into the number of lawns (nodes) and roads (edges). Each edge is stored in an adjacency list with its GCD and LCM values.\n2. **Initial Check**: If there are no edges, assign 1 to each lawn by default.\n3. **Depth-First Search (DFS)**: The DFS traverses the graph starting from node 1, assigning each node a value based on the product of the edge's GCD and LCM divided by its parent's value.\n4. **Validation**: After assigning values, the solution checks if the GCD and LCM of connected nodes match the given values. If any check fails, the answer is \"NO\".\n5. **Output**: If all checks pass, the solution outputs \"YES\" followed by the assigned values for each lawn.\n\nThis approach efficiently verifies the feasibility of the mushroom count arrangement while ensuring all given constraints are met.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import defaultdict\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        print(\"NO\")\n        return\n    \n    it = iter(data)\n    n = int(next(it)); m = int(next(it))\n    \n    graph = defaultdict(list)\n    for _ in range(m):\n        u = int(next(it)); v = int(next(it))\n        g_val = int(next(it)); l_val = int(next(it))\n        graph[u].append((v, g_val, l_val))\n        graph[v].append((u, g_val, l_val))\n        \n    if m == 0:\n        print(\"YES\")\n        print(\" \".join([\"1\"] * n))\n        return\n        \n    ans = [0] * (n+1)\n    stack = []\n    for i in range(1, n+1):\n        stack.append(i)\n        break\n        \n    visited = [False] * (n+1)\n    parent = {}\n    for i in range(1, n+1):\n        visited[i] = False\n        \n    def dfs(node, base):\n        visited[node] = True\n        ans[node] = base\n        for neighbor, g_val, l_val in graph[node]:\n            if neighbor == parent.get(node, None):\n                continue\n            if visited[neighbor]:\n                if ans[neighbor] != (g_val * l_val) // base:\n                    print(\"NO\")\n                    return\n                continue\n            stack.append(neighbor)\n            parent[neighbor] = node\n            dfs(neighbor, (g_val * l_val) // base)\n            \n    try:\n        dfs(1, 1)\n    except RecursionError:\n        print(\"NO\")\n        return\n        \n    for i in range(1, n+1):\n        if not visited[i]:\n            stack.append(i)\n            parent[i] = None\n            dfs(i, 1)\n                \n    for i in range(1, n+1):\n        if not visited[i]:\n            print(\"NO\")\n            return\n            \n    for u in range(1, n+1):\n        for v, g_val, l_val in graph[u]:\n            if gcd(ans[u], ans[v]) != g_val or (ans[u] * ans[v]) // gcd(ans[u], ans[v]) != l_val:\n                print(\"NO\")\n                return\n                \n    print(\"YES\")\n    print(\" \".join(map(str, ans[1:n+1])))\n    \ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 544,
        "completion_token_count": 1173,
        "thoughts_token_count": 1023
    }
}