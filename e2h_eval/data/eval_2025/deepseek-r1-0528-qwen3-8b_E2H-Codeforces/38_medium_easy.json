{
    "start": 1758300973.4676933,
    "end": 1758304805.6091073,
    "start-formatted": "2025-09-20 01:56 KST",
    "end-formatted": "2025-09-20 03:00 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\n Okay, we are given an integer p (0 <= p <= 200000). We need to:\n 1. Find the minimum number of nodes n such that there exists a directed graph with n nodes that is p-reachable.\n    - Note: The graph must have exactly p ordered pairs (u, v) with u < v and u and v being mutually reachable.\n\n 2. Among all graphs with the minimum number of nodes that are p-reachable, find the maximum number of unidirectional pairs (u, v) (with u != v, a path from u to v but not from v to u).\n\n Observation for part 1:\n\n What does it mean for a graph to be p-reachable?\n   We require that the graph has exactly p ordered pairs (u, v) (with u < v) such that u and v are mutually reachable.\n\n Note: In a directed graph, mutual reachability defines strongly connected components (SCCs). In fact, two nodes are in the same SCC if they are mutually reachable.\n\n However, note the problem says \"exactly p ordered pairs of nodes (u, v) such that u < v and u and v are reachable from each other\". \n But note: In an SCC, the entire component is strongly connected. The condition for being p-reachable is that the total number of unordered pairs (u, v) with u < v that are in the same SCC is p.\n\n However, note: the problem counts ordered pairs? Actually, the condition is: \"exactly p ordered pairs of nodes (u, v) such that u < v\" — wait, no: the problem says \"ordered pairs\" but then says \"u < v\". Actually, the condition is: \n   \"exactly p ordered pairs of nodes (u, v) such that u < v and u and v are reachable from each other\"\n\n So, it's counting the unordered pairs (since u < v) but the term \"ordered pair\" might be a bit misleading. But note: the problem says \"ordered pair\" at the beginning for the unidirectional definition, but here the condition for p-reachable is defined by counting pairs (u, v) with u < v.\n\n Actually, let me clarify: \n   In the p-reachable condition, we are counting unordered pairs (because we have u < v). But note the problem says \"ordered pairs of nodes (u, v)\" — wait, no: the condition for p-reachable is: \"exactly p ordered pairs of nodes (u, v) such that u < v\". \n\n But wait: an ordered pair (u, v) with u < v is just one specific ordering. So the condition is that the graph has exactly p edges (if you think of the underlying undirected graph) of mutual reachability? Not exactly: because two nodes in the same SCC form a mutual reachability, and if there are k nodes in an SCC, then the number of unordered pairs (u, v) (with u < v) in that SCC is C(k,2). Then the total p is the sum of C(k_i,2) over all SCCs.\n\n Now, note: the entire graph must be built so that the set of SCCs (which are disjoint) gives this total p.\n\n How to minimize the number of nodes?\n\n Let the graph have n nodes. We can partition the n nodes into several SCCs. Each SCC is a strongly connected component. Then the total p is the sum_{each SCC} of C(size_i, 2).\n\n We want to choose a partition (size_1, size_2, ..., size_k) such that the sum of C(size_i, 2) = p, and we minimize n = sum_i size_i.\n\n Also, note that we can arrange the graph arbitrarily as long as the SCC structure is as given. We are free to choose the structure of the SCCs (they can be cycles or complete tournaments, etc.), but the key is the sizes.\n\n The problem now reduces to: represent p as a sum of triangular numbers (i.e., C(k,2) = k*(k-1)//2) and minimize the total nodes (which is the sum of k_i).\n\n However, note: we cannot break the condition that the entire graph must be built with n nodes, and we can use only the SCC decomposition.\n\n But note: the graph must be built so that the SCCs are disjoint and cover all n nodes.\n\n Therefore, we need to represent p as the sum of some triangular numbers (each triangular number corresponds to an SCC of size k_i, which contributes T(k_i) = k_i*(k_i-1)//2) and the total nodes is the sum of k_i.\n\n And we want to minimize the total nodes (the sum of the k_i) such that the sum of T(k_i) = p.\n\n Additionally, we are allowed to have multiple SCCs (each of size at least 1). The triangular number for k=1 is 0, for k=2 is 1, for k=3 is 3, for k=4 is 6, etc.\n\n This is similar to the coin change problem where coins are triangular numbers and we want to minimize the total value (the k_i) when representing p.\n\n However, note: we are minimizing the total number of nodes (which is the sum of k_i) and the value represented is p (which is the sum of T(k_i)).\n\n But note: we are allowed to use any triangular number (any k_i>=1). The triangular numbers are: 0,1,3,6,10,15,... \n\n We want to minimize the total nodes (sum_i k_i) given that the sum of T(k_i) = p.\n\n However, note: we are not forced to use distinct SCCs; we can use as many as we want. But we cannot exceed the total nodes.\n\n Since the problem constraints are up to 200000, we need an efficient way.\n\n Alternatively, we can consider that the entire graph must have at least as many nodes as the minimal representation.\n\n Another observation: the minimal representation of p as the sum of triangular numbers (with the goal of minimizing the sum of the bases k_i) is achieved by using as few large triangular numbers as possible.\n\n However, we know that the triangular numbers grow quadratically. So we can try to use the largest triangular numbers first.\n\n Steps for part 1:\n\n  Let n_min = minimum total nodes such that there exists a set of integers {k_1, k_2, ..., k_m} (each >=1) with:\n      T(k_1) + T(k_2) + ... + T(k_m) = p\n      and n_min = k_1 + k_2 + ... + k_m.\n\n  But note: the same node cannot be split. And we are allowed to have multiple SCCs (so we can break the graph arbitrarily).\n\n  However, note: the problem also requires that the graph is built with the minimum number of nodes. We are free to design the graph arbitrarily (as long as the SCC structure is as given). \n\n  But the problem also asks for the maximum number of unidirectional pairs in such a graph (with minimum nodes).\n\n  For part 2: Unidirectional pairs.\n\n  Definition: An ordered pair (u, v) (u != v) is unidirectional if there is a path from u to v and no path from v to u.\n\n  Note: In a directed graph, we can count the following:\n\n    Total directed edges? But we are not given edges, we are designing the graph.\n\n  However, note that the graph must be p-reachable, so the mutual reachability condition is fixed by the SCC decomposition.\n\n  We are free to design the edges between the SCCs arbitrarily (as long as the mutual reachability condition holds within the SCCs and the entire graph is built on n_min nodes).\n\n  The total number of ordered pairs (u, v) (with u != v) is n_min * (n_min-1).\n\n  Then, the unidirectional pairs are the ones that are not bidirectional and not absent (i.e., one-way). But note: the definition requires a path from u to v and no path from v to u.\n\n  How do we maximize the number of unidirectional pairs?\n\n  Consider:\n\n    The graph is built from several SCCs. Within an SCC, every node is mutually reachable, so for any two nodes u, v in the same SCC, the pair (u,v) is not unidirectional (because both directions exist). Similarly, for two nodes in different SCCs, we can design the edges arbitrarily (but note: the entire graph must be built so that the SCCs are indeed the strongly connected components).\n\n  Conditions for edges between SCCs:\n\n    We can have edges from one SCC to another, but then we must ensure that if there is a path from u to v (where u is in one SCC and v in another), then there cannot be a path from v to u.\n\n    Typically, we can arrange the SCCs in a total order (like a DAG of SCCs) and then put edges from earlier SCCs to later ones (and then the graph is acyclic). However, we can also have more complex structures.\n\n  But note: the problem does not require the entire graph to be strongly connected. It only requires that the mutual reachability (for the condition p) is achieved by the SCCs.\n\n  However, to maximize the unidirectional pairs, we would like to have as many directed edges as possible that are one-way. But note: we are constrained by the SCC decomposition.\n\n  Important: The definition of unidirectional pairs requires that there is a path (not necessarily a direct edge). \n\n  But note: the entire graph must be built so that the SCCs are as specified. This means that the edges must respect the SCCs: within an SCC, the subgraph must be strongly connected. Between two different SCCs, we can have arbitrary edges as long as the mutual reachability condition (within the SCCs) is preserved.\n\n  However, the mutual reachability condition is already fixed by the SCCs. The key is that the entire graph must have the property that if two nodes are in the same SCC, then they are mutually reachable, and if they are in different SCCs, then they are not mutually reachable.\n\n  Therefore, for two nodes in different SCCs, we cannot have both directions. So we can either have a path from the first SCC to the second, or from the second to the first, or none, but not both.\n\n  How do we count unidirectional pairs?\n\n    Consider two nodes u and v.\n\n    Case 1: u and v in the same SCC -> no unidirectional pair (both directions exist).\n\n    Case 2: u and v in different SCCs.\n\n        If there is a path from u to v and no path from v to u, then (u,v) is unidirectional.\n\n        Similarly, if there is a path from v to u and no path from u to v, then (v,u) is unidirectional.\n\n        But note: the definition is for an ordered pair (u, v). So (u,v) and (v,u) are two distinct ordered pairs.\n\n    Therefore, for two nodes in different SCCs, we can have 0, 1, or 2 unidirectional pairs? Actually, we can have at most two: one for (u->v) and one for (v->u). However, if we have a path from u to v and a path from v to u, then they would be in the same SCC (by definition of SCC). So actually, we cannot have both paths between two different SCCs.\n\n    Therefore, for two different SCCs, say A and B, we can have:\n\n        Option 1: no edges between A and B -> no unidirectional pairs.\n\n        Option 2: edges from A to B (and possibly not vice versa) -> then for every node u in A and v in B, we have a path from u to v (if we design the edges appropriately) and no path from v to u. Then the pairs (u, v) for u in A and v in B are all unidirectional.\n\n        Similarly, we can have edges from B to A (and not vice versa).\n\n        But note: we can also have a mix? Actually, if we have edges from A to B and from B to A, then we would create a path from A to B and from B to A, meaning that any node in A is mutually reachable with any node in B, which would imply that A and B should be in the same SCC. But we assumed they are separate. So we cannot have edges in both directions.\n\n    Therefore, for two different SCCs, we can choose one direction (or none) for the edges.\n\n    Now, to maximize the total number of unidirectional pairs, we want to maximize the number of ordered pairs (u, v) (with u and v in different SCCs) such that there is a path from u to v and not from v to u.\n\n    Since the graph is built on n_min nodes (with the SCC sizes fixed by the representation of p), we can assign the SCCs arbitrarily and then arrange the edges between them.\n\n    How to maximize?\n\n        We can consider the entire graph as a DAG of SCCs (since there are no cycles between SCCs). Then, if we topologically order the SCCs, then we can have edges from an SCC to all the SCCs that come after it (in the topological order) and no edges in the reverse direction.\n\n        Then, for two different SCCs A and B, if A comes before B in the topological order, then every node in A can reach every node in B, and vice versa (from B to A) there is no path.\n\n        Then, the number of unidirectional pairs between A and B is |A| * |B| (for the direction A->B) and 0 for the reverse.\n\n        Similarly, if we have a set of SCCs and we order them arbitrarily, then the total unidirectional pairs is the sum over all pairs of distinct SCCs (A, B) of |A|*|B| if we fix an ordering (say, we only allow edges from left to right) then for every pair (A, B) with A before B, we get |A|*|B| unidirectional pairs (for the direction A->B) and nothing for the reverse.\n\n        But wait: the definition of unidirectional pairs is for (u, v) and we require that there is a path from u to v and no path from v to u. In our arrangement, if we have edges from A to B, then for u in A and v in B, we have a path from u to v (so (u,v) is unidirectional). But for u in B and v in A, we don't have a path (so (u,v) is not unidirectional). However, note: we did not put edges from B to A, so there is no path from B to A. But what about the reverse? The definition requires a path from u to v (for (u,v)) and no path from v to u. For (u in B, v in A): we don't have a path from u to v (since we only have edges from A to B, so from B to A we don't have edges and no path because the DAG is acyclic and we don't have edges from B to A). Therefore, (u in B, v in A) is not unidirectional because there is no path from u to v.\n\n        Therefore, the total unidirectional pairs in this arrangement is the sum_{all ordered pairs (A, B) with A != B and A before B in the topological order} |A|*|B|.\n\n        Alternatively, if we arrange the SCCs arbitrarily, we can choose the topological order arbitrarily. To maximize the sum, we want to maximize the product terms. Notice that the total number of ordered pairs (u, v) (with u and v in different SCCs) is fixed: it is (n_min^2 - n_min) / 2 * 2? Actually, no: the total ordered pairs (u, v) (u != v) is n_min*(n_min-1). Then subtract the pairs that are within the same SCC (which are not unidirectional) and the pairs that are between different SCCs but without a one-way path? \n\n        Actually, the above arrangement (a DAG of SCCs with edges from an SCC to all subsequent SCCs) ensures that for every pair of distinct SCCs, we have exactly one direction (if we choose a linear order). But note: we are allowed to have arbitrary edges (as long as we don't create mutual reachability between two different SCCs). We are not forced to have edges from every node in an SCC to every node in the next SCC. However, to maximize the unidirectional pairs, we want as many (u, v) (with u and v in different SCCs) as possible to have a path from u to v and not from v to u.\n\n        The maximum we can achieve for the entire graph is to have a total order of the SCCs and then have edges from every node in an earlier SCC to every node in a later SCC. Then, for any two nodes u and v in different SCCs, if u is in an earlier SCC than v, then there is a path from u to v (via the edges we designed) and no path from v to u. Similarly, if u is in a later SCC, then there is no path from u to the earlier one. \n\n        Then, the total unidirectional pairs is the sum_{i < j} (size_i * size_j) [for the direction i->j] plus the sum_{j < i} (size_j * size_i) for the direction j->i? Actually, no: because we only have edges from earlier to later, so for a pair (u in i, v in j) with i < j, we have a path from u to v (so (u,v) is unidirectional). For the reverse (v in j, u in i) with i<j, we don't have a path from v to u (so (v,u) is unidirectional only if there was a path from v to u, which we don't have). But wait, the definition requires a path from u to v (for (u,v)) and no path from v to u. In the case (v,u) (with v in j and u in i, and i<j) we have no path from v to u, but we do have a path from u to v? Actually, we have a path from u to v, but the definition for (v,u) requires a path from v to u (which we don't have) and no path from u to v (which we do have). So (v,u) is not unidirectional because there is a path from u to v (which is the reverse direction) but that doesn't matter: the definition is for the specific ordered pair (v,u). However, note the condition for unidirectional is: path from v to u exists? No, we require a path from v to u and no path from u to v for (v,u) to be unidirectional. But we have a path from u to v, so for (v,u) we have no path from v to u and there is a path from u to v (so the condition for (v,u) is: no path from v to u and a path from u to v, which is the reverse). This does not satisfy the condition for (v,u) to be unidirectional (which requires a path from v to u and no path from u to v). \n\n        Therefore, in our arrangement, the only unidirectional pairs are the ones going from an earlier SCC to a later SCC. And note: the pairs going from a later SCC to an earlier SCC are not unidirectional.\n\n        Then, the total unidirectional pairs is the sum_{i < j} (size_i * size_j) [if we order the SCCs arbitrarily, and we choose the order that maximizes the sum?]\n\n        But note: the sum_{i < j} (size_i * size_j) is independent of the order? Actually, no: the sum is the same regardless of the order because it is the square of the total nodes minus the sum of squares of the sizes, divided by 2, but then multiplied by 2? Wait:\n\n            Total ordered pairs (u, v) (u != v) = n_min*(n_min-1)\n\n            This includes:\n                - Pairs within the same SCC: which are not unidirectional (so excluded).\n                - Pairs between different SCCs: which we break down as follows.\n\n            Alternatively, we can compute the total unidirectional pairs as:\n\n                Total_unidirectional = (Total directed edges that are one-way) \n\n            But note: we are not counting edges, but the existence of a path.\n\n            However, in our DAG arrangement, we have a complete directed bipartite graph from an SCC to every SCC that comes after it. Then, for two different SCCs A and B, if A is before B, then every node in A can reach every node in B (so |A|*|B| unidirectional pairs (A->B)). But if we choose a different order, say we reverse the order, then we would have edges from B to A and then the unidirectional pairs would be |B|*|A| for the direction B->A. But note: the set of pairs (u, v) (with u in A and v in B) is the same regardless of the order. However, the direction matters.\n\n            Actually, the total number of unidirectional pairs is fixed by the sizes of the SCCs and the fact that we can only have one direction between two different SCCs. But note: we are allowed to choose which direction to use for each pair of SCCs. However, we cannot use both. \n\n            The maximum total unidirectional pairs is achieved if we use as many directed edges as possible. But note: we are constrained by the requirement that we cannot have mutual reachability between two different SCCs.\n\n            The maximum number of unidirectional pairs is the total number of ordered pairs (u, v) (u != v) that are not within the same SCC, and then we can assign a direction for each such pair arbitrarily? Actually, no: because the graph must form a DAG (to avoid cycles between SCCs) and we cannot have cycles. However, we can have a complete DAG: for every two distinct SCCs, we choose one direction (either from A to B or from B to A). Then, the total unidirectional pairs is the sum_{all pairs (A, B) with A != B} |A|*|B|, because for each ordered pair (u, v) (u in A, v in B) we can choose the direction from A to B, then (u,v) is unidirectional (if we choose A->B) and (v,u) is not (because we didn't choose B->A). But wait: if we choose A->B, then (u,v) is unidirectional and (v,u) is not (because we did not put the reverse edge). Similarly, if we choose B->A, then (v,u) is unidirectional and (u,v) is not.\n\n            However, note: we cannot choose independently for each pair of SCCs. The entire graph must be consistent: if we have a path from A to B and from B to C, then we must have a path from A to C. But if we choose for A->B and B->C, then we can have a path from A to C by going through B. But we are not required to put direct edges, just that the entire graph must be built so that the SCCs are as given.\n\n            Actually, the problem does not require that the graph is a DAG. We can have more complex structures (like multiple edges from one SCC to another) but we must avoid mutual reachability. However, the standard way is to arrange the SCCs as a DAG.\n\n            But note: we are free to design the edges arbitrarily (as long as the SCC decomposition is fixed). The condition for the SCC decomposition is that if two nodes are in the same SCC, they are mutually reachable, and if they are in different SCCs, they are not.\n\n            How to maximize the unidirectional pairs? We want to maximize the total number of ordered pairs (u, v) (u != v) that have a path from u to v and no path from v to u.\n\n            The total number of ordered pairs (u, v) (u != v) is n_min*(n_min-1). Then subtract the pairs that are not unidirectional:\n\n                - Pairs within the same SCC: these are not unidirectional (because both directions exist) -> there are sum_i [size_i*(size_i-1)] such pairs.\n                - Pairs between different SCCs: we can choose the direction arbitrarily, but we cannot have both. However, we are allowed to have no path in one direction and a path in the other? Actually, no: for two different SCCs, we must not have mutual reachability, so we cannot have both directions. But we can choose one direction arbitrarily. However, we can also choose to not have any path in either direction? That would reduce the unidirectional pairs.\n\n            To maximize, we choose for every pair of distinct SCCs (A, B) to have a path from A to B or from B to A (but not both). Then, for each ordered pair (u, v) (u in A, v in B) we get one unidirectional pair (either (u,v) if we choose A->B, or (v,u) if we choose B->A). But note: we are not forced to have edges from every node in A to every node in B. We can have a path from A to B without having direct edges. However, the existence of a path from A to B (for every node in A to every node in B) and the absence of a path from B to A is what we need for (u,v) to be unidirectional (with u in A and v in B). But note: the definition requires a path from u to v (which we can provide by a path through the DAG) and no path from v to u (which we ensure by the DAG ordering). \n\n            However, the problem does not require the entire graph to be a DAG. But we can always arrange the edges to form a DAG (by putting all edges from one SCC to the next in a linear order). Then, we can have a path from an earlier SCC to a later one (without having edges from the later to the earlier). Then, for two different SCCs, we have a path in one direction only (if we arrange the linear order).\n\n            Then, the total unidirectional pairs is the sum_{i<j} (size_i * size_j) [if we choose the direction from i to j] but note: we can also choose the opposite direction. However, the total number of ordered pairs (u, v) (u != v) that are between different SCCs is fixed: it is n_min*(n_min-1) - sum_i (size_i*(size_i-1)).\n\n            And we can assign each unordered pair {u, v} (from two different SCCs) to one of the two directions arbitrarily. But note: if we assign a direction for a single edge (between two SCCs) then we are effectively covering all the pairs between these two SCCs. However, the entire graph must be consistent: if we have a path from A to B and from B to C, then we must have a path from A to C. This forces that if we choose a direction for each edge between two SCCs, the entire graph must be a DAG (with the SCCs as nodes). Then, the maximum total unidirectional pairs is the total number of ordered pairs (u, v) (u != v) that are between different SCCs, because we can assign the direction for each unordered pair of SCCs arbitrarily (but consistently) so that for every pair of distinct SCCs, we have exactly one direction (covering all the pairs between them). Then, the total unidirectional pairs is the entire set of ordered pairs (u, v) (u != v) except those within the same SCC.\n\n            Why? Because for two different SCCs, we can always choose the direction (by arranging the DAG appropriately) so that for every u in the first and v in the second, the pair (u,v) is unidirectional (if we choose the first to the second) and the reverse is not (because we don't have the reverse edge). But note: the definition requires that there is a path from u to v and no path from v to u. In our DAG arrangement, we have a path from u to v (if we choose the direction from the SCC of u to the SCC of v) and no path from v to u (because we don't have edges in the reverse direction and the DAG is acyclic). Therefore, we can make every ordered pair (u, v) (u != v and u, v in different SCCs) unidirectional by choosing the appropriate direction for the entire DAG.\n\n            However, wait: we cannot assign independently for each pair of SCCs. The entire DAG must be acyclic. But note: we are free to choose the topological order arbitrarily. Then, if we fix a total order (linear order) of the SCCs, then for two SCCs A and B, if A comes before B, then we have edges from A to B (so (u in A, v in B) is unidirectional) and (v in B, u in A) is not (because there's no path from B to A). Then, the total unidirectional pairs is the sum_{i < j} (size_i * size_j) [if we order the SCCs arbitrarily]. But note: we can choose the ordering arbitrarily to maximize the sum.\n\n            However, the sum_{i<j} (size_i * size_j) is independent of the ordering? Actually, no: the sum is fixed by the sizes. It is (n_min^2 - sum_i (size_i^2)) / 2.\n\n            But wait: the total number of ordered pairs (u, v) (u != v) is n_min*(n_min-1). Then subtract the pairs that are within the same SCC: that is sum_i (size_i*(size_i-1)). Then, the remaining pairs (between different SCCs) is n_min*(n_min-1) - sum_i (size_i*(size_i-1)) = 2 * (sum_{i<j} (size_i * size_j)).\n\n            Then, the maximum number of unidirectional pairs we can get is the entire set of between-SCCs pairs, because we can assign the DAG so that each between-SCCs pair is covered by exactly one direction (so each ordered pair (u, v) (u != v and u, v in different SCCs) becomes unidirectional). \n\n            However, wait: if we have two SCCs A and B, and we have a linear order (say A then B), then we get |A|*|B| unidirectional pairs (for the direction A->B) and the reverse (B->A) is not present. But note: the reverse direction (B->A) would require a path from B to A, which we don't have. So we only get the |A|*|B| pairs (A->B) and we don't get the |B|*|A| pairs (B->A). Therefore, the total unidirectional pairs is the sum_{all ordered pairs (i, j) with i != j and i<j in the chosen linear order} (size_i * size_j). \n\n            But note: we can choose the linear order arbitrarily. Then, we can choose the order that maximizes the sum. However, the total sum of products for all pairs (i,j) with i<j is fixed (it is half the square of the total nodes minus half the sum of squares). But wait, the expression:\n\n                S = sum_{i<j} (size_i * size_j) \n\n            is independent of the ordering. Therefore, the total unidirectional pairs we can achieve is 2 * S? \n\n            Actually, no: in the entire set of between-SCCs pairs, there are 2*S ordered pairs (because for each unordered pair (A,B) we have two ordered pairs (u in A, v in B) and (u in B, v in A)). But in our DAG arrangement, we only count one of these two. Specifically, if we fix a linear order, then for the unordered pair (A,B) we only count the direction from the earlier to the later (which is one of the two). Therefore, the total unidirectional pairs is S (if we take the linear order) but wait:\n\n                Example: two SCCs A and B, sizes a and b.\n                Then the between-SCCs pairs: \n                    (A,B): a*b pairs (if A is before B) and (B,A): b*a pairs (if B is before A). But we can choose the order. \n\n            However, note: the entire graph must be built with a fixed set of SCCs (sizes fixed). Then, the total between-SCCs pairs is fixed (a*b). And we can choose the direction arbitrarily (by choosing the linear order). Then, we can choose to count either a*b (if we put A before B) or b*a (if we put B before A) but note a*b = b*a. \n\n            But wait, the entire graph has multiple SCCs. The total unidirectional pairs is the sum over all unordered pairs (A,B) of min(a,b) * max(a,b)? No, it's fixed: for each unordered pair (A,B) we have a*b (if we choose the direction from A to B) or b*a (if we choose B to A) but again a*b = b*a. However, the catch is: we are counting the ordered pairs (u,v) (u in A, v in B) and (u in B, v in A). \n\n            Actually, the entire set of between-SCCs pairs is fixed: there are a*b + b*a = 2*a*b pairs. But we can only count one of these two per unordered pair (A,B). And we are allowed to choose which one. However, the DAG must be acyclic and we can choose the linear order arbitrarily. Then, for each unordered pair (A,B) we choose one direction. Then, the total unidirectional pairs is the sum_{all unordered pairs (A,B)} (size_A * size_B) (because we choose one direction and then we get size_A * size_B unidirectional pairs). \n\n            Then, the total unidirectional pairs is S_total = sum_{i<j} (size_i * size_j) [this is the sum over all unordered pairs (A,B)].\n\n            And note: the entire set of between-SCCs ordered pairs is 2 * S_total, but we only get S_total unidirectional pairs (because for each unordered pair (A,B) we get one direction).\n\n            However, wait: the definition counts an ordered pair (u,v). The set of ordered pairs (u,v) that are unidirectional is:\n\n                { (u,v) | u and v in different SCCs and there is a path from u to v and no path from v to u }\n\n            In our DAG arrangement, for a given unordered pair (A,B) (with A and B distinct), we choose one direction (say from A to B). Then, we get:\n\n                All pairs (u in A, v in B) are unidirectional (because there is a path from u to v and no path from v to u) -> that's |A|*|B| pairs.\n\n                And we do not get any pair (u in B, v in A) as unidirectional.\n\n            Therefore, the total unidirectional pairs is the sum_{i<j} (size_i * size_j) (if we define the linear order arbitrarily and then take the sum of the products for the edges from earlier to later). But note: the linear order is arbitrary, so the sum is fixed (it is independent of the order). \n\n            Therefore, the maximum number of unidirectional pairs is:\n\n                U = (n_min^2 - sum_i (size_i^2)) // 2\n\n            Why? Because:\n\n                (sum_i size_i)^2 = n_min^2 = sum_i (size_i^2) + 2 * (sum_{i<j} (size_i * size_j))\n\n                => sum_{i<j} (size_i * size_j) = (n_min^2 - sum_i (size_i^2)) // 2\n\n            Then, the answer for the second part is U.\n\n            However, wait: is that correct? \n\n            Example: p=3, n_min=3 (since the representation is one SCC of size 3: T(3)=3). Then, the graph has one SCC of size 3.\n\n            Then, the between-SCCs pairs: there are no between-SCCs pairs. Then, U = (9 - 9)//2 = 0. Matches the example.\n\n            Example: p=4. The example input includes p=4, output is '5 6'.\n\n            How to represent p=4? \n\n                We need to represent 4 as the sum of triangular numbers.\n\n                Triangular numbers: 0,1,3,6,...\n\n                We can use:\n                  3 (from k=3) and then 1 (from k=2) -> 3+1=4. Then the SCCs are of sizes 3 and 2. Then, n_min=3+2=5.\n\n                Then, the maximum unidirectional pairs is (5^2 - (3^2+2^2))//2 = (25 - (9+4))//2 = (25-13)//2 = 12//2 = 6.\n\n            Therefore, the output for p=4 is \"5 6\".\n\n            Now, how to compute n_min?\n\n            We need to represent p as the sum of triangular",
    "response": "\nTo solve this problem, we need to determine the minimum number of nodes required to create a directed graph that is p-reachable, and among all such graphs with the minimum number of nodes, find the maximum number of unidirectional node pairs.\n\n### Approach\n1. **Problem Analysis**:\n   - **p-Reachable Graph**: A directed graph is p-reachable if it contains exactly `p` ordered pairs `(u, v)` where `u < v` and nodes `u` and `v` are mutually reachable (i.e., they belong to the same strongly connected component (SCC)).\n   - **Unidirectional Pairs**: An ordered pair `(u, v)` is unidirectional if there is a path from `u` to `v` but no path from `v` to `u`.\n\n2. **Key Insight**:\n   - The problem reduces to partitioning the nodes into SCCs such that the sum of combinations of nodes within each SCC (i.e., `C(k_i, 2) = k_i*(k_i-1)/2` for each SCC of size `k_i`) equals `p`. The goal is to minimize the total number of nodes (`n_min`), which is the sum of all `k_i`.\n   - For the second part, the maximum number of unidirectional pairs is derived from the total possible ordered pairs minus those within the same SCC, considering the optimal arrangement of edges between different SCCs.\n\n3. **Algorithm Selection**:\n   - **Finding Minimum Nodes (`n_min`)**: We use dynamic programming or greedy approach to find the minimal sum of node counts (SCC sizes) such that the sum of their triangular numbers equals `p`. The solution involves checking possible SCC sizes (triangular numbers) in descending order to minimize the total nodes.\n   - **Maximizing Unidirectional Pairs**: Once the SCC sizes are determined, the maximum unidirectional pairs is calculated using the formula `(n_min^2 - sum_i(size_i^2)) // 2`, which accounts for all ordered pairs between different SCCs.\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    p = int(sys.stdin.readline().strip())\n    \n    if p == 0:\n        print(\"0 0\")\n        return\n        \n    tri = [0]\n    i = 1\n    while True:\n        t_val = i * (i - 1) // 2\n        if t_val > 200000:\n            break\n        tri.append(t_val)\n        i += 1\n        \n    n = len(tri)\n    dp = [float('inf')] * (p + 1)\n    dp[0] = 0\n    \n    for t_val in tri:\n        for j in range(p, t_val - 1, -1):\n            if dp[j - t_val] != float('inf'):\n                dp[j] = min(dp[j], dp[j - t_val] + int(((t_val * 2 + 1) ** 0.5) + 1) // 1)\n                \n    k = 0\n    remaining = p\n    sizes = []\n    index = len(tri) - 1\n    while remaining > 0:\n        for i in range(index, 0, -1):\n            if tri[i] <= remaining and dp[remaining] == dp[remaining - tri[i]] + 1:\n                k = int(((tri[i] * 2 + 1) ** 0.5) + 1) // 1\n                sizes.append(k)\n                remaining -= tri[i]\n                index = i - 1\n                break\n        else:\n            index -= 1\n            \n    n_min = sum(sizes)\n    total_sq = sum(k*k for k in sizes)\n    unidirectional = (n_min*n_min - total_sq) // 2\n    \n    print(f\"{n_min} {unidirectional}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read as an integer `p`, representing the required number of mutual reachability pairs.\n2. **Special Case Handling**: If `p` is 0, the output is \"0 0\" since no nodes are needed.\n3. **Triangular Numbers Generation**: We generate all triangular numbers up to 200,000 (since `p` can be up to 200,000). Each triangular number corresponds to an SCC size.\n4. **Dynamic Programming Setup**: We initialize a DP array where `dp[j]` stores the minimal number of nodes needed to achieve `j` mutual reachability pairs.\n5. **DP Array Population**: For each triangular number, we update the DP array in reverse to ensure minimal node count for each possible `p`.\n6. **Backtracking for Solution**: After processing all triangular numbers, we backtrack to determine the actual SCC sizes that sum up to `p` with minimal nodes.\n7. **Output Calculation**: The total nodes (`n_min`) is the sum of SCC sizes. The maximum unidirectional pairs is computed using the derived formula, which considers all ordered pairs between different SCCs.\n\nThis approach efficiently finds the minimal node configuration and maximizes unidirectional pairs by leveraging dynamic programming and combinatorial mathematics.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    p = int(sys.stdin.readline().strip())\n    \n    if p == 0:\n        print(\"0 0\")\n        return\n        \n    tri = [0]\n    i = 1\n    while True:\n        t_val = i * (i - 1) // 2\n        if t_val > 200000:\n            break\n        tri.append(t_val)\n        i += 1\n        \n    n = len(tri)\n    dp = [float('inf')] * (p + 1)\n    dp[0] = 0\n    \n    for t_val in tri:\n        for j in range(p, t_val - 1, -1):\n            if dp[j - t_val] != float('inf'):\n                dp[j] = min(dp[j], dp[j - t_val] + int(((t_val * 2 + 1) ** 0.5) + 1) // 1)\n                \n    k = 0\n    remaining = p\n    sizes = []\n    index = len(tri) - 1\n    while remaining > 0:\n        for i in range(index, 0, -1):\n            if tri[i] <= remaining and dp[remaining] == dp[remaining - tri[i]] + 1:\n                k = int(((tri[i] * 2 + 1) ** 0.5) + 1) // 1\n                sizes.append(k)\n                remaining -= tri[i]\n                index = i - 1\n                break\n        else:\n            index -= 1\n            \n    n_min = sum(sizes)\n    total_sq = sum(k*k for k in sizes)\n    unidirectional = (n_min*n_min - total_sq) // 2\n    \n    print(f\"{n_min} {unidirectional}\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 474,
        "completion_token_count": 1110,
        "thoughts_token_count": 8191
    }
}