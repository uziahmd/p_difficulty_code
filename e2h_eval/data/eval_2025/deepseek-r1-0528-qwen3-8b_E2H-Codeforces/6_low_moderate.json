{
    "start": 1758088070.3139343,
    "end": 1758089174.6595056,
    "start-formatted": "2025-09-17 14:47 KST",
    "end-formatted": "2025-09-17 15:06 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\n Okay, we are given n and x (the total desired duration) and then n lines of [l, r, cost]\n Each voucher has duration = r - l + 1.\n\n Conditions:\n We need two distinct vouchers i and j such that:\n   (duration_i + duration_j == x) and the two intervals [li, ri] and [lj, rj] do not intersect (at least one condition: ri < lj or rj < li).\n\n We want the minimal total cost.\n\n Approach:\n\n Since x can be up to 200,000 and the number of vouchers is up to 200,000, we cannot try all pairs.\n\n Idea:\n Let d = duration of a voucher = r-l+1.\n\n We are looking for two durations d1 and d2 such that d1+d2 = x.\n\n Then we need to consider two types of non-overlapping conditions:\n   Condition 1: [l1, r1] and [l2, r2] with r1 < l2 (voucher1 ends before voucher2 starts)\n   Condition 2: [l2, r2] and [l1, r1] with r2 < l1 (voucher2 ends before voucher1 starts)\n\n However, note that the two conditions are symmetric. So without loss of generality, we can consider:\n\n   Case 1: The first voucher ends before the second starts (r1 < l2)\n   Case 2: The second voucher ends before the first starts (r2 < l1)\n\n But note: the problem does not specify which voucher is taken first. However, the condition for non-intersection is symmetric.\n\n Steps:\n\n 1. We can group vouchers by their duration. But note: same duration might appear multiple times, and we have two conditions (order) to consider.\n\n 2. Alternatively, we can precompute for each duration d (which is at most 200000) a list of (l, r, cost) but then we also need to check the non-overlapping condition.\n\n However, note that the condition requires the two vouchers to be disjoint. We are only concerned with the two conditions: one ends before the other begins.\n\n Let's reframe:\n\n For a fixed pair (d1, d2) such that d1+d2=x, we want to find two vouchers with durations d1 and d2 respectively that do not overlap.\n\n How to check non-overlap?\n\n Condition 1: if we take voucher i (duration d1) and voucher j (duration d2), then either:\n   (a) r_i < l_j   OR\n   (b) r_j < l_i\n\n But note: we don't know which one is which. However, we can consider:\n\n   If we fix the first voucher (say the one with duration d1) and then look for a voucher with duration d2 that starts after r_i (condition a) OR ends before the first voucher starts (condition b). But condition b requires that the second voucher ends before the first starts, which would mean the second voucher must end at or below l_i-1 (but wait, the first voucher starts at l_i). \n\n However, note: condition (b) is: the second voucher (with duration d2) must end before the first voucher starts, i.e., r_j < l_i.\n\n But if we fix the first voucher (with duration d1) then the second voucher (with duration d2) must either:\n   - start after the first voucher ends (r_i) OR \n   - end before the first voucher starts (l_i)\n\n Similarly, if we fix the second voucher (with duration d2) then the first voucher must either:\n   - start after the second voucher ends (r_j) OR \n   - end before the second voucher starts (l_j)\n\n But note: the condition is symmetric. So we can consider two cases independently.\n\n However, we are going to consider pairs (d1, d2) and (d2, d1) separately? Actually, no: because in the condition, the order of taking the vacations matters in terms of time, but the non-overlapping condition is independent of the order. But note: the condition is defined without order: \"two vouchers i and j (i≠j) so that they don't intersect\" — meaning the intervals [li, ri] and [lj, rj] don't intersect.\n\n So we don't assign which one is first. But we can still use the two conditions: either the first interval is entirely before the second, or the second is entirely before the first.\n\n How to efficiently check for a fixed d1 and d2?\n\n We can precompute:\n\n   For each duration d, we store the vouchers and then for each voucher we record:\n        l, r, cost\n\n   Then, for a fixed d1 and d2 (with d1+d2=x), we want to find",
    "response": "\nTo solve this problem, we need to find two distinct travel vouchers such that their combined duration equals exactly `x` days, they do not overlap in time, and their total cost is minimized. The solution involves efficiently processing the vouchers and checking for valid pairs without resorting to a brute-force approach, which would be computationally expensive given the constraints.\n\n### Approach\n1. **Group Vouchers by Duration**: We first group all vouchers by their duration. For each duration `d`, we store a list of tuples `(l, r, cost)` representing the start day, end day, and cost of each voucher. This helps in quickly accessing all vouchers of a specific duration later.\n\n2. **Precompute Minimum Costs**: For each duration `d`, we precompute the minimum cost among all vouchers of that duration. Additionally, we maintain a list of vouchers sorted by their start day (or end day) to facilitate efficient range queries.\n\n3. **Check Valid Pairs**: For each possible pair of durations `(d, x - d)`, we check if there exists at least one voucher of duration `d` and one of duration `x - d`. If such vouchers exist, we then verify if they do not overlap. The non-overlapping condition is satisfied if either the first voucher ends before the second starts or vice versa.\n\n4. **Efficient Non-Overlap Check**: To efficiently check for non-overlapping vouchers, we use binary search on the sorted lists of start or end days. For each voucher of duration `d`, we look for a voucher of duration `x - d` that starts after the end of the first voucher (indicating no overlap). Similarly, we check the other way around.\n\n5. **Minimize Total Cost**: For each valid non-overlapping pair found, we compute the sum of their costs and keep track of the minimum such sum encountered during the search.\n\n### Solution Code\n```python\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    data = sys.stdin.read().split()\n    it = iter(data)\n    n = int(next(it))\n    x = int(next(it))\n    vouchers = []\n    for _ in range(n):\n        l = int(next(it))\n        r = int(next(it))\n        cost_val = int(next(it))\n        vouchers.append((l, r, cost_val))\n    \n    max_day = 200000\n    duration_dict = defaultdict(list)\n    for l, r, cost_val in vouchers:\n        dur = r - l + 1\n        duration_dict[dur].append((l, r, cost_val))\n    \n    min_cost_by_duration = {}\n    for dur, lst in duration_dict.items():\n        min_val = float('inf')\n        for tup in lst:\n            if tup[2] < min_val:\n                min_val = tup[2]\n        min_cost_by_duration[dur] = min_val\n    \n    sorted_vouchers = {}\n    for dur, lst in duration_dict.items():\n        sorted_vouchers[dur] = sorted(lst, key=lambda x: x[0])\n    \n    ans = float('inf')\n    found = False\n    \n    for dur1, lst1 in duration_dict.items():\n        dur2 = x - dur1\n        if dur2 not in duration_dict:\n            continue\n        \n        if dur1 == dur2:\n            if len(lst1) < 2:\n                continue\n            for i in range(len(lst1)):\n                l1, r1, c1 = lst1[i]\n                j = bisect.bisect_right(sorted_vouchers[dur2], (r1,)) \n                while j < len(sorted_vouchers[dur2]) and sorted_vouchers[dur2][j][0] <= r1:\n                    j += 1\n                k = bisect.bisect_left(sorted_vouchers[dur2], (r1,))\n                while k < len(sorted_vouchers[dur2]) and sorted_vouchers[dur2][k][0] >= r1:\n                    k -= 1\n                if j < len(sorted_vouchers[dur2]):\n                    cand1 = sorted_vouchers[dur2][j]\n                    if cand1[2] + c1 < ans:\n                        ans = cand1[2] + c1\n                if k >= 0:\n                    cand2 = sorted_vouchers[dur2][k]\n                    if cand2[2] + c1 < ans:\n                        ans = cand2[2] + c1\n            continue\n        \n        lst2 = sorted_vouchers[dur2]\n        for i in range(len(lst1)):\n            l1, r1, c1 = lst1[i]\n            pos = bisect.bisect_right(lst2, (r1, 10**9, 10**9), key=lambda x: x[0])\n            if pos < len(lst2):\n                cand = lst2[pos]\n                if cand[0] > r1:\n                    total_cost = cand[2] + c1\n                    if total_cost < ans:\n                        ans = total_cost\n            else:\n                pass\n        \n        lst1_sorted = sorted_vouchers[dur1]\n        for i in range(len(lst2)):\n            l2, r2, c2 = lst2[i]\n            pos = bisect.bisect_right(lst1_sorted, (r2, 10**9, 10**9), key=lambda x: x[0])\n            if pos < len(lst1_sorted):\n                cand = lst1_sorted[pos]\n                if cand[0] > r2:\n                    total_cost = cand[2] + c2\n                    if total_cost < ans:\n                        ans = total_cost\n    \n    if ans == float('inf'):\n        print(-1)\n    else:\n        print(ans)\n\nif __name__ == '__main__':\n    import bisect\n    main()\n```\n\n### Explanation\n1. **Input Handling**: The input is read and parsed into a list of tuples, each representing a voucher's start day, end day, and cost.\n2. **Grouping by Duration**: Vouchers are grouped by their duration using a dictionary where keys are durations and values are lists of vouchers.\n3. **Minimum Cost Calculation**: For each duration, the minimum cost among all vouchers of that duration is stored to facilitate quick cost checks.\n4. **Sorting Vouchers**: Vouchers are sorted by their start day to enable efficient binary search operations during the non-overlap check.\n5. **Finding Valid Pairs**: For each duration `d`, the code checks if there exists another duration `x - d`. If so, it verifies if vouchers from both durations can be paired without overlapping. The binary search ensures that the check is done efficiently.\n6. **Output Result**: The minimum total cost of valid pairs is printed, or `-1` if no such pair exists.\n\nThis approach efficiently narrows down the search space using grouping and sorting, ensuring optimal performance even for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import defaultdict\n\ndef main():\n    data = sys.stdin.read().split()\n    it = iter(data)\n    n = int(next(it))\n    x = int(next(it))\n    vouchers = []\n    for _ in range(n):\n        l = int(next(it))\n        r = int(next(it))\n        cost_val = int(next(it))\n        vouchers.append((l, r, cost_val))\n    \n    max_day = 200000\n    duration_dict = defaultdict(list)\n    for l, r, cost_val in vouchers:\n        dur = r - l + 1\n        duration_dict[dur].append((l, r, cost_val))\n    \n    min_cost_by_duration = {}\n    for dur, lst in duration_dict.items():\n        min_val = float('inf')\n        for tup in lst:\n            if tup[2] < min_val:\n                min_val = tup[2]\n        min_cost_by_duration[dur] = min_val\n    \n    sorted_vouchers = {}\n    for dur, lst in duration_dict.items():\n        sorted_vouchers[dur] = sorted(lst, key=lambda x: x[0])\n    \n    ans = float('inf')\n    found = False\n    \n    for dur1, lst1 in duration_dict.items():\n        dur2 = x - dur1\n        if dur2 not in duration_dict:\n            continue\n        \n        if dur1 == dur2:\n            if len(lst1) < 2:\n                continue\n            for i in range(len(lst1)):\n                l1, r1, c1 = lst1[i]\n                j = bisect.bisect_right(sorted_vouchers[dur2], (r1,)) \n                while j < len(sorted_vouchers[dur2]) and sorted_vouchers[dur2][j][0] <= r1:\n                    j += 1\n                k = bisect.bisect_left(sorted_vouchers[dur2], (r1,))\n                while k < len(sorted_vouchers[dur2]) and sorted_vouchers[dur2][k][0] >= r1:\n                    k -= 1\n                if j < len(sorted_vouchers[dur2]):\n                    cand1 = sorted_vouchers[dur2][j]\n                    if cand1[2] + c1 < ans:\n                        ans = cand1[2] + c1\n                if k >= 0:\n                    cand2 = sorted_vouchers[dur2][k]\n                    if cand2[2] + c1 < ans:\n                        ans = cand2[2] + c1\n            continue\n        \n        lst2 = sorted_vouchers[dur2]\n        for i in range(len(lst1)):\n            l1, r1, c1 = lst1[i]\n            pos = bisect.bisect_right(lst2, (r1, 10**9, 10**9), key=lambda x: x[0])\n            if pos < len(lst2):\n                cand = lst2[pos]\n                if cand[0] > r1:\n                    total_cost = cand[2] + c1\n                    if total_cost < ans:\n                        ans = total_cost\n            else:\n                pass\n        \n        lst1_sorted = sorted_vouchers[dur1]\n        for i in range(len(lst2)):\n            l2, r2, c2 = lst2[i]\n            pos = bisect.bisect_right(lst1_sorted, (r2, 10**9, 10**9), key=lambda x: x[0])\n            if pos < len(lst1_sorted):\n                cand = lst1_sorted[pos]\n                if cand[0] > r2:\n                    total_cost = cand[2] + c2\n                    if total_cost < ans:\n                        ans = total_cost\n    \n    if ans == float('inf'):\n        print(-1)\n    else:\n        print(ans)\n\nif __name__ == '__main__':\n    import bisect\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 735,
        "completion_token_count": 1438,
        "thoughts_token_count": 1023
    }
}