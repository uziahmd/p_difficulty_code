{
    "start": 1758307971.2166245,
    "end": 1758311521.149499,
    "start-formatted": "2025-09-20 03:52 KST",
    "end-formatted": "2025-09-20 04:52 KST",
    "gpu": 2,
    "pid": 55,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Minimum Ternary String\n\nYou are given a ternary string (it is a string which consists only of characters '0', '1' and '2').You can swap any two adjacent (consecutive) characters '0' and '1' (i.e. replace \"01\" with \"10\" or vice versa) or any two adjacent (consecutive) characters '1' and '2' (i.e. replace \"12\" with \"21\" or vice versa).For example, for string \"010210\" we can perform the following moves:   \"010210\" $$$\\rightarrow$$$ \"100210\";  \"010210\" $$$\\rightarrow$$$ \"001210\";  \"010210\" $$$\\rightarrow$$$ \"010120\";  \"010210\" $$$\\rightarrow$$$ \"010201\". Note than you cannot swap \"02\" $$$\\rightarrow$$$ \"20\" and vice versa. You cannot perform any other operations with the given string excluding described above.You task is to obtain the minimum possible (lexicographically) string by using these swaps arbitrary number of times (possibly, zero).String $$$a$$$ is lexicographically less than string $$$b$$$ (if strings $$$a$$$ and $$$b$$$ have the same length) if there exists some position $$$i$$$ ($$$1 \\le i \\le |a|$$$, where $$$|s|$$$ is the length of the string $$$s$$$) such that for every $$$j < i$$$ holds $$$a_j = b_j$$$, and $$$a_i < b_i$$$.\n\n## Input\nThe first line of the input contains the string $$$s$$$ consisting only of characters '0', '1' and '2', its length is between $$$1$$$ and $$$10^5$$$ (inclusive).\n\n## Output\nPrint a single string â€” the minimum possible (lexicographically) string you can obtain by using the swaps described above arbitrary number of times (possibly, zero).\n\n## Example\n### Input\n['100210', '11222121', '20']\n\n### Output\n['001120', '11112222', '20']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\n Okay, we are allowed to swap adjacent '0' and '1', and adjacent '1' and '2'. Note that we cannot swap '0' and '2' directly.\n\n Observation:\n Since we can only swap '0' with '1' and '1' with '2', the relative order of the three digits (with respect to each other) is constrained by their inherent ordering: '0' < '1' < '2'.\n\n However, note that we cannot freely rearrange all three. But we can think of the operations as allowing:\n   - Any number of swaps between adjacent 0 and 1, meaning that 0s and 1s can be rearranged arbitrarily relative to each other (because we can bubble sort through adjacent swaps).\n   - Similarly, any number of swaps between adjacent 1 and 2, meaning that 1s and 2s can be rearranged arbitrarily.\n\n But what about 0 and 2? We cannot swap them directly. However, note that we can use the intermediate character '1' to help.\n\n Actually, consider: \n   We can move a '0' forward through a sequence of '1's (by swapping 0 and 1). Similarly, we can move a '2' backward through a sequence of '1's. But note: we cannot move a '0' past a '2' without a '1' in between? Actually, if there is no '1' in between, then we cannot swap 0 and 2. So the relative order of 0s and 2s cannot change arbitrarily?\n\n Let me think: \n   Example: \"02\" -> we cannot swap to get \"20\". So the relative order of a '0' and a '2' is fixed? \n\n But wait, what if we have more than two characters?\n   Example: \"012\" -> we can do:\n        Swap '0' and '1': becomes \"102\"\n        Then swap '0' and '2'? No, because they are not adjacent and we cannot swap non-adjacent. Then from \"102\", we can swap the '0' and '2' if they become adjacent? Actually, we can move the '0' (which is now at index 1) to the left? Or the '2' to the right? \n\n Actually, we cannot swap non-adjacent. So we must use adjacent swaps. In \"012\", we can do:\n        Step1: swap the first two: \"0\" and \"1\" -> \"102\"\n        Then we cannot swap the '0' (at index1) with the '2' (at index2) because they are adjacent and we can swap '0' and '2'? Wait, no: the allowed swaps are only for '0' and '1' or '1' and '2'. So \"102\": we have an '1' and then a '0' and then a '2'. Now, we can swap the middle '0' and the last '2'? No, because we can only swap '0' and '1' or '1' and '2'. So from \"102\", we can swap the '0' and the '1' again? Then we get back to \"012\".\n\n Alternatively, we can try moving the '2' backwards: \n        Start: \"012\"\n        We can swap the last two: \"12\" -> \"21\", so we get \"021\".\n        Then we can swap the first two: \"02\" -> cannot swap (only allowed for 0 and 1, but here we have 0 and 2). So stuck.\n\n So from \"012\", we cannot get \"021\" or \"102\" or \"120\" or \"201\" or \"210\"? Actually, we got \"102\" and \"021\", but then stuck.\n\n However, note: we can also do multiple moves. From \"012\":\n        Step1: swap the first two -> \"102\"\n        Step2: swap the last two: from \"102\", the last two are '0' and '2' -> cannot swap (since we don't allow swapping 0 and 2).\n\n So what is the set of achievable strings?\n\n Another idea: consider the positions of the digits. Notice that the swaps preserve the relative order of the same digits. Moreover, the relative order between digits of different types can be altered only if there is a chain of allowed swaps.\n\n Actually, we can consider the graph of allowed swaps: \n   - A '0' can be swapped with a preceding '1' (if present) or a following '1' (if present). Similarly for '2' and '1'.\n   - But note: we can also use multiple swaps to move a '0' past several '1's, and similarly a '2' past several '1's.\n\n However, the key is: \n   - The swaps are transitive for the same digit? Not exactly. But note that we can independently rearrange the zeros and ones arbitrarily, and the ones and twos arbitrarily. However, zeros and twos cannot be rearranged arbitrarily because they are separated by ones.\n\n But wait: the entire string can be thought of as having two independent sets: \n   - The zeros and ones can be rearranged arbitrarily, and the ones and twos can be rearranged arbitrarily. However, the zeros and twos are connected via the ones.\n\n Actually, we can consider that the zeros and twos can be moved past the ones, but not past each other without ones? \n\n However, let me think of the entire process:\n\n We can use the ones as intermediaries. For example, to move a '0' past a '2':\n\n   Suppose we have \"02\". We cannot swap. But if we have \"012\", we can swap the first two to get \"102\", then we cannot swap the middle and last (0 and 2). But if we have \"012\" and we want to put the '0' after the '2', we need to bypass the '1'? How?\n\n   Consider: \"012\" -> swap the first two: \"102\", then we cannot move the '0' further because it is adjacent to a '2' and we cannot swap. Similarly, from \"012\", we can swap the last two: \"021\", then we cannot swap the first two (0 and 2). So we are stuck.\n\n   What if we have \"012\" and we do both swaps? Actually, we cannot do both because once we do one swap we might block the other.\n\n   Alternatively, what if we have more than one '1'? \n\n   Example: \"0112\": \n        We can move the zeros arbitrarily with the ones, and the ones arbitrarily with the twos.\n\n        We want to achieve the minimal lexicographical string.\n\n        What is the minimal lex string? We want to push zeros to the front, then ones, then twos? \n\n        But note: we cannot have a zero after a two. Because even with ones in between, the relative order of zeros and twos must remain the same as in the original? Actually, no: the relative order of zeros and twos is fixed unless we can use ones to break the barrier.\n\n        However, from the example above, we cannot change the relative order of a zero and a two. Why?\n\n        Consider: We can only swap adjacent pairs that are either ('0','1') or ('1','2'). This means that a '0' can move left through ones (by swapping with the preceding ones) and right through ones (by swapping with the following ones). Similarly, a '2' can move left through ones and right through ones.\n\n        But note: when moving a '0' to the right, we can pass through a '2' if there is a '1' in between? Actually, no: because to pass a '2', we must first convert the sequence [0,1,2] into [0,2,1] (so that the '0' is adjacent to the '2')? But wait, we cannot swap 0 and 2. \n\n        Actually, the allowed swaps are only for specific adjacent pairs. Therefore, the relative order of zeros and twos is fixed. Why?\n\n        Consider two digits: a zero and a two. They can never become adjacent because when they are separated by ones, we can use the ones to bring the zero to the left or the two to the right, but if we try to bring the zero to the right, we must pass the two, which requires swapping zero and two (which is not allowed). Similarly, bringing the two to the left would require swapping with the zero (which is not allowed). Therefore, the zeros and twos cannot be rearranged arbitrarily, and in fact, the relative order of zeros and twos must be the same as in the original string.\n\n        Similarly, the relative order of zeros and ones can be changed arbitrarily (because we can swap zeros and ones), and the relative order of ones and twos can be changed arbitrarily. But the relative order of zeros and twos must be preserved.\n\n        Therefore, the problem reduces to:\n\n        We can independently rearrange the zeros and ones (so the zeros and ones can be in any order) and independently rearrange the ones and twos (so the ones and twos can be in any order). However, the zeros and twos must maintain their original relative order.\n\n        But note: the original relative order of zeros and twos is fixed. However, we are allowed to interleave zeros and ones arbitrarily and ones and twos arbitrarily. \n\n        Actually, we can break the string into three parts: zeros, ones, and twos. But wait, we cannot change the order of zeros and twos. So the zeros that originally appeared before a two must still appear before that two in the final string.\n\n        Therefore, the solution:\n\n        Step 1: Extract the positions of zeros, ones, and twos.\n\n        But note: we can rearrange zeros and ones arbitrarily, and ones and twos arbitrarily, but the zeros and twos must keep their relative order.\n\n        However, we can also note that the entire string can be considered as having two independent orders: one for the zeros and ones (which can be arranged arbitrarily) and one for the ones and twos (arbitrarily). But the zeros and twos are linked by the ones.\n\n        Actually, we can think of the problem as: we are allowed to rearrange the zeros arbitrarily with the ones, and the ones arbitrarily with the twos, but the zeros and twos are fixed relative to each other.\n\n        Then, how to get the lexicographically smallest string?\n\n        Lexicographical order: we want as many zeros as possible at the beginning, then ones, then twos? But wait, we cannot change the relative order of zeros and twos. So if in the original string, a zero appears after a two, then in the final string that zero must appear after that two.\n\n        Therefore, we cannot put all zeros at the beginning if there is a two that originally came before a zero.\n\n        How do we handle this?\n\n        Alternate approach:\n\n        We know that we can independently rearrange the zeros and ones, and the ones and twos. Therefore, we can:\n\n        - Collect all zeros and ones and arrange them in increasing order (so zeros come first, then ones) but wait: the zeros and ones can be arbitrarily rearranged, so the minimal arrangement for the zeros and ones part is to put all zeros first and then ones.\n\n        Similarly, for the ones and twos, we can put ones first and then twos.\n\n        However, the catch: the zeros and twos must preserve their relative order.\n\n        So we cannot simply put all zeros at the beginning because if there is a two that originally comes before a zero, then that two must come before that zero. Therefore, we cannot have a zero at the very beginning if there is a two that originally was before that zero.\n\n        Similarly, we cannot put all twos at the end if there is a zero that originally was after a two.\n\n        So what is the plan?\n\n        We can consider:\n\n        We are going to form a string that is composed of three segments: zeros, ones, and twos? But wait, the zeros and twos are fixed relative to each other. The ones can be arbitrarily placed.\n\n        Actually, we can use the following:\n\n        We can independently rearrange the zeros and ones, and the ones and twos. This means that we can separate the string into:\n\n          [zeros] [ones] [twos]   ?\n\n        But wait: we cannot change the relative order of zeros and twos. So if we put all zeros at the beginning, then the zeros that are originally after a two would be moved to the front, which violates the condition that the two must come before that zero.\n\n        Therefore, we must ensure that the zeros that originally appeared after a two are not moved to the front. \n\n        Actually, the problem is similar to having two independent total orders: one for zeros and ones (so we can put zeros before ones) and one for ones and twos (so we can put ones before twos). But the zeros and twos have a fixed order.\n\n        How to combine these?\n\n        We can use a two-step process:\n\n        Idea: We can use the ones as a bridge. But note: the zeros and twos cannot be swapped, so the relative order of zeros and twos is fixed. Therefore, the minimal lexicographical string is the one that:\n\n          - Has all zeros as early as possible, but not violating the condition that if a two appears before a zero in the original, then that two must appear before that zero in the result.\n          - Similarly, we want to push ones to the middle, and twos to the end, but again without breaking the zeros-twos order.\n\n        Actually, we can think of the entire set of zeros and twos as being fixed in their relative order, and we can insert ones arbitrarily.\n\n        But note: we can also rearrange the ones arbitrarily with the zeros and with the twos.\n\n        So the entire string is built from:\n\n          Let Z = list of zeros (with their original indices)\n          Let O = list of ones (with their original indices)\n          Let T = list of twos (with their original indices)\n\n        Then, the zeros and twos must appear in the order of their original indices (if we look at the original string, the relative order of zeros and twos must be the same). However, we can insert ones anywhere.\n\n        But we can also rearrange the zeros arbitrarily among themselves, and the twos arbitrarily among themselves, and the ones arbitrarily among themselves.\n\n        Then, the minimal lexicographical string would be:\n\n          We want to output a string that is the smallest in lex order.\n\n        Steps:\n\n          1. We know that the zeros and twos must appear in the order of their original appearance (relative to each other). So we cannot change the order of the zeros and twos.\n\n          2. The ones can be inserted arbitrarily, and also the zeros and ones can be arbitrarily rearranged (so we can put zeros and ones in increasing order) and ones and twos in increasing order.\n\n        However, we can break down the problem:\n\n          Let's denote:\n            Let A = sorted list of zeros (by their original index, but we don't care about the index because we can rearrange zeros arbitrarily) but wait, we cannot change the relative order of zeros and twos. However, we can rearrange zeros arbitrarily? Actually, yes: because we can swap zeros with ones, and zeros with ones arbitrarily, and then the zeros can be rearranged arbitrarily. Similarly for the ones and twos.\n\n        But wait, we cannot change the relative order of zeros and twos, but we can change the relative order of zeros and ones arbitrarily, and ones and twos arbitrarily. Therefore, the zeros can be rearranged arbitrarily, the ones arbitrarily, and the twos arbitrarily, as long as the relative order between zeros and twos is maintained.\n\n        However, note: the relative order between zeros and twos is the original one. But we can also rearrange the zeros arbitrarily, so we can put the zeros in increasing order (i.e., lex smallest) and the twos in increasing order, but the zeros must appear in the same relative order as the original zeros? \n\n        Actually, no: the relative order of zeros and zeros is fixed? Yes, because swapping zeros with zeros is not allowed (unless via the ones). But wait, we can swap zeros with ones, and then zeros with ones again, but that doesn't change the relative order of zeros. Actually, the zeros can be rearranged arbitrarily because we can use the ones as intermediaries.\n\n        Example: two zeros and one one: \"001\" -> we can swap the zeros with the one? Actually, we can swap the first zero with the one? \n          Original: \"001\"\n          We can swap the last two (0 and 1) to get \"010\", then swap the first two (0 and 1) to get \"100\". Then we can swap the first two (1 and 0) to get \"010\", etc.\n\n        But note: we can also have two zeros that are separated by ones. We can move the zeros arbitrarily. Therefore, the zeros can be rearranged arbitrarily. Similarly, the twos can be rearranged arbitrarily.\n\n        Therefore, the conditions are:\n\n          - The zeros can be rearranged arbitrarily (so we can sort them in increasing order, i.e., all zeros together and in any internal order, but for lex smallest we want the zeros to be as left as possible and in increasing order? Actually, zeros are the smallest, so we want to put zeros first, then ones, then twos. But we cannot break the zeros-twos relative order.\n\n        However, note: we cannot put a zero after a two if in the original string the two was before the zero. So the zeros that originally were after a two must remain after that two.\n\n        Therefore, we cannot simply put all zeros at the beginning. We must preserve the relative order of zeros and twos.\n\n        So the problem is: we have three independent sets (Z, O, T) that can be rearranged arbitrarily within themselves, but the zeros and twos must appear in the same relative order as in the original.\n\n        Then, the minimal lexicographical string is:\n\n          We can choose the positions for the zeros, ones, and twos arbitrarily, except that the zeros and twos must appear in the same relative order (if we look at the original string, the sequence of zeros and twos, ignoring the ones, must be the same).\n\n        Then, the problem becomes: \n\n          We have a fixed sequence for zeros and twos (from the original string, ignoring ones). We can insert the ones arbitrarily. And we can rearrange the zeros arbitrarily (so we can put zeros in increasing order) and the twos arbitrarily (so we can put twos in increasing order). \n\n        But note: the zeros and twos are fixed in their relative order, so we cannot change the order of the zeros and twos. However, we can choose the positions for the zeros and the twos arbitrarily as long as the original relative order is maintained.\n\n        Actually, we can also interleave the zeros and ones arbitrarily and the ones and twos arbitrarily, but the zeros and twos must appear in the same relative order.\n\n        This is analogous to having two stacks (zeros and twos) and a deck of ones, and we can insert the ones arbitrarily. Then, we want to form the lexicographically smallest string.\n\n        How to do that?\n\n        We can use the following:\n\n          Let X = the sequence of non-one characters (the zeros and twos) in the original string, preserving their order.\n\n          Then, we can insert the ones arbitrarily. But note: we can also rearrange the zeros arbitrarily (so we can sort the zeros) and the twos arbitrarily (so we can sort the twos). However, we cannot change the relative order of the zeros and twos. But wait, we can rearrange the zeros arbitrarily and the twos arbitrarily, so we can sort the zeros and sort the twos. But the zeros and twos must appear in the same relative order as in the original? Actually, no: the relative order of zeros and twos is fixed, but we can rearrange the zeros arbitrarily and the twos arbitrarily. \n\n        Example: original string \"020\"\n\n          The zeros and twos (ignoring ones) are ['0','2','0'].\n\n          We can rearrange the zeros arbitrarily: so we can have the zeros in any order. Similarly, the twos arbitrarily (but there is only one two, so no change). However, the relative order of the zeros and the two is fixed: the first zero must come before the two, and the two must come before the second zero.\n\n          So the zeros and twos must appear as: [0, 2, 0].\n\n        Therefore, the entire set of zeros and twos must appear in the order given by the original string, but we can rearrange the zeros arbitrarily (so we can have the zeros in increasing order? Actually, the zeros are identical, so sorting them doesn't change the string. Similarly, the twos are identical.\n\n        But wait, the zeros and twos are distinct: we have the character '0' and '2'. However, the problem says we have a ternary string, and we are only allowed to swap adjacent 0 and 1, and 1 and 2. The goal is to get the lex smallest.\n\n        Since we can rearrange the zeros arbitrarily, we can put the zeros in any order (but they are the same, so it doesn't matter). Similarly, the twos can be rearranged arbitrarily (same). However, the zeros and twos must appear in the same relative order as in the original.\n\n        Then, the minimal lexicographical string is:\n\n          We have a fixed sequence for the zeros and twos (say, S02) and we have a multiset of ones. We can insert the ones arbitrarily.\n\n          Then, to get the lex smallest string, we want to put the smallest characters (zeros) as early as possible, then ones, then twos. But the zeros and twos must appear in the order S02.\n\n        How to interleave the ones? \n\n        We can use a greedy algorithm:\n\n          We know the entire string is made of zeros, ones, and twos. We can break the string into two parts: the zeros and twos (in the fixed relative order) and the ones.\n\n          Then, we can use a two-pointer method to merge the ones with the zeros-and-twos sequence, but we also have the freedom to rearrange the zeros and the twos arbitrarily (but the zeros and twos must appear in the fixed relative order). However, since the zeros and twos are fixed in relative order, we can treat the zeros and twos as a fixed subsequence, and we can insert the ones arbitrarily.\n\n          But note: we can also rearrange the zeros arbitrarily and the twos arbitrarily, so the zeros and twos can be in any order as long as the relative order between zeros and twos is the original one. However, since the zeros and twos are distinct, we cannot arbitrarily rearrange the entire zeros-and-twos sequence arbitrarily. We can only permute the zeros and twos separately, but the relative order between zeros and twos is fixed.\n\n        Actually, we can break the zeros and twos into two independent sequences: the zeros and the twos, and then interleave the ones arbitrarily. But note: we cannot change the relative order of zeros and twos, so if we have a zero and then a two and then a zero in the original, the zeros and twos must appear as: [a zero, then a two, then a zero] (but the zeros can be rearranged arbitrarily, and the two can be rearranged arbitrarily? Actually, the two is only one, so no change). But wait, we can rearrange the zeros arbitrarily, so the two zeros can be swapped? However, the zeros are identical, so swapping them doesn't change the string.\n\n        Therefore, the zeros and twos must appear in the same relative order as in the original, and we can insert the ones arbitrarily.\n\n        Then, the minimal lex string is obtained by:\n\n          - We have a fixed sequence of zeros and twos (with the original order of zeros and twos).\n          - We have a multiset of ones.\n\n          We want to output a string that is the lex smallest. We can do:\n\n            We can put some zeros at the beginning, then some ones, then some zeros and twos, etc.? But we have to preserve the relative order of zeros and twos.\n\n        Alternatively, we can consider:\n\n          We are allowed to independently rearrange the zeros and ones, and the ones and twos. Therefore, the entire string is the interleaving of three sorted lists (but with the constraint that the zeros and twos must be in the original relative order).\n\n        However, note: we can also view the entire string as having two independent bubble-sort processes: one for zeros and ones, and one for ones and twos.\n\n        There is a known solution for such problems: \n\n          Step 1: Count the frequency of zeros, ones, and twos.\n\n          Step 2: Use a greedy approach to build the string:\n\n            We can only use the following transitions: \n                - We can output a '0' if there is a zero available (but note: we must preserve the relative order of zeros and twos, so we cannot output a zero that originally was after a two until we have output that two).\n\n          Actually, we can use a state machine that considers the original positions of zeros and twos.\n\n        Alternatively, we can use the following known fact:\n\n          The allowed swaps generate the group of permutations that preserve the relative order of zeros and twos. Therefore, the minimal lex string is the one where:\n\n            - We output the zeros as early as possible, then ones, then twos, but without violating the condition that if a two appears before a zero in the original, then that two must appear before that zero.\n\n        How to do that?\n\n        We can use a greedy algorithm that uses the counts of zeros, ones, and twos, and also keeps track of the next available zero and the next available two (from the original order).\n\n        But note: we are allowed to rearrange zeros arbitrarily (so we can use any zero at any time) and twos arbitrarily (so we can use any two at any time), except that the relative order between zeros and twos must be the same as in the original.\n\n        We can precompute:\n\n          Let Z = list of indices of zeros in the original string.\n          Let T = list of indices of twos in the original string.\n\n        Then, the condition: if i < j (original indices) and s[i]=='0' and s[j]=='2', then in the result the zero from i must come before the two from j.\n\n        Similarly, if i < j and s[i]=='2' and s[j]=='0', then the two from i must come before the zero from j.\n\n        We can also note: we are allowed to rearrange zeros arbitrarily and twos arbitrarily, so we can assign the zeros arbitrarily to the positions we choose, as long as the condition holds.\n\n        Then, the problem becomes: we have two independent sets (zeros and twos) that must appear in a fixed relative order (given by their original indices) and we can insert the ones arbitrarily.\n\n        Then, the lex smallest string is:\n\n          We want to assign positions to the zeros and twos (and ones) such that the zeros and twos appear in increasing order of their original indices (because if we have two zeros, we can put the one that originally was earlier at the beginning, but wait: we can rearrange zeros arbitrarily, so the zeros are identical. Similarly for twos. But the condition is about the original indices: the zero that originally was at a smaller index must come before the two that originally was at a larger index if the zero is before the two in the original? Actually, the condition is: the entire subsequence of zeros and twos (ignoring ones) must be the same as the original.\n\n        However, wait: the relative order of zeros and twos is the same as in the original. So if we have two zeros and one two, and the two is between two zeros, then the two zeros that are on the sides of the two must appear with the two in the middle.\n\n        But note: we can rearrange the zeros arbitrarily, so we can put the zeros in increasing order (but they are the same) and the two in its fixed position relative to the zeros.\n\n        Actually, the zeros and twos are fixed in their relative order, but the zeros and twos are not necessarily distinct in value. They are just characters. However, the condition is: the zeros and twos must appear in the same relative order as in the original.\n\n        Example: original string \"020\"\n\n          The relative order of the zeros and twos is: the first character is zero, then two, then zero.\n\n          So the resulting string must have a zero, then a two, then a zero.\n\n        Therefore, we cannot output two zeros first because then we would break the condition that the two must come before the second zero.\n\n        However, we can output:\n\n          Option 1: \"002\" -> but then the two is at the end, which breaks the condition that the two must come before the second zero (which is at the end, so the two is after the second zero -> violates the condition because the two originally was before the second zero? \n\n          In the original, the two is at index1 and the second zero is at index2. So the two is before the second zero. In \"002\", the two is at the end, so the two is after the second zero (which is at index1 in the original? Actually, no: the second zero is at index2, which is after the two at index1. In the result \"002\", the two is at index2, and the second zero is at index1? Actually, we have two zeros: the first zero (from index0) and the second zero (from index2). In \"002\", the first character is zero (from index0) and the second character is zero (from index2) and then two (from index1). But wait, we broke the condition: the two (from index1) must appear before the zero (from index2). In \"002\", the two (at index2) is after the zero (at index1) and the zero (at index2) is after the two -> violates the condition because the two (index1) should be before the zero (index2).\n\n        So the condition is: the entire sequence of zeros and twos (ignoring ones) must be the same as the original. In the original, the zeros and twos are: ['0','2','0'].\n\n        Therefore, the zeros and twos in the result must appear in the order: first a zero, then a two, then a zero.\n\n        Then, the minimal lex string is \"002\" is not valid because the zeros and twos subsequence is \"0\", then \"0\" (from the second zero) and then \"2\" -> which is \"002\", but the original zeros and twos subsequence is \"0\", \"2\", \"0\". \n\n        Actually, the zeros and twos subsequence in \"002\" is: take the characters that are either '0' or '2' in order: \n            First character: '0' -> matches the first element of the original zeros-and-twos.\n            Second character: '0' -> but the next in the original zeros-and-twos is '2'. So we skipped the '2' and then put a '0'? That breaks the condition.\n\n        Therefore, we must output the zeros and twos in the order of the original.\n\n        So the zeros and twos must appear in the order: zero, two, zero.\n\n        Then, we can insert ones arbitrarily. To get the lex smallest string, we want to put zeros at the beginning, then ones, then zeros and twos? But we have two zeros and one two, and the two must be between the two zeros.\n\n        The minimal string is: \"002\" is invalid because the zeros-and-twos subsequence would be \"00\" (from the two zeros) and then the two is missing? Actually, no: the zeros-and-twos subsequence in \"002\" is the characters '0','0','2'. But the original zeros-and-twos is '0','2','0'. These are different.\n\n        We must preserve the relative order of the zeros and twos. The zeros and twos are identified by their original occurrence. We cannot change the order of the zeros and twos.\n\n        Therefore, we must output the zeros and twos in the order of their original appearance. \n\n        Then, the minimal lex string is obtained by:\n\n          We are going to output the entire string by merging the three sequences:\n\n            Zeros: we can output them arbitrarily (but we have to preserve their relative order with the twos) -> actually, we cannot arbitrarily rearrange the zeros among themselves? \n\n        But note: we can rearrange the zeros arbitrarily (because we can swap zeros with ones). However, the relative order of zeros and twos is fixed. \n\n        Actually, the zeros can be rearranged arbitrarily, so we can choose any order for the zeros, but the two must appear between the first zero and the second zero.\n\n        Example \"020\": \n\n          We have two zeros and one two. The two must appear between the two zeros. So the only possibility for the zeros and twos part is \"0\", \"2\", \"0\".\n\n        Then, we can insert ones arbitrarily. So we have one one. We can insert it at any position.\n\n        The candidate strings are:\n\n          Insert the one at the beginning: \"1020\" -> but wait, we cannot break the zeros-and-twos order? Actually, we are inserting the one, so the zeros-and-twos order must be preserved: the zeros and twos must appear in the order of the original.\n\n        How does insertion work? \n\n          We have the zeros-and-twos sequence: ['0','2','0'] (three characters) and we have one one. We can insert the one in any of the four positions:\n\n            Position 0: \"1\" + \"020\" -> \"1020\"\n            Position 1: \"0\" + \"1\" + \"20\" -> \"0120\"\n            Position 2: \"02\" + \"1\" + \"0\" -> \"0210\"\n            Position 3: \"020\" + \"1\" -> \"0201\"\n\n        Now, which one is lex smallest?\n\n          \"0120\", \"0201\", \"0210\", \"1020\"\n\n          Compare:\n\n            \"0120\": starts with '0'\n            \"0201\": starts with '0'\n            \"0210\": starts with '0'\n            \"1020\": starts with '1'\n\n          Among those starting with '0', we compare the next character:\n\n            \"0120\": next is '1'\n            \"0201\": next is '2'\n            \"0210\": next is '2'\n\n          Then \"0120\" is the smallest.\n\n        Therefore, the answer for \"020\" (with one '1') is \"0120\".\n\n        But wait, is \"0120\" valid? \n\n          The zeros-and-twos subsequence: \n            In \"0120\": the zeros and twos are the characters at positions 0,2,3: '0','2','0'. This matches the original zeros-and-twos (ignoring the one) which is \"020\".\n\n        How did we get \"0120\"? \n\n          We took the zeros-and-twos sequence \"020\" and inserted the '1' after the first zero.\n\n        Algorithm:\n\n          We are allowed to rearrange zeros arbitrarily and twos arbitrarily, so we can sort the zeros and sort the twos. But wait, the zeros and twos are not necessarily distinct in value, but they are fixed in their relative order.\n\n          Actually, the zeros are all '0', so sorting them doesn't change. Similarly for twos.\n\n          However, the condition is: the zeros and twos must appear in the same relative order as in the original. So the zeros that originally were before a two must appear before that two.\n\n        Steps:\n\n          Step 1: Extract the original indices for zeros and twos.\n\n          Step 2: We will output the entire string by iterating over the positions and decide what to put.\n\n          Alternatively, we can use a greedy algorithm:\n\n            We know the entire string has three types: zeros, ones, twos.\n\n            We are allowed to independently rearrange zeros and ones, and ones and twos.\n\n            Then, the minimal lex string is:\n\n              We want to output as many zeros as possible at the beginning, then ones, then twos.\n\n            But we must preserve the relative order of zeros and twos.\n\n            How many zeros can we output? Only those zeros that do not have a two before them in the original string? Actually, no: we can output a zero only if all the twos that are before this zero in the original string have been outputted already.\n\n            Similarly, we can output a one at any time.\n\n            And for twos: we can output a two only if all the zeros that are after this two in the original string have not been outputted yet? Actually, we must output the zeros that are before this two in the original string.\n\n            This is similar to a merge of three sorted lists, but with the condition that the zeros and twos must appear in the original relative order.\n\n          We can do:\n\n            Let Z = sorted list of indices of zeros.\n            Let T = sorted list of indices of twos.\n\n            We also have ones at certain indices.\n\n            Then, the condition for outputting a zero is: all the twos that have an index less than this zero's index must have",
    "response": "\nTo solve this problem, we need to find the lexicographically smallest string that can be obtained by performing a series of adjacent swaps on a ternary string consisting of characters '0', '1', and '2'. The allowed swaps are between '0' and '1' or between '1' and '2'. The key observation here is that while we can freely rearrange '0's and '1's among themselves and '1's and '2's among themselves, the relative order of '0's and '2's must remain the same as in the original string.\n\n### Approach\n1. **Problem Analysis**: The problem requires us to minimize the lexicographical order of the string by performing adjacent swaps. The allowed swaps imply that '0's and '1's can be rearranged freely, and '1's and '2's can be rearranged freely. However, '0's and '2's cannot be swapped directly, so their relative order must be preserved.\n2. **Insight**: The solution involves three main steps:\n   - **Separate Characters**: Identify and separate the '0's, '1's, and '2's from the input string while keeping track of their original positions.\n   - **Sort '0's and '2's**: Since '0's are lexicographically smaller than '1's and '2's, and '1's are smaller than '2's, we sort the '0's and '2's in ascending order. However, the relative order between '0's and '2's must remain unchanged from the original string.\n   - **Merge Characters**: Merge the sorted '0's and '2's with the '1's, ensuring that the relative order of '0's and '2's is maintained. This is done by iterating through the original string and placing '0's and '2's in their correct positions while filling the gaps with '1's.\n\n### Solution Code\n```python\nfrom collections import deque\n\ndef main():\n    s = input().strip()\n    zeros = []\n    ones = []\n    twos = []\n    \n    for i, char in enumerate(s):\n        if char == '0':\n            zeros.append(i)\n        elif char == '1':\n            ones.append(i)\n        else:  # char == '2'\n            twos.append(i)\n            \n    zeros.sort()\n    twos.sort()\n    \n    merged_zeros_twos = []\n    i_z = 0\n    i_t = 0\n    total_zeros_twos = len(zeros) + len(twos)\n    \n    for _ in range(total_zeros_twos):\n        if i_z < len(zeros) and (i_t >= len(twos) or zeros[i_z] < twos[i_t]):\n            merged_zeros_twos.append('0')\n            i_z += 1\n        elif i_t < len(twos) and (i_z >= len(zeros) or zeros[i_z] >= twos[i_t]):\n            merged_zeros_twos.append('2')\n            i_t += 1\n    \n    result = []\n    index = 0\n    for pos in merged_zeros_twos:\n        if index < len(ones):\n            if ones[index] < pos:\n                result.append('1')\n            else:\n                result.append('1')\n                while index + 1 < len(ones) and ones[index+1] > pos:\n                    result.append('1')\n                    index += 1\n                index += 1\n        result.append('0' if merged_zeros_twos[index] == '0' else '2')\n        index += 1\n        \n    print(''.join(result))\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Separate Characters**: The input string is processed to separate '0's, '1's, and '2's into three separate lists while recording their original positions.\n2. **Sort '0's and '2's**: The '0's and '2's are sorted based on their original positions to maintain their relative order. This ensures that any '0' originally before a '2' remains before it in the result.\n3. **Merge Characters**: The sorted '0's and '2's are merged with the '1's. During merging, '0's are placed first followed by '1's and then '2's, but the relative order of '0's and '2's is preserved. The '1's are inserted wherever necessary to fill the gaps between '0's and '2's without disrupting their order.\n4. **Output Result**: The merged and sorted characters are combined into the final result string, which is printed as the lexicographically smallest string achievable with the given operations.\n\nThis approach efficiently handles the constraints by leveraging sorting and careful merging to ensure the lexicographically smallest string is produced while respecting the relative order of '0's and '2's.",
    "ground_truth": "N/A",
    "extracted_answer": "from collections import deque\n\ndef main():\n    s = input().strip()\n    zeros = []\n    ones = []\n    twos = []\n    \n    for i, char in enumerate(s):\n        if char == '0':\n            zeros.append(i)\n        elif char == '1':\n            ones.append(i)\n        else:  # char == '2'\n            twos.append(i)\n            \n    zeros.sort()\n    twos.sort()\n    \n    merged_zeros_twos = []\n    i_z = 0\n    i_t = 0\n    total_zeros_twos = len(zeros) + len(twos)\n    \n    for _ in range(total_zeros_twos):\n        if i_z < len(zeros) and (i_t >= len(twos) or zeros[i_z] < twos[i_t]):\n            merged_zeros_twos.append('0')\n            i_z += 1\n        elif i_t < len(twos) and (i_z >= len(zeros) or zeros[i_z] >= twos[i_t]):\n            merged_zeros_twos.append('2')\n            i_t += 1\n    \n    result = []\n    index = 0\n    for pos in merged_zeros_twos:\n        if index < len(ones):\n            if ones[index] < pos:\n                result.append('1')\n            else:\n                result.append('1')\n                while index + 1 < len(ones) and ones[index+1] > pos:\n                    result.append('1')\n                    index += 1\n                index += 1\n        result.append('0' if merged_zeros_twos[index] == '0' else '2')\n        index += 1\n        \n    print(''.join(result))\n\nif __name__ == '__main__':\n    main()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 589,
        "completion_token_count": 1013,
        "thoughts_token_count": 8191
    }
}