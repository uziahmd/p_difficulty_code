{
    "start": 1758088066.3659616,
    "end": 1758089083.3337798,
    "start-formatted": "2025-09-17 14:47 KST",
    "end-formatted": "2025-09-17 15:04 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\n Okay, we are given: n, x and then n lines of (l, r, cost)\n Conditions:\n  - We need two distinct vouchers i and j such that they do not intersect (either r_i < l_j or r_j < l_i).\n  - The sum of their durations is exactly x. Note: duration = r - l + 1.\n\n Steps:\n\n Let's denote:\n   d_i = r_i - l_i + 1\n\n Then we require: d_i + d_j = x.\n\n Additionally, the two vouchers must not overlap.\n\n Approach:\n\n Since n, x, and the day values can be up to 200,000, we cannot try all pairs.\n\n Idea:\n\n 1. Group the vouchers by their duration. But note: two vouchers with the same duration might have different intervals.\n\n However, note: we require the two vouchers to be non-overlapping. So even if two vouchers have durations that sum to x, we must check that they don't overlap.\n\n Alternative:\n\n We can precompute for each voucher the duration and then consider only pairs (i, j) such that d_i + d_j = x.\n\n But then how to quickly find a pair (i, j) that satisfies the non-overlapping condition?\n\n Another idea: iterate over one voucher and then look for another that has duration = x - d_i and then check non-overlapping? But we have two conditions (non-overlapping) and we need to minimize cost.\n\n How to check non-overlapping? Condition: either r_i < l_j OR r_j < l_i.\n\n But note: the two vouchers are independent. However, we are free to choose the order? Actually, the condition is symmetric. But when we fix the first voucher, the second must be non-overlapping.\n\n However, we cannot simply check every voucher with duration d_j = x - d_i because there might be many.\n\n We need an efficient way.\n\n Steps:\n\n 1. Precompute the list of vouchers and group by duration? Actually, we can create a dictionary mapping from duration to a list of (l, r, cost).\n\n 2. But then, for a fixed voucher i (with duration d_i), we need to look at all vouchers j with duration d_j = x - d_i. Then check if (voucher i and voucher j) do not overlap.\n\n However, the total number of vouchers is up to 200,000 and the number of distinct durations might be up to 200,000 as well (since days are in [1,200000]), so we cannot iterate over every voucher for each voucher.\n\n Instead, we can:\n\n  - Precompute a mapping from duration to a list of intervals (each interval is (l, r, cost)).\n  - Then, for each duration d, we can also sort the intervals by something? \n\n But note: the non-overlapping condition with a fixed voucher i (which has [l_i, r_i]) and a candidate voucher j (with duration d_j = x-d_i) requires that either:\n      r_i < l_j   OR   r_j < l_i\n\n However, since we are going to consider both orders (because the two vouchers are unordered) we can break the problem into two parts:\n\n  Option 1: The first voucher ends before the second starts (r_i < l_j).\n  Option 2: The second voucher ends before the first starts (r_j < l_i).\n\n But note: the condition is symmetric, so we can assume without loss of generality that we are going to consider the first voucher and then the second one must start after the first ends OR the second voucher must end before the first starts.\n\n However, we can also consider storing two separate structures: one for intervals that end early and one for intervals that start late? Or we can store intervals by their starting and ending points.\n\n Alternatively, we can consider:\n\n  For each duration d, we can store two sorted lists (or maybe one sorted list by l and one by r) of the intervals with that duration? But note: the condition involves both l and r.\n\n Let me think: \n\n  We want to find a voucher j (with duration d_j = x-d_i) such that either:\n      Condition 1: r_i < l_j   (then the first voucher ends before the second starts)\n      Condition 2: r_j < l_i   (then the second voucher ends before the first starts)\n\n But note: we are considering two distinct vouchers. \n\n How about we preprocess all vouchers by their duration and then by their endpoints? We can do:\n\n  Let's create:\n    - A dictionary `by_duration` that maps duration d to a list of (l, r, cost) for that duration.\n    - Also, we can create two arrays (or dictionaries) for the entire set of vouchers:\n\n        For each duration d, we want to quickly query:\n          Option 1:",
    "response": "\nTo solve this problem, we need to find two distinct travel vouchers such that their combined duration equals exactly `x` days, they do not overlap in time, and their total cost is minimized. The solution involves efficiently processing the vouchers to check these conditions without resorting to a brute-force approach, which would be computationally expensive given the constraints.\n\n### Approach\n1. **Group Vouchers by Duration**: First, we group all vouchers by their duration (i.e., `r_i - l_i + 1`). This allows us to quickly access all vouchers that contribute to a specific part of the required total duration `x`.\n\n2. **Check for Valid Pairs**: For each voucher with duration `d`, we look for another voucher with duration `x - d`. We then check if these two vouchers do not overlap in their time intervals. The non-overlapping condition is satisfied if either the first voucher ends before the second starts (`r_i < l_j`) or the second voucher ends before the first starts (`r_j < l_i`).\n\n3. **Efficient Lookup Using Sorted Intervals**: For each duration, we maintain two sorted lists: one sorted by the start day (`l`) and another by the end day (`r`). This allows us to efficiently query for vouchers that start after a certain day or end before a certain day, ensuring the non-overlapping condition is met.\n\n4. **Minimize Cost**: For each valid pair found, we keep track of the minimum total cost. If no such pair exists, we return `-1`.\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        print(-1)\n        return\n        \n    it = iter(data)\n    n = int(next(it)); x = int(next(it))\n    vouchers = []\n    for _ in range(n):\n        l = int(next(it)); r = int(next(it)); cost = int(next(it))\n        vouchers.append((l, r, cost))\n        \n    by_duration = {}\n    for (l, r, cost) in vouchers:\n        d = r - l + 1\n        if d not in by_duration:\n            by_duration[d] = []\n        by_duration[d].append((l, r, cost))\n        \n    for d in by_duration:\n        if d == x - d:\n            lst = by_duration[d]\n            lst.sort(key=lambda x: (x[0], x[1]))\n            if len(lst) < 2:\n                continue\n            i = 0\n            j = 1\n            min_cost = float('inf')\n            while i < len(lst):\n                if j >= len(lst):\n                    j = i + 1\n                    while j < len(lst) and lst[j][0] <= lst[i][1]:\n                        j += 1\n                    if j >= len(lst):\n                        break\n                if lst[j][0] > lst[i][1]:\n                    total_cost = lst[i][2] + lst[j][2]\n                    if total_cost < min_cost:\n                        min_cost = total_cost\n                    i += 1\n                    j = i + 1\n                else:\n                    j += 1\n            if min_cost != float('inf'):\n                print(int(min_cost))\n                return\n        else:\n            d1 = d\n            d2 = x - d\n            if d2 not in by_duration:\n                continue\n            list1 = by_duration[d1]\n            list2 = by_duration[d2]\n            \n            list1.sort(key=lambda x: x[0])\n            list2.sort(key=lambda x: x[1])\n            \n            min_total = float('inf')\n            for (l1, r1, c1) in list1:\n                if r1 < list2[0][0]:\n                    total_cost = c1 + list2[0][2]\n                    if total_cost < min_total:\n                        min_total = total_cost\n                elif l1 > list2[-1][1]:\n                    total_cost = c1 + list2[-1][2]\n                    if total_cost < min_total:\n                        min_total = total_cost\n                else:\n                    pos_start = bisect.bisect_left(list2, (l1, 0, 0), key=lambda x: x[0])\n                    if pos_start < len(list2):\n                        cand1 = list2[pos_start]\n                        total_cost = c1 + cand1[2]\n                        if total_cost < min_total:\n                            min_total = total_cost\n                    pos_end = bisect.bisect_right(list2, (float('inf'), r1, 0), key=lambda x: x[1]) - 1\n                    if pos_end >= 0:\n                        cand2 = list2[pos_end]\n                        total_cost = c1 + cand2[2]\n                        if total_cost < min_total:\n                            min_total = total_cost\n            if min_total != float('inf'):\n                print(int(min_total))\n                return\n                \n    print(-1)\n\nfrom bisect import bisect_left, bisect_right\n\ndef bisect_key_view(a, key, lo=0, hi=None, *, key_index=0):\n    pass\n\nbisect.bisect_left = lambda a, x, lo=0, hi=len(a): bisect_left(a, x, lo, hi)\nbisect.bisect_right = lambda a, x, lo=0, hi=len(a): bisect_right(a, x, lo, hi)\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into a list of vouchers, each characterized by its start day, end day, and cost.\n2. **Grouping by Duration**: Vouchers are grouped by their duration into a dictionary where each key is a duration, and the value is a list of tuples representing the voucher details.\n3. **Checking Valid Pairs**: For each duration `d`, the code checks if there exists another duration `x - d` in the dictionary. If so, it proceeds to find pairs of vouchers from both groups that do not overlap.\n4. **Efficient Lookup**: Using binary search (via `bisect`), the code efficiently finds vouchers in the second group that start after the end of a voucher from the first group or end before the start of a voucher from the first group. This ensures the non-overlapping condition is met.\n5. **Minimizing Cost**: For each valid pair found, the total cost is compared to the current minimum, updating the minimum if a lower cost is found. If no valid pair is found after all checks, the code outputs `-1`.\n\nThis approach efficiently narrows down the search space using grouping and binary search, ensuring optimal performance even for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        print(-1)\n        return\n        \n    it = iter(data)\n    n = int(next(it)); x = int(next(it))\n    vouchers = []\n    for _ in range(n):\n        l = int(next(it)); r = int(next(it)); cost = int(next(it))\n        vouchers.append((l, r, cost))\n        \n    by_duration = {}\n    for (l, r, cost) in vouchers:\n        d = r - l + 1\n        if d not in by_duration:\n            by_duration[d] = []\n        by_duration[d].append((l, r, cost))\n        \n    for d in by_duration:\n        if d == x - d:\n            lst = by_duration[d]\n            lst.sort(key=lambda x: (x[0], x[1]))\n            if len(lst) < 2:\n                continue\n            i = 0\n            j = 1\n            min_cost = float('inf')\n            while i < len(lst):\n                if j >= len(lst):\n                    j = i + 1\n                    while j < len(lst) and lst[j][0] <= lst[i][1]:\n                        j += 1\n                    if j >= len(lst):\n                        break\n                if lst[j][0] > lst[i][1]:\n                    total_cost = lst[i][2] + lst[j][2]\n                    if total_cost < min_cost:\n                        min_cost = total_cost\n                    i += 1\n                    j = i + 1\n                else:\n                    j += 1\n            if min_cost != float('inf'):\n                print(int(min_cost))\n                return\n        else:\n            d1 = d\n            d2 = x - d\n            if d2 not in by_duration:\n                continue\n            list1 = by_duration[d1]\n            list2 = by_duration[d2]\n            \n            list1.sort(key=lambda x: x[0])\n            list2.sort(key=lambda x: x[1])\n            \n            min_total = float('inf')\n            for (l1, r1, c1) in list1:\n                if r1 < list2[0][0]:\n                    total_cost = c1 + list2[0][2]\n                    if total_cost < min_total:\n                        min_total = total_cost\n                elif l1 > list2[-1][1]:\n                    total_cost = c1 + list2[-1][2]\n                    if total_cost < min_total:\n                        min_total = total_cost\n                else:\n                    pos_start = bisect.bisect_left(list2, (l1, 0, 0), key=lambda x: x[0])\n                    if pos_start < len(list2):\n                        cand1 = list2[pos_start]\n                        total_cost = c1 + cand1[2]\n                        if total_cost < min_total:\n                            min_total = total_cost\n                    pos_end = bisect.bisect_right(list2, (float('inf'), r1, 0), key=lambda x: x[1]) - 1\n                    if pos_end >= 0:\n                        cand2 = list2[pos_end]\n                        total_cost = c1 + cand2[2]\n                        if total_cost < min_total:\n                            min_total = total_cost\n            if min_total != float('inf'):\n                print(int(min_total))\n                return\n                \n    print(-1)\n\nfrom bisect import bisect_left, bisect_right\n\ndef bisect_key_view(a, key, lo=0, hi=None, *, key_index=0):\n    pass\n\nbisect.bisect_left = lambda a, x, lo=0, hi=len(a): bisect_left(a, x, lo, hi)\nbisect.bisect_right = lambda a, x, lo=0, hi=len(a): bisect_right(a, x, lo, hi)",
    "score": 0,
    "metadata": {
        "prompt_token_count": 726,
        "completion_token_count": 1398,
        "thoughts_token_count": 1023
    }
}