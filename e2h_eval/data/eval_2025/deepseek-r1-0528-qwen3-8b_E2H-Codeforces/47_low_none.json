{
    "start": 1758296410.0509424,
    "end": 1758298993.0265214,
    "start-formatted": "2025-09-20 00:40 KST",
    "end-formatted": "2025-09-20 01:23 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\n Okay, we are given two integers a and b (1 <= a, b <= 10^9). We are to find a non-negative integer k such that the LCM of (a+k) and (b+k) is minimized, and if there are multiple k with the same minimal LCM, choose the smallest k.\n\n Let d = (a+k) and e = (b+k). Then note that d - e = a - b (constant). Without loss of generality, assume a >= b. Then we can let g = gcd(a+k, b+k). Then note that g must divide (a-b). Also, we have:\n   LCM(a+k, b+k) = (a+k)*(b+k) / g\n\n But note: (a+k) = (b+k) + (a-b). So the difference between the two numbers is fixed (a-b). However, we can also consider symmetry: if a < b, then we can swap the roles.\n\n Alternatively, we can set x = k, and note that the two numbers are (a+x) and (b+x). The LCM of two numbers is (n1 * n2) / GCD(n1, n2). Therefore, we want to minimize (a+x)*(b+x) / GCD(a+x, b+x).\n\n But note: GCD(a+x, b+x) = GCD(a+x, (a+x)-(b+x)) = GCD(a+x, a-b). Similarly, if we assume a>=b, then GCD(a+x, a-b) divides (a-b). So the gcd must be a divisor of |a-b|.\n\n Approach:\n Let d = |a-b|. If d==0, then a==b, then we are looking for k such that LCM(2a+k) but actually the two numbers are the same: (a+k) and (a+k). Then LCM is (a+k)^2. We want to minimize (a+k)^2. The minimum is at k=0.\n\n But note: when d==0, then the problem becomes trivial: k=0.\n\n For d != 0, note that the gcd of (a+k) and (b+k) is the same as the gcd of (a+k) and d (if we take absolute value). Actually, without loss of generality, we can assume d = a-b (if a>=b, else we can consider absolute value, but we need to be cautious).\n\n Steps:\n\n 1. Without loss of generality, let d = abs(a-b). But note: the gcd condition: GCD(a+k, b+k) = GCD(a+k, a-b) [if a>=b] or GCD(a+k, b-a) [if a<b]. Actually, we can say: GCD(a+k, b+k) = GCD(a+k, a-b) if a>=b? Not exactly: \n        GCD(a+k, b+k) = GCD(a+k, (a+k) - (b+k)) = GCD(a+k, a-b)\n\n But note: if a < b, then we can write:\n        GCD(a+k, b+k) = GCD(b+k, b-a)   [because GCD(x,y)=GCD(y,x) and GCD(x,y)=GCD(x, y-x) with y-x positive if we assume b>a]\n\n So in general, we can define:\n        base = abs(a-b)\n\n Then the gcd of (a+k) and (b+k) is the same as the gcd of (a+k) and base (if a>=b) or the gcd of (b+k) and base (if a<b). However, note that the expression (a+k) and base: the gcd must divide base. Therefore, the possible values for the gcd are the divisors of base.\n\n But note: we are free to choose k. We want to minimize LCM(a+k, b+k) = (a+k)*(b+k) / g, where g = GCD(a+k, b+k). \n\n However, note that (a+k)*(b+k) = (k^2 + (a+b)*k + a*b). But the denominator g is not independent of k.\n\n Alternate approach:\n\n We know that g divides base. Therefore, we can iterate over all divisors of base (which are finite, because base has at most around 1344 divisors for numbers up to 10^9). Then, for each divisor g, we can try to find k such that GCD(a+k, base) = g (or more precisely, the gcd is a multiple of g? Actually, no: the gcd must be at least g and divisible by g? Actually, we require that g divides (a+k) and also g divides base. But note: the gcd is the greatest common divisor. However, we are allowed",
    "response": "\nTo solve this problem, we need to find a non-negative integer \\( k \\) such that the least common multiple (LCM) of \\( a + k \\) and \\( b + k \\) is minimized. If multiple values of \\( k \\) yield the same minimal LCM, we should choose the smallest \\( k \\).\n\n### Approach\n1. **Problem Analysis**: The key observation here is that the difference between \\( a + k \\) and \\( b + k \\) is constant (\\( |a - b| \\)). The greatest common divisor (GCD) of \\( a + k \\) and \\( b + k \\) must divide this constant difference. Therefore, the GCD can only be one of the divisors of \\( |a - b| \\).\n\n2. **Insight**: For each divisor \\( d \\) of \\( |a - b| \\), we can determine the smallest \\( k \\) such that \\( \\text{GCD}(a + k, b + k) = d \\). The LCM can then be computed using the formula \\( \\text{LCM}(x, y) = \\frac{x \\times y}{\\text{GCD}(x, y)} \\). \n\n3. **Algorithm Selection**: \n   - **Step 1**: If \\( a = b \\), the answer is trivially \\( k = 0 \\).\n   - **Step 2**: For \\( a \\neq b \\), compute all divisors of \\( |a - b| \\).\n   - **Step 3**: For each divisor \\( d \\), compute the smallest \\( k \\) such that \\( d \\) divides both \\( a + k \\) and \\( b + k \\). This involves solving linear congruences.\n   - **Step 4**: Among all candidate \\( k \\) values derived from the divisors, select the one that minimizes the LCM. If multiple \\( k \\) values yield the same minimal LCM, choose the smallest \\( k \\).\n\n4. **Complexity Analysis**: The number of divisors of \\( |a - b| \\) is \\( O(\\sqrt{n}) \\), where \\( n \\) is \\( |a - b| \\). Since \\( n \\) can be up to \\( 10^9 \\), the maximum number of divisors is around 1344 (for highly composite numbers), making this approach efficient.\n\n### Solution Code\n```python\nimport math\nfrom math import gcd as math_gcd\n\ndef main():\n    data = input().split()\n    a = int(data[0])\n    b = int(data[1])\n    \n    if a == b:\n        print(0)\n        return\n        \n    base = abs(a - b)\n    divisors = set()\n    i = 1\n    while i * i <= base:\n        if base % i == 0:\n            divisors.add(i)\n            divisors.add(base // i)\n        i += 1\n        \n    candidate_k = []\n    for d in divisors:\n        if d == 0:\n            continue\n        if a % d == b % d:\n            k0 = (-a) % d\n            candidate_k.append(k0)\n        else:\n            x = (-a) % d\n            y = (-b) % d\n            if x != y:\n                continue\n            else:\n                k0 = x\n                candidate_k.append(k0)\n                \n    candidate_k.append(0)\n    best_k = None\n    best_lcm = None\n    \n    for k in candidate_k:\n        if k < 0:\n            continue\n        num1 = a + k\n        num2 = b + k\n        g = math_gcd(num1, num2)\n        current_lcm = (num1 * num2) // g\n        if best_lcm is None or current_lcm < best_lcm or (current_lcm == best_lcm and k < best_k):\n            best_lcm = current_lcm\n            best_k = k\n            \n    print(best_k)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Input Handling**: The program reads two integers \\( a \\) and \\( b \\) from standard input.\n2. **Special Case Handling**: If \\( a \\) equals \\( b \\), the solution is immediately \\( k = 0 \\) because the LCM of two identical numbers is minimized at \\( k = 0 \\).\n3. **Divisor Calculation**: The program calculates all divisors of \\( |a - b| \\) by iterating up to the square root of \\( |a - b| \\).\n4. **Candidate Generation**: For each divisor \\( d \\), the program checks if there exists a \\( k \\) such that \\( d \\) divides both \\( a + k \\) and \\( b + k \\). This is done using modular arithmetic to find the smallest non-negative \\( k \\).\n5. **Optimal \\( k \\) Selection**: The program evaluates each candidate \\( k \\) by computing the corresponding LCM. The smallest \\( k \\) yielding the minimal LCM is selected and printed.\n\nThis approach efficiently narrows down the problem to checking divisors of the absolute difference between \\( a \\) and \\( b \\), ensuring optimal performance even for large values.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\nfrom math import gcd as math_gcd\n\ndef main():\n    data = input().split()\n    a = int(data[0])\n    b = int(data[1])\n    \n    if a == b:\n        print(0)\n        return\n        \n    base = abs(a - b)\n    divisors = set()\n    i = 1\n    while i * i <= base:\n        if base % i == 0:\n            divisors.add(i)\n            divisors.add(base // i)\n        i += 1\n        \n    candidate_k = []\n    for d in divisors:\n        if d == 0:\n            continue\n        if a % d == b % d:\n            k0 = (-a) % d\n            candidate_k.append(k0)\n        else:\n            x = (-a) % d\n            y = (-b) % d\n            if x != y:\n                continue\n            else:\n                k0 = x\n                candidate_k.append(k0)\n                \n    candidate_k.append(0)\n    best_k = None\n    best_lcm = None\n    \n    for k in candidate_k:\n        if k < 0:\n            continue\n        num1 = a + k\n        num2 = b + k\n        g = math_gcd(num1, num2)\n        current_lcm = (num1 * num2) // g\n        if best_lcm is None or current_lcm < best_lcm or (current_lcm == best_lcm and k < best_k):\n            best_lcm = current_lcm\n            best_k = k\n            \n    print(best_k)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 388,
        "completion_token_count": 1111,
        "thoughts_token_count": 1023
    }
}