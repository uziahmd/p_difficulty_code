{
    "start": 1758307915.0649018,
    "end": 1758311478.228257,
    "start-formatted": "2025-09-20 03:51 KST",
    "end-formatted": "2025-09-20 04:51 KST",
    "gpu": 2,
    "pid": 55,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Minimum Ternary String\n\nYou are given a ternary string (it is a string which consists only of characters '0', '1' and '2').You can swap any two adjacent (consecutive) characters '0' and '1' (i.e. replace \"01\" with \"10\" or vice versa) or any two adjacent (consecutive) characters '1' and '2' (i.e. replace \"12\" with \"21\" or vice versa).For example, for string \"010210\" we can perform the following moves:   \"010210\" $$$\\rightarrow$$$ \"100210\";  \"010210\" $$$\\rightarrow$$$ \"001210\";  \"010210\" $$$\\rightarrow$$$ \"010120\";  \"010210\" $$$\\rightarrow$$$ \"010201\". Note than you cannot swap \"02\" $$$\\rightarrow$$$ \"20\" and vice versa. You cannot perform any other operations with the given string excluding described above.You task is to obtain the minimum possible (lexicographically) string by using these swaps arbitrary number of times (possibly, zero).String $$$a$$$ is lexicographically less than string $$$b$$$ (if strings $$$a$$$ and $$$b$$$ have the same length) if there exists some position $$$i$$$ ($$$1 \\le i \\le |a|$$$, where $$$|s|$$$ is the length of the string $$$s$$$) such that for every $$$j < i$$$ holds $$$a_j = b_j$$$, and $$$a_i < b_i$$$.\n\n## Input\nThe first line of the input contains the string $$$s$$$ consisting only of characters '0', '1' and '2', its length is between $$$1$$$ and $$$10^5$$$ (inclusive).\n\n## Output\nPrint a single string â€” the minimum possible (lexicographically) string you can obtain by using the swaps described above arbitrary number of times (possibly, zero).\n\n## Example\n### Input\n['100210', '11222121', '20']\n\n### Output\n['001120', '11112222', '20']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\n Okay, we are allowed to swap adjacent '0' and '1', and adjacent '1' and '2'. Note that we cannot swap '0' and '2' directly.\n\n Observation:\n Since we can only swap '0' with '1' and '1' with '2', the relative order of the three digits (if we consider their natural order) is constrained. However, note that we can effectively move the digits arbitrarily as long as we respect the following:\n\n - A '0' can be moved leftwards arbitrarily (because we can swap it with '1's and then the '1's can be swapped with the '2's if needed? Actually, note: \n   - We can only swap '0' and '1' (so 0 can pass through 1s but not 2s), and swap '1' and '2' (so 1 can pass through 2s). \n\n Therefore, we can think of the swaps as allowing the following movements:\n\n - '0' can only move to the left, because when we have a '0' followed by a '1', we can swap to put the '1' first and then the '0' can continue to move left if there are more ones to the left? Actually, wait: we can also move a '0' to the right if there is a '1' to the right? But note: swapping adjacent '0' and '1' allows us to move a '0' to the right only if we swap the '0' and '1' (so \"01\" becomes \"10\", meaning the '0' moves one step to the right). Similarly, we can move a '0' to the left by swapping with a '1' to the left? Actually, if we have \"10\", we can swap to get \"01\", so the '0' moves to the left. \n\n Similarly for '2': we can swap with an adjacent '1' to the left or right. But note, we cannot swap '0' and '2'. \n\n However, we can use the '1's as intermediaries. For example, to move a '0' past a '2', we must first convert the '2' into a '1' (if possible) or vice versa? Actually, we cannot directly. But note: we can move the '2' to the left until it hits a '1'? Then we can swap the '2' and the '1' (which is allowed) and then move the '2' further left? Actually, let's break down:\n\n Consider: We want to move a '0' to the left through a '2'. The problem is that we cannot swap '0' and '2'. But we can use the '1's in between.\n\n Example: \n   Start: \"02\"\n   We cannot swap. So stuck.\n\n   But if we have: \"012\"\n   We can swap the '1' and '2': \"021\"\n   Then we cannot swap the '0' and '2'. So we cannot get \"012\" to become \"012\" (it's already the same) or \"021\" (we did one swap). But what if we try to move the '0'?\n\n   Alternatively, from \"012\":\n     First, swap '0' and '1' -> \"102\"\n     Then swap '0' and the next (which is now '2')? But wait, we cannot swap '0' and '2'. So we cannot move the '0' from the middle to the right.\n\n   However, note: we can move the '0' to the left only if there is a '1' to the left. Similarly, we can move a '2' to the left through '1's.\n\n Alternate Insight:\n\n The allowed swaps are transitive in the sense of connectivity? Actually, we can model the problem as having two types of swaps: between '0' and '1', and between '1' and '2'. This is similar to having two independent bubble sort processes (one for 0-1 and one for 1-2) but note that the presence of '1' allows the other two to bypass each other (via the intermediary).\n\n In fact, we can note that:\n\n - The relative order of the three distinct digits is fixed by their numeric values? Not exactly, because we can change the positions arbitrarily as long as we don't break the constraints.\n\n However, note: \n   - The relative order of two zeros remains the same, two ones, two twos, but zeros and ones can be rearranged arbitrarily (like bubble sort) and similarly ones and twos arbitrarily? But zeros and twos cannot be arbitrarily rearranged because they are separated by the ones.\n\n Actually, we can use the following:\n\n Consider that we can independently arrange the zeros and the ones arbitrarily (as if they form a two-element set: 0 and 1) and the ones and twos arbitrarily (as if they form a two-element set: 1 and 2). However, the ones are shared. \n\n Another approach: Think of the entire string as being composed of three layers (from smallest to largest): 0, 1, 2. But 0 and 2 are separated by 1. \n\n How about we note that:\n\n - A '0' can only be moved to the left (because to the right you can only swap with 1, which would move the 0 to the right? Actually, no: swapping adjacent 0 and 1: if you have \"a0b1c\", then swapping gives \"a1b0c\". So the 0 moves to the right. Similarly, if you have \"a1b0c\", you can swap to get \"a0b1c\", so the 0 moves to the left. Therefore, we can move a 0 arbitrarily leftward by swapping with ones to the left, and arbitrarily rightward by swapping with ones to the right? \n\n But wait: to move a 0 to the right, we need a 1 to the right. Similarly, to move a 0 to the left, we need a 1 to the left.\n\n Similarly, a '2' can be moved arbitrarily leftward by swapping with ones to the left, and arbitrarily rightward by swapping with ones to the right? Actually, for moving a 2 to the left: we can swap with a 1 (if there is a 1 to the left) and then the 2 moves left. To move a 2 to the right, we can swap with a 1 to the right.\n\n However, the problem is that we cannot swap 0 and 2. So the movement of 0 and 2 are independent except that they both use the 1's as intermediaries.\n\n But note: we can also move the 1's arbitrarily with respect to 0 and 2 (because 1 can swap with 0 and with 2). \n\n Actually, we can completely separate the zeros and twos by moving all the ones to one side? \n\n However, we want the lexicographically minimum string.\n\n Lexicographical order: '0' < '1' < '2'\n\n So ideally, we want as many zeros as possible to the front, then ones, then twos.\n\n But note: we can only swap adjacent 0 and 1, and 1 and 2. \n\n Let's consider what we can do:\n\n We can independently sort the zeros and ones, and the ones and twos. But note that the ones are common. \n\n Actually, we can use the following strategy:\n\n Step 1: We can move all zeros to the far left. How? \n   - We can move a zero to the left as long as there are ones to the left? Actually, we can also move zeros to the right (by swapping with ones to the right) and then use ones to move the zeros further? \n\n But wait: to move a zero to the left, we swap with ones. But we cannot move a zero to the right beyond a one? Actually, we can: swapping a zero and a one to the right moves the zero one step to the right. Then if we swap again with the next character (if it is a one) we can move the zero further. But if we have a two, we cannot swap the zero and two. So the zeros can pass through the ones but not the twos.\n\n Similarly, the twos can pass through the ones but not the zeros.\n\n So the zeros can only be placed to the left of the twos (if we ignore the ones). And the ones can be anywhere.\n\n Therefore, the final string should have all zeros at the beginning, then all ones, then all twos? \n\n But wait, consider: \n   We cannot swap a zero and a two. So if we have a two that originally is to the left of a zero, we cannot swap them. However, we can use ones to separate them.\n\n Example: \"20\"\n   Input: \"20\" -> Output: \"20\"\n\n Why? Because we cannot swap the '2' and the '0'. So we cannot move the '0' to the left of the '2'. \n\n Similarly, if we have \"02\", we can swap to get \"02\" (no swap because adjacent is 0 and 2, which is not allowed) OR wait: the example input says:\n   Input: ['100210', '11222121', '20'] -> Output: ['001120', '11112222', '20']\n\n So for \"20\", we cannot change it.\n\n Therefore, the idea is:\n\n We can separate the string into three parts: zeros, ones, and twos. But note: the zeros and twos cannot be arbitrarily reordered. The condition is: we can only swap adjacent 0-1 and 1-2. \n\n This means that the relative order of zeros and twos is fixed? Actually, no: we can use the ones to separate them. For example, consider \"02\": we cannot swap, so the zero and two are fixed. But if we have \"012\", then we can do:\n\n   \"012\" -> swap the 0 and 1 -> \"102\"\n   Then swap the 1 and 2 -> \"120\"\n   Then swap the 1 and 2 again? No, because we can swap 1 and 2, so from \"120\" we can swap the 1 and 2 (the first two) to get \"210\". Then we cannot swap the 1 and 0 (because they are separated by a 2). \n\n Alternatively, from \"012\", we can also:\n   Swap the 1 and 2 first: \"021\"\n   Then swap the 0 and 2? Not allowed. So the possibilities are:\n\n   \"012\" -> \"102\" -> \"120\" -> \"210\"\n\n   So we can get \"120\" and \"210\", but not \"012\" (it's the original) and not \"021\" (from the direct swap of 1 and 2) is that allowed? Actually, yes: from \"012\", we can swap the 1 and 2 (adjacent) to get \"021\". Then we can leave it, or swap the 0 and 2? No. So we have two possibilities for \"012\": \"012\", \"021\", \"102\", \"120\", \"210\".\n\n Now, which one is lexicographically smallest? \n   \"012\", \"021\", \"102\", \"120\", \"210\": \n   The smallest is \"012\" (but wait, we started with \"012\" and we didn't change it). However, note that we can also get \"012\" by doing nothing. But we can also get \"021\", which is larger than \"012\"? \n\n Actually, no: \"012\" is the smallest. But wait, is \"012\" the smallest? \n   Compare: \n     \"012\": first character '0'\n     \"021\": first character '0' -> same, second character '1' vs '2' -> so \"012\" is smaller.\n\n So why did we get \"012\" as the starting point? We didn't change it. But note: we are allowed to do any number of swaps. So we can leave it as \"012\".\n\n However, consider: \"102\": \n   \"102\" has first character '1', which is greater than '0'. So \"012\" is the smallest.\n\n Similarly, \"120\" and \"210\" are even worse.\n\n Now, what about \"021\"? \n   It's \"0\" then \"2\" then \"1\": \n   Compare with \"012\": \n     First character: '0' == '0'\n     Second character: '2' vs '1' -> so \"012\" is smaller.\n\n So the minimal arrangement for \"012\" is \"012\".\n\n But wait, what if we have multiple zeros and twos? \n\n We cannot change the relative order of zeros and twos that are separated by ones? Actually, we can use the ones to separate zeros and twos arbitrarily.\n\n However, note: we cannot swap zeros and twos, so the zeros that are originally to the left of a two must remain to the left of that two (unless we use ones to push the two to the left of the zero, but then the two would have to jump over the zero which isn't allowed). \n\n Actually, consider two zeros and a two: \n   Example: \"002\"\n   We can swap the last two: not allowed (swap 0 and 2). But we can swap the two zeros? No, because we can only swap adjacent 0 and 1, or 1 and 2. There are no ones here. So we cannot change \"002\". \n\n   Example: \"020\"\n   We cannot swap the two zeros (no adjacent 0 and 1 or 1 and 2). But we can try to move the two? \n        \"020\": \n        We can swap the middle '2' and the last '0'? No. \n        We can swap the first '0' and the '2'? No.\n\n   So \"020\" remains \"020\".\n\n   Example: \"200\": \n        We cannot swap the first two. So remains \"200\".\n\n   Example: \"20\": remains \"20\".\n\n   Example: \"00\": remains \"00\".\n\n   Example: \"22\": remains \"22\".\n\n   Example: \"010\": \n        We can swap the first two (0 and 1) -> \"100\", then we cannot swap the 1 and 0 (they are adjacent) but wait, we can swap the 1 and 0 again? Actually, we can do:\n\n        \"010\": \n          swap the first two: \"100\"\n          then swap the two zeros? No, because no adjacent 0 and 1 or 1 and 2 (the two zeros are adjacent, but we can't swap zeros). So we get \"100\".\n\n        Now, compare \"010\" and \"100\": \n          \"010\" is lexicographically smaller.\n\n        So we don't necessarily want to move the zeros to the very front if we can avoid it? Actually, wait: in \"010\", the zeros are not at the very front? They are: the first character is zero. Then we have a one, then a zero.\n\n        Actually, \"010\" is already with zeros at the front. But wait, the two zeros are separated by a one. \n\n        But note: we cannot move the zeros arbitrarily past the one? Actually, we can: from \"010\", we can swap the first two to get \"100\", but we can also swap the last two (if we had a one and a zero) but the last two are \"10\", so we can swap that to get \"011\". Then we can swap the first two (if we have two zeros) but wait, after swapping the last two, we get \"011\", and then we can swap the first two? The first two are \"01\", so we can swap to get \"101\". Then we can swap the last two? The last two are \"01\", so we can swap to get \"100\". \n\n        Actually, the process is reversible? \n\n        We want the lexicographically smallest. \n\n        In \"010\", we have:\n          [0, 1, 0] -> the two zeros are separated by a one.\n\n        But we can also have:\n          Option 1: \"001\" (if we can move the second zero to the front) but wait, we cannot swap zeros. \n\n        How to get \"001\"?\n          We can only swap 0 and 1. So from \"010\", we can swap the first two: \"100\", then we cannot swap the middle two (0 and 0) because no swap allowed for zeros. Then we cannot get the zero from the end to the front.\n\n        Alternatively, from \"010\": \n          We can swap the last two: \"001\" (because the last two are \"10\", which are adjacent and we can swap). So:\n\n          \"010\" -> swap the last two: \"001\"\n\n        So we can get \"001\", which is lexicographically smaller than \"010\".\n\n        So the minimal string for \"010\" is \"001\".\n\n        Similarly, we can move zeros arbitrarily to the left as long as we have ones in the way.\n\n        Therefore, the zeros can be moved arbitrarily to the left (by swapping with ones to the left) and also to the right (by swapping with ones to the right) until they hit the boundary of non-one characters. But note: we cannot move zeros through twos.\n\n        Similarly, the twos can be moved arbitrarily to the right (by swapping with ones to the right) and to the left (by swapping with ones to the left) until they hit a zero? Actually, no: we cannot move a two through a zero.\n\n        And the ones can be moved arbitrarily because they can swap with zeros and twos.\n\n        Therefore, the goal is to arrange the string so that:\n\n        - All zeros are as left as possible (but note: we cannot put a zero to the left of a two that is originally to the left of that zero? Actually, we cannot swap zeros and twos, so if a two is originally to the left of a zero, we cannot move the zero to the left of that two.\n\n        So the constraint is: the relative order of zeros and twos must be the same as the original.\n\n        Therefore, we can only rearrange the zeros and ones arbitrarily, and the ones and twos arbitrarily, but the zeros and twos must preserve their relative order.\n\n        This is similar to having two independent sets: zeros and ones (which can be arranged arbitrarily) and ones and twos (which can be arranged arbitrarily). But the ones are shared.\n\n        How to solve?\n\n        We can use the following:\n\n        Step 1: Count the frequency of zeros, ones, and twos.\n\n        Step 2: We know that the final string must have the same multiset of characters.\n\n        Step 3: The zeros and twos must appear in the same relative order as in the original string.\n\n        Then, we can think of building the string by:\n\n        - We will place zeros and ones arbitrarily (without regard to the original order of zeros and ones, because we can rearrange them arbitrarily) but we must preserve the relative order of zeros and twos.\n\n        Actually, we can break the problem into:\n\n        We are allowed to independently rearrange the zeros and the ones (like two independent lists) and the ones and the twos (another independent list). But the zeros and twos are fixed in their relative order.\n\n        Alternatively, we can consider that the entire string is built by:\n\n        - We can assign positions to the zeros, ones, and twos arbitrarily, except that if a zero appears after a two in the original string, then in the final string that zero must appear after that two.\n\n        How to achieve the lexicographically smallest string?\n\n        We want to put zeros as much as possible at the front, then ones, then twos. But the constraint: the relative order of zeros and twos must be preserved.\n\n        So the minimal arrangement is:\n\n        - We can put all zeros at the beginning, then all ones, then all twos, provided that in the original string, every zero that comes before a one or a two does not break the constraint that zeros must appear before the corresponding twos (i.e., if a zero appears after a two in the original string, then we cannot put that zero before the two).\n\n        Actually, the constraint is: if in the original string, a zero appears after a two, then in the final string that zero must appear after that two.\n\n        So we cannot simply put all zeros at the front.\n\n        Example: \"20\" -> cannot change, so the two must come before the zero.\n\n        Example: \"02\" -> we cannot change, so the zero must come before the two.\n\n        Therefore, the problem reduces to:\n\n        We have three types: \n          Type0: '0'\n          Type1: '1'\n          Type2: '2'\n\n        And we have two constraints:\n\n          Constraint1: The relative order of zeros and ones can be arbitrary (because we can swap them arbitrarily).\n          Constraint2: The relative order of ones and twos can be arbitrary.\n          Constraint3: The relative order of zeros and twos must be the same as the original.\n\n        So the zeros and twos must appear in the same order as in the original string.\n\n        Then, the minimal lexicographic string is:\n\n        - We can interlace zeros and ones arbitrarily (to get zeros as left as possible) and ones and twos arbitrarily (to get ones next, then twos) but the zeros and twos must not violate the original order.\n\n        This is similar to a merge of three sequences with two of them being fully mergeable and one having a fixed order.\n\n        Steps:\n\n        1. Extract the positions of zeros, ones, and twos.\n\n        2. The zeros and twos must appear in the same relative order as in the original string.\n\n        3. Then, we can use the following:\n\n            We know that the final string must have the zeros and ones merged arbitrarily (so we can put all zeros first and then ones, but wait: if we do that, we break the constraint of zeros and twos? No, because the zeros and twos constraint is independent of the ones. The constraint is only on the relative order of zeros and twos.\n\n        However, we can also insert ones arbitrarily. The trick is: we want to put as many zeros as possible at the beginning, then as many ones as possible, then the rest.\n\n        But note: we cannot break the relative order of zeros and twos. So if there is a two that originally is to the left of a zero, then that two must be placed before that zero.\n\n        Therefore, we can do:\n\n        Let the final string be built from three independent sets:\n\n          Zeros: we can put them anywhere (except we must not put a zero that originally comes after a two before that two).\n          Twos: similarly, we must put them in the order they appear, and we cannot put a two that originally comes after a zero before that zero.\n\n        But we are allowed to interlace zeros and ones arbitrarily, and ones and twos arbitrarily.\n\n        Algorithm:\n\n        We can use a two-step process:\n\n        Step 1: Remove all the ones and note the positions of zeros and twos. Then, we must output the zeros and twos in the original relative order, and we can insert ones arbitrarily in between. However, we are allowed to move ones arbitrarily, so we can put all the ones together either at the beginning, middle, or end? Actually, we can put the ones wherever we want.\n\n        But wait: we want the lexicographically smallest. We want to put zeros first, then ones, then twos. However, if we put a one before a zero, then the zero would be after the one, which is bad because '0'<'1'. But we can also put zeros and ones arbitrarily. So we can put all zeros and ones at the beginning, and then the twos? But the zeros and ones can be arbitrarily rearranged, so we can put zeros first then ones.\n\n        However, the constraint: the zeros and twos must be in the original relative order.\n\n        So the plan is:\n\n        Let the original string be s.\n\n        We want to form:\n\n          result = []\n\n          We have a list of zeros and ones (without the twos) and we can arrange the zeros and ones arbitrarily (so we put all zeros then all ones) but then we have to interleave the twos such that the relative order of zeros and twos is preserved.\n\n        Alternatively, we can use the following:\n\n        We know that the zeros and twos must appear in the original order. So we can do:\n\n          Step 1: Collect the indices of zeros and twos and record their order.\n\n          Step 2: We are going to build the string by:\n\n            We can use a greedy algorithm:\n\n            We want to output as many zeros as possible at the beginning, then ones, then twos, but if we output a two, we must not break the condition that if a zero comes later in the original string, then we haven't output a two that originally was before that zero.\n\n        Actually, we can use a state machine or simply:\n\n          We can use two pointers for zeros and twos, and then fill the gaps with ones.\n\n        But note: we can also rearrange the ones arbitrarily, so we can put all ones in the middle.\n\n        The minimal lexicographic string is:\n\n          [all zeros (from the original string, but we can take them arbitrarily? No, we cannot change the count) then all ones then all twos] if we disregard the constraint? \n\n        But wait: the constraint is that the zeros and twos must be in the original relative order.\n\n        Example: Original string: \"201\"\n\n        The zeros and twos: \n          There is a zero at index1 and a two at index0. The relative order of zeros and twos: the two comes first, then the zero.\n\n        Then, the minimal arrangement must have the two before the zero.\n\n        But if we put all zeros first, we would put the zero (which is the only zero) at the beginning, and then the two, which violates the constraint.\n\n        So the minimal arrangement for \"201\" is:\n\n          We cannot put the zero at the beginning because that would require the two to be after the zero, which is not allowed.\n\n          So the minimal arrangement is \"201\" (but wait, we can swap the 0 and 1? Yes, because they are adjacent and allowed. So:\n\n          \"201\" -> swap the 0 and 1: \"210\"\n\n          Then we can swap the 1 and 2? \"210\" -> swap the 1 and 2 (if adjacent) but the 2 and 1 are adjacent? Then we get \"120\".\n\n          Then we can swap the 1 and 0? No, because they are separated by the 2. \n\n          So the possibilities: \n            \"201\", \"210\", \"120\"\n\n          Lexicographic order: \n            \"120\": starts with '1'\n            \"201\": starts with '2'\n            \"210\": starts with '2'\n\n          So the smallest is \"120\".\n\n          But wait, how did we get \"120\"? \n            From \"201\": \n              swap the 0 and 1: \"210\"\n              then swap the 2 and 1: \"120\"\n\n          So the minimal arrangement is \"120\".\n\n        Now, what is the rule?\n\n        We want to put zeros and ones arbitrarily, and ones and twos arbitrarily, but zeros and twos must be in the original order.\n\n        We can use:\n\n          Let A = list of zeros (with their original indices)\n          Let B = list of twos (with their original indices)\n\n        Then, the condition for the final string is: if in the original string, a zero at index i and a two at index j, then if i < j, the zero must come before the two; if i > j, the zero must come after the two.\n\n        Then, the minimal lexicographic string is:\n\n          We want to put as many zeros as possible at the beginning, then as many ones as possible, then the rest (twos). But we cannot break the relative order of zeros and twos.\n\n        How to build the string?\n\n        We can use a greedy method:\n\n          We'll traverse the original string and decide for each character whether we can put it at the current position.\n\n        Alternatively, we can note:\n\n          The problem is equivalent to: we have a fixed order for zeros and twos, and we can insert ones arbitrarily.\n\n          The minimal lexicographic string is obtained by:\n\n            - We will have a sequence of zeros (as many as we can without violating the constraint with the twos) then ones (as many as we can) then twos.\n\n          But the constraint: the zeros and twos must appear in the original order.\n\n          We can do:\n\n            Step 1: Extract the positions of zeros and twos.\n\n            Step 2: We know the final string must have the zeros and twos in the order of increasing index (for zeros and twos that are in the original order) and decreasing index (for zeros and twos that are in reverse order).\n\n          Actually, we can split the zeros and twos into two groups: \n            Group1: zeros that originally are before a certain two, and zeros that are after a certain two.\n\n        Another idea: \n\n          We can use a two-pointer for zeros and twos and then fill the rest with ones.\n\n        However, there is a known solution for this type of problem (like the problem of sorting with adjacent swaps and restricted swaps) is to use independent sorting for the pairs.\n\n        Known approach for similar problems (e.g., \"Minimum swaps to make the string sorted\" with restrictions) is to use inversion counts, but here we are allowed to do any number of adjacent swaps (within the allowed pairs) so we can achieve any permutation that preserves the relative order of zeros and twos.\n\n        Then, the problem reduces to: \n\n          We have three symbols, and we are allowed to rearrange arbitrarily within the set {0,1} and within the set {1,2}. Then the minimal lexicographic string is the one that has all zeros, then all ones, then all twos, unless the relative order of zeros and twos is violated.\n\n        But wait, the relative order of zeros and twos must be preserved. So we cannot put a zero that originally is after a two before that two.\n\n        Therefore, the minimal arrangement is:\n\n          We will output:\n\n            - All zeros that appear before a particular two (according to the original order) and then the two, but wait, we have multiple zeros and twos.\n\n        Actually, we can use the following:\n\n          We will build an array of the final positions for zeros and twos, and then we know that the ones can be placed arbitrarily.\n\n        Steps:\n\n          Let n = len(s)\n          Let zeros = [i for i, char in enumerate(s) if char=='0']\n          Let ones = [i for i, char in enumerate(s) if char=='1']\n          Let twos = [i for i, char in enumerate(s) if char=='2']\n\n          The condition: the zeros and twos must appear in the original string's order. That is, if we look at the original string, then the zeros and twos must appear in the order they appear. \n\n          But note: we are allowed to remove ones arbitrarily (because we can move them arbitrarily). \n\n          The final string must have:\n\n            The zeros that are in the original string, and the twos that are in the original string, must appear in the same relative order as they appear in the original string.\n\n          Then, we can do:\n\n            We will create an array for the answer.\n\n            We know that the entire string has length n, and we know the counts.\n\n            We can use two pointers for zeros and twos (from the original order) and then fill the rest with ones.\n\n          However, there is a simpler solution:\n\n          We can use a stack or a deque to simulate the movement.\n\n        After reading discussions of similar problems (like CodeForces problems with adjacent swaps and ternary strings), I recall that we can use the following:\n\n          The minimal string is achieved by:\n\n            - We can move zeros arbitrarily to the left (if there is a one to the left, we can swap and move the zero left, and then if we meet a two, we stop because we cannot swap with two). But wait, we can use ones to separate.\n\n          Actually, we can use a bubble-sort like method for zeros and ones, and for ones and twos, but then we must preserve the zeros and twos order.\n\n        Alternatively, we can use the following:\n\n          We are allowed to do any number of adjacent swaps for 0-1 and 1-2. Therefore, the relative order of zeros and twos must be the same as the original.\n\n          Then, we can use:\n\n            result = []\n            i = 0   # pointer for zeros and ones (we will consider zeros and ones as one group, and twos as the other, but the constraint is the zeros and twos order)\n\n          But wait, we can also use the following known solution for this exact problem (it's a classic):\n\n          We can use a greedy algorithm that goes from left to right and decides what to put.\n\n          Steps:\n\n            Let's define:\n\n              count0 = total zeros\n              count1 = total ones\n              count2 = total twos\n\n            But we cannot simply put zeros then ones then twos because of the constraint.\n\n          Another known solution is to use a two-pass method:\n\n            Pass1: Move all zeros to the left (using swaps with ones) but without disturbing the relative order of zeros and twos.\n\n          However, there is an easier insight:\n\n          The allowed swaps mean that the only fixed part is the relative order of zeros and twos. The ones can be placed arbitrarily.\n\n          Then, the minimal lexicographic string is:\n\n            We will have a string that is a merge of:\n\n              - The zeros and ones (which can be arranged arbitrarily) and the ones and twos (which can be arranged arbitrarily), but the zeros and twos must be in the original order.\n\n          We can do:\n\n            Step1: Create an array for the final positions for zeros and twos, preserving their original order.\n\n            Step2: Then, we will fill the gaps (where the ones were) with ones.\n\n          But how to distribute the ones?\n\n          We want the lexicographically smallest, so we want to put ones as much as possible to the right? \n\n          Actually, we want to put zeros first, then ones, then twos. But the constraint: the zeros and twos must be in the original order.\n\n          We can do:\n\n            Let X = the original string.\n\n            We will create an array 'ans' of length n.\n\n            Let's denote by Z the list of zeros and their original indices, and by T the list of twos and their original indices.\n\n            The condition: if we look at the combined list of zeros and twos (in the order they appear in the original string), then in the final string, the zeros and twos must appear in that order.\n\n            Then, we can:\n\n              - We will place the zeros and twos in the final string in the order they appear in the original string, and then fill the remaining positions with ones.\n\n            But wait, we cannot change the count of ones. The total length is fixed.\n\n            However, the catch is: we are allowed to move the ones arbitrarily, so we can put them anywhere. But the minimal lexicographic string requires that we put zeros first, then ones, then twos, provided that the zeros and twos are in the original order.\n\n            But if we put a one before a zero, then that zero might be forced to appear after a two (if there is a two that originally comes after that zero) which might be okay, but we want to put zeros as much as possible at the front.\n\n            Actually, we can use the following greedy:\n\n              We will simulate the final string by having three pointers for zeros, ones, and twos, and we will decide the next character by:\n\n                If there is a zero available (and we haven't used all zeros) and if placing a zero does not violate the constraint (that is, if there is a two that hasn't been placed and that two originally appeared before this zero, then we cannot place this zero now), then we place a zero.\n\n            But note: the constraint is global: the zeros and twos must be in the original order. We cannot place a zero if there is a two (that originally appeared before this zero) that hasn't been placed yet.\n\n            Similarly, we cannot place a two if there is a zero (that originally appeared after this two) that hasn't been placed yet.\n\n            However, we can place ones freely.\n\n            So algorithm:\n\n              Let's collect:\n\n                zeros = list of indices where s[i]=='0'\n                twos = list of indices where s[i]=='2'\n\n              But actually, we need to know the original order of zeros and twos.\n\n              Let's create:\n\n                events = []\n                for i, char in enumerate(s):\n                    if char == '0':\n                        events.append(('0', i))\n                    elif char == '2':\n                        events.append(('2', i))\n\n              Then, the",
    "response": "\nTo solve this problem, we need to find the lexicographically smallest string that can be obtained by performing any number of adjacent swaps between '0' and '1', or between '1' and '2'. The key observation here is that the relative order of '0's and '2's in the original string must be preserved in the final string. The '1's can be rearranged freely between the '0's and '2's.\n\n### Approach\n1. **Problem Analysis**: The allowed swaps are between '0' and '1' (adjacent) and between '1' and '2' (adjacent). This means '0's can move left or right through '1's, and '2's can move left or right through '1's, but '0's and '2's cannot directly swap places. Therefore, the relative order of '0's and '2's in the original string must remain unchanged in the final string.\n2. **Intuition**: To achieve the lexicographically smallest string, we should place all '0's as far left as possible, followed by '1's, and then '2's. However, we must ensure that the relative order of '0's and '2's is maintained. This means if a '2' originally appears before a '0', the '2' must still appear before the '0' in the final string.\n3. **Algorithm Selection**: We can use a two-pointer technique to traverse the original string and build the result string. We maintain pointers for the next available '0' and '2' from the original order. For each position in the result string, if there is a '0' available (and no '2' that originally came before it remains to be placed), we place '0'. Otherwise, if there is a '2' available (and no '0' that originally came before it remains to be placed), we place '2'. Otherwise, we place '1's wherever they can fit without violating the order constraints.\n\n### Solution Code\n```python\ndef main():\n    s = input().strip()\n    n = len(s)\n    zeros = []\n    ones = []\n    twos = []\n    \n    for i, char in enumerate(s):\n        if char == '0':\n            zeros.append(i)\n        elif char == '1':\n            ones.append(i)\n        else:\n            twos.append(i)\n            \n    ptr0 = 0\n    ptr2 = 0\n    res = []\n    count_ones = len(ones)\n    total_zeros = len(zeros)\n    total_twos = len(twos)\n    \n    for pos in range(n):\n        if ptr0 < total_zeros and (ptr2 >= total_twos or zeros[ptr0] < twos[ptr2]):\n            res.append('0')\n            ptr0 += 1\n        elif ptr2 < total_twos and (ptr0 >= total_zeros or zeros[ptr0] > twos[ptr2]):\n            res.append('2')\n            ptr2 += 1\n        else:\n            res.append('1')\n            \n    print(''.join(res))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Initialization**: The code starts by reading the input string and categorizing the positions of '0's, '1's, and '2's into separate lists.\n2. **Two-Pointer Technique**: The algorithm uses two pointers, `ptr0` and `ptr2`, to keep track of the next available '0' and '2' from their original order. These pointers help ensure that the relative order of '0's and '2's is maintained in the result string.\n3. **Building the Result String**: For each position in the result string, the algorithm checks if a '0' can be placed next (i.e., no '2' that originally came before this '0' remains to be placed). If not, it checks if a '2' can be placed. If neither '0' nor '2' can be placed without violating the order, it places a '1'.\n4. **Output**: The constructed result string is printed, which is the lexicographically smallest string obtainable under the given constraints.\n\nThis approach efficiently ensures that the result string is lexicographically smallest while respecting the constraints on the relative order of '0's and '2's. The complexity is linear, O(n), where n is the length of the input string, making it suitable for large inputs up to 10^5 characters.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    s = input().strip()\n    n = len(s)\n    zeros = []\n    ones = []\n    twos = []\n    \n    for i, char in enumerate(s):\n        if char == '0':\n            zeros.append(i)\n        elif char == '1':\n            ones.append(i)\n        else:\n            twos.append(i)\n            \n    ptr0 = 0\n    ptr2 = 0\n    res = []\n    count_ones = len(ones)\n    total_zeros = len(zeros)\n    total_twos = len(twos)\n    \n    for pos in range(n):\n        if ptr0 < total_zeros and (ptr2 >= total_twos or zeros[ptr0] < twos[ptr2]):\n            res.append('0')\n            ptr0 += 1\n        elif ptr2 < total_twos and (ptr0 >= total_zeros or zeros[ptr0] > twos[ptr2]):\n            res.append('2')\n            ptr2 += 1\n        else:\n            res.append('1')\n            \n    print(''.join(res))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 589,
        "completion_token_count": 942,
        "thoughts_token_count": 8191
    }
}