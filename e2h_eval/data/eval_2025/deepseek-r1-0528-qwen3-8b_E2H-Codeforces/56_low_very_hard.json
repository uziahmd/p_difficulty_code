{
    "start": 1758294369.835565,
    "end": 1758296437.8576555,
    "start-formatted": "2025-09-20 00:06 KST",
    "end-formatted": "2025-09-20 00:40 KST",
    "gpu": 2,
    "pid": 56,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Guard Duty (easy)\n\nThe Rebel fleet is afraid that the Empire might want to strike back again. Princess Heidi needs to know if it is possible to assign R Rebel spaceships to guard B bases so that every base has exactly one guardian and each spaceship has exactly one assigned base (in other words, the assignment is a perfect matching). Since she knows how reckless her pilots are, she wants to be sure that any two (straight) paths – from a base to its assigned spaceship – do not intersect in the galaxy plane (that is, in 2D), and so there is no risk of collision.\n\n## Input\nThe first line contains two space-separated integers R, B(1 ≤ R, B ≤ 10). For 1 ≤ i ≤ R, the i + 1-th line contains two space-separated integers xi and yi (|xi|, |yi| ≤ 10000) denoting the coordinates of the i-th Rebel spaceship. The following B lines have the same format, denoting the position of bases. It is guaranteed that no two points coincide and that no three points are on the same line.\n\n## Output\nIf it is possible to connect Rebel spaceships and bases so as satisfy the constraint, output Yes, otherwise output No (without quote).\n\n## Example\n### Input\n['3 3\\n0 0\\n2 0\\n3 1\\n-2 1\\n0 3\\n2 2', '2 1\\n1 0\\n2 2\\n3 1']\n\n### Output\n['Yes', 'No']\n\n## Note\nFor the first example, one possible way is to connect the Rebels and bases in order.For the second example, there is no perfect matching between Rebels and bases.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\n Okay, we are given R and B (each between 1 and 10) and then R lines for rebels and B lines for bases.\n\n Conditions:\n - We need a perfect matching (so R must equal B? Actually, the problem says \"assign R Rebel spaceships to guard B bases\" and \"every base has exactly one guardian and each spaceship has exactly one assigned base\", so it's a bijection. Therefore, we require R == B? But note: the input says \"For 1 ≤ i ≤ R, ...\", then \"the following B lines ...\", and the constraints say R, B ≥ 1 and ≤ 10. However, the example input does not necessarily have R=B. Let's check the example:\n\n Example 1: Input \"3 3 ...\" -> R=3, B=3 -> output Yes.\n Example 2: Input \"2 1 ...\" -> R=2, B=1 -> output No.\n\n So the first condition is that we must have a bijection, i.e., R must equal B. Otherwise, we cannot assign one spaceship per base and vice versa.\n\n But wait, the problem says: \"every base has exactly one guardian\" and \"each spaceship has exactly one assigned base\". This implies that the number of bases must equal the number of spaceships. Therefore, if R != B, we output 'No'.\n\n However, note that the example input format: \n   First line: R, B\n   Then R lines for rebels, then B lines for bases.\n\n So if R != B, we immediately return 'No'?\n\n But wait: what if R != B, but we are still to check the non-intersection condition? Actually, the problem says \"perfect matching\", which requires |R| = |B|. So we can assume that if R != B, the answer is 'No'.\n\n Steps:\n\n 1. Check if R == B. If not, output 'No'.\n 2. Otherwise, we have R = B, and we have 2*R points: R rebels and R bases (since B=R).\n\n The problem: Assign each rebel to a base such that the two straight lines (from base to its assigned rebel) do not intersect.\n\n Note: The bases and rebels are given as two sets of points. We are allowed to assign any rebel to any base (bijection). The condition is that no two connecting segments (straight lines) should intersect.\n\n Important: The assignment is a set of segments from a base to a rebel. We require that no two segments (from two different pairs) intersect.\n\n However, note: the problem says \"any two (straight) paths – from a base to its assigned spaceship – do not intersect\". So if we draw the segments, they should not cross.\n\n How to solve?\n\n Since R and B are at most 10, and we require a perfect matching (which is a bijection), we can use backtracking (or try all permutations) because the maximum R is 10, so 10! = 3628800 which is acceptable in Python if we do it smartly.\n\n But wait: 10! is about 3.6 million, which is acceptable in worst-case if we do a single permutation and check the condition for the entire matching. However, we can break early.\n\n Alternatively, we can use recursion and check for the matching condition as we assign.\n\n However, note: the condition is that no two segments intersect. So we have to check that for the entire set of segments.\n\n How to check if two segments (with endpoints being base and rebel) intersect?\n\n But note: the problem does not require the entire set of segments to be non-intersecting only when drawn in the plane? However, note that the bases and rebels are distinct and no three points are colinear. Also, the segments are between a base and a rebel.\n\n However, note: the segments are from base i to rebel j. Two segments (base_i, rebel_j) and (base_k, rebel_l) might intersect even if i != k and j != l.\n\n We need to check that none of the segments in the matching cross.\n\n But note: the problem states \"any two (straight) paths\" meaning every pair of segments (from two different assignments) must not intersect.\n\n However, there is a catch: the segments are from a base to a rebel. The bases and rebels are distinct points.\n\n There is a known fact: two line segments (p1, q1) and (p2, q2) intersect if and only if one point of one segment lies on the other side of the line defined by the other segment and vice versa, but we have to be cautious with the endpoints.\n\n But note: the problem says \"in the galaxy plane (that is, in 2D)\", and \"no three points are on the same line\". However, the endpoints are distinct, but two segments might share an",
    "response": "\nTo solve this problem, we need to determine if there exists a perfect matching between a set of Rebel spaceships and bases such that the straight-line segments connecting each spaceship to its assigned base do not intersect. The solution involves checking all possible bijections between the spaceships and bases for the non-intersection condition.\n\n### Approach\n1. **Problem Analysis**: The problem requires a perfect matching (bijection) between R spaceships and B bases where R must equal B. If they don't, the answer is immediately \"No\". For each valid bijection, we need to ensure that no two connecting segments intersect in the plane.\n2. **Key Insight**: The non-intersection condition can be checked using geometric properties. Two segments (A-B) and (C-D) intersect if the points C and D lie on opposite sides of the line defined by A-B, and vice versa. This is known as the cross product test.\n3. **Algorithm Selection**: Given the constraints (R, B ≤ 10), a brute-force approach is feasible. We generate all permutations of the bases assigned to the spaceships and check the non-intersection condition for each permutation.\n4. **Complexity Analysis**: The number of permutations is R! (up to 10! = 3,628,800). For each permutation, we check all pairs of segments (O(R^2) per permutation). Thus, the total complexity is O(R! * R^2), which is manageable for R ≤ 10.\n\n### Solution Code\n```python\nimport sys\nfrom itertools import permutations\n\ndef orientation(a, b, c, d):\n    return (b.x - a.x) * (d.y - a.y) - (b.y - a.y) * (d.x - a.x)\n\ndef do_segments_intersect(seg1, seg2):\n    p1, q1 = seg1\n    p2, q2 = seg2\n    \n    o1 = orientation(p1, q1, p2, q2)\n    o2 = orientation(p1, q1, q2, p2)\n    o3 = orientation(p2, q2, p1, q1)\n    o4 = orientation(p2, q2, q1, p1)\n    \n    if (o1 > 0 and o2 < 0) or (o1 < 0 and o2 > 0):\n        return True\n        \n    if (o3 > 0 and o4 < 0) or (o3 < 0 and o4 > 0):\n        return True\n        \n    if o1 == 0 or o2 == 0 or o3 == 0 or o4 == 0:\n        return False\n        \n    return False\n\nclass Point:\n    __slots__ = ('x', 'y')\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"No\")\n        return\n        \n    r = int(data[0])\n    b = int(data[1])\n    \n    rebels = []\n    index = 2\n    for _ in range(r):\n        x = int(data[index])\n        y = int(data[index+1])\n        index += 2\n        rebels.append(Point(x, y))\n        \n    bases = []\n    for _ in range(b):\n        x = int(data[index])\n        y = int(data[index+1])\n        index += 2\n        bases.append(Point(x, y))\n        \n    if r != b:\n        print(\"No\")\n        return\n        \n    base_points = bases\n    \n    for perm in permutations(range(b)):\n        segments = []\n        for i in range(r):\n            rebel = rebels[i]\n            base_index = perm[i]\n            base_point = base_points[base_index]\n            segments.append((rebel, base_point))\n            \n        valid = True\n        n = len(segments)\n        for i in range(n):\n            for j in range(i+1, n):\n                seg1 = segments[i]\n                seg2 = segments[j]\n                if do_segments_intersect(seg1, seg2):\n                    valid = False\n                    break\n            if not valid:\n                break\n                \n        if valid:\n            print(\"Yes\")\n            return\n            \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Input Handling**: The input is read and parsed into integers representing the number of spaceships (R) and bases (B). Their coordinates are stored in lists.\n2. **Initial Check**: If R ≠ B, output \"No\" immediately since a perfect matching is impossible.\n3. **Permutation Generation**: For each permutation of base indices, we form segments connecting each spaceship to its assigned base.\n4. **Intersection Check**: For each permutation, we check if any two segments intersect using the cross product method. The `orientation` function determines the relative position of points, and `do_segments_intersect` checks if two segments cross each other.\n5. **Output Result**: If any permutation satisfies the non-intersection condition, print \"Yes\"; otherwise, print \"No\".\n\nThis approach efficiently checks all possible assignments and ensures correctness by leveraging geometric properties and combinatorial search within feasible limits.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom itertools import permutations\n\ndef orientation(a, b, c, d):\n    return (b.x - a.x) * (d.y - a.y) - (b.y - a.y) * (d.x - a.x)\n\ndef do_segments_intersect(seg1, seg2):\n    p1, q1 = seg1\n    p2, q2 = seg2\n    \n    o1 = orientation(p1, q1, p2, q2)\n    o2 = orientation(p1, q1, q2, p2)\n    o3 = orientation(p2, q2, p1, q1)\n    o4 = orientation(p2, q2, q1, p1)\n    \n    if (o1 > 0 and o2 < 0) or (o1 < 0 and o2 > 0):\n        return True\n        \n    if (o3 > 0 and o4 < 0) or (o3 < 0 and o4 > 0):\n        return True\n        \n    if o1 == 0 or o2 == 0 or o3 == 0 or o4 == 0:\n        return False\n        \n    return False\n\nclass Point:\n    __slots__ = ('x', 'y')\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"No\")\n        return\n        \n    r = int(data[0])\n    b = int(data[1])\n    \n    rebels = []\n    index = 2\n    for _ in range(r):\n        x = int(data[index])\n        y = int(data[index+1])\n        index += 2\n        rebels.append(Point(x, y))\n        \n    bases = []\n    for _ in range(b):\n        x = int(data[index])\n        y = int(data[index+1])\n        index += 2\n        bases.append(Point(x, y))\n        \n    if r != b:\n        print(\"No\")\n        return\n        \n    base_points = bases\n    \n    for perm in permutations(range(b)):\n        segments = []\n        for i in range(r):\n            rebel = rebels[i]\n            base_index = perm[i]\n            base_point = base_points[base_index]\n            segments.append((rebel, base_point))\n            \n        valid = True\n        n = len(segments)\n        for i in range(n):\n            for j in range(i+1, n):\n                seg1 = segments[i]\n                seg2 = segments[j]\n                if do_segments_intersect(seg1, seg2):\n                    valid = False\n                    break\n            if not valid:\n                break\n                \n        if valid:\n            print(\"Yes\")\n            return\n            \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 480,
        "completion_token_count": 1098,
        "thoughts_token_count": 1023
    }
}