{
    "start": 1758304703.4811044,
    "end": 1758308669.8694315,
    "start-formatted": "2025-09-20 02:58 KST",
    "end-formatted": "2025-09-20 04:04 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\n Okay, we are given a graph with n nodes and m edges. Each edge (u, v) gives two numbers: gcd and lcm.\n Conditions for an edge (a, b):\n   Let x = gcd, y = lcm.\n   Then, we must have:\n      x * y = a * b   (because gcd(a,b) * lcm(a,b) = a*b)\n   Also, we must have x divides both a and b, and y is divisible by x.\n\n Steps:\n\n 1. Check consistency per edge: \n      For each edge (u, v, g, l):\n        - If g * l does not equal u * v, then note that the product condition must hold. However, note that the product condition is necessary but not sufficient.\n\n 2. However, note: the problem does not require the same number of mushrooms on every lawn. We are to assign a number to each node (lawns) such that for every edge (u, v) with given gcd and lcm, the assigned numbers a[u] and a[v] satisfy:\n        gcd(a[u], a[v]) = g and lcm(a[u], a[v]) = l\n\n 3. We can think of assigning prime factors. But note: the constraints (n up to 10^5, and numbers up to 10^6) make factorization heavy.\n\n Alternative approach:\n\n   Let's denote:\n        a = assigned number to node u, b = assigned number to node v.\n\n   From the edge, we know:\n        a = g * a1, b = g * b1, and then the LCM condition: LCM(a,b) = g * a1 * b1 / gcd(a1, b1) = l.\n\n   So we have: g * a1 * b1 / gcd(a1, b1) = l   =>   a1 * b1 / gcd(a1, b1) = l/g.\n\n   But note: a1 and b1 must be coprime? Not necessarily, but the condition is that the gcd(a1, b1) must divide (l/g). Moreover, the equation can be rewritten as: \n        a1 * b1 = (l/g) * d, where d = gcd(a1, b1). However, this is circular.\n\n   Another known fact: For two numbers a and b, we have:\n        gcd(a, b) = g, and lcm(a, b) = l.\n        Then, a and b must be multiples of g, and the ratio l/g must be the least common multiple of (a/g) and (b/g). Moreover, we know that the product of (a/g) and (b/g) must be l/g, because:\n            a * b = g^2 * a1 * b1 = g * l   => so a1 * b1 = l/g.\n\n        And also, the gcd(a1, b1) must be 1? Actually, no. But wait: if we let d = gcd(a1, b1), then we can write a1 = d * k, b1 = d * m, then the condition becomes:\n            gcd(k, m) = 1, and then the LCM(a,b) = g * d * k * m / gcd(k, m) = g * d * k * m = l.\n\n        But from the product condition we have: a1 * b1 = d^2 * k * m = l/g.\n\n        Then, from the equation: d^2 * k * m = l/g, and from the LCM we have: g * d * k * m = l.\n\n        This implies: d * k * m = l/g, and then d^2 * k * m = (l/g) * d = l/g * d = l/g * d = l/g * d = (l/g)*d = l/g*d = ... \n\n        Actually, from the two conditions we have:\n            d * k * m = l/g   (from the LCM condition: g * d * k * m = l  => d*k*m = l/g)\n            and from the product condition: (g*a1)*(g*b1)=g*l => g^2 * (d*k)*(d*m)=g*l => g*d^2*k*m = l => d^2*k*m = l/g.\n\n        So we get: d^2*k*m = d*(l/g) => d*k*m = l/g, which is consistent.\n\n        Therefore, we can set: \n            Let a = g * k * d, b = g * m * d, and then k and m must be coprime.\n\n        But note: the product condition requires: a1 * b1 = (k*d)*(m*d) = d^2 * k*m = (l/g) * d = l/g * d = (l/g)*d = (l/g)*d = ... and we already have d^2*k*m = l/g, so d*k*m = (l/g)/d = (l/g)/d, which is not matching unless d=1.\n\n        Alternatively, let's reexamine:\n\n        We know:\n          a = g * a1, b = g * b1, and then LCM(a, b) = g * LCM(a1, b1) = l.\n\n        Also, the product: a*b = g^2 * a1 * b1 = g*l.\n\n        Now, we have two equations:\n          (1) g * LCM(a1, b1) = l\n          (2) g^2 * a1 * b1 = g * l   => g * a1 * b1 = l\n\n        Then, from (1) and (2): \n          LCM(a1, b1) = (l / g)   [from (1)]\n          and from (2): a1 * b1 = (l / g)   [since g * a1 * b1 = l]\n\n        But note: for any two positive integers, the product is equal to the LCM only if the GCD is 1. Because:\n          a1 * b1 = GCD(a1, b1) * LCM(a1, b1)\n\n        So, we have: GCD(a1, b1) * LCM(a1, b1) = a1 * b1 = (l/g) = LCM(a1, b1) => so GCD(a1, b1) must be 1.\n\n        Therefore, we must have: \n          a1 * b1 = (l/g) and gcd(a1, b1) = 1.\n\n        So for each edge, the value (l/g) must be an integer (which we check first) and then we must be able to factor (l/g) into two coprime factors (a1, b1) such that a1 * b1 = (l/g). \n\n        However, note: the edge gives two numbers (g, l) and we don't know how to split (l/g) into two coprime factors. But actually, the assignment must be consistent across the entire graph.\n\n 4. We can model this as:\n\n        Let x_i be the number at node i.\n\n        For an edge (u, v) with (g, l):\n          Condition 1: g must divide both x_u and x_v, and also l must be the LCM of x_u and x_v.\n\n        But note: from the above, we can say:\n          Let A = x_u, B = x_v.\n          Then, A and B must be multiples of g, and the LCM(A, B) = l.\n\n        Also, from the product condition: A * B = g * l.\n\n        Moreover, we have: A = g * a1, B = g * b1, and then a1 and b1 must be coprime and a1 * b1 = l/g.\n\n        However, the entire graph must be consistent. We are free to choose the factors as long as they are coprime and their product is l/g.\n\n        But note: the same node might appear in multiple edges. How do we combine?\n\n 5. Another idea: factorize the entire graph by the prime factors.\n\n        Since the numbers are up to 10^6, we can consider the following:\n\n        For each edge, we know the gcd and lcm. The entire number at a node must be the product of primes raised to exponents that are the maximum over the incident edges? \n\n        However, note: the gcd is the minimum exponent for each prime, and the lcm is the maximum exponent for each prime.\n\n        We can do:\n\n          Let the base set of primes be the primes that appear in any of the edges' gcd or lcm.\n\n        Steps:\n\n          Precomputation: factorize the gcd and lcm for each edge? But there are up to 10^5 edges.\n\n        Alternatively, we can use a union-find or BFS/DFS to assign exponents for each prime separately? \n\n        However, note: the problem does not require a unique solution.\n\n 6. We can try to assign to each node a number that is the product of some primes raised to some exponents. But the exponents must be consistent across edges.\n\n        For each prime p, consider the entire graph and the edges. In each edge, the gcd and lcm give constraints on the exponents of p.\n\n        Specifically, for an edge (u, v) with gcd=g, lcm=l, and for a prime p:\n\n          Let e1 = exponent of p in g, and e2 = exponent of p in l.\n\n          Then, for the two nodes u and v, the exponents of p in their numbers (say a and b) must satisfy:\n                min(exponent_p(a), exponent_p(b)) = e1\n                max(exponent_p(a), exponent_p(b)) = e2\n\n        Then, the exponents for p in the two nodes must be exactly (e1, e2) (in some order).\n\n        Now, the entire graph for prime p must form a \"two-coloring\" of exponents: either e1 or e2. But note: if two edges incident to a node have constraints on the same prime, they must agree.\n\n        Example: two edges incident to node u, one says that for prime p, the exponent must be e1 (if the other node has e2) and the other says it must be e1 (if the other node has e2) — then that's consistent. But if one edge says the exponent must be e1 and another says it must be e2, then conflict.\n\n        However, note: an edge gives two exponents (min and max). We don't know which node gets which. So for an edge (u, v) we have two possibilities: \n            Case 1: exponent_p(u) = e1, exponent_p(v) = e2.\n            Case 2: exponent_p(u) = e2, exponent_p(v) = e1.\n\n        Then we must assign the exponents consistently for the entire graph for prime p.\n\n        Steps for prime p:\n\n          Step 1: For each edge, factorize the gcd and lcm for prime p. But note: if p does not divide g, then e1=0, and if p does not divide l, then e2=0. However, if p divides g, then e1>=1, and if p divides l, then e2>=1.\n\n          Actually, we can extract for prime p:\n\n            For an edge (u, v) with (g, l):\n\n            Let e1 = exponent of p in g (if p doesn't divide g, then 0)\n            Let e2 = exponent of p in l (if p doesn't divide l, then 0)\n\n            Then, if e1 > e2, then this is impossible (because min exponent cannot exceed max exponent). Similarly, if e2 < e1, then invalid. Also, if e1==0 and e2>0, then the min exponent should be 0 and max exponent e2, so that's okay. Similarly, if e1==0 and e2==0, then both exponents must be 0.\n\n          But note: if the gcd does not have p, then the min exponent is 0, and the max exponent is e2 (which must be >=0). However, if the lcm has p and the gcd does not, then one of the numbers must have exponent e2 and the other must have exponent 0 (so that min=0 and max=e2). \n\n          However, wait: the gcd is the minimum exponent, so if one of the numbers has exponent 0 (i.e., p does not divide that number) then the gcd won't have p. But if both numbers have exponents at least 1, then the gcd would have p. So the above holds.\n\n          Now, we can model for prime p:\n\n            We build a graph (for this prime) with n nodes and m edges. For an edge (u, v):\n\n              If e1 == e2 and e1 != 0 and e2 != 0:\n                  Then both u and v must have exponent = e1 (and e2=e1). So both must have the same exponent.\n\n              If e1 == 0 and e2 == 0:\n                  Then both must have exponent 0.\n\n              If e1 == 0 and e2 > 0:\n                  Then one of the two must have exponent 0 and the other must have exponent e2.\n\n              If e1 > 0 and e2 > 0 and e1 < e2:\n                  Then one node must have exponent e1 and the other e2.\n\n              If e1 == e2 and one of them is 0 and the other is 0, then we are in the case above.\n\n            But note: the condition e1==e2 and e1,e2>0 forces both to be e1. Similarly, if e1==e2 and e1==0, then both must be 0.\n\n          However, there is an issue: what if an edge has e1=0 and e2=0, but then we have no constraint? Actually, that means both nodes must have exponents for p that are at most 0 (so 0) and at least 0 (so 0). So then the exponents must be 0.\n\n          Now, we can build a constraint graph for prime p:\n\n            For each edge, we have two possibilities (unless the exponents are fixed):\n\n            We'll use a graph and traverse the connected components for prime p. We can use BFS/DFS to assign:\n\n              Let color0 = 0 (meaning we haven't assigned) and then we assign two colors: color1 and color2.\n\n            Actually, we can do:\n\n              For an edge (u, v) with (e1, e2):\n\n                Case 1: e1 == e2 (non-zero) OR e1==0 and e2==0: then we require that the exponent for p in u and v must be the same (either both e1 or both 0). Then we can set a constraint that they must be the same.\n\n                Case 2: e1==0 and e2>0: then the exponents must be 0 and e2, respectively. But we don't know which is which. So we have two possibilities.\n\n            However, note: we can also have mixed constraints from multiple edges.\n\n            Approach for prime p:\n\n              We'll create an undirected graph for the edges that have at least one of e1 or e2 non-zero? Actually, we can ignore edges that are (0,0) because they don't constrain (they just require both to be 0, but if we have an edge with (0,0) and then another edge with (0,5) then the (0,0) edge doesn't force 0? Actually, the (0,0) edge forces both to be 0, and then the (0,5) edge would require one of them to be 0 and the other 5. But if one is forced to 0 by the (0,0) edge, then the (0,5) edge must assign 5 to the other node.\n\n            Steps for prime p:\n\n              Build a graph with n nodes.\n\n              For each edge (u, v) in the original graph:\n\n                 Compute e1 = exponent of p in g, e2 = exponent of p in l.\n\n                 If e1 == e2 and e1 != 0:\n                    Then we add an edge (u, v) with constraint: the exponents must be equal (both e1).\n\n                 If e1 == e2 and e1 == 0:\n                    Then we add an edge (u, v) with constraint: the exponents must be 0.\n\n                 If e1 == 0 and e2 != 0:\n                    Then we add an edge (u, v) with constraint: the exponents must be {0, e2} (so one is 0 and the other is e2).\n\n                 If e1 != 0 and e2 != 0 and e1 < e2:\n                    Then we add an edge (u, v) with constraint: the exponents must be {e1, e2} (so one is e1 and the other is e2).\n\n                 If e1 != 0 and e2 == 0: \n                    Then we have a problem: the gcd has p and the lcm does not. This is impossible because if the gcd has p (so both numbers have at least exponent e1>0) then the lcm must have at least exponent e1 (so e2>=e1>0). Contradiction.\n\n                 Similarly, if e1 == 0 and e2 == 0, we do nothing? Actually, we have to enforce that both are 0. But we can do: if we have an edge (u, v) with (0,0), then we require that the exponents of p in u and v are 0. However, we might have already forced some nodes to be 0 from other edges. \n\n            Actually, we can treat the (0,0) case as a constraint that both are 0, and then if we have an edge (u, v) with (0,0) and then an edge (u, w) with (0,5), then we must set u to 0 (from the (0,0) edge) and then set w to 5.\n\n            However, we can combine the constraints:\n\n              We can break down the graph for prime p into connected components. In each connected component, we need to assign exponents to nodes such that for each edge:\n\n                 Type 1: (same value) -> both nodes get the same exponent (which is either the fixed value or 0, but note: if the edge is (same non-zero) then that value, if (same zero) then 0).\n                 Type 2: (two values) -> the two nodes must have the two different exponents.\n\n            But note: the two values are fixed (like 0 and e2, or e1 and e2). However, in a connected component, if we have multiple edges of type (same value) and (two values) then we must be consistent.\n\n            We can do:\n\n              Let's define two sets of constraints for prime p:\n\n                - Fixed: for an edge (u, v) that has (e1, e2) with e1==e2 and e1!=0, then the exponent for p in u and v is fixed to e1.\n                - Or if (e1, e2) is (0,0), then the exponent is fixed to 0.\n\n              However, note: the (0,0) case is also fixed to 0.\n\n            So we can do:\n\n              We'll build a graph for prime p that includes:\n\n                For each edge (u, v) with (e1, e2):\n\n                  Case 1: e1 == e2 and e1 != 0 -> mark that u and v must have exponent = e1.\n                  Case 2: e1 == e2 and e1 == 0 -> mark that u and v must have exponent = 0.\n                  Case 3: e1 != e2 and (e1==0 and e2>0) or (e1>0 and e2==0) is not allowed (but we already saw: if e1>0 and e2==0, then invalid; similarly, if e1==0 and e2==0 is handled above, and if e1==0 and e2>0, then we have two possibilities).\n\n                  Actually, we missed the case when e1 != e2 and both non-zero? The condition was e1 < e2, but if e1>e2 then that edge is invalid. So we only consider e1<=e2, and if e1>e2 then skip (invalid). Also, if e1==e2 and non-zero, then we use that.\n\n            But wait: what if we have an edge with (e1, e2) and e1>e2? Then it's invalid.\n\n            So algorithm for prime p:\n\n              Step 1: For each edge, compute exponents e1 and e2.\n\n              Step 2: If e1 > e2, then this prime p leads to an invalid constraint for this edge -> overall invalid.\n\n              Step 3: Then, we have three types:\n\n                Type A: e1 == e2 (and non-zero) -> both nodes must have exponent = e1.\n                Type B: e1 == e2 and e1==0 -> both nodes must have exponent = 0.\n                Type C: e1 == 0 and e2 != 0 -> the two nodes must have exponents 0 and e2 (we don't know which is which).\n                Type D: e1 != 0 and e2 != 0 and e1 < e2 -> the two nodes must have exponents e1 and e2 (again, we don't know which is which).\n\n              Step 4: We will use a union-find or DFS/BFS to propagate the constraints.\n\n              However, note: we have two types that fix the exponent (Type A and Type B) and two that don't (Type C and D). We can combine the fixed ones and then use the non-fixed ones to connect components.\n\n              Alternatively, we can do:\n\n                First, for the fixed cases (Type A and Type B), we can set the exponent for all nodes in the connected component (via these fixed edges) to the fixed value (or 0).\n\n                Then, for Type C and D, we can use the fixed values to determine the assignment.\n\n              But note: even Type C and D might fix the value of a node if the other node is fixed by a Type A or B.\n\n            Steps for prime p:\n\n              We'll create an array for the exponent of p for each node, initially set to None (unknown).\n\n              We'll also create an array for the base value (the part without prime p) for the entire number? No, we are handling prime by prime.\n\n              However, note: the entire number is the product over primes. We can compute the entire number by multiplying the primes raised to the assigned exponents.\n\n              But wait: the constraints are independent for each prime? Actually, yes. Because the gcd and lcm for the entire number is the product of the gcd and lcm for each prime.\n\n              However, we must ensure that the entire number is consistent. The assignment for each prime is independent.\n\n            Steps:\n\n              For each prime p (that appears in any edge's gcd or lcm, and also consider primes that are in the range [2, 10^6] but only those that appear in at least one edge? Actually, we can consider all primes up to 10^6, but that is too many (about 100000 primes). \n\n            Alternatively, we can extract the set of primes from the factorization of all gcd and lcm? But that is too heavy.\n\n            We need a better way.\n\n 7. Alternative Insight:\n\n        Since we know that for an edge (u, v) with (g, l), the product of the two numbers is g*l, and the gcd is g, we can set:\n\n            Let x = number at u, y = number at v.\n\n            Then, x and y must be divisors of g*l. Moreover, we have:\n\n                x * y = g * l\n                gcd(x, y) = g\n\n            Then, we can write x = g * a, y = g * b, and then a * b = l/g, and gcd(a, b) = 1.\n\n            So the entire number at node u is g * (a factor of l/g that is coprime to the other factor).\n\n        Now, note that the entire graph must satisfy for every edge (u, v): the product of the numbers is g*l (for that edge). But also, the gcd condition must hold.\n\n        How to assign the entire number?\n\n        We can do:\n\n            Let ans[i] be the number for node i.\n\n            We start by setting an array ans[0..n-1] = 1 for all nodes.\n\n            Then, for each edge (u, v, g, l):\n\n                Let product = g * l.\n\n                Then, the two numbers must multiply to product.\n\n                But note: the gcd condition: gcd(ans[u], ans[v]) = g.\n\n            However, we don't know the assignments yet.\n\n        Another approach: use the idea that the entire graph must have the property that for each prime p, the exponents are as described. But then we have to combine the primes.\n\n        Since the constraints per prime are independent, we can:\n\n            Step 1: Factorize the gcd and lcm for each edge? But that is too heavy (each gcd and lcm up to 10^6, and 10^5 edges, so 200000 factorizations, which is acceptable if we precompute smallest prime factors for numbers up to 10^6).\n\n        However, note: the problem says the numbers (gcd and lcm) are between 1 and 10^6, and there are up to 10^5 edges.\n\n        We can precompute the smallest prime factor (spf) for numbers up to 10^6.\n\n        Then, for each edge, we factorize the gcd and lcm to get the exponents for each prime.\n\n        Then, for each prime, we build a graph as described and check consistency.\n\n        Steps:\n\n          Precomputation: \n            Precompute spf for numbers up to 10^6.\n\n          Then, for each edge, factorize the gcd and lcm to get the exponents for each prime.\n\n          Then, for each prime p (that appears in any edge) we:\n\n            Initialize an array exp[0..n-1] to -1 (meaning unknown) for this prime.\n\n            For each edge (u, v, g, l):\n\n                Let e1 = exponent of p in g, e2 = exponent of p in l.\n\n                If e1 > e2: invalid, return \"NO\"\n\n                Then, we store the constraint for the edge (u, v) for prime p.\n\n            Then, we traverse the graph for prime p.\n\n            We'll use BFS/DFS to traverse the connected components.\n\n            But note: the constraints are of two types: fixed (when e1==e2) and variable (when e1 != e2).\n\n            We can do:\n\n              For edges of type fixed (e1==e2):\n\n                Then, we set the exponent for both u and v to e1 (if e1==0 then set to 0, but note: if e1==0, then it's fixed to 0).\n\n              For edges of type variable (e1 != e2, and we know e1<e2):\n\n                Then, we have two possibilities. But we can use the fixed nodes to determine the assignment.\n\n            However, we can use the following:\n\n              We'll do:\n\n                Let's create a graph for prime p with n nodes.\n\n                For each edge (u, v):\n\n                  If e1 == e2:\n                    Then, we require that exp[u] == exp[v] == e1 (if e1==0 then exp[u]=exp[v]=0)\n\n                  Else (e1 < e2):\n                    Then, we require that {exp[u], exp[v]} = {e1, e2}\n\n            But note: the graph might be disconnected.\n\n            We can do:\n\n              We'll maintain for each node two things: the exponent we have assigned, and also the possibility of two colors (like two sets) for the variable edges.\n\n            However, we can use a two-coloring for the variable edges? But note: the variable edge requires that the two endpoints have distinct exponents (from {e1, e2}). But also, if we have a fixed node, then we can assign the variable edge accordingly.\n\n            Steps for prime p:\n\n              We'll collect all edges that are fixed and variable.\n\n              First, we process the fixed edges: if two nodes are connected by fixed edges, then they must have the same exponent (which is the fixed value). So we can use union-find to group nodes that must have the same exponent.\n\n              Then, for each connected component (from fixed edges), we have a set of nodes that must have exponent = e (which is the fixed exponent for the fixed edges). But note: what if we have multiple fixed edges with different fixed exponents? Then it's invalid.\n\n              Example: \n                 Edge1: (u,v) with (g1, l1) for prime p: fixed exponent = 2.\n                 Edge2: (u,w) with (g2, l2) for prime p: fixed exponent = 3.\n                 Then u must be 2 and 3 -> conflict.\n\n              So we must check that within a connected component (by fixed edges) the fixed exponent is the same.\n\n              Then, after grouping by fixed edges, we have:\n\n                 Each node belongs to a component, and the component has a fixed exponent value (or if the component has no fixed edge, then we don't know).\n\n              Then, we process the variable edges (e1 < e2):\n\n                 For an edge (u, v) with variable constraint:\n\n                    Let comp_u = the component of u (from fixed edges), and comp_v = the component of v.\n\n                    There are several cases:\n\n                      Case 1: Both u and v are fixed (i.e., they belong to a fixed component with known exponent).\n\n                         Then, we require that the two fixed exponents are {e1, e2}. That is, {fixed_value[u], fixed_value[v]} = {e1, e2}. \n\n                         If not, then invalid.\n\n                      Case 2: One is fixed, the other is not.\n\n                         Then, the fixed one must be either e1 or e2.\n\n                         Without loss of generality, suppose fixed_value[u] is known.\n\n                            If fixed_value[u] == e1, then the other node v must be e2.\n                            If fixed_value[u] == e2, then the other node v must be e1.\n                            Otherwise, invalid.\n\n                      Case 3: Neither is fixed.\n\n                         Then, we can assign arbitrarily: one gets e1 and the other e2. But we must assign consistently with the entire connected component (via variable edges). \n\n                         However, note: the entire graph for prime p is built from fixed and variable edges. We can use BFS/DFS to assign the two exponents (0 and e2 for a Type C, or e1 and e2 for a Type D) in a bipartite manner.\n\n                         Actually, we can consider: the variable edges form a graph that must be bipartite, and the two parts get the two exponents.\n\n                         But note: the variable edge constraint is that the two endpoints must be the two different values (e1 and e2). So we can do a two-coloring (with two colors: color0 = e1, color1 = e2) and then if there is an odd cycle, then it's impossible.\n\n            However, note: the variable edges might connect multiple components. We can merge the components via the variable edges.\n\n            Steps for prime p:\n\n              Step 1: Group nodes by fixed edges (using union-find or BFS for fixed edges). For each fixed edge, we require the two nodes to be in the same component and have the same fixed exponent. We also check consistency: if two fixed edges in the same component have different exponents, then invalid.\n\n              Step 2: For variable edges, we build a graph that includes all nodes (even those not fixed) and connect them by variable edges. Then, we do a BFS/DFS to assign the two exponents (e1 and e2) to the two parts of the bipartite graph.\n\n              But note: the variable edges might connect two fixed components? Then we must check the fixed values.\n\n            Alternatively, we can do:\n\n              Build a graph for prime p that includes:\n\n                Nodes: all n nodes.\n\n                Edges:\n\n                  For fixed edges: we don't explicitly add edges, but we record the fixed exponent for each node (if any).\n\n                  For variable edges: add an edge between u and v.\n\n              Then, we traverse the graph (connected by variable edges) and do:\n\n                Let's define:\n\n                  state[node] = -1 (unvisited), 0 (assigned e1), 1 (assigned e2) for variable edges.\n\n                But wait: the fixed nodes might break the bipartite coloring.\n\n            Actually, we can do:\n\n              We'll do a BFS starting from a node that is not fixed (or if fixed, then check) and assign the variable edges.\n\n            Steps for one connected component (via variable edges) for prime p:\n\n              Let the component have a set of nodes.\n\n              We'll keep track of:\n\n                fixed_value[node] = the fixed exponent (if any) from fixed edges, otherwise None.\n\n              Then, we start BFS:\n\n                Queue q.\n\n                For each node in the component:\n\n                  If the node is fixed (fixed_value[node] is not None):\n\n                     Then, we check if fixed_value[node] is either e1 or e2.\n\n                     If not, invalid.\n\n                     Then, we know the color (if fixed_value[node] == e1, then color0; if e2, then color1).\n\n                  If the node is not fixed, then we can start by assigning one of them, say color0 (e1).\n\n                Then, for each edge (u, v) in the variable edges within the component, we require:\n\n                  If one node is fixed and the other is not: then the not fixed node must be the other exponent.\n\n                  If both are fixed: then the set of fixed exponents must be {e1, e2}.\n\n                  If none is fixed: then we assign the two colors (e1 and e2) alternatingly.\n\n              However, note: the entire component must be bipartite? Yes, because the variable edge requires the two endpoints to have different exponents (one e1, one e2). But wait: what if we have a triangle (three nodes) and the edge constraints are {e1, e2}? Then:\n\n                Node1: e1, Node2: e2, Node3: must be e1 (because edge1-3: {e1, e2} and Node1 is e1, so Node3 must be e2? -> no, then edge2-3: {e1, e2} and Node2 is e2, so Node3 must be e1 -> conflict.\n\n              Actually, the condition for a variable edge is that the two endpoints are the two distinct values. So the graph must be bipartite, and the two parts are assigned e1 and e2.\n\n              But note: the two values are fixed (e1 and e2). So we can assign:\n\n                Part0: e1, Part1: e2.\n\n              Then, if we have a triangle, the bipartite graph fails (because a triangle is not bipartite). Therefore, we must check for bipartiteness.\n\n            Algorithm for a connected component (via variable edges) for prime p:\n\n              Let graph_component = (V, E) where V is the set of nodes in the component (considering only variable edges) and E the variable edges.\n\n              We'll do:\n\n                Let color[node] = None for all nodes.\n\n                Start with a node s.\n\n                If s is fixed:\n\n                   color[s] = (fixed_value[s] == e1) ? 0 : 1   [but wait: what if fixed_value[s] is not e1 or e2? Then invalid.]\n\n                Else:\n\n                   color[s] = 0\n\n                Then, for each neighbor v of s in the graph_component:\n\n                   If fixed_value[v] is set:\n\n                      If fixed_value[v] == e1: then color[v] must be 0, and if fixed_value[v]==e2 then color[v] must be 1.\n\n                   Else:\n\n                      color[v] = 1 - color[s]\n\n                Then, if we find a contradiction (a fixed node that doesn't match, or an edge connecting two nodes of the same color), then invalid.\n\n            However, note: the variable edge constraint is that the two nodes must be {e1, e2}, so they must be different. Therefore, the bipartite graph must be properly colored with two colors.\n\n            But wait: what if the variable edge constraint is {0, e2} (Type C)? Then the two colors are 0 and 1, but the fixed_value might be 0 (which is e1) and then the other node must be e2 (which is the other color). Similarly, if the variable edge constraint is {e1, e2} (Type D), then same.\n\n            So we can use the same bipartite coloring regardless of the specific e1 and e2.\n\n            Steps for prime p:\n\n              Precompute fixed_value for each node from fixed edges.\n\n              Build a graph for variable edges (edges with e1 != e2, and e1<e2).\n\n              Then, for each connected component (via the variable edges) that has at least one variable edge:\n\n                Let S = set of nodes in the component.\n\n                We'll do BFS/DFS to color the graph with two colors.\n\n                During BFS:\n\n                  For a node u:\n\n                    If u is fixed, then we know its",
    "response": "\nTo solve this problem, we need to determine if it's possible to restore the number of mushrooms on each lawn (node) in a forest graph based on given roads (edges) that provide the greatest common divisor (GCD) and least common multiple (LCM) of the mushroom counts on the connected lawns. The solution involves verifying the consistency of these constraints across the entire graph and assigning mushroom counts accordingly.\n\n### Approach\n1. **Problem Analysis**:\n   - Each edge between two nodes (lawns) provides GCD and LCM values. The product of these values must equal the product of the mushroom counts on the connected nodes.\n   - For each edge, the GCD must divide both mushroom counts, and the LCM must be the smallest number that is a multiple of both counts.\n   - The solution requires checking these conditions for all edges and ensuring they are consistent across the graph.\n\n2. **Key Insights**:\n   - For each edge, the mushroom counts must satisfy `a * b = GCD * LCM` and `gcd(a, b) = GCD`, `lcm(a, b) = LCM`.\n   - The problem can be decomposed into handling each prime factor independently, leveraging the multiplicative properties of GCD and LCM.\n\n3. **Algorithm Selection**:\n   - **Prime Factorization**: For each edge, factorize the GCD and LCM to determine the exponents of each prime factor involved.\n   - **Graph Processing**: For each prime factor, model the constraints as a graph where nodes represent lawns and edges represent constraints on the exponents of the prime factor. Use BFS or DFS to check bipartiteness and assign exponents consistently.\n   - **Validation**: Ensure all constraints are satisfied for each prime factor across the graph. If any constraint is violated, the solution is impossible.\n\n4. **Complexity Analysis**:\n   - **Preprocessing**: Factorizing numbers up to 10^6 using the Sieve of Eratosthenes takes O(N log log N) time, where N is the maximum value (10^6).\n   - **Graph Processing**: For each edge and each prime factor, the BFS/DFS operations are linear in the number of nodes and edges, making the overall complexity manageable for the given constraints.\n\n### Solution Code\n```python\nimport sys\nfrom collections import deque\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    m = int(data[1])\n    edges = []\n    index = 2\n    for i in range(m):\n        u = int(data[index]); v = int(data[index+1]); g = int(data[index+2]); l = int(data[index+3])\n        index += 4\n        edges.append((u-1, v-1, g, l))\n    \n    max_val = 10**6\n    spf = list(range(max_val+1))\n    for i in range(2, int(max_val**0.5)+1):\n        if spf[i] == i:\n            for j in range(i*i, max_val+1, i):\n                if spf[j] == j:\n                    spf[j] = i\n\n    def factorize(x):\n        factors = {}\n        temp = x\n        while temp > 1:\n            p = spf[temp]\n            cnt = 0\n            while temp % p == 0:\n                cnt += 1\n                temp //= p\n            factors[p] = cnt\n        return factors\n\n    prime_edges = {}\n\n    for (u, v, g, l) in edges:\n        if g == 0 or l == 0:\n            continue\n        if g > l:\n            print(\"NO\")\n            return\n            \n        gcd_factors = factorize(g)\n        lcm_factors = factorize(l)\n        \n        all_primes_here = set(gcd_factors.keys()) | set(lcm_factors.keys())\n        for p in all_primes_here:\n            exp_g = gcd_factors.get(p, 0)\n            exp_l = lcm_factors.get(p, 0)\n            if exp_g > exp_l:\n                print(\"NO\")\n                return\n                \n            if p not in prime_edges:\n                prime_edges[p] = []\n            prime_edges[p].append((u, v, exp_g, exp_l))\n            \n    for p, constraints in prime_edges.items():\n        fixed_exponents = [-1] * n\n        comp_id = [-1] * n\n        comp_root = [i for i in range(n)]\n        comp_size = [1] * n\n        parent = list(range(n))\n        \n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n                \n        def union(x, y):\n            rx = find(x)\n            ry = find(y)\n            if rx == ry:\n                return False\n            if comp_size[rx] < comp_size[ry]:\n                parent[rx] = ry\n                comp_size[ry] += comp_size[rx]\n            else:\n                parent[ry] = rx\n                comp_size[rx] += comp_size[ry]\n            return True\n        \n        for (u, v, e1, e2) in constraints:\n            if e1 == e2:\n                if e1 == 0:\n                    fixed_exponents[u] = 0\n                    fixed_exponents[v] = 0\n                else:\n                    ru = find(u)\n                    rv = find(v)\n                    if ru != rv:\n                        if union(u, v):\n                            if fixed_exponents[u] != -1 and fixed_exponents[u] != e1:\n                                print(\"NO\")\n                                return\n                            if fixed_exponents[v] != -1 and fixed_exponents[v] != e1:\n                                print(\"NO\")\n                                return\n                    else:\n                        if fixed_exponents[u] != -1 and fixed_exponents[u] != e1:\n                            print(\"NO\")\n                            return\n                        if fixed_exponents[v] != -1 and fixed_exponents[v] != e1:\n                            print(\"NO\")\n                            return\n                    if fixed_exponents[u] == -1:\n                        fixed_exponents[u] = e1\n                    if fixed_exponents[v] == -1:\n                        fixed_exponents[v] = e1\n        \n        for (u, v, e1, e2) in constraints:\n            if e1 == e2:\n                continue\n            ru = find(u)\n            rv = find(v)\n            if ru != rv:\n                if e1 == 0 or e2 == 0:\n                    if fixed_exponents[u] != -1 and fixed_exponents[v] != -1:\n                        if {fixed_exponents[u], fixed_exponents[v]} != {0, max(e1, e2)}:\n                            print(\"NO\")\n                            return\n                    elif fixed_exponents[u] != -1:\n                        if fixed_exponents[u] != 0 and fixed_exponents[u] != max(e1, e2):\n                            print(\"NO\")\n                            return\n                        other = max(e1, e2)\n                        if fixed_exponents[v] != -1 and fixed_exponents[v] != other:\n                            print(\"NO\")\n                            return\n                    elif fixed_exponents[v] != -1:\n                        if fixed_exponents[v] != 0 and fixed_exponents[v] != max(e1, e2):\n                            print(\"NO\")\n                            return\n                        other = max(e1, e2)\n                        if fixed_exponents[u] != -1 and fixed_exponents[u] != other:\n                            print(\"NO\")\n                            return\n                    else:\n                        if e1 == 0:\n                            if fixed_exponents[u] != -1 or fixed_exponents[v] != -1:\n                                print(\"NO\")\n                                return\n                        else:\n                            pass\n                else:\n                    if fixed_exponents[u] != -1 and fixed_exponents[v] != -1:\n                        if {fixed_exponents[u], fixed_exponents[v]} != {e1, e2}:\n                            print(\"NO\")\n                            return\n                    elif fixed_exponents[u] != -1:\n                        if fixed_exponents[u] != e1 and fixed_exponents[u] != e2:\n                            print(\"NO\")\n                            return\n                        other = e1 + e2 - fixed_exponents[u]\n                        if fixed_exponents[v] != -1 and fixed_exponents[v] != other:\n                            print(\"NO\")\n                            return\n                    elif fixed_exponents[v] != -1:\n                        if fixed_exponents[v] != e1 and fixed_exponents[v] != e2:\n                            print(\"NO\")\n                            return\n                        other = e1 + e2 - fixed_exponents[v]\n                        if fixed_exponents[u] != -1 and fixed_exponents[u] != other:\n                            print(\"NO\")\n                            return\n                    else:\n                        if e1 != e2:\n                            pass\n                        else:\n                            print(\"NO\")\n                            return\n                if find(u) != find(v):\n                    union(u, v)\n        \n        for p in prime_edges:\n            graph = [[] for _ in range(n)]\n            for (u, v, e1, e2) in prime_edges[p]:\n                if e1 != e2:\n                    graph[u].append(v)\n                    graph[v].append(u)\n                    \n            visited = [False] * n\n            colors = [-1] * n\n            valid_component = True\n            \n            for i in range(n):\n                if not visited[i] and (fixed_exponents[i] == -1):\n                    queue = deque([i])\n                    visited[i] = True\n                    colors[i] = 0\n                    while queue:\n                        node = queue.popleft()\n                        for neighbor in graph[node]:\n                            if not visited[neighbor]:\n                                visited[neighbor] = True\n                                colors[neighbor] = 1 - colors[node]\n                                queue.append(neighbor)\n                            else:\n                                if colors[node] == colors[neighbor]:\n                                    valid_component = False\n                                    break\n                        if not valid_component:\n                            break\n                    if not valid_component:\n                        break\n                        \n            if not valid_component:\n                print(\"NO\")\n                return\n                \n    ans = [1] * n\n    for i in range(n):\n        num = 1\n        for p in prime_edges:\n            exp = fixed_exponents[i]\n            if exp != -1:\n                power = 1\n                temp = p\n                for _ in range(exp):\n                    power *= temp\n                num *= power\n        ans[i] = num\n\n    print(\"YES\")\n    print(\" \".join(map(str, ans)))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Prime Factorization**: The code first preprocesses the smallest prime factors (SPF) for numbers up to 10^6 using the Sieve of Eratosthenes. This allows efficient factorization of GCD and LCM values for each edge.\n2. **Constraint Handling**: For each edge, the code checks if the GCD and LCM are consistent (i.e., GCD ≤ LCM). It then decomposes the problem into handling each prime factor separately.\n3. **Union-Find for Fixed Exponents**: For each prime factor, the code uses a union-find data structure to group nodes that must have the same exponent (based on fixed constraints from edges where GCD equals LCM).\n4. **Bipartite Graph Check**: For edges where GCD ≠ LCM, the code checks if the graph formed by these edges is bipartite. This ensures that the exponents can be assigned alternately (like a two-coloring) without conflicts.\n5. **Solution Construction**: Finally, the code constructs the mushroom counts by multiplying the prime factors raised to their respective exponents, ensuring all constraints are satisfied. If any step fails, it outputs \"NO\"; otherwise, it outputs \"YES\" followed by the mushroom counts.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import deque\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    m = int(data[1])\n    edges = []\n    index = 2\n    for i in range(m):\n        u = int(data[index]); v = int(data[index+1]); g = int(data[index+2]); l = int(data[index+3])\n        index += 4\n        edges.append((u-1, v-1, g, l))\n    \n    max_val = 10**6\n    spf = list(range(max_val+1))\n    for i in range(2, int(max_val**0.5)+1):\n        if spf[i] == i:\n            for j in range(i*i, max_val+1, i):\n                if spf[j] == j:\n                    spf[j] = i\n\n    def factorize(x):\n        factors = {}\n        temp = x\n        while temp > 1:\n            p = spf[temp]\n            cnt = 0\n            while temp % p == 0:\n                cnt += 1\n                temp //= p\n            factors[p] = cnt\n        return factors\n\n    prime_edges = {}\n\n    for (u, v, g, l) in edges:\n        if g == 0 or l == 0:\n            continue\n        if g > l:\n            print(\"NO\")\n            return\n            \n        gcd_factors = factorize(g)\n        lcm_factors = factorize(l)\n        \n        all_primes_here = set(gcd_factors.keys()) | set(lcm_factors.keys())\n        for p in all_primes_here:\n            exp_g = gcd_factors.get(p, 0)\n            exp_l = lcm_factors.get(p, 0)\n            if exp_g > exp_l:\n                print(\"NO\")\n                return\n                \n            if p not in prime_edges:\n                prime_edges[p] = []\n            prime_edges[p].append((u, v, exp_g, exp_l))\n            \n    for p, constraints in prime_edges.items():\n        fixed_exponents = [-1] * n\n        comp_id = [-1] * n\n        comp_root = [i for i in range(n)]\n        comp_size = [1] * n\n        parent = list(range(n))\n        \n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n                \n        def union(x, y):\n            rx = find(x)\n            ry = find(y)\n            if rx == ry:\n                return False\n            if comp_size[rx] < comp_size[ry]:\n                parent[rx] = ry\n                comp_size[ry] += comp_size[rx]\n            else:\n                parent[ry] = rx\n                comp_size[rx] += comp_size[ry]\n            return True\n        \n        for (u, v, e1, e2) in constraints:\n            if e1 == e2:\n                if e1 == 0:\n                    fixed_exponents[u] = 0\n                    fixed_exponents[v] = 0\n                else:\n                    ru = find(u)\n                    rv = find(v)\n                    if ru != rv:\n                        if union(u, v):\n                            if fixed_exponents[u] != -1 and fixed_exponents[u] != e1:\n                                print(\"NO\")\n                                return\n                            if fixed_exponents[v] != -1 and fixed_exponents[v] != e1:\n                                print(\"NO\")\n                                return\n                    else:\n                        if fixed_exponents[u] != -1 and fixed_exponents[u] != e1:\n                            print(\"NO\")\n                            return\n                        if fixed_exponents[v] != -1 and fixed_exponents[v] != e1:\n                            print(\"NO\")\n                            return\n                    if fixed_exponents[u] == -1:\n                        fixed_exponents[u] = e1\n                    if fixed_exponents[v] == -1:\n                        fixed_exponents[v] = e1\n        \n        for (u, v, e1, e2) in constraints:\n            if e1 == e2:\n                continue\n            ru = find(u)\n            rv = find(v)\n            if ru != rv:\n                if e1 == 0 or e2 == 0:\n                    if fixed_exponents[u] != -1 and fixed_exponents[v] != -1:\n                        if {fixed_exponents[u], fixed_exponents[v]} != {0, max(e1, e2)}:\n                            print(\"NO\")\n                            return\n                    elif fixed_exponents[u] != -1:\n                        if fixed_exponents[u] != 0 and fixed_exponents[u] != max(e1, e2):\n                            print(\"NO\")\n                            return\n                        other = max(e1, e2)\n                        if fixed_exponents[v] != -1 and fixed_exponents[v] != other:\n                            print(\"NO\")\n                            return\n                    elif fixed_exponents[v] != -1:\n                        if fixed_exponents[v] != 0 and fixed_exponents[v] != max(e1, e2):\n                            print(\"NO\")\n                            return\n                        other = max(e1, e2)\n                        if fixed_exponents[u] != -1 and fixed_exponents[u] != other:\n                            print(\"NO\")\n                            return\n                    else:\n                        if e1 == 0:\n                            if fixed_exponents[u] != -1 or fixed_exponents[v] != -1:\n                                print(\"NO\")\n                                return\n                        else:\n                            pass\n                else:\n                    if fixed_exponents[u] != -1 and fixed_exponents[v] != -1:\n                        if {fixed_exponents[u], fixed_exponents[v]} != {e1, e2}:\n                            print(\"NO\")\n                            return\n                    elif fixed_exponents[u] != -1:\n                        if fixed_exponents[u] != e1 and fixed_exponents[u] != e2:\n                            print(\"NO\")\n                            return\n                        other = e1 + e2 - fixed_exponents[u]\n                        if fixed_exponents[v] != -1 and fixed_exponents[v] != other:\n                            print(\"NO\")\n                            return\n                    elif fixed_exponents[v] != -1:\n                        if fixed_exponents[v] != e1 and fixed_exponents[v] != e2:\n                            print(\"NO\")\n                            return\n                        other = e1 + e2 - fixed_exponents[v]\n                        if fixed_exponents[u] != -1 and fixed_exponents[u] != other:\n                            print(\"NO\")\n                            return\n                    else:\n                        if e1 != e2:\n                            pass\n                        else:\n                            print(\"NO\")\n                            return\n                if find(u) != find(v):\n                    union(u, v)\n        \n        for p in prime_edges:\n            graph = [[] for _ in range(n)]\n            for (u, v, e1, e2) in prime_edges[p]:\n                if e1 != e2:\n                    graph[u].append(v)\n                    graph[v].append(u)\n                    \n            visited = [False] * n\n            colors = [-1] * n\n            valid_component = True\n            \n            for i in range(n):\n                if not visited[i] and (fixed_exponents[i] == -1):\n                    queue = deque([i])\n                    visited[i] = True\n                    colors[i] = 0\n                    while queue:\n                        node = queue.popleft()\n                        for neighbor in graph[node]:\n                            if not visited[neighbor]:\n                                visited[neighbor] = True\n                                colors[neighbor] = 1 - colors[node]\n                                queue.append(neighbor)\n                            else:\n                                if colors[node] == colors[neighbor]:\n                                    valid_component = False\n                                    break\n                        if not valid_component:\n                            break\n                    if not valid_component:\n                        break\n                        \n            if not valid_component:\n                print(\"NO\")\n                return\n                \n    ans = [1] * n\n    for i in range(n):\n        num = 1\n        for p in prime_edges:\n            exp = fixed_exponents[i]\n            if exp != -1:\n                power = 1\n                temp = p\n                for _ in range(exp):\n                    power *= temp\n                num *= power\n        ans[i] = num\n\n    print(\"YES\")\n    print(\" \".join(map(str, ans)))\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 553,
        "completion_token_count": 2495,
        "thoughts_token_count": 8191
    }
}