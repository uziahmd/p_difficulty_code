{
    "start": 1758308581.1290336,
    "end": 1758311988.956573,
    "start-formatted": "2025-09-20 04:03 KST",
    "end-formatted": "2025-09-20 04:59 KST",
    "gpu": 2,
    "pid": 30,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# TV Game\n\nThere is a new TV game on BerTV. In this game two players get a number A consisting of 2n digits. Before each turn players determine who will make the next move. Each player should make exactly n moves. On it's turn i-th player takes the leftmost digit of A and appends it to his or her number Si. After that this leftmost digit is erased from A. Initially the numbers of both players (S1 and S2) are «empty». Leading zeroes in numbers A, S1, S2 are allowed. In the end of the game the first player gets S1 dollars, and the second gets S2 dollars.One day Homer and Marge came to play the game. They managed to know the number A beforehand. They want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize. Help them.\n\n## Input\nThe first line contains integer n (1 ≤ n ≤ 18). The second line contains integer A consisting of exactly 2n digits. This number can have leading zeroes.\n\n## Output\nOutput the line of 2n characters «H» and «M» — the sequence of moves of Homer and Marge, which gives them maximum possible total prize. Each player must make exactly n moves. If there are several solutions, output any of them.\n\n## Example\n### Input\n['2\\n1234', '2\\n9911']\n\n### Output\n['HHMM', 'HMHM']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a moderately difficult question."
        }
    ],
    "thought": "\n Okay, we are given an integer n (1 <= n <= 18) and a string A of exactly 2n digits.\n We have two players, Homer (H) and Marge (M). Each makes exactly n moves.\n In each move, the current player takes the leftmost digit of A and appends it to their own number.\n\n The goal is to maximize the total prize: S1 (Homer's number) + S2 (Marge's number).\n\n However, note that the sequence of moves matters. At each turn, one player is chosen to go first, then the other, and so on for 2n moves.\n\n But note: the problem says \"before each turn players determine who will make the next move\". So we can choose the order arbitrarily as long as each player makes exactly n moves.\n\n Since the entire game has 2n moves, and each player must move n times, the sequence will be a string of length 2n containing n 'H's and n 'M's.\n\n How do we think about the problem?\n\n Let the original number A be represented as a string of 2n digits.\n\n The process:\n   Initially: S1 = \"\", S2 = \"\", A = [d0, d1, ..., d_{2n-1}]\n   Then, for each move, we remove the leftmost digit and assign it to one of the players.\n\n After all moves, we have two numbers: \n   S1 is the concatenation of the digits taken by Homer in the order they were taken (so if Homer took the first digit, then the third, then the fifth, etc., then S1 would be \"d0\" + \"d2\" + \"d4\", but note: the moves are sequential and the digits are taken from the front of A, so the relative order in S1 is the order of the moves when it was Homer's turn)\n\n Similarly for S2.\n\n The value of S1 is computed by interpreting the string of digits (which may include leading zeros) as a decimal number. Same for S2.\n\n We wish to maximize (value(S1) + value(S2)).\n\n Note: the entire set of digits is fixed. The catch: which digits go to which player.\n\n However, note that the assignment of digits to players is not independent of the order because the digits are taken from the front.\n\n Actually, the entire sequence of digits is predetermined: the first digit is always the first one in A, then the second, etc.\n\n But the ownership (which player gets which digit) is determined by the sequence of moves.\n\n Let the sequence of moves be a string s of length 2n, containing n H's and n M's.\n\n Then, the i-th digit (0-indexed) of A goes to:\n   s[i] if we consider that at step i (from 0 to 2n-1) we take the i-th digit and assign it to the player corresponding to s[i].\n\n Then, the number for Homer is formed by taking the digits at positions i where s[i]=='H', in increasing order of i (because the moves happen in order and we take the leftmost remaining digit each time).\n Similarly for Marge.\n\n But note: the digits are taken from the front, so the i-th digit in A is taken at move i, and assigned to the player whose turn it is.\n\n Therefore, the two numbers are built by:\n\n   S1 = \"\"\n   S2 = \"\"\n   For i from 0 to 2n-1:\n        if s[i] == 'H': append A[i] to S1\n        else: append A[i] to S2\n\n Then the value of S1 is the integer value of the string S1 (which might have leading zeros, so we interpret as base-10 with the string representation).\n\n However, note: the integer value of a string with leading zeros is just the number. But the problem allows leading zeros.\n\n But wait: the problem says \"Leading zeroes in numbers A, S1, S2 are allowed.\"\n\n So we are to compute the numerical value of the string of digits (with base 10) even if there are leading zeros.\n\n Example: \n   Input: n=2, A=\"1234\"\n   One solution: \"HHMM\"\n\n   Then:\n        Move0: H takes '1' -> S1 = \"1\", S2 = \"\"\n        Move1: H takes '2' -> S1 = \"12\", S2 = \"\"\n        Move2: M takes '3' -> S1 = \"12\", S2 = \"3\"\n        Move3: M takes '4' -> S1 = \"12\", S2 = \"34\"\n\n   Total prize = 12 + 34 = 46.\n\n   Another solution: \"HMHM\"\n\n        Move0: H takes '1' -> S1 = \"1\"\n        Move1: M takes '2' -> S2 = \"2\"\n        Move2: H takes '3' -> S1 = \"13\"\n        Move3: M takes '4' -> S2 = \"24\"\n\n        Total prize = 13 + 24 = 37.\n\n   And the example output for the second input is \"HMHM\", but note the example input was ['2\\n9911'] and output ['HMHM'].\n\n   Let me check with A='9911' and n=2:\n\n        Sequence \"HMHM\":\n            Move0: H takes '9' -> S1=\"9\"\n            Move1: M takes '9' -> S2=\"9\"\n            Move2: H takes '1' -> S1=\"91\"\n            Move3: M takes '1' -> S2=\"91\"\n            Total prize = 91 + 91 = 182.\n\n        Alternatively, what if we use \"HM HM\" (same as above) vs \"HHMM\":\n\n            \"HHMM\": \n                S1 = \"99\", S2 = \"11\" -> 99+11 = 110.\n\n        But wait, why is the example output \"HMHM\" for input \"9911\"?\n\n        Actually, the example input is provided as two examples:\n\n          Example 1: Input: \n              2\n              1234\n          Output: \n              HHMM\n\n          Example 2: Input:\n              2\n              9911\n          Output:\n              HMHM\n\n        Why for 1234 the answer is HHMM? Because 12+34=46 is better than 13+24=37.\n\n        Why for 9911 the answer is HMHM? Because 91+91=182 is better than 99+11=110.\n\n        So the problem is: we need to assign the digits to the two players (via choosing the order) such that the sum of the two numbers (each being the digits taken in the order they were taken) is maximized.\n\n How to solve?\n\n We have 2n moves, and we must assign exactly n to H and n to M.\n\n The value of the two numbers depends on the order of assignment. Note that the digits are fixed in the order of A.\n\n We can think of the problem as: we have a fixed list of 2n digits. We want to split this list into two subsequences (preserving the original order) of length n, and we wish to maximize the sum of the two numbers formed by these subsequences.\n\n However, note: the two numbers are formed by the digits in the order they appear in A. That is, the first digit taken by a player becomes the most significant digit of that player's number.\n\n This is similar to: we have two numbers, and we are building them by taking the digits from the front. The catch: we can interleave arbitrarily.\n\n We wish to maximize:\n   Let X = the number formed by the digits assigned to H (in the order of appearance)\n   Let Y = the number formed by the digits assigned to M (in the order of appearance)\n\n Then total = X + Y.\n\n How to assign the digits optimally?\n\n Observation: \n   The first digit (the very first one) will be assigned to either H or M. If we assign the first digit to H, then the number for H will have that digit as the most significant. Similarly for M.\n\n   However, if we assign the first digit to H, then the rest of the digits (for both players) will be shifted one position to the right in terms of significance for the subsequent moves? Not exactly, because the next digit is the second one, and so on.\n\n   But note: the entire sequence of digits is fixed. We cannot change the order of digits, only assign ownership.\n\n   This is similar to forming two numbers from a fixed sequence of digits (without reordering) and we wish to maximize the sum.\n\n   However, note: the two numbers are built by interleaving the digits. The first digit goes to one of the numbers, the second to the other or same, etc.\n\n   We can use dynamic programming.\n\n   Let dp[i][j] be the maximum difference (or the maximum total value?) we can achieve after processing the first i+j digits, having assigned j digits to M (and hence i digits to H), and also keeping track of the current state of the two numbers? \n\n   But note: the numbers are built by the digits in the order they appear, and the digits have different place values.\n\n   Alternatively, note that the total value of the two numbers is:\n\n        X + Y = ?\n\n   We can break down by digit positions. The k-th digit (from left, 0-indexed) in A has a place value of 10^(2n-1-k). \n\n   But wait: when we assign a digit to a player, that digit will be placed at a certain position in that player's number. However, the position in the player's number depends on the order of moves for that player.\n\n   For example, if a player takes the first digit, then the next digit they take is the next available (which is later in the sequence) and that becomes the next more significant digit? Actually, no: the first digit taken by a player is the most significant. Then the next one is less significant.\n\n   Actually, the entire process:\n\n        Let the moves be represented by a string s of length 2n.\n\n        Then, the number for H is built by taking the digits at positions i (in increasing order) and the significance of the j-th digit taken by H is 10^(n - j - 1) (if we consider the number as having n digits).\n\n        Similarly for M.\n\n   Alternatively, we can consider the entire set of 2n digits and assign them to two numbers, and the assignment must preserve the original order (each number's digits are in the original order). Then, the value of a number built from a subsequence of length n is:\n\n        Let the subsequence for H be d_{i1}, d_{i2}, ... , d_{in} (with i1 < i2 < ... < in). Then the value is:\n            d_{i1} * 10^(n-1) + d_{i2} * 10^(n-2) + ... + d_{in} * 10^0.\n\n   Similarly for M.\n\n   Therefore, the total value is the sum over the two subsequences.\n\n   Now, note: we can assign each digit to either H or M, but the condition is that we assign exactly n to each, and the two subsequences must be increasing in indices.\n\n   Then, the problem becomes: split the 2n-digit string into two increasing subsequences (each of length n) so that the sum of the two numbers (as defined above) is maximized.\n\n   How to compute this?\n\n   We can use DP with state (i, j) meaning we have processed up to index i (so i digits processed) and we have assigned j digits to M (then H has i-j digits). Then we need to keep track of the actual numbers? But the numbers can be very large (n up to 18, so 18 digits -> numbers up to 10^18, which is too big to store as integers in a DP state).\n\n   Alternatively, we can use digit DP that considers the contributions of the digits to the two numbers.\n\n   Let's define:\n\n        dp[i][j] = the maximum total value (X + Y) we can achieve from the first i+j digits, having assigned j digits to M (and i digits to H). But wait, i+j is the index we are at (we've processed i+j digits). We need to know the exact assignment to compute the value.\n\n   Alternatively, we can consider the contribution of each digit. The k-th digit (0-indexed) in A is going to be multiplied by a power of 10 that depends on how many digits remain to be assigned to the same player after it.\n\n   However, we don't know the future.\n\n   Another idea: since n is at most 18, the total length is 36. We can try to use DP that goes digit by digit and assigns each digit to either H or M, but we have to keep track of the counts and the current \"length\" of each number (because the place value of a digit depends on how many digits are already assigned to that player).\n\n   Let dp[i][a][b] be the maximum total value (X+Y) from the first i digits, where a is the number of digits assigned to H so far, and b is the number of digits assigned to M so far. Then we require a+b=i, and we must have a<=n, b<=n.\n\n   Then, for the next digit (the i-th digit, 0-indexed), we can assign it to H (if a < n) or to M (if b < n).\n\n   How does assigning a digit to a player affect the total value?\n\n        When we assign the digit d (converted to integer) to a player, then in the final number, this digit will be placed at the position (count of digits already assigned to that player) from the left. The place value is 10^(remaining_digits_in_that_player) ? \n\n        Actually, the entire number for a player has n digits. The first digit assigned to the player is multiplied by 10^(n-1), the second by 10^(n-2), etc.\n\n        So if we are assigning a digit to a player, and the player has already been assigned k digits, then this digit will be multiplied by 10^(n - (k+1)).\n\n        But wait: the total value for the two numbers is the sum of the two. \n\n        However, we can break the total value as:\n\n            Total = (value of H) + (value of M)\n\n            The value of H is: for each digit d assigned to H at step j (0-indexed in the assignment order for H) -> d * (10^(n - j - 1))\n\n        So if we assign a digit to H now, and currently H has a digits (so j = a, because we are going to assign this as the (a+1)-th digit for H), then its contribution is d * (10^(n - a - 1)).\n\n        Similarly, if we assign to M, then its contribution is d * (10^(n - b - 1)).\n\n        But note: the same digit d is assigned to one of the players, and the two players are independent.\n\n        However, we are building two numbers simultaneously.\n\n        Then, the recurrence:\n\n            dp[i][a][b] = maximum total value from the first i digits (where i = a+b) such that we have a assignments to H and b to M.\n\n            Then, for the next digit (the i-th digit, which is the (a+b)-th digit in the sequence) we have two choices:\n\n                Option1: Assign to H (if a < n)\n                    Then the new state is (i+1, a+1, b)\n                    The value added by this digit is: d_i * (10^(n - a - 1))   [because in the final number, this digit will be the (a+1)-th digit for H, so it has exponent (n - (a+1))]\n\n                Option2: Assign to M (if b < n)\n                    Then the new state is (i+1, a, b+1)\n                    The value added by this digit is: d_i * (10^(n - b - 1))\n\n            Then:\n                dp[i][a][b] = max( \n                    (if a < n: dp[i+1][a+1][b] + d_i * (10**(n - a - 1))),\n                    (if b < n: dp[i+1][a][b+1] + d_i * (10**(n - b - 1)))\n                )\n\n        Base case: when i = 2n, then we must have a=n and b=n, and the total value is 0.\n\n        Then we can work backwards.\n\n        However, note: the exponent base: the first digit assigned to a player (when a=0) will be multiplied by 10^(n-1), the next by 10^(n-2), etc.\n\n        But wait: the entire number for H is built from the digits assigned to H, and the first digit assigned is the most significant (so it should be multiplied by 10^(n-1)), the second by 10^(n-2)), etc.\n\n        So for the (k)-th digit assigned to H (0-indexed, k from 0 to n-1) we multiply by 10^(n-1-k).\n\n        In our recurrence, when we are at state (i, a, b) and we assign the next digit to H, then the current count for H is a (so we are going to assign the (a+1)-th digit to H). Then the exponent is (n - (a+1))? \n\n        Actually, if we have already assigned a digits to H, then the next digit for H (the (a+1)-th) will be the (a+1)-th most significant digit, so it should be multiplied by 10^(n - (a+1)).\n\n        But note: the total number of digits for H is n, so the exponents for H are from 10^(n-1) down to 10^0.\n\n        The last digit (the n-th) for H is multiplied by 10^0.\n\n        So the (a+1)-th digit is the (a+1)-th most significant, so it is at exponent (n - (a+1)): \n            exponent = n - 1 - a   ??? \n\n        Let me check: \n            a=0: first digit -> exponent = n-1 (correct)\n            a=1: second digit -> exponent = n-2 (correct)\n            ...\n            a=k: (k+1)-th digit -> exponent = n - (k+1) = n-1 - k.\n\n        So we can write: for a digit assigned to H at state (i, a, b) (so we are going to assign the (a+1)-th digit to H) the multiplier is 10^(n-1-a).\n\n        Similarly, for M: multiplier is 10^(n-1-b).\n\n        Therefore, the recurrence:\n\n            dp[i][a][b] = maximum of:\n                Option1: if a < n, then \n                    value1 = dp[i+1][a+1][b] + int(A[i]) * (10 ** (n-1-a))\n                Option2: if b < n, then \n                    value2 = dp[i+1][a][b+1] + int(A[i]) * (10 ** (n-1-b))\n\n            Then dp[i][a][b] = max(value1, value2)   (if both options are available, otherwise the one available)\n\n        However, note: the state (i, a, b) must satisfy i = a+b, and we are iterating from i=2n-1 down to 0.\n\n        The state space: i from 0 to 2n (so 2n+1 states), a from 0 to n, b from 0 to n, and i = a+b. So the total states are (n+1)*(n+1) for each i, but i = a+b, so we can iterate by i from 0 to 2n, and for each i, a from 0 to min(i, n) and b = i - a, but we must have b<=n.\n\n        Actually, we can let i from 0 to 2n, and a from 0 to min(i, n), then b = i - a, and we require b<=n (which is equivalent to a>= i-n, but i<=2n and a>=0, so we require a from max(0, i-n) to min(i, n)).\n\n        But note: the exponent calculation uses n and a (for H) and n and b (for M). \n\n        However, we have to be cautious: the exponent for H depends on the total count for H (a) and the digit we are assigning is the (a+1)-th for H, so we use (n-1-a). Similarly for M.\n\n        But note: the digit we are assigning is the (i)-th digit in A (0-indexed) and we are at state (i, a, b) meaning we have processed i digits (which is a+b) and we are going to assign the next digit (the i-th digit) to either H or M.\n\n        Wait, no: in our recurrence above, we are processing the i-th digit (the next one) and we are at state (i, a, b) which means we have processed i digits (so we are at the (i+1)-th digit to assign?).\n\n        Let me redefine the state:\n\n            Let dp[i][a][b] be the maximum total value from the first i digits (so we have processed i digits, and we have a for H and b for M, so i = a+b).\n\n            Then, we are at the (i+1)-th digit (index i in the string A, because A[0] is the first digit).\n\n            Then, we assign the i-th digit (0-indexed, so the next digit) to H or M.\n\n            Then, the value for that digit if assigned to H is: int(A[i]) * (10 ** (n-1 - a))   [because we are going to have a+1 digits for H, so the next digit is the (a+1)-th, and the exponent is (n-1 - (a+1) + 1)? \n\n            Actually, wait: the exponent for the (a+1)-th digit for H is (n - (a+1)) in terms of the power? \n\n            Let me clarify: \n                The H number has n digits. The first digit (assigned first) is the most significant, so it is multiplied by 10^(n-1). \n                The second by 10^(n-2), ... the last by 10^0.\n\n            So if we are about to assign the (a+1)-th digit to H, then it is the (a+1)-th digit from the beginning (so the (a+1)-th most significant) and its exponent is 10^(n-1 - a) (because the first digit: a=0 -> exponent n-1, second: a=1 -> exponent n-2, ...).\n\n            Similarly for M.\n\n            Then the recurrence:\n\n                dp[i][a][b] = max(\n                    (if a < n: dp[i+1][a+1][b] + int(A[i]) * (10**(n-1-a)),\n                    (if b < n: dp[i+1][a][b+1] + int(A[i]) * (10**(n-1-b))\n                )\n\n        But note: the state (i, a, b) must be computed from states (i+1, a+1, b) and (i+1, a, b+1). We can iterate i from 2n-1 down to 0.\n\n        However, note: the exponent base: 10**something. Since n<=18, the exponents go up to 10^17, which is a very big number, but Python can handle integers.\n\n        But wait: the total value might be huge, but we are only storing the maximum value for the state.\n\n        However, the state space is (2n+1) * (n+1) * (n+1) which is about 37*19*19 ~ 13000 states. This is acceptable.\n\n        Steps:\n\n            n = int(input().strip())\n            A = input().strip()   # string of 2n digits\n\n            Let dp be a 3D array: dp[i][a][b] for i from 0 to 2n, a from 0 to n, b from 0 to n.\n\n            Alternatively, we can use memoization and recursion, but iterative is easier.\n\n            Alternatively, we can use two 2D arrays: dp_current and dp_next, but we need to iterate from the end.\n\n            We'll do:\n\n                dp[i][a][b] = maximum total value from the state (i, a, b) to the end.\n\n                i ranges from 0 to 2n (we consider i from 0 to 2n-1, and the base case at i=2n)\n\n            Base case: when i = 2n, then we have processed all digits. Then we require a==n and b==n, then dp[2n][n][n] = 0. Otherwise, it's invalid.\n\n            Then, for i from 2n-1 down to 0, and for a from max(0, i-(2n-n)) to min(i, n) [but actually, b = i - a, and we require b<=n and a<=n, so a from max(0, i-n) to min(i, n)].\n\n            However, we can simply iterate a from 0 to min(i, n) and set b = i - a, and then check that b <= n.\n\n            But note: i = a+b, and we must have a<=n and b<=n, so i = a+b <= 2n, and we are going from 0 to 2n.\n\n            Algorithm:\n\n                dp = a 3D array of dimensions [2n+1][n+1][n+1] (we can use a dictionary or a list of lists)\n\n                for i from 2n down to 0:\n                    for a from max(0, i-n) to min(i, n):\n                        b = i - a\n                        if a > n or b > n: skip (but our loop condition ensures a<=n and b<=n? Actually, we require a<=n and b<=n, and i=a+b, so if i>n+n, then we don't consider, but i<=2n, and we start from 2n down to 0, so we consider i from 0 to 2n.\n\n                Actually, we can do:\n\n                    for i from 2n down to 0:\n                        for a from 0 to min(i, n):\n                            b = i - a\n                            if b > n: continue   # because we require b<=n, so if b>n, then skip.\n\n                Then, if i == 2n:\n                    if a==n and b==n: dp[i][a][b] = 0\n                    else: dp[i][a][b] = -infinity (or skip, but we don't need to compute)\n\n                But note: we are going backwards, so we start from i=2n and go to i=0.\n\n                Then, for each state (i, a, b):\n\n                    if a < n and b < n:\n                        option1 = dp[i+1][a+1][b] + int(A[i]) * (10**(n-1-a))\n                        option2 = dp[i+1][a][b+1] + int(A[i]) * (10**(n-1-b))\n                        dp[i][a][b] = max(option1, option2)\n\n                    elif a < n:\n                        dp[i][a][b] = dp[i+1][a+1][b] + int(A[i]) * (10**(n-1-a))\n\n                    elif b < n:\n                        dp[i][a][b] = dp[i+1][a][b+1] + int(A[i]) * (10**(n-1-b))\n\n                    else: \n                        # This state is terminal? Actually, we should have a+b=i, and if a==n and b==n then i=2n, so we are at base case. Otherwise, if we have a==n and b==n and i<2n, then it's invalid. But we skip states with b>n, so if we get here, then a>n or b>n, but we skipped those.\n\n            Then, we start from state (0,0,0) and the value is dp[0][0][0]. But we are interested in the sequence of moves.\n\n            However, the problem requires: output the sequence of moves (a string of 2n characters, with n H's and n M's) that achieves the maximum total prize.\n\n            We can record the choices we made in the DP.\n\n            We can do:\n\n                dp[i][a][b] = (max_value, next_move)   or we can store separately the path.\n\n            Alternatively, we can do:\n\n                Let dp[i][a][b] = the maximum total value from state (i, a, b) to the end.\n\n                Let choice[i][a][b] = either 'H' or 'M' for the move at the i-th digit (the next one), or None if we are at the base case.\n\n            Then, after filling dp, we can backtrack from (0,0,0) to (2n, n, n) by:\n\n                current_i = 0, current_a = 0, current_b = 0\n                s = []   # list of moves\n\n                while current_i < 2n:\n                    if a_choice[current_i][a] is 'H' or 'M' (from the dp table), then we append that and update the state.\n\n            But note: we are storing the move at state (i, a, b) for the next digit (the i-th digit, which is A[i]).\n\n            Alternatively, we can store:\n\n                dp[i][a][b] = (max_value, move)   where move is the choice for the i-th digit (if any) and then we know the next state.\n\n            However, the state space is 13000 states, and we want to store the move for each state.\n\n            Steps for backtracking:\n\n                We'll create a 3D array (or dictionary) for the move at each state.\n\n                Then, starting at (0,0,0), we look at:\n\n                    If we choose 'H', then the next state is (i+1, a+1, b) and the value is dp[i][a][b] (which we stored) and the move is 'H'\n\n                    Similarly for 'M'.\n\n                But wait, we computed the dp value from the next state and the current digit's contribution. So we can store:\n\n                    dp[i][a][b] = (max_value, choice)   where choice is either 'H' or 'M'\n\n                Then, we can reconstruct the entire sequence.\n\n            However, note: the problem says \"If there are several solutions, output any of them.\"\n\n            Implementation:\n\n                We'll create two 3D arrays: dp_value[i][a][b] and dp_move[i][a][b]\n\n                Steps:\n\n                    Initialize dp_value[2n][n][n] = 0, and for other states at i=2n, we don't use.\n\n                    Then for i from 2n-1 down to 0:\n\n                        for a from max(0, i-n) to min(i, n):\n\n                            b = i - a\n\n                            if a < n and b < n:\n                                candidate1 = dp_value[i+1][a+1][b] + int(A[i]) * (10**(n-1-a))\n                                candidate2 = dp_value[i+1][a][b+1] + int(A[i]) * (10**(n-1-b))\n                                dp_value[i][a][b] = max(candidate1, candidate2)\n                                if candidate1 >= candidate2:\n                                    dp_move[i][a][b] = 'H'\n                                else:\n                                    dp_move[i][a][b] = 'M'\n\n                            elif a < n:\n                                dp_value[i][a][b] = dp_value[i+1][a+1][b] + int(A[i]) * (10**(n-1-a))\n                                dp_move[i][a][b] = 'H'\n\n                            elif b < n:\n                                dp_value[i][a][b] = dp_value[i+1][a][b+1] + int(A[i]) * (10**(n-1-b))\n                                dp_move[i][a][b] = 'M'\n\n                    Then, we start from (0,0,0) and build the sequence:\n\n                        i = 0, a=0, b=0\n                        seq = []\n                        while i < 2*n:\n                            move_char = dp_move[i][a][b]\n                            seq.append(move_char)\n                            if move_char == 'H':\n                                a += 1\n                            else:\n                                b += 1\n                            i += 1\n\n            However, note: the state (i, a, b) must be valid: i = a+b.\n\n            But in our iteration, we are iterating by i (which is the total digits processed so far) and a and b are set by the state.\n\n            But wait: we are storing dp_value[i][a][b] for every state (i, a, b) with i = a+b. Then the next state is (i+1, a+ (if H) or b+ (if M)).\n\n            However, we must be cautious: the exponent calculation: the digit A[i] is the i-th digit (0-indexed) in the string A.\n\n            But note: the problem says the first move takes the leftmost digit, then the next leftmost, etc. So the i-th digit in A is the one to be processed at state (i, a, b) (because we have processed i digits, so the next digit is the i-th).\n\n            This matches.\n\n        Example with n=1, A=\"12\":\n\n            Then, two moves: one for H and one for M.\n\n            We have two possibilities: \n                Option1: \"HM\" -> \n                    H: first digit '1' -> value 1\n                    M: second digit '2' -> value 2\n                    total = 3\n                Option2: \"MH\" ->\n                    M: first digit '1' -> value 1\n                    H: second digit '2' -> value 2\n                    total = 3\n\n            They are equal.\n\n            According to our DP:\n\n                i=0: a=0, b=0, i=0, then we can assign to H or M.\n\n                If we assign to H: \n                    value_H = 1 * (10^(1-1-0)) = 1 * 10^0 = 1\n                    then state (1,1,0): then we must assign the next digit to M (since a=1, then we can only assign to M) -> value_M = 2 * (10^(1-1-0)) [for M, the exponent is (n-1-b) = 1-1-0? wait, n=1, so for M: exponent = 1-1-0? \n\n                Let me recalc: for M, the exponent is (n-1-b) where b is the current count for M. Here, we are at state (0,0,0) and assigning to H, then we go to (1,1,0). Then from (1,1,0) we assign the next digit (second digit) to M: \n                    Then, the exponent for M: (n-1 - b) = 1-1-0 = 0? But wait, the state (1,1,0) has b=0 for M? Actually, no: in the state (1,1,0): \n                        a=1, b=0, so i=1, then we are going to assign the next digit (index1) to M. Then the exponent for M is (n-1 - b) = 1-1-0 = 0? \n\n                Actually, the exponent for M is (n-1 - (current count for M)). In the state (1,1,0) we are about to assign the first digit to M (so current count for M is 0) -> exponent = 1-1-0 = 0? \n\n                But wait, the M number has 1 digit, so the first digit assigned to M is the most significant? Then it should be 10^(0) for a 1-digit number? Actually, no: the M number is one digit, so the first digit is the only digit and it is multiplied by 10^0.\n\n                So the calculation for the second digit (if assigned to M) is 2 * (10^(1-1-0)) = 2 * 10^0 = 2.\n\n                Then total for Option1: 1 (from H) + 2 (from M) = 3.\n\n                Similarly, if",
    "response": "\nTo solve this problem, we need to maximize the total prize for two players, Homer and Marge, who take turns picking digits from a given number A. The goal is to determine the optimal sequence of moves where each player picks exactly n digits such that the sum of their respective numbers (formed by the digits they pick) is maximized.\n\n### Approach\n1. **Problem Analysis**: The problem involves splitting a 2n-digit number into two subsequences of n digits each, preserving the original order of digits. Each subsequence forms a number, and the sum of these two numbers should be maximized. The challenge is to decide the optimal sequence of moves (alternating between H and M) to achieve this sum.\n\n2. **Dynamic Programming (DP) Setup**: We use a DP approach where `dp[i][a][b]` represents the maximum value achievable after processing the first `i` digits, with `a` digits assigned to Homer and `b` digits assigned to Marge. The state transitions involve assigning the next digit to either player, updating the count and the total value accordingly.\n\n3. **State Transition**: For each state `(i, a, b)`, if we assign the next digit to Homer, the value contributed by this digit is `digit * 10^(n-1-a)`. Similarly, assigning to Marge contributes `digit * 10^(n-1-b)`. The DP state is updated by considering both possibilities and choosing the one that maximizes the total value.\n\n4. **Backtracking**: After filling the DP table, we backtrack from the initial state `(0, 0, 0)` to construct the sequence of moves by following the optimal choices recorded during the DP computation.\n\n### Solution Code\n```python\ndef main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    if not data:\n        return\n    n = int(data[0].strip())\n    A_str = data[1].strip()\n    \n    total_digits = 2 * n\n    \n    dp_value = [[[-10**30] * (n+1) for _ in range(n+1)] for i in range(total_digits+1)]\n    dp_move = [[''] * (n+1) for _ in range(n+1)]\n    \n    dp_value[total_digits][n][n] = 0\n    \n    for i in range(total_digits-1, -1, -1):\n        for a in range(0, min(i, n)+1):\n            b = i - a\n            if b > n or a > n:\n                continue\n            candidates = []\n            if a < n:\n                next_a = a + 1\n                next_b = b\n                exp = n - 1 - a\n                digit_val = int(A_str[i]) * (10 ** exp)\n                next_total = dp_value[i+1][next_a][next_b]\n                candidates.append(next_total + digit_val)\n            if b < n:\n                next_a = a\n                next_b = b + 1\n                exp = n - 1 - b\n                digit_val = int(A_str[i]) * (10 ** exp)\n                next_total = dp_value[i+1][next_a][next_b]\n                candidates.append(next_total + digit_val)\n            if candidates:\n                idx_max = 0\n                max_candidate = candidates[0]\n                for j in range(1, len(candidates)):\n                    if candidates[j] > max_candidate:\n                        max_candidate = candidates[j]\n                        idx_max = j\n                dp_value[i][a][b] = max_candidate\n                if idx_max == 0:\n                    dp_move[a][b] = 'H'\n                else:\n                    dp_move[a][b] = 'M'\n            else:\n                dp_value[i][a][b] = -10**30\n    \n    seq = []\n    i = 0\n    a_count = 0\n    b_count = 0\n    while i < total_digits:\n        move_char = dp_move[a_count][b_count]\n        seq.append(move_char)\n        if move_char == 'H':\n            a_count += 1\n        else:\n            b_count += 1\n        i += 1\n    \n    result_str = ''.join(seq)\n    print(result_str)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Initialization**: The code reads the input values for `n` and the 2n-digit number `A_str`. It initializes DP tables `dp_value` to store the maximum achievable value for each state and `dp_move` to record the optimal move (either 'H' or 'M').\n\n2. **Base Case**: The base case is set when all digits are processed (`i = 2n`), with both players having picked exactly `n` digits, resulting in a total value of 0.\n\n3. **DP Table Filling**: The DP table is filled in reverse order, starting from the end of the digit sequence. For each state `(i, a, b)`, the algorithm checks if assigning the next digit to either player yields a higher total value, updating the DP table accordingly.\n\n4. **Backtracking**: After filling the DP table, the algorithm backtracks from the initial state `(0, 0, 0)` to construct the sequence of moves by following the optimal choices stored in `dp_move`.\n\n5. **Output**: The constructed sequence of moves (a string of 'H's and 'M's) is printed, ensuring both players pick exactly `n` digits and the sum of their numbers is maximized.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    if not data:\n        return\n    n = int(data[0].strip())\n    A_str = data[1].strip()\n    \n    total_digits = 2 * n\n    \n    dp_value = [[[-10**30] * (n+1) for _ in range(n+1)] for i in range(total_digits+1)]\n    dp_move = [[''] * (n+1) for _ in range(n+1)]\n    \n    dp_value[total_digits][n][n] = 0\n    \n    for i in range(total_digits-1, -1, -1):\n        for a in range(0, min(i, n)+1):\n            b = i - a\n            if b > n or a > n:\n                continue\n            candidates = []\n            if a < n:\n                next_a = a + 1\n                next_b = b\n                exp = n - 1 - a\n                digit_val = int(A_str[i]) * (10 ** exp)\n                next_total = dp_value[i+1][next_a][next_b]\n                candidates.append(next_total + digit_val)\n            if b < n:\n                next_a = a\n                next_b = b + 1\n                exp = n - 1 - b\n                digit_val = int(A_str[i]) * (10 ** exp)\n                next_total = dp_value[i+1][next_a][next_b]\n                candidates.append(next_total + digit_val)\n            if candidates:\n                idx_max = 0\n                max_candidate = candidates[0]\n                for j in range(1, len(candidates)):\n                    if candidates[j] > max_candidate:\n                        max_candidate = candidates[j]\n                        idx_max = j\n                dp_value[i][a][b] = max_candidate\n                if idx_max == 0:\n                    dp_move[a][b] = 'H'\n                else:\n                    dp_move[a][b] = 'M'\n            else:\n                dp_value[i][a][b] = -10**30\n    \n    seq = []\n    i = 0\n    a_count = 0\n    b_count = 0\n    while i < total_digits:\n        move_char = dp_move[a_count][b_count]\n        seq.append(move_char)\n        if move_char == 'H':\n            a_count += 1\n        else:\n            b_count += 1\n        i += 1\n    \n    result_str = ''.join(seq)\n    print(result_str)\n\nif __name__ == \"__main__\":\n    main()",
    "score": -1,
    "metadata": {
        "prompt_token_count": 420,
        "completion_token_count": 1176,
        "thoughts_token_count": 8189
    }
}