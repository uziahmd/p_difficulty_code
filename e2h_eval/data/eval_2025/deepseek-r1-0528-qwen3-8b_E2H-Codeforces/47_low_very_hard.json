{
    "start": 1758296535.906005,
    "end": 1758299459.5944567,
    "start-formatted": "2025-09-20 00:42 KST",
    "end-formatted": "2025-09-20 01:30 KST",
    "gpu": 2,
    "pid": 47,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Neko does Maths\n\nNeko loves divisors. During the latest number theory lesson, he got an interesting exercise from his math teacher.Neko has two integers $$$a$$$ and $$$b$$$. His goal is to find a non-negative integer $$$k$$$ such that the least common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible. If there are multiple optimal integers $$$k$$$, he needs to choose the smallest one.Given his mathematical talent, Neko had no trouble getting Wrong Answer on this problem. Can you help him solve it?\n\n## Input\nThe only line contains two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 10^9$$$).\n\n## Output\nPrint the smallest non-negative integer $$$k$$$ ($$$k \\ge 0$$$) such that the lowest common multiple of $$$a+k$$$ and $$$b+k$$$ is the smallest possible.If there are many possible integers $$$k$$$ giving the same value of the least common multiple, print the smallest one.\n\n## Example\n### Input\n['6 10', '21 31', '5 10']\n\n### Output\n['2', '9', '0']\n\n## Note\nIn the first test, one should choose $$$k = 2$$$, as the least common multiple of $$$6 + 2$$$ and $$$10 + 2$$$ is $$$24$$$, which is the smallest least common multiple possible.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\n Okay, we are given two integers a and b (1 <= a, b <= 10^9). We are to find the smallest non-negative integer k such that the LCM of (a+k) and (b+k) is minimized.\n\n Let d = a - b. Without loss of generality, assume a <= b, then we can set d = b - a (if negative, we swap). But note: the problem does not specify which is larger.\n\n Alternatively, let g = gcd(a+k, b+k). Then note:\n   (a+k) * (b+k) = LCM(a+k, b+k) * GCD(a+k, b+k)\n\n However, we can also note that the difference between (a+k) and (b+k) is fixed: |(a+k) - (b+k)| = |a-b|.\n\n Let d = |a-b|. Then, for any k, we have:\n   gcd(a+k, b+k) = gcd(a+k, d)\n\n Why? Because:\n   gcd(a+k, b+k) = gcd(a+k, (b+k) - (a+k)) = gcd(a+k, b-a)\n\n So, let d0 = |a-b|, then the gcd of (a+k) and (b+k) must be a divisor of d0.\n\n Now, note that the LCM is (a+k)*(b+k)/gcd(a+k, b+k). Since (a+k)*(b+k) grows with k, but the denominator (gcd) might change, we need to consider different k's.\n\n Alternate approach:\n\n We want to minimize LCM(a+k, b+k). Note that:\n   LCM(a+k, b+k) = (a+k)*(b+k) / gcd(a+k, b+k)\n\n And since the gcd divides d0 (the absolute difference), then the gcd must be one of the divisors of d0.\n\n Therefore, we can consider k being chosen such that (a+k) mod t == 0 and (b+k) mod t == 0 for some divisor t of d0, but note: actually, we require that t divides both (a+k) and (b+k). Since (a+k) and (b+k) differ by d0, then if t divides (a+k) and (b+k), then t divides d0.\n\n Moreover, we can think: we want to choose k so that the gcd(a+k, b+k) is as large as possible (because then the LCM would be smaller, since the product (a+k)*(b+k) is increasing in k, but the gcd increases so the denominator increases). However, note that sometimes a larger k might yield a larger gcd and a product that isn't too big, but we cannot simply maximize the gcd because k also affects the product.\n\n But note: the condition on k is that k ≡ (-a) mod t and k ≡ (-b) mod t. Since t divides d0, then t divides (b-a) (or (a-b)), so (-a) ≡ (-b) mod t? Actually, because t divides (b-a), then (b-a) ≡ 0 mod t, so (-a) ≡ (-b) mod t. Therefore, we only require k ≡ (-a) mod t. The smallest non-negative k for modulus t is (t - a % t) % t, but note: if a % t == 0 then k=0.\n\n However, note: we are allowed to use any divisor t of d0 (where d0 = |a-b|). Then, for each divisor t of d0, we can set k0 = (t - a % t) % t (which is the smallest non-negative k such that (a+k) is divisible by t). Then we compute the LCM at k0 and then compare.\n\n But wait: is that all? Actually, note that the gcd might be a multiple of t? No, because the gcd must divide d0, and t is already a divisor of d0. However, the gcd might be greater than t? Actually, no: the gcd is a divisor of d0, so it could be any divisor (including divisors larger than t). But note: we are iterating over divisors t of d0. However, the condition that the gcd is at least t is satisfied because we set (a+k) divisible by t, so the gcd is at least t. But the actual gcd might be a divisor of d0 that is >= t. \n\n However, note: the equation: \n   gcd(a+k, b+k) = gcd(a+k, d0)\n\n But we set (a+k) divisible by t, but the gcd is the gcd of (a+k) and d0. The gcd might be a multiple of t? Actually, the gcd must divide d0 and also (a+k). But note: we are setting",
    "response": "\nTo solve this problem, we need to find the smallest non-negative integer \\( k \\) such that the least common multiple (LCM) of \\( a+k \\) and \\( b+k \\) is minimized. The solution involves leveraging mathematical insights about divisors and the greatest common divisor (GCD) to efficiently determine the optimal \\( k \\).\n\n### Approach\n1. **Problem Analysis**: The key observation here is that the difference between \\( a+k \\) and \\( b+k \\) is constant, equal to \\( |a - b| \\). The GCD of \\( a+k \\) and \\( b+k \\) must be a divisor of this difference. Therefore, the problem reduces to checking all divisors of \\( |a - b| \\) to find the smallest \\( k \\) that maximizes the GCD, which in turn minimizes the LCM.\n\n2. **Insight**: For each divisor \\( t \\) of \\( d = |a - b| \\), we compute the smallest \\( k \\) such that \\( t \\) divides both \\( a+k \\) and \\( b+k \\). This \\( k \\) is given by \\( (t - (a \\% t)) \\% t \\). By evaluating the LCM for these candidate \\( k \\) values, we can determine the smallest \\( k \\) that yields the minimal LCM.\n\n3. **Algorithm Selection**: The algorithm involves:\n   - Calculating the absolute difference \\( d \\) between \\( a \\) and \\( b \\).\n   - Finding all divisors of \\( d \\).\n   - For each divisor \\( t \\), computing the corresponding \\( k \\) and the LCM of \\( a+k \\) and \\( b+k \\).\n   - Tracking the smallest \\( k \\) that results in the minimal LCM.\n\n4. **Complexity Analysis**: The time complexity is dominated by the factorization of \\( d \\), which for numbers up to \\( 10^9 \\) is manageable as \\( d \\) can have at most around 1344 divisors (for highly composite numbers). This ensures the solution is efficient even for large inputs.\n\n### Solution Code\n```python\nimport math\nfrom functools import reduce\nimport sys\n\ndef get_divisors(n):\n    if n == 1:\n        return [1]\n    divisors = set()\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sorted(divisors)\n\ndef main():\n    data = sys.stdin.read().split()\n    a = int(data[0])\n    b = int(data[1])\n    \n    if a == b:\n        print(0)\n        return\n        \n    d = abs(a - b)\n    divisors_list = get_divisors(d)\n    candidates = {}\n    \n    for t in divisors_list:\n        remainder = a % t\n        if remainder == 0:\n            k_candidate = 0\n        else:\n            k_candidate = t - remainder\n        candidates[k_candidate] = True\n        \n    best_k = None\n    min_lcm = None\n    \n    for k in candidates.keys():\n        num1 = a + k\n        num2 = b + k\n        current_lcm = (num1 * num2) // math.gcd(num1, num2)\n        \n        if min_lcm is None or current_lcm < min_lcm or (current_lcm == min_lcm and k < best_k):\n            min_lcm = current_lcm\n            best_k = k\n            \n    print(best_k)\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input consists of two integers \\( a \\) and \\( b \\).\n2. **Special Case Handling**: If \\( a \\) and \\( b \\) are equal, the LCM is trivially minimized at \\( k = 0 \\).\n3. **Divisor Calculation**: The absolute difference \\( d \\) between \\( a \\) and \\( b \\) is computed, and all its divisors are found.\n4. **Candidate Generation**: For each divisor \\( t \\), the smallest \\( k \\) such that \\( t \\) divides both \\( a+k \\) and \\( b+k \\) is calculated.\n5. **LCM Evaluation**: For each candidate \\( k \\), the LCM of \\( a+k \\) and \\( b+k \\) is computed. The smallest \\( k \\) yielding the minimal LCM is selected.\n6. **Output**: The optimal \\( k \\) is printed.\n\nThis approach efficiently narrows down the problem to checking divisors of the difference between the two numbers, ensuring optimal performance even for large values.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\nfrom functools import reduce\nimport sys\n\ndef get_divisors(n):\n    if n == 1:\n        return [1]\n    divisors = set()\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sorted(divisors)\n\ndef main():\n    data = sys.stdin.read().split()\n    a = int(data[0])\n    b = int(data[1])\n    \n    if a == b:\n        print(0)\n        return\n        \n    d = abs(a - b)\n    divisors_list = get_divisors(d)\n    candidates = {}\n    \n    for t in divisors_list:\n        remainder = a % t\n        if remainder == 0:\n            k_candidate = 0\n        else:\n            k_candidate = t - remainder\n        candidates[k_candidate] = True\n        \n    best_k = None\n    min_lcm = None\n    \n    for k in candidates.keys():\n        num1 = a + k\n        num2 = b + k\n        current_lcm = (num1 * num2) // math.gcd(num1, num2)\n        \n        if min_lcm is None or current_lcm < min_lcm or (current_lcm == min_lcm and k < best_k):\n            min_lcm = current_lcm\n            best_k = k\n            \n    print(best_k)\n\nif __name__ == '__main__':\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 397,
        "completion_token_count": 991,
        "thoughts_token_count": 1023
    }
}