{
    "start": 1758308212.2523944,
    "end": 1758311724.7957458,
    "start-formatted": "2025-09-20 03:56 KST",
    "end-formatted": "2025-09-20 04:55 KST",
    "gpu": 2,
    "pid": 30,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# TV Game\n\nThere is a new TV game on BerTV. In this game two players get a number A consisting of 2n digits. Before each turn players determine who will make the next move. Each player should make exactly n moves. On it's turn i-th player takes the leftmost digit of A and appends it to his or her number Si. After that this leftmost digit is erased from A. Initially the numbers of both players (S1 and S2) are «empty». Leading zeroes in numbers A, S1, S2 are allowed. In the end of the game the first player gets S1 dollars, and the second gets S2 dollars.One day Homer and Marge came to play the game. They managed to know the number A beforehand. They want to find such sequence of their moves that both of them makes exactly n moves and which maximizes their total prize. Help them.\n\n## Input\nThe first line contains integer n (1 ≤ n ≤ 18). The second line contains integer A consisting of exactly 2n digits. This number can have leading zeroes.\n\n## Output\nOutput the line of 2n characters «H» and «M» — the sequence of moves of Homer and Marge, which gives them maximum possible total prize. Each player must make exactly n moves. If there are several solutions, output any of them.\n\n## Example\n### Input\n['2\\n1234', '2\\n9911']\n\n### Output\n['HHMM', 'HMHM']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\n Okay, we are given an integer n and a string A of 2n digits.\n\n The game: two players take turns (each exactly n moves) removing the leftmost digit of A and appending it to their own number.\n\n We need to output a string of 2n characters (either 'H' or 'M') that indicates the sequence of moves.\n\n However, note: Homer and Marge are two players. They want to maximize their total prize, which is S1 + S2.\n\n But note: the problem says \"maximizes their total prize\". However, observe that:\n\n In the end, the entire number A is split between S1 and S2, each having n digits. The total prize is the sum of two numbers.\n\n However, note that the assignment of digits to S1 and S2 is fixed by the order of moves. But we can choose the order arbitrarily (since we can decide who goes first, but actually the problem says: before each turn they determine who will make the next move. And each player must make exactly n moves).\n\n But note: the problem does not specify who goes first. However, the example outputs are:\n\n Input: 2\\n1234 -> Output: 'HHMM'\n Input: 2\\n9911 -> Output: 'HMHM'\n\n How do we think?\n\n Let's denote:\n   Let the moves be represented by a string s of length 2n, where s[i] is either 'H' or 'M'. Then, the i-th digit of A (from left) goes to the player whose turn it is.\n\n But note: the entire process: \n   Initially, A = [a0, a1, a2, ..., a_{2n-1}]\n\n   On the first move: remove a0 and assign to the first player (according to s[0]).\n   Then on the second move: remove a1 and assign to the second player (according to s[1]), etc.\n\n Now, the total prize is the numerical value of S1 plus the numerical value of S2.\n\n However, we are allowed to assign the digits arbitrarily to the two players (by choosing the sequence of moves). But note: the entire set of digits is fixed and we are just partitioning the 2n digits into two numbers (each of n digits).\n\n But wait: the order of digits in each player's number is the order of removals for that player. Since the removals are from left to right, the first time a player gets a digit, that becomes the most significant digit for that player.\n\n So, if we assign a set of n digits (with the order of removals) to Homer, then his number is built by taking the digits in the order they were removed. Similarly for Marge.\n\n However, note: the removals happen in the fixed order of the original A. But we can interleave the removals arbitrarily (as long as we use exactly n moves for each).\n\n Example: \n   n=2, A=\"1234\"\n\n   Possibility 1: HHMM: \n        H takes '1' -> S1 = 1, then H takes '2' -> S1 = 12.\n        M takes '3' -> S2 = 3, then M takes '4' -> S2 = 34.\n        Total prize = 12 + 34 = 46.\n\n   Possibility 2: HMHM:\n        H takes '1' -> S1 = 1\n        M takes '2' -> S2 = 2\n        H takes '3' -> S1 = 13\n        M takes '4' -> S2 = 24\n        Total prize = 13+24 = 37.\n\n   Possibility 3: HM HM? Actually, we have two possibilities for each move.\n\n But note: the problem says \"output any of them\", so we don't have to find the best one necessarily? Actually, wait: the problem says \"which maximizes their total prize\".\n\n However, note: the total prize is the sum of two numbers. How to maximize?\n\n Observation: We are going to assign the entire set of 2n digits to two sequences (each of length n). The catch: the assignment must respect the original order of A, but we can interleave arbitrarily.\n\n But note: the order of digits in each player's number is the same as the order of their removals. And the removals happen from left to right, so the relative order of the digits assigned to a player is the same as their order in A.\n\n However, we can choose which player gets which set of digits (with the condition that we cannot change the relative order of the digits in A). This is similar to a two-person game where we are splitting the array into two increasing subsequences (not necessarily contiguous) and then the value for a player is the number formed by the digits in the order of appearance.\n\n How to maximize S1+S2?\n\n Note: the entire set of digits is fixed. The two numbers are built from disjoint sets of digits (each digit goes to one of the two players) and the order of the digits in each number is the same as in A.\n\n But note: the problem allows leading zeros. So we cannot simply compare by lex order? However, the numerical value of a number with leading zeros is still the same as the integer value.\n\n But wait, we are building two numbers. The total prize is the sum of two integers. We are allowed to assign the digits arbitrarily (as long as we preserve the original order for each player).\n\n However, the catch: the moves are interleaved. The removals are in the fixed order, but we can assign the digits to either player at the moment we remove them.\n\n How to compute the maximum total prize?\n\n Let the digits be d0, d1, d2, ... d_{2n-1}.\n\n We have to assign each digit to either Homer or Marge, such that in the final sequence of assignments (the move sequence) the assignment for each player forms a subsequence of the original A (and the relative order is preserved).\n\n But note: the entire assignment is fixed by the move sequence: the first time we assign a digit to a player, that's the most significant, then the next time we assign a digit to that player, it becomes the next more significant, etc.\n\n So, if we let x_i be the assignment (0 for Homer, 1 for Marge) then the number for Homer is:\n\n   H = x_0 * 10^(n-1) + x_1 * 10^(n-2) + ... + x_{n-1} * 10^0   ??? \n\n Wait, no: the first digit taken by Homer (if any) might not be the very first digit of A? Actually, the first move is the first digit. But the first move is assigned to one of the players.\n\n Actually, the structure is:\n\n   The entire process: we have 2n digits. The i-th digit (0-indexed) is assigned to a player. Then, for a given player, the digits assigned to him are in the order of increasing index (because we remove from left to right). So the first time we assign a digit to a player, it is the most significant (multiplied by 10^(k)) where k is the position in the player's number (from 0 to n-1).\n\n However, the assignment is interleaved. The k-th digit assigned to a player (i.e., the k-th time that player moves) is the (some increasing index j) digit, and its weight in the number is 10^(n-1-k).\n\n But note: we don't know the exact indices until we assign.\n\n Alternatively, we can think: we are going to assign the 2n digits to two sequences (each of length n) and the value of a player's number is the integer formed by the digits in the order they appear in A.\n\n Then the total prize is the sum of these two integers.\n\n How to maximize the sum?\n\n Let me consider: we have two numbers, each of n digits. The entire set of digits is fixed. The catch: the assignment must be such that the two sequences are increasing in the index (i.e., we cannot assign a digit that appears later to a player and then assign an earlier digit to the same player, because the moves are sequential from left to right).\n\n Actually, the two numbers are built by taking the digits in the order they are removed (so the indices of the digits for a given player must be increasing). Therefore, we are splitting the sequence A (of 2n digits) into two increasing subsequences (each of length n) and the two subsequences together form A (i.e., they are disjoint and cover all digits).\n\n Then, what is the maximum total prize?\n\n We wish to maximize: \n   F(x0, x1, ..., x_{2n-1}) = (number formed by the digits assigned to Homer) + (number formed by the digits assigned to Marge)\n\n But note: the digits assigned to a player are taken in the order of appearance. So the value for Homer is:\n\n   H = d_i0 * 10^(n-1) + d_i1 * 10^(n-2) + ... + d_i{n-1} * 10^0\n\n and similarly for Marge.\n\n However, the indices i0, i1, ... for Homer must be increasing, and similarly for Marge.\n\n But note: the entire assignment must use all digits.\n\n This is a dynamic programming problem? But n is up to 18 (so 2n=36) and we have two players. However, the state space would be 2^(2n) which is too large.\n\n Alternative insight:\n\n Consider that the total prize is independent of the interleaving? Actually, no: the same set of digits assigned to a player, but in different orders (but the order is fixed by the original A) and the weights (powers of 10) depend on the position in the subsequence.\n\n But note: the assignment must be a splitting of the entire sequence into two increasing subsequences (each of length n). The two subsequences are disjoint and their union is the whole sequence.\n\n However, the problem is asking for the move sequence (a string of 'H' and 'M' of length 2n). And we are free to assign as long as we use each digit exactly once and the two subsequences are increasing.\n\n But note: the two subsequences must be increasing in indices, but the digits themselves can be arbitrary. However, the value of the number is determined by the digits and the order.\n\n How to maximize the sum? \n\n Let me consider the two numbers as two n-digit numbers. The total sum is:\n\n   Sum = (d_i0 * 10^{n-1} + ... + d_i{n-1} * 10^0) + (d_j0 * 10^{n-1} + ... + d_j{n-1} * 10^0)\n\n But note: the same digit cannot appear twice.\n\n However, we can also consider: the entire set of digits is fixed, and the two numbers are built from disjoint sets. The maximum sum is achieved when the largest digits are placed in the highest places (leftmost) of both numbers? \n\n But wait: the two numbers are built from the entire set. The entire set of digits is fixed, so the maximum sum we can get is by having the two largest digits in the two most significant positions (the first two digits of the two numbers) and so on.\n\n However, the two numbers are built from the entire set, but the digits are taken from the entire sequence in order. \n\n Actually, we are forced to use the digits in the order they appear, but we can assign them arbitrarily to the two players (as long as we don't break the order). \n\n This is equivalent to: we wish to assign the digits to two stacks (each stack being a number) and the stacks must be built by taking digits from left to right (each digit goes to one of the two stacks). Then, the value of a stack is the integer formed by the digits in the order they were pushed.\n\n How to maximize the sum? \n\n We can use a greedy idea: we want the higher digits to be in the more significant positions. But note: the more significant positions are the first moves (the earliest in the sequence) of the two players.\n\n However, the two players have n moves each, and the moves are interleaved arbitrarily. \n\n Another idea: since the two numbers are built from the entire set, the total sum is fixed if we assign the digits arbitrarily? Actually, no: the same digit in a higher place (more significant) has a bigger effect.\n\n But note: we are forced to use the digits in the order they appear. We cannot rearrange the digits arbitrarily. We can only assign them to one of the two players.\n\n Therefore, the problem reduces to: we have two numbers, and the digits for each number must appear in increasing index order (because the removals are left-to-right). We wish to maximize the sum of the two numbers.\n\n This is similar to the problem: \"assign 2n digits (in order) to two numbers, each of n digits, and maximize the sum\".\n\n How to maximize the sum? \n\n Consider: the first digit (most significant of both numbers) should be assigned to the player who will have a higher digit in the most significant position? But note: the first digit is the most significant for the first move of the player that takes it.\n\n However, the two numbers have n digits, so the first digit of a number (the very first time the player moves) is multiplied by 10^(n-1). The second digit of a number (the next time the player moves) is multiplied by 10^(n-2), etc.\n\n Therefore, we wish to assign the largest available digits to the most significant positions (the earliest moves) of the two players.\n\n But note: the moves are interleaved. The first move (the first digit) can be assigned to either player. Then the second move (second digit) to either, etc.\n\n We can use dynamic programming:\n\n   Let dp[i][j] be the maximum total sum we can achieve after processing the first i+j digits, where i is the number of digits assigned to Homer and j to Marge.\n\n   Then, the next digit (at position i+j) can be assigned to Homer or Marge.\n\n   If we assign it to Homer, then the value added is: digit * (10^(n - i - 1))? \n\n   But wait: the digit is at position i+j (0-indexed). However, the power of 10 for this digit in Homer's number depends on how many digits Homer has already taken. Specifically, if Homer has already taken k digits, then this new digit will be the (k)-th digit (counting from 0) and will be multiplied by 10^(n-1-k). Similarly for Marge.\n\n   However, we don't know the future. But note: the entire set of digits is fixed. We are processing from left to right.\n\n   Alternatively, we can precompute the contribution of each digit if assigned to a player at a particular time.\n\n   But note: the assignment must be done in the order of the digits. We cannot assign a digit to a player until we have passed all the digits that are to be assigned to that player? Actually, no: we can assign arbitrarily, but the digits must appear in increasing index order for each player.\n\n   However, we are processing from left to right, so when we are at digit d (at position k), we can assign it to a player only if that player has been assigned fewer than n digits. And the power of 10 for that digit in that player's number is 10^(n-1 - (number of digits already assigned to that player)).\n\n   But note: we don't know the future, so we cannot know the exact power. However, the problem doesn't require us to compute the maximum total prize, but to output a move sequence that achieves the maximum total prize.\n\n   We can do DP that tracks:\n        state: (i, j) where i = number of moves by Homer, j = number of moves by Marge, and we have processed up to k = i+j digits.\n\n        Then, the next digit (the k-th digit) can be assigned to Homer (if i < n) or Marge (if j < n).\n\n        The total prize from the assignment so far is not additive independently because the digit's value depends on the position in the number (which depends on the count of moves by that player so far). \n\n        We can store the total prize so far, but then the state space is too big (because the digits are up to 36, and the numbers are big, and the state is (i, j) and the total prize is a number with up to 18 digits, which is too big to store as an integer in state).\n\n   Alternatively, we can use DP that stores (i, j) and the current total prize. But the total prize can be as large as 2 * (10^n - 1) * (10^(n-1)) which is about 2 * 10^(2n-1) and n=18 -> 2n=36, so 10^35 which is too big.\n\n   We need another way.\n\n Insight: the problem asks for any move sequence that maximizes the total prize.\n\n There is a known fact: the maximum total prize is achieved by a greedy strategy that assigns the largest available digit to the most significant position that is available (across both numbers). But note: the moves are interleaved, and we have two numbers. We have two most significant positions (the first move of each player). Then two next most significant positions (the second move of each player), etc.\n\n However, the catch: the digits must be taken in the order of A. So we cannot assign a digit to a player until we have seen it.\n\n So, we have to simulate the entire sequence and at each step, we have two choices (if both players haven't finished) unless one has finished.\n\n But note: the problem is symmetric? Actually, no: because the two numbers are built from the entire set, and the same digit cannot be used twice.\n\n Alternate Insight from known problems:\n\n This problem is similar to \"Two Numbers\" (Codeforces) or \"Split the String\" problems.\n\n However, note: the total prize is the sum of the two numbers. We want to maximize the sum.\n\n How about: we wish to maximize the two numbers. The best way is to assign the largest digits to the most significant places. But the moves are constrained by the order of A.\n\n We can use a greedy method that, at each step, compares the two available moves (if both are available) and decides which one gives the higher benefit.\n\n But the benefit of assigning a digit d to a player who has already taken k digits is: d * (10^(n-1-k)). However, if we assign d to a player, then that player's next move will have one less power (the exponent decreases). Also, if we assign a digit now, we lock that digit in that player's number.\n\n However, we cannot look ahead arbitrarily because we don't know the future digits.\n\n But note: the entire set of digits is known.\n\n Another idea: we are going to assign the entire sequence. We can use DP that stores (i, j) and the current total prize, but the total prize is too big.\n\n Alternatively, we can use a recursive DFS with memoization using state (i, j) and the index we are at (k = i+j). The total prize is computed by:\n\n   For a given state (i, j) and having processed k digits, we know that the remaining digits (from k to 2n-1) will be assigned.\n\n   But the total prize we have so far is fixed by the digits we have assigned and the exponents (which depend on the count of moves for each player). However, we can compute the total prize so far by:\n\n      Let H_so_far = the number formed by the i digits we've assigned to Homer so far. Similarly for Marge.\n\n   But storing H_so_far and M_so_far as integers is not feasible (they are up to 10^18, and we have 2^36 states?).\n\n   We need to avoid storing the entire numbers.\n\n   Instead, we can separate the contributions:\n\n   The total prize is the sum of two numbers. Each digit d at position p (0-indexed) if assigned to a player who, at the time of assignment, had c moves (so this digit will be the (c)-th digit for that player, so its weight is 10^(n-1-c)), and c goes from 0 to n-1.\n\n   But note: the same digit d at position p, if assigned to a player at a time when that player has c moves, then its contribution is d * (10^(n-1-c)).\n\n   However, we don't know the future c (because the number of moves for a player is fixed to n, but the timing is variable). \n\n   But wait: the entire assignment is fixed by the sequence. We know that each player must get exactly n digits.\n\n   Then, the total prize is fixed by the assignment of digits to players and the counts (the order) of the moves for each player.\n\n   However, the problem is: we are processing from left to right, and we must assign the digit to a player at the moment we see it.\n\n   We can use state (i, j) meaning that we have assigned i digits to Homer and j digits to Marge, and we have processed k = i+j digits. Then, the remaining digits (from k to 2n-1) must be assigned.\n\n   The total prize so far is:\n\n        H_value = sum_{for each digit assigned to Homer so far} (digit * (10^(n-1 - (the order of that digit in Homer's sequence)))\n        Similarly for Marge.\n\n   But the order of a digit in a player's sequence is the count of moves that player has made so far (at the time of assignment). However, we cannot store the entire history of which digits were assigned to which player and in which order because that would be too expensive.\n\n   Alternatively, we can store the total value for each player so far. Then:\n\n        dp[i][j] = (homer_value, marge_value) for having assigned i to Homer and j to Marge, and the next digit (at position k = i+j) is the next one.\n\n   Then, when we assign the next digit d (at position k) to Homer, we update:\n\n        new_homer_value = homer_value + d * (10^(n-1-i))   [because the next move for Homer is the i-th move (0-indexed) so the power is 10^(n-1-i)]\n\n   Similarly for Marge.\n\n   However, the state space is (n+1) * (n+1) which is 19x19 = 361 states. But the values of the numbers are huge (up to 10^36) and we cannot store them as integers in the state? But wait, we are only interested in the maximum total prize, and then we want to reconstruct the path.\n\n   But note: the problem doesn't require the maximum total prize, only the move sequence that achieves the maximum.\n\n   We can do:\n\n        dp[i][j] = the maximum total prize (which is the sum of the two numbers) that can be achieved from state (i,j) (with i+j digits processed) to the end.\n\n        Then, we can use memoization (top-down DP) and then backtrack the moves.\n\n   However, the total prize is the sum of two numbers, and we are building the numbers from left to right. The issue is that the same state (i, j) can be reached by different assignments of digits to players, and the total prize so far is the sum of the two numbers built so far. But the rest of the digits are fixed, so we can compute the future part independently? Actually, no: because the digits are fixed, but the assignment to the two players in the future depends on the state (i, j) and the remaining digits.\n\n   Actually, the entire sequence is fixed. We are processing from left to right, and the remaining digits are fixed. The total prize is the sum of the two numbers. The two numbers are built by the digits assigned to each player (with the correct order of appearance). \n\n   We can precompute the entire value for a player's number if we know the set of digits and the order (which is fixed by the original indices). But wait: the order is fixed by the original indices, so the value for a player's number is independent of the interleaving? \n\n   Actually, no: the value of a player's number depends on the exact indices at which the digits were taken. For example, if a player takes the first digit and the third digit, then the first digit is multiplied by 10^(n-1) and the third by 10^(n-2). But if the same set of digits is taken in a different order (for example, the third and then the first) that is not allowed because the moves are sequential from left to right. So the order is fixed by the appearance.\n\n   Therefore, the entire value of the two numbers is determined by which digits go to which player and the order in which they appear. \n\n   However, we can compute the total prize for a complete assignment without DP? \n\n   But the assignment must be a valid interleaving (two increasing index subsequences). \n\n   Actually, we can use DP that considers:\n\n        dp[i][j] = the maximum total prize achievable from the state (i, j) (having assigned i digits to Homer and j to Marge) for the remaining digits (from index i+j to 2n-1).\n\n        Then, the recurrence:\n\n            If i+j == 2n: then dp[i][j] = 0 (base case)\n\n            Otherwise, let d = int(A[i+j])\n\n            Option1: assign to Homer if i < n.\n                Then, the value for Homer for this digit is d * (10**(n-1-i))   [because this is the i-th digit for Homer, so the power is 10^(n-1-i)]\n                Then, the remaining part: dp[i+1][j] for the rest.\n\n                But note: the rest of the digits will be assigned, and the total prize from the rest is dp[i+1][j]. However, the rest of the digits are fixed, but the assignment to the two players will add more digits.\n\n            However, wait: the total prize is the sum of the two numbers. The two numbers are built from all the digits. We are building the two numbers as we go.\n\n            But the catch: the same digit cannot be split. And the two numbers are built independently.\n\n            Actually, we can compute the entire future value for the two players? \n\n            But note: the future digits will be assigned to the two players, and the value of a digit in the future depends on the number of moves the player has made so far (including the current one). \n\n            However, we are processing from left to right, and the state (i, j) tells us how many moves each player has made so far. Then, the remaining moves for Homer: n - i, for Marge: n - j.\n\n            And the remaining digits: from index i+j to 2n-1, which is (2n - (i+j)) digits.\n\n            Now, the total prize from the rest of the digits is independent of the past? \n\n            But the value of a digit depends on the number of moves the player has made at the time of assignment. \n\n            Actually, we cannot separate the past and future because the exponent for a digit depends on the total number of moves the player has made so far (including the current one). \n\n            Therefore, we must account for the entire assignment.\n\n   However, the state (i, j) and the current index (k = i+j) is enough to determine the exponents for the remaining digits. \n\n   But note: the entire assignment is fixed by the state (i, j) and the remaining digits. The remaining digits are from k to 2n-1. For each remaining digit, we can assign it to Homer (if i < n) or Marge (if j < n). \n\n   Then, we can compute:\n\n        dp[i][j] = max {\n            (if i < n) then d_k * (10**(n-1-i)) + dp[i+1][j],\n            (if j < n) then d_k * (10**(n-1-j)) + dp[i][j+1]\n        }   [taking the maximum of the two options, but note: if both are available, we take the maximum of the two]\n\n   But wait: the two options are independent. However, the base case is when i+j=2n, then dp[i][j]=0.\n\n   But note: the entire set of digits is fixed, and we must assign all digits. The state (i, j) must satisfy i+j <= 2n, and we stop at i+j=2n.\n\n   However, the above recurrence does not consider that the assignment must cover all digits. We are processing one digit at a time.\n\n   But note: the digit d_k is the next digit (at index k). Then we assign it to one of the players, and then we proceed to the next digit.\n\n   Then, the total prize from the state (i, j) is the sum of the contributions from the current digit (if we assign it) and the rest.\n\n   But wait: the exponent for a digit depends on the total number of moves the player will have at the time of assignment. However, in our state we only track the number of moves so far (i and j). \n\n   When we assign the current digit to Homer, then we update i -> i+1, and the next state will have i+1 and j, and the next digit (if any) will use the updated i (for Homer) to compute the exponent.\n\n   This recurrence is correct.\n\n   However, the state space is (n+1) * (n+1) = 361 states, and each state we do two operations (if both moves are available) or one.\n\n   But the exponents: we need to compute 10^(n-1-i) for i from 0 to n-1. Since n<=18, we can precompute powers of 10.\n\n   Steps:\n\n        Precompute: \n            power[i] = 10^(n-1-i) for i from 0 to n-1.\n\n        Then, dp[i][j] = \n            if i+j == 2*n: 0\n            else:\n                d = int(A[i+j])\n                option1 = -1, option2 = -1\n                if i < n:\n                    option1 = d * power[n-1-i] + dp[i+1][j]\n                if j < n:\n                    option2 = d * power[n-1-j] + dp[i][j+1]\n                if both available: dp[i][j] = max(option1, option2)\n                else: dp[i][j] = the available one\n\n   However, wait: what if we have two moves available, but one option leads to a higher total prize? We take the maximum.\n\n   But note: the entire future is independent of the past, so we can use memoization.\n\n   Then, we can backtrack to find the sequence.\n\n   But note: we are asked for the sequence of moves (a string of length 2n of 'H' and 'M').\n\n   We can store the decision in the dp table, or we can store a parent pointer.\n\n   Alternatively, we can do:\n\n        dp[i][j] = (total_prize, move_sequence)   but the move_sequence would be a string of length 2*(2n - (i+j)) and we are building from the beginning? \n\n   Actually, we are processing from the beginning to the end. The dp table is computed from the end to the beginning.\n\n   We can store:\n\n        dp[i][j] = (total_prize, last_move)   but we need the entire sequence.\n\n   Alternatively, we can store the entire sequence in the state? That would be too heavy.\n\n   Better: we do recursion and then backtrack the moves.\n\n   Steps:\n\n        We'll use memoization (or iterative DP) to compute the maximum total prize.\n\n        Then, we start from state (0,0) and we know the maximum total prize.\n\n        Then, we traverse the digits from left to right, and at each state (i, j) we look at the two options (if available) and choose the one that leads to the maximum total prize (but note: we are maximizing the entire sum, so we choose the option that gives the higher dp[i][j]).\n\n        However, we have to record the decision (which move we took) at each state.\n\n   Implementation:\n\n        Let dp[i][j] = the maximum total prize from state (i, j) (meaning we've processed i+j digits) to the end.\n\n        We'll use a 2D array of size (n+1) x (n+1) for dp.\n\n        Precompute power: \n            power = [10**(n-1-i) for i in range(n)]\n\n        Then, we fill dp from i+j = 2n down to 0.\n\n        Alternatively, we can do recursion with memoization.\n\n        Then, to get the sequence:\n\n            We start at (0,0) and we have the entire string of moves.\n\n            We know the next digit is at index 0.\n\n            Then, we consider: if we assign the first digit to Homer, then the total prize from state (1,0) must be dp[1][0]. Similarly for Marge.\n\n            Then, we choose the option with the higher dp[i][j] (but note: the recurrence is additive, so we don't need to compare the entire future, we stored dp[i][j] as the maximum from that state).\n\n        However, note: the recurrence:\n\n            dp[i][j] = max( d * power[n-1-i] + dp[i+1][j], d * power[n-1-j] + dp[i][j+1] )\n\n        But wait: is that correct? \n\n        Actually, the total prize from state (i, j) is the sum of the prizes from the current digit and the rest.\n\n        And the rest is independent.\n\n        But note: the entire assignment must cover the rest of the digits, and the total prize is the sum of the two numbers. Our dp[i][j] is defined as the maximum total prize from state (i, j) to the end.\n\n        Then, the recurrence is:\n\n            dp[i][j] = max( \n                (if i < n) then d * power[n-1-i] + dp[i+1][j],\n                (if j < n) then d * power[n-1-j] + dp[i][j+1]\n            )\n\n        However, note: the two numbers are built independently, and the assignment of one digit only affects that player's number.\n\n        But wait: the total prize is the sum of the two numbers, and the two numbers are built from the entire set of digits. The recurrence above is correct because we are adding the current digit's contribution to one of the numbers and then the rest.\n\n        But note: the rest of the digits are assigned arbitrarily (to maximize the total prize). \n\n        However, the entire set of digits is fixed, and the assignment to the two players is independent (except for the constraint that each gets exactly n digits). \n\n        Therefore, the recurrence is correct.\n\n   But note: the power array: the exponent for a digit assigned to a player at the time when that player has i moves (so the next move is the i-th, meaning there will be i digits already, so the current digit will be the (i)-th digit (0-indexed) and hence the power is 10^(n-1-i).\n\n   Example: n=2, A=\"1234\"\n\n        State (0,0): digit '1' (index0)\n            Assign to Homer: 1 * 10^(2-1-0) = 1 * 10^(1) = 10\n            Then state (1,0): digit '2' (index1)\n                Then, we can assign to Homer or Marge.\n                For Homer: 2 * 10^(2-1-1)=2 * 10^0 = 2, then state (2,0): digit '3' (index2) -> must assign to Marge: 3 * 10^(2-1-0)=3*10=30, then state (2,1): digit '4' (index3): 4 * 10^(2-1-1)=4 -> total prize = 10+2+30+4 = 46.\n\n                Alternatively, at state (1,0): assign to Marge: 2 * 10^(2-1-0)=2*10=20, then state (1,1): digits left: '3','4'\n                    Then, assign '3': can go to either.\n                    If to Homer: 3 * 10^(2-1-1)=3, then state (2,1): assign '4' to Marge: 4 * 10^(2-1-1)=4 -> total prize = 10+20+3+4 = 37.\n                    If to Marge: 3 * 10^(2-1-1)=3, then state (1,2): assign '4' to Homer: 4 * 10^(2-1-1)=4 -> total prize = 10+20+3+4 = 37.\n\n            Now, the other branch at state (0,0): assign to Marge: 1 * 10^(2-1-0)=10, then state (0,1): digit '2'\n                Then, assign to Homer: 2 * 10^(2-1-0)=2*1",
    "response": "\nTo solve this problem, we need to maximize the total prize for two players in a game where they alternately take digits from a given number. The total prize is the sum of the two numbers each player forms by appending the digits they take in sequence. The challenge is to determine the optimal sequence of moves (either 'H' for Homer or 'M' for Marge) such that both players make exactly `n` moves, and the sum of their numbers is maximized.\n\n### Approach\n1. **Problem Analysis**: The problem involves splitting a sequence of `2n` digits into two subsequences (one for each player) of length `n` each, while preserving the original order of digits. The goal is to maximize the sum of the two numbers formed by these subsequences.\n2. **Key Insight**: The value of each digit in a player's number depends on its position (most significant digit contributes the most). Therefore, to maximize the total prize, we should prioritize assigning higher digits to more significant positions in both numbers.\n3. **Dynamic Programming (DP) Setup**: We use a DP table where `dp[i][j]` represents the maximum total prize achievable after assigning `i` digits to Homer and `j` digits to Marge. The DP state transitions consider assigning the next digit to either player, updating the total prize based on the digit's contribution (digit value multiplied by the appropriate power of 10).\n4. **Backtracking**: After filling the DP table, we backtrack from the initial state `(0, 0)` to determine the optimal move sequence by choosing at each step the assignment (to Homer or Marge) that leads to the highest total prize.\n\n### Solution Code\n```python\ndef main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    if not data:\n        return\n    \n    n = int(data[0].strip())\n    A_str = data[1].strip()\n    total_digits = 2 * n\n\n    power = [10**(n-1-i) for i in range(n)]\n    \n    dp = [[-1] * (n+1) for _ in range(n+1)]\n    seq = [[''] * (n+1) for _ in range(n+1)]\n    \n    def calculate_digit_value(d, pos):\n        return d * power[pos]\n        \n    def dfs(i, j):\n        idx = i + j\n        if idx == total_digits:\n            return 0\n            \n        if dp[i][j] != -1:\n            return dp[i][j]\n            \n        d_char = A_str[idx]\n        d_val = int(d_char)\n        option1 = -1\n        option2 = -1\n        \n        if i < n:\n            part1 = dfs(i+1, j)\n            if part1 == -1:\n                part1 = 0\n            option1 = calculate_digit_value(d_val, n-1-i) + part1\n        if j < n:\n            part2 = dfs(i, j+1)\n            if part2 == -1:\n                part2 = 0\n            option2 = calculate_digit_value(d_val, n-1-j) + part2\n            \n        res = max(option1, option2)\n        dp[i][j] = res\n        return res\n        \n    dfs(0, 0)\n    \n    path = []\n    i, j = 0, 0\n    idx = 0\n    while idx < total_digits:\n        d_char = A_str[idx]\n        d_val = int(d_char)\n        if i < n:\n            option1 = calculate_digit_value(d_val, n-1-i) + dp[i+1][j] if dp[i+1][j] != -1 else float('-inf')\n        else:\n            option1 = float('-inf')\n            \n        if j < n:\n            option2 = calculate_digit_value(d_val, n-1-j) + dp[i][j+1] if dp[i][j+1] != -1 else float('-inf')\n        else:\n            option2 = float('-inf')\n            \n        if option1 > option2:\n            path.append('H')\n            i += 1\n        else:\n            path.append('M')\n            j += 1\n        idx += 1\n        \n    result_str = ''.join(path)\n    print(result_str)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input consists of an integer `n` and a string `A` of `2n` digits.\n2. **Power Calculation**: Precompute the powers of 10 for each possible position in the numbers (from most significant to least significant).\n3. **DP Table Initialization**: The DP table `dp[i][j]` is initialized to store the maximum total prize achievable from state `(i, j)`, where `i` and `j` are the counts of digits assigned to Homer and Marge, respectively.\n4. **DFS for DP Filling**: The `dfs` function recursively computes the maximum prize by considering both possible moves (assigning the current digit to Homer or Marge) and updates the DP table accordingly.\n5. **Path Reconstruction**: After filling the DP table, backtrack from `(0, 0)` to construct the move sequence by choosing at each step the move (Homer or Marge) that leads to the highest total prize.\n6. **Output**: The constructed sequence of moves is printed as the result.\n\nThis approach efficiently maximizes the total prize by leveraging dynamic programming and careful backtracking, ensuring optimal play from both players.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n    data = sys.stdin.read().splitlines()\n    if not data:\n        return\n    \n    n = int(data[0].strip())\n    A_str = data[1].strip()\n    total_digits = 2 * n\n\n    power = [10**(n-1-i) for i in range(n)]\n    \n    dp = [[-1] * (n+1) for _ in range(n+1)]\n    seq = [[''] * (n+1) for _ in range(n+1)]\n    \n    def calculate_digit_value(d, pos):\n        return d * power[pos]\n        \n    def dfs(i, j):\n        idx = i + j\n        if idx == total_digits:\n            return 0\n            \n        if dp[i][j] != -1:\n            return dp[i][j]\n            \n        d_char = A_str[idx]\n        d_val = int(d_char)\n        option1 = -1\n        option2 = -1\n        \n        if i < n:\n            part1 = dfs(i+1, j)\n            if part1 == -1:\n                part1 = 0\n            option1 = calculate_digit_value(d_val, n-1-i) + part1\n        if j < n:\n            part2 = dfs(i, j+1)\n            if part2 == -1:\n                part2 = 0\n            option2 = calculate_digit_value(d_val, n-1-j) + part2\n            \n        res = max(option1, option2)\n        dp[i][j] = res\n        return res\n        \n    dfs(0, 0)\n    \n    path = []\n    i, j = 0, 0\n    idx = 0\n    while idx < total_digits:\n        d_char = A_str[idx]\n        d_val = int(d_char)\n        if i < n:\n            option1 = calculate_digit_value(d_val, n-1-i) + dp[i+1][j] if dp[i+1][j] != -1 else float('-inf')\n        else:\n            option1 = float('-inf')\n            \n        if j < n:\n            option2 = calculate_digit_value(d_val, n-1-j) + dp[i][j+1] if dp[i][j+1] != -1 else float('-inf')\n        else:\n            option2 = float('-inf')\n            \n        if option1 > option2:\n            path.append('H')\n            i += 1\n        else:\n            path.append('M')\n            j += 1\n        idx += 1\n        \n    result_str = ''.join(path)\n    print(result_str)\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 420,
        "completion_token_count": 1166,
        "thoughts_token_count": 8190
    }
}