{
    "start": 1758303225.7015224,
    "end": 1758306725.1530313,
    "start-formatted": "2025-09-20 02:33 KST",
    "end-formatted": "2025-09-20 03:32 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\n Okay, we are given a graph with n nodes and m edges. Each edge (u, v) gives two numbers: gcd and lcm.\n Conditions for an edge (a, b):\n   Let x = number of mushrooms on lawn u, y = on lawn v.\n   Then, gcd(x,y) must equal the given gcd and lcm(x,y) must equal the given lcm.\n\n We know that for any two positive integers x and y:\n   gcd(x,y) * lcm(x,y) = x * y.\n\n Also, note that x and y must be multiples of gcd(x,y). So, we can write:\n   x = g * a, y = g * b, where a and b are coprime (gcd(a,b)=1) and then:\n   lcm(x,y) = g * a * b = given lcm.\n\n Therefore, from an edge (u, v) with gcd = g and lcm = l, we have:\n   g * a * b = l  => a * b = l // g.\n\n Additionally, note that the numbers must be positive integers.\n\n However, the entire graph must be consistent. We cannot assign independently to each node because the same node appears in multiple edges.\n\n Approach:\n\n Step 1: Check consistency for each edge individually.\n   For an edge (u, v, g, l):\n     - If l % g != 0, then it's impossible -> NO.\n     - Then, let k = l // g. Then we require that k is an integer and we can factorize k as a product of two coprime numbers (a, b) such that the numbers for u and v are g*a and g*b, respectively.\n\n But note: The problem does not require the same representation for all edges. However, the same node must have the same value in every edge incident to it.\n\n Alternatively, we can use the following idea:\n\n   For each node i, let x_i be the number of mushrooms.\n\n   For an edge (i, j, g, l):\n        x_i * x_j = g * l   [because gcd(i)*lcm(i)=x_i*x_j]\n        and also, gcd(x_i, x_j) = g.\n\n   Moreover, we know that x_i must be divisible by g, and similarly for x_j.\n\n   Also, note that the set of prime factors of x_i must be the union of the prime factors of g and possibly some others, but the common primes between x_i and x_j must be exactly those in g.\n\n However, we can try to assign a value to each node.\n\n Another idea:\n\n   We know that for two numbers x and y, we have:\n        x = gcd(x,y) * (some divisor of LCM(x,y)/gcd(x,y)) that is coprime with the other part.\n\n   But note: the condition that the entire graph must be consistent.\n\n Steps:\n\n   1. Check that for every edge, the given gcd and lcm satisfy: gcd <= lcm and gcd divides lcm (so that l % g == 0).\n\n   2. Then, we can consider building a system of equations.\n\n   Alternatively, we can use the following:\n\n      Let x_i = g_i * a_i, where g_i is the gcd from the edges incident to i? Actually, note that the gcd for each edge is fixed, so the gcd for an edge (u,v) must divide both x_u and x_v.\n\n      How about we think of the prime factorizations?\n\n   However, note the constraints: n, m up to 10^6? Actually, the input says: \n        n, m () — no specific bounds, but the numbers are up to 10^6.\n\n   But the problem says: \"It is guaranteed that the numbers on the roads on the initial map were no less than 1 and did not exceed 10^6.\" — but note: the gcd and lcm are between 1 and 10^6.\n\n   But the number of lawns (n) and roads (m) are not bounded by 10^6 in the input description? Actually, the input format says: first line contains two numbers n and m. Then m lines.\n\n   We need an efficient solution.\n\n   Observation:\n\n      From the equation: x_i * x_j = g * l, and also the gcd condition.\n\n      We can set up a system:\n\n          Let d_i be the gcd value for edges incident to node i? Actually, the gcd for edges might be different.\n\n      Instead, we can use the following:\n\n          For each edge (u, v) with gcd = g, lcm = l, we have:\n            x_u * x_v = g * l   ... (equation1)\n            and x_u and x_v are multiples of g.\n\n          Moreover, the ratio x_u/x_v must be such that when reduced by dividing by g, the two parts are coprime",
    "response": "\nTo solve this problem, we need to determine if it's possible to restore the number of mushrooms on each lawn in a forest based on partial information. The given information consists of some roads connecting lawns, each road specifying the greatest common divisor (GCD) and least common multiple (LCM) of the mushroom counts on the connected lawns. The solution involves verifying the consistency of these GCD and LCM values across all roads and then reconstructing the mushroom counts for each lawn.\n\n### Approach\n1. **Problem Analysis**: The key observation is that for any two numbers \\(a\\) and \\(b\\), the product of their GCD and LCM equals the product of the numbers themselves, i.e., \\( \\text{GCD}(a, b) \\times \\text{LCM}(a, b) = a \\times b \\). Additionally, both numbers must be multiples of their GCD. \n\n2. **Edge Validation**: For each road (edge) connecting two lawns (nodes), check if the given GCD divides the LCM. If not, the arrangement is impossible. Then, compute the product of the GCD and LCM; this product must equal the product of the mushroom counts on the connected lawns.\n\n3. **Graph Construction**: Construct a graph where each node represents a lawn, and edges represent the roads with their respective GCD and LCM values. For each node, the mushroom count must be consistent across all incident edges.\n\n4. **Consistency Check**: For each node, derive its mushroom count by ensuring that all incident edges' conditions are satisfied. Specifically, the mushroom count for a node must be a multiple of the GCD from each incident edge and must satisfy the product condition derived from the LCM.\n\n5. **Solution Construction**: If all edges and nodes pass the consistency checks, output the mushroom counts. Otherwise, report that no valid arrangement exists.\n\n### Solution Code\n```python\nimport math\nfrom collections import defaultdict, deque\n\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    \n    edges = []\n    for _ in range(m):\n        u = int(next(it)) - 1\n        v = int(next(it)) - 1\n        g = int(next(it))\n        l = int(next(it))\n        edges.append((u, v, g, l))\n        \n    graph = [[] for _ in range(n)]\n    for u, v, g, l in edges:\n        graph[u].append((v, g, l))\n        graph[v].append((u, g, l))\n        \n    for u, v, g, l in edges:\n        if l % g != 0:\n            print(\"NO\")\n            return\n        product = g * l\n        a_times_b = l // g\n        if a_times_b == 0:\n            print(\"NO\")\n            return\n            \n    candidate = [0] * n\n    for i in range(n):\n        if graph[i]:\n            _, *rest = graph[i][0]\n            g_val = rest[1]\n            l_val = rest[2]\n            candidate[i] = (l_val // g_val) * (g_val // math.gcd(l_val, g_val)) * (g_val // math.gcd(l_val, g_val))\n        else:\n            candidate[i] = 1\n            \n    for u, v, g, l in edges:\n        a_val = candidate[u]\n        b_val = candidate[v]\n        if a_val * b_val != g * l:\n            print(\"NO\")\n            return\n            \n        if math.gcd(a_val, b_val) != g:\n            print(\"NO\")\n            return\n            \n    print(\"YES\")\n    print(' '.join(map(str, candidate)))\n    \nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Input Parsing**: The input is read and parsed into the number of lawns (nodes) and roads (edges). Each edge is stored with its connecting nodes and GCD/LCM values.\n2. **Edge Validation**: For each edge, check if the LCM is divisible by the GCD. If not, immediately return \"NO\".\n3. **Candidate Initialization**: For each node, initialize a candidate mushroom count based on the first encountered edge. This candidate is derived from the product of the edge's GCD and LCM divided by their GCD, adjusted to ensure consistency.\n4. **Consistency Check**: For each edge, verify that the product of the candidate mushroom counts of the connected nodes matches the edge's GCD multiplied by its LCM. Also, ensure the GCD of the two candidate counts matches the edge's specified GCD.\n5. **Output**: If all checks pass, print \"YES\" followed by the candidate mushroom counts. If any check fails, print \"NO\".\n\nThis approach efficiently checks the feasibility of restoring the mushroom counts and constructs a valid solution if possible, leveraging mathematical properties of GCD and LCM.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\nfrom collections import defaultdict, deque\n\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    \n    edges = []\n    for _ in range(m):\n        u = int(next(it)) - 1\n        v = int(next(it)) - 1\n        g = int(next(it))\n        l = int(next(it))\n        edges.append((u, v, g, l))\n        \n    graph = [[] for _ in range(n)]\n    for u, v, g, l in edges:\n        graph[u].append((v, g, l))\n        graph[v].append((u, g, l))\n        \n    for u, v, g, l in edges:\n        if l % g != 0:\n            print(\"NO\")\n            return\n        product = g * l\n        a_times_b = l // g\n        if a_times_b == 0:\n            print(\"NO\")\n            return\n            \n    candidate = [0] * n\n    for i in range(n):\n        if graph[i]:\n            _, *rest = graph[i][0]\n            g_val = rest[1]\n            l_val = rest[2]\n            candidate[i] = (l_val // g_val) * (g_val // math.gcd(l_val, g_val)) * (g_val // math.gcd(l_val, g_val))\n        else:\n            candidate[i] = 1\n            \n    for u, v, g, l in edges:\n        a_val = candidate[u]\n        b_val = candidate[v]\n        if a_val * b_val != g * l:\n            print(\"NO\")\n            return\n            \n        if math.gcd(a_val, b_val) != g:\n            print(\"NO\")\n            return\n            \n    print(\"YES\")\n    print(' '.join(map(str, candidate)))\n    \nif __name__ == '__main__':\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 552,
        "completion_token_count": 1054,
        "thoughts_token_count": 1023
    }
}