{
    "start": 1758300299.3475418,
    "end": 1758304143.3409977,
    "start-formatted": "2025-09-20 01:44 KST",
    "end-formatted": "2025-09-20 02:49 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a hard question."
        }
    ],
    "thought": "\n Okay, we are given an integer p (0 <= p <= 200000). We need to:\n 1. Find the minimum number of nodes n such that there exists a directed graph with n nodes that is p-reachable.\n    - Note: The graph must have exactly p ordered pairs (u, v) with u < v and u and v being mutually reachable.\n\n 2. Among all graphs with the minimum number of nodes that are p-reachable, find the maximum number of unidirectional pairs (u, v) (with u != v, a path from u to v but not from v to u).\n\n Observation for part 1:\n\n What does it mean for a directed graph to be p-reachable?\n    It has exactly p unordered pairs {u, v} (or ordered pairs (u, v) with u < v) that are mutually reachable.\n\n In a strongly connected component (SCC), every pair of nodes (u, v) with u < v is mutually reachable? \n    Actually, note: the condition is for the entire graph to have exactly p such pairs. However, note that if two nodes are in the same SCC, then they are mutually reachable. But also, if we have multiple SCCs, then two nodes in different SCCs might not be mutually reachable.\n\n However, note: the problem says \"exactly p ordered pairs (u, v) such that u < v and u and v are reachable from each other\". \n\n Important: The graph must be such that the set of mutual reachability (i.e., the equivalence classes under the relation \"u and v are mutually reachable\") forms exactly p pairs (each pair being one unordered pair, but the problem counts (u, v) for u < v). \n\n How can we arrange the graph?\n\n Consider: We can break the graph into several strongly connected components (SCCs). Then, two nodes are mutually reachable if and only if they are in the same SCC (because if they are in different SCCs, then no path exists from one to the other in both directions). \n\n So, if we break the graph into k SCCs, then the number of mutual pairs is the sum_{each SCC of size s} [C(s,2)] (where C(s,2)= s*(s-1)//2). \n\n Therefore, we need to represent p as the sum of combinations (triangular numbers) of sizes of disjoint sets (the SCCs) and minimize the total number of nodes (which is the sum of the sizes of the SCCs).\n\n But note: we are allowed to have as many SCCs as we want? Actually, the entire graph must be built with nodes and edges. However, to minimize the total number of nodes, we want to use the representation of p as a sum of triangular numbers with the smallest possible total nodes.\n\n However, note: the triangular numbers T(s) = s*(s-1)//2. We wish to write p as a sum of triangular numbers (each triangular number corresponds to an SCC of size s) and we wish to minimize the total number of nodes (which is the sum of the s_i's). \n\n But note: the graph must be built so that the SCCs are disjoint and the graph is directed. Also, note that we cannot split a node. However, we can form an SCC of any size.\n\n However, there is a catch: the entire graph must be built with exactly the SCCs we choose, and the mutual pairs are exactly the ones within the SCCs.\n\n But note: the problem does not require the graph to be strongly connected. We can have multiple SCCs. However, the condition is on the mutual reachability: two nodes are mutually reachable if and only if they are in the same SCC.\n\n Now, how to minimize the total number of nodes?\n\n Let the SCCs have sizes s1, s2, ..., sk. Then the total nodes n = s1 + s2 + ... + sk, and the total mutual pairs = T(s1) + T(s2) + ... + T(sk) = p.\n\n We wish to minimize n.\n\n This is equivalent to: represent p as a sum of triangular numbers (each triangular number T(s)=s*(s-1)//2) and minimize the sum of the bases s (since each triangular number comes from an s). \n\n However, note: we are allowed to use the same s multiple times? Yes, because we can have multiple SCCs of the same size.\n\n Example: \n   p=3: \n      We can use one SCC of size 3: T(3)=3 -> n=3.\n      Alternatively, we could use three SCCs of size 2: T(2)=1, so 1+1+1=3 -> n=6. \n      Or one SCC of size 2 and one SCC of size 2 and one SCC of size 1: T(2)+T(2)+T(1)=1+1+0=2 -> doesn't work.\n\n So the minimal n is 3.\n\n But note: we can also use one SCC of size 3, or two SCCs: one of size 4 (T(4)=6) is too big, so we must use smaller ones.\n\n How to compute this?\n\n We note that the triangular numbers grow quadratically. We are allowed to use at most p (if we use all SCCs of size 2, then each contributes 1, so we would need p SCCs of size 2, then n=2p).\n\n But we want the minimal n.\n\n Observation: We can use an SCC of size s only once, but actually we can use multiple SCCs of the same size.\n\n However, we can also use a greedy approach: use as many large triangular numbers as possible to reduce the total nodes.\n\n But note: the triangular numbers are not necessarily additive in a way that minimizes the total base. We are trying to minimize the sum of the bases (s_i) given that the sum of T(s_i) is p.\n\n We can also note: the minimal n is achieved by using as few SCCs as possible? Actually, no: consider that a larger SCC gives more pairs per node. For example, an SCC of size s gives T(s) pairs with s nodes. The ratio T(s)/(s) = (s-1)/2. This ratio increases with s. So to get a fixed amount of pairs, we want to use as large as possible SCCs.\n\n Therefore, we can use dynamic programming or greedy to represent p as a sum of triangular numbers (each triangular number can be used arbitrarily many times) and we wish to minimize the total base (the sum of the s_i's).\n\n However, note: the triangular numbers are not consecutive and the problem constraints are up to 200000.\n\n Alternatively, we can think: what is the maximum number of pairs we can get with n nodes? \n   Maximum pairs: if we form one big SCC of size n, then the number of pairs is T(n)=n*(n-1)//2.\n   Minimum pairs: we can form as many SCCs of size 1 as we want (which contribute 0) and one SCC of size 2 for each pair we want. But wait, we can also form SCCs of size 2,3,... \n\n But note: we are required to have exactly p pairs.\n\n We wish to minimize n (the total nodes) such that there exists a decomposition of p into a sum of triangular numbers (each triangular number T(s) for s>=1, and T(1)=0, T(2)=1, T(3)=3, T(4)=6, ...) and the sum of the s_i's is minimized.\n\n However, note: the triangular numbers are defined for s>=1, but T(1)=0, T(2)=1, T(3)=3, T(4)=6, T(5)=10, etc.\n\n We can use a greedy algorithm that uses the largest triangular numbers first to minimize the total base.\n\n But note: the base s for a triangular number T(s) is s, and T(s) = s*(s-1)//2.\n\n Steps for part 1:\n\n   We wish to represent p as a sum of triangular numbers (with repetition allowed) and minimize the total base (the sum of s_i).\n\n   Since the triangular numbers are increasing and the ratio T(s)/s is increasing, we should use as many large triangular numbers as possible.\n\n   However, we cannot exceed p.\n\n   Let s_max be the maximum s such that T(s) <= p.\n\n   Then, we can use dynamic programming for small p? But p can be up to 200000.\n\n   Alternatively, we can use a greedy method that uses the largest triangular numbers (starting from s_max down to 2) and then adjust with smaller ones.\n\n   But note: the triangular numbers are not contiguous and we are allowed to use any combination.\n\n   Another idea: we can also use the fact that the triangular numbers are convex. We want to minimize the total base (n) given that the sum of T(s_i) = p.\n\n   Let n = s1+s2+...+sk, and p = T(s1)+T(s2)+...+T(sk).\n\n   We know that T(s) = s*(s-1)//2, and note that the base s_i is at least ceil((1+sqrt(1+8p))/2) for one component? \n\n   However, we can use a known result: the minimal representation of p as a sum of triangular numbers (allowing repetitions) is achieved by using as many large triangular numbers as possible.\n\n   Algorithm for part 1:\n\n     Step 1: Precompute the triangular numbers and their corresponding s (from s=1 to s_max, where T(s_max) >= p).\n\n     Step 2: Use a greedy algorithm that subtracts the largest triangular number <= p, and then continues until p becomes 0, and then the total base is the sum of the s_i's.\n\n     But is this greedy optimal for minimizing the total base?\n\n        Example: p=3. \n            Largest triangular <=3: T(3)=3, so use s=3, then total base=3.\n            Alternatively: T(2)=1, then we need three T(2)'s: base=2+2+2=6, which is worse.\n\n        Example: p=4.\n            Largest triangular <=4: T(3)=3, then remainder=1 -> T(2)=1, so base=3+2=5.\n            Alternatively: four T(2)'s: base=8, which is worse.\n\n        Example: p=5.\n            Largest triangular <=5: T(3)=3, remainder=2 -> cannot use T(2) because 2 is not a triangular number, but wait: 2 is not a triangular number? Actually, triangular numbers: 0,1,3,6,...\n            But note: we can use two T(2)'s: 1+1=2. Then base=3+2+2=7.\n\n        However, let me check: \n            p=5: \n                Option1: one SCC of size 3 (3 pairs) and two SCCs of size 2 (each 1 pair): 3+1+1=5. Total nodes=3+2+2=7.\n                Option2: five SCCs of size 2: 5*1=5, total nodes=10.\n                Option3: one SCC of size 4: T(4)=6 (too big) so no.\n                Option4: one SCC of size 3 and one SCC of size 2: 3+1=4, not enough.\n\n            But wait, is there a better way? What about using an SCC of size 3 and two SCCs of size 1? Then pairs=3+0+0=3, not 5.\n\n            Actually, we must cover 5 pairs. The triangular numbers available: 0,1,3,6,...\n\n            We can do: 3 (from s=3) and then 1+1 (from two s=2) -> 3+1+1=5, so base=3+2+2=7.\n\n            Alternatively, we can use one SCC of size 3 and one SCC of size 3? Then we get 3+3=6, which is too much.\n\n            So the greedy approach (using the largest triangular number) works for these examples.\n\n        Why is greedy optimal? Because the triangular numbers are increasing and the base s is roughly proportional to sqrt(T(s)) (since T(s) ~ s^2/2). Using a large triangular number gives a large reduction in p and a relatively small base (compared to using many small ones). \n\n        However, note: the base s for a triangular number T(s) is s, and we have T(s) = s*(s-1)//2. The cost per unit of p is s/(T(s)) = 2/(s-1) (for s>=2). So to minimize the total base, we want to use the largest s first (because the cost per unit p is lower for larger s). \n\n        Therefore, we can do:\n\n          while p > 0:\n              Find the largest s such that T(s) <= p.\n              Then, we use one SCC of size s, subtract T(s) from p, and add s to the base.\n\n        Then the minimal n is the base.\n\n        But wait: is that always optimal? Consider p=2. \n            Greedy: largest s: T(2)=1, then we use two of them: base=2+2=4.\n            Alternatively, we can use an SCC of size 3? T(3)=3>2, so no. Then the only way is two SCCs of size 2, giving base=4.\n\n        Example p=1: base=2.\n\n        Example p=0: then no nodes? Actually, p=0: we don't need any mutual pair. Then we can have no edges and 0 nodes? But note: the graph must have nodes? The problem says \"minimum number of nodes\". If p=0, then we can have 0 nodes? Or is there a constraint that we must have at least one node? \n\n        According to the example: Input 0 -> Output '0 0'\n\n        However, note: the definition of a graph: the graph must contain nodes. But if p=0, then we don't require any mutual pair. We can have a graph with 0 nodes. But typically, we consider graphs with at least one node. However, the problem does not specify. But the example output for p=0 is \"0 0\".\n\n        So we assume that if p=0, then the minimal number of nodes is 0.\n\n        But wait: the example input includes p=0, and the output is \"0 0\".\n\n        However, note: the problem says \"ordered pairs of nodes (u, v) in a directed graph\". If there are 0 nodes, then there are no pairs. So p=0 is satisfied.\n\n        Now, the problem: we have to output the minimal n (number of nodes) and then the maximum number of unidirectional pairs.\n\n        Part 2: Unidirectional pairs.\n\n        Definition: an ordered pair (u, v) (with u != v) is unidirectional if there is a path from u to v but not from v to u.\n\n        In our graph, we have broken the graph into SCCs. Within an SCC, there are no unidirectional pairs (because every node is mutually reachable). \n\n        Between two different SCCs, say A and B, we can have edges from A to B but not from B to A (if we make the graph acyclic between SCCs). \n\n        However, note: the graph must be p-reachable, meaning the mutual pairs are exactly p. The mutual pairs come only from within the SCCs.\n\n        How to maximize the number of unidirectional pairs?\n\n        We can arrange the edges arbitrarily between the SCCs, as long as the entire graph is built from the chosen SCCs (and the mutual pairs are fixed by the SCCs). \n\n        The unidirectional pairs can only occur between two distinct SCCs. \n\n        Consider two SCCs, say of sizes a and b. We can have two types of edges:\n          - From the first SCC to the second: then for every node in the first SCC and every node in the second SCC, we get a directed edge (so a*b edges from first to second).\n          - Similarly, we can have edges from the second to the first.\n\n        But note: if we have edges from the first to the second and not vice versa, then for every pair (u in first, v in second) we have a path from u to v (via the edges we put) and no path from v to u (because if there were, then the two SCCs would be merged). \n\n        However, we are free to choose the edges arbitrarily as long as the SCCs are formed as desired. But note: the problem requires that the graph is p-reachable, which depends only on the SCCs. The edges between SCCs do not affect the mutual reachability (as long as we don't create edges that would merge two SCCs). \n\n        Therefore, we can choose a directed acyclic graph (DAG) on the SCCs. \n\n        How many unidirectional pairs are there?\n\n          For a pair (u, v) with u and v in different SCCs, the pair is unidirectional if there is a path from u to v but not from v to u. \n\n        However, note: the definition is for the entire graph. But if we arrange the edges arbitrarily, then we can have:\n\n          For two SCCs A and B, we can choose to have edges from A to B or from B to A, or both, or none. However, if we have both, then we might create a mutual reachability between A and B? Actually, no: because if we have edges from A to B and from B to A, then every node in A can reach every node in B and vice versa, so the two SCCs would become one big SCC. But then the mutual pairs would increase by the product of the sizes of A and B (actually, the number of pairs between A and B is |A|*|B|, and then we would have to account for that in the p value). \n\n        Therefore, to keep the graph p-reachable (with the SCCs fixed), we must not have bidirectional edges between any two SCCs. \n\n        Hence, the graph on the SCCs must be a DAG. Then, the unidirectional pairs are:\n\n          For an ordered pair (u, v) with u and v in different SCCs, we count it if there is a path from u to v and not from v to u.\n\n        However, note: the definition of unidirectional pair does not require direct edges, but paths. So even if we don't put a direct edge, if we put a path from u to v and not from v to u, then it counts.\n\n        But wait: if we have two SCCs A and B, and we put some edges from A to B (but not from B to A) then we can have a path from A to B (if we connect A to B with a directed edge, then there is a path). But if we don't put any edge from B to A, then there is no path from B to A.\n\n        However, the entire graph must be built with the given SCCs. The edges within an SCC are arbitrary (as long as the SCC is strongly connected). But the edges between SCCs must not create cycles (otherwise the SCCs would merge). \n\n        Therefore, we can arrange the edges between SCCs arbitrarily as long as the condensation of the graph (the DAG of SCCs) is acyclic.\n\n        Now, the question: how to maximize the total unidirectional pairs?\n\n        We have a DAG of SCCs (nodes in the DAG are the SCCs, and edges go from an SCC to another if there is at least one edge from the first to the second). \n\n        Then, an unidirectional pair (u, v) (with u in SCC A, v in SCC B) exists if and only if there is a path from A to B in the DAG. \n\n        But note: the problem counts ordered pairs (u, v) (with u != v). And if u and v are in the same SCC, then they are not unidirectional (because they are mutually reachable). \n\n        Therefore, the total unidirectional pairs is the sum over all ordered pairs (A, B) of distinct SCCs (with A and B being SCCs) for which there is a path from A to B (in the DAG) multiplied by the product of the sizes of A and B? \n\n        Actually, for a fixed DAG structure, the number of unidirectional pairs (u, v) (with u in A, v in B) is:\n\n            If there is a path from A to B, then every node in A can reach every node in B, and no node in B can reach any node in A (because the DAG is acyclic and the condensation is a partial order). \n\n            Therefore, for each ordered pair (A, B) with A != B and there is a path from A to B, we add |A| * |B|.\n\n        However, note: the DAG might not have all possible edges. But if we want to maximize the unidirectional pairs, we would want to maximize the number of (A, B) pairs (with A->B path) and also the sizes of A and B.\n\n        But wait: we are free to choose the DAG? Actually, we can choose the edges arbitrarily as long as the condensation is acyclic. To maximize the unidirectional pairs, we should arrange the DAG to have as many edges as possible (without creating cycles). However, note that having a direct edge from A to B gives the same effect as having a path (because if there is a path, then all nodes in A can reach all nodes in B). But if we have multiple edges, we cannot change the existence of a path.\n\n        Actually, the existence of a path from A to B is determined by the DAG. The maximum number of ordered pairs (A,B) (with A != B) for which there is a path from A to B is achieved when the DAG is a total order (i.e., a linear chain). \n\n        Why? Because in a total order (linear chain), for any two distinct SCCs A and B, there is a unique direction: either A->B or B->A, and hence one of the two is present (the other isn't). And the entire DAG is transitive and connected.\n\n        Then, the total unidirectional pairs is the sum_{all pairs (A,B) with A and B distinct SCCs and A before B in the total order} (|A| * |B|).\n\n        However, note: the DAG can have multiple edges? Actually, we can have multiple edges from A to B, but that doesn't change the reachability (if we have one edge from A to B, then A can reach B; if we have more, still A can reach B). \n\n        But the definition of unidirectional pair is based on the existence of a path. So we don't care about the multiplicity.\n\n        Therefore, the maximum number of unidirectional pairs is achieved when the condensation is a total order (a linear chain) and then:\n\n            Let the SCCs be arranged in a linear order: C1, C2, ..., Ck (so edges go from Ci to Cj for i<j).\n\n            Then, for every i < j, we have a path from Ci to Cj, so we get |Ci| * |Cj| unidirectional pairs.\n\n            Therefore, the total unidirectional pairs = sum_{1<=i<j<=k} (|Ci| * |Cj|).\n\n        Now, note: the total number of nodes is n = |C1| + |C2| + ... + |Ck|.\n\n        Then, the sum_{i<j} |Ci|*|Cj| = (n^2 - (sum_i |Ci|^2)) / 2.\n\n        But wait, we have the sizes fixed (from the representation of p). We must use the representation that minimizes n (the total nodes). However, there might be multiple representations (multiple ways to break p into triangular numbers) that yield the same minimal n? \n\n        Actually, the greedy representation we did above is one way, but note: the problem says \"among all such p-reachable graphs with the minimum number of nodes\", so we must consider all decompositions of p into triangular numbers that yield the same minimal n, and then choose the one that maximizes the unidirectional pairs.\n\n        However, note: the minimal n is achieved by the greedy method (using as many large triangular numbers as possible). But is that the only representation? \n\n        Example: p=3 -> n=3 (one triangle of size 3). \n                 p=4 -> n=5 (triangle of size 3 and then a triangle of size 2: 3+2=5)\n\n        But wait, is there another representation for p=4 that also gives n=5? \n            We could use two triangles of size 2 and one triangle of size 1? But T(1)=0, so two triangles of size 2 give 1+1=2, and we need 4, so no.\n\n        Actually, the greedy representation is the unique one? Not necessarily. Consider p=6.\n\n          Greedy: use T(4)=6, so base=4.\n\n          Alternatively, we could use two T(3)=3+3=6, then base=3+3=6, which is worse.\n\n          Or, we could use six T(2)=1*6=6, base=12.\n\n        So the greedy representation gives the minimal base.\n\n        But note: the problem does not require that the graph is connected. We can have multiple SCCs. The representation is the multiset of SCCs (each of size s_i) such that the sum of T(s_i)=p and the sum of s_i is minimized.\n\n        Now, for a fixed set of SCCs (with sizes s1, s2, ..., sk) that sum to p (in triangular numbers) and total nodes n = s1+s2+...+sk (minimal), then the maximum number of unidirectional pairs is:\n\n            (n^2 - (s1^2+s2^2+...+sk^2)) // 2\n\n        Why? Because the sum_{i<j} |Ci||Cj| = ( (sum_i |Ci|)^2 - sum_i |Ci|^2 ) / 2.\n\n        But note: we are allowed to arrange the DAG arbitrarily (as long as acyclic) to maximize the unidirectional pairs. And the maximum is achieved by the linear chain.\n\n        However, is that true regardless of the sizes? Yes, because the formula for the linear chain is independent of the ordering (it's just the sum of the products for every pair). \n\n        But wait: is that the same as the entire graph? \n\n          The entire graph's unidirectional pairs are the sum over all ordered pairs (u, v) (u != v) that are in different SCCs and for which there is a path from u to v (and not from v to u). \n\n          In the linear chain, the set of pairs (u, v) is exactly the pairs (u in Ci, v in Cj) for which i < j. \n\n          And the number is the sum_{i<j} (|Ci|*|Cj|).\n\n        Now, the question: are there other DAGs that would yield more unidirectional pairs? \n\n          Consider two SCCs: A and B. In the linear chain, we can have either A->B or B->A. Then the pairs from A to B are |A|*|B| and from B to A are 0 (if we choose A->B) or vice versa. \n\n          But if we don't put any edge from A to B, then there is no path from A to B, so no unidirectional pair from A to B. Similarly, if we don't put any edge from B to A, then no unidirectional pair from B to A.\n\n          However, if we put both edges (A->B and B->A) then the two SCCs would merge, which we cannot do (because then the mutual pairs would increase). \n\n          Therefore, we must choose one direction or the other (or none) for each pair of SCCs. But note: if we choose none, then we get zero for that pair. \n\n          The maximum is achieved by choosing a total order (linear chain) and then we have for every unordered pair (A,B) one direction (the one that fits the chain) and that gives |A|*|B| for that direction.\n\n        Therefore, the maximum unidirectional pairs is indeed the sum_{i<j} (|Ci| * |Cj|) = (n^2 - sum_i |Ci|^2) // 2.\n\n        However, note: the problem says \"among all such p-reachable directed graphs with the minimum number of nodes, let G denote a graph which maximizes the number of unidirectional pairs of nodes.\".\n\n        But wait: is the representation (the multiset of SCCs) fixed for a given minimal n? \n\n        Example: p=5. Minimal n=7 (from the greedy representation: one SCC of size 3 and two of size 2). \n\n        But is there another representation that uses 7 nodes and gives p=5? \n\n          We have to form 5 pairs. The SCCs must have sizes s1, s2, s3 such that s1+s2+s3=7 and T(s1)+T(s2)+T(s3)=5.\n\n          The triangular numbers for s>=1: T(1)=0, T(2)=1, T(3)=3, T(4)=6 (too big).\n\n          So we need to assign sizes from {1,2,3}. \n\n          Let the sizes be (a,b,c) with a<=b<=c and a+b+c=7.\n\n          Possibilities:\n            (1,2,4): but T(4)=6 -> 0+1+6=7 -> too much.\n            (1,3,3): T(1)=0, T(3)=3, T(3)=3 -> 0+3+3=6 -> too much.\n            (2,2,3): T(2)=1, T(2)=1, T(3)=3 -> 1+1+3=5 -> yes.\n\n          So there are two representations: \n            Representation1: [3,2,2] (from the greedy: we took the largest triangular number 3, then the remainder 2 is represented by two 1's (which are T(2)=1, so two SCCs of size 2))\n            Representation2: [2,2,3] (same as Representation1, just sorted)\n\n          Actually, they are the same multiset.\n\n          Another possibility: (1,1,5): T(5)=10 -> too big.\n                   (1,1,5) invalid.\n\n          So the representation is unique for minimal n? \n\n        But wait: sometimes there might be multiple multisets that yield the same minimal n. \n\n        Example: p=10.\n\n          Greedy: \n            Largest triangular <=10: T(5)=10 -> use one SCC of size 5, then n=5.\n\n          Alternatively, we could use two SCCs of size 4 and one of size 2? \n            T(4)=6, T(4)=6, then 6+6=12>10 -> not valid.\n\n          Or, one SCC of size 5: 10 -> n=5.\n\n          Another representation: \n            T(4)=6, then remainder=4. Then use T(3)=3 and T(2)=1: 6+3+1=10, then n=4+3+2=9 -> not minimal.\n\n          Or, T(3)=3, then remainder=7. Then T(4)=6 -> 3+6=9, then remainder=1 -> T(2)=1, then n=3+4+2=9.\n\n          Or, T(3)=3, then remainder=7: use T(3)=3 and T(3)=3 and T(2)=1 and T(2)=1: 3+3+1+1=8, then n=3+3+2+2=10.\n\n          So the minimal n is 5.\n\n          Is there another multiset of triangular numbers that sums to 10 and has a total base of 5? \n            We need the base (the sum of the s_i) to be 5, and the triangular numbers must be 10.\n\n            The triangular numbers from the multiset must be chosen from {T(1)=0, T(2)=1, T(3)=3, T(4)=6, T(5)=10}. \n\n            We need to choose numbers that sum to 10, and the base (the s_i) must sum to 5.\n\n            The base is the sum of the s_i. So if we use T(5)=10, then base=5.\n\n            If we use T(4)=6, then we need 10-6=4 from the rest. The rest must be represented by triangular numbers with base at least 4 (since the smallest triangular number is 0, but then we need 4: we can use T(2)=1 four times: base=2*4=8, total base=4+8=12). Or T(3)=3 and then T(2)=1: 6+3+1=10, base=4+3+2=9.\n\n            So the only representation with base=5 is one SCC of size 5.\n\n        Therefore, for p=10, the representation is unique.\n\n        Now, what if we have two different multisets that yield the same minimal n?\n\n        Example: p=2.\n\n          Minimal representation: two SCCs of size 2: base=4, and p=1+1=2.\n\n          Is there another representation with base=4? \n            We need two triangular numbers that sum to 2, and the base (the s_i) must sum to 4.\n\n            Possibilities: \n              Two T(2): 1+1=2, base=2+2=4.\n              One T(3)=3 (too big) or T(1)=0: then we need two more: 0+? -> not.\n\n          So unique.\n\n        Example: p=0 -> base=0.\n\n        Example: p=1 -> base=2 (two SCCs of size 1? but wait: no, we have to use T(2)=1, so one SCC of size 2, base=2). \n\n          But wait: the representation for p=1: \n            We can use one SCC of size 2: base=2, then p=1.\n            Alternatively, we could use two SCCs of size 2? Then p=2, too much.\n            Or, one SCC of size 1 and one SCC of size 2? Then p=0+1=1, base=1+2=3 -> not minimal.\n\n          So minimal base=2.\n\n        Now, consider p=6.\n\n          Greedy: T(4)=6 -> base=4.\n\n          Another representation: two T(3)=3+3=6, base=3+3=6 -> not minimal.\n\n          Or, six T(2)=6, base=12.\n\n          So minimal base=4.\n\n        But wait, what if we use a mix? \n          We can use T(3)=3 and then T(3)=3, but that gives base=6, which is bigger than 4.\n\n        Example: p=7.\n\n          Greedy: T(4)=6, then remainder=1 -> T(2)=1, base=4+2=6.\n\n          Another representation: T(3)=3, then remainder=4 -> T(3)=3 and then T(2)=1 and T(2)=1 -> base=3+3+2+2=10 -> worse.\n\n          Or, T(3)=3, then T(2)=1, then T(2)=1, then T(2)=1 -> base=3+2+2+2=9 -> worse.\n\n          Or, T(2) seven times: base=14.\n\n          So minimal base=6.\n\n        Example: p=8.\n\n          Greedy: T(4)=6, remainder=2 -> two T(2)=1+1=2, base=4+2+2=8.\n\n          Another representation: two T(4)=12 -> too big.\n\n          Or, T(3)=3, then remainder=5 -> then T(3)=3 and T(3)=3 and T(2)=1 -> 3+3+3+1=10, base=3+3+3+2=11.\n\n          Or, one T(3)=3, then remainder=5: we can use one T(4)=6 -> then 3+6=9, base=3+4=7, but 9>8 -> no.\n\n          Or, two T(3)=6, then remainder=2 -> two T(2)=1+1=2, base=3+3+2+2=10.\n\n          So minimal base=8.\n\n        Example: p=9.\n\n          Greedy: T(4)=6, remainder=3 -> T(3)=3, base=4+3=7.\n\n          Another representation: three T(3)=9, base=3+3+3=9 -> worse.\n\n          Or, T(4)=6 and then T(2)=1 and T(2)=1 and T(2)=1: 6+3=9, base=4+2+2+2=10.\n\n          Or, two T(4)=1",
    "response": "\nTo solve this problem, we need to determine the minimum number of nodes required to create a directed graph that is p-reachable, and among all such graphs with the minimum number of nodes, find the maximum number of unidirectional node pairs.\n\n### Approach\n1. **Problem Analysis**:\n   - A directed graph is p-reachable if it contains exactly p ordered pairs of nodes (u, v) where u < v and u and v are mutually reachable (i.e., there exists a path from u to v and vice versa).\n   - The mutual reachability between nodes is determined by strongly connected components (SCCs). Each SCC contributes \\( \\binom{s}{2} \\) pairs where \\( s \\) is the size of the SCC.\n   - The goal is to decompose the integer \\( p \\) into a sum of triangular numbers (each representing an SCC) such that the sum of the corresponding SCC sizes (nodes) is minimized.\n\n2. **Key Insight**:\n   - The minimal number of nodes is achieved by using as many large triangular numbers as possible. This is because larger SCCs provide more mutual pairs per node, thus minimizing the total node count for a given \\( p \\).\n\n3. **Algorithm Selection**:\n   - **Greedy Algorithm**: For each \\( p \\), repeatedly subtract the largest triangular number less than or equal to the remaining value. The sum of the bases (sizes) of these triangular numbers gives the minimal number of nodes.\n   - **Unidirectional Pairs Calculation**: For the decomposition found, the maximum number of unidirectional pairs is calculated by arranging the SCCs in a linear order (a DAG) and summing the products of the sizes of all pairs of SCCs that are connected in the direction of the order. This is given by \\( \\frac{n^2 - \\sum s_i^2}{2} \\), where \\( n \\) is the total number of nodes and \\( s_i \\) are the sizes of the SCCs.\n\n4. **Complexity Analysis**:\n   - The algorithm efficiently computes the decomposition using a greedy approach, which operates in \\( O(\\sqrt{p}) \\) time due to the triangular numbers' growth rate. The unidirectional pairs calculation is \\( O(k) \\), where \\( k \\) is the number of SCCs, which is optimal for the given constraints.\n\n### Solution Code\n```python\ndef main():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    p = int(data[0])\n    \n    if p == 0:\n        print(\"0 0\")\n        return\n        \n    triangular = []\n    s_val = 1\n    while True:\n        t_val = s_val * (s_val - 1) // 2\n        if t_val > p:\n            break\n        triangular.append((t_val, s_val))\n        s_val += 1\n        \n    triangular.reverse()\n    \n    base = 0\n    remaining = p\n    num_nodes = 0\n    sizes = []\n    for t, s in triangular:\n        if remaining == 0:\n            break\n        if t <= remaining:\n            count = remaining // t\n            base += count\n            num_nodes += count * s\n            sizes.extend([s] * count)\n            remaining %= t\n            \n    if remaining != 0:\n        while remaining > 0:\n            t_val = (s_val-1) * (s_val-2) // 2\n            if t_val <= remaining:\n                count = remaining // t_val\n                base += count\n                num_nodes += count * s_val\n                sizes.extend([s_val] * count)\n                remaining %= t_val\n                s_val += 1\n            else:\n                t_val = (s_val-1) * (s_val-2) // 2\n                count = remaining // t_val\n                base += count\n                num_nodes += count * s_val\n                sizes.extend([s_val] * count)\n                remaining %= t_val\n                s_val += 1\n        total_size = sum(sizes)\n        if total_size != num_nodes:\n            num_nodes = total_size\n\n    n = num_nodes\n    sum_of_squares = sum(x*x for x in sizes)\n    unidirectional = (n*n - sum_of_squares) // 2\n\n    print(f\"{n} {unidirectional}\")\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read from standard input, which is a single integer \\( p \\).\n2. **Special Case Handling**: If \\( p \\) is 0, the output is \"0 0\" since no nodes are needed.\n3. **Triangular Numbers Generation**: The algorithm generates all triangular numbers up to \\( p \\) and stores them along with their corresponding base values (SCC sizes).\n4. **Greedy Decomposition**: The algorithm decomposes \\( p \\) into a sum of triangular numbers by repeatedly selecting the largest possible triangular number, adjusting the remaining value, and accumulating the corresponding node counts.\n5. **Unidirectional Pairs Calculation**: Using the sizes of the SCCs obtained from the decomposition, the algorithm calculates the maximum number of unidirectional pairs by arranging the SCCs in a linear order and summing the products of their sizes.\n6. **Output**: The minimal number of nodes and the maximum number of unidirectional pairs are printed.\n\nThis approach efficiently addresses the problem by leveraging mathematical insights and greedy decomposition to minimize the node count and maximize unidirectional pairs.",
    "ground_truth": "N/A",
    "extracted_answer": "def main():\n    import sys\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    p = int(data[0])\n    \n    if p == 0:\n        print(\"0 0\")\n        return\n        \n    triangular = []\n    s_val = 1\n    while True:\n        t_val = s_val * (s_val - 1) // 2\n        if t_val > p:\n            break\n        triangular.append((t_val, s_val))\n        s_val += 1\n        \n    triangular.reverse()\n    \n    base = 0\n    remaining = p\n    num_nodes = 0\n    sizes = []\n    for t, s in triangular:\n        if remaining == 0:\n            break\n        if t <= remaining:\n            count = remaining // t\n            base += count\n            num_nodes += count * s\n            sizes.extend([s] * count)\n            remaining %= t\n            \n    if remaining != 0:\n        while remaining > 0:\n            t_val = (s_val-1) * (s_val-2) // 2\n            if t_val <= remaining:\n                count = remaining // t_val\n                base += count\n                num_nodes += count * s_val\n                sizes.extend([s_val] * count)\n                remaining %= t_val\n                s_val += 1\n            else:\n                t_val = (s_val-1) * (s_val-2) // 2\n                count = remaining // t_val\n                base += count\n                num_nodes += count * s_val\n                sizes.extend([s_val] * count)\n                remaining %= t_val\n                s_val += 1\n        total_size = sum(sizes)\n        if total_size != num_nodes:\n            num_nodes = total_size\n\n    n = num_nodes\n    sum_of_squares = sum(x*x for x in sizes)\n    unidirectional = (n*n - sum_of_squares) // 2\n\n    print(f\"{n} {unidirectional}\")\n\nif __name__ == '__main__':\n    main()",
    "score": 1,
    "metadata": {
        "prompt_token_count": 474,
        "completion_token_count": 1162,
        "thoughts_token_count": 8191
    }
}