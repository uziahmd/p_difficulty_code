{
    "start": 1758088080.3615527,
    "end": 1758089244.100725,
    "start-formatted": "2025-09-17 14:48 KST",
    "end-formatted": "2025-09-17 15:07 KST",
    "gpu": 2,
    "pid": 6,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Hacker, pack your bags!\n\nIt's well known that the best way to distract from something is to do one's favourite thing. Job is such a thing for Leha.So the hacker began to work hard in order to get rid of boredom. It means that Leha began to hack computers all over the world. For such zeal boss gave the hacker a vacation of exactly x days. You know the majority of people prefer to go somewhere for a vacation, so Leha immediately went to the travel agency. There he found out that n vouchers left. i-th voucher is characterized by three integers li, ri, costi — day of departure from Vičkopolis, day of arriving back in Vičkopolis and cost of the voucher correspondingly. The duration of the i-th voucher is a value ri - li + 1.At the same time Leha wants to split his own vocation into two parts. Besides he wants to spend as little money as possible. Formally Leha wants to choose exactly two vouchers i and j (i ≠ j) so that they don't intersect, sum of their durations is exactly x and their total cost is as minimal as possible. Two vouchers i and j don't intersect if only at least one of the following conditions is fulfilled: ri < lj or rj < li.Help Leha to choose the necessary vouchers!\n\n## Input\nThe first line contains two integers n and x (2 ≤ n, x ≤ 2·105) — the number of vouchers in the travel agency and the duration of Leha's vacation correspondingly.Each of the next n lines contains three integers li, ri and costi (1 ≤ li ≤ ri ≤ 2·105, 1 ≤ costi ≤ 109) — description of the voucher.\n\n## Output\nPrint a single integer — a minimal amount of money that Leha will spend, or print  - 1 if it's impossible to choose two disjoint vouchers with the total duration exactly x.\n\n## Example\n### Input\n['4 5\\n1 3 4\\n1 2 5\\n5 6 1\\n1 2 4', '3 2\\n4 6 3\\n2 4 1\\n3 5 4']\n\n### Output\n['5', '-1']\n\n## Note\nIn the first sample Leha should choose first and third vouchers. Hereupon the total duration will be equal to (3 - 1 + 1) + (6 - 5 + 1) = 5 and the total cost will be 4 + 1 = 5.In the second sample the duration of each voucher is 3 therefore it's impossible to choose two vouchers with the total duration equal to 2.\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very hard question."
        }
    ],
    "thought": "\n Okay, we are given n and x (the total desired duration) and then n lines of [l, r, cost]\n Each voucher has duration = r - l + 1.\n\n Conditions:\n We need two distinct vouchers i and j such that:\n   (duration_i + duration_j == x) and the two intervals [li, ri] and [lj, rj] do not intersect (at least one condition: ri < lj or rj < li).\n\n We want the minimal total cost.\n\n Approach:\n\n Since x can be up to 200,000 and the number of vouchers is up to 200,000, we cannot try all pairs.\n\n Idea:\n Let d = duration of a voucher = r-l+1.\n\n We are looking for two durations d1 and d2 such that d1+d2 = x.\n\n Then we need to consider two types of non-overlapping conditions:\n   Condition 1: [l1, r1] and [l2, r2] with r1 < l2 (voucher1 ends before voucher2 starts)\n   Condition 2: [l2, r2] and [l1, r1] with r2 < l1 (voucher2 ends before voucher1 starts)\n\n However, note that the two conditions are symmetric. We can assume without loss of generality that we fix the first voucher (with duration d1) and then look for a second voucher (with duration d2 = x-d1) that does not overlap.\n\n But note: the two vouchers are chosen arbitrarily (not ordered by time). So we have two cases: \n   Case A: The first voucher ends before the second starts.\n   Case B: The second voucher ends before the first starts.\n\n Actually, the problem says: they don't intersect if at least one of the following holds:\n   Condition 1: ri < lj   (voucher i ends before voucher j starts)\n   Condition 2: rj < li   (voucher j ends before voucher i starts)\n\n But note: the two conditions are independent and we can consider both orders.\n\n However, we can restructure the problem:\n\n Let's group the vouchers by their duration. For each duration d (from 1 to max_duration, which is <= 200000), we store all vouchers with that duration, and we want to quickly query for a given duration d, what is the minimal cost for a voucher that ends (or starts) at a certain point.\n\n Specifically, for a fixed duration d1, we require a voucher with duration d2 = x - d1.\n\n Then we have two possibilities:\n\n Possibility 1: Voucher1 (duration d1) and Voucher2 (duration d2) with r1 < l2.\n Possibility 2: Voucher1 (duration d1) and Voucher2 (duration d2) with r2 < l1.\n\n But note: in Possibility 1, we require that the entire interval of voucher1 is before voucher2. Similarly, in Possibility 2, the entire interval of voucher2 is before voucher1.\n\n However, we can also consider: which one is the first? Actually, the condition is symmetric, but we are going to consider two cases:\n\n Case 1: We take a voucher i with duration d1, and then look for a voucher j (with duration d2=x-d1) such that the end of i is less than the start of j.\n\n Case 2: We take a voucher j with duration d2, and then look for a voucher i (with duration d1) such that the end of j is less than the start of i.\n\n But note: the two cases are actually the same if we swap i and j. So we can do:\n\n For each duration d1, we have a set of vouchers (each represented by (l, r, cost)).\n Then we want to find a voucher j with duration d2 = x-d1 that satisfies either:\n   Option A: (r1 < l2) [if we take voucher i first and then j] OR\n   Option B: (r2 < l1) [if we take voucher j first and then i]\n\n However, note that we are allowed to choose any two, so we must consider both orders.\n\n Alternate approach:\n\n Since the condition requires non-overlapping, we can think of two separate orders: one where the first voucher ends before the second starts, and the other where the second voucher ends before the first starts.\n\n But note: we can combine the two by considering the entire set of vouchers and grouping by duration.\n\n Steps:\n\n 1. Precompute an array for each duration d (from 1 to maybe max_r = 200000) that contains all the vouchers (l, r, cost) with that duration.\n\n 2. Then, we are going to iterate over the durations d from 1 to max_d (which is min(20000",
    "response": "\nTo solve this problem, we need to find two distinct travel vouchers such that their combined duration equals exactly `x` days, they do not overlap in time, and their total cost is minimized. The solution involves efficiently processing the vouchers by grouping them by their duration and then querying for complementary durations while ensuring non-overlapping conditions.\n\n### Approach\n1. **Grouping by Duration**: We first group all vouchers by their duration. This allows us to quickly access all vouchers of a specific duration when needed.\n2. **Handling Queries for Complementary Durations**: For each voucher with duration `d`, we look for another voucher with duration `x - d`. We then check if these two vouchers do not overlap by verifying if one ends before the other starts.\n3. **Efficient Query Processing**: To handle the non-overlapping condition efficiently, we maintain two sorted lists for each duration:\n   - **Start Days (l)**: Sorted by the start day (`l`) and store the minimal cost for each start day or range.\n   - **End Days (r)**: Sorted by the end day (`r`) and store the minimal cost for each end day or range.\n4. **Binary Search for Valid Pairs**: For each voucher, we use binary search on the complementary duration's start and end lists to find valid non-overlapping pairs with the minimal total cost.\n\n### Solution Code\n```python\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    data = sys.stdin.read().split()\n    it = iter(data)\n    n = int(next(it))\n    x = int(next(it))\n    vouchers = []\n    max_day = 0\n    for _ in range(n):\n        l = int(next(it))\n        r = int(next(it))\n        cost = int(next(it))\n        vouchers.append((l, r, cost))\n        max_day = max(max_day, r)\n    \n    duration_map = defaultdict(list)\n    for l, r, cost in vouchers:\n        dur = r - l + 1\n        duration_map[dur].append((l, r, cost))\n    \n    start_days = {}\n    end_days = {}\n    \n    for dur, vouchers_list in duration_map.items():\n        comp_dur = x - dur\n        if comp_dur < 1:\n            continue\n            \n        if dur == comp_dur:\n            key = 'same'\n        else:\n            key = f\"{min(dur, comp_dur)},{max(dur, comp_dur)}\"\n        \n        start_days[key] = []\n        end_days[key] = []\n        \n        for l, r, cost in vouchers_list:\n            start_days[key].append((l, cost))\n            end_days[key].append((r, cost))\n            \n        start_days[key] = sorted(start_days[key])\n        end_days[key] = sorted(end_days[key])\n    \n    ans = float('inf')\n    used = set()\n    for l, r, cost in vouchers:\n        dur = r - l + 1\n        comp_dur = x - dur\n        if comp_dur < 1 or comp_dur not in duration_map:\n            continue\n            \n        comp_key = f\"{min(dur, comp_dur)},{max(dur, comp_dur)}\"\n        \n        if dur == comp_dur:\n            idx1 = bisect.bisect_left(start_days[comp_key], (l + dur, float('inf')))\n            while idx1 < len(start_days[comp_key]) and start_days[comp_key][idx1][0] < l + dur:\n                candidate_cost = start_days[comp_key][idx1][1]\n                total = cost + candidate_cost\n                if total < ans:\n                    ans = total\n                idx1 += 1\n                \n            idx2 = bisect.bisect_left(end_days[comp_key], (r, float('inf')))\n            while idx2 < len(end_days[comp_key]) and end_days[comp_key][idx2][0] < l:\n                candidate_cost = end_days[comp_key][idx2][1]\n                total = cost + candidate_cost\n                if total < ans:\n                    ans = total\n                idx2 += 1\n        else:\n            key1 = f\"{dur},{comp_dur}\"\n            key2 = f\"{comp_dur},{dur}\"\n            \n            if key1 in start_days:\n                arr1 = start_days[key1]\n                arr2 = end_days[key2]\n            else:\n                arr1 = start_days[key2]\n                arr2 = end_days[key1]\n                \n            idx1 = bisect.bisect_left(arr1, (l + dur, float('inf')))\n            while idx1 < len(arr1) and arr1[idx1][0] < l + dur:\n                candidate_cost = arr1[idx1][1]\n                total = cost + candidate_cost\n                if total < ans:\n                    ans = total\n                idx1 += 1\n                \n            idx2 = bisect.bisect_left(arr2, (r, float('inf')))\n            while idx2 < len(arr2) and arr2[idx2][0] < l:\n                candidate_cost = arr2[idx2][1]\n                total = cost + candidate_cost\n                if total < ans:\n                    ans = total\n                idx2 += 1\n                \n    if ans == float('inf'):\n        print(-1)\n    else:\n        print(ans)\n\nif __name__ == \"__main__\":\n    import bisect\n    main()\n```\n\n### Explanation\n1. **Input Reading and Initialization**: The input is read and parsed into a list of vouchers. Each voucher is characterized by its start day, end day, and cost.\n2. **Grouping by Duration**: Vouchers are grouped by their duration using a dictionary where the key is the duration and the value is a list of tuples containing the start day, end day, and cost.\n3. **Building Start and End Lists**: For each duration, we create two lists:\n   - **Start Days**: Sorted by start day, storing tuples of (start day, cost).\n   - **End Days**: Sorted by end day, storing tuples of (end day, cost).\n4. **Query Processing**: For each voucher, we determine the complementary duration (`x - current duration`). Using binary search, we check for valid non-overlapping vouchers in the complementary duration's start and end lists. The minimal total cost is tracked throughout this process.\n5. **Output Result**: After processing all vouchers, if a valid pair is found, the minimal total cost is printed; otherwise, `-1` is printed indicating no valid pair exists. \n\nThis approach efficiently narrows down the search space using grouping and binary search, ensuring optimal performance even for large input sizes.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\nfrom collections import defaultdict\n\ndef main():\n    data = sys.stdin.read().split()\n    it = iter(data)\n    n = int(next(it))\n    x = int(next(it))\n    vouchers = []\n    max_day = 0\n    for _ in range(n):\n        l = int(next(it))\n        r = int(next(it))\n        cost = int(next(it))\n        vouchers.append((l, r, cost))\n        max_day = max(max_day, r)\n    \n    duration_map = defaultdict(list)\n    for l, r, cost in vouchers:\n        dur = r - l + 1\n        duration_map[dur].append((l, r, cost))\n    \n    start_days = {}\n    end_days = {}\n    \n    for dur, vouchers_list in duration_map.items():\n        comp_dur = x - dur\n        if comp_dur < 1:\n            continue\n            \n        if dur == comp_dur:\n            key = 'same'\n        else:\n            key = f\"{min(dur, comp_dur)},{max(dur, comp_dur)}\"\n        \n        start_days[key] = []\n        end_days[key] = []\n        \n        for l, r, cost in vouchers_list:\n            start_days[key].append((l, cost))\n            end_days[key].append((r, cost))\n            \n        start_days[key] = sorted(start_days[key])\n        end_days[key] = sorted(end_days[key])\n    \n    ans = float('inf')\n    used = set()\n    for l, r, cost in vouchers:\n        dur = r - l + 1\n        comp_dur = x - dur\n        if comp_dur < 1 or comp_dur not in duration_map:\n            continue\n            \n        comp_key = f\"{min(dur, comp_dur)},{max(dur, comp_dur)}\"\n        \n        if dur == comp_dur:\n            idx1 = bisect.bisect_left(start_days[comp_key], (l + dur, float('inf')))\n            while idx1 < len(start_days[comp_key]) and start_days[comp_key][idx1][0] < l + dur:\n                candidate_cost = start_days[comp_key][idx1][1]\n                total = cost + candidate_cost\n                if total < ans:\n                    ans = total\n                idx1 += 1\n                \n            idx2 = bisect.bisect_left(end_days[comp_key], (r, float('inf')))\n            while idx2 < len(end_days[comp_key]) and end_days[comp_key][idx2][0] < l:\n                candidate_cost = end_days[comp_key][idx2][1]\n                total = cost + candidate_cost\n                if total < ans:\n                    ans = total\n                idx2 += 1\n        else:\n            key1 = f\"{dur},{comp_dur}\"\n            key2 = f\"{comp_dur},{dur}\"\n            \n            if key1 in start_days:\n                arr1 = start_days[key1]\n                arr2 = end_days[key2]\n            else:\n                arr1 = start_days[key2]\n                arr2 = end_days[key1]\n                \n            idx1 = bisect.bisect_left(arr1, (l + dur, float('inf')))\n            while idx1 < len(arr1) and arr1[idx1][0] < l + dur:\n                candidate_cost = arr1[idx1][1]\n                total = cost + candidate_cost\n                if total < ans:\n                    ans = total\n                idx1 += 1\n                \n            idx2 = bisect.bisect_left(arr2, (r, float('inf')))\n            while idx2 < len(arr2) and arr2[idx2][0] < l:\n                candidate_cost = arr2[idx2][1]\n                total = cost + candidate_cost\n                if total < ans:\n                    ans = total\n                idx2 += 1\n                \n    if ans == float('inf'):\n        print(-1)\n    else:\n        print(ans)\n\nif __name__ == \"__main__\":\n    import bisect\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 735,
        "completion_token_count": 1375,
        "thoughts_token_count": 1023
    }
}