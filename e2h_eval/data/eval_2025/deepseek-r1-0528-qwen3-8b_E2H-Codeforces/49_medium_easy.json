{
    "start": 1758304094.6367066,
    "end": 1758308007.9962308,
    "start-formatted": "2025-09-20 02:48 KST",
    "end-formatted": "2025-09-20 03:53 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is an easy question."
        }
    ],
    "thought": "\n Okay, we are given a graph with n nodes and m edges. Each edge (u, v) has two numbers: gcd and lcm.\n Conditions for an edge (a, b):\n   Let x = number of mushrooms on lawn u, y = on lawn v.\n   Then, gcd(x,y) must be the given gcd and lcm(x,y) must be the given lcm.\n\n We know that for any two positive integers x and y:\n   gcd(x,y) * lcm(x,y) = x * y.\n\n Also, note that x must be divisible by gcd and y must be divisible by gcd, and both x and y must divide the lcm.\n\n Steps:\n\n 1. For each edge, we can compute the product: p = gcd * lcm. Then, we have x * y = p.\n\n 2. Additionally, we know that if we set d = gcd(x,y) (which is given as g), then we can write x = d * a, y = d * b, where gcd(a,b)=1.\n    Then, the LCM would be d * a * b, so d * a * b = lcm. Therefore, a * b = lcm // d.\n\n 3. However, note that the same lawn might appear in multiple edges. So we need to assign a value to each node such that for every edge (u, v) with gcd=g and lcm=l, \n    we have:\n        x_u * x_v = g * l   [from condition 1]\n        and also the gcd(x_u, x_v) must be g.\n\n 4. Moreover, note that the value assigned to a node must be consistent across all edges incident to it.\n\n Approach:\n\n We can think of this as a system of equations. However, note that the problem does not require unique restoration, just one possible arrangement.\n\n Alternative idea:\n\n Since the constraints say that the numbers on the roads were no less than 1 and did not exceed 10^6, and the gcd and lcm are given, we can try to reconstruct the numbers for the nodes.\n\n Steps:\n\n  a. Check consistency for each edge: \n        Condition 1: gcd * lcm must be equal to x * y (but we don't know x and y). However, we know that the gcd must divide both x and y, and the lcm must be divisible by the gcd.\n\n        Actually, we can check: \n          - The given gcd must divide the given lcm (since gcd divides both x and y, so it must divide their LCM).\n          - And then, let x = gcd * a, y = gcd * b, then we must have that the LCM is gcd * a * b / gcd(a,b) = lcm. But note that if we set d = gcd, then the LCM is d * (a*b) / gcd(a,b) = lcm.\n\n        Alternatively, we can use the fact that for two numbers, the product is gcd*lcm. So if we assume x and y are divisors of the product, then we can factorize the product and look for pairs (x,y) such that x*y = gcd*lcm, and then check that gcd(x,y)==gcd and lcm(x,y)==lcm.\n\n        But note: the product might be very large (up to 10^12) and we have up to 1000 edges and 1000 nodes? Actually, n, m are up to 10^5? The problem says: first line has n and m, and then m lines. The constraints do not specify the exact range, but typically in competitive programming, n and m can be up to 10^5.\n\n        However, we cannot factorize the product for each edge and then try to assign to nodes.\n\n  b. Another idea: \n\n      From the edge (u, v): \n          x_u * x_v = g * l   (product)\n          and also, x_u and x_v must be multiples of g, and they must divide l? Actually, the LCM is the least common multiple, so yes, both x_u and x_v must divide the LCM.\n\n      But note: the LCM is the LCM of x_u and x_v, so the LCM must be divisible by both. However, we are given the LCM, so we can deduce that x_u must divide the LCM and x_v must divide the LCM.\n\n  c. However, the problem is that we have multiple edges and multiple constraints on the same node.\n\n  Proposed solution:\n\n  Step 1: For each edge, we have two conditions:\n        Condition A: x_u * x_v = g * l.\n        Condition B: gcd(x_u, x_v) = g.\n\n  Step 2: We can express x_u and x_v in terms of g and the LCM. Since x_u and x_v are multiples of g, we can write:\n        x_u = g * a, x_v = g * b, then Condition A becomes: g^2 * a * b = g * l   =>   g * a * b = l.\n        Condition B: gcd(a,b)=1.\n\n        Then, the pair (a,b) must be such that a*b = l//g, and gcd(a,b)=1.\n\n        Now, note that the same node u may appear in multiple edges. In each edge, the value of x_u must be represented as g1 * a1, then in another edge with different g2, as g2 * a2.\n\n        So, what is the actual value of x_u? It must be divisible by all the g's from the edges incident to u. But wait, that might not be the case: consider if we have two edges (u,v) and (u,w) with gcds g1 and g2 respectively. Then x_u must be divisible by both g1 and g2. However, note that the condition on the edge (u,v) is that gcd(x_u, x_v)=g1, so x_u must be divisible by g1, and similarly for g2.\n\n        Therefore, the value of x_u must be divisible by the LCM of all the gcd's from the edges incident to u.\n\n        But note: it's not necessarily the LCM of the gcds. Actually, the value x_u must be divisible by each individual gcd from each edge. So the minimal candidate for x_u is the LCM of all the gcds from the incident edges.\n\n        However, there is a catch: the entire system must satisfy the conditions for every edge.\n\n  Step 3: We can do:\n\n        Let deg(u) be the list of edges incident to u. For each edge (u,v) with gcd=g, we know that x_u must be divisible by g. So the candidate for x_u is the LCM of all g's from edges incident to u. But wait, is that sufficient? Not necessarily, because the product condition and the gcd condition must hold for every edge.\n\n        However, we can set x_u = candidate = LCM_{for each edge (u,v)} (g)   (the gcd from that edge).\n\n        Then, for each edge (u,v) with gcd=g and lcm=l, we have:\n            x_u * x_v = candidate_u * candidate_v = g * l   (must hold)\n\n        But this candidate might not satisfy the product condition. Moreover, we must also have that gcd(x_u, x_v) = g.\n\n        However, note: we are free to choose a candidate for each node as long as it satisfies the divisibility conditions. But the product condition must hold exactly.\n\n        How about: for each edge (u,v) with gcd=g and lcm=l, we know that x_u and x_v must be such that:\n            x_u * x_v = g * l, and\n            gcd(x_u, x_v) = g.\n\n        Then, we can write x_u = g * a, x_v = g * b, and then a and b must be coprime and a*b = l//g.\n\n        Now, if we set x_u to be the LCM of all the gcds from edges incident to u, then we have to check if for every edge (u,v):\n\n            Let candidate_u = LCM_{e incident to u} (gcd(e)), candidate_v = LCM_{e incident to v} (gcd(e))\n\n            Then, we must have candidate_u * candidate_v == g * l and gcd(candidate_u, candidate_v) == g.\n\n        But wait, the candidate_u might not be the minimal representation. Actually, we can set x_u to be the LCM of the gcds from the edges, but then we must also satisfy the product condition. However, the product condition is fixed: x_u*x_v must be g*l.\n\n        Therefore, we can set:\n\n            candidate_u = LCM_{e incident to u} (g_e)\n\n        Then, for each edge (u,v) with gcd=g and lcm=l, we require:\n            candidate_u * candidate_v == g * l   and   gcd(candidate_u, candidate_v) == g.\n\n        But note: the condition gcd(candidate_u, candidate_v) == g must hold. However, candidate_u is divisible by g (because it's the LCM of the gcds, and g is one of them). Similarly candidate_v is divisible by g. Then, let d = gcd(candidate_u, candidate_v). Then d must be >= g. But we require d==g.\n\n        However, it is possible that the LCM of the gcds from the incident edges (which gives candidate_u) might have more factors than necessary. Then the gcd of candidate_u and candidate_v might be larger than g.\n\n        Example: Consider two edges from node u: one edge (u,v) with gcd=2, lcm=12 (so product=24) and another edge (u,w) with gcd=3, lcm=18 (product=54). Then candidate_u = LCM(2,3)=6.\n\n        Now, for edge (u,v): \n            candidate_u * candidate_v = 6 * candidate_v must equal 24 -> candidate_v=4. But then for edge (u,w): 6 * candidate_w = 54 -> candidate_w=9. Now, check the gcd condition for (u,v): gcd(6,4)=2 -> matches. For (u,w): gcd(6,9)=3 -> matches.\n\n        But wait, how do we get candidate_v and candidate_w? We cannot independently set them. Actually, we are trying to assign a candidate for every node. However, note that the candidate for a node is defined as the LCM of the gcds from the edges incident to it. But then, the product condition for an edge (u,v) is candidate_u * candidate_v = g * l.\n\n        In the above example, we have candidate_u=6, and for edge (u,v) we require candidate_v=4. But for node v, we must consider the edges incident to it. Suppose node v only has the edge (u,v). Then candidate_v would be the LCM of the gcds from edges incident to v, which is just 2 (from the edge (u,v)). But 2 != 4.\n\n        This means that the candidate for node v is forced by the edge (u,v) to be 4, but from the incident edges to v (only one) we get candidate_v=2. So they conflict.\n\n        Therefore, we cannot simply set each node's value to the LCM of the gcds of its incident edges. We must satisfy both the divisibility and the product conditions.\n\n  Alternate approach:\n\n  We can model this as follows:\n\n      Let the value at node i be x_i.\n\n      For each edge (i, j) with gcd=g, lcm=l:\n          x_i * x_j = g * l\n          gcd(x_i, x_j) = g\n\n      We can write x_i = g * a_i, x_j = g * b_j, then a_i * b_j = l // g, and gcd(a_i, b_j)=1.\n\n      Then, for node i, we can define a base part: x_i = g_i * (some integer) but note that the same node i appears in multiple edges. In each edge, the factor g (the gcd for that edge) must divide x_i.\n\n      Therefore, x_i must be divisible by the LCM of the gcds from all edges incident to i. Let base_i = LCM_{for each edge (i,j)} (g_ij)\n\n      Then, we can write x_i = base_i * k_i, for some integer k_i.\n\n      Now, consider an edge (i,j) with gcd=g and lcm=l. Then:\n          x_i * x_j = (base_i * k_i) * (base_j * k_j) = g * l.\n\n          Also, gcd(x_i, x_j) = g.\n\n      Note: base_i is divisible by g (because g is one of the factors in the LCM). Similarly base_j is divisible by g.\n\n      Then, we can factor out g from base_i and base_j. Let base_i = g * a, base_j = g * b, then x_i = g * a * k_i, x_j = g * b * k_j.\n\n      Then the product condition: (g * a * k_i) * (g * b * k_j) = g * l   =>   g^2 * a * b * k_i * k_j = g * l   =>   g * a * b * k_i * k_j = l.\n\n      Also, the gcd condition: gcd(x_i, x_j) = g. Since x_i = g * a * k_i, x_j = g * b * k_j, then we have:\n          gcd(x_i, x_j) = g * gcd(a * k_i, b * k_j) = g.\n\n      Therefore, we must have gcd(a * k_i, b * k_j) = 1.\n\n      Now, note that base_i = LCM_{edges}(g) is fixed for node i. Then, for each edge (i,j) with gcd=g, we know that base_i must be divisible by g, and base_j by g.\n\n      We can precompute base_i for each node.\n\n      Then, the product condition for edge (i,j) becomes: (base_i * base_j) * (k_i * k_j) = g * l.\n\n      So, k_i * k_j = (g * l) / (base_i * base_j)\n\n      But note: base_i is the LCM of the gcds from the edges incident to i, so it includes g (from this edge). However, the product base_i * base_j might be larger than g * l? Then we cannot assign integer k_i, k_j.\n\n      Therefore, the equation must hold: base_i * base_j must divide g * l, and the quotient must be an integer, and then k_i * k_j = (g * l) / (base_i * base_j). But note that we have multiple edges, and k_i is shared among all edges.\n\n      However, we have multiple constraints on k_i: for each edge (i,j) we have a constraint on the product k_i * k_j. This is a system of equations for the k_i's.\n\n      But note: the k_i's must be positive integers.\n\n      Steps:\n\n        Step 1: Precompute base_i for each node i: \n                base_i = 1\n                for each edge (i,j) incident to i, base_i = LCM(base_i, g_ij)\n\n        Step 2: For each edge (i,j) with gcd=g, lcm=l:\n                Let P = g * l\n                Let B = base_i * base_j\n                Then, we require that P % B == 0, and then k_i * k_j = P // B.\n\n                But note: base_i is divisible by g, so base_i = g * (some integer). Similarly base_j = g * (some integer). Then, P // B = (g * l) / (base_i * base_j) = (g * l) / (g^2 * ...) = (l) / (g * ...). This might not be an integer.\n\n        However, we have to check the condition: base_i must be divisible by g (which it is, because g is one of the factors in the base_i computation). Similarly base_j. But the entire product base_i * base_j might not divide g*l.\n\n        Actually, note that base_i is divisible by g, so base_i = g * a, base_j = g * b, then base_i * base_j = g^2 * a * b, and g*l is divisible by g^2? Not necessarily: because l might not be divisible by g. But wait: the given gcd must divide the LCM (property of gcd and lcm). Indeed, we have the property: gcd divides lcm. So g divides l. Then, g*l is divisible by g^2? Only if l is divisible by g, which it is (because g divides l). Then, g*l is divisible by g^2.\n\n        However, base_i is the LCM of the gcds from the edges. The gcds are the given g's. And note: for the edge (i,j), the gcd g must be one of the factors in base_i. So base_i is divisible by g. Similarly base_j is divisible by g. Then base_i * base_j is divisible by g^2. And since g divides l, then g*l is divisible by g^2. So the condition P % B == 0 holds?\n\n        But wait: base_i might be divisible by more than g. For example, base_i might be divisible by other primes from other edges. Then base_i * base_j might be larger than g^2, and then g*l might not be divisible by base_i * base_j.\n\n        Example: \n          Edge (u,v): g=2, l=12 -> product=24.\n          base_u = LCM(2) = 2, base_v = LCM(2)=2 -> then 2*2=4 divides 24 -> 24/4=6, so k_u * k_v = 6.\n\n          Now, if node u has two edges: (u,v) with g=2 and (u,w) with g=3, then base_u = LCM(2,3)=6.\n          For edge (u,v): base_u * base_v = 6 * 2 = 12. Then 12 must divide 24 -> yes, 24/12=2, so k_u * k_v = 2.\n\n          But now, from edge (u,w): base_u * base_w = 6 * base_w. The edge (u,w) has g=3, so base_w must be divisible by 3. Let base_w = LCM(3) (if w only has this edge) then base_w=3. Then 6*3=18, and 3*l (for edge (u,w)) is 3 * l. What is l for edge (u,w)? We are not told, but the condition for edge (u,w) is that the product is 3*l, and base_u * base_w = 18 must divide 3*l, so l must be divisible by 6. Then 3*l = 3*(6*k) = 18*k. Then k_u * k_w = k.\n\n          Now, from edge (u,v): k_u * k_v = 2, and from edge (u,w): k_u * k_w = k.\n\n          We don't know k_u, k_v, k_w. But note: the base_u=6, so x_u = 6 * k_u. Similarly, x_v = base_v * k_v = 2 * k_v, and x_w = 3 * k_w.\n\n          For edge (u,v): \n              x_u * x_v = 6 * k_u * 2 * k_v = 12 * k_u * k_v = 24 -> k_u * k_v = 2. (matches)\n\n          For edge (u,w):\n              x_u * x_w = 6 * k_u * 3 * k_w = 18 * k_u * k_w = 3*l -> k_u * k_w = (3*l)/18 = l/6.\n\n          We also have the gcd condition for edge (u,w): gcd(x_u, x_w)=3.\n              gcd(6*k_u, 3*k_w) = 3 * gcd(2*k_u, k_w) = 3.\n              => gcd(2*k_u, k_w)=1.\n\n          But from the product, k_u * k_w = l/6, and l is given for that edge. We must have that l is divisible by 6 (as we saw). But note: we don't know l, but the input provides it.\n\n        The problem: We are given the entire graph, so for each edge we know g and l.\n\n        Therefore, we can:\n\n          For each node i, compute base_i = LCM_{e incident to i} (g_e)\n\n          Then, for each edge (i,j) with gcd=g, lcm=l:\n                Let T = g * l\n                If T % (base_i * base_j) != 0, then return \"NO\".\n\n          But wait, we must also satisfy the gcd condition. However, the above ensures the product condition. But note: the product condition is necessary but not sufficient.\n\n        After setting base_i for each node, we have to assign k_i for each node. Then, the product condition for edge (i,j) is: k_i * k_j = (g * l) / (base_i * base_j)\n\n        This forms a system of multiplicative constraints on the k_i's. Moreover, the gcd condition for edge (i,j) is: gcd(x_i, x_j)=g, which is equivalent to gcd(base_i * k_i, base_j * k_j)=g.\n\n        Since base_i is divisible by g and base_j by g, we can write base_i = g * a, base_j = g * b, then:\n            gcd(g*a*k_i, g*b*k_j) = g * gcd(a*k_i, b*k_j) = g   =>   gcd(a*k_i, b*k_j)=1.\n\n        Now, note that a = base_i // g, and b = base_j // g.\n\n        Then, we require that gcd(a*k_i, b*k_j)=1.\n\n        How to assign k_i? We have a system:\n\n            For each edge (i,j): k_i * k_j = C_{ij}   (where C_{ij} = (g_ij * l_ij) / (base_i * base_j))\n\n        And we also have the gcd condition: gcd(a_i * k_i, b_j * k_j)=1, where a_i = base_i // g_i (for the specific edge (i,j) we use the g_ij) and similarly for b_j.\n\n        But note: the a_i and b_j depend on the edge? Actually, for an edge (i,j) with gcd=g, then a_i = base_i // g, and b_j = base_j // g.\n\n        However, base_i is fixed, but g is the gcd of that edge. So for different edges incident to node i, we get different g's and hence different a_i (if we use base_i for the same node i). But wait, base_i is the LCM of all the gcds from edges incident to i. Then, for an edge (i,j) with gcd=g, we have base_i divisible by g, so a_i = base_i // g is an integer. But note: base_i is built from all edges, so the same base_i is used for every edge.\n\n        However, the condition gcd(a_i * k_i, b_j * k_j)=1 must hold for every edge (i,j). \n\n        But note: the same node i has a fixed k_i. Then, for two different edges (i,j) and (i,k), we have two conditions:\n\n            Condition1: gcd( (base_i // g1) * k_i, (base_j // g1) * k_j ) = 1\n            Condition2: gcd( (base_i // g2) * k_i, (base_k // g2) * k_k ) = 1\n\n        The values (base_i // g1) and (base_i // g2) are different.\n\n        This seems complex.\n\n  Simplified idea:\n\n  Instead of trying to compute base_i and then k_i, we can use the following:\n\n      Since for an edge (u,v) we have x_u * x_v = g * l, and gcd(x_u, x_v)=g, then we can set:\n\n          x_u = g * a, x_v = g * b, with a*b = l//g, and gcd(a,b)=1.\n\n      Then, the entire graph must have consistent assignments.\n\n      We can assign to each node a value by propagating the constraints. However, the graph might be disconnected.\n\n  Steps:\n\n      Let's create an array ans[1..n] for the mushroom counts.\n\n      We'll do:\n\n        For each connected component, we will try to assign values.\n\n        However, note: the product condition and the gcd condition must hold for every edge.\n\n      We can use union-find or DFS/BFS to traverse the graph.\n\n      But note: the product condition is multiplicative and the gcd condition is additive in factors.\n\n  Another idea from known problems (like restoring the numbers from GCD and LCM on edges) is to use the following:\n\n        For each edge (u,v) with gcd=g, lcm=l, we know that the numbers (x,y) must be divisors of l and must be multiples of g, and x*y = g*l, and gcd(x,y)=g.\n\n        Then, we can factorize the product g*l and look for two divisors d1, d2 such that d1*d2 = g*l, and gcd(d1,d2)=g, and d1 divides l and d2 divides l.\n\n        However, the product g*l can be up to 10^6 * 10^6 = 10^12, and we have up to 10^5 edges, so we cannot factorize each product.\n\n  Known fact: \n\n        The two numbers must be of the form: \n            x = g * a, y = g * b, with a*b = (l // g) and gcd(a,b)=1.\n\n        Then, we can factorize (l // g) and look for two coprime factors (a,b) such that a*b = l//g.\n\n        But note: the same node u must have the same value in all edges.\n\n        So, for node u, we must assign a value x that is divisible by all the gcds from edges incident to u, and also, for each edge (u,v) with gcd=g and lcm=l, the value x must divide the LCM (given) and the other node v must have value y = (g*l) / x, and then gcd(x,y)=g.\n\n        Steps for a node u:\n\n            Let S be the set of gcds from edges incident to u.\n\n            Then, x must be divisible by the LCM of S (call it L).\n\n            Also, for each edge (u,v) with gcd=g and lcm=l, we have x * y = g*l, and y must be an integer and gcd(x,y)=g.\n\n        Then, we can iterate over the divisors of (g*l) for each edge, but that is too expensive.\n\n  Efficient way:\n\n        We can try to assign x_u for node u by considering the edges. But note: the entire graph must be consistent.\n\n        Since the product condition and the gcd condition are very strict, we can use the following:\n\n            For each edge (u,v), the two numbers (x,y) are uniquely determined by the prime factorization of (g*l) and the requirement that the gcd is g and the product is g*l.\n\n            Specifically, let D = l // g. Then we need two coprime factors (a,b) of D such that a*b = D.\n\n            Then, the two numbers are (g*a, g*b).\n\n        Then, the entire graph must be labeled with numbers that are products of the base (which is the gcd of the edge) and a factor that is coprime to the corresponding factor of the neighbor.\n\n        This resembles a graph coloring problem with multiplicative constraints.\n\n  However, note: the problem does not require unique restoration. We only need to find one assignment.\n\n  We can do:\n\n        Step 1: For each edge (u,v) with gcd=g and lcm=l, let D = l // g. Then, we must have that the two numbers are (g * a, g * b) with a*b=D and gcd(a,b)=1.\n\n        But note: there might be multiple ways to factor D into two coprime factors. We can choose any.\n\n        Then, we can assign to node u a value that is a multiple of all the gcds from edges, and then adjust by the factors from the edges.\n\n        Alternatively, we can use a two-coloring of the graph for each prime factor? This might be too heavy.\n\n  Insight from the known problem \"Reconstruction from GCD and LCM\" (or similar):\n\n        There is a known problem: given a graph and for each edge (u,v) you are given (g, l), determine if there exists an assignment of positive integers to nodes such that for each edge, gcd(node_u, node_v)=g and lcm(node_u, node_v)=l.\n\n        Steps:\n\n          1. Check for each edge: g must divide l, otherwise invalid.\n\n          2. The product g*l must be divisible by the product of the gcds from the incident edges? Not exactly.\n\n        Actually, we can use the following necessary conditions:\n\n          a. For each edge, g divides l.\n\n          b. For each node u, let g_u be the LCM of the gcds from all edges incident to u. Then, the value x_u must be divisible by g_u.\n\n          c. For each edge (u,v): \n                x_u * x_v = g * l.\n\n          d. For each edge (u,v): \n                gcd(x_u, x_v) = g.\n\n        Now, if we set x_u = g_u * k_u, then for edge (u,v): \n                (g_u * k_u) * (g_v * k_v) = g * l.\n\n                => k_u * k_v = (g * l) / (g_u * g_v)\n\n        And the condition gcd(x_u, x_v)=g becomes:\n                gcd(g_u * k_u, g_v * k_v) = g.\n\n        Since g_u is divisible by g, let g_u = g * a_u, g_v = g * b_v, then:\n                gcd(g * a_u * k_u, g * b_v * k_v) = g * gcd(a_u * k_u, b_v * k_v) = g   =>   gcd(a_u * k_u, b_v * k_v)=1.\n\n        Now, note that a_u = g_u / g, and b_v = g_v / g.\n\n        Then, the system of equations is:\n\n            For each edge (u,v): \n                k_u * k_v = C_{uv}   (with C_{uv} = (g * l) / (g_u * g_v))\n                and gcd(a_u * k_u, b_v * k_v)=1.\n\n        This is a system of multiplicative equations on the k_u's. Moreover, the k_u's must be positive integers.\n\n        We can solve this system by BFS/DFS on the graph, but note: the graph can have up to 10^5 nodes and edges.\n\n        However, the values of C_{uv} might be very large, and the k_u's must be chosen such that they are integers and the product condition holds.\n\n        But note: the product condition is multiplicative and the graph is undirected. We can fix a starting node and set k_start = 1, then propagate the products to neighbors.\n\n        Steps for one connected component:\n\n            Let's pick a node s.\n\n            Set k_s = 1.\n\n            Then, for each edge (s, v) with gcd=g, lcm=l, we have:\n                    k_s * k_v = C_{sv}   =>   k_v = C_{sv} // k_s = C_{sv}\n\n            Then, for the next level, use these k_v's to compute k for the next neighbors.\n\n            But wait: the edge (s,v) gives one constraint. Then, for an edge (v,t), we have k_v * k_t = C_{vt}. So k_t = C_{vt} // k_v.\n\n            However, we must ensure that the division is exact.\n\n            Then, after assigning k_u for all nodes, we must check two things:\n\n                (1) For every edge (u,v): k_u * k_v == C_{uv}\n                (2) For every edge (u,v): gcd(a_u * k_u, b_v * k_v) == 1.\n\n            But note: the a_u and b_v are fixed (from base_u and base_v) and we have computed k_u and k_v.\n\n        However, there is a catch: the base_u (which is g_u) depends on all the edges incident to u. But we are computing k_u independently.\n\n        But note: the base_u is computed from the gcds of the edges incident to u. In our propagation, we haven't used the base_u for anything except to compute C_{uv}. The base_u is fixed and then C_{uv} = (g_uv * l_uv) / (base_u * base_v) must be an integer.\n\n        Steps summary:\n\n            Step 1: Precompute base_u for each node u (the LCM of the gcds of the edges incident to u).\n\n            Step 2: For each edge (u,v) with gcd=g, lcm=l:\n                    Let C = (g * l) / (base_u * base_v)\n                    If C is not an integer, then output \"NO\".\n\n            Step 3: Build a graph with n nodes and m edges, and for each edge (u,v) store the constant C_{uv} = (g * l) / (base_u * base_v)\n\n            Step 4: For each connected component, do:\n\n                    Let s be a node in the component.\n\n                    Set k[s] = 1.\n\n                    Use BFS/DFS to traverse the graph, and for each edge (u,v) encountered, set k[v] = C_{uv} / k[u]. (But careful: the edge (u,v) has been stored with constant C_{uv} from the perspective of u->v. But note: the edge (u,v) has two ends: from u's side and v's side. However, the constant C_{uv} is defined as (g*u*v) / (base_u * base_v), and the product condition is symmetric: k_u * k_v = C_{uv}. So we can use the same constant for both directions.\n\n                    However, when traversing from u to v, we set k_v = C_{uv} // k_u. But we must ensure that k_u divides C_{uv} exactly.\n\n            Step 5: After assigning k for all nodes in the component, verify:\n\n                    For every edge (u,v) in the component: k_u * k_v == C_{uv} (should hold by construction)\n\n                    And for every edge (u,v): gcd(a_u * k_u, b_v * k_v) == 1, where a_u = base_u // g_{uv} (wait, note: the gcd condition uses the specific edge's gcd for the node's base? Actually, for edge (u,v) we use the gcd g_{uv} to compute a_u = base_u // g_{uv} and b_v = base_v // g_{uv}. \n\n            However, note: base_u is the LCM of all the gcds from edges incident to u. Then, base_u is divisible by g_{uv}. So a_u is an integer.\n\n            But wait, in the condition for edge (u,v), we use the gcd g_{uv} to compute a_u and b_v. \n\n            But in our propagation, we used the constant C_{uv} = (g_{uv} * l_{uv}) / (base_u * base_v). And we require that base_u * base_v divides g_{uv} * l_{uv}.\n\n            Then, the condition gcd(a_u * k_u, b_v * k_v)=1 must be checked for every edge.\n\n        However, there is a potential issue: the same node u might appear in multiple edges with different g's. But the base_u is fixed. Then, a_u for an edge (u,v) is base_u // g_{uv}. This is well-defined.\n\n        Implementation:\n\n            We must compute base_u for each node.\n\n            Steps:\n\n                Read n, m.\n\n                Graph representation: \n                    graph = { node: list of (neighbor, gcd, lcm) }\n\n                But we need to know for each edge (u,v) the gcd and lcm.\n\n                Then, for each node u, base_u = 1\n                for each edge (u,v) incident to u, base_u = LCM(base_u, gcd_uv)\n\n                However, note: the LCM of a set of numbers can be computed by: \n                    LCM(a,b) = abs(a*b) // gcd(a,b)   [if a or b is 0, but here gcd>=1]\n\n                But we have up to 10^5 nodes and each node might have many edges. The numbers are up to 10^6, so the LCM might become very large? But the gcd's are divisors of the given numbers, and the product of two numbers up to 10^6 is 10^12, and then LCM might be up to 10^12, and then we might have many of them. But the total number of edges is m (up to 10^5) and each node's base",
    "response": "\nTo solve this problem, we need to determine if it's possible to restore the number of mushrooms on each lawn (node) in a forest map based on given roads (edges) that provide the greatest common divisor (GCD) and least common multiple (LCM) of the mushroom counts on the connected lawns. The solution involves verifying consistency conditions and assigning values to nodes such that all edge constraints are satisfied.\n\n### Approach\n1. **Problem Analysis**:\n   - Each edge between two nodes (lawns) provides two numbers: GCD and LCM of the mushroom counts on those nodes.\n   - The key insight is that for any two numbers \\(x\\) and \\(y\\), \\(x \\times y = \\text{GCD}(x, y) \\times \\text{LCM}(x, y)\\).\n   - Additionally, the GCD must divide both \\(x\\) and \\(y\\), and the LCM must be divisible by the GCD.\n\n2. **Intuitions and Insights**:\n   - For each node, the value must be divisible by the LCM of all GCDs from its incident edges. This forms the base value for the node.\n   - Using the product condition \\(x \\times y = \\text{GCD} \\times \\text{LCM}\\), we can derive multiplicative constraints between node values.\n   - The GCD condition ensures that the derived values from these constraints are coprime in their respective components.\n\n3. **Algorithm Selection**:\n   - **Base Value Calculation**: For each node, compute the base value as the LCM of all GCDs from its incident edges.\n   - **Consistency Check**: For each edge, verify that the product of the base values of the connected nodes equals \\(\\text{GCD} \\times \\text{LCM}\\). If not, the arrangement is impossible.\n   - **Value Assignment**: Propagate values through the graph using BFS/DFS, ensuring multiplicative constraints are met. After assignment, verify the GCD conditions for all edges.\n\n4. **Complexity Analysis**:\n   - **Time Complexity**: The solution involves traversing the graph (O(n + m)) and computing LCMs (O(m log n)) due to GCD/LCM operations, which are efficient for numbers up to \\(10^6\\).\n   - **Space Complexity**: O(n + m) for storing the graph and auxiliary data structures.\n\n### Solution Code\n```python\nimport math\nfrom math import gcd\nfrom collections import defaultdict, deque\nimport sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"NO\")\n        return\n    \n    it = iter(data)\n    n = int(next(it)); m = int(next(it))\n    \n    graph = [[] for _ in range(n+1)]\n    edges_info = []\n    for i in range(m):\n        u = int(next(it)); v = int(next(it)); g_val = int(next(it)); l_val = int(next(it))\n        graph[u].append((v, g_val, l_val))\n        graph[v].append((u, g_val, l_val))\n        edges_info.append((u, v, g_val, l_val))\n    \n    base = [1] * (n+1)\n    for i in range(1, n+1):\n        bases_here = []\n        for neighbor, g_val, l_val in graph[i]:\n            bases_here.append(g_val)\n        if bases_here:\n            base[i] = 1\n            for num in bases_here:\n                base[i] = (base[i] * num) // gcd(base[i], num)\n    \n    valid_edges = True\n    for u, v, g_val, l_val in edges_info:\n        prod = g_val * l_val\n        base_u = base[u]\n        base_v = base[v]\n        total_base = base_u * base_v\n        if prod % total_base != 0:\n            valid_edges = False\n            break\n    \n    if not valid_edges:\n        print(\"NO\")\n        return\n    \n    C = {}\n    for u, v, g_val, l_val in edges_info:\n        total_base = base[u] * base[v]\n        C[(u, v)] = (g_val * l_val) // total_base\n    \n    k = [0] * (n+1)\n    visited = [False] * (n+1)\n    valid_assignment = True\n    for i in range(1, n+1):\n        if not visited[i]:\n            comp_nodes = []\n            q = deque([i])\n            visited[i] = True\n            while q:\n                node = q.popleft()\n                comp_nodes.append(node)\n                for neighbor, g_val, l_val in graph[node]:\n                    if not visited[neighbor]:\n                        visited[neighbor] = True\n                        q.append(neighbor)\n            \n            q = deque([i])\n            visited_in_comp = {node: False for node in comp_nodes}\n            visited_in_comp[i] = True\n            k[i] = 1\n            while q:\n                node = q.popleft()\n                for neighbor, g_val, l_val in graph[node]:\n                    if not visited_in_comp[neighbor]:\n                        visited_in_comp[neighbor] = True\n                        c_uv = C.get((node, neighbor), C.get((neighbor, node)))\n                        if c_uv is None:\n                            valid_assignment = False\n                            break\n                        if k[node] == 0:\n                            valid_assignment = False\n                            break\n                        if c_uv % k[node] != 0:\n                            valid_assignment = False\n                            break\n                        k[neighbor] = c_uv // k[node]\n                        q.append(neighbor)\n                if not valid_assignment:\n                    break\n            \n            if not valid_assignment:\n                break\n\n    if not valid_assignment:\n        print(\"NO\")\n        return\n\n    for i in range(1, n+1):\n        if k[i] == 0:\n            print(\"NO\")\n            return\n\n    for u, v, g_val, l_val in edges_info:\n        if k[u] * k[v] != C[(u, v)]:\n            print(\"NO\")\n            return\n\n    for u, v, g_val, l_val in edges_info:\n        a_u = base[u] // g_val\n        b_v = base[v] // g_val\n        x_u = a_u * k[u]\n        x_v = b_v * k[v]\n        if math.gcd(x_u, x_v) != 1:\n            print(\"NO\")\n            return\n\n    ans = []\n    for i in range(1, n+1):\n        ans.append(str(k[i]))\n    \n    print(\"YES\")\n    print(\" \".join(ans))\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is read and parsed into the number of nodes (n) and edges (m), followed by the edges' details (nodes and GCD/LCM values).\n2. **Base Value Calculation**: For each node, the base value is computed as the LCM of all GCDs from its incident edges. This ensures the node's value will satisfy divisibility conditions for all connected edges.\n3. **Consistency Check**: For each edge, the product of the base values of the connected nodes must equal the product of the GCD and LCM. If not, the arrangement is impossible.\n4. **Value Assignment**: Using BFS, values (k) are propagated through the graph, ensuring multiplicative constraints are met. The assignment starts with an initial value (1) for the root node and propagates to neighbors.\n5. **Validation**: After assignment, the solution checks if all edge conditions (product and GCD) are satisfied. If successful, the values are printed; otherwise, \"NO\" is printed indicating no valid arrangement exists.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\nfrom math import gcd\nfrom collections import defaultdict, deque\nimport sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        print(\"NO\")\n        return\n    \n    it = iter(data)\n    n = int(next(it)); m = int(next(it))\n    \n    graph = [[] for _ in range(n+1)]\n    edges_info = []\n    for i in range(m):\n        u = int(next(it)); v = int(next(it)); g_val = int(next(it)); l_val = int(next(it))\n        graph[u].append((v, g_val, l_val))\n        graph[v].append((u, g_val, l_val))\n        edges_info.append((u, v, g_val, l_val))\n    \n    base = [1] * (n+1)\n    for i in range(1, n+1):\n        bases_here = []\n        for neighbor, g_val, l_val in graph[i]:\n            bases_here.append(g_val)\n        if bases_here:\n            base[i] = 1\n            for num in bases_here:\n                base[i] = (base[i] * num) // gcd(base[i], num)\n    \n    valid_edges = True\n    for u, v, g_val, l_val in edges_info:\n        prod = g_val * l_val\n        base_u = base[u]\n        base_v = base[v]\n        total_base = base_u * base_v\n        if prod % total_base != 0:\n            valid_edges = False\n            break\n    \n    if not valid_edges:\n        print(\"NO\")\n        return\n    \n    C = {}\n    for u, v, g_val, l_val in edges_info:\n        total_base = base[u] * base[v]\n        C[(u, v)] = (g_val * l_val) // total_base\n    \n    k = [0] * (n+1)\n    visited = [False] * (n+1)\n    valid_assignment = True\n    for i in range(1, n+1):\n        if not visited[i]:\n            comp_nodes = []\n            q = deque([i])\n            visited[i] = True\n            while q:\n                node = q.popleft()\n                comp_nodes.append(node)\n                for neighbor, g_val, l_val in graph[node]:\n                    if not visited[neighbor]:\n                        visited[neighbor] = True\n                        q.append(neighbor)\n            \n            q = deque([i])\n            visited_in_comp = {node: False for node in comp_nodes}\n            visited_in_comp[i] = True\n            k[i] = 1\n            while q:\n                node = q.popleft()\n                for neighbor, g_val, l_val in graph[node]:\n                    if not visited_in_comp[neighbor]:\n                        visited_in_comp[neighbor] = True\n                        c_uv = C.get((node, neighbor), C.get((neighbor, node)))\n                        if c_uv is None:\n                            valid_assignment = False\n                            break\n                        if k[node] == 0:\n                            valid_assignment = False\n                            break\n                        if c_uv % k[node] != 0:\n                            valid_assignment = False\n                            break\n                        k[neighbor] = c_uv // k[node]\n                        q.append(neighbor)\n                if not valid_assignment:\n                    break\n            \n            if not valid_assignment:\n                break\n\n    if not valid_assignment:\n        print(\"NO\")\n        return\n\n    for i in range(1, n+1):\n        if k[i] == 0:\n            print(\"NO\")\n            return\n\n    for u, v, g_val, l_val in edges_info:\n        if k[u] * k[v] != C[(u, v)]:\n            print(\"NO\")\n            return\n\n    for u, v, g_val, l_val in edges_info:\n        a_u = base[u] // g_val\n        b_v = base[v] // g_val\n        x_u = a_u * k[u]\n        x_v = b_v * k[v]\n        if math.gcd(x_u, x_v) != 1:\n            print(\"NO\")\n            return\n\n    ans = []\n    for i in range(1, n+1):\n        ans.append(str(k[i]))\n    \n    print(\"YES\")\n    print(\" \".join(ans))\n\nif __name__ == '__main__':\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 552,
        "completion_token_count": 1639,
        "thoughts_token_count": 8191
    }
}