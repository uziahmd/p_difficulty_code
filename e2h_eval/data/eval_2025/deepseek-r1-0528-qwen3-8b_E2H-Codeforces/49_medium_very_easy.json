{
    "start": 1758303976.8823524,
    "end": 1758307836.63218,
    "start-formatted": "2025-09-20 02:46 KST",
    "end-formatted": "2025-09-20 03:50 KST",
    "gpu": 2,
    "pid": 49,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Mushroom Strife\n\nPasha and Akim were making a forest map — the lawns were the graph's vertexes and the roads joining the lawns were its edges. They decided to encode the number of laughy mushrooms on every lawn in the following way: on every edge between two lawns they wrote two numbers, the greatest common divisor (GCD) and the least common multiple (LCM) of the number of mushrooms on these lawns. But one day Pasha and Akim had an argument about the laughy mushrooms and tore the map. Pasha was left with just some part of it, containing only m roads. Your task is to help Pasha — use the map he has to restore the number of mushrooms on every lawn. As the result is not necessarily unique, help Pasha to restore any one or report that such arrangement of mushrooms does not exist. It is guaranteed that the numbers on the roads on the initial map were no less that 1 and did not exceed 106.\n\n## Input\nThe first line contains two numbers n and m () which are the numbers of lawns and roads we know about. Each of the following m lines contains four numbers which are the numbers of lawns the road connects, the GCD and the LCM of the numbers of mushrooms on these lawns (1 ≤ GCD, LCM ≤ 106).It is guaranteed, that no road connects lawn to itself, and no two lawns are connected by more than one road.\n\n## Output\nThe answer should contain \"YES\" or \"NO\" on the first line, saying whether it is possible or not to perform the arrangement. If the answer is \"YES\", print on the following line n numbers which are the numbers of mushrooms on the corresponding lawns.\n\n## Example\n### Input\n['1 0', '2 1\\n1 2 1 3', '3 2\\n3 2 1 2\\n3 1 1 10', '2 1\\n1 2 3 7']\n\n### Output\n['YES\\n1', 'YES\\n1 3', 'YES\\n5 1 2', 'NO']\n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments.\n\nNote that this is a very easy question."
        }
    ],
    "thought": "\n Okay, we are given a graph with n nodes and m edges. Each edge (u, v) gives two numbers: gcd and lcm.\n Conditions:\n  For an edge (u, v): \n      Let the number of mushrooms at u be a, at v be b.\n      Then, gcd(a, b) = GCD and lcm(a, b) = LCM.\n\n We know that for any two positive integers a and b:\n      a * b = gcd(a, b) * lcm(a, b)\n\n Also, note that we can write:\n      a = d * x\n      b = d * y\n    where d = gcd(a, b) and gcd(x, y) = 1, and then lcm(a, b) = d * x * y.\n\n Therefore, from the edge (u, v) with given GCD = d and LCM = l, we have:\n      d * x * y = l   =>   x * y = l / d\n\n But note: since d divides both a and b, and also divides the LCM (because d divides a and b, so d divides their LCM), we must have that d divides l (because l is a multiple of d). Moreover, x and y must be coprime.\n\n However, the problem is that we have multiple edges and we need to assign numbers to all n lawns.\n\n Steps:\n\n 1. Check for each edge: does the given GCD divide the LCM? If not, then it's invalid -> output \"NO\".\n\n 2. For each edge, we can compute the product: base = LCM // GCD. Then the two numbers on the edge must be of the form (d * x, d * y) with x*y = base and gcd(x,y)=1.\n\n 3. But note: the same node may appear in multiple edges. So we have to assign one number for each node.\n\n 4. We can use a DFS/BFS to traverse the graph and assign values to the nodes, but note that the graph might be disconnected.\n\n Alternatively, we can think:\n\n Let the value at node i be A[i]. Then for an edge (u, v) with gcd = g and lcm = l:\n        g = gcd(A[u], A[v])\n        l = lcm(A[u], A[v])\n\n And we know: A[u] * A[v] = g * l.\n\n Also, we know that g must divide both A[u] and A[v], and the ratio between A[u] and A[v] must be such that they share no common factors beyond g.\n\n However, we can set up equations:\n\n   Let d_u be the gcd of all edges incident to u? Not exactly.\n\n Another approach:\n\n   Since the entire graph must satisfy the condition for every edge, we can try to assign a base value for each connected component.\n\n   Observation: In a connected component, we can fix one node arbitrarily (but note: the assignment must be consistent). \n\n   However, note that from an edge (u, v) we have two possibilities: \n        A[u] = d * x, A[v] = d * y, with x * y = base, and gcd(x,y)=1.\n\n   But the same node u appears in multiple edges. So we must have the same value for u in all edges.\n\n   Let's denote by A[i] the value at node i.\n\n   Then for an edge (u, v, g, l):\n        g = gcd(A[u], A[v])\n        l = lcm(A[u], A[v])\n\n   Also, we have: A[u] * A[v] = g * l.\n\n   Moreover, we can factorize the numbers? But note constraints: up to 10^6 and n, m up to 10^5.\n\n   Alternate Insight:\n\n     Let’s consider: from an edge (u, v) we have:\n          A[u] = g * x\n          A[v] = g * y\n        and x * y = l // g, and gcd(x, y) = 1.\n\n     Now, if we have two edges from u to two different nodes, say (u, v1) and (u, v2), then the value at u must be divisible by the gcd of the two edges? Actually, the value at u must be divisible by both g1 (from edge1) and g2 (from edge2). \n\n     However, note: the gcd of the two edges is the gcd of the two numbers at u and v1, and u and v2. But we don't know the gcd between v1 and v2.\n\n   We can set up:\n\n        Let d_i be the greatest common divisor of the values at node i and the values at its neighbors? Not directly.\n\n   Alternatively, we can do:\n\n        Step 1: Check for each edge that g divides l. If not, return \"NO\".\n\n        Step 2: For each node, we can set an initial candidate value. But note: the graph might be disconnected.\n\n   How about:\n\n        We can assign a value for each node as follows:\n\n        Let’s define for each edge (u, v) with gcd g and lcm l, we have two factors: the gcd part and the remaining part.\n\n        But note: the entire system must be consistent.\n\n   Another idea: use union-find or BFS to assign the value for each node relative to a root.\n\n   However, note that the value at a node must be divisible by all the gcds of the edges incident to it. Why?\n\n        Consider: for an edge (u, v) with gcd g, then g divides A[u]. Similarly, for another edge (u, w) with gcd h, then h divides A[u].\n\n        Therefore, A[u] must be divisible by the least common multiple (LCM) of all the gcds of the edges incident to u? Not necessarily: actually, the gcd of the edge (u, v) is the gcd of A[u] and A[v]. But we don't know A[v] until we assign everything.\n\n   Alternatively, we can use the following:\n\n        For each edge (u, v, g, l), we know that A[u] must be divisible by g, and A[v] must be divisible by g.\n\n        Moreover, the product A[u]*A[v] must be g * l.\n\n   So we can set:\n\n        Let M[u] be the set of prime factors that must be present in A[u] (with exponents) but we cannot easily do that for 10^6.\n\n   Instead, we can use a method:\n\n        We can fix an arbitrary node (say node 0) and set A[0] to a particular value. Then propagate to its neighbors.\n\n   But wait: we have multiple constraints.\n\n   However, note: the problem says that the original numbers were between 1 and 10^6. We don't have to recover the original, just any arrangement.\n\n   Here's a plan:\n\n        Step 1: Precompute for each edge (u, v) the value 'base' = LCM // GCD. Then, the product of the two numbers on the edge is fixed (GCD * LCM).\n\n        Step 2: For each node, let candidate[u] be the product of all the GCDs from edges incident to u? Not exactly.\n\n        Actually, we can use the following:\n\n            Let X[u] = A[u] (the actual value).\n\n            For an edge (u, v): \n                X[u] * X[v] = GCD * LCM   (for that edge)\n\n            And also, the GCD of X[u] and X[v] must be the given GCD.\n\n        We can also note:\n\n            Let d = gcd(X[u], X[v]) = GCD_edge.\n            Then, we can write:\n                X[u] = GCD_edge * a\n                X[v] = GCD_edge * b\n            with gcd(a, b) = 1.\n\n        Then, the product condition: GCD_edge * a * GCD_edge * b = GCD_edge * LCM   =>   GCD_edge * a * b = LCM   =>   a * b = LCM // GCD_edge.\n\n        Now, note that the value at u (X[u]) must be divisible by the gcd of the edge (u, v) and also by the gcd from other edges.\n\n        But we can set:\n\n            Let D[u] be the greatest common divisor of all the gcds from edges incident to u? Not exactly, because the gcd from an edge is the gcd of two numbers, and the same node appears in multiple edges.\n\n        Actually, consider: for node u, let S[u] be the set of all gcds from edges incident to u. Then, the value X[u] must be divisible by the least common multiple (LCM) of all these gcds? Not necessarily, because the gcd of an edge is the gcd of two numbers, and the same node's value must be divisible by each gcd from each edge, but the LCM of the gcds might be too strong.\n\n        Example: two edges from u to v and u to w.\n\n            Edge1: (u, v) with gcd g1 -> then g1 divides X[u] and X[v].\n            Edge2: (u, w) with gcd g2 -> then g2 divides X[u] and X[w].\n\n        Then, X[u] must be divisible by both g1 and g2. So by lcm(g1, g2). \n\n        However, is that sufficient? Not exactly, but necessary.\n\n        But note: the gcd of the edge (u, v) is the gcd of X[u] and X[v]. We don't know X[v] and X[w] until we assign, so we can set:\n\n            Let L[u] = the LCM of all the gcds from edges incident to u.\n\n        Then, we set X[u] = k * L[u] for some integer k.\n\n        Then, for each edge (u, v) with gcd g and lcm l, we have:\n\n            Let X[u] = k * L[u], and we require that gcd(X[u], X[v]) = g.\n\n            Also, we have X[u] * X[v] = g * l.\n\n        But wait, we don't know the entire graph structure and the assignments for all nodes.\n\n   This seems complicated.\n\n   Alternate Insight from known constraints (each number between 1 and 10^6):\n\n        We can use the following:\n\n        For an edge (u, v) with gcd = g and lcm = l, the two numbers must be divisors of l (since they are divisors of the lcm). Moreover, they must be multiples of g.\n\n        So the candidates for the two numbers are the divisors of l that are multiples of g.\n\n        However, the product is fixed: g * l = X[u] * X[v].\n\n        Also, we know that the gcd is g. So we can iterate over divisors? But l can be up to 10^6, and then the number of divisors is around 100-200, which is acceptable per edge? But we have up to 10^5 edges, so total operations 10^5 * 200 = 20e6, which is acceptable.\n\n        But note: we have to assign for all nodes consistently.\n\n        However, we are not required to find all solutions, just one or report that none exists.\n\n        Steps:\n\n        1. For each edge, check if g divides l. If not, output \"NO\".\n\n        2. For each edge, we can record the possible pairs (a, b) such that:\n               a * b = g * l, and gcd(a, b) = g, and a and b are in the range [g, l] (actually, a and b must be multiples of g, and divisors of l? Actually, since a divides the lcm (because the lcm is a multiple of a) and similarly for b, but note: the lcm is the least common multiple, so a and b must divide the lcm? Not necessarily: the lcm is a multiple of both a and b, so yes, a divides the lcm and b divides the lcm.\n\n        But wait, is that true? Actually, the lcm is the smallest number that is a multiple of both a and b. Therefore, a divides the lcm and b divides the lcm.\n\n        So we can generate the divisors of l (which is <= 10^6) for each edge. But note: l can be up to 10^6 and we have up to 10^5 edges, so we cannot factorize 10^5 numbers up to 10^6 (that would be too slow).\n\n   We need a better way.\n\n   Let me reframe:\n\n        We know that for an edge (u, v): \n            X[u] * X[v] = g * l, and gcd(X[u], X[v]) = g.\n\n        Then, we can write:\n            Let X[u] = g * a, X[v] = g * b, then a and b must be coprime and a * b = l // g.\n\n        So the problem reduces to: for the product P = l//g, we need two coprime numbers a and b such that a * b = P.\n\n        And note: the value of X[u] = g * a, and X[v] = g * b must be in [1, 10^6]. But the problem says the original numbers were in [1, 10^6], so we require 1 <= g*a <= 10^6 and 1 <= g*b <= 10^6.\n\n        Now, for each edge, we can factorize P = l//g (if we do that for each edge, and there are up to 10^5 edges, and P can be up to 10^6, then we might do 10^5 factorizations, which is acceptable because the maximum P is 10^6 and we can precompute the smallest prime factor (spf) for numbers up to 10^6, but wait, the problem says up to 10^6, so we can precompute the divisors for numbers up to 10^6.\n\n        However, note: the constraints say that the input GCD and LCM are between 1 and 10^6, so l//g can be as large as 10^6 (if g=1, then l=10^6). And we have up to 10^5 edges, so we would need to factorize up to 10^5 distinct numbers (each up to 10^6). Without precomputation, factorizing 10^5 numbers up to 10^6 might be acceptable in Pyton if we use a simple trial division (because 10^6 has about 168 primes, but worst-case we iterate up to sqrt(10^6)=1000, so 10^5 * 1000 = 100e6, which is acceptable in C++ but in Python we should be cautious).\n\n        Alternatively, we can precompute the smallest prime factor (spf) for numbers up to 10^6. Then factorization of any number up to 10^6 would be O(log n). But we have 10^5 edges, so 10^5 factorizations, which is acceptable with precomputation.\n\n        However, the problem says the input size is up to 10^5 edges, and we are only given n, m and m lines. We must be efficient.\n\n        But note: the problem says that the numbers on the roads on the initial map were no less than 1 and did not exceed 10^6. So the LCM and GCD are in [1, 10^6]. Then, for each edge, we compute P = LCM // GCD. Then, we factorize P to get all divisors? Actually, we don't need the factorization for the entire graph, we only need to split P into two coprime factors.\n\n        Actually, we don't need all divisors, we only need to check if there exists a divisor d of P such that gcd(d, P//d) == 1. And then we can assign (g*d, g*(P//d)) to the two nodes.\n\n        But wait: we must assign consistently across the graph.\n\n        So here's the plan:\n\n        We are going to build a graph and then do a BFS/DFS to assign values to the nodes.\n\n        Steps:\n\n          1. Precomputation: Factorize is not needed for the entire graph, but we need to check for each edge the existence of a representation.\n\n          2. For each edge (u, v, g, l):\n                Check if l % g != 0 -> then NO.\n                Let P = l // g.\n                Now, we need to split P into two coprime factors. There always exists at least one way: the trivial split (1, P) is coprime.\n\n                However, we have multiple edges. We want to assign a value to each node.\n\n          3. We can set up:\n\n                Let A[u] and A[v] must be multiples of g, and A[u] = g * a, A[v] = g * b, with a*b = P and gcd(a,b)=1.\n\n          4. The key: the same node u must have the same value in all edges incident to it.\n\n          5. We can use a graph coloring / assignment:\n\n                We start from an arbitrary node and set a value for it.\n\n                Then, for each edge from that node, we determine the value of the neighbor.\n\n                How?\n\n                    Suppose we set node u to value V. Then, for an edge (u, v) with gcd g and lcm l, we know:\n\n                         V * A[v] = g * l   =>   A[v] = (g * l) / V.\n\n                    But also, we require that gcd(V, A[v]) = g.\n\n                    However, note: from the representation, V = g * a, and A[v] = g * b, and a * b = P = l//g, and gcd(a,b)=1.\n\n                    Therefore, we must have that V divides (g * l) and also that the gcd of V and (g*l)/V is g.\n\n          6. But wait: we don't know the factorization of V. However, from the edge condition, we have:\n\n                Condition 1: V must divide (g*l) (so that A[v] is an integer).\n                Condition 2: gcd(V, (g*l)//V) == g.\n\n          7. How to check condition 2?\n\n                Let d = gcd(V, (g*l)//V). Then we require d == g.\n\n                But note: we also know that V is a multiple of g (from the edge condition: the edge's gcd is g, so g divides V and g divides A[v]). \n\n                Now, condition 2: \n                    Let V = g * a, then (g*l)//V = (g*l) / (g*a) = (l/g) / a = P / a.\n\n                Then, we require gcd(g*a, P/a) = g.\n\n                But note: since a and P/a are coprime (by the representation), then gcd(g*a, P/a) = gcd(g, P/a) * gcd(a, P/a) ? Not exactly.\n\n                Actually, we have:\n\n                    gcd(g*a, P/a) = gcd(g*a, P/a)\n\n                And we know that a and P/a are coprime, so the gcd is the same as gcd(g, P/a) because a and P/a are coprime, so the factors of a do not interact with P/a.\n\n                But wait, we also have that g divides P (because P = l//g, and l is divisible by g, and then g divides l, so P is an integer). Moreover, note that a must divide P (because V = g*a, and V divides g*l, so a divides l). \n\n                However, we don't know the relation between g and a.\n\n          8. Alternatively, we can avoid the above complexity by using the following:\n\n                We know that the value for node u (V) must be divisible by g (the edge gcd). Then, we set A[v] = (g*l) // V.\n\n                Then, we check two conditions:\n\n                    Condition 1: (g*l) % V == 0.\n                    Condition 2: gcd(V, A[v]) == g.\n\n                But note: Condition 1 is necessary for A[v] to be an integer.\n\n                Condition 2: gcd(V, (g*l)//V) == g.\n\n          9. However, we must also ensure that the value assigned to node v is consistent with the other edges incident to v.\n\n        So the algorithm:\n\n          We'll build a graph with n nodes and m edges.\n\n          We'll maintain an array ans[0..n-1] for the assigned value, initially -1 (unassigned).\n\n          Steps:\n\n            Step 1: For each edge, check if the given gcd divides the lcm. If not, output \"NO\" and exit.\n\n            Step 2: Choose an arbitrary node (say node 0) and set ans[0] to a value.\n\n            But what value? We don't know. We can set it arbitrarily? \n\n            However, note: the value must be a divisor of the product of the gcds of edges incident to it? Actually, no. We have to satisfy the edge conditions.\n\n            Instead, we can use the following:\n\n                We can set the initial value for node 0 to be the product of the gcds of all edges incident to node 0? That might be too big.\n\n            Alternatively, we can set the initial value to 1? But then for an edge from node0 to node1 with gcd=g and lcm=l, we require:\n\n                Condition 1: 1 * A[1] = g*l -> A[1] = g*l, which must be an integer (yes) and then we check gcd(1, g*l)==g -> which implies g==1.\n\n            So that doesn't work.\n\n            Let me think: we can set node0 to a value that is the LCM of the gcds from the edges incident to node0? But we don't know the edges incident to node0 until we read the graph.\n\n            Another idea: use the fact that for an edge (u, v) we have two possibilities for the assignment. We can fix the value for node0 arbitrarily, but then we must choose a value that is divisible by the gcd of the first edge we use.\n\n            Actually, we can set the value for node0 as the LCM of the gcds of all edges incident to node0. Why? Because node0 must be divisible by each edge's gcd. Then, we set:\n\n                Let L0 = LCM of all gcds from edges incident to node0.\n\n                Then, set ans[0] = L0 * k, for some k? But we don't know k.\n\n            Alternatively, we set ans[0] = L0 (the LCM of the gcds). Then, for each edge (0, v) with gcd g and lcm l:\n\n                We require: ans[0] * ans[v] = g * l   =>   L0 * ans[v] = g * l   =>   ans[v] = (g * l) / L0.\n\n                Then, we must check:\n\n                    (g * l) % L0 == 0, and gcd(L0, (g*l)//L0) == g.\n\n            But note: L0 is the LCM of the gcds from the edges incident to node0. It is divisible by g (since g is one of the gcds). So (g*l) is divisible by L0? Not necessarily, because L0 is the LCM of several gcds, and the LCM of a set of numbers might not divide g*l.\n\n            Example: \n                Node0 has two edges: \n                    edge1: (0,1) with gcd=2, lcm=6 -> then l=6, so g*l=12.\n                    edge2: (0,2) with gcd=3, lcm=6 -> then g*l=18.\n                Then L0 = LCM(2,3)=6.\n                Then for edge1: (2*6)%6==0 -> yes, and (2*6)//6 = 2, then gcd(6,2)=2 -> matches g=2.\n                For edge2: (3*6)//6=3, then gcd(6,3)=3 -> matches g=3.\n\n            So that works.\n\n            But what if the graph is not connected? Then we have to do this for each connected component.\n\n            Steps:\n\n              - Build the graph and for each node, store the list of edges (neighbor, gcd, lcm).\n              - Compute for each node the LCM of the gcds of all edges incident to it (call it base[node]). If there are no edges, then base[node] = 1? (because the empty set LCM is 1 by convention).\n\n              - Then, for each connected component, pick a starting node s. Then set ans[s] = base[s] * k, but wait, we set it to base[s] (the LCM of the gcds). Then, for each edge from s to v, set:\n\n                    candidate = (g * l) // base[s]\n\n                    Then, we require that candidate is an integer and that gcd(base[s], candidate) == g.\n\n              - Then, assign ans[v] = candidate.\n\n              - Then, for the next edges from v, we update base[v] (if we haven't already) by taking the LCM of the current base[v] (if any) and the gcd from the edge (v, ...). But wait, we already computed base[v] as the LCM of the gcds of all edges incident to v. So we don't update base[v] during assignment, we use the precomputed base[v].\n\n            However, note: when we assign a value to v, we must use the same base[v] (the LCM of the gcds of all edges incident to v) and then for an edge (v, u) (which we already used) we have:\n\n                    ans[u] = (g * l) // base[v]\n\n            But wait, we did:\n\n                    For edge (s, v): \n                        ans[s] = base[s]\n                        ans[v] = (g * l) // base[s]\n\n            Then, for an edge (v, w) (another edge from v), we use:\n\n                    ans[w] = (g2 * l2) // base[v]\n\n            But note: base[v] is the LCM of the gcds of all edges incident to v. This includes the edge (s, v) with gcd g and the edge (v, w) with gcd g2.\n\n            However, we are using the same base[v] for all edges from v.\n\n            But note: the value ans[v] must be divisible by base[v]. Is that true?\n\n                    ans[v] = (g * l) // base[s]\n\n            And base[s] is divisible by g (because base[s] is the LCM of the gcds including g). But base[s] might be larger than g. Then, (g * l) // base[s] might not be divisible by base[v]? \n\n            Actually, we don't require that ans[v] is divisible by base[v] by the condition of the edge (s, v). The condition for edge (s, v) only requires that the gcd(ans[s], ans[v]) = g. \n\n            However, we require that the value ans[v] must be divisible by every gcd from edges incident to v. Why?\n\n                Consider: for edge (v, w) with gcd g2, then g2 must divide ans[v] and ans[w].\n\n            So we must ensure that base[v] divides ans[v]. \n\n            How do we ensure that?\n\n                We set ans[v] = (g * l) // base[s]\n\n                But base[s] is the LCM of the gcds of edges incident to s, and we are using the edge (s, v) to set ans[v]. The gcd for this edge is g. \n\n                We require that base[v] divides ans[v]. But base[v] is the LCM of all gcds from edges incident to v, including g and g2, etc. \n\n                However, note: we are not using base[v] to set ans[v] (we are using base[s]). \n\n            This suggests that our initial assignment for node s must be chosen so that for every edge (s, v), the value (g * l) // base[s] is divisible by base[v] (the LCM of the gcds of all edges incident to v). But base[v] is fixed and we don't know it until we process the entire graph.\n\n            Alternatively, we can do:\n\n                Step 1: Precompute for each node the LCM of the gcds of all edges incident to it (call this base[node]).\n                Step 2: For each connected component, pick a starting node s and set ans[s] = base[s] (this satisfies that ans[s] is divisible by base[s]).\n                Step 3: Then, for each neighbor v of s, set ans[v] = (g * l) // base[s]. Then, we must check:\n\n                    (a) (g * l) % base[s] == 0\n                    (b) gcd(ans[s], ans[v]) == g   (which is the given gcd for edge (s, v))\n                    (c) ans[v] must be divisible by base[v] (the LCM of the gcds of all edges incident to v)\n\n                Condition (c) is critical because the edge (s, v) is one of the edges incident to v, so base[v] must divide ans[v]. \n\n            How to check (c)? We can check if ans[v] % base[v] == 0.\n\n            But note: base[v] is the LCM of the gcds from all edges incident to v. We have processed one edge (s, v) and we know one gcd (g) is in base[v]. But base[v] might be larger than g (if there are other edges incident to v with gcds that are not dividing g). Actually, base[v] is the LCM of the gcds, so it is divisible by g. However, we require that base[v] divides ans[v]. \n\n            Example: \n                Node v has two edges: (s, v) with gcd=2, and (v, w) with gcd=3. Then base[v] = LCM(2,3)=6.\n                We set ans[v] = (2 * l) // base[s] (where base[s] is the LCM of the gcds of edges incident to s). \n                Then we require that 6 divides ans[v].\n\n            But note: we don't know base[s] and l (the LCM for edge (s,v)) and we don't know the other edges (to w) until we process them.\n\n            So we must do:\n\n                Step 1: Read the graph and compute base[node] for each node (the LCM of the gcds of edges incident to node).\n\n                Step 2: For each connected component, do a BFS/DFS:\n\n                    Start with a node s, set ans[s] = base[s] (which is divisible by base[s] by definition).\n\n                    Then, for each edge (s, v) with gcd g and lcm l:\n\n                         candidate = (g * l) // base[s]\n\n                         Check:\n                            (i) candidate must be an integer (i.e., base[s] divides g*l)\n                            (ii) gcd(ans[s], candidate) == g\n                            (iii) candidate must be divisible by base[v] (the precomputed LCM for v)\n\n                    Then, set ans[v] = candidate.\n\n                    Then, push v into the queue and for each edge (v, u) (including the one we just came from and others) we set:\n\n                         candidate2 = (g2 * l2) // base[v]   (for edge (v, u) with gcd g2 and lcm l2)\n\n                    And check the conditions similarly.\n\n                However, note: the edge (v, u) might have been considered from u's side? But we are doing BFS so we mark visited.\n\n            But wait: the graph is undirected. We are traversing from s to v, then from v to u. The edge (v, u) is the same as (u, v). We must ensure that the assignment from both sides is consistent.\n\n            How? \n\n                When we visit u from v, we set ans[u] = (g2 * l2) // base[v]\n\n                But if we had visited u earlier from another path, we must have set ans[u] already.\n\n            So we do:\n\n                We use a visited array. We start from s, then we set ans[s] = base[s]. Then we mark s as visited.\n\n                Then, for each neighbor v of s:\n\n                    candidate = (g * l) // base[s]\n\n                    Check conditions (i), (ii), (iii) above.\n\n                    Then, set ans[v] = candidate and mark v visited.\n\n                    Then, for each neighbor u of v (excluding s if we don't want to go back, but we must consider all edges):\n\n                         candidate2 = (g2 * l2) // base[v]\n\n                    And then check conditions (i) (base[v] divides g2*l2?), (ii) gcd(ans[v], candidate2)==g2, (iii) candidate2 is divisible by base[u] (if u is unvisited).\n\n            However, note: the condition (i) for an edge (v, u) is: base[v] divides (g2 * l2). But base[v] is the LCM of the gcds of edges incident to v. We have one edge (s, v) and then (v, u). The gcd for (s, v) is g, and for (v, u) is g2. Then base[v] = LCM(g, g2, ...). \n\n            Condition (i) for edge (v, u): base[v] divides (g2 * l2). \n\n            But note: base[v] is divisible by g2 (because base[v] is the LCM of the gcds, which includes g2). Therefore, base[v] divides (g2 * l2) if and only if (l2) is divisible by (base[v] // g2). But wait, we don't know l2.\n\n            Actually, from the edge (v, u): \n                We know that l2 must be divisible by base[v]? Not necessarily. But note: the edge (v, u) has gcd = g2 and lcm = l2, so we must have that g2 divides l2. And base[v] is divisible by g2, but base[v] might have extra prime factors that are not in g2. Then, base[v] divides g2 * l2? \n\n                Since base[v] = g2 * k (for some integer k) and k divides l2? Not necessarily. \n\n            Example: \n                Edge (v, u): g2=2, l2=6 -> then base[v] (for node v) is the LCM of the gcds of edges incident to v. Suppose there's another edge incident to v with gcd=3, then base[v]=6. Then, base[v] divides (g2*l2)=12 -> yes.\n\n                But if there's no other edge, then base[v]=2, then 2 divides 12 -> yes.\n\n            However, consider: \n                Edge (v, u): g2=2, l2=4 -> then base[v]=2 (if only this edge) then 2 divides 8 (2*4) -> yes.\n\n            Actually, we know that from the edge (v, u): \n                We have: g2 * l2 = (g2 * a) * (g2 * b) = g2^2 * a * b, and we also know that the product of the two numbers is g2 * l2, so the two numbers are (g2 * a, g2 * b) and a*b = l2 // g2.\n\n            But condition (i) requires base[v] divides (g2 * l2). Since base[v] is divisible by g2, we can write base[v] = g2 * t. Then, we require that g2 * t divides (g2 * l2) -> t divides l2.\n\n            Now, t is the LCM of the gcds of edges incident to v divided by g2. In the case of only one edge, t=1. Then, we require 1 divides l2, which is always true.\n\n            But if there are multiple edges, then t might be greater than 1. Then, we require that t divides l2.\n\n            However, note: the edge (v, u) was given and we know that l2 is the LCM of the two numbers. The two numbers are (g2 * a, g2 * b) and the LCM is g2 * a * b (since a and b are coprime). Therefore, l2 = g2 * a * b.\n\n            Then, condition (i): base[v] divides (g2 * l2) = g2 * (g2 * a * b) = g2^2 * a * b.\n\n            And base[v] = LCM_{incident edges} (gcd) = LCM( g1, g2, ... ) (for edges incident to v). \n\n            But note: we don't have a direct relation between base[v] and l2 (the LCM of the edge (v,u)).\n\n            Therefore, we cannot assume that base[v] divides g2*l2. We must check the divisibility condition (i) for each edge.\n\n            However, note: the edge (v, u) is given and we know that the two numbers on the edge must be divisors",
    "response": "\nTo solve this problem, we need to determine if it's possible to restore the number of mushrooms on each lawn (node) in a forest map based on given roads (edges) that provide the greatest common divisor (GCD) and least common multiple (LCM) of the mushroom counts on the connected lawns. The solution involves verifying the consistency of these GCD and LCM values across all edges and assigning mushroom counts to each node such that all edge conditions are satisfied.\n\n### Approach\n1. **Graph Representation**: Represent the forest as a graph where each node is a lawn and each edge contains the GCD and LCM values provided.\n2. **Precompute Base Values**: For each node, compute the base value as the least common multiple (LCM) of all GCD values from edges incident to it. This base value ensures that the node's mushroom count will be divisible by all relevant GCDs.\n3. **BFS for Assignment**: Perform a breadth-first search (BFS) starting from an arbitrary node. Assign the base value to the starting node. For each neighboring node, compute its mushroom count using the edge's GCD and LCM, ensuring the conditions (divisibility and GCD match) are met.\n4. **Validation**: During BFS, validate that the computed mushroom count for each node meets the necessary conditions (divisibility by the base value and correct GCD with adjacent nodes). If any condition fails, the arrangement is impossible.\n\n### Solution Code\n```python\nimport math\nfrom collections import deque\nimport sys\n\nsys.setrecursionlimit(200000)\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    it = iter(data)\n    n = int(next(it)); m = int(next(it))\n    \n    edges = []\n    for i in range(m):\n        u = int(next(it)); v = int(next(it))\n        g = int(next(it)); l = int(next(it))\n        edges.append((u-1, v-1, g, l))\n        \n    graph = [[] for _ in range(n)]\n    for u, v, g, l in edges:\n        graph[u].append((v, g, l))\n        graph[v].append((u, g, l))\n        \n    base = [0] * n\n    for i in range(n):\n        if len(graph[i]) == 0:\n            base[i] = 1\n        else:\n            current = 1\n            for _, g_val, _ in graph[i]:\n                current = (current * g_val) // math.gcd(current, g_val)\n            base[i] = current\n            \n    visited = [False] * n\n    ans = [-1] * n\n    valid = True\n    \n    for i in range(n):\n        if not visited[i]:\n            q = deque()\n            q.append(i)\n            visited[i] = True\n            ans[i] = base[i]\n            \n            while q:\n                node = q.popleft()\n                for neighbor, g_val, l_val in graph[node]:\n                    if visited[neighbor]:\n                        continue\n                    product = g_val * l_val\n                    if product % ans[node] != 0:\n                        valid = False\n                        break\n                    candidate = product // ans[node]\n                    if math.gcd(ans[node], candidate) != g_val:\n                        valid = False\n                        break\n                    if candidate % base[neighbor] != 0:\n                        valid = False\n                        break\n                    if not valid:\n                        break\n                    ans[neighbor] = candidate\n                    visited[neighbor] = True\n                    q.append(neighbor)\n                if not valid:\n                    break\n                    \n            if not valid:\n                break\n                \n    if not valid:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(\" \".join(map(str, ans)))\n        \nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n1. **Graph Representation**: The input is read and parsed into a graph structure where each node points to its neighbors along with the GCD and LCM values of the connecting edge.\n2. **Base Value Calculation**: For each node, the base value is calculated as the LCM of all GCD values from its incident edges. This ensures the node's mushroom count will be divisible by all relevant GCDs.\n3. **BFS Assignment**: Starting from an unvisited node, BFS is used to traverse the graph. The starting node's mushroom count is set to its base value. For each neighboring node, the mushroom count is derived from the edge's GCD and LCM, ensuring it meets divisibility and GCD conditions.\n4. **Validation**: During traversal, each computed mushroom count is checked to ensure it is divisible by the neighbor's base value and that the GCD with the current node matches the edge's specified GCD. If any check fails, the solution is deemed impossible (\"NO\"). Otherwise, the mushroom counts are printed (\"YES\").\n\nThis approach efficiently checks for the feasibility of the mushroom count arrangement and ensures consistency across all edges in the graph.",
    "ground_truth": "N/A",
    "extracted_answer": "import math\nfrom collections import deque\nimport sys\n\nsys.setrecursionlimit(200000)\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    \n    it = iter(data)\n    n = int(next(it)); m = int(next(it))\n    \n    edges = []\n    for i in range(m):\n        u = int(next(it)); v = int(next(it))\n        g = int(next(it)); l = int(next(it))\n        edges.append((u-1, v-1, g, l))\n        \n    graph = [[] for _ in range(n)]\n    for u, v, g, l in edges:\n        graph[u].append((v, g, l))\n        graph[v].append((u, g, l))\n        \n    base = [0] * n\n    for i in range(n):\n        if len(graph[i]) == 0:\n            base[i] = 1\n        else:\n            current = 1\n            for _, g_val, _ in graph[i]:\n                current = (current * g_val) // math.gcd(current, g_val)\n            base[i] = current\n            \n    visited = [False] * n\n    ans = [-1] * n\n    valid = True\n    \n    for i in range(n):\n        if not visited[i]:\n            q = deque()\n            q.append(i)\n            visited[i] = True\n            ans[i] = base[i]\n            \n            while q:\n                node = q.popleft()\n                for neighbor, g_val, l_val in graph[node]:\n                    if visited[neighbor]:\n                        continue\n                    product = g_val * l_val\n                    if product % ans[node] != 0:\n                        valid = False\n                        break\n                    candidate = product // ans[node]\n                    if math.gcd(ans[node], candidate) != g_val:\n                        valid = False\n                        break\n                    if candidate % base[neighbor] != 0:\n                        valid = False\n                        break\n                    if not valid:\n                        break\n                    ans[neighbor] = candidate\n                    visited[neighbor] = True\n                    q.append(neighbor)\n                if not valid:\n                    break\n                    \n            if not valid:\n                break\n                \n    if not valid:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(\" \".join(map(str, ans)))\n        \nif __name__ == '__main__':\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 553,
        "completion_token_count": 1055,
        "thoughts_token_count": 8191
    }
}