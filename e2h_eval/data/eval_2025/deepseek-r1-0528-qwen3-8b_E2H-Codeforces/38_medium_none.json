{
    "start": 1758300516.922891,
    "end": 1758304358.0192535,
    "start-formatted": "2025-09-20 01:48 KST",
    "end-formatted": "2025-09-20 02:52 KST",
    "gpu": 2,
    "pid": 38,
    "use_openrouter": 0,
    "prompt": [
        {
            "role": "user",
            "content": "The following is a competitive programming problem.\n\n# Node Pairs\n\nLet's call an ordered pair of nodes $$$(u, v)$$$ in a directed graph unidirectional if $$$u \\neq v$$$, there exists a path from $$$u$$$ to $$$v$$$, and there are no paths from $$$v$$$ to $$$u$$$.A directed graph is called $$$p$$$-reachable if it contains exactly $$$p$$$ ordered pairs of nodes $$$(u, v)$$$ such that $$$u < v$$$ and $$$u$$$ and $$$v$$$ are reachable from each other. Find the minimum number of nodes required to create a $$$p$$$-reachable directed graph.Also, among all such $$$p$$$-reachable directed graphs with the minimum number of nodes, let $$$G$$$ denote a graph which maximizes the number of unidirectional pairs of nodes. Find this number.\n\n## Input\nThe first and only line contains a single integer $$$p$$$ ($$$0 \\le p \\le 2 \\cdot 10^5$$$) — the number of ordered pairs of nodes.\n\n## Output\nPrint a single line containing two integers — the minimum number of nodes required to create a $$$p$$$-reachable directed graph, and the maximum number of unidirectional pairs of nodes among all such $$$p$$$-reachable directed graphs with the minimum number of nodes.\n\n## Example\n### Input\n['3', '4', '0']\n\n### Output\n['3 0', '5 6', '0 0']\n\n## Note\nIn the first test case, the minimum number of nodes required to create a $$$3$$$-reachable directed graph is $$$3$$$. Among all $$$3$$$-reachable directed graphs with $$$3$$$ nodes, the following graph $$$G$$$ is one of the graphs with the maximum number of unidirectional pairs of nodes, which is $$$0$$$.   \n\nYour task is to solve the problem above by writing a Python script that reads input from standard input (stdin) and prints the desired outputs to standard output (stdout). Please ensure your solution is efficient and handles all edge cases. Make sure to include any necessary imports and helper functions. Your code should be ready to run and should not include any additional explanations or comments."
        }
    ],
    "thought": "\n Okay, we are given an integer p (0 <= p <= 200000). We need to:\n 1. Find the minimum number of nodes n such that there exists a directed graph with n nodes that is p-reachable.\n    - Note: The graph must have exactly p ordered pairs (u, v) with u < v and u and v being mutually reachable.\n\n 2. Among all graphs with the minimum number of nodes that are p-reachable, find the maximum number of unidirectional pairs (u, v) (with u != v, a path from u to v but not from v to u).\n\n Observation for part 1:\n\n What does it mean for a directed graph to be p-reachable?\n    It has exactly p unordered pairs {u, v} (or ordered pairs (u, v) with u < v) that are mutually reachable.\n\n In a directed graph, mutual reachability forms equivalence classes (strongly connected components, SCCs). \n However, note: the problem says \"ordered pairs of nodes (u, v) in a directed graph unidirectional\" but then defines p-reachability as having exactly p ordered pairs (u, v) with u < v and u and v mutually reachable.\n\n Actually, note: the condition for p-reachability is defined for pairs (u, v) with u < v. So if two nodes are mutually reachable, then the pair (u, v) (with u < v) counts. But note that the same mutual reachability also implies that (v, u) would be a mutual pair, but the condition only counts one per unordered pair (since u < v). So each strongly connected component (SCC) of size at least 2 will contribute C(size,2) = (size*(size-1))//2 pairs.\n\n However, note: the entire graph might not be strongly connected. But the definition of p-reachability is just about the existence of exactly p pairs (u, v) with u < v and mutual reachability. \n\n How do we arrange the graph?\n\n Let's break the graph into k strongly connected components (SCCs). Then, the mutual reachability condition: within an SCC, every pair (u, v) with u < v is mutually reachable (if the SCC has m nodes, then it contributes C(m,2) pairs). And between two different SCCs, if there's a path from one to the other, then we don't have mutual reachability (because the graph is acyclic in terms of SCCs? Actually, we can arrange the SCCs in a linear order so that there is a path from an earlier SCC to a later one, but not the reverse). \n\n Therefore, the entire graph's set of mutually reachable pairs is the sum over each SCC of C(m_i, 2). \n\n So we need to form a graph with a decomposition into SCCs (which can be arranged in a DAG, and without cycles in the DAG) such that the total number of mutually reachable pairs (i.e., the sum of C(m_i,2) for each SCC) is exactly p.\n\n However, note that the problem does not require that the entire graph is strongly connected. It only requires that there are exactly p pairs (u, v) (with u < v) that are mutually reachable.\n\n Now, we want the minimum number of nodes n (so the sum of the sizes of the SCCs) such that we can partition n into some integers m1, m2, ..., mk (each >=1, and the sum is n) and the sum of C(m_i, 2) is at least p, and we can choose the partition so that the sum is exactly p? \n\n But note: we can also choose to have multiple SCCs. However, we cannot arbitrarily assign the pairs because the function C(m,2) is fixed for each SCC. \n\n However, note: the problem says \"exactly p\", so we must have the total sum of C(m_i, 2) equal to p.\n\n But wait: we are allowed to choose any graph. We are not forced to use only one way to decompose. However, note that we are to minimize the total number of nodes.\n\n How do we minimize the number of nodes for a given p?\n\n We know that the function f(m) = C(m,2) = m*(m-1)//2 is a quadratic function. We want to represent p as a sum of triangular numbers (each triangular number is T(m)=m*(m-1)//2) and we want the minimal total nodes (which is the sum of the m_i's) for which the triangular numbers sum to p.\n\n However, note: we are not limited to using only one type of SCC. We can have multiple SCCs. But the entire graph must be decomposed into SCCs (each node in one SCC). The total number of pairs (from the SCCs) must be p.\n\n This is similar to the coin change problem where we have coins of denominations T(m) for m>=1, and we want to represent p as a sum of these coins, and we want to minimize the total number of nodes (which is the sum of the bases m for each coin used, because each SCC of size m uses m nodes and contributes T(m) to p).\n\n But note: the same node cannot be split. Each node is in one SCC.\n\n So we are to write p as a sum of triangular numbers (allowing repetition) and minimize the total base (the sum of the m_i's).\n\n However, there's a catch: we cannot use the same node twice, but in our representation, each SCC is independent. The minimal total nodes is the sum of the m_i's.\n\n Example: p=3.\n   We can use one SCC of size 3: T(3)=3. Then total nodes = 3.\n   Alternatively, we could use three SCCs of size 2: T(2)=1, so three of them gives 3. Then total nodes = 2+2+2 = 6.\n   Or two SCCs: one of size 2 (gives 1) and one of size 3 (gives 3) -> but 1+3=4 which is too much, so we don't use that.\n\n So the minimal total nodes for p=3 is 3.\n\n How to compute this?\n\n We note that the triangular numbers are: T(1)=0, T(2)=1, T(3)=3, T(4)=6, T(5)=10, etc.\n\n We can use dynamic programming (DP) for small p? But p can be up to 200000.\n\n Alternatively, note that we are allowed to use multiple copies of the same SCC. We want to minimize the total nodes (which is the sum of the sizes) for representing p as the sum of triangular numbers.\n\n However, the problem also asks for the maximum number of unidirectional pairs in a graph with the minimum number of nodes and p-reachable.\n\n Steps:\n\n 1. Find the minimal n (number of nodes) such that there exists a set of positive integers {m1, m2, ..., mk} (each at least 1) with sum_{i} [T(m_i)] = p and sum_{i} m_i = n, and n is minimized.\n\n 2. Then, among all graphs with n nodes and exactly p mutually reachable pairs (which is the same as the sum of T(m_i) being p), we want to maximize the number of unidirectional pairs.\n\n How to do step 1?\n\n Since T(m) = m*(m-1)//2, and T(m) grows quadratically, the minimal n is achieved by using as few large SCCs as possible (because T(m) is the contribution per node set, and we want to cover p with minimal total nodes).\n\n However, note: the minimal n is the minimal sum of the m_i's such that the sum of T(m_i) is p.\n\n But note: we can use any triangular numbers (any m>=1). However, T(1)=0, so including an SCC of size 1 doesn't add to p. So we can ignore 1's because they don't help in increasing p.\n\n Actually, we can consider that the entire graph is broken down into SCCs. The total p is the sum of T(m_i) for each SCC. The total nodes is the sum of m_i.\n\n We want to minimize the total nodes.\n\n Observation: The more we use larger SCCs, the more p we get per node. But sometimes breaking a large SCC into smaller ones might allow us to use fewer total nodes? \n\n Example: p=3. \n   Option 1: one SCC of size 3 -> nodes=3, p=3.\n   Option 2: three SCCs of size 2 -> nodes=6, p=3.\n\n So we prefer larger SCCs.\n\n But wait: what if p=6?\n   One SCC of size 4: T(4)=6, nodes=4.\n   Two SCCs of size 3: T(3)=3, so two gives 6, nodes=3+3=6.\n\n So for p=6, we can use either 4 nodes (one SCC of size 4) or 6 nodes (two SCCs of size 3). The minimal is 4.\n\n Similarly, p=7:\n   One SCC of size 4: 6, then we need 1 more. We can have another SCC of size 2 (which adds 1) -> total nodes=4+2=6, p=7.\n   Or: one SCC of size 4 (6) and one SCC of size 1 (0) -> then p=6, not enough.\n        so we need at least 6 nodes.\n\n   Alternatively, two SCCs: one of size 3 (3) and one of size 3 (3) -> total p=6, then we need one more. Then we can break one of the size 3? Actually, we can't. Instead, we can use one SCC of size 4 (6) and one of size 2 (1) -> total 7 and nodes 6.\n\n   Or: one SCC of size 3 (3) and one SCC of size 3 (3) and one SCC of size 2 (1) -> total p=7, nodes=8. Worse.\n\n   Or: one SCC of size 5: T(5)=10 -> too big.\n\n   So minimal nodes for p=7 is 6.\n\n How to compute the minimal n for given p?\n\n We note that the triangular numbers are 0,1,3,6,10,15,... (for m=1,2,3,4,5,6,...)\n\n We can use a greedy method: start from the largest triangular number <= p, then subtract and continue.\n\n However, note: we are minimizing the total nodes. The function T(m) is increasing, but the efficiency (p per node) is T(m)/m = (m-1)/2, which increases with m. So using larger m is more efficient (more p per node). Therefore, we want to use as many large SCCs as possible.\n\n But we cannot exceed p. So we can use the following:\n\n Let F(p) be the minimal total nodes required to represent p as the sum of triangular numbers (allowing repetition).\n\n We know that T(m) = m*(m-1)//2.\n\n We can try to use the fact that the greedy algorithm for the coin change (using the largest coin first) minimizes the total number of coins (but here we care about the total nodes, not the number of SCCs). However, note: the total nodes is the sum of the bases (the m_i's). \n\n Example: p=7: \n   Using largest triangular number <=7: T(4)=6, then remainder=1. Then we use T(2)=1. Total nodes=4+2=6.\n\n Example: p=6: \n   Largest triangular number <=6: T(4)=6, remainder=0. Total nodes=4.\n\n Example: p=5:\n   T(3)=3, then remainder=2. Then we can use T(2)=1 (twice) but wait, 3+1+1=5, so nodes=3+2+2=7.\n   Alternatively, we can use two T(3)=3 and then we have 5-6 is negative, so no. Or maybe use T(4)=6 is too big. \n   But wait: we can use T(3)=3 and then T(2)=1 and T(2)=1, so 3+1+1=5. Is there a better way?\n   Another idea: use T(3)=3 and then T(3)=3 is 6 which exceeds 5. So we must break into 3,2,2. Or use two T(3)=3 and then we have 6 which is too big, so we cannot. So minimal nodes=7.\n\n However, wait: can we use a single SCC of size 4? That gives 6, which is too big. Then we have to use smaller ones.\n\n But note: we are allowed to use any combination. There might be a better way: \n   What if we use one SCC of size 3 and two SCCs of size 2? Then p=3+1+1=5, nodes=3+2+2=7.\n\n   Alternatively, we can use one SCC of size 4? Then we have 6, which is too big. Then we can break the 4 into two 2's? But that would be two SCCs of size 2, then p=1+1=2, which is not 5.\n\n   Alternatively, we can use one SCC of size 3 (3) and then the remaining 2 can be represented by two SCCs of size 2? Actually, we cannot: because two SCCs of size 2 give 1+1=2, so total 5. So that works.\n\n   But wait, is there a way to use fewer than 7 nodes? \n   We must have at least 3 (from the SCC of size 3) and then 2+2=4, total 7.\n\n   Another representation: can we use an SCC of size 4 and then remove some? No, because we can't break an SCC arbitrarily (we are decomposing the graph). \n\n   So the minimal nodes for p=5 is 7.\n\n But note: we are allowed to have multiple SCCs. The entire graph is the disjoint union of these SCCs (in a DAG). \n\n How to compute F(p) for p up to 200000?\n\n Since the triangular numbers grow as m^2/2, the largest m we need is about sqrt(2*p). For p=200000, m_max ~ sqrt(400000) ~ 632.\n\n We can precompute the minimal nodes for all values of p from 0 to 200000.\n\n However, the state space is 200001, and we have triangular numbers up to 632 (so about 632 different denominations). Then we can do a DP with:\n\n   dp[i] = minimal total nodes to represent i (i from 0 to p_max=200000)\n\n   Then, for each triangular number t (for m from 2 to 632, since T(1)=0 and we can ignore zeros) and for j from t to p_max:\n        dp[j] = min(dp[j], dp[j-t] + m)\n\n But note: we are allowed to use any triangular number (any m) any number of times.\n\n However, the triangular numbers are distinct, but we can use the same triangular number multiple times. So we have to iterate over all m (from 2 to 632) and update the dp array.\n\n But 632 * 200000 is about 126400000, which is acceptable in C++ but in Python might be borderline in speed (but note p_max=200000, and 632*200000 is 126e6, which is acceptable in Pyton if we use a compiled language or optimize, but in pure Python we should be cautious). However, 126e6 iterations is acceptable in Pyton if we code it carefully.\n\n But note: we are only going to use triangular numbers for m from 2 to 632 (about 631 numbers). Then the inner loop is from t to 200000, so the total operations is about the sum_{t in triangular numbers} (200000 - t + 1). The largest triangular number is T(632)=632*631//2=198,636 (which is less than 200000). So we can do:\n\n   Let max_p = 200000\n   Let m_min = 2, m_max = ceil(sqrt(2*max_p)) # which is about 632\n\n   Precompute all triangular numbers: \n        tri = [m*(m-1)//2 for m in range(2, m_max+1)]\n\n   Then initialize dp[0]=0, and for i from 1 to max_p: dp[i] = infinity (or a big number)\n\n   Then for each t in tri_list (each triangular number) and for j from t to max_p:\n        dp[j] = min(dp[j], dp[j-t] + m)   # because the SCC of size m (which has m nodes) contributes t and adds m nodes.\n\n However, note: the same triangular number can be used repeatedly, and we are iterating over all t and then doing a complete update. This is the standard unbounded knapSack style.\n\n But note: we are allowed to use each SCC type (each m) as many times as we want. So we do:\n\n   for t, m_val in zip(triangular_numbers, [m for m in range(2, m_max+1)]):\n        for j in range(t, max_p+1):\n            if dp[j-t] is not inf:\n                dp[j] = min(dp[j], dp[j-t] + m_val)\n\n However, note: the triangular numbers are distinct and we are iterating in increasing order of t. But the above loop does not guarantee that we consider all combinations. Actually, we are doing a complete update for each t. Since the problem is unbounded (we can use each m_val multiple times), we must do the inner loop in increasing order (which we are, because we iterate j from t to max_p). \n\n But note: the above DP will work, but the state space is 200000 and we have about 630 triangular numbers, so the inner loop runs about 200000 - t + 1 for each t. The total operations is about 630 * (200000) which is 126000000, which is acceptable in C++ but in Python might run in a few seconds.\n\n However, we must note that p can be 0, then we output n=0.\n\n But wait: the problem says the graph must have exactly p mutually reachable pairs. If p=0, then we must have no two nodes that are mutually reachable. We can have 0 nodes, or 1 node (then no pair) or more nodes as long as we break the graph into SCCs such that no SCC has size>=2. So for p=0, the minimal n is 0? Or 1? Actually, the problem states \"minimum number of nodes\". \n\n For p=0: \n   We can have 0 nodes: then 0 pairs (there are no two distinct nodes) -> valid.\n   Or 1 node: then no pair (because the condition is for u < v, and there's only one node) -> valid, but 0 nodes is fewer.\n\n However, the problem says \"minimum number of nodes\", so 0 is the answer.\n\n But note: the example input includes 0. The example output for p=0 is \"0 0\".\n\n However, the example input format: \n      Input: ['3', '4', '0']\n      Output: ['3 0', '5 6', '0 0']\n\n But wait, the example input line is given as three separate test cases? Actually, the problem states: \"The first and only line contains a single integer p\". So we are to read one integer p and output two integers.\n\n But the example input shows three numbers: 3, 4, 0. So the example input is three separate inputs? Actually, the example input section says:\n\n      Input\n      ['3', '4', '0']\n\n This might be a mistake. The problem says: \"The first and only line contains a single integer p\". So we are reading one integer per run.\n\n However, the example output has three lines: \n      '3 0'\n      '5 6'\n      '0 0'\n\n So probably the example input is three separate runs? Or the problem intended to show three examples.\n\n Since the problem says the first and only line, we assume one integer per run.\n\n But the problem statement says: \"The first and only line contains a single integer p\".\n\n So we assume we are reading one integer.\n\n However, the example input is provided as a list of strings: ['3','4','0'].\n\n Let me clarify: the problem says \"Input: The first and only line contains a single integer p (0<=p<=200000)\".\n\n So we are to write a program that reads one integer from stdin.\n\n But the example input is given as a list of three integers. This is likely just to show three examples.\n\n Now, the second part: maximizing the number of unidirectional pairs.\n\n What is a unidirectional pair? An ordered pair (u, v) (u != v) such that there is a path from u to v but not from v to u.\n\n In our graph, we have a decomposition into SCCs and a DAG of SCCs. The entire graph is the disjoint union of these SCCs with edges only from one SCC to another (and we can arrange the DAG arbitrarily, but typically we arrange in a topological order).\n\n The total number of ordered pairs (u, v) (with u != v) is n*(n-1). Some of these are:\n   - Mutual: if u and v are in the same SCC (then they are mutually reachable) -> but note: the condition for unidirectional excludes the mutual ones (and requires that there is no path from v to u). Also, mutual pairs are not unidirectional.\n\n   - Non-mutual: if u and v are in different SCCs, then the existence of a path from u to v or from v to u depends on the DAG. In a DAG of SCCs, we can arrange the edges arbitrarily (as long as we don't form cycles). \n\n   However, note: the problem does not fix the DAG structure, so we can choose the DAG arbitrarily.\n\n   We want to maximize the total number of unidirectional pairs.\n\n How to count unidirectional pairs?\n\n   Let the graph have k SCCs, with sizes m1, m2, ..., mk.\n\n   Within an SCC, every ordered pair (u, v) (with u != v) is bidirectional (so they are not unidirectional). So the number of ordered pairs within an SCC of size m is m*(m-1) (all are bidirectional). \n\n   Between two different SCCs, say of sizes m_i and m_j (i != j), we can choose to have edges from the i-th to the j-th or not, but we cannot have both (because then we would create a cycle). \n\n   However, note: the definition of unidirectional requires a path from u to v but not from v to u. \n\n   But observe: if we have a directed edge from the i-th SCC to the j-th, then for every u in the i-th SCC and v in the j-th SCC, there is a path from u to v (via the edge between the SCCs). However, there is no path from v to u (because the DAG is acyclic and we assume the edges go only forward). \n\n   Conversely, if we don't have an edge from i to j, then we might have an edge from j to i? But wait, if we have an edge from j to i, then we have a path from v to u, so then the pair (u, v) would not be unidirectional (because we have a path from v to u) and the pair (v, u) would be unidirectional (if we have a path from v to u but not from u to v). \n\n   However, note: the problem counts ordered pairs (u, v). \n\n   So for two nodes u (in SCC i) and v (in SCC j):\n\n     If there is an edge from i to j (or a path from i to j) and not from j to i, then the pair (u, v) is unidirectional.\n\n     If there is an edge from j to i (or a path from j to i) and not from i to j, then the pair (v, u) is unidirectional.\n\n   But note: the entire graph is arranged as a DAG of SCCs, and we can choose the edges arbitrarily (as long as the DAG remains acyclic). To maximize the unidirectional pairs, we want to have as many directed edges (or paths) as possible, but without creating cycles.\n\n   However, the problem does not require that we have a complete DAG. But we can choose the edges arbitrarily. \n\n   Important: the mutual reachability condition is already satisfied by the SCC decomposition (so the DAG edges do not affect the mutual reachability). \n\n   Now, the total number of ordered pairs (u, v) (u != v) is n*(n-1). The number of bidirectional pairs is the sum_{i} [m_i*(m_i-1)]. \n\n   The rest are unidirectional or non-existent? Actually, the graph might not have all possible edges between SCCs, so we can control the edges.\n\n   The goal is to maximize the unidirectional pairs.\n\n   How?\n\n   Consider two SCCs, i and j. We can choose to have edges from i to j, or from j to i, or none. But note: if we have edges from i to j, then we cannot have edges from j to i (because that would create a cycle). \n\n   The pairs (u, v) for u in i and v in j:\n        If we have a path from i to j (we can choose to put an edge from i to j, then we have a path) and no path from j to i (because we didn't put an edge from j to i and the DAG is acyclic so no path from j to i if we only put edges from i to j), then the pair (u, v) is unidirectional.\n\n        Similarly, if we put an edge from j to i, then (v, u) is unidirectional.\n\n   But note: we can choose independently for each ordered pair of SCCs? Actually, the DAG condition forces that the entire set of SCCs is a partial order. However, we can choose the DAG arbitrarily (as long as it is acyclic). The maximum number of edges (without cycles) is the complete DAG (transitive tournament) which has k*(k-1)//2 edges. \n\n   But wait: we are counting the existence of a path, not necessarily a direct edge. However, if we set up a complete DAG (linear ordering) then for every pair of SCCs (i, j) with i < j, we have an edge from i to j (and hence a path) and no edge from j to i (so no path from j to i). Then, for any u in i and v in j (with i<j) we have a path from u to v but not from v to u. Similarly, for pairs (v, u) (v in j and u in i) we don't have a path from v to u (because j>i and we only go from lower index to higher, so no backward edges). \n\n   Therefore, in the complete DAG (linear ordering) we have:\n\n        For every ordered pair (u, v) with u and v in different SCCs, we have exactly one direction: from the SCC with the lower index to the higher index.\n\n   Then, the number of unidirectional pairs is:\n\n        Total pairs (excluding mutual) = n*(n-1) - (sum_{i} [m_i*(m_i-1)])\n\n        And then, in the complete DAG, we have exactly half of the non-mutual pairs as unidirectional? Actually, no: the non-mutual pairs are those between different SCCs, and we have a directed edge from one to the other (so for every non-mutual pair (u,v) with u and v in different SCCs, exactly one direction is present). Therefore, the entire non-mutual set is split into two sets: one direction is present, the other is absent. So the unidirectional pairs are exactly the non-mutual pairs? \n\n        Actually, note: the definition of unidirectional requires that there is a path from u to v and no path from v to u. In the complete DAG (with linear ordering), for any two distinct SCCs i and j (say i<j), then for any u in i and v in j, we have a path from u to v but not from v to u. Similarly, for any u in j and v in i (j>i), we have a path from u to v? Wait, no: because the ordering is i<j, then from j to i we don't have an edge. So actually, we have:\n\n          For u in i and v in j (with i<j): (u,v) is unidirectional.\n          For u in j and v in i (with i<j): (u,v) is not unidirectional (because there is no path from u (in j) to v (in i) since we only go from lower index to higher). \n\n        Therefore, the unidirectional pairs are only the pairs (u, v) where u is in an SCC with a lower index and v in an SCC with a higher index.\n\n        The total number of such pairs is: \n          Sum_{i < j} [m_i * m_j]\n\n        Why? Because for each pair of SCCs (i, j) with i<j, every node in i can go to every node in j.\n\n        Then, the total unidirectional pairs is the sum_{i<j} [m_i * m_j].\n\n        And note: the total non-mutual pairs is the same as the total pairs between different SCCs, which is n*(n-1) - (sum_i m_i*(m_i-1)).\n\n        And the unidirectional pairs are exactly the pairs (u, v) that go from an earlier SCC to a later one. But note: the definition of unidirectional does not require that the entire path is direct; it requires that there is a path and no path in the reverse. In our complete DAG, we have arranged that for any two nodes in different SCCs, the direction is fixed (from the lower index to the higher). \n\n        Therefore, the maximum number of unidirectional pairs is the sum_{i<j} [m_i * m_j].\n\n        But note: we are allowed to arrange the DAG arbitrarily (as long as acyclic). The complete DAG (linear ordering) maximizes the edges (and hence the unidirectional pairs) because for every pair of distinct SCCs we have one directed edge (or path) and we choose the direction that goes from one to the other. \n\n        However, is this the maximum? \n\n        Consider: if we choose a DAG that is not complete (i.e., missing some edges), then for a pair of SCCs (i, j), we might not have an edge from i to j. Then, the pairs (u, v) for u in i and v in j would not be unidirectional (because there's no path from i to j). Similarly, if we don't have an edge from j to i, then (v, u) is unidirectional. But we are free to choose the direction. \n\n        However, if we don't put an edge from i to j, then we can put an edge from j to i. Then we get the unidirectional pairs for (v, u) (v in j, u in i). \n\n        So in fact, for each unordered pair of distinct SCCs, we can choose one direction (either i->j or j->i) to be the one that has the path, and the other direction is absent. \n\n        Therefore, for each unordered pair (i, j), we get exactly m_i * m_j unidirectional pairs (either from i->j or j->i). \n\n        Hence, regardless of the order we choose, the total unidirectional pairs is always the same: the sum_{i<j} [m_i * m_j] (if we fix the SCC sizes, then the product terms are fixed, and we always count one of the two directions). \n\n        Therefore, the maximum unidirectional pairs is fixed for a given set of SCC sizes? \n\n        Actually, yes: because the DAG structure (being a complete DAG) gives the same total unidirectional pairs: the sum_{i<j} [m_i * m_j]. \n\n        But wait, what if we choose a DAG that is not complete? Then for some pairs of SCCs, we might not have any edge, then the pairs (u, v) for u in i and v in j are not unidirectional (because there's no path from u to v) and similarly no path from v to u (so they are not counted). Then the total unidirectional pairs would be less.\n\n        Therefore, to maximize the unidirectional pairs, we must have a complete DAG (i.e., for every pair of distinct SCCs, we have exactly one directed edge, meaning a linear ordering). Then the total is the sum_{i<j} [m_i * m_j].\n\n        So the second part: Given the minimal n (and the SCC sizes that we found by the DP) and the fact that we are to maximize the unidirectional pairs, we must arrange the graph as a complete DAG. Then the number of unidirectional pairs is:\n\n            unidirectional = (n*(n-1) - (sum_i [m_i*(m_i-1)])) // 2   ? \n\n        But wait: the total non-mutual pairs is n*(n-1) - (sum_i [m_i*(m_i-1)]).\n\n        And the unidirectional pairs are exactly the non-mutual pairs (because in the complete DAG, for each non-mutual pair (u, v) (which is between two different SCCs) we have one direction and that direction is unidirectional). \n\n        However, note: the non-mutual pairs are not symmetric. The complete DAG splits the non-mutual pairs into two sets: \n            Set A: pairs (u, v) that are in an order that we have chosen (from lower index to higher) -> unidirectional.\n            Set B: pairs (u, v) that are in the reverse order -> not unidirectional (because there is no path from u to v, but there is a path from v to u? Actually, no: in the complete DAG, we have edges only from lower index to higher. So for a pair (u, v) with u in i and v in j, if i<j then we have a path from u to v (so unidirectional) and if i>j then we don't have a path from u to v, but we do have a path from v to u (because j < i, so the edge goes from j to i, so from v to u) -> then (v, u) is unidirectional. \n\n        But wait: the definition of unidirectional is for the ordered pair (u, v). The pair (u, v) is unidirectional if there is a path from u to v and not from v to u.\n\n        In the complete DAG (with linear ordering by index), for a pair (u, v) with u in i and v in j:\n            If i < j: then we have a path from u to v, and we don't have a path from v to u (because j>i, so the edge goes from j to ... but wait, the DAG goes from lower index to higher, so from j (higher) we don't have an edge to i (lower)? Actually, no: the complete DAG we built is from lower index to higher index. So the edges go from i to j only when i<j. Then from j to i (if j>i) we don't have an edge. So the path from v to u (v in j, u in i) does not exist.\n\n        Therefore, for (u, v) with u in i and v in j:\n            if i < j: then (u, v) is unidirectional (path from u to v, no path from v to u).\n            if i > j: then (u, v) is not unidirectional (no path from u to v, and we have a path from v to u? Actually, wait: the graph has a path from v to u? \n                We have an edge from j to i (since j < i) and hence from v (in j) to u (in i) is present. But the definition requires that there is a path from u to v (which we don't have) and not from v to u (but we have a path from v to u). So (u, v) is not unidirectional.\n\n        But note: the pair (v, u) (with v in j and u in i) is unidirectional (if j < i) because we have a path from v to u (since j < i) and no path from u to v (because i > j, so the edge goes from i to somewhere else, but not back to j). \n\n",
    "response": "\nTo solve this problem, we need to determine the minimum number of nodes required to create a directed graph that is p-reachable, and among all such graphs with the minimum number of nodes, find the maximum number of unidirectional node pairs.\n\n### Approach\n1. **Problem Analysis**:\n   - A directed graph is p-reachable if it contains exactly p ordered pairs (u, v) where u < v and there exists a path from u to v and vice versa.\n   - The solution involves decomposing the graph into strongly connected components (SCCs) such that the sum of combinations of nodes within each SCC equals p. Each SCC of size m contributes \\( \\binom{m}{2} \\) to p.\n   - The goal is to minimize the total number of nodes (sum of sizes of all SCCs) while ensuring the sum of their combinations equals p.\n\n2. **Key Insight**:\n   - The problem reduces to representing p as the sum of triangular numbers (each corresponding to an SCC's size) with the minimal total node count. This is similar to a coin change problem where each \"coin\" is a triangular number \\( T(m) = \\frac{m(m-1)}{2} \\), and we aim to minimize the sum of the bases (m) of these coins.\n\n3. **Algorithm Selection**:\n   - **Dynamic Programming (DP)**: We use a DP approach where `dp[i]` stores the minimal number of nodes needed to achieve exactly i mutually reachable pairs. For each triangular number \\( T(m) \\), we update the DP array by considering the addition of an SCC of size m.\n   - **Unidirectional Pairs Calculation**: Once the SCC sizes are determined, the maximum number of unidirectional pairs is calculated as the sum of products of the sizes of all pairs of distinct SCCs, which is \\( \\sum_{i<j} m_i \\times m_j \\).\n\n4. **Complexity Analysis**:\n   - **Preprocessing**: We precompute triangular numbers up to the maximum possible p (200,000). The largest triangular number needed is around 632, leading to about 632 different values.\n   - **DP Update**: For each triangular number, we update the DP array from its value up to 200,000. This results in approximately 126 million operations, which is feasible given the constraints.\n\n### Solution Code\n```python\nimport sys\n\ndef main():\n    p_val = int(sys.stdin.readline().strip())\n    \n    if p_val == 0:\n        print(\"0 0\")\n        return\n        \n    max_p = 200000\n    m_max = 1 + int((2 * max_p) ** 0.5) + 1\n    \n    tri = []\n    m_list = []\n    for m in range(2, m_max):\n        t_val = m * (m - 1) // 2\n        if t_val > max_p:\n            break\n        tri.append(t_val)\n        m_list.append(m)\n        \n    dp = [10**9] * (max_p + 1)\n    dp[0] = 0\n    \n    for idx, t_val in enumerate(tri):\n        m_val = m_list[idx]\n        for j in range(t_val, max_p + 1):\n            if dp[j - t_val] != 10**9:\n                if dp[j] > dp[j - t_val] + m_val:\n                    dp[j] = dp[j - t_val] + m_val\n                    \n    n_nodes = dp[p_val]\n    \n    if n_nodes == 10**9:\n        n_nodes = 0\n        \n    total_pairs = n_nodes * (n_nodes - 1)\n    intra_scc_pairs = 0\n    for t_val in tri:\n        intra_scc_pairs += t_val\n    \n    inter_scc_pairs = total_pairs - intra_scc_pairs\n    unidirectional = inter_scc_pairs\n    \n    print(f\"{n_nodes} {unidirectional}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n1. **Reading Input**: The input is a single integer p, representing the number of mutually reachable pairs required.\n2. **Special Case Handling**: If p is 0, the solution is trivially 0 nodes and 0 unidirectional pairs.\n3. **Triangular Numbers Calculation**: We compute all triangular numbers \\( T(m) = \\frac{m(m-1)}{2} \\) up to the maximum possible p (200,000). Each triangular number corresponds to an SCC of size m.\n4. **Dynamic Programming Setup**: Initialize a DP array where `dp[i]` holds the minimal node count to achieve i mutually reachable pairs. The initial state `dp[0]` is 0 (no nodes needed for 0 pairs).\n5. **DP Array Update**: For each triangular number, update the DP array by considering adding an SCC of the corresponding size. This step ensures we find the minimal node count for each possible p.\n6. **Result Extraction**: After processing all triangular numbers, the minimal node count for p is found in `dp[p]`. The maximum number of unidirectional pairs is derived by subtracting the sum of intra-SCC pairs from the total possible ordered pairs (n_nodes * (n_nodes - 1)).\n7. **Output**: The result is printed as the minimal node count and the maximal unidirectional pairs.\n\nThis approach efficiently solves the problem by leveraging dynamic programming and combinatorial mathematics to minimize node count and maximize unidirectional pairs.",
    "ground_truth": "N/A",
    "extracted_answer": "import sys\n\ndef main():\n    p_val = int(sys.stdin.readline().strip())\n    \n    if p_val == 0:\n        print(\"0 0\")\n        return\n        \n    max_p = 200000\n    m_max = 1 + int((2 * max_p) ** 0.5) + 1\n    \n    tri = []\n    m_list = []\n    for m in range(2, m_max):\n        t_val = m * (m - 1) // 2\n        if t_val > max_p:\n            break\n        tri.append(t_val)\n        m_list.append(m)\n        \n    dp = [10**9] * (max_p + 1)\n    dp[0] = 0\n    \n    for idx, t_val in enumerate(tri):\n        m_val = m_list[idx]\n        for j in range(t_val, max_p + 1):\n            if dp[j - t_val] != 10**9:\n                if dp[j] > dp[j - t_val] + m_val:\n                    dp[j] = dp[j - t_val] + m_val\n                    \n    n_nodes = dp[p_val]\n    \n    if n_nodes == 10**9:\n        n_nodes = 0\n        \n    total_pairs = n_nodes * (n_nodes - 1)\n    intra_scc_pairs = 0\n    for t_val in tri:\n        intra_scc_pairs += t_val\n    \n    inter_scc_pairs = total_pairs - intra_scc_pairs\n    unidirectional = inter_scc_pairs\n    \n    print(f\"{n_nodes} {unidirectional}\")\n\nif __name__ == \"__main__\":\n    main()",
    "score": 0,
    "metadata": {
        "prompt_token_count": 466,
        "completion_token_count": 1176,
        "thoughts_token_count": 8191
    }
}